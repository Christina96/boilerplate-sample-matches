<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_dnsutil.py &amp; test_virt_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_dnsutil.py &amp; test_virt_1.py
      </h3>
<h1 align="center">
        0.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_dnsutil.py (9.090909%)<th>test_virt_1.py (0.14287415%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(111-115)<td><a href="#" name="0">(4648-4653)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_dnsutil.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import salt.modules.dnsutil as dnsutil
3 import salt.utils.stringutils
4 from tests.support.mock import MagicMock, mock_open, patch
5 from tests.support.unit import TestCase, skipIf
6 log = logging.getLogger(__name__)
7 mock_hosts_file = salt.utils.stringutils.to_str(
8     "##\n"
9     "# Host Database\n"
10     "#\n"
11     "# localhost is used to configure the loopback interface\n"
12     "# when the system is booting.  Do not change this entry.\n"
13     "##\n"
14     "127.0.0.1	localhost\n"
15     "255.255.255.255	broadcasthost\n"
16     "::1             localhost\n"
17     "fe80::1%lo0	localhost"
18 )
19 mock_hosts_file_rtn = {
20     "::1": ["localhost"],
21     "255.255.255.255": ["broadcasthost"],
22     "127.0.0.1": ["localhost"],
23     "fe80::1%lo0": ["localhost"],
24 }
25 mock_soa_zone = salt.utils.stringutils.to_str(
26     "$TTL 3D\n"
27     "@               IN      SOA     land-5.com. root.land-5.com. (\n"
28     "199609203       ; Serial\n"
29     "28800   ; Refresh\n"
30     "7200    ; Retry\n"
31     "604800  ; Expire\n"
32     "86400)  ; Minimum TTL\n"
33     "NS      land-5.com.\n\n"
34     "1                       PTR     localhost."
35 )
36 mock_writes_list = salt.utils.data.decode(
37     [
38         "##\n",
39         "# Host Database\n",
40         "#\n",
41         "# localhost is used to configure the loopback interface\n",
42         "# when the system is booting.  Do not change this entry.\n",
43         "##\n",
44         "127.0.0.1 localhost",
45         "\n",
46         "255.255.255.255 broadcasthost",
47         "\n",
48         "::1 localhost",
49         "\n",
50         "fe80::1%lo0 localhost",
51         "\n",
52     ],
53     to_str=True,
54 )
55 class DNSUtilTestCase(TestCase):
56     def test_parse_hosts(self):
57         with patch("salt.utils.files.fopen", mock_open(read_data=mock_hosts_file)):
58             self.assertEqual(
59                 dnsutil.parse_hosts(),
60                 {
61                     "::1": ["localhost"],
62                     "255.255.255.255": ["broadcasthost"],
63                     "127.0.0.1": ["localhost"],
64                     "fe80::1%lo0": ["localhost"],
65                 },
66             )
67     def test_hosts_append(self):
68         with patch(
69             "salt.utils.files.fopen", mock_open(read_data=mock_hosts_file)
70         ) as m_open, patch(
71             "salt.modules.dnsutil.parse_hosts",
72             MagicMock(return_value=mock_hosts_file_rtn),
73         ):
74             dnsutil.hosts_append("/etc/hosts", "127.0.0.1", "ad1.yuk.co,ad2.yuk.co")
75             writes = m_open.write_calls()
76             num_writes = len(writes)
77             assert num_writes == 1, num_writes
78             expected = salt.utils.stringutils.to_str(
79                 "\n127.0.0.1 ad1.yuk.co ad2.yuk.co"
80             )
81             assert writes[0] == expected, writes[0]
82     def test_hosts_remove(self):
83         to_remove = "ad1.yuk.co"
84         new_mock_file = mock_hosts_file + "\n127.0.0.1 " + to_remove + "\n"
85         with patch(
86             "salt.utils.files.fopen", mock_open(read_data=new_mock_file)
87         ) as m_open:
88             dnsutil.hosts_remove("/etc/hosts", to_remove)
89             writes = m_open.write_calls()
90             assert writes == mock_writes_list, writes
91 <a name="0"></a>
92     @skipIf(True, "Waiting on bug report fixes")
93     def test_parse_zone(self):
94         with patch("salt.utils.files.fopen", mock_open<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(read_data=mock_soa_zone)):
95             log.debug(mock_soa_zone)
96             log.debug(dnsutil.parse_zone("/var/lib/named/example.com.zone"))
97     def</b></font> test_to_seconds_hour(self):
98         self.assertEqual(
99             dnsutil._to_seconds("4H"),
100             14400,
101             msg="Did not detect valid hours as invalid",
102         )
103     def test_to_seconds_day(self):
104         self.assertEqual(
105             dnsutil._to_seconds("1D"), 86400, msg="Did not detect valid day as invalid"
106         )
107     def test_to_seconds_week(self):
108         self.assertEqual(
109             dnsutil._to_seconds("2W"),
110             604800,
111             msg="Did not set time greater than one week to one week",
112         )
113     def test_to_seconds_empty(self):
114         self.assertEqual(
115             dnsutil._to_seconds(""), 604800, msg="Did not set empty time to one week"
116         )
117     def test_to_seconds_large(self):
118         self.assertEqual(
119             dnsutil._to_seconds("604801"),
120             604800,
121             msg="Did not set time greater than one week to one week",
122         )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_virt_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import datetime
2 import os
3 import shutil
4 import tempfile
5 import xml.etree.ElementTree as ET
6 import salt.config
7 import salt.modules.config as config
8 import salt.modules.virt as virt
9 import salt.syspaths
10 import salt.utils.yaml
11 from salt.exceptions import CommandExecutionError, SaltInvocationError
12 from tests.support.helpers import dedent
13 from tests.support.mixins import LoaderModuleMockMixin
14 from tests.support.mock import MagicMock, patch
15 from tests.support.unit import TestCase
16 class LibvirtMock(MagicMock):  # pylint: disable=too-many-ancestors
17     class virDomain(MagicMock):
18     class libvirtError(Exception):
19         def __init__(self, msg):
20             super().__init__(msg)
21             self.msg = msg
22         def get_error_message(self):
23             return self.msg
24 class VirtTestCase(TestCase, LoaderModuleMockMixin):
25     def setup_loader_modules(self):
26         self.mock_libvirt = LibvirtMock()
27         self.mock_conn = MagicMock()
28         self.mock_conn.getStoragePoolCapabilities.return_value = (
29             "&lt;storagepoolCapabilities/&gt;"
30         )
31         self.mock_libvirt.openAuth.return_value = self.mock_conn
32         self.mock_popen = MagicMock()
33         self.addCleanup(delattr, self, "mock_libvirt")
34         self.addCleanup(delattr, self, "mock_conn")
35         self.addCleanup(delattr, self, "mock_popen")
36         self.mock_subprocess = MagicMock()
37         self.mock_subprocess.return_value = (
38             self.mock_subprocess
39         )  # pylint: disable=no-member
40         self.mock_subprocess.Popen.return_value = (
41             self.mock_popen
42         )  # pylint: disable=no-member
43         loader_globals = {
44             "__salt__": {"config.get": config.get, "config.option": config.option},
45             "libvirt": self.mock_libvirt,
46             "subprocess": self.mock_subprocess,
47         }
48         return {virt: loader_globals, config: loader_globals}
49     def set_mock_vm(self, name, xml):
50         self.mock_conn.listDefinedDomains.return_value = [
51             name
52         ]  # pylint: disable=no-member
53         mock_domain = self.mock_libvirt.virDomain()
54         self.mock_conn.lookupByName.return_value = (
55             mock_domain  # pylint: disable=no-member
56         )
57         mock_domain.XMLDesc.return_value = xml  # pylint: disable=no-member
58         mock_domain.info.return_value = [
59             4,
60             2048 * 1024,
61             1024 * 1024,
62             2,
63             1234,
64         ]  # pylint: disable=no-member
65         mock_domain.ID.return_value = 1
66         mock_domain.name.return_value = name
67         return mock_domain
68     def assert_equal_unit(self, actual, expected, unit="KiB"):
69         self.assertEqual(actual.get("unit"), unit)
70         self.assertEqual(actual.text, str(expected))
71     def test_disk_profile_merge(self):
72         root_dir = os.path.join(salt.syspaths.ROOT_DIR, "srv", "salt-images")
73         userdisks = [
74             {"name": "system", "image": "/path/to/image"},
75             {"name": "data", "size": 16384, "format": "raw"},
76         ]
77         disks = virt._disk_profile(self.mock_conn, "default", "kvm", userdisks, "myvm")
78         self.assertEqual(
79             [
80                 {
81                     "name": "system",
82                     "device": "disk",
83                     "size": 8192,
84                     "format": "qcow2",
85                     "model": "virtio",
86                     "filename": "myvm_system.qcow2",
87                     "image": "/path/to/image",
88                     "source_file": "{}{}myvm_system.qcow2".format(root_dir, os.sep),
89                 },
90                 {
91                     "name": "data",
92                     "device": "disk",
93                     "size": 16384,
94                     "format": "raw",
95                     "model": "virtio",
96                     "filename": "myvm_data.raw",
97                     "source_file": "{}{}myvm_data.raw".format(root_dir, os.sep),
98                 },
99             ],
100             disks,
101         )
102     def test_boot_default_dev(self):
103         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
104         nicp = virt._nic_profile("default", "kvm")
105         xml_data = virt._gen_xml(
106             self.mock_conn, "hello", 1, 512, diskp, nicp, "kvm", "hvm", "x86_64"
107         )
108         root = ET.fromstring(xml_data)
109         self.assertEqual(root.find("os/boot").attrib["dev"], "hd")
110         self.assertEqual(root.find("os/type").attrib["arch"], "x86_64")
111         self.assertEqual(root.find("os/type").text, "hvm")
112     def test_boot_custom_dev(self):
113         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
114         nicp = virt._nic_profile("default", "kvm")
115         xml_data = virt._gen_xml(
116             self.mock_conn,
117             "hello",
118             1,
119             512,
120             diskp,
121             nicp,
122             "kvm",
123             "hvm",
124             "x86_64",
125             boot_dev="cdrom",
126         )
127         root = ET.fromstring(xml_data)
128         self.assertEqual(root.find("os/boot").attrib["dev"], "cdrom")
129     def test_boot_multiple_devs(self):
130         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
131         nicp = virt._nic_profile("default", "kvm")
132         xml_data = virt._gen_xml(
133             self.mock_conn,
134             "hello",
135             1,
136             512,
137             diskp,
138             nicp,
139             "kvm",
140             "hvm",
141             "x86_64",
142             boot_dev="cdrom network",
143         )
144         root = ET.fromstring(xml_data)
145         devs = root.findall(".//boot")
146         self.assertTrue(len(devs) == 2)
147     def test_gen_xml_no_nic(self):
148         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
149         nicp = virt._nic_profile("default", "kvm")
150         xml_data = virt._gen_xml(
151             self.mock_conn,
152             "hello",
153             1,
154             512,
155             diskp,
156             nicp,
157             "kvm",
158             "hvm",
159             "x86_64",
160             serials=[{"type": "pty"}],
161         )
162         root = ET.fromstring(xml_data)
163         self.assertEqual(root.find("devices/serial").attrib["type"], "pty")
164     def test_gen_xml_for_telnet_serial(self):
165         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
166         nicp = virt._nic_profile("default", "kvm")
167         xml_data = virt._gen_xml(
168             self.mock_conn,
169             "hello",
170             1,
171             512,
172             diskp,
173             nicp,
174             "kvm",
175             "hvm",
176             "x86_64",
177             serials=[{"type": "tcp", "port": 22223, "protocol": "telnet"}],
178         )
179         root = ET.fromstring(xml_data)
180         self.assertEqual(root.find("devices/serial").attrib["type"], "tcp")
181         self.assertEqual(root.find("devices/serial/source").attrib["service"], "22223")
182         self.assertEqual(root.find("devices/serial/protocol").attrib["type"], "telnet")
183     def test_gen_xml_for_telnet_serial_unspecified_port(self):
184         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
185         nicp = virt._nic_profile("default", "kvm")
186         xml_data = virt._gen_xml(
187             self.mock_conn,
188             "hello",
189             1,
190             512,
191             diskp,
192             nicp,
193             "kvm",
194             "hvm",
195             "x86_64",
196             serials=[{"type": "tcp"}],
197         )
198         root = ET.fromstring(xml_data)
199         self.assertEqual(root.find("devices/serial").attrib["type"], "tcp")
200         self.assertEqual(root.find("devices/serial/source").attrib["service"], "23023")
201         self.assertFalse("tls" in root.find("devices/serial/source").keys())
202         self.assertEqual(root.find("devices/serial/protocol").attrib["type"], "telnet")
203     def test_gen_xml_for_chardev_types(self):
204         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
205         nicp = virt._nic_profile("default", "kvm")
206         xml_data = virt._gen_xml(
207             self.mock_conn,
208             "hello",
209             1,
210             512,
211             diskp,
212             nicp,
213             "kvm",
214             "hvm",
215             "x86_64",
216             consoles=[
217                 {"type": "pty", "path": "/dev/pts/2", "target_port": 2},
218                 {"type": "pty", "target_type": "usb-serial"},
219                 {"type": "stdio"},
220                 {"type": "file", "path": "/path/to/serial.log"},
221             ],
222             serials=[
223                 {"type": "pipe", "path": "/tmp/mypipe"},
224                 {"type": "udp", "host": "127.0.0.1", "port": 1234},
225                 {"type": "tcp", "port": 22223, "protocol": "raw", "tls": True},
226                 {"type": "unix", "path": "/path/to/socket"},
227             ],
228         )
229         root = ET.fromstring(xml_data)
230         self.assertEqual(root.find("devices/console[1]").attrib["type"], "pty")
231         self.assertEqual(
232             root.find("devices/console[1]/source").attrib["path"], "/dev/pts/2"
233         )
234         self.assertEqual(root.find("devices/console[1]/target").attrib["port"], "2")
235         self.assertEqual(root.find("devices/console[2]").attrib["type"], "pty")
236         self.assertIsNone(root.find("devices/console[2]/source"))
237         self.assertEqual(
238             root.find("devices/console[2]/target").attrib["type"], "usb-serial"
239         )
240         self.assertEqual(root.find("devices/console[3]").attrib["type"], "stdio")
241         self.assertIsNone(root.find("devices/console[3]/source"))
242         self.assertEqual(root.find("devices/console[4]").attrib["type"], "file")
243         self.assertEqual(
244             root.find("devices/console[4]/source").attrib["path"], "/path/to/serial.log"
245         )
246         self.assertEqual(root.find("devices/serial[1]").attrib["type"], "pipe")
247         self.assertEqual(
248             root.find("devices/serial[1]/source").attrib["path"], "/tmp/mypipe"
249         )
250         self.assertEqual(root.find("devices/serial[2]").attrib["type"], "udp")
251         self.assertEqual(root.find("devices/serial[2]/source").attrib["mode"], "bind")
252         self.assertEqual(
253             root.find("devices/serial[2]/source").attrib["service"], "1234"
254         )
255         self.assertEqual(
256             root.find("devices/serial[2]/source").attrib["host"], "127.0.0.1"
257         )
258         self.assertEqual(root.find("devices/serial[3]").attrib["type"], "tcp")
259         self.assertEqual(root.find("devices/serial[3]/source").attrib["mode"], "bind")
260         self.assertEqual(
261             root.find("devices/serial[3]/source").attrib["service"], "22223"
262         )
263         self.assertEqual(root.find("devices/serial[3]/source").attrib["tls"], "yes")
264         self.assertEqual(root.find("devices/serial[3]/protocol").attrib["type"], "raw")
265         self.assertEqual(root.find("devices/serial[4]").attrib["type"], "unix")
266         self.assertEqual(
267             root.find("devices/serial[4]/source").attrib["path"], "/path/to/socket"
268         )
269     def test_gen_xml_no_nic_console(self):
270         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
271         nicp = virt._nic_profile("default", "kvm")
272         xml_data = virt._gen_xml(
273             self.mock_conn,
274             "hello",
275             1,
276             512,
277             diskp,
278             nicp,
279             "kvm",
280             "hvm",
281             "x86_64",
282             consoles=[{"type": "pty"}],
283         )
284         root = ET.fromstring(xml_data)
285         self.assertEqual(root.find("devices/console").attrib["type"], "pty")
286     def test_gen_xml_for_telnet_console(self):
287         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
288         nicp = virt._nic_profile("default", "kvm")
289         xml_data = virt._gen_xml(
290             self.mock_conn,
291             "hello",
292             1,
293             512,
294             diskp,
295             nicp,
296             "kvm",
297             "hvm",
298             "x86_64",
299             consoles=[{"type": "tcp", "port": 22223, "protocol": "telnet"}],
300         )
301         root = ET.fromstring(xml_data)
302         self.assertEqual(root.find("devices/console").attrib["type"], "tcp")
303         self.assertEqual(root.find("devices/console/source").attrib["service"], "22223")
304         self.assertEqual(root.find("devices/console/protocol").attrib["type"], "telnet")
305     def test_gen_xml_for_telnet_console_unspecified_port(self):
306         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
307         nicp = virt._nic_profile("default", "kvm")
308         xml_data = virt._gen_xml(
309             self.mock_conn,
310             "hello",
311             1,
312             512,
313             diskp,
314             nicp,
315             "kvm",
316             "hvm",
317             "x86_64",
318             consoles=[{"type": "tcp"}],
319         )
320         root = ET.fromstring(xml_data)
321         self.assertEqual(root.find("devices/console").attrib["type"], "tcp")
322         self.assertEqual(root.find("devices/console/source").attrib["service"], "23023")
323         self.assertEqual(root.find("devices/console/protocol").attrib["type"], "telnet")
324     def test_gen_xml_for_serial_no_console(self):
325         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
326         nicp = virt._nic_profile("default", "kvm")
327         xml_data = virt._gen_xml(
328             self.mock_conn,
329             "hello",
330             1,
331             512,
332             diskp,
333             nicp,
334             "kvm",
335             "hvm",
336             "x86_64",
337             serials=[{"type": "pty"}],
338             consoles=[],
339         )
340         root = ET.fromstring(xml_data)
341         self.assertEqual(root.find("devices/serial").attrib["type"], "pty")
342         self.assertEqual(root.find("devices/console"), None)
343     def test_gen_xml_for_telnet_no_console(self):
344         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
345         nicp = virt._nic_profile("default", "kvm")
346         xml_data = virt._gen_xml(
347             self.mock_conn,
348             "hello",
349             1,
350             512,
351             diskp,
352             nicp,
353             "kvm",
354             "hvm",
355             "x86_64",
356             serials=[{"type": "tcp", "port": 22223, "protocol": "telnet"}],
357             consoles=[],
358         )
359         root = ET.fromstring(xml_data)
360         self.assertEqual(root.find("devices/serial").attrib["type"], "tcp")
361         self.assertEqual(root.find("devices/console"), None)
362     def test_gen_xml_nographics_default(self):
363         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
364         nicp = virt._nic_profile("default", "kvm")
365         xml_data = virt._gen_xml(
366             self.mock_conn, "hello", 1, 512, diskp, nicp, "kvm", "hvm", "x86_64"
367         )
368         root = ET.fromstring(xml_data)
369         self.assertIsNone(root.find("devices/graphics"))
370     def test_gen_xml_noloader_default(self):
371         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
372         nicp = virt._nic_profile("default", "kvm")
373         xml_data = virt._gen_xml(
374             self.mock_conn, "hello", 1, 512, diskp, nicp, "kvm", "hvm", "x86_64"
375         )
376         root = ET.fromstring(xml_data)
377         self.assertIsNone(root.find("os/loader"))
378     def test_gen_xml_vnc_default(self):
379         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
380         nicp = virt._nic_profile("default", "kvm")
381         xml_data = virt._gen_xml(
382             self.mock_conn,
383             "hello",
384             1,
385             512,
386             diskp,
387             nicp,
388             "kvm",
389             "hvm",
390             "x86_64",
391             graphics={
392                 "type": "vnc",
393                 "port": 1234,
394                 "tlsPort": 5678,
395                 "listen": {"type": "address", "address": "myhost"},
396             },
397         )
398         root = ET.fromstring(xml_data)
399         self.assertEqual(root.find("devices/graphics").attrib["type"], "vnc")
400         self.assertEqual(root.find("devices/graphics").attrib["autoport"], "no")
401         self.assertEqual(root.find("devices/graphics").attrib["port"], "1234")
402         self.assertFalse("tlsPort" in root.find("devices/graphics").attrib)
403         self.assertEqual(root.find("devices/graphics").attrib["listen"], "myhost")
404         self.assertEqual(root.find("devices/graphics/listen").attrib["type"], "address")
405         self.assertEqual(
406             root.find("devices/graphics/listen").attrib["address"], "myhost"
407         )
408     def test_gen_xml_memory(self):
409         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
410         nicp = virt._nic_profile("default", "kvm")
411         xml_data = virt._gen_xml(
412             self.mock_conn,
413             "hello",
414             1,
415             {
416                 "boot": "512m",
417                 "current": "256m",
418                 "max": "1g",
419                 "hard_limit": "1024",
420                 "soft_limit": "512m",
421                 "swap_hard_limit": "1g",
422                 "min_guarantee": "256m",
423                 "hugepages": [
424                     {"size": "128m"},
425                     {"nodeset": "0", "size": "256m"},
426                     {"nodeset": "1", "size": "512m"},
427                 ],
428                 "nosharepages": True,
429                 "locked": True,
430                 "source": "file",
431                 "access": "shared",
432                 "allocation": "immediate",
433                 "discard": True,
434             },
435             diskp,
436             nicp,
437             "kvm",
438             "hvm",
439             "x86_64",
440         )
441         root = ET.fromstring(xml_data)
442         self.assert_equal_unit(root.find("memory"), 512 * 1024)
443         self.assert_equal_unit(root.find("currentMemory"), 256 * 1024)
444         self.assert_equal_unit(root.find("maxMemory"), 1024 * 1024)
445         self.assertFalse("slots" in root.find("maxMemory").keys())
446         self.assert_equal_unit(root.find("memtune/hard_limit"), 1024 * 1024)
447         self.assert_equal_unit(root.find("memtune/soft_limit"), 512 * 1024)
448         self.assert_equal_unit(root.find("memtune/swap_hard_limit"), 1024 ** 2)
449         self.assert_equal_unit(root.find("memtune/min_guarantee"), 256 * 1024)
450         self.assertEqual(
451             [
452                 {"nodeset": page.get("nodeset"), "size": page.get("size")}
453                 for page in root.findall("memoryBacking/hugepages/page")
454             ],
455             [
456                 {"nodeset": None, "size": str(128 * 1024)},
457                 {"nodeset": "0", "size": str(256 * 1024)},
458                 {"nodeset": "1", "size": str(512 * 1024)},
459             ],
460         )
461         self.assertIsNotNone(root.find("memoryBacking/nosharepages"))
462         self.assertIsNotNone(root.find("memoryBacking/locked"))
463         self.assertIsNotNone(root.find("memoryBacking/discard"))
464         self.assertEqual(root.find("memoryBacking/source").get("type"), "file")
465         self.assertEqual(root.find("memoryBacking/access").get("mode"), "shared")
466         self.assertEqual(root.find("memoryBacking/allocation").get("mode"), "immediate")
467     def test_gen_xml_cpu(self):
468         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
469         nicp = virt._nic_profile("default", "kvm")
470         xml_data = virt._gen_xml(
471             self.mock_conn,
472             "hello",
473             {
474                 "maximum": 12,
475                 "placement": "static",
476                 "cpuset": "0-11",
477                 "current": 5,
478                 "mode": "custom",
479                 "match": "minimum",
480                 "check": "full",
481                 "vendor": "Intel",
482                 "model": {
483                     "name": "core2duo",
484                     "fallback": "allow",
485                     "vendor_id": "GenuineIntel",
486                 },
487                 "cache": {"level": 3, "mode": "emulate"},
488                 "features": {"lahf": "optional", "vmx": "require"},
489                 "vcpus": {
490                     0: {"enabled": True, "hotpluggable": True},
491                     1: {"enabled": False},
492                 },
493             },
494             512,
495             diskp,
496             nicp,
497             "kvm",
498             "hvm",
499             "x86_64",
500         )
501         root = ET.fromstring(xml_data)
502         self.assertEqual(root.find("vcpu").get("current"), "5")
503         self.assertEqual(root.find("vcpu").get("placement"), "static")
504         self.assertEqual(root.find("vcpu").get("cpuset"), "0-11")
505         self.assertEqual(root.find("vcpu").text, "12")
506         self.assertEqual(root.find("cpu").get("match"), "minimum")
507         self.assertEqual(root.find("cpu").get("mode"), "custom")
508         self.assertEqual(root.find("cpu").get("check"), "full")
509         self.assertEqual(root.find("cpu/vendor").text, "Intel")
510         self.assertEqual(root.find("cpu/model").text, "core2duo")
511         self.assertEqual(root.find("cpu/model").get("fallback"), "allow")
512         self.assertEqual(root.find("cpu/model").get("vendor_id"), "GenuineIntel")
513         self.assertEqual(root.find("cpu/cache").get("level"), "3")
514         self.assertEqual(root.find("cpu/cache").get("mode"), "emulate")
515         self.assertEqual(
516             {f.get("name"): f.get("policy") for f in root.findall("cpu/feature")},
517             {"lahf": "optional", "vmx": "require"},
518         )
519         self.assertEqual(
520             {
521                 v.get("id"): {
522                     "enabled": v.get("enabled"),
523                     "hotpluggable": v.get("hotpluggable"),
524                 }
525                 for v in root.findall("vcpus/vcpu")
526             },
527             {
528                 "0": {"enabled": "yes", "hotpluggable": "yes"},
529                 "1": {"enabled": "no", "hotpluggable": None},
530             },
531         )
532     def test_gen_xml_cpu_topology(self):
533         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
534         nicp = virt._nic_profile("default", "kvm")
535         xml_data = virt._gen_xml(
536             self.mock_conn,
537             "hello",
538             {"maximum": 1, "topology": {"sockets": 4, "cores": 16, "threads": 2}},
539             512,
540             diskp,
541             nicp,
542             "kvm",
543             "hvm",
544             "x86_64",
545         )
546         root = ET.fromstring(xml_data)
547         self.assertEqual(root.find("cpu/topology").get("sockets"), "4")
548         self.assertEqual(root.find("cpu/topology").get("cores"), "16")
549         self.assertEqual(root.find("cpu/topology").get("threads"), "2")
550     def test_gen_xml_cpu_numa(self):
551         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
552         nicp = virt._nic_profile("default", "kvm")
553         xml_data = virt._gen_xml(
554             self.mock_conn,
555             "hello",
556             {
557                 "maximum": 1,
558                 "numa": {
559                     0: {
560                         "cpus": "0-3",
561                         "memory": "1g",
562                         "discard": True,
563                         "distances": {0: 10, 1: 20},
564                     },
565                     1: {"cpus": "4-7", "memory": "2g", "distances": {0: 20, 1: 10}},
566                 },
567             },
568             512,
569             diskp,
570             nicp,
571             "kvm",
572             "hvm",
573             "x86_64",
574         )
575         root = ET.fromstring(xml_data)
576         cell0 = root.find("cpu/numa/cell[@id='0']")
577         self.assertEqual(cell0.get("cpus"), "0-3")
578         self.assertIsNone(cell0.get("unit"))
579         self.assertEqual(cell0.get("memory"), str(1024 ** 2))
580         self.assertEqual(cell0.get("discard"), "yes")
581         self.assertEqual(
582             {d.get("id"): d.get("value") for d in cell0.findall("distances/sibling")},
583             {"0": "10", "1": "20"},
584         )
585         cell1 = root.find("cpu/numa/cell[@id='1']")
586         self.assertEqual(cell1.get("cpus"), "4-7")
587         self.assertIsNone(cell0.get("unit"))
588         self.assertEqual(cell1.get("memory"), str(2 * 1024 ** 2))
589         self.assertFalse("discard" in cell1.keys())
590         self.assertEqual(
591             {d.get("id"): d.get("value") for d in cell1.findall("distances/sibling")},
592             {"0": "20", "1": "10"},
593         )
594     def test_gen_xml_cputune(self):
595         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
596         nicp = virt._nic_profile("default", "kvm")
597         cputune = {
598             "shares": 2048,
599             "period": 122000,
600             "quota": -1,
601             "global_period": 1000000,
602             "global_quota": -3,
603             "emulator_period": 1200000,
604             "emulator_quota": -10,
605             "iothread_period": 133000,
606             "iothread_quota": -1,
607             "vcpupin": {0: "1-4,^2", 1: "0,1", 2: "2,3", 3: "0,4"},
608             "emulatorpin": "1-3",
609             "iothreadpin": {1: "5-6", 2: "7-8"},
610             "vcpusched": [
611                 {"scheduler": "fifo", "priority": 1, "vcpus": "0"},
612                 {"scheduler": "fifo", "priority": 2, "vcpus": "1"},
613                 {"scheduler": "idle", "priority": 3, "vcpus": "2"},
614             ],
615             "iothreadsched": [
616                 {"scheduler": "idle"},
617                 {"scheduler": "batch", "iothreads": "5-7", "priority": 1},
618             ],
619             "emulatorsched": {"scheduler": "rr", "priority": 2},
620             "cachetune": {
621                 "0-3": {
622                     0: {"level": 3, "type": "both", "size": 3},
623                     1: {"level": 3, "type": "both", "size": 3},
624                     "monitor": {1: 3, "0-3": 3},
625                 },
626                 "4-5": {"monitor": {4: 3, 5: 2}},
627             },
628             "memorytune": {"0-2": {0: 60}, "3-4": {0: 50, 1: 70}},
629         }
630         xml_data = virt._gen_xml(
631             self.mock_conn,
632             "hello",
633             {"maximum": 1, "tuning": cputune, "iothreads": 2},
634             512,
635             diskp,
636             nicp,
637             "kvm",
638             "hvm",
639             "x86_64",
640         )
641         root = ET.fromstring(xml_data)
642         self.assertEqual(root.find("cputune").find("shares").text, "2048")
643         self.assertEqual(root.find("cputune").find("period").text, "122000")
644         self.assertEqual(root.find("cputune").find("quota").text, "-1")
645         self.assertEqual(root.find("cputune").find("global_period").text, "1000000")
646         self.assertEqual(root.find("cputune").find("global_quota").text, "-3")
647         self.assertEqual(root.find("cputune").find("emulator_period").text, "1200000")
648         self.assertEqual(root.find("cputune").find("emulator_quota").text, "-10")
649         self.assertEqual(root.find("cputune").find("iothread_period").text, "133000")
650         self.assertEqual(root.find("cputune").find("iothread_quota").text, "-1")
651         self.assertEqual(
652             root.find("cputune").find("vcpupin[@vcpu='0']").attrib.get("cpuset"),
653             "1-4,^2",
654         )
655         self.assertEqual(
656             root.find("cputune").find("vcpupin[@vcpu='1']").attrib.get("cpuset"),
657             "0,1",
658         )
659         self.assertEqual(
660             root.find("cputune").find("vcpupin[@vcpu='2']").attrib.get("cpuset"),
661             "2,3",
662         )
663         self.assertEqual(
664             root.find("cputune").find("vcpupin[@vcpu='3']").attrib.get("cpuset"),
665             "0,4",
666         )
667         self.assertEqual(
668             root.find("cputune").find("emulatorpin").attrib.get("cpuset"), "1-3"
669         )
670         self.assertEqual(
671             root.find("cputune")
672             .find("iothreadpin[@iothread='1']")
673             .attrib.get("cpuset"),
674             "5-6",
675         )
676         self.assertEqual(
677             root.find("cputune")
678             .find("iothreadpin[@iothread='2']")
679             .attrib.get("cpuset"),
680             "7-8",
681         )
682         self.assertDictEqual(
683             {
684                 s.get("vcpus"): {
685                     "scheduler": s.get("scheduler"),
686                     "priority": s.get("priority"),
687                 }
688                 for s in root.findall("cputune/vcpusched")
689             },
690             {
691                 "0": {"scheduler": "fifo", "priority": "1"},
692                 "1": {"scheduler": "fifo", "priority": "2"},
693                 "2": {"scheduler": "idle", "priority": "3"},
694             },
695         )
696         self.assertDictEqual(
697             {
698                 s.get("iothreads"): {
699                     "scheduler": s.get("scheduler"),
700                     "priority": s.get("priority"),
701                 }
702                 for s in root.findall("cputune/iothreadsched")
703             },
704             {
705                 None: {"scheduler": "idle", "priority": None},
706                 "5-7": {"scheduler": "batch", "priority": "1"},
707             },
708         )
709         self.assertEqual(root.find("cputune/emulatorsched").get("scheduler"), "rr")
710         self.assertEqual(root.find("cputune/emulatorsched").get("priority"), "2")
711         self.assertEqual(
712             root.find("./cputune/cachetune[@vcpus='0-3']").attrib.get("vcpus"), "0-3"
713         )
714         self.assertEqual(
715             root.find("./cputune/cachetune[@vcpus='0-3']/cache[@id='0']").attrib.get(
716                 "level"
717             ),
718             "3",
719         )
720         self.assertEqual(
721             root.find("./cputune/cachetune[@vcpus='0-3']/cache[@id='0']").attrib.get(
722                 "type"
723             ),
724             "both",
725         )
726         self.assertEqual(
727             root.find(
728                 "./cputune/cachetune[@vcpus='0-3']/monitor[@vcpus='1']"
729             ).attrib.get("level"),
730             "3",
731         )
732         self.assertNotEqual(
733             root.find("./cputune/cachetune[@vcpus='0-3']/monitor[@vcpus='1']"), None
734         )
735         self.assertNotEqual(
736             root.find("./cputune/cachetune[@vcpus='4-5']").attrib.get("vcpus"), None
737         )
738         self.assertEqual(
739             root.find("./cputune/cachetune[@vcpus='4-5']/cache[@id='0']"), None
740         )
741         self.assertEqual(
742             root.find(
743                 "./cputune/cachetune[@vcpus='4-5']/monitor[@vcpus='4']"
744             ).attrib.get("level"),
745             "3",
746         )
747         self.assertEqual(
748             root.find(
749                 "./cputune/cachetune[@vcpus='4-5']/monitor[@vcpus='5']"
750             ).attrib.get("level"),
751             "2",
752         )
753         self.assertNotEqual(root.find("./cputune/memorytune[@vcpus='0-2']"), None)
754         self.assertEqual(
755             root.find("./cputune/memorytune[@vcpus='0-2']/node[@id='0']").attrib.get(
756                 "bandwidth"
757             ),
758             "60",
759         )
760         self.assertNotEqual(root.find("./cputune/memorytune[@vcpus='3-4']"), None)
761         self.assertEqual(
762             root.find("./cputune/memorytune[@vcpus='3-4']/node[@id='0']").attrib.get(
763                 "bandwidth"
764             ),
765             "50",
766         )
767         self.assertEqual(
768             root.find("./cputune/memorytune[@vcpus='3-4']/node[@id='1']").attrib.get(
769                 "bandwidth"
770             ),
771             "70",
772         )
773         self.assertEqual(root.find("iothreads").text, "2")
774     def test_default_disk_profile_hypervisor_esxi(self):
775         mock = MagicMock(return_value={})
776         with patch.dict(
777             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
778         ):
779             ret = virt._disk_profile(
780                 self.mock_conn, "nonexistent", "vmware", None, "test-vm"
781             )
782             self.assertTrue(len(ret) == 1)
783             found = [disk for disk in ret if disk["name"] == "system"]
784             self.assertTrue(bool(found))
785             system = found[0]
786             self.assertEqual(system["format"], "vmdk")
787             self.assertEqual(system["model"], "scsi")
788             self.assertTrue(int(system["size"]) &gt;= 1)
789     def test_default_disk_profile_hypervisor_kvm(self):
790         mock = MagicMock(side_effect=[{}, "/images/dir"])
791         with patch.dict(
792             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
793         ):
794             ret = virt._disk_profile(
795                 self.mock_conn, "nonexistent", "kvm", None, "test-vm"
796             )
797             self.assertTrue(len(ret) == 1)
798             found = [disk for disk in ret if disk["name"] == "system"]
799             self.assertTrue(bool(found))
800             system = found[0]
801             self.assertEqual(system["format"], "qcow2")
802             self.assertEqual(system["model"], "virtio")
803             self.assertTrue(int(system["size"]) &gt;= 1)
804     def test_default_disk_profile_hypervisor_xen(self):
805         mock = MagicMock(side_effect=[{}, "/images/dir"])
806         with patch.dict(
807             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
808         ):
809             ret = virt._disk_profile(
810                 self.mock_conn, "nonexistent", "xen", None, "test-vm"
811             )
812             self.assertTrue(len(ret) == 1)
813             found = [disk for disk in ret if disk["name"] == "system"]
814             self.assertTrue(bool(found))
815             system = found[0]
816             self.assertEqual(system["format"], "qcow2")
817             self.assertEqual(system["model"], "xen")
818             self.assertTrue(int(system["size"]) &gt;= 1)
819     def test_default_nic_profile_hypervisor_esxi(self):
820         mock = MagicMock(return_value={})
821         with patch.dict(
822             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
823         ):
824             ret = virt._nic_profile("nonexistent", "vmware")
825             self.assertTrue(len(ret) == 1)
826             eth0 = ret[0]
827             self.assertEqual(eth0["name"], "eth0")
828             self.assertEqual(eth0["type"], "bridge")
829             self.assertEqual(eth0["source"], "DEFAULT")
830             self.assertEqual(eth0["model"], "e1000")
831     def test_default_nic_profile_hypervisor_kvm(self):
832         mock = MagicMock(return_value={})
833         with patch.dict(
834             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
835         ):
836             ret = virt._nic_profile("nonexistent", "kvm")
837             self.assertTrue(len(ret) == 1)
838             eth0 = ret[0]
839             self.assertEqual(eth0["name"], "eth0")
840             self.assertEqual(eth0["type"], "bridge")
841             self.assertEqual(eth0["source"], "br0")
842             self.assertEqual(eth0["model"], "virtio")
843     def test_default_nic_profile_hypervisor_xen(self):
844         mock = MagicMock(return_value={})
845         with patch.dict(
846             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
847         ):
848             ret = virt._nic_profile("nonexistent", "xen")
849             self.assertTrue(len(ret) == 1)
850             eth0 = ret[0]
851             self.assertEqual(eth0["name"], "eth0")
852             self.assertEqual(eth0["type"], "bridge")
853             self.assertEqual(eth0["source"], "br0")
854             self.assertFalse(eth0["model"])
855     def test_gen_vol_xml_esx(self):
856         xml_data = virt._gen_vol_xml("vmname/system.vmdk", 8192, format="vmdk")
857         root = ET.fromstring(xml_data)
858         self.assertIsNone(root.get("type"))
859         self.assertEqual(root.find("name").text, "vmname/system.vmdk")
860         self.assertEqual(root.find("capacity").attrib["unit"], "KiB")
861         self.assertEqual(root.find("capacity").text, str(8192 * 1024))
862         self.assertEqual(root.find("allocation").text, str(0))
863         self.assertEqual(root.find("target/format").get("type"), "vmdk")
864         self.assertIsNone(root.find("target/permissions"))
865         self.assertIsNone(root.find("target/nocow"))
866         self.assertIsNone(root.find("backingStore"))
867     def test_gen_vol_xml_file(self):
868         xml_data = virt._gen_vol_xml(
869             "myvm_system.qcow2",
870             8192,
871             format="qcow2",
872             allocation=4096,
873             type="file",
874             permissions={
875                 "mode": "0775",
876                 "owner": "123",
877                 "group": "456",
878                 "label": "sec_label",
879             },
880             backing_store={"path": "/backing/image", "format": "raw"},
881             nocow=True,
882         )
883         root = ET.fromstring(xml_data)
884         self.assertEqual(root.get("type"), "file")
885         self.assertEqual(root.find("name").text, "myvm_system.qcow2")
886         self.assertIsNone(root.find("key"))
887         self.assertIsNone(root.find("target/path"))
888         self.assertEqual(root.find("target/format").get("type"), "qcow2")
889         self.assertEqual(root.find("capacity").attrib["unit"], "KiB")
890         self.assertEqual(root.find("capacity").text, str(8192 * 1024))
891         self.assertEqual(root.find("capacity").attrib["unit"], "KiB")
892         self.assertEqual(root.find("allocation").text, str(4096 * 1024))
893         self.assertEqual(root.find("target/permissions/mode").text, "0775")
894         self.assertEqual(root.find("target/permissions/owner").text, "123")
895         self.assertEqual(root.find("target/permissions/group").text, "456")
896         self.assertEqual(root.find("target/permissions/label").text, "sec_label")
897         self.assertIsNotNone(root.find("target/nocow"))
898         self.assertEqual(root.find("backingStore/path").text, "/backing/image")
899         self.assertEqual(root.find("backingStore/format").get("type"), "raw")
900     def test_gen_xml_for_kvm_default_profile(self):
901         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
902         nicp = virt._nic_profile("default", "kvm")
903         xml_data = virt._gen_xml(
904             self.mock_conn,
905             "hello",
906             1,
907             512,
908             diskp,
909             nicp,
910             "kvm",
911             "hvm",
912             "x86_64",
913         )
914         root = ET.fromstring(xml_data)
915         self.assertEqual(root.attrib["type"], "kvm")
916         self.assertEqual(root.find("vcpu").text, "1")
917         self.assertEqual(root.find("memory").text, str(512 * 1024))
918         self.assertEqual(root.find("memory").attrib["unit"], "KiB")
919         disks = root.findall(".//disk")
920         self.assertEqual(len(disks), 1)
921         disk = disks[0]
922         root_dir = salt.config.DEFAULT_MINION_OPTS.get("root_dir")
923         self.assertTrue(disk.find("source").attrib["file"].startswith(root_dir))
924         self.assertTrue("hello_system" in disk.find("source").attrib["file"])
925         self.assertEqual(disk.find("target").attrib["dev"], "vda")
926         self.assertEqual(disk.find("target").attrib["bus"], "virtio")
927         self.assertEqual(disk.find("driver").attrib["name"], "qemu")
928         self.assertEqual(disk.find("driver").attrib["type"], "qcow2")
929         interfaces = root.findall(".//interface")
930         self.assertEqual(len(interfaces), 1)
931         iface = interfaces[0]
932         self.assertEqual(iface.attrib["type"], "bridge")
933         self.assertEqual(iface.find("source").attrib["bridge"], "br0")
934         self.assertEqual(iface.find("model").attrib["type"], "virtio")
935     def test_gen_xml_for_esxi_default_profile(self):
936         diskp = virt._disk_profile(self.mock_conn, "default", "vmware", [], "hello")
937         nicp = virt._nic_profile("default", "vmware")
938         xml_data = virt._gen_xml(
939             self.mock_conn,
940             "hello",
941             1,
942             512,
943             diskp,
944             nicp,
945             "vmware",
946             "hvm",
947             "x86_64",
948         )
949         root = ET.fromstring(xml_data)
950         self.assertEqual(root.attrib["type"], "vmware")
951         self.assertEqual(root.find("vcpu").text, "1")
952         self.assertEqual(root.find("memory").text, str(512 * 1024))
953         self.assertEqual(root.find("memory").attrib["unit"], "KiB")
954         disks = root.findall(".//disk")
955         self.assertEqual(len(disks), 1)
956         disk = disks[0]
957         self.assertTrue("[0]" in disk.find("source").attrib["file"])
958         self.assertTrue("hello_system" in disk.find("source").attrib["file"])
959         self.assertEqual(disk.find("target").attrib["dev"], "sda")
960         self.assertEqual(disk.find("target").attrib["bus"], "scsi")
961         self.assertEqual(disk.find("address").attrib["unit"], "0")
962         interfaces = root.findall(".//interface")
963         self.assertEqual(len(interfaces), 1)
964         iface = interfaces[0]
965         self.assertEqual(iface.attrib["type"], "bridge")
966         self.assertEqual(iface.find("source").attrib["bridge"], "DEFAULT")
967         self.assertEqual(iface.find("model").attrib["type"], "e1000")
968     def test_gen_xml_for_esxi_custom_profile(self):
969         disks = {
970             "noeffect": [
971                 {"first": {"size": 8192, "pool": "datastore1"}},
972                 {"second": {"size": 4096, "pool": "datastore2"}},
973             ]
974         }
975         nics = {
976             "noeffect": [
977                 {"name": "eth1", "source": "ONENET"},
978                 {"name": "eth2", "source": "TWONET"},
979             ]
980         }
981         with patch.dict(
982             virt.__salt__,  # pylint: disable=no-member
983             {"config.get": MagicMock(side_effect=[disks, nics])},
984         ):
985             diskp = virt._disk_profile(
986                 self.mock_conn, "noeffect", "vmware", [], "hello"
987             )
988             nicp = virt._nic_profile("noeffect", "vmware")
989             xml_data = virt._gen_xml(
990                 self.mock_conn,
991                 "hello",
992                 1,
993                 512,
994                 diskp,
995                 nicp,
996                 "vmware",
997                 "hvm",
998                 "x86_64",
999             )
1000             root = ET.fromstring(xml_data)
1001             self.assertEqual(root.attrib["type"], "vmware")
1002             self.assertEqual(root.find("vcpu").text, "1")
1003             self.assertEqual(root.find("memory").text, str(512 * 1024))
1004             self.assertEqual(root.find("memory").attrib["unit"], "KiB")
1005             self.assertTrue(len(root.findall(".//disk")) == 2)
1006             self.assertTrue(len(root.findall(".//interface")) == 2)
1007     def test_gen_xml_for_kvm_custom_profile(self):
1008         disks = {
1009             "noeffect": [
1010                 {"first": {"size": 8192, "pool": "/var/lib/images"}},
1011                 {"second": {"size": 4096, "pool": "/var/lib/images"}},
1012             ]
1013         }
1014         nics = {
1015             "noeffect": [
1016                 {"name": "eth1", "source": "b2"},
1017                 {"name": "eth2", "source": "b2"},
1018             ]
1019         }
1020         with patch.dict(
1021             virt.__salt__,  # pylint: disable=no-member
1022             {"config.get": MagicMock(side_effect=[disks, nics])},
1023         ):
1024             diskp = virt._disk_profile(self.mock_conn, "noeffect", "kvm", [], "hello")
1025             nicp = virt._nic_profile("noeffect", "kvm")
1026             xml_data = virt._gen_xml(
1027                 self.mock_conn,
1028                 "hello",
1029                 1,
1030                 512,
1031                 diskp,
1032                 nicp,
1033                 "kvm",
1034                 "hvm",
1035                 "x86_64",
1036             )
1037             root = ET.fromstring(xml_data)
1038             self.assertEqual(root.attrib["type"], "kvm")
1039             self.assertEqual(root.find("vcpu").text, "1")
1040             self.assertEqual(root.find("memory").text, str(512 * 1024))
1041             self.assertEqual(root.find("memory").attrib["unit"], "KiB")
1042             disks = root.findall(".//disk")
1043             self.assertTrue(len(disks) == 2)
1044             self.assertEqual(disks[0].find("target").get("dev"), "vda")
1045             self.assertEqual(disks[1].find("target").get("dev"), "vdb")
1046             self.assertTrue(len(root.findall(".//interface")) == 2)
1047     def test_disk_profile_kvm_disk_pool(self):
1048         disks = {
1049             "noeffect": [
1050                 {"first": {"size": 8192, "pool": "mypool"}},
1051                 {"second": {"size": 4096}},
1052             ]
1053         }
1054         with patch.dict(
1055             virt.__salt__,
1056             {
1057                 "config.get": MagicMock(
1058                     side_effect=[
1059                         disks,
1060                         os.path.join(salt.syspaths.ROOT_DIR, "default", "path"),
1061                     ]
1062                 )
1063             },
1064         ):
1065             diskp = virt._disk_profile(self.mock_conn, "noeffect", "kvm", [], "hello")
1066             pools_path = (
1067                 os.path.join(salt.syspaths.ROOT_DIR, "pools", "mypool") + os.sep
1068             )
1069             default_path = (
1070                 os.path.join(salt.syspaths.ROOT_DIR, "default", "path") + os.sep
1071             )
1072             self.assertEqual(len(diskp), 2)
1073             self.assertTrue(diskp[1]["source_file"].startswith(default_path))
1074     def test_disk_profile_kvm_disk_external_image(self):
1075         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
1076             diskp = virt._disk_profile(
1077                 self.mock_conn,
1078                 None,
1079                 "kvm",
1080                 [{"name": "mydisk", "source_file": "/path/to/my/image.qcow2"}],
1081                 "hello",
1082             )
1083             self.assertEqual(len(diskp), 1)
1084             self.assertEqual(diskp[0]["source_file"], "/path/to/my/image.qcow2")
1085     def test_disk_profile_cdrom_default(self):
1086         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
1087             diskp = virt._disk_profile(
1088                 self.mock_conn,
1089                 None,
1090                 "kvm",
1091                 [
1092                     {
1093                         "name": "mydisk",
1094                         "device": "cdrom",
1095                         "source_file": "/path/to/my.iso",
1096                     }
1097                 ],
1098                 "hello",
1099             )
1100             self.assertEqual(len(diskp), 1)
1101             self.assertEqual(diskp[0]["model"], "ide")
1102             self.assertEqual(diskp[0]["format"], "raw")
1103     def test_disk_profile_pool_disk_type(self):
1104         self.mock_conn.listStoragePools.return_value = ["test-vdb"]
1105         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = """
1106             &lt;pool type="disk"&gt;
1107               &lt;name&gt;test-vdb&lt;/name&gt;
1108               &lt;source&gt;
1109                 &lt;device path='/dev/vdb'/&gt;
1110               &lt;/source&gt;
1111               &lt;target&gt;
1112                 &lt;path&gt;/dev&lt;/path&gt;
1113               &lt;/target&gt;
1114             &lt;/pool&gt;
1115         """
1116         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = (
1117             []
1118         )
1119         diskp = virt._disk_profile(
1120             self.mock_conn,
1121             None,
1122             "kvm",
1123             [{"name": "mydisk", "pool": "test-vdb"}],
1124             "hello",
1125         )
1126         self.assertEqual(diskp[0]["filename"], "vdb1")
1127         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = [
1128             "vdb1",
1129             "vdb2",
1130         ]
1131         diskp = virt._disk_profile(
1132             self.mock_conn,
1133             None,
1134             "kvm",
1135             [{"name": "mydisk", "pool": "test-vdb"}],
1136             "hello",
1137         )
1138         self.assertEqual(diskp[0]["filename"], "vdb3")
1139         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = [
1140             "vdb1",
1141             "vdb3",
1142         ]
1143         diskp = virt._disk_profile(
1144             self.mock_conn,
1145             None,
1146             "kvm",
1147             [{"name": "mydisk", "pool": "test-vdb"}],
1148             "hello",
1149         )
1150         self.assertEqual(diskp[0]["filename"], "vdb2")
1151         diskp = virt._disk_profile(
1152             self.mock_conn,
1153             None,
1154             "kvm",
1155             [{"name": "mydisk", "pool": "test-vdb", "source_file": "vdb1"}],
1156             "hello",
1157         )
1158         self.assertEqual(diskp[0]["filename"], "vdb1")
1159     def test_gen_xml_volume(self):
1160         self.mock_conn.listStoragePools.return_value = ["default"]
1161         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
1162             "&lt;pool type='dir'/&gt;"
1163         )
1164         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = [
1165             "myvolume"
1166         ]
1167         diskp = virt._disk_profile(
1168             self.mock_conn,
1169             None,
1170             "kvm",
1171             [
1172                 {"name": "system", "pool": "default"},
1173                 {"name": "data", "pool": "default", "source_file": "myvolume"},
1174             ],
1175             "hello",
1176         )
1177         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
1178             "&lt;pool type='dir'/&gt;"
1179         )
1180         nicp = virt._nic_profile(None, "kvm")
1181         xml_data = virt._gen_xml(
1182             self.mock_conn,
1183             "hello",
1184             1,
1185             512,
1186             diskp,
1187             nicp,
1188             "kvm",
1189             "hvm",
1190             "x86_64",
1191         )
1192         root = ET.fromstring(xml_data)
1193         disk = root.findall(".//disk")[0]
1194         self.assertEqual(disk.attrib["device"], "disk")
1195         self.assertEqual(disk.attrib["type"], "volume")
1196         source = disk.find("source")
1197         self.assertEqual("default", source.attrib["pool"])
1198         self.assertEqual("hello_system", source.attrib["volume"])
1199         self.assertEqual("myvolume", root.find(".//disk[2]/source").get("volume"))
1200         self.mock_conn.listStoragePools.return_value = ["test-rbd"]
1201         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = """
1202             &lt;pool type='rbd'&gt;
1203               &lt;name&gt;test-rbd&lt;/name&gt;
1204               &lt;uuid&gt;ede33e0a-9df0-479f-8afd-55085a01b244&lt;/uuid&gt;
1205               &lt;capacity unit='bytes'&gt;526133493760&lt;/capacity&gt;
1206               &lt;allocation unit='bytes'&gt;589928&lt;/allocation&gt;
1207               &lt;available unit='bytes'&gt;515081306112&lt;/available&gt;
1208               &lt;source&gt;
1209                 &lt;host name='ses2.tf.local'/&gt;
1210                 &lt;host name='ses3.tf.local' port='1234'/&gt;
1211                 &lt;name&gt;libvirt-pool&lt;/name&gt;
1212                 &lt;auth type='ceph' username='libvirt'&gt;
1213                   &lt;secret usage='pool_test-rbd'/&gt;
1214                 &lt;/auth&gt;
1215               &lt;/source&gt;
1216             &lt;/pool&gt;
1217         """
1218         self.mock_conn.getStoragePoolCapabilities.return_value = """
1219             &lt;storagepoolCapabilities&gt;
1220               &lt;pool type='rbd' supported='yes'&gt;
1221                 &lt;volOptions&gt;
1222                   &lt;defaultFormat type='raw'/&gt;
1223                   &lt;enum name='targetFormatType'&gt;
1224                   &lt;/enum&gt;
1225                 &lt;/volOptions&gt;
1226               &lt;/pool&gt;
1227             &lt;/storagepoolCapabilities&gt;
1228         """
1229         diskp = virt._disk_profile(
1230             self.mock_conn,
1231             None,
1232             "kvm",
1233             [{"name": "system", "pool": "test-rbd"}],
1234             "test-vm",
1235         )
1236         xml_data = virt._gen_xml(
1237             self.mock_conn,
1238             "hello",
1239             1,
1240             512,
1241             diskp,
1242             nicp,
1243             "kvm",
1244             "hvm",
1245             "x86_64",
1246         )
1247         root = ET.fromstring(xml_data)
1248         disk = root.findall(".//disk")[0]
1249         self.assertDictEqual(
1250             {
1251                 "type": "network",
1252                 "device": "disk",
1253                 "source": {
1254                     "protocol": "rbd",
1255                     "name": "libvirt-pool/test-vm_system",
1256                     "host": [
1257                         {"name": "ses2.tf.local"},
1258                         {"name": "ses3.tf.local", "port": "1234"},
1259                     ],
1260                     "auth": {
1261                         "username": "libvirt",
1262                         "secret": {"type": "ceph", "usage": "pool_test-rbd"},
1263                     },
1264                 },
1265                 "target": {"dev": "vda", "bus": "virtio"},
1266                 "driver": {
1267                     "name": "qemu",
1268                     "type": "raw",
1269                     "cache": "none",
1270                     "io": "native",
1271                 },
1272             },
1273             salt.utils.xmlutil.to_dict(disk, True),
1274         )
1275         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = """
1276             &lt;pool type='rbd'&gt;
1277               &lt;name&gt;test-rbd&lt;/name&gt;
1278               &lt;uuid&gt;ede33e0a-9df0-479f-8afd-55085a01b244&lt;/uuid&gt;
1279               &lt;capacity unit='bytes'&gt;526133493760&lt;/capacity&gt;
1280               &lt;allocation unit='bytes'&gt;589928&lt;/allocation&gt;
1281               &lt;available unit='bytes'&gt;515081306112&lt;/available&gt;
1282               &lt;source&gt;
1283                 &lt;host name='ses2.tf.local'/&gt;
1284                 &lt;host name='ses3.tf.local' port='1234'/&gt;
1285                 &lt;name&gt;libvirt-pool&lt;/name&gt;
1286                 &lt;auth type='ceph' username='libvirt'&gt;
1287                   &lt;secret uuid='some-uuid'/&gt;
1288                 &lt;/auth&gt;
1289               &lt;/source&gt;
1290             &lt;/pool&gt;
1291         """
1292         self.mock_conn.secretLookupByUUIDString.return_value.usageID.return_value = (
1293             "pool_test-rbd"
1294         )
1295         diskp = virt._disk_profile(
1296             self.mock_conn,
1297             None,
1298             "kvm",
1299             [{"name": "system", "pool": "test-rbd"}],
1300             "test-vm",
1301         )
1302         xml_data = virt._gen_xml(
1303             self.mock_conn,
1304             "hello",
1305             1,
1306             512,
1307             diskp,
1308             nicp,
1309             "kvm",
1310             "hvm",
1311             "x86_64",
1312         )
1313         root = ET.fromstring(xml_data)
1314         self.assertDictEqual(
1315             {
1316                 "username": "libvirt",
1317                 "secret": {"type": "ceph", "usage": "pool_test-rbd"},
1318             },
1319             salt.utils.xmlutil.to_dict(root.find(".//disk/source/auth"), True),
1320         )
1321         self.mock_conn.secretLookupByUUIDString.assert_called_once_with("some-uuid")
1322         self.mock_conn.getStoragePoolCapabilities.return_value = """
1323             &lt;storagepoolCapabilities&gt;
1324               &lt;pool type='disk' supported='yes'&gt;
1325                 &lt;volOptions&gt;
1326                   &lt;defaultFormat type='none'/&gt;
1327                   &lt;enum name='targetFormatType'&gt;
1328                     &lt;value&gt;none&lt;/value&gt;
1329                     &lt;value&gt;linux&lt;/value&gt;
1330                     &lt;value&gt;fat16&lt;/value&gt;
1331                   &lt;/enum&gt;
1332                 &lt;/volOptions&gt;
1333               &lt;/pool&gt;
1334             &lt;/storagepoolCapabilities&gt;
1335         """
1336         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = """
1337             &lt;pool type='disk'&gt;
1338               &lt;name&gt;test-vdb&lt;/name&gt;
1339               &lt;source&gt;
1340                 &lt;device path='/dev/vdb'/&gt;
1341                 &lt;format type='gpt'/&gt;
1342               &lt;/source&gt;
1343             &lt;/pool&gt;
1344         """
1345         self.mock_conn.listStoragePools.return_value = ["test-vdb"]
1346         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = [
1347             "vdb1",
1348         ]
1349         diskp = virt._disk_profile(
1350             self.mock_conn,
1351             None,
1352             "kvm",
1353             [{"name": "system", "pool": "test-vdb"}],
1354             "test-vm",
1355         )
1356         xml_data = virt._gen_xml(
1357             self.mock_conn,
1358             "hello",
1359             1,
1360             512,
1361             diskp,
1362             nicp,
1363             "kvm",
1364             "hvm",
1365             "x86_64",
1366         )
1367         root = ET.fromstring(xml_data)
1368         disk = root.findall(".//disk")[0]
1369         self.assertEqual(disk.attrib["type"], "volume")
1370         source = disk.find("source")
1371         self.assertEqual("test-vdb", source.attrib["pool"])
1372         self.assertEqual("vdb2", source.attrib["volume"])
1373         self.assertEqual("raw", disk.find("driver").get("type"))
1374     def test_get_xml_volume_xen_dir(self):
1375         self.mock_conn.listStoragePools.return_value = ["default"]
1376         pool_mock = MagicMock()
1377         pool_mock.XMLDesc.return_value = (
1378             "&lt;pool type='dir'&gt;&lt;target&gt;&lt;path&gt;/path/to/images&lt;/path&gt;&lt;/target&gt;&lt;/pool&gt;"
1379         )
1380         volume_xml = "&lt;volume&gt;&lt;target&gt;&lt;path&gt;/path/to/images/hello_system&lt;/path&gt;&lt;/target&gt;&lt;/volume&gt;"
1381         pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = volume_xml
1382         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
1383         diskp = virt._disk_profile(
1384             self.mock_conn,
1385             None,
1386             "xen",
1387             [{"name": "system", "pool": "default"}],
1388             "hello",
1389         )
1390         xml_data = virt._gen_xml(
1391             self.mock_conn,
1392             "hello",
1393             1,
1394             512,
1395             diskp,
1396             [],
1397             "xen",
1398             "hvm",
1399             "x86_64",
1400         )
1401         root = ET.fromstring(xml_data)
1402         disk = root.findall(".//disk")[0]
1403         self.assertEqual(disk.attrib["type"], "file")
1404         self.assertEqual(
1405             "/path/to/images/hello_system", disk.find("source").attrib["file"]
1406         )
1407     def test_get_xml_volume_xen_block(self):
1408         self.mock_conn.listStoragePools.return_value = ["default"]
1409         pool_mock = MagicMock()
1410         pool_mock.listVolumes.return_value = ["vol01"]
1411         volume_xml = "&lt;volume&gt;&lt;target&gt;&lt;path&gt;/dev/to/vol01&lt;/path&gt;&lt;/target&gt;&lt;/volume&gt;"
1412         pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = volume_xml
1413         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
1414         for pool_type in ["logical", "disk", "iscsi", "scsi"]:
1415             pool_mock.XMLDesc.return_value = "&lt;pool type='{}'&gt;&lt;source&gt;&lt;device path='/dev/sda'/&gt;&lt;/source&gt;&lt;/pool&gt;".format(
1416                 pool_type
1417             )
1418             diskp = virt._disk_profile(
1419                 self.mock_conn,
1420                 None,
1421                 "xen",
1422                 [{"name": "system", "pool": "default", "source_file": "vol01"}],
1423                 "hello",
1424             )
1425             xml_data = virt._gen_xml(
1426                 self.mock_conn,
1427                 "hello",
1428                 1,
1429                 512,
1430                 diskp,
1431                 [],
1432                 "xen",
1433                 "hvm",
1434                 "x86_64",
1435             )
1436             root = ET.fromstring(xml_data)
1437             disk = root.findall(".//disk")[0]
1438             self.assertEqual(disk.attrib["type"], "block")
1439             self.assertEqual("/dev/to/vol01", disk.find("source").attrib["dev"])
1440     def test_gen_xml_cdrom(self):
1441         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
1442             "&lt;pool type='dir'/&gt;"
1443         )
1444         diskp = virt._disk_profile(
1445             self.mock_conn,
1446             None,
1447             "kvm",
1448             [
1449                 {"name": "system", "pool": "default"},
1450                 {
1451                     "name": "tested",
1452                     "device": "cdrom",
1453                     "source_file": None,
1454                     "model": "ide",
1455                 },
1456                 {
1457                     "name": "remote",
1458                     "device": "cdrom",
1459                     "source_file": (
1460                         "http://myhost:8080/url/to/image?query=foo&amp;filter=bar"
1461                     ),
1462                     "model": "ide",
1463                 },
1464             ],
1465             "hello",
1466         )
1467         nicp = virt._nic_profile(None, "kvm")
1468         xml_data = virt._gen_xml(
1469             self.mock_conn,
1470             "hello",
1471             1,
1472             512,
1473             diskp,
1474             nicp,
1475             "kvm",
1476             "hvm",
1477             "x86_64",
1478         )
1479         root = ET.fromstring(xml_data)
1480         disk = root.findall(".//disk")[1]
1481         self.assertEqual(disk.get("type"), "file")
1482         self.assertEqual(disk.attrib["device"], "cdrom")
1483         self.assertIsNone(disk.find("source"))
1484         self.assertEqual(disk.find("target").get("dev"), "hda")
1485         disk = root.findall(".//disk")[2]
1486         self.assertEqual(disk.get("type"), "network")
1487         self.assertEqual(disk.attrib["device"], "cdrom")
1488         self.assertEqual(
1489             {
1490                 "protocol": "http",
1491                 "name": "/url/to/image",
1492                 "query": "query=foo&amp;filter=bar",
1493                 "host": {"name": "myhost", "port": "8080"},
1494             },
1495             salt.utils.xmlutil.to_dict(disk.find("source"), True),
1496         )
1497     def test_controller_for_esxi(self):
1498         diskp = virt._disk_profile(self.mock_conn, "default", "vmware", [], "hello")
1499         nicp = virt._nic_profile("default", "vmware")
1500         xml_data = virt._gen_xml(
1501             self.mock_conn,
1502             "hello",
1503             1,
1504             512,
1505             diskp,
1506             nicp,
1507             "vmware",
1508             "hvm",
1509             "x86_64",
1510         )
1511         root = ET.fromstring(xml_data)
1512         controllers = root.findall(".//devices/controller")
1513         self.assertTrue(len(controllers) == 1)
1514         controller = controllers[0]
1515         self.assertEqual(controller.attrib["model"], "lsilogic")
1516     def test_controller_for_kvm(self):
1517         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
1518         nicp = virt._nic_profile("default", "kvm")
1519         xml_data = virt._gen_xml(
1520             self.mock_conn,
1521             "hello",
1522             1,
1523             512,
1524             diskp,
1525             nicp,
1526             "kvm",
1527             "hvm",
1528             "x86_64",
1529         )
1530         root = ET.fromstring(xml_data)
1531         controllers = root.findall(".//devices/controller")
1532         self.assertTrue(len(controllers) == 0)
1533     def test_diff_disks(self):
1534         old_disks = ET.fromstring(
1535         ).findall("disk")
1536         new_disks = ET.fromstring(
1537         ).findall("disk")
1538         ret = virt._diff_disk_lists(old_disks, new_disks)
1539         self.assertEqual(
1540             [
1541                 disk.find("source").get("file")
1542                 if disk.find("source") is not None
1543                 else None
1544                 for disk in ret["unchanged"]
1545             ],
1546             [],
1547         )
1548         self.assertEqual(
1549             [
1550                 disk.find("source").get("file")
1551                 if disk.find("source") is not None
1552                 else None
1553                 for disk in ret["new"]
1554             ],
1555             ["/path/to/img3.qcow2", "/path/to/img0.qcow2", "/path/to/img4.qcow2", None],
1556         )
1557         self.assertEqual(
1558             [disk.find("target").get("dev") for disk in ret["sorted"]],
1559             ["vda", "vdb", "vdc", "hda"],
1560         )
1561         self.assertEqual(
1562             [
1563                 disk.find("source").get("file")
1564                 if disk.find("source") is not None
1565                 else None
1566                 for disk in ret["sorted"]
1567             ],
1568             ["/path/to/img3.qcow2", "/path/to/img0.qcow2", "/path/to/img4.qcow2", None],
1569         )
1570         self.assertEqual(ret["new"][1].find("target").get("bus"), "virtio")
1571         self.assertEqual(
1572             [
1573                 disk.find("source").get("file")
1574                 if disk.find("source") is not None
1575                 else None
1576                 for disk in ret["deleted"]
1577             ],
1578             [
1579                 "/path/to/img0.qcow2",
1580                 "/path/to/img1.qcow2",
1581                 "/path/to/img2.qcow2",
1582                 "/path/to/img4.qcow2",
1583                 None,
1584             ],
1585         )
1586     def test_init(self):
1587         xml = """
1588 &lt;capabilities&gt;
1589   &lt;host&gt;
1590     &lt;uuid&gt;44454c4c-3400-105a-8033-b3c04f4b344a&lt;/uuid&gt;
1591     &lt;cpu&gt;
1592       &lt;arch&gt;x86_64&lt;/arch&gt;
1593       &lt;model&gt;Nehalem&lt;/model&gt;
1594       &lt;vendor&gt;Intel&lt;/vendor&gt;
1595       &lt;microcode version='25'/&gt;
1596       &lt;topology sockets='1' cores='4' threads='2'/&gt;
1597       &lt;feature name='vme'/&gt;
1598       &lt;feature name='ds'/&gt;
1599       &lt;feature name='acpi'/&gt;
1600       &lt;pages unit='KiB' size='4'/&gt;
1601       &lt;pages unit='KiB' size='2048'/&gt;
1602     &lt;/cpu&gt;
1603     &lt;power_management&gt;
1604       &lt;suspend_mem/&gt;
1605       &lt;suspend_disk/&gt;
1606       &lt;suspend_hybrid/&gt;
1607     &lt;/power_management&gt;
1608     &lt;migration_features&gt;
1609       &lt;live/&gt;
1610       &lt;uri_transports&gt;
1611         &lt;uri_transport&gt;tcp&lt;/uri_transport&gt;
1612         &lt;uri_transport&gt;rdma&lt;/uri_transport&gt;
1613       &lt;/uri_transports&gt;
1614     &lt;/migration_features&gt;
1615     &lt;topology&gt;
1616       &lt;cells num='1'&gt;
1617         &lt;cell id='0'&gt;
1618           &lt;memory unit='KiB'&gt;12367120&lt;/memory&gt;
1619           &lt;pages unit='KiB' size='4'&gt;3091780&lt;/pages&gt;
1620           &lt;pages unit='KiB' size='2048'&gt;0&lt;/pages&gt;
1621           &lt;distances&gt;
1622             &lt;sibling id='0' value='10'/&gt;
1623           &lt;/distances&gt;
1624           &lt;cpus num='8'&gt;
1625             &lt;cpu id='0' socket_id='0' core_id='0' siblings='0,4'/&gt;
1626             &lt;cpu id='1' socket_id='0' core_id='1' siblings='1,5'/&gt;
1627             &lt;cpu id='2' socket_id='0' core_id='2' siblings='2,6'/&gt;
1628             &lt;cpu id='3' socket_id='0' core_id='3' siblings='3,7'/&gt;
1629             &lt;cpu id='4' socket_id='0' core_id='0' siblings='0,4'/&gt;
1630             &lt;cpu id='5' socket_id='0' core_id='1' siblings='1,5'/&gt;
1631             &lt;cpu id='6' socket_id='0' core_id='2' siblings='2,6'/&gt;
1632             &lt;cpu id='7' socket_id='0' core_id='3' siblings='3,7'/&gt;
1633           &lt;/cpus&gt;
1634         &lt;/cell&gt;
1635       &lt;/cells&gt;
1636     &lt;/topology&gt;
1637     &lt;cache&gt;
1638       &lt;bank id='0' level='3' type='both' size='8' unit='MiB' cpus='0-7'/&gt;
1639     &lt;/cache&gt;
1640     &lt;secmodel&gt;
1641       &lt;model&gt;apparmor&lt;/model&gt;
1642       &lt;doi&gt;0&lt;/doi&gt;
1643     &lt;/secmodel&gt;
1644     &lt;secmodel&gt;
1645       &lt;model&gt;dac&lt;/model&gt;
1646       &lt;doi&gt;0&lt;/doi&gt;
1647       &lt;baselabel type='kvm'&gt;+487:+486&lt;/baselabel&gt;
1648       &lt;baselabel type='qemu'&gt;+487:+486&lt;/baselabel&gt;
1649     &lt;/secmodel&gt;
1650   &lt;/host&gt;
1651   &lt;guest&gt;
1652     &lt;os_type&gt;hvm&lt;/os_type&gt;
1653     &lt;arch name='i686'&gt;
1654       &lt;wordsize&gt;32&lt;/wordsize&gt;
1655       &lt;emulator&gt;/usr/bin/qemu-system-i386&lt;/emulator&gt;
1656       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
1657       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
1658       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
1659       &lt;domain type='qemu'/&gt;
1660       &lt;domain type='kvm'&gt;
1661         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
1662         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
1663         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
1664         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
1665       &lt;/domain&gt;
1666     &lt;/arch&gt;
1667     &lt;features&gt;
1668       &lt;cpuselection/&gt;
1669       &lt;deviceboot/&gt;
1670       &lt;disksnapshot default='on' toggle='no'/&gt;
1671       &lt;acpi default='on' toggle='yes'/&gt;
1672       &lt;apic default='on' toggle='no'/&gt;
1673       &lt;pae/&gt;
1674       &lt;nonpae/&gt;
1675     &lt;/features&gt;
1676   &lt;/guest&gt;
1677   &lt;guest&gt;
1678     &lt;os_type&gt;hvm&lt;/os_type&gt;
1679     &lt;arch name='x86_64'&gt;
1680       &lt;wordsize&gt;64&lt;/wordsize&gt;
1681       &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
1682       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
1683       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
1684       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
1685       &lt;domain type='qemu'/&gt;
1686       &lt;domain type='kvm'&gt;
1687         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
1688         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
1689         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
1690         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
1691       &lt;/domain&gt;
1692     &lt;/arch&gt;
1693     &lt;features&gt;
1694       &lt;cpuselection/&gt;
1695       &lt;deviceboot/&gt;
1696       &lt;disksnapshot default='on' toggle='no'/&gt;
1697       &lt;acpi default='on' toggle='yes'/&gt;
1698       &lt;apic default='on' toggle='no'/&gt;
1699     &lt;/features&gt;
1700   &lt;/guest&gt;
1701 &lt;/capabilities&gt;
1702         """
1703         self.mock_conn.getCapabilities.return_value = xml  # pylint: disable=no-member
1704         root_dir = os.path.join(salt.syspaths.ROOT_DIR, "srv", "salt-images")
1705         defineMock = MagicMock(return_value=1)
1706         self.mock_conn.defineXML = defineMock
1707         mock_chmod = MagicMock()
1708         mock_run = MagicMock()
1709         with patch.dict(
1710             os.__dict__, {"chmod": mock_chmod, "makedirs": MagicMock()}
1711         ):  # pylint: disable=no-member
1712             with patch.dict(
1713                 virt.__salt__, {"cmd.run": mock_run}
1714             ):  # pylint: disable=no-member
1715                 virt.init(
1716                     "test vm", 2, 1234, nic=None, disk=None, seed=False, start=False
1717                 )
1718                 definition = defineMock.call_args_list[0][0][0]
1719                 self.assertFalse("&lt;interface" in definition)
1720                 self.assertFalse("&lt;disk" in definition)
1721                 defineMock.reset_mock()
1722                 mock_run.reset_mock()
1723                 boot = {
1724                     "kernel": "/root/f8-i386-vmlinuz",
1725                     "initrd": "/root/f8-i386-initrd",
1726                     "cmdline": "console=ttyS0 ks=http://example.com/f8-i386/os/",
1727                 }
1728                 retval = virt.init(
1729                     "test vm boot params",
1730                     2,
1731                     1234,
1732                     nic=None,
1733                     disk=None,
1734                     seed=False,
1735                     start=False,
1736                     boot=boot,
1737                 )
1738                 definition = defineMock.call_args_list[0][0][0]
1739                 self.assertEqual("&lt;kernel" in definition, True)
1740                 self.assertEqual("&lt;initrd" in definition, True)
1741                 self.assertEqual("&lt;cmdline" in definition, True)
1742                 self.assertEqual(retval, True)
1743                 mock_response = MagicMock()
1744                 mock_response.read = MagicMock(return_value="filecontent")
1745                 cache_dir = tempfile.mkdtemp()
1746                 with patch.dict(virt.__dict__, {"CACHE_DIR": cache_dir}):
1747                     with patch(
1748                         "urllib.request.urlopen",
1749                         MagicMock(return_value=mock_response),
1750                     ):
1751                         with patch(
1752                             "salt.utils.files.fopen", return_value=mock_response
1753                         ):
1754                             defineMock.reset_mock()
1755                             mock_run.reset_mock()
1756                             boot = {
1757                                 "kernel": "https://www.example.com/download/vmlinuz",
1758                                 "initrd": "",
1759                                 "cmdline": (
1760                                     "console=ttyS0 ks=http://example.com/f8-i386/os/"
1761                                 ),
1762                             }
1763                             retval = virt.init(
1764                                 "test remote vm boot params",
1765                                 2,
1766                                 1234,
1767                                 nic=None,
1768                                 disk=None,
1769                                 seed=False,
1770                                 start=False,
1771                                 boot=boot,
1772                             )
1773                             definition = defineMock.call_args_list[0][0][0]
1774                             self.assertEqual(cache_dir in definition, True)
1775                     shutil.rmtree(cache_dir)
1776                 defineMock.reset_mock()
1777                 mock_run.reset_mock()
1778                 pool_mock = MagicMock()
1779                 pool_mock.XMLDesc.return_value = '&lt;pool type="dir"/&gt;'
1780                 self.mock_conn.storagePoolLookupByName.return_value = pool_mock
1781                 virt.init(
1782                     "test vm",
1783                     2,
1784                     1234,
1785                     nic=None,
1786                     disk=None,
1787                     disks=[
1788                         {"name": "system", "size": 10240},
1789                         {
1790                             "name": "cddrive",
1791                             "device": "cdrom",
1792                             "source_file": None,
1793                             "model": "ide",
1794                         },
1795                     ],
1796                     seed=False,
1797                     start=False,
1798                 )
1799                 definition = ET.fromstring(defineMock.call_args_list[0][0][0])
1800                 expected_disk_path = os.path.join(root_dir, "test vm_system.qcow2")
1801                 self.assertEqual(
1802                     expected_disk_path,
1803                     definition.find("./devices/disk[1]/source").get("file"),
1804                 )
1805                 self.assertIsNone(definition.find("./devices/disk[2]/source"))
1806                 self.assertEqual(
1807                     mock_run.call_args[0][0],
1808                     'qemu-img create -f qcow2 "{}" 10240M'.format(expected_disk_path),
1809                 )
1810                 self.assertEqual(mock_chmod.call_args[0][0], expected_disk_path)
1811                 defineMock.reset_mock()
1812                 mock_run.reset_mock()
1813                 vol_mock = MagicMock()
1814                 pool_mock.storageVolLookupByName.return_value = vol_mock
1815                 pool_mock.listVolumes.return_value = ["test vm_data"]
1816                 stream_mock = MagicMock()
1817                 self.mock_conn.newStream.return_value = stream_mock
1818                 self.mock_conn.listStoragePools.return_value = ["default", "test"]
1819                 with patch.dict(
1820                     os.__dict__, {"open": MagicMock(), "close": MagicMock()}
1821                 ):
1822                     cache_mock = MagicMock()
1823                     with patch.dict(virt.__salt__, {"cp.cache_file": cache_mock}):
1824                         virt.init(
1825                             "test vm",
1826                             2,
1827                             1234,
1828                             nic=None,
1829                             disk=None,
1830                             disks=[
1831                                 {
1832                                     "name": "system",
1833                                     "size": 10240,
1834                                     "image": "/path/to/image",
1835                                     "pool": "test",
1836                                 },
1837                                 {"name": "data", "size": 10240, "pool": "default"},
1838                                 {
1839                                     "name": "test",
1840                                     "size": 1024,
1841                                     "pool": "default",
1842                                     "format": "qcow2",
1843                                     "backing_store_path": "/backing/path",
1844                                     "backing_store_format": "raw",
1845                                 },
1846                             ],
1847                             seed=False,
1848                             start=False,
1849                         )
1850                         definition = ET.fromstring(defineMock.call_args_list[0][0][0])
1851                         self.assertTrue(
1852                             all(
1853                                 [
1854                                     disk.get("type") == "volume"
1855                                     for disk in definition.findall("./devices/disk")
1856                                 ]
1857                             )
1858                         )
1859                         self.assertEqual(
1860                             ["test", "default", "default"],
1861                             [
1862                                 src.get("pool")
1863                                 for src in definition.findall("./devices/disk/source")
1864                             ],
1865                         )
1866                         self.assertEqual(
1867                             ["test vm_system", "test vm_data", "test vm_test"],
1868                             [
1869                                 src.get("volume")
1870                                 for src in definition.findall("./devices/disk/source")
1871                             ],
1872                         )
1873                         create_calls = pool_mock.createXML.call_args_list
1874                         vol_names = [
1875                             ET.fromstring(call[0][0]).find("name").text
1876                             for call in create_calls
1877                         ]
1878                         self.assertEqual(
1879                             ["test vm_system", "test vm_test"],
1880                             vol_names,
1881                         )
1882                         stream_mock.sendAll.assert_called_once()
1883                         stream_mock.finish.assert_called_once()
1884                         vol_mock.upload.assert_called_once_with(stream_mock, 0, 0, 0)
1885     def test_update_backing_store(self):
1886         xml = """
1887             &lt;domain type='kvm' id='7'&gt;
1888               &lt;name&gt;my_vm&lt;/name&gt;
1889               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
1890               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
1891               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
1892               &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
1893               &lt;os&gt;
1894                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
1895               &lt;/os&gt;
1896               &lt;devices&gt;
1897                 &lt;disk type='volume' device='disk'&gt;
1898                   &lt;driver name='qemu' type='qcow2' cache='none' io='native'/&gt;
1899                   &lt;source pool='default' volume='my_vm_system' index='1'/&gt;
1900                   &lt;backingStore type='file' index='2'&gt;
1901                     &lt;format type='qcow2'/&gt;
1902                     &lt;source file='/path/to/base.qcow2'/&gt;
1903                     &lt;backingStore/&gt;
1904                   &lt;/backingStore&gt;
1905                   &lt;target dev='vda' bus='virtio'/&gt;
1906                   &lt;alias name='virtio-disk0'/&gt;
1907                   &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x04' function='0x0'/&gt;
1908                 &lt;/disk&gt;
1909               &lt;/devices&gt;
1910             &lt;/domain&gt;
1911         """
1912         domain_mock = self.set_mock_vm("my_vm", xml)
1913         domain_mock.OSType.return_value = "hvm"
1914         self.mock_conn.defineXML.return_value = True
1915         updatedev_mock = MagicMock(return_value=0)
1916         domain_mock.updateDeviceFlags = updatedev_mock
1917         self.mock_conn.listStoragePools.return_value = ["default"]
1918         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
1919             "&lt;pool type='dir'/&gt;"
1920         )
1921         ret = virt.update(
1922             "my_vm",
1923             disks=[
1924                 {
1925                     "name": "system",
1926                     "pool": "default",
1927                     "backing_store_path": "/path/to/base.qcow2",
1928                     "backing_store_format": "qcow2",
1929                 },
1930             ],
1931         )
1932         self.assertFalse(ret["definition"])
1933         self.assertFalse(ret["disk"]["attached"])
1934         self.assertFalse(ret["disk"]["detached"])
1935     def test_update_removables(self):
1936         xml = """
1937             &lt;domain type='kvm' id='7'&gt;
1938               &lt;name&gt;my_vm&lt;/name&gt;
1939               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
1940               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
1941               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
1942               &lt;os&gt;
1943                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
1944               &lt;/os&gt;
1945               &lt;devices&gt;
1946                 &lt;disk type='network' device='cdrom'&gt;
1947                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1948                   &lt;source protocol='https' name='/dvd-image-1.iso'&gt;
1949                     &lt;host name='test-srv.local' port='80'/&gt;
1950                   &lt;/source&gt;
1951                   &lt;backingStore/&gt;
1952                   &lt;target dev='hda' bus='ide'/&gt;
1953                   &lt;readonly/&gt;
1954                   &lt;alias name='ide0-0-0'/&gt;
1955                   &lt;address type='drive' controller='0' bus='0' target='0' unit='0'/&gt;
1956                 &lt;/disk&gt;
1957                 &lt;disk type='file' device='cdrom'&gt;
1958                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1959                   &lt;target dev='hdb' bus='ide'/&gt;
1960                   &lt;readonly/&gt;
1961                   &lt;alias name='ide0-0-1'/&gt;
1962                   &lt;address type='drive' controller='0' bus='0' target='0' unit='1'/&gt;
1963                 &lt;/disk&gt;
1964                 &lt;disk type='file' device='cdrom'&gt;
1965                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1966                   &lt;source file='/srv/dvd-image-2.iso'/&gt;
1967                   &lt;backingStore/&gt;
1968                   &lt;target dev='hdc' bus='ide'/&gt;
1969                   &lt;readonly/&gt;
1970                   &lt;alias name='ide0-0-2'/&gt;
1971                   &lt;address type='drive' controller='0' bus='0' target='0' unit='2'/&gt;
1972                 &lt;/disk&gt;
1973                 &lt;disk type='file' device='cdrom'&gt;
1974                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1975                   &lt;source file='/srv/dvd-image-3.iso'/&gt;
1976                   &lt;backingStore/&gt;
1977                   &lt;target dev='hdd' bus='ide'/&gt;
1978                   &lt;readonly/&gt;
1979                   &lt;alias name='ide0-0-3'/&gt;
1980                   &lt;address type='drive' controller='0' bus='0' target='0' unit='3'/&gt;
1981                 &lt;/disk&gt;
1982                 &lt;disk type='network' device='cdrom'&gt;
1983                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1984                   &lt;source protocol='https' name='/dvd-image-6.iso'&gt;
1985                     &lt;host name='test-srv.local' port='80'/&gt;
1986                   &lt;/source&gt;
1987                   &lt;backingStore/&gt;
1988                   &lt;target dev='hde' bus='ide'/&gt;
1989                   &lt;readonly/&gt;
1990                 &lt;/disk&gt;
1991               &lt;/devices&gt;
1992             &lt;/domain&gt;
1993         """
1994         domain_mock = self.set_mock_vm("my_vm", xml)
1995         domain_mock.OSType.return_value = "hvm"
1996         self.mock_conn.defineXML.return_value = True
1997         updatedev_mock = MagicMock(return_value=0)
1998         domain_mock.updateDeviceFlags = updatedev_mock
1999         ret = virt.update(
2000             "my_vm",
2001             disks=[
2002                 {
2003                     "name": "dvd1",
2004                     "device": "cdrom",
2005                     "source_file": None,
2006                     "model": "ide",
2007                 },
2008                 {
2009                     "name": "dvd2",
2010                     "device": "cdrom",
2011                     "source_file": "/srv/dvd-image-4.iso",
2012                     "model": "ide",
2013                 },
2014                 {
2015                     "name": "dvd3",
2016                     "device": "cdrom",
2017                     "source_file": "/srv/dvd-image-2.iso",
2018                     "model": "ide",
2019                 },
2020                 {
2021                     "name": "dvd4",
2022                     "device": "cdrom",
2023                     "source_file": "/srv/dvd-image-5.iso",
2024                     "model": "ide",
2025                 },
2026                 {
2027                     "name": "dvd5",
2028                     "device": "cdrom",
2029                     "source_file": "/srv/dvd-image-6.iso",
2030                     "model": "ide",
2031                 },
2032             ],
2033         )
2034         self.assertTrue(ret["definition"])
2035         self.assertFalse(ret["disk"].get("attached"))
2036         self.assertFalse(ret["disk"].get("detached"))
2037         self.assertEqual(
2038             [
2039                 {
2040                     "type": "file",
2041                     "device": "cdrom",
2042                     "driver": {
2043                         "name": "qemu",
2044                         "type": "raw",
2045                         "cache": "none",
2046                         "io": "native",
2047                     },
2048                     "backingStore": None,
2049                     "target": {"dev": "hda", "bus": "ide"},
2050                     "readonly": None,
2051                     "alias": {"name": "ide0-0-0"},
2052                     "address": {
2053                         "type": "drive",
2054                         "controller": "0",
2055                         "bus": "0",
2056                         "target": "0",
2057                         "unit": "0",
2058                     },
2059                 },
2060                 {
2061                     "type": "file",
2062                     "device": "cdrom",
2063                     "driver": {
2064                         "name": "qemu",
2065                         "type": "raw",
2066                         "cache": "none",
2067                         "io": "native",
2068                     },
2069                     "target": {"dev": "hdb", "bus": "ide"},
2070                     "readonly": None,
2071                     "alias": {"name": "ide0-0-1"},
2072                     "address": {
2073                         "type": "drive",
2074                         "controller": "0",
2075                         "bus": "0",
2076                         "target": "0",
2077                         "unit": "1",
2078                     },
2079                     "source": {"file": "/srv/dvd-image-4.iso"},
2080                 },
2081                 {
2082                     "type": "file",
2083                     "device": "cdrom",
2084                     "driver": {
2085                         "name": "qemu",
2086                         "type": "raw",
2087                         "cache": "none",
2088                         "io": "native",
2089                     },
2090                     "backingStore": None,
2091                     "target": {"dev": "hdd", "bus": "ide"},
2092                     "readonly": None,
2093                     "alias": {"name": "ide0-0-3"},
2094                     "address": {
2095                         "type": "drive",
2096                         "controller": "0",
2097                         "bus": "0",
2098                         "target": "0",
2099                         "unit": "3",
2100                     },
2101                     "source": {"file": "/srv/dvd-image-5.iso"},
2102                 },
2103                 {
2104                     "type": "file",
2105                     "device": "cdrom",
2106                     "driver": {
2107                         "name": "qemu",
2108                         "type": "raw",
2109                         "cache": "none",
2110                         "io": "native",
2111                     },
2112                     "backingStore": None,
2113                     "target": {"dev": "hde", "bus": "ide"},
2114                     "readonly": None,
2115                     "source": {"file": "/srv/dvd-image-6.iso"},
2116                 },
2117             ],
2118             [
2119                 salt.utils.xmlutil.to_dict(ET.fromstring(disk), True)
2120                 for disk in ret["disk"]["updated"]
2121             ],
2122         )
2123     def test_update_xen_boot_params(self):
2124         root_dir = os.path.join(salt.syspaths.ROOT_DIR, "srv", "salt-images")
2125         xml_boot = """
2126             &lt;domain type='xen' id='8'&gt;
2127               &lt;name&gt;vm&lt;/name&gt;
2128               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
2129               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
2130               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
2131               &lt;os&gt;
2132                 &lt;type arch='x86_64' machine='xenfv'&gt;hvm&lt;/type&gt;
2133                 &lt;loader type='rom'&gt;/usr/lib/xen/boot/hvmloader&lt;/loader&gt;
2134               &lt;/os&gt;
2135             &lt;/domain&gt;
2136         """
2137         domain_mock_boot = self.set_mock_vm("vm", xml_boot)
2138         domain_mock_boot.OSType = MagicMock(return_value="hvm")
2139         define_mock_boot = MagicMock(return_value=True)
2140         define_mock_boot.setVcpusFlags = MagicMock(return_value=0)
2141         self.mock_conn.defineXML = define_mock_boot
2142         self.assertEqual(
2143             {
2144                 "cpu": False,
2145                 "definition": True,
2146                 "disk": {"attached": [], "detached": [], "updated": []},
2147                 "interface": {"attached": [], "detached": []},
2148             },
2149             virt.update("vm", cpu=2),
2150         )
2151         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2152         self.assertEqual(setxml.find("os").find("loader").attrib.get("type"), "rom")
2153         self.assertEqual(
2154             setxml.find("os").find("loader").text, "/usr/lib/xen/boot/hvmloader"
2155         )
2156     def test_update_existing_boot_params(self):
2157         xml_boot = """
2158             &lt;domain type='kvm' id='8'&gt;
2159               &lt;name&gt;vm_with_boot_param&lt;/name&gt;
2160               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
2161               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
2162               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
2163               &lt;os&gt;
2164                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
2165                 &lt;kernel&gt;/boot/oldkernel&lt;/kernel&gt;
2166                 &lt;initrd&gt;/boot/initrdold.img&lt;/initrd&gt;
2167                 &lt;cmdline&gt;console=ttyS0 ks=http://example.com/old/os/&lt;/cmdline&gt;
2168                 &lt;loader&gt;/usr/share/old/OVMF_CODE.fd&lt;/loader&gt;
2169                 &lt;nvram&gt;/usr/share/old/OVMF_VARS.ms.fd&lt;/nvram&gt;
2170               &lt;/os&gt;
2171             &lt;/domain&gt;
2172         """
2173         domain_mock_boot = self.set_mock_vm("vm_with_boot_param", xml_boot)
2174         domain_mock_boot.OSType = MagicMock(return_value="hvm")
2175         define_mock_boot = MagicMock(return_value=True)
2176         self.mock_conn.defineXML = define_mock_boot
2177         boot_new = {
2178             "kernel": "/root/new-vmlinuz",
2179             "initrd": "/root/new-initrd",
2180             "cmdline": "console=ttyS0 ks=http://example.com/new/os/",
2181         }
2182         uefi_boot_new = {
2183             "loader": "/usr/share/new/OVMF_CODE.fd",
2184             "nvram": "/usr/share/new/OVMF_VARS.ms.fd",
2185         }
2186         self.assertEqual(
2187             {
2188                 "definition": True,
2189                 "disk": {"attached": [], "detached": [], "updated": []},
2190                 "interface": {"attached": [], "detached": []},
2191             },
2192             virt.update("vm_with_boot_param", boot=boot_new),
2193         )
2194         setxml_boot = ET.fromstring(define_mock_boot.call_args[0][0])
2195         self.assertEqual(
2196             setxml_boot.find("os").find("kernel").text, "/root/new-vmlinuz"
2197         )
2198         self.assertEqual(setxml_boot.find("os").find("initrd").text, "/root/new-initrd")
2199         self.assertEqual(
2200             setxml_boot.find("os").find("cmdline").text,
2201             "console=ttyS0 ks=http://example.com/new/os/",
2202         )
2203         self.assertEqual(
2204             {
2205                 "definition": True,
2206                 "disk": {"attached": [], "detached": [], "updated": []},
2207                 "interface": {"attached": [], "detached": []},
2208             },
2209             virt.update("vm_with_boot_param", boot=uefi_boot_new),
2210         )
2211         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2212         self.assertEqual(
2213             setxml.find("os").find("loader").text, "/usr/share/new/OVMF_CODE.fd"
2214         )
2215         self.assertEqual(setxml.find("os").find("loader").attrib.get("readonly"), "yes")
2216         self.assertEqual(setxml.find("os").find("loader").attrib["type"], "pflash")
2217         self.assertEqual(
2218             setxml.find("os").find("nvram").attrib["template"],
2219             "/usr/share/new/OVMF_VARS.ms.fd",
2220         )
2221         kernel_none = {
2222             "kernel": None,
2223             "initrd": None,
2224             "cmdline": None,
2225         }
2226         uefi_none = {"loader": None, "nvram": None}
2227         self.assertEqual(
2228             {
2229                 "definition": True,
2230                 "disk": {"attached": [], "detached": [], "updated": []},
2231                 "interface": {"attached": [], "detached": []},
2232             },
2233             virt.update("vm_with_boot_param", boot=kernel_none),
2234         )
2235         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2236         self.assertEqual(setxml.find("os").find("kernel"), None)
2237         self.assertEqual(setxml.find("os").find("initrd"), None)
2238         self.assertEqual(setxml.find("os").find("cmdline"), None)
2239         self.assertEqual(
2240             {
2241                 "definition": True,
2242                 "disk": {"attached": [], "detached": [], "updated": []},
2243                 "interface": {"attached": [], "detached": []},
2244             },
2245             virt.update("vm_with_boot_param", boot={"efi": False}),
2246         )
2247         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2248         self.assertEqual(setxml.find("os").find("nvram"), None)
2249         self.assertEqual(setxml.find("os").find("loader"), None)
2250         self.assertEqual(
2251             {
2252                 "definition": True,
2253                 "disk": {"attached": [], "detached": [], "updated": []},
2254                 "interface": {"attached": [], "detached": []},
2255             },
2256             virt.update("vm_with_boot_param", boot=uefi_none),
2257         )
2258         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2259         self.assertEqual(setxml.find("os").find("loader"), None)
2260         self.assertEqual(setxml.find("os").find("nvram"), None)
2261     def test_update_existing_numatune_params(self):
2262         xml_numatune = """
2263             &lt;domain type='kvm' id='8'&gt;
2264               &lt;name&gt;vm_with_numatune_param&lt;/name&gt;
2265               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
2266               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
2267               &lt;maxMemory slots="12" unit="bytes"&gt;1048576&lt;/maxMemory&gt;
2268               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
2269               &lt;numatune&gt;
2270                 &lt;memory mode="strict" nodeset="0-11"/&gt;
2271                 &lt;memnode cellid="1" mode="strict" nodeset="3"/&gt;
2272                 &lt;memnode cellid="3" mode="preferred" nodeset="7"/&gt;
2273               &lt;/numatune&gt;
2274               &lt;os&gt;
2275                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
2276               &lt;/os&gt;
2277               &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
2278             &lt;/domain&gt;
2279         """
2280         domain_mock = self.set_mock_vm("vm_with_numatune_param", xml_numatune)
2281         domain_mock.OSType = MagicMock(return_value="hvm")
2282         define_mock = MagicMock(return_value=True)
2283         self.mock_conn.defineXML = define_mock
2284         numatune = {
2285             "memory": {"mode": "preferred", "nodeset": "0-5"},
2286             "memnodes": {
2287                 0: {"mode": "strict", "nodeset": "4"},
2288                 3: {"mode": "preferred", "nodeset": "7"},
2289                 4: {"mode": "strict", "nodeset": "6"},
2290             },
2291         }
2292         self.assertEqual(
2293             {
2294                 "definition": True,
2295                 "disk": {"attached": [], "detached": [], "updated": []},
2296                 "interface": {"attached": [], "detached": []},
2297             },
2298             virt.update("vm_with_numatune_param", numatune=numatune),
2299         )
2300         setxml = ET.fromstring(define_mock.call_args[0][0])
2301         self.assertEqual(
2302             setxml.find("numatune").find("memory").attrib.get("mode"), "preferred"
2303         )
2304         self.assertEqual(
2305             setxml.find("numatune").find("memory").attrib.get("nodeset"),
2306             ",".join([str(i) for i in range(0, 6)]),
2307         )
2308         self.assertEqual(
2309             setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("mode"), "strict"
2310         )
2311         self.assertEqual(
2312             setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("nodeset"), "4"
2313         )
2314         self.assertEqual(setxml.find("./numatune/memnode/[@cellid='1']"), None)
2315         self.assertEqual(
2316             setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("mode"),
2317             "preferred",
2318         )
2319         self.assertEqual(
2320             setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("nodeset"), "7"
2321         )
2322         self.assertEqual(
2323             setxml.find("./numatune/memnode/[@cellid='4']").attrib.get("mode"), "strict"
2324         )
2325         self.assertEqual(
2326             setxml.find("./numatune/memnode/[@cellid='4']").attrib.get("nodeset"), "6"
2327         )
2328         self.assertEqual(setxml.find("./numatune/memnode/[@cellid='2']"), None)
2329         numatune_mem_none = {
2330             "memory": None,
2331             "memnodes": {
2332                 0: {"mode": "strict", "nodeset": "4"},
2333                 3: {"mode": "preferred", "nodeset": "7"},
2334                 4: {"mode": "strict", "nodeset": "6"},
2335             },
2336         }
2337         self.assertEqual(
2338             {
2339                 "definition": True,
2340                 "disk": {"attached": [], "detached": [], "updated": []},
2341                 "interface": {"attached": [], "detached": []},
2342             },
2343             virt.update("vm_with_numatune_param", numatune=numatune_mem_none),
2344         )
2345         setxml = ET.fromstring(define_mock.call_args[0][0])
2346         self.assertEqual(setxml.find("numatune").find("memory"), None)
2347         self.assertEqual(
2348             setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("mode"), "strict"
2349         )
2350         self.assertEqual(
2351             setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("nodeset"), "4"
2352         )
2353         self.assertEqual(
2354             setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("mode"),
2355             "preferred",
2356         )
2357         self.assertEqual(
2358             setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("nodeset"), "7"
2359         )
2360         self.assertEqual(setxml.find("./numatune/memnode/[@cellid='2']"), None)
2361         numatune_mnodes_none = {
2362             "memory": {"mode": "preferred", "nodeset": "0-5"},
2363             "memnodes": None,
2364         }
2365         self.assertEqual(
2366             {
2367                 "definition": True,
2368                 "disk": {"attached": [], "detached": [], "updated": []},
2369                 "interface": {"attached": [], "detached": []},
2370             },
2371             virt.update("vm_with_numatune_param", numatune=numatune_mnodes_none),
2372         )
2373         setxml = ET.fromstring(define_mock.call_args[0][0])
2374         self.assertEqual(
2375             setxml.find("numatune").find("memory").attrib.get("mode"), "preferred"
2376         )
2377         self.assertEqual(
2378             setxml.find("numatune").find("memory").attrib.get("nodeset"),
2379             ",".join([str(i) for i in range(0, 6)]),
2380         )
2381         self.assertEqual(setxml.find("./numatune/memnode"), None)
2382         numatune_without_change = {
2383             "memory": {"mode": "strict", "nodeset": "0-5,6,7-11"},
2384             "memnodes": {
2385                 1: {"mode": "strict", "nodeset": "3"},
2386                 3: {"mode": "preferred", "nodeset": "7"},
2387             },
2388         }
2389         self.assertEqual(
2390             {
2391                 "definition": False,
2392                 "disk": {"attached": [], "detached": [], "updated": []},
2393                 "interface": {"attached": [], "detached": []},
2394             },
2395             virt.update("vm_with_numatune_param", numatune=numatune_without_change),
2396         )
2397         self.assertEqual(
2398             {
2399                 "definition": True,
2400                 "disk": {"attached": [], "detached": [], "updated": []},
2401                 "interface": {"attached": [], "detached": []},
2402             },
2403             virt.update(
2404                 "vm_with_numatune_param", numatune={"memory": None, "memnodes": None}
2405             ),
2406         )
2407         setxml = ET.fromstring(define_mock.call_args[0][0])
2408         self.assertEqual(setxml.find("numatune"), None)
2409     def test_update_existing_cpu_params(self):
2410         xml_with_existing_params = """
2411             &lt;domain type='kvm' id='8'&gt;
2412               &lt;name&gt;vm_with_boot_param&lt;/name&gt;
2413               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
2414               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
2415               &lt;vcpu placement="static" cpuset="0-11" current="3"&gt;6&lt;/vcpu&gt;
2416               &lt;vcpus&gt;
2417                 &lt;vcpu id="0" enabled="yes" hotpluggable="no" order="1"/&gt;
2418                 &lt;vcpu id="1" enabled="no" hotpluggable="yes"/&gt;
2419                 &lt;vcpu id="2" enabled="no" hotpluggable="yes"/&gt;
2420                 &lt;vcpu id="3" enabled="no" hotpluggable="yes"/&gt;
2421                 &lt;vcpu id="4" enabled="no" hotpluggable="yes"/&gt;
2422                 &lt;vcpu id="5" enabled="no" hotpluggable="yes"/&gt;
2423                 &lt;vcpu id="6" enabled="no" hotpluggable="yes"/&gt;
2424                 &lt;vcpu id="7" enabled="no" hotpluggable="yes"/&gt;
2425                 &lt;vcpu id="8" enabled="no" hotpluggable="yes"/&gt;
2426                 &lt;vcpu id="9" enabled="no" hotpluggable="yes"/&gt;
2427                 &lt;vcpu id="10" enabled="no" hotpluggable="yes"/&gt;
2428                 &lt;vcpu id="11" enabled="no" hotpluggable="yes"/&gt;
2429               &lt;/vcpus&gt;
2430               &lt;cpu mode="custom" match="exact" check="full"&gt;
2431                  &lt;model fallback="allow" vendor_id="Genuine20201"&gt;core2duo&lt;/model&gt;
2432                  &lt;vendor&gt;Intel&lt;/vendor&gt;
2433                  &lt;topology sockets="2" cores="5" threads="2"/&gt;
2434                  &lt;cache level="3" mode="emulate"/&gt;
2435                  &lt;feature policy="optional" name="lahf_lm"/&gt;
2436                  &lt;feature policy="require" name="pcid"/&gt;
2437                  &lt;numa&gt;
2438                     &lt;cell id="0" cpus="0-3" memory="1073741824" unit="KiB" discard="no"&gt;
2439                         &lt;distances&gt;
2440                             &lt;sibling id="0" value="10"/&gt;
2441                             &lt;sibling id="1" value="21"/&gt;
2442                             &lt;sibling id="2" value="31"/&gt;
2443                             &lt;sibling id="3" value="41"/&gt;
2444                         &lt;/distances&gt;
2445                     &lt;/cell&gt;
2446                     &lt;cell id="1" cpus="4-6" memory="1073741824" unit="KiB" memAccess="private"&gt;
2447                         &lt;distances&gt;
2448                             &lt;sibling id="0" value="21"/&gt;
2449                             &lt;sibling id="1" value="10"/&gt;
2450                             &lt;sibling id="2" value="21"/&gt;
2451                             &lt;sibling id="3" value="31"/&gt;
2452                         &lt;/distances&gt;
2453                     &lt;/cell&gt;
2454                  &lt;/numa&gt;
2455               &lt;/cpu&gt;
2456               &lt;os&gt;
2457                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
2458               &lt;/os&gt;
2459               &lt;/domain&gt;
2460          """
2461         domain_mock = self.set_mock_vm(
2462             "vm_with_existing_param", xml_with_existing_params
2463         )
2464         domain_mock.OSType = MagicMock(return_value="hvm")
2465         define_mock = MagicMock(return_value=True)
2466         self.mock_conn.defineXML = define_mock
2467         setvcpus_mock = MagicMock(return_value=0)
2468         domain_mock.setVcpusFlags = setvcpus_mock
2469         cpu_attr = {"placement": "static", "cpuset": "0-5", "current": 3, "maximum": 5}
2470         self.assertEqual(
2471             {
2472                 "definition": True,
2473                 "cpu": True,
2474                 "disk": {"attached": [], "detached": [], "updated": []},
2475                 "interface": {"attached": [], "detached": []},
2476             },
2477             virt.update("vm_with_existing_param", cpu=cpu_attr),
2478         )
2479         setxml = ET.fromstring(define_mock.call_args[0][0])
2480         self.assertEqual(setxml.find("vcpu").text, "5")
2481         self.assertEqual(setxml.find("vcpu").attrib["placement"], "static")
2482         self.assertEqual(
2483             setxml.find("vcpu").attrib["cpuset"],
2484             ",".join([str(i) for i in range(0, 6)]),
2485         )
2486         self.assertEqual(setxml.find("vcpu").attrib["current"], "3")
2487         cpu_none = {"placement": "auto", "cpuset": None, "current": 2, "maximum": 5}
2488         self.assertEqual(
2489             {
2490                 "definition": True,
2491                 "cpu": True,
2492                 "disk": {"attached": [], "detached": [], "updated": []},
2493                 "interface": {"attached": [], "detached": []},
2494             },
2495             virt.update("vm_with_existing_param", cpu=cpu_none),
2496         )
2497         setxml = ET.fromstring(define_mock.call_args[0][0])
2498         self.assertEqual(setxml.find("vcpu").text, "5")
2499         self.assertEqual(setxml.find("vcpu").attrib["placement"], "auto")
2500         self.assertEqual(setxml.find("vcpu").attrib.get("cpuset"), None)
2501         self.assertEqual(setxml.find("vcpu").attrib.get("current"), "2")
2502         vcpus = {
2503             "vcpus": {
2504                 "0": {"enabled": False, "hotpluggable": True, "order": 5},
2505                 "3": {"enabled": True, "hotpluggable": False, "order": 3},
2506                 "7": {"enabled": True, "hotpluggable": False},
2507             }
2508         }
2509         self.assertEqual(
2510             {
2511                 "definition": True,
2512                 "disk": {"attached": [], "detached": [], "updated": []},
2513                 "interface": {"attached": [], "detached": []},
2514             },
2515             virt.update("vm_with_existing_param", cpu=vcpus),
2516         )
2517         setxml = ET.fromstring(define_mock.call_args[0][0])
2518         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']").attrib["id"], "0")
2519         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']").attrib["enabled"], "no")
2520         self.assertEqual(
2521             setxml.find("./vcpus/vcpu/[@id='0']").attrib["hotpluggable"], "yes"
2522         )
2523         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']").attrib["order"], "5")
2524         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["id"], "3")
2525         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["enabled"], "yes")
2526         self.assertEqual(
2527             setxml.find("./vcpus/vcpu/[@id='3']").attrib["hotpluggable"], "no"
2528         )
2529         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["order"], "3")
2530         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='7']").attrib["id"], "7")
2531         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='7']").attrib["enabled"], "yes")
2532         self.assertEqual(
2533             setxml.find("./vcpus/vcpu/[@id='7']").attrib["hotpluggable"], "no"
2534         )
2535         self.assertEqual(
2536             setxml.find("./vcpus/vcpu/[@id='7']").attrib.get("order"), None
2537         )
2538         ind_vcpu = {
2539             "vcpus": {"3": {"enabled": True, "hotpluggable": False, "order": None}}
2540         }
2541         self.assertEqual(
2542             {
2543                 "definition": True,
2544                 "disk": {"attached": [], "detached": [], "updated": []},
2545                 "interface": {"attached": [], "detached": []},
2546             },
2547             virt.update("vm_with_existing_param", cpu=ind_vcpu),
2548         )
2549         setxml = ET.fromstring(define_mock.call_args[0][0])
2550         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']"), None)
2551         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["enabled"], "yes")
2552         self.assertEqual(
2553             setxml.find("./vcpus/vcpu/[@id='3']").attrib["hotpluggable"], "no"
2554         )
2555         self.assertEqual(
2556             setxml.find("./vcpus/vcpu/[@id='3']").attrib.get("order"), None
2557         )
2558         vcpus_none = {"vcpus": None}
2559         self.assertEqual(
2560             {
2561                 "definition": True,
2562                 "disk": {"attached": [], "detached": [], "updated": []},
2563                 "interface": {"attached": [], "detached": []},
2564             },
2565             virt.update("vm_with_existing_param", cpu=vcpus_none),
2566         )
2567         setxml = ET.fromstring(define_mock.call_args[0][0])
2568         self.assertEqual(setxml.find("vcpus"), None)
2569         cpu_atr_none = {"match": None, "mode": None, "check": None}
2570         self.assertEqual(
2571             {
2572                 "definition": True,
2573                 "disk": {"attached": [], "detached": [], "updated": []},
2574                 "interface": {"attached": [], "detached": []},
2575             },
2576             virt.update("vm_with_existing_param", cpu=cpu_atr_none),
2577         )
2578         setxml = ET.fromstring(define_mock.call_args[0][0])
2579         self.assertEqual(setxml.find("cpu").attrib, {})
2580         cpu_atr_mn = {"match": None}
2581         self.assertEqual(
2582             {
2583                 "definition": True,
2584                 "disk": {"attached": [], "detached": [], "updated": []},
2585                 "interface": {"attached": [], "detached": []},
2586             },
2587             virt.update("vm_with_existing_param", cpu=cpu_atr_mn),
2588         )
2589         setxml = ET.fromstring(define_mock.call_args[0][0])
2590         self.assertEqual(setxml.find("cpu").attrib.get("match"), None)
2591         self.assertEqual(setxml.find("cpu").attrib.get("mode"), "custom")
2592         self.assertEqual(setxml.find("cpu").attrib.get("check"), "full")
2593         cpu_model_none = {"model": None}
2594         self.assertEqual(
2595             {
2596                 "definition": True,
2597                 "disk": {"attached": [], "detached": [], "updated": []},
2598                 "interface": {"attached": [], "detached": []},
2599             },
2600             virt.update("vm_with_existing_param", cpu=cpu_model_none),
2601         )
2602         setxml = ET.fromstring(define_mock.call_args[0][0])
2603         self.assertEqual(setxml.find("cpu").find("model"), None)
2604         cpu_model_atr_none = {
2605             "model": {"name": "coresolo", "fallback": "forbid", "vendor_id": None}
2606         }
2607         self.assertEqual(
2608             {
2609                 "definition": True,
2610                 "disk": {"attached": [], "detached": [], "updated": []},
2611                 "interface": {"attached": [], "detached": []},
2612             },
2613             virt.update("vm_with_existing_param", cpu=cpu_model_atr_none),
2614         )
2615         setxml = ET.fromstring(define_mock.call_args[0][0])
2616         self.assertEqual(setxml.find("cpu").find("model").attrib.get("vendor_id"), None)
2617         self.assertEqual(
2618             setxml.find("cpu").find("model").attrib.get("fallback"), "forbid"
2619         )
2620         self.assertEqual(setxml.find("cpu").find("model").text, "coresolo")
2621         cpu_model_atr = {
2622             "model": {
2623                 "name": "coresolo",
2624                 "fallback": "forbid",
2625                 "vendor_id": "AuthenticAMD",
2626             }
2627         }
2628         self.assertEqual(
2629             {
2630                 "definition": True,
2631                 "disk": {"attached": [], "detached": [], "updated": []},
2632                 "interface": {"attached": [], "detached": []},
2633             },
2634             virt.update("vm_with_existing_param", cpu=cpu_model_atr),
2635         )
2636         setxml = ET.fromstring(define_mock.call_args[0][0])
2637         self.assertEqual(
2638             setxml.find("cpu").find("model").attrib.get("fallback"), "forbid"
2639         )
2640         self.assertEqual(
2641             setxml.find("cpu").find("model").attrib.get("vendor_id"), "AuthenticAMD"
2642         )
2643         self.assertEqual(setxml.find("cpu").find("model").text, "coresolo")
2644         cpu_vendor = {"vendor": "AMD"}
2645         self.assertEqual(
2646             {
2647                 "definition": True,
2648                 "disk": {"attached": [], "detached": [], "updated": []},
2649                 "interface": {"attached": [], "detached": []},
2650             },
2651             virt.update("vm_with_existing_param", cpu=cpu_vendor),
2652         )
2653         setxml = ET.fromstring(define_mock.call_args[0][0])
2654         self.assertEqual(setxml.find("cpu").find("vendor").text, "AMD")
2655         cpu_vendor_none = {"vendor": None}
2656         self.assertEqual(
2657             {
2658                 "definition": True,
2659                 "disk": {"attached": [], "detached": [], "updated": []},
2660                 "interface": {"attached": [], "detached": []},
2661             },
2662             virt.update("vm_with_existing_param", cpu=cpu_vendor_none),
2663         )
2664         setxml = ET.fromstring(define_mock.call_args[0][0])
2665         self.assertEqual(setxml.find("cpu").find("vendor"), None)
2666         cpu_topology = {"topology": {"sockets": 1, "cores": 12, "threads": 1}}
2667         self.assertEqual(
2668             {
2669                 "definition": True,
2670                 "disk": {"attached": [], "detached": [], "updated": []},
2671                 "interface": {"attached": [], "detached": []},
2672             },
2673             virt.update("vm_with_existing_param", cpu=cpu_topology),
2674         )
2675         setxml = ET.fromstring(define_mock.call_args[0][0])
2676         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("sockets"), "1")
2677         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("cores"), "12")
2678         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("threads"), "1")
2679         cpu_topology_atr_none = {
2680             "topology": {"sockets": None, "cores": 12, "threads": 1}
2681         }
2682         self.assertEqual(
2683             {
2684                 "definition": True,
2685                 "disk": {"attached": [], "detached": [], "updated": []},
2686                 "interface": {"attached": [], "detached": []},
2687             },
2688             virt.update("vm_with_existing_param", cpu=cpu_topology_atr_none),
2689         )
2690         setxml = ET.fromstring(define_mock.call_args[0][0])
2691         self.assertEqual(
2692             setxml.find("cpu").find("topology").attrib.get("sockets"), None
2693         )
2694         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("cores"), "12")
2695         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("threads"), "1")
2696         cpu_topology_none = {"topology": None}
2697         self.assertEqual(
2698             {
2699                 "definition": True,
2700                 "disk": {"attached": [], "detached": [], "updated": []},
2701                 "interface": {"attached": [], "detached": []},
2702             },
2703             virt.update("vm_with_existing_param", cpu=cpu_topology_none),
2704         )
2705         setxml = ET.fromstring(define_mock.call_args[0][0])
2706         self.assertEqual(setxml.find("cpu").find("topology"), None)
2707         cpu_cache = {"cache": {"mode": "passthrough", "level": 2}}
2708         self.assertEqual(
2709             {
2710                 "definition": True,
2711                 "disk": {"attached": [], "detached": [], "updated": []},
2712                 "interface": {"attached": [], "detached": []},
2713             },
2714             virt.update("vm_with_existing_param", cpu=cpu_cache),
2715         )
2716         setxml = ET.fromstring(define_mock.call_args[0][0])
2717         self.assertEqual(setxml.find("cpu").find("cache").attrib.get("level"), "2")
2718         self.assertEqual(
2719             setxml.find("cpu").find("cache").attrib.get("mode"), "passthrough"
2720         )
2721         cpu_cache_atr_none = {"cache": {"mode": "passthrough", "level": None}}
2722         self.assertEqual(
2723             {
2724                 "definition": True,
2725                 "disk": {"attached": [], "detached": [], "updated": []},
2726                 "interface": {"attached": [], "detached": []},
2727             },
2728             virt.update("vm_with_existing_param", cpu=cpu_cache_atr_none),
2729         )
2730         setxml = ET.fromstring(define_mock.call_args[0][0])
2731         self.assertEqual(setxml.find("cpu").find("cache").attrib.get("level"), None)
2732         self.assertEqual(
2733             setxml.find("cpu").find("cache").attrib.get("mode"), "passthrough"
2734         )
2735         cpu_cache_none = {"cache": None}
2736         self.assertEqual(
2737             {
2738                 "definition": True,
2739                 "disk": {"attached": [], "detached": [], "updated": []},
2740                 "interface": {"attached": [], "detached": []},
2741             },
2742             virt.update("vm_with_existing_param", cpu=cpu_cache_none),
2743         )
2744         setxml = ET.fromstring(define_mock.call_args[0][0])
2745         self.assertEqual(setxml.find("cpu").find("cache"), None)
2746         cpu_feature = {"features": {"lahf_lm": "require", "pcid": "optional"}}
2747         self.assertEqual(
2748             {
2749                 "definition": True,
2750                 "disk": {"attached": [], "detached": [], "updated": []},
2751                 "interface": {"attached": [], "detached": []},
2752             },
2753             virt.update("vm_with_existing_param", cpu=cpu_feature),
2754         )
2755         setxml = ET.fromstring(define_mock.call_args[0][0])
2756         self.assertEqual(
2757             setxml.find("./cpu/feature[@name='pcid']").attrib.get("policy"), "optional"
2758         )
2759         self.assertEqual(
2760             setxml.find("./cpu/feature[@name='lahf_lm']").attrib.get("policy"),
2761             "require",
2762         )
2763         cpu_feature_atr_none = {"features": {"pcid": "optional", "lahf_lm": "disable"}}
2764         self.assertEqual(
2765             {
2766                 "definition": True,
2767                 "disk": {"attached": [], "detached": [], "updated": []},
2768                 "interface": {"attached": [], "detached": []},
2769             },
2770             virt.update("vm_with_existing_param", cpu=cpu_feature_atr_none),
2771         )
2772         setxml = ET.fromstring(define_mock.call_args[0][0])
2773         self.assertEqual(
2774             setxml.find("./cpu/feature[@name='lahf_lm']").attrib.get("policy"),
2775             "disable",
2776         )
2777         self.assertEqual(
2778             setxml.find("./cpu/feature[@name='pcid']").attrib.get("policy"), "optional"
2779         )
2780         cpu_feature_none = {"features": {"lahf_lm": None, "pcid": None}}
2781         self.assertEqual(
2782             {
2783                 "definition": True,
2784                 "disk": {"attached": [], "detached": [], "updated": []},
2785                 "interface": {"attached": [], "detached": []},
2786             },
2787             virt.update("vm_with_existing_param", cpu=cpu_feature_none),
2788         )
2789         setxml = ET.fromstring(define_mock.call_args[0][0])
2790         self.assertEqual(setxml.find("./cpu/feature"), None)
2791         numa_cell = {
2792             "numa": {
2793                 0: {
2794                     "cpus": "0-6",
2795                     "memory": "512m",
2796                     "discard": True,
2797                     "distances": {0: 15, 1: 16, 2: 17, 3: 18},
2798                 },
2799                 1: {
2800                     "cpus": "7-12",
2801                     "memory": "2g",
2802                     "discard": True,
2803                     "memAccess": "shared",
2804                     "distances": {0: 23, 1: 24, 2: 25, 3: 26},
2805                 },
2806             }
2807         }
2808         self.assertEqual(
2809             {
2810                 "definition": True,
2811                 "disk": {"attached": [], "detached": [], "updated": []},
2812                 "interface": {"attached": [], "detached": []},
2813             },
2814             virt.update("vm_with_existing_param", cpu=numa_cell),
2815         )
2816         setxml = ET.fromstring(define_mock.call_args[0][0])
2817         self.assertEqual(
2818             setxml.find("./cpu/numa/cell/[@id='0']").attrib["cpus"],
2819             ",".join([str(i) for i in range(0, 7)]),
2820         )
2821         self.assertEqual(
2822             setxml.find("./cpu/numa/cell/[@id='0']").attrib["memory"],
2823             str(512 * 1024 ** 2),
2824         )
2825         self.assertEqual(
2826             setxml.find("./cpu/numa/cell/[@id='0']").get("unit"),
2827             "bytes",
2828         )
2829         self.assertEqual(
2830             setxml.find("./cpu/numa/cell/[@id='0']").attrib["discard"], "yes"
2831         )
2832         self.assertEqual(
2833             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='0']").attrib[
2834                 "value"
2835             ],
2836             "15",
2837         )
2838         self.assertEqual(
2839             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='1']").attrib[
2840                 "value"
2841             ],
2842             "16",
2843         )
2844         self.assertEqual(
2845             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='2']").attrib[
2846                 "value"
2847             ],
2848             "17",
2849         )
2850         self.assertEqual(
2851             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='3']").attrib[
2852                 "value"
2853             ],
2854             "18",
2855         )
2856         self.assertEqual(
2857             setxml.find("./cpu/numa/cell/[@id='1']").attrib["cpus"],
2858             ",".join([str(i) for i in range(7, 13)]),
2859         )
2860         self.assertEqual(
2861             setxml.find("./cpu/numa/cell/[@id='1']").attrib["memory"],
2862             str(int(2 * 1024 ** 3)),
2863         )
2864         self.assertEqual(
2865             setxml.find("./cpu/numa/cell/[@id='1']").get("unit"),
2866             "bytes",
2867         )
2868         self.assertEqual(
2869             setxml.find("./cpu/numa/cell/[@id='1']").attrib["discard"], "yes"
2870         )
2871         self.assertEqual(
2872             setxml.find("./cpu/numa/cell/[@id='1']").attrib["memAccess"], "shared"
2873         )
2874         self.assertEqual(
2875             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='0']").attrib[
2876                 "value"
2877             ],
2878             "23",
2879         )
2880         self.assertEqual(
2881             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='1']").attrib[
2882                 "value"
2883             ],
2884             "24",
2885         )
2886         self.assertEqual(
2887             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='2']").attrib[
2888                 "value"
2889             ],
2890             "25",
2891         )
2892         self.assertEqual(
2893             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='3']").attrib[
2894                 "value"
2895             ],
2896             "26",
2897         )
2898         numa_cell_atr_none = {
2899             "numa": {
2900                 "0": {
2901                     "cpus": "0-6",
2902                     "memory": "512m",
2903                     "discard": False,
2904                     "distances": {0: 15, 2: 17, 3: 18},
2905                 },
2906                 "1": {
2907                     "cpus": "7-12",
2908                     "memory": "2g",
2909                     "discard": True,
2910                     "distances": {0: 23, 1: 24, 2: 25},
2911                 },
2912             }
2913         }
2914         self.assertEqual(
2915             {
2916                 "definition": True,
2917                 "disk": {"attached": [], "detached": [], "updated": []},
2918                 "interface": {"attached": [], "detached": []},
2919             },
2920             virt.update("vm_with_existing_param", cpu=numa_cell_atr_none),
2921         )
2922         setxml = ET.fromstring(define_mock.call_args[0][0])
2923         self.assertEqual(
2924             setxml.find("./cpu/numa/cell/[@id='0']").attrib["cpus"],
2925             ",".join([str(i) for i in range(0, 7)]),
2926         )
2927         self.assertEqual(
2928             setxml.find("./cpu/numa/cell/[@id='0']").attrib["memory"],
2929             str(512 * 1024 ** 2),
2930         )
2931         self.assertEqual(
2932             setxml.find("./cpu/numa/cell/[@id='0']").get("unit"),
2933             "bytes",
2934         )
2935         self.assertEqual(
2936             setxml.find("./cpu/numa/cell/[@id='0']").attrib.get("discard"), "no"
2937         )
2938         self.assertEqual(
2939             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='0']").attrib[
2940                 "value"
2941             ],
2942             "15",
2943         )
2944         self.assertEqual(
2945             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='1']"), None
2946         )
2947         self.assertEqual(
2948             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='2']").attrib[
2949                 "value"
2950             ],
2951             "17",
2952         )
2953         self.assertEqual(
2954             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='3']").attrib[
2955                 "value"
2956             ],
2957             "18",
2958         )
2959         self.assertEqual(
2960             setxml.find("./cpu/numa/cell/[@id='1']").attrib["cpus"],
2961             ",".join([str(i) for i in range(7, 13)]),
2962         )
2963         self.assertEqual(
2964             setxml.find("./cpu/numa/cell/[@id='1']").attrib["memory"],
2965             str(int(2 * 1024 ** 3)),
2966         )
2967         self.assertEqual(
2968             setxml.find("./cpu/numa/cell/[@id='1']").attrib["discard"], "yes"
2969         )
2970         self.assertEqual(
2971             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='0']").attrib[
2972                 "value"
2973             ],
2974             "23",
2975         )
2976         self.assertEqual(
2977             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='1']").attrib[
2978                 "value"
2979             ],
2980             "24",
2981         )
2982         self.assertEqual(
2983             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='2']").attrib[
2984                 "value"
2985             ],
2986             "25",
2987         )
2988         self.assertEqual(
2989             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='3']"), None
2990         )
2991         self.assertEqual(
2992             setxml.find("./cpu/numa/cell/[@id='1']").attrib["cpus"],
2993             ",".join([str(i) for i in range(7, 13)]),
2994         )
2995         self.assertEqual(
2996             setxml.find("./cpu/numa/cell/[@id='1']").attrib["memory"],
2997             str(int(1024 ** 3 * 2)),
2998         )
2999         self.assertEqual(
3000             setxml.find("./cpu/numa/cell/[@id='1']").attrib["discard"], "yes"
3001         )
3002         self.assertEqual(
3003             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='0']").attrib[
3004                 "value"
3005             ],
3006             "23",
3007         )
3008         self.assertEqual(
3009             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='1']").attrib[
3010                 "value"
3011             ],
3012             "24",
3013         )
3014         self.assertEqual(
3015             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='2']").attrib[
3016                 "value"
3017             ],
3018             "25",
3019         )
3020         self.assertEqual(
3021             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='3']"),
3022             None,
3023         )
3024     def test_update_memtune_params(self):
3025         xml_with_memtune_params = """
3026             &lt;domain type='kvm' id='8'&gt;
3027               &lt;name&gt;vm_with_boot_param&lt;/name&gt;
3028               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
3029               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
3030               &lt;maxMemory slots="12" unit="bytes"&gt;1048576&lt;/maxMemory&gt;
3031               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
3032               &lt;memtune&gt;
3033                 &lt;hard_limit unit="KiB"&gt;1048576&lt;/hard_limit&gt;
3034                 &lt;soft_limit unit="KiB"&gt;2097152&lt;/soft_limit&gt;
3035                 &lt;swap_hard_limit unit="KiB"&gt;2621440&lt;/swap_hard_limit&gt;
3036                 &lt;min_guarantee unit='KiB'&gt;671088&lt;/min_guarantee&gt;
3037               &lt;/memtune&gt;
3038               &lt;os&gt;
3039                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
3040               &lt;/os&gt;
3041             &lt;/domain&gt;
3042         """
3043         domain_mock = self.set_mock_vm("vm_with_memtune_param", xml_with_memtune_params)
3044         domain_mock.OSType = MagicMock(return_value="hvm")
3045         define_mock = MagicMock(return_value=True)
3046         self.mock_conn.defineXML = define_mock
3047         memtune_new_val = {
3048             "boot": "0.7g",
3049             "current": "2.5g",
3050             "max": "3096m",
3051             "slots": "10",
3052             "soft_limit": "2048m",
3053             "hard_limit": "1024",
3054             "swap_hard_limit": "2.5g",
3055             "min_guarantee": "1 g",
3056         }
3057         domain_mock.setMemoryFlags.return_value = 0
3058         self.assertEqual(
3059             {
3060                 "definition": True,
3061                 "disk": {"attached": [], "detached": [], "updated": []},
3062                 "interface": {"attached": [], "detached": []},
3063                 "mem": True,
3064             },
3065             virt.update("vm_with_memtune_param", mem=memtune_new_val),
3066         )
3067         self.assertEqual(
3068             domain_mock.setMemoryFlags.call_args[0][0], int(2.5 * 1024 ** 2)
3069         )
3070         setxml = ET.fromstring(define_mock.call_args[0][0])
3071         self.assertEqual(
3072             setxml.find("memtune").find("soft_limit").text, str(2048 * 1024)
3073         )
3074         self.assertEqual(
3075             setxml.find("memtune").find("hard_limit").text, str(1024 * 1024)
3076         )
3077         self.assertEqual(
3078             setxml.find("memtune").find("swap_hard_limit").text,
3079             str(int(2.5 * 1024 ** 2)),
3080         )
3081         self.assertEqual(
3082             setxml.find("memtune").find("swap_hard_limit").get("unit"),
3083             "KiB",
3084         )
3085         self.assertEqual(
3086             setxml.find("memtune").find("min_guarantee").text, str(1 * 1024 ** 3)
3087         )
3088         self.assertEqual(
3089             setxml.find("memtune").find("min_guarantee").attrib.get("unit"), "bytes"
3090         )
3091         self.assertEqual(setxml.find("maxMemory").text, str(3096 * 1024 ** 2))
3092         self.assertEqual(setxml.find("maxMemory").attrib.get("slots"), "10")
3093         self.assertEqual(setxml.find("currentMemory").text, str(int(2.5 * 1024 ** 3)))
3094         self.assertEqual(setxml.find("memory").text, str(int(0.7 * 1024 ** 3)))
3095         max_slot_reverse = {
3096             "slots": "10",
3097             "max": "3096m",
3098         }
3099         self.assertEqual(
3100             {
3101                 "definition": True,
3102                 "disk": {"attached": [], "detached": [], "updated": []},
3103                 "interface": {"attached": [], "detached": []},
3104             },
3105             virt.update("vm_with_memtune_param", mem=max_slot_reverse),
3106         )
3107         setxml = ET.fromstring(define_mock.call_args[0][0])
3108         self.assertEqual(setxml.find("maxMemory").text, str(3096 * 1024 ** 2))
3109         self.assertEqual(setxml.find("maxMemory").get("unit"), "bytes")
3110         self.assertEqual(setxml.find("maxMemory").attrib.get("slots"), "10")
3111         max_swap_none = {
3112             "boot": "0.7g",
3113             "current": "2.5g",
3114             "max": None,
3115             "slots": "10",
3116             "soft_limit": "2048m",
3117             "hard_limit": "1024",
3118             "swap_hard_limit": None,
3119             "min_guarantee": "1 g",
3120         }
3121         domain_mock.setMemoryFlags.reset_mock()
3122         self.assertEqual(
3123             {
3124                 "definition": True,
3125                 "disk": {"attached": [], "detached": [], "updated": []},
3126                 "interface": {"attached": [], "detached": []},
3127                 "mem": True,
3128             },
3129             virt.update("vm_with_memtune_param", mem=max_swap_none),
3130         )
3131         self.assertEqual(
3132             domain_mock.setMemoryFlags.call_args[0][0], int(2.5 * 1024 ** 2)
3133         )
3134         setxml = ET.fromstring(define_mock.call_args[0][0])
3135         self.assertEqual(
3136             setxml.find("memtune").find("soft_limit").text, str(2048 * 1024)
3137         )
3138         self.assertEqual(
3139             setxml.find("memtune").find("hard_limit").text, str(1024 * 1024)
3140         )
3141         self.assertEqual(setxml.find("memtune").find("swap_hard_limit"), None)
3142         self.assertEqual(
3143             setxml.find("memtune").find("min_guarantee").text, str(1 * 1024 ** 3)
3144         )
3145         self.assertEqual(
3146             setxml.find("memtune").find("min_guarantee").attrib.get("unit"), "bytes"
3147         )
3148         self.assertEqual(setxml.find("maxMemory").text, None)
3149         self.assertEqual(setxml.find("currentMemory").text, str(int(2.5 * 1024 ** 3)))
3150         self.assertEqual(setxml.find("memory").text, str(int(0.7 * 1024 ** 3)))
3151         memtune_none = {
3152             "soft_limit": None,
3153             "hard_limit": None,
3154             "swap_hard_limit": None,
3155             "min_guarantee": None,
3156         }
3157         self.assertEqual(
3158             {
3159                 "definition": True,
3160                 "disk": {"attached": [], "detached": [], "updated": []},
3161                 "interface": {"attached": [], "detached": []},
3162             },
3163             virt.update("vm_with_memtune_param", mem=memtune_none),
3164         )
3165         setxml = ET.fromstring(define_mock.call_args[0][0])
3166         self.assertEqual(setxml.find("memtune").find("soft_limit"), None)
3167         self.assertEqual(setxml.find("memtune").find("hard_limit"), None)
3168         self.assertEqual(setxml.find("memtune").find("swap_hard_limit"), None)
3169         self.assertEqual(setxml.find("memtune").find("min_guarantee"), None)
3170         max_none = {
3171             "max": None,
3172         }
3173         self.assertEqual(
3174             {
3175                 "definition": True,
3176                 "disk": {"attached": [], "detached": [], "updated": []},
3177                 "interface": {"attached": [], "detached": []},
3178             },
3179             virt.update("vm_with_memtune_param", mem=max_none),
3180         )
3181         setxml = ET.fromstring(define_mock.call_args[0][0])
3182         self.assertEqual(setxml.find("maxMemory"), None)
3183         self.assertEqual(setxml.find("currentMemory").text, str(int(1 * 1024 ** 2)))
3184         self.assertEqual(setxml.find("memory").text, str(int(1 * 1024 ** 2)))
3185     def test_update_exist_memorybacking_params(self):
3186         xml_with_memback_params = """
3187             &lt;domain type='kvm' id='8'&gt;
3188               &lt;name&gt;vm_with_memback_param&lt;/name&gt;
3189               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
3190               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
3191               &lt;maxMemory slots="12" unit="KiB"&gt;1048576&lt;/maxMemory&gt;
3192               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
3193               &lt;memoryBacking&gt;
3194                 &lt;hugepages&gt;
3195                   &lt;page size="2048" unit="KiB"/&gt;
3196                   &lt;page size="3145728" nodeset="1-4,^3" unit="KiB"/&gt;
3197                   &lt;page size="1048576" nodeset="3" unit="KiB"/&gt;
3198                 &lt;/hugepages&gt;
3199                 &lt;nosharepages/&gt;
3200                 &lt;locked/&gt;
3201                 &lt;source type="file"/&gt;
3202                 &lt;access mode="shared"/&gt;
3203                 &lt;discard/&gt;
3204               &lt;/memoryBacking&gt;
3205               &lt;os&gt;
3206                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
3207               &lt;/os&gt;
3208               &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
3209             &lt;/domain&gt;
3210         """
3211         domain_mock = self.set_mock_vm("vm_with_memback_param", xml_with_memback_params)
3212         domain_mock.OSType = MagicMock(return_value="hvm")
3213         define_mock = MagicMock(return_value=True)
3214         self.mock_conn.defineXML = define_mock
3215         mem_back_param = {
3216             "hugepages": [
3217                 {"nodeset": "1-4,^3", "size": "1g"},
3218                 {"nodeset": "3", "size": "2g"},
3219             ],
3220             "nosharepages": None,
3221             "locked": None,
3222             "source": "anonymous",
3223             "access": "private",
3224             "allocation": "ondemand",
3225             "discard": None,
3226         }
3227         self.assertEqual(
3228             {
3229                 "definition": True,
3230                 "disk": {"attached": [], "detached": [], "updated": []},
3231                 "interface": {"attached": [], "detached": []},
3232             },
3233             virt.update("vm_with_memback_param", mem=mem_back_param),
3234         )
3235         setxml = ET.fromstring(define_mock.call_args[0][0])
3236         self.assertDictEqual(
3237             {
3238                 p.get("nodeset"): {"size": p.get("size"), "unit": p.get("unit")}
3239                 for p in setxml.findall("memoryBacking/hugepages/page")
3240             },
3241             {
3242                 "1,2,4": {"size": str(1024 ** 3), "unit": "bytes"},
3243                 "3": {"size": str(2 * 1024 ** 3), "unit": "bytes"},
3244             },
3245         )
3246         self.assertEqual(setxml.find("./memoryBacking/nosharepages"), None)
3247         self.assertEqual(setxml.find("./memoryBacking/locked"), None)
3248         self.assertEqual(
3249             setxml.find("./memoryBacking/source").attrib["type"], "anonymous"
3250         )
3251         self.assertEqual(
3252             setxml.find("./memoryBacking/access").attrib["mode"], "private"
3253         )
3254         self.assertEqual(
3255             setxml.find("./memoryBacking/allocation").attrib["mode"], "ondemand"
3256         )
3257         self.assertEqual(setxml.find("./memoryBacking/discard"), None)
3258         unchanged_page = {
3259             "hugepages": [
3260                 {"size": "2m"},
3261                 {"nodeset": "1-4,^3", "size": "3g"},
3262                 {"nodeset": "3", "size": "1g"},
3263             ],
3264         }
3265         self.assertEqual(
3266             {
3267                 "definition": False,
3268                 "disk": {"attached": [], "detached": [], "updated": []},
3269                 "interface": {"attached": [], "detached": []},
3270             },
3271             virt.update("vm_with_memback_param", mem=unchanged_page),
3272         )
3273     def test_update_iothreads_params(self):
3274         xml_with_iothreads_params = """
3275             &lt;domain type='kvm' id='8'&gt;
3276               &lt;name&gt;xml_with_iothreads_params&lt;/name&gt;
3277               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
3278               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
3279               &lt;maxMemory slots="12" unit="KiB"&gt;1048576&lt;/maxMemory&gt;
3280               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
3281               &lt;iothreads&gt;6&lt;/iothreads&gt;
3282               &lt;os&gt;
3283                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
3284               &lt;/os&gt;
3285             &lt;/domain&gt;
3286         """
3287         domain_mock = self.set_mock_vm(
3288             "xml_with_iothreads_params", xml_with_iothreads_params
3289         )
3290         domain_mock.OSType = MagicMock(return_value="hvm")
3291         define_mock = MagicMock(return_value=True)
3292         self.mock_conn.defineXML = define_mock
3293         self.assertEqual(
3294             {
3295                 "definition": True,
3296                 "disk": {"attached": [], "detached": [], "updated": []},
3297                 "interface": {"attached": [], "detached": []},
3298             },
3299             virt.update("xml_with_iothreads_params", cpu={"iothreads": 7}),
3300         )
3301         setxml = ET.fromstring(define_mock.call_args[0][0])
3302         self.assertEqual(setxml.find("iothreads").text, "7")
3303     def test_update_cputune_paramters(self):
3304         xml_with_cputune_params = """
3305                     &lt;domain type='kvm' id='8'&gt;
3306                       &lt;name&gt;xml_with_cputune_params&lt;/name&gt;
3307                       &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
3308                       &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
3309                       &lt;maxMemory slots="12" unit="KiB"&gt;1048576&lt;/maxMemory&gt;
3310                       &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
3311                       &lt;iothreads&gt;4&lt;/iothreads&gt;
3312                       &lt;cputune&gt;
3313                         &lt;shares&gt;2048&lt;/shares&gt;
3314                         &lt;period&gt;1000000&lt;/period&gt;
3315                         &lt;quota&gt;-1&lt;/quota&gt;
3316                         &lt;global_period&gt;1000000&lt;/global_period&gt;
3317                         &lt;global_quota&gt;-1&lt;/global_quota&gt;
3318                         &lt;emulator_period&gt;1000000&lt;/emulator_period&gt;
3319                         &lt;emulator_quota&gt;-1&lt;/emulator_quota&gt;
3320                         &lt;iothread_period&gt;1000000&lt;/iothread_period&gt;
3321                         &lt;iothread_quota&gt;-1&lt;/iothread_quota&gt;
3322                         &lt;vcpupin vcpu="0" cpuset="0-2"/&gt;
3323                         &lt;vcpupin vcpu="1" cpuset="3"/&gt;
3324                         &lt;vcpupin vcpu="2" cpuset="4"/&gt;
3325                         &lt;vcpupin vcpu="3" cpuset="5-7"/&gt;
3326                         &lt;emulatorpin cpuset="1-2"/&gt;
3327                         &lt;iothreadpin iothread="1" cpuset="1-5"/&gt;
3328                         &lt;iothreadpin iothread="2" cpuset="6-7"/&gt;
3329                         &lt;vcpusched vcpus="0" scheduler="idle" priority="3"/&gt;
3330                         &lt;vcpusched vcpus="1" scheduler="rr" priority="1"/&gt;
3331                         &lt;vcpusched vcpus="2" scheduler="fifo" priority="2"/&gt;
3332                         &lt;iothreadsched iothreads="4" scheduler="fifo"/&gt;
3333                         &lt;emulatorsched scheduler="idle"/&gt;
3334                         &lt;cachetune vcpus="0-4"&gt;
3335                           &lt;cache id="0" level="2" type="both" size="4" unit="KiB"/&gt;
3336                           &lt;cache id="1" level="2" type="both" size="4" unit="KiB"/&gt;
3337                           &lt;monitor level="5" vcpus="0-2"/&gt;
3338                           &lt;monitor level="6" vcpus="1-3"/&gt;
3339                         &lt;/cachetune&gt;
3340                         &lt;cachetune vcpus="5-8"&gt;
3341                           &lt;monitor level="5" vcpus="5-6"/&gt;
3342                           &lt;monitor level="3" vcpus="7-8"/&gt;
3343                         &lt;/cachetune&gt;
3344                         &lt;memorytune vcpus="0-6"&gt;
3345                           &lt;node id="0" bandwidth="45"/&gt;
3346                         &lt;/memorytune&gt;
3347                         &lt;memorytune vcpus="7-8"&gt;
3348                           &lt;node id="0" bandwidth="120"/&gt;
3349                         &lt;/memorytune&gt;
3350                       &lt;/cputune&gt;
3351                       &lt;os&gt;
3352                         &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
3353                       &lt;/os&gt;
3354                     &lt;/domain&gt;
3355                 """
3356         domain_mock = self.set_mock_vm(
3357             "xml_with_cputune_params", xml_with_cputune_params
3358         )
3359         domain_mock.OSType = MagicMock(return_value="hvm")
3360         define_mock = MagicMock(return_value=True)
3361         self.mock_conn.defineXML = define_mock
3362         cputune = {
3363             "shares": 1024,
3364             "period": 5000,
3365             "quota": -20,
3366             "global_period": 4000,
3367             "global_quota": -30,
3368             "emulator_period": 3000,
3369             "emulator_quota": -4,
3370             "iothread_period": 7000,
3371             "iothread_quota": -5,
3372             "vcpupin": {0: "1-4,^2", 1: "0,1", 2: "2,3", 3: "0,4"},
3373             "emulatorpin": "1-3",
3374             "iothreadpin": {1: "5-6", 2: "7-8"},
3375             "vcpusched": [
3376                 {"scheduler": "fifo", "priority": 1, "vcpus": "0"},
3377                 {"scheduler": "fifo", "priority": 2, "vcpus": "1"},
3378                 {"scheduler": "idle", "priority": 3, "vcpus": "2"},
3379             ],
3380             "iothreadsched": [
3381                 {"scheduler": "batch", "iothreads": "5-7", "priority": 1}
3382             ],
3383             "emulatorsched": {"scheduler": "rr", "priority": 2},
3384             "cachetune": {
3385                 "0-3": {
3386                     0: {"level": 3, "type": "both", "size": 3},
3387                     1: {"level": 3, "type": "both", "size": 3},
3388                     "monitor": {1: 3, "0-3": 3},
3389                 },
3390                 "4-5": {"monitor": {4: 3, 5: 2}},
3391             },
3392             "memorytune": {"0-2": {0: 60}, "3-4": {0: 50, 1: 70}},
3393         }
3394         self.assertEqual(
3395             {
3396                 "definition": True,
3397                 "disk": {"attached": [], "detached": [], "updated": []},
3398                 "interface": {"attached": [], "detached": []},
3399             },
3400             virt.update("xml_with_cputune_params", cpu={"tuning": cputune}),
3401         )
3402         setxml = ET.fromstring(define_mock.call_args[0][0])
3403         self.assertEqual(setxml.find("cputune").find("shares").text, "1024")
3404         self.assertEqual(setxml.find("cputune").find("period").text, "5000")
3405         self.assertEqual(setxml.find("cputune").find("quota").text, "-20")
3406         self.assertEqual(setxml.find("cputune").find("global_period").text, "4000")
3407         self.assertEqual(setxml.find("cputune").find("global_quota").text, "-30")
3408         self.assertEqual(setxml.find("cputune").find("emulator_period").text, "3000")
3409         self.assertEqual(setxml.find("cputune").find("emulator_quota").text, "-4")
3410         self.assertEqual(setxml.find("cputune").find("iothread_period").text, "7000")
3411         self.assertEqual(setxml.find("cputune").find("iothread_quota").text, "-5")
3412         self.assertEqual(
3413             setxml.find("cputune").find("vcpupin[@vcpu='0']").attrib.get("cpuset"),
3414             "1,3,4",
3415         )
3416         self.assertEqual(
3417             setxml.find("cputune").find("vcpupin[@vcpu='1']").attrib.get("cpuset"),
3418             "0,1",
3419         )
3420         self.assertEqual(
3421             setxml.find("cputune").find("vcpupin[@vcpu='2']").attrib.get("cpuset"),
3422             "2,3",
3423         )
3424         self.assertEqual(
3425             setxml.find("cputune").find("vcpupin[@vcpu='3']").attrib.get("cpuset"),
3426             "0,4",
3427         )
3428         self.assertEqual(
3429             setxml.find("cputune").find("emulatorpin").attrib.get("cpuset"), "1,2,3"
3430         )
3431         self.assertEqual(
3432             setxml.find("cputune")
3433             .find("iothreadpin[@iothread='1']")
3434             .attrib.get("cpuset"),
3435             "5,6",
3436         )
3437         self.assertEqual(
3438             setxml.find("cputune")
3439             .find("iothreadpin[@iothread='2']")
3440             .attrib.get("cpuset"),
3441             "7,8",
3442         )
3443         self.assertDictEqual(
3444             {
3445                 s.get("vcpus"): {
3446                     "scheduler": s.get("scheduler"),
3447                     "priority": s.get("priority"),
3448                 }
3449                 for s in setxml.findall("cputune/vcpusched")
3450             },
3451             {
3452                 "0": {"scheduler": "fifo", "priority": "1"},
3453                 "1": {"scheduler": "fifo", "priority": "2"},
3454                 "2": {"scheduler": "idle", "priority": "3"},
3455             },
3456         )
3457         self.assertDictEqual(
3458             {
3459                 s.get("iothreads"): {
3460                     "scheduler": s.get("scheduler"),
3461                     "priority": s.get("priority"),
3462                 }
3463                 for s in setxml.findall("cputune/iothreadsched")
3464             },
3465             {"5,6,7": {"scheduler": "batch", "priority": "1"}},
3466         )
3467         self.assertEqual(setxml.find("cputune/emulatorsched").get("scheduler"), "rr")
3468         self.assertEqual(setxml.find("cputune/emulatorsched").get("priority"), "2")
3469         self.assertIsNotNone(setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']"))
3470         self.assertEqual(
3471             setxml.find(
3472                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3473             ).attrib.get("level"),
3474             "3",
3475         )
3476         self.assertEqual(
3477             setxml.find(
3478                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3479             ).attrib.get("type"),
3480             "both",
3481         )
3482         self.assertEqual(
3483             setxml.find(
3484                 "./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='1']"
3485             ).attrib.get("level"),
3486             "3",
3487         )
3488         self.assertNotEqual(
3489             setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='1']"),
3490             None,
3491         )
3492         self.assertNotEqual(
3493             setxml.find("./cputune/cachetune[@vcpus='4,5']").attrib.get("vcpus"), None
3494         )
3495         self.assertEqual(
3496             setxml.find("./cputune/cachetune[@vcpus='4,5']/cache[@id='0']"), None
3497         )
3498         self.assertEqual(
3499             setxml.find(
3500                 "./cputune/cachetune[@vcpus='4,5']/monitor[@vcpus='4']"
3501             ).attrib.get("level"),
3502             "3",
3503         )
3504         self.assertEqual(
3505             setxml.find(
3506                 "./cputune/cachetune[@vcpus='4,5']/monitor[@vcpus='5']"
3507             ).attrib.get("level"),
3508             "2",
3509         )
3510         self.assertNotEqual(setxml.find("./cputune/memorytune[@vcpus='0,1,2']"), None)
3511         self.assertEqual(
3512             setxml.find(
3513                 "./cputune/memorytune[@vcpus='0,1,2']/node[@id='0']"
3514             ).attrib.get("bandwidth"),
3515             "60",
3516         )
3517         self.assertNotEqual(setxml.find("./cputune/memorytune[@vcpus='3,4']"), None)
3518         self.assertEqual(
3519             setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='0']").attrib.get(
3520                 "bandwidth"
3521             ),
3522             "50",
3523         )
3524         self.assertEqual(
3525             setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='1']").attrib.get(
3526                 "bandwidth"
3527             ),
3528             "70",
3529         )
3530         cputune = {
3531             "shares": None,
3532             "period": 20000,
3533             "quota": None,
3534             "global_period": 5000,
3535             "global_quota": None,
3536             "emulator_period": 2000,
3537             "emulator_quota": -4,
3538             "iothread_period": None,
3539             "iothread_quota": -5,
3540             "vcpupin": {0: "1-4,^2", 2: "2,4"},
3541             "emulatorpin": None,
3542             "iothreadpin": {1: "5-6"},
3543             "vcpusched": [{"scheduler": "idle", "priority": 5, "vcpus": "1"}],
3544             "iothreadsched": None,
3545             "cachetune": {
3546                 "0-3": {
3547                     0: {"level": 4, "type": "data", "size": 7},
3548                     "monitor": {"1-2": 11},
3549                 },
3550             },
3551             "memorytune": {"3-4": {0: 37, 1: 73}},
3552         }
3553         self.assertEqual(
3554             {
3555                 "definition": True,
3556                 "disk": {"attached": [], "detached": [], "updated": []},
3557                 "interface": {"attached": [], "detached": []},
3558             },
3559             virt.update("xml_with_cputune_params", cpu={"tuning": cputune}),
3560         )
3561         setxml = ET.fromstring(define_mock.call_args[0][0])
3562         self.assertEqual(setxml.find("cputune").find("shares"), None)
3563         self.assertEqual(setxml.find("cputune").find("period").text, "20000")
3564         self.assertEqual(setxml.find("cputune").find("quota"), None)
3565         self.assertEqual(setxml.find("cputune").find("global_period").text, "5000")
3566         self.assertEqual(setxml.find("cputune").find("global_quota"), None)
3567         self.assertEqual(setxml.find("cputune").find("emulator_period").text, "2000")
3568         self.assertEqual(setxml.find("cputune").find("emulator_quota").text, "-4")
3569         self.assertEqual(setxml.find("cputune").find("iothread_period"), None)
3570         self.assertEqual(setxml.find("cputune").find("iothread_quota").text, "-5")
3571         self.assertEqual(
3572             setxml.find("cputune").find("vcpupin[@vcpu='0']").attrib.get("cpuset"),
3573             "1,3,4",
3574         )
3575         self.assertEqual(setxml.find("cputune").find("vcpupin[@vcpu='1']"), None)
3576         self.assertEqual(
3577             setxml.find("cputune").find("vcpupin[@vcpu='2']").attrib.get("cpuset"),
3578             "2,4",
3579         )
3580         self.assertEqual(setxml.find("cputune").find("vcpupin[@vcpu='3']"), None)
3581         self.assertEqual(setxml.find("cputune").find("emulatorpin"), None)
3582         self.assertEqual(
3583             setxml.find("cputune")
3584             .find("iothreadpin[@iothread='1']")
3585             .attrib.get("cpuset"),
3586             "5,6",
3587         )
3588         self.assertEqual(
3589             setxml.find("cputune").find("iothreadpin[@iothread='2']"), None
3590         )
3591         self.assertDictEqual(
3592             {
3593                 s.get("vcpus"): {
3594                     "scheduler": s.get("scheduler"),
3595                     "priority": s.get("priority"),
3596                 }
3597                 for s in setxml.findall("cputune/vcpusched")
3598             },
3599             {"1": {"scheduler": "idle", "priority": "5"}},
3600         )
3601         self.assertEqual(setxml.find("cputune").find("iothreadsched"), None)
3602         self.assertIsNotNone(setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']"))
3603         self.assertEqual(
3604             setxml.find(
3605                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3606             ).attrib.get("size"),
3607             "7",
3608         )
3609         self.assertEqual(
3610             setxml.find(
3611                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3612             ).attrib.get("level"),
3613             "4",
3614         )
3615         self.assertEqual(
3616             setxml.find(
3617                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3618             ).attrib.get("type"),
3619             "data",
3620         )
3621         self.assertEqual(
3622             setxml.find(
3623                 "./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='1,2']"
3624             ).attrib.get("level"),
3625             "11",
3626         )
3627         self.assertEqual(
3628             setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='3,4']"),
3629             None,
3630         )
3631         self.assertEqual(
3632             setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='1']"), None
3633         )
3634         self.assertEqual(setxml.find("./cputune/cachetune[@vcpus='4,5']"), None)
3635         self.assertEqual(setxml.find("./cputune/memorytune[@vcpus='0,1,2']"), None)
3636         self.assertEqual(
3637             setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='0']").attrib.get(
3638                 "bandwidth"
3639             ),
3640             "37",
3641         )
3642         self.assertEqual(
3643             setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='1']").attrib.get(
3644                 "bandwidth"
3645             ),
3646             "73",
3647         )
3648         cputune_subelement = {
3649             "vcpupin": None,
3650             "iothreadpin": None,
3651             "vcpusched": None,
3652             "iothreadsched": None,
3653             "cachetune": None,
3654             "memorytune": None,
3655         }
3656         self.assertEqual(
3657             {
3658                 "definition": True,
3659                 "disk": {"attached": [], "detached": [], "updated": []},
3660                 "interface": {"attached": [], "detached": []},
3661             },
3662             virt.update("xml_with_cputune_params", cpu={"tuning": cputune_subelement}),
3663         )
3664         setxml = ET.fromstring(define_mock.call_args[0][0])
3665         self.assertEqual(setxml.find("cputune").find("vcpupin"), None)
3666         self.assertEqual(setxml.find("cputune").find("iothreadpin"), None)
3667         self.assertEqual(setxml.find("cputune").find("vcpusched"), None)
3668         self.assertEqual(setxml.find("cputune").find("iothreadsched"), None)
3669         self.assertEqual(setxml.find("cputune").find("cachetune"), None)
3670         self.assertEqual(setxml.find("cputune").find("memorytune"), None)
3671     def test_handle_unit(self):
3672         valid_case = [
3673             ("2", 2097152),
3674             ("42", 44040192),
3675             ("5b", 5),
3676             ("2.3Kib", 2355),
3677             ("5.8Kb", 5800),
3678             ("16MiB", 16777216),
3679             ("20 GB", 20000000000),
3680             ("16KB", 16000),
3681             (".5k", 512),
3682             ("2.k", 2048),
3683         ]
3684         for key, val in valid_case:
3685             self.assertEqual(virt._handle_unit(key), val)
3686         invalid_case = [
3687             ("9ib", "invalid units"),
3688             ("8byte", "invalid units"),
3689             ("512bytes", "invalid units"),
3690             ("4 Kbytes", "invalid units"),
3691             ("3.4.MB", "invalid number"),
3692             ("", "invalid number"),
3693             ("bytes", "invalid number"),
3694             ("2HB", "invalid units"),
3695         ]
3696         for key, val in invalid_case:
3697             with self.assertRaises(SaltInvocationError):
3698                 virt._handle_unit(key)
3699     def test_mixed_dict_and_list_as_profile_objects(self):
3700         yaml_config = """
3701           virt:
3702              nic:
3703                 new-listonly-profile:
3704                    - bridge: br0
3705                      name: eth0
3706                    - model: virtio
3707                      name: eth1
3708                      source: test_network
3709                      type: network
3710                 new-list-with-legacy-names:
3711                    - eth0:
3712                         bridge: br0
3713                    - eth1:
3714                         bridge: br1
3715                         model: virtio
3716                 non-default-legacy-profile:
3717                    eth0:
3718                       bridge: br0
3719                    eth1:
3720                       bridge: br1
3721                       model: virtio
3722         Test virt.get_xml()
3723         domain = self.set_mock_vm("test-vm", xml)
3724         self.assertEqual(xml, virt.get_xml("test-vm"))
3725         self.assertEqual(xml, virt.get_xml(domain))
3726     def test_get_loader(self):
3727         xml = """&lt;domain type='kvm' id='7'&gt;
3728               &lt;name&gt;test-vm&lt;/name&gt;
3729               &lt;os&gt;
3730                 &lt;loader readonly='yes' type='pflash'&gt;/foo/bar&lt;/loader&gt;
3731               &lt;/os&gt;
3732             &lt;/domain&gt;
3733         """
3734         self.set_mock_vm("test-vm", xml)
3735         loader = virt.get_loader("test-vm")
3736         self.assertEqual("/foo/bar", loader["path"])
3737         self.assertEqual("yes", loader["readonly"])
3738     def test_cpu_baseline(self):
3739         capabilities_xml = dedent(
3740         Make sure that qemu-img info output is properly parsed
3741         Test virt.purge() with default parameters
3742         self.set_mock_vm("test-vm", xml)
3743         qemu_infos = """[{
3744             "virtual-size": 25769803776,
3745             "filename": "/disks/test.qcow2",
3746             "cluster-size": 65536,
3747             "format": "qcow2",
3748             "actual-size": 217088,
3749             "format-specific": {
3750                 "type": "qcow2",
3751                 "data": {
3752                     "compat": "1.1",
3753                     "lazy-refcounts": false,
3754                     "refcount-bits": 16,
3755                     "corrupt": false
3756                 }
3757             },
3758             "dirty-flag": false
3759         }]"""
3760         self.mock_popen.communicate.return_value = [qemu_infos, ""]
3761         self.mock_popen.returncode = 0
3762         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
3763             res = virt.purge("test-vm")
3764             self.assertTrue(res)
3765             mock_remove.assert_called_once()
3766             mock_remove.assert_any_call("/disks/test.qcow2")
3767     @patch("salt.modules.virt.stop", return_value=True)
3768     @patch("salt.modules.virt.undefine")
3769     def test_purge_volumes(self, mock_undefine, mock_stop):
3770         xml = """&lt;domain type='kvm' id='7'&gt;
3771               &lt;name&gt;test-vm&lt;/name&gt;
3772               &lt;devices&gt;
3773                 &lt;disk type='volume' device='disk'&gt;
3774                   &lt;driver name='qemu' type='qcow2' cache='none' io='native'/&gt;
3775                   &lt;source pool='default' volume='vm05_system'/&gt;
3776                   &lt;backingStore type='file' index='1'&gt;
3777                     &lt;format type='qcow2'/&gt;
3778                     &lt;source file='/var/lib/libvirt/images/vm04_system.qcow2'/&gt;
3779                     &lt;backingStore type='file' index='2'&gt;
3780                       &lt;format type='qcow2'/&gt;
3781                       &lt;source file='/var/testsuite-data/disk-image-template.qcow2'/&gt;
3782                       &lt;backingStore/&gt;
3783                     &lt;/backingStore&gt;
3784                   &lt;/backingStore&gt;
3785                   &lt;target dev='vda' bus='virtio'/&gt;
3786                   &lt;alias name='virtio-disk0'/&gt;
3787                   &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x04' function='0x0'/&gt;
3788                 &lt;/disk&gt;
3789               &lt;/devices&gt;
3790             &lt;/domain&gt;
3791         """
3792         self.set_mock_vm("test-vm", xml)
3793         pool_mock = MagicMock()
3794         pool_mock.storageVolLookupByName.return_value.info.return_value = [
3795             0,
3796             1234567,
3797             12345,
3798         ]
3799         pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = [
3800         ]
3801         pool_mock.listVolumes.return_value = ["vm05_system", "vm04_system.qcow2"]
3802         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
3803         self.mock_conn.listStoragePools.return_value = ["default"]
3804         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=False)}):
3805             res = virt.purge("test-vm")
3806             self.assertTrue(res)
3807             pool_mock.storageVolLookupByName.return_value.delete.assert_called_once()
3808     @patch("salt.modules.virt.stop", return_value=True)
3809     @patch("salt.modules.virt.undefine")
3810     def test_purge_rbd(self, mock_undefine, mock_stop):
3811         xml = """&lt;domain type='kvm' id='7'&gt;
3812               &lt;name&gt;test-vm&lt;/name&gt;
3813               &lt;devices&gt;
3814                 &lt;disk type="network" device="disk"&gt;
3815                   &lt;driver name='raw' type='qcow2'/&gt;
3816                   &lt;source protocol='rbd' name='libvirt-pool/my_vm_data2'&gt;
3817                     &lt;host name='ses2.tf.local'/&gt;
3818                     &lt;host name='ses3.tf.local' port='1234'/&gt;
3819                     &lt;auth username='libvirt'&gt;
3820                       &lt;secret type='ceph' usage='pool_test-rbd'/&gt;
3821                     &lt;/auth&gt;
3822                   &lt;/source&gt;
3823                   &lt;target dev='vdc' bus='virtio'/&gt;
3824                   &lt;alias name='virtio-disk2'/&gt;
3825                   &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x07' function='0x2'/&gt;
3826                 &lt;/disk&gt;
3827               &lt;/devices&gt;
3828             &lt;/domain&gt;
3829         """
3830         self.set_mock_vm("test-vm", xml)
3831         pool_mock = MagicMock()
3832         pool_mock.storageVolLookupByName.return_value.info.return_value = [
3833             0,
3834             1234567,
3835             12345,
3836         ]
3837         pool_mock.XMLDesc.return_value = """
3838         &lt;pool type='rbd'&gt;
3839           &lt;name&gt;test-ses&lt;/name&gt;
3840           &lt;source&gt;
3841             &lt;host name='ses2.tf.local'/&gt;
3842             &lt;name&gt;libvirt-pool&lt;/name&gt;
3843             &lt;auth type='ceph' username='libvirt'&gt;
3844               &lt;secret usage='pool_test-ses'/&gt;
3845             &lt;/auth&gt;
3846           &lt;/source&gt;
3847         &lt;/pool&gt;
3848         """
3849         pool_mock.name.return_value = "test-ses"
3850         pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = [
3851         ]
3852         pool_mock.listVolumes.return_value = ["my_vm_data2"]
3853         self.mock_conn.listAllStoragePools.return_value = [pool_mock]
3854         self.mock_conn.listStoragePools.return_value = ["test-ses"]
3855         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
3856         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=False)}):
3857             res = virt.purge("test-vm")
3858             self.assertTrue(res)
3859             pool_mock.storageVolLookupByName.return_value.delete.assert_called_once()
3860     @patch("salt.modules.virt.stop", return_value=True)
3861     @patch("salt.modules.virt.undefine")
3862     @patch("os.remove")
3863     def test_purge_removable(self, mock_remove, mock_undefine, mock_stop):
3864         xml = """&lt;domain type="kvm" id="7"&gt;
3865               &lt;name&gt;test-vm&lt;/name&gt;
3866               &lt;devices&gt;
3867                 &lt;disk type='file' device='disk'&gt;
3868                 &lt;driver name='qemu' type='qcow2'/&gt;
3869                 &lt;source file='/disks/test.qcow2'/&gt;
3870                 &lt;target dev='vda' bus='virtio'/&gt;
3871               &lt;/disk&gt;
3872               &lt;disk type='file' device='cdrom'&gt;
3873                 &lt;driver name='qemu' type='raw'/&gt;
3874                 &lt;source file='/disks/test-cdrom.iso'/&gt;
3875                 &lt;target dev='hda' bus='ide'/&gt;
3876                 &lt;readonly/&gt;
3877               &lt;/disk&gt;
3878               &lt;disk type='file' device='floppy'&gt;
3879                 &lt;driver name='qemu' type='raw'/&gt;
3880                 &lt;source file='/disks/test-floppy.iso'/&gt;
3881                 &lt;target dev='hdb' bus='ide'/&gt;
3882                 &lt;readonly/&gt;
3883               &lt;/disk&gt;
3884               &lt;/devices&gt;
3885             &lt;/domain&gt;
3886         """
3887         self.set_mock_vm("test-vm", xml)
3888         qemu_infos = """[{
3889             "virtual-size": 25769803776,
3890             "filename": "/disks/test.qcow2",
3891             "cluster-size": 65536,
3892             "format": "qcow2",
3893             "actual-size": 217088,
3894             "format-specific": {
3895                 "type": "qcow2",
3896                 "data": {
3897                     "compat": "1.1",
3898                     "lazy-refcounts": false,
3899                     "refcount-bits": 16,
3900                     "corrupt": false
3901                 }
3902             },
3903             "dirty-flag": false
3904         }]"""
3905         self.mock_popen.communicate.return_value = [qemu_infos, ""]
3906 <a name="0"></a>        self.mock_popen.returncode = 0
3907         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
3908             res = virt.purge<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>("test-vm", removables=True)
3909             self.assertTrue(res)
3910             mock_remove.assert_any_call("/disks/test.qcow2")
3911             mock_remove.assert_any_call("/disks/test-cdrom.iso")
3912     def</b></font> test_capabilities(self):
3913         xml = """
3914 &lt;capabilities&gt;
3915   &lt;host&gt;
3916     &lt;uuid&gt;44454c4c-3400-105a-8033-b3c04f4b344a&lt;/uuid&gt;
3917     &lt;cpu&gt;
3918       &lt;arch&gt;x86_64&lt;/arch&gt;
3919       &lt;model&gt;Nehalem&lt;/model&gt;
3920       &lt;vendor&gt;Intel&lt;/vendor&gt;
3921       &lt;microcode version='25'/&gt;
3922       &lt;topology sockets='1' cores='4' threads='2'/&gt;
3923       &lt;feature name='vme'/&gt;
3924       &lt;feature name='ds'/&gt;
3925       &lt;feature name='acpi'/&gt;
3926       &lt;pages unit='KiB' size='4'/&gt;
3927       &lt;pages unit='KiB' size='2048'/&gt;
3928     &lt;/cpu&gt;
3929     &lt;power_management&gt;
3930       &lt;suspend_mem/&gt;
3931       &lt;suspend_disk/&gt;
3932       &lt;suspend_hybrid/&gt;
3933     &lt;/power_management&gt;
3934     &lt;migration_features&gt;
3935       &lt;live/&gt;
3936       &lt;uri_transports&gt;
3937         &lt;uri_transport&gt;tcp&lt;/uri_transport&gt;
3938         &lt;uri_transport&gt;rdma&lt;/uri_transport&gt;
3939       &lt;/uri_transports&gt;
3940     &lt;/migration_features&gt;
3941     &lt;topology&gt;
3942       &lt;cells num='1'&gt;
3943         &lt;cell id='0'&gt;
3944           &lt;memory unit='KiB'&gt;12367120&lt;/memory&gt;
3945           &lt;pages unit='KiB' size='4'&gt;3091780&lt;/pages&gt;
3946           &lt;pages unit='KiB' size='2048'&gt;0&lt;/pages&gt;
3947           &lt;distances&gt;
3948             &lt;sibling id='0' value='10'/&gt;
3949           &lt;/distances&gt;
3950           &lt;cpus num='8'&gt;
3951             &lt;cpu id='0' socket_id='0' core_id='0' siblings='0,4'/&gt;
3952             &lt;cpu id='1' socket_id='0' core_id='1' siblings='1,5'/&gt;
3953             &lt;cpu id='2' socket_id='0' core_id='2' siblings='2,6'/&gt;
3954             &lt;cpu id='3' socket_id='0' core_id='3' siblings='3,7'/&gt;
3955             &lt;cpu id='4' socket_id='0' core_id='0' siblings='0,4'/&gt;
3956             &lt;cpu id='5' socket_id='0' core_id='1' siblings='1,5'/&gt;
3957             &lt;cpu id='6' socket_id='0' core_id='2' siblings='2,6'/&gt;
3958             &lt;cpu id='7' socket_id='0' core_id='3' siblings='3,7'/&gt;
3959           &lt;/cpus&gt;
3960         &lt;/cell&gt;
3961       &lt;/cells&gt;
3962     &lt;/topology&gt;
3963     &lt;cache&gt;
3964       &lt;bank id='0' level='3' type='both' size='8' unit='MiB' cpus='0-7'/&gt;
3965     &lt;/cache&gt;
3966     &lt;secmodel&gt;
3967       &lt;model&gt;apparmor&lt;/model&gt;
3968       &lt;doi&gt;0&lt;/doi&gt;
3969     &lt;/secmodel&gt;
3970     &lt;secmodel&gt;
3971       &lt;model&gt;dac&lt;/model&gt;
3972       &lt;doi&gt;0&lt;/doi&gt;
3973       &lt;baselabel type='kvm'&gt;+487:+486&lt;/baselabel&gt;
3974       &lt;baselabel type='qemu'&gt;+487:+486&lt;/baselabel&gt;
3975     &lt;/secmodel&gt;
3976   &lt;/host&gt;
3977   &lt;guest&gt;
3978     &lt;os_type&gt;hvm&lt;/os_type&gt;
3979     &lt;arch name='i686'&gt;
3980       &lt;wordsize&gt;32&lt;/wordsize&gt;
3981       &lt;emulator&gt;/usr/bin/qemu-system-i386&lt;/emulator&gt;
3982       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
3983       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
3984       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
3985       &lt;domain type='qemu'/&gt;
3986       &lt;domain type='kvm'&gt;
3987         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
3988         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
3989         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
3990         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
3991       &lt;/domain&gt;
3992     &lt;/arch&gt;
3993     &lt;features&gt;
3994       &lt;cpuselection/&gt;
3995       &lt;deviceboot/&gt;
3996       &lt;disksnapshot default='on' toggle='no'/&gt;
3997       &lt;acpi default='off' toggle='yes'/&gt;
3998       &lt;apic default='on' toggle='no'/&gt;
3999       &lt;pae/&gt;
4000       &lt;nonpae/&gt;
4001     &lt;/features&gt;
4002   &lt;/guest&gt;
4003   &lt;guest&gt;
4004     &lt;os_type&gt;hvm&lt;/os_type&gt;
4005     &lt;arch name='x86_64'&gt;
4006       &lt;wordsize&gt;64&lt;/wordsize&gt;
4007       &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
4008       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
4009       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
4010       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
4011       &lt;domain type='qemu'/&gt;
4012       &lt;domain type='kvm'&gt;
4013         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
4014         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
4015         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
4016         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
4017       &lt;/domain&gt;
4018     &lt;/arch&gt;
4019     &lt;features&gt;
4020       &lt;cpuselection/&gt;
4021       &lt;deviceboot/&gt;
4022       &lt;disksnapshot default='on' toggle='no'/&gt;
4023       &lt;acpi default='on' toggle='yes'/&gt;
4024       &lt;apic default='off' toggle='no'/&gt;
4025     &lt;/features&gt;
4026   &lt;/guest&gt;
4027   &lt;guest&gt;
4028     &lt;os_type&gt;xen&lt;/os_type&gt;
4029     &lt;arch name='x86_64'&gt;
4030       &lt;wordsize&gt;64&lt;/wordsize&gt;
4031       &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
4032       &lt;machine&gt;xenpv&lt;/machine&gt;
4033       &lt;domain type='xen'/&gt;
4034     &lt;/arch&gt;
4035   &lt;/guest&gt;
4036 &lt;/capabilities&gt;
4037         """
4038         self.mock_conn.getCapabilities.return_value = xml  # pylint: disable=no-member
4039         caps = virt.capabilities()
4040         expected = {
4041             "host": {
4042                 "uuid": "44454c4c-3400-105a-8033-b3c04f4b344a",
4043                 "cpu": {
4044                     "arch": "x86_64",
4045                     "model": "Nehalem",
4046                     "vendor": "Intel",
4047                     "microcode": "25",
4048                     "sockets": 1,
4049                     "cores": 4,
4050                     "threads": 2,
4051                     "features": ["vme", "ds", "acpi"],
4052                     "pages": [{"size": "4 KiB"}, {"size": "2048 KiB"}],
4053                 },
4054                 "power_management": ["suspend_mem", "suspend_disk", "suspend_hybrid"],
4055                 "migration": {"live": True, "transports": ["tcp", "rdma"]},
4056                 "topology": {
4057                     "cells": [
4058                         {
4059                             "id": 0,
4060                             "memory": "12367120 KiB",
4061                             "pages": [
4062                                 {"size": "4 KiB", "available": 3091780},
4063                                 {"size": "2048 KiB", "available": 0},
4064                             ],
4065                             "distances": {0: 10},
4066                             "cpus": [
4067                                 {
4068                                     "id": 0,
4069                                     "socket_id": 0,
4070                                     "core_id": 0,
4071                                     "siblings": "0,4",
4072                                 },
4073                                 {
4074                                     "id": 1,
4075                                     "socket_id": 0,
4076                                     "core_id": 1,
4077                                     "siblings": "1,5",
4078                                 },
4079                                 {
4080                                     "id": 2,
4081                                     "socket_id": 0,
4082                                     "core_id": 2,
4083                                     "siblings": "2,6",
4084                                 },
4085                                 {
4086                                     "id": 3,
4087                                     "socket_id": 0,
4088                                     "core_id": 3,
4089                                     "siblings": "3,7",
4090                                 },
4091                                 {
4092                                     "id": 4,
4093                                     "socket_id": 0,
4094                                     "core_id": 0,
4095                                     "siblings": "0,4",
4096                                 },
4097                                 {
4098                                     "id": 5,
4099                                     "socket_id": 0,
4100                                     "core_id": 1,
4101                                     "siblings": "1,5",
4102                                 },
4103                                 {
4104                                     "id": 6,
4105                                     "socket_id": 0,
4106                                     "core_id": 2,
4107                                     "siblings": "2,6",
4108                                 },
4109                                 {
4110                                     "id": 7,
4111                                     "socket_id": 0,
4112                                     "core_id": 3,
4113                                     "siblings": "3,7",
4114                                 },
4115                             ],
4116                         }
4117                     ]
4118                 },
4119                 "cache": {
4120                     "banks": [
4121                         {
4122                             "id": 0,
4123                             "level": 3,
4124                             "type": "both",
4125                             "size": "8 MiB",
4126                             "cpus": "0-7",
4127                         }
4128                     ]
4129                 },
4130                 "security": [
4131                     {"model": "apparmor", "doi": "0", "baselabels": []},
4132                     {
4133                         "model": "dac",
4134                         "doi": "0",
4135                         "baselabels": [
4136                             {"type": "kvm", "label": "+487:+486"},
4137                             {"type": "qemu", "label": "+487:+486"},
4138                         ],
4139                     },
4140                 ],
4141             },
4142             "guests": [
4143                 {
4144                     "os_type": "hvm",
4145                     "arch": {
4146                         "name": "i686",
4147                         "wordsize": 32,
4148                         "emulator": "/usr/bin/qemu-system-i386",
4149                         "machines": {
4150                             "pc-i440fx-2.6": {
4151                                 "maxcpus": 255,
4152                                 "alternate_names": ["pc"],
4153                             },
4154                             "pc-0.12": {"maxcpus": 255, "alternate_names": []},
4155                         },
4156                         "domains": {
4157                             "qemu": {"emulator": None, "machines": {}},
4158                             "kvm": {
4159                                 "emulator": "/usr/bin/qemu-kvm",
4160                                 "machines": {
4161                                     "pc-i440fx-2.6": {
4162                                         "maxcpus": 255,
4163                                         "alternate_names": ["pc"],
4164                                     },
4165                                     "pc-0.12": {"maxcpus": 255, "alternate_names": []},
4166                                 },
4167                             },
4168                         },
4169                     },
4170                     "features": {
4171                         "cpuselection": {"default": True, "toggle": False},
4172                         "deviceboot": {"default": True, "toggle": False},
4173                         "disksnapshot": {"default": True, "toggle": False},
4174                         "acpi": {"default": False, "toggle": True},
4175                         "apic": {"default": True, "toggle": False},
4176                         "pae": {"default": True, "toggle": False},
4177                         "nonpae": {"default": True, "toggle": False},
4178                     },
4179                 },
4180                 {
4181                     "os_type": "hvm",
4182                     "arch": {
4183                         "name": "x86_64",
4184                         "wordsize": 64,
4185                         "emulator": "/usr/bin/qemu-system-x86_64",
4186                         "machines": {
4187                             "pc-i440fx-2.6": {
4188                                 "maxcpus": 255,
4189                                 "alternate_names": ["pc"],
4190                             },
4191                             "pc-0.12": {"maxcpus": 255, "alternate_names": []},
4192                         },
4193                         "domains": {
4194                             "qemu": {"emulator": None, "machines": {}},
4195                             "kvm": {
4196                                 "emulator": "/usr/bin/qemu-kvm",
4197                                 "machines": {
4198                                     "pc-i440fx-2.6": {
4199                                         "maxcpus": 255,
4200                                         "alternate_names": ["pc"],
4201                                     },
4202                                     "pc-0.12": {"maxcpus": 255, "alternate_names": []},
4203                                 },
4204                             },
4205                         },
4206                     },
4207                     "features": {
4208                         "cpuselection": {"default": True, "toggle": False},
4209                         "deviceboot": {"default": True, "toggle": False},
4210                         "disksnapshot": {"default": True, "toggle": False},
4211                         "acpi": {"default": True, "toggle": True},
4212                         "apic": {"default": False, "toggle": False},
4213                     },
4214                 },
4215                 {
4216                     "os_type": "xen",
4217                     "arch": {
4218                         "name": "x86_64",
4219                         "wordsize": 64,
4220                         "emulator": "/usr/bin/qemu-system-x86_64",
4221                         "machines": {"xenpv": {"alternate_names": []}},
4222                         "domains": {"xen": {"emulator": None, "machines": {}}},
4223                     },
4224                 },
4225             ],
4226         }
4227         self.assertEqual(expected, caps)
4228     def test_domain_capabilities(self):
4229         xml = """
4230 &lt;domainCapabilities&gt;
4231   &lt;path&gt;/usr/bin/qemu-system-aarch64&lt;/path&gt;
4232   &lt;domain&gt;kvm&lt;/domain&gt;
4233   &lt;machine&gt;virt-2.12&lt;/machine&gt;
4234   &lt;arch&gt;aarch64&lt;/arch&gt;
4235   &lt;vcpu max='255'/&gt;
4236   &lt;iothreads supported='yes'/&gt;
4237   &lt;os supported='yes'&gt;
4238     &lt;loader supported='yes'&gt;
4239       &lt;value&gt;/usr/share/AAVMF/AAVMF_CODE.fd&lt;/value&gt;
4240       &lt;value&gt;/usr/share/AAVMF/AAVMF32_CODE.fd&lt;/value&gt;
4241       &lt;value&gt;/usr/share/OVMF/OVMF_CODE.fd&lt;/value&gt;
4242       &lt;enum name='type'&gt;
4243         &lt;value&gt;rom&lt;/value&gt;
4244         &lt;value&gt;pflash&lt;/value&gt;
4245       &lt;/enum&gt;
4246       &lt;enum name='readonly'&gt;
4247         &lt;value&gt;yes&lt;/value&gt;
4248         &lt;value&gt;no&lt;/value&gt;
4249       &lt;/enum&gt;
4250     &lt;/loader&gt;
4251   &lt;/os&gt;
4252   &lt;cpu&gt;
4253     &lt;mode name='host-passthrough' supported='yes'/&gt;
4254     &lt;mode name='host-model' supported='yes'&gt;
4255       &lt;model fallback='forbid'&gt;sample-cpu&lt;/model&gt;
4256       &lt;vendor&gt;ACME&lt;/vendor&gt;
4257       &lt;feature policy='require' name='vme'/&gt;
4258       &lt;feature policy='require' name='ss'/&gt;
4259     &lt;/mode&gt;
4260     &lt;mode name='custom' supported='yes'&gt;
4261       &lt;model usable='unknown'&gt;pxa262&lt;/model&gt;
4262       &lt;model usable='yes'&gt;pxa270-a0&lt;/model&gt;
4263       &lt;model usable='no'&gt;arm1136&lt;/model&gt;
4264     &lt;/mode&gt;
4265   &lt;/cpu&gt;
4266   &lt;devices&gt;
4267     &lt;disk supported='yes'&gt;
4268       &lt;enum name='diskDevice'&gt;
4269         &lt;value&gt;disk&lt;/value&gt;
4270         &lt;value&gt;cdrom&lt;/value&gt;
4271         &lt;value&gt;floppy&lt;/value&gt;
4272         &lt;value&gt;lun&lt;/value&gt;
4273       &lt;/enum&gt;
4274       &lt;enum name='bus'&gt;
4275         &lt;value&gt;fdc&lt;/value&gt;
4276         &lt;value&gt;scsi&lt;/value&gt;
4277         &lt;value&gt;virtio&lt;/value&gt;
4278         &lt;value&gt;usb&lt;/value&gt;
4279         &lt;value&gt;sata&lt;/value&gt;
4280       &lt;/enum&gt;
4281     &lt;/disk&gt;
4282     &lt;graphics supported='yes'&gt;
4283       &lt;enum name='type'&gt;
4284         &lt;value&gt;sdl&lt;/value&gt;
4285         &lt;value&gt;vnc&lt;/value&gt;
4286       &lt;/enum&gt;
4287     &lt;/graphics&gt;
4288     &lt;video supported='yes'&gt;
4289       &lt;enum name='modelType'&gt;
4290         &lt;value&gt;vga&lt;/value&gt;
4291         &lt;value&gt;virtio&lt;/value&gt;
4292       &lt;/enum&gt;
4293     &lt;/video&gt;
4294     &lt;hostdev supported='yes'&gt;
4295       &lt;enum name='mode'&gt;
4296         &lt;value&gt;subsystem&lt;/value&gt;
4297       &lt;/enum&gt;
4298       &lt;enum name='startupPolicy'&gt;
4299         &lt;value&gt;default&lt;/value&gt;
4300         &lt;value&gt;mandatory&lt;/value&gt;
4301         &lt;value&gt;requisite&lt;/value&gt;
4302         &lt;value&gt;optional&lt;/value&gt;
4303       &lt;/enum&gt;
4304       &lt;enum name='subsysType'&gt;
4305         &lt;value&gt;usb&lt;/value&gt;
4306         &lt;value&gt;pci&lt;/value&gt;
4307         &lt;value&gt;scsi&lt;/value&gt;
4308       &lt;/enum&gt;
4309       &lt;enum name='capsType'/&gt;
4310       &lt;enum name='pciBackend'&gt;
4311         &lt;value&gt;default&lt;/value&gt;
4312         &lt;value&gt;kvm&lt;/value&gt;
4313         &lt;value&gt;vfio&lt;/value&gt;
4314       &lt;/enum&gt;
4315     &lt;/hostdev&gt;
4316   &lt;/devices&gt;
4317   &lt;features&gt;
4318     &lt;gic supported='yes'&gt;
4319       &lt;enum name='version'&gt;
4320         &lt;value&gt;3&lt;/value&gt;
4321       &lt;/enum&gt;
4322     &lt;/gic&gt;
4323     &lt;vmcoreinfo supported='yes'/&gt;
4324   &lt;/features&gt;
4325 &lt;/domainCapabilities&gt;
4326         """
4327         self.mock_conn.getDomainCapabilities.return_value = (
4328             xml  # pylint: disable=no-member
4329         )
4330         caps = virt.domain_capabilities()
4331         expected = {
4332             "emulator": "/usr/bin/qemu-system-aarch64",
4333             "domain": "kvm",
4334             "machine": "virt-2.12",
4335             "arch": "aarch64",
4336             "max_vcpus": 255,
4337             "iothreads": True,
4338             "os": {
4339                 "loader": {
4340                     "type": ["rom", "pflash"],
4341                     "readonly": ["yes", "no"],
4342                     "values": [
4343                         "/usr/share/AAVMF/AAVMF_CODE.fd",
4344                         "/usr/share/AAVMF/AAVMF32_CODE.fd",
4345                         "/usr/share/OVMF/OVMF_CODE.fd",
4346                     ],
4347                 }
4348             },
4349             "cpu": {
4350                 "host-passthrough": True,
4351                 "host-model": {
4352                     "model": {"name": "sample-cpu", "fallback": "forbid"},
4353                     "vendor": "ACME",
4354                     "features": {"vme": "require", "ss": "require"},
4355                 },
4356                 "custom": {
4357                     "models": {"pxa262": "unknown", "pxa270-a0": "yes", "arm1136": "no"}
4358                 },
4359             },
4360             "devices": {
4361                 "disk": {
4362                     "diskDevice": ["disk", "cdrom", "floppy", "lun"],
4363                     "bus": ["fdc", "scsi", "virtio", "usb", "sata"],
4364                 },
4365                 "graphics": {"type": ["sdl", "vnc"]},
4366                 "video": {"modelType": ["vga", "virtio"]},
4367                 "hostdev": {
4368                     "mode": ["subsystem"],
4369                     "startupPolicy": ["default", "mandatory", "requisite", "optional"],
4370                     "subsysType": ["usb", "pci", "scsi"],
4371                     "capsType": [],
4372                     "pciBackend": ["default", "kvm", "vfio"],
4373                 },
4374             },
4375             "features": {"gic": {"version": ["3"]}, "vmcoreinfo": {}},
4376         }
4377         self.assertEqual(expected, caps)
4378     def test_all_capabilities(self):
4379         domainXml = """
4380 &lt;domainCapabilities&gt;
4381   &lt;path&gt;/usr/bin/qemu-system-x86_64&lt;/path&gt;
4382   &lt;domain&gt;kvm&lt;/domain&gt;
4383   &lt;machine&gt;virt-2.12&lt;/machine&gt;
4384   &lt;arch&gt;x86_64&lt;/arch&gt;
4385   &lt;vcpu max='255'/&gt;
4386   &lt;iothreads supported='yes'/&gt;
4387 &lt;/domainCapabilities&gt;
4388         """
4389         hostXml = """
4390 &lt;capabilities&gt;
4391   &lt;host&gt;
4392     &lt;uuid&gt;44454c4c-3400-105a-8033-b3c04f4b344a&lt;/uuid&gt;
4393     &lt;cpu&gt;
4394       &lt;arch&gt;x86_64&lt;/arch&gt;
4395       &lt;model&gt;Nehalem&lt;/model&gt;
4396       &lt;vendor&gt;Intel&lt;/vendor&gt;
4397       &lt;microcode version='25'/&gt;
4398       &lt;topology sockets='1' cores='4' threads='2'/&gt;
4399     &lt;/cpu&gt;
4400   &lt;/host&gt;
4401   &lt;guest&gt;
4402     &lt;os_type&gt;hvm&lt;/os_type&gt;
4403     &lt;arch name='x86_64'&gt;
4404       &lt;wordsize&gt;64&lt;/wordsize&gt;
4405       &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
4406       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
4407       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
4408       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
4409       &lt;domain type='qemu'/&gt;
4410       &lt;domain type='kvm'&gt;
4411         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
4412         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
4413         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
4414         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
4415       &lt;/domain&gt;
4416     &lt;/arch&gt;
4417   &lt;/guest&gt;
4418 &lt;/capabilities&gt;
4419         """
4420         self.mock_conn.getCapabilities.return_value = hostXml
4421         self.mock_conn.getDomainCapabilities.side_effect = [
4422             domainXml,
4423             domainXml.replace("&lt;domain&gt;kvm", "&lt;domain&gt;qemu"),
4424         ]
4425         caps = virt.all_capabilities()
4426         self.assertEqual(
4427             "44454c4c-3400-105a-8033-b3c04f4b344a", caps["host"]["host"]["uuid"]
4428         )
4429         self.assertEqual(
4430             {"qemu", "kvm"},
4431             {domainCaps["domain"] for domainCaps in caps["domains"]},
4432         )
4433         self.assertEqual(
4434             {call[0] for call in self.mock_conn.getDomainCapabilities.call_args_list},
4435             {
4436                 ("/usr/bin/qemu-system-x86_64", "x86_64", None, "kvm"),
4437                 ("/usr/bin/qemu-system-x86_64", "x86_64", None, "qemu"),
4438             },
4439         )
4440     def test_network_tag(self):
4441         xml_data = virt._gen_net_xml("network", "main", "bridge", "openvswitch", 1001)
4442         root = ET.fromstring(xml_data)
4443         self.assertEqual(root.find("name").text, "network")
4444         self.assertEqual(root.find("bridge").attrib["name"], "main")
4445         self.assertEqual(root.find("forward").attrib["mode"], "bridge")
4446         self.assertEqual(root.find("virtualport").attrib["type"], "openvswitch")
4447         self.assertEqual(root.find("vlan/tag").attrib["id"], "1001")
4448     def test_list_networks(self):
4449         names = ["net1", "default", "net2"]
4450         net_mocks = [MagicMock(), MagicMock(), MagicMock()]
4451         for i, value in enumerate(names):
4452             net_mocks[i].name.return_value = value
4453         self.mock_conn.listAllNetworks.return_value = (
4454             net_mocks  # pylint: disable=no-member
4455         )
4456         actual = virt.list_networks()
4457         self.assertEqual(names, actual)
4458     def test_network_info(self):
4459         self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV4 = 0
4460         self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV6 = 1
4461         net_mock = MagicMock()
4462         net_mock.name.return_value = "foo"
4463         net_mock.UUIDString.return_value = "some-uuid"
4464         net_mock.bridgeName.return_value = "br0"
4465         net_mock.autostart.return_value = True
4466         net_mock.isActive.return_value = False
4467         net_mock.isPersistent.return_value = True
4468         net_mock.DHCPLeases.return_value = [
4469             {
4470                 "iface": "virbr0",
4471                 "expirytime": 1527757552,
4472                 "type": 0,
4473                 "mac": "52:54:00:01:71:bd",
4474                 "ipaddr": "192.168.122.45",
4475                 "prefix": 24,
4476                 "hostname": "py3-test",
4477                 "clientid": "01:52:54:00:01:71:bd",
4478                 "iaid": None,
4479             }
4480         ]
4481         self.mock_conn.listAllNetworks.return_value = [net_mock]
4482         net = virt.network_info("foo")
4483         self.assertEqual(
4484             {
4485                 "foo": {
4486                     "uuid": "some-uuid",
4487                     "bridge": "br0",
4488                     "autostart": True,
4489                     "active": False,
4490                     "persistent": True,
4491                     "leases": [
4492                         {
4493                             "iface": "virbr0",
4494                             "expirytime": 1527757552,
4495                             "type": "ipv4",
4496                             "mac": "52:54:00:01:71:bd",
4497                             "ipaddr": "192.168.122.45",
4498                             "prefix": 24,
4499                             "hostname": "py3-test",
4500                             "clientid": "01:52:54:00:01:71:bd",
4501                             "iaid": None,
4502                         }
4503                     ],
4504                 }
4505             },
4506             net,
4507         )
4508     def test_network_info_all(self):
4509         self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV4 = 0
4510         self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV6 = 1
4511         net_mocks = []
4512         for i in range(2):
4513             net_mock = MagicMock()
4514             net_mock.name.return_value = "net{}".format(i)
4515             net_mock.UUIDString.return_value = "some-uuid"
4516             net_mock.bridgeName.return_value = "br{}".format(i)
4517             net_mock.autostart.return_value = True
4518             net_mock.isActive.return_value = False
4519             net_mock.isPersistent.return_value = True
4520             net_mock.DHCPLeases.return_value = []
4521             net_mocks.append(net_mock)
4522         self.mock_conn.listAllNetworks.return_value = net_mocks
4523         net = virt.network_info()
4524         self.assertEqual(
4525             {
4526                 "net0": {
4527                     "uuid": "some-uuid",
4528                     "bridge": "br0",
4529                     "autostart": True,
4530                     "active": False,
4531                     "persistent": True,
4532                     "leases": [],
4533                 },
4534                 "net1": {
4535                     "uuid": "some-uuid",
4536                     "bridge": "br1",
4537                     "autostart": True,
4538                     "active": False,
4539                     "persistent": True,
4540                     "leases": [],
4541                 },
4542             },
4543             net,
4544         )
4545     def test_network_info_notfound(self):
4546         self.mock_conn.listAllNetworks.return_value = []
4547         net = virt.network_info("foo")
4548         self.assertEqual({}, net)
4549     def test_network_get_xml(self):
4550         network_mock = MagicMock()
4551         network_mock.XMLDesc.return_value = "&lt;net&gt;Raw XML&lt;/net&gt;"
4552         self.mock_conn.networkLookupByName.return_value = network_mock
4553         self.assertEqual("&lt;net&gt;Raw XML&lt;/net&gt;", virt.network_get_xml("default"))
4554     def test_pool(self):
4555         xml_data = virt._gen_pool_xml("pool", "logical", "/dev/base")
4556         root = ET.fromstring(xml_data)
4557         self.assertEqual(root.find("name").text, "pool")
4558         self.assertEqual(root.attrib["type"], "logical")
4559         self.assertEqual(root.find("target/path").text, "/dev/base")
4560     def test_pool_with_source(self):
4561         xml_data = virt._gen_pool_xml(
4562             "pool", "logical", "/dev/base", source_devices=[{"path": "/dev/sda"}]
4563         )
4564         root = ET.fromstring(xml_data)
4565         self.assertEqual(root.find("name").text, "pool")
4566         self.assertEqual(root.attrib["type"], "logical")
4567         self.assertEqual(root.find("target/path").text, "/dev/base")
4568         self.assertEqual(root.find("source/device").attrib["path"], "/dev/sda")
4569     def test_pool_with_scsi(self):
4570         xml_data = virt._gen_pool_xml(
4571             "pool",
4572             "scsi",
4573             "/dev/disk/by-path",
4574             source_devices=[{"path": "/dev/sda"}],
4575             source_adapter={
4576                 "type": "scsi_host",
4577                 "parent_address": {
4578                     "unique_id": 5,
4579                     "address": {
4580                         "domain": "0x0000",
4581                         "bus": "0x00",
4582                         "slot": "0x1f",
4583                         "function": "0x2",
4584                     },
4585                 },
4586             },
4587             source_name="srcname",
4588         )
4589         root = ET.fromstring(xml_data)
4590         self.assertEqual(root.find("name").text, "pool")
4591         self.assertEqual(root.attrib["type"], "scsi")
4592         self.assertEqual(root.find("target/path").text, "/dev/disk/by-path")
4593         self.assertEqual(root.find("source/device"), None)
4594         self.assertEqual(root.find("source/name"), None)
4595         self.assertEqual(root.find("source/adapter").attrib["type"], "scsi_host")
4596         self.assertEqual(
4597             root.find("source/adapter/parentaddr").attrib["unique_id"], "5"
4598         )
4599         self.assertEqual(
4600             root.find("source/adapter/parentaddr/address").attrib["domain"], "0x0000"
4601         )
4602         self.assertEqual(
4603             root.find("source/adapter/parentaddr/address").attrib["bus"], "0x00"
4604         )
4605         self.assertEqual(
4606             root.find("source/adapter/parentaddr/address").attrib["slot"], "0x1f"
4607         )
4608         self.assertEqual(
4609             root.find("source/adapter/parentaddr/address").attrib["function"], "0x2"
4610         )
4611     def test_pool_with_rbd(self):
4612         xml_data = virt._gen_pool_xml(
4613             "pool",
4614             "rbd",
4615             source_devices=[{"path": "/dev/sda"}],
4616             source_hosts=["1.2.3.4", "my.ceph.monitor:69"],
4617             source_auth={
4618                 "type": "ceph",
4619                 "username": "admin",
4620                 "secret": {"type": "uuid", "value": "someuuid"},
4621             },
4622             source_name="srcname",
4623             source_adapter={"type": "scsi_host", "name": "host0"},
4624             source_dir="/some/dir",
4625             source_format="fmt",
4626         )
4627         root = ET.fromstring(xml_data)
4628         self.assertEqual(root.find("name").text, "pool")
4629         self.assertEqual(root.attrib["type"], "rbd")
4630         self.assertEqual(root.find("target"), None)
4631         self.assertEqual(root.find("source/device"), None)
4632         self.assertEqual(root.find("source/name").text, "srcname")
4633         self.assertEqual(root.find("source/adapter"), None)
4634         self.assertEqual(root.find("source/dir"), None)
4635         self.assertEqual(root.find("source/format"), None)
4636         self.assertEqual(root.findall("source/host")[0].attrib["name"], "1.2.3.4")
4637         self.assertTrue("port" not in root.findall("source/host")[0].attrib)
4638         self.assertEqual(
4639             root.findall("source/host")[1].attrib["name"], "my.ceph.monitor"
4640         )
4641         self.assertEqual(root.findall("source/host")[1].attrib["port"], "69")
4642         self.assertEqual(root.find("source/auth").attrib["type"], "ceph")
4643         self.assertEqual(root.find("source/auth").attrib["username"], "admin")
4644         self.assertEqual(root.find("source/auth/secret").attrib["uuid"], "someuuid")
4645     def test_pool_with_netfs(self):
4646         xml_data = virt._gen_pool_xml(
4647             "pool",
4648             "netfs",
4649             target="/path/to/target",
4650             permissions={
4651                 "mode": "0770",
4652                 "owner": 1000,
4653                 "group": 100,
4654                 "label": "seclabel",
4655             },
4656             source_devices=[{"path": "/dev/sda"}],
4657             source_hosts=["nfs.host"],
4658             source_name="srcname",
4659             source_adapter={"type": "scsi_host", "name": "host0"},
4660             source_dir="/some/dir",
4661             source_format="nfs",
4662         )
4663         root = ET.fromstring(xml_data)
4664         self.assertEqual(root.find("name").text, "pool")
4665         self.assertEqual(root.attrib["type"], "netfs")
4666         self.assertEqual(root.find("target/path").text, "/path/to/target")
4667         self.assertEqual(root.find("target/permissions/mode").text, "0770")
4668         self.assertEqual(root.find("target/permissions/owner").text, "1000")
4669         self.assertEqual(root.find("target/permissions/group").text, "100")
4670         self.assertEqual(root.find("target/permissions/label").text, "seclabel")
4671         self.assertEqual(root.find("source/device"), None)
4672         self.assertEqual(root.find("source/name"), None)
4673         self.assertEqual(root.find("source/adapter"), None)
4674         self.assertEqual(root.find("source/dir").attrib["path"], "/some/dir")
4675         self.assertEqual(root.find("source/format").attrib["type"], "nfs")
4676         self.assertEqual(root.find("source/host").attrib["name"], "nfs.host")
4677         self.assertEqual(root.find("source/auth"), None)
4678     def test_pool_with_iscsi_direct(self):
4679         xml_data = virt._gen_pool_xml(
4680             "pool",
4681             "iscsi-direct",
4682             source_hosts=["iscsi.example.com"],
4683             source_devices=[{"path": "iqn.2013-06.com.example:iscsi-pool"}],
4684             source_initiator="iqn.2013-06.com.example:iscsi-initiator",
4685         )
4686         root = ET.fromstring(xml_data)
4687         self.assertEqual(root.find("name").text, "pool")
4688         self.assertEqual(root.attrib["type"], "iscsi-direct")
4689         self.assertEqual(root.find("target"), None)
4690         self.assertEqual(
4691             root.find("source/device").attrib["path"],
4692             "iqn.2013-06.com.example:iscsi-pool",
4693         )
4694         self.assertEqual(
4695             root.findall("source/host")[0].attrib["name"], "iscsi.example.com"
4696         )
4697         self.assertEqual(
4698             root.find("source/initiator/iqn").attrib["name"],
4699             "iqn.2013-06.com.example:iscsi-initiator",
4700         )
4701     def test_pool_define(self):
4702         mock_pool = MagicMock()
4703         mock_secret = MagicMock()
4704         mock_secret_define = MagicMock(return_value=mock_secret)
4705         self.mock_conn.secretDefineXML = mock_secret_define
4706         self.mock_conn.storagePoolCreateXML = MagicMock(return_value=mock_pool)
4707         self.mock_conn.storagePoolDefineXML = MagicMock(return_value=mock_pool)
4708         mocks = [
4709             mock_pool,
4710             mock_secret,
4711             mock_secret_define,
4712             self.mock_conn.storagePoolCreateXML,
4713             self.mock_conn.secretDefineXML,
4714             self.mock_conn.storagePoolDefineXML,
4715         ]
4716         self.assertTrue(
4717             virt.pool_define(
4718                 "default",
4719                 "rbd",
4720                 source_hosts=["one.example.com", "two.example.com"],
4721                 source_name="rbdvol",
4722                 source_auth={
4723                     "type": "ceph",
4724                     "username": "admin",
4725                     "secret": {"type": "uuid", "value": "someuuid"},
4726                 },
4727             )
4728         )
4729         self.mock_conn.storagePoolDefineXML.assert_called_once()
4730         self.mock_conn.storagePoolCreateXML.assert_not_called()
4731         mock_pool.create.assert_called_once()
4732         mock_secret_define.assert_not_called()
4733         for mock in mocks:
4734             mock.reset_mock()
4735         self.assertTrue(
4736             virt.pool_define(
4737                 "default",
4738                 "rbd",
4739                 transient=True,
4740                 source_hosts=["one.example.com", "two.example.com"],
4741                 source_name="rbdvol",
4742                 source_auth={"username": "admin", "password": "c2VjcmV0"},
4743             )
4744         )
4745         self.mock_conn.storagePoolDefineXML.assert_not_called()
4746         pool_xml = self.mock_conn.storagePoolCreateXML.call_args[0][0]
4747         root = ET.fromstring(pool_xml)
4748         self.assertEqual(root.find("source/auth").attrib["type"], "ceph")
4749         self.assertEqual(root.find("source/auth").attrib["username"], "admin")
4750         self.assertEqual(
4751             root.find("source/auth/secret").attrib["usage"], "pool_default"
4752         )
4753         mock_pool.create.assert_not_called()
4754         mock_secret.setValue.assert_called_once_with(b"secret")
4755         secret_xml = mock_secret_define.call_args[0][0]
4756         root = ET.fromstring(secret_xml)
4757         self.assertEqual(root.find("usage/name").text, "pool_default")
4758         self.assertEqual(root.find("usage").attrib["type"], "ceph")
4759         self.assertEqual(root.attrib["private"], "yes")
4760         self.assertEqual(
4761             root.find("description").text, "Passphrase for default pool created by Salt"
4762         )
4763         for mock in mocks:
4764             mock.reset_mock()
4765         self.assertTrue(
4766             virt.pool_define(
4767                 "default",
4768                 "iscsi",
4769                 target="/dev/disk/by-path",
4770                 source_hosts=["iscsi.example.com"],
4771                 source_devices=[{"path": "iqn.2013-06.com.example:iscsi-pool"}],
4772                 source_auth={"username": "admin", "password": "secret"},
4773                 start=False,
4774             )
4775         )
4776         self.mock_conn.storagePoolCreateXML.assert_not_called()
4777         pool_xml = self.mock_conn.storagePoolDefineXML.call_args[0][0]
4778         root = ET.fromstring(pool_xml)
4779         self.assertEqual(root.find("source/auth").attrib["type"], "chap")
4780         self.assertEqual(root.find("source/auth").attrib["username"], "admin")
4781         self.assertEqual(
4782             root.find("source/auth/secret").attrib["usage"], "pool_default"
4783         )
4784         mock_pool.create.assert_not_called()
4785         mock_secret.setValue.assert_called_once_with("secret")
4786         secret_xml = mock_secret_define.call_args[0][0]
4787         root = ET.fromstring(secret_xml)
4788         self.assertEqual(root.find("usage/target").text, "pool_default")
4789         self.assertEqual(root.find("usage").attrib["type"], "iscsi")
4790         self.assertEqual(root.attrib["private"], "yes")
4791         self.assertEqual(
4792             root.find("description").text, "Passphrase for default pool created by Salt"
4793         )
4794     def test_list_pools(self):
4795         names = ["pool1", "default", "pool2"]
4796         pool_mocks = [MagicMock(), MagicMock(), MagicMock()]
4797         for i, value in enumerate(names):
4798             pool_mocks[i].name.return_value = value
4799         self.mock_conn.listAllStoragePools.return_value = (
4800             pool_mocks  # pylint: disable=no-member
4801         )
4802         actual = virt.list_pools()
4803         self.assertEqual(names, actual)
4804     def test_pool_info(self):
4805         pool_mock = MagicMock()
4806         pool_mock.name.return_value = "foo"
4807         pool_mock.UUIDString.return_value = "some-uuid"
4808         pool_mock.info.return_value = [0, 1234, 5678, 123]
4809         pool_mock.autostart.return_value = True
4810         pool_mock.isPersistent.return_value = True
4811         pool_mock.XMLDesc.return_value = """&lt;pool type='dir'&gt;
4812   &lt;name&gt;default&lt;/name&gt;
4813   &lt;uuid&gt;d92682d0-33cf-4e10-9837-a216c463e158&lt;/uuid&gt;
4814   &lt;capacity unit='bytes'&gt;854374301696&lt;/capacity&gt;
4815   &lt;allocation unit='bytes'&gt;596275986432&lt;/allocation&gt;
4816   &lt;available unit='bytes'&gt;258098315264&lt;/available&gt;
4817   &lt;source&gt;
4818   &lt;/source&gt;
4819   &lt;target&gt;
4820     &lt;path&gt;/srv/vms&lt;/path&gt;
4821     &lt;permissions&gt;
4822       &lt;mode&gt;0755&lt;/mode&gt;
4823       &lt;owner&gt;0&lt;/owner&gt;
4824       &lt;group&gt;0&lt;/group&gt;
4825     &lt;/permissions&gt;
4826   &lt;/target&gt;
4827 &lt;/pool&gt;"""
4828         self.mock_conn.listAllStoragePools.return_value = [pool_mock]
4829         pool = virt.pool_info("foo")
4830         self.assertEqual(
4831             {
4832                 "foo": {
4833                     "uuid": "some-uuid",
4834                     "state": "inactive",
4835                     "capacity": 1234,
4836                     "allocation": 5678,
4837                     "free": 123,
4838                     "autostart": True,
4839                     "persistent": True,
4840                     "type": "dir",
4841                     "target_path": "/srv/vms",
4842                 }
4843             },
4844             pool,
4845         )
4846     def test_pool_info_notarget(self):
4847         pool_mock = MagicMock()
4848         pool_mock.name.return_value = "ceph"
4849         pool_mock.UUIDString.return_value = "some-uuid"
4850         pool_mock.info.return_value = [0, 0, 0, 0]
4851         pool_mock.autostart.return_value = True
4852         pool_mock.isPersistent.return_value = True
4853         pool_mock.XMLDesc.return_value = """&lt;pool type='rbd'&gt;
4854   &lt;name&gt;ceph&lt;/name&gt;
4855   &lt;uuid&gt;some-uuid&lt;/uuid&gt;
4856   &lt;capacity unit='bytes'&gt;0&lt;/capacity&gt;
4857   &lt;allocation unit='bytes'&gt;0&lt;/allocation&gt;
4858   &lt;available unit='bytes'&gt;0&lt;/available&gt;
4859   &lt;source&gt;
4860     &lt;host name='localhost' port='6789'/&gt;
4861     &lt;host name='localhost' port='6790'/&gt;
4862     &lt;name&gt;rbd&lt;/name&gt;
4863     &lt;auth type='ceph' username='admin'&gt;
4864       &lt;secret uuid='2ec115d7-3a88-3ceb-bc12-0ac909a6fd87'/&gt;
4865     &lt;/auth&gt;
4866   &lt;/source&gt;
4867 &lt;/pool&gt;"""
4868         self.mock_conn.listAllStoragePools.return_value = [pool_mock]
4869         pool = virt.pool_info("ceph")
4870         self.assertEqual(
4871             {
4872                 "ceph": {
4873                     "uuid": "some-uuid",
4874                     "state": "inactive",
4875                     "capacity": 0,
4876                     "allocation": 0,
4877                     "free": 0,
4878                     "autostart": True,
4879                     "persistent": True,
4880                     "type": "rbd",
4881                     "target_path": None,
4882                 }
4883             },
4884             pool,
4885         )
4886     def test_pool_info_notfound(self):
4887         self.mock_conn.listAllStoragePools.return_value = []
4888         pool = virt.pool_info("foo")
4889         self.assertEqual({}, pool)
4890     def test_pool_info_all(self):
4891         pool_mocks = []
4892         for i in range(2):
4893             pool_mock = MagicMock()
4894             pool_mock.name.return_value = "pool{}".format(i)
4895             pool_mock.UUIDString.return_value = "some-uuid-{}".format(i)
4896             pool_mock.info.return_value = [0, 1234, 5678, 123]
4897             pool_mock.autostart.return_value = True
4898             pool_mock.isPersistent.return_value = True
4899             pool_mock.XMLDesc.return_value = """&lt;pool type='dir'&gt;
4900   &lt;name&gt;default&lt;/name&gt;
4901   &lt;uuid&gt;d92682d0-33cf-4e10-9837-a216c463e158&lt;/uuid&gt;
4902   &lt;capacity unit='bytes'&gt;854374301696&lt;/capacity&gt;
4903   &lt;allocation unit='bytes'&gt;596275986432&lt;/allocation&gt;
4904   &lt;available unit='bytes'&gt;258098315264&lt;/available&gt;
4905   &lt;source&gt;
4906   &lt;/source&gt;
4907   &lt;target&gt;
4908     &lt;path&gt;/srv/vms&lt;/path&gt;
4909     &lt;permissions&gt;
4910       &lt;mode&gt;0755&lt;/mode&gt;
4911       &lt;owner&gt;0&lt;/owner&gt;
4912       &lt;group&gt;0&lt;/group&gt;
4913     &lt;/permissions&gt;
4914   &lt;/target&gt;
4915 &lt;/pool&gt;"""
4916             pool_mocks.append(pool_mock)
4917         self.mock_conn.listAllStoragePools.return_value = pool_mocks
4918         pool = virt.pool_info()
4919         self.assertEqual(
4920             {
4921                 "pool0": {
4922                     "uuid": "some-uuid-0",
4923                     "state": "inactive",
4924                     "capacity": 1234,
4925                     "allocation": 5678,
4926                     "free": 123,
4927                     "autostart": True,
4928                     "persistent": True,
4929                     "type": "dir",
4930                     "target_path": "/srv/vms",
4931                 },
4932                 "pool1": {
4933                     "uuid": "some-uuid-1",
4934                     "state": "inactive",
4935                     "capacity": 1234,
4936                     "allocation": 5678,
4937                     "free": 123,
4938                     "autostart": True,
4939                     "persistent": True,
4940                     "type": "dir",
4941                     "target_path": "/srv/vms",
4942                 },
4943             },
4944             pool,
4945         )
4946     def test_pool_get_xml(self):
4947         pool_mock = MagicMock()
4948         pool_mock.XMLDesc.return_value = "&lt;pool&gt;Raw XML&lt;/pool&gt;"
4949         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
4950         self.assertEqual("&lt;pool&gt;Raw XML&lt;/pool&gt;", virt.pool_get_xml("default"))
4951     def test_pool_list_volumes(self):
4952         names = ["volume1", "volume2"]
4953         mock_pool = MagicMock()
4954         mock_pool.listVolumes.return_value = names
4955         self.mock_conn.storagePoolLookupByName.return_value = mock_pool
4956         self.assertEqual(names, virt.pool_list_volumes("default"))
4957     @patch("salt.modules.virt._is_bhyve_hyper", return_value=False)
4958     @patch("salt.modules.virt._is_kvm_hyper", return_value=True)
4959     @patch("salt.modules.virt._is_xen_hyper", return_value=False)
4960     def test_get_hypervisor(self, isxen_mock, iskvm_mock, is_bhyve_mock):
4961         self.assertEqual("kvm", virt.get_hypervisor())
4962         iskvm_mock.return_value = False
4963         self.assertIsNone(virt.get_hypervisor())
4964         is_bhyve_mock.return_value = False
4965         self.assertIsNone(virt.get_hypervisor())
4966         isxen_mock.return_value = True
4967         self.assertEqual("xen", virt.get_hypervisor())
4968     def test_pool_delete(self):
4969         mock_pool = MagicMock()
4970         mock_pool.delete = MagicMock(return_value=0)
4971         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mock_pool)
4972         res = virt.pool_delete("test-pool")
4973         self.assertTrue(res)
4974         self.mock_conn.storagePoolLookupByName.assert_called_once_with("test-pool")
4975         mock_pool.delete.assert_called_once_with(
4976             self.mock_libvirt.VIR_STORAGE_POOL_DELETE_NORMAL
4977         )
4978     def test_pool_undefine_secret(self):
4979         mock_pool = MagicMock()
4980         mock_pool.undefine = MagicMock(return_value=0)
4981         mock_pool.XMLDesc.return_value = """
4982             &lt;pool type='rbd'&gt;
4983               &lt;name&gt;test-ses&lt;/name&gt;
4984               &lt;source&gt;
4985                 &lt;host name='myhost'/&gt;
4986                 &lt;name&gt;libvirt-pool&lt;/name&gt;
4987                 &lt;auth type='ceph' username='libvirt'&gt;
4988                   &lt;secret usage='pool_test-ses'/&gt;
4989                 &lt;/auth&gt;
4990               &lt;/source&gt;
4991             &lt;/pool&gt;
4992         """
4993         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mock_pool)
4994         mock_undefine = MagicMock(return_value=0)
4995         self.mock_conn.secretLookupByUsage.return_value.undefine = mock_undefine
4996         res = virt.pool_undefine("test-ses")
4997         self.assertTrue(res)
4998         self.mock_conn.storagePoolLookupByName.assert_called_once_with("test-ses")
4999         mock_pool.undefine.assert_called_once_with()
5000         self.mock_conn.secretLookupByUsage.assert_called_once_with(
5001             self.mock_libvirt.VIR_SECRET_USAGE_TYPE_CEPH, "pool_test-ses"
5002         )
5003         mock_undefine.assert_called_once()
5004     def test_full_info(self):
5005         xml = """&lt;domain type='kvm' id='7'&gt;
5006               &lt;uuid&gt;28deee33-4859-4f23-891c-ee239cffec94&lt;/uuid&gt;
5007               &lt;name&gt;test-vm&lt;/name&gt;
5008               &lt;on_poweroff&gt;destroy&lt;/on_poweroff&gt;
5009               &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
5010               &lt;on_crash&gt;destroy&lt;/on_crash&gt;
5011               &lt;devices&gt;
5012                 &lt;disk type='file' device='disk'&gt;
5013                 &lt;driver name='qemu' type='qcow2'/&gt;
5014                 &lt;source file='/disks/test.qcow2'/&gt;
5015                 &lt;target dev='vda' bus='virtio'/&gt;
5016               &lt;/disk&gt;
5017               &lt;disk type='file' device='cdrom'&gt;
5018                 &lt;driver name='qemu' type='raw'/&gt;
5019                 &lt;source file='/disks/test-cdrom.iso'/&gt;
5020                 &lt;target dev='hda' bus='ide'/&gt;
5021                 &lt;readonly/&gt;
5022               &lt;/disk&gt;
5023               &lt;interface type='bridge'&gt;
5024                 &lt;mac address='ac:de:48:b6:8b:59'/&gt;
5025                 &lt;source bridge='br0'/&gt;
5026                 &lt;model type='virtio'/&gt;
5027                 &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x03' function='0x0'/&gt;
5028               &lt;/interface&gt;
5029               &lt;graphics type='vnc' port='5900' autoport='yes' listen='0.0.0.0'&gt;
5030                 &lt;listen type='address' address='0.0.0.0'/&gt;
5031               &lt;/graphics&gt;
5032               &lt;/devices&gt;
5033             &lt;/domain&gt;
5034         """
5035         self.set_mock_vm("test-vm", xml)
5036         qemu_infos = """[{
5037             "virtual-size": 25769803776,
5038             "filename": "/disks/test.qcow2",
5039             "cluster-size": 65536,
5040             "format": "qcow2",
5041             "actual-size": 217088,
5042             "format-specific": {
5043                 "type": "qcow2",
5044                 "data": {
5045                     "compat": "1.1",
5046                     "lazy-refcounts": false,
5047                     "refcount-bits": 16,
5048                     "corrupt": false
5049                 }
5050             },
5051             "full-backing-filename": "/disks/mybacking.qcow2",
5052             "backing-filename": "mybacking.qcow2",
5053             "dirty-flag": false
5054         },
5055         {
5056             "virtual-size": 25769803776,
5057             "filename": "/disks/mybacking.qcow2",
5058             "cluster-size": 65536,
5059             "format": "qcow2",
5060             "actual-size": 393744384,
5061             "format-specific": {
5062                 "type": "qcow2",
5063                 "data": {
5064                     "compat": "1.1",
5065                     "lazy-refcounts": false,
5066                     "refcount-bits": 16,
5067                     "corrupt": false
5068                 }
5069             },
5070             "dirty-flag": false
5071         }]"""
5072         self.mock_popen.communicate.return_value = [qemu_infos, ""]
5073         self.mock_popen.returncode = 0
5074         self.mock_conn.getInfo = MagicMock(
5075             return_value=["x86_64", 4096, 8, 2712, 1, 2, 4, 2]
5076         )
5077         actual = virt.full_info()
5078         qemu_img_call = [
5079             call
5080             for call in self.mock_subprocess.Popen.call_args_list
5081             if "qemu-img" in call[0][0]
5082         ][0]
5083         self.assertIn("info", qemu_img_call[0][0])
5084         self.assertIn("-U", qemu_img_call[0][0])
5085         self.assertEqual(2816, actual["freemem"])
5086         self.assertEqual(6, actual["freecpu"])
5087         self.assertEqual(4, actual["node_info"]["cpucores"])
5088         self.assertEqual(2712, actual["node_info"]["cpumhz"])
5089         self.assertEqual("x86_64", actual["node_info"]["cpumodel"])
5090         self.assertEqual(8, actual["node_info"]["cpus"])
5091         self.assertEqual(2, actual["node_info"]["cputhreads"])
5092         self.assertEqual(1, actual["node_info"]["numanodes"])
5093         self.assertEqual(4096, actual["node_info"]["phymemory"])
5094         self.assertEqual(2, actual["node_info"]["sockets"])
5095         self.assertEqual(2, actual["vm_info"]["test-vm"]["cpu"])
5096         self.assertEqual(1234, actual["vm_info"]["test-vm"]["cputime"])
5097         self.assertEqual(1024 * 1024, actual["vm_info"]["test-vm"]["mem"])
5098         self.assertEqual(2048 * 1024, actual["vm_info"]["test-vm"]["maxMem"])
5099         self.assertEqual("shutdown", actual["vm_info"]["test-vm"]["state"])
5100         self.assertEqual(
5101             "28deee33-4859-4f23-891c-ee239cffec94", actual["vm_info"]["test-vm"]["uuid"]
5102         )
5103         self.assertEqual("destroy", actual["vm_info"]["test-vm"]["on_crash"])
5104         self.assertEqual("restart", actual["vm_info"]["test-vm"]["on_reboot"])
5105         self.assertEqual("destroy", actual["vm_info"]["test-vm"]["on_poweroff"])
5106         nic = actual["vm_info"]["test-vm"]["nics"]["ac:de:48:b6:8b:59"]
5107         self.assertEqual("bridge", nic["type"])
5108         self.assertEqual("ac:de:48:b6:8b:59", nic["mac"])
5109         disks = actual["vm_info"]["test-vm"]["disks"]
5110         disk = disks.get("vda")
5111         self.assertEqual("/disks/test.qcow2", disk["file"])
5112         self.assertEqual("disk", disk["type"])
5113         self.assertEqual("/disks/mybacking.qcow2", disk["backing file"]["file"])
5114         cdrom = disks.get("hda")
5115         self.assertEqual("/disks/test-cdrom.iso", cdrom["file"])
5116         self.assertEqual("cdrom", cdrom["type"])
5117         self.assertFalse("backing file" in cdrom.keys())
5118         graphics = actual["vm_info"]["test-vm"]["graphics"]
5119         self.assertEqual("vnc", graphics["type"])
5120         self.assertEqual("5900", graphics["port"])
5121         self.assertEqual("0.0.0.0", graphics["listen"])
5122     def test_pool_update(self):
5123         current_xml = """&lt;pool type='dir'&gt;
5124           &lt;name&gt;default&lt;/name&gt;
5125           &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
5126           &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
5127           &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
5128           &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
5129           &lt;source&gt;
5130           &lt;/source&gt;
5131           &lt;target&gt;
5132             &lt;path&gt;/path/to/pool&lt;/path&gt;
5133             &lt;permissions&gt;
5134               &lt;mode&gt;0775&lt;/mode&gt;
5135               &lt;owner&gt;0&lt;/owner&gt;
5136               &lt;group&gt;100&lt;/group&gt;
5137             &lt;/permissions&gt;
5138           &lt;/target&gt;
5139         &lt;/pool&gt;"""
5140         expected_xml = (
5141             '&lt;pool type="netfs"&gt;'
5142             "&lt;name&gt;default&lt;/name&gt;"
5143             "&lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;"
5144             '&lt;capacity unit="bytes"&gt;1999421108224&lt;/capacity&gt;'
5145             '&lt;allocation unit="bytes"&gt;713207042048&lt;/allocation&gt;'
5146             '&lt;available unit="bytes"&gt;1286214066176&lt;/available&gt;'
5147             "&lt;target&gt;"
5148             "&lt;path&gt;/mnt/cifs&lt;/path&gt;"
5149             "&lt;permissions&gt;"
5150             "&lt;mode&gt;0774&lt;/mode&gt;"
5151             "&lt;owner&gt;1234&lt;/owner&gt;"
5152             "&lt;group&gt;123&lt;/group&gt;"
5153             "&lt;/permissions&gt;"
5154             "&lt;/target&gt;"
5155             "&lt;source&gt;"
5156             '&lt;dir path="samba_share" /&gt;'
5157             '&lt;host name="one.example.com" /&gt;'
5158             '&lt;host name="two.example.com" /&gt;'
5159             '&lt;format type="cifs" /&gt;'
5160             "&lt;/source&gt;"
5161             "&lt;/pool&gt;"
5162         )
5163         mocked_pool = MagicMock()
5164         mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
5165         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
5166         self.mock_conn.storagePoolDefineXML = MagicMock()
5167         self.assertTrue(
5168             virt.pool_update(
5169                 "default",
5170                 "netfs",
5171                 target="/mnt/cifs",
5172                 permissions={"mode": "0774", "owner": "1234", "group": "123"},
5173                 source_format="cifs",
5174                 source_dir="samba_share",
5175                 source_hosts=["one.example.com", "two.example.com"],
5176             )
5177         )
5178         self.mock_conn.storagePoolDefineXML.assert_called_once_with(expected_xml)
5179     def test_pool_update_nochange(self):
5180         current_xml = """&lt;pool type='dir'&gt;
5181           &lt;name&gt;default&lt;/name&gt;
5182           &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
5183           &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
5184           &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
5185           &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
5186           &lt;source&gt;
5187           &lt;/source&gt;
5188           &lt;target&gt;
5189             &lt;path&gt;/path/to/pool&lt;/path&gt;
5190             &lt;permissions&gt;
5191               &lt;mode&gt;0775&lt;/mode&gt;
5192               &lt;owner&gt;0&lt;/owner&gt;
5193               &lt;group&gt;100&lt;/group&gt;
5194             &lt;/permissions&gt;
5195           &lt;/target&gt;
5196         &lt;/pool&gt;"""
5197         mocked_pool = MagicMock()
5198         mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
5199         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
5200         self.mock_conn.storagePoolDefineXML = MagicMock()
5201         self.assertFalse(
5202             virt.pool_update(
5203                 "default",
5204                 "dir",
5205                 target="/path/to/pool",
5206                 permissions={"mode": "0775", "owner": "0", "group": "100"},
5207                 test=True,
5208             )
5209         )
5210         self.mock_conn.storagePoolDefineXML.assert_not_called()
5211     def test_pool_update_password(self):
5212         current_xml = """&lt;pool type='rbd'&gt;
5213           &lt;name&gt;default&lt;/name&gt;
5214           &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
5215           &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
5216           &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
5217           &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
5218           &lt;source&gt;
5219             &lt;name&gt;iscsi-images&lt;/name&gt;
5220             &lt;host name='ses4.tf.local'/&gt;
5221             &lt;host name='ses5.tf.local'/&gt;
5222             &lt;auth username='libvirt' type='ceph'&gt;
5223               &lt;secret uuid='14e9a0f1-8fbf-4097-b816-5b094c182212'/&gt;
5224             &lt;/auth&gt;
5225           &lt;/source&gt;
5226         &lt;/pool&gt;"""
5227         mock_secret = MagicMock()
5228         self.mock_conn.secretLookupByUUIDString = MagicMock(return_value=mock_secret)
5229         mocked_pool = MagicMock()
5230         mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
5231         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
5232         self.mock_conn.storagePoolDefineXML = MagicMock()
5233         self.assertFalse(
5234             virt.pool_update(
5235                 "default",
5236                 "rbd",
5237                 source_name="iscsi-images",
5238                 source_hosts=["ses4.tf.local", "ses5.tf.local"],
5239                 source_auth={"username": "libvirt", "password": "c2VjcmV0"},
5240             )
5241         )
5242         self.mock_conn.storagePoolDefineXML.assert_not_called()
5243         mock_secret.setValue.assert_called_once_with(b"secret")
5244         self.mock_conn.secretLookupByUUIDString = MagicMock(
5245             side_effect=self.mock_libvirt.libvirtError("secret not found")
5246         )
5247         self.assertFalse(
5248             virt.pool_update(
5249                 "default",
5250                 "rbd",
5251                 source_name="iscsi-images",
5252                 source_hosts=["ses4.tf.local", "ses5.tf.local"],
5253                 source_auth={"username": "libvirt", "password": "c2VjcmV0"},
5254             )
5255         )
5256         self.mock_conn.storagePoolDefineXML.assert_not_called()
5257         self.mock_conn.secretDefineXML.assert_called_once()
5258         mock_secret.setValue.assert_called_once_with(b"secret")
5259     def test_pool_update_password_create(self):
5260         current_xml = """&lt;pool type='rbd'&gt;
5261           &lt;name&gt;default&lt;/name&gt;
5262           &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
5263           &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
5264           &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
5265           &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
5266           &lt;source&gt;
5267             &lt;name&gt;iscsi-images&lt;/name&gt;
5268             &lt;host name='ses4.tf.local'/&gt;
5269             &lt;host name='ses5.tf.local'/&gt;
5270           &lt;/source&gt;
5271         &lt;/pool&gt;"""
5272         expected_xml = (
5273             '&lt;pool type="rbd"&gt;'
5274             "&lt;name&gt;default&lt;/name&gt;"
5275             "&lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;"
5276             '&lt;capacity unit="bytes"&gt;1999421108224&lt;/capacity&gt;'
5277             '&lt;allocation unit="bytes"&gt;713207042048&lt;/allocation&gt;'
5278             '&lt;available unit="bytes"&gt;1286214066176&lt;/available&gt;'
5279             "&lt;source&gt;"
5280             '&lt;host name="ses4.tf.local" /&gt;'
5281             '&lt;host name="ses5.tf.local" /&gt;'
5282             '&lt;auth type="ceph" username="libvirt"&gt;'
5283             '&lt;secret usage="pool_default" /&gt;'
5284             "&lt;/auth&gt;"
5285             "&lt;name&gt;iscsi-images&lt;/name&gt;"
5286             "&lt;/source&gt;"
5287             "&lt;/pool&gt;"
5288         )
5289         mock_secret = MagicMock()
5290         self.mock_conn.secretDefineXML = MagicMock(return_value=mock_secret)
5291         mocked_pool = MagicMock()
5292         mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
5293         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
5294         self.mock_conn.storagePoolDefineXML = MagicMock()
5295         self.assertTrue(
5296             virt.pool_update(
5297                 "default",
5298                 "rbd",
5299                 source_name="iscsi-images",
5300                 source_hosts=["ses4.tf.local", "ses5.tf.local"],
5301                 source_auth={"username": "libvirt", "password": "c2VjcmV0"},
5302             )
5303         )
5304         self.mock_conn.storagePoolDefineXML.assert_called_once_with(expected_xml)
5305         mock_secret.setValue.assert_called_once_with(b"secret")
5306     def test_volume_infos(self):
5307         vms_disks = [
5308         ]
5309         mock_vms = []
5310         for idx, disk in enumerate(vms_disks):
5311             vm = MagicMock()
5312             vm.name.return_value = "vm{}".format(idx)
5313             vm.XMLDesc.return_value = """
5314                     &lt;domain type='kvm' id='1'&gt;
5315                       &lt;name&gt;vm{}&lt;/name&gt;
5316                       &lt;devices&gt;{}&lt;/devices&gt;
5317                     &lt;/domain&gt;
5318                 """.format(
5319                 idx, disk
5320             )
5321             mock_vms.append(vm)
5322         mock_pool_data = [
5323             {
5324                 "name": "pool0",
5325                 "state": self.mock_libvirt.VIR_STORAGE_POOL_RUNNING,
5326                 "volumes": [
5327                     {
5328                         "key": "/key/of/vol0",
5329                         "name": "vol0",
5330                         "path": "/path/to/vol0.qcow2",
5331                         "info": [0, 123456789, 123456],
5332                         "backingStore": None,
5333                     }
5334                 ],
5335             },
5336             {
5337                 "name": "pool1",
5338                 "state": self.mock_libvirt.VIR_STORAGE_POOL_RUNNING,
5339                 "volumes": [
5340                     {
5341                         "key": "/key/of/vol0bad",
5342                         "name": "vol0bad",
5343                         "path": "/path/to/vol0bad.qcow2",
5344                         "info": None,
5345                         "backingStore": None,
5346                     },
5347                     {
5348                         "key": "/key/of/vol1",
5349                         "name": "vol1",
5350                         "path": "/path/to/vol1.qcow2",
5351                         "info": [0, 12345, 1234],
5352                         "backingStore": None,
5353                     },
5354                     {
5355                         "key": "/key/of/vol2",
5356                         "name": "vol2",
5357                         "path": "/path/to/vol2.qcow2",
5358                         "info": [0, 12345, 1234],
5359                         "backingStore": "/path/to/vol0.qcow2",
5360                     },
5361                 ],
5362             },
5363         ]
5364         mock_pools = []
5365         for pool_data in mock_pool_data:
5366             mock_pool = MagicMock()
5367             mock_pool.name.return_value = pool_data["name"]  # pylint: disable=no-member
5368             mock_pool.info.return_value = [pool_data["state"]]
5369             mock_volumes = []
5370             for vol_data in pool_data["volumes"]:
5371                 mock_volume = MagicMock()
5372                 mock_volume.name.return_value = vol_data["name"]
5373                 mock_volume.key.return_value = vol_data["key"]
5374                 mock_volume.path.return_value = "/path/to/{}.qcow2".format(
5375                     vol_data["name"]
5376                 )
5377                 if vol_data["info"]:
5378                     mock_volume.info.return_value = vol_data["info"]
5379                     backing_store = (
5380                             vol_data["backingStore"]
5381                         )
5382                         if vol_data["backingStore"]
5383                         else "&lt;backingStore/&gt;"
5384                     )
5385                     mock_volume.XMLDesc.return_value = """
5386                         &lt;volume type='file'&gt;
5387                           &lt;name&gt;{0}&lt;/name&gt;
5388                           &lt;target&gt;
5389                             &lt;format type="qcow2"/&gt;
5390                             &lt;path&gt;/path/to/{0}.qcow2&lt;/path&gt;
5391                           &lt;/target&gt;
5392                           {1}
5393                         &lt;/volume&gt;
5394                     """.format(
5395                         vol_data["name"], backing_store
5396                     )
5397                 else:
5398                     mock_volume.info.side_effect = self.mock_libvirt.libvirtError(
5399                         "No such volume"
5400                     )
5401                     mock_volume.XMLDesc.side_effect = self.mock_libvirt.libvirtError(
5402                         "No such volume"
5403                     )
5404                 mock_volumes.append(mock_volume)
5405             mock_pool.listAllVolumes.return_value = (
5406                 mock_volumes  # pylint: disable=no-member
5407             )
5408             mock_pools.append(mock_pool)
5409         inactive_pool = MagicMock()
5410         inactive_pool.name.return_value = "pool2"
5411         inactive_pool.info.return_value = [self.mock_libvirt.VIR_STORAGE_POOL_INACTIVE]
5412         inactive_pool.listAllVolumes.side_effect = self.mock_libvirt.libvirtError(
5413             "pool is inactive"
5414         )
5415         mock_pools.append(inactive_pool)
5416         self.mock_conn.listAllStoragePools.return_value = (
5417             mock_pools  # pylint: disable=no-member
5418         )
5419         with patch("salt.modules.virt._get_domain", MagicMock(return_value=mock_vms)):
5420             actual = virt.volume_infos("pool0", "vol0")
5421             self.assertEqual(1, len(actual.keys()))
5422             self.assertEqual(1, len(actual["pool0"].keys()))
5423             self.assertEqual(["vm0", "vm2"], sorted(actual["pool0"]["vol0"]["used_by"]))
5424             self.assertEqual("/path/to/vol0.qcow2", actual["pool0"]["vol0"]["path"])
5425             self.assertEqual("file", actual["pool0"]["vol0"]["type"])
5426             self.assertEqual("/key/of/vol0", actual["pool0"]["vol0"]["key"])
5427             self.assertEqual(123456789, actual["pool0"]["vol0"]["capacity"])
5428             self.assertEqual(123456, actual["pool0"]["vol0"]["allocation"])
5429             self.assertEqual(
5430                 virt.volume_infos("pool1", None),
5431                 {
5432                     "pool1": {
5433                         "vol1": {
5434                             "type": "file",
5435                             "key": "/key/of/vol1",
5436                             "path": "/path/to/vol1.qcow2",
5437                             "capacity": 12345,
5438                             "allocation": 1234,
5439                             "used_by": [],
5440                             "backing_store": None,
5441                             "format": "qcow2",
5442                         },
5443                         "vol2": {
5444                             "type": "file",
5445                             "key": "/key/of/vol2",
5446                             "path": "/path/to/vol2.qcow2",
5447                             "capacity": 12345,
5448                             "allocation": 1234,
5449                             "used_by": ["vm2"],
5450                             "backing_store": {
5451                                 "path": "/path/to/vol0.qcow2",
5452                                 "format": "qcow2",
5453                             },
5454                             "format": "qcow2",
5455                         },
5456                     }
5457                 },
5458             )
5459             self.assertEqual(
5460                 virt.volume_infos(None, "vol2"),
5461                 {
5462                     "pool1": {
5463                         "vol2": {
5464                             "type": "file",
5465                             "key": "/key/of/vol2",
5466                             "path": "/path/to/vol2.qcow2",
5467                             "capacity": 12345,
5468                             "allocation": 1234,
5469                             "used_by": ["vm2"],
5470                             "backing_store": {
5471                                 "path": "/path/to/vol0.qcow2",
5472                                 "format": "qcow2",
5473                             },
5474                             "format": "qcow2",
5475                         }
5476                     }
5477                 },
5478             )
5479         with patch(
5480             "salt.modules.virt._get_domain", MagicMock(return_value=mock_vms[0])
5481         ):
5482             actual = virt.volume_infos("pool0", "vol0")
5483             self.assertEqual(1, len(actual.keys()))
5484             self.assertEqual(1, len(actual["pool0"].keys()))
5485             self.assertEqual(["vm0"], sorted(actual["pool0"]["vol0"]["used_by"]))
5486             self.assertEqual("/path/to/vol0.qcow2", actual["pool0"]["vol0"]["path"])
5487             self.assertEqual("file", actual["pool0"]["vol0"]["type"])
5488             self.assertEqual("/key/of/vol0", actual["pool0"]["vol0"]["key"])
5489             self.assertEqual(123456789, actual["pool0"]["vol0"]["capacity"])
5490             self.assertEqual(123456, actual["pool0"]["vol0"]["allocation"])
5491             self.assertEqual(
5492                 virt.volume_infos("pool1", None),
5493                 {
5494                     "pool1": {
5495                         "vol1": {
5496                             "type": "file",
5497                             "key": "/key/of/vol1",
5498                             "path": "/path/to/vol1.qcow2",
5499                             "capacity": 12345,
5500                             "allocation": 1234,
5501                             "used_by": [],
5502                             "backing_store": None,
5503                             "format": "qcow2",
5504                         },
5505                         "vol2": {
5506                             "type": "file",
5507                             "key": "/key/of/vol2",
5508                             "path": "/path/to/vol2.qcow2",
5509                             "capacity": 12345,
5510                             "allocation": 1234,
5511                             "used_by": [],
5512                             "backing_store": {
5513                                 "path": "/path/to/vol0.qcow2",
5514                                 "format": "qcow2",
5515                             },
5516                             "format": "qcow2",
5517                         },
5518                     }
5519                 },
5520             )
5521             self.assertEqual(
5522                 virt.volume_infos(None, "vol2"),
5523                 {
5524                     "pool1": {
5525                         "vol2": {
5526                             "type": "file",
5527                             "key": "/key/of/vol2",
5528                             "path": "/path/to/vol2.qcow2",
5529                             "capacity": 12345,
5530                             "allocation": 1234,
5531                             "used_by": [],
5532                             "backing_store": {
5533                                 "path": "/path/to/vol0.qcow2",
5534                                 "format": "qcow2",
5535                             },
5536                             "format": "qcow2",
5537                         }
5538                     }
5539                 },
5540             )
5541         with patch(
5542             "salt.modules.virt._get_domain",
5543             MagicMock(side_effect=CommandExecutionError("no VM")),
5544         ):
5545             actual = virt.volume_infos("pool0", "vol0")
5546             self.assertEqual(1, len(actual.keys()))
5547             self.assertEqual(1, len(actual["pool0"].keys()))
5548             self.assertEqual([], sorted(actual["pool0"]["vol0"]["used_by"]))
5549             self.assertEqual("/path/to/vol0.qcow2", actual["pool0"]["vol0"]["path"])
5550             self.assertEqual("file", actual["pool0"]["vol0"]["type"])
5551             self.assertEqual("/key/of/vol0", actual["pool0"]["vol0"]["key"])
5552             self.assertEqual(123456789, actual["pool0"]["vol0"]["capacity"])
5553             self.assertEqual(123456, actual["pool0"]["vol0"]["allocation"])
5554             self.assertEqual(
5555                 virt.volume_infos("pool1", None),
5556                 {
5557                     "pool1": {
5558                         "vol1": {
5559                             "type": "file",
5560                             "key": "/key/of/vol1",
5561                             "path": "/path/to/vol1.qcow2",
5562                             "capacity": 12345,
5563                             "allocation": 1234,
5564                             "used_by": [],
5565                             "backing_store": None,
5566                             "format": "qcow2",
5567                         },
5568                         "vol2": {
5569                             "type": "file",
5570                             "key": "/key/of/vol2",
5571                             "path": "/path/to/vol2.qcow2",
5572                             "capacity": 12345,
5573                             "allocation": 1234,
5574                             "used_by": [],
5575                             "backing_store": {
5576                                 "path": "/path/to/vol0.qcow2",
5577                                 "format": "qcow2",
5578                             },
5579                             "format": "qcow2",
5580                         },
5581                     }
5582                 },
5583             )
5584             self.assertEqual(
5585                 virt.volume_infos(None, "vol2"),
5586                 {
5587                     "pool1": {
5588                         "vol2": {
5589                             "type": "file",
5590                             "key": "/key/of/vol2",
5591                             "path": "/path/to/vol2.qcow2",
5592                             "capacity": 12345,
5593                             "allocation": 1234,
5594                             "used_by": [],
5595                             "backing_store": {
5596                                 "path": "/path/to/vol0.qcow2",
5597                                 "format": "qcow2",
5598                             },
5599                             "format": "qcow2",
5600                         }
5601                     }
5602                 },
5603             )
5604     def test_volume_delete(self):
5605         mock_delete = MagicMock(side_effect=[0, 1])
5606         mock_volume = MagicMock()
5607         mock_volume.delete = mock_delete  # pylint: disable=no-member
5608         mock_pool = MagicMock()
5609         mock_pool.storageVolLookupByName.side_effect = [
5610             mock_volume,
5611             mock_volume,
5612             self.mock_libvirt.libvirtError("Missing volume"),
5613             mock_volume,
5614         ]
5615         self.mock_conn.storagePoolLookupByName.side_effect = [
5616             mock_pool,
5617             mock_pool,
5618             mock_pool,
5619             self.mock_libvirt.libvirtError("Missing pool"),
5620         ]
5621         self.assertTrue(virt.volume_delete("default", "test_volume"))
5622         self.assertFalse(virt.volume_delete("default", "test_volume"))
5623         with self.assertRaises(self.mock_libvirt.libvirtError):
5624             virt.volume_delete("default", "missing")
5625             virt.volume_delete("missing", "test_volume")
5626         self.assertEqual(mock_delete.call_count, 2)
5627     def test_pool_capabilities(self):
5628         xml_caps = """
5629 &lt;storagepoolCapabilities&gt;
5630   &lt;pool type='disk' supported='yes'&gt;
5631     &lt;poolOptions&gt;
5632       &lt;defaultFormat type='unknown'/&gt;
5633       &lt;enum name='sourceFormatType'&gt;
5634         &lt;value&gt;unknown&lt;/value&gt;
5635         &lt;value&gt;dos&lt;/value&gt;
5636         &lt;value&gt;dvh&lt;/value&gt;
5637       &lt;/enum&gt;
5638     &lt;/poolOptions&gt;
5639     &lt;volOptions&gt;
5640       &lt;defaultFormat type='none'/&gt;
5641       &lt;enum name='targetFormatType'&gt;
5642         &lt;value&gt;none&lt;/value&gt;
5643         &lt;value&gt;linux&lt;/value&gt;
5644       &lt;/enum&gt;
5645     &lt;/volOptions&gt;
5646   &lt;/pool&gt;
5647   &lt;pool type='iscsi' supported='yes'&gt;
5648   &lt;/pool&gt;
5649   &lt;pool type='rbd' supported='yes'&gt;
5650     &lt;volOptions&gt;
5651       &lt;defaultFormat type='raw'/&gt;
5652       &lt;enum name='targetFormatType'&gt;
5653       &lt;/enum&gt;
5654     &lt;/volOptions&gt;
5655   &lt;/pool&gt;
5656   &lt;pool type='sheepdog' supported='no'&gt;
5657   &lt;/pool&gt;
5658 &lt;/storagepoolCapabilities&gt;
5659         """
5660         self.mock_conn.getStoragePoolCapabilities = MagicMock(return_value=xml_caps)
5661         actual = virt.pool_capabilities()
5662         self.assertEqual(
5663             {
5664                 "computed": False,
5665                 "pool_types": [
5666                     {
5667                         "name": "disk",
5668                         "supported": True,
5669                         "options": {
5670                             "pool": {
5671                                 "default_format": "unknown",
5672                                 "sourceFormatType": ["unknown", "dos", "dvh"],
5673                             },
5674                             "volume": {
5675                                 "default_format": "none",
5676                                 "targetFormatType": ["none", "linux"],
5677                             },
5678                         },
5679                     },
5680                     {"name": "iscsi", "supported": True},
5681                     {
5682                         "name": "rbd",
5683                         "supported": True,
5684                         "options": {
5685                             "volume": {"default_format": "raw", "targetFormatType": []}
5686                         },
5687                     },
5688                     {"name": "sheepdog", "supported": False},
5689                 ],
5690             },
5691             actual,
5692         )
5693     @patch("salt.modules.virt.get_hypervisor", return_value="kvm")
5694     def test_pool_capabilities_computed(self, mock_get_hypervisor):
5695         self.mock_conn.getLibVersion = MagicMock(return_value=4006000)
5696         del self.mock_conn.getStoragePoolCapabilities
5697         actual = virt.pool_capabilities()
5698         self.assertTrue(actual["computed"])
5699         backends = actual["pool_types"]
5700         self.assertFalse(
5701             [backend for backend in backends if backend["name"] == "iscsi-direct"][0][
5702                 "supported"
5703             ]
5704         )
5705         self.assertTrue(
5706             [backend for backend in backends if backend["name"] == "gluster"][0][
5707                 "supported"
5708             ]
5709         )
5710         self.assertFalse(
5711             [backend for backend in backends if backend["name"] == "zfs"][0][
5712                 "supported"
5713             ]
5714         )
5715         mock_get_hypervisor.return_value = "xen"
5716         backends = virt.pool_capabilities()["pool_types"]
5717         self.assertFalse(
5718             [backend for backend in backends if backend["name"] == "gluster"][0][
5719                 "supported"
5720             ]
5721         )
5722         mock_get_hypervisor.return_value = "bhyve"
5723         backends = virt.pool_capabilities()["pool_types"]
5724         self.assertFalse(
5725             [backend for backend in backends if backend["name"] == "gluster"][0][
5726                 "supported"
5727             ]
5728         )
5729         self.assertTrue(
5730             [backend for backend in backends if backend["name"] == "zfs"][0][
5731                 "supported"
5732             ]
5733         )
5734         self.assertNotIn(
5735             "options",
5736             [backend for backend in backends if backend["name"] == "iscsi"][0],
5737         )
5738         self.assertNotIn(
5739             "pool",
5740             [backend for backend in backends if backend["name"] == "dir"][0]["options"],
5741         )
5742         self.assertNotIn(
5743             "volume",
5744             [backend for backend in backends if backend["name"] == "logical"][0][
5745                 "options"
5746             ],
5747         )
5748         self.assertEqual(
5749             {
5750                 "pool": {
5751                     "default_format": "auto",
5752                     "sourceFormatType": ["auto", "nfs", "glusterfs", "cifs"],
5753                 },
5754                 "volume": {
5755                     "default_format": "raw",
5756                     "targetFormatType": [
5757                         "none",
5758                         "raw",
5759                         "dir",
5760                         "bochs",
5761                         "cloop",
5762                         "dmg",
5763                         "iso",
5764                         "vpc",
5765                         "vdi",
5766                         "fat",
5767                         "vhd",
5768                         "ploop",
5769                         "cow",
5770                         "qcow",
5771                         "qcow2",
5772                         "qed",
5773                         "vmdk",
5774                     ],
5775                 },
5776             },
5777             [backend for backend in backends if backend["name"] == "netfs"][0][
5778                 "options"
5779             ],
5780         )
5781     def test_get_domain(self):
5782         self.mock_conn.listDomainsID.return_value = []
5783         self.mock_conn.listDefinedDomains.return_value = []
5784         self.assertEqual([], virt._get_domain(self.mock_conn))
5785         self.assertRaisesRegex(
5786             CommandExecutionError,
5787             "No virtual machines found.",
5788             virt._get_domain,
5789             self.mock_conn,
5790             "vm2",
5791         )
5792         self.mock_conn.listDomainsID.return_value = [1]
5793         def create_mock_vm(idx):
5794             mock_vm = MagicMock()
5795             mock_vm.name.return_value = "vm{}".format(idx)
5796             return mock_vm
5797         mock_vms = [create_mock_vm(idx) for idx in range(3)]
5798         self.mock_conn.lookupByID.return_value = mock_vms[0]
5799         self.mock_conn.listDefinedDomains.return_value = ["vm1", "vm2"]
5800         self.mock_conn.lookupByName.side_effect = mock_vms
5801         self.assertEqual(mock_vms, virt._get_domain(self.mock_conn))
5802         self.mock_conn.lookupByName.side_effect = None
5803         self.mock_conn.lookupByName.return_value = mock_vms[0]
5804         self.assertEqual(mock_vms[0], virt._get_domain(self.mock_conn, inactive=False))
5805         self.mock_conn.lookupByName.return_value = None
5806         self.mock_conn.lookupByName.side_effect = [mock_vms[1], mock_vms[2]]
5807         self.assertEqual(
5808             [mock_vms[1], mock_vms[2]], virt._get_domain(self.mock_conn, active=False)
5809         )
5810         self.mock_conn.reset_mock()
5811         self.mock_conn.lookupByName.return_value = None
5812         self.mock_conn.lookupByName.side_effect = [mock_vms[1], mock_vms[2]]
5813         self.assertEqual(
5814             [mock_vms[1], mock_vms[2]], virt._get_domain(self.mock_conn, "vm1", "vm2")
5815         )
5816         self.assertRaisesRegex(
5817             CommandExecutionError,
5818             'The VM "vm2" is not present',
5819             virt._get_domain,
5820             self.mock_conn,
5821             "vm2",
5822             inactive=False,
5823         )
5824     def test_volume_define(self):
5825         pool_mock = MagicMock()
5826         pool_mock.XMLDesc.return_value = "&lt;pool type='dir'&gt;&lt;/pool&gt;"
5827         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
5828         self.assertTrue(
5829             virt.volume_define(
5830                 "testpool",
5831                 "myvm_system.qcow2",
5832                 8192,
5833                 allocation=4096,
5834                 format="qcow2",
5835                 type="file",
5836             )
5837         )
5838         expected_xml = (
5839             "&lt;volume type='file'&gt;\n"
5840             "  &lt;name&gt;myvm_system.qcow2&lt;/name&gt;\n"
5841             "  &lt;source&gt;\n"
5842             "  &lt;/source&gt;\n"
5843             "  &lt;capacity unit='KiB'&gt;8388608&lt;/capacity&gt;\n"
5844             "  &lt;allocation unit='KiB'&gt;4194304&lt;/allocation&gt;\n"
5845             "  &lt;target&gt;\n"
5846             "    &lt;format type='qcow2'/&gt;\n"
5847             "  &lt;/target&gt;\n"
5848             "&lt;/volume&gt;"
5849         )
5850         pool_mock.createXML.assert_called_once_with(expected_xml, 0)
5851         pool_mock.reset_mock()
5852         self.assertTrue(
5853             virt.volume_define(
5854                 "testpool",
5855                 "myvm_system.qcow2",
5856                 8192,
5857                 allocation=4096,
5858                 format="qcow2",
5859                 type="file",
5860                 backing_store={"path": "/path/to/base.raw", "format": "raw"},
5861             )
5862         )
5863         expected_xml = (
5864             "&lt;volume type='file'&gt;\n"
5865             "  &lt;name&gt;myvm_system.qcow2&lt;/name&gt;\n"
5866             "  &lt;source&gt;\n"
5867             "  &lt;/source&gt;\n"
5868             "  &lt;capacity unit='KiB'&gt;8388608&lt;/capacity&gt;\n"
5869             "  &lt;allocation unit='KiB'&gt;4194304&lt;/allocation&gt;\n"
5870             "  &lt;target&gt;\n"
5871             "    &lt;format type='qcow2'/&gt;\n"
5872             "  &lt;/target&gt;\n"
5873             "  &lt;backingStore&gt;\n"
5874             "    &lt;path&gt;/path/to/base.raw&lt;/path&gt;\n"
5875             "    &lt;format type='raw'/&gt;\n"
5876             "  &lt;/backingStore&gt;\n"
5877             "&lt;/volume&gt;"
5878         )
5879         pool_mock.createXML.assert_called_once_with(expected_xml, 0)
5880         pool_mock.reset_mock()
5881         pool_mock.XMLDesc.return_value = "&lt;pool type='logical'&gt;&lt;/pool&gt;"
5882         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
5883         self.assertTrue(
5884             virt.volume_define(
5885                 "testVG",
5886                 "myvm_system",
5887                 8192,
5888                 backing_store={"path": "/dev/testVG/base"},
5889             )
5890         )
5891         expected_xml = (
5892             "&lt;volume&gt;\n"
5893             "  &lt;name&gt;myvm_system&lt;/name&gt;\n"
5894             "  &lt;source&gt;\n"
5895             "  &lt;/source&gt;\n"
5896             "  &lt;capacity unit='KiB'&gt;8388608&lt;/capacity&gt;\n"
5897             "  &lt;allocation unit='KiB'&gt;8388608&lt;/allocation&gt;\n"
5898             "  &lt;target&gt;\n"
5899             "  &lt;/target&gt;\n"
5900             "  &lt;backingStore&gt;\n"
5901             "    &lt;path&gt;/dev/testVG/base&lt;/path&gt;\n"
5902             "  &lt;/backingStore&gt;\n"
5903             "&lt;/volume&gt;"
5904         )
5905         pool_mock.createXML.assert_called_once_with(expected_xml, 0)
5906     def test_volume_upload(self):
5907         pool_mock = MagicMock()
5908         vol_mock = MagicMock()
5909         pool_mock.storageVolLookupByName.return_value = vol_mock
5910         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
5911         stream_mock = MagicMock()
5912         self.mock_conn.newStream.return_value = stream_mock
5913         open_mock = MagicMock()
5914         close_mock = MagicMock()
5915         with patch.dict(
5916             os.__dict__, {"open": open_mock, "close": close_mock}
5917         ):  # pylint: disable=no-member
5918             self.assertTrue(virt.volume_upload("pool0", "vol1.qcow2", "/path/to/file"))
5919             stream_mock.sendAll.assert_called_once()
5920             stream_mock.finish.assert_called_once()
5921             self.mock_conn.close.assert_called_once()
5922             vol_mock.upload.assert_called_once_with(stream_mock, 0, 0, 0)
5923             stream_mock.sendAll.reset_mock()
5924             vol_mock.upload.reset_mock()
5925             self.assertTrue(
5926                 virt.volume_upload(
5927                     "pool0",
5928                     "vol1.qcow2",
5929                     "/path/to/file",
5930                     offset=123,
5931                     length=456,
5932                     sparse=True,
5933                 )
5934             )
5935             stream_mock.sendAll.assert_not_called()
5936             stream_mock.sparseSendAll.assert_called_once()
5937             vol_mock.upload.assert_called_once_with(
5938                 stream_mock,
5939                 123,
5940                 456,
5941                 self.mock_libvirt.VIR_STORAGE_VOL_UPLOAD_SPARSE_STREAM,
5942             )
5943             vol_mock.upload.side_effect = self.mock_libvirt.libvirtError("Unsupported")
5944             self.assertRaisesRegex(
5945                 CommandExecutionError,
5946                 "Unsupported",
5947                 virt.volume_upload,
5948                 "pool0",
5949                 "vol1.qcow2",
5950                 "/path/to/file",
5951             )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
