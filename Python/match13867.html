<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for layer1_10.py &amp; __init___141.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for layer1_10.py &amp; __init___141.py
      </h3>
<h1 align="center">
        2.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>layer1_10.py (4.347826%)<th>__init___141.py (1.6686531%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(565-602)<td><a href="#" name="0">(844-869)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>layer1_10.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import boto
2 from boto.connection import AWSQueryConnection
3 from boto.regioninfo import RegionInfo
4 from boto.exception import JSONResponseError
5 from boto.directconnect import exceptions
6 from boto.compat import json
7 class DirectConnectConnection(AWSQueryConnection):
8     APIVersion = "2012-10-25"
9     DefaultRegionName = "us-east-1"
10     DefaultRegionEndpoint = "directconnect.us-east-1.amazonaws.com"
11     ServiceName = "DirectConnect"
12     TargetPrefix = "OvertureService"
13     ResponseError = JSONResponseError
14     _faults = {
15         "DirectConnectClientException": exceptions.DirectConnectClientException,
16         "DirectConnectServerException": exceptions.DirectConnectServerException,
17     }
18     def __init__(self, **kwargs):
19         region = kwargs.pop('region', None)
20         if not region:
21             region = RegionInfo(self, self.DefaultRegionName,
22                                 self.DefaultRegionEndpoint)
23         if 'host' not in kwargs:
24             kwargs['host'] = region.endpoint
25         super(DirectConnectConnection, self).__init__(**kwargs)
26         self.region = region
27     def _required_auth_capability(self):
28         return ['hmac-v4']
29     def allocate_connection_on_interconnect(self, bandwidth, connection_name,
30                                             owner_account, interconnect_id,
31                                             vlan):
32         params = {
33             'bandwidth': bandwidth,
34             'connectionName': connection_name,
35             'ownerAccount': owner_account,
36             'interconnectId': interconnect_id,
37             'vlan': vlan,
38         }
39         return self.make_request(action='AllocateConnectionOnInterconnect',
40                                  body=json.dumps(params))
41     def allocate_private_virtual_interface(self, connection_id,
42                                            owner_account,
43                                            new_private_virtual_interface_allocation):
44         params = {
45             'connectionId': connection_id,
46             'ownerAccount': owner_account,
47             'newPrivateVirtualInterfaceAllocation': new_private_virtual_interface_allocation,
48         }
49         return self.make_request(action='AllocatePrivateVirtualInterface',
50                                  body=json.dumps(params))
51     def allocate_public_virtual_interface(self, connection_id, owner_account,
52                                           new_public_virtual_interface_allocation):
53         params = {
54             'connectionId': connection_id,
55             'ownerAccount': owner_account,
56             'newPublicVirtualInterfaceAllocation': new_public_virtual_interface_allocation,
57         }
58         return self.make_request(action='AllocatePublicVirtualInterface',
59                                  body=json.dumps(params))
60     def confirm_connection(self, connection_id):
61         params = {'connectionId': connection_id, }
62         return self.make_request(action='ConfirmConnection',
63                                  body=json.dumps(params))
64     def confirm_private_virtual_interface(self, virtual_interface_id,
65                                           virtual_gateway_id):
66         params = {
67             'virtualInterfaceId': virtual_interface_id,
68             'virtualGatewayId': virtual_gateway_id,
69         }
70         return self.make_request(action='ConfirmPrivateVirtualInterface',
71                                  body=json.dumps(params))
72     def confirm_public_virtual_interface(self, virtual_interface_id):
73         params = {'virtualInterfaceId': virtual_interface_id, }
74         return self.make_request(action='ConfirmPublicVirtualInterface',
75                                  body=json.dumps(params))
76     def create_connection(self, location, bandwidth, connection_name):
77         params = {
78             'location': location,
79             'bandwidth': bandwidth,
80             'connectionName': connection_name,
81         }
82         return self.make_request(action='CreateConnection',
83                                  body=json.dumps(params))
84     def create_interconnect(self, interconnect_name, bandwidth, location):
85         params = {
86             'interconnectName': interconnect_name,
87             'bandwidth': bandwidth,
88             'location': location,
89         }
90         return self.make_request(action='CreateInterconnect',
91                                  body=json.dumps(params))
92     def create_private_virtual_interface(self, connection_id,
93                                          new_private_virtual_interface):
94         params = {
95             'connectionId': connection_id,
96             'newPrivateVirtualInterface': new_private_virtual_interface,
97         }
98         return self.make_request(action='CreatePrivateVirtualInterface',
99                                  body=json.dumps(params))
100     def create_public_virtual_interface(self, connection_id,
101                                         new_public_virtual_interface):
102         params = {
103             'connectionId': connection_id,
104             'newPublicVirtualInterface': new_public_virtual_interface,
105         }
106         return self.make_request(action='CreatePublicVirtualInterface',
107                                  body=json.dumps(params))
108     def delete_connection(self, connection_id):
109         params = {'connectionId': connection_id, }
110         return self.make_request(action='DeleteConnection',
111                                  body=json.dumps(params))
112     def delete_interconnect(self, interconnect_id):
113         params = {'interconnectId': interconnect_id, }
114         return self.make_request(action='DeleteInterconnect',
115                                  body=json.dumps(params))
116     def delete_virtual_interface(self, virtual_interface_id):
117         params = {'virtualInterfaceId': virtual_interface_id, }
118         return self.make_request(action='DeleteVirtualInterface',
119                                  body=json.dumps(params))
120     def describe_connections(self, connection_id=None):
121         params = {}
122         if connection_id is not None:
123             params['connectionId'] = connection_id
124         return self.make_request(action='DescribeConnections',
125                                  body=json.dumps(params))
126     def describe_connections_on_interconnect(self, interconnect_id):
127         params = {'interconnectId': interconnect_id, }
128         return self.make_request(action='DescribeConnectionsOnInterconnect',
129                                  body=json.dumps(params))
130     def describe_interconnects(self, interconnect_id=None):
131         params = {}
132         if interconnect_id is not None:
133             params['interconnectId'] = interconnect_id
134         return self.make_request(action='DescribeInterconnects',
135                                  body=json.dumps(params))
136     def describe_locations(self):
137         params = {}
138         return self.make_request(action='DescribeLocations',
139                                  body=json.dumps(params))
140     def describe_virtual_gateways(self):
141         params = {}
142 <a name="0"></a>        return self.make_request(action='DescribeVirtualGateways',
143                                  body=json.dumps(params))
144     def describe_virtual_interfaces(self, connection_id<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None,
145                                     virtual_interface_id=None):
146         params = {}
147         if connection_id is not None:
148             params['connectionId'] = connection_id
149         if virtual_interface_id is not None:
150             params['virtualInterfaceId'] = virtual_interface_id
151         return self.make_request(</b></font>action='DescribeVirtualInterfaces',
152                                  body=json.dumps(params))
153     def make_request(self, action, body):
154         headers = {
155             'X-Amz-Target': '%s.%s' % (self.TargetPrefix, action),
156             'Host': self.region.endpoint,
157             'Content-Type': 'application/x-amz-json-1.1',
158             'Content-Length': str(len(body)),
159         }
160         http_request = self.build_base_http_request(
161             method='POST', path='/', auth_path='/', params={},
162             headers=headers, data=body)
163         response = self._mexe(http_request, sender=None,
164                               override_num_retries=10)
165         response_body = response.read().decode('utf-8')
166         boto.log.debug(response_body)
167         if response.status == 200:
168             if response_body:
169                 return json.loads(response_body)
170         else:
171             json_body = json.loads(response_body)
172             fault_name = json_body.get('__type', None)
173             exception_class = self._faults.get(fault_name, self.ResponseError)
174             raise exception_class(response.status, response.reason,
175                                   body=json_body)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>__init___141.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import base64
2 import boto
3 from boto.connection import AWSQueryConnection
4 from boto.regioninfo import RegionInfo, get_regions, load_regions
5 from boto.regioninfo import connect
6 from boto.ec2.autoscale.request import Request
7 from boto.ec2.autoscale.launchconfig import LaunchConfiguration
8 from boto.ec2.autoscale.group import AutoScalingGroup
9 from boto.ec2.autoscale.group import ProcessType
10 from boto.ec2.autoscale.activity import Activity
11 from boto.ec2.autoscale.policy import AdjustmentType
12 from boto.ec2.autoscale.policy import MetricCollectionTypes
13 from boto.ec2.autoscale.policy import ScalingPolicy
14 from boto.ec2.autoscale.policy import TerminationPolicies
15 from boto.ec2.autoscale.instance import Instance
16 from boto.ec2.autoscale.scheduled import ScheduledUpdateGroupAction
17 from boto.ec2.autoscale.tag import Tag
18 from boto.ec2.autoscale.limits import AccountLimits
19 from boto.compat import six
20 RegionData = load_regions().get('autoscaling', {})
21 def regions():
22     return get_regions('autoscaling', connection_cls=AutoScaleConnection)
23 def connect_to_region(region_name, **kw_params):
24     return connect('autoscaling', region_name,
25                    connection_cls=AutoScaleConnection, **kw_params)
26 class AutoScaleConnection(AWSQueryConnection):
27     APIVersion = boto.config.get('Boto', 'autoscale_version', '2011-01-01')
28     DefaultRegionEndpoint = boto.config.get('Boto', 'autoscale_endpoint',
29                                             'autoscaling.us-east-1.amazonaws.com')
30     DefaultRegionName = boto.config.get('Boto', 'autoscale_region_name',
31                                         'us-east-1')
32     def __init__(self, aws_access_key_id=None, aws_secret_access_key=None,
33                  is_secure=True, port=None, proxy=None, proxy_port=None,
34                  proxy_user=None, proxy_pass=None, debug=0,
35                  https_connection_factory=None, region=None, path='/',
36                  security_token=None, validate_certs=True, profile_name=None,
37                  use_block_device_types=False):
38         if not region:
39             region = RegionInfo(self, self.DefaultRegionName,
40                                 self.DefaultRegionEndpoint,
41                                 AutoScaleConnection)
42         self.region = region
43         self.use_block_device_types = use_block_device_types
44         super(AutoScaleConnection, self).__init__(aws_access_key_id,
45                                                   aws_secret_access_key,
46                                                   is_secure, port, proxy, proxy_port,
47                                                   proxy_user, proxy_pass,
48                                                   self.region.endpoint, debug,
49                                                   https_connection_factory, path=path,
50                                                   security_token=security_token,
51                                                   validate_certs=validate_certs,
52                                                   profile_name=profile_name)
53     def _required_auth_capability(self):
54         return ['hmac-v4']
55     def build_list_params(self, params, items, label):
56         for i in range(1, len(items) + 1):
57             if isinstance(items[i - 1], dict):
58                 for k, v in six.iteritems(items[i - 1]):
59                     if isinstance(v, dict):
60                         for kk, vv in six.iteritems(v):
61                             params['%s.member.%d.%s.%s' % (label, i, k, kk)] = vv
62                     else:
63                         params['%s.member.%d.%s' % (label, i, k)] = v
64             elif isinstance(items[i - 1], six.string_types):
65                 params['%s.member.%d' % (label, i)] = items[i - 1]
66     def _update_group(self, op, as_group):
67         params = {'AutoScalingGroupName': as_group.name,
68                   'LaunchConfigurationName': as_group.launch_config_name,
69                   'MinSize': as_group.min_size,
70                   'MaxSize': as_group.max_size}
71         zones = as_group.availability_zones
72         self.build_list_params(params, zones, 'AvailabilityZones')
73         if as_group.desired_capacity is not None:
74             params['DesiredCapacity'] = as_group.desired_capacity
75         if as_group.vpc_zone_identifier:
76             params['VPCZoneIdentifier'] = as_group.vpc_zone_identifier
77         if as_group.health_check_period:
78             params['HealthCheckGracePeriod'] = as_group.health_check_period
79         if as_group.health_check_type:
80             params['HealthCheckType'] = as_group.health_check_type
81         if as_group.default_cooldown:
82             params['DefaultCooldown'] = as_group.default_cooldown
83         if as_group.placement_group:
84             params['PlacementGroup'] = as_group.placement_group
85         if as_group.instance_id:
86             params['InstanceId'] = as_group.instance_id
87         if as_group.termination_policies:
88             self.build_list_params(params, as_group.termination_policies,
89                                    'TerminationPolicies')
90         if op.startswith('Create'):
91             if as_group.load_balancers:
92                 self.build_list_params(params, as_group.load_balancers,
93                                        'LoadBalancerNames')
94             if as_group.tags:
95                 for i, tag in enumerate(as_group.tags):
96                     tag.build_params(params, i + 1)
97         return self.get_object(op, params, Request)
98     def attach_instances(self, name, instance_ids):
99         params = {
100             'AutoScalingGroupName': name,
101         }
102         self.build_list_params(params, instance_ids, 'InstanceIds')
103         return self.get_status('AttachInstances', params)
104     def detach_instances(self, name, instance_ids, decrement_capacity=True):
105         params = {'AutoScalingGroupName': name}
106         params['ShouldDecrementDesiredCapacity'] = 'true' if decrement_capacity else 'false'
107         self.build_list_params(params, instance_ids, 'InstanceIds')
108         return self.get_status('DetachInstances', params)
109     def create_auto_scaling_group(self, as_group):
110         return self._update_group('CreateAutoScalingGroup', as_group)
111     def delete_auto_scaling_group(self, name, force_delete=False):
112         if(force_delete):
113             params = {'AutoScalingGroupName': name, 'ForceDelete': 'true'}
114         else:
115             params = {'AutoScalingGroupName': name}
116         return self.get_object('DeleteAutoScalingGroup', params, Request)
117     def create_launch_configuration(self, launch_config):
118         params = {'ImageId': launch_config.image_id,
119                   'LaunchConfigurationName': launch_config.name,
120                   'InstanceType': launch_config.instance_type}
121         if launch_config.key_name:
122             params['KeyName'] = launch_config.key_name
123         if launch_config.user_data:
124             user_data = launch_config.user_data
125             if isinstance(user_data, six.text_type):
126                 user_data = user_data.encode('utf-8')
127             params['UserData'] = base64.b64encode(user_data).decode('utf-8')
128         if launch_config.kernel_id:
129             params['KernelId'] = launch_config.kernel_id
130         if launch_config.ramdisk_id:
131             params['RamdiskId'] = launch_config.ramdisk_id
132         if launch_config.block_device_mappings:
133             [x.autoscale_build_list_params(params) for x in launch_config.block_device_mappings]
134         if launch_config.security_groups:
135             self.build_list_params(params, launch_config.security_groups,
136                                    'SecurityGroups')
137         if launch_config.instance_monitoring:
138             params['InstanceMonitoring.Enabled'] = 'true'
139         else:
140             params['InstanceMonitoring.Enabled'] = 'false'
141         if launch_config.spot_price is not None:
142             params['SpotPrice'] = str(launch_config.spot_price)
143         if launch_config.instance_profile_name is not None:
144             params['IamInstanceProfile'] = launch_config.instance_profile_name
145         if launch_config.ebs_optimized:
146             params['EbsOptimized'] = 'true'
147         else:
148             params['EbsOptimized'] = 'false'
149         if launch_config.associate_public_ip_address is True:
150             params['AssociatePublicIpAddress'] = 'true'
151         elif launch_config.associate_public_ip_address is False:
152             params['AssociatePublicIpAddress'] = 'false'
153         if launch_config.volume_type:
154             params['VolumeType'] = launch_config.volume_type
155         if launch_config.delete_on_termination:
156             params['DeleteOnTermination'] = 'true'
157         else:
158             params['DeleteOnTermination'] = 'false'
159         if launch_config.iops:
160             params['Iops'] = launch_config.iops
161         if launch_config.classic_link_vpc_id:
162             params['ClassicLinkVPCId'] = launch_config.classic_link_vpc_id
163         if launch_config.classic_link_vpc_security_groups:
164             self.build_list_params(
165                 params,
166                 launch_config.classic_link_vpc_security_groups,
167                 'ClassicLinkVPCSecurityGroups'
168             )
169         return self.get_object('CreateLaunchConfiguration', params,
170                                Request, verb='POST')
171     def get_account_limits(self):
172         params = {}
173         return self.get_object('DescribeAccountLimits', params, AccountLimits)
174     def create_scaling_policy(self, scaling_policy):
175         params = {'AdjustmentType': scaling_policy.adjustment_type,
176                   'AutoScalingGroupName': scaling_policy.as_name,
177                   'PolicyName': scaling_policy.name,
178                   'ScalingAdjustment': scaling_policy.scaling_adjustment}
179         if scaling_policy.adjustment_type == "PercentChangeInCapacity" and \
180            scaling_policy.min_adjustment_step is not None:
181             params['MinAdjustmentStep'] = scaling_policy.min_adjustment_step
182         if scaling_policy.cooldown is not None:
183             params['Cooldown'] = scaling_policy.cooldown
184         return self.get_object('PutScalingPolicy', params, Request)
185     def delete_launch_configuration(self, launch_config_name):
186         params = {'LaunchConfigurationName': launch_config_name}
187         return self.get_object('DeleteLaunchConfiguration', params, Request)
188     def get_all_groups(self, names=None, max_records=None, next_token=None):
189         params = {}
190         if max_records:
191             params['MaxRecords'] = max_records
192         if next_token:
193             params['NextToken'] = next_token
194         if names:
195             self.build_list_params(params, names, 'AutoScalingGroupNames')
196         return self.get_list('DescribeAutoScalingGroups', params,
197                              [('member', AutoScalingGroup)])
198     def get_all_launch_configurations(self, **kwargs):
199         params = {}
200         max_records = kwargs.get('max_records', None)
201         names = kwargs.get('names', None)
202         if max_records is not None:
203             params['MaxRecords'] = max_records
204         if names:
205             self.build_list_params(params, names, 'LaunchConfigurationNames')
206         next_token = kwargs.get('next_token')
207         if next_token:
208             params['NextToken'] = next_token
209         return self.get_list('DescribeLaunchConfigurations', params,
210                              [('member', LaunchConfiguration)])
211     def get_all_activities(self, autoscale_group, activity_ids=None,
212                            max_records=None, next_token=None):
213         name = autoscale_group
214         if isinstance(autoscale_group, AutoScalingGroup):
215             name = autoscale_group.name
216         params = {'AutoScalingGroupName': name}
217         if max_records:
218             params['MaxRecords'] = max_records
219         if next_token:
220             params['NextToken'] = next_token
221         if activity_ids:
222             self.build_list_params(params, activity_ids, 'ActivityIds')
223         return self.get_list('DescribeScalingActivities',
224                              params, [('member', Activity)])
225     def get_termination_policies(self):
226         return self.get_object('DescribeTerminationPolicyTypes',
227                                {}, TerminationPolicies)
228     def delete_scheduled_action(self, scheduled_action_name,
229                                 autoscale_group=None):
230         params = {'ScheduledActionName': scheduled_action_name}
231         if autoscale_group:
232             params['AutoScalingGroupName'] = autoscale_group
233         return self.get_status('DeleteScheduledAction', params)
234     def terminate_instance(self, instance_id, decrement_capacity=True):
235         params = {'InstanceId': instance_id}
236         if decrement_capacity:
237             params['ShouldDecrementDesiredCapacity'] = 'true'
238         else:
239             params['ShouldDecrementDesiredCapacity'] = 'false'
240         return self.get_object('TerminateInstanceInAutoScalingGroup', params,
241                                Activity)
242     def delete_policy(self, policy_name, autoscale_group=None):
243         params = {'PolicyName': policy_name}
244         if autoscale_group:
245             params['AutoScalingGroupName'] = autoscale_group
246         return self.get_status('DeletePolicy', params)
247     def get_all_adjustment_types(self):
248         return self.get_list('DescribeAdjustmentTypes', {},
249                              [('member', AdjustmentType)])
250     def get_all_autoscaling_instances(self, instance_ids=None,
251                                       max_records=None, next_token=None):
252         params = {}
253         if instance_ids:
254             self.build_list_params(params, instance_ids, 'InstanceIds')
255         if max_records:
256             params['MaxRecords'] = max_records
257         if next_token:
258             params['NextToken'] = next_token
259         return self.get_list('DescribeAutoScalingInstances',
260                              params, [('member', Instance)])
261     def get_all_metric_collection_types(self):
262         return self.get_object('DescribeMetricCollectionTypes',
263                                {}, MetricCollectionTypes)
264     def get_all_policies(self, as_group=None, policy_names=None,
265                          max_records=None, next_token=None):
266         params = {}
267         if as_group:
268             params['AutoScalingGroupName'] = as_group
269         if policy_names:
270             self.build_list_params(params, policy_names, 'PolicyNames')
271         if max_records:
272             params['MaxRecords'] = max_records
273         if next_token:
274             params['NextToken'] = next_token
275         return self.get_list('DescribePolicies', params,
276                              [('member', ScalingPolicy)])
277     def get_all_scaling_process_types(self):
278         return self.get_list('DescribeScalingProcessTypes', {},
279                              [('member', ProcessType)])
280     def suspend_processes(self, as_group, scaling_processes=None):
281         params = {'AutoScalingGroupName': as_group}
282         if scaling_processes:
283             self.build_list_params(params, scaling_processes,
284                                    'ScalingProcesses')
285         return self.get_status('SuspendProcesses', params)
286     def resume_processes(self, as_group, scaling_processes=None):
287         params = {'AutoScalingGroupName': as_group}
288         if scaling_processes:
289             self.build_list_params(params, scaling_processes,
290                                    'ScalingProcesses')
291         return self.get_status('ResumeProcesses', params)
292     def create_scheduled_group_action(self, as_group, name, time=None,
293                                       desired_capacity=None,
294                                       min_size=None, max_size=None,
295                                       start_time=None, end_time=None,
296                                       recurrence=None):
297         params = {'AutoScalingGroupName': as_group,
298                   'ScheduledActionName': name}
299         if start_time is not None:
300             params['StartTime'] = start_time.isoformat()
301         if end_time is not None:
302             params['EndTime'] = end_time.isoformat()
303         if recurrence is not None:
304             params['Recurrence'] = recurrence
305         if time:
306             params['Time'] = time.isoformat()
307         if desired_capacity is not None:
308             params['DesiredCapacity'] = desired_capacity
309         if min_size is not None:
310             params['MinSize'] = min_size
311         if max_size is not None:
312             params['MaxSize'] = max_size
313         return self.get_status('PutScheduledUpdateGroupAction', params)
314     def get_all_scheduled_actions(self, as_group=None, start_time=None,
315                                   end_time=None, scheduled_actions=None,
316                                   max_records=None, next_token=None):
317         params = {}
318         if as_group:
319             params['AutoScalingGroupName'] = as_group
320         if scheduled_actions:
321             self.build_list_params(params, scheduled_actions,
322                                    'ScheduledActionNames')
323         if max_records:
324             params['MaxRecords'] = max_records
325         if next_token:
326             params['NextToken'] = next_token
327         return self.get_list('DescribeScheduledActions', params,
328                              [('member', ScheduledUpdateGroupAction)])
329     def disable_metrics_collection(self, as_group, metrics=None):
330         params = {'AutoScalingGroupName': as_group}
331         if metrics:
332             self.build_list_params(params, metrics, 'Metrics')
333         return self.get_status('DisableMetricsCollection', params)
334     def enable_metrics_collection(self, as_group, granularity, metrics=None):
335         params = {'AutoScalingGroupName': as_group,
336                   'Granularity': granularity}
337         if metrics:
338             self.build_list_params(params, metrics, 'Metrics')
339         return self.get_status('EnableMetricsCollection', params)
340     def execute_policy(self, policy_name, as_group=None, honor_cooldown=None):
341         params = {'PolicyName': policy_name}
342         if as_group:
343             params['AutoScalingGroupName'] = as_group
344         if honor_cooldown:
345             params['HonorCooldown'] = honor_cooldown
346         return self.get_status('ExecutePolicy', params)
347     def put_notification_configuration(self, autoscale_group, topic, notification_types):
348         name = autoscale_group
349         if isinstance(autoscale_group, AutoScalingGroup):
350             name = autoscale_group.name
351         params = {'AutoScalingGroupName': name,
352                   'TopicARN': topic}
353         self.build_list_params(params, notification_types, 'NotificationTypes')
354         return self.get_status('PutNotificationConfiguration', params)
355     def delete_notification_configuration(self, autoscale_group, topic):
356         name = autoscale_group
357         if isinstance(autoscale_group, AutoScalingGroup):
358             name = autoscale_group.name
359         params = {'AutoScalingGroupName': name,
360                   'TopicARN': topic}
361         return self.get_status('DeleteNotificationConfiguration', params)
362     def set_instance_health(self, instance_id, health_status,
363                             should_respect_grace_period=True):
364         params = {'InstanceId': instance_id,
365                   'HealthStatus': health_status}
366         if should_respect_grace_period:
367             params['ShouldRespectGracePeriod'] = 'true'
368         else:
369             params['ShouldRespectGracePeriod'] = 'false'
370         return self.get_status('SetInstanceHealth', params)
371     def set_desired_capacity(self, group_name, desired_capacity, honor_cooldown=False):
372         params = {'AutoScalingGroupName': group_name,
373                   'DesiredCapacity': desired_capacity}
374         if honor_cooldown:
375             params['HonorCooldown'] = 'true'
376         return self.get_status('SetDesiredCapacity', params)
377 <a name="0"></a>
378     def get_all_tags(self, filters=None, max_records<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None, next_token=None):
379         params = {}
380         if max_records:
381             params['MaxRecords'] = max_records
382         if next_token:
383             params['NextToken'] = next_token
384         return self.get_list(</b></font>'DescribeTags', params,
385                              [('member', Tag)])
386     def create_or_update_tags(self, tags):
387         params = {}
388         for i, tag in enumerate(tags):
389             tag.build_params(params, i + 1)
390         return self.get_status('CreateOrUpdateTags', params, verb='POST')
391     def delete_tags(self, tags):
392         params = {}
393         for i, tag in enumerate(tags):
394             tag.build_params(params, i + 1)
395         return self.get_status('DeleteTags', params, verb='POST')
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
