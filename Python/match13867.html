<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for layer1_10.py &amp; __init___141.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for layer1_10.py &amp; __init___141.py
      </h3>
<h1 align="center">
        2.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>layer1_10.py (4.347826%)<th>__init___141.py (1.6686531%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(565-602)<td><a href="#" name="0">(844-869)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>layer1_10.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import boto
from boto.connection import AWSQueryConnection
from boto.regioninfo import RegionInfo
from boto.exception import JSONResponseError
from boto.directconnect import exceptions
from boto.compat import json
class DirectConnectConnection(AWSQueryConnection):
    APIVersion = "2012-10-25"
    DefaultRegionName = "us-east-1"
    DefaultRegionEndpoint = "directconnect.us-east-1.amazonaws.com"
    ServiceName = "DirectConnect"
    TargetPrefix = "OvertureService"
    ResponseError = JSONResponseError
    _faults = {
        "DirectConnectClientException": exceptions.DirectConnectClientException,
        "DirectConnectServerException": exceptions.DirectConnectServerException,
    }
    def __init__(self, **kwargs):
        region = kwargs.pop('region', None)
        if not region:
            region = RegionInfo(self, self.DefaultRegionName,
                                self.DefaultRegionEndpoint)
        if 'host' not in kwargs:
            kwargs['host'] = region.endpoint
        super(DirectConnectConnection, self).__init__(**kwargs)
        self.region = region
    def _required_auth_capability(self):
        return ['hmac-v4']
    def allocate_connection_on_interconnect(self, bandwidth, connection_name,
                                            owner_account, interconnect_id,
                                            vlan):
        params = {
            'bandwidth': bandwidth,
            'connectionName': connection_name,
            'ownerAccount': owner_account,
            'interconnectId': interconnect_id,
            'vlan': vlan,
        }
        return self.make_request(action='AllocateConnectionOnInterconnect',
                                 body=json.dumps(params))
    def allocate_private_virtual_interface(self, connection_id,
                                           owner_account,
                                           new_private_virtual_interface_allocation):
        params = {
            'connectionId': connection_id,
            'ownerAccount': owner_account,
            'newPrivateVirtualInterfaceAllocation': new_private_virtual_interface_allocation,
        }
        return self.make_request(action='AllocatePrivateVirtualInterface',
                                 body=json.dumps(params))
    def allocate_public_virtual_interface(self, connection_id, owner_account,
                                          new_public_virtual_interface_allocation):
        params = {
            'connectionId': connection_id,
            'ownerAccount': owner_account,
            'newPublicVirtualInterfaceAllocation': new_public_virtual_interface_allocation,
        }
        return self.make_request(action='AllocatePublicVirtualInterface',
                                 body=json.dumps(params))
    def confirm_connection(self, connection_id):
        params = {'connectionId': connection_id, }
        return self.make_request(action='ConfirmConnection',
                                 body=json.dumps(params))
    def confirm_private_virtual_interface(self, virtual_interface_id,
                                          virtual_gateway_id):
        params = {
            'virtualInterfaceId': virtual_interface_id,
            'virtualGatewayId': virtual_gateway_id,
        }
        return self.make_request(action='ConfirmPrivateVirtualInterface',
                                 body=json.dumps(params))
    def confirm_public_virtual_interface(self, virtual_interface_id):
        params = {'virtualInterfaceId': virtual_interface_id, }
        return self.make_request(action='ConfirmPublicVirtualInterface',
                                 body=json.dumps(params))
    def create_connection(self, location, bandwidth, connection_name):
        params = {
            'location': location,
            'bandwidth': bandwidth,
            'connectionName': connection_name,
        }
        return self.make_request(action='CreateConnection',
                                 body=json.dumps(params))
    def create_interconnect(self, interconnect_name, bandwidth, location):
        params = {
            'interconnectName': interconnect_name,
            'bandwidth': bandwidth,
            'location': location,
        }
        return self.make_request(action='CreateInterconnect',
                                 body=json.dumps(params))
    def create_private_virtual_interface(self, connection_id,
                                         new_private_virtual_interface):
        params = {
            'connectionId': connection_id,
            'newPrivateVirtualInterface': new_private_virtual_interface,
        }
        return self.make_request(action='CreatePrivateVirtualInterface',
                                 body=json.dumps(params))
    def create_public_virtual_interface(self, connection_id,
                                        new_public_virtual_interface):
        params = {
            'connectionId': connection_id,
            'newPublicVirtualInterface': new_public_virtual_interface,
        }
        return self.make_request(action='CreatePublicVirtualInterface',
                                 body=json.dumps(params))
    def delete_connection(self, connection_id):
        params = {'connectionId': connection_id, }
        return self.make_request(action='DeleteConnection',
                                 body=json.dumps(params))
    def delete_interconnect(self, interconnect_id):
        params = {'interconnectId': interconnect_id, }
        return self.make_request(action='DeleteInterconnect',
                                 body=json.dumps(params))
    def delete_virtual_interface(self, virtual_interface_id):
        params = {'virtualInterfaceId': virtual_interface_id, }
        return self.make_request(action='DeleteVirtualInterface',
                                 body=json.dumps(params))
    def describe_connections(self, connection_id=None):
        params = {}
        if connection_id is not None:
            params['connectionId'] = connection_id
        return self.make_request(action='DescribeConnections',
                                 body=json.dumps(params))
    def describe_connections_on_interconnect(self, interconnect_id):
        params = {'interconnectId': interconnect_id, }
        return self.make_request(action='DescribeConnectionsOnInterconnect',
                                 body=json.dumps(params))
    def describe_interconnects(self, interconnect_id=None):
        params = {}
        if interconnect_id is not None:
            params['interconnectId'] = interconnect_id
        return self.make_request(action='DescribeInterconnects',
                                 body=json.dumps(params))
    def describe_locations(self):
        params = {}
        return self.make_request(action='DescribeLocations',
                                 body=json.dumps(params))
    def describe_virtual_gateways(self):
        params = {}
<a name="0"></a>        return self.make_request(action='DescribeVirtualGateways',
                                 body=json.dumps(params))
    def describe_virtual_interfaces(self, connection_id<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None,
                                    virtual_interface_id=None):
        params = {}
        if connection_id is not None:
            params['connectionId'] = connection_id
        if virtual_interface_id is not None:
            params['virtualInterfaceId'] = virtual_interface_id
        return self.make_request(</b></font>action='DescribeVirtualInterfaces',
                                 body=json.dumps(params))
    def make_request(self, action, body):
        headers = {
            'X-Amz-Target': '%s.%s' % (self.TargetPrefix, action),
            'Host': self.region.endpoint,
            'Content-Type': 'application/x-amz-json-1.1',
            'Content-Length': str(len(body)),
        }
        http_request = self.build_base_http_request(
            method='POST', path='/', auth_path='/', params={},
            headers=headers, data=body)
        response = self._mexe(http_request, sender=None,
                              override_num_retries=10)
        response_body = response.read().decode('utf-8')
        boto.log.debug(response_body)
        if response.status == 200:
            if response_body:
                return json.loads(response_body)
        else:
            json_body = json.loads(response_body)
            fault_name = json_body.get('__type', None)
            exception_class = self._faults.get(fault_name, self.ResponseError)
            raise exception_class(response.status, response.reason,
                                  body=json_body)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>__init___141.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import base64
import boto
from boto.connection import AWSQueryConnection
from boto.regioninfo import RegionInfo, get_regions, load_regions
from boto.regioninfo import connect
from boto.ec2.autoscale.request import Request
from boto.ec2.autoscale.launchconfig import LaunchConfiguration
from boto.ec2.autoscale.group import AutoScalingGroup
from boto.ec2.autoscale.group import ProcessType
from boto.ec2.autoscale.activity import Activity
from boto.ec2.autoscale.policy import AdjustmentType
from boto.ec2.autoscale.policy import MetricCollectionTypes
from boto.ec2.autoscale.policy import ScalingPolicy
from boto.ec2.autoscale.policy import TerminationPolicies
from boto.ec2.autoscale.instance import Instance
from boto.ec2.autoscale.scheduled import ScheduledUpdateGroupAction
from boto.ec2.autoscale.tag import Tag
from boto.ec2.autoscale.limits import AccountLimits
from boto.compat import six
RegionData = load_regions().get('autoscaling', {})
def regions():
    return get_regions('autoscaling', connection_cls=AutoScaleConnection)
def connect_to_region(region_name, **kw_params):
    return connect('autoscaling', region_name,
                   connection_cls=AutoScaleConnection, **kw_params)
class AutoScaleConnection(AWSQueryConnection):
    APIVersion = boto.config.get('Boto', 'autoscale_version', '2011-01-01')
    DefaultRegionEndpoint = boto.config.get('Boto', 'autoscale_endpoint',
                                            'autoscaling.us-east-1.amazonaws.com')
    DefaultRegionName = boto.config.get('Boto', 'autoscale_region_name',
                                        'us-east-1')
    def __init__(self, aws_access_key_id=None, aws_secret_access_key=None,
                 is_secure=True, port=None, proxy=None, proxy_port=None,
                 proxy_user=None, proxy_pass=None, debug=0,
                 https_connection_factory=None, region=None, path='/',
                 security_token=None, validate_certs=True, profile_name=None,
                 use_block_device_types=False):
        if not region:
            region = RegionInfo(self, self.DefaultRegionName,
                                self.DefaultRegionEndpoint,
                                AutoScaleConnection)
        self.region = region
        self.use_block_device_types = use_block_device_types
        super(AutoScaleConnection, self).__init__(aws_access_key_id,
                                                  aws_secret_access_key,
                                                  is_secure, port, proxy, proxy_port,
                                                  proxy_user, proxy_pass,
                                                  self.region.endpoint, debug,
                                                  https_connection_factory, path=path,
                                                  security_token=security_token,
                                                  validate_certs=validate_certs,
                                                  profile_name=profile_name)
    def _required_auth_capability(self):
        return ['hmac-v4']
    def build_list_params(self, params, items, label):
        for i in range(1, len(items) + 1):
            if isinstance(items[i - 1], dict):
                for k, v in six.iteritems(items[i - 1]):
                    if isinstance(v, dict):
                        for kk, vv in six.iteritems(v):
                            params['%s.member.%d.%s.%s' % (label, i, k, kk)] = vv
                    else:
                        params['%s.member.%d.%s' % (label, i, k)] = v
            elif isinstance(items[i - 1], six.string_types):
                params['%s.member.%d' % (label, i)] = items[i - 1]
    def _update_group(self, op, as_group):
        params = {'AutoScalingGroupName': as_group.name,
                  'LaunchConfigurationName': as_group.launch_config_name,
                  'MinSize': as_group.min_size,
                  'MaxSize': as_group.max_size}
        zones = as_group.availability_zones
        self.build_list_params(params, zones, 'AvailabilityZones')
        if as_group.desired_capacity is not None:
            params['DesiredCapacity'] = as_group.desired_capacity
        if as_group.vpc_zone_identifier:
            params['VPCZoneIdentifier'] = as_group.vpc_zone_identifier
        if as_group.health_check_period:
            params['HealthCheckGracePeriod'] = as_group.health_check_period
        if as_group.health_check_type:
            params['HealthCheckType'] = as_group.health_check_type
        if as_group.default_cooldown:
            params['DefaultCooldown'] = as_group.default_cooldown
        if as_group.placement_group:
            params['PlacementGroup'] = as_group.placement_group
        if as_group.instance_id:
            params['InstanceId'] = as_group.instance_id
        if as_group.termination_policies:
            self.build_list_params(params, as_group.termination_policies,
                                   'TerminationPolicies')
        if op.startswith('Create'):
            if as_group.load_balancers:
                self.build_list_params(params, as_group.load_balancers,
                                       'LoadBalancerNames')
            if as_group.tags:
                for i, tag in enumerate(as_group.tags):
                    tag.build_params(params, i + 1)
        return self.get_object(op, params, Request)
    def attach_instances(self, name, instance_ids):
        params = {
            'AutoScalingGroupName': name,
        }
        self.build_list_params(params, instance_ids, 'InstanceIds')
        return self.get_status('AttachInstances', params)
    def detach_instances(self, name, instance_ids, decrement_capacity=True):
        params = {'AutoScalingGroupName': name}
        params['ShouldDecrementDesiredCapacity'] = 'true' if decrement_capacity else 'false'
        self.build_list_params(params, instance_ids, 'InstanceIds')
        return self.get_status('DetachInstances', params)
    def create_auto_scaling_group(self, as_group):
        return self._update_group('CreateAutoScalingGroup', as_group)
    def delete_auto_scaling_group(self, name, force_delete=False):
        if(force_delete):
            params = {'AutoScalingGroupName': name, 'ForceDelete': 'true'}
        else:
            params = {'AutoScalingGroupName': name}
        return self.get_object('DeleteAutoScalingGroup', params, Request)
    def create_launch_configuration(self, launch_config):
        params = {'ImageId': launch_config.image_id,
                  'LaunchConfigurationName': launch_config.name,
                  'InstanceType': launch_config.instance_type}
        if launch_config.key_name:
            params['KeyName'] = launch_config.key_name
        if launch_config.user_data:
            user_data = launch_config.user_data
            if isinstance(user_data, six.text_type):
                user_data = user_data.encode('utf-8')
            params['UserData'] = base64.b64encode(user_data).decode('utf-8')
        if launch_config.kernel_id:
            params['KernelId'] = launch_config.kernel_id
        if launch_config.ramdisk_id:
            params['RamdiskId'] = launch_config.ramdisk_id
        if launch_config.block_device_mappings:
            [x.autoscale_build_list_params(params) for x in launch_config.block_device_mappings]
        if launch_config.security_groups:
            self.build_list_params(params, launch_config.security_groups,
                                   'SecurityGroups')
        if launch_config.instance_monitoring:
            params['InstanceMonitoring.Enabled'] = 'true'
        else:
            params['InstanceMonitoring.Enabled'] = 'false'
        if launch_config.spot_price is not None:
            params['SpotPrice'] = str(launch_config.spot_price)
        if launch_config.instance_profile_name is not None:
            params['IamInstanceProfile'] = launch_config.instance_profile_name
        if launch_config.ebs_optimized:
            params['EbsOptimized'] = 'true'
        else:
            params['EbsOptimized'] = 'false'
        if launch_config.associate_public_ip_address is True:
            params['AssociatePublicIpAddress'] = 'true'
        elif launch_config.associate_public_ip_address is False:
            params['AssociatePublicIpAddress'] = 'false'
        if launch_config.volume_type:
            params['VolumeType'] = launch_config.volume_type
        if launch_config.delete_on_termination:
            params['DeleteOnTermination'] = 'true'
        else:
            params['DeleteOnTermination'] = 'false'
        if launch_config.iops:
            params['Iops'] = launch_config.iops
        if launch_config.classic_link_vpc_id:
            params['ClassicLinkVPCId'] = launch_config.classic_link_vpc_id
        if launch_config.classic_link_vpc_security_groups:
            self.build_list_params(
                params,
                launch_config.classic_link_vpc_security_groups,
                'ClassicLinkVPCSecurityGroups'
            )
        return self.get_object('CreateLaunchConfiguration', params,
                               Request, verb='POST')
    def get_account_limits(self):
        params = {}
        return self.get_object('DescribeAccountLimits', params, AccountLimits)
    def create_scaling_policy(self, scaling_policy):
        params = {'AdjustmentType': scaling_policy.adjustment_type,
                  'AutoScalingGroupName': scaling_policy.as_name,
                  'PolicyName': scaling_policy.name,
                  'ScalingAdjustment': scaling_policy.scaling_adjustment}
        if scaling_policy.adjustment_type == "PercentChangeInCapacity" and \
           scaling_policy.min_adjustment_step is not None:
            params['MinAdjustmentStep'] = scaling_policy.min_adjustment_step
        if scaling_policy.cooldown is not None:
            params['Cooldown'] = scaling_policy.cooldown
        return self.get_object('PutScalingPolicy', params, Request)
    def delete_launch_configuration(self, launch_config_name):
        params = {'LaunchConfigurationName': launch_config_name}
        return self.get_object('DeleteLaunchConfiguration', params, Request)
    def get_all_groups(self, names=None, max_records=None, next_token=None):
        params = {}
        if max_records:
            params['MaxRecords'] = max_records
        if next_token:
            params['NextToken'] = next_token
        if names:
            self.build_list_params(params, names, 'AutoScalingGroupNames')
        return self.get_list('DescribeAutoScalingGroups', params,
                             [('member', AutoScalingGroup)])
    def get_all_launch_configurations(self, **kwargs):
        params = {}
        max_records = kwargs.get('max_records', None)
        names = kwargs.get('names', None)
        if max_records is not None:
            params['MaxRecords'] = max_records
        if names:
            self.build_list_params(params, names, 'LaunchConfigurationNames')
        next_token = kwargs.get('next_token')
        if next_token:
            params['NextToken'] = next_token
        return self.get_list('DescribeLaunchConfigurations', params,
                             [('member', LaunchConfiguration)])
    def get_all_activities(self, autoscale_group, activity_ids=None,
                           max_records=None, next_token=None):
        name = autoscale_group
        if isinstance(autoscale_group, AutoScalingGroup):
            name = autoscale_group.name
        params = {'AutoScalingGroupName': name}
        if max_records:
            params['MaxRecords'] = max_records
        if next_token:
            params['NextToken'] = next_token
        if activity_ids:
            self.build_list_params(params, activity_ids, 'ActivityIds')
        return self.get_list('DescribeScalingActivities',
                             params, [('member', Activity)])
    def get_termination_policies(self):
        return self.get_object('DescribeTerminationPolicyTypes',
                               {}, TerminationPolicies)
    def delete_scheduled_action(self, scheduled_action_name,
                                autoscale_group=None):
        params = {'ScheduledActionName': scheduled_action_name}
        if autoscale_group:
            params['AutoScalingGroupName'] = autoscale_group
        return self.get_status('DeleteScheduledAction', params)
    def terminate_instance(self, instance_id, decrement_capacity=True):
        params = {'InstanceId': instance_id}
        if decrement_capacity:
            params['ShouldDecrementDesiredCapacity'] = 'true'
        else:
            params['ShouldDecrementDesiredCapacity'] = 'false'
        return self.get_object('TerminateInstanceInAutoScalingGroup', params,
                               Activity)
    def delete_policy(self, policy_name, autoscale_group=None):
        params = {'PolicyName': policy_name}
        if autoscale_group:
            params['AutoScalingGroupName'] = autoscale_group
        return self.get_status('DeletePolicy', params)
    def get_all_adjustment_types(self):
        return self.get_list('DescribeAdjustmentTypes', {},
                             [('member', AdjustmentType)])
    def get_all_autoscaling_instances(self, instance_ids=None,
                                      max_records=None, next_token=None):
        params = {}
        if instance_ids:
            self.build_list_params(params, instance_ids, 'InstanceIds')
        if max_records:
            params['MaxRecords'] = max_records
        if next_token:
            params['NextToken'] = next_token
        return self.get_list('DescribeAutoScalingInstances',
                             params, [('member', Instance)])
    def get_all_metric_collection_types(self):
        return self.get_object('DescribeMetricCollectionTypes',
                               {}, MetricCollectionTypes)
    def get_all_policies(self, as_group=None, policy_names=None,
                         max_records=None, next_token=None):
        params = {}
        if as_group:
            params['AutoScalingGroupName'] = as_group
        if policy_names:
            self.build_list_params(params, policy_names, 'PolicyNames')
        if max_records:
            params['MaxRecords'] = max_records
        if next_token:
            params['NextToken'] = next_token
        return self.get_list('DescribePolicies', params,
                             [('member', ScalingPolicy)])
    def get_all_scaling_process_types(self):
        return self.get_list('DescribeScalingProcessTypes', {},
                             [('member', ProcessType)])
    def suspend_processes(self, as_group, scaling_processes=None):
        params = {'AutoScalingGroupName': as_group}
        if scaling_processes:
            self.build_list_params(params, scaling_processes,
                                   'ScalingProcesses')
        return self.get_status('SuspendProcesses', params)
    def resume_processes(self, as_group, scaling_processes=None):
        params = {'AutoScalingGroupName': as_group}
        if scaling_processes:
            self.build_list_params(params, scaling_processes,
                                   'ScalingProcesses')
        return self.get_status('ResumeProcesses', params)
    def create_scheduled_group_action(self, as_group, name, time=None,
                                      desired_capacity=None,
                                      min_size=None, max_size=None,
                                      start_time=None, end_time=None,
                                      recurrence=None):
        params = {'AutoScalingGroupName': as_group,
                  'ScheduledActionName': name}
        if start_time is not None:
            params['StartTime'] = start_time.isoformat()
        if end_time is not None:
            params['EndTime'] = end_time.isoformat()
        if recurrence is not None:
            params['Recurrence'] = recurrence
        if time:
            params['Time'] = time.isoformat()
        if desired_capacity is not None:
            params['DesiredCapacity'] = desired_capacity
        if min_size is not None:
            params['MinSize'] = min_size
        if max_size is not None:
            params['MaxSize'] = max_size
        return self.get_status('PutScheduledUpdateGroupAction', params)
    def get_all_scheduled_actions(self, as_group=None, start_time=None,
                                  end_time=None, scheduled_actions=None,
                                  max_records=None, next_token=None):
        params = {}
        if as_group:
            params['AutoScalingGroupName'] = as_group
        if scheduled_actions:
            self.build_list_params(params, scheduled_actions,
                                   'ScheduledActionNames')
        if max_records:
            params['MaxRecords'] = max_records
        if next_token:
            params['NextToken'] = next_token
        return self.get_list('DescribeScheduledActions', params,
                             [('member', ScheduledUpdateGroupAction)])
    def disable_metrics_collection(self, as_group, metrics=None):
        params = {'AutoScalingGroupName': as_group}
        if metrics:
            self.build_list_params(params, metrics, 'Metrics')
        return self.get_status('DisableMetricsCollection', params)
    def enable_metrics_collection(self, as_group, granularity, metrics=None):
        params = {'AutoScalingGroupName': as_group,
                  'Granularity': granularity}
        if metrics:
            self.build_list_params(params, metrics, 'Metrics')
        return self.get_status('EnableMetricsCollection', params)
    def execute_policy(self, policy_name, as_group=None, honor_cooldown=None):
        params = {'PolicyName': policy_name}
        if as_group:
            params['AutoScalingGroupName'] = as_group
        if honor_cooldown:
            params['HonorCooldown'] = honor_cooldown
        return self.get_status('ExecutePolicy', params)
    def put_notification_configuration(self, autoscale_group, topic, notification_types):
        name = autoscale_group
        if isinstance(autoscale_group, AutoScalingGroup):
            name = autoscale_group.name
        params = {'AutoScalingGroupName': name,
                  'TopicARN': topic}
        self.build_list_params(params, notification_types, 'NotificationTypes')
        return self.get_status('PutNotificationConfiguration', params)
    def delete_notification_configuration(self, autoscale_group, topic):
        name = autoscale_group
        if isinstance(autoscale_group, AutoScalingGroup):
            name = autoscale_group.name
        params = {'AutoScalingGroupName': name,
                  'TopicARN': topic}
        return self.get_status('DeleteNotificationConfiguration', params)
    def set_instance_health(self, instance_id, health_status,
                            should_respect_grace_period=True):
        params = {'InstanceId': instance_id,
                  'HealthStatus': health_status}
        if should_respect_grace_period:
            params['ShouldRespectGracePeriod'] = 'true'
        else:
            params['ShouldRespectGracePeriod'] = 'false'
        return self.get_status('SetInstanceHealth', params)
    def set_desired_capacity(self, group_name, desired_capacity, honor_cooldown=False):
        params = {'AutoScalingGroupName': group_name,
                  'DesiredCapacity': desired_capacity}
        if honor_cooldown:
            params['HonorCooldown'] = 'true'
        return self.get_status('SetDesiredCapacity', params)
<a name="0"></a>
    def get_all_tags(self, filters=None, max_records<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None, next_token=None):
        params = {}
        if max_records:
            params['MaxRecords'] = max_records
        if next_token:
            params['NextToken'] = next_token
        return self.get_list(</b></font>'DescribeTags', params,
                             [('member', Tag)])
    def create_or_update_tags(self, tags):
        params = {}
        for i, tag in enumerate(tags):
            tag.build_params(params, i + 1)
        return self.get_status('CreateOrUpdateTags', params, verb='POST')
    def delete_tags(self, tags):
        params = {}
        for i, tag in enumerate(tags):
            tag.build_params(params, i + 1)
        return self.get_status('DeleteTags', params, verb='POST')
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
