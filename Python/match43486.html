<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for collector.py &amp; queues_test.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for collector.py &amp; queues_test.py
      </h3>
<h1 align="center">
        6.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>collector.py (6.5677967%)<th>queues_test.py (6.1386137%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(483-486)<td><a href="#" name="0">(73-75)</a><td align="center"><font color="#ff0000">13</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(364-369)<td><a href="#" name="1">(69-72)</a><td align="center"><font color="#ff0000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(498-507)<td><a href="#" name="2">(368-371)</a><td align="center"><font color="#eb0000">12</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(383-385)<td><a href="#" name="3">(28-30)</a><td align="center"><font color="#eb0000">12</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(191-194)<td><a href="#" name="4">(104-107)</a><td align="center"><font color="#eb0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>collector.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import os
3 import subprocess
4 import sys
5 import salt.utils.crypt
6 import salt.utils.files
7 import salt.utils.fsutils
8 import salt.utils.path
9 import salt.utils.stringutils
10 from salt.exceptions import CommandExecutionError
11 from salt.modules.inspectlib import EnvLoader, kiwiproc
12 from salt.modules.inspectlib.entities import (
13     AllowedDir,
14     IgnoredDir,
15     Package,
16     PackageCfgFile,
17     PayloadFile,
18 )
19 from salt.modules.inspectlib.exceptions import InspectorSnapshotException
20 try:
21     import kiwi
22 except ImportError:
23     kiwi = None
24 log = logging.getLogger(__name__)
25 class Inspector(EnvLoader):
26     DEFAULT_MINION_CONFIG_PATH = "/etc/salt/minion"
27     MODE = ["configuration", "payload", "all"]
28     IGNORE_MOUNTS = ["proc", "sysfs", "devtmpfs", "tmpfs", "fuse.gvfs-fuse-daemon"]
29     IGNORE_FS_TYPES = ["autofs", "cifs", "nfs", "nfs4"]
30     IGNORE_PATHS = [
31         "/tmp",
32         "/var/tmp",
33         "/lost+found",
34         "/var/run",
35         "/var/lib/rpm",
36         "/.snapshots",
37         "/.zfs",
38         "/etc/ssh",
39         "/root",
40         "/home",
41     ]
42     def __init__(self, cachedir=None, piddir=None, pidfilename=None):
43         EnvLoader.__init__(
44             self, cachedir=cachedir, piddir=piddir, pidfilename=pidfilename
45         )
46     def create_snapshot(self):
47         self.db.open(new=True)
48         return self
49     def reuse_snapshot(self):
50         self.db.open()
51         return self
52     def _syscall(self, command, input=None, env=None, *params):
53         return subprocess.Popen(
54             [command] + list(params),
55             stdout=subprocess.PIPE,
56             stdin=subprocess.PIPE,
57             stderr=subprocess.STDOUT,
58             env=env or os.environ,
59         ).communicate(input=input)
60     def _get_cfg_pkgs(self):
61         if self.grains_core.os_data().get("os_family") == "Debian":
62             return self.__get_cfg_pkgs_dpkg()
63         elif self.grains_core.os_data().get("os_family") in ["Suse", "redhat"]:
64             return self.__get_cfg_pkgs_rpm()
65         else:
66             return dict()
67     def __get_cfg_pkgs_dpkg(self):
68         data = dict()
69         for pkg_name in salt.utils.stringutils.to_str(
70             self._syscall("dpkg-query", None, None, "-Wf", "${binary:Package}\\n")[0]
71         ).split(os.linesep):
72             pkg_name = pkg_name.strip()
73             if not pkg_name:
74                 continue
75             data[pkg_name] = list()
76             for pkg_cfg_item in salt.utils.stringutils.to_str(
77                 self._syscall(
78                     "dpkg-query", None, None, "-Wf", "${Conffiles}\\n", pkg_name
79                 )[0]
80             ).split(os.linesep):
81                 pkg_cfg_item = pkg_cfg_item.strip()
82                 if not pkg_cfg_item:
83                     continue
84                 pkg_cfg_file, pkg_cfg_sum = pkg_cfg_item.strip().split(" ", 1)
85                 data[pkg_name].append(pkg_cfg_file)
86             if not data[pkg_name]:
87                 data.pop(pkg_name)
88         return data
89     def __get_cfg_pkgs_rpm(self):
90         out, err = self._syscall(
91             "rpm",
92             None,
93             None,
94             "-qa",
95             "--configfiles",
96             "--queryformat",
97             "%{name}-%{version}-%{release}\\n",
98         )
99         data = dict()
100         pkg_name = None
101         pkg_configs = []
102         out = salt.utils.stringutils.to_str(out)
103         for line in out.split(os.linesep):
104             line = line.strip()
105             if not line:
106                 continue
107             if not line.startswith("/"):
108                 if pkg_name and pkg_configs:
109                     data[pkg_name] = pkg_configs
110                 pkg_name = line
111                 pkg_configs = []
112             else:
113                 pkg_configs.append(line)
114         if pkg_name and pkg_configs:
115             data[pkg_name] = pkg_configs
116         return data
117     def _get_changed_cfg_pkgs(self, data):
118         f_data = dict()
119         for pkg_name, pkg_files in data.items():
120             cfg_data = list()
121             if self.grains_core.os_data().get("os_family") == "Debian":
122                 cfg_data = salt.utils.stringutils<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.to_str(
123                     self._syscall("dpkg", None, None, "--verify", pkg_name)[0]
124                 ).split(os.linesep)
125             elif self.grains_core.os_data().</b></font>get("os_family") in ["Suse", "redhat"]:
126                 cfg_data = salt.utils.stringutils.to_str(
127                     self._syscall(
128                         "rpm",
129                         None,
130                         None,
131                         "-V",
132                         "--nodeps",
133                         "--nodigest",
134                         "--nosignature",
135                         "--nomtime",
136                         "--nolinkto",
137                         pkg_name,
138                     )[0]
139                 ).split(os.linesep)
140             for line in cfg_data:
141                 line = line.strip()
142                 if not line or line.find(" c ") &lt; 0 or line.split(" ")[0].find("5") &lt; 0:
143                     continue
144                 cfg_file = line.split(" ")[-1]
145                 if cfg_file in pkg_files:
146                     cfgs.append(cfg_file)
147             if cfgs:
148                 f_data[pkg_name] = cfgs
149         return f_data
150     def _save_cfg_packages(self, data):
151         pkg_id = 0
152         pkg_cfg_id = 0
153         for pkg_name, pkg_configs in data.items():
154             pkg = Package()
155             pkg.id = pkg_id
156             pkg.name = pkg_name
157             self.db.store(pkg)
158             for pkg_config in pkg_configs:
159                 cfg = PackageCfgFile()
160                 cfg.id = pkg_cfg_id
161                 cfg.pkgid = pkg_id
162                 cfg.path = pkg_config
163                 self.db.store(cfg)
164                 pkg_cfg_id += 1
165             pkg_id += 1
166     def _save_payload(self, files, directories, links):
167         idx = 0
168         for p_type, p_list in (
169             ("f", files),
170             ("d", directories),
171             ("l", links),
172         ):
173             for p_obj in p_list:
174                 stats = os.stat(p_obj)
175                 payload = PayloadFile()
176                 payload.id = idx
177                 payload.path = p_obj
178                 payload.p_type = p_type
179                 payload.mode = stats.st_mode
180                 payload.uid = stats.st_uid
181                 payload.gid = stats.st_gid
182                 payload.p_size = stats.st_size
183                 payload.atime = stats.st_atime
184                 payload.mtime = stats.st_mtime
185                 payload.ctime = stats.st_ctime
186                 idx += 1
187                 self.db.store(payload)
188     def _get_managed_files(self):
189         if self.grains_core.os_data().get("os_family") == "Debian":
190             return self.__get_managed_files_dpkg()
191         elif self.grains_core.os_data().get("os_family") in ["Suse", "redhat"]:
192             return self.__get_managed_files_rpm()
193         return list(), list(), list()
194     def __get_managed_files_dpkg(self):
195         dirs = set()
196         links = set()
197         files = set()
198         for pkg_name in salt.utils.stringutils.to_str(
199             self._syscall("dpkg-query", None, None, "-Wf", "${binary:Package}\\n")[0]
200         ).split(os.linesep):
201             pkg_name = pkg_name.strip()
202             if not pkg_name:
203                 continue
204             for resource in salt.utils.stringutils.to_str(
205                 self._syscall("dpkg", None, None, "-L", pkg_name)[0]
206             ).split(os.linesep):
207                 resource = resource.strip()
208                 if not resource or resource in ["/", "./", "."]:
209                     continue
210                 if os.path.isdir(resource):
211                     dirs.add(resource)
212                 elif os.path.islink(resource):
213                     links.add(resource)
214                 elif os.path.isfile(resource):
215                     files.add(resource)
216         return sorted(files), sorted(dirs), sorted(links)
217     def __get_managed_files_rpm(self):
218         dirs = set()
219         links = set()
220         files = set()
221         for line in salt.utils.stringutils.to_str(
222             self._syscall("rpm", None, None, "-qlav")[0]
223         ).split(os.linesep):
224             line = line.strip()
225             if not line:
226                 continue
227             line = line.replace("\t", " ").split(" ")
228             if line[0][0] == "d":
229                 dirs.add(line[-1])
230             elif line[0][0] == "l":
231                 links.add(line[-1])
232             elif line[0][0] == "-":
233                 files.add(line[-1])
234         return sorted(files), sorted(dirs), sorted(links)
235     def _get_all_files(self, path, *exclude):
236         files = list()
237         dirs = list()
238         links = list()
239         if os.access(path, os.R_OK):
240             for obj in os.listdir(path):
241                 obj = os.path.join(path, obj)
242                 valid = True
243                 for ex_obj in exclude:
244                     if obj.startswith(str(ex_obj)):
245                         valid = False
246                         continue
247                 if not valid or not os.path.exists(obj) or not os.access(obj, os.R_OK):
248                 if salt.utils.path.islink(obj):
249                     links.append(obj)
250                 elif os.path<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.isdir(obj):
251                     dirs.append(obj)
252                     f_obj, d_obj, l_obj = self._get_all_files(obj, *exclude)
253                     files.extend(f_obj)
254                     dirs.extend(d_obj)
255                     links.extend(</b></font>l_obj)
256                 elif os.path.isfile(obj):
257                     files.append(obj)
258         return sorted(files), sorted(dirs), sorted(links)
259     def _get_unmanaged_files(self, managed, system_all):
260         m_files, m_dirs, m_links = managed
261         return (
262             sorted(list(set(s_files)<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.difference(m_files))),
263             sorted(list(set(s_dirs).difference(m_dirs))),
264             sorted(list(set(s_links).difference(</b></font>m_links))),
265         )
266     def _scan_payload(self):
267         allowed = list()
268         for allowed_dir in self.db.get(AllowedDir):
269             if os.path.exists(allowed_dir.path):
270                 allowed.append(allowed_dir.path)
271         ignored = list()
272         if not allowed:
273             for ignored_dir in self.db.get(IgnoredDir):
274                 if os.path.exists(ignored_dir.path):
275                     ignored.append(ignored_dir.path)
276         all_files = list()
277         all_dirs = list()
278         all_links = list()
279         for entry_path in [pth for pth in (allowed or os.listdir("/")) if pth]:
280             if entry_path[0] != "/":
281                 entry_path = "/{}".format(entry_path)
282             if entry_path in ignored or os.path.islink(entry_path):
283                 continue
284             e_files, e_dirs, e_links = self._get_all_files(entry_path, *ignored)
285             all_files.extend(e_files)
286             all_dirs.extend(e_dirs)
287             all_links.extend(e_links)
288         return self._get_unmanaged_files(
289             self._get_managed_files(),
290             (
291                 all_files,
292                 all_dirs,
293                 all_links,
294             ),
295         )
296     def _prepare_full_scan(self, **kwargs):
297         self.db.open(new=True)
298         ignored_fs = set()
299         ignored_fs |= set(self.IGNORE_PATHS)
300         mounts = salt.utils.fsutils._get_mounts()
301         for device, data in mounts.items():
302             if device in self.IGNORE_MOUNTS:
303                 for mpt in data:
304                     ignored_fs.add(mpt["mount_point"])
305                 continue
306             for mpt in data:
307                 if mpt["type"] in self.IGNORE_FS_TYPES:
308                     ignored_fs.add(mpt["mount_point"])
309         ignored_all = list()
310         for entry in sorted(list(ignored_fs)):
311             valid = True
312             for e_entry in ignored_all:
313                 if entry.startswith(e_entry):
314                     valid = False
315                     break
316             if valid:
317                 ignored_all.append(entry)
318         for ignored_dir in ignored_all:
319             dir_obj = IgnoredDir()
320             dir_obj.path = ignored_dir
321             self.db.store(dir_obj)
322         allowed = [elm for elm in kwargs.get("filter", "").split(",") if elm]
323         for allowed_dir in allowed:
324             dir_obj = AllowedDir()
325             dir_obj.path = allowed_dir
326             self.db.store(dir_obj)
327         return ignored_all
328     def _init_env(self):
329         from salt.config import minion_config
330         from salt.grains import core as g_core
331         g_core.__opts__ = minion_config(self.DEFAULT_MINION_CONFIG_PATH)
332         self.grains_core = g_core
333     def snapshot(self, mode):
334         Take a snapshot of the system.
335         """
336         self<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>._init_env()
337         self._save_cfg_packages(self._get_changed_cfg_pkgs(self._get_cfg_pkgs()))
338         self._save_payload(*self._scan_payload(</b></font>))
339     def request_snapshot(self, mode, priority=19, **kwargs):
340         """
341         Take a snapshot of the system.
342         """
343         if mode not in self.MODE:
344             raise InspectorSnapshotException("Unknown mode: '{}'".format(mode))
345             raise CommandExecutionError("Inspection already in progress.")
346         self<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>._prepare_full_scan(**kwargs)
347         subprocess.run(
348             [
349                 "nice",
350                 "-{}".format(priority),
351                 "python",
352                 __file__,
353                 os.path.dirname(self.pidfile),
354                 os.</b></font>path.dirname(self.dbfile),
355                 mode,
356             ],
357             check=False,
358             stdout=subprocess.DEVNULL,
359             stderr=subprocess.DEVNULL,
360         )
361     def export(self, description, local=False, path="/tmp", format="qcow2"):
362         """
363         Export description for Kiwi.
364         :param local:
365         :param path:
366         :return:
367         """
368         kiwiproc.__salt__ = __salt__
369         return (
370             kiwiproc.KiwiExporter(grains=__grains__, format=format)
371             .load(**description)
372             .export("something")
373         )
374     def build(self, format="qcow2", path="/tmp"):
375         """
376         Build an image using Kiwi.
377         :param format:
378         :param path:
379         :return:
380         """
381         if kiwi is None:
382             msg = (
383                 "Unable to build the image due to the missing dependencies: Kiwi module"
384                 " is not available."
385             )
386             log.error(msg)
387             raise CommandExecutionError(msg)
388         raise CommandExecutionError("Build is not yet implemented")
389 def is_alive(pidfile):
390     """
391     Check if PID is still alive.
392     """
393     try:
394         with salt.utils.files.fopen(pidfile) as fp_:
395             os.kill(int(fp_.read().strip()), 0)
396         return True
397     except Exception as ex:  # pylint: disable=broad-except
398         if os.access(pidfile, os.W_OK) and os.path.isfile(pidfile):
399             os.unlink(pidfile)
400         return False
401 def main(dbfile, pidfile, mode):
402     """
403     Main analyzer routine.
404     """
405     Inspector(dbfile, pidfile).reuse_snapshot().snapshot(mode)
406 if __name__ == "__main__":
407     if len(sys.argv) != 4:
408         print("This module is not intended to use directly!", file=sys.stderr)
409         sys.exit(1)
410     pidfile, dbfile, mode = sys.argv[1:]  # pylint: disable=unbalanced-tuple-unpacking
411     if is_alive(pidfile):
412         sys.exit(1)
413     try:
414         if os.fork() &gt; 0:
415             salt.utils.crypt.reinit_crypto()
416             sys.exit(0)
417         else:
418             salt.utils.crypt.reinit_crypto()
419     except OSError as ex:
420         sys.exit(1)
421     os.setsid()
422     os.umask(0o000)  # pylint: disable=blacklisted-function
423     try:
424         pid = os.fork()
425         if pid &gt; 0:
426             salt.utils.crypt.reinit_crypto()
427             with salt.utils.files.fopen(
428                 os.path.join(pidfile, EnvLoader.PID_FILE), "w"
429             ) as fp_:
430                 fp_.write("{}\n".format(pid))
431             sys.exit(0)
432     except OSError as ex:
433         sys.exit(1)
434     salt.utils.crypt.reinit_crypto()
435     main(dbfile, pidfile, mode)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>queues_test.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from __future__ import absolute_import, division, print_function
2 from datetime import timedelta
3 from random import random
4 from salt.ext.tornado import gen, queues
5 from salt.ext.tornado.gen import TimeoutError
6 from salt.ext.tornado.testing import gen_test, AsyncTestCase
7 from salt.ext.tornado.test.util import unittest, skipBefore35, exec_test
8     def test_repr_and_str(self):
9         q = queues.Queue(maxsize=1)
10         self<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertIn(hex(id(q)), repr(q))
11         self.assertNotIn(hex(id(q)), str(q))
12         q.get(</b></font>)
13         for q_str in repr(q), str(q):
14             self.assertTrue(q_str.startswith('&lt;Queue'))
15             self.assertIn('maxsize=1', q_str)
16             self.assertIn('getters[1]', q_str)
17             self.assertNotIn('putters', q_str)
18             self.assertNotIn('tasks', q_str)
19         q.put(None)
20         q.put(None)
21         q.put(None)
22         for q_str in repr(q), str(q):
23             self.assertNotIn('getters', q_str)
24             self.assertIn('putters[1]', q_str)
25             self.assertIn('tasks=2', q_str)
26     def test_order(self):
27         q = queues.Queue()
28         for i in [1, 3, 2]:
29             q.put_nowait(i)
30         items = [q.get_nowait() for _ in range(3)]
31         self.assertEqual([1, 3, 2], items)
32     @gen_test
33     def test_maxsize(self):
34         self.assertRaises(TypeError, queues.Queue, maxsize=None)
35         self.assertRaises(ValueError, queues.Queue, maxsize=-1)
36         q = queues.Queue(maxsize=2)
37         self.assertTrue(q.empty())
38         self.assertFalse(q.full())
39         self.assertEqual(2, q.maxsize)
40         self.assertTrue(q.put(1).done())
41         self.assertFalse(q.empty())
42         self<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertTrue(q.full())
43         self.assertFalse(put2.done())
44         self.assertEqual(</b></font>0, (yield q.get()))  # Make room.
45         self<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertTrue(put2.done())
46         self.assertFalse(q.empty())
47         self.assertTrue(q.full(</b></font>))
48 class QueueGetTest(AsyncTestCase):
49     @gen_test
50     def test_blocking_get(self):
51         q = queues.Queue()
52         q.put_nowait(0)
53         self.assertEqual(0, (yield q.get()))
54     def test_nonblocking_get(self):
55         q = queues.Queue()
56         q.put_nowait(0)
57         self.assertEqual(0, q.get_nowait())
58     def test_nonblocking_get_exception(self):
59         q = queues.Queue()
60         self.assertRaises(queues.QueueEmpty, q.get_nowait)
61     @gen_test
62     def test_get_with_putters(self):
63         q = queues.Queue(1)
64         q.put_nowait(0)
65         put = q.put(1)
66         self.assertEqual(0, (yield q.get()))
67         self.assertIsNone((yield put))
68     @gen_test
69     def test_blocking_get_wait(self):
70         q = queues<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.Queue()
71         q.put(0)
72         self.io_loop.call_later(0.01, q.put, 1)
73         self.io_loop.call_later(0.02, q.</b></font>put, 2)
74         self.assertEqual(0, (yield q.get(timeout=timedelta(seconds=1))))
75         self.assertEqual(1, (yield q.get(timeout=timedelta(seconds=1))))
76     @gen_test
77     def test_get_timeout(self):
78         q = queues.Queue()
79         get_timeout = q.get(timeout=timedelta(seconds=0.01))
80         get = q.get()
81         with self.assertRaises(TimeoutError):
82             yield get_timeout
83         q.put_nowait(0)
84         self.assertEqual(0, (yield get))
85     @gen_test
86     def test_get_timeout_preempted(self):
87         q = queues.Queue()
88         get = q.get(timeout=timedelta(seconds=0.01))
89         q.put(0)
90         yield gen.sleep(0.02)
91         self.assertEqual(0, (yield get))
92     @gen_test
93     def test_get_clears_timed_out_putters(self):
94         q = queues.Queue(1)
95         putters = [q.put(i, timedelta(seconds=0.01)) for i in range(10)]
96         put = q.put(10)
97         self.assertEqual(10, len(q._putters))
98         yield gen.sleep(0.02)
99         self.assertEqual(10, len(q._putters))
100         self.assertFalse(put.done())  # Final waiter is still active.
101         q.put(11)
102         self.assertEqual(0, (yield q.get()))  # get() clears the waiters.
103         self.assertEqual(1, len(q._putters))
104         for putter in putters[1:]:
105             self.assertRaises(TimeoutError, putter.result)
106     @gen_test
107     def test_get_clears_timed_out_getters(self):
108         q = queues.Queue()
109         getters = [q.get(timedelta(seconds=0.01)) for _ in range(10)]
110         get = q.get()
111         self.assertEqual(11, len(q._getters))
112         yield gen.sleep(0.02)
113         self.assertEqual(11, len(q._getters))
114         self.assertFalse(get.done())  # Final waiter is still active.
115         q.get()  # get() clears the waiters.
116         self.assertEqual(2, len(q._getters))
117         for getter in getters:
118             self.assertRaises(TimeoutError, getter.result)
119     @skipBefore35
120     @gen_test
121     def test_async_for(self):
122         q = queues.Queue()
123         for i in range(5):
124             q.put(i)
125         namespace = exec_test(globals(), locals(), """
126         async def f():
127             results = []
128             async for i in q:
129                 results.append(i)
130                 if i == 4:
131                     return results
132         """)
133         results = yield namespace['f']()
134         self.assertEqual(results, list(range(5)))
135 class QueuePutTest(AsyncTestCase):
136     @gen_test
137     def test_blocking_put(self):
138         q = queues.Queue()
139         q.put(0)
140         self.assertEqual(0, q.get_nowait())
141     def test_nonblocking_put_exception(self):
142         q = queues.Queue(1)
143         q.put(0)
144         self.assertRaises(queues.QueueFull, q.put_nowait, 1)
145     @gen_test
146     def test_put_with_getters(self):
147         q = queues.Queue()
148         get0 = q.get()
149         get1 = q.get()
150         yield q.put(0)
151         self.assertEqual(0, (yield get0))
152         yield q.put(1)
153         self.assertEqual(1, (yield get1))
154     @gen_test
155     def test_nonblocking_put_with_getters(self):
156         q = queues.Queue()
157         get0 = q.get()
158         get1 = q.get()
159         q.put_nowait(0)
160         yield gen.moment
161         self.assertEqual(0, (yield get0))
162         q.put_nowait(1)
163         yield gen.moment
164         self.assertEqual(1, (yield get1))
165     @gen_test
166     def test_blocking_put_wait(self):
167         q = queues.Queue(1)
168         q.put_nowait(0)
169         self.io_loop.call_later(0.01, q.get)
170         self.io_loop.call_later(0.02, q.get)
171         futures = [q.put(0), q.put(1)]
172         self.assertFalse(any(f.done() for f in futures))
173         yield futures
174     @gen_test
175     def test_put_timeout(self):
176         q = queues.Queue(1)
177         q.put_nowait(0)  # Now it's full.
178         put_timeout = q.put(1, timeout=timedelta(seconds=0.01))
179         put = q.put(2)
180         with self.assertRaises(TimeoutError):
181             yield put_timeout
182         self.assertEqual(0, q.get_nowait())
183         self.assertEqual(2, (yield q.get()))
184         yield put
185     @gen_test
186     def test_put_timeout_preempted(self):
187         q = queues.Queue(1)
188         q.put_nowait(0)
189         put = q.put(1, timeout=timedelta(seconds=0.01))
190         q.get()
191         yield gen.sleep(0.02)
192         yield put  # No TimeoutError.
193     @gen_test
194     def test_put_clears_timed_out_putters(self):
195         q = queues.Queue(1)
196         putters = [q.put(i, timedelta(seconds=0.01)) for i in range(10)]
197         put = q.put(10)
198         self.assertEqual(10, len(q._putters))
199         yield gen.sleep(0.02)
200         self.assertEqual(10, len(q._putters))
201         self.assertFalse(put.done())  # Final waiter is still active.
202         q.put(11)  # put() clears the waiters.
203         self.assertEqual(2, len(q._putters))
204         for putter in putters[1:]:
205             self.assertRaises(TimeoutError, putter.result)
206     @gen_test
207     def test_put_clears_timed_out_getters(self):
208         q = queues.Queue()
209         getters = [q.get(timedelta(seconds=0.01)) for _ in range(10)]
210         get = q.get()
211         q.get()
212         self.assertEqual(12, len(q._getters))
213         yield gen.sleep(0.02)
214         self.assertEqual(12, len(q._getters))
215         self.assertFalse(get.done())  # Final waiters still active.
216         q.put(0)  # put() clears the waiters.
217         self.assertEqual(1, len(q._getters))
218         self.assertEqual(0, (yield get))
219         for getter in getters:
220             self.assertRaises(TimeoutError, getter.result)
221     @gen_test
222     def test_float_maxsize(self):
223         q = queues.Queue(maxsize=1.3)
224         self.assertTrue(q.empty())
225         self.assertFalse(q.full())
226         q.put_nowait(0)
227         q.put_nowait(1)
228         self.assertFalse(q.empty())
229         self.assertTrue(q.full())
230         self.assertRaises(queues.QueueFull, q.put_nowait, 2)
231         self.assertEqual(0, q.get_nowait())
232         self.assertFalse(q.empty())
233         self.assertFalse(q.full())
234         yield q.put(2)
235         put = q.put(3)
236         self.assertFalse(put.done())
237         self.assertEqual(1, (yield q.get()))
238         yield put
239         self.assertTrue(q.full())
240 class QueueJoinTest(AsyncTestCase):
241     queue_class = queues.Queue
242     def test_task_done_underflow(self):
243         q = self.queue_class()
244         self.assertRaises(ValueError, q.task_done)
245     @gen_test
246     def test_task_done(self):
247         q = self.queue_class()
248         for i in range(100):
249             q.put_nowait(i)
250         self.accumulator = 0
251         @gen.coroutine
252         def worker():
253             while True:
254                 item = yield q.get()
255                 self.accumulator += item
256                 q.task_done()
257                 yield gen.sleep(random() * 0.01)
258         worker()
259         worker()
260         yield q.join()
261         self.assertEqual(sum(range(100)), self.accumulator)
262     @gen_test
263     def test_task_done_delay(self):
264         q = self.queue_class()
265         q.put_nowait(0)
266         join = q.join()
267         self.assertFalse(join.done())
268         yield q.get()
269         self.assertFalse(join.done())
270         yield gen.moment
271         self.assertFalse(join.done())
272         q.task_done()
273         self.assertTrue(join.done())
274     @gen_test
275     def test_join_empty_queue(self):
276         q = self.queue_class()
277         yield q.join()
278         yield q.join()
279     @gen_test
280     def test_join_timeout(self):
281         q = self.queue_class()
282         q.put(0)
283         with self.assertRaises(TimeoutError):
284             yield q.join(timeout=timedelta(seconds=0.01))
285 class PriorityQueueJoinTest(QueueJoinTest):
286     queue_class = queues.PriorityQueue
287     @gen_test
288     def test_order(self):
289         q.put_nowait((1, 'a'))
290         q.put_nowait((0, 'b'))
291         self.assertTrue(q<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.full())
292         q.put((3, 'c'))
293         q.put((2, 'd'))
294         self.assertEqual((0, 'b'), q.</b></font>get_nowait())
295         self.assertEqual((1, 'a'), (yield q.get()))
296         self.assertEqual((2, 'd'), q.get_nowait())
297         self.assertEqual((3, 'c'), (yield q.get()))
298         self.assertTrue(q.empty())
299 class LifoQueueJoinTest(QueueJoinTest):
300     queue_class = queues.LifoQueue
301     @gen_test
302     def test_order(self):
303         q = self.queue_class(maxsize=2)
304         q.put_nowait(1)
305         q.put_nowait(0)
306         self.assertTrue(q.full())
307         q.put(3)
308         q.put(2)
309         self.assertEqual(3, q.get_nowait())
310         self.assertEqual(2, (yield q.get()))
311         self.assertEqual(0, q.get_nowait())
312         self.assertEqual(1, (yield q.get()))
313         self.assertTrue(q.empty())
314 class ProducerConsumerTest(AsyncTestCase):
315     @gen_test
316     def test_producer_consumer(self):
317         q = queues.Queue(maxsize=3)
318         history = []
319         @gen.coroutine
320         def consumer():
321             while True:
322                 history.append((yield q.get()))
323                 q.task_done()
324         @gen.coroutine
325         def producer():
326             for item in range(10):
327                 yield q.put(item)
328         consumer()
329         yield producer()
330         yield q.join()
331         self.assertEqual(list(range(10)), history)
332 if __name__ == '__main__':
333     unittest.main()
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
