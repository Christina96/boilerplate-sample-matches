<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for collector.py & queues_test.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for collector.py & queues_test.py
      </h3>
      <h1 align="center">
        6.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>collector.py (6.5677967%)<TH>queues_test.py (6.1386137%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match43486-0.html#0',2,'match43486-1.html#0',3)" NAME="0">(483-486)<TD><A HREF="javascript:ZweiFrames('match43486-0.html#0',2,'match43486-1.html#0',3)" NAME="0">(73-75)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match43486-0.html#1',2,'match43486-1.html#1',3)" NAME="1">(364-369)<TD><A HREF="javascript:ZweiFrames('match43486-0.html#1',2,'match43486-1.html#1',3)" NAME="1">(69-72)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match43486-0.html#2',2,'match43486-1.html#2',3)" NAME="2">(498-507)<TD><A HREF="javascript:ZweiFrames('match43486-0.html#2',2,'match43486-1.html#2',3)" NAME="2">(368-371)</A><TD ALIGN=center><FONT COLOR="#eb0000">12</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match43486-0.html#3',2,'match43486-1.html#3',3)" NAME="3">(383-385)<TD><A HREF="javascript:ZweiFrames('match43486-0.html#3',2,'match43486-1.html#3',3)" NAME="3">(28-30)</A><TD ALIGN=center><FONT COLOR="#eb0000">12</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match43486-0.html#4',2,'match43486-1.html#4',3)" NAME="4">(191-194)<TD><A HREF="javascript:ZweiFrames('match43486-0.html#4',2,'match43486-1.html#4',3)" NAME="4">(104-107)</A><TD ALIGN=center><FONT COLOR="#eb0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>collector.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
#
# Copyright 2015 SUSE LLC
#
# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import logging
import os
import subprocess
import sys

import salt.utils.crypt
import salt.utils.files
import salt.utils.fsutils
import salt.utils.path
import salt.utils.stringutils
from salt.exceptions import CommandExecutionError
from salt.modules.inspectlib import EnvLoader, kiwiproc
from salt.modules.inspectlib.entities import (
    AllowedDir,
    IgnoredDir,
    Package,
    PackageCfgFile,
    PayloadFile,
)
from salt.modules.inspectlib.exceptions import InspectorSnapshotException

try:
    import kiwi
except ImportError:
    kiwi = None

log = logging.getLogger(__name__)


class Inspector(EnvLoader):
    DEFAULT_MINION_CONFIG_PATH = &quot;/etc/salt/minion&quot;

    MODE = [&quot;configuration&quot;, &quot;payload&quot;, &quot;all&quot;]
    IGNORE_MOUNTS = [&quot;proc&quot;, &quot;sysfs&quot;, &quot;devtmpfs&quot;, &quot;tmpfs&quot;, &quot;fuse.gvfs-fuse-daemon&quot;]
    IGNORE_FS_TYPES = [&quot;autofs&quot;, &quot;cifs&quot;, &quot;nfs&quot;, &quot;nfs4&quot;]
    IGNORE_PATHS = [
        &quot;/tmp&quot;,
        &quot;/var/tmp&quot;,
        &quot;/lost+found&quot;,
        &quot;/var/run&quot;,
        &quot;/var/lib/rpm&quot;,
        &quot;/.snapshots&quot;,
        &quot;/.zfs&quot;,
        &quot;/etc/ssh&quot;,
        &quot;/root&quot;,
        &quot;/home&quot;,
    ]

    def __init__(self, cachedir=None, piddir=None, pidfilename=None):
        EnvLoader.__init__(
            self, cachedir=cachedir, piddir=piddir, pidfilename=pidfilename
        )

    def create_snapshot(self):
        &quot;&quot;&quot;
        Open new snapshot.

        :return:
        &quot;&quot;&quot;
        self.db.open(new=True)
        return self

    def reuse_snapshot(self):
        &quot;&quot;&quot;
        Open an existing, latest snapshot.

        :return:
        &quot;&quot;&quot;
        self.db.open()
        return self

    def _syscall(self, command, input=None, env=None, *params):
        &quot;&quot;&quot;
        Call an external system command.
        &quot;&quot;&quot;
        return subprocess.Popen(
            [command] + list(params),
            stdout=subprocess.PIPE,
            stdin=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            env=env or os.environ,
        ).communicate(input=input)

    def _get_cfg_pkgs(self):
        &quot;&quot;&quot;
        Package scanner switcher between the platforms.

        :return:
        &quot;&quot;&quot;
        if self.grains_core.os_data().get(&quot;os_family&quot;) == &quot;Debian&quot;:
            return self.__get_cfg_pkgs_dpkg()
        elif self.grains_core.os_data().get(&quot;os_family&quot;) in [&quot;Suse&quot;, &quot;redhat&quot;]:
            return self.__get_cfg_pkgs_rpm()
        else:
            return dict()

    def __get_cfg_pkgs_dpkg(self):
        &quot;&quot;&quot;
        Get packages with configuration files on Dpkg systems.
        :return:
        &quot;&quot;&quot;
        # Get list of all available packages
        data = dict()

        for pkg_name in salt.utils.stringutils.to_str(
            self._syscall(&quot;dpkg-query&quot;, None, None, &quot;-Wf&quot;, &quot;${binary:Package}\\n&quot;)[0]
        ).split(os.linesep):
            pkg_name = pkg_name.strip()
            if not pkg_name:
                continue
            data[pkg_name] = list()
            for pkg_cfg_item in salt.utils.stringutils.to_str(
                self._syscall(
                    &quot;dpkg-query&quot;, None, None, &quot;-Wf&quot;, &quot;${Conffiles}\\n&quot;, pkg_name
                )[0]
            ).split(os.linesep):
                pkg_cfg_item = pkg_cfg_item.strip()
                if not pkg_cfg_item:
                    continue
                pkg_cfg_file, pkg_cfg_sum = pkg_cfg_item.strip().split(&quot; &quot;, 1)
                data[pkg_name].append(pkg_cfg_file)

            # Dpkg meta data is unreliable. Check every package
            # and remove which actually does not have config files.
            if not data[pkg_name]:
                data.pop(pkg_name)

        return data

    def __get_cfg_pkgs_rpm(self):
        &quot;&quot;&quot;
        Get packages with configuration files on RPM systems.
        &quot;&quot;&quot;
        out, err = self._syscall(
            &quot;rpm&quot;,
            None,
            None,
            &quot;-qa&quot;,
            &quot;--configfiles&quot;,
            &quot;--queryformat&quot;,
            &quot;%{name}-%{version}-%{release}\\n&quot;,
        )
        data = dict()
        pkg_name = None
        pkg_configs = []

        out = salt.utils.stringutils.to_str(out)
        for line in out.split(os.linesep):
            line = line.strip()
            if not line:
                continue
            if not line.startswith(&quot;/&quot;):
                if pkg_name and pkg_configs:
                    data[pkg_name] = pkg_configs
                pkg_name = line
                pkg_configs = []
            else:
                pkg_configs.append(line)

        if pkg_name and pkg_configs:
            data[pkg_name] = pkg_configs

        return data

    def _get_changed_cfg_pkgs(self, data):
        &quot;&quot;&quot;
        Filter out unchanged packages on the Debian or RPM systems.

        :param data: Structure {package-name -&gt; [ file .. file1 ]}
        :return: Same structure as data, except only files that were changed.
        &quot;&quot;&quot;
        f_data = dict()
        for pkg_name, pkg_files in data.items():
<A NAME="4"></A>            cfgs = list()
            cfg_data = list()
            if self.grains_core.os_data().get(&quot;os_family&quot;) == &quot;Debian&quot;:
                cfg_data = salt.utils.stringutils<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match43486-1.html#4',3,'match43486-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.to_str(
                    self._syscall(&quot;dpkg&quot;, None, None, &quot;--verify&quot;, pkg_name)[0]
                ).split(os.linesep)
            elif self.grains_core.os_data().</B></FONT>get(&quot;os_family&quot;) in [&quot;Suse&quot;, &quot;redhat&quot;]:
                cfg_data = salt.utils.stringutils.to_str(
                    self._syscall(
                        &quot;rpm&quot;,
                        None,
                        None,
                        &quot;-V&quot;,
                        &quot;--nodeps&quot;,
                        &quot;--nodigest&quot;,
                        &quot;--nosignature&quot;,
                        &quot;--nomtime&quot;,
                        &quot;--nolinkto&quot;,
                        pkg_name,
                    )[0]
                ).split(os.linesep)
            for line in cfg_data:
                line = line.strip()
                if not line or line.find(&quot; c &quot;) &lt; 0 or line.split(&quot; &quot;)[0].find(&quot;5&quot;) &lt; 0:
                    continue
                cfg_file = line.split(&quot; &quot;)[-1]
                if cfg_file in pkg_files:
                    cfgs.append(cfg_file)
            if cfgs:
                f_data[pkg_name] = cfgs

        return f_data

    def _save_cfg_packages(self, data):
        &quot;&quot;&quot;
        Save configuration packages. (NG)

        :param data:
        :return:
        &quot;&quot;&quot;
        pkg_id = 0
        pkg_cfg_id = 0
        for pkg_name, pkg_configs in data.items():
            pkg = Package()
            pkg.id = pkg_id
            pkg.name = pkg_name
            self.db.store(pkg)

            for pkg_config in pkg_configs:
                cfg = PackageCfgFile()
                cfg.id = pkg_cfg_id
                cfg.pkgid = pkg_id
                cfg.path = pkg_config
                self.db.store(cfg)
                pkg_cfg_id += 1

            pkg_id += 1

    def _save_payload(self, files, directories, links):
        &quot;&quot;&quot;
        Save payload (unmanaged files)

        :param files:
        :param directories:
        :param links:
        :return:
        &quot;&quot;&quot;

        idx = 0
        for p_type, p_list in (
            (&quot;f&quot;, files),
            (&quot;d&quot;, directories),
            (&quot;l&quot;, links),
        ):
            for p_obj in p_list:
                stats = os.stat(p_obj)

                payload = PayloadFile()
                payload.id = idx
                payload.path = p_obj
                payload.p_type = p_type
                payload.mode = stats.st_mode
                payload.uid = stats.st_uid
                payload.gid = stats.st_gid
                payload.p_size = stats.st_size
                payload.atime = stats.st_atime
                payload.mtime = stats.st_mtime
                payload.ctime = stats.st_ctime

                idx += 1
                self.db.store(payload)

    def _get_managed_files(self):
        &quot;&quot;&quot;
        Build a in-memory data of all managed files.
        &quot;&quot;&quot;
        if self.grains_core.os_data().get(&quot;os_family&quot;) == &quot;Debian&quot;:
            return self.__get_managed_files_dpkg()
        elif self.grains_core.os_data().get(&quot;os_family&quot;) in [&quot;Suse&quot;, &quot;redhat&quot;]:
            return self.__get_managed_files_rpm()

        return list(), list(), list()

    def __get_managed_files_dpkg(self):
        &quot;&quot;&quot;
        Get a list of all system files, belonging to the Debian package manager.
        &quot;&quot;&quot;
        dirs = set()
        links = set()
        files = set()

        for pkg_name in salt.utils.stringutils.to_str(
            self._syscall(&quot;dpkg-query&quot;, None, None, &quot;-Wf&quot;, &quot;${binary:Package}\\n&quot;)[0]
        ).split(os.linesep):
            pkg_name = pkg_name.strip()
            if not pkg_name:
                continue
            for resource in salt.utils.stringutils.to_str(
                self._syscall(&quot;dpkg&quot;, None, None, &quot;-L&quot;, pkg_name)[0]
            ).split(os.linesep):
                resource = resource.strip()
                if not resource or resource in [&quot;/&quot;, &quot;./&quot;, &quot;.&quot;]:
                    continue
                if os.path.isdir(resource):
                    dirs.add(resource)
                elif os.path.islink(resource):
                    links.add(resource)
                elif os.path.isfile(resource):
                    files.add(resource)

        return sorted(files), sorted(dirs), sorted(links)

    def __get_managed_files_rpm(self):
        &quot;&quot;&quot;
        Get a list of all system files, belonging to the RedHat package manager.
        &quot;&quot;&quot;
        dirs = set()
        links = set()
        files = set()

        for line in salt.utils.stringutils.to_str(
            self._syscall(&quot;rpm&quot;, None, None, &quot;-qlav&quot;)[0]
        ).split(os.linesep):
            line = line.strip()
            if not line:
                continue
            line = line.replace(&quot;\t&quot;, &quot; &quot;).split(&quot; &quot;)
            if line[0][0] == &quot;d&quot;:
                dirs.add(line[-1])
            elif line[0][0] == &quot;l&quot;:
                links.add(line[-1])
            elif line[0][0] == &quot;-&quot;:
                files.add(line[-1])

        return sorted(files), sorted(dirs), sorted(links)

    def _get_all_files(self, path, *exclude):
        &quot;&quot;&quot;
        Walk implementation. Version in python 2.x and 3.x works differently.
        &quot;&quot;&quot;
        files = list()
        dirs = list()
        links = list()

        if os.access(path, os.R_OK):
            for obj in os.listdir(path):
                obj = os.path.join(path, obj)
                valid = True
                for ex_obj in exclude:
                    if obj.startswith(str(ex_obj)):
                        valid = False
                        continue
                if not valid or not os.path.exists(obj) or not os.access(obj, os.R_OK):
<A NAME="1"></A>                    continue
                if salt.utils.path.islink(obj):
                    links.append(obj)
                elif os.path<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match43486-1.html#1',3,'match43486-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.isdir(obj):
                    dirs.append(obj)
                    f_obj, d_obj, l_obj = self._get_all_files(obj, *exclude)
                    files.extend(f_obj)
                    dirs.extend(d_obj)
                    links.extend(</B></FONT>l_obj)
                elif os.path.isfile(obj):
                    files.append(obj)

        return sorted(files), sorted(dirs), sorted(links)

    def _get_unmanaged_files(self, managed, system_all):
        &quot;&quot;&quot;
        Get the intersection between all files and managed files.
        &quot;&quot;&quot;
        m_files, m_dirs, m_links = managed
<A NAME="3"></A>        s_files, s_dirs, s_links = system_all

        return (
            sorted(list(set(s_files)<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match43486-1.html#3',3,'match43486-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.difference(m_files))),
            sorted(list(set(s_dirs).difference(m_dirs))),
            sorted(list(set(s_links).difference(</B></FONT>m_links))),
        )

    def _scan_payload(self):
        &quot;&quot;&quot;
        Scan the system.
        &quot;&quot;&quot;
        # Get ignored points
        allowed = list()
        for allowed_dir in self.db.get(AllowedDir):
            if os.path.exists(allowed_dir.path):
                allowed.append(allowed_dir.path)

        ignored = list()
        if not allowed:
            for ignored_dir in self.db.get(IgnoredDir):
                if os.path.exists(ignored_dir.path):
                    ignored.append(ignored_dir.path)

        all_files = list()
        all_dirs = list()
        all_links = list()
        for entry_path in [pth for pth in (allowed or os.listdir(&quot;/&quot;)) if pth]:
            if entry_path[0] != &quot;/&quot;:
                entry_path = &quot;/{}&quot;.format(entry_path)
            if entry_path in ignored or os.path.islink(entry_path):
                continue
            e_files, e_dirs, e_links = self._get_all_files(entry_path, *ignored)
            all_files.extend(e_files)
            all_dirs.extend(e_dirs)
            all_links.extend(e_links)

        return self._get_unmanaged_files(
            self._get_managed_files(),
            (
                all_files,
                all_dirs,
                all_links,
            ),
        )

    def _prepare_full_scan(self, **kwargs):
        &quot;&quot;&quot;
        Prepare full system scan by setting up the database etc.
        &quot;&quot;&quot;
        self.db.open(new=True)
        # Add ignored filesystems
        ignored_fs = set()
        ignored_fs |= set(self.IGNORE_PATHS)
        mounts = salt.utils.fsutils._get_mounts()
        for device, data in mounts.items():
            if device in self.IGNORE_MOUNTS:
                for mpt in data:
                    ignored_fs.add(mpt[&quot;mount_point&quot;])
                continue
            for mpt in data:
                if mpt[&quot;type&quot;] in self.IGNORE_FS_TYPES:
                    ignored_fs.add(mpt[&quot;mount_point&quot;])

        # Remove leafs of ignored filesystems
        ignored_all = list()
        for entry in sorted(list(ignored_fs)):
            valid = True
            for e_entry in ignored_all:
                if entry.startswith(e_entry):
                    valid = False
                    break
            if valid:
                ignored_all.append(entry)
        # Save to the database for further scan
        for ignored_dir in ignored_all:
            dir_obj = IgnoredDir()
            dir_obj.path = ignored_dir
            self.db.store(dir_obj)

        # Add allowed filesystems (overrides all above at full scan)
        allowed = [elm for elm in kwargs.get(&quot;filter&quot;, &quot;&quot;).split(&quot;,&quot;) if elm]
        for allowed_dir in allowed:
            dir_obj = AllowedDir()
            dir_obj.path = allowed_dir
            self.db.store(dir_obj)

        return ignored_all

    def _init_env(self):
        &quot;&quot;&quot;
        Initialize some Salt environment.
        &quot;&quot;&quot;
        from salt.config import minion_config
        from salt.grains import core as g_core

        g_core.__opts__ = minion_config(self.DEFAULT_MINION_CONFIG_PATH)
        self.grains_core = g_core

    def snapshot(self, mode):
<A NAME="0"></A>        &quot;&quot;&quot;
        Take a snapshot of the system.
        &quot;&quot;&quot;
        self<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match43486-1.html#0',3,'match43486-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>._init_env()

        self._save_cfg_packages(self._get_changed_cfg_pkgs(self._get_cfg_pkgs()))
        self._save_payload(*self._scan_payload(</B></FONT>))

    def request_snapshot(self, mode, priority=19, **kwargs):
        &quot;&quot;&quot;
        Take a snapshot of the system.
        &quot;&quot;&quot;
        if mode not in self.MODE:
            raise InspectorSnapshotException(&quot;Unknown mode: '{}'&quot;.format(mode))

<A NAME="2"></A>        if is_alive(self.pidfile):
            raise CommandExecutionError(&quot;Inspection already in progress.&quot;)

        self<FONT color="#980517"><A HREF="javascript:ZweiFrames('match43486-1.html#2',3,'match43486-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>._prepare_full_scan(**kwargs)

        subprocess.run(
            [
                &quot;nice&quot;,
                &quot;-{}&quot;.format(priority),
                &quot;python&quot;,
                __file__,
                os.path.dirname(self.pidfile),
                os.</B></FONT>path.dirname(self.dbfile),
                mode,
            ],
            check=False,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )

    def export(self, description, local=False, path=&quot;/tmp&quot;, format=&quot;qcow2&quot;):
        &quot;&quot;&quot;
        Export description for Kiwi.

        :param local:
        :param path:
        :return:
        &quot;&quot;&quot;
        kiwiproc.__salt__ = __salt__
        return (
            kiwiproc.KiwiExporter(grains=__grains__, format=format)
            .load(**description)
            .export(&quot;something&quot;)
        )

    def build(self, format=&quot;qcow2&quot;, path=&quot;/tmp&quot;):
        &quot;&quot;&quot;
        Build an image using Kiwi.

        :param format:
        :param path:
        :return:
        &quot;&quot;&quot;
        if kiwi is None:
            msg = (
                &quot;Unable to build the image due to the missing dependencies: Kiwi module&quot;
                &quot; is not available.&quot;
            )
            log.error(msg)
            raise CommandExecutionError(msg)

        raise CommandExecutionError(&quot;Build is not yet implemented&quot;)


def is_alive(pidfile):
    &quot;&quot;&quot;
    Check if PID is still alive.
    &quot;&quot;&quot;
    try:
        with salt.utils.files.fopen(pidfile) as fp_:
            os.kill(int(fp_.read().strip()), 0)
        return True
    except Exception as ex:  # pylint: disable=broad-except
        if os.access(pidfile, os.W_OK) and os.path.isfile(pidfile):
            os.unlink(pidfile)
        return False


def main(dbfile, pidfile, mode):
    &quot;&quot;&quot;
    Main analyzer routine.
    &quot;&quot;&quot;
    Inspector(dbfile, pidfile).reuse_snapshot().snapshot(mode)


if __name__ == &quot;__main__&quot;:
    if len(sys.argv) != 4:
        print(&quot;This module is not intended to use directly!&quot;, file=sys.stderr)
        sys.exit(1)

    pidfile, dbfile, mode = sys.argv[1:]  # pylint: disable=unbalanced-tuple-unpacking
    if is_alive(pidfile):
        sys.exit(1)

    # Double-fork stuff
    try:
        if os.fork() &gt; 0:
            salt.utils.crypt.reinit_crypto()
            sys.exit(0)
        else:
            salt.utils.crypt.reinit_crypto()
    except OSError as ex:
        sys.exit(1)

    os.setsid()
    os.umask(0o000)  # pylint: disable=blacklisted-function

    try:
        pid = os.fork()
        if pid &gt; 0:
            salt.utils.crypt.reinit_crypto()
            with salt.utils.files.fopen(
                os.path.join(pidfile, EnvLoader.PID_FILE), &quot;w&quot;
            ) as fp_:
                fp_.write(&quot;{}\n&quot;.format(pid))
            sys.exit(0)
    except OSError as ex:
        sys.exit(1)

    salt.utils.crypt.reinit_crypto()
    main(dbfile, pidfile, mode)
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>queues_test.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.
# pylint: skip-file


from __future__ import absolute_import, division, print_function
from datetime import timedelta
from random import random

from salt.ext.tornado import gen, queues
from salt.ext.tornado.gen import TimeoutError
from salt.ext.tornado.testing import gen_test, AsyncTestCase
from salt.ext.tornado.test.util import unittest, skipBefore35, exec_test


<A NAME="3"></A>class QueueBasicTest(AsyncTestCase):
    def test_repr_and_str(self):
        q = queues.Queue(maxsize=1)
        self<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match43486-0.html#3',2,'match43486-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.assertIn(hex(id(q)), repr(q))
        self.assertNotIn(hex(id(q)), str(q))
        q.get(</B></FONT>)

        for q_str in repr(q), str(q):
            self.assertTrue(q_str.startswith('&lt;Queue'))
            self.assertIn('maxsize=1', q_str)
            self.assertIn('getters[1]', q_str)
            self.assertNotIn('putters', q_str)
            self.assertNotIn('tasks', q_str)

        q.put(None)
        q.put(None)
        # Now the queue is full, this putter blocks.
        q.put(None)

        for q_str in repr(q), str(q):
            self.assertNotIn('getters', q_str)
            self.assertIn('putters[1]', q_str)
            self.assertIn('tasks=2', q_str)

    def test_order(self):
        q = queues.Queue()
        for i in [1, 3, 2]:
            q.put_nowait(i)

        items = [q.get_nowait() for _ in range(3)]
        self.assertEqual([1, 3, 2], items)

    @gen_test
    def test_maxsize(self):
        self.assertRaises(TypeError, queues.Queue, maxsize=None)
        self.assertRaises(ValueError, queues.Queue, maxsize=-1)

        q = queues.Queue(maxsize=2)
        self.assertTrue(q.empty())
        self.assertFalse(q.full())
        self.assertEqual(2, q.maxsize)
<A NAME="1"></A>        self.assertTrue(q.put(0).done())
        self.assertTrue(q.put(1).done())
        self.assertFalse(q.empty())
        self<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match43486-0.html#1',2,'match43486-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.assertTrue(q.full())
<A NAME="0"></A>        put2 = q.put(2)
        self.assertFalse(put2.done())
        self.assertEqual(</B></FONT>0, (yield q.get()))  # Make room.
        self<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match43486-0.html#0',2,'match43486-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.assertTrue(put2.done())
        self.assertFalse(q.empty())
        self.assertTrue(q.full(</B></FONT>))


class QueueGetTest(AsyncTestCase):
    @gen_test
    def test_blocking_get(self):
        q = queues.Queue()
        q.put_nowait(0)
        self.assertEqual(0, (yield q.get()))

    def test_nonblocking_get(self):
        q = queues.Queue()
        q.put_nowait(0)
        self.assertEqual(0, q.get_nowait())

    def test_nonblocking_get_exception(self):
        q = queues.Queue()
        self.assertRaises(queues.QueueEmpty, q.get_nowait)

    @gen_test
    def test_get_with_putters(self):
        q = queues.Queue(1)
        q.put_nowait(0)
        put = q.put(1)
        self.assertEqual(0, (yield q.get()))
        self.assertIsNone((yield put))
<A NAME="4"></A>
    @gen_test
    def test_blocking_get_wait(self):
        q = queues<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match43486-0.html#4',2,'match43486-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.Queue()
        q.put(0)
        self.io_loop.call_later(0.01, q.put, 1)
        self.io_loop.call_later(0.02, q.</B></FONT>put, 2)
        self.assertEqual(0, (yield q.get(timeout=timedelta(seconds=1))))
        self.assertEqual(1, (yield q.get(timeout=timedelta(seconds=1))))

    @gen_test
    def test_get_timeout(self):
        q = queues.Queue()
        get_timeout = q.get(timeout=timedelta(seconds=0.01))
        get = q.get()
        with self.assertRaises(TimeoutError):
            yield get_timeout

        q.put_nowait(0)
        self.assertEqual(0, (yield get))

    @gen_test
    def test_get_timeout_preempted(self):
        q = queues.Queue()
        get = q.get(timeout=timedelta(seconds=0.01))
        q.put(0)
        yield gen.sleep(0.02)
        self.assertEqual(0, (yield get))

    @gen_test
    def test_get_clears_timed_out_putters(self):
        q = queues.Queue(1)
        # First putter succeeds, remainder block.
        putters = [q.put(i, timedelta(seconds=0.01)) for i in range(10)]
        put = q.put(10)
        self.assertEqual(10, len(q._putters))
        yield gen.sleep(0.02)
        self.assertEqual(10, len(q._putters))
        self.assertFalse(put.done())  # Final waiter is still active.
        q.put(11)
        self.assertEqual(0, (yield q.get()))  # get() clears the waiters.
        self.assertEqual(1, len(q._putters))
        for putter in putters[1:]:
            self.assertRaises(TimeoutError, putter.result)

    @gen_test
    def test_get_clears_timed_out_getters(self):
        q = queues.Queue()
        getters = [q.get(timedelta(seconds=0.01)) for _ in range(10)]
        get = q.get()
        self.assertEqual(11, len(q._getters))
        yield gen.sleep(0.02)
        self.assertEqual(11, len(q._getters))
        self.assertFalse(get.done())  # Final waiter is still active.
        q.get()  # get() clears the waiters.
        self.assertEqual(2, len(q._getters))
        for getter in getters:
            self.assertRaises(TimeoutError, getter.result)

    @skipBefore35
    @gen_test
    def test_async_for(self):
        q = queues.Queue()
        for i in range(5):
            q.put(i)

        namespace = exec_test(globals(), locals(), &quot;&quot;&quot;
        async def f():
            results = []
            async for i in q:
                results.append(i)
                if i == 4:
                    return results
        &quot;&quot;&quot;)
        results = yield namespace['f']()
        self.assertEqual(results, list(range(5)))


class QueuePutTest(AsyncTestCase):
    @gen_test
    def test_blocking_put(self):
        q = queues.Queue()
        q.put(0)
        self.assertEqual(0, q.get_nowait())

    def test_nonblocking_put_exception(self):
        q = queues.Queue(1)
        q.put(0)
        self.assertRaises(queues.QueueFull, q.put_nowait, 1)

    @gen_test
    def test_put_with_getters(self):
        q = queues.Queue()
        get0 = q.get()
        get1 = q.get()
        yield q.put(0)
        self.assertEqual(0, (yield get0))
        yield q.put(1)
        self.assertEqual(1, (yield get1))

    @gen_test
    def test_nonblocking_put_with_getters(self):
        q = queues.Queue()
        get0 = q.get()
        get1 = q.get()
        q.put_nowait(0)
        # put_nowait does *not* immediately unblock getters.
        yield gen.moment
        self.assertEqual(0, (yield get0))
        q.put_nowait(1)
        yield gen.moment
        self.assertEqual(1, (yield get1))

    @gen_test
    def test_blocking_put_wait(self):
        q = queues.Queue(1)
        q.put_nowait(0)
        self.io_loop.call_later(0.01, q.get)
        self.io_loop.call_later(0.02, q.get)
        futures = [q.put(0), q.put(1)]
        self.assertFalse(any(f.done() for f in futures))
        yield futures

    @gen_test
    def test_put_timeout(self):
        q = queues.Queue(1)
        q.put_nowait(0)  # Now it's full.
        put_timeout = q.put(1, timeout=timedelta(seconds=0.01))
        put = q.put(2)
        with self.assertRaises(TimeoutError):
            yield put_timeout

        self.assertEqual(0, q.get_nowait())
        # 1 was never put in the queue.
        self.assertEqual(2, (yield q.get()))

        # Final get() unblocked this putter.
        yield put

    @gen_test
    def test_put_timeout_preempted(self):
        q = queues.Queue(1)
        q.put_nowait(0)
        put = q.put(1, timeout=timedelta(seconds=0.01))
        q.get()
        yield gen.sleep(0.02)
        yield put  # No TimeoutError.

    @gen_test
    def test_put_clears_timed_out_putters(self):
        q = queues.Queue(1)
        # First putter succeeds, remainder block.
        putters = [q.put(i, timedelta(seconds=0.01)) for i in range(10)]
        put = q.put(10)
        self.assertEqual(10, len(q._putters))
        yield gen.sleep(0.02)
        self.assertEqual(10, len(q._putters))
        self.assertFalse(put.done())  # Final waiter is still active.
        q.put(11)  # put() clears the waiters.
        self.assertEqual(2, len(q._putters))
        for putter in putters[1:]:
            self.assertRaises(TimeoutError, putter.result)

    @gen_test
    def test_put_clears_timed_out_getters(self):
        q = queues.Queue()
        getters = [q.get(timedelta(seconds=0.01)) for _ in range(10)]
        get = q.get()
        q.get()
        self.assertEqual(12, len(q._getters))
        yield gen.sleep(0.02)
        self.assertEqual(12, len(q._getters))
        self.assertFalse(get.done())  # Final waiters still active.
        q.put(0)  # put() clears the waiters.
        self.assertEqual(1, len(q._getters))
        self.assertEqual(0, (yield get))
        for getter in getters:
            self.assertRaises(TimeoutError, getter.result)

    @gen_test
    def test_float_maxsize(self):
        # Non-int maxsize must round down: http://bugs.python.org/issue21723
        q = queues.Queue(maxsize=1.3)
        self.assertTrue(q.empty())
        self.assertFalse(q.full())
        q.put_nowait(0)
        q.put_nowait(1)
        self.assertFalse(q.empty())
        self.assertTrue(q.full())
        self.assertRaises(queues.QueueFull, q.put_nowait, 2)
        self.assertEqual(0, q.get_nowait())
        self.assertFalse(q.empty())
        self.assertFalse(q.full())

        yield q.put(2)
        put = q.put(3)
        self.assertFalse(put.done())
        self.assertEqual(1, (yield q.get()))
        yield put
        self.assertTrue(q.full())


class QueueJoinTest(AsyncTestCase):
    queue_class = queues.Queue

    def test_task_done_underflow(self):
        q = self.queue_class()
        self.assertRaises(ValueError, q.task_done)

    @gen_test
    def test_task_done(self):
        q = self.queue_class()
        for i in range(100):
            q.put_nowait(i)

        self.accumulator = 0

        @gen.coroutine
        def worker():
            while True:
                item = yield q.get()
                self.accumulator += item
                q.task_done()
                yield gen.sleep(random() * 0.01)

        # Two coroutines share work.
        worker()
        worker()
        yield q.join()
        self.assertEqual(sum(range(100)), self.accumulator)

    @gen_test
    def test_task_done_delay(self):
        # Verify it is task_done(), not get(), that unblocks join().
        q = self.queue_class()
        q.put_nowait(0)
        join = q.join()
        self.assertFalse(join.done())
        yield q.get()
        self.assertFalse(join.done())
        yield gen.moment
        self.assertFalse(join.done())
        q.task_done()
        self.assertTrue(join.done())

    @gen_test
    def test_join_empty_queue(self):
        q = self.queue_class()
        yield q.join()
        yield q.join()

    @gen_test
    def test_join_timeout(self):
        q = self.queue_class()
        q.put(0)
        with self.assertRaises(TimeoutError):
            yield q.join(timeout=timedelta(seconds=0.01))


class PriorityQueueJoinTest(QueueJoinTest):
    queue_class = queues.PriorityQueue

    @gen_test
    def test_order(self):
<A NAME="2"></A>        q = self.queue_class(maxsize=2)
        q.put_nowait((1, 'a'))
        q.put_nowait((0, 'b'))
        self.assertTrue(q<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match43486-0.html#2',2,'match43486-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.full())
        q.put((3, 'c'))
        q.put((2, 'd'))
        self.assertEqual((0, 'b'), q.</B></FONT>get_nowait())
        self.assertEqual((1, 'a'), (yield q.get()))
        self.assertEqual((2, 'd'), q.get_nowait())
        self.assertEqual((3, 'c'), (yield q.get()))
        self.assertTrue(q.empty())


class LifoQueueJoinTest(QueueJoinTest):
    queue_class = queues.LifoQueue

    @gen_test
    def test_order(self):
        q = self.queue_class(maxsize=2)
        q.put_nowait(1)
        q.put_nowait(0)
        self.assertTrue(q.full())
        q.put(3)
        q.put(2)
        self.assertEqual(3, q.get_nowait())
        self.assertEqual(2, (yield q.get()))
        self.assertEqual(0, q.get_nowait())
        self.assertEqual(1, (yield q.get()))
        self.assertTrue(q.empty())


class ProducerConsumerTest(AsyncTestCase):
    @gen_test
    def test_producer_consumer(self):
        q = queues.Queue(maxsize=3)
        history = []

        # We don't yield between get() and task_done(), so get() must wait for
        # the next tick. Otherwise we'd immediately call task_done and unblock
        # join() before q.put() resumes, and we'd only process the first four
        # items.
        @gen.coroutine
        def consumer():
            while True:
                history.append((yield q.get()))
                q.task_done()

        @gen.coroutine
        def producer():
            for item in range(10):
                yield q.put(item)

        consumer()
        yield producer()
        yield q.join()
        self.assertEqual(list(range(10)), history)


if __name__ == '__main__':
    unittest.main()
</PRE>
</div>
  </div>
</body>
</html>
