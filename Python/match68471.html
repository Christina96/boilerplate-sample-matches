<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for zpool.py & nfs3.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for zpool.py & nfs3.py
      </h3>
      <h1 align="center">
        4.6%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>zpool.py (3.5502958%)<TH>nfs3.py (6.5934067%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match68471-0.html#0',2,'match68471-1.html#0',3)" NAME="0">(295-299)<TD><A HREF="javascript:ZweiFrames('match68471-0.html#0',2,'match68471-1.html#0',3)" NAME="0">(146-151)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>zpool.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
States for managing zpools

:maintainer:    Jorge Schrauwen &lt;sjorge@blackdot.be&gt;
:maturity:      new
:depends:       salt.utils.zfs, salt.modules.zpool
:platform:      smartos, illumos, solaris, freebsd, linux

.. versionadded:: 2016.3.0
.. versionchanged:: 2018.3.1
  Big refactor to remove duplicate code, better type conversions and improved
  consistency in output.

.. code-block:: yaml

    oldpool:
      zpool.absent:
        - export: true

    newpool:
      zpool.present:
        - config:
            import: false
            force: true
        - properties:
            comment: salty storage pool
        - layout:
            - mirror:
              - /dev/disk0
              - /dev/disk1
            - mirror:
              - /dev/disk2
              - /dev/disk3

    partitionpool:
      zpool.present:
        - config:
            import: false
            force: true
        - properties:
            comment: disk partition salty storage pool
            ashift: '12'
            feature@lz4_compress: enabled
        - filesystem_properties:
            compression: lz4
            atime: on
            relatime: on
        - layout:
            - /dev/disk/by-uuid/3e43ce94-77af-4f52-a91b-6cdbb0b0f41b

    simplepool:
      zpool.present:
        - config:
            import: false
            force: true
        - properties:
            comment: another salty storage pool
        - layout:
            - /dev/disk0
            - /dev/disk1

.. warning::

    The layout will never be updated, it will only be used at time of creation.
    It's a whole lot of work to figure out if a devices needs to be detached, removed,
    etc. This is best done by the sysadmin on a case per case basis.

    Filesystem properties are also not updated, this should be managed by the zfs state module.

&quot;&quot;&quot;

import logging
import os

from salt.utils.odict import OrderedDict

log = logging.getLogger(__name__)

# Define the state's virtual name
__virtualname__ = &quot;zpool&quot;


def __virtual__():
    &quot;&quot;&quot;
    Provides zpool state
    &quot;&quot;&quot;
    if not __grains__.get(&quot;zfs_support&quot;):
        return False, &quot;The zpool state cannot be loaded: zfs not supported&quot;
    return __virtualname__


def _layout_to_vdev(layout, device_dir=None):
    &quot;&quot;&quot;
    Turn the layout data into usable vdevs spedcification

    We need to support 2 ways of passing the layout:

    .. code::
        layout_new:
          - mirror:
            - disk0
            - disk1
          - mirror:
            - disk2
            - disk3

    .. code:
        layout_legacy:
          mirror-0:
            disk0
            disk1
          mirror-1:
            disk2
            disk3

    &quot;&quot;&quot;
    vdevs = []

    # NOTE: check device_dir exists
    if device_dir and not os.path.exists(device_dir):
        device_dir = None

    # NOTE: handle list of OrderedDicts (new layout)
    if isinstance(layout, list):
        # NOTE: parse each vdev as a tiny layout and just append
        for vdev in layout:
            if isinstance(vdev, OrderedDict):
                vdevs.extend(_layout_to_vdev(vdev, device_dir))
            else:
                if device_dir and vdev[0] != &quot;/&quot;:
                    vdev = os.path.join(device_dir, vdev)
                vdevs.append(vdev)

    # NOTE: handle nested OrderedDict (legacy layout)
    #       this is also used to parse the nested OrderedDicts
    #       from the new layout
    elif isinstance(layout, OrderedDict):
        for vdev in layout:
            # NOTE: extract the vdev type and disks in the vdev
            vdev_type = vdev.split(&quot;-&quot;)[0]
            vdev_disk = layout[vdev]

            # NOTE: skip appending the dummy type 'disk'
            if vdev_type != &quot;disk&quot;:
                vdevs.append(vdev_type)

            # NOTE: ensure the disks are a list (legacy layout are not)
            if not isinstance(vdev_disk, list):
                vdev_disk = vdev_disk.split(&quot; &quot;)

            # NOTE: also append the actualy disks behind the type
            #       also prepend device_dir to disks if required
            for disk in vdev_disk:
                if device_dir and disk[0] != &quot;/&quot;:
                    disk = os.path.join(device_dir, disk)
                vdevs.append(disk)

    # NOTE: we got invalid data for layout
    else:
        vdevs = None

    return vdevs


def present(
    name, properties=None, filesystem_properties=None, layout=None, config=None
):
    &quot;&quot;&quot;
    ensure storage pool is present on the system

    name : string
        name of storage pool
    properties : dict
        optional set of properties to set for the storage pool
    filesystem_properties : dict
        optional set of filesystem properties to set for the storage pool (creation only)
    layout: dict
        disk layout to use if the pool does not exist (creation only)
    config : dict
        fine grain control over this state

    .. note::

        The following configuration properties can be toggled in the config parameter.
          - import (true) - try to import the pool before creating it if absent
          - import_dirs (None) - specify additional locations to scan for devices on import (comma-separated)
          - device_dir (None, SunOS=/dev/dsk, Linux=/dev) - specify device directory to prepend for none
            absolute device paths
          - force (false) - try to force the import or creation

    .. note::

        It is no longer needed to give a unique name to each top-level vdev, the old
        layout format is still supported but no longer recommended.

        .. code-block:: yaml

            - mirror:
              - /tmp/vdisk3
              - /tmp/vdisk2
            - mirror:
              - /tmp/vdisk0
              - /tmp/vdisk1

        The above yaml will always result in the following zpool create:

        .. code-block:: bash

            zpool create mypool mirror /tmp/vdisk3 /tmp/vdisk2 mirror /tmp/vdisk0 /tmp/vdisk1

    .. warning::

        The legacy format is also still supported but not recommended,
        because ID's inside the layout dict must be unique they need to have a suffix.

        .. code-block:: yaml

            mirror-0:
              /tmp/vdisk3
              /tmp/vdisk2
            mirror-1:
              /tmp/vdisk0
              /tmp/vdisk1

    .. warning::

        Pay attention to the order of your dict!

        .. code-block:: yaml

            - mirror:
              - /tmp/vdisk0
              - /tmp/vdisk1
            - /tmp/vdisk2

        The above will result in the following zpool create:

        .. code-block:: bash

            zpool create mypool mirror /tmp/vdisk0 /tmp/vdisk1 /tmp/vdisk2

        Creating a 3-way mirror! While you probably expect it to be mirror
        root vdev with 2 devices + a root vdev of 1 device!

    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: None, &quot;comment&quot;: &quot;&quot;}

    # config defaults
    default_config = {
        &quot;import&quot;: True,
        &quot;import_dirs&quot;: None,
        &quot;device_dir&quot;: None,
        &quot;force&quot;: False,
    }
    if __grains__[&quot;kernel&quot;] == &quot;SunOS&quot;:
        default_config[&quot;device_dir&quot;] = &quot;/dev/dsk&quot;
    elif __grains__[&quot;kernel&quot;] == &quot;Linux&quot;:
        default_config[&quot;device_dir&quot;] = &quot;/dev&quot;

    # merge state config
    if config:
        default_config.update(config)
    config = default_config

    # ensure properties are zfs values
    if properties:
        properties = __utils__[&quot;zfs.from_auto_dict&quot;](properties)
    elif properties is None:
        properties = {}
    if filesystem_properties:
        filesystem_properties = __utils__[&quot;zfs.from_auto_dict&quot;](filesystem_properties)
    elif filesystem_properties is None:
        filesystem_properties = {}

    # parse layout
    vdevs = _layout_to_vdev(layout, config[&quot;device_dir&quot;])
    if vdevs:
        vdevs.insert(0, name)

    # log configuration
    log.debug(&quot;zpool.present::%s::config - %s&quot;, name, config)
    log.debug(&quot;zpool.present::%s::vdevs - %s&quot;, name, vdevs)
    log.debug(&quot;zpool.present::%s::properties -  %s&quot;, name, properties)
    log.debug(
        &quot;zpool.present::%s::filesystem_properties -  %s&quot;, name, filesystem_properties
    )

    # ensure the pool is present
    ret[&quot;result&quot;] = False

    # don't do anything because this is a test
<A NAME="0"></A>    if __opts__[&quot;test&quot;]:
        if __salt__[&quot;zpool.exists&quot;](name):
            ret[&quot;result&quot;] = True
            ret[&quot;comment&quot;] <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match68471-1.html#0',3,'match68471-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>= &quot;storage pool {} is {}&quot;.format(name, &quot;uptodate&quot;)
        else:
            ret[&quot;result&quot;] = None
            ret[&quot;changes&quot;][name] = &quot;imported&quot; if config[&quot;import&quot;] else &quot;created&quot;
            ret[&quot;comment&quot;] = &quot;storage pool {} would have been {}&quot;.</B></FONT>format(
                name, ret[&quot;changes&quot;][name]
            )

    # update pool
    elif __salt__[&quot;zpool.exists&quot;](name):
        ret[&quot;result&quot;] = True

        # fetch current pool properties
        properties_current = __salt__[&quot;zpool.get&quot;](name, parsable=True)

        # build list of properties to update
        properties_update = []
        if properties:
            for prop in properties:
                # skip unexisting properties
                if prop not in properties_current:
                    log.warning(
                        &quot;zpool.present::%s::update - unknown property: %s&quot;, name, prop
                    )
                    continue

                # compare current and wanted value
                if properties_current[prop] != properties[prop]:
                    properties_update.append(prop)

        # update pool properties
        for prop in properties_update:
            res = __salt__[&quot;zpool.set&quot;](name, prop, properties[prop])

            if res[&quot;set&quot;]:
                if name not in ret[&quot;changes&quot;]:
                    ret[&quot;changes&quot;][name] = {}
                ret[&quot;changes&quot;][name][prop] = properties[prop]
            else:
                ret[&quot;result&quot;] = False
                if ret[&quot;comment&quot;] == &quot;&quot;:
                    ret[&quot;comment&quot;] = &quot;The following properties were not updated:&quot;
                ret[&quot;comment&quot;] = &quot;{} {}&quot;.format(ret[&quot;comment&quot;], prop)

        if ret[&quot;result&quot;]:
            ret[&quot;comment&quot;] = (
                &quot;properties updated&quot; if ret[&quot;changes&quot;] else &quot;no update needed&quot;
            )

    # import or create the pool (at least try to anyway)
    else:
        # import pool
        if config[&quot;import&quot;]:
            mod_res = __salt__[&quot;zpool.import&quot;](
                name,
                force=config[&quot;force&quot;],
                dir=config[&quot;import_dirs&quot;],
            )

            ret[&quot;result&quot;] = mod_res[&quot;imported&quot;]
            if ret[&quot;result&quot;]:
                ret[&quot;changes&quot;][name] = &quot;imported&quot;
                ret[&quot;comment&quot;] = &quot;storage pool {} was imported&quot;.format(name)

        # create pool
        if not ret[&quot;result&quot;] and vdevs:
            log.debug(&quot;zpool.present::%s::creating&quot;, name)

            # execute zpool.create
            mod_res = __salt__[&quot;zpool.create&quot;](
                *vdevs,
                force=config[&quot;force&quot;],
                properties=properties,
                filesystem_properties=filesystem_properties
            )

            ret[&quot;result&quot;] = mod_res[&quot;created&quot;]
            if ret[&quot;result&quot;]:
                ret[&quot;changes&quot;][name] = &quot;created&quot;
                ret[&quot;comment&quot;] = &quot;storage pool {} was created&quot;.format(name)
            elif &quot;error&quot; in mod_res:
                ret[&quot;comment&quot;] = mod_res[&quot;error&quot;]
            else:
                ret[&quot;comment&quot;] = &quot;could not create storage pool {}&quot;.format(name)

        # give up, we cannot import the pool and we do not have a layout to create it
        if not ret[&quot;result&quot;] and not vdevs:
            ret[&quot;comment&quot;] = (
                &quot;storage pool {} was not imported, no (valid) layout specified for&quot;
                &quot; creation&quot;.format(name)
            )

    return ret


def absent(name, export=False, force=False):
    &quot;&quot;&quot;
    ensure storage pool is absent on the system

    name : string
        name of storage pool
    export : boolean
        export instead of destroy the zpool if present
    force : boolean
        force destroy or export

    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: None, &quot;comment&quot;: &quot;&quot;}

    # log configuration
    log.debug(&quot;zpool.absent::%s::config::force = %s&quot;, name, force)
    log.debug(&quot;zpool.absent::%s::config::export = %s&quot;, name, export)

    # ensure the pool is absent
    if __salt__[&quot;zpool.exists&quot;](name):  # looks like we need to do some work
        mod_res = {}
        ret[&quot;result&quot;] = False

        # NOTE: handle test
        if __opts__[&quot;test&quot;]:
            ret[&quot;result&quot;] = True

        # NOTE: try to export the pool
        elif export:
            mod_res = __salt__[&quot;zpool.export&quot;](name, force=force)
            ret[&quot;result&quot;] = mod_res[&quot;exported&quot;]

        # NOTE: try to destroy the pool
        else:
            mod_res = __salt__[&quot;zpool.destroy&quot;](name, force=force)
            ret[&quot;result&quot;] = mod_res[&quot;destroyed&quot;]

        if ret[&quot;result&quot;]:  # update the changes and comment
            ret[&quot;changes&quot;][name] = &quot;exported&quot; if export else &quot;destroyed&quot;
            ret[&quot;comment&quot;] = &quot;storage pool {} was {}&quot;.format(name, ret[&quot;changes&quot;][name])
        elif &quot;error&quot; in mod_res:
            ret[&quot;comment&quot;] = mod_res[&quot;error&quot;]

    else:  # we are looking good
        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;storage pool {} is absent&quot;.format(name)

    return ret


# vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>nfs3.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Module for managing NFS version 3.
&quot;&quot;&quot;

import logging

import salt.utils.files
import salt.utils.path
import salt.utils.stringutils

log = logging.getLogger(__name__)


def __virtual__():
    &quot;&quot;&quot;
    Only work on POSIX-like systems
    &quot;&quot;&quot;
    if not salt.utils.path.which(&quot;showmount&quot;):
        return (
            False,
            &quot;The nfs3 execution module failed to load: the showmount binary is not in&quot;
            &quot; the path.&quot;,
        )
    return True


def list_exports(exports=&quot;/etc/exports&quot;):
    &quot;&quot;&quot;
    List configured exports

    CLI Example:

    .. code-block:: bash

        salt '*' nfs.list_exports
    &quot;&quot;&quot;
    ret = {}
    with salt.utils.files.fopen(exports, &quot;r&quot;) as efl:
        for line in salt.utils.stringutils.to_unicode(efl.read()).splitlines():
            if not line:
                continue
            if line.startswith(&quot;#&quot;):
                continue
            comps = line.split()

            # Handle the case where the same path is given twice
            if not comps[0] in ret:
                ret[comps[0]] = []

            newshares = []
            for perm in comps[1:]:
                if perm.startswith(&quot;/&quot;):
                    newshares.append(perm)
                    continue
                permcomps = perm.split(&quot;(&quot;)
                permcomps[1] = permcomps[1].replace(&quot;)&quot;, &quot;&quot;)
                hosts = permcomps[0]
                if not isinstance(hosts, str):
                    # Lists, etc would silently mangle /etc/exports
                    raise TypeError(&quot;hosts argument must be a string&quot;)
                options = permcomps[1].split(&quot;,&quot;)
                ret[comps[0]].append({&quot;hosts&quot;: hosts, &quot;options&quot;: options})
            for share in newshares:
                ret[share] = ret[comps[0]]
    return ret


def del_export(exports=&quot;/etc/exports&quot;, path=None):
    &quot;&quot;&quot;
    Remove an export

    CLI Example:

    .. code-block:: bash

        salt '*' nfs.del_export /media/storage
    &quot;&quot;&quot;
    edict = list_exports(exports)
    del edict[path]
    _write_exports(exports, edict)
    return edict


def add_export(exports=&quot;/etc/exports&quot;, path=None, hosts=None, options=None):
    &quot;&quot;&quot;
    Add an export

    CLI Example:

    .. code-block:: bash

        salt '*' nfs3.add_export path='/srv/test' hosts='127.0.0.1' options=['rw']
    &quot;&quot;&quot;
    if options is None:
        options = []
    if not isinstance(hosts, str):
        # Lists, etc would silently mangle /etc/exports
        raise TypeError(&quot;hosts argument must be a string&quot;)
    edict = list_exports(exports)
    if path not in edict:
        edict[path] = []
    new = {&quot;hosts&quot;: hosts, &quot;options&quot;: options}
    edict[path].append(new)
    _write_exports(exports, edict)

    return new


def _write_exports(exports, edict):
    &quot;&quot;&quot;
    Write an exports file to disk

    If multiple shares were initially configured per line, like:

        /media/storage /media/data *(ro,sync,no_subtree_check)

    ...then they will be saved to disk with only one share per line:

        /media/storage *(ro,sync,no_subtree_check)
        /media/data *(ro,sync,no_subtree_check)
    &quot;&quot;&quot;
    with salt.utils.files.fopen(exports, &quot;w&quot;) as efh:
        for export in edict:
            line = salt.utils.stringutils.to_str(export)
            for perms in edict[export]:
                hosts = perms[&quot;hosts&quot;]
                options = &quot;,&quot;.join(perms[&quot;options&quot;])
                line += &quot; {}({})&quot;.format(hosts, options)
            efh.write(&quot;{}\n&quot;.format(line))


def reload_exports():
    &quot;&quot;&quot;
    Trigger a reload of the exports file to apply changes

    CLI Example:

    .. code-block:: bash

        salt '*' nfs3.reload_exports
    &quot;&quot;&quot;
    ret = {}
<A NAME="0"></A>
    command = &quot;exportfs -r&quot;

    output <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match68471-0.html#0',2,'match68471-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>= __salt__[&quot;cmd.run_all&quot;](command)
    ret[&quot;stdout&quot;] = output[&quot;stdout&quot;]
    ret[&quot;stderr&quot;] = output[&quot;stderr&quot;]
    # exportfs always returns 0, so retcode is useless
    # We will consider it an error if stderr is nonempty
    ret[&quot;result&quot;] = output[</B></FONT>&quot;stderr&quot;] == &quot;&quot;

    return ret
</PRE>
</div>
  </div>
</body>
</html>
