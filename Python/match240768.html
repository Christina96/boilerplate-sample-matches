<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for aptpkg_1.py &amp; kiwiproc.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for aptpkg_1.py &amp; kiwiproc.py
      </h3>
<h1 align="center">
        1.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>aptpkg_1.py (0.6717045%)<th>kiwiproc.py (5.769231%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(2162-2169)<td><a href="#" name="0">(205-210)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(770-780)<td><a href="#" name="1">(77-81)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>aptpkg_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import copy
import datetime
import fnmatch
import logging
import os
import pathlib
import re
import shutil
import tempfile
import time
from urllib.error import HTTPError
from urllib.request import Request as _Request
from urllib.request import urlopen as _urlopen
import salt.config
import salt.syspaths
import salt.utils.args
import salt.utils.data
import salt.utils.environment
import salt.utils.files
import salt.utils.functools
import salt.utils.itertools
import salt.utils.json
import salt.utils.path
import salt.utils.pkg
import salt.utils.pkg.deb
import salt.utils.stringutils
import salt.utils.systemd
import salt.utils.versions
import salt.utils.yaml
from salt.exceptions import (
    CommandExecutionError,
    CommandNotFoundError,
    MinionError,
    SaltInvocationError,
)
from salt.modules.cmdmod import _parse_env
log = logging.getLogger(__name__)
try:
    import apt.cache
    import apt.debfile
    from aptsources.sourceslist import (
        SourceEntry,
        SourcesList,
    )
    HAS_APT = True
except ImportError:
    HAS_APT = False
try:
    import apt_pkg
    HAS_APTPKG = True
except ImportError:
    HAS_APTPKG = False
try:
    import softwareproperties.ppa
    HAS_SOFTWAREPROPERTIES = True
except ImportError:
    HAS_SOFTWAREPROPERTIES = False
APT_LISTS_PATH = "/var/lib/apt/lists"
PKG_ARCH_SEPARATOR = ":"
LP_SRC_FORMAT = "deb http://ppa.launchpad.net/{0}/{1}/ubuntu {2} main"
LP_PVT_SRC_FORMAT = "deb https://{0}private-ppa.launchpad.net/{1}/{2}/ubuntu {3} main"
_MODIFY_OK = frozenset(["uri", "comps", "architectures", "disabled", "file", "dist"])
DPKG_ENV_VARS = {
    "APT_LISTBUGS_FRONTEND": "none",
    "APT_LISTCHANGES_FRONTEND": "none",
    "DEBIAN_FRONTEND": "noninteractive",
    "UCF_FORCE_CONFFOLD": "1",
}
__virtualname__ = "pkg"
def __virtual__():
    if __grains__.get("os_family") == "Debian":
        return __virtualname__
    return False, "The pkg module could not be loaded: unsupported OS family"
def __init__(opts):
    if __virtual__() == __virtualname__:
        os.environ.update(DPKG_ENV_VARS)
if not HAS_APT:
    class SourceEntry:  # pylint: disable=function-redefined
        def __init__(self, line, file=None):
            self.invalid = False
            self.comps = []
            self.disabled = False
            self.comment = ""
            self.dist = ""
            self.type = ""
            self.uri = ""
            self.line = line
            self.architectures = []
            self.file = file
            if not self.file:
                self.file = str(pathlib.Path(os.sep, "etc", "apt", "sources.list"))
            self._parse_sources(line)
        def repo_line(self):
            repo_line = []
            if self.invalid:
                return self.line
            if self.disabled:
                repo_line.append("#")
            repo_line.append(self.type)
            if self.architectures:
                repo_line.append("[arch={}]".format(" ".join(self.architectures)))
            repo_line = repo_line + [self.uri, self.dist, " ".join(self.comps)]
            if self.comment:
                repo_line.append("#{}".format(self.comment))
            return " ".join(repo_line) + "\n"
        def _parse_sources(self, line):
            self.disabled = False
            repo_line = self.line.strip().split()
            if not repo_line:
                self.invalid = True
                return False
            if repo_line[0].startswith("#"):
                repo_line.pop(0)
                self.disabled = True
            if repo_line[0] not in ["deb", "deb-src", "rpm", "rpm-src"]:
                self.invalid = True
                return False
            if repo_line[1].startswith("["):
                opts = re.search(r"\[.*\]", self.line).group(0).strip("[]")
                repo_line = [x for x in (line.strip("[]") for line in repo_line) if x]
                for opt in opts.split():
                    if opt.startswith("arch"):
                        self.architectures.extend(opt.split("=", 1)[1].split(","))
                    try:
                        repo_line.pop(repo_line.index(opt))
                    except ValueError:
                        repo_line.pop(repo_line.index("[" + opt + "]"))
            self.type = repo_line[0]
            self.uri = repo_line[1]
            self.dist = repo_line[2]
            self.comps = repo_line[3:]
    class SourcesList:  # pylint: disable=function-redefined
        def __init__(self):
            self.list = []
            self.files = [
                pathlib.Path(os.sep, "etc", "apt", "sources.list"),
                pathlib.Path(os.sep, "etc", "apt", "sources.list.d"),
            ]
            for file in self.files:
                if file.is_dir():
                    for fp in file.glob("**/*.list"):
                        self.add_file(file=fp)
                else:
                    self.add_file(file)
        def __iter__(self):
            yield from self.list
        def add_file(self, file):
            if file.is_file():
                with salt.utils.files.fopen(file) as source:
                    for line in source:
                        self.list.append(SourceEntry(line, file=str(file)))
            else:
                log.debug("The apt sources file %s does not exist", file)
        def add(self, type, uri, dist, orig_comps, architectures):
            repo_line = [
                type,
                " [arch={}] ".format(" ".join(architectures)) if architectures else "",
                uri,
                dist,
                " ".join(orig_comps),
            ]
            return SourceEntry(" ".join(repo_line))
        def remove(self, source):
            self.list.remove(source)
        def save(self):
            filemap = {}
            with tempfile.TemporaryDirectory() as tmpdir:
                for source in self.list:
                    fname = pathlib.Path(tmpdir, pathlib.Path(source.file).name)
                    with salt.utils.files.fopen(fname, "a") as fp:
                        fp.write(source.repo_line())
                    if source.file not in filemap:
                        filemap[source.file] = {"tmp": fname}
                for fp in filemap:
                    shutil.move(filemap[fp]["tmp"], fp)
def _get_ppa_info_from_launchpad(owner_name, ppa_name):
    lp_url = "https://launchpad.net/api/1.0/~{}/+archive/{}".format(
        owner_name, ppa_name
    )
    request = _Request(lp_url, headers={"Accept": "application/json"})
    lp_page = _urlopen(request)
    return salt.utils.json.load(lp_page)
def _reconstruct_ppa_name(owner_name, ppa_name):
    return "ppa:{}/{}".format(owner_name, ppa_name)
def _call_apt(args, scope=True, **kwargs):
    cmd = []
    if (
        scope
        and salt.utils.systemd.has_scope(__context__)
        and __salt__["config.get"]("systemd.scope", True)
    ):
        cmd.extend(["systemd-run", "--scope", "--description", '"{}"'.format(__name__)])
    cmd.extend(args)
    params = {
        "output_loglevel": "trace",
        "python_shell": False,
        "env": salt.utils.environment.get_module_environment(globals()),
    }
    params.update(kwargs)
    cmd_ret = __salt__["cmd.run_all"](cmd, **params)
    count = 0
    while "Could not get lock" in cmd_ret.get("stderr", "") and count &lt; 10:
        count += 1
        log.warning("Waiting for dpkg lock release: retrying... %s/100", count)
        time.sleep(2 ** count)
        cmd_ret = __salt__["cmd.run_all"](cmd, **params)
    return cmd_ret
def _warn_software_properties(repo):
    log.warning(
        "The 'python-software-properties' package is not installed. "
        "For more accurate support of PPA repositories, you should "
        "install this package."
    )
    log.warning("Best guess at ppa format: %s", repo)
def normalize_name(name):
    try:
        pkgname, pkgarch = name.rsplit(PKG_ARCH_SEPARATOR, 1)
    except ValueError:
        pkgname = name
        pkgarch = __grains__["osarch"]
    return pkgname if pkgarch in (__grains__["osarch"], "all", "any") else name
def parse_arch(name):
    try:
        _name, _arch = name.rsplit(PKG_ARCH_SEPARATOR, 1)
    except ValueError:
        _name, _arch = name, None
    return {"name": _name, "arch": _arch}
def latest_version(*names, **kwargs):
    refresh = salt.utils.data.is_true(kwargs.pop("refresh", True))
    show_installed = salt.utils.data.is_true(kwargs.pop("show_installed", False))
    if "repo" in kwargs:
        raise SaltInvocationError(
            "The 'repo' argument is invalid, use 'fromrepo' instead"
        )
    fromrepo = kwargs.pop("fromrepo", None)
    cache_valid_time = kwargs.pop("cache_valid_time", 0)
    if not names:
        return ""
    ret = {}
    for name in names:
        ret[name] = ""
    pkgs = list_pkgs(versions_as_list=True)
    repo = ["-o", "APT::Default-Release={}".format(fromrepo)] if fromrepo else None
    if refresh:
        refresh_db(cache_valid_time)
    for name in names:
        cmd = ["apt-cache", "-q", "policy", name]
        if repo is not None:
            cmd.extend(repo)
        out = _call_apt(cmd, scope=False)
        candidate = ""
        for line in salt.utils.itertools.split(out["stdout"], "\n"):
            if "Candidate" in line:
                comps = line.split()
                if len(comps) &gt;= 2:
                    candidate = comps[-1]
                    if candidate.lower() == "(none)":
                        candidate = ""
                break
        installed = pkgs.get(name, [])
        if not installed:
            ret[name] = candidate
        elif installed and show_installed:
            ret[name] = candidate
        elif candidate:
            if not any(
                salt.utils.versions.compare(
                    ver1=x, oper="&gt;=", ver2=candidate, cmp_func=version_cmp
                )
                for x in installed
            ):
                ret[name] = candidate
    if len(names) == 1:
        return ret[names[0]]
    return ret
available_version = salt.utils.functools.alias_function(
    latest_version, "available_version"
)
def version(*names, **kwargs):
    return __salt__["pkg_resource.version"](*names, **kwargs)
def refresh_db(cache_valid_time=0, failhard=False, **kwargs):
    salt.utils.pkg.clear_rtag(__opts__)
    failhard = salt.utils.data.is_true(failhard)
    ret = {}
    error_repos = list()
    if cache_valid_time:
        try:
            latest_update = os.stat(APT_LISTS_PATH).st_mtime
            now = time.time()
            log.debug(
                "now: %s, last update time: %s, expire after: %s seconds",
                now,
                latest_update,
                cache_valid_time,
            )
            if latest_update + cache_valid_time &gt; now:
                return ret
        except TypeError as exp:
            log.warning(
                "expected integer for cache_valid_time parameter, failed with: %s", exp
            )
        except OSError as exp:
            log.warning("could not stat cache directory due to: %s", exp)
    call = _call_apt(["apt-get", "-q", "update"], scope=False)
    if call["retcode"] != 0:
        comment = ""
        if "stderr" in call:
            comment += call["stderr"]
        raise CommandExecutionError(comment)
    else:
        out = call["stdout"]
    for line in out.splitlines():
        cols = line.split()
        if not cols:
            continue
        ident = " ".join(cols[1:])
        if "Get" in cols[0]:
            ident = re.sub(r" \[.+B\]$", "", ident)
            ret[ident] = True
        elif "Ign" in cols[0]:
            ret[ident] = False
        elif "Hit" in cols[0]:
            ret[ident] = None
        elif "Err" in cols[0]:
            ret[ident] = False
            error_repos.append(ident)
    if failhard and error_repos:
        raise CommandExecutionError(
            "Error getting repos: {}".format(", ".join(error_repos))
        )
    return ret
def install(
    name=None,
    refresh=False,
    fromrepo=None,
    skip_verify=False,
    debconf=None,
    pkgs=None,
    sources=None,
    reinstall=False,
    downloadonly=False,
    ignore_epoch=False,
    **kwargs
):
    _refresh_db = False
    if salt.utils.data.is_true(refresh):
        _refresh_db = True
        if "version" in kwargs and kwargs["version"]:
            _refresh_db = False
            _latest_version = latest_version(name, refresh=False, show_installed=True)
            _version = kwargs.get("version")
            if not _latest_version == _version:
                _refresh_db = True
        if pkgs:
            _refresh_db = False
            for pkg in pkgs:
                if isinstance(pkg, dict):
                    _name = next(iter(pkg.keys()))
                    _latest_version = latest_version(
                        _name, refresh=False, show_installed=True
                    )
                    _version = pkg[_name]
                    if not _latest_version == _version:
                        _refresh_db = True
                else:
                    _refresh_db = True
    if debconf:
        __salt__["debconf.set_file"](debconf)
    try:
        pkg_params, pkg_type = __salt__["pkg_resource.parse_targets"](
            name, pkgs, sources, **kwargs
        )
    except MinionError as exc:
        raise CommandExecutionError(exc)
    repo = kwargs.get("repo", "")
    if not fromrepo and repo:
        fromrepo = repo
    if not pkg_params:
        return {}
    cmd_prefix = []
    old = list_pkgs()
    targets = []
    downgrade = []
    to_reinstall = {}
    errors = []
<a name="1"></a>    if pkg_type == "repository":
        pkg_params_items = list(pkg_params.items())
        has_comparison = [
            <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>x
            for x, y in pkg_params_items
            if y is not None and (y.startswith("&lt;") or y.startswith("&gt;"))
        ]
        _available = (
            list_repo_pkgs(*has_comparison, byrepo=False, **kwargs)
            if has_comparison
            else {}
        )
        cmd_prefix.extend(["apt-get"</b></font>, "-q", "-y"])
        if kwargs.get("force_yes", False):
            cmd_prefix.append("--force-yes")
        if "force_conf_new" in kwargs and kwargs["force_conf_new"]:
            cmd_prefix.extend(["-o", "DPkg::Options::=--force-confnew"])
        else:
            cmd_prefix.extend(["-o", "DPkg::Options::=--force-confold"])
            cmd_prefix += ["-o", "DPkg::Options::=--force-confdef"]
        if "install_recommends" in kwargs:
            if not kwargs["install_recommends"]:
                cmd_prefix.append("--no-install-recommends")
            else:
                cmd_prefix.append("--install-recommends")
        if "only_upgrade" in kwargs and kwargs["only_upgrade"]:
            cmd_prefix.append("--only-upgrade")
        if skip_verify:
            cmd_prefix.append("--allow-unauthenticated")
        if fromrepo:
            cmd_prefix.extend(["-t", fromrepo])
        cmd_prefix.append("install")
    else:
        pkg_params_items = []
        for pkg_source in pkg_params:
            if "lowpkg.bin_pkg_info" in __salt__:
                deb_info = __salt__["lowpkg.bin_pkg_info"](pkg_source)
            else:
                deb_info = None
            if deb_info is None:
                log.error(
                    "pkg.install: Unable to get deb information for %s. "
                    "Version comparisons will be unavailable.",
                    pkg_source,
                )
                pkg_params_items.append([pkg_source])
            else:
                pkg_params_items.append(
                    [deb_info["name"], pkg_source, deb_info["version"]]
                )
        if "force_conf_new" in kwargs and kwargs["force_conf_new"]:
            cmd_prefix.extend(["dpkg", "-i", "--force-confnew"])
        else:
            cmd_prefix.extend(["dpkg", "-i", "--force-confold"])
        if skip_verify:
            cmd_prefix.append("--force-bad-verify")
        if HAS_APT:
            _resolve_deps(name, pkg_params, **kwargs)
    for pkg_item_list in pkg_params_items:
        if pkg_type == "repository":
            pkgname, version_num = pkg_item_list
            if name and pkgs is None and kwargs.get("version") and len(pkg_params) == 1:
                version_num = kwargs["version"]
        else:
            try:
                pkgname, pkgpath, version_num = pkg_item_list
            except ValueError:
                pkgname = None
                pkgpath = pkg_item_list[0]
                version_num = None
        if version_num is None:
            if pkg_type == "repository":
                if reinstall and pkgname in old:
                    to_reinstall[pkgname] = pkgname
                else:
                    targets.append(pkgname)
            else:
                targets.append(pkgpath)
        else:
            if pkg_type == "repository":
                version_num = version_num.lstrip("=")
                if pkgname in has_comparison:
                    candidates = _available.get(pkgname, [])
                    target = salt.utils.pkg.match_version(
                        version_num,
                        candidates,
                        cmp_func=version_cmp,
                        ignore_epoch=ignore_epoch,
                    )
                    if target is None:
                        errors.append(
                            "No version matching '{}{}' could be found "
                            "(available: {})".format(
                                pkgname,
                                version_num,
                                ", ".join(candidates) if candidates else None,
                            )
                        )
                        continue
                    else:
                        version_num = target
                pkgstr = "{}={}".format(pkgname, version_num)
            else:
                pkgstr = pkgpath
            cver = old.get(pkgname, "")
            if (
                reinstall
                and cver
                and salt.utils.versions.compare(
                    ver1=version_num, oper="==", ver2=cver, cmp_func=version_cmp
                )
            ):
                to_reinstall[pkgname] = pkgstr
            elif not cver or salt.utils.versions.compare(
                ver1=version_num, oper="&gt;=", ver2=cver, cmp_func=version_cmp
            ):
                targets.append(pkgstr)
            else:
                downgrade.append(pkgstr)
    if fromrepo and not sources:
        log.info("Targeting repo '%s'", fromrepo)
    cmds = []
    all_pkgs = []
    if targets:
        all_pkgs.extend(targets)
        cmd = copy.deepcopy(cmd_prefix)
        cmd.extend(targets)
        cmds.append(cmd)
    if downgrade:
        cmd = copy.deepcopy(cmd_prefix)
        if pkg_type == "repository" and "--force-yes" not in cmd:
            cmd.insert(-1, "--force-yes")
        cmd.extend(downgrade)
        cmds.append(cmd)
    if downloadonly:
        cmd.append("--download-only")
    if to_reinstall:
        all_pkgs.extend(to_reinstall)
        cmd = copy.deepcopy(cmd_prefix)
        if not sources:
            cmd.append("--reinstall")
        cmd.extend([x for x in to_reinstall.values()])
        cmds.append(cmd)
    if not cmds:
        ret = {}
    else:
        cache_valid_time = kwargs.pop("cache_valid_time", 0)
        if _refresh_db:
            refresh_db(cache_valid_time)
        env = _parse_env(kwargs.get("env"))
        env.update(DPKG_ENV_VARS.copy())
        hold_pkgs = get_selections(state="hold").get("hold", [])
        targeted_names = [x.split("=")[0] for x in all_pkgs]
        to_unhold = [x for x in hold_pkgs if x in targeted_names]
        if to_unhold:
            unhold(pkgs=to_unhold)
        for cmd in cmds:
            out = _call_apt(cmd)
            if out["retcode"] != 0 and out["stderr"]:
                errors.append(out["stderr"])
        __context__.pop("pkg.list_pkgs", None)
        new = list_pkgs()
        ret = salt.utils.data.compare_dicts(old, new)
        for pkgname in to_reinstall:
            if pkgname not in ret or pkgname in old:
                ret.update(
                    {
                        pkgname: {
                            "old": old.get(pkgname, ""),
                            "new": new.get(pkgname, ""),
                        }
                    }
                )
        if to_unhold:
            hold(pkgs=to_unhold)
    if errors:
        raise CommandExecutionError(
            "Problem encountered installing package(s)",
            info={"errors": errors, "changes": ret},
        )
    return ret
def _uninstall(action="remove", name=None, pkgs=None, **kwargs):
    try:
        pkg_params = __salt__["pkg_resource.parse_targets"](name, pkgs)[0]
    except MinionError as exc:
        raise CommandExecutionError(exc)
    old = list_pkgs()
    old_removed = list_pkgs(removed=True)
    targets = [x for x in pkg_params if x in old]
    if action == "purge":
        targets.extend([x for x in pkg_params if x in old_removed])
    if not targets:
        return {}
    cmd = ["apt-get", "-q", "-y", action]
    cmd.extend(targets)
    env = _parse_env(kwargs.get("env"))
    env.update(DPKG_ENV_VARS.copy())
    out = _call_apt(cmd, env=env)
    if out["retcode"] != 0 and out["stderr"]:
        errors = [out["stderr"]]
    else:
        errors = []
    __context__.pop("pkg.list_pkgs", None)
    new = list_pkgs()
    new_removed = list_pkgs(removed=True)
    changes = salt.utils.data.compare_dicts(old, new)
    if action == "purge":
        ret = {
            "removed": salt.utils.data.compare_dicts(old_removed, new_removed),
            "installed": changes,
        }
    else:
        ret = changes
    if errors:
        raise CommandExecutionError(
            "Problem encountered removing package(s)",
            info={"errors": errors, "changes": ret},
        )
    return ret
def autoremove(list_only=False, purge=False):
    cmd = []
    if list_only:
        ret = []
        cmd.extend(["apt-get", "--assume-no"])
        if purge:
            cmd.append("--purge")
        cmd.append("autoremove")
        out = _call_apt(cmd, ignore_retcode=True)["stdout"]
        found = False
        for line in out.splitlines():
            if found is True:
                if line.startswith(" "):
                    ret.extend(line.split())
                else:
                    found = False
            elif "The following packages will be REMOVED:" in line:
                found = True
        ret.sort()
        return ret
    else:
        old = list_pkgs()
        cmd.extend(["apt-get", "--assume-yes"])
        if purge:
            cmd.append("--purge")
        cmd.append("autoremove")
        _call_apt(cmd, ignore_retcode=True)
        __context__.pop("pkg.list_pkgs", None)
        new = list_pkgs()
        return salt.utils.data.compare_dicts(old, new)
def remove(name=None, pkgs=None, **kwargs):
    return _uninstall(action="remove", name=name, pkgs=pkgs, **kwargs)
def purge(name=None, pkgs=None, **kwargs):
    return _uninstall(action="purge", name=name, pkgs=pkgs, **kwargs)
def upgrade(refresh=True, dist_upgrade=False, **kwargs):
    cache_valid_time = kwargs.pop("cache_valid_time", 0)
    if salt.utils.data.is_true(refresh):
        refresh_db(cache_valid_time)
    old = list_pkgs()
    if "force_conf_new" in kwargs and kwargs["force_conf_new"]:
        dpkg_options = ["--force-confnew"]
    else:
        dpkg_options = ["--force-confold", "--force-confdef"]
    cmd = [
        "apt-get",
        "-q",
        "-y",
    ]
    for option in dpkg_options:
        cmd.append("-o")
        cmd.append("DPkg::Options::={}".format(option))
    if kwargs.get("force_yes", False):
        cmd.append("--force-yes")
    if kwargs.get("skip_verify", False):
        cmd.append("--allow-unauthenticated")
    if kwargs.get("download_only", False) or kwargs.get("downloadonly", False):
        cmd.append("--download-only")
    if kwargs.get("allow_downgrades", False):
        cmd.append("--allow-downgrades")
    cmd.append("dist-upgrade" if dist_upgrade else "upgrade")
    result = _call_apt(cmd, env=DPKG_ENV_VARS.copy())
    __context__.pop("pkg.list_pkgs", None)
    new = list_pkgs()
    ret = salt.utils.data.compare_dicts(old, new)
    if result["retcode"] != 0:
        raise CommandExecutionError(
            "Problem encountered upgrading packages",
            info={"changes": ret, "result": result},
        )
    return ret
def hold(name=None, pkgs=None, sources=None, **kwargs):  # pylint: disable=W0613
    if not name and not pkgs and not sources:
        raise SaltInvocationError("One of name, pkgs, or sources must be specified.")
    if pkgs and sources:
        raise SaltInvocationError("Only one of pkgs or sources can be specified.")
    targets = []
    if pkgs:
        targets.extend(pkgs)
    elif sources:
        for source in sources:
            targets.append(next(iter(source)))
    else:
        targets.append(name)
    ret = {}
    for target in targets:
        if isinstance(target, dict):
            target = next(iter(target))
        ret[target] = {"name": target, "changes": {}, "result": False, "comment": ""}
        state = get_selections(pattern=target, state="hold")
        if not state:
            ret[target]["comment"] = "Package {} not currently held.".format(target)
        elif not salt.utils.data.is_true(state.get("hold", False)):
            if "test" in __opts__ and __opts__["test"]:
                ret[target].update(result=None)
                ret[target]["comment"] = "Package {} is set to be held.".format(target)
            else:
                result = set_selections(selection={"hold": [target]})
                ret[target].update(changes=result[target], result=True)
                ret[target]["comment"] = "Package {} is now being held.".format(target)
        else:
            ret[target].update(result=True)
            ret[target]["comment"] = "Package {} is already set to be held.".format(
                target
            )
    return ret
def unhold(name=None, pkgs=None, sources=None, **kwargs):  # pylint: disable=W0613
    if not name and not pkgs and not sources:
        raise SaltInvocationError("One of name, pkgs, or sources must be specified.")
    if pkgs and sources:
        raise SaltInvocationError("Only one of pkgs or sources can be specified.")
    targets = []
    if pkgs:
        targets.extend(pkgs)
    elif sources:
        for source in sources:
            targets.append(next(iter(source)))
    else:
        targets.append(name)
    ret = {}
    for target in targets:
        if isinstance(target, dict):
            target = next(iter(target))
        ret[target] = {"name": target, "changes": {}, "result": False, "comment": ""}
        state = get_selections(pattern=target)
        if not state:
            ret[target]["comment"] = "Package {} does not have a state.".format(target)
        elif salt.utils.data.is_true(state.get("hold", False)):
            if "test" in __opts__ and __opts__["test"]:
                ret[target].update(result=None)
                ret[target]["comment"] = "Package {} is set not to be held.".format(
                    target
                )
            else:
                result = set_selections(selection={"install": [target]})
                ret[target].update(changes=result[target], result=True)
                ret[target]["comment"] = "Package {} is no longer being held.".format(
                    target
                )
        else:
            ret[target].update(result=True)
            ret[target]["comment"] = "Package {} is already set not to be held.".format(
                target
            )
    return ret
def _list_pkgs_from_context(versions_as_list, removed, purge_desired):
    if removed:
        ret = copy.deepcopy(__context__["pkg.list_pkgs"]["removed"])
    else:
        ret = copy.deepcopy(__context__["pkg.list_pkgs"]["purge_desired"])
        if not purge_desired:
            ret.update(__context__["pkg.list_pkgs"]["installed"])
    if not versions_as_list:
        __salt__["pkg_resource.stringify"](ret)
    return ret
def list_pkgs(
    versions_as_list=False, removed=False, purge_desired=False, **kwargs
):  # pylint: disable=W0613
    versions_as_list = salt.utils.data.is_true(versions_as_list)
    removed = salt.utils.data.is_true(removed)
    purge_desired = salt.utils.data.is_true(purge_desired)
    if "pkg.list_pkgs" in __context__ and kwargs.get("use_context", True):
        return _list_pkgs_from_context(versions_as_list, removed, purge_desired)
    ret = {"installed": {}, "removed": {}, "purge_desired": {}}
    cmd = [
        "dpkg-query",
        "--showformat",
        "${Status} ${Package} ${Version} ${Architecture}\n",
        "-W",
    ]
    out = __salt__["cmd.run_stdout"](cmd, output_loglevel="trace", python_shell=False)
    for line in out.splitlines():
        cols = line.split()
        try:
            linetype, status, name, version_num, arch = (
                cols[x] for x in (0, 2, 3, 4, 5)
            )
        except (ValueError, IndexError):
            continue
        if __grains__.get("cpuarch", "") == "x86_64":
            osarch = __grains__.get("osarch", "")
            if arch != "all" and osarch == "amd64" and osarch != arch:
                name += ":{}".format(arch)
        if cols:
            if ("install" in linetype or "hold" in linetype) and "installed" in status:
                __salt__["pkg_resource.add_pkg"](ret["installed"], name, version_num)
            elif "deinstall" in linetype:
                __salt__["pkg_resource.add_pkg"](ret["removed"], name, version_num)
            elif "purge" in linetype and status == "installed":
                __salt__["pkg_resource.add_pkg"](
                    ret["purge_desired"], name, version_num
                )
    for pkglist_type in ("installed", "removed", "purge_desired"):
        __salt__["pkg_resource.sort_pkglist"](ret[pkglist_type])
    __context__["pkg.list_pkgs"] = copy.deepcopy(ret)
    if removed:
        ret = ret["removed"]
    else:
        ret = copy.deepcopy(__context__["pkg.list_pkgs"]["purge_desired"])
        if not purge_desired:
            ret.update(__context__["pkg.list_pkgs"]["installed"])
    if not versions_as_list:
        __salt__["pkg_resource.stringify"](ret)
    return ret
def _get_upgradable(dist_upgrade=True, **kwargs):
    cmd = ["apt-get", "--just-print"]
    if dist_upgrade:
        cmd.append("dist-upgrade")
    else:
        cmd.append("upgrade")
    try:
        cmd.extend(["-o", "APT::Default-Release={}".format(kwargs["fromrepo"])])
    except KeyError:
        pass
    call = _call_apt(cmd)
    if call["retcode"] != 0:
        msg = "Failed to get upgrades"
        for key in ("stderr", "stdout"):
            if call[key]:
                msg += ": " + call[key]
                break
        raise CommandExecutionError(msg)
    else:
        out = call["stdout"]
    rexp = re.compile("(?m)^Conf " "([^ ]+) " r"\(([^ ]+)")  # Package name  # Version
    keys = ["name", "version"]
    _get = lambda l, k: l[keys.index(k)]
    upgrades = rexp.findall(out)
    ret = {}
    for line in upgrades:
        name = _get(line, "name")
        version_num = _get(line, "version")
        ret[name] = version_num
    return ret
def list_upgrades(refresh=True, dist_upgrade=True, **kwargs):
    cache_valid_time = kwargs.pop("cache_valid_time", 0)
    if salt.utils.data.is_true(refresh):
        refresh_db(cache_valid_time)
    return _get_upgradable(dist_upgrade, **kwargs)
def upgrade_available(name, **kwargs):
    return latest_version(name) != ""
def version_cmp(pkg1, pkg2, ignore_epoch=False, **kwargs):
    normalize = lambda x: str(x).split(":", 1)[-1] if ignore_epoch else str(x)
    pkg1 = normalize(pkg1)
    pkg2 = normalize(pkg2)
    if HAS_APTPKG:
        try:
            apt_pkg.init_system()
            try:
                ret = apt_pkg.version_compare(pkg1, pkg2)
            except TypeError:
                ret = apt_pkg.version_compare(str(pkg1), str(pkg2))
            return 1 if ret &gt; 0 else -1 if ret &lt; 0 else 0
        except Exception:  # pylint: disable=broad-except
            pass
    try:
        for oper, ret in (("lt", -1), ("eq", 0), ("gt", 1)):
            cmd = ["dpkg", "--compare-versions", pkg1, oper, pkg2]
            retcode = __salt__["cmd.retcode"](
                cmd, output_loglevel="trace", python_shell=False, ignore_retcode=True
            )
            if retcode == 0:
                return ret
    except Exception as exc:  # pylint: disable=broad-except
        log.error(exc)
    return None
def _split_repo_str(repo):
    split = SourceEntry(repo)
    return split.type, split.architectures, split.uri, split.dist, split.comps
def _consolidate_repo_sources(sources):
    if not isinstance(sources, SourcesList):
        raise TypeError("'{}' not a '{}'".format(type(sources), SourcesList))
    consolidated = {}
    delete_files = set()
    base_file = SourceEntry("").file
    repos = [s for s in sources.list if not s.invalid]
    for repo in repos:
        key = str(
            (
                getattr(repo, "architectures", []),
                repo.disabled,
                repo.type,
                repo.uri,
                repo.dist,
            )
        )
        if key in consolidated:
            combined = consolidated[key]
            combined_comps = set(repo.comps).union(set(combined.comps))
            consolidated[key].comps = list(combined_comps)
        else:
            consolidated[key] = SourceEntry(repo.line)
        if repo.file != base_file:
            delete_files.add(repo.file)
    sources.list = list(consolidated.values())
    sources.save()
    for file_ in delete_files:
        try:
            os.remove(file_)
        except OSError:
            pass
    return sources
def list_repo_pkgs(*args, **kwargs):  # pylint: disable=unused-import
    if args:
        cmd = ["apt-cache", "show"] + [arg for arg in args]
    else:
        cmd = ["apt-cache", "dump"]
    out = _call_apt(cmd, scope=False, ignore_retcode=True)
    ret = {}
    pkg_name = None
    skip_pkg = False
    new_pkg = re.compile("^Package: (.+)")
    for line in salt.utils.itertools.split(out["stdout"], "\n"):
        if not line.strip():
            continue
        try:
            cur_pkg = new_pkg.match(line).group(1)
        except AttributeError:
            pass
        else:
            if cur_pkg != pkg_name:
                pkg_name = cur_pkg
                continue
        comps = line.strip().split(None, 1)
        if comps[0] == "Version:":
            ret.setdefault(pkg_name, []).append(comps[1])
    return ret
def _skip_source(source):
    if source.invalid:
        if (
            source.uri
            and source.type
            and source.type in ("deb", "deb-src", "rpm", "rpm-src")
        ):
            pieces = source.mysplit(source.line)
            if pieces[1].strip()[0] == "[":
                options = pieces.pop(1).strip("[]").split()
                if len(options) &gt; 0:
                    log.debug(
                        "Source %s will be included although is marked invalid",
                        source.uri,
                    )
                    return False
            return True
        else:
            return True
    return False
def list_repos(**kwargs):
    repos = {}
    sources = SourcesList()
    for source in sources.list:
        if _skip_source(source):
            continue
        repo = {}
        repo["file"] = source.file
        repo["comps"] = getattr(source, "comps", [])
        repo["disabled"] = source.disabled
        repo["dist"] = source.dist
        repo["type"] = source.type
        repo["uri"] = source.uri
        repo["line"] = source.line.strip()
        repo["architectures"] = getattr(source, "architectures", [])
        repos.setdefault(source.uri, []).append(repo)
    return repos
def get_repo(repo, **kwargs):
    ppa_auth = kwargs.get("ppa_auth", None)
    if repo.startswith("ppa:") and __grains__["os"] in ("Ubuntu", "Mint", "neon"):
        dist = __grains__["lsb_distrib_codename"]
        owner_name, ppa_name = repo[4:].split("/")
        if ppa_auth:
            auth_info = "{}@".format(ppa_auth)
            repo = LP_PVT_SRC_FORMAT.format(auth_info, owner_name, ppa_name, dist)
        else:
            if HAS_SOFTWAREPROPERTIES:
                try:
                    if hasattr(softwareproperties.ppa, "PPAShortcutHandler"):
                        repo = softwareproperties.ppa.PPAShortcutHandler(repo).expand(
                            dist
                        )[0]
                    else:
                        repo = softwareproperties.ppa.expand_ppa_line(repo, dist)[0]
                except NameError as name_error:
                    raise CommandExecutionError(
                        "Could not find ppa {}: {}".format(repo, name_error)
                    )
            else:
                repo = LP_SRC_FORMAT.format(owner_name, ppa_name, dist)
    repos = list_repos()
    if repos:
        try:
            (
                repo_type,
                repo_architectures,
                repo_uri,
                repo_dist,
                repo_comps,
            ) = _split_repo_str(repo)
            if ppa_auth:
                uri_match = re.search("(http[s]?://)(.+)", repo_uri)
                if uri_match:
                    if not uri_match.group(2).startswith(ppa_auth):
                        repo_uri = "{}{}@{}".format(
                            uri_match.group(1), ppa_auth, uri_match.group(2)
                        )
        except SyntaxError:
            raise CommandExecutionError(
                "Error: repo '{}' is not a well formatted definition".format(repo)
            )
        for source in repos.values():
            for sub in source:
                if (
                    sub["type"] == repo_type
                    and sub["uri"] == repo_uri
                    and sub["dist"] == repo_dist
                ):
                    if not repo_comps:
                        return sub
                    for comp in repo_comps:
                        if comp in sub.get("comps", []):
                            return sub
    return {}
def del_repo(repo, **kwargs):
    is_ppa = False
    if repo.startswith("ppa:") and __grains__["os"] in ("Ubuntu", "Mint", "neon"):
        is_ppa = True
        dist = __grains__["lsb_distrib_codename"]
        if not HAS_SOFTWAREPROPERTIES:
            _warn_software_properties(repo)
            owner_name, ppa_name = repo[4:].split("/")
            if "ppa_auth" in kwargs:
                auth_info = "{}@".format(kwargs["ppa_auth"])
                repo = LP_PVT_SRC_FORMAT.format(auth_info, dist, owner_name, ppa_name)
            else:
                repo = LP_SRC_FORMAT.format(owner_name, ppa_name, dist)
        else:
            if hasattr(softwareproperties.ppa, "PPAShortcutHandler"):
                repo = softwareproperties.ppa.PPAShortcutHandler(repo).expand(dist)[0]
            else:
                repo = softwareproperties.ppa.expand_ppa_line(repo, dist)[0]
    sources = SourcesList()
    repos = [s for s in sources.list if not s.invalid]
    if repos:
        deleted_from = dict()
        try:
            (
                repo_type,
                repo_architectures,
                repo_uri,
                repo_dist,
                repo_comps,
            ) = _split_repo_str(repo)
        except SyntaxError:
            raise SaltInvocationError(
                "Error: repo '{}' not a well formatted definition".format(repo)
            )
        for source in repos:
            if (
                source.type == repo_type
                and source.architectures == repo_architectures
                and source.uri == repo_uri
                and source.dist == repo_dist
            ):
                s_comps = set(source.comps)
                r_comps = set(repo_comps)
                if s_comps.intersection(r_comps):
                    deleted_from[source.file] = 0
                    source.comps = list(s_comps.difference(r_comps))
                    if not source.comps:
                        try:
                            sources.remove(source)
                        except ValueError:
                            pass
            if (
                is_ppa
                and repo_type == "deb"
                and source.type == "deb-src"
                and source.uri == repo_uri
                and source.dist == repo_dist
            ):
                s_comps = set(source.comps)
                r_comps = set(repo_comps)
                if s_comps.intersection(r_comps):
                    deleted_from[source.file] = 0
                    source.comps = list(s_comps.difference(r_comps))
                    if not source.comps:
                        try:
                            sources.remove(source)
                        except ValueError:
                            pass
            sources.save()
        if deleted_from:
            ret = ""
            for source in sources:
                if source.file in deleted_from:
                    deleted_from[source.file] += 1
            for repo_file, count in deleted_from.items():
                msg = "Repo '{0}' has been removed from {1}.\n"
                if count == 0 and "sources.list.d/" in repo_file:
                    if os.path.isfile(repo_file):
                        msg = "File {1} containing repo '{0}' has been removed."
                        try:
                            os.remove(repo_file)
                        except OSError:
                            pass
                ret += msg.format(repo, repo_file)
            refresh_db()
            return ret
    raise CommandExecutionError(
        "Repo {} doesn't exist in the sources.list(s)".format(repo)
    )
def _convert_if_int(value):
    try:
        value = int(str(value))
    except ValueError:
        pass
    return value
def get_repo_keys():
    ret = dict()
    repo_keys = list()
    cmd = [
        "apt-key",
        "adv",
        "--batch",
        "--list-public-keys",
        "--with-fingerprint",
        "--with-fingerprint",
        "--with-colons",
        "--fixed-list-mode",
    ]
    cmd_ret = _call_apt(cmd, scope=False)
    if cmd_ret["retcode"] != 0:
        log.error(cmd_ret["stderr"])
        return ret
    lines = [line for line in cmd_ret["stdout"].splitlines() if line.strip()]
    for line in lines:
        items = [
            _convert_if_int(item.strip()) if item.strip() else None
            for item in line.split(":")
        ]
        key_props = dict()
        if len(items) &lt; 2:
            log.debug("Skipping line: %s", line)
            continue
        if items[0] in ("pub", "sub"):
            key_props.update(
                {
                    "algorithm": items[3],
                    "bits": items[2],
                    "capability": items[11],
                    "date_creation": items[5],
                    "date_expiration": items[6],
                    "keyid": items[4],
                    "validity": items[1],
                }
            )
            if items[0] == "pub":
                repo_keys.append(key_props)
            else:
                repo_keys[-1]["subkey"] = key_props
        elif items[0] == "fpr":
            if repo_keys[-1].get("subkey", False):
                repo_keys[-1]["subkey"].update({"fingerprint": items[9]})
            else:
                repo_keys[-1].update({"fingerprint": items[9]})
        elif items[0] == "uid":
            repo_keys[-1].update({"uid": items[9], "uid_hash": items[7]})
    for repo_key in repo_keys:
        ret[repo_key["keyid"]] = repo_key
    return ret
def add_repo_key(path=None, text=None, keyserver=None, keyid=None, saltenv="base"):
    cmd = ["apt-key"]
    kwargs = {}
    current_repo_keys = get_repo_keys()
    if path:
        cached_source_path = __salt__["cp.cache_file"](path, saltenv)
        if not cached_source_path:
<a name="0"></a>            log.error("Unable to get cached copy of file: %s", path)
            return False
        cmd<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.extend(["add", cached_source_path])
    elif text:
        log.debug("Received value: %s", text)
        cmd.extend(["add", "-"])
        kwargs.update({"stdin": text})
    elif keyserver:
        if</b></font> not keyid:
            error_msg = "No keyid or keyid too short for keyserver: {}".format(
                keyserver
            )
            raise SaltInvocationError(error_msg)
        cmd.extend(["adv", "--batch", "--keyserver", keyserver, "--recv", keyid])
    elif keyid:
        error_msg = "No keyserver specified for keyid: {}".format(keyid)
        raise SaltInvocationError(error_msg)
    else:
        raise TypeError(
            "{}() takes at least 1 argument (0 given)".format(add_repo_key.__name__)
        )
    if keyid:
        for current_keyid in current_repo_keys:
            if current_keyid[-(len(keyid)) :] == keyid:
                log.debug("The keyid '%s' already present: %s", keyid, current_keyid)
                return True
    cmd_ret = _call_apt(cmd, **kwargs)
    if cmd_ret["retcode"] == 0:
        return True
    log.error("Unable to add repo key: %s", cmd_ret["stderr"])
    return False
def del_repo_key(name=None, **kwargs):
    if kwargs.get("keyid_ppa", False):
        if isinstance(name, str) and name.startswith("ppa:"):
            owner_name, ppa_name = name[4:].split("/")
            ppa_info = _get_ppa_info_from_launchpad(owner_name, ppa_name)
            keyid = ppa_info["signing_key_fingerprint"][-8:]
        else:
            raise SaltInvocationError("keyid_ppa requires that a PPA be passed")
    else:
        if "keyid" in kwargs:
            keyid = kwargs.get("keyid")
        else:
            raise SaltInvocationError("keyid or keyid_ppa and PPA name must be passed")
    result = _call_apt(["apt-key", "del", keyid], scope=False)
    if result["retcode"] != 0:
        msg = "Failed to remove keyid {0}"
        if result["stderr"]:
            msg += ": {}".format(result["stderr"])
        raise CommandExecutionError(msg)
    return keyid
def mod_repo(repo, saltenv="base", **kwargs):
    if "refresh_db" in kwargs:
        refresh = kwargs["refresh_db"]
    else:
        refresh = kwargs.get("refresh", True)
    if repo.startswith("ppa:"):
        if __grains__["os"] in ("Ubuntu", "Mint", "neon"):
            if salt.utils.path.which("apt-add-repository") and "ppa_auth" not in kwargs:
                repo_info = get_repo(repo)
                if repo_info:
                    return {repo: repo_info}
                else:
                    env = None
                    http_proxy_url = _get_http_proxy_url()
                    if http_proxy_url:
                        env = {
                            "http_proxy": http_proxy_url,
                            "https_proxy": http_proxy_url,
                        }
                    if float(__grains__["osrelease"]) &lt; 12.04:
                        cmd = ["apt-add-repository", repo]
                    else:
                        cmd = ["apt-add-repository", "-y", repo]
                    out = _call_apt(cmd, env=env, scope=False, **kwargs)
                    if out["retcode"]:
                        raise CommandExecutionError(
                            "Unable to add PPA '{}'. '{}' exited with "
                            "status {!s}: '{}' ".format(
                                repo[4:], cmd, out["retcode"], out["stderr"]
                            )
                        )
                    if refresh:
                        refresh_db()
                    return {repo: out}
            else:
                if not HAS_SOFTWAREPROPERTIES:
                    _warn_software_properties(repo)
                else:
                    log.info("Falling back to urllib method for private PPA")
                try:
                    owner_name, ppa_name = repo[4:].split("/", 1)
                except ValueError:
                    raise CommandExecutionError(
                        "Unable to get PPA info from argument. "
                        'Expected format "&lt;PPA_OWNER&gt;/&lt;PPA_NAME&gt;" '
                        "(e.g. saltstack/salt) not found.  Received "
                        "'{}' instead.".format(repo[4:])
                    )
                dist = __grains__["lsb_distrib_codename"]
                kwargs["dist"] = dist
                ppa_auth = ""
                if "file" not in kwargs:
                    filename = "/etc/apt/sources.list.d/{0}-{1}-{2}.list"
                    kwargs["file"] = filename.format(owner_name, ppa_name, dist)
                try:
                    launchpad_ppa_info = _get_ppa_info_from_launchpad(
                        owner_name, ppa_name
                    )
                    if "ppa_auth" not in kwargs:
                        kwargs["keyid"] = launchpad_ppa_info["signing_key_fingerprint"]
                    else:
                        if "keyid" not in kwargs:
                            error_str = (
                                "Private PPAs require a keyid to be specified: {0}/{1}"
                            )
                            raise CommandExecutionError(
                                error_str.format(owner_name, ppa_name)
                            )
                except HTTPError as exc:
                    raise CommandExecutionError(
                        "Launchpad does not know about {}/{}: {}".format(
                            owner_name, ppa_name, exc
                        )
                    )
                except IndexError as exc:
                    raise CommandExecutionError(
                        "Launchpad knows about {}/{} but did not "
                        "return a fingerprint. Please set keyid "
                        "manually: {}".format(owner_name, ppa_name, exc)
                    )
                if "keyserver" not in kwargs:
                    kwargs["keyserver"] = "keyserver.ubuntu.com"
                if "ppa_auth" in kwargs:
                    if not launchpad_ppa_info["private"]:
                        raise CommandExecutionError(
                            "PPA is not private but auth credentials passed: {}".format(
                                repo
                            )
                        )
                if "ppa_auth" in kwargs:
                    ppa_auth = "{}@".format(kwargs["ppa_auth"])
                    repo = LP_PVT_SRC_FORMAT.format(
                        ppa_auth, owner_name, ppa_name, dist
                    )
                else:
                    repo = LP_SRC_FORMAT.format(owner_name, ppa_name, dist)
        else:
            raise CommandExecutionError(
                'cannot parse "ppa:" style repo definitions: {}'.format(repo)
            )
    sources = SourcesList()
    if kwargs.get("consolidate", False):
        sources = _consolidate_repo_sources(sources)
    repos = [s for s in sources if not s.invalid]
    mod_source = None
    try:
        (
            repo_type,
            repo_architectures,
            repo_uri,
            repo_dist,
            repo_comps,
        ) = _split_repo_str(repo)
    except SyntaxError:
        raise SyntaxError(
            "Error: repo '{}' not a well formatted definition".format(repo)
        )
    full_comp_list = {comp.strip() for comp in repo_comps}
    no_proxy = __salt__["config.option"]("no_proxy")
    if "keyid" in kwargs:
        keyid = kwargs.pop("keyid", None)
        keyserver = kwargs.pop("keyserver", None)
        if not keyid or not keyserver:
            error_str = "both keyserver and keyid options required."
            raise NameError(error_str)
        if not isinstance(keyid, list):
            keyid = [keyid]
        for key in keyid:
            if isinstance(
                key, int
            ):  # yaml can make this an int, we need the hex version
                key = hex(key)
            cmd = ["apt-key", "export", key]
            output = __salt__["cmd.run_stdout"](cmd, python_shell=False, **kwargs)
            imported = output.startswith("-----BEGIN PGP")
            if keyserver:
                if not imported:
                    http_proxy_url = _get_http_proxy_url()
                    if http_proxy_url and keyserver not in no_proxy:
                        cmd = [
                            "apt-key",
                            "adv",
                            "--batch",
                            "--keyserver-options",
                            "http-proxy={}".format(http_proxy_url),
                            "--keyserver",
                            keyserver,
                            "--logger-fd",
                            "1",
                            "--recv-keys",
                            key,
                        ]
                    else:
                        cmd = [
                            "apt-key",
                            "adv",
                            "--batch",
                            "--keyserver",
                            keyserver,
                            "--logger-fd",
                            "1",
                            "--recv-keys",
                            key,
                        ]
                    ret = _call_apt(cmd, scope=False, **kwargs)
                    if ret["retcode"] != 0:
                        raise CommandExecutionError(
                            "Error: key retrieval failed: {}".format(ret["stdout"])
                        )
    elif "key_url" in kwargs:
        key_url = kwargs["key_url"]
        fn_ = __salt__["cp.cache_file"](key_url, saltenv)
        if not fn_:
            raise CommandExecutionError("Error: file not found: {}".format(key_url))
        cmd = ["apt-key", "add", fn_]
        out = __salt__["cmd.run_stdout"](cmd, python_shell=False, **kwargs)
        if not out.upper().startswith("OK"):
            raise CommandExecutionError(
                "Error: failed to add key from {}".format(key_url)
            )
    elif "key_text" in kwargs:
        key_text = kwargs["key_text"]
        cmd = ["apt-key", "add", "-"]
        out = __salt__["cmd.run_stdout"](
            cmd, stdin=key_text, python_shell=False, **kwargs
        )
        if not out.upper().startswith("OK"):
            raise CommandExecutionError(
                "Error: failed to add key:\n{}".format(key_text)
            )
    if "comps" in kwargs:
        kwargs["comps"] = [comp.strip() for comp in kwargs["comps"].split(",")]
        full_comp_list |= set(kwargs["comps"])
    else:
        kwargs["comps"] = list(full_comp_list)
    if "architectures" in kwargs:
        kwargs["architectures"] = kwargs["architectures"].split(",")
    else:
        kwargs["architectures"] = repo_architectures
    if "disabled" in kwargs:
        kwargs["disabled"] = salt.utils.data.is_true(kwargs["disabled"])
    elif "enabled" in kwargs:
        kwargs["disabled"] = not salt.utils.data.is_true(kwargs["enabled"])
    kw_type = kwargs.get("type")
    kw_dist = kwargs.get("dist")
    for source in repos:
        repo_matches = (
            source.type == repo_type
            and source.uri.rstrip("/") == repo_uri.rstrip("/")
            and source.dist == repo_dist
        )
        kw_matches = source.dist == kw_dist and source.type == kw_type
        if repo_matches or kw_matches:
            for comp in full_comp_list:
                if comp in getattr(source, "comps", []):
                    mod_source = source
            if not source.comps:
                mod_source = source
            if kwargs["architectures"] != source.architectures:
                mod_source = source
            if mod_source:
                break
    if "comments" in kwargs:
        kwargs["comments"] = salt.utils.pkg.deb.combine_comments(kwargs["comments"])
    if not mod_source:
        mod_source = SourceEntry(repo)
        if "comments" in kwargs:
            mod_source.comment = kwargs["comments"]
        sources.list.append(mod_source)
    elif "comments" in kwargs:
        mod_source.comment = kwargs["comments"]
    for key in kwargs:
        if key in _MODIFY_OK and hasattr(mod_source, key):
            setattr(mod_source, key, kwargs[key])
    sources.save()
    if refresh:
        refresh_db()
    return {
        repo: {
            "architectures": getattr(mod_source, "architectures", []),
            "comps": mod_source.comps,
            "disabled": mod_source.disabled,
            "file": mod_source.file,
            "type": mod_source.type,
            "uri": mod_source.uri,
            "line": mod_source.line,
        }
    }
def file_list(*packages, **kwargs):
    return __salt__["lowpkg.file_list"](*packages)
def file_dict(*packages, **kwargs):
    return __salt__["lowpkg.file_dict"](*packages)
def expand_repo_def(**kwargs):
    if "repo" not in kwargs:
        raise SaltInvocationError("missing 'repo' argument")
    sanitized = {}
    repo = kwargs["repo"]
    if repo.startswith("ppa:") and __grains__["os"] in ("Ubuntu", "Mint", "neon"):
        dist = __grains__["lsb_distrib_codename"]
        owner_name, ppa_name = repo[4:].split("/", 1)
        if "ppa_auth" in kwargs:
            auth_info = "{}@".format(kwargs["ppa_auth"])
            repo = LP_PVT_SRC_FORMAT.format(auth_info, owner_name, ppa_name, dist)
        else:
            if HAS_SOFTWAREPROPERTIES:
                if hasattr(softwareproperties.ppa, "PPAShortcutHandler"):
                    repo = softwareproperties.ppa.PPAShortcutHandler(repo).expand(dist)[
                        0
                    ]
                else:
                    repo = softwareproperties.ppa.expand_ppa_line(repo, dist)[0]
            else:
                repo = LP_SRC_FORMAT.format(owner_name, ppa_name, dist)
        if "file" not in kwargs:
            filename = "/etc/apt/sources.list.d/{0}-{1}-{2}.list"
            kwargs["file"] = filename.format(owner_name, ppa_name, dist)
    source_entry = SourceEntry(repo)
    for list_args in ("architectures", "comps"):
        if list_args in kwargs:
            kwargs[list_args] = [
                kwarg.strip() for kwarg in kwargs[list_args].split(",")
            ]
    for kwarg in _MODIFY_OK:
        if kwarg in kwargs:
            setattr(source_entry, kwarg, kwargs[kwarg])
    source_list = SourcesList()
    source_entry = source_list.add(
        type=source_entry.type,
        uri=source_entry.uri,
        dist=source_entry.dist,
        orig_comps=getattr(source_entry, "comps", []),
        architectures=getattr(source_entry, "architectures", []),
    )
    sanitized["file"] = source_entry.file
    sanitized["comps"] = getattr(source_entry, "comps", [])
    sanitized["disabled"] = source_entry.disabled
    sanitized["dist"] = source_entry.dist
    sanitized["type"] = source_entry.type
    sanitized["uri"] = source_entry.uri
    sanitized["line"] = source_entry.line.strip()
    sanitized["architectures"] = getattr(source_entry, "architectures", [])
    return sanitized
def _parse_selections(dpkgselection):
    ret = {}
    if isinstance(dpkgselection, str):
        dpkgselection = dpkgselection.split("\n")
    for line in dpkgselection:
        if line:
            _pkg, _state = line.split()
            if _state in ret:
                ret[_state].append(_pkg)
            else:
                ret[_state] = [_pkg]
    return ret
def get_selections(pattern=None, state=None):
    ret = {}
    cmd = ["dpkg", "--get-selections"]
    cmd.append(pattern if pattern else "*")
    stdout = __salt__["cmd.run_stdout"](
        cmd, output_loglevel="trace", python_shell=False
    )
    ret = _parse_selections(stdout)
    if state:
        return {state: ret.get(state, [])}
    return ret
def set_selections(path=None, selection=None, clear=False, saltenv="base"):
    ret = {}
    if not path and not selection:
        return ret
    if path and selection:
        err = (
            "The 'selection' and 'path' arguments to "
            "pkg.set_selections are mutually exclusive, and cannot be "
            "specified together"
        )
        raise SaltInvocationError(err)
    if isinstance(selection, str):
        try:
            selection = salt.utils.yaml.safe_load(selection)
        except (
            salt.utils.yaml.parser.ParserError,
            salt.utils.yaml.scanner.ScannerError,
        ) as exc:
            raise SaltInvocationError("Improperly-formatted selection: {}".format(exc))
    if path:
        path = __salt__["cp.cache_file"](path, saltenv)
        with salt.utils.files.fopen(path, "r") as ifile:
            content = [salt.utils.stringutils.to_unicode(x) for x in ifile.readlines()]
        selection = _parse_selections(content)
    if selection:
        valid_states = ("install", "hold", "deinstall", "purge")
        bad_states = [x for x in selection if x not in valid_states]
        if bad_states:
            raise SaltInvocationError(
                "Invalid state(s): {}".format(", ".join(bad_states))
            )
        if clear:
            cmd = ["dpkg", "--clear-selections"]
            if not __opts__["test"]:
                result = _call_apt(cmd, scope=False)
                if result["retcode"] != 0:
                    err = "Running dpkg --clear-selections failed: {}".format(
                        result["stderr"]
                    )
                    log.error(err)
                    raise CommandExecutionError(err)
        sel_revmap = {}
        for _state, _pkgs in get_selections().items():
            sel_revmap.update({_pkg: _state for _pkg in _pkgs})
        for _state, _pkgs in selection.items():
            for _pkg in _pkgs:
                if _state == sel_revmap.get(_pkg):
                    continue
                cmd = ["dpkg", "--set-selections"]
                cmd_in = "{} {}".format(_pkg, _state)
                if not __opts__["test"]:
                    result = _call_apt(cmd, scope=False, stdin=cmd_in)
                    if result["retcode"] != 0:
                        log.error("failed to set state %s for package %s", _state, _pkg)
                    else:
                        ret[_pkg] = {"old": sel_revmap.get(_pkg), "new": _state}
    return ret
def _resolve_deps(name, pkgs, **kwargs):
    missing_deps = []
    for pkg_file in pkgs:
        deb = apt.debfile.DebPackage(filename=pkg_file, cache=apt.Cache())
        if deb.check():
            missing_deps.extend(deb.missing_deps)
    if missing_deps:
        cmd = ["apt-get", "-q", "-y"]
        cmd = cmd + ["-o", "DPkg::Options::=--force-confold"]
        cmd = cmd + ["-o", "DPkg::Options::=--force-confdef"]
        cmd.append("install")
        cmd.extend(missing_deps)
        ret = __salt__["cmd.retcode"](cmd, env=kwargs.get("env"), python_shell=False)
        if ret != 0:
            raise CommandExecutionError(
                "Error: unable to resolve dependencies for: {}".format(name)
            )
        else:
            try:
                cmd = ["apt-mark", "auto"] + missing_deps
                __salt__["cmd.run"](cmd, env=kwargs.get("env"), python_shell=False)
            except MinionError as exc:
                raise CommandExecutionError(exc)
    return
def owner(*paths, **kwargs):
    if not paths:
        return ""
    ret = {}
    for path in paths:
        cmd = ["dpkg", "-S", path]
        output = __salt__["cmd.run_stdout"](
            cmd, output_loglevel="trace", python_shell=False
        )
        ret[path] = output.split(":")[0]
        if "no path found" in ret[path].lower():
            ret[path] = ""
    if len(ret) == 1:
        return next(iter(ret.values()))
    return ret
def show(*names, **kwargs):
    kwargs = salt.utils.args.clean_kwargs(**kwargs)
    refresh = kwargs.pop("refresh", False)
    filter_ = salt.utils.args.split_input(
        kwargs.pop("filter", []),
        lambda x: str(x) if not isinstance(x, str) else x.lower(),
    )
    if kwargs:
        salt.utils.args.invalid_kwargs(kwargs)
    if refresh:
        refresh_db()
    if not names:
        return {}
    result = _call_apt(["apt-cache", "show"] + list(names), scope=False)
    def _add(ret, pkginfo):
        name = pkginfo.pop("Package", None)
        version = pkginfo.pop("Version", None)
        if name is not None and version is not None:
            ret.setdefault(name, {}).setdefault(version, {}).update(pkginfo)
    def _check_filter(key):
        key = key.lower()
        return True if key in ("package", "version") or not filter_ else key in filter_
    ret = {}
    pkginfo = {}
    for line in salt.utils.itertools.split(result["stdout"], "\n"):
        line = line.strip()
        if line:
            try:
                key, val = (x.strip() for x in line.split(":", 1))
            except ValueError:
                pass
            else:
                if _check_filter(key):
                    pkginfo[key] = val
        else:
            _add(ret, pkginfo)
            pkginfo = {}
            continue
    _add(ret, pkginfo)
    return ret
def info_installed(*names, **kwargs):
    kwargs = salt.utils.args.clean_kwargs(**kwargs)
    failhard = kwargs.pop("failhard", True)
    if kwargs:
        salt.utils.args.invalid_kwargs(kwargs)
    ret = dict()
    for pkg_name, pkg_nfo in __salt__["lowpkg.info"](*names, failhard=failhard).items():
        t_nfo = dict()
        if pkg_nfo.get("status", "ii")[1] != "i":
            continue  # return only packages that are really installed
        for key, value in pkg_nfo.items():
            if key == "package":
                t_nfo["name"] = value
            elif key == "origin":
                t_nfo["vendor"] = value
            elif key == "section":
                t_nfo["group"] = value
            elif key == "maintainer":
                t_nfo["packager"] = value
            elif key == "homepage":
                t_nfo["url"] = value
            elif key == "status":
                continue  # only installed pkgs are returned, no need for status
            else:
                t_nfo[key] = value
        ret[pkg_name] = t_nfo
    return ret
def _get_http_proxy_url():
    http_proxy_url = ""
    host = __salt__["config.option"]("proxy_host")
    port = __salt__["config.option"]("proxy_port")
    username = __salt__["config.option"]("proxy_username")
    password = __salt__["config.option"]("proxy_password")
    if host and port:
        if username and password:
            http_proxy_url = "http://{}:{}@{}:{}".format(username, password, host, port)
        else:
            http_proxy_url = "http://{}:{}".format(host, port)
    return http_proxy_url
def list_downloaded(root=None, **kwargs):
    CACHE_DIR = "/var/cache/apt"
    if root:
        CACHE_DIR = os.path.join(root, os.path.relpath(CACHE_DIR, os.path.sep))
    ret = {}
    for root, dirnames, filenames in salt.utils.path.os_walk(CACHE_DIR):
        for filename in fnmatch.filter(filenames, "*.deb"):
            package_path = os.path.join(root, filename)
            pkg_info = __salt__["lowpkg.bin_pkg_info"](package_path)
            pkg_timestamp = int(os.path.getctime(package_path))
            ret.setdefault(pkg_info["name"], {})[pkg_info["version"]] = {
                "path": package_path,
                "size": os.path.getsize(package_path),
                "creation_date_time_t": pkg_timestamp,
                "creation_date_time": datetime.datetime.utcfromtimestamp(
                    pkg_timestamp
                ).isoformat(),
            }
    return ret
def services_need_restart(**kwargs):
    if not salt.utils.path.which_bin(["checkrestart"]):
        raise CommandNotFoundError(
            "'checkrestart' is needed. It is part of the 'debian-goodies' "
            "package which can be installed from official repositories."
        )
    cmd = ["checkrestart", "--machine", "--package"]
    services = set()
    cr_output = __salt__["cmd.run_stdout"](cmd, python_shell=False)
    for line in cr_output.split("\n"):
        if not line.startswith("SERVICE:"):
            continue
        end_of_name = line.find(",")
        service = line[8:end_of_name]  # skip "SERVICE:"
        services.add(service)
    return list(services)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>kiwiproc.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import os
import platform
import socket
from xml.dom import minidom
import salt.utils.files
from salt.modules.inspectlib.exceptions import InspectorKiwiProcessorException
try:
    import grp
    import pwd
except ImportError:
    pass
try:
    from lxml import etree
except ImportError:
    import xml.etree.ElementTree as etree
class KiwiExporter:
    def __init__(self, grains, format):
        self.__grains__ = grains
        self.format = format
        self._data = type("data", (), {})
        self.name = None
    def load(self, **descr):
        for obj, data in descr.items():
            setattr(self._data, obj, data)
        return self
    def export(self, name):
        self.name = name
        root = self._create_doc()
        self._set_description(root)
        self._set_preferences(root)
        self._set_repositories(root)
        self._set_users(root)
        self._set_packages(root)
<a name="1"></a>
        return "\n".join(
            [
                <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>line
                for line in minidom.parseString(etree.tostring(root, encoding="UTF-8"))
                .toprettyxml(indent="  ")
                .split("\n")
                if line.</b></font>strip()
            ]
        )
    def _get_package_manager(self):
        ret = None
        if self.__grains__.get("os_family") in ("Kali", "Debian"):
            ret = "apt-get"
        elif self.__grains__.get("os_family", "") == "Suse":
            ret = "zypper"
        elif self.__grains__.get("os_family", "") == "redhat":
            ret = "yum"
        if ret is None:
            raise InspectorKiwiProcessorException(
                "Unsupported platform: {}".format(self.__grains__.get("os_family"))
            )
        return ret
    def _set_preferences(self, node):
        pref = etree.SubElement(node, "preferences")
        pacman = etree.SubElement(pref, "packagemanager")
        pacman.text = self._get_package_manager()
        p_version = etree.SubElement(pref, "version")
        p_version.text = "0.0.1"
        p_type = etree.SubElement(pref, "type")
        p_type.set("image", "vmx")
        for disk_id, disk_data in self._data.system.get("disks", {}).items():
            if disk_id.startswith("/dev"):
                p_type.set("filesystem", disk_data.get("type") or "ext3")
                break
        p_type.set("installiso", "true")
        p_type.set("boot", "vmxboot/suse-leap42.1")
        p_type.set("format", self.format)
        p_type.set("bootloader", "grub2")
        p_type.set("timezone", __salt__["timezone.get_zone"]())
        p_type.set("hwclock", __salt__["timezone.get_hwclock"]())
        return pref
    def _get_user_groups(self, user):
        return [g.gr_name for g in grp.getgrall() if user in g.gr_mem] + [
            grp.getgrgid(pwd.getpwnam(user).pw_gid).gr_name
        ]
    def _set_users(self, node):
        shadow = {}
        with salt.utils.files.fopen("/etc/shadow") as rfh:
            for sh_line in rfh.read().split(os.linesep):
                if sh_line.strip():
                    login, pwd = sh_line.split(":")[:2]
                    if pwd and pwd[0] not in "!*":
                        shadow[login] = {"p": pwd}
        with salt.utils.files.fopen("/etc/passwd") as rfh:
            for ps_line in rfh.read().split(os.linesep):
                if ps_line.strip():
                    ps_line = ps_line.strip().split(":")
                    if ps_line[0] in shadow:
                        shadow[ps_line[0]]["h"] = ps_line[5]
                        shadow[ps_line[0]]["s"] = ps_line[6]
                        shadow[ps_line[0]]["g"] = self._get_user_groups(ps_line[0])
        users_groups = []
        users_node = etree.SubElement(node, "users")
        for u_name, u_data in shadow.items():
            user_node = etree.SubElement(users_node, "user")
            user_node.set("password", u_data["p"])
            user_node.set("home", u_data["h"])
            user_node.set("name", u_name)
            users_groups.extend(u_data["g"])
        users_node.set("group", ",".join(users_groups))
        return users_node
    def _set_repositories(self, node):
        priority = 99
        for repo_id, repo_data in self._data.software.get("repositories", {}).items():
            if type(repo_data) == list:
                repo_data = repo_data[0]
            if repo_data.get("enabled") or not repo_data.get(
                "disabled"
            ):  # RPM and Debian, respectively
                uri = repo_data.get("baseurl", repo_data.get("uri"))
<a name="0"></a>                if not uri:
                    continue
                repo = etree.SubElement(node, "repository")
                if self.__grains__<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.get("os_family") in ("Kali", "Debian"):
                    repo.set("alias", repo_id)
                    repo.set("distribution", repo_data["dist"])
                else:
                    repo.set("alias", repo_data["alias"])
                    if</b></font> self.__grains__.get("os_family", "") == "Suse":
                        repo.set("type", "yast2")  # TODO: Check for options!
                    repo.set("priority", str(priority))
                source = etree.SubElement(repo, "source")
                source.set("path", uri)  # RPM and Debian, respectively
                priority -= 1
    def _set_packages(self, node):
        pkgs = etree.SubElement(node, "packages")
        for pkg_name, pkg_version in sorted(
            self._data.software.get("packages", {}).items()
        ):
            pkg = etree.SubElement(pkgs, "package")
            pkg.set("name", pkg_name)
        if self.__grains__.get("os_family", "") == "Suse":
            for ptn_id, ptn_data in self._data.software.get("patterns", {}).items():
                if ptn_data.get("installed"):
                    ptn = etree.SubElement(pkgs, "namedCollection")
                    ptn.set("name", ptn_id)
        return pkgs
    def _set_description(self, node):
        hostname = socket.getfqdn() or platform.node()
        descr = etree.SubElement(node, "description")
        author = etree.SubElement(descr, "author")
        author.text = "salt.modules.node on {}".format(hostname)
        contact = etree.SubElement(descr, "contact")
        contact.text = "root@{}".format(hostname)
        specs = etree.SubElement(descr, "specification")
        specs.text = "Rebuild of {}, based on Salt inspection.".format(hostname)
        return descr
    def _create_doc(self):
        root = etree.Element("image")
        root.set("schemaversion", "6.3")
        root.set("name", self.name)
        return root
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
