<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for alternatives.py &amp; vt.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for alternatives.py &amp; vt.py
      </h3>
<h1 align="center">
        1.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>alternatives.py (5.3333335%)<th>vt.py (1.0676156%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(148-153)<td><a href="#" name="0">(490-494)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>alternatives.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 __func_alias__ = {"set_": "set"}
2 def __virtual__():
3     if "alternatives.auto" in __salt__:
4         return True
5     return (False, "alernatives module could not be loaded")
6 def install(name, link, path, priority):
7     ret = {
8         "name": name,
9         "link": link,
10         "path": path,
11         "priority": priority,
12         "result": True,
13         "changes": {},
14         "comment": "",
15     }
16     if __salt__["alternatives.check_exists"](name, path):
17         ret["comment"] = "Alternative {} for {} is already registered".format(
18             path, name
19         )
20     else:
21         if __opts__["test"]:
22             ret[
23                 "comment"
24             ] = "Alternative will be set for {} to {} with priority {}".format(
25                 name, path, priority
26             )
27             ret["result"] = None
28             return ret
29         out = __salt__["alternatives.install"](name, link, path, priority)
30         if __salt__["alternatives.check_exists"](name, path):
31             if __salt__["alternatives.check_installed"](name, path):
32                 ret[
33                     "comment"
34                 ] = "Alternative for {} set to path {} with priority {}".format(
35                     name, path, priority
36                 )
37             else:
38                 ret["comment"] = (
39                     "Alternative {} for {} registered with priority {} and "
40                     "not set to default".format(path, name, priority)
41                 )
42             ret["changes"] = {
43                 "name": name,
44                 "link": link,
45                 "path": path,
46                 "priority": priority,
47             }
48         else:
49             ret["result"] = False
50             ret["comment"] = "Alternative for {} not installed: {}".format(name, out)
51     return ret
52 def remove(name, path):
53     ret = {"name": name, "path": path, "result": True, "changes": {}, "comment": ""}
54     isinstalled = __salt__["alternatives.check_exists"](name, path)
55     if isinstalled:
56         if __opts__["test"]:
57             ret["comment"] = "Alternative for {} will be removed".format(name)
58             ret["result"] = None
59             return ret
60         __salt__["alternatives.remove"](name, path)
61         current = __salt__["alternatives.show_current"](name)
62         if current:
63             ret["result"] = True
64             ret[
65                 "comment"
66             ] = "Alternative for {} removed. Falling back to path {}".format(
67                 name, current
68             )
69             ret["changes"] = {"path": current}
70             return ret
71 <a name="0"></a>
72         ret["comment"] = "Alternative for {} removed".format(name)
73         ret["changes"] = {}
74         <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return ret
75     current = __salt__["alternatives.show_current"](name)
76     if current:
77         ret["result"] = True
78         ret["comment"] = "Alternative for {} is set to it's default path {}".format(</b></font>
79             name, current
80         )
81         return ret
82     ret["result"] = False
83     ret["comment"] = "Alternative for {} doesn't exist".format(name)
84     return ret
85 def auto(name):
86     ret = {"name": name, "result": True, "comment": "", "changes": {}}
87     display = __salt__["alternatives.display"](name)
88     line = display.splitlines()[0]
89     if line.endswith(" auto mode"):
90         ret["comment"] = "{} already in auto mode".format(name)
91         return ret
92     if __opts__["test"]:
93         ret["comment"] = "{} will be put in auto mode".format(name)
94         ret["result"] = None
95         return ret
96     ret["changes"]["result"] = __salt__["alternatives.auto"](name)
97     return ret
98 def set_(name, path):
99     ret = {"name": name, "path": path, "result": True, "changes": {}, "comment": ""}
100     current = __salt__["alternatives.show_current"](name)
101     if current == path:
102         ret["comment"] = "Alternative for {} already set to {}".format(name, path)
103         return ret
104     display = __salt__["alternatives.display"](name)
105     isinstalled = False
106     for line in display.splitlines():
107         if line.startswith(path):
108             isinstalled = True
109             break
110     if isinstalled:
111         if __opts__["test"]:
112             ret["comment"] = "Alternative for {} will be set to path {}".format(
113                 name, path
114             )
115             ret["result"] = None
116             return ret
117         __salt__["alternatives.set"](name, path)
118         current = __salt__["alternatives.show_current"](name)
119         if current == path:
120             ret["comment"] = "Alternative for {} set to path {}".format(name, current)
121             ret["changes"] = {"path": current}
122         else:
123             ret["comment"] = "Alternative for {} not updated".format(name)
124         return ret
125     else:
126         ret["result"] = False
127         ret["comment"] = "Alternative {} for {} doesn't exist".format(path, name)
128     return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>vt.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import errno
2 import functools
3 import logging
4 import os
5 import select
6 import signal
7 import subprocess
8 import sys
9 import time
10 import salt.utils.crypt
11 import salt.utils.data
12 import salt.utils.stringutils
13 from salt.log.setup import LOG_LEVELS
14 mswindows = sys.platform == "win32"
15 try:
16     from win32file import ReadFile, WriteFile
17     from win32pipe import PeekNamedPipe
18     import msvcrt
19     import win32api
20     import win32con
21     import win32process
22 except ImportError:
23     import pty
24     import fcntl
25     import struct
26     import termios
27 log = logging.getLogger(__name__)
28 class TerminalException(Exception):
29 def setwinsize(child, rows=80, cols=80):
30     TIOCSWINSZ = getattr(termios, "TIOCSWINSZ", -2146929561)
31     if TIOCSWINSZ == 2148037735:
32         TIOCSWINSZ = -2146929561
33     packed = struct.pack(b"HHHH", rows, cols, 0, 0)
34     fcntl.ioctl(child, TIOCSWINSZ, packed)
35 def getwinsize(child):
36     TIOCGWINSZ = getattr(termios, "TIOCGWINSZ", 1074295912)
37     packed = struct.pack(b"HHHH", 0, 0, 0, 0)
38     ioctl = fcntl.ioctl(child, TIOCGWINSZ, packed)
39     return struct.unpack(b"HHHH", ioctl)[0:2]
40 class Terminal:
41     def __init__(
42         self,
43         args=None,
44         executable=None,
45         shell=False,
46         cwd=None,
47         env=None,
48         preexec_fn=None,
49         rows=None,
50         cols=None,
51         log_stdin=None,
52         log_stdin_level="debug",
53         log_stdout=None,
54         log_stdout_level="debug",
55         log_stderr=None,
56         log_stderr_level="debug",
57         stream_stdout=None,
58         stream_stderr=None,
59         force_receive_encoding=__salt_system_encoding__,
60     ):
61         if not args and not executable:
62             raise TerminalException(
63                 'You need to pass at least one of "args", "executable" '
64             )
65         self.args = args
66         self.executable = executable
67         self.shell = shell
68         self.cwd = cwd
69         self.env = env
70         self.preexec_fn = preexec_fn
71         self.receive_encoding = force_receive_encoding
72         if rows is None and cols is None:
73             rows, cols = self.__detect_parent_terminal_size()
74         elif rows is not None and cols is None:
75             _, cols = self.__detect_parent_terminal_size()
76         elif rows is None and cols is not None:
77             rows, _ = self.__detect_parent_terminal_size()
78         self.rows = rows
79         self.cols = cols
80         self.pid = None
81         self.stdin = None
82         self.stdout = None
83         self.stderr = None
84         self.child_fd = None
85         self.child_fde = None
86         self.partial_data_stdout = b""
87         self.partial_data_stderr = b""
88         self.closed = True
89         self.flag_eof_stdout = False
90         self.flag_eof_stderr = False
91         self.terminated = True
92         self.exitstatus = None
93         self.signalstatus = None
94         self.status = None
95         if stream_stdout is True:
96             self.stream_stdout = sys.stdout
97         elif stream_stdout is False:
98             self.stream_stdout = None
99         elif stream_stdout is not None:
100             if (
101                 not hasattr(stream_stdout, "write")
102                 or not hasattr(stream_stdout, "flush")
103                 or not hasattr(stream_stdout, "close")
104             ):
105                 raise TerminalException(
106                     "'stream_stdout' needs to have at least 3 methods, "
107                     "'write()', 'flush()' and 'close()'."
108                 )
109             self.stream_stdout = stream_stdout
110         else:
111             raise TerminalException(
112                 "Don't know how to handle '{}' as the VT's "
113                 "'stream_stdout' parameter.".format(stream_stdout)
114             )
115         if stream_stderr is True:
116             self.stream_stderr = sys.stderr
117         elif stream_stderr is False:
118             self.stream_stderr = None
119         elif stream_stderr is not None:
120             if (
121                 not hasattr(stream_stderr, "write")
122                 or not hasattr(stream_stderr, "flush")
123                 or not hasattr(stream_stderr, "close")
124             ):
125                 raise TerminalException(
126                     "'stream_stderr' needs to have at least 3 methods, "
127                     "'write()', 'flush()' and 'close()'."
128                 )
129             self.stream_stderr = stream_stderr
130         else:
131             raise TerminalException(
132                 "Don't know how to handle '{}' as the VT's "
133                 "'stream_stderr' parameter.".format(stream_stderr)
134             )
135         try:
136             self._spawn()
137         except Exception as err:  # pylint: disable=W0703
138             log.warning(
139                 "Failed to spawn the VT: %s", err, exc_info_on_loglevel=logging.DEBUG
140             )
141             raise TerminalException("Failed to spawn the VT. Error: {}".format(err))
142         log.debug(
143             "Child Forked! PID: %s  STDOUT_FD: %s  STDERR_FD: %s",
144             self.pid,
145             self.child_fd,
146             self.child_fde,
147         )
148         terminal_command = " ".join(self.args)
149         if (
150             'decode("base64")' in terminal_command
151             or "base64.b64decode(" in terminal_command
152         ):
153             log.debug("VT: Salt-SSH SHIM Terminal Command executed. Logged to TRACE")
154             log.trace("Terminal Command: %s", terminal_command)
155         else:
156             log.debug("Terminal Command: %s", terminal_command)
157         self.stdin_logger_level = LOG_LEVELS.get(log_stdin_level, log_stdin_level)
158         if log_stdin is True:
159             self.stdin_logger = logging.getLogger(
160                 "{}.{}.PID-{}.STDIN".format(__name__, self.__class__.__name__, self.pid)
161             )
162         elif log_stdin is not None:
163             if not isinstance(log_stdin, logging.Logger):
164                 raise RuntimeError("'log_stdin' needs to subclass `logging.Logger`")
165             self.stdin_logger = log_stdin
166         else:
167             self.stdin_logger = None
168         self.stdout_logger_level = LOG_LEVELS.get(log_stdout_level, log_stdout_level)
169         if log_stdout is True:
170             self.stdout_logger = logging.getLogger(
171                 "{}.{}.PID-{}.STDOUT".format(
172                     __name__, self.__class__.__name__, self.pid
173                 )
174             )
175         elif log_stdout is not None:
176             if not isinstance(log_stdout, logging.Logger):
177                 raise RuntimeError("'log_stdout' needs to subclass `logging.Logger`")
178             self.stdout_logger = log_stdout
179         else:
180             self.stdout_logger = None
181         self.stderr_logger_level = LOG_LEVELS.get(log_stderr_level, log_stderr_level)
182         if log_stderr is True:
183             self.stderr_logger = logging.getLogger(
184                 "{}.{}.PID-{}.STDERR".format(
185                     __name__, self.__class__.__name__, self.pid
186                 )
187             )
188         elif log_stderr is not None:
189             if not isinstance(log_stderr, logging.Logger):
190                 raise RuntimeError("'log_stderr' needs to subclass `logging.Logger`")
191             self.stderr_logger = log_stderr
192         else:
193             self.stderr_logger = None
194     def send(self, data):
195         return self._send(data)
196     def sendline(self, data, linesep=os.linesep):
197         return self.send("{}{}".format(data, linesep))
198     def recv(self, maxsize=None):
199         if maxsize is None:
200             maxsize = 1024
201         elif maxsize &lt; 1:
202             maxsize = 1
203         return self._recv(maxsize)
204     def close(self, terminate=True, kill=False):
205         if not self.closed:
206             if self.child_fd is not None:
207                 os.close(self.child_fd)
208                 self.child_fd = None
209             if self.child_fde is not None:
210                 os.close(self.child_fde)
211                 self.child_fde = None
212             time.sleep(0.1)
213             if terminate:
214                 if not self.terminate(kill):
215                     raise TerminalException("Failed to terminate child process.")
216             self.closed = True
217     @property
218     def has_unread_data(self):
219         return self.flag_eof_stderr is False or self.flag_eof_stdout is False
220     def _translate_newlines(self, data):
221         if data is None or not data:
222             return
223         return data.replace("\r\n", os.linesep)
224     def __enter__(self):
225         return self
226     def __exit__(self, exc_type, exc_value, traceback):
227         self.close(terminate=True, kill=True)
228         if self.isalive():
229             self.wait()
230     if mswindows:
231         def _execute(self):
232             raise NotImplementedError
233         def _spawn(self):
234             raise NotImplementedError
235         def _recv(self, maxsize):
236             raise NotImplementedError
237         def _send(self, data):
238             raise NotImplementedError
239         def send_signal(self, sig):
240             if sig == signal.SIGTERM:
241                 self.terminate()
242             elif sig == signal.CTRL_C_EVENT:
243                 os.kill(self.pid, signal.CTRL_C_EVENT)
244             elif sig == signal.CTRL_BREAK_EVENT:
245                 os.kill(self.pid, signal.CTRL_BREAK_EVENT)
246             else:
247                 raise ValueError("Unsupported signal: {}".format(sig))
248         def terminate(self, force=False):
249             try:
250                 win32api.TerminateProcess(self._handle, 1)
251             except OSError:
252                 ecode = win32process.GetExitCodeProcess(self._handle)
253                 if ecode == win32con.STILL_ACTIVE:
254                     raise
255                 self.exitstatus = ecode
256         kill = terminate
257     else:
258         def _spawn(self):
259             if not isinstance(self.args, str) and self.shell is True:
260                 self.args = " ".join(self.args)
261             parent, child = pty.openpty()
262             err_parent, err_child = os.pipe()
263             child_name = os.ttyname(child)
264             proc = subprocess.Popen(  # pylint: disable=subprocess-popen-preexec-fn
265                 self.args,
266                 preexec_fn=functools.partial(
267                     self._preexec, child_name, self.rows, self.cols, self.preexec_fn
268                 ),
269                 shell=self.shell,  # nosec
270                 executable=self.executable,
271                 cwd=self.cwd,
272                 stdin=child,
273                 stdout=child,
274                 stderr=err_child,
275                 env=self.env,
276                 close_fds=True,
277             )
278             os.close(child)
279             os.close(err_child)
280             self.child_fd = parent
281             self.child_fde = err_parent
282             self.pid = proc.pid
283             self.proc = proc
284             self.closed = False
285             self.terminated = False
286         @staticmethod
287         def _preexec(child_name, rows=80, cols=80, preexec_fn=None):
288             try:
289                 tty_fd = os.open("/dev/tty", os.O_RDWR | os.O_NOCTTY)
290                 if tty_fd &gt;= 0:
291                     os.close(tty_fd)
292             except Exception:  # pylint: disable=broad-except
293                 pass
294             try:
295                 os.setsid()
296             except OSError:
297                 pass
298             try:
299                 tty_fd = os.open("/dev/tty", os.O_RDWR | os.O_NOCTTY)
300                 if tty_fd &gt;= 0:
301                     os.close(tty_fd)
302                     raise TerminalException(
303                         "Could not open child pty, {}".format(child_name)
304                     )
305             except Exception:  # pylint: disable=broad-except
306                 pass
307             tty_fd = os.open(child_name, os.O_RDWR)
308             setwinsize(tty_fd, rows, cols)
309             if tty_fd &lt; 0:
310                 raise TerminalException(
311                     "Could not open child pty, {}".format(child_name)
312                 )
313             else:
314                 os.close(tty_fd)
315             if os.name != "posix":
316                 tty_fd = os.open("/dev/tty", os.O_WRONLY)
317                 if tty_fd &lt; 0:
318                     raise TerminalException("Could not open controlling tty, /dev/tty")
319                 else:
320                     os.close(tty_fd)
321             salt.utils.crypt.reinit_crypto()
322             if preexec_fn is not None:
323                 preexec_fn()
324         def _send(self, data):
325             if self.child_fd is None:
326                 return None
327             if not select.select([], [self.child_fd], [], 0)[1]:
328                 return 0
329             try:
330                 if self.stdin_logger:
331                     self.stdin_logger.log(self.stdin_logger_level, data)
332                 written = os.write(self.child_fd, data.encode(__salt_system_encoding__))
333             except OSError as why:
334                 if why.errno == errno.EPIPE:  # broken pipe
335                     os.close(self.child_fd)
336                     self.child_fd = None
337                     return
338                 raise
339             return written
340         def _recv(self, maxsize):
341             rfds = []
342             if self.child_fd:
343                 rfds.append(self.child_fd)
344             if self.child_fde:
345                 rfds.append(self.child_fde)
346 <a name="0"></a>            if not self.isalive():
347                 if not rfds:
348                     self.close()
349                     <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return None, None
350                 rlist, _, _ = select.select(rfds, [], [], 0)
351                 if not rlist:
352                     self.flag_eof_stdout = self.flag_eof_stderr = True
353                     log.debug(</b></font>"End of file(EOL). Brain-dead platform.")
354                     if self.partial_data_stdout or self.partial_data_stderr:
355                         self.close()
356                         return (
357                             salt.utils.stringutils.to_unicode(self.partial_data_stdout),
358                             salt.utils.stringutils.to_unicode(self.partial_data_stderr),
359                         )
360                     self.close()
361                     return None, None
362             stderr = ""
363             stdout = ""
364             if self.child_fd:
365                 fd_flags = fcntl.fcntl(self.child_fd, fcntl.F_GETFL)
366             if self.child_fde:
367                 fde_flags = fcntl.fcntl(self.child_fde, fcntl.F_GETFL)
368             if self.child_fd:
369                 fcntl.fcntl(self.child_fd, fcntl.F_SETFL, fd_flags | os.O_NONBLOCK)
370             if self.child_fde:
371                 fcntl.fcntl(self.child_fde, fcntl.F_SETFL, fde_flags | os.O_NONBLOCK)
372             rlist, _, _ = select.select(rfds, [], [], 0)
373             if not rlist:
374                 if not self.isalive():
375                     self.flag_eof_stdout = self.flag_eof_stderr = True
376                     log.debug("End of file(EOL). Very slow platform.")
377                     return None, None
378             def read_and_decode_fd(fd, maxsize, partial_data_attr=None):
379                 bytes_read = getattr(self, partial_data_attr, b"")
380                 bytes_read += os.read(fd, maxsize if not bytes_read else 1)
381                 try:
382                     decoded_data = self._translate_newlines(
383                         salt.utils.stringutils.to_unicode(
384                             bytes_read, self.receive_encoding
385                         )
386                     )
387                     if partial_data_attr is not None:
388                         setattr(self, partial_data_attr, b"")
389                     return decoded_data, False
390                 except UnicodeDecodeError as ex:
391                     max_multibyte_character_length = 4
392                     if ex.start &gt; (
393                         len(bytes_read) - max_multibyte_character_length
394                     ) and ex.end == len(bytes_read):
395                         if partial_data_attr is not None:
396                             setattr(self, partial_data_attr, bytes_read)
397                         else:
398                             raise
399                         return "", True
400                     else:
401                         raise
402             if self.child_fde in rlist and not self.flag_eof_stderr:
403                 try:
404                     stderr, partial_data = read_and_decode_fd(
405                         self.child_fde, maxsize, "partial_data_stderr"
406                     )
407                     if not stderr and not partial_data:
408                         self.flag_eof_stderr = True
409                         stderr = None
410                     else:
411                         if self.stream_stderr:
412                             self.stream_stderr.write(stderr)
413                             self.stream_stderr.flush()
414                         if self.stderr_logger:
415                             stripped = stderr.rstrip()
416                             if stripped.startswith(os.linesep):
417                                 stripped = stripped[len(os.linesep) :]
418                             if stripped:
419                                 self.stderr_logger.log(
420                                     self.stderr_logger_level, stripped
421                                 )
422                 except OSError:
423                     os.close(self.child_fde)
424                     self.child_fde = None
425                     self.flag_eof_stderr = True
426                     stderr = None
427                 finally:
428                     if self.child_fde is not None:
429                         fcntl.fcntl(self.child_fde, fcntl.F_SETFL, fde_flags)
430             if self.child_fd in rlist and not self.flag_eof_stdout:
431                 try:
432                     stdout, partial_data = read_and_decode_fd(
433                         self.child_fd, maxsize, "partial_data_stdout"
434                     )
435                     if not stdout and not partial_data:
436                         self.flag_eof_stdout = True
437                         stdout = None
438                     else:
439                         if self.stream_stdout:
440                             self.stream_stdout.write(
441                                 salt.utils.stringutils.to_str(stdout)
442                             )
443                             self.stream_stdout.flush()
444                         if self.stdout_logger:
445                             stripped = stdout.rstrip()
446                             if stripped.startswith(os.linesep):
447                                 stripped = stripped[len(os.linesep) :]
448                             if stripped:
449                                 self.stdout_logger.log(
450                                     self.stdout_logger_level, stripped
451                                 )
452                 except OSError:
453                     os.close(self.child_fd)
454                     self.child_fd = None
455                     self.flag_eof_stdout = True
456                     stdout = None
457                 finally:
458                     if self.child_fd is not None:
459                         fcntl.fcntl(self.child_fd, fcntl.F_SETFL, fd_flags)
460             return stdout, stderr
461         def __detect_parent_terminal_size(self):
462             try:
463                 TIOCGWINSZ = getattr(termios, "TIOCGWINSZ", 1074295912)
464                 packed = struct.pack(b"HHHH", 0, 0, 0, 0)
465                 ioctl = fcntl.ioctl(sys.stdin.fileno(), TIOCGWINSZ, packed)
466                 return struct.unpack(b"HHHH", ioctl)[0:2]
467             except OSError:
468                 return 24, 80
469         def getwinsize(self):
470             if self.child_fd is None:
471                 raise TerminalException(
472                     "Can't check the size of the terminal since we're not "
473                     "connected to the child process."
474                 )
475             return getwinsize(self.child_fd)
476         def setwinsize(self, child, rows=80, cols=80):
477             setwinsize(self.child_fd, rows, cols)
478         def isalive(
479             self,
480             _waitpid=os.waitpid,
481             _wnohang=os.WNOHANG,
482             _wifexited=os.WIFEXITED,
483             _wexitstatus=os.WEXITSTATUS,
484             _wifsignaled=os.WIFSIGNALED,
485             _wifstopped=os.WIFSTOPPED,
486             _wtermsig=os.WTERMSIG,
487             _os_error=os.error,
488             _errno_echild=errno.ECHILD,
489             _terminal_exception=TerminalException,
490         ):
491             if self.terminated:
492                 return False
493             if self.has_unread_data is False:
494                 waitpid_options = 0
495             else:
496                 waitpid_options = _wnohang
497             try:
498                 pid, status = _waitpid(self.pid, waitpid_options)
499             except ChildProcessError:
500                 polled = self.proc.poll()
501                 if polled is None:
502                     return True
503                 pid = self.pid
504                 status = polled
505             except _os_error:
506                 err = sys.exc_info()[1]
507                 if err.errno == _errno_echild:
508                     raise _terminal_exception(
509                         'isalive() encountered condition where "terminated" '
510                         "is 0, but there was no child process. Did someone "
511                         "else call waitpid() on our process?"
512                     )
513                 else:
514                     raise
515             if pid == 0:
516                 try:
517                     pid, status = _waitpid(self.pid, waitpid_options)
518                 except _os_error as exc:
519                     if exc.errno == _errno_echild:
520                         raise _terminal_exception(
521                             "isalive() encountered condition that should "
522                             "never happen. There was no child process. Did "
523                             "someone else call waitpid() on our process?"
524                         )
525                     else:
526                         raise
527                 if pid == 0:
528                     return True
529             if pid == 0:
530                 return True
531             if _wifexited(status):
532                 self.status = status
533                 self.exitstatus = _wexitstatus(status)
534                 self.signalstatus = None
535                 self.terminated = True
536             elif _wifsignaled(status):
537                 self.status = status
538                 self.exitstatus = None
539                 self.signalstatus = _wtermsig(status)
540                 self.terminated = True
541             elif _wifstopped(status):
542                 raise _terminal_exception(
543                     "isalive() encountered condition where child process is "
544                     "stopped. This is not supported. Is some other process "
545                     "attempting job control with our child pid?"
546                 )
547             return False
548         def terminate(self, force=False):
549             if not self.closed:
550                 self.close(terminate=False)
551             if not self.isalive():
552                 return True
553             try:
554                 self.send_signal(signal.SIGHUP)
555                 time.sleep(0.1)
556                 if not self.isalive():
557                     return True
558                 self.send_signal(signal.SIGCONT)
559                 time.sleep(0.1)
560                 if not self.isalive():
561                     return True
562                 self.send_signal(signal.SIGINT)
563                 time.sleep(0.1)
564                 if not self.isalive():
565                     return True
566                 if force:
567                     self.send_signal(signal.SIGKILL)
568                     time.sleep(0.1)
569                     if not self.isalive():
570                         return True
571                     else:
572                         return False
573                 return False
574             except OSError:
575                 time.sleep(0.1)
576                 if not self.isalive():
577                     return True
578                 else:
579                     return False
580         def wait(self):
581             if self.isalive():
582                 while self.isalive():
583                     stdout, stderr = self.recv()
584                     if stdout is None:
585                         break
586                     if stderr is None:
587                         break
588             else:
589                 raise TerminalException("Cannot wait for dead child process.")
590             return self.exitstatus
591         def send_signal(self, sig):
592             os.kill(self.pid, sig)
593         def kill(self):
594             self.send_signal(signal.SIGKILL)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
