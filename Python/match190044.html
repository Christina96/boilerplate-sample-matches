<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for alternatives.py &amp; vt.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for alternatives.py &amp; vt.py
      </h3>
<h1 align="center">
        1.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>alternatives.py (5.3333335%)<th>vt.py (1.0676156%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(148-153)<td><a href="#" name="0">(490-494)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>alternatives.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 __func_alias__ = {"set_": "set"}
2 def __virtual__():
3     if "alternatives.auto" in __salt__:
4         return True
5     return (False, "alernatives module could not be loaded")
6 def install(name, link, path, priority):
7     ret = {
8         "name": name,
9         "link": link,
10         "path": path,
11         "priority": priority,
12         "result": True,
13         "changes": {},
14         "comment": "",
15     }
16     if __salt__["alternatives.check_exists"](name, path):
17         ret["comment"] = "Alternative {} for {} is already registered".format(
18             path, name
19         )
20     else:
21         if __opts__["test"]:
22             ret[
23                 "comment"
24             ] = "Alternative will be set for {} to {} with priority {}".format(
25                 name, path, priority
26             )
27             ret["result"] = None
28             return ret
29         out = __salt__["alternatives.install"](name, link, path, priority)
30         if __salt__["alternatives.check_exists"](name, path):
31             if __salt__["alternatives.check_installed"](name, path):
32                 ret[
33                     "comment"
34                 ] = "Alternative for {} set to path {} with priority {}".format(
35                     name, path, priority
36                 )
37             else:
38                 ret["comment"] = (
39                     "Alternative {} for {} registered with priority {} and "
40                     "not set to default".format(path, name, priority)
41                 )
42             ret["changes"] = {
43                 "name": name,
44                 "link": link,
45                 "path": path,
46                 "priority": priority,
47             }
48         else:
49             ret["result"] = False
50             ret["comment"] = "Alternative for {} not installed: {}".format(name, out)
51     return ret
52 def remove(name, path):
53     ret = {"name": name, "path": path, "result": True, "changes": {}, "comment": ""}
54     isinstalled = __salt__["alternatives.check_exists"](name, path)
55     if isinstalled:
56         if __opts__["test"]:
57             ret["comment"] = "Alternative for {} will be removed".format(name)
58             ret["result"] = None
59             return ret
60         __salt__["alternatives.remove"](name, path)
61         current = __salt__["alternatives.show_current"](name)
62         if current:
63             ret["result"] = True
64             ret[
65                 "comment"
66             ] = "Alternative for {} removed. Falling back to path {}".format(
67                 name, current
68             )
69             ret["changes"] = {"path": current}
70             return ret
71         ret["comment"] = "Alternative for {} removed".format(name)
72         ret["changes"] = {}
73         <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return ret
74     current = __salt__["alternatives.show_current"](name)
75     if current:
76         ret["result"] = True
77         ret["comment"] = "Alternative for {} is set to it's default path {}".format(</b></font>
78             name, current
79         )
80         return ret
81     ret["result"] = False
82     ret["comment"] = "Alternative for {} doesn't exist".format(name)
83     return ret
84 def auto(name):
85     ret = {"name": name, "result": True, "comment": "", "changes": {}}
86     display = __salt__["alternatives.display"](name)
87     line = display.splitlines()[0]
88     if line.endswith(" auto mode"):
89         ret["comment"] = "{} already in auto mode".format(name)
90         return ret
91     if __opts__["test"]:
92         ret["comment"] = "{} will be put in auto mode".format(name)
93         ret["result"] = None
94         return ret
95     ret["changes"]["result"] = __salt__["alternatives.auto"](name)
96     return ret
97 def set_(name, path):
98     ret = {"name": name, "path": path, "result": True, "changes": {}, "comment": ""}
99     current = __salt__["alternatives.show_current"](name)
100     if current == path:
101         ret["comment"] = "Alternative for {} already set to {}".format(name, path)
102         return ret
103     display = __salt__["alternatives.display"](name)
104     isinstalled = False
105     for line in display.splitlines():
106         if line.startswith(path):
107             isinstalled = True
108             break
109     if isinstalled:
110         if __opts__["test"]:
111             ret["comment"] = "Alternative for {} will be set to path {}".format(
112                 name, path
113             )
114             ret["result"] = None
115             return ret
116         __salt__["alternatives.set"](name, path)
117         current = __salt__["alternatives.show_current"](name)
118         if current == path:
119             ret["comment"] = "Alternative for {} set to path {}".format(name, current)
120             ret["changes"] = {"path": current}
121         else:
122             ret["comment"] = "Alternative for {} not updated".format(name)
123         return ret
124     else:
125         ret["result"] = False
126         ret["comment"] = "Alternative {} for {} doesn't exist".format(path, name)
127     return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>vt.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import errno
2 import functools
3 import logging
4 import os
5 import select
6 import signal
7 import subprocess
8 import sys
9 import time
10 import salt.utils.crypt
11 import salt.utils.data
12 import salt.utils.stringutils
13 from salt.log.setup import LOG_LEVELS
14 mswindows = sys.platform == "win32"
15 try:
16     from win32file import ReadFile, WriteFile
17     from win32pipe import PeekNamedPipe
18     import msvcrt
19     import win32api
20     import win32con
21     import win32process
22 except ImportError:
23     import pty
24     import fcntl
25     import struct
26     import termios
27 log = logging.getLogger(__name__)
28 class TerminalException(Exception):
29 def setwinsize(child, rows=80, cols=80):
30     TIOCSWINSZ = getattr(termios, "TIOCSWINSZ", -2146929561)
31     if TIOCSWINSZ == 2148037735:
32         TIOCSWINSZ = -2146929561
33     packed = struct.pack(b"HHHH", rows, cols, 0, 0)
34     fcntl.ioctl(child, TIOCSWINSZ, packed)
35 def getwinsize(child):
36     TIOCGWINSZ = getattr(termios, "TIOCGWINSZ", 1074295912)
37     packed = struct.pack(b"HHHH", 0, 0, 0, 0)
38     ioctl = fcntl.ioctl(child, TIOCGWINSZ, packed)
39     return struct.unpack(b"HHHH", ioctl)[0:2]
40 class Terminal:
41     def __init__(
42         self,
43         args=None,
44         executable=None,
45         shell=False,
46         cwd=None,
47         env=None,
48         preexec_fn=None,
49         rows=None,
50         cols=None,
51         log_stdin=None,
52         log_stdin_level="debug",
53         log_stdout=None,
54         log_stdout_level="debug",
55         log_stderr=None,
56         log_stderr_level="debug",
57         stream_stdout=None,
58         stream_stderr=None,
59         force_receive_encoding=__salt_system_encoding__,
60     ):
61         if not args and not executable:
62             raise TerminalException(
63                 'You need to pass at least one of "args", "executable" '
64             )
65         self.args = args
66         self.executable = executable
67         self.shell = shell
68         self.cwd = cwd
69         self.env = env
70         self.preexec_fn = preexec_fn
71         self.receive_encoding = force_receive_encoding
72         if rows is None and cols is None:
73             rows, cols = self.__detect_parent_terminal_size()
74         elif rows is not None and cols is None:
75             _, cols = self.__detect_parent_terminal_size()
76         elif rows is None and cols is not None:
77             rows, _ = self.__detect_parent_terminal_size()
78         self.rows = rows
79         self.cols = cols
80         self.pid = None
81         self.stdin = None
82         self.stdout = None
83         self.stderr = None
84         self.child_fd = None
85         self.child_fde = None
86         self.partial_data_stdout = b""
87         self.partial_data_stderr = b""
88         self.closed = True
89         self.flag_eof_stdout = False
90         self.flag_eof_stderr = False
91         self.terminated = True
92         self.exitstatus = None
93         self.signalstatus = None
94         self.status = None
95         if stream_stdout is True:
96             self.stream_stdout = sys.stdout
97         elif stream_stdout is False:
98             self.stream_stdout = None
99         elif stream_stdout is not None:
100             if (
101                 not hasattr(stream_stdout, "write")
102                 or not hasattr(stream_stdout, "flush")
103                 or not hasattr(stream_stdout, "close")
104             ):
105                 raise TerminalException(
106                     "'stream_stdout' needs to have at least 3 methods, "
107                     "'write()', 'flush()' and 'close()'."
108                 )
109             self.stream_stdout = stream_stdout
110         else:
111             raise TerminalException(
112                 "Don't know how to handle '{}' as the VT's "
113                 "'stream_stdout' parameter.".format(stream_stdout)
114             )
115         if stream_stderr is True:
116             self.stream_stderr = sys.stderr
117         elif stream_stderr is False:
118             self.stream_stderr = None
119         elif stream_stderr is not None:
120             if (
121                 not hasattr(stream_stderr, "write")
122                 or not hasattr(stream_stderr, "flush")
123                 or not hasattr(stream_stderr, "close")
124             ):
125                 raise TerminalException(
126                     "'stream_stderr' needs to have at least 3 methods, "
127                     "'write()', 'flush()' and 'close()'."
128                 )
129             self.stream_stderr = stream_stderr
130         else:
131             raise TerminalException(
132                 "Don't know how to handle '{}' as the VT's "
133                 "'stream_stderr' parameter.".format(stream_stderr)
134             )
135         try:
136             self._spawn()
137         except Exception as err:  # pylint: disable=W0703
138             log.warning(
139                 "Failed to spawn the VT: %s", err, exc_info_on_loglevel=logging.DEBUG
140             )
141             raise TerminalException("Failed to spawn the VT. Error: {}".format(err))
142         log.debug(
143             "Child Forked! PID: %s  STDOUT_FD: %s  STDERR_FD: %s",
144             self.pid,
145             self.child_fd,
146             self.child_fde,
147         )
148         terminal_command = " ".join(self.args)
149         if (
150             'decode("base64")' in terminal_command
151             or "base64.b64decode(" in terminal_command
152         ):
153             log.debug("VT: Salt-SSH SHIM Terminal Command executed. Logged to TRACE")
154             log.trace("Terminal Command: %s", terminal_command)
155         else:
156             log.debug("Terminal Command: %s", terminal_command)
157         self.stdin_logger_level = LOG_LEVELS.get(log_stdin_level, log_stdin_level)
158         if log_stdin is True:
159             self.stdin_logger = logging.getLogger(
160                 "{}.{}.PID-{}.STDIN".format(__name__, self.__class__.__name__, self.pid)
161             )
162         elif log_stdin is not None:
163             if not isinstance(log_stdin, logging.Logger):
164                 raise RuntimeError("'log_stdin' needs to subclass `logging.Logger`")
165             self.stdin_logger = log_stdin
166         else:
167             self.stdin_logger = None
168         self.stdout_logger_level = LOG_LEVELS.get(log_stdout_level, log_stdout_level)
169         if log_stdout is True:
170             self.stdout_logger = logging.getLogger(
171                 "{}.{}.PID-{}.STDOUT".format(
172                     __name__, self.__class__.__name__, self.pid
173                 )
174             )
175         elif log_stdout is not None:
176             if not isinstance(log_stdout, logging.Logger):
177                 raise RuntimeError("'log_stdout' needs to subclass `logging.Logger`")
178             self.stdout_logger = log_stdout
179         else:
180             self.stdout_logger = None
181         self.stderr_logger_level = LOG_LEVELS.get(log_stderr_level, log_stderr_level)
182         if log_stderr is True:
183             self.stderr_logger = logging.getLogger(
184                 "{}.{}.PID-{}.STDERR".format(
185                     __name__, self.__class__.__name__, self.pid
186                 )
187             )
188         elif log_stderr is not None:
189             if not isinstance(log_stderr, logging.Logger):
190                 raise RuntimeError("'log_stderr' needs to subclass `logging.Logger`")
191             self.stderr_logger = log_stderr
192         else:
193             self.stderr_logger = None
194     def send(self, data):
195         return self._send(data)
196     def sendline(self, data, linesep=os.linesep):
197         return self.send("{}{}".format(data, linesep))
198     def recv(self, maxsize=None):
199         if maxsize is None:
200             maxsize = 1024
201         elif maxsize &lt; 1:
202             maxsize = 1
203         return self._recv(maxsize)
204     def close(self, terminate=True, kill=False):
205         if not self.closed:
206             if self.child_fd is not None:
207                 os.close(self.child_fd)
208                 self.child_fd = None
209             if self.child_fde is not None:
210                 os.close(self.child_fde)
211                 self.child_fde = None
212             time.sleep(0.1)
213             if terminate:
214                 if not self.terminate(kill):
215                     raise TerminalException("Failed to terminate child process.")
216             self.closed = True
217     @property
218     def has_unread_data(self):
219         return self.flag_eof_stderr is False or self.flag_eof_stdout is False
220     def _translate_newlines(self, data):
221         if data is None or not data:
222             return
223         return data.replace("\r\n", os.linesep)
224     def __enter__(self):
225         return self
226     def __exit__(self, exc_type, exc_value, traceback):
227         self.close(terminate=True, kill=True)
228         if self.isalive():
229             self.wait()
230     if mswindows:
231         def _execute(self):
232             raise NotImplementedError
233         def _spawn(self):
234             raise NotImplementedError
235         def _recv(self, maxsize):
236             raise NotImplementedError
237         def _send(self, data):
238             raise NotImplementedError
239         def send_signal(self, sig):
240             if sig == signal.SIGTERM:
241                 self.terminate()
242             elif sig == signal.CTRL_C_EVENT:
243                 os.kill(self.pid, signal.CTRL_C_EVENT)
244             elif sig == signal.CTRL_BREAK_EVENT:
245                 os.kill(self.pid, signal.CTRL_BREAK_EVENT)
246             else:
247                 raise ValueError("Unsupported signal: {}".format(sig))
248         def terminate(self, force=False):
249             try:
250                 win32api.TerminateProcess(self._handle, 1)
251             except OSError:
252                 ecode = win32process.GetExitCodeProcess(self._handle)
253                 if ecode == win32con.STILL_ACTIVE:
254                     raise
255                 self.exitstatus = ecode
256         kill = terminate
257     else:
258         def _spawn(self):
259             if not isinstance(self.args, str) and self.shell is True:
260                 self.args = " ".join(self.args)
261             parent, child = pty.openpty()
262             err_parent, err_child = os.pipe()
263             child_name = os.ttyname(child)
264             proc = subprocess.Popen(  # pylint: disable=subprocess-popen-preexec-fn
265                 self.args,
266                 preexec_fn=functools.partial(
267                     self._preexec, child_name, self.rows, self.cols, self.preexec_fn
268                 ),
269                 shell=self.shell,  # nosec
270                 executable=self.executable,
271                 cwd=self.cwd,
272                 stdin=child,
273                 stdout=child,
274                 stderr=err_child,
275                 env=self.env,
276                 close_fds=True,
277             )
278             os.close(child)
279             os.close(err_child)
280             self.child_fd = parent
281             self.child_fde = err_parent
282             self.pid = proc.pid
283             self.proc = proc
284             self.closed = False
285             self.terminated = False
286         @staticmethod
287         def _preexec(child_name, rows=80, cols=80, preexec_fn=None):
288             try:
289                 tty_fd = os.open("/dev/tty", os.O_RDWR | os.O_NOCTTY)
290                 if tty_fd &gt;= 0:
291                     os.close(tty_fd)
292             except Exception:  # pylint: disable=broad-except
293                 pass
294             try:
295                 os.setsid()
296             except OSError:
297                 pass
298             try:
299                 tty_fd = os.open("/dev/tty", os.O_RDWR | os.O_NOCTTY)
300                 if tty_fd &gt;= 0:
301                     os.close(tty_fd)
302                     raise TerminalException(
303                         "Could not open child pty, {}".format(child_name)
304                     )
305             except Exception:  # pylint: disable=broad-except
306                 pass
307             tty_fd = os.open(child_name, os.O_RDWR)
308             setwinsize(tty_fd, rows, cols)
309             if tty_fd &lt; 0:
310                 raise TerminalException(
311                     "Could not open child pty, {}".format(child_name)
312                 )
313             else:
314                 os.close(tty_fd)
315             if os.name != "posix":
316                 tty_fd = os.open("/dev/tty", os.O_WRONLY)
317                 if tty_fd &lt; 0:
318                     raise TerminalException("Could not open controlling tty, /dev/tty")
319                 else:
320                     os.close(tty_fd)
321             salt.utils.crypt.reinit_crypto()
322             if preexec_fn is not None:
323                 preexec_fn()
324         def _send(self, data):
325             if self.child_fd is None:
326                 return None
327             if not select.select([], [self.child_fd], [], 0)[1]:
328                 return 0
329             try:
330                 if self.stdin_logger:
331                     self.stdin_logger.log(self.stdin_logger_level, data)
332                 written = os.write(self.child_fd, data.encode(__salt_system_encoding__))
333             except OSError as why:
334                 if why.errno == errno.EPIPE:  # broken pipe
335                     os.close(self.child_fd)
336                     self.child_fd = None
337                     return
338                 raise
339             return written
340         def _recv(self, maxsize):
341             rfds = []
342             if self.child_fd:
343                 rfds.append(self.child_fd)
344             if self.child_fde:
345                 rfds.append(self.child_fde)
346                 if not rfds:
347                     self.close()
348                     <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return None, None
349                 rlist, _, _ = select.select(rfds, [], [], 0)
350                 if not rlist:
351                     self.flag_eof_stdout = self.flag_eof_stderr = True
352                     log.debug(</b></font>"End of file(EOL). Brain-dead platform.")
353                     if self.partial_data_stdout or self.partial_data_stderr:
354                         self.close()
355                         return (
356                             salt.utils.stringutils.to_unicode(self.partial_data_stdout),
357                             salt.utils.stringutils.to_unicode(self.partial_data_stderr),
358                         )
359                     self.close()
360                     return None, None
361             stderr = ""
362             stdout = ""
363             if self.child_fd:
364                 fd_flags = fcntl.fcntl(self.child_fd, fcntl.F_GETFL)
365             if self.child_fde:
366                 fde_flags = fcntl.fcntl(self.child_fde, fcntl.F_GETFL)
367             if self.child_fd:
368                 fcntl.fcntl(self.child_fd, fcntl.F_SETFL, fd_flags | os.O_NONBLOCK)
369             if self.child_fde:
370                 fcntl.fcntl(self.child_fde, fcntl.F_SETFL, fde_flags | os.O_NONBLOCK)
371             rlist, _, _ = select.select(rfds, [], [], 0)
372             if not rlist:
373                 if not self.isalive():
374                     self.flag_eof_stdout = self.flag_eof_stderr = True
375                     log.debug("End of file(EOL). Very slow platform.")
376                     return None, None
377             def read_and_decode_fd(fd, maxsize, partial_data_attr=None):
378                 bytes_read = getattr(self, partial_data_attr, b"")
379                 bytes_read += os.read(fd, maxsize if not bytes_read else 1)
380                 try:
381                     decoded_data = self._translate_newlines(
382                         salt.utils.stringutils.to_unicode(
383                             bytes_read, self.receive_encoding
384                         )
385                     )
386                     if partial_data_attr is not None:
387                         setattr(self, partial_data_attr, b"")
388                     return decoded_data, False
389                 except UnicodeDecodeError as ex:
390                     max_multibyte_character_length = 4
391                     if ex.start &gt; (
392                         len(bytes_read) - max_multibyte_character_length
393                     ) and ex.end == len(bytes_read):
394                         if partial_data_attr is not None:
395                             setattr(self, partial_data_attr, bytes_read)
396                         else:
397                             raise
398                         return "", True
399                     else:
400                         raise
401             if self.child_fde in rlist and not self.flag_eof_stderr:
402                 try:
403                     stderr, partial_data = read_and_decode_fd(
404                         self.child_fde, maxsize, "partial_data_stderr"
405                     )
406                     if not stderr and not partial_data:
407                         self.flag_eof_stderr = True
408                         stderr = None
409                     else:
410                         if self.stream_stderr:
411                             self.stream_stderr.write(stderr)
412                             self.stream_stderr.flush()
413                         if self.stderr_logger:
414                             stripped = stderr.rstrip()
415                             if stripped.startswith(os.linesep):
416                                 stripped = stripped[len(os.linesep) :]
417                             if stripped:
418                                 self.stderr_logger.log(
419                                     self.stderr_logger_level, stripped
420                                 )
421                 except OSError:
422                     os.close(self.child_fde)
423                     self.child_fde = None
424                     self.flag_eof_stderr = True
425                     stderr = None
426                 finally:
427                     if self.child_fde is not None:
428                         fcntl.fcntl(self.child_fde, fcntl.F_SETFL, fde_flags)
429             if self.child_fd in rlist and not self.flag_eof_stdout:
430                 try:
431                     stdout, partial_data = read_and_decode_fd(
432                         self.child_fd, maxsize, "partial_data_stdout"
433                     )
434                     if not stdout and not partial_data:
435                         self.flag_eof_stdout = True
436                         stdout = None
437                     else:
438                         if self.stream_stdout:
439                             self.stream_stdout.write(
440                                 salt.utils.stringutils.to_str(stdout)
441                             )
442                             self.stream_stdout.flush()
443                         if self.stdout_logger:
444                             stripped = stdout.rstrip()
445                             if stripped.startswith(os.linesep):
446                                 stripped = stripped[len(os.linesep) :]
447                             if stripped:
448                                 self.stdout_logger.log(
449                                     self.stdout_logger_level, stripped
450                                 )
451                 except OSError:
452                     os.close(self.child_fd)
453                     self.child_fd = None
454                     self.flag_eof_stdout = True
455                     stdout = None
456                 finally:
457                     if self.child_fd is not None:
458                         fcntl.fcntl(self.child_fd, fcntl.F_SETFL, fd_flags)
459             return stdout, stderr
460         def __detect_parent_terminal_size(self):
461             try:
462                 TIOCGWINSZ = getattr(termios, "TIOCGWINSZ", 1074295912)
463                 packed = struct.pack(b"HHHH", 0, 0, 0, 0)
464                 ioctl = fcntl.ioctl(sys.stdin.fileno(), TIOCGWINSZ, packed)
465                 return struct.unpack(b"HHHH", ioctl)[0:2]
466             except OSError:
467                 return 24, 80
468         def getwinsize(self):
469             if self.child_fd is None:
470                 raise TerminalException(
471                     "Can't check the size of the terminal since we're not "
472                     "connected to the child process."
473                 )
474             return getwinsize(self.child_fd)
475         def setwinsize(self, child, rows=80, cols=80):
476             setwinsize(self.child_fd, rows, cols)
477         def isalive(
478             self,
479             _waitpid=os.waitpid,
480             _wnohang=os.WNOHANG,
481             _wifexited=os.WIFEXITED,
482             _wexitstatus=os.WEXITSTATUS,
483             _wifsignaled=os.WIFSIGNALED,
484             _wifstopped=os.WIFSTOPPED,
485             _wtermsig=os.WTERMSIG,
486             _os_error=os.error,
487             _errno_echild=errno.ECHILD,
488             _terminal_exception=TerminalException,
489         ):
490             if self.terminated:
491                 return False
492             if self.has_unread_data is False:
493                 waitpid_options = 0
494             else:
495                 waitpid_options = _wnohang
496             try:
497                 pid, status = _waitpid(self.pid, waitpid_options)
498             except ChildProcessError:
499                 polled = self.proc.poll()
500                 if polled is None:
501                     return True
502                 pid = self.pid
503                 status = polled
504             except _os_error:
505                 err = sys.exc_info()[1]
506                 if err.errno == _errno_echild:
507                     raise _terminal_exception(
508                         'isalive() encountered condition where "terminated" '
509                         "is 0, but there was no child process. Did someone "
510                         "else call waitpid() on our process?"
511                     )
512                 else:
513                     raise
514             if pid == 0:
515                 try:
516                     pid, status = _waitpid(self.pid, waitpid_options)
517                 except _os_error as exc:
518                     if exc.errno == _errno_echild:
519                         raise _terminal_exception(
520                             "isalive() encountered condition that should "
521                             "never happen. There was no child process. Did "
522                             "someone else call waitpid() on our process?"
523                         )
524                     else:
525                         raise
526                 if pid == 0:
527                     return True
528             if pid == 0:
529                 return True
530             if _wifexited(status):
531                 self.status = status
532                 self.exitstatus = _wexitstatus(status)
533                 self.signalstatus = None
534                 self.terminated = True
535             elif _wifsignaled(status):
536                 self.status = status
537                 self.exitstatus = None
538                 self.signalstatus = _wtermsig(status)
539                 self.terminated = True
540             elif _wifstopped(status):
541                 raise _terminal_exception(
542                     "isalive() encountered condition where child process is "
543                     "stopped. This is not supported. Is some other process "
544                     "attempting job control with our child pid?"
545                 )
546             return False
547         def terminate(self, force=False):
548             if not self.closed:
549                 self.close(terminate=False)
550             if not self.isalive():
551                 return True
552             try:
553                 self.send_signal(signal.SIGHUP)
554                 time.sleep(0.1)
555                 if not self.isalive():
556                     return True
557                 self.send_signal(signal.SIGCONT)
558                 time.sleep(0.1)
559                 if not self.isalive():
560                     return True
561                 self.send_signal(signal.SIGINT)
562                 time.sleep(0.1)
563                 if not self.isalive():
564                     return True
565                 if force:
566                     self.send_signal(signal.SIGKILL)
567                     time.sleep(0.1)
568                     if not self.isalive():
569                         return True
570                     else:
571                         return False
572                 return False
573             except OSError:
574                 time.sleep(0.1)
575                 if not self.isalive():
576                     return True
577                 else:
578                     return False
579         def wait(self):
580             if self.isalive():
581                 while self.isalive():
582                     stdout, stderr = self.recv()
583                     if stdout is None:
584                         break
585                     if stderr is None:
586                         break
587             else:
588                 raise TerminalException("Cannot wait for dead child process.")
589             return self.exitstatus
590         def send_signal(self, sig):
591             os.kill(self.pid, sig)
592         def kill(self):
593             self.send_signal(signal.SIGKILL)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
