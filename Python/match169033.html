<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_configparser.py &amp; test_k8s.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_configparser.py &amp; test_k8s.py
      </h3>
<h1 align="center">
        2.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_configparser.py (3.3942559%)<th>test_k8s.py (1.475596%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(73-75)<td><a href="#" name="0">(83-85)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_configparser.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import errno
3 import logging
4 import os
5 import salt.utils.configparser
6 import salt.utils.files
7 import salt.utils.platform
8 import salt.utils.stringutils
9 from tests.support.runtests import RUNTIME_VARS
10 from tests.support.unit import TestCase
11 log = logging.getLogger(__name__)
12 ORIG_CONFIG = """[user]
13         name = Артём Анисимов
14 \temail = foo@bar.com
15 [remote "origin"]
16 \turl = https://github.com/terminalmage/salt.git
17 \tfetch = +refs/heads/*:refs/remotes/origin/*
18 \tpushurl = git@github.com:terminalmage/salt.git
19 [color "diff"]
20 \told = 196
21 \tnew = 39
22 [core]
23 \tpager = less -R
24 \trepositoryformatversion = 0
25 \tfilemode = true
26 \tbare = false
27 \tlogallrefupdates = true
28 [alias]
29 \tmodified = ! git status --porcelain | awk 'match($1, "M"){print $2}'
30 \tgraph = log --all --decorate --oneline --graph
31 \thist = log --pretty=format:\\"%h %ad | %s%d [%an]\\" --graph --date=short
32 [http]
33 \tsslverify = false""".split(
34     "\n"
35 )
36 class TestGitConfigParser(TestCase):
37     maxDiff = None
38     orig_config = os.path.join(RUNTIME_VARS.TMP, "test_gitconfig.orig")
39     new_config = os.path.join(RUNTIME_VARS.TMP, "test_gitconfig.new")
40     remote = 'remote "origin"'
41     def tearDown(self):
42         del self.conf
43         try:
44             os.remove(self.new_config)
45         except OSError as exc:
46             if exc.errno != errno.ENOENT:
47                 raise
48     def setUp(self):
49 <a name="0"></a>        if not os.path.exists(self.orig_config):
50             with salt.utils.files.fopen(self.orig_config, "wb") as fp_:
51                 fp_.write(salt.utils.stringutils.to_bytes(os.linesep.join(ORIG_CONFIG)))
52         self.conf = salt.utils.configparser<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.GitConfigParser()
53         with salt.utils.files.fopen(self.orig_config, "rb") as fp:
54             self.conf._read(fp, self.</b></font>orig_config)
55     @classmethod
56     def tearDownClass(cls):
57         try:
58             os.remove(cls.orig_config)
59         except OSError as exc:
60             if exc.errno != errno.ENOENT:
61                 raise
62     @staticmethod
63     def fix_indent(lines):
64         ret = copy.copy(lines)
65         for i, _ in enumerate(ret):
66             if ret[i].startswith(salt.utils.configparser.GitConfigParser.SPACEINDENT):
67                 ret[i] = ret[i].replace(
68                     salt.utils.configparser.GitConfigParser.SPACEINDENT, "\t"
69                 )
70         return ret
71     @staticmethod
72     def get_lines(path):
73         with salt.utils.files.fopen(path, "rb") as fp_:
74             return salt.utils.stringutils.to_unicode(fp_.read()).splitlines()
75     def _test_write(self, mode):
76         kwargs = {"mode": mode}
77         if salt.utils.platform.is_windows() and "b" not in mode:
78             kwargs["encoding"] = "utf-8"
79         with salt.utils.files.fopen(self.new_config, **kwargs) as fp_:
80             self.conf.write(fp_)
81         self.assertEqual(self.get_lines(self.new_config), self.fix_indent(ORIG_CONFIG))
82     def test_get(self):
83         self.assertEqual(self.conf.get('color "diff"', "old"), "196")
84         self.assertEqual(
85             self.conf.get("alias", "modified"),
86         Test that user.name was successfully loaded despite being indented
87         using spaces instead of a tab. Additionally, this tests that the value
88         was loaded as a unicode type on PY2.
89         Test setting a new option in an existing section
90         Test adding a section and adding an item to that section
91         Test replacing an existing option
92         Test setting a multivar and then writing the resulting file
93         test removing an option, including all items from a multivar
94         test removing an option, including all items from a multivar
95         Test writing using non-binary filehandle
96         Test writing using binary filehandle
97 Unit Tests for the k8s execution module.
98         filename = "/tmp/{}.json"<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.format(name)
99         with salt.utils.files.fopen(filename, "w") as f:
100             salt.utils.json.dump(self.</b></font>request, f)
101         create = Popen(
102             ["kubectl", "--namespace=default", "create", "-f", filename], stdout=PIPE
103         )
104         time.sleep(0.1)
105         res = k8s.get_secrets("default", name, apiserver_url="http://127.0.0.1:8080")
106         a = res.get("metadata", {}).get("name", "a")
107         proc = Popen(
108             ["kubectl", "--namespace=default", "get", "secrets", name, "-o", "json"],
109             stdout=PIPE,
110         )
111         kubectl_out = salt.utils.json.loads(proc.communicate()[0])
112         b = kubectl_out.get("metadata", {}).get("name", "b")
113         self.assertEqual(a, b)
114     def test_get_decoded_secret(self):
115         name = self.name
116         filename = "/tmp/{}.json".format(name)
117         with salt.utils.files.fopen(filename, "w") as f:
118             salt.utils.json.dump(self.request, f)
119         create = Popen(
120             ["kubectl", "--namespace=default", "create", "-f", filename], stdout=PIPE
121         )
122         time.sleep(0.1)
123         res = k8s.get_secrets(
124             "default", name, apiserver_url="http://127.0.0.1:8080", decode=True
125         )
126         a = res.get("data", {}).get(
127             "testsecret",
128         )
129         self.assertEqual(a, "teststring")
130     def test_create_secret(self):
131         name = self.name
132         names = []
133         expected_data = {}
134         for i in range(2):
135             names.append("/tmp/{}-{}".format(name, i))
136             with salt.utils.files.fopen("/tmp/{}-{}".format(name, i), "w") as f:
137                 expected_data["{}-{}".format(name, i)] = base64.b64encode(
138                     "{}{}".format(name, i)
139                 )
140                 f.write(salt.utils.stringutils.to_str("{}{}".format(name, i)))
141         res = k8s.create_secret(
142             "default", name, names, apiserver_url="http://127.0.0.1:8080"
143         )
144         proc = Popen(
145             ["kubectl", "--namespace=default", "get", "secrets", name, "-o", "json"],
146             stdout=PIPE,
147         )
148         kubectl_out = salt.utils.json.loads(proc.communicate()[0])
149         b = kubectl_out.get("data", {})
150         self.assertTrue(isinstance(kubectl_out, dict))
151         self.assertEqual(expected_data, b)
152     def test_update_secret(self):
153         name = self.name
154         filename = "/tmp/{}.json".format(name)
155         with salt.utils.files.fopen(filename, "w") as f:
156             salt.utils.json.dump(self.request, f)
157         create = Popen(
158             ["kubectl", "--namespace=default", "create", "-f", filename], stdout=PIPE
159         )
160         time.sleep(0.1)
161         expected_data = {}
162         names = []
163         for i in range(3):
164             names.append("/tmp/{}-{}-updated".format(name, i))
165             with salt.utils.files.fopen("/tmp/{}-{}-updated".format(name, i), "w") as f:
166                 expected_data["{}-{}-updated".format(name, i)] = base64.b64encode(
167                     "{}{}-updated".format(name, i)
168                 )
169                 f.write("{}{}-updated".format(name, i))
170         res = k8s.update_secret(
171             "default", name, names, apiserver_url="http://127.0.0.1:8080"
172         )
173         proc = Popen(
174             ["kubectl", "--namespace=default", "get", "secrets", name, "-o", "json"],
175             stdout=PIPE,
176         )
177         kubectl_out = salt.utils.json.loads(proc.communicate()[0])
178         b = kubectl_out.get("data", {})
179         self.assertTrue(isinstance(kubectl_out, dict))
180         self.assertEqual(expected_data, b)
181     def test_delete_secret(self):
182         name = self.name
183         filename = "/tmp/{}.json".format(name)
184         with salt.utils.files.fopen(filename, "w") as f:
185             salt.utils.json.dump(self.request, f)
186         create = Popen(
187             ["kubectl", "--namespace=default", "create", "-f", filename], stdout=PIPE
188         )
189         time.sleep(0.1)
190         res = k8s.delete_secret("default", name, apiserver_url="http://127.0.0.1:8080")
191         time.sleep(0.1)
192         proc = Popen(
193             ["kubectl", "--namespace=default", "get", "secrets", name, "-o", "json"],
194             stdout=PIPE,
195             stderr=PIPE,
196         )
197         kubectl_out, err = proc.communicate()
198         self.assertEqual("", kubectl_out)
199         self.assertEqual(
200             'Error from server: secrets "{}" not found\n'.format(name), err
201         )
202 @pytest.mark.skip_if_binaries_missing("kubectl")
203 class TestK8SResourceQuotas(TestCase):
204     maxDiff = None
205     def setUp(self):
206         hash = hashlib.sha1()
207         hash.update(str(time.time()))
208         self.name = hash.hexdigest()[:16]
209     def test_get_resource_quotas(self):
210         name = self.name
211         namespace = self.name
212         create_namespace = Popen(
213             ["kubectl", "create", "namespace", namespace], stdout=PIPE
214         )
215         create_namespace = Popen(
216             ["kubectl", "create", "namespace", namespace], stdout=PIPE
217         )
218         request = """
219 apiVersion: v1
220 kind: ResourceQuota
221 metadata:
222   name: {}
223 spec:
224   hard:
225     cpu: "20"
226     memory: 1Gi
227     persistentvolumeclaims: "10"
228     pods: "10"
229     replicationcontrollers: "20"
230     resourcequotas: "1"
231     secrets: "10"
232     services: "5"
233             name
234         )
235         filename = "/tmp/{}.yaml".format(name)
236         with salt.utils.files.fopen(filename, "w") as f:
237             f.write(salt.utils.stringutils.to_str(request))
238         create = Popen(
239             ["kubectl", "--namespace={}".format(namespace), "create", "-f", filename],
240             stdout=PIPE,
241         )
242         time.sleep(0.2)
243         res = k8s.get_resource_quotas(
244             namespace, name, apiserver_url="http://127.0.0.1:8080"
245         )
246         a = res.get("metadata", {}).get("name", "a")
247         proc = Popen(
248             [
249                 "kubectl",
250                 "--namespace={}".format(namespace),
251                 "get",
252                 "quota",
253                 name,
254                 "-o",
255                 "json",
256             ],
257             stdout=PIPE,
258         )
259         kubectl_out = salt.utils.json.loads(proc.communicate()[0])
260         b = kubectl_out.get("metadata", {}).get("name", "b")
261         self.assertEqual(a, b)
262     def test_create_resource_quota(self):
263         name = self.name
264         namespace = self.name
265         create_namespace = Popen(
266             ["kubectl", "create", "namespace", namespace], stdout=PIPE
267         )
268         quota = {"cpu": "20", "memory": "1Gi"}
269         res = k8s.create_resource_quota(
270             namespace, quota, name=name, apiserver_url="http://127.0.0.1:8080"
271         )
272         proc = Popen(
273             [
274                 "kubectl",
275                 "--namespace={}".format(namespace),
276                 "get",
277                 "quota",
278                 name,
279                 "-o",
280                 "json",
281             ],
282             stdout=PIPE,
283         )
284         kubectl_out = salt.utils.json.loads(proc.communicate()[0])
285         self.assertTrue(isinstance(kubectl_out, dict))
286     def test_update_resource_quota(self):
287         name = self.name
288         namespace = self.name
289         create_namespace = Popen(
290             ["kubectl", "create", "namespace", namespace], stdout=PIPE
291         )
292         request = """
293 apiVersion: v1
294 kind: ResourceQuota
295 metadata:
296   name: {}
297 spec:
298   hard:
299     cpu: "20"
300     memory: 1Gi
301     persistentvolumeclaims: "10"
302     pods: "10"
303     replicationcontrollers: "20"
304     resourcequotas: "1"
305     secrets: "10"
306     services: "5"
307             name
308         )
309         limits = {"Container": {"defaultRequest": {"cpu": "100m"}}}
310         filename = "/tmp/{}.yaml".format(name)
311         with salt.utils.files.fopen(filename, "w") as f:
312             f.write(salt.utils.stringutils.to_str(request))
313         create = Popen(
314             ["kubectl", "--namespace=default", "create", "-f", filename], stdout=PIPE
315         )
316         time.sleep(0.1)
317         res = k8s.create_limit_range(
318             "default",
319             limits,
320             name=name,
321             apiserver_url="http://127.0.0.1:8080",
322             update=True,
323         )
324         proc = Popen(
325             ["kubectl", "--namespace=default", "get", "limits", name, "-o", "json"],
326             stdout=PIPE,
327         )
328         kubectl_out = salt.utils.json.loads(proc.communicate()[0])
329         limit = (
330             kubectl_out.get("spec").get("limits")[0].get("defaultRequest").get("cpu")
331         )
332         self.assertEqual("100m", limit)
333     def test_get_limit_ranges(self):
334         res = k8s.get_limit_ranges("default", apiserver_url="http://127.0.0.1:8080")
335         a = len(res.get("items", []))
336         proc = Popen(
337             ["kubectl", "--namespace=default", "get", "limits", "-o", "json"],
338             stdout=PIPE,
339         )
340         kubectl_out = salt.utils.json.loads(proc.communicate()[0])
341         b = len(kubectl_out.get("items", []))
342         self.assertEqual(a, b)
343     def test_get_one_limit_range(self):
344         name = self.name
345         request = """
346 apiVersion: v1
347 kind: LimitRange
348 metadata:
349   name: {}
350 spec:
351   limits:
352   - default:
353       cpu: 200m
354       memory: 512Mi
355     defaultRequest:
356       cpu: 100m
357       memory: 256Mi
358     type: Container
359 """.format(
360             name
361         )
362         filename = "/tmp/{}.yaml".format(name)
363         with salt.utils.files.fopen(filename, "w") as f:
364             f.write(salt.utils.stringutils.to_str(request))
365         create = Popen(
366             ["kubectl", "--namespace=default", "create", "-f", filename], stdout=PIPE
367         )
368         time.sleep(0.1)
369         res = k8s.get_limit_ranges(
370             "default", name, apiserver_url="http://127.0.0.1:8080"
371         )
372         a = res.get("metadata", {}).get("name", "a")
373         proc = Popen(
374             ["kubectl", "--namespace=default", "get", "limits", name, "-o", "json"],
375             stdout=PIPE,
376         )
377         kubectl_out = salt.utils.json.loads(proc.communicate()[0])
378         b = kubectl_out.get("metadata", {}).get("name", "b")
379         self.assertEqual(a, b)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
