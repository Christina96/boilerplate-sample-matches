<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_configparser.py &amp; test_k8s.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_configparser.py &amp; test_k8s.py
      </h3>
<h1 align="center">
        2.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_configparser.py (3.3942559%)<th>test_k8s.py (1.475596%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(73-75)<td><a href="#" name="0">(83-85)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_configparser.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
tests.unit.utils.test_configparser
==================================
Test the funcs in the custom parsers in salt.utils.configparser
"""
import copy
import errno
import logging
import os
import salt.utils.configparser
import salt.utils.files
import salt.utils.platform
import salt.utils.stringutils
from tests.support.runtests import RUNTIME_VARS
from tests.support.unit import TestCase
log = logging.getLogger(__name__)
ORIG_CONFIG = """[user]
        name = Артём Анисимов
\temail = foo@bar.com
[remote "origin"]
\turl = https://github.com/terminalmage/salt.git
\tfetch = +refs/heads/*:refs/remotes/origin/*
\tpushurl = git@github.com:terminalmage/salt.git
[color "diff"]
\told = 196
\tnew = 39
[core]
\tpager = less -R
\trepositoryformatversion = 0
\tfilemode = true
\tbare = false
\tlogallrefupdates = true
[alias]
\tmodified = ! git status --porcelain | awk 'match($1, "M"){print $2}'
\tgraph = log --all --decorate --oneline --graph
\thist = log --pretty=format:\\"%h %ad | %s%d [%an]\\" --graph --date=short
[http]
\tsslverify = false""".split(
    "\n"
)
class TestGitConfigParser(TestCase):
    """
    Tests for salt.utils.configparser.GitConfigParser
    """
    maxDiff = None
    orig_config = os.path.join(RUNTIME_VARS.TMP, "test_gitconfig.orig")
    new_config = os.path.join(RUNTIME_VARS.TMP, "test_gitconfig.new")
    remote = 'remote "origin"'
    def tearDown(self):
        del self.conf
        try:
            os.remove(self.new_config)
        except OSError as exc:
            if exc.errno != errno.ENOENT:
                raise
    def setUp(self):
            with salt.utils.files.fopen(self.orig_config, "wb") as fp_:
                fp_.write(salt.utils.stringutils.to_bytes(os.linesep.join(ORIG_CONFIG)))
        self.conf = salt.utils.configparser<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.GitConfigParser()
        with salt.utils.files.fopen(self.orig_config, "rb") as fp:
            self.conf._read(fp, self.</b></font>orig_config)
    @classmethod
    def tearDownClass(cls):
        try:
            os.remove(cls.orig_config)
        except OSError as exc:
            if exc.errno != errno.ENOENT:
                raise
    @staticmethod
    def fix_indent(lines):
        """
        Fixes the space-indented 'user' line, because when we write the config
        object to a file space indentation will be replaced by tab indentation.
        """
        ret = copy.copy(lines)
        for i, _ in enumerate(ret):
            if ret[i].startswith(salt.utils.configparser.GitConfigParser.SPACEINDENT):
                ret[i] = ret[i].replace(
                    salt.utils.configparser.GitConfigParser.SPACEINDENT, "\t"
                )
        return ret
    @staticmethod
    def get_lines(path):
        with salt.utils.files.fopen(path, "rb") as fp_:
            return salt.utils.stringutils.to_unicode(fp_.read()).splitlines()
    def _test_write(self, mode):
        kwargs = {"mode": mode}
        if salt.utils.platform.is_windows() and "b" not in mode:
            kwargs["encoding"] = "utf-8"
        with salt.utils.files.fopen(self.new_config, **kwargs) as fp_:
            self.conf.write(fp_)
        self.assertEqual(self.get_lines(self.new_config), self.fix_indent(ORIG_CONFIG))
    def test_get(self):
        """
        Test getting an option's value
        """
        self.assertEqual(self.conf.get('color "diff"', "old"), "196")
        self.assertEqual(
            self.conf.get("alias", "modified"),
            """! git status --porcelain | awk 'match($1, "M"){print $2}'""",
        )
        self.assertEqual(
            self.conf.get("alias", "hist"),
            salt.utils.stringutils.to_unicode(
                r"""log --pretty=format:\"%h %ad | %s%d [%an]\" --graph --date=short"""
            ),
        )
    def test_read_space_indent(self):
        """
        Test that user.name was successfully loaded despite being indented
        using spaces instead of a tab. Additionally, this tests that the value
        was loaded as a unicode type on PY2.
        """
        self.assertEqual(self.conf.get("user", "name"), "Артём Анисимов")
    def test_set_new_option(self):
        """
        Test setting a new option in an existing section
        """
        self.conf.set("http", "useragent", "myawesomeagent")
        self.assertEqual(self.conf.get("http", "useragent"), "myawesomeagent")
    def test_add_section(self):
        """
        Test adding a section and adding an item to that section
        """
        self.conf.add_section("foo")
        self.conf.set("foo", "bar", "baz")
        self.assertEqual(self.conf.get("foo", "bar"), "baz")
    def test_replace_option(self):
        """
        Test replacing an existing option
        """
        self.conf.set("http", "sslVerify", "true")
        self.assertEqual(self.conf.get("http", "sslverify"), "true")
    def test_set_multivar(self):
        """
        Test setting a multivar and then writing the resulting file
        """
        orig_refspec = "+refs/heads/*:refs/remotes/origin/*"
        new_refspec = "+refs/tags/*:refs/tags/*"
        self.assertEqual(self.conf.get(self.remote, "fetch"), orig_refspec)
        self.conf.set_multivar(self.remote, "fetch", new_refspec)
        self.assertEqual(
            self.conf.get(self.remote, "fetch"), [orig_refspec, new_refspec]
        )
        with salt.utils.files.fopen(self.new_config, "wb") as fp_:
            self.conf.write(fp_)
        expected = self.fix_indent(ORIG_CONFIG)
        expected.insert(6, "\tfetch = %s" % new_refspec)
        self.assertEqual(self.get_lines(self.new_config), expected)
    def test_remove_option(self):
        """
        test removing an option, including all items from a multivar
        """
        for item in ("fetch", "pushurl"):
            self.conf.remove_option(self.remote, item)
            self.assertRaises(
                salt.utils.configparser.NoOptionError, self.conf.get, self.remote, item
            )
    def test_remove_option_regexp(self):
        """
        test removing an option, including all items from a multivar
        """
        orig_refspec = "+refs/heads/*:refs/remotes/origin/*"
        new_refspec_1 = "+refs/tags/*:refs/tags/*"
        new_refspec_2 = "+refs/foo/*:refs/foo/*"
        self.conf.set_multivar(self.remote, "fetch", new_refspec_1)
        self.conf.set_multivar(self.remote, "fetch", new_refspec_2)
        self.assertEqual(
            self.conf.get(self.remote, "fetch"),
            [orig_refspec, new_refspec_1, new_refspec_2],
        )
        self.assertFalse(
            self.conf.remove_option_regexp(
                self.remote,
                "fetch",
                salt.utils.stringutils.to_unicode(r"\d{7,10}"),
            )
        )
        self.assertEqual(
            self.conf.get(self.remote, "fetch"),
            [orig_refspec, new_refspec_1, new_refspec_2],
        )
        self.assertTrue(self.conf.remove_option_regexp(self.remote, "fetch", "tags"))
        self.assertEqual(
            self.conf.get(self.remote, "fetch"), [orig_refspec, new_refspec_2]
        )
        self.assertTrue(self.conf.remove_option_regexp(self.remote, "fetch", "foo"))
        self.assertEqual(self.conf.get(self.remote, "fetch"), orig_refspec)
        self.assertTrue(self.conf.remove_option_regexp(self.remote, "fetch", "heads"))
        self.assertRaises(
            salt.utils.configparser.NoOptionError, self.conf.get, self.remote, "fetch"
        )
    def test_write(self):
        """
        Test writing using non-binary filehandle
        """
        self._test_write(mode="w")
    def test_write_binary(self):
        """
        Test writing using binary filehandle
        """
        self._test_write(mode="wb")
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_k8s.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
Unit Tests for the k8s execution module.
"""
import base64
import hashlib
import time
from subprocess import PIPE, Popen
import pytest
import salt.modules.k8s as k8s
import salt.utils.files
import salt.utils.json
from tests.support.unit import TestCase
@pytest.mark.skip_if_binaries_missing("kubectl")
class TestK8SNamespace(TestCase):
    maxDiff = None
    def test_get_namespaces(self):
        res = k8s.get_namespaces(apiserver_url="http://127.0.0.1:8080")
        a = len(res.get("items"))
        proc = Popen(["kubectl", "get", "namespaces", "-o", "json"], stdout=PIPE)
        kubectl_out = salt.utils.json.loads(proc.communicate()[0])
        b = len(kubectl_out.get("items"))
        self.assertEqual(a, b)
    def test_get_one_namespace(self):
        res = k8s.get_namespaces("default", apiserver_url="http://127.0.0.1:8080")
        a = res.get("metadata", {}).get("name", "a")
        proc = Popen(
            ["kubectl", "get", "namespaces", "default", "-o", "json"], stdout=PIPE
        )
        kubectl_out = salt.utils.json.loads(proc.communicate()[0])
        b = kubectl_out.get("metadata", {}).get("name", "b")
        self.assertEqual(a, b)
    def test_create_namespace(self):
        hash = hashlib.sha1()
        hash.update(str(time.time()))
        nsname = hash.hexdigest()[:16]
        res = k8s.create_namespace(nsname, apiserver_url="http://127.0.0.1:8080")
        proc = Popen(
            ["kubectl", "get", "namespaces", nsname, "-o", "json"], stdout=PIPE
        )
        kubectl_out = salt.utils.json.loads(proc.communicate()[0])
        self.assertTrue(isinstance(kubectl_out, dict))
@pytest.mark.skip_if_binaries_missing("kubectl")
class TestK8SSecrets(TestCase):
    maxDiff = None
    def setUp(self):
        hash = hashlib.sha1()
        hash.update(str(time.time()))
        self.name = hash.hexdigest()[:16]
        data = {"testsecret": base64.encodestring("teststring")}
        self.request = {
            "apiVersion": "v1",
            "kind": "Secret",
            "metadata": {"name": self.name, "namespace": "default"},
            "data": data,
        }
    def test_get_secrets(self):
        res = k8s.get_secrets("default", apiserver_url="http://127.0.0.1:8080")
        a = len(res.get("items", []))
        proc = Popen(
            ["kubectl", "--namespace=default", "get", "secrets", "-o", "json"],
            stdout=PIPE,
        )
        kubectl_out = salt.utils.json.loads(proc.communicate()[0])
        b = len(kubectl_out.get("items", []))
        self.assertEqual(a, b)
    def test_get_one_secret(self):
        name = self.name
        filename = "/tmp/{}.json"<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.format(name)
        with salt.utils.files.fopen(filename, "w") as f:
            salt.utils.json.dump(self.</b></font>request, f)
        create = Popen(
            ["kubectl", "--namespace=default", "create", "-f", filename], stdout=PIPE
        )
        time.sleep(0.1)
        res = k8s.get_secrets("default", name, apiserver_url="http://127.0.0.1:8080")
        a = res.get("metadata", {}).get("name", "a")
        proc = Popen(
            ["kubectl", "--namespace=default", "get", "secrets", name, "-o", "json"],
            stdout=PIPE,
        )
        kubectl_out = salt.utils.json.loads(proc.communicate()[0])
        b = kubectl_out.get("metadata", {}).get("name", "b")
        self.assertEqual(a, b)
    def test_get_decoded_secret(self):
        name = self.name
        filename = "/tmp/{}.json".format(name)
        with salt.utils.files.fopen(filename, "w") as f:
            salt.utils.json.dump(self.request, f)
        create = Popen(
            ["kubectl", "--namespace=default", "create", "-f", filename], stdout=PIPE
        )
        time.sleep(0.1)
        res = k8s.get_secrets(
            "default", name, apiserver_url="http://127.0.0.1:8080", decode=True
        )
        a = res.get("data", {}).get(
            "testsecret",
        )
        self.assertEqual(a, "teststring")
    def test_create_secret(self):
        name = self.name
        names = []
        expected_data = {}
        for i in range(2):
            names.append("/tmp/{}-{}".format(name, i))
            with salt.utils.files.fopen("/tmp/{}-{}".format(name, i), "w") as f:
                expected_data["{}-{}".format(name, i)] = base64.b64encode(
                    "{}{}".format(name, i)
                )
                f.write(salt.utils.stringutils.to_str("{}{}".format(name, i)))
        res = k8s.create_secret(
            "default", name, names, apiserver_url="http://127.0.0.1:8080"
        )
        proc = Popen(
            ["kubectl", "--namespace=default", "get", "secrets", name, "-o", "json"],
            stdout=PIPE,
        )
        kubectl_out = salt.utils.json.loads(proc.communicate()[0])
        b = kubectl_out.get("data", {})
        self.assertTrue(isinstance(kubectl_out, dict))
        self.assertEqual(expected_data, b)
    def test_update_secret(self):
        name = self.name
        filename = "/tmp/{}.json".format(name)
        with salt.utils.files.fopen(filename, "w") as f:
            salt.utils.json.dump(self.request, f)
        create = Popen(
            ["kubectl", "--namespace=default", "create", "-f", filename], stdout=PIPE
        )
        time.sleep(0.1)
        expected_data = {}
        names = []
        for i in range(3):
            names.append("/tmp/{}-{}-updated".format(name, i))
            with salt.utils.files.fopen("/tmp/{}-{}-updated".format(name, i), "w") as f:
                expected_data["{}-{}-updated".format(name, i)] = base64.b64encode(
                    "{}{}-updated".format(name, i)
                )
                f.write("{}{}-updated".format(name, i))
        res = k8s.update_secret(
            "default", name, names, apiserver_url="http://127.0.0.1:8080"
        )
        proc = Popen(
            ["kubectl", "--namespace=default", "get", "secrets", name, "-o", "json"],
            stdout=PIPE,
        )
        kubectl_out = salt.utils.json.loads(proc.communicate()[0])
        b = kubectl_out.get("data", {})
        self.assertTrue(isinstance(kubectl_out, dict))
        self.assertEqual(expected_data, b)
    def test_delete_secret(self):
        name = self.name
        filename = "/tmp/{}.json".format(name)
        with salt.utils.files.fopen(filename, "w") as f:
            salt.utils.json.dump(self.request, f)
        create = Popen(
            ["kubectl", "--namespace=default", "create", "-f", filename], stdout=PIPE
        )
        time.sleep(0.1)
        res = k8s.delete_secret("default", name, apiserver_url="http://127.0.0.1:8080")
        time.sleep(0.1)
        proc = Popen(
            ["kubectl", "--namespace=default", "get", "secrets", name, "-o", "json"],
            stdout=PIPE,
            stderr=PIPE,
        )
        kubectl_out, err = proc.communicate()
        self.assertEqual("", kubectl_out)
        self.assertEqual(
            'Error from server: secrets "{}" not found\n'.format(name), err
        )
@pytest.mark.skip_if_binaries_missing("kubectl")
class TestK8SResourceQuotas(TestCase):
    maxDiff = None
    def setUp(self):
        hash = hashlib.sha1()
        hash.update(str(time.time()))
        self.name = hash.hexdigest()[:16]
    def test_get_resource_quotas(self):
        name = self.name
        namespace = self.name
        create_namespace = Popen(
            ["kubectl", "create", "namespace", namespace], stdout=PIPE
        )
        create_namespace = Popen(
            ["kubectl", "create", "namespace", namespace], stdout=PIPE
        )
        request = """
apiVersion: v1
kind: ResourceQuota
metadata:
  name: {}
spec:
  hard:
    cpu: "20"
    memory: 1Gi
    persistentvolumeclaims: "10"
    pods: "10"
    replicationcontrollers: "20"
    resourcequotas: "1"
    secrets: "10"
    services: "5"
""".format(
            name
        )
        filename = "/tmp/{}.yaml".format(name)
        with salt.utils.files.fopen(filename, "w") as f:
            f.write(salt.utils.stringutils.to_str(request))
        create = Popen(
            ["kubectl", "--namespace={}".format(namespace), "create", "-f", filename],
            stdout=PIPE,
        )
        time.sleep(0.2)
        res = k8s.get_resource_quotas(namespace, apiserver_url="http://127.0.0.1:8080")
        a = len(res.get("items", []))
        proc = Popen(
            [
                "kubectl",
                "--namespace={}".format(namespace),
                "get",
                "quota",
                "-o",
                "json",
            ],
            stdout=PIPE,
        )
        kubectl_out = salt.utils.json.loads(proc.communicate()[0])
        b = len(kubectl_out.get("items", []))
        self.assertEqual(a, b)
    def test_get_one_resource_quota(self):
        name = self.name
        namespace = self.name
        create_namespace = Popen(
            ["kubectl", "create", "namespace", namespace], stdout=PIPE
        )
        request = """
apiVersion: v1
kind: ResourceQuota
metadata:
  name: {}
spec:
  hard:
    cpu: "20"
    memory: 1Gi
    persistentvolumeclaims: "10"
    pods: "10"
    replicationcontrollers: "20"
    resourcequotas: "1"
    secrets: "10"
    services: "5"
""".format(
            name
        )
        filename = "/tmp/{}.yaml".format(name)
        with salt.utils.files.fopen(filename, "w") as f:
            f.write(salt.utils.stringutils.to_str(request))
        create = Popen(
            ["kubectl", "--namespace={}".format(namespace), "create", "-f", filename],
            stdout=PIPE,
        )
        time.sleep(0.2)
        res = k8s.get_resource_quotas(
            namespace, name, apiserver_url="http://127.0.0.1:8080"
        )
        a = res.get("metadata", {}).get("name", "a")
        proc = Popen(
            [
                "kubectl",
                "--namespace={}".format(namespace),
                "get",
                "quota",
                name,
                "-o",
                "json",
            ],
            stdout=PIPE,
        )
        kubectl_out = salt.utils.json.loads(proc.communicate()[0])
        b = kubectl_out.get("metadata", {}).get("name", "b")
        self.assertEqual(a, b)
    def test_create_resource_quota(self):
        name = self.name
        namespace = self.name
        create_namespace = Popen(
            ["kubectl", "create", "namespace", namespace], stdout=PIPE
        )
        quota = {"cpu": "20", "memory": "1Gi"}
        res = k8s.create_resource_quota(
            namespace, quota, name=name, apiserver_url="http://127.0.0.1:8080"
        )
        proc = Popen(
            [
                "kubectl",
                "--namespace={}".format(namespace),
                "get",
                "quota",
                name,
                "-o",
                "json",
            ],
            stdout=PIPE,
        )
        kubectl_out = salt.utils.json.loads(proc.communicate()[0])
        self.assertTrue(isinstance(kubectl_out, dict))
    def test_update_resource_quota(self):
        name = self.name
        namespace = self.name
        create_namespace = Popen(
            ["kubectl", "create", "namespace", namespace], stdout=PIPE
        )
        request = """
apiVersion: v1
kind: ResourceQuota
metadata:
  name: {}
spec:
  hard:
    cpu: "20"
    memory: 1Gi
    persistentvolumeclaims: "10"
    pods: "10"
    replicationcontrollers: "20"
    resourcequotas: "1"
    secrets: "10"
    services: "5"
""".format(
            name
        )
        filename = "/tmp/{}.yaml".format(name)
        with salt.utils.files.fopen(filename, "w") as f:
            f.write(salt.utils.stringutils.to_str(request))
        create = Popen(
            ["kubectl", "--namespace={}".format(namespace), "create", "-f", filename],
            stdout=PIPE,
        )
        time.sleep(0.2)
        quota = {"cpu": "10", "memory": "2Gi"}
        res = k8s.create_resource_quota(
            namespace,
            quota,
            name=name,
            apiserver_url="http://127.0.0.1:8080",
            update=True,
        )
        proc = Popen(
            [
                "kubectl",
                "--namespace={}".format(namespace),
                "get",
                "quota",
                name,
                "-o",
                "json",
            ],
            stdout=PIPE,
        )
        kubectl_out = salt.utils.json.loads(proc.communicate()[0])
        limit = kubectl_out.get("spec").get("hard").get("memory")
        self.assertEqual("2Gi", limit)
@pytest.mark.skip_if_binaries_missing("kubectl")
class TestK8SLimitRange(TestCase):
    maxDiff = None
    def setUp(self):
        hash = hashlib.sha1()
        hash.update(str(time.time()))
        self.name = hash.hexdigest()[:16]
    def test_create_limit_range(self):
        name = self.name
        limits = {"Container": {"defaultRequest": {"cpu": "100m"}}}
        res = k8s.create_limit_range(
            "default", limits, name=name, apiserver_url="http://127.0.0.1:8080"
        )
        proc = Popen(
            ["kubectl", "--namespace=default", "get", "limits", name, "-o", "json"],
            stdout=PIPE,
        )
        kubectl_out = salt.utils.json.loads(proc.communicate()[0])
        self.assertTrue(isinstance(kubectl_out, dict))
    def test_update_limit_range(self):
        name = self.name
        request = """
apiVersion: v1
kind: LimitRange
metadata:
  name: {}
spec:
  limits:
  - default:
      cpu: 200m
      memory: 512Mi
    defaultRequest:
      cpu: 100m
      memory: 256Mi
    type: Container
""".format(
            name
        )
        limits = {"Container": {"defaultRequest": {"cpu": "100m"}}}
        filename = "/tmp/{}.yaml".format(name)
        with salt.utils.files.fopen(filename, "w") as f:
            f.write(salt.utils.stringutils.to_str(request))
        create = Popen(
            ["kubectl", "--namespace=default", "create", "-f", filename], stdout=PIPE
        )
        time.sleep(0.1)
        res = k8s.create_limit_range(
            "default",
            limits,
            name=name,
            apiserver_url="http://127.0.0.1:8080",
            update=True,
        )
        proc = Popen(
            ["kubectl", "--namespace=default", "get", "limits", name, "-o", "json"],
            stdout=PIPE,
        )
        kubectl_out = salt.utils.json.loads(proc.communicate()[0])
        limit = (
            kubectl_out.get("spec").get("limits")[0].get("defaultRequest").get("cpu")
        )
        self.assertEqual("100m", limit)
    def test_get_limit_ranges(self):
        res = k8s.get_limit_ranges("default", apiserver_url="http://127.0.0.1:8080")
        a = len(res.get("items", []))
        proc = Popen(
            ["kubectl", "--namespace=default", "get", "limits", "-o", "json"],
            stdout=PIPE,
        )
        kubectl_out = salt.utils.json.loads(proc.communicate()[0])
        b = len(kubectl_out.get("items", []))
        self.assertEqual(a, b)
    def test_get_one_limit_range(self):
        name = self.name
        request = """
apiVersion: v1
kind: LimitRange
metadata:
  name: {}
spec:
  limits:
  - default:
      cpu: 200m
      memory: 512Mi
    defaultRequest:
      cpu: 100m
      memory: 256Mi
    type: Container
""".format(
            name
        )
        filename = "/tmp/{}.yaml".format(name)
        with salt.utils.files.fopen(filename, "w") as f:
            f.write(salt.utils.stringutils.to_str(request))
        create = Popen(
            ["kubectl", "--namespace=default", "create", "-f", filename], stdout=PIPE
        )
        time.sleep(0.1)
        res = k8s.get_limit_ranges(
            "default", name, apiserver_url="http://127.0.0.1:8080"
        )
        a = res.get("metadata", {}).get("name", "a")
        proc = Popen(
            ["kubectl", "--namespace=default", "get", "limits", name, "-o", "json"],
            stdout=PIPE,
        )
        kubectl_out = salt.utils.json.loads(proc.communicate()[0])
        b = kubectl_out.get("metadata", {}).get("name", "b")
        self.assertEqual(a, b)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
