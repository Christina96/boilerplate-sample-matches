<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_configparser.py & test_k8s.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_configparser.py & test_k8s.py
      </h3>
      <h1 align="center">
        2.0%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_configparser.py (3.3942559%)<TH>test_k8s.py (1.475596%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match169033-0.html#0',2,'match169033-1.html#0',3)" NAME="0">(73-75)<TD><A HREF="javascript:ZweiFrames('match169033-0.html#0',2,'match169033-1.html#0',3)" NAME="0">(83-85)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_configparser.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
tests.unit.utils.test_configparser
==================================

Test the funcs in the custom parsers in salt.utils.configparser
&quot;&quot;&quot;

import copy
import errno
import logging
import os

import salt.utils.configparser
import salt.utils.files
import salt.utils.platform
import salt.utils.stringutils
from tests.support.runtests import RUNTIME_VARS
from tests.support.unit import TestCase

log = logging.getLogger(__name__)


# The user.name param here is intentionally indented with spaces instead of a
# tab to test that we properly load a file with mixed indentation.
ORIG_CONFIG = &quot;&quot;&quot;[user]
        name = Артём Анисимов
\temail = foo@bar.com
[remote &quot;origin&quot;]
\turl = https://github.com/terminalmage/salt.git
\tfetch = +refs/heads/*:refs/remotes/origin/*
\tpushurl = git@github.com:terminalmage/salt.git
[color &quot;diff&quot;]
\told = 196
\tnew = 39
[core]
\tpager = less -R
\trepositoryformatversion = 0
\tfilemode = true
\tbare = false
\tlogallrefupdates = true
[alias]
\tmodified = ! git status --porcelain | awk 'match($1, &quot;M&quot;){print $2}'
\tgraph = log --all --decorate --oneline --graph
\thist = log --pretty=format:\\&quot;%h %ad | %s%d [%an]\\&quot; --graph --date=short
[http]
\tsslverify = false&quot;&quot;&quot;.split(
    &quot;\n&quot;
)


class TestGitConfigParser(TestCase):
    &quot;&quot;&quot;
    Tests for salt.utils.configparser.GitConfigParser
    &quot;&quot;&quot;

    maxDiff = None
    orig_config = os.path.join(RUNTIME_VARS.TMP, &quot;test_gitconfig.orig&quot;)
    new_config = os.path.join(RUNTIME_VARS.TMP, &quot;test_gitconfig.new&quot;)
    remote = 'remote &quot;origin&quot;'

    def tearDown(self):
        del self.conf
        try:
            os.remove(self.new_config)
        except OSError as exc:
            if exc.errno != errno.ENOENT:
                raise

    def setUp(self):
<A NAME="0"></A>        if not os.path.exists(self.orig_config):
            with salt.utils.files.fopen(self.orig_config, &quot;wb&quot;) as fp_:
                fp_.write(salt.utils.stringutils.to_bytes(os.linesep.join(ORIG_CONFIG)))
        self.conf = salt.utils.configparser<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match169033-1.html#0',3,'match169033-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.GitConfigParser()
        with salt.utils.files.fopen(self.orig_config, &quot;rb&quot;) as fp:
            self.conf._read(fp, self.</B></FONT>orig_config)

    @classmethod
    def tearDownClass(cls):
        try:
            os.remove(cls.orig_config)
        except OSError as exc:
            if exc.errno != errno.ENOENT:
                raise

    @staticmethod
    def fix_indent(lines):
        &quot;&quot;&quot;
        Fixes the space-indented 'user' line, because when we write the config
        object to a file space indentation will be replaced by tab indentation.
        &quot;&quot;&quot;
        ret = copy.copy(lines)
        for i, _ in enumerate(ret):
            if ret[i].startswith(salt.utils.configparser.GitConfigParser.SPACEINDENT):
                ret[i] = ret[i].replace(
                    salt.utils.configparser.GitConfigParser.SPACEINDENT, &quot;\t&quot;
                )
        return ret

    @staticmethod
    def get_lines(path):
        with salt.utils.files.fopen(path, &quot;rb&quot;) as fp_:
            return salt.utils.stringutils.to_unicode(fp_.read()).splitlines()

    def _test_write(self, mode):
        kwargs = {&quot;mode&quot;: mode}
        if salt.utils.platform.is_windows() and &quot;b&quot; not in mode:
            kwargs[&quot;encoding&quot;] = &quot;utf-8&quot;
        with salt.utils.files.fopen(self.new_config, **kwargs) as fp_:
            self.conf.write(fp_)
        self.assertEqual(self.get_lines(self.new_config), self.fix_indent(ORIG_CONFIG))

    def test_get(self):
        &quot;&quot;&quot;
        Test getting an option's value
        &quot;&quot;&quot;
        # Numeric values should be loaded as strings
        self.assertEqual(self.conf.get('color &quot;diff&quot;', &quot;old&quot;), &quot;196&quot;)
        # Complex strings should be loaded with their literal quotes and
        # slashes intact
        self.assertEqual(
            self.conf.get(&quot;alias&quot;, &quot;modified&quot;),
            &quot;&quot;&quot;! git status --porcelain | awk 'match($1, &quot;M&quot;){print $2}'&quot;&quot;&quot;,
        )
        self.assertEqual(
            self.conf.get(&quot;alias&quot;, &quot;hist&quot;),
            salt.utils.stringutils.to_unicode(
                r&quot;&quot;&quot;log --pretty=format:\&quot;%h %ad | %s%d [%an]\&quot; --graph --date=short&quot;&quot;&quot;
            ),
        )

    def test_read_space_indent(self):
        &quot;&quot;&quot;
        Test that user.name was successfully loaded despite being indented
        using spaces instead of a tab. Additionally, this tests that the value
        was loaded as a unicode type on PY2.
        &quot;&quot;&quot;
        self.assertEqual(self.conf.get(&quot;user&quot;, &quot;name&quot;), &quot;Артём Анисимов&quot;)

    def test_set_new_option(self):
        &quot;&quot;&quot;
        Test setting a new option in an existing section
        &quot;&quot;&quot;
        self.conf.set(&quot;http&quot;, &quot;useragent&quot;, &quot;myawesomeagent&quot;)
        self.assertEqual(self.conf.get(&quot;http&quot;, &quot;useragent&quot;), &quot;myawesomeagent&quot;)

    def test_add_section(self):
        &quot;&quot;&quot;
        Test adding a section and adding an item to that section
        &quot;&quot;&quot;
        self.conf.add_section(&quot;foo&quot;)
        self.conf.set(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;)
        self.assertEqual(self.conf.get(&quot;foo&quot;, &quot;bar&quot;), &quot;baz&quot;)

    def test_replace_option(self):
        &quot;&quot;&quot;
        Test replacing an existing option
        &quot;&quot;&quot;
        # We're also testing the normalization of key names, here. Setting
        # &quot;sslVerify&quot; should actually set an &quot;sslverify&quot; option.
        self.conf.set(&quot;http&quot;, &quot;sslVerify&quot;, &quot;true&quot;)
        self.assertEqual(self.conf.get(&quot;http&quot;, &quot;sslverify&quot;), &quot;true&quot;)

    def test_set_multivar(self):
        &quot;&quot;&quot;
        Test setting a multivar and then writing the resulting file
        &quot;&quot;&quot;
        orig_refspec = &quot;+refs/heads/*:refs/remotes/origin/*&quot;
        new_refspec = &quot;+refs/tags/*:refs/tags/*&quot;
        # Make sure that the original value is a string
        self.assertEqual(self.conf.get(self.remote, &quot;fetch&quot;), orig_refspec)
        # Add another refspec
        self.conf.set_multivar(self.remote, &quot;fetch&quot;, new_refspec)
        # The value should now be a list
        self.assertEqual(
            self.conf.get(self.remote, &quot;fetch&quot;), [orig_refspec, new_refspec]
        )
        # Write the config object to a file
        with salt.utils.files.fopen(self.new_config, &quot;wb&quot;) as fp_:
            self.conf.write(fp_)
        # Confirm that the new file was written correctly
        expected = self.fix_indent(ORIG_CONFIG)
        # pylint: disable=string-substitution-usage-error
        expected.insert(6, &quot;\tfetch = %s&quot; % new_refspec)
        # pylint: enable=string-substitution-usage-error
        self.assertEqual(self.get_lines(self.new_config), expected)

    def test_remove_option(self):
        &quot;&quot;&quot;
        test removing an option, including all items from a multivar
        &quot;&quot;&quot;
        for item in (&quot;fetch&quot;, &quot;pushurl&quot;):
            self.conf.remove_option(self.remote, item)
            # To confirm that the option is now gone, a get should raise an
            # NoOptionError exception.
            self.assertRaises(
                salt.utils.configparser.NoOptionError, self.conf.get, self.remote, item
            )

    def test_remove_option_regexp(self):
        &quot;&quot;&quot;
        test removing an option, including all items from a multivar
        &quot;&quot;&quot;
        orig_refspec = &quot;+refs/heads/*:refs/remotes/origin/*&quot;
        new_refspec_1 = &quot;+refs/tags/*:refs/tags/*&quot;
        new_refspec_2 = &quot;+refs/foo/*:refs/foo/*&quot;
        # First, add both refspecs
        self.conf.set_multivar(self.remote, &quot;fetch&quot;, new_refspec_1)
        self.conf.set_multivar(self.remote, &quot;fetch&quot;, new_refspec_2)
        # Make sure that all three values are there
        self.assertEqual(
            self.conf.get(self.remote, &quot;fetch&quot;),
            [orig_refspec, new_refspec_1, new_refspec_2],
        )
        # If the regex doesn't match, no items should be removed
        self.assertFalse(
            self.conf.remove_option_regexp(
                self.remote,
                &quot;fetch&quot;,
                salt.utils.stringutils.to_unicode(r&quot;\d{7,10}&quot;),
            )
        )
        # Make sure that all three values are still there (since none should
        # have been removed)
        self.assertEqual(
            self.conf.get(self.remote, &quot;fetch&quot;),
            [orig_refspec, new_refspec_1, new_refspec_2],
        )
        # Remove one of the values
        self.assertTrue(self.conf.remove_option_regexp(self.remote, &quot;fetch&quot;, &quot;tags&quot;))
        # Confirm that the value is gone
        self.assertEqual(
            self.conf.get(self.remote, &quot;fetch&quot;), [orig_refspec, new_refspec_2]
        )
        # Remove the other one we added earlier
        self.assertTrue(self.conf.remove_option_regexp(self.remote, &quot;fetch&quot;, &quot;foo&quot;))
        # Since the option now only has one value, it should be a string
        self.assertEqual(self.conf.get(self.remote, &quot;fetch&quot;), orig_refspec)
        # Remove the last remaining option
        self.assertTrue(self.conf.remove_option_regexp(self.remote, &quot;fetch&quot;, &quot;heads&quot;))
        # Trying to do a get now should raise an exception
        self.assertRaises(
            salt.utils.configparser.NoOptionError, self.conf.get, self.remote, &quot;fetch&quot;
        )

    def test_write(self):
        &quot;&quot;&quot;
        Test writing using non-binary filehandle
        &quot;&quot;&quot;
        self._test_write(mode=&quot;w&quot;)

    def test_write_binary(self):
        &quot;&quot;&quot;
        Test writing using binary filehandle
        &quot;&quot;&quot;
        self._test_write(mode=&quot;wb&quot;)
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_k8s.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Unit Tests for the k8s execution module.
&quot;&quot;&quot;

import base64
import hashlib
import time
from subprocess import PIPE, Popen

import pytest
import salt.modules.k8s as k8s
import salt.utils.files
import salt.utils.json
from tests.support.unit import TestCase


@pytest.mark.skip_if_binaries_missing(&quot;kubectl&quot;)
class TestK8SNamespace(TestCase):

    maxDiff = None

    def test_get_namespaces(self):
        res = k8s.get_namespaces(apiserver_url=&quot;http://127.0.0.1:8080&quot;)
        a = len(res.get(&quot;items&quot;))
        proc = Popen([&quot;kubectl&quot;, &quot;get&quot;, &quot;namespaces&quot;, &quot;-o&quot;, &quot;json&quot;], stdout=PIPE)
        kubectl_out = salt.utils.json.loads(proc.communicate()[0])
        b = len(kubectl_out.get(&quot;items&quot;))
        self.assertEqual(a, b)

    def test_get_one_namespace(self):
        res = k8s.get_namespaces(&quot;default&quot;, apiserver_url=&quot;http://127.0.0.1:8080&quot;)
        a = res.get(&quot;metadata&quot;, {}).get(&quot;name&quot;, &quot;a&quot;)
        proc = Popen(
            [&quot;kubectl&quot;, &quot;get&quot;, &quot;namespaces&quot;, &quot;default&quot;, &quot;-o&quot;, &quot;json&quot;], stdout=PIPE
        )
        kubectl_out = salt.utils.json.loads(proc.communicate()[0])
        b = kubectl_out.get(&quot;metadata&quot;, {}).get(&quot;name&quot;, &quot;b&quot;)
        self.assertEqual(a, b)

    def test_create_namespace(self):
        hash = hashlib.sha1()
        hash.update(str(time.time()))
        nsname = hash.hexdigest()[:16]
        res = k8s.create_namespace(nsname, apiserver_url=&quot;http://127.0.0.1:8080&quot;)
        proc = Popen(
            [&quot;kubectl&quot;, &quot;get&quot;, &quot;namespaces&quot;, nsname, &quot;-o&quot;, &quot;json&quot;], stdout=PIPE
        )
        kubectl_out = salt.utils.json.loads(proc.communicate()[0])
        # if creation is failed, kubernetes return non json error message
        self.assertTrue(isinstance(kubectl_out, dict))


@pytest.mark.skip_if_binaries_missing(&quot;kubectl&quot;)
class TestK8SSecrets(TestCase):

    maxDiff = None

    def setUp(self):
        hash = hashlib.sha1()
        hash.update(str(time.time()))
        self.name = hash.hexdigest()[:16]
        data = {&quot;testsecret&quot;: base64.encodestring(&quot;teststring&quot;)}
        self.request = {
            &quot;apiVersion&quot;: &quot;v1&quot;,
            &quot;kind&quot;: &quot;Secret&quot;,
            &quot;metadata&quot;: {&quot;name&quot;: self.name, &quot;namespace&quot;: &quot;default&quot;},
            &quot;data&quot;: data,
        }

    def test_get_secrets(self):
        res = k8s.get_secrets(&quot;default&quot;, apiserver_url=&quot;http://127.0.0.1:8080&quot;)
        a = len(res.get(&quot;items&quot;, []))
        proc = Popen(
            [&quot;kubectl&quot;, &quot;--namespace=default&quot;, &quot;get&quot;, &quot;secrets&quot;, &quot;-o&quot;, &quot;json&quot;],
            stdout=PIPE,
        )
        kubectl_out = salt.utils.json.loads(proc.communicate()[0])
        b = len(kubectl_out.get(&quot;items&quot;, []))
        self.assertEqual(a, b)
<A NAME="0"></A>
    def test_get_one_secret(self):
        name = self.name
        filename = &quot;/tmp/{}.json&quot;<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match169033-0.html#0',2,'match169033-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.format(name)
        with salt.utils.files.fopen(filename, &quot;w&quot;) as f:
            salt.utils.json.dump(self.</B></FONT>request, f)

        create = Popen(
            [&quot;kubectl&quot;, &quot;--namespace=default&quot;, &quot;create&quot;, &quot;-f&quot;, filename], stdout=PIPE
        )
        # wee need to give kubernetes time save data in etcd
        time.sleep(0.1)
        res = k8s.get_secrets(&quot;default&quot;, name, apiserver_url=&quot;http://127.0.0.1:8080&quot;)
        a = res.get(&quot;metadata&quot;, {}).get(&quot;name&quot;, &quot;a&quot;)
        proc = Popen(
            [&quot;kubectl&quot;, &quot;--namespace=default&quot;, &quot;get&quot;, &quot;secrets&quot;, name, &quot;-o&quot;, &quot;json&quot;],
            stdout=PIPE,
        )
        kubectl_out = salt.utils.json.loads(proc.communicate()[0])
        b = kubectl_out.get(&quot;metadata&quot;, {}).get(&quot;name&quot;, &quot;b&quot;)
        self.assertEqual(a, b)

    def test_get_decoded_secret(self):
        name = self.name
        filename = &quot;/tmp/{}.json&quot;.format(name)
        with salt.utils.files.fopen(filename, &quot;w&quot;) as f:
            salt.utils.json.dump(self.request, f)

        create = Popen(
            [&quot;kubectl&quot;, &quot;--namespace=default&quot;, &quot;create&quot;, &quot;-f&quot;, filename], stdout=PIPE
        )
        # wee need to give etcd to populate data on all nodes
        time.sleep(0.1)
        res = k8s.get_secrets(
            &quot;default&quot;, name, apiserver_url=&quot;http://127.0.0.1:8080&quot;, decode=True
        )
        a = res.get(&quot;data&quot;, {}).get(
            &quot;testsecret&quot;,
        )
        self.assertEqual(a, &quot;teststring&quot;)

    def test_create_secret(self):
        name = self.name
        names = []
        expected_data = {}
        for i in range(2):
            names.append(&quot;/tmp/{}-{}&quot;.format(name, i))
            with salt.utils.files.fopen(&quot;/tmp/{}-{}&quot;.format(name, i), &quot;w&quot;) as f:
                expected_data[&quot;{}-{}&quot;.format(name, i)] = base64.b64encode(
                    &quot;{}{}&quot;.format(name, i)
                )
                f.write(salt.utils.stringutils.to_str(&quot;{}{}&quot;.format(name, i)))
        res = k8s.create_secret(
            &quot;default&quot;, name, names, apiserver_url=&quot;http://127.0.0.1:8080&quot;
        )
        proc = Popen(
            [&quot;kubectl&quot;, &quot;--namespace=default&quot;, &quot;get&quot;, &quot;secrets&quot;, name, &quot;-o&quot;, &quot;json&quot;],
            stdout=PIPE,
        )
        kubectl_out = salt.utils.json.loads(proc.communicate()[0])
        # if creation is failed, kubernetes return non json error message
        b = kubectl_out.get(&quot;data&quot;, {})
        self.assertTrue(isinstance(kubectl_out, dict))
        self.assertEqual(expected_data, b)

    def test_update_secret(self):
        name = self.name
        filename = &quot;/tmp/{}.json&quot;.format(name)
        with salt.utils.files.fopen(filename, &quot;w&quot;) as f:
            salt.utils.json.dump(self.request, f)

        create = Popen(
            [&quot;kubectl&quot;, &quot;--namespace=default&quot;, &quot;create&quot;, &quot;-f&quot;, filename], stdout=PIPE
        )
        # wee need to give kubernetes time save data in etcd
        time.sleep(0.1)
        expected_data = {}
        names = []
        for i in range(3):
            names.append(&quot;/tmp/{}-{}-updated&quot;.format(name, i))
            with salt.utils.files.fopen(&quot;/tmp/{}-{}-updated&quot;.format(name, i), &quot;w&quot;) as f:
                expected_data[&quot;{}-{}-updated&quot;.format(name, i)] = base64.b64encode(
                    &quot;{}{}-updated&quot;.format(name, i)
                )
                f.write(&quot;{}{}-updated&quot;.format(name, i))

        res = k8s.update_secret(
            &quot;default&quot;, name, names, apiserver_url=&quot;http://127.0.0.1:8080&quot;
        )
        # if creation is failed, kubernetes return non json error message
        proc = Popen(
            [&quot;kubectl&quot;, &quot;--namespace=default&quot;, &quot;get&quot;, &quot;secrets&quot;, name, &quot;-o&quot;, &quot;json&quot;],
            stdout=PIPE,
        )
        kubectl_out = salt.utils.json.loads(proc.communicate()[0])
        # if creation is failed, kubernetes return non json error message
        b = kubectl_out.get(&quot;data&quot;, {})
        self.assertTrue(isinstance(kubectl_out, dict))
        self.assertEqual(expected_data, b)

    def test_delete_secret(self):
        name = self.name
        filename = &quot;/tmp/{}.json&quot;.format(name)
        with salt.utils.files.fopen(filename, &quot;w&quot;) as f:
            salt.utils.json.dump(self.request, f)

        create = Popen(
            [&quot;kubectl&quot;, &quot;--namespace=default&quot;, &quot;create&quot;, &quot;-f&quot;, filename], stdout=PIPE
        )
        # wee need to give kubernetes time save data in etcd
        time.sleep(0.1)
        res = k8s.delete_secret(&quot;default&quot;, name, apiserver_url=&quot;http://127.0.0.1:8080&quot;)
        time.sleep(0.1)
        proc = Popen(
            [&quot;kubectl&quot;, &quot;--namespace=default&quot;, &quot;get&quot;, &quot;secrets&quot;, name, &quot;-o&quot;, &quot;json&quot;],
            stdout=PIPE,
            stderr=PIPE,
        )
        kubectl_out, err = proc.communicate()
        # stdout is empty, stderr is showing something like &quot;not found&quot;
        self.assertEqual(&quot;&quot;, kubectl_out)
        self.assertEqual(
            'Error from server: secrets &quot;{}&quot; not found\n'.format(name), err
        )


@pytest.mark.skip_if_binaries_missing(&quot;kubectl&quot;)
class TestK8SResourceQuotas(TestCase):

    maxDiff = None

    def setUp(self):
        hash = hashlib.sha1()
        hash.update(str(time.time()))
        self.name = hash.hexdigest()[:16]

    def test_get_resource_quotas(self):
        name = self.name
        namespace = self.name
        create_namespace = Popen(
            [&quot;kubectl&quot;, &quot;create&quot;, &quot;namespace&quot;, namespace], stdout=PIPE
        )
        create_namespace = Popen(
            [&quot;kubectl&quot;, &quot;create&quot;, &quot;namespace&quot;, namespace], stdout=PIPE
        )
        request = &quot;&quot;&quot;
apiVersion: v1
kind: ResourceQuota
metadata:
  name: {}
spec:
  hard:
    cpu: &quot;20&quot;
    memory: 1Gi
    persistentvolumeclaims: &quot;10&quot;
    pods: &quot;10&quot;
    replicationcontrollers: &quot;20&quot;
    resourcequotas: &quot;1&quot;
    secrets: &quot;10&quot;
    services: &quot;5&quot;
&quot;&quot;&quot;.format(
            name
        )
        filename = &quot;/tmp/{}.yaml&quot;.format(name)
        with salt.utils.files.fopen(filename, &quot;w&quot;) as f:
            f.write(salt.utils.stringutils.to_str(request))

        create = Popen(
            [&quot;kubectl&quot;, &quot;--namespace={}&quot;.format(namespace), &quot;create&quot;, &quot;-f&quot;, filename],
            stdout=PIPE,
        )
        # wee need to give kubernetes time save data in etcd
        time.sleep(0.2)
        res = k8s.get_resource_quotas(namespace, apiserver_url=&quot;http://127.0.0.1:8080&quot;)
        a = len(res.get(&quot;items&quot;, []))
        proc = Popen(
            [
                &quot;kubectl&quot;,
                &quot;--namespace={}&quot;.format(namespace),
                &quot;get&quot;,
                &quot;quota&quot;,
                &quot;-o&quot;,
                &quot;json&quot;,
            ],
            stdout=PIPE,
        )
        kubectl_out = salt.utils.json.loads(proc.communicate()[0])
        b = len(kubectl_out.get(&quot;items&quot;, []))
        self.assertEqual(a, b)

    def test_get_one_resource_quota(self):
        name = self.name
        namespace = self.name
        create_namespace = Popen(
            [&quot;kubectl&quot;, &quot;create&quot;, &quot;namespace&quot;, namespace], stdout=PIPE
        )
        request = &quot;&quot;&quot;
apiVersion: v1
kind: ResourceQuota
metadata:
  name: {}
spec:
  hard:
    cpu: &quot;20&quot;
    memory: 1Gi
    persistentvolumeclaims: &quot;10&quot;
    pods: &quot;10&quot;
    replicationcontrollers: &quot;20&quot;
    resourcequotas: &quot;1&quot;
    secrets: &quot;10&quot;
    services: &quot;5&quot;
&quot;&quot;&quot;.format(
            name
        )
        filename = &quot;/tmp/{}.yaml&quot;.format(name)
        with salt.utils.files.fopen(filename, &quot;w&quot;) as f:
            f.write(salt.utils.stringutils.to_str(request))

        create = Popen(
            [&quot;kubectl&quot;, &quot;--namespace={}&quot;.format(namespace), &quot;create&quot;, &quot;-f&quot;, filename],
            stdout=PIPE,
        )
        # wee need to give kubernetes time save data in etcd
        time.sleep(0.2)
        res = k8s.get_resource_quotas(
            namespace, name, apiserver_url=&quot;http://127.0.0.1:8080&quot;
        )
        a = res.get(&quot;metadata&quot;, {}).get(&quot;name&quot;, &quot;a&quot;)
        proc = Popen(
            [
                &quot;kubectl&quot;,
                &quot;--namespace={}&quot;.format(namespace),
                &quot;get&quot;,
                &quot;quota&quot;,
                name,
                &quot;-o&quot;,
                &quot;json&quot;,
            ],
            stdout=PIPE,
        )
        kubectl_out = salt.utils.json.loads(proc.communicate()[0])
        b = kubectl_out.get(&quot;metadata&quot;, {}).get(&quot;name&quot;, &quot;b&quot;)
        self.assertEqual(a, b)

    def test_create_resource_quota(self):
        name = self.name
        namespace = self.name
        create_namespace = Popen(
            [&quot;kubectl&quot;, &quot;create&quot;, &quot;namespace&quot;, namespace], stdout=PIPE
        )
        quota = {&quot;cpu&quot;: &quot;20&quot;, &quot;memory&quot;: &quot;1Gi&quot;}
        res = k8s.create_resource_quota(
            namespace, quota, name=name, apiserver_url=&quot;http://127.0.0.1:8080&quot;
        )
        proc = Popen(
            [
                &quot;kubectl&quot;,
                &quot;--namespace={}&quot;.format(namespace),
                &quot;get&quot;,
                &quot;quota&quot;,
                name,
                &quot;-o&quot;,
                &quot;json&quot;,
            ],
            stdout=PIPE,
        )
        kubectl_out = salt.utils.json.loads(proc.communicate()[0])
        self.assertTrue(isinstance(kubectl_out, dict))

    def test_update_resource_quota(self):
        name = self.name
        namespace = self.name
        create_namespace = Popen(
            [&quot;kubectl&quot;, &quot;create&quot;, &quot;namespace&quot;, namespace], stdout=PIPE
        )
        request = &quot;&quot;&quot;
apiVersion: v1
kind: ResourceQuota
metadata:
  name: {}
spec:
  hard:
    cpu: &quot;20&quot;
    memory: 1Gi
    persistentvolumeclaims: &quot;10&quot;
    pods: &quot;10&quot;
    replicationcontrollers: &quot;20&quot;
    resourcequotas: &quot;1&quot;
    secrets: &quot;10&quot;
    services: &quot;5&quot;
&quot;&quot;&quot;.format(
            name
        )
        filename = &quot;/tmp/{}.yaml&quot;.format(name)
        with salt.utils.files.fopen(filename, &quot;w&quot;) as f:
            f.write(salt.utils.stringutils.to_str(request))

        create = Popen(
            [&quot;kubectl&quot;, &quot;--namespace={}&quot;.format(namespace), &quot;create&quot;, &quot;-f&quot;, filename],
            stdout=PIPE,
        )
        # wee need to give kubernetes time save data in etcd
        time.sleep(0.2)
        quota = {&quot;cpu&quot;: &quot;10&quot;, &quot;memory&quot;: &quot;2Gi&quot;}
        res = k8s.create_resource_quota(
            namespace,
            quota,
            name=name,
            apiserver_url=&quot;http://127.0.0.1:8080&quot;,
            update=True,
        )
        proc = Popen(
            [
                &quot;kubectl&quot;,
                &quot;--namespace={}&quot;.format(namespace),
                &quot;get&quot;,
                &quot;quota&quot;,
                name,
                &quot;-o&quot;,
                &quot;json&quot;,
            ],
            stdout=PIPE,
        )
        kubectl_out = salt.utils.json.loads(proc.communicate()[0])
        limit = kubectl_out.get(&quot;spec&quot;).get(&quot;hard&quot;).get(&quot;memory&quot;)
        self.assertEqual(&quot;2Gi&quot;, limit)


@pytest.mark.skip_if_binaries_missing(&quot;kubectl&quot;)
class TestK8SLimitRange(TestCase):

    maxDiff = None

    def setUp(self):
        hash = hashlib.sha1()
        hash.update(str(time.time()))
        self.name = hash.hexdigest()[:16]

    def test_create_limit_range(self):
        name = self.name
        limits = {&quot;Container&quot;: {&quot;defaultRequest&quot;: {&quot;cpu&quot;: &quot;100m&quot;}}}
        res = k8s.create_limit_range(
            &quot;default&quot;, limits, name=name, apiserver_url=&quot;http://127.0.0.1:8080&quot;
        )
        proc = Popen(
            [&quot;kubectl&quot;, &quot;--namespace=default&quot;, &quot;get&quot;, &quot;limits&quot;, name, &quot;-o&quot;, &quot;json&quot;],
            stdout=PIPE,
        )
        kubectl_out = salt.utils.json.loads(proc.communicate()[0])
        self.assertTrue(isinstance(kubectl_out, dict))

    def test_update_limit_range(self):
        name = self.name
        request = &quot;&quot;&quot;
apiVersion: v1
kind: LimitRange
metadata:
  name: {}
spec:
  limits:
  - default:
      cpu: 200m
      memory: 512Mi
    defaultRequest:
      cpu: 100m
      memory: 256Mi
    type: Container
&quot;&quot;&quot;.format(
            name
        )
        limits = {&quot;Container&quot;: {&quot;defaultRequest&quot;: {&quot;cpu&quot;: &quot;100m&quot;}}}
        filename = &quot;/tmp/{}.yaml&quot;.format(name)
        with salt.utils.files.fopen(filename, &quot;w&quot;) as f:
            f.write(salt.utils.stringutils.to_str(request))

        create = Popen(
            [&quot;kubectl&quot;, &quot;--namespace=default&quot;, &quot;create&quot;, &quot;-f&quot;, filename], stdout=PIPE
        )
        # wee need to give kubernetes time save data in etcd
        time.sleep(0.1)
        res = k8s.create_limit_range(
            &quot;default&quot;,
            limits,
            name=name,
            apiserver_url=&quot;http://127.0.0.1:8080&quot;,
            update=True,
        )
        proc = Popen(
            [&quot;kubectl&quot;, &quot;--namespace=default&quot;, &quot;get&quot;, &quot;limits&quot;, name, &quot;-o&quot;, &quot;json&quot;],
            stdout=PIPE,
        )
        kubectl_out = salt.utils.json.loads(proc.communicate()[0])
        limit = (
            kubectl_out.get(&quot;spec&quot;).get(&quot;limits&quot;)[0].get(&quot;defaultRequest&quot;).get(&quot;cpu&quot;)
        )
        self.assertEqual(&quot;100m&quot;, limit)

    def test_get_limit_ranges(self):
        res = k8s.get_limit_ranges(&quot;default&quot;, apiserver_url=&quot;http://127.0.0.1:8080&quot;)
        a = len(res.get(&quot;items&quot;, []))
        proc = Popen(
            [&quot;kubectl&quot;, &quot;--namespace=default&quot;, &quot;get&quot;, &quot;limits&quot;, &quot;-o&quot;, &quot;json&quot;],
            stdout=PIPE,
        )
        kubectl_out = salt.utils.json.loads(proc.communicate()[0])
        b = len(kubectl_out.get(&quot;items&quot;, []))
        self.assertEqual(a, b)

    def test_get_one_limit_range(self):
        name = self.name
        request = &quot;&quot;&quot;
apiVersion: v1
kind: LimitRange
metadata:
  name: {}
spec:
  limits:
  - default:
      cpu: 200m
      memory: 512Mi
    defaultRequest:
      cpu: 100m
      memory: 256Mi
    type: Container
&quot;&quot;&quot;.format(
            name
        )
        filename = &quot;/tmp/{}.yaml&quot;.format(name)
        with salt.utils.files.fopen(filename, &quot;w&quot;) as f:
            f.write(salt.utils.stringutils.to_str(request))

        create = Popen(
            [&quot;kubectl&quot;, &quot;--namespace=default&quot;, &quot;create&quot;, &quot;-f&quot;, filename], stdout=PIPE
        )
        # wee need to give kubernetes time save data in etcd
        time.sleep(0.1)
        res = k8s.get_limit_ranges(
            &quot;default&quot;, name, apiserver_url=&quot;http://127.0.0.1:8080&quot;
        )
        a = res.get(&quot;metadata&quot;, {}).get(&quot;name&quot;, &quot;a&quot;)
        proc = Popen(
            [&quot;kubectl&quot;, &quot;--namespace=default&quot;, &quot;get&quot;, &quot;limits&quot;, name, &quot;-o&quot;, &quot;json&quot;],
            stdout=PIPE,
        )
        kubectl_out = salt.utils.json.loads(proc.communicate()[0])
        b = kubectl_out.get(&quot;metadata&quot;, {}).get(&quot;name&quot;, &quot;b&quot;)
        self.assertEqual(a, b)
</PRE>
</div>
  </div>
</body>
</html>
