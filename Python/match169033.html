<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_configparser.py &amp; test_k8s.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_configparser.py &amp; test_k8s.py
      </h3>
<h1 align="center">
        2.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_configparser.py (3.3942559%)<th>test_k8s.py (1.475596%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(73-75)<td><a href="#" name="0">(83-85)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_configparser.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import errno
3 import logging
4 import os
5 import salt.utils.configparser
6 import salt.utils.files
7 import salt.utils.platform
8 import salt.utils.stringutils
9 from tests.support.runtests import RUNTIME_VARS
10 from tests.support.unit import TestCase
11 log = logging.getLogger(__name__)
12 ORIG_CONFIG = """[user]
13         name = Артём Анисимов
14 \temail = foo@bar.com
15 [remote "origin"]
16 \turl = https://github.com/terminalmage/salt.git
17 \tfetch = +refs/heads/*:refs/remotes/origin/*
18 \tpushurl = git@github.com:terminalmage/salt.git
19 [color "diff"]
20 \told = 196
21 \tnew = 39
22 [core]
23 \tpager = less -R
24 \trepositoryformatversion = 0
25 \tfilemode = true
26 \tbare = false
27 \tlogallrefupdates = true
28 [alias]
29 \tmodified = ! git status --porcelain | awk 'match($1, "M"){print $2}'
30 \tgraph = log --all --decorate --oneline --graph
31 \thist = log --pretty=format:\\"%h %ad | %s%d [%an]\\" --graph --date=short
32 [http]
33 \tsslverify = false""".split(
34     "\n"
35 )
36 class TestGitConfigParser(TestCase):
37     maxDiff = None
38     orig_config = os.path.join(RUNTIME_VARS.TMP, "test_gitconfig.orig")
39     new_config = os.path.join(RUNTIME_VARS.TMP, "test_gitconfig.new")
40     remote = 'remote "origin"'
41     def tearDown(self):
42         del self.conf
43         try:
44             os.remove(self.new_config)
45         except OSError as exc:
46             if exc.errno != errno.ENOENT:
47                 raise
48     def setUp(self):
49             with salt.utils.files.fopen(self.orig_config, "wb") as fp_:
50                 fp_.write(salt.utils.stringutils.to_bytes(os.linesep.join(ORIG_CONFIG)))
51         self.conf = salt.utils.configparser<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.GitConfigParser()
52         with salt.utils.files.fopen(self.orig_config, "rb") as fp:
53             self.conf._read(fp, self.</b></font>orig_config)
54     @classmethod
55     def tearDownClass(cls):
56         try:
57             os.remove(cls.orig_config)
58         except OSError as exc:
59             if exc.errno != errno.ENOENT:
60                 raise
61     @staticmethod
62     def fix_indent(lines):
63         ret = copy.copy(lines)
64         for i, _ in enumerate(ret):
65             if ret[i].startswith(salt.utils.configparser.GitConfigParser.SPACEINDENT):
66                 ret[i] = ret[i].replace(
67                     salt.utils.configparser.GitConfigParser.SPACEINDENT, "\t"
68                 )
69         return ret
70     @staticmethod
71     def get_lines(path):
72         with salt.utils.files.fopen(path, "rb") as fp_:
73             return salt.utils.stringutils.to_unicode(fp_.read()).splitlines()
74     def _test_write(self, mode):
75         kwargs = {"mode": mode}
76         if salt.utils.platform.is_windows() and "b" not in mode:
77             kwargs["encoding"] = "utf-8"
78         with salt.utils.files.fopen(self.new_config, **kwargs) as fp_:
79             self.conf.write(fp_)
80         self.assertEqual(self.get_lines(self.new_config), self.fix_indent(ORIG_CONFIG))
81     def test_get(self):
82         self.assertEqual(self.conf.get('color "diff"', "old"), "196")
83         self.assertEqual(
84             self.conf.get("alias", "modified"),
85         Test that user.name was successfully loaded despite being indented
86         using spaces instead of a tab. Additionally, this tests that the value
87         was loaded as a unicode type on PY2.
88         Test setting a new option in an existing section
89         Test adding a section and adding an item to that section
90         Test replacing an existing option
91         Test setting a multivar and then writing the resulting file
92         test removing an option, including all items from a multivar
93         test removing an option, including all items from a multivar
94         Test writing using non-binary filehandle
95         Test writing using binary filehandle
96 Unit Tests for the k8s execution module.
97 """
98         filename = "/tmp/{}.json"<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.format(name)
99         with salt.utils.files.fopen(filename, "w") as f:
100             salt.utils.json.dump(self.</b></font>request, f)
101         create = Popen(
102             ["kubectl", "--namespace=default", "create", "-f", filename], stdout=PIPE
103         )
104         time.sleep(0.1)
105         res = k8s.get_secrets("default", name, apiserver_url="http://127.0.0.1:8080")
106         a = res.get("metadata", {}).get("name", "a")
107         proc = Popen(
108             ["kubectl", "--namespace=default", "get", "secrets", name, "-o", "json"],
109             stdout=PIPE,
110         )
111         kubectl_out = salt.utils.json.loads(proc.communicate()[0])
112         b = kubectl_out.get("metadata", {}).get("name", "b")
113         self.assertEqual(a, b)
114     def test_get_decoded_secret(self):
115         name = self.name
116         filename = "/tmp/{}.json".format(name)
117         with salt.utils.files.fopen(filename, "w") as f:
118             salt.utils.json.dump(self.request, f)
119         create = Popen(
120             ["kubectl", "--namespace=default", "create", "-f", filename], stdout=PIPE
121         )
122         time.sleep(0.1)
123         res = k8s.get_secrets(
124             "default", name, apiserver_url="http://127.0.0.1:8080", decode=True
125         )
126         a = res.get("data", {}).get(
127             "testsecret",
128         )
129         self.assertEqual(a, "teststring")
130     def test_create_secret(self):
131         name = self.name
132         names = []
133         expected_data = {}
134         for i in range(2):
135             names.append("/tmp/{}-{}".format(name, i))
136             with salt.utils.files.fopen("/tmp/{}-{}".format(name, i), "w") as f:
137                 expected_data["{}-{}".format(name, i)] = base64.b64encode(
138                     "{}{}".format(name, i)
139                 )
140                 f.write(salt.utils.stringutils.to_str("{}{}".format(name, i)))
141         res = k8s.create_secret(
142             "default", name, names, apiserver_url="http://127.0.0.1:8080"
143         )
144         proc = Popen(
145             ["kubectl", "--namespace=default", "get", "secrets", name, "-o", "json"],
146             stdout=PIPE,
147         )
148         kubectl_out = salt.utils.json.loads(proc.communicate()[0])
149         b = kubectl_out.get("data", {})
150         self.assertTrue(isinstance(kubectl_out, dict))
151         self.assertEqual(expected_data, b)
152     def test_update_secret(self):
153         name = self.name
154         filename = "/tmp/{}.json".format(name)
155         with salt.utils.files.fopen(filename, "w") as f:
156             salt.utils.json.dump(self.request, f)
157         create = Popen(
158             ["kubectl", "--namespace=default", "create", "-f", filename], stdout=PIPE
159         )
160         time.sleep(0.1)
161         expected_data = {}
162         names = []
163         for i in range(3):
164             names.append("/tmp/{}-{}-updated".format(name, i))
165             with salt.utils.files.fopen("/tmp/{}-{}-updated".format(name, i), "w") as f:
166                 expected_data["{}-{}-updated".format(name, i)] = base64.b64encode(
167                     "{}{}-updated".format(name, i)
168                 )
169                 f.write("{}{}-updated".format(name, i))
170         res = k8s.update_secret(
171             "default", name, names, apiserver_url="http://127.0.0.1:8080"
172         )
173         proc = Popen(
174             ["kubectl", "--namespace=default", "get", "secrets", name, "-o", "json"],
175             stdout=PIPE,
176         )
177         kubectl_out = salt.utils.json.loads(proc.communicate()[0])
178         b = kubectl_out.get("data", {})
179         self.assertTrue(isinstance(kubectl_out, dict))
180         self.assertEqual(expected_data, b)
181     def test_delete_secret(self):
182         name = self.name
183         filename = "/tmp/{}.json".format(name)
184         with salt.utils.files.fopen(filename, "w") as f:
185             salt.utils.json.dump(self.request, f)
186         create = Popen(
187             ["kubectl", "--namespace=default", "create", "-f", filename], stdout=PIPE
188         )
189         time.sleep(0.1)
190         res = k8s.delete_secret("default", name, apiserver_url="http://127.0.0.1:8080")
191         time.sleep(0.1)
192         proc = Popen(
193             ["kubectl", "--namespace=default", "get", "secrets", name, "-o", "json"],
194             stdout=PIPE,
195             stderr=PIPE,
196         )
197         kubectl_out, err = proc.communicate()
198         self.assertEqual("", kubectl_out)
199         self.assertEqual(
200             'Error from server: secrets "{}" not found\n'.format(name), err
201         )
202 @pytest.mark.skip_if_binaries_missing("kubectl")
203 class TestK8SResourceQuotas(TestCase):
204     maxDiff = None
205     def setUp(self):
206         hash = hashlib.sha1()
207         hash.update(str(time.time()))
208         self.name = hash.hexdigest()[:16]
209     def test_get_resource_quotas(self):
210         name = self.name
211         namespace = self.name
212         create_namespace = Popen(
213             ["kubectl", "create", "namespace", namespace], stdout=PIPE
214         )
215         create_namespace = Popen(
216             ["kubectl", "create", "namespace", namespace], stdout=PIPE
217         )
218         request = """
219 apiVersion: v1
220 kind: ResourceQuota
221 metadata:
222   name: {}
223 spec:
224   hard:
225     cpu: "20"
226     memory: 1Gi
227     persistentvolumeclaims: "10"
228     pods: "10"
229     replicationcontrollers: "20"
230     resourcequotas: "1"
231     secrets: "10"
232     services: "5"
233 """.format(
234             name
235         )
236         filename = "/tmp/{}.yaml".format(name)
237         with salt.utils.files.fopen(filename, "w") as f:
238             f.write(salt.utils.stringutils.to_str(request))
239         create = Popen(
240             ["kubectl", "--namespace={}".format(namespace), "create", "-f", filename],
241             stdout=PIPE,
242         )
243         time.sleep(0.2)
244         res = k8s.get_resource_quotas(namespace, apiserver_url="http://127.0.0.1:8080")
245         a = len(res.get("items", []))
246         proc = Popen(
247             [
248                 "kubectl",
249                 "--namespace={}".format(namespace),
250                 "get",
251                 "quota",
252                 "-o",
253                 "json",
254             ],
255             stdout=PIPE,
256         )
257         kubectl_out = salt.utils.json.loads(proc.communicate()[0])
258         b = len(kubectl_out.get("items", []))
259         self.assertEqual(a, b)
260     def test_get_one_resource_quota(self):
261         name = self.name
262         namespace = self.name
263         create_namespace = Popen(
264             ["kubectl", "create", "namespace", namespace], stdout=PIPE
265         )
266         request = """
267 apiVersion: v1
268 kind: ResourceQuota
269 metadata:
270   name: {}
271 spec:
272   hard:
273     cpu: "20"
274     memory: 1Gi
275     persistentvolumeclaims: "10"
276     pods: "10"
277     replicationcontrollers: "20"
278     resourcequotas: "1"
279     secrets: "10"
280     services: "5"
281 """.format(
282             name
283         )
284         filename = "/tmp/{}.yaml".format(name)
285         with salt.utils.files.fopen(filename, "w") as f:
286             f.write(salt.utils.stringutils.to_str(request))
287         create = Popen(
288             ["kubectl", "--namespace={}".format(namespace), "create", "-f", filename],
289             stdout=PIPE,
290         )
291         time.sleep(0.2)
292         res = k8s.get_resource_quotas(
293             namespace, name, apiserver_url="http://127.0.0.1:8080"
294         )
295         a = res.get("metadata", {}).get("name", "a")
296         proc = Popen(
297             [
298                 "kubectl",
299                 "--namespace={}".format(namespace),
300                 "get",
301                 "quota",
302                 name,
303                 "-o",
304                 "json",
305             ],
306             stdout=PIPE,
307         )
308         kubectl_out = salt.utils.json.loads(proc.communicate()[0])
309         b = kubectl_out.get("metadata", {}).get("name", "b")
310         self.assertEqual(a, b)
311     def test_create_resource_quota(self):
312         name = self.name
313         namespace = self.name
314         create_namespace = Popen(
315             ["kubectl", "create", "namespace", namespace], stdout=PIPE
316         )
317         quota = {"cpu": "20", "memory": "1Gi"}
318         res = k8s.create_resource_quota(
319             namespace, quota, name=name, apiserver_url="http://127.0.0.1:8080"
320         )
321         proc = Popen(
322             [
323                 "kubectl",
324                 "--namespace={}".format(namespace),
325                 "get",
326                 "quota",
327                 name,
328                 "-o",
329                 "json",
330             ],
331             stdout=PIPE,
332         )
333         kubectl_out = salt.utils.json.loads(proc.communicate()[0])
334         self.assertTrue(isinstance(kubectl_out, dict))
335     def test_update_resource_quota(self):
336         name = self.name
337         namespace = self.name
338         create_namespace = Popen(
339             ["kubectl", "create", "namespace", namespace], stdout=PIPE
340         )
341         request = """
342 apiVersion: v1
343 kind: ResourceQuota
344 metadata:
345   name: {}
346 spec:
347   hard:
348     cpu: "20"
349     memory: 1Gi
350     persistentvolumeclaims: "10"
351     pods: "10"
352     replicationcontrollers: "20"
353     resourcequotas: "1"
354     secrets: "10"
355     services: "5"
356 """.format(
357             name
358         )
359         filename = "/tmp/{}.yaml".format(name)
360         with salt.utils.files.fopen(filename, "w") as f:
361             f.write(salt.utils.stringutils.to_str(request))
362         create = Popen(
363             ["kubectl", "--namespace={}".format(namespace), "create", "-f", filename],
364             stdout=PIPE,
365         )
366         time.sleep(0.2)
367         quota = {"cpu": "10", "memory": "2Gi"}
368         res = k8s.create_resource_quota(
369             namespace,
370             quota,
371             name=name,
372             apiserver_url="http://127.0.0.1:8080",
373             update=True,
374         )
375         proc = Popen(
376             [
377                 "kubectl",
378                 "--namespace={}".format(namespace),
379                 "get",
380                 "quota",
381                 name,
382                 "-o",
383                 "json",
384             ],
385             stdout=PIPE,
386         )
387         kubectl_out = salt.utils.json.loads(proc.communicate()[0])
388         limit = kubectl_out.get("spec").get("hard").get("memory")
389         self.assertEqual("2Gi", limit)
390 @pytest.mark.skip_if_binaries_missing("kubectl")
391 class TestK8SLimitRange(TestCase):
392     maxDiff = None
393     def setUp(self):
394         hash = hashlib.sha1()
395         hash.update(str(time.time()))
396         self.name = hash.hexdigest()[:16]
397     def test_create_limit_range(self):
398         name = self.name
399         limits = {"Container": {"defaultRequest": {"cpu": "100m"}}}
400         res = k8s.create_limit_range(
401             "default", limits, name=name, apiserver_url="http://127.0.0.1:8080"
402         )
403         proc = Popen(
404             ["kubectl", "--namespace=default", "get", "limits", name, "-o", "json"],
405             stdout=PIPE,
406         )
407         kubectl_out = salt.utils.json.loads(proc.communicate()[0])
408         self.assertTrue(isinstance(kubectl_out, dict))
409     def test_update_limit_range(self):
410         name = self.name
411         request = """
412 apiVersion: v1
413 kind: LimitRange
414 metadata:
415   name: {}
416 spec:
417   limits:
418   - default:
419       cpu: 200m
420       memory: 512Mi
421     defaultRequest:
422       cpu: 100m
423       memory: 256Mi
424     type: Container
425 """.format(
426             name
427         )
428         limits = {"Container": {"defaultRequest": {"cpu": "100m"}}}
429         filename = "/tmp/{}.yaml".format(name)
430         with salt.utils.files.fopen(filename, "w") as f:
431             f.write(salt.utils.stringutils.to_str(request))
432         create = Popen(
433             ["kubectl", "--namespace=default", "create", "-f", filename], stdout=PIPE
434         )
435         time.sleep(0.1)
436         res = k8s.create_limit_range(
437             "default",
438             limits,
439             name=name,
440             apiserver_url="http://127.0.0.1:8080",
441             update=True,
442         )
443         proc = Popen(
444             ["kubectl", "--namespace=default", "get", "limits", name, "-o", "json"],
445             stdout=PIPE,
446         )
447         kubectl_out = salt.utils.json.loads(proc.communicate()[0])
448         limit = (
449             kubectl_out.get("spec").get("limits")[0].get("defaultRequest").get("cpu")
450         )
451         self.assertEqual("100m", limit)
452     def test_get_limit_ranges(self):
453         res = k8s.get_limit_ranges("default", apiserver_url="http://127.0.0.1:8080")
454         a = len(res.get("items", []))
455         proc = Popen(
456             ["kubectl", "--namespace=default", "get", "limits", "-o", "json"],
457             stdout=PIPE,
458         )
459         kubectl_out = salt.utils.json.loads(proc.communicate()[0])
460         b = len(kubectl_out.get("items", []))
461         self.assertEqual(a, b)
462     def test_get_one_limit_range(self):
463         name = self.name
464         request = """
465 apiVersion: v1
466 kind: LimitRange
467 metadata:
468   name: {}
469 spec:
470   limits:
471   - default:
472       cpu: 200m
473       memory: 512Mi
474     defaultRequest:
475       cpu: 100m
476       memory: 256Mi
477     type: Container
478 """.format(
479             name
480         )
481         filename = "/tmp/{}.yaml".format(name)
482         with salt.utils.files.fopen(filename, "w") as f:
483             f.write(salt.utils.stringutils.to_str(request))
484         create = Popen(
485             ["kubectl", "--namespace=default", "create", "-f", filename], stdout=PIPE
486         )
487         time.sleep(0.1)
488         res = k8s.get_limit_ranges(
489             "default", name, apiserver_url="http://127.0.0.1:8080"
490         )
491         a = res.get("metadata", {}).get("name", "a")
492         proc = Popen(
493             ["kubectl", "--namespace=default", "get", "limits", name, "-o", "json"],
494             stdout=PIPE,
495         )
496         kubectl_out = salt.utils.json.loads(proc.communicate()[0])
497         b = kubectl_out.get("metadata", {}).get("name", "b")
498         self.assertEqual(a, b)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
