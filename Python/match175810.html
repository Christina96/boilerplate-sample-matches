<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for boto3_sns_1.py & lxd_1.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for boto3_sns_1.py & lxd_1.py
      </h3>
      <h1 align="center">
        1.9%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>boto3_sns_1.py (5.6034484%)<TH>lxd_1.py (1.1882998%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match175810-0.html#0',2,'match175810-1.html#0',3)" NAME="0">(69-84)<TD><A HREF="javascript:ZweiFrames('match175810-0.html#0',2,'match175810-1.html#0',3)" NAME="0">(1810-1862)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match175810-0.html#1',2,'match175810-1.html#1',3)" NAME="1">(162-176)<TD><A HREF="javascript:ZweiFrames('match175810-0.html#1',2,'match175810-1.html#1',3)" NAME="1">(2121-2167)</A><TD ALIGN=center><FONT COLOR="#da0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto3_sns_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Connection module for Amazon SNS

:configuration: This module accepts explicit sns credentials but can also
    utilize IAM roles assigned to the instance through Instance Profiles. Dynamic
    credentials are then automatically obtained from AWS API and no further
    configuration is necessary. More Information available at:

    .. code-block:: text

        http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html

    If IAM roles are not used you need to specify them either in a pillar or
    in the minion's config file:

    .. code-block:: yaml

        sns.keyid: GKTADJGHEIQSXMKKRBJ08H
        sns.key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs

    A region may also be specified in the configuration:

    .. code-block:: yaml

        sns.region: us-east-1

    If a region is not specified, the default is us-east-1.

    It's also possible to specify key, keyid and region via a profile, either
    as a passed in dict, or as a string to pull from pillars or minion config:

    .. code-block:: yaml

        myprofile:
            keyid: GKTADJGHEIQSXMKKRBJ08H
            key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs
            region: us-east-1

:depends: boto3
&quot;&quot;&quot;
# keep lint from choking on _get_conn and _cache_id
# pylint: disable=E0602


import logging

import salt.utils.versions

log = logging.getLogger(__name__)

# pylint: disable=unused-import
try:
    import botocore
    import boto3
    import jmespath

    logging.getLogger(&quot;boto3&quot;).setLevel(logging.CRITICAL)
    HAS_BOTO = True
except ImportError:
    HAS_BOTO = False
# pylint: enable=unused-import


def __virtual__():
    &quot;&quot;&quot;
<A NAME="0"></A>    Only load if boto libraries exist.
    &quot;&quot;&quot;
    has_boto_reqs = salt.utils.versions.check_boto_reqs()
    <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match175810-1.html#0',3,'match175810-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>if has_boto_reqs is True:
        __utils__[&quot;boto3.assign_funcs&quot;](__name__, &quot;sns&quot;)
    return has_boto_reqs


def list_topics(region=None, key=None, keyid=None, profile=None):
    &quot;&quot;&quot;
    Returns a list of the requester's topics

    CLI Example:

    .. code-block:: bash

        salt myminion boto3_sns.list_topics
    &quot;&quot;&quot;
    conn = _get_conn(region=</B></FONT>region, key=key, keyid=keyid, profile=profile)
    res = {}
    NextToken = &quot;&quot;
    while NextToken is not None:
        ret = conn.list_topics(NextToken=NextToken)
        NextToken = ret.get(&quot;NextToken&quot;, None)
        arns = jmespath.search(&quot;Topics[*].TopicArn&quot;, ret)
        for t in arns:
            short_name = t.split(&quot;:&quot;)[-1]
            res[short_name] = t
    return res


def describe_topic(name, region=None, key=None, keyid=None, profile=None):
    &quot;&quot;&quot;
    Returns details about a specific SNS topic, specified by name or ARN.

    CLI Example:

    .. code-block:: bash

        salt my_favorite_client boto3_sns.describe_topic a_sns_topic_of_my_choice
    &quot;&quot;&quot;
    topics = list_topics(region=region, key=key, keyid=keyid, profile=profile)
    ret = {}
    for topic, arn in topics.items():
        if name in (topic, arn):
            ret = {&quot;TopicArn&quot;: arn}
            ret[&quot;Subscriptions&quot;] = list_subscriptions_by_topic(
                arn, region=region, key=key, keyid=keyid, profile=profile
            )
            ret[&quot;Attributes&quot;] = get_topic_attributes(
                arn, region=region, key=key, keyid=keyid, profile=profile
            )
            # Grab extended attributes for the above subscriptions
            for sub in ret[&quot;Subscriptions&quot;]:
                sub_arn = sub[&quot;SubscriptionArn&quot;]
                if not sub_arn.startswith(&quot;arn:aws:sns:&quot;):
                    # Sometimes a sub is in e.g. PendingAccept or other
                    # wierd states and doesn't have an ARN yet
                    log.debug(&quot;Subscription with invalid ARN %s skipped...&quot;, sub_arn)
                    continue
    return ret


def topic_exists(name, region=None, key=None, keyid=None, profile=None):
    &quot;&quot;&quot;
    Check to see if an SNS topic exists.

    CLI Example:

    .. code-block:: bash

        salt myminion boto3_sns.topic_exists mytopic region=us-east-1
    &quot;&quot;&quot;
    topics = list_topics(region=region, key=key, keyid=keyid, profile=profile)
    return name in list(topics.values() + topics.keys())


def create_topic(Name, region=None, key=None, keyid=None, profile=None):
    &quot;&quot;&quot;
    Create an SNS topic.

    CLI Example:

    .. code-block:: bash

        salt myminion boto3_sns.create_topic mytopic region=us-east-1
    &quot;&quot;&quot;
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    try:
        ret = conn.create_topic(Name=Name)
        log.info(&quot;SNS topic %s created with ARN %s&quot;, Name, ret[&quot;TopicArn&quot;])
        return ret[&quot;TopicArn&quot;]
    except botocore.exceptions.ClientError as e:
<A NAME="1"></A>        log.error(&quot;Failed to create SNS topic %s: %s&quot;, Name, e)
        return None
    except KeyError:
        log<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match175810-1.html#1',3,'match175810-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.error(&quot;Failed to create SNS topic %s&quot;, Name)
        return None


def delete_topic(TopicArn, region=None, key=None, keyid=None, profile=None):
    &quot;&quot;&quot;
    Delete an SNS topic.

    CLI Example:

    .. code-block:: bash

        salt myminion boto3_sns.delete_topic mytopic region=us-east-1
    &quot;&quot;&quot;
    conn = _get_conn(region=</B></FONT>region, key=key, keyid=keyid, profile=profile)
    try:
        conn.delete_topic(TopicArn=TopicArn)
        log.info(&quot;SNS topic %s deleted&quot;, TopicArn)
        return True
    except botocore.exceptions.ClientError as e:
        log.error(&quot;Failed to delete SNS topic %s: %s&quot;, name, e)
        return False


def get_topic_attributes(TopicArn, region=None, key=None, keyid=None, profile=None):
    &quot;&quot;&quot;
    Returns all of the properties of a topic.  Topic properties returned might differ based on the
    authorization of the user.

    CLI Example:

    .. code-block:: bash

        salt myminion boto3_sns.get_topic_attributes someTopic region=us-west-1
    &quot;&quot;&quot;
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    try:
        return conn.get_topic_attributes(TopicArn=TopicArn).get(&quot;Attributes&quot;)
    except botocore.exceptions.ClientError as e:
        log.error(&quot;Failed to garner attributes for SNS topic %s: %s&quot;, TopicArn, e)
        return None


def set_topic_attributes(
    TopicArn,
    AttributeName,
    AttributeValue,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;
    Set an attribute of a topic to a new value.

    CLI Example:

    .. code-block:: bash

        salt myminion boto3_sns.set_topic_attributes someTopic DisplayName myDisplayNameValue
    &quot;&quot;&quot;
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    try:
        conn.set_topic_attributes(
            TopicArn=TopicArn,
            AttributeName=AttributeName,
            AttributeValue=AttributeValue,
        )
        log.debug(
            &quot;Set attribute %s=%s on SNS topic %s&quot;,
            AttributeName,
            AttributeValue,
            TopicArn,
        )
        return True
    except botocore.exceptions.ClientError as e:
        log.error(
            &quot;Failed to set attribute %s=%s for SNS topic %s: %s&quot;,
            AttributeName,
            AttributeValue,
            TopicArn,
            e,
        )
        return False


def list_subscriptions_by_topic(
    TopicArn, region=None, key=None, keyid=None, profile=None
):
    &quot;&quot;&quot;
    Returns a list of the subscriptions to a specific topic

    CLI Example:

    .. code-block:: bash

        salt myminion boto3_sns.list_subscriptions_by_topic mytopic region=us-east-1
    &quot;&quot;&quot;
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    NextToken = &quot;&quot;
    res = []
    try:
        while NextToken is not None:
            ret = conn.list_subscriptions_by_topic(
                TopicArn=TopicArn, NextToken=NextToken
            )
            NextToken = ret.get(&quot;NextToken&quot;, None)
            subs = ret.get(&quot;Subscriptions&quot;, [])
            res += subs
    except botocore.exceptions.ClientError as e:
        log.error(&quot;Failed to list subscriptions for SNS topic %s: %s&quot;, TopicArn, e)
        return None
    return res


def list_subscriptions(region=None, key=None, keyid=None, profile=None):
    &quot;&quot;&quot;
    Returns a list of the requester's topics

    CLI Example:

    .. code-block:: bash

        salt myminion boto3_sns.list_subscriptions region=us-east-1
    &quot;&quot;&quot;
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    NextToken = &quot;&quot;
    res = []
    try:
        while NextToken is not None:
            ret = conn.list_subscriptions(NextToken=NextToken)
            NextToken = ret.get(&quot;NextToken&quot;, None)
            subs = ret.get(&quot;Subscriptions&quot;, [])
            res += subs
    except botocore.exceptions.ClientError as e:
        log.error(&quot;Failed to list SNS subscriptions: %s&quot;, e)
        return None
    return res


def get_subscription_attributes(
    SubscriptionArn, region=None, key=None, keyid=None, profile=None
):
    &quot;&quot;&quot;
    Returns all of the properties of a subscription.

    CLI Example:

    .. code-block:: bash

        salt myminion boto3_sns.get_subscription_attributes somesubscription region=us-west-1
    &quot;&quot;&quot;
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    try:
        ret = conn.get_subscription_attributes(SubscriptionArn=SubscriptionArn)
        return ret[&quot;Attributes&quot;]
    except botocore.exceptions.ClientError as e:
        log.error(
            &quot;Failed to list attributes for SNS subscription %s: %s&quot;, SubscriptionArn, e
        )
        return None
    except KeyError:
        log.error(&quot;Failed to list attributes for SNS subscription %s&quot;, SubscriptionArn)
        return None


def set_subscription_attributes(
    SubscriptionArn,
    AttributeName,
    AttributeValue,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;
    Set an attribute of a subscription to a new value.

    CLI Example:

    .. code-block:: bash

        salt myminion boto3_sns.set_subscription_attributes someSubscription RawMessageDelivery jsonStringValue
    &quot;&quot;&quot;
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    try:
        conn.set_subscription_attributes(
            SubscriptionArn=SubscriptionArn,
            AttributeName=AttributeName,
            AttributeValue=AttributeValue,
        )
        log.debug(
            &quot;Set attribute %s=%s on SNS subscription %s&quot;,
            AttributeName,
            AttributeValue,
            SubscriptionArn,
        )
        return True
    except botocore.exceptions.ClientError as e:
        log.error(
            &quot;Failed to set attribute %s=%s for SNS subscription %s: %s&quot;,
            AttributeName,
            AttributeValue,
            SubscriptionArn,
            e,
        )
        return False


def subscribe(
    TopicArn, Protocol, Endpoint, region=None, key=None, keyid=None, profile=None
):
    &quot;&quot;&quot;
    Subscribe to a Topic.

    CLI Example:

    .. code-block:: bash

        salt myminion boto3_sns.subscribe mytopic https https://www.example.com/sns-endpoint
    &quot;&quot;&quot;
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    try:
        ret = conn.subscribe(TopicArn=TopicArn, Protocol=Protocol, Endpoint=Endpoint)
        log.info(
            &quot;Subscribed %s %s to topic %s with SubscriptionArn %s&quot;,
            Protocol,
            Endpoint,
            TopicArn,
            ret[&quot;SubscriptionArn&quot;],
        )
        return ret[&quot;SubscriptionArn&quot;]
    except botocore.exceptions.ClientError as e:
        log.error(&quot;Failed to create subscription to SNS topic %s: %s&quot;, TopicArn, e)
        return None
    except KeyError:
        log.error(&quot;Failed to create subscription to SNS topic %s&quot;, TopicArn)
        return None


def unsubscribe(SubscriptionArn, region=None, key=None, keyid=None, profile=None):
    &quot;&quot;&quot;
    Unsubscribe a specific SubscriptionArn of a topic.

    CLI Example:

    .. code-block:: bash

        salt myminion boto3_sns.unsubscribe my_subscription_arn region=us-east-1
    &quot;&quot;&quot;
    if not SubscriptionArn.startswith(&quot;arn:aws:sns:&quot;):
        # Grrr, AWS sent us an ARN that's NOT and ARN....
        # This can happen if, for instance, a subscription is left in PendingAcceptance or similar
        # Note that anything left in PendingConfirmation will be auto-deleted by AWS after 30 days
        # anyway, so this isn't as ugly a hack as it might seem at first...
        log.info(
            &quot;Invalid subscription ARN `%s` passed - likely a PendingConfirmaton or&quot;
            &quot; such.  Skipping unsubscribe attempt as it would almost certainly fail...&quot;,
            SubscriptionArn,
        )
        return True
    subs = list_subscriptions(region=region, key=key, keyid=keyid, profile=profile)
    sub = [s for s in subs if s.get(&quot;SubscriptionArn&quot;) == SubscriptionArn]
    if not sub:
        log.error(&quot;Subscription ARN %s not found&quot;, SubscriptionArn)
        return False
    TopicArn = sub[0][&quot;TopicArn&quot;]
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    try:
        conn.unsubscribe(SubscriptionArn=SubscriptionArn)
        log.info(&quot;Deleted subscription %s from SNS topic %s&quot;, SubscriptionArn, TopicArn)
        return True
    except botocore.exceptions.ClientError as e:
        log.error(&quot;Failed to delete subscription %s: %s&quot;, SubscriptionArn, e)
        return False
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>lxd_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Module for managing the LXD daemon and its containers.

.. versionadded:: 2019.2.0

`LXD(1)`_ is a container &quot;hypervisor&quot;. This execution module provides
several functions to help manage it and its containers.

.. note::

    - `pylxd(2)`_ version &gt;=2.2.5 is required to let this work,
      currently only available via pip.

        To install on Ubuntu:

        $ apt-get install libssl-dev python-pip
        $ pip install -U pylxd

    - you need lxd installed on the minion
      for the init() and version() methods.

    - for the config_get() and config_get() methods
      you need to have lxd-client installed.

.. _LXD(1): https://linuxcontainers.org/lxd/
.. _pylxd(2): https://github.com/lxc/pylxd/blob/master/doc/source/installation.rst

:maintainer: René Jochum &lt;rene@jochums.at&gt;
:maturity: new
:depends: python-pylxd
:platform: Linux
&quot;&quot;&quot;


import logging
import os
from datetime import datetime

import salt.utils.decorators.path
import salt.utils.files
from salt.exceptions import CommandExecutionError, SaltInvocationError
from salt.utils.versions import LooseVersion

try:
    import pylxd

    HAS_PYLXD = True

    import urllib3

    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
except ImportError:
    HAS_PYLXD = False


log = logging.getLogger(__name__)

__docformat__ = &quot;restructuredtext en&quot;

_pylxd_minimal_version = &quot;2.2.5&quot;

# Keep in sync with: https://github.com/lxc/lxd/blob/master/shared/osarch/architectures.go
_architectures = {
    &quot;unknown&quot;: &quot;0&quot;,
    &quot;i686&quot;: &quot;1&quot;,
    &quot;x86_64&quot;: &quot;2&quot;,
    &quot;armv7l&quot;: &quot;3&quot;,
    &quot;aarch64&quot;: &quot;4&quot;,
    &quot;ppc&quot;: &quot;5&quot;,
    &quot;ppc64&quot;: &quot;6&quot;,
    &quot;ppc64le&quot;: &quot;7&quot;,
    &quot;s390x&quot;: &quot;8&quot;,
}

# Keep in sync with: https://github.com/lxc/lxd/blob/master/shared/api/status_code.go
CONTAINER_STATUS_RUNNING = 103

__virtualname__ = &quot;lxd&quot;

_connection_pool = {}


def __virtual__():
    if HAS_PYLXD:
        if LooseVersion(pylxd_version()) &lt; LooseVersion(_pylxd_minimal_version):
            return (
                False,
                'The lxd execution module cannot be loaded: pylxd &quot;{}&quot; is '
                'not supported, you need at least pylxd &quot;{}&quot;'.format(
                    pylxd_version(), _pylxd_minimal_version
                ),
            )

        return __virtualname__

    return (
        False,
        &quot;The lxd execution module cannot be loaded: &quot;
        &quot;the pylxd python module is not available.&quot;,
    )


################
# LXD Management
################
@salt.utils.decorators.path.which(&quot;lxd&quot;)
def version():
    &quot;&quot;&quot;
    Returns the actual lxd version.

    CLI Example:

    .. code-block:: bash

        salt '*' lxd.version

    &quot;&quot;&quot;
    return __salt__[&quot;cmd.run&quot;](&quot;lxd --version&quot;)


def pylxd_version():
    &quot;&quot;&quot;
    Returns the actual pylxd version.

    CLI Example:

    .. code-block:: bash

        salt '*' lxd.pylxd_version

    &quot;&quot;&quot;
    return pylxd.__version__


@salt.utils.decorators.path.which(&quot;lxd&quot;)
def init(
    storage_backend=&quot;dir&quot;,
    trust_password=None,
    network_address=None,
    network_port=None,
    storage_create_device=None,
    storage_create_loop=None,
    storage_pool=None,
):
    &quot;&quot;&quot;
    Calls lxd init --auto -- opts

    storage_backend :
        Storage backend to use (zfs or dir, default: dir)

    trust_password :
        Password required to add new clients

    network_address : None
        Address to bind LXD to (default: none)

    network_port : None
        Port to bind LXD to (Default: 8443)

    storage_create_device : None
        Setup device based storage using this DEVICE

    storage_create_loop : None
        Setup loop based storage with this SIZE in GB

    storage_pool : None
        Storage pool to use or create

    CLI Examples:

    To listen on all IPv4/IPv6 Addresses:

    .. code-block:: bash

        salt '*' lxd.init dir PaSsW0rD [::]

    To not listen on Network:

    .. code-block:: bash

        salt '*' lxd.init
    &quot;&quot;&quot;

    cmd = 'lxd init --auto --storage-backend=&quot;{}&quot;'.format(storage_backend)

    if trust_password is not None:
        cmd = cmd + ' --trust-password=&quot;{}&quot;'.format(trust_password)

    if network_address is not None:
        cmd = cmd + ' --network-address=&quot;{}&quot;'.format(network_address)

    if network_port is not None:
        cmd = cmd + ' --network-port=&quot;{}&quot;'.format(network_port)

    if storage_create_device is not None:
        cmd = cmd + ' --storage-create-device=&quot;{}&quot;'.format(storage_create_device)

    if storage_create_loop is not None:
        cmd = cmd + ' --storage-create-loop=&quot;{}&quot;'.format(storage_create_loop)

    if storage_pool is not None:
        cmd = cmd + ' --storage-pool=&quot;{}&quot;'.format(storage_pool)

    try:
        output = __salt__[&quot;cmd.run&quot;](cmd)
    except ValueError as e:
        raise CommandExecutionError(
            &quot;Failed to call: '{}', error was: {}&quot;.format(cmd, str(e)),
        )

    if &quot;error:&quot; in output:
        raise CommandExecutionError(
            output[output.index(&quot;error:&quot;) + 7 :],
        )

    return output


@salt.utils.decorators.path.which(&quot;lxd&quot;)
@salt.utils.decorators.path.which(&quot;lxc&quot;)
def config_set(key, value):
    &quot;&quot;&quot;
    Set an LXD daemon config option

    CLI Examples:

    To listen on IPv4 and IPv6 port 8443,
    you can omit the :8443 its the default:

    .. code-block:: bash

        salt '*' lxd.config_set core.https_address [::]:8443

    To set the server trust password:

    .. code-block:: bash

        salt '*' lxd.config_set core.trust_password blah

    &quot;&quot;&quot;
    cmd = 'lxc config set &quot;{}&quot; &quot;{}&quot;'.format(
        key,
        value,
    )

    output = __salt__[&quot;cmd.run&quot;](cmd)
    if &quot;error:&quot; in output:
        raise CommandExecutionError(
            output[output.index(&quot;error:&quot;) + 7 :],
        )

    return ('Config value &quot;{}&quot; successfully set.'.format(key),)


@salt.utils.decorators.path.which(&quot;lxd&quot;)
@salt.utils.decorators.path.which(&quot;lxc&quot;)
def config_get(key):
    &quot;&quot;&quot;
    Get an LXD daemon config option

    key :
        The key of the config value to retrieve

    CLI Examples:

    .. code-block:: bash

        salt '*' lxd.config_get core.https_address
    &quot;&quot;&quot;

    cmd = 'lxc config get &quot;{}&quot;'.format(key)

    output = __salt__[&quot;cmd.run&quot;](cmd)
    if &quot;error:&quot; in output:
        raise CommandExecutionError(
            output[output.index(&quot;error:&quot;) + 7 :],
        )

    return output


#######################
# Connection Management
#######################
def pylxd_client_get(remote_addr=None, cert=None, key=None, verify_cert=True):
    &quot;&quot;&quot;
    Get an pyxld client, this is not meant to be run over the CLI.

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if you
        provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.

    See the `requests-docs`_ for the SSL stuff.

    .. _requests-docs: http://docs.python-requests.org/en/master/user/advanced/#ssl-cert-verification

    &quot;&quot;&quot;

    pool_key = &quot;|&quot;.join(
        (
            str(remote_addr),
            str(cert),
            str(key),
            str(verify_cert),
        )
    )

    if pool_key in _connection_pool:
        log.debug('Returning the client &quot;%s&quot; from our connection pool', remote_addr)
        return _connection_pool[pool_key]

    try:
        if remote_addr is None or remote_addr == &quot;/var/lib/lxd/unix.socket&quot;:
            log.debug(&quot;Trying to connect to the local unix socket&quot;)
            client = pylxd.Client()
        else:
            if remote_addr.startswith(&quot;/&quot;):
                client = pylxd.Client(remote_addr)
            else:
                if cert is None or key is None:
                    raise SaltInvocationError(
                        &quot;You have to give a Cert and Key file for remote endpoints.&quot;
                    )

                cert = os.path.expanduser(cert)
                key = os.path.expanduser(key)

                if not os.path.isfile(cert):
                    raise SaltInvocationError(
                        'You have given an invalid cert path: &quot;{}&quot;, the '
                        &quot;file does not exist or is not a file.&quot;.format(cert)
                    )

                if not os.path.isfile(key):
                    raise SaltInvocationError(
                        'You have given an invalid key path: &quot;{}&quot;, the '
                        &quot;file does not exists or is not a file.&quot;.format(key)
                    )

                log.debug(
                    'Trying to connect to &quot;%s&quot; with cert &quot;%s&quot;, key &quot;%s&quot; and '
                    'verify_cert &quot;%s&quot;',
                    remote_addr,
                    cert,
                    key,
                    verify_cert,
                )
                client = pylxd.Client(
                    endpoint=remote_addr,
                    cert=(
                        cert,
                        key,
                    ),
                    verify=verify_cert,
                )
    except pylxd.exceptions.ClientConnectionFailed:
        raise CommandExecutionError(&quot;Failed to connect to '{}'&quot;.format(remote_addr))

    except TypeError as e:
        # Happens when the verification failed.
        raise CommandExecutionError(
            'Failed to connect to &quot;{}&quot;, looks like the SSL verification '
            &quot;failed, error was: {}&quot;.format(remote_addr, str(e))
        )

    _connection_pool[pool_key] = client

    return client


def pylxd_save_object(obj):
    &quot;&quot;&quot;Saves an object (profile/image/container) and
        translate its execpetion on failure

    obj :
        The object to save

    This is an internal method, no CLI Example.
    &quot;&quot;&quot;
    try:
        obj.save(wait=True)
    except pylxd.exceptions.LXDAPIException as e:
        raise CommandExecutionError(str(e))

    return True


def authenticate(remote_addr, password, cert, key, verify_cert=True):
    &quot;&quot;&quot;
    Authenticate with a remote LXDaemon.

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if you
        provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443

    password :
        The password of the remote.

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.

    CLI Example:

    .. code-block:: bash

        salt '*' lxd.authenticate https://srv01:8443 &lt;yourpass&gt; ~/.config/lxc/client.crt ~/.config/lxc/client.key false

    See the `requests-docs`_ for the SSL stuff.

    .. _requests-docs: http://docs.python-requests.org/en/master/user/advanced/#ssl-cert-verification

    &quot;&quot;&quot;
    client = pylxd_client_get(remote_addr, cert, key, verify_cert)

    if client.trusted:
        return True

    try:
        client.authenticate(password)
    except pylxd.exceptions.LXDAPIException as e:
        # Wrong password
        raise CommandExecutionError(str(e))

    return client.trusted


######################
# Container Management
######################
def container_list(
    list_names=False, remote_addr=None, cert=None, key=None, verify_cert=True
):
    &quot;&quot;&quot;
    Lists containers

    list_names : False
        Only return a list of names when True

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.

    CLI Examples:

    Full dict with all available information:

    .. code-block:: bash

        salt '*' lxd.container_list

    For a list of names:

    .. code-block:: bash

        salt '*' lxd.container_list true

    See also `container-attributes`_.

    .. _container-attributes: https://github.com/lxc/pylxd/blob/master/doc/source/containers.rst#container-attributes

    &quot;&quot;&quot;

    client = pylxd_client_get(remote_addr, cert, key, verify_cert)
    containers = client.containers.all()
    if list_names:
        return [c.name for c in containers]

    return map(_pylxd_model_to_dict, containers)


def container_create(
    name,
    source,
    profiles=None,
    config=None,
    devices=None,
    architecture=&quot;x86_64&quot;,
    ephemeral=False,
    wait=True,
    remote_addr=None,
    cert=None,
    key=None,
    verify_cert=True,
    _raw=False,
):
    &quot;&quot;&quot;
    Create a container

    name :
        The name of the container

    source :
        Can be either a string containing an image alias:
             &quot;xenial/amd64&quot;

        or an dict with type &quot;image&quot; with alias:
            {&quot;type&quot;: &quot;image&quot;,
             &quot;alias&quot;: &quot;xenial/amd64&quot;}

        or image with &quot;fingerprint&quot;:
            {&quot;type&quot;: &quot;image&quot;,
             &quot;fingerprint&quot;: &quot;SHA-256&quot;}

        or image with &quot;properties&quot;:
            {&quot;type&quot;: &quot;image&quot;,
             &quot;properties&quot;: {
                &quot;os&quot;: &quot;ubuntu&quot;,
                &quot;release&quot;: &quot;14.04&quot;,
                &quot;architecture&quot;: &quot;x86_64&quot;}}

        or none:
            {&quot;type&quot;: &quot;none&quot;}

        or copy:
            {&quot;type&quot;: &quot;copy&quot;,
             &quot;source&quot;: &quot;my-old-container&quot;}

    profiles : ['default']
        List of profiles to apply on this container

    config :
        A config dict or None (None = unset).

        Can also be a list:
            [{'key': 'boot.autostart', 'value': 1},
             {'key': 'security.privileged', 'value': '1'}]

    devices :
        A device dict or None (None = unset).

    architecture : 'x86_64'
        Can be one of the following:
            * unknown
            * i686
            * x86_64
            * armv7l
            * aarch64
            * ppc
            * ppc64
            * ppc64le
            * s390x

    ephemeral : False
        Destroy this container after stop?

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.

    _raw : False
        Return the raw pyxld object or a dict?

    CLI Examples:

    .. code-block:: bash

        salt '*' lxd.container_create test xenial/amd64

    See also the `rest-api-docs`_.

    .. _rest-api-docs: https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-1

    &quot;&quot;&quot;
    if profiles is None:
        profiles = [&quot;default&quot;]

    if config is None:
        config = {}

    if devices is None:
        devices = {}

    client = pylxd_client_get(remote_addr, cert, key, verify_cert)

    if not isinstance(profiles, (list, tuple, set)):
        raise SaltInvocationError(&quot;'profiles' must be formatted as list/tuple/set.&quot;)

    if architecture not in _architectures:
        raise SaltInvocationError(
            &quot;Unknown architecture '{}' given for the container '{}'&quot;.format(
                architecture, name
            )
        )

    if isinstance(source, str):
        source = {&quot;type&quot;: &quot;image&quot;, &quot;alias&quot;: source}

    config, devices = normalize_input_values(config, devices)

    try:
        container = client.containers.create(
            {
                &quot;name&quot;: name,
                &quot;architecture&quot;: _architectures[architecture],
                &quot;profiles&quot;: profiles,
                &quot;source&quot;: source,
                &quot;config&quot;: config,
                &quot;ephemeral&quot;: ephemeral,
            },
            wait=wait,
        )
    except pylxd.exceptions.LXDAPIException as e:
        raise CommandExecutionError(str(e))

    if not wait:
        return container.json()[&quot;operation&quot;]

    # Add devices if not wait and devices have been given.
    if devices:
        for dn, dargs in devices.items():
            container_device_add(name, dn, **dargs)

    if _raw:
        return container

    return _pylxd_model_to_dict(container)


def container_get(
    name=None, remote_addr=None, cert=None, key=None, verify_cert=True, _raw=False
):
    &quot;&quot;&quot;Gets a container from the LXD

    name :
        The name of the container to get.

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.

    _raw :
        Return the pylxd object, this is internal and by states in use.
    &quot;&quot;&quot;
    client = pylxd_client_get(remote_addr, cert, key, verify_cert)

    if name is None:
        containers = client.containers.all()
        if _raw:
            return containers
    else:
        containers = []
        try:
            containers = [client.containers.get(name)]
        except pylxd.exceptions.LXDAPIException:
            raise SaltInvocationError(&quot;Container '{}' not found&quot;.format(name))
        if _raw:
            return containers[0]

    infos = []
    for container in containers:
        infos.append(dict([(container.name, _pylxd_model_to_dict(container))]))
    return infos


def container_delete(name, remote_addr=None, cert=None, key=None, verify_cert=True):
    &quot;&quot;&quot;
    Delete a container

    name :
        Name of the container to delete

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.
    &quot;&quot;&quot;
    container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
    container.delete(wait=True)
    return True


def container_rename(
    name, newname, remote_addr=None, cert=None, key=None, verify_cert=True
):
    &quot;&quot;&quot;
    Rename a container

    name :
        Name of the container to Rename

    newname :
        The new name of the container

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.
    &quot;&quot;&quot;
    container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)

    if container.status_code == CONTAINER_STATUS_RUNNING:
        raise SaltInvocationError(
            &quot;Can't rename the running container '{}'.&quot;.format(name)
        )

    container.rename(newname, wait=True)
    return _pylxd_model_to_dict(container)


def container_state(name=None, remote_addr=None, cert=None, key=None, verify_cert=True):
    &quot;&quot;&quot;
    Get container state

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.
    &quot;&quot;&quot;
    client = pylxd_client_get(remote_addr, cert, key, verify_cert)

    if name is None:
        containers = client.containers.all()
    else:
        try:
            containers = [client.containers.get(name)]
        except pylxd.exceptions.LXDAPIException:
            raise SaltInvocationError(&quot;Container '{}' not found&quot;.format(name))

    states = []
    for container in containers:
        state = {}
        state = container.state()

        states.append(
            dict(
                [
                    (
                        container.name,
                        {
                            k: getattr(state, k)
                            for k in dir(state)
                            if not k.startswith(&quot;_&quot;)
                        },
                    )
                ]
            )
        )
    return states


def container_start(name, remote_addr=None, cert=None, key=None, verify_cert=True):
    &quot;&quot;&quot;
    Start a container

    name :
        Name of the container to start

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.
    &quot;&quot;&quot;
    container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
    container.start(wait=True)
    return _pylxd_model_to_dict(container)


def container_stop(
    name,
    timeout=30,
    force=True,
    remote_addr=None,
    cert=None,
    key=None,
    verify_cert=True,
):
    &quot;&quot;&quot;
    Stop a container

    name :
        Name of the container to stop

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.
    &quot;&quot;&quot;
    container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
    container.stop(timeout, force, wait=True)
    return _pylxd_model_to_dict(container)


def container_restart(name, remote_addr=None, cert=None, key=None, verify_cert=True):
    &quot;&quot;&quot;
    Restart a container

    name :
        Name of the container to restart

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.
    &quot;&quot;&quot;
    container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
    container.restart(wait=True)
    return _pylxd_model_to_dict(container)


def container_freeze(name, remote_addr=None, cert=None, key=None, verify_cert=True):
    &quot;&quot;&quot;
    Freeze a container

    name :
        Name of the container to freeze

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.
    &quot;&quot;&quot;
    container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
    container.freeze(wait=True)
    return _pylxd_model_to_dict(container)


def container_unfreeze(name, remote_addr=None, cert=None, key=None, verify_cert=True):
    &quot;&quot;&quot;
    Unfreeze a container

    name :
        Name of the container to unfreeze

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.
    &quot;&quot;&quot;
    container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
    container.unfreeze(wait=True)
    return _pylxd_model_to_dict(container)


def container_migrate(
    name,
    stop_and_start=False,
    remote_addr=None,
    cert=None,
    key=None,
    verify_cert=True,
    src_remote_addr=None,
    src_cert=None,
    src_key=None,
    src_verify_cert=None,
):
    &quot;&quot;&quot;Migrate a container.

    If the container is running, it either must be shut down
    first (use stop_and_start=True) or criu must be installed
    on the source and destination machines.

    For this operation both certs need to be authenticated,
    use :mod:`lxd.authenticate &lt;salt.modules.lxd.authenticate`
    to authenticate your cert(s).

    name :
        Name of the container to migrate

    stop_and_start :
        Stop the container on the source and start it on dest

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.

    CLI Example:

    .. code-block:: bash

        # Authorize
        salt '*' lxd.authenticate https://srv01:8443 &lt;yourpass&gt; ~/.config/lxc/client.crt ~/.config/lxc/client.key false
        salt '*' lxd.authenticate https://srv02:8443 &lt;yourpass&gt; ~/.config/lxc/client.crt ~/.config/lxc/client.key false

        # Migrate phpmyadmin from srv01 to srv02
        salt '*' lxd.container_migrate phpmyadmin stop_and_start=true remote_addr=https://srv02:8443 cert=~/.config/lxc/client.crt key=~/.config/lxc/client.key verify_cert=False src_remote_addr=https://srv01:8443
    &quot;&quot;&quot;
    if src_cert is None:
        src_cert = cert

    if src_key is None:
        src_key = key

    if src_verify_cert is None:
        src_verify_cert = verify_cert

    container = container_get(
        name, src_remote_addr, src_cert, src_key, src_verify_cert, _raw=True
    )

    dest_client = pylxd_client_get(remote_addr, cert, key, verify_cert)

    for pname in container.profiles:
        try:
            dest_client.profiles.get(pname)
        except pylxd.exceptions.LXDAPIException:
            raise SaltInvocationError(
                &quot;not all the profiles from the source exist on the target&quot;
            )

    was_running = container.status_code == CONTAINER_STATUS_RUNNING
    if stop_and_start and was_running:
        container.stop(wait=True)

    try:
        dest_container = container.migrate(dest_client, wait=True)
        dest_container.profiles = container.profiles
        dest_container.save()
    except pylxd.exceptions.LXDAPIException as e:
        raise CommandExecutionError(str(e))

    # Remove the source container
    container.delete(wait=True)

    if stop_and_start and was_running:
        dest_container.start(wait=True)

    return _pylxd_model_to_dict(dest_container)


def container_config_get(
    name, config_key, remote_addr=None, cert=None, key=None, verify_cert=True
):
    &quot;&quot;&quot;
    Get a container config value

    name :
        Name of the container

    config_key :
        The config key to retrieve

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.
    &quot;&quot;&quot;
    container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
    return _get_property_dict_item(container, &quot;config&quot;, config_key)


def container_config_set(
    name,
    config_key,
    config_value,
    remote_addr=None,
    cert=None,
    key=None,
    verify_cert=True,
):
    &quot;&quot;&quot;
    Set a container config value

    name :
        Name of the container

    config_key :
        The config key to set

    config_value :
        The config value to set

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.
    &quot;&quot;&quot;
    container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)

    return _set_property_dict_item(container, &quot;config&quot;, config_key, config_value)


def container_config_delete(
    name, config_key, remote_addr=None, cert=None, key=None, verify_cert=True
):
    &quot;&quot;&quot;
    Delete a container config value

    name :
        Name of the container

    config_key :
        The config key to delete

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.
    &quot;&quot;&quot;
    container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)

    return _delete_property_dict_item(container, &quot;config&quot;, config_key)


def container_device_get(
    name, device_name, remote_addr=None, cert=None, key=None, verify_cert=True
):
    &quot;&quot;&quot;
    Get a container device

    name :
        Name of the container

    device_name :
        The device name to retrieve

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.
    &quot;&quot;&quot;
    container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)

    return _get_property_dict_item(container, &quot;devices&quot;, device_name)


def container_device_add(
    name,
    device_name,
    device_type=&quot;disk&quot;,
    remote_addr=None,
    cert=None,
    key=None,
    verify_cert=True,
    **kwargs
):
    &quot;&quot;&quot;
    Add a container device

    name :
        Name of the container

    device_name :
        The device name to add

    device_type :
        Type of the device

    ** kwargs :
        Additional device args

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.
    &quot;&quot;&quot;
    container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)

    kwargs[&quot;type&quot;] = device_type
    return _set_property_dict_item(container, &quot;devices&quot;, device_name, kwargs)


def container_device_delete(
    name, device_name, remote_addr=None, cert=None, key=None, verify_cert=True
):
    &quot;&quot;&quot;
    Delete a container device

    name :
        Name of the container

    device_name :
        The device name to delete

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.
    &quot;&quot;&quot;
    container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)

    return _delete_property_dict_item(container, &quot;devices&quot;, device_name)


def container_file_put(
    name,
    src,
    dst,
    recursive=False,
    overwrite=False,
    mode=None,
    uid=None,
    gid=None,
    saltenv=&quot;base&quot;,
    remote_addr=None,
    cert=None,
    key=None,
    verify_cert=True,
):
    &quot;&quot;&quot;
    Put a file into a container

    name :
        Name of the container

    src :
        The source file or directory

    dst :
        The destination file or directory

    recursive :
        Decent into src directory

    overwrite :
        Replace destination if it exists

    mode :
        Set file mode to octal number

    uid :
        Set file uid (owner)

    gid :
        Set file gid (group)

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.

    CLI Example:

    .. code-block:: bash

        salt '*' lxd.container_file_put &lt;container name&gt; /var/tmp/foo /var/tmp/

    &quot;&quot;&quot;
    # Possibilities:
    #  (src, dst, dir, dir1, and dir2 are directories)
    #  cp /src/file1 /dst/file1
    #  cp /src/file1 /dst/file2
    #  cp /src/file1 /dst
    #  cp /src/file1 /dst/
    #  cp -r /src/dir /dst/
    #  cp -r /src/dir/ /dst/
    #  cp -r /src/dir1 /dst/dir2 (which is not /src/dir1 /dst/dir2/)
    #  cp -r /src/dir1 /dst/dir2/

    # Fix mode. Salt commandline doesn't use octals, so 0600 will be
    # the decimal integer 600 (and not the octal 0600). So, it it's
    # and integer, handle it as if it where a octal representation.
    mode = str(mode)
    if not mode.startswith(&quot;0&quot;):
        mode = &quot;0{}&quot;.format(mode)

    container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)

    src = os.path.expanduser(src)

    if not os.path.isabs(src):
        if src.find(&quot;://&quot;) &gt;= 0:
            cached_file = __salt__[&quot;cp.cache_file&quot;](src, saltenv=saltenv)
            if not cached_file:
                raise SaltInvocationError(&quot;File '{}' not found&quot;.format(src))
            if not os.path.isabs(cached_file):
                raise SaltInvocationError(&quot;File path must be absolute.&quot;)
            src = cached_file

    # Make sure that src doesn't end with '/', unless it's '/'
    src = src.rstrip(os.path.sep)
    if not src:
        src = os.path.sep

    if not os.path.exists(src):
        raise CommandExecutionError(&quot;No such file or directory '{}'&quot;.format(src))

    if os.path.isdir(src) and not recursive:
        raise SaltInvocationError(
            &quot;Cannot copy overwriting a directory without recursive flag set to true!&quot;
        )

    try:
        dst_is_directory = False
        container.files.get(os.path.join(dst, &quot;.&quot;))
    except pylxd.exceptions.NotFound:
        pass
    except pylxd.exceptions.LXDAPIException as why:
        if str(why).find(&quot;Is a directory&quot;) &gt;= 0:
            dst_is_directory = True

    if os.path.isfile(src):
        # Source is a file
        if dst_is_directory:
            dst = os.path.join(dst, os.path.basename(src))
            if not overwrite:
                found = True
                try:
                    container.files.get(os.path.join(dst))
                except pylxd.exceptions.NotFound:
                    found = False
                except pylxd.exceptions.LXDAPIException as why:
                    if str(why).find(&quot;not found&quot;) &gt;= 0:
                        # Old version of pylxd
                        found = False
                    else:
                        raise
                if found:
                    raise SaltInvocationError(
                        &quot;Destination exists and overwrite is false&quot;
                    )
        if mode is not None or uid is not None or gid is not None:
            # Need to get file stats
            stat = os.stat(src)
            if mode is None:
                mode = oct(stat.st_mode)
            if uid is None:
                uid = stat.st_uid
            if gid is None:
                gid = stat.st_gid

        with salt.utils.files.fopen(src, &quot;rb&quot;) as src_fp:
            container.files.put(dst, src_fp.read(), mode=mode, uid=uid, gid=gid)
        return True
    elif not os.path.isdir(src):
        raise SaltInvocationError(&quot;Source is neither file nor directory&quot;)

    # Source is a directory
    # idx for dstdir = dst + src[idx:]
    if dst.endswith(os.sep):
        idx = len(os.path.dirname(src))
    elif dst_is_directory:
        idx = len(src)
    else:
        # Destination is not a directory and doesn't end with '/'
        # Check that the parent directory of dst exists
        # and is a directory
        try:
            container.files.get(os.path.join(os.path.dirname(dst), &quot;.&quot;))
        except pylxd.exceptions.NotFound:
            pass
        except pylxd.exceptions.LXDAPIException as why:
            if str(why).find(&quot;Is a directory&quot;) &gt;= 0:
                dst_is_directory = True
                # destination is non-existent
                # cp -r /src/dir1 /scr/dir1
                # cp -r /src/dir1 /scr/dir2
                idx = len(src)
                overwrite = True

    # Copy src directory recursive
    if not overwrite:
        raise SaltInvocationError(&quot;Destination exists and overwrite is false&quot;)

    # Collect all directories first, to create them in one call
    # (for performance reasons)
    dstdirs = []
    for path, _, files in os.walk(src):
        dstdir = os.path.join(dst, path[idx:].lstrip(os.path.sep))
        dstdirs.append(dstdir)
    container.execute([&quot;mkdir&quot;, &quot;-p&quot;] + dstdirs)

    set_mode = mode
    set_uid = uid
    set_gid = gid
    # Now transfer the files
    for path, _, files in os.walk(src):
        dstdir = os.path.join(dst, path[idx:].lstrip(os.path.sep))
        for name in files:
            src_name = os.path.join(path, name)
            dst_name = os.path.join(dstdir, name)

            if mode is not None or uid is not None or gid is not None:
                # Need to get file stats
                stat = os.stat(src_name)
                if mode is None:
                    set_mode = oct(stat.st_mode)
                if uid is None:
                    set_uid = stat.st_uid
                if gid is None:
                    set_gid = stat.st_gid

            with salt.utils.files.fopen(src_name, &quot;rb&quot;) as src_fp:
                container.files.put(
                    dst_name, src_fp.read(), mode=set_mode, uid=set_uid, gid=set_gid
                )

    return True


def container_file_get(
    name,
    src,
    dst,
    overwrite=False,
    mode=None,
    uid=None,
    gid=None,
    remote_addr=None,
    cert=None,
    key=None,
    verify_cert=True,
):
    &quot;&quot;&quot;
    Get a file from a container

    name :
        Name of the container

    src :
        The source file or directory

    dst :
        The destination file or directory

    mode :
        Set file mode to octal number

    uid :
        Set file uid (owner)

    gid :
        Set file gid (group)

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.

    &quot;&quot;&quot;
    # Fix mode. Salt commandline doesn't use octals, so 0600 will be
    # the decimal integer 600 (and not the octal 0600). So, it it's
    # and integer, handle it as if it where a octal representation.

    # Do only if mode is not None, otherwise we get 0None
    if mode is not None:
        mode = str(mode)
        if not mode.startswith(&quot;0&quot;):
            mode = &quot;0{}&quot;.format(mode)

    container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)

    dst = os.path.expanduser(dst)
    if not os.path.isabs(dst):
        raise SaltInvocationError(&quot;File path must be absolute.&quot;)

    if os.path.isdir(dst):
        dst = os.path.join(dst, os.path.basename(src))
    elif not os.path.isdir(os.path.dirname(dst)):
        raise SaltInvocationError(&quot;Parent directory for destination doesn't exist.&quot;)

    if os.path.exists(dst):
        if not overwrite:
            raise SaltInvocationError(&quot;Destination exists and overwrite is false.&quot;)
        if not os.path.isfile(dst):
            raise SaltInvocationError(&quot;Destination exists but is not a file.&quot;)
    else:
        dst_path = os.path.dirname(dst)
        if not os.path.isdir(dst_path):
            raise CommandExecutionError(
                &quot;No such file or directory '{}'&quot;.format(dst_path)
            )
        # Seems to be duplicate of line 1794, produces /path/file_name/file_name
        # dst = os.path.join(dst, os.path.basename(src))

    with salt.utils.files.fopen(dst, &quot;wb&quot;) as df:
        df.write(container.files.get(src))

    if mode:
        os.chmod(dst, mode)
    if uid or uid == &quot;0&quot;:
        uid = int(uid)
    else:
        uid = -1
    if gid or gid == &quot;0&quot;:
<A NAME="0"></A>        gid = int(gid)
    else:
        gid = -1
    <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match175810-0.html#0',2,'match175810-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>if uid != -1 or gid != -1:
        os.chown(dst, uid, gid)
    return True


def container_execute(
    name, cmd, remote_addr=None, cert=None, key=None, verify_cert=True
):
    &quot;&quot;&quot;
    Execute a command list on a container.

    name :
        Name of the container

    cmd :
        Command to be executed (as a list)

        Example :
            '[&quot;ls&quot;, &quot;-l&quot;]'

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.

    CLI Example:

    .. code-block:: bash

        salt '*' lxd.container_execute &lt;container name&gt; '[&quot;ls&quot;, &quot;-l&quot;]'

    &quot;&quot;&quot;
    container = container_get(name, remote_addr, cert, key, verify_cert, _raw=</B></FONT>True)
    try:
        result = container.execute(cmd)
        saltresult = {}
        if not hasattr(result, &quot;exit_code&quot;):
            saltresult = dict(
                exit_code=0,
                stdout=result[0],
                stderr=result[1],
            )
        else:
            saltresult = dict(
                exit_code=result.exit_code,
                stdout=result.stdout,
                stderr=result.stderr,
            )
    except pylxd.exceptions.NotFound as e:
        # TODO: Using exit_code 0 here is not always right,
        # in the most cases the command worked ok though.
        # See: https://github.com/lxc/pylxd/issues/280
        saltresult = dict(exit_code=0, stdout=&quot;&quot;, stderr=str(e))

    if int(saltresult[&quot;exit_code&quot;]) &gt; 0:
        saltresult[&quot;result&quot;] = False
    else:
        saltresult[&quot;result&quot;] = True

    return saltresult


####################
# Profile Management
####################
def profile_list(
    list_names=False, remote_addr=None, cert=None, key=None, verify_cert=True
):
    &quot;&quot;&quot;Lists all profiles from the LXD.

    list_names :

        Return a list of names instead of full blown dicts.

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.

    CLI Examples:

    .. code-block:: bash

        salt '*' lxd.profile_list true --out=json
        salt '*' lxd.profile_list --out=json
    &quot;&quot;&quot;

    client = pylxd_client_get(remote_addr, cert, key, verify_cert)

    profiles = client.profiles.all()
    if list_names:
        return [p.name for p in profiles]

    return map(_pylxd_model_to_dict, profiles)


def profile_create(
    name,
    config=None,
    devices=None,
    description=None,
    remote_addr=None,
    cert=None,
    key=None,
    verify_cert=True,
):
    &quot;&quot;&quot;Creates a profile.

    name :
        The name of the profile to get.

    config :
        A config dict or None (None = unset).

        Can also be a list:
            [{'key': 'boot.autostart', 'value': 1},
             {'key': 'security.privileged', 'value': '1'}]

    devices :
        A device dict or None (None = unset).

    description :
        A description string or None (None = unset).

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.

    CLI Examples:

    .. code-block:: bash

        salt '*' lxd.profile_create autostart config=&quot;{boot.autostart: 1, boot.autostart.delay: 2, boot.autostart.priority: 1}&quot;
        salt '*' lxd.profile_create shared_mounts devices=&quot;{shared_mount: {type: 'disk', source: '/home/shared', path: '/home/shared'}}&quot;

    See the `lxd-docs`_ for the details about the config and devices dicts.

    .. _lxd-docs: https://github.com/lxc/lxd/blob/master/doc/rest-api.md#post-10
    &quot;&quot;&quot;
    client = pylxd_client_get(remote_addr, cert, key, verify_cert)

    config, devices = normalize_input_values(config, devices)

    try:
        profile = client.profiles.create(name, config, devices)
    except pylxd.exceptions.LXDAPIException as e:
        raise CommandExecutionError(str(e))

    if description is not None:
        profile.description = description
        pylxd_save_object(profile)

    return _pylxd_model_to_dict(profile)


def profile_get(
    name, remote_addr=None, cert=None, key=None, verify_cert=True, _raw=False
):
    &quot;&quot;&quot;Gets a profile from the LXD

    name :
        The name of the profile to get.

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.

    _raw :
        Return the pylxd object, this is internal and by states in use.

    CLI Examples:

    .. code-block:: bash

        salt '*' lxd.profile_get autostart
    &quot;&quot;&quot;
    client = pylxd_client_get(remote_addr, cert, key, verify_cert)

    profile = None
    try:
        profile = client.profiles.get(name)
    except pylxd.exceptions.LXDAPIException:
        raise SaltInvocationError(&quot;Profile '{}' not found&quot;.format(name))

    if _raw:
        return profile

    return _pylxd_model_to_dict(profile)


def profile_delete(name, remote_addr=None, cert=None, key=None, verify_cert=True):
    &quot;&quot;&quot;Deletes a profile.

    name :
        The name of the profile to delete.

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.

    CLI Example:

    .. code-block:: bash

        salt '*' lxd.profile_delete shared_mounts
<A NAME="1"></A>    &quot;&quot;&quot;
    profile = profile_get(name, remote_addr, cert, key, verify_cert, _raw=True)

    profile<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match175810-0.html#1',2,'match175810-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.delete()
    return True


def profile_config_get(
    name, config_key, remote_addr=None, cert=None, key=None, verify_cert=True
):
    &quot;&quot;&quot;Get a profile config item.

    name :
        The name of the profile to get the config item from.

    config_key :
        The key for the item to retrieve.

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.

    CLI Example:

    .. code-block:: bash

        salt '*' lxd.profile_config_get autostart boot.autostart
    &quot;&quot;&quot;
    profile = profile_get(name, remote_addr, cert, key, verify_cert, _raw=</B></FONT>True)

    return _get_property_dict_item(profile, &quot;config&quot;, config_key)


def profile_config_set(
    name,
    config_key,
    config_value,
    remote_addr=None,
    cert=None,
    key=None,
    verify_cert=True,
):
    &quot;&quot;&quot;Set a profile config item.

    name :
        The name of the profile to set the config item to.

    config_key :
        The items key.

    config_value :
        Its items value.

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.

    CLI Example:

    .. code-block:: bash

        salt '*' lxd.profile_config_set autostart boot.autostart 0
    &quot;&quot;&quot;
    profile = profile_get(name, remote_addr, cert, key, verify_cert, _raw=True)

    return _set_property_dict_item(profile, &quot;config&quot;, config_key, config_value)


def profile_config_delete(
    name, config_key, remote_addr=None, cert=None, key=None, verify_cert=True
):
    &quot;&quot;&quot;Delete a profile config item.

    name :
        The name of the profile to delete the config item.

    config_key :
        The config key for the value to retrieve.

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.

    CLI Example:

    .. code-block:: bash

        salt '*' lxd.profile_config_delete autostart boot.autostart.delay
    &quot;&quot;&quot;
    profile = profile_get(name, remote_addr, cert, key, verify_cert, _raw=True)

    return _delete_property_dict_item(profile, &quot;config&quot;, config_key)


def profile_device_get(
    name, device_name, remote_addr=None, cert=None, key=None, verify_cert=True
):
    &quot;&quot;&quot;Get a profile device.

    name :
        The name of the profile to get the device from.

    device_name :
        The name of the device to retrieve.

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.

    CLI Example:

    .. code-block:: bash

        salt '*' lxd.profile_device_get default eth0
    &quot;&quot;&quot;
    profile = profile_get(name, remote_addr, cert, key, verify_cert, _raw=True)

    return _get_property_dict_item(profile, &quot;devices&quot;, device_name)


def profile_device_set(
    name,
    device_name,
    device_type=&quot;disk&quot;,
    remote_addr=None,
    cert=None,
    key=None,
    verify_cert=True,
    **kwargs
):
    &quot;&quot;&quot;Set a profile device.

    name :
        The name of the profile to set the device to.

    device_name :
        The name of the device to set.

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.

    CLI Example:

    .. code-block:: bash

        salt '*' lxd.profile_device_set autostart eth1 nic nictype=bridged parent=lxdbr0
    &quot;&quot;&quot;
    profile = profile_get(name, remote_addr, cert, key, verify_cert, _raw=True)

    kwargs[&quot;type&quot;] = device_type

    for k, v in kwargs.items():
        kwargs[k] = str(v)

    return _set_property_dict_item(profile, &quot;devices&quot;, device_name, kwargs)


def profile_device_delete(
    name, device_name, remote_addr=None, cert=None, key=None, verify_cert=True
):
    &quot;&quot;&quot;Delete a profile device.

    name :
        The name of the profile to delete the device.

    device_name :
        The name of the device to delete.

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.

    CLI Example:

    .. code-block:: bash

        salt '*' lxd.profile_device_delete autostart eth1

    &quot;&quot;&quot;
    profile = profile_get(name, remote_addr, cert, key, verify_cert, _raw=True)

    return _delete_property_dict_item(profile, &quot;devices&quot;, device_name)


##################
# Image Management
##################
def image_list(
    list_aliases=False, remote_addr=None, cert=None, key=None, verify_cert=True
):
    &quot;&quot;&quot;Lists all images from the LXD.

    list_aliases :

        Return a dict with the fingerprint as key and
        a list of aliases as value instead.

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.

    CLI Examples:

    .. code-block:: bash

        salt '*' lxd.image_list true --out=json
        salt '*' lxd.image_list --out=json
    &quot;&quot;&quot;
    client = pylxd_client_get(remote_addr, cert, key, verify_cert)

    images = client.images.all()
    if list_aliases:
        return {i.fingerprint: [a[&quot;name&quot;] for a in i.aliases] for i in images}

    return map(_pylxd_model_to_dict, images)


def image_get(
    fingerprint, remote_addr=None, cert=None, key=None, verify_cert=True, _raw=False
):
    &quot;&quot;&quot;Get an image by its fingerprint

    fingerprint :
        The fingerprint of the image to retrieve

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.

    _raw : False
        Return the raw pylxd object or a dict of it?

    CLI Examples:

    .. code-block:: bash

        salt '*' lxd.image_get &lt;fingerprint&gt;
    &quot;&quot;&quot;
    client = pylxd_client_get(remote_addr, cert, key, verify_cert)

    image = None
    try:
        image = client.images.get(fingerprint)
    except pylxd.exceptions.LXDAPIException:
        raise SaltInvocationError(
            &quot;Image with fingerprint '{}' not found&quot;.format(fingerprint)
        )

    if _raw:
        return image

    return _pylxd_model_to_dict(image)


def image_get_by_alias(
    alias, remote_addr=None, cert=None, key=None, verify_cert=True, _raw=False
):
    &quot;&quot;&quot;Get an image by an alias

    alias :
        The alias of the image to retrieve

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.

    _raw : False
        Return the raw pylxd object or a dict of it?

    CLI Examples:

    .. code-block:: bash

        salt '*' lxd.image_get_by_alias xenial/amd64
    &quot;&quot;&quot;
    client = pylxd_client_get(remote_addr, cert, key, verify_cert)

    image = None
    try:
        image = client.images.get_by_alias(alias)
    except pylxd.exceptions.LXDAPIException:
        raise SaltInvocationError(&quot;Image with alias '{}' not found&quot;.format(alias))

    if _raw:
        return image

    return _pylxd_model_to_dict(image)


def image_delete(image, remote_addr=None, cert=None, key=None, verify_cert=True):
    &quot;&quot;&quot;Delete an image by an alias or fingerprint

    name :
        The alias or fingerprint of the image to delete,
        can be a obj for the states.

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.

    CLI Examples:

    .. code-block:: bash

        salt '*' lxd.image_delete xenial/amd64
    &quot;&quot;&quot;

    image = _verify_image(image, remote_addr, cert, key, verify_cert)

    image.delete()
    return True


def image_from_simplestreams(
    server,
    alias,
    remote_addr=None,
    cert=None,
    key=None,
    verify_cert=True,
    aliases=None,
    public=False,
    auto_update=False,
    _raw=False,
):
    &quot;&quot;&quot;Create an image from simplestreams

    server :
        Simplestreams server URI

    alias :
        The alias of the image to retrieve

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.

    aliases : []
        List of aliases to append to the copied image

    public : False
        Make this image public available

    auto_update : False
        Should LXD auto update that image?

    _raw : False
        Return the raw pylxd object or a dict of the image?

    CLI Examples:

    .. code-block:: bash

        salt '*' lxd.image_from_simplestreams &quot;https://cloud-images.ubuntu.com/releases&quot; &quot;trusty/amd64&quot; aliases='[&quot;t&quot;, &quot;trusty/amd64&quot;]' auto_update=True
    &quot;&quot;&quot;
    if aliases is None:
        aliases = []

    client = pylxd_client_get(remote_addr, cert, key, verify_cert)

    try:
        image = client.images.create_from_simplestreams(
            server, alias, public=public, auto_update=auto_update
        )
    except pylxd.exceptions.LXDAPIException as e:
        raise CommandExecutionError(str(e))

    # Aliases support
    for alias in aliases:
        image_alias_add(image, alias)

    if _raw:
        return image

    return _pylxd_model_to_dict(image)


def image_from_url(
    url,
    remote_addr=None,
    cert=None,
    key=None,
    verify_cert=True,
    aliases=None,
    public=False,
    auto_update=False,
    _raw=False,
):
    &quot;&quot;&quot;Create an image from an url

    url :
        The URL from where to download the image

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.

    aliases : []
        List of aliases to append to the copied image

    public : False
        Make this image public available

    auto_update : False
        Should LXD auto update that image?

    _raw : False
        Return the raw pylxd object or a dict of the image?

    CLI Examples:

    .. code-block:: bash

        salt '*' lxd.image_from_url https://dl.stgraber.org/lxd aliases='[&quot;busybox-amd64&quot;]'
    &quot;&quot;&quot;
    if aliases is None:
        aliases = []

    client = pylxd_client_get(remote_addr, cert, key, verify_cert)

    try:
        image = client.images.create_from_url(
            url, public=public, auto_update=auto_update
        )
    except pylxd.exceptions.LXDAPIException as e:
        raise CommandExecutionError(str(e))

    # Aliases support
    for alias in aliases:
        image_alias_add(image, alias)

    if _raw:
        return image

    return _pylxd_model_to_dict(image)


def image_from_file(
    filename,
    remote_addr=None,
    cert=None,
    key=None,
    verify_cert=True,
    aliases=None,
    public=False,
    saltenv=&quot;base&quot;,
    _raw=False,
):
    &quot;&quot;&quot;Create an image from a file

    filename :
        The filename of the rootfs

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.

    aliases : []
        List of aliases to append to the copied image

    public : False
        Make this image public available

    saltenv : base
        The saltenv to use for salt:// copies

    _raw : False
        Return the raw pylxd object or a dict of the image?

    CLI Examples:

    .. code-block:: bash

        salt '*' lxd.image_from_file salt://lxd/files/busybox.tar.xz aliases=[&quot;busybox-amd64&quot;]
    &quot;&quot;&quot;
    if aliases is None:
        aliases = []

    cached_file = __salt__[&quot;cp.cache_file&quot;](filename, saltenv=saltenv)
    data = b&quot;&quot;
    with salt.utils.files.fopen(cached_file, &quot;r+b&quot;) as fp:
        data = fp.read()

    client = pylxd_client_get(remote_addr, cert, key, verify_cert)

    try:
        image = client.images.create(data, public=public, wait=True)
    except pylxd.exceptions.LXDAPIException as e:
        raise CommandExecutionError(str(e))

    # Aliases support
    for alias in aliases:
        image_alias_add(image, alias)

    if _raw:
        return image

    return _pylxd_model_to_dict(image)


def image_copy_lxd(
    source,
    src_remote_addr,
    src_cert,
    src_key,
    src_verify_cert,
    remote_addr,
    cert,
    key,
    verify_cert=True,
    aliases=None,
    public=None,
    auto_update=None,
    _raw=False,
):
    &quot;&quot;&quot;Copy an image from another LXD instance

    source :
        An alias or a fingerprint of the source.

    src_remote_addr :
        An URL to the source remote daemon

        Examples:
            https://mysourceserver.lan:8443

    src_cert :
        PEM Formatted SSL Certificate for the source

        Examples:
            ~/.config/lxc/client.crt

    src_key :
        PEM Formatted SSL Key for the source

        Examples:
            ~/.config/lxc/client.key

    src_verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.

    remote_addr :
        Address of the destination daemon

        Examples:
            https://mydestserver.lan:8443

    cert :
        PEM Formatted SSL Certificate for the destination

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key for the destination

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.

    aliases : []
        List of aliases to append to the copied image

    public : None
        Make this image public available, None = copy source

    auto_update : None
        Wherever to auto-update from the original source, None = copy source

    _raw : False
        Return the raw pylxd object or a dict of the destination image?

    CLI Examples:

    .. code-block:: bash

        salt '*' lxd.image_copy_lxd xenial/amd64 https://srv01:8443 ~/.config/lxc/client.crt ~/.config/lxc/client.key false https://srv02:8443 ~/.config/lxc/client.crt ~/.config/lxc/client.key false aliases=&quot;['xenial/amd64']&quot;
    &quot;&quot;&quot;
    if aliases is None:
        aliases = []

    log.debug(
        'Trying to copy the image &quot;%s&quot; from &quot;%s&quot; to &quot;%s&quot;',
        source,
        src_remote_addr,
        remote_addr,
    )

    # This will fail with a SaltInvocationError if
    # the image doesn't exists on the source and with a CommandExecutionError
    # on connection problems.
    src_image = None
    try:
        src_image = image_get_by_alias(
            source, src_remote_addr, src_cert, src_key, src_verify_cert, _raw=True
        )
    except SaltInvocationError:
        src_image = image_get(
            source, src_remote_addr, src_cert, src_key, src_verify_cert, _raw=True
        )

    # Will fail with a CommandExecutionError on connection problems.
    dest_client = pylxd_client_get(remote_addr, cert, key, verify_cert)

    dest_image = src_image.copy(
        dest_client, public=public, auto_update=auto_update, wait=True
    )

    # Aliases support
    for alias in aliases:
        image_alias_add(dest_image, alias)

    if _raw:
        return dest_image

    return _pylxd_model_to_dict(dest_image)


def image_alias_add(
    image,
    alias,
    description=&quot;&quot;,
    remote_addr=None,
    cert=None,
    key=None,
    verify_cert=True,
):
    &quot;&quot;&quot;Create an alias on the given image

    image :
        An image alias, a fingerprint or a image object

    alias :
        The alias to add

    description :
        Description of the alias

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.

    CLI Examples:

    .. code-block:: bash

        salt '*' lxd.image_alias_add xenial/amd64 x &quot;Short version of xenial/amd64&quot;
    &quot;&quot;&quot;
    image = _verify_image(image, remote_addr, cert, key, verify_cert)

    for alias_info in image.aliases:
        if alias_info[&quot;name&quot;] == alias:
            return True
    image.add_alias(alias, description)

    return True


def image_alias_delete(
    image, alias, remote_addr=None, cert=None, key=None, verify_cert=True
):
    &quot;&quot;&quot;Delete an alias (this is currently not restricted to the image)

    image :
        An image alias, a fingerprint or a image object

    alias :
        The alias to delete

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if
        you provide remote_addr and its a TCP Address!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.

    CLI Examples:

    .. code-block:: bash

        salt '*' lxd.image_alias_add xenial/amd64 x &quot;Short version of xenial/amd64&quot;
    &quot;&quot;&quot;
    image = _verify_image(image, remote_addr, cert, key, verify_cert)

    try:
        image.delete_alias(alias)
    except pylxd.exceptions.LXDAPIException:
        return False

    return True


#####################
# Snapshot Management
#####################


def snapshots_all(container, remote_addr=None, cert=None, key=None, verify_cert=True):
    &quot;&quot;&quot;
    Get all snapshots for a container

    container :
        The name of the container to get.

    remote_addr :
        An URL to a remote server. The 'cert' and 'key' fields must also be
        provided if 'remote_addr' is defined.

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Verify the ssl certificate.  Default: True

    CLI Examples:

    .. code-block:: bash

        salt '*' lxd.snapshots_all test-container
    &quot;&quot;&quot;
    containers = container_get(
        container, remote_addr, cert, key, verify_cert, _raw=True
    )
    if container:
        containers = [containers]
    ret = {}
    for cont in containers:
        ret.update({cont.name: [{&quot;name&quot;: c.name} for c in cont.snapshots.all()]})

    return ret


def snapshots_create(
    container, name=None, remote_addr=None, cert=None, key=None, verify_cert=True
):
    &quot;&quot;&quot;
    Create a snapshot for a container

    container :
        The name of the container to get.

    name :
        The name of the snapshot.

    remote_addr :
        An URL to a remote server. The 'cert' and 'key' fields must also be
        provided if 'remote_addr' is defined.

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Verify the ssl certificate.  Default: True

    CLI Examples:

    .. code-block:: bash

        salt '*' lxd.snapshots_create test-container test-snapshot
    &quot;&quot;&quot;
    cont = container_get(container, remote_addr, cert, key, verify_cert, _raw=True)
    if not name:
        name = datetime.now().strftime(&quot;%Y%m%d%H%M%S&quot;)

    cont.snapshots.create(name)

    for c in snapshots_all(container).get(container):
        if c.get(&quot;name&quot;) == name:
            return {&quot;name&quot;: name}

    return {&quot;name&quot;: False}


def snapshots_delete(
    container, name, remote_addr=None, cert=None, key=None, verify_cert=True
):
    &quot;&quot;&quot;
    Delete a snapshot for a container

    container :
        The name of the container to get.

    name :
        The name of the snapshot.

    remote_addr :
        An URL to a remote server. The 'cert' and 'key' fields must also be
        provided if 'remote_addr' is defined.

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Verify the ssl certificate.  Default: True

    CLI Examples:

    .. code-block:: bash

        salt '*' lxd.snapshots_delete test-container test-snapshot
    &quot;&quot;&quot;
    cont = container_get(container, remote_addr, cert, key, verify_cert, _raw=True)

    try:
        for s in cont.snapshots.all():
            if s.name == name:
                s.delete()
                return True
    except pylxd.exceptions.LXDAPIException:
        pass

    return False


def snapshots_get(
    container, name, remote_addr=None, cert=None, key=None, verify_cert=True
):
    &quot;&quot;&quot;
    Get information about snapshot for a container

    container :
        The name of the container to get.

    name :
        The name of the snapshot.

    remote_addr :
        An URL to a remote server. The 'cert' and 'key' fields must also be
        provided if 'remote_addr' is defined.

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Certificate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Verify the ssl certificate.  Default: True

    CLI Examples:

    .. code-block:: bash

        salt '*' lxd.snapshots_get test-container test-snapshot
    &quot;&quot;&quot;
    container = container_get(container, remote_addr, cert, key, verify_cert, _raw=True)
    return container.snapshots.get(name)


################
# Helper Methods
################


def normalize_input_values(config, devices):
    &quot;&quot;&quot;
    normalize config input so returns can be put into mongodb, which doesn't like `.`

    This is not meant to be used on the commandline.

    CLI Examples:

    .. code-block:: bash

        salt '*' lxd.normalize_input_values config={} devices={}
    &quot;&quot;&quot;
    if isinstance(config, list):
        if config and &quot;key&quot; in config[0] and &quot;value&quot; in config[0]:
            config = {d[&quot;key&quot;]: d[&quot;value&quot;] for d in config}
        else:
            config = {}

    if isinstance(config, str):
        raise SaltInvocationError(&quot;config can't be a string, validate your YAML input.&quot;)

    if isinstance(devices, str):
        raise SaltInvocationError(
            &quot;devices can't be a string, validate your YAML input.&quot;
        )

    # Golangs wants strings
    if config is not None:
        for k, v in config.items():
            config[k] = str(v)
    if devices is not None:
        for dn in devices:
            for k, v in devices[dn].items():
                devices[dn][k] = v

    return (
        config,
        devices,
    )


def sync_config_devices(obj, newconfig, newdevices, test=False):
    &quot;&quot;&quot;Syncs the given config and devices with the object
    (a profile or a container)
    returns a changes dict with all changes made.

    obj :
        The object to sync with / or just test with.

    newconfig:
        The new config to check with the obj.

    newdevices:
        The new devices to check with the obj.

    test:
        Wherever to not change anything and give &quot;Would change&quot; message.
    &quot;&quot;&quot;
    changes = {}

    #
    # config changes
    #
    if newconfig is None:
        newconfig = {}

    newconfig = dict(
        list(zip(map(str, newconfig.keys()), map(str, newconfig.values())))
    )
    cck = set(newconfig.keys())

    obj.config = dict(
        list(zip(map(str, obj.config.keys()), map(str, obj.config.values())))
    )
    ock = set(obj.config.keys())

    config_changes = {}
    # Removed keys
    for k in ock.difference(cck):
        # Ignore LXD internals.
        if k.startswith(&quot;volatile.&quot;) or k.startswith(&quot;image.&quot;):
            continue

        if not test:
            config_changes[k] = 'Removed config key &quot;{}&quot;, its value was &quot;{}&quot;'.format(
                k, obj.config[k]
            )
            del obj.config[k]
        else:
            config_changes[k] = 'Would remove config key &quot;{} with value &quot;{}&quot;'.format(
                k, obj.config[k]
            )

    # same keys
    for k in cck.intersection(ock):
        # Ignore LXD internals.
        if k.startswith(&quot;volatile.&quot;) or k.startswith(&quot;image.&quot;):
            continue

        if newconfig[k] != obj.config[k]:
            if not test:
                config_changes[
                    k
                ] = 'Changed config key &quot;{}&quot; to &quot;{}&quot;, its value was &quot;{}&quot;'.format(
                    k, newconfig[k], obj.config[k]
                )
                obj.config[k] = newconfig[k]
            else:
                config_changes[
                    k
                ] = 'Would change config key &quot;{}&quot; to &quot;{}&quot;, its current value is &quot;{}&quot;'.format(
                    k, newconfig[k], obj.config[k]
                )

    # New keys
    for k in cck.difference(ock):
        # Ignore LXD internals.
        if k.startswith(&quot;volatile.&quot;) or k.startswith(&quot;image.&quot;):
            continue

        if not test:
            config_changes[k] = 'Added config key &quot;{}&quot; = &quot;{}&quot;'.format(k, newconfig[k])
            obj.config[k] = newconfig[k]
        else:
            config_changes[k] = 'Would add config key &quot;{}&quot; = &quot;{}&quot;'.format(
                k, newconfig[k]
            )

    if config_changes:
        changes[&quot;config&quot;] = config_changes

    #
    # devices changes
    #
    if newdevices is None:
        newdevices = {}

    dk = set(obj.devices.keys())
    ndk = set(newdevices.keys())

    devices_changes = {}
    # Removed devices
    for k in dk.difference(ndk):
        # Ignore LXD internals.
        if k == &quot;root&quot;:
            continue

        if not test:
            devices_changes[k] = 'Removed device &quot;{}&quot;'.format(k)
            del obj.devices[k]
        else:
            devices_changes[k] = 'Would remove device &quot;{}&quot;'.format(k)

    # Changed devices
    for k, v in obj.devices.items():
        # Ignore LXD internals also for new devices.
        if k == &quot;root&quot;:
            continue

        if k not in newdevices:
            # In test mode we don't delete devices above.
            continue

        if newdevices[k] != v:
            if not test:
                devices_changes[k] = 'Changed device &quot;{}&quot;'.format(k)
                obj.devices[k] = newdevices[k]
            else:
                devices_changes[k] = 'Would change device &quot;{}&quot;'.format(k)

    # New devices
    for k in ndk.difference(dk):
        # Ignore LXD internals.
        if k == &quot;root&quot;:
            continue

        if not test:
            devices_changes[k] = 'Added device &quot;{}&quot;'.format(k)
            obj.devices[k] = newdevices[k]
        else:
            devices_changes[k] = 'Would add device &quot;{}&quot;'.format(k)

    if devices_changes:
        changes[&quot;devices&quot;] = devices_changes

    return changes


def _set_property_dict_item(obj, prop, key, value):
    &quot;&quot;&quot;Sets the dict item key of the attr from obj.

    Basicaly it does getattr(obj, prop)[key] = value.


    For the disk device we added some checks to make
    device changes on the CLI saver.
    &quot;&quot;&quot;
    attr = getattr(obj, prop)
    if prop == &quot;devices&quot;:
        device_type = value[&quot;type&quot;]

        if device_type == &quot;disk&quot;:

            if &quot;path&quot; not in value:
                raise SaltInvocationError(&quot;path must be given as parameter&quot;)

            if value[&quot;path&quot;] != &quot;/&quot; and &quot;source&quot; not in value:
                raise SaltInvocationError(&quot;source must be given as parameter&quot;)

        for k in value.keys():
            if k.startswith(&quot;__&quot;):
                del value[k]

        attr[key] = value

    else:  # config
        attr[key] = str(value)

    pylxd_save_object(obj)

    return _pylxd_model_to_dict(obj)


def _get_property_dict_item(obj, prop, key):
    attr = getattr(obj, prop)
    if key not in attr:
        raise SaltInvocationError(&quot;'{}' doesn't exists&quot;.format(key))

    return attr[key]


def _delete_property_dict_item(obj, prop, key):
    attr = getattr(obj, prop)
    if key not in attr:
        raise SaltInvocationError(&quot;'{}' doesn't exists&quot;.format(key))

    del attr[key]
    pylxd_save_object(obj)

    return True


def _verify_image(image, remote_addr=None, cert=None, key=None, verify_cert=True):
    # Get image by alias/fingerprint or check for fingerprint attribute
    if isinstance(image, str):
        name = image

        # This will fail with a SaltInvocationError if
        # the image doesn't exists on the source and with a
        # CommandExecutionError on connection problems.
        image = None
        try:
            image = image_get_by_alias(
                name, remote_addr, cert, key, verify_cert, _raw=True
            )
        except SaltInvocationError:
            image = image_get(name, remote_addr, cert, key, verify_cert, _raw=True)
    elif not hasattr(image, &quot;fingerprint&quot;):
        raise SaltInvocationError(&quot;Invalid image '{}'&quot;.format(image))
    return image


def _pylxd_model_to_dict(obj):
    &quot;&quot;&quot;Translates a plyxd model object to a dict&quot;&quot;&quot;
    marshalled = {}
    for key in obj.__attributes__.keys():
        if hasattr(obj, key):
            marshalled[key] = getattr(obj, key)
    return marshalled


#
# Monkey patching for missing functionality in pylxd
#

if HAS_PYLXD:
    import pylxd.exceptions  # NOQA

    if not hasattr(pylxd.exceptions, &quot;NotFound&quot;):
        # Old version of pylxd

        class NotFound(pylxd.exceptions.LXDAPIException):
            &quot;&quot;&quot;An exception raised when an object is not found.&quot;&quot;&quot;

        pylxd.exceptions.NotFound = NotFound

    try:
        from pylxd.container import Container
    except ImportError:
        from pylxd.models.container import Container

    class FilesManager(Container.FilesManager):
        def put(self, filepath, data, mode=None, uid=None, gid=None):
            headers = {}
            if mode is not None:
                if isinstance(mode, int):
                    mode = oct(mode)
                elif not mode.startswith(&quot;0&quot;):
                    mode = &quot;0{}&quot;.format(mode)
                headers[&quot;X-LXD-mode&quot;] = mode
            if uid is not None:
                headers[&quot;X-LXD-uid&quot;] = str(uid)
            if gid is not None:
                headers[&quot;X-LXD-gid&quot;] = str(gid)
            response = self._client.api.containers[self._container.name].files.post(
                params={&quot;path&quot;: filepath}, data=data, headers=headers
            )
            return response.status_code == 200

    Container.FilesManager = FilesManager
</PRE>
</div>
  </div>
</body>
</html>
