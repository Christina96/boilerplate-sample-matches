<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for boto3_sns_1.py &amp; lxd_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for boto3_sns_1.py &amp; lxd_1.py
      </h3>
<h1 align="center">
        1.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>boto3_sns_1.py (5.6034484%)<th>lxd_1.py (1.1882998%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(69-84)<td><a href="#" name="0">(1810-1862)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(162-176)<td><a href="#" name="1">(2121-2167)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto3_sns_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import salt.utils.versions
3 log = logging.getLogger(__name__)
4 try:
5     import botocore
6     import boto3
7     import jmespath
8     logging.getLogger("boto3").setLevel(logging.CRITICAL)
9     HAS_BOTO = True
10 except ImportError:
11     HAS_BOTO = False
12 def __virtual__():
13     has_boto_reqs = salt.utils.versions.check_boto_reqs()
14     <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>if has_boto_reqs is True:
15         __utils__["boto3.assign_funcs"](__name__, "sns")
16     return has_boto_reqs
17 def list_topics(region=None, key=None, keyid=None, profile=None):
18     conn = _get_conn(region=</b></font>region, key=key, keyid=keyid, profile=profile)
19     res = {}
20     NextToken = ""
21     while NextToken is not None:
22         ret = conn.list_topics(NextToken=NextToken)
23         NextToken = ret.get("NextToken", None)
24         arns = jmespath.search("Topics[*].TopicArn", ret)
25         for t in arns:
26             short_name = t.split(":")[-1]
27             res[short_name] = t
28     return res
29 def describe_topic(name, region=None, key=None, keyid=None, profile=None):
30     topics = list_topics(region=region, key=key, keyid=keyid, profile=profile)
31     ret = {}
32     for topic, arn in topics.items():
33         if name in (topic, arn):
34             ret = {"TopicArn": arn}
35             ret["Subscriptions"] = list_subscriptions_by_topic(
36                 arn, region=region, key=key, keyid=keyid, profile=profile
37             )
38             ret["Attributes"] = get_topic_attributes(
39                 arn, region=region, key=key, keyid=keyid, profile=profile
40             )
41             for sub in ret["Subscriptions"]:
42                 sub_arn = sub["SubscriptionArn"]
43                 if not sub_arn.startswith("arn:aws:sns:"):
44                     log.debug("Subscription with invalid ARN %s skipped...", sub_arn)
45                     continue
46     return ret
47 def topic_exists(name, region=None, key=None, keyid=None, profile=None):
48     topics = list_topics(region=region, key=key, keyid=keyid, profile=profile)
49     return name in list(topics.values() + topics.keys())
50 def create_topic(Name, region=None, key=None, keyid=None, profile=None):
51     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
52     try:
53         ret = conn.create_topic(Name=Name)
54         log.info("SNS topic %s created with ARN %s", Name, ret["TopicArn"])
55         return ret["TopicArn"]
56     except botocore.exceptions.ClientError as e:
57 <a name="1"></a>        log.error("Failed to create SNS topic %s: %s", Name, e)
58         return None
59     except KeyError:
60         log<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.error("Failed to create SNS topic %s", Name)
61         return None
62 def delete_topic(TopicArn, region=None, key=None, keyid=None, profile=None):
63     conn = _get_conn(region=</b></font>region, key=key, keyid=keyid, profile=profile)
64     try:
65         conn.delete_topic(TopicArn=TopicArn)
66         log.info("SNS topic %s deleted", TopicArn)
67         return True
68     except botocore.exceptions.ClientError as e:
69         log.error("Failed to delete SNS topic %s: %s", name, e)
70         return False
71 def get_topic_attributes(TopicArn, region=None, key=None, keyid=None, profile=None):
72     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
73     try:
74         return conn.get_topic_attributes(TopicArn=TopicArn).get("Attributes")
75     except botocore.exceptions.ClientError as e:
76         log.error("Failed to garner attributes for SNS topic %s: %s", TopicArn, e)
77         return None
78 def set_topic_attributes(
79     TopicArn,
80     AttributeName,
81     AttributeValue,
82     region=None,
83     key=None,
84     keyid=None,
85     profile=None,
86 ):
87     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
88     try:
89         conn.set_topic_attributes(
90             TopicArn=TopicArn,
91             AttributeName=AttributeName,
92             AttributeValue=AttributeValue,
93         )
94         log.debug(
95             "Set attribute %s=%s on SNS topic %s",
96             AttributeName,
97             AttributeValue,
98             TopicArn,
99         )
100         return True
101     except botocore.exceptions.ClientError as e:
102         log.error(
103             "Failed to set attribute %s=%s for SNS topic %s: %s",
104             AttributeName,
105             AttributeValue,
106             TopicArn,
107             e,
108         )
109         return False
110 def list_subscriptions_by_topic(
111     TopicArn, region=None, key=None, keyid=None, profile=None
112 ):
113     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
114     NextToken = ""
115     res = []
116     try:
117         while NextToken is not None:
118             ret = conn.list_subscriptions_by_topic(
119                 TopicArn=TopicArn, NextToken=NextToken
120             )
121             NextToken = ret.get("NextToken", None)
122             subs = ret.get("Subscriptions", [])
123             res += subs
124     except botocore.exceptions.ClientError as e:
125         log.error("Failed to list subscriptions for SNS topic %s: %s", TopicArn, e)
126         return None
127     return res
128 def list_subscriptions(region=None, key=None, keyid=None, profile=None):
129     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
130     NextToken = ""
131     res = []
132     try:
133         while NextToken is not None:
134             ret = conn.list_subscriptions(NextToken=NextToken)
135             NextToken = ret.get("NextToken", None)
136             subs = ret.get("Subscriptions", [])
137             res += subs
138     except botocore.exceptions.ClientError as e:
139         log.error("Failed to list SNS subscriptions: %s", e)
140         return None
141     return res
142 def get_subscription_attributes(
143     SubscriptionArn, region=None, key=None, keyid=None, profile=None
144 ):
145     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
146     try:
147         ret = conn.get_subscription_attributes(SubscriptionArn=SubscriptionArn)
148         return ret["Attributes"]
149     except botocore.exceptions.ClientError as e:
150         log.error(
151             "Failed to list attributes for SNS subscription %s: %s", SubscriptionArn, e
152         )
153         return None
154     except KeyError:
155         log.error("Failed to list attributes for SNS subscription %s", SubscriptionArn)
156         return None
157 def set_subscription_attributes(
158     SubscriptionArn,
159     AttributeName,
160     AttributeValue,
161     region=None,
162     key=None,
163     keyid=None,
164     profile=None,
165 ):
166     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
167     try:
168         conn.set_subscription_attributes(
169             SubscriptionArn=SubscriptionArn,
170             AttributeName=AttributeName,
171             AttributeValue=AttributeValue,
172         )
173         log.debug(
174             "Set attribute %s=%s on SNS subscription %s",
175             AttributeName,
176             AttributeValue,
177             SubscriptionArn,
178         )
179         return True
180     except botocore.exceptions.ClientError as e:
181         log.error(
182             "Failed to set attribute %s=%s for SNS subscription %s: %s",
183             AttributeName,
184             AttributeValue,
185             SubscriptionArn,
186             e,
187         )
188         return False
189 def subscribe(
190     TopicArn, Protocol, Endpoint, region=None, key=None, keyid=None, profile=None
191 ):
192     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
193     try:
194         ret = conn.subscribe(TopicArn=TopicArn, Protocol=Protocol, Endpoint=Endpoint)
195         log.info(
196             "Subscribed %s %s to topic %s with SubscriptionArn %s",
197             Protocol,
198             Endpoint,
199             TopicArn,
200             ret["SubscriptionArn"],
201         )
202         return ret["SubscriptionArn"]
203     except botocore.exceptions.ClientError as e:
204         log.error("Failed to create subscription to SNS topic %s: %s", TopicArn, e)
205         return None
206     except KeyError:
207         log.error("Failed to create subscription to SNS topic %s", TopicArn)
208         return None
209 def unsubscribe(SubscriptionArn, region=None, key=None, keyid=None, profile=None):
210     if not SubscriptionArn.startswith("arn:aws:sns:"):
211         log.info(
212             "Invalid subscription ARN `%s` passed - likely a PendingConfirmaton or"
213             " such.  Skipping unsubscribe attempt as it would almost certainly fail...",
214             SubscriptionArn,
215         )
216         return True
217     subs = list_subscriptions(region=region, key=key, keyid=keyid, profile=profile)
218     sub = [s for s in subs if s.get("SubscriptionArn") == SubscriptionArn]
219     if not sub:
220         log.error("Subscription ARN %s not found", SubscriptionArn)
221         return False
222     TopicArn = sub[0]["TopicArn"]
223     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
224     try:
225         conn.unsubscribe(SubscriptionArn=SubscriptionArn)
226         log.info("Deleted subscription %s from SNS topic %s", SubscriptionArn, TopicArn)
227         return True
228     except botocore.exceptions.ClientError as e:
229         log.error("Failed to delete subscription %s: %s", SubscriptionArn, e)
230         return False
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>lxd_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import os
3 from datetime import datetime
4 import salt.utils.decorators.path
5 import salt.utils.files
6 from salt.exceptions import CommandExecutionError, SaltInvocationError
7 from salt.utils.versions import LooseVersion
8 try:
9     import pylxd
10     HAS_PYLXD = True
11     import urllib3
12     urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
13 except ImportError:
14     HAS_PYLXD = False
15 log = logging.getLogger(__name__)
16 __docformat__ = "restructuredtext en"
17 _pylxd_minimal_version = "2.2.5"
18 _architectures = {
19     "unknown": "0",
20     "i686": "1",
21     "x86_64": "2",
22     "armv7l": "3",
23     "aarch64": "4",
24     "ppc": "5",
25     "ppc64": "6",
26     "ppc64le": "7",
27     "s390x": "8",
28 }
29 CONTAINER_STATUS_RUNNING = 103
30 __virtualname__ = "lxd"
31 _connection_pool = {}
32 def __virtual__():
33     if HAS_PYLXD:
34         if LooseVersion(pylxd_version()) &lt; LooseVersion(_pylxd_minimal_version):
35             return (
36                 False,
37                 'The lxd execution module cannot be loaded: pylxd "{}" is '
38                 'not supported, you need at least pylxd "{}"'.format(
39                     pylxd_version(), _pylxd_minimal_version
40                 ),
41             )
42         return __virtualname__
43     return (
44         False,
45         "The lxd execution module cannot be loaded: "
46         "the pylxd python module is not available.",
47     )
48 @salt.utils.decorators.path.which("lxd")
49 def version():
50     return __salt__["cmd.run"]("lxd --version")
51 def pylxd_version():
52     return pylxd.__version__
53 @salt.utils.decorators.path.which("lxd")
54 def init(
55     storage_backend="dir",
56     trust_password=None,
57     network_address=None,
58     network_port=None,
59     storage_create_device=None,
60     storage_create_loop=None,
61     storage_pool=None,
62 ):
63     cmd = 'lxd init --auto --storage-backend="{}"'.format(storage_backend)
64     if trust_password is not None:
65         cmd = cmd + ' --trust-password="{}"'.format(trust_password)
66     if network_address is not None:
67         cmd = cmd + ' --network-address="{}"'.format(network_address)
68     if network_port is not None:
69         cmd = cmd + ' --network-port="{}"'.format(network_port)
70     if storage_create_device is not None:
71         cmd = cmd + ' --storage-create-device="{}"'.format(storage_create_device)
72     if storage_create_loop is not None:
73         cmd = cmd + ' --storage-create-loop="{}"'.format(storage_create_loop)
74     if storage_pool is not None:
75         cmd = cmd + ' --storage-pool="{}"'.format(storage_pool)
76     try:
77         output = __salt__["cmd.run"](cmd)
78     except ValueError as e:
79         raise CommandExecutionError(
80             "Failed to call: '{}', error was: {}".format(cmd, str(e)),
81         )
82     if "error:" in output:
83         raise CommandExecutionError(
84             output[output.index("error:") + 7 :],
85         )
86     return output
87 @salt.utils.decorators.path.which("lxd")
88 @salt.utils.decorators.path.which("lxc")
89 def config_set(key, value):
90     cmd = 'lxc config set "{}" "{}"'.format(
91         key,
92         value,
93     )
94     output = __salt__["cmd.run"](cmd)
95     if "error:" in output:
96         raise CommandExecutionError(
97             output[output.index("error:") + 7 :],
98         )
99     return ('Config value "{}" successfully set.'.format(key),)
100 @salt.utils.decorators.path.which("lxd")
101 @salt.utils.decorators.path.which("lxc")
102 def config_get(key):
103     cmd = 'lxc config get "{}"'.format(key)
104     output = __salt__["cmd.run"](cmd)
105     if "error:" in output:
106         raise CommandExecutionError(
107             output[output.index("error:") + 7 :],
108         )
109     return output
110 def pylxd_client_get(remote_addr=None, cert=None, key=None, verify_cert=True):
111     pool_key = "|".join(
112         (
113             str(remote_addr),
114             str(cert),
115             str(key),
116             str(verify_cert),
117         )
118     )
119     if pool_key in _connection_pool:
120         log.debug('Returning the client "%s" from our connection pool', remote_addr)
121         return _connection_pool[pool_key]
122     try:
123         if remote_addr is None or remote_addr == "/var/lib/lxd/unix.socket":
124             log.debug("Trying to connect to the local unix socket")
125             client = pylxd.Client()
126         else:
127             if remote_addr.startswith("/"):
128                 client = pylxd.Client(remote_addr)
129             else:
130                 if cert is None or key is None:
131                     raise SaltInvocationError(
132                         "You have to give a Cert and Key file for remote endpoints."
133                     )
134                 cert = os.path.expanduser(cert)
135                 key = os.path.expanduser(key)
136                 if not os.path.isfile(cert):
137                     raise SaltInvocationError(
138                         'You have given an invalid cert path: "{}", the '
139                         "file does not exist or is not a file.".format(cert)
140                     )
141                 if not os.path.isfile(key):
142                     raise SaltInvocationError(
143                         'You have given an invalid key path: "{}", the '
144                         "file does not exists or is not a file.".format(key)
145                     )
146                 log.debug(
147                     'Trying to connect to "%s" with cert "%s", key "%s" and '
148                     'verify_cert "%s"',
149                     remote_addr,
150                     cert,
151                     key,
152                     verify_cert,
153                 )
154                 client = pylxd.Client(
155                     endpoint=remote_addr,
156                     cert=(
157                         cert,
158                         key,
159                     ),
160                     verify=verify_cert,
161                 )
162     except pylxd.exceptions.ClientConnectionFailed:
163         raise CommandExecutionError("Failed to connect to '{}'".format(remote_addr))
164     except TypeError as e:
165         raise CommandExecutionError(
166             'Failed to connect to "{}", looks like the SSL verification '
167             "failed, error was: {}".format(remote_addr, str(e))
168         )
169     _connection_pool[pool_key] = client
170     return client
171 def pylxd_save_object(obj):
172     try:
173         obj.save(wait=True)
174     except pylxd.exceptions.LXDAPIException as e:
175         raise CommandExecutionError(str(e))
176     return True
177 def authenticate(remote_addr, password, cert, key, verify_cert=True):
178     client = pylxd_client_get(remote_addr, cert, key, verify_cert)
179     if client.trusted:
180         return True
181     try:
182         client.authenticate(password)
183     except pylxd.exceptions.LXDAPIException as e:
184         raise CommandExecutionError(str(e))
185     return client.trusted
186 def container_list(
187     list_names=False, remote_addr=None, cert=None, key=None, verify_cert=True
188 ):
189     client = pylxd_client_get(remote_addr, cert, key, verify_cert)
190     containers = client.containers.all()
191     if list_names:
192         return [c.name for c in containers]
193     return map(_pylxd_model_to_dict, containers)
194 def container_create(
195     name,
196     source,
197     profiles=None,
198     config=None,
199     devices=None,
200     architecture="x86_64",
201     ephemeral=False,
202     wait=True,
203     remote_addr=None,
204     cert=None,
205     key=None,
206     verify_cert=True,
207     _raw=False,
208 ):
209     if profiles is None:
210         profiles = ["default"]
211     if config is None:
212         config = {}
213     if devices is None:
214         devices = {}
215     client = pylxd_client_get(remote_addr, cert, key, verify_cert)
216     if not isinstance(profiles, (list, tuple, set)):
217         raise SaltInvocationError("'profiles' must be formatted as list/tuple/set.")
218     if architecture not in _architectures:
219         raise SaltInvocationError(
220             "Unknown architecture '{}' given for the container '{}'".format(
221                 architecture, name
222             )
223         )
224     if isinstance(source, str):
225         source = {"type": "image", "alias": source}
226     config, devices = normalize_input_values(config, devices)
227     try:
228         container = client.containers.create(
229             {
230                 "name": name,
231                 "architecture": _architectures[architecture],
232                 "profiles": profiles,
233                 "source": source,
234                 "config": config,
235                 "ephemeral": ephemeral,
236             },
237             wait=wait,
238         )
239     except pylxd.exceptions.LXDAPIException as e:
240         raise CommandExecutionError(str(e))
241     if not wait:
242         return container.json()["operation"]
243     if devices:
244         for dn, dargs in devices.items():
245             container_device_add(name, dn, **dargs)
246     if _raw:
247         return container
248     return _pylxd_model_to_dict(container)
249 def container_get(
250     name=None, remote_addr=None, cert=None, key=None, verify_cert=True, _raw=False
251 ):
252     client = pylxd_client_get(remote_addr, cert, key, verify_cert)
253     if name is None:
254         containers = client.containers.all()
255         if _raw:
256             return containers
257     else:
258         containers = []
259         try:
260             containers = [client.containers.get(name)]
261         except pylxd.exceptions.LXDAPIException:
262             raise SaltInvocationError("Container '{}' not found".format(name))
263         if _raw:
264             return containers[0]
265     infos = []
266     for container in containers:
267         infos.append(dict([(container.name, _pylxd_model_to_dict(container))]))
268     return infos
269 def container_delete(name, remote_addr=None, cert=None, key=None, verify_cert=True):
270     container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
271     container.delete(wait=True)
272     return True
273 def container_rename(
274     name, newname, remote_addr=None, cert=None, key=None, verify_cert=True
275 ):
276     container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
277     if container.status_code == CONTAINER_STATUS_RUNNING:
278         raise SaltInvocationError(
279             "Can't rename the running container '{}'.".format(name)
280         )
281     container.rename(newname, wait=True)
282     return _pylxd_model_to_dict(container)
283 def container_state(name=None, remote_addr=None, cert=None, key=None, verify_cert=True):
284     client = pylxd_client_get(remote_addr, cert, key, verify_cert)
285     if name is None:
286         containers = client.containers.all()
287     else:
288         try:
289             containers = [client.containers.get(name)]
290         except pylxd.exceptions.LXDAPIException:
291             raise SaltInvocationError("Container '{}' not found".format(name))
292     states = []
293     for container in containers:
294         state = {}
295         state = container.state()
296         states.append(
297             dict(
298                 [
299                     (
300                         container.name,
301                         {
302                             k: getattr(state, k)
303                             for k in dir(state)
304                             if not k.startswith("_")
305                         },
306                     )
307                 ]
308             )
309         )
310     return states
311 def container_start(name, remote_addr=None, cert=None, key=None, verify_cert=True):
312     container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
313     container.start(wait=True)
314     return _pylxd_model_to_dict(container)
315 def container_stop(
316     name,
317     timeout=30,
318     force=True,
319     remote_addr=None,
320     cert=None,
321     key=None,
322     verify_cert=True,
323 ):
324     container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
325     container.stop(timeout, force, wait=True)
326     return _pylxd_model_to_dict(container)
327 def container_restart(name, remote_addr=None, cert=None, key=None, verify_cert=True):
328     container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
329     container.restart(wait=True)
330     return _pylxd_model_to_dict(container)
331 def container_freeze(name, remote_addr=None, cert=None, key=None, verify_cert=True):
332     container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
333     container.freeze(wait=True)
334     return _pylxd_model_to_dict(container)
335 def container_unfreeze(name, remote_addr=None, cert=None, key=None, verify_cert=True):
336     container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
337     container.unfreeze(wait=True)
338     return _pylxd_model_to_dict(container)
339 def container_migrate(
340     name,
341     stop_and_start=False,
342     remote_addr=None,
343     cert=None,
344     key=None,
345     verify_cert=True,
346     src_remote_addr=None,
347     src_cert=None,
348     src_key=None,
349     src_verify_cert=None,
350 ):
351     if src_cert is None:
352         src_cert = cert
353     if src_key is None:
354         src_key = key
355     if src_verify_cert is None:
356         src_verify_cert = verify_cert
357     container = container_get(
358         name, src_remote_addr, src_cert, src_key, src_verify_cert, _raw=True
359     )
360     dest_client = pylxd_client_get(remote_addr, cert, key, verify_cert)
361     for pname in container.profiles:
362         try:
363             dest_client.profiles.get(pname)
364         except pylxd.exceptions.LXDAPIException:
365             raise SaltInvocationError(
366                 "not all the profiles from the source exist on the target"
367             )
368     was_running = container.status_code == CONTAINER_STATUS_RUNNING
369     if stop_and_start and was_running:
370         container.stop(wait=True)
371     try:
372         dest_container = container.migrate(dest_client, wait=True)
373         dest_container.profiles = container.profiles
374         dest_container.save()
375     except pylxd.exceptions.LXDAPIException as e:
376         raise CommandExecutionError(str(e))
377     container.delete(wait=True)
378     if stop_and_start and was_running:
379         dest_container.start(wait=True)
380     return _pylxd_model_to_dict(dest_container)
381 def container_config_get(
382     name, config_key, remote_addr=None, cert=None, key=None, verify_cert=True
383 ):
384     container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
385     return _get_property_dict_item(container, "config", config_key)
386 def container_config_set(
387     name,
388     config_key,
389     config_value,
390     remote_addr=None,
391     cert=None,
392     key=None,
393     verify_cert=True,
394 ):
395     container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
396     return _set_property_dict_item(container, "config", config_key, config_value)
397 def container_config_delete(
398     name, config_key, remote_addr=None, cert=None, key=None, verify_cert=True
399 ):
400     container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
401     return _delete_property_dict_item(container, "config", config_key)
402 def container_device_get(
403     name, device_name, remote_addr=None, cert=None, key=None, verify_cert=True
404 ):
405     container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
406     return _get_property_dict_item(container, "devices", device_name)
407 def container_device_add(
408     name,
409     device_name,
410     device_type="disk",
411     remote_addr=None,
412     cert=None,
413     key=None,
414     verify_cert=True,
415     **kwargs
416 ):
417     container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
418     kwargs["type"] = device_type
419     return _set_property_dict_item(container, "devices", device_name, kwargs)
420 def container_device_delete(
421     name, device_name, remote_addr=None, cert=None, key=None, verify_cert=True
422 ):
423     container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
424     return _delete_property_dict_item(container, "devices", device_name)
425 def container_file_put(
426     name,
427     src,
428     dst,
429     recursive=False,
430     overwrite=False,
431     mode=None,
432     uid=None,
433     gid=None,
434     saltenv="base",
435     remote_addr=None,
436     cert=None,
437     key=None,
438     verify_cert=True,
439 ):
440     mode = str(mode)
441     if not mode.startswith("0"):
442         mode = "0{}".format(mode)
443     container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
444     src = os.path.expanduser(src)
445     if not os.path.isabs(src):
446         if src.find("://") &gt;= 0:
447             cached_file = __salt__["cp.cache_file"](src, saltenv=saltenv)
448             if not cached_file:
449                 raise SaltInvocationError("File '{}' not found".format(src))
450             if not os.path.isabs(cached_file):
451                 raise SaltInvocationError("File path must be absolute.")
452             src = cached_file
453     src = src.rstrip(os.path.sep)
454     if not src:
455         src = os.path.sep
456     if not os.path.exists(src):
457         raise CommandExecutionError("No such file or directory '{}'".format(src))
458     if os.path.isdir(src) and not recursive:
459         raise SaltInvocationError(
460             "Cannot copy overwriting a directory without recursive flag set to true!"
461         )
462     try:
463         dst_is_directory = False
464         container.files.get(os.path.join(dst, "."))
465     except pylxd.exceptions.NotFound:
466         pass
467     except pylxd.exceptions.LXDAPIException as why:
468         if str(why).find("Is a directory") &gt;= 0:
469             dst_is_directory = True
470     if os.path.isfile(src):
471         if dst_is_directory:
472             dst = os.path.join(dst, os.path.basename(src))
473             if not overwrite:
474                 found = True
475                 try:
476                     container.files.get(os.path.join(dst))
477                 except pylxd.exceptions.NotFound:
478                     found = False
479                 except pylxd.exceptions.LXDAPIException as why:
480                     if str(why).find("not found") &gt;= 0:
481                         found = False
482                     else:
483                         raise
484                 if found:
485                     raise SaltInvocationError(
486                         "Destination exists and overwrite is false"
487                     )
488         if mode is not None or uid is not None or gid is not None:
489             stat = os.stat(src)
490             if mode is None:
491                 mode = oct(stat.st_mode)
492             if uid is None:
493                 uid = stat.st_uid
494             if gid is None:
495                 gid = stat.st_gid
496         with salt.utils.files.fopen(src, "rb") as src_fp:
497             container.files.put(dst, src_fp.read(), mode=mode, uid=uid, gid=gid)
498         return True
499     elif not os.path.isdir(src):
500         raise SaltInvocationError("Source is neither file nor directory")
501     if dst.endswith(os.sep):
502         idx = len(os.path.dirname(src))
503     elif dst_is_directory:
504         idx = len(src)
505     else:
506         try:
507             container.files.get(os.path.join(os.path.dirname(dst), "."))
508         except pylxd.exceptions.NotFound:
509             pass
510         except pylxd.exceptions.LXDAPIException as why:
511             if str(why).find("Is a directory") &gt;= 0:
512                 dst_is_directory = True
513                 idx = len(src)
514                 overwrite = True
515     if not overwrite:
516         raise SaltInvocationError("Destination exists and overwrite is false")
517     dstdirs = []
518     for path, _, files in os.walk(src):
519         dstdir = os.path.join(dst, path[idx:].lstrip(os.path.sep))
520         dstdirs.append(dstdir)
521     container.execute(["mkdir", "-p"] + dstdirs)
522     set_mode = mode
523     set_uid = uid
524     set_gid = gid
525     for path, _, files in os.walk(src):
526         dstdir = os.path.join(dst, path[idx:].lstrip(os.path.sep))
527         for name in files:
528             src_name = os.path.join(path, name)
529             dst_name = os.path.join(dstdir, name)
530             if mode is not None or uid is not None or gid is not None:
531                 stat = os.stat(src_name)
532                 if mode is None:
533                     set_mode = oct(stat.st_mode)
534                 if uid is None:
535                     set_uid = stat.st_uid
536                 if gid is None:
537                     set_gid = stat.st_gid
538             with salt.utils.files.fopen(src_name, "rb") as src_fp:
539                 container.files.put(
540                     dst_name, src_fp.read(), mode=set_mode, uid=set_uid, gid=set_gid
541                 )
542     return True
543 def container_file_get(
544     name,
545     src,
546     dst,
547     overwrite=False,
548     mode=None,
549     uid=None,
550     gid=None,
551     remote_addr=None,
552     cert=None,
553     key=None,
554     verify_cert=True,
555 ):
556     if mode is not None:
557         mode = str(mode)
558         if not mode.startswith("0"):
559             mode = "0{}".format(mode)
560     container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
561     dst = os.path.expanduser(dst)
562     if not os.path.isabs(dst):
563         raise SaltInvocationError("File path must be absolute.")
564     if os.path.isdir(dst):
565         dst = os.path.join(dst, os.path.basename(src))
566     elif not os.path.isdir(os.path.dirname(dst)):
567         raise SaltInvocationError("Parent directory for destination doesn't exist.")
568     if os.path.exists(dst):
569         if not overwrite:
570             raise SaltInvocationError("Destination exists and overwrite is false.")
571         if not os.path.isfile(dst):
572             raise SaltInvocationError("Destination exists but is not a file.")
573     else:
574         dst_path = os.path.dirname(dst)
575         if not os.path.isdir(dst_path):
576             raise CommandExecutionError(
577                 "No such file or directory '{}'".format(dst_path)
578             )
579     with salt.utils.files.fopen(dst, "wb") as df:
580         df.write(container.files.get(src))
581     if mode:
582         os.chmod(dst, mode)
583     if uid or uid == "0":
584         uid = int(uid)
585     else:
586         uid = -1
587     if gid or gid == "0":
588 <a name="0"></a>        gid = int(gid)
589     else:
590         gid = -1
591     <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>if uid != -1 or gid != -1:
592         os.chown(dst, uid, gid)
593     return True
594 def container_execute(
595     name, cmd, remote_addr=None, cert=None, key=None, verify_cert=True
596 ):
597     container = container_get(name, remote_addr, cert, key, verify_cert, _raw=</b></font>True)
598     try:
599         result = container.execute(cmd)
600         saltresult = {}
601         if not hasattr(result, "exit_code"):
602             saltresult = dict(
603                 exit_code=0,
604                 stdout=result[0],
605                 stderr=result[1],
606             )
607         else:
608             saltresult = dict(
609                 exit_code=result.exit_code,
610                 stdout=result.stdout,
611                 stderr=result.stderr,
612             )
613     except pylxd.exceptions.NotFound as e:
614         saltresult = dict(exit_code=0, stdout="", stderr=str(e))
615     if int(saltresult["exit_code"]) &gt; 0:
616         saltresult["result"] = False
617     else:
618         saltresult["result"] = True
619     return saltresult
620 def profile_list(
621     list_names=False, remote_addr=None, cert=None, key=None, verify_cert=True
622 ):
623     client = pylxd_client_get(remote_addr, cert, key, verify_cert)
624     profiles = client.profiles.all()
625     if list_names:
626         return [p.name for p in profiles]
627     return map(_pylxd_model_to_dict, profiles)
628 def profile_create(
629     name,
630     config=None,
631     devices=None,
632     description=None,
633     remote_addr=None,
634     cert=None,
635     key=None,
636     verify_cert=True,
637 ):
638     client = pylxd_client_get(remote_addr, cert, key, verify_cert)
639     config, devices = normalize_input_values(config, devices)
640     try:
641         profile = client.profiles.create(name, config, devices)
642     except pylxd.exceptions.LXDAPIException as e:
643         raise CommandExecutionError(str(e))
644     if description is not None:
645         profile.description = description
646         pylxd_save_object(profile)
647     return _pylxd_model_to_dict(profile)
648 def profile_get(
649     name, remote_addr=None, cert=None, key=None, verify_cert=True, _raw=False
650 ):
651     client = pylxd_client_get(remote_addr, cert, key, verify_cert)
652     profile = None
653     try:
654         profile = client.profiles.get(name)
655     except pylxd.exceptions.LXDAPIException:
656         raise SaltInvocationError("Profile '{}' not found".format(name))
657     if _raw:
658         return profile
659     return _pylxd_model_to_dict(profile)
660 def profile_delete(name, remote_addr=None, cert=None, key=None, verify_cert=True):
661     profile<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.delete()
662     return True
663 def profile_config_get(
664     name, config_key, remote_addr=None, cert=None, key=None, verify_cert=True
665 ):
666     profile = profile_get(name, remote_addr, cert, key, verify_cert, _raw=</b></font>True)
667     return _get_property_dict_item(profile, "config", config_key)
668 def profile_config_set(
669     name,
670     config_key,
671     config_value,
672     remote_addr=None,
673     cert=None,
674     key=None,
675     verify_cert=True,
676 ):
677     profile = profile_get(name, remote_addr, cert, key, verify_cert, _raw=True)
678     return _set_property_dict_item(profile, "config", config_key, config_value)
679 def profile_config_delete(
680     name, config_key, remote_addr=None, cert=None, key=None, verify_cert=True
681 ):
682     profile = profile_get(name, remote_addr, cert, key, verify_cert, _raw=True)
683     return _delete_property_dict_item(profile, "config", config_key)
684 def profile_device_get(
685     name, device_name, remote_addr=None, cert=None, key=None, verify_cert=True
686 ):
687     profile = profile_get(name, remote_addr, cert, key, verify_cert, _raw=True)
688     return _get_property_dict_item(profile, "devices", device_name)
689 def profile_device_set(
690     name,
691     device_name,
692     device_type="disk",
693     remote_addr=None,
694     cert=None,
695     key=None,
696     verify_cert=True,
697     **kwargs
698 ):
699     profile = profile_get(name, remote_addr, cert, key, verify_cert, _raw=True)
700     kwargs["type"] = device_type
701     for k, v in kwargs.items():
702         kwargs[k] = str(v)
703     return _set_property_dict_item(profile, "devices", device_name, kwargs)
704 def profile_device_delete(
705     name, device_name, remote_addr=None, cert=None, key=None, verify_cert=True
706 ):
707     profile = profile_get(name, remote_addr, cert, key, verify_cert, _raw=True)
708     return _delete_property_dict_item(profile, "devices", device_name)
709 def image_list(
710     list_aliases=False, remote_addr=None, cert=None, key=None, verify_cert=True
711 ):
712     client = pylxd_client_get(remote_addr, cert, key, verify_cert)
713     images = client.images.all()
714     if list_aliases:
715         return {i.fingerprint: [a["name"] for a in i.aliases] for i in images}
716     return map(_pylxd_model_to_dict, images)
717 def image_get(
718     fingerprint, remote_addr=None, cert=None, key=None, verify_cert=True, _raw=False
719 ):
720     client = pylxd_client_get(remote_addr, cert, key, verify_cert)
721     image = None
722     try:
723         image = client.images.get(fingerprint)
724     except pylxd.exceptions.LXDAPIException:
725         raise SaltInvocationError(
726             "Image with fingerprint '{}' not found".format(fingerprint)
727         )
728     if _raw:
729         return image
730     return _pylxd_model_to_dict(image)
731 def image_get_by_alias(
732     alias, remote_addr=None, cert=None, key=None, verify_cert=True, _raw=False
733 ):
734     client = pylxd_client_get(remote_addr, cert, key, verify_cert)
735     image = None
736     try:
737         image = client.images.get_by_alias(alias)
738     except pylxd.exceptions.LXDAPIException:
739         raise SaltInvocationError("Image with alias '{}' not found".format(alias))
740     if _raw:
741         return image
742     return _pylxd_model_to_dict(image)
743 def image_delete(image, remote_addr=None, cert=None, key=None, verify_cert=True):
744     image = _verify_image(image, remote_addr, cert, key, verify_cert)
745     image.delete()
746     return True
747 def image_from_simplestreams(
748     server,
749     alias,
750     remote_addr=None,
751     cert=None,
752     key=None,
753     verify_cert=True,
754     aliases=None,
755     public=False,
756     auto_update=False,
757     _raw=False,
758 ):
759     if aliases is None:
760         aliases = []
761     client = pylxd_client_get(remote_addr, cert, key, verify_cert)
762     try:
763         image = client.images.create_from_simplestreams(
764             server, alias, public=public, auto_update=auto_update
765         )
766     except pylxd.exceptions.LXDAPIException as e:
767         raise CommandExecutionError(str(e))
768     for alias in aliases:
769         image_alias_add(image, alias)
770     if _raw:
771         return image
772     return _pylxd_model_to_dict(image)
773 def image_from_url(
774     url,
775     remote_addr=None,
776     cert=None,
777     key=None,
778     verify_cert=True,
779     aliases=None,
780     public=False,
781     auto_update=False,
782     _raw=False,
783 ):
784     if aliases is None:
785         aliases = []
786     client = pylxd_client_get(remote_addr, cert, key, verify_cert)
787     try:
788         image = client.images.create_from_url(
789             url, public=public, auto_update=auto_update
790         )
791     except pylxd.exceptions.LXDAPIException as e:
792         raise CommandExecutionError(str(e))
793     for alias in aliases:
794         image_alias_add(image, alias)
795     if _raw:
796         return image
797     return _pylxd_model_to_dict(image)
798 def image_from_file(
799     filename,
800     remote_addr=None,
801     cert=None,
802     key=None,
803     verify_cert=True,
804     aliases=None,
805     public=False,
806     saltenv="base",
807     _raw=False,
808 ):
809     if aliases is None:
810         aliases = []
811     cached_file = __salt__["cp.cache_file"](filename, saltenv=saltenv)
812     data = b""
813     with salt.utils.files.fopen(cached_file, "r+b") as fp:
814         data = fp.read()
815     client = pylxd_client_get(remote_addr, cert, key, verify_cert)
816     try:
817         image = client.images.create(data, public=public, wait=True)
818     except pylxd.exceptions.LXDAPIException as e:
819         raise CommandExecutionError(str(e))
820     for alias in aliases:
821         image_alias_add(image, alias)
822     if _raw:
823         return image
824     return _pylxd_model_to_dict(image)
825 def image_copy_lxd(
826     source,
827     src_remote_addr,
828     src_cert,
829     src_key,
830     src_verify_cert,
831     remote_addr,
832     cert,
833     key,
834     verify_cert=True,
835     aliases=None,
836     public=None,
837     auto_update=None,
838     _raw=False,
839 ):
840     if aliases is None:
841         aliases = []
842     log.debug(
843         'Trying to copy the image "%s" from "%s" to "%s"',
844         source,
845         src_remote_addr,
846         remote_addr,
847     )
848     src_image = None
849     try:
850         src_image = image_get_by_alias(
851             source, src_remote_addr, src_cert, src_key, src_verify_cert, _raw=True
852         )
853     except SaltInvocationError:
854         src_image = image_get(
855             source, src_remote_addr, src_cert, src_key, src_verify_cert, _raw=True
856         )
857     dest_client = pylxd_client_get(remote_addr, cert, key, verify_cert)
858     dest_image = src_image.copy(
859         dest_client, public=public, auto_update=auto_update, wait=True
860     )
861     for alias in aliases:
862         image_alias_add(dest_image, alias)
863     if _raw:
864         return dest_image
865     return _pylxd_model_to_dict(dest_image)
866 def image_alias_add(
867     image,
868     alias,
869     description="",
870     remote_addr=None,
871     cert=None,
872     key=None,
873     verify_cert=True,
874 ):
875     image = _verify_image(image, remote_addr, cert, key, verify_cert)
876     for alias_info in image.aliases:
877         if alias_info["name"] == alias:
878             return True
879     image.add_alias(alias, description)
880     return True
881 def image_alias_delete(
882     image, alias, remote_addr=None, cert=None, key=None, verify_cert=True
883 ):
884     image = _verify_image(image, remote_addr, cert, key, verify_cert)
885     try:
886         image.delete_alias(alias)
887     except pylxd.exceptions.LXDAPIException:
888         return False
889     return True
890 def snapshots_all(container, remote_addr=None, cert=None, key=None, verify_cert=True):
891     containers = container_get(
892         container, remote_addr, cert, key, verify_cert, _raw=True
893     )
894     if container:
895         containers = [containers]
896     ret = {}
897     for cont in containers:
898         ret.update({cont.name: [{"name": c.name} for c in cont.snapshots.all()]})
899     return ret
900 def snapshots_create(
901     container, name=None, remote_addr=None, cert=None, key=None, verify_cert=True
902 ):
903     cont = container_get(container, remote_addr, cert, key, verify_cert, _raw=True)
904     if not name:
905         name = datetime.now().strftime("%Y%m%d%H%M%S")
906     cont.snapshots.create(name)
907     for c in snapshots_all(container).get(container):
908         if c.get("name") == name:
909             return {"name": name}
910     return {"name": False}
911 def snapshots_delete(
912     container, name, remote_addr=None, cert=None, key=None, verify_cert=True
913 ):
914     cont = container_get(container, remote_addr, cert, key, verify_cert, _raw=True)
915     try:
916         for s in cont.snapshots.all():
917             if s.name == name:
918                 s.delete()
919                 return True
920     except pylxd.exceptions.LXDAPIException:
921         pass
922     return False
923 def snapshots_get(
924     container, name, remote_addr=None, cert=None, key=None, verify_cert=True
925 ):
926     container = container_get(container, remote_addr, cert, key, verify_cert, _raw=True)
927     return container.snapshots.get(name)
928 def normalize_input_values(config, devices):
929     if isinstance(config, list):
930         if config and "key" in config[0] and "value" in config[0]:
931             config = {d["key"]: d["value"] for d in config}
932         else:
933             config = {}
934     if isinstance(config, str):
935         raise SaltInvocationError("config can't be a string, validate your YAML input.")
936     if isinstance(devices, str):
937         raise SaltInvocationError(
938             "devices can't be a string, validate your YAML input."
939         )
940     if config is not None:
941         for k, v in config.items():
942             config[k] = str(v)
943     if devices is not None:
944         for dn in devices:
945             for k, v in devices[dn].items():
946                 devices[dn][k] = v
947     return (
948         config,
949         devices,
950     )
951 def sync_config_devices(obj, newconfig, newdevices, test=False):
952     changes = {}
953     if newconfig is None:
954         newconfig = {}
955     newconfig = dict(
956         list(zip(map(str, newconfig.keys()), map(str, newconfig.values())))
957     )
958     cck = set(newconfig.keys())
959     obj.config = dict(
960         list(zip(map(str, obj.config.keys()), map(str, obj.config.values())))
961     )
962     ock = set(obj.config.keys())
963     config_changes = {}
964     for k in ock.difference(cck):
965         if k.startswith("volatile.") or k.startswith("image."):
966             continue
967         if not test:
968             config_changes[k] = 'Removed config key "{}", its value was "{}"'.format(
969                 k, obj.config[k]
970             )
971             del obj.config[k]
972         else:
973             config_changes[k] = 'Would remove config key "{} with value "{}"'.format(
974                 k, obj.config[k]
975             )
976     for k in cck.intersection(ock):
977         if k.startswith("volatile.") or k.startswith("image."):
978             continue
979         if newconfig[k] != obj.config[k]:
980             if not test:
981                 config_changes[
982                     k
983                 ] = 'Changed config key "{}" to "{}", its value was "{}"'.format(
984                     k, newconfig[k], obj.config[k]
985                 )
986                 obj.config[k] = newconfig[k]
987             else:
988                 config_changes[
989                     k
990                 ] = 'Would change config key "{}" to "{}", its current value is "{}"'.format(
991                     k, newconfig[k], obj.config[k]
992                 )
993     for k in cck.difference(ock):
994         if k.startswith("volatile.") or k.startswith("image."):
995             continue
996         if not test:
997             config_changes[k] = 'Added config key "{}" = "{}"'.format(k, newconfig[k])
998             obj.config[k] = newconfig[k]
999         else:
1000             config_changes[k] = 'Would add config key "{}" = "{}"'.format(
1001                 k, newconfig[k]
1002             )
1003     if config_changes:
1004         changes["config"] = config_changes
1005     if newdevices is None:
1006         newdevices = {}
1007     dk = set(obj.devices.keys())
1008     ndk = set(newdevices.keys())
1009     devices_changes = {}
1010     for k in dk.difference(ndk):
1011         if k == "root":
1012             continue
1013         if not test:
1014             devices_changes[k] = 'Removed device "{}"'.format(k)
1015             del obj.devices[k]
1016         else:
1017             devices_changes[k] = 'Would remove device "{}"'.format(k)
1018     for k, v in obj.devices.items():
1019         if k == "root":
1020             continue
1021         if k not in newdevices:
1022             continue
1023         if newdevices[k] != v:
1024             if not test:
1025                 devices_changes[k] = 'Changed device "{}"'.format(k)
1026                 obj.devices[k] = newdevices[k]
1027             else:
1028                 devices_changes[k] = 'Would change device "{}"'.format(k)
1029     for k in ndk.difference(dk):
1030         if k == "root":
1031             continue
1032         if not test:
1033             devices_changes[k] = 'Added device "{}"'.format(k)
1034             obj.devices[k] = newdevices[k]
1035         else:
1036             devices_changes[k] = 'Would add device "{}"'.format(k)
1037     if devices_changes:
1038         changes["devices"] = devices_changes
1039     return changes
1040 def _set_property_dict_item(obj, prop, key, value):
1041     attr = getattr(obj, prop)
1042     if prop == "devices":
1043         device_type = value["type"]
1044         if device_type == "disk":
1045             if "path" not in value:
1046                 raise SaltInvocationError("path must be given as parameter")
1047             if value["path"] != "/" and "source" not in value:
1048                 raise SaltInvocationError("source must be given as parameter")
1049         for k in value.keys():
1050             if k.startswith("__"):
1051                 del value[k]
1052         attr[key] = value
1053     else:  # config
1054         attr[key] = str(value)
1055     pylxd_save_object(obj)
1056     return _pylxd_model_to_dict(obj)
1057 def _get_property_dict_item(obj, prop, key):
1058     attr = getattr(obj, prop)
1059     if key not in attr:
1060         raise SaltInvocationError("'{}' doesn't exists".format(key))
1061     return attr[key]
1062 def _delete_property_dict_item(obj, prop, key):
1063     attr = getattr(obj, prop)
1064     if key not in attr:
1065         raise SaltInvocationError("'{}' doesn't exists".format(key))
1066     del attr[key]
1067     pylxd_save_object(obj)
1068     return True
1069 def _verify_image(image, remote_addr=None, cert=None, key=None, verify_cert=True):
1070     if isinstance(image, str):
1071         name = image
1072         image = None
1073         try:
1074             image = image_get_by_alias(
1075                 name, remote_addr, cert, key, verify_cert, _raw=True
1076             )
1077         except SaltInvocationError:
1078             image = image_get(name, remote_addr, cert, key, verify_cert, _raw=True)
1079     elif not hasattr(image, "fingerprint"):
1080         raise SaltInvocationError("Invalid image '{}'".format(image))
1081     return image
1082 def _pylxd_model_to_dict(obj):
1083     marshalled = {}
1084     for key in obj.__attributes__.keys():
1085         if hasattr(obj, key):
1086             marshalled[key] = getattr(obj, key)
1087     return marshalled
1088 if HAS_PYLXD:
1089     import pylxd.exceptions  # NOQA
1090     if not hasattr(pylxd.exceptions, "NotFound"):
1091         class NotFound(pylxd.exceptions.LXDAPIException):
1092         pylxd.exceptions.NotFound = NotFound
1093     try:
1094         from pylxd.container import Container
1095     except ImportError:
1096         from pylxd.models.container import Container
1097     class FilesManager(Container.FilesManager):
1098         def put(self, filepath, data, mode=None, uid=None, gid=None):
1099             headers = {}
1100             if mode is not None:
1101                 if isinstance(mode, int):
1102                     mode = oct(mode)
1103                 elif not mode.startswith("0"):
1104                     mode = "0{}".format(mode)
1105                 headers["X-LXD-mode"] = mode
1106             if uid is not None:
1107                 headers["X-LXD-uid"] = str(uid)
1108             if gid is not None:
1109                 headers["X-LXD-gid"] = str(gid)
1110             response = self._client.api.containers[self._container.name].files.post(
1111                 params={"path": filepath}, data=data, headers=headers
1112             )
1113             return response.status_code == 200
1114     Container.FilesManager = FilesManager
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
