<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for boto3_sns_1.py &amp; lxd_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for boto3_sns_1.py &amp; lxd_1.py
      </h3>
<h1 align="center">
        1.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>boto3_sns_1.py (5.6034484%)<th>lxd_1.py (1.1882998%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(69-84)<td><a href="#" name="0">(1810-1862)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(162-176)<td><a href="#" name="1">(2121-2167)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto3_sns_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import salt.utils.versions
3 log = logging.getLogger(__name__)
4 try:
5     import botocore
6     import boto3
7     import jmespath
8     logging.getLogger("boto3").setLevel(logging.CRITICAL)
9     HAS_BOTO = True
10 except ImportError:
11     HAS_BOTO = False
12 def __virtual__():
13     has_boto_reqs = salt.utils.versions.check_boto_reqs()
14     <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>if has_boto_reqs is True:
15         __utils__["boto3.assign_funcs"](__name__, "sns")
16     return has_boto_reqs
17 def list_topics(region=None, key=None, keyid=None, profile=None):
18     conn = _get_conn(region=</b></font>region, key=key, keyid=keyid, profile=profile)
19     res = {}
20     NextToken = ""
21     while NextToken is not None:
22         ret = conn.list_topics(NextToken=NextToken)
23         NextToken = ret.get("NextToken", None)
24         arns = jmespath.search("Topics[*].TopicArn", ret)
25         for t in arns:
26             short_name = t.split(":")[-1]
27             res[short_name] = t
28     return res
29 def describe_topic(name, region=None, key=None, keyid=None, profile=None):
30     topics = list_topics(region=region, key=key, keyid=keyid, profile=profile)
31     ret = {}
32     for topic, arn in topics.items():
33         if name in (topic, arn):
34             ret = {"TopicArn": arn}
35             ret["Subscriptions"] = list_subscriptions_by_topic(
36                 arn, region=region, key=key, keyid=keyid, profile=profile
37             )
38             ret["Attributes"] = get_topic_attributes(
39                 arn, region=region, key=key, keyid=keyid, profile=profile
40             )
41             for sub in ret["Subscriptions"]:
42                 sub_arn = sub["SubscriptionArn"]
43                 if not sub_arn.startswith("arn:aws:sns:"):
44                     log.debug("Subscription with invalid ARN %s skipped...", sub_arn)
45                     continue
46     return ret
47 def topic_exists(name, region=None, key=None, keyid=None, profile=None):
48     topics = list_topics(region=region, key=key, keyid=keyid, profile=profile)
49     return name in list(topics.values() + topics.keys())
50 def create_topic(Name, region=None, key=None, keyid=None, profile=None):
51     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
52     try:
53         ret = conn.create_topic(Name=Name)
54         log.info("SNS topic %s created with ARN %s", Name, ret["TopicArn"])
55         return ret["TopicArn"]
56     except botocore.exceptions.ClientError as e:
57         return None
58     except KeyError:
59         log<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.error("Failed to create SNS topic %s", Name)
60         return None
61 def delete_topic(TopicArn, region=None, key=None, keyid=None, profile=None):
62     conn = _get_conn(region=</b></font>region, key=key, keyid=keyid, profile=profile)
63     try:
64         conn.delete_topic(TopicArn=TopicArn)
65         log.info("SNS topic %s deleted", TopicArn)
66         return True
67     except botocore.exceptions.ClientError as e:
68         log.error("Failed to delete SNS topic %s: %s", name, e)
69         return False
70 def get_topic_attributes(TopicArn, region=None, key=None, keyid=None, profile=None):
71     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
72     try:
73         return conn.get_topic_attributes(TopicArn=TopicArn).get("Attributes")
74     except botocore.exceptions.ClientError as e:
75         log.error("Failed to garner attributes for SNS topic %s: %s", TopicArn, e)
76         return None
77 def set_topic_attributes(
78     TopicArn,
79     AttributeName,
80     AttributeValue,
81     region=None,
82     key=None,
83     keyid=None,
84     profile=None,
85 ):
86     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
87     try:
88         conn.set_topic_attributes(
89             TopicArn=TopicArn,
90             AttributeName=AttributeName,
91             AttributeValue=AttributeValue,
92         )
93         log.debug(
94             "Set attribute %s=%s on SNS topic %s",
95             AttributeName,
96             AttributeValue,
97             TopicArn,
98         )
99         return True
100     except botocore.exceptions.ClientError as e:
101         log.error(
102             "Failed to set attribute %s=%s for SNS topic %s: %s",
103             AttributeName,
104             AttributeValue,
105             TopicArn,
106             e,
107         )
108         return False
109 def list_subscriptions_by_topic(
110     TopicArn, region=None, key=None, keyid=None, profile=None
111 ):
112     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
113     NextToken = ""
114     res = []
115     try:
116         while NextToken is not None:
117             ret = conn.list_subscriptions_by_topic(
118                 TopicArn=TopicArn, NextToken=NextToken
119             )
120             NextToken = ret.get("NextToken", None)
121             subs = ret.get("Subscriptions", [])
122             res += subs
123     except botocore.exceptions.ClientError as e:
124         log.error("Failed to list subscriptions for SNS topic %s: %s", TopicArn, e)
125         return None
126     return res
127 def list_subscriptions(region=None, key=None, keyid=None, profile=None):
128     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
129     NextToken = ""
130     res = []
131     try:
132         while NextToken is not None:
133             ret = conn.list_subscriptions(NextToken=NextToken)
134             NextToken = ret.get("NextToken", None)
135             subs = ret.get("Subscriptions", [])
136             res += subs
137     except botocore.exceptions.ClientError as e:
138         log.error("Failed to list SNS subscriptions: %s", e)
139         return None
140     return res
141 def get_subscription_attributes(
142     SubscriptionArn, region=None, key=None, keyid=None, profile=None
143 ):
144     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
145     try:
146         ret = conn.get_subscription_attributes(SubscriptionArn=SubscriptionArn)
147         return ret["Attributes"]
148     except botocore.exceptions.ClientError as e:
149         log.error(
150             "Failed to list attributes for SNS subscription %s: %s", SubscriptionArn, e
151         )
152         return None
153     except KeyError:
154         log.error("Failed to list attributes for SNS subscription %s", SubscriptionArn)
155         return None
156 def set_subscription_attributes(
157     SubscriptionArn,
158     AttributeName,
159     AttributeValue,
160     region=None,
161     key=None,
162     keyid=None,
163     profile=None,
164 ):
165     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
166     try:
167         conn.set_subscription_attributes(
168             SubscriptionArn=SubscriptionArn,
169             AttributeName=AttributeName,
170             AttributeValue=AttributeValue,
171         )
172         log.debug(
173             "Set attribute %s=%s on SNS subscription %s",
174             AttributeName,
175             AttributeValue,
176             SubscriptionArn,
177         )
178         return True
179     except botocore.exceptions.ClientError as e:
180         log.error(
181             "Failed to set attribute %s=%s for SNS subscription %s: %s",
182             AttributeName,
183             AttributeValue,
184             SubscriptionArn,
185             e,
186         )
187         return False
188 def subscribe(
189     TopicArn, Protocol, Endpoint, region=None, key=None, keyid=None, profile=None
190 ):
191     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
192     try:
193         ret = conn.subscribe(TopicArn=TopicArn, Protocol=Protocol, Endpoint=Endpoint)
194         log.info(
195             "Subscribed %s %s to topic %s with SubscriptionArn %s",
196             Protocol,
197             Endpoint,
198             TopicArn,
199             ret["SubscriptionArn"],
200         )
201         return ret["SubscriptionArn"]
202     except botocore.exceptions.ClientError as e:
203         log.error("Failed to create subscription to SNS topic %s: %s", TopicArn, e)
204         return None
205     except KeyError:
206         log.error("Failed to create subscription to SNS topic %s", TopicArn)
207         return None
208 def unsubscribe(SubscriptionArn, region=None, key=None, keyid=None, profile=None):
209     if not SubscriptionArn.startswith("arn:aws:sns:"):
210         log.info(
211             "Invalid subscription ARN `%s` passed - likely a PendingConfirmaton or"
212             " such.  Skipping unsubscribe attempt as it would almost certainly fail...",
213             SubscriptionArn,
214         )
215         return True
216     subs = list_subscriptions(region=region, key=key, keyid=keyid, profile=profile)
217     sub = [s for s in subs if s.get("SubscriptionArn") == SubscriptionArn]
218     if not sub:
219         log.error("Subscription ARN %s not found", SubscriptionArn)
220         return False
221     TopicArn = sub[0]["TopicArn"]
222     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
223     try:
224         conn.unsubscribe(SubscriptionArn=SubscriptionArn)
225         log.info("Deleted subscription %s from SNS topic %s", SubscriptionArn, TopicArn)
226         return True
227     except botocore.exceptions.ClientError as e:
228         log.error("Failed to delete subscription %s: %s", SubscriptionArn, e)
229         return False
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>lxd_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import os
3 from datetime import datetime
4 import salt.utils.decorators.path
5 import salt.utils.files
6 from salt.exceptions import CommandExecutionError, SaltInvocationError
7 from salt.utils.versions import LooseVersion
8 try:
9     import pylxd
10     HAS_PYLXD = True
11     import urllib3
12     urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
13 except ImportError:
14     HAS_PYLXD = False
15 log = logging.getLogger(__name__)
16 __docformat__ = "restructuredtext en"
17 _pylxd_minimal_version = "2.2.5"
18 _architectures = {
19     "unknown": "0",
20     "i686": "1",
21     "x86_64": "2",
22     "armv7l": "3",
23     "aarch64": "4",
24     "ppc": "5",
25     "ppc64": "6",
26     "ppc64le": "7",
27     "s390x": "8",
28 }
29 CONTAINER_STATUS_RUNNING = 103
30 __virtualname__ = "lxd"
31 _connection_pool = {}
32 def __virtual__():
33     if HAS_PYLXD:
34         if LooseVersion(pylxd_version()) &lt; LooseVersion(_pylxd_minimal_version):
35             return (
36                 False,
37                 'The lxd execution module cannot be loaded: pylxd "{}" is '
38                 'not supported, you need at least pylxd "{}"'.format(
39                     pylxd_version(), _pylxd_minimal_version
40                 ),
41             )
42         return __virtualname__
43     return (
44         False,
45         "The lxd execution module cannot be loaded: "
46         "the pylxd python module is not available.",
47     )
48 @salt.utils.decorators.path.which("lxd")
49 def version():
50     return __salt__["cmd.run"]("lxd --version")
51 def pylxd_version():
52     return pylxd.__version__
53 @salt.utils.decorators.path.which("lxd")
54 def init(
55     storage_backend="dir",
56     trust_password=None,
57     network_address=None,
58     network_port=None,
59     storage_create_device=None,
60     storage_create_loop=None,
61     storage_pool=None,
62 ):
63     cmd = 'lxd init --auto --storage-backend="{}"'.format(storage_backend)
64     if trust_password is not None:
65         cmd = cmd + ' --trust-password="{}"'.format(trust_password)
66     if network_address is not None:
67         cmd = cmd + ' --network-address="{}"'.format(network_address)
68     if network_port is not None:
69         cmd = cmd + ' --network-port="{}"'.format(network_port)
70     if storage_create_device is not None:
71         cmd = cmd + ' --storage-create-device="{}"'.format(storage_create_device)
72     if storage_create_loop is not None:
73         cmd = cmd + ' --storage-create-loop="{}"'.format(storage_create_loop)
74     if storage_pool is not None:
75         cmd = cmd + ' --storage-pool="{}"'.format(storage_pool)
76     try:
77         output = __salt__["cmd.run"](cmd)
78     except ValueError as e:
79         raise CommandExecutionError(
80             "Failed to call: '{}', error was: {}".format(cmd, str(e)),
81         )
82     if "error:" in output:
83         raise CommandExecutionError(
84             output[output.index("error:") + 7 :],
85         )
86     return output
87 @salt.utils.decorators.path.which("lxd")
88 @salt.utils.decorators.path.which("lxc")
89 def config_set(key, value):
90     cmd = 'lxc config set "{}" "{}"'.format(
91         key,
92         value,
93     )
94     output = __salt__["cmd.run"](cmd)
95     if "error:" in output:
96         raise CommandExecutionError(
97             output[output.index("error:") + 7 :],
98         )
99     return ('Config value "{}" successfully set.'.format(key),)
100 @salt.utils.decorators.path.which("lxd")
101 @salt.utils.decorators.path.which("lxc")
102 def config_get(key):
103     cmd = 'lxc config get "{}"'.format(key)
104     output = __salt__["cmd.run"](cmd)
105     if "error:" in output:
106         raise CommandExecutionError(
107             output[output.index("error:") + 7 :],
108         )
109     return output
110 def pylxd_client_get(remote_addr=None, cert=None, key=None, verify_cert=True):
111     pool_key = "|".join(
112         (
113             str(remote_addr),
114             str(cert),
115             str(key),
116             str(verify_cert),
117         )
118     )
119     if pool_key in _connection_pool:
120         log.debug('Returning the client "%s" from our connection pool', remote_addr)
121         return _connection_pool[pool_key]
122     try:
123         if remote_addr is None or remote_addr == "/var/lib/lxd/unix.socket":
124             log.debug("Trying to connect to the local unix socket")
125             client = pylxd.Client()
126         else:
127             if remote_addr.startswith("/"):
128                 client = pylxd.Client(remote_addr)
129             else:
130                 if cert is None or key is None:
131                     raise SaltInvocationError(
132                         "You have to give a Cert and Key file for remote endpoints."
133                     )
134                 cert = os.path.expanduser(cert)
135                 key = os.path.expanduser(key)
136                 if not os.path.isfile(cert):
137                     raise SaltInvocationError(
138                         'You have given an invalid cert path: "{}", the '
139                         "file does not exist or is not a file.".format(cert)
140                     )
141                 if not os.path.isfile(key):
142                     raise SaltInvocationError(
143                         'You have given an invalid key path: "{}", the '
144                         "file does not exists or is not a file.".format(key)
145                     )
146                 log.debug(
147                     'Trying to connect to "%s" with cert "%s", key "%s" and '
148                     'verify_cert "%s"',
149                     remote_addr,
150                     cert,
151                     key,
152                     verify_cert,
153                 )
154                 client = pylxd.Client(
155                     endpoint=remote_addr,
156                     cert=(
157                         cert,
158                         key,
159                     ),
160                     verify=verify_cert,
161                 )
162     except pylxd.exceptions.ClientConnectionFailed:
163         raise CommandExecutionError("Failed to connect to '{}'".format(remote_addr))
164     except TypeError as e:
165         raise CommandExecutionError(
166             'Failed to connect to "{}", looks like the SSL verification '
167             "failed, error was: {}".format(remote_addr, str(e))
168         )
169     _connection_pool[pool_key] = client
170     return client
171 def pylxd_save_object(obj):
172     try:
173         obj.save(wait=True)
174     except pylxd.exceptions.LXDAPIException as e:
175         raise CommandExecutionError(str(e))
176     return True
177 def authenticate(remote_addr, password, cert, key, verify_cert=True):
178     client = pylxd_client_get(remote_addr, cert, key, verify_cert)
179     if client.trusted:
180         return True
181     try:
182         client.authenticate(password)
183     except pylxd.exceptions.LXDAPIException as e:
184         raise CommandExecutionError(str(e))
185     return client.trusted
186 def container_list(
187     list_names=False, remote_addr=None, cert=None, key=None, verify_cert=True
188 ):
189     client = pylxd_client_get(remote_addr, cert, key, verify_cert)
190     containers = client.containers.all()
191     if list_names:
192         return [c.name for c in containers]
193     return map(_pylxd_model_to_dict, containers)
194 def container_create(
195     name,
196     source,
197     profiles=None,
198     config=None,
199     devices=None,
200     architecture="x86_64",
201     ephemeral=False,
202     wait=True,
203     remote_addr=None,
204     cert=None,
205     key=None,
206     verify_cert=True,
207     _raw=False,
208 ):
209     if profiles is None:
210         profiles = ["default"]
211     if config is None:
212         config = {}
213     if devices is None:
214         devices = {}
215     client = pylxd_client_get(remote_addr, cert, key, verify_cert)
216     if not isinstance(profiles, (list, tuple, set)):
217         raise SaltInvocationError("'profiles' must be formatted as list/tuple/set.")
218     if architecture not in _architectures:
219         raise SaltInvocationError(
220             "Unknown architecture '{}' given for the container '{}'".format(
221                 architecture, name
222             )
223         )
224     if isinstance(source, str):
225         source = {"type": "image", "alias": source}
226     config, devices = normalize_input_values(config, devices)
227     try:
228         container = client.containers.create(
229             {
230                 "name": name,
231                 "architecture": _architectures[architecture],
232                 "profiles": profiles,
233                 "source": source,
234                 "config": config,
235                 "ephemeral": ephemeral,
236             },
237             wait=wait,
238         )
239     except pylxd.exceptions.LXDAPIException as e:
240         raise CommandExecutionError(str(e))
241     if not wait:
242         return container.json()["operation"]
243     if devices:
244         for dn, dargs in devices.items():
245             container_device_add(name, dn, **dargs)
246     if _raw:
247         return container
248     return _pylxd_model_to_dict(container)
249 def container_get(
250     name=None, remote_addr=None, cert=None, key=None, verify_cert=True, _raw=False
251 ):
252     client = pylxd_client_get(remote_addr, cert, key, verify_cert)
253     if name is None:
254         containers = client.containers.all()
255         if _raw:
256             return containers
257     else:
258         containers = []
259         try:
260             containers = [client.containers.get(name)]
261         except pylxd.exceptions.LXDAPIException:
262             raise SaltInvocationError("Container '{}' not found".format(name))
263         if _raw:
264             return containers[0]
265     infos = []
266     for container in containers:
267         infos.append(dict([(container.name, _pylxd_model_to_dict(container))]))
268     return infos
269 def container_delete(name, remote_addr=None, cert=None, key=None, verify_cert=True):
270     container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
271     container.delete(wait=True)
272     return True
273 def container_rename(
274     name, newname, remote_addr=None, cert=None, key=None, verify_cert=True
275 ):
276     container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
277     if container.status_code == CONTAINER_STATUS_RUNNING:
278         raise SaltInvocationError(
279             "Can't rename the running container '{}'.".format(name)
280         )
281     container.rename(newname, wait=True)
282     return _pylxd_model_to_dict(container)
283 def container_state(name=None, remote_addr=None, cert=None, key=None, verify_cert=True):
284     client = pylxd_client_get(remote_addr, cert, key, verify_cert)
285     if name is None:
286         containers = client.containers.all()
287     else:
288         try:
289             containers = [client.containers.get(name)]
290         except pylxd.exceptions.LXDAPIException:
291             raise SaltInvocationError("Container '{}' not found".format(name))
292     states = []
293     for container in containers:
294         state = {}
295         state = container.state()
296         states.append(
297             dict(
298                 [
299                     (
300                         container.name,
301                         {
302                             k: getattr(state, k)
303                             for k in dir(state)
304                             if not k.startswith("_")
305                         },
306                     )
307                 ]
308             )
309         )
310     return states
311 def container_start(name, remote_addr=None, cert=None, key=None, verify_cert=True):
312     container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
313     container.start(wait=True)
314     return _pylxd_model_to_dict(container)
315 def container_stop(
316     name,
317     timeout=30,
318     force=True,
319     remote_addr=None,
320     cert=None,
321     key=None,
322     verify_cert=True,
323 ):
324     container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
325     container.stop(timeout, force, wait=True)
326     return _pylxd_model_to_dict(container)
327 def container_restart(name, remote_addr=None, cert=None, key=None, verify_cert=True):
328     container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
329     container.restart(wait=True)
330     return _pylxd_model_to_dict(container)
331 def container_freeze(name, remote_addr=None, cert=None, key=None, verify_cert=True):
332     container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
333     container.freeze(wait=True)
334     return _pylxd_model_to_dict(container)
335 def container_unfreeze(name, remote_addr=None, cert=None, key=None, verify_cert=True):
336     container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
337     container.unfreeze(wait=True)
338     return _pylxd_model_to_dict(container)
339 def container_migrate(
340     name,
341     stop_and_start=False,
342     remote_addr=None,
343     cert=None,
344     key=None,
345     verify_cert=True,
346     src_remote_addr=None,
347     src_cert=None,
348     src_key=None,
349     src_verify_cert=None,
350 ):
351     if src_cert is None:
352         src_cert = cert
353     if src_key is None:
354         src_key = key
355     if src_verify_cert is None:
356         src_verify_cert = verify_cert
357     container = container_get(
358         name, src_remote_addr, src_cert, src_key, src_verify_cert, _raw=True
359     )
360     dest_client = pylxd_client_get(remote_addr, cert, key, verify_cert)
361     for pname in container.profiles:
362         try:
363             dest_client.profiles.get(pname)
364         except pylxd.exceptions.LXDAPIException:
365             raise SaltInvocationError(
366                 "not all the profiles from the source exist on the target"
367             )
368     was_running = container.status_code == CONTAINER_STATUS_RUNNING
369     if stop_and_start and was_running:
370         container.stop(wait=True)
371     try:
372         dest_container = container.migrate(dest_client, wait=True)
373         dest_container.profiles = container.profiles
374         dest_container.save()
375     except pylxd.exceptions.LXDAPIException as e:
376         raise CommandExecutionError(str(e))
377     container.delete(wait=True)
378     if stop_and_start and was_running:
379         dest_container.start(wait=True)
380     return _pylxd_model_to_dict(dest_container)
381 def container_config_get(
382     name, config_key, remote_addr=None, cert=None, key=None, verify_cert=True
383 ):
384     container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
385     return _get_property_dict_item(container, "config", config_key)
386 def container_config_set(
387     name,
388     config_key,
389     config_value,
390     remote_addr=None,
391     cert=None,
392     key=None,
393     verify_cert=True,
394 ):
395     container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
396     return _set_property_dict_item(container, "config", config_key, config_value)
397 def container_config_delete(
398     name, config_key, remote_addr=None, cert=None, key=None, verify_cert=True
399 ):
400     container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
401     return _delete_property_dict_item(container, "config", config_key)
402 def container_device_get(
403     name, device_name, remote_addr=None, cert=None, key=None, verify_cert=True
404 ):
405     container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
406     return _get_property_dict_item(container, "devices", device_name)
407 def container_device_add(
408     name,
409     device_name,
410     device_type="disk",
411     remote_addr=None,
412     cert=None,
413     key=None,
414     verify_cert=True,
415     **kwargs
416 ):
417     container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
418     kwargs["type"] = device_type
419     return _set_property_dict_item(container, "devices", device_name, kwargs)
420 def container_device_delete(
421     name, device_name, remote_addr=None, cert=None, key=None, verify_cert=True
422 ):
423     container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
424     return _delete_property_dict_item(container, "devices", device_name)
425 def container_file_put(
426     name,
427     src,
428     dst,
429     recursive=False,
430     overwrite=False,
431     mode=None,
432     uid=None,
433     gid=None,
434     saltenv="base",
435     remote_addr=None,
436     cert=None,
437     key=None,
438     verify_cert=True,
439 ):
440     mode = str(mode)
441     if not mode.startswith("0"):
442         mode = "0{}".format(mode)
443     container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
444     src = os.path.expanduser(src)
445     if not os.path.isabs(src):
446         if src.find("://") &gt;= 0:
447             cached_file = __salt__["cp.cache_file"](src, saltenv=saltenv)
448             if not cached_file:
449                 raise SaltInvocationError("File '{}' not found".format(src))
450             if not os.path.isabs(cached_file):
451                 raise SaltInvocationError("File path must be absolute.")
452             src = cached_file
453     src = src.rstrip(os.path.sep)
454     if not src:
455         src = os.path.sep
456     if not os.path.exists(src):
457         raise CommandExecutionError("No such file or directory '{}'".format(src))
458     if os.path.isdir(src) and not recursive:
459         raise SaltInvocationError(
460             "Cannot copy overwriting a directory without recursive flag set to true!"
461         )
462     try:
463         dst_is_directory = False
464         container.files.get(os.path.join(dst, "."))
465     except pylxd.exceptions.NotFound:
466         pass
467     except pylxd.exceptions.LXDAPIException as why:
468         if str(why).find("Is a directory") &gt;= 0:
469             dst_is_directory = True
470     if os.path.isfile(src):
471         if dst_is_directory:
472             dst = os.path.join(dst, os.path.basename(src))
473             if not overwrite:
474                 found = True
475                 try:
476                     container.files.get(os.path.join(dst))
477                 except pylxd.exceptions.NotFound:
478                     found = False
479                 except pylxd.exceptions.LXDAPIException as why:
480                     if str(why).find("not found") &gt;= 0:
481                         found = False
482                     else:
483                         raise
484                 if found:
485                     raise SaltInvocationError(
486                         "Destination exists and overwrite is false"
487                     )
488         if mode is not None or uid is not None or gid is not None:
489             stat = os.stat(src)
490             if mode is None:
491                 mode = oct(stat.st_mode)
492             if uid is None:
493                 uid = stat.st_uid
494             if gid is None:
495                 gid = stat.st_gid
496         with salt.utils.files.fopen(src, "rb") as src_fp:
497             container.files.put(dst, src_fp.read(), mode=mode, uid=uid, gid=gid)
498         return True
499     elif not os.path.isdir(src):
500         raise SaltInvocationError("Source is neither file nor directory")
501     if dst.endswith(os.sep):
502         idx = len(os.path.dirname(src))
503     elif dst_is_directory:
504         idx = len(src)
505     else:
506         try:
507             container.files.get(os.path.join(os.path.dirname(dst), "."))
508         except pylxd.exceptions.NotFound:
509             pass
510         except pylxd.exceptions.LXDAPIException as why:
511             if str(why).find("Is a directory") &gt;= 0:
512                 dst_is_directory = True
513                 idx = len(src)
514                 overwrite = True
515     if not overwrite:
516         raise SaltInvocationError("Destination exists and overwrite is false")
517     dstdirs = []
518     for path, _, files in os.walk(src):
519         dstdir = os.path.join(dst, path[idx:].lstrip(os.path.sep))
520         dstdirs.append(dstdir)
521     container.execute(["mkdir", "-p"] + dstdirs)
522     set_mode = mode
523     set_uid = uid
524     set_gid = gid
525     for path, _, files in os.walk(src):
526         dstdir = os.path.join(dst, path[idx:].lstrip(os.path.sep))
527         for name in files:
528             src_name = os.path.join(path, name)
529             dst_name = os.path.join(dstdir, name)
530             if mode is not None or uid is not None or gid is not None:
531                 stat = os.stat(src_name)
532                 if mode is None:
533                     set_mode = oct(stat.st_mode)
534                 if uid is None:
535                     set_uid = stat.st_uid
536                 if gid is None:
537                     set_gid = stat.st_gid
538             with salt.utils.files.fopen(src_name, "rb") as src_fp:
539                 container.files.put(
540                     dst_name, src_fp.read(), mode=set_mode, uid=set_uid, gid=set_gid
541                 )
542     return True
543 def container_file_get(
544     name,
545     src,
546     dst,
547     overwrite=False,
548     mode=None,
549     uid=None,
550     gid=None,
551     remote_addr=None,
552     cert=None,
553     key=None,
554     verify_cert=True,
555 ):
556     if mode is not None:
557         mode = str(mode)
558         if not mode.startswith("0"):
559             mode = "0{}".format(mode)
560     container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
561     dst = os.path.expanduser(dst)
562     if not os.path.isabs(dst):
563         raise SaltInvocationError("File path must be absolute.")
564     if os.path.isdir(dst):
565         dst = os.path.join(dst, os.path.basename(src))
566     elif not os.path.isdir(os.path.dirname(dst)):
567         raise SaltInvocationError("Parent directory for destination doesn't exist.")
568     if os.path.exists(dst):
569         if not overwrite:
570             raise SaltInvocationError("Destination exists and overwrite is false.")
571         if not os.path.isfile(dst):
572             raise SaltInvocationError("Destination exists but is not a file.")
573     else:
574         dst_path = os.path.dirname(dst)
575         if not os.path.isdir(dst_path):
576             raise CommandExecutionError(
577                 "No such file or directory '{}'".format(dst_path)
578             )
579     with salt.utils.files.fopen(dst, "wb") as df:
580         df.write(container.files.get(src))
581     if mode:
582         os.chmod(dst, mode)
583     if uid or uid == "0":
584         uid = int(uid)
585     else:
586         uid = -1
587     if gid or gid == "0":
588     else:
589         gid = -1
590     <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>if uid != -1 or gid != -1:
591         os.chown(dst, uid, gid)
592     return True
593 def container_execute(
594     name, cmd, remote_addr=None, cert=None, key=None, verify_cert=True
595 ):
596     container = container_get(name, remote_addr, cert, key, verify_cert, _raw=</b></font>True)
597     try:
598         result = container.execute(cmd)
599         saltresult = {}
600         if not hasattr(result, "exit_code"):
601             saltresult = dict(
602                 exit_code=0,
603                 stdout=result[0],
604                 stderr=result[1],
605             )
606         else:
607             saltresult = dict(
608                 exit_code=result.exit_code,
609                 stdout=result.stdout,
610                 stderr=result.stderr,
611             )
612     except pylxd.exceptions.NotFound as e:
613         saltresult = dict(exit_code=0, stdout="", stderr=str(e))
614     if int(saltresult["exit_code"]) &gt; 0:
615         saltresult["result"] = False
616     else:
617         saltresult["result"] = True
618     return saltresult
619 def profile_list(
620     list_names=False, remote_addr=None, cert=None, key=None, verify_cert=True
621 ):
622     client = pylxd_client_get(remote_addr, cert, key, verify_cert)
623     profiles = client.profiles.all()
624     if list_names:
625         return [p.name for p in profiles]
626     return map(_pylxd_model_to_dict, profiles)
627 def profile_create(
628     name,
629     config=None,
630     devices=None,
631     description=None,
632     remote_addr=None,
633     cert=None,
634     key=None,
635     verify_cert=True,
636 ):
637     client = pylxd_client_get(remote_addr, cert, key, verify_cert)
638     config, devices = normalize_input_values(config, devices)
639     try:
640         profile = client.profiles.create(name, config, devices)
641     except pylxd.exceptions.LXDAPIException as e:
642         raise CommandExecutionError(str(e))
643     if description is not None:
644         profile.description = description
645         pylxd_save_object(profile)
646     return _pylxd_model_to_dict(profile)
647 def profile_get(
648     name, remote_addr=None, cert=None, key=None, verify_cert=True, _raw=False
649 ):
650     client = pylxd_client_get(remote_addr, cert, key, verify_cert)
651     profile = None
652     try:
653         profile = client.profiles.get(name)
654     except pylxd.exceptions.LXDAPIException:
655         raise SaltInvocationError("Profile '{}' not found".format(name))
656     if _raw:
657         return profile
658     return _pylxd_model_to_dict(profile)
659 def profile_delete(name, remote_addr=None, cert=None, key=None, verify_cert=True):
660     """Deletes a profile.
661     profile<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.delete()
662     return True
663 def profile_config_get(
664     name, config_key, remote_addr=None, cert=None, key=None, verify_cert=True
665 ):
666     """Get a profile config item.
667     name :
668         The name of the profile to get the config item from.
669     config_key :
670         The key for the item to retrieve.
671     remote_addr :
672         An URL to a remote Server, you also have to give cert and key if
673         you provide remote_addr and its a TCP Address!
674         Examples:
675             https://myserver.lan:8443
676             /var/lib/mysocket.sock
677     cert :
678         PEM Formatted SSL Certificate.
679         Examples:
680             ~/.config/lxc/client.crt
681     key :
682         PEM Formatted SSL Key.
683         Examples:
684             ~/.config/lxc/client.key
685     verify_cert : True
686         Wherever to verify the cert, this is by default True
687         but in the most cases you want to set it off as LXD
688         normally uses self-signed certificates.
689     CLI Example:
690     .. code-block:: bash
691         salt '*' lxd.profile_config_get autostart boot.autostart
692     """
693     profile = profile_get(name, remote_addr, cert, key, verify_cert, _raw=</b></font>True)
694     return _get_property_dict_item(profile, "config", config_key)
695 def profile_config_set(
696     name,
697     config_key,
698     config_value,
699     remote_addr=None,
700     cert=None,
701     key=None,
702     verify_cert=True,
703 ):
704     """Set a profile config item.
705     name :
706         The name of the profile to set the config item to.
707     config_key :
708         The items key.
709     config_value :
710         Its items value.
711     remote_addr :
712         An URL to a remote Server, you also have to give cert and key if
713         you provide remote_addr and its a TCP Address!
714         Examples:
715             https://myserver.lan:8443
716             /var/lib/mysocket.sock
717     cert :
718         PEM Formatted SSL Certificate.
719         Examples:
720             ~/.config/lxc/client.crt
721     key :
722         PEM Formatted SSL Key.
723         Examples:
724             ~/.config/lxc/client.key
725     verify_cert : True
726         Wherever to verify the cert, this is by default True
727         but in the most cases you want to set it off as LXD
728         normally uses self-signed certificates.
729     CLI Example:
730     .. code-block:: bash
731         salt '*' lxd.profile_config_set autostart boot.autostart 0
732     """
733     profile = profile_get(name, remote_addr, cert, key, verify_cert, _raw=True)
734     return _set_property_dict_item(profile, "config", config_key, config_value)
735 def profile_config_delete(
736     name, config_key, remote_addr=None, cert=None, key=None, verify_cert=True
737 ):
738     """Delete a profile config item.
739     name :
740         The name of the profile to delete the config item.
741     config_key :
742         The config key for the value to retrieve.
743     remote_addr :
744         An URL to a remote Server, you also have to give cert and key if
745         you provide remote_addr and its a TCP Address!
746         Examples:
747             https://myserver.lan:8443
748             /var/lib/mysocket.sock
749     cert :
750         PEM Formatted SSL Certificate.
751         Examples:
752             ~/.config/lxc/client.crt
753     key :
754         PEM Formatted SSL Key.
755         Examples:
756             ~/.config/lxc/client.key
757     verify_cert : True
758         Wherever to verify the cert, this is by default True
759         but in the most cases you want to set it off as LXD
760         normally uses self-signed certificates.
761     CLI Example:
762     .. code-block:: bash
763         salt '*' lxd.profile_config_delete autostart boot.autostart.delay
764     """
765     profile = profile_get(name, remote_addr, cert, key, verify_cert, _raw=True)
766     return _delete_property_dict_item(profile, "config", config_key)
767 def profile_device_get(
768     name, device_name, remote_addr=None, cert=None, key=None, verify_cert=True
769 ):
770     """Get a profile device.
771     name :
772         The name of the profile to get the device from.
773     device_name :
774         The name of the device to retrieve.
775     remote_addr :
776         An URL to a remote Server, you also have to give cert and key if
777         you provide remote_addr and its a TCP Address!
778         Examples:
779             https://myserver.lan:8443
780             /var/lib/mysocket.sock
781     cert :
782         PEM Formatted SSL Certificate.
783         Examples:
784             ~/.config/lxc/client.crt
785     key :
786         PEM Formatted SSL Key.
787         Examples:
788             ~/.config/lxc/client.key
789     verify_cert : True
790         Wherever to verify the cert, this is by default True
791         but in the most cases you want to set it off as LXD
792         normally uses self-signed certificates.
793     CLI Example:
794     .. code-block:: bash
795         salt '*' lxd.profile_device_get default eth0
796     """
797     profile = profile_get(name, remote_addr, cert, key, verify_cert, _raw=True)
798     return _get_property_dict_item(profile, "devices", device_name)
799 def profile_device_set(
800     name,
801     device_name,
802     device_type="disk",
803     remote_addr=None,
804     cert=None,
805     key=None,
806     verify_cert=True,
807     **kwargs
808 ):
809     """Set a profile device.
810     name :
811         The name of the profile to set the device to.
812     device_name :
813         The name of the device to set.
814     remote_addr :
815         An URL to a remote Server, you also have to give cert and key if
816         you provide remote_addr and its a TCP Address!
817         Examples:
818             https://myserver.lan:8443
819             /var/lib/mysocket.sock
820     cert :
821         PEM Formatted SSL Certificate.
822         Examples:
823             ~/.config/lxc/client.crt
824     key :
825         PEM Formatted SSL Key.
826         Examples:
827             ~/.config/lxc/client.key
828     verify_cert : True
829         Wherever to verify the cert, this is by default True
830         but in the most cases you want to set it off as LXD
831         normally uses self-signed certificates.
832     CLI Example:
833     .. code-block:: bash
834         salt '*' lxd.profile_device_set autostart eth1 nic nictype=bridged parent=lxdbr0
835     """
836     profile = profile_get(name, remote_addr, cert, key, verify_cert, _raw=True)
837     kwargs["type"] = device_type
838     for k, v in kwargs.items():
839         kwargs[k] = str(v)
840     return _set_property_dict_item(profile, "devices", device_name, kwargs)
841 def profile_device_delete(
842     name, device_name, remote_addr=None, cert=None, key=None, verify_cert=True
843 ):
844     """Delete a profile device.
845     name :
846         The name of the profile to delete the device.
847     device_name :
848         The name of the device to delete.
849     remote_addr :
850         An URL to a remote Server, you also have to give cert and key if
851         you provide remote_addr and its a TCP Address!
852         Examples:
853             https://myserver.lan:8443
854             /var/lib/mysocket.sock
855     cert :
856         PEM Formatted SSL Certificate.
857         Examples:
858             ~/.config/lxc/client.crt
859     key :
860         PEM Formatted SSL Key.
861         Examples:
862             ~/.config/lxc/client.key
863     verify_cert : True
864         Wherever to verify the cert, this is by default True
865         but in the most cases you want to set it off as LXD
866         normally uses self-signed certificates.
867     CLI Example:
868     .. code-block:: bash
869         salt '*' lxd.profile_device_delete autostart eth1
870     """
871     profile = profile_get(name, remote_addr, cert, key, verify_cert, _raw=True)
872     return _delete_property_dict_item(profile, "devices", device_name)
873 def image_list(
874     list_aliases=False, remote_addr=None, cert=None, key=None, verify_cert=True
875 ):
876     """Lists all images from the LXD.
877     list_aliases :
878         Return a dict with the fingerprint as key and
879         a list of aliases as value instead.
880     remote_addr :
881         An URL to a remote Server, you also have to give cert and key if
882         you provide remote_addr and its a TCP Address!
883         Examples:
884             https://myserver.lan:8443
885             /var/lib/mysocket.sock
886     cert :
887         PEM Formatted SSL Certificate.
888         Examples:
889             ~/.config/lxc/client.crt
890     key :
891         PEM Formatted SSL Key.
892         Examples:
893             ~/.config/lxc/client.key
894     verify_cert : True
895         Wherever to verify the cert, this is by default True
896         but in the most cases you want to set it off as LXD
897         normally uses self-signed certificates.
898     CLI Examples:
899     .. code-block:: bash
900         salt '*' lxd.image_list true --out=json
901         salt '*' lxd.image_list --out=json
902     """
903     client = pylxd_client_get(remote_addr, cert, key, verify_cert)
904     images = client.images.all()
905     if list_aliases:
906         return {i.fingerprint: [a["name"] for a in i.aliases] for i in images}
907     return map(_pylxd_model_to_dict, images)
908 def image_get(
909     fingerprint, remote_addr=None, cert=None, key=None, verify_cert=True, _raw=False
910 ):
911     """Get an image by its fingerprint
912     fingerprint :
913         The fingerprint of the image to retrieve
914     remote_addr :
915         An URL to a remote Server, you also have to give cert and key if
916         you provide remote_addr and its a TCP Address!
917         Examples:
918             https://myserver.lan:8443
919             /var/lib/mysocket.sock
920     cert :
921         PEM Formatted SSL Certificate.
922         Examples:
923             ~/.config/lxc/client.crt
924     key :
925         PEM Formatted SSL Key.
926         Examples:
927             ~/.config/lxc/client.key
928     verify_cert : True
929         Wherever to verify the cert, this is by default True
930         but in the most cases you want to set it off as LXD
931         normally uses self-signed certificates.
932     _raw : False
933         Return the raw pylxd object or a dict of it?
934     CLI Examples:
935     .. code-block:: bash
936         salt '*' lxd.image_get &lt;fingerprint&gt;
937     """
938     client = pylxd_client_get(remote_addr, cert, key, verify_cert)
939     image = None
940     try:
941         image = client.images.get(fingerprint)
942     except pylxd.exceptions.LXDAPIException:
943         raise SaltInvocationError(
944             "Image with fingerprint '{}' not found".format(fingerprint)
945         )
946     if _raw:
947         return image
948     return _pylxd_model_to_dict(image)
949 def image_get_by_alias(
950     alias, remote_addr=None, cert=None, key=None, verify_cert=True, _raw=False
951 ):
952     """Get an image by an alias
953     alias :
954         The alias of the image to retrieve
955     remote_addr :
956         An URL to a remote Server, you also have to give cert and key if
957         you provide remote_addr and its a TCP Address!
958         Examples:
959             https://myserver.lan:8443
960             /var/lib/mysocket.sock
961     cert :
962         PEM Formatted SSL Certificate.
963         Examples:
964             ~/.config/lxc/client.crt
965     key :
966         PEM Formatted SSL Key.
967         Examples:
968             ~/.config/lxc/client.key
969     verify_cert : True
970         Wherever to verify the cert, this is by default True
971         but in the most cases you want to set it off as LXD
972         normally uses self-signed certificates.
973     _raw : False
974         Return the raw pylxd object or a dict of it?
975     CLI Examples:
976     .. code-block:: bash
977         salt '*' lxd.image_get_by_alias xenial/amd64
978     """
979     client = pylxd_client_get(remote_addr, cert, key, verify_cert)
980     image = None
981     try:
982         image = client.images.get_by_alias(alias)
983     except pylxd.exceptions.LXDAPIException:
984         raise SaltInvocationError("Image with alias '{}' not found".format(alias))
985     if _raw:
986         return image
987     return _pylxd_model_to_dict(image)
988 def image_delete(image, remote_addr=None, cert=None, key=None, verify_cert=True):
989     """Delete an image by an alias or fingerprint
990     name :
991         The alias or fingerprint of the image to delete,
992         can be a obj for the states.
993     remote_addr :
994         An URL to a remote Server, you also have to give cert and key if
995         you provide remote_addr and its a TCP Address!
996         Examples:
997             https://myserver.lan:8443
998             /var/lib/mysocket.sock
999     cert :
1000         PEM Formatted SSL Certificate.
1001         Examples:
1002             ~/.config/lxc/client.crt
1003     key :
1004         PEM Formatted SSL Key.
1005         Examples:
1006             ~/.config/lxc/client.key
1007     verify_cert : True
1008         Wherever to verify the cert, this is by default True
1009         but in the most cases you want to set it off as LXD
1010         normally uses self-signed certificates.
1011     CLI Examples:
1012     .. code-block:: bash
1013         salt '*' lxd.image_delete xenial/amd64
1014     """
1015     image = _verify_image(image, remote_addr, cert, key, verify_cert)
1016     image.delete()
1017     return True
1018 def image_from_simplestreams(
1019     server,
1020     alias,
1021     remote_addr=None,
1022     cert=None,
1023     key=None,
1024     verify_cert=True,
1025     aliases=None,
1026     public=False,
1027     auto_update=False,
1028     _raw=False,
1029 ):
1030     """Create an image from simplestreams
1031     server :
1032         Simplestreams server URI
1033     alias :
1034         The alias of the image to retrieve
1035     remote_addr :
1036         An URL to a remote Server, you also have to give cert and key if
1037         you provide remote_addr and its a TCP Address!
1038         Examples:
1039             https://myserver.lan:8443
1040             /var/lib/mysocket.sock
1041     cert :
1042         PEM Formatted SSL Certificate.
1043         Examples:
1044             ~/.config/lxc/client.crt
1045     key :
1046         PEM Formatted SSL Key.
1047         Examples:
1048             ~/.config/lxc/client.key
1049     verify_cert : True
1050         Wherever to verify the cert, this is by default True
1051         but in the most cases you want to set it off as LXD
1052         normally uses self-signed certificates.
1053     aliases : []
1054         List of aliases to append to the copied image
1055     public : False
1056         Make this image public available
1057     auto_update : False
1058         Should LXD auto update that image?
1059     _raw : False
1060         Return the raw pylxd object or a dict of the image?
1061     CLI Examples:
1062     .. code-block:: bash
1063         salt '*' lxd.image_from_simplestreams "https://cloud-images.ubuntu.com/releases" "trusty/amd64" aliases='["t", "trusty/amd64"]' auto_update=True
1064     """
1065     if aliases is None:
1066         aliases = []
1067     client = pylxd_client_get(remote_addr, cert, key, verify_cert)
1068     try:
1069         image = client.images.create_from_simplestreams(
1070             server, alias, public=public, auto_update=auto_update
1071         )
1072     except pylxd.exceptions.LXDAPIException as e:
1073         raise CommandExecutionError(str(e))
1074     for alias in aliases:
1075         image_alias_add(image, alias)
1076     if _raw:
1077         return image
1078     return _pylxd_model_to_dict(image)
1079 def image_from_url(
1080     url,
1081     remote_addr=None,
1082     cert=None,
1083     key=None,
1084     verify_cert=True,
1085     aliases=None,
1086     public=False,
1087     auto_update=False,
1088     _raw=False,
1089 ):
1090     """Create an image from an url
1091     url :
1092         The URL from where to download the image
1093     remote_addr :
1094         An URL to a remote Server, you also have to give cert and key if
1095         you provide remote_addr and its a TCP Address!
1096         Examples:
1097             https://myserver.lan:8443
1098             /var/lib/mysocket.sock
1099     cert :
1100         PEM Formatted SSL Certificate.
1101         Examples:
1102             ~/.config/lxc/client.crt
1103     key :
1104         PEM Formatted SSL Key.
1105         Examples:
1106             ~/.config/lxc/client.key
1107     verify_cert : True
1108         Wherever to verify the cert, this is by default True
1109         but in the most cases you want to set it off as LXD
1110         normally uses self-signed certificates.
1111     aliases : []
1112         List of aliases to append to the copied image
1113     public : False
1114         Make this image public available
1115     auto_update : False
1116         Should LXD auto update that image?
1117     _raw : False
1118         Return the raw pylxd object or a dict of the image?
1119     CLI Examples:
1120     .. code-block:: bash
1121         salt '*' lxd.image_from_url https://dl.stgraber.org/lxd aliases='["busybox-amd64"]'
1122     """
1123     if aliases is None:
1124         aliases = []
1125     client = pylxd_client_get(remote_addr, cert, key, verify_cert)
1126     try:
1127         image = client.images.create_from_url(
1128             url, public=public, auto_update=auto_update
1129         )
1130     except pylxd.exceptions.LXDAPIException as e:
1131         raise CommandExecutionError(str(e))
1132     for alias in aliases:
1133         image_alias_add(image, alias)
1134     if _raw:
1135         return image
1136     return _pylxd_model_to_dict(image)
1137 def image_from_file(
1138     filename,
1139     remote_addr=None,
1140     cert=None,
1141     key=None,
1142     verify_cert=True,
1143     aliases=None,
1144     public=False,
1145     saltenv="base",
1146     _raw=False,
1147 ):
1148     """Create an image from a file
1149     filename :
1150         The filename of the rootfs
1151     remote_addr :
1152         An URL to a remote Server, you also have to give cert and key if
1153         you provide remote_addr and its a TCP Address!
1154         Examples:
1155             https://myserver.lan:8443
1156             /var/lib/mysocket.sock
1157     cert :
1158         PEM Formatted SSL Certificate.
1159         Examples:
1160             ~/.config/lxc/client.crt
1161     key :
1162         PEM Formatted SSL Key.
1163         Examples:
1164             ~/.config/lxc/client.key
1165     verify_cert : True
1166         Wherever to verify the cert, this is by default True
1167         but in the most cases you want to set it off as LXD
1168         normally uses self-signed certificates.
1169     aliases : []
1170         List of aliases to append to the copied image
1171     public : False
1172         Make this image public available
1173     saltenv : base
1174         The saltenv to use for salt:// copies
1175     _raw : False
1176         Return the raw pylxd object or a dict of the image?
1177     CLI Examples:
1178     .. code-block:: bash
1179         salt '*' lxd.image_from_file salt://lxd/files/busybox.tar.xz aliases=["busybox-amd64"]
1180     """
1181     if aliases is None:
1182         aliases = []
1183     cached_file = __salt__["cp.cache_file"](filename, saltenv=saltenv)
1184     data = b""
1185     with salt.utils.files.fopen(cached_file, "r+b") as fp:
1186         data = fp.read()
1187     client = pylxd_client_get(remote_addr, cert, key, verify_cert)
1188     try:
1189         image = client.images.create(data, public=public, wait=True)
1190     except pylxd.exceptions.LXDAPIException as e:
1191         raise CommandExecutionError(str(e))
1192     for alias in aliases:
1193         image_alias_add(image, alias)
1194     if _raw:
1195         return image
1196     return _pylxd_model_to_dict(image)
1197 def image_copy_lxd(
1198     source,
1199     src_remote_addr,
1200     src_cert,
1201     src_key,
1202     src_verify_cert,
1203     remote_addr,
1204     cert,
1205     key,
1206     verify_cert=True,
1207     aliases=None,
1208     public=None,
1209     auto_update=None,
1210     _raw=False,
1211 ):
1212     """Copy an image from another LXD instance
1213     source :
1214         An alias or a fingerprint of the source.
1215     src_remote_addr :
1216         An URL to the source remote daemon
1217         Examples:
1218             https://mysourceserver.lan:8443
1219     src_cert :
1220         PEM Formatted SSL Certificate for the source
1221         Examples:
1222             ~/.config/lxc/client.crt
1223     src_key :
1224         PEM Formatted SSL Key for the source
1225         Examples:
1226             ~/.config/lxc/client.key
1227     src_verify_cert : True
1228         Wherever to verify the cert, this is by default True
1229         but in the most cases you want to set it off as LXD
1230         normally uses self-signed certificates.
1231     remote_addr :
1232         Address of the destination daemon
1233         Examples:
1234             https://mydestserver.lan:8443
1235     cert :
1236         PEM Formatted SSL Certificate for the destination
1237         Examples:
1238             ~/.config/lxc/client.crt
1239     key :
1240         PEM Formatted SSL Key for the destination
1241         Examples:
1242             ~/.config/lxc/client.key
1243     verify_cert : True
1244         Wherever to verify the cert, this is by default True
1245         but in the most cases you want to set it off as LXD
1246         normally uses self-signed certificates.
1247     aliases : []
1248         List of aliases to append to the copied image
1249     public : None
1250         Make this image public available, None = copy source
1251     auto_update : None
1252         Wherever to auto-update from the original source, None = copy source
1253     _raw : False
1254         Return the raw pylxd object or a dict of the destination image?
1255     CLI Examples:
1256     .. code-block:: bash
1257         salt '*' lxd.image_copy_lxd xenial/amd64 https://srv01:8443 ~/.config/lxc/client.crt ~/.config/lxc/client.key false https://srv02:8443 ~/.config/lxc/client.crt ~/.config/lxc/client.key false aliases="['xenial/amd64']"
1258     """
1259     if aliases is None:
1260         aliases = []
1261     log.debug(
1262         'Trying to copy the image "%s" from "%s" to "%s"',
1263         source,
1264         src_remote_addr,
1265         remote_addr,
1266     )
1267     src_image = None
1268     try:
1269         src_image = image_get_by_alias(
1270             source, src_remote_addr, src_cert, src_key, src_verify_cert, _raw=True
1271         )
1272     except SaltInvocationError:
1273         src_image = image_get(
1274             source, src_remote_addr, src_cert, src_key, src_verify_cert, _raw=True
1275         )
1276     dest_client = pylxd_client_get(remote_addr, cert, key, verify_cert)
1277     dest_image = src_image.copy(
1278         dest_client, public=public, auto_update=auto_update, wait=True
1279     )
1280     for alias in aliases:
1281         image_alias_add(dest_image, alias)
1282     if _raw:
1283         return dest_image
1284     return _pylxd_model_to_dict(dest_image)
1285 def image_alias_add(
1286     image,
1287     alias,
1288     description="",
1289     remote_addr=None,
1290     cert=None,
1291     key=None,
1292     verify_cert=True,
1293 ):
1294     """Create an alias on the given image
1295     image :
1296         An image alias, a fingerprint or a image object
1297     alias :
1298         The alias to add
1299     description :
1300         Description of the alias
1301     remote_addr :
1302         An URL to a remote Server, you also have to give cert and key if
1303         you provide remote_addr and its a TCP Address!
1304         Examples:
1305             https://myserver.lan:8443
1306             /var/lib/mysocket.sock
1307     cert :
1308         PEM Formatted SSL Certificate.
1309         Examples:
1310             ~/.config/lxc/client.crt
1311     key :
1312         PEM Formatted SSL Key.
1313         Examples:
1314             ~/.config/lxc/client.key
1315     verify_cert : True
1316         Wherever to verify the cert, this is by default True
1317         but in the most cases you want to set it off as LXD
1318         normally uses self-signed certificates.
1319     CLI Examples:
1320     .. code-block:: bash
1321         salt '*' lxd.image_alias_add xenial/amd64 x "Short version of xenial/amd64"
1322     """
1323     image = _verify_image(image, remote_addr, cert, key, verify_cert)
1324     for alias_info in image.aliases:
1325         if alias_info["name"] == alias:
1326             return True
1327     image.add_alias(alias, description)
1328     return True
1329 def image_alias_delete(
1330     image, alias, remote_addr=None, cert=None, key=None, verify_cert=True
1331 ):
1332     """Delete an alias (this is currently not restricted to the image)
1333     image :
1334         An image alias, a fingerprint or a image object
1335     alias :
1336         The alias to delete
1337     remote_addr :
1338         An URL to a remote Server, you also have to give cert and key if
1339         you provide remote_addr and its a TCP Address!
1340         Examples:
1341             https://myserver.lan:8443
1342             /var/lib/mysocket.sock
1343     cert :
1344         PEM Formatted SSL Certificate.
1345         Examples:
1346             ~/.config/lxc/client.crt
1347     key :
1348         PEM Formatted SSL Key.
1349         Examples:
1350             ~/.config/lxc/client.key
1351     verify_cert : True
1352         Wherever to verify the cert, this is by default True
1353         but in the most cases you want to set it off as LXD
1354         normally uses self-signed certificates.
1355     CLI Examples:
1356     .. code-block:: bash
1357         salt '*' lxd.image_alias_add xenial/amd64 x "Short version of xenial/amd64"
1358     """
1359     image = _verify_image(image, remote_addr, cert, key, verify_cert)
1360     try:
1361         image.delete_alias(alias)
1362     except pylxd.exceptions.LXDAPIException:
1363         return False
1364     return True
1365 def snapshots_all(container, remote_addr=None, cert=None, key=None, verify_cert=True):
1366     """
1367     Get all snapshots for a container
1368     container :
1369         The name of the container to get.
1370     remote_addr :
1371         An URL to a remote server. The 'cert' and 'key' fields must also be
1372         provided if 'remote_addr' is defined.
1373         Examples:
1374             https://myserver.lan:8443
1375             /var/lib/mysocket.sock
1376     cert :
1377         PEM Formatted SSL Certificate.
1378         Examples:
1379             ~/.config/lxc/client.crt
1380     key :
1381         PEM Formatted SSL Key.
1382         Examples:
1383             ~/.config/lxc/client.key
1384     verify_cert : True
1385         Verify the ssl certificate.  Default: True
1386     CLI Examples:
1387     .. code-block:: bash
1388         salt '*' lxd.snapshots_all test-container
1389     """
1390     containers = container_get(
1391         container, remote_addr, cert, key, verify_cert, _raw=True
1392     )
1393     if container:
1394         containers = [containers]
1395     ret = {}
1396     for cont in containers:
1397         ret.update({cont.name: [{"name": c.name} for c in cont.snapshots.all()]})
1398     return ret
1399 def snapshots_create(
1400     container, name=None, remote_addr=None, cert=None, key=None, verify_cert=True
1401 ):
1402     """
1403     Create a snapshot for a container
1404     container :
1405         The name of the container to get.
1406     name :
1407         The name of the snapshot.
1408     remote_addr :
1409         An URL to a remote server. The 'cert' and 'key' fields must also be
1410         provided if 'remote_addr' is defined.
1411         Examples:
1412             https://myserver.lan:8443
1413             /var/lib/mysocket.sock
1414     cert :
1415         PEM Formatted SSL Certificate.
1416         Examples:
1417             ~/.config/lxc/client.crt
1418     key :
1419         PEM Formatted SSL Key.
1420         Examples:
1421             ~/.config/lxc/client.key
1422     verify_cert : True
1423         Verify the ssl certificate.  Default: True
1424     CLI Examples:
1425     .. code-block:: bash
1426         salt '*' lxd.snapshots_create test-container test-snapshot
1427     """
1428     cont = container_get(container, remote_addr, cert, key, verify_cert, _raw=True)
1429     if not name:
1430         name = datetime.now().strftime("%Y%m%d%H%M%S")
1431     cont.snapshots.create(name)
1432     for c in snapshots_all(container).get(container):
1433         if c.get("name") == name:
1434             return {"name": name}
1435     return {"name": False}
1436 def snapshots_delete(
1437     container, name, remote_addr=None, cert=None, key=None, verify_cert=True
1438 ):
1439     """
1440     Delete a snapshot for a container
1441     container :
1442         The name of the container to get.
1443     name :
1444         The name of the snapshot.
1445     remote_addr :
1446         An URL to a remote server. The 'cert' and 'key' fields must also be
1447         provided if 'remote_addr' is defined.
1448         Examples:
1449             https://myserver.lan:8443
1450             /var/lib/mysocket.sock
1451     cert :
1452         PEM Formatted SSL Certificate.
1453         Examples:
1454             ~/.config/lxc/client.crt
1455     key :
1456         PEM Formatted SSL Key.
1457         Examples:
1458             ~/.config/lxc/client.key
1459     verify_cert : True
1460         Verify the ssl certificate.  Default: True
1461     CLI Examples:
1462     .. code-block:: bash
1463         salt '*' lxd.snapshots_delete test-container test-snapshot
1464     """
1465     cont = container_get(container, remote_addr, cert, key, verify_cert, _raw=True)
1466     try:
1467         for s in cont.snapshots.all():
1468             if s.name == name:
1469                 s.delete()
1470                 return True
1471     except pylxd.exceptions.LXDAPIException:
1472         pass
1473     return False
1474 def snapshots_get(
1475     container, name, remote_addr=None, cert=None, key=None, verify_cert=True
1476 ):
1477     """
1478     Get information about snapshot for a container
1479     container :
1480         The name of the container to get.
1481     name :
1482         The name of the snapshot.
1483     remote_addr :
1484         An URL to a remote server. The 'cert' and 'key' fields must also be
1485         provided if 'remote_addr' is defined.
1486         Examples:
1487             https://myserver.lan:8443
1488             /var/lib/mysocket.sock
1489     cert :
1490         PEM Formatted SSL Certificate.
1491         Examples:
1492             ~/.config/lxc/client.crt
1493     key :
1494         PEM Formatted SSL Key.
1495         Examples:
1496             ~/.config/lxc/client.key
1497     verify_cert : True
1498         Verify the ssl certificate.  Default: True
1499     CLI Examples:
1500     .. code-block:: bash
1501         salt '*' lxd.snapshots_get test-container test-snapshot
1502     """
1503     container = container_get(container, remote_addr, cert, key, verify_cert, _raw=True)
1504     return container.snapshots.get(name)
1505 def normalize_input_values(config, devices):
1506     """
1507     normalize config input so returns can be put into mongodb, which doesn't like `.`
1508     This is not meant to be used on the commandline.
1509     CLI Examples:
1510     .. code-block:: bash
1511         salt '*' lxd.normalize_input_values config={} devices={}
1512     """
1513     if isinstance(config, list):
1514         if config and "key" in config[0] and "value" in config[0]:
1515             config = {d["key"]: d["value"] for d in config}
1516         else:
1517             config = {}
1518     if isinstance(config, str):
1519         raise SaltInvocationError("config can't be a string, validate your YAML input.")
1520     if isinstance(devices, str):
1521         raise SaltInvocationError(
1522             "devices can't be a string, validate your YAML input."
1523         )
1524     if config is not None:
1525         for k, v in config.items():
1526             config[k] = str(v)
1527     if devices is not None:
1528         for dn in devices:
1529             for k, v in devices[dn].items():
1530                 devices[dn][k] = v
1531     return (
1532         config,
1533         devices,
1534     )
1535 def sync_config_devices(obj, newconfig, newdevices, test=False):
1536     """Syncs the given config and devices with the object
1537     (a profile or a container)
1538     returns a changes dict with all changes made.
1539     obj :
1540         The object to sync with / or just test with.
1541     newconfig:
1542         The new config to check with the obj.
1543     newdevices:
1544         The new devices to check with the obj.
1545     test:
1546         Wherever to not change anything and give "Would change" message.
1547     """
1548     changes = {}
1549     if newconfig is None:
1550         newconfig = {}
1551     newconfig = dict(
1552         list(zip(map(str, newconfig.keys()), map(str, newconfig.values())))
1553     )
1554     cck = set(newconfig.keys())
1555     obj.config = dict(
1556         list(zip(map(str, obj.config.keys()), map(str, obj.config.values())))
1557     )
1558     ock = set(obj.config.keys())
1559     config_changes = {}
1560     for k in ock.difference(cck):
1561         if k.startswith("volatile.") or k.startswith("image."):
1562             continue
1563         if not test:
1564             config_changes[k] = 'Removed config key "{}", its value was "{}"'.format(
1565                 k, obj.config[k]
1566             )
1567             del obj.config[k]
1568         else:
1569             config_changes[k] = 'Would remove config key "{} with value "{}"'.format(
1570                 k, obj.config[k]
1571             )
1572     for k in cck.intersection(ock):
1573         if k.startswith("volatile.") or k.startswith("image."):
1574             continue
1575         if newconfig[k] != obj.config[k]:
1576             if not test:
1577                 config_changes[
1578                     k
1579                 ] = 'Changed config key "{}" to "{}", its value was "{}"'.format(
1580                     k, newconfig[k], obj.config[k]
1581                 )
1582                 obj.config[k] = newconfig[k]
1583             else:
1584                 config_changes[
1585                     k
1586                 ] = 'Would change config key "{}" to "{}", its current value is "{}"'.format(
1587                     k, newconfig[k], obj.config[k]
1588                 )
1589     for k in cck.difference(ock):
1590         if k.startswith("volatile.") or k.startswith("image."):
1591             continue
1592         if not test:
1593             config_changes[k] = 'Added config key "{}" = "{}"'.format(k, newconfig[k])
1594             obj.config[k] = newconfig[k]
1595         else:
1596             config_changes[k] = 'Would add config key "{}" = "{}"'.format(
1597                 k, newconfig[k]
1598             )
1599     if config_changes:
1600         changes["config"] = config_changes
1601     if newdevices is None:
1602         newdevices = {}
1603     dk = set(obj.devices.keys())
1604     ndk = set(newdevices.keys())
1605     devices_changes = {}
1606     for k in dk.difference(ndk):
1607         if k == "root":
1608             continue
1609         if not test:
1610             devices_changes[k] = 'Removed device "{}"'.format(k)
1611             del obj.devices[k]
1612         else:
1613             devices_changes[k] = 'Would remove device "{}"'.format(k)
1614     for k, v in obj.devices.items():
1615         if k == "root":
1616             continue
1617         if k not in newdevices:
1618             continue
1619         if newdevices[k] != v:
1620             if not test:
1621                 devices_changes[k] = 'Changed device "{}"'.format(k)
1622                 obj.devices[k] = newdevices[k]
1623             else:
1624                 devices_changes[k] = 'Would change device "{}"'.format(k)
1625     for k in ndk.difference(dk):
1626         if k == "root":
1627             continue
1628         if not test:
1629             devices_changes[k] = 'Added device "{}"'.format(k)
1630             obj.devices[k] = newdevices[k]
1631         else:
1632             devices_changes[k] = 'Would add device "{}"'.format(k)
1633     if devices_changes:
1634         changes["devices"] = devices_changes
1635     return changes
1636 def _set_property_dict_item(obj, prop, key, value):
1637     """Sets the dict item key of the attr from obj.
1638     Basicaly it does getattr(obj, prop)[key] = value.
1639     For the disk device we added some checks to make
1640     device changes on the CLI saver.
1641     """
1642     attr = getattr(obj, prop)
1643     if prop == "devices":
1644         device_type = value["type"]
1645         if device_type == "disk":
1646             if "path" not in value:
1647                 raise SaltInvocationError("path must be given as parameter")
1648             if value["path"] != "/" and "source" not in value:
1649                 raise SaltInvocationError("source must be given as parameter")
1650         for k in value.keys():
1651             if k.startswith("__"):
1652                 del value[k]
1653         attr[key] = value
1654     else:  # config
1655         attr[key] = str(value)
1656     pylxd_save_object(obj)
1657     return _pylxd_model_to_dict(obj)
1658 def _get_property_dict_item(obj, prop, key):
1659     attr = getattr(obj, prop)
1660     if key not in attr:
1661         raise SaltInvocationError("'{}' doesn't exists".format(key))
1662     return attr[key]
1663 def _delete_property_dict_item(obj, prop, key):
1664     attr = getattr(obj, prop)
1665     if key not in attr:
1666         raise SaltInvocationError("'{}' doesn't exists".format(key))
1667     del attr[key]
1668     pylxd_save_object(obj)
1669     return True
1670 def _verify_image(image, remote_addr=None, cert=None, key=None, verify_cert=True):
1671     if isinstance(image, str):
1672         name = image
1673         image = None
1674         try:
1675             image = image_get_by_alias(
1676                 name, remote_addr, cert, key, verify_cert, _raw=True
1677             )
1678         except SaltInvocationError:
1679             image = image_get(name, remote_addr, cert, key, verify_cert, _raw=True)
1680     elif not hasattr(image, "fingerprint"):
1681         raise SaltInvocationError("Invalid image '{}'".format(image))
1682     return image
1683 def _pylxd_model_to_dict(obj):
1684     marshalled = {}
1685     for key in obj.__attributes__.keys():
1686         if hasattr(obj, key):
1687             marshalled[key] = getattr(obj, key)
1688     return marshalled
1689 if HAS_PYLXD:
1690     import pylxd.exceptions  # NOQA
1691     if not hasattr(pylxd.exceptions, "NotFound"):
1692         class NotFound(pylxd.exceptions.LXDAPIException):
1693         pylxd.exceptions.NotFound = NotFound
1694     try:
1695         from pylxd.container import Container
1696     except ImportError:
1697         from pylxd.models.container import Container
1698     class FilesManager(Container.FilesManager):
1699         def put(self, filepath, data, mode=None, uid=None, gid=None):
1700             headers = {}
1701             if mode is not None:
1702                 if isinstance(mode, int):
1703                     mode = oct(mode)
1704                 elif not mode.startswith("0"):
1705                     mode = "0{}".format(mode)
1706                 headers["X-LXD-mode"] = mode
1707             if uid is not None:
1708                 headers["X-LXD-uid"] = str(uid)
1709             if gid is not None:
1710                 headers["X-LXD-gid"] = str(gid)
1711             response = self._client.api.containers[self._container.name].files.post(
1712                 params={"path": filepath}, data=data, headers=headers
1713             )
1714             return response.status_code == 200
1715     Container.FilesManager = FilesManager
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
