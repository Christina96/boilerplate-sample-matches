<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for boto3_sns_1.py &amp; lxd_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for boto3_sns_1.py &amp; lxd_1.py
      </h3>
<h1 align="center">
        1.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>boto3_sns_1.py (5.6034484%)<th>lxd_1.py (1.1882998%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(69-84)<td><a href="#" name="0">(1810-1862)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(162-176)<td><a href="#" name="1">(2121-2167)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto3_sns_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import logging
import salt.utils.versions
log = logging.getLogger(__name__)
try:
    import botocore
    import boto3
    import jmespath
    logging.getLogger("boto3").setLevel(logging.CRITICAL)
    HAS_BOTO = True
except ImportError:
    HAS_BOTO = False
def __virtual__():
    has_boto_reqs = salt.utils.versions.check_boto_reqs()
    <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>if has_boto_reqs is True:
        __utils__["boto3.assign_funcs"](__name__, "sns")
    return has_boto_reqs
def list_topics(region=None, key=None, keyid=None, profile=None):
    conn = _get_conn(region=</b></font>region, key=key, keyid=keyid, profile=profile)
    res = {}
    NextToken = ""
    while NextToken is not None:
        ret = conn.list_topics(NextToken=NextToken)
        NextToken = ret.get("NextToken", None)
        arns = jmespath.search("Topics[*].TopicArn", ret)
        for t in arns:
            short_name = t.split(":")[-1]
            res[short_name] = t
    return res
def describe_topic(name, region=None, key=None, keyid=None, profile=None):
    topics = list_topics(region=region, key=key, keyid=keyid, profile=profile)
    ret = {}
    for topic, arn in topics.items():
        if name in (topic, arn):
            ret = {"TopicArn": arn}
            ret["Subscriptions"] = list_subscriptions_by_topic(
                arn, region=region, key=key, keyid=keyid, profile=profile
            )
            ret["Attributes"] = get_topic_attributes(
                arn, region=region, key=key, keyid=keyid, profile=profile
            )
            for sub in ret["Subscriptions"]:
                sub_arn = sub["SubscriptionArn"]
                if not sub_arn.startswith("arn:aws:sns:"):
                    log.debug("Subscription with invalid ARN %s skipped...", sub_arn)
                    continue
    return ret
def topic_exists(name, region=None, key=None, keyid=None, profile=None):
    topics = list_topics(region=region, key=key, keyid=keyid, profile=profile)
    return name in list(topics.values() + topics.keys())
def create_topic(Name, region=None, key=None, keyid=None, profile=None):
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    try:
        ret = conn.create_topic(Name=Name)
        log.info("SNS topic %s created with ARN %s", Name, ret["TopicArn"])
        return ret["TopicArn"]
    except botocore.exceptions.ClientError as e:
<a name="1"></a>        log.error("Failed to create SNS topic %s: %s", Name, e)
        return None
    except KeyError:
        log<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.error("Failed to create SNS topic %s", Name)
        return None
def delete_topic(TopicArn, region=None, key=None, keyid=None, profile=None):
    conn = _get_conn(region=</b></font>region, key=key, keyid=keyid, profile=profile)
    try:
        conn.delete_topic(TopicArn=TopicArn)
        log.info("SNS topic %s deleted", TopicArn)
        return True
    except botocore.exceptions.ClientError as e:
        log.error("Failed to delete SNS topic %s: %s", name, e)
        return False
def get_topic_attributes(TopicArn, region=None, key=None, keyid=None, profile=None):
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    try:
        return conn.get_topic_attributes(TopicArn=TopicArn).get("Attributes")
    except botocore.exceptions.ClientError as e:
        log.error("Failed to garner attributes for SNS topic %s: %s", TopicArn, e)
        return None
def set_topic_attributes(
    TopicArn,
    AttributeName,
    AttributeValue,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    try:
        conn.set_topic_attributes(
            TopicArn=TopicArn,
            AttributeName=AttributeName,
            AttributeValue=AttributeValue,
        )
        log.debug(
            "Set attribute %s=%s on SNS topic %s",
            AttributeName,
            AttributeValue,
            TopicArn,
        )
        return True
    except botocore.exceptions.ClientError as e:
        log.error(
            "Failed to set attribute %s=%s for SNS topic %s: %s",
            AttributeName,
            AttributeValue,
            TopicArn,
            e,
        )
        return False
def list_subscriptions_by_topic(
    TopicArn, region=None, key=None, keyid=None, profile=None
):
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    NextToken = ""
    res = []
    try:
        while NextToken is not None:
            ret = conn.list_subscriptions_by_topic(
                TopicArn=TopicArn, NextToken=NextToken
            )
            NextToken = ret.get("NextToken", None)
            subs = ret.get("Subscriptions", [])
            res += subs
    except botocore.exceptions.ClientError as e:
        log.error("Failed to list subscriptions for SNS topic %s: %s", TopicArn, e)
        return None
    return res
def list_subscriptions(region=None, key=None, keyid=None, profile=None):
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    NextToken = ""
    res = []
    try:
        while NextToken is not None:
            ret = conn.list_subscriptions(NextToken=NextToken)
            NextToken = ret.get("NextToken", None)
            subs = ret.get("Subscriptions", [])
            res += subs
    except botocore.exceptions.ClientError as e:
        log.error("Failed to list SNS subscriptions: %s", e)
        return None
    return res
def get_subscription_attributes(
    SubscriptionArn, region=None, key=None, keyid=None, profile=None
):
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    try:
        ret = conn.get_subscription_attributes(SubscriptionArn=SubscriptionArn)
        return ret["Attributes"]
    except botocore.exceptions.ClientError as e:
        log.error(
            "Failed to list attributes for SNS subscription %s: %s", SubscriptionArn, e
        )
        return None
    except KeyError:
        log.error("Failed to list attributes for SNS subscription %s", SubscriptionArn)
        return None
def set_subscription_attributes(
    SubscriptionArn,
    AttributeName,
    AttributeValue,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    try:
        conn.set_subscription_attributes(
            SubscriptionArn=SubscriptionArn,
            AttributeName=AttributeName,
            AttributeValue=AttributeValue,
        )
        log.debug(
            "Set attribute %s=%s on SNS subscription %s",
            AttributeName,
            AttributeValue,
            SubscriptionArn,
        )
        return True
    except botocore.exceptions.ClientError as e:
        log.error(
            "Failed to set attribute %s=%s for SNS subscription %s: %s",
            AttributeName,
            AttributeValue,
            SubscriptionArn,
            e,
        )
        return False
def subscribe(
    TopicArn, Protocol, Endpoint, region=None, key=None, keyid=None, profile=None
):
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    try:
        ret = conn.subscribe(TopicArn=TopicArn, Protocol=Protocol, Endpoint=Endpoint)
        log.info(
            "Subscribed %s %s to topic %s with SubscriptionArn %s",
            Protocol,
            Endpoint,
            TopicArn,
            ret["SubscriptionArn"],
        )
        return ret["SubscriptionArn"]
    except botocore.exceptions.ClientError as e:
        log.error("Failed to create subscription to SNS topic %s: %s", TopicArn, e)
        return None
    except KeyError:
        log.error("Failed to create subscription to SNS topic %s", TopicArn)
        return None
def unsubscribe(SubscriptionArn, region=None, key=None, keyid=None, profile=None):
    if not SubscriptionArn.startswith("arn:aws:sns:"):
        log.info(
            "Invalid subscription ARN `%s` passed - likely a PendingConfirmaton or"
            " such.  Skipping unsubscribe attempt as it would almost certainly fail...",
            SubscriptionArn,
        )
        return True
    subs = list_subscriptions(region=region, key=key, keyid=keyid, profile=profile)
    sub = [s for s in subs if s.get("SubscriptionArn") == SubscriptionArn]
    if not sub:
        log.error("Subscription ARN %s not found", SubscriptionArn)
        return False
    TopicArn = sub[0]["TopicArn"]
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    try:
        conn.unsubscribe(SubscriptionArn=SubscriptionArn)
        log.info("Deleted subscription %s from SNS topic %s", SubscriptionArn, TopicArn)
        return True
    except botocore.exceptions.ClientError as e:
        log.error("Failed to delete subscription %s: %s", SubscriptionArn, e)
        return False
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>lxd_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import logging
import os
from datetime import datetime
import salt.utils.decorators.path
import salt.utils.files
from salt.exceptions import CommandExecutionError, SaltInvocationError
from salt.utils.versions import LooseVersion
try:
    import pylxd
    HAS_PYLXD = True
    import urllib3
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
except ImportError:
    HAS_PYLXD = False
log = logging.getLogger(__name__)
__docformat__ = "restructuredtext en"
_pylxd_minimal_version = "2.2.5"
_architectures = {
    "unknown": "0",
    "i686": "1",
    "x86_64": "2",
    "armv7l": "3",
    "aarch64": "4",
    "ppc": "5",
    "ppc64": "6",
    "ppc64le": "7",
    "s390x": "8",
}
CONTAINER_STATUS_RUNNING = 103
__virtualname__ = "lxd"
_connection_pool = {}
def __virtual__():
    if HAS_PYLXD:
        if LooseVersion(pylxd_version()) &lt; LooseVersion(_pylxd_minimal_version):
            return (
                False,
                'The lxd execution module cannot be loaded: pylxd "{}" is '
                'not supported, you need at least pylxd "{}"'.format(
                    pylxd_version(), _pylxd_minimal_version
                ),
            )
        return __virtualname__
    return (
        False,
        "The lxd execution module cannot be loaded: "
        "the pylxd python module is not available.",
    )
@salt.utils.decorators.path.which("lxd")
def version():
    return __salt__["cmd.run"]("lxd --version")
def pylxd_version():
    return pylxd.__version__
@salt.utils.decorators.path.which("lxd")
def init(
    storage_backend="dir",
    trust_password=None,
    network_address=None,
    network_port=None,
    storage_create_device=None,
    storage_create_loop=None,
    storage_pool=None,
):
    cmd = 'lxd init --auto --storage-backend="{}"'.format(storage_backend)
    if trust_password is not None:
        cmd = cmd + ' --trust-password="{}"'.format(trust_password)
    if network_address is not None:
        cmd = cmd + ' --network-address="{}"'.format(network_address)
    if network_port is not None:
        cmd = cmd + ' --network-port="{}"'.format(network_port)
    if storage_create_device is not None:
        cmd = cmd + ' --storage-create-device="{}"'.format(storage_create_device)
    if storage_create_loop is not None:
        cmd = cmd + ' --storage-create-loop="{}"'.format(storage_create_loop)
    if storage_pool is not None:
        cmd = cmd + ' --storage-pool="{}"'.format(storage_pool)
    try:
        output = __salt__["cmd.run"](cmd)
    except ValueError as e:
        raise CommandExecutionError(
            "Failed to call: '{}', error was: {}".format(cmd, str(e)),
        )
    if "error:" in output:
        raise CommandExecutionError(
            output[output.index("error:") + 7 :],
        )
    return output
@salt.utils.decorators.path.which("lxd")
@salt.utils.decorators.path.which("lxc")
def config_set(key, value):
    cmd = 'lxc config set "{}" "{}"'.format(
        key,
        value,
    )
    output = __salt__["cmd.run"](cmd)
    if "error:" in output:
        raise CommandExecutionError(
            output[output.index("error:") + 7 :],
        )
    return ('Config value "{}" successfully set.'.format(key),)
@salt.utils.decorators.path.which("lxd")
@salt.utils.decorators.path.which("lxc")
def config_get(key):
    cmd = 'lxc config get "{}"'.format(key)
    output = __salt__["cmd.run"](cmd)
    if "error:" in output:
        raise CommandExecutionError(
            output[output.index("error:") + 7 :],
        )
    return output
def pylxd_client_get(remote_addr=None, cert=None, key=None, verify_cert=True):
    pool_key = "|".join(
        (
            str(remote_addr),
            str(cert),
            str(key),
            str(verify_cert),
        )
    )
    if pool_key in _connection_pool:
        log.debug('Returning the client "%s" from our connection pool', remote_addr)
        return _connection_pool[pool_key]
    try:
        if remote_addr is None or remote_addr == "/var/lib/lxd/unix.socket":
            log.debug("Trying to connect to the local unix socket")
            client = pylxd.Client()
        else:
            if remote_addr.startswith("/"):
                client = pylxd.Client(remote_addr)
            else:
                if cert is None or key is None:
                    raise SaltInvocationError(
                        "You have to give a Cert and Key file for remote endpoints."
                    )
                cert = os.path.expanduser(cert)
                key = os.path.expanduser(key)
                if not os.path.isfile(cert):
                    raise SaltInvocationError(
                        'You have given an invalid cert path: "{}", the '
                        "file does not exist or is not a file.".format(cert)
                    )
                if not os.path.isfile(key):
                    raise SaltInvocationError(
                        'You have given an invalid key path: "{}", the '
                        "file does not exists or is not a file.".format(key)
                    )
                log.debug(
                    'Trying to connect to "%s" with cert "%s", key "%s" and '
                    'verify_cert "%s"',
                    remote_addr,
                    cert,
                    key,
                    verify_cert,
                )
                client = pylxd.Client(
                    endpoint=remote_addr,
                    cert=(
                        cert,
                        key,
                    ),
                    verify=verify_cert,
                )
    except pylxd.exceptions.ClientConnectionFailed:
        raise CommandExecutionError("Failed to connect to '{}'".format(remote_addr))
    except TypeError as e:
        raise CommandExecutionError(
            'Failed to connect to "{}", looks like the SSL verification '
            "failed, error was: {}".format(remote_addr, str(e))
        )
    _connection_pool[pool_key] = client
    return client
def pylxd_save_object(obj):
    try:
        obj.save(wait=True)
    except pylxd.exceptions.LXDAPIException as e:
        raise CommandExecutionError(str(e))
    return True
def authenticate(remote_addr, password, cert, key, verify_cert=True):
    client = pylxd_client_get(remote_addr, cert, key, verify_cert)
    if client.trusted:
        return True
    try:
        client.authenticate(password)
    except pylxd.exceptions.LXDAPIException as e:
        raise CommandExecutionError(str(e))
    return client.trusted
def container_list(
    list_names=False, remote_addr=None, cert=None, key=None, verify_cert=True
):
    client = pylxd_client_get(remote_addr, cert, key, verify_cert)
    containers = client.containers.all()
    if list_names:
        return [c.name for c in containers]
    return map(_pylxd_model_to_dict, containers)
def container_create(
    name,
    source,
    profiles=None,
    config=None,
    devices=None,
    architecture="x86_64",
    ephemeral=False,
    wait=True,
    remote_addr=None,
    cert=None,
    key=None,
    verify_cert=True,
    _raw=False,
):
    if profiles is None:
        profiles = ["default"]
    if config is None:
        config = {}
    if devices is None:
        devices = {}
    client = pylxd_client_get(remote_addr, cert, key, verify_cert)
    if not isinstance(profiles, (list, tuple, set)):
        raise SaltInvocationError("'profiles' must be formatted as list/tuple/set.")
    if architecture not in _architectures:
        raise SaltInvocationError(
            "Unknown architecture '{}' given for the container '{}'".format(
                architecture, name
            )
        )
    if isinstance(source, str):
        source = {"type": "image", "alias": source}
    config, devices = normalize_input_values(config, devices)
    try:
        container = client.containers.create(
            {
                "name": name,
                "architecture": _architectures[architecture],
                "profiles": profiles,
                "source": source,
                "config": config,
                "ephemeral": ephemeral,
            },
            wait=wait,
        )
    except pylxd.exceptions.LXDAPIException as e:
        raise CommandExecutionError(str(e))
    if not wait:
        return container.json()["operation"]
    if devices:
        for dn, dargs in devices.items():
            container_device_add(name, dn, **dargs)
    if _raw:
        return container
    return _pylxd_model_to_dict(container)
def container_get(
    name=None, remote_addr=None, cert=None, key=None, verify_cert=True, _raw=False
):
    client = pylxd_client_get(remote_addr, cert, key, verify_cert)
    if name is None:
        containers = client.containers.all()
        if _raw:
            return containers
    else:
        containers = []
        try:
            containers = [client.containers.get(name)]
        except pylxd.exceptions.LXDAPIException:
            raise SaltInvocationError("Container '{}' not found".format(name))
        if _raw:
            return containers[0]
    infos = []
    for container in containers:
        infos.append(dict([(container.name, _pylxd_model_to_dict(container))]))
    return infos
def container_delete(name, remote_addr=None, cert=None, key=None, verify_cert=True):
    container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
    container.delete(wait=True)
    return True
def container_rename(
    name, newname, remote_addr=None, cert=None, key=None, verify_cert=True
):
    container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
    if container.status_code == CONTAINER_STATUS_RUNNING:
        raise SaltInvocationError(
            "Can't rename the running container '{}'.".format(name)
        )
    container.rename(newname, wait=True)
    return _pylxd_model_to_dict(container)
def container_state(name=None, remote_addr=None, cert=None, key=None, verify_cert=True):
    client = pylxd_client_get(remote_addr, cert, key, verify_cert)
    if name is None:
        containers = client.containers.all()
    else:
        try:
            containers = [client.containers.get(name)]
        except pylxd.exceptions.LXDAPIException:
            raise SaltInvocationError("Container '{}' not found".format(name))
    states = []
    for container in containers:
        state = {}
        state = container.state()
        states.append(
            dict(
                [
                    (
                        container.name,
                        {
                            k: getattr(state, k)
                            for k in dir(state)
                            if not k.startswith("_")
                        },
                    )
                ]
            )
        )
    return states
def container_start(name, remote_addr=None, cert=None, key=None, verify_cert=True):
    container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
    container.start(wait=True)
    return _pylxd_model_to_dict(container)
def container_stop(
    name,
    timeout=30,
    force=True,
    remote_addr=None,
    cert=None,
    key=None,
    verify_cert=True,
):
    container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
    container.stop(timeout, force, wait=True)
    return _pylxd_model_to_dict(container)
def container_restart(name, remote_addr=None, cert=None, key=None, verify_cert=True):
    container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
    container.restart(wait=True)
    return _pylxd_model_to_dict(container)
def container_freeze(name, remote_addr=None, cert=None, key=None, verify_cert=True):
    container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
    container.freeze(wait=True)
    return _pylxd_model_to_dict(container)
def container_unfreeze(name, remote_addr=None, cert=None, key=None, verify_cert=True):
    container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
    container.unfreeze(wait=True)
    return _pylxd_model_to_dict(container)
def container_migrate(
    name,
    stop_and_start=False,
    remote_addr=None,
    cert=None,
    key=None,
    verify_cert=True,
    src_remote_addr=None,
    src_cert=None,
    src_key=None,
    src_verify_cert=None,
):
    if src_cert is None:
        src_cert = cert
    if src_key is None:
        src_key = key
    if src_verify_cert is None:
        src_verify_cert = verify_cert
    container = container_get(
        name, src_remote_addr, src_cert, src_key, src_verify_cert, _raw=True
    )
    dest_client = pylxd_client_get(remote_addr, cert, key, verify_cert)
    for pname in container.profiles:
        try:
            dest_client.profiles.get(pname)
        except pylxd.exceptions.LXDAPIException:
            raise SaltInvocationError(
                "not all the profiles from the source exist on the target"
            )
    was_running = container.status_code == CONTAINER_STATUS_RUNNING
    if stop_and_start and was_running:
        container.stop(wait=True)
    try:
        dest_container = container.migrate(dest_client, wait=True)
        dest_container.profiles = container.profiles
        dest_container.save()
    except pylxd.exceptions.LXDAPIException as e:
        raise CommandExecutionError(str(e))
    container.delete(wait=True)
    if stop_and_start and was_running:
        dest_container.start(wait=True)
    return _pylxd_model_to_dict(dest_container)
def container_config_get(
    name, config_key, remote_addr=None, cert=None, key=None, verify_cert=True
):
    container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
    return _get_property_dict_item(container, "config", config_key)
def container_config_set(
    name,
    config_key,
    config_value,
    remote_addr=None,
    cert=None,
    key=None,
    verify_cert=True,
):
    container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
    return _set_property_dict_item(container, "config", config_key, config_value)
def container_config_delete(
    name, config_key, remote_addr=None, cert=None, key=None, verify_cert=True
):
    container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
    return _delete_property_dict_item(container, "config", config_key)
def container_device_get(
    name, device_name, remote_addr=None, cert=None, key=None, verify_cert=True
):
    container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
    return _get_property_dict_item(container, "devices", device_name)
def container_device_add(
    name,
    device_name,
    device_type="disk",
    remote_addr=None,
    cert=None,
    key=None,
    verify_cert=True,
    **kwargs
):
    container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
    kwargs["type"] = device_type
    return _set_property_dict_item(container, "devices", device_name, kwargs)
def container_device_delete(
    name, device_name, remote_addr=None, cert=None, key=None, verify_cert=True
):
    container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
    return _delete_property_dict_item(container, "devices", device_name)
def container_file_put(
    name,
    src,
    dst,
    recursive=False,
    overwrite=False,
    mode=None,
    uid=None,
    gid=None,
    saltenv="base",
    remote_addr=None,
    cert=None,
    key=None,
    verify_cert=True,
):
    mode = str(mode)
    if not mode.startswith("0"):
        mode = "0{}".format(mode)
    container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
    src = os.path.expanduser(src)
    if not os.path.isabs(src):
        if src.find("://") &gt;= 0:
            cached_file = __salt__["cp.cache_file"](src, saltenv=saltenv)
            if not cached_file:
                raise SaltInvocationError("File '{}' not found".format(src))
            if not os.path.isabs(cached_file):
                raise SaltInvocationError("File path must be absolute.")
            src = cached_file
    src = src.rstrip(os.path.sep)
    if not src:
        src = os.path.sep
    if not os.path.exists(src):
        raise CommandExecutionError("No such file or directory '{}'".format(src))
    if os.path.isdir(src) and not recursive:
        raise SaltInvocationError(
            "Cannot copy overwriting a directory without recursive flag set to true!"
        )
    try:
        dst_is_directory = False
        container.files.get(os.path.join(dst, "."))
    except pylxd.exceptions.NotFound:
        pass
    except pylxd.exceptions.LXDAPIException as why:
        if str(why).find("Is a directory") &gt;= 0:
            dst_is_directory = True
    if os.path.isfile(src):
        if dst_is_directory:
            dst = os.path.join(dst, os.path.basename(src))
            if not overwrite:
                found = True
                try:
                    container.files.get(os.path.join(dst))
                except pylxd.exceptions.NotFound:
                    found = False
                except pylxd.exceptions.LXDAPIException as why:
                    if str(why).find("not found") &gt;= 0:
                        found = False
                    else:
                        raise
                if found:
                    raise SaltInvocationError(
                        "Destination exists and overwrite is false"
                    )
        if mode is not None or uid is not None or gid is not None:
            stat = os.stat(src)
            if mode is None:
                mode = oct(stat.st_mode)
            if uid is None:
                uid = stat.st_uid
            if gid is None:
                gid = stat.st_gid
        with salt.utils.files.fopen(src, "rb") as src_fp:
            container.files.put(dst, src_fp.read(), mode=mode, uid=uid, gid=gid)
        return True
    elif not os.path.isdir(src):
        raise SaltInvocationError("Source is neither file nor directory")
    if dst.endswith(os.sep):
        idx = len(os.path.dirname(src))
    elif dst_is_directory:
        idx = len(src)
    else:
        try:
            container.files.get(os.path.join(os.path.dirname(dst), "."))
        except pylxd.exceptions.NotFound:
            pass
        except pylxd.exceptions.LXDAPIException as why:
            if str(why).find("Is a directory") &gt;= 0:
                dst_is_directory = True
                idx = len(src)
                overwrite = True
    if not overwrite:
        raise SaltInvocationError("Destination exists and overwrite is false")
    dstdirs = []
    for path, _, files in os.walk(src):
        dstdir = os.path.join(dst, path[idx:].lstrip(os.path.sep))
        dstdirs.append(dstdir)
    container.execute(["mkdir", "-p"] + dstdirs)
    set_mode = mode
    set_uid = uid
    set_gid = gid
    for path, _, files in os.walk(src):
        dstdir = os.path.join(dst, path[idx:].lstrip(os.path.sep))
        for name in files:
            src_name = os.path.join(path, name)
            dst_name = os.path.join(dstdir, name)
            if mode is not None or uid is not None or gid is not None:
                stat = os.stat(src_name)
                if mode is None:
                    set_mode = oct(stat.st_mode)
                if uid is None:
                    set_uid = stat.st_uid
                if gid is None:
                    set_gid = stat.st_gid
            with salt.utils.files.fopen(src_name, "rb") as src_fp:
                container.files.put(
                    dst_name, src_fp.read(), mode=set_mode, uid=set_uid, gid=set_gid
                )
    return True
def container_file_get(
    name,
    src,
    dst,
    overwrite=False,
    mode=None,
    uid=None,
    gid=None,
    remote_addr=None,
    cert=None,
    key=None,
    verify_cert=True,
):
    if mode is not None:
        mode = str(mode)
        if not mode.startswith("0"):
            mode = "0{}".format(mode)
    container = container_get(name, remote_addr, cert, key, verify_cert, _raw=True)
    dst = os.path.expanduser(dst)
    if not os.path.isabs(dst):
        raise SaltInvocationError("File path must be absolute.")
    if os.path.isdir(dst):
        dst = os.path.join(dst, os.path.basename(src))
    elif not os.path.isdir(os.path.dirname(dst)):
        raise SaltInvocationError("Parent directory for destination doesn't exist.")
    if os.path.exists(dst):
        if not overwrite:
            raise SaltInvocationError("Destination exists and overwrite is false.")
        if not os.path.isfile(dst):
            raise SaltInvocationError("Destination exists but is not a file.")
    else:
        dst_path = os.path.dirname(dst)
        if not os.path.isdir(dst_path):
            raise CommandExecutionError(
                "No such file or directory '{}'".format(dst_path)
            )
    with salt.utils.files.fopen(dst, "wb") as df:
        df.write(container.files.get(src))
    if mode:
        os.chmod(dst, mode)
    if uid or uid == "0":
        uid = int(uid)
    else:
        uid = -1
    if gid or gid == "0":
<a name="0"></a>        gid = int(gid)
    else:
        gid = -1
    <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>if uid != -1 or gid != -1:
        os.chown(dst, uid, gid)
    return True
def container_execute(
    name, cmd, remote_addr=None, cert=None, key=None, verify_cert=True
):
    container = container_get(name, remote_addr, cert, key, verify_cert, _raw=</b></font>True)
    try:
        result = container.execute(cmd)
        saltresult = {}
        if not hasattr(result, "exit_code"):
            saltresult = dict(
                exit_code=0,
                stdout=result[0],
                stderr=result[1],
            )
        else:
            saltresult = dict(
                exit_code=result.exit_code,
                stdout=result.stdout,
                stderr=result.stderr,
            )
    except pylxd.exceptions.NotFound as e:
        saltresult = dict(exit_code=0, stdout="", stderr=str(e))
    if int(saltresult["exit_code"]) &gt; 0:
        saltresult["result"] = False
    else:
        saltresult["result"] = True
    return saltresult
def profile_list(
    list_names=False, remote_addr=None, cert=None, key=None, verify_cert=True
):
    client = pylxd_client_get(remote_addr, cert, key, verify_cert)
    profiles = client.profiles.all()
    if list_names:
        return [p.name for p in profiles]
    return map(_pylxd_model_to_dict, profiles)
def profile_create(
    name,
    config=None,
    devices=None,
    description=None,
    remote_addr=None,
    cert=None,
    key=None,
    verify_cert=True,
):
    client = pylxd_client_get(remote_addr, cert, key, verify_cert)
    config, devices = normalize_input_values(config, devices)
    try:
        profile = client.profiles.create(name, config, devices)
    except pylxd.exceptions.LXDAPIException as e:
        raise CommandExecutionError(str(e))
    if description is not None:
        profile.description = description
        pylxd_save_object(profile)
    return _pylxd_model_to_dict(profile)
def profile_get(
    name, remote_addr=None, cert=None, key=None, verify_cert=True, _raw=False
):
    client = pylxd_client_get(remote_addr, cert, key, verify_cert)
    profile = None
    try:
        profile = client.profiles.get(name)
    except pylxd.exceptions.LXDAPIException:
        raise SaltInvocationError("Profile '{}' not found".format(name))
    if _raw:
        return profile
    return _pylxd_model_to_dict(profile)
def profile_delete(name, remote_addr=None, cert=None, key=None, verify_cert=True):
    profile<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.delete()
    return True
def profile_config_get(
    name, config_key, remote_addr=None, cert=None, key=None, verify_cert=True
):
    profile = profile_get(name, remote_addr, cert, key, verify_cert, _raw=</b></font>True)
    return _get_property_dict_item(profile, "config", config_key)
def profile_config_set(
    name,
    config_key,
    config_value,
    remote_addr=None,
    cert=None,
    key=None,
    verify_cert=True,
):
    profile = profile_get(name, remote_addr, cert, key, verify_cert, _raw=True)
    return _set_property_dict_item(profile, "config", config_key, config_value)
def profile_config_delete(
    name, config_key, remote_addr=None, cert=None, key=None, verify_cert=True
):
    profile = profile_get(name, remote_addr, cert, key, verify_cert, _raw=True)
    return _delete_property_dict_item(profile, "config", config_key)
def profile_device_get(
    name, device_name, remote_addr=None, cert=None, key=None, verify_cert=True
):
    profile = profile_get(name, remote_addr, cert, key, verify_cert, _raw=True)
    return _get_property_dict_item(profile, "devices", device_name)
def profile_device_set(
    name,
    device_name,
    device_type="disk",
    remote_addr=None,
    cert=None,
    key=None,
    verify_cert=True,
    **kwargs
):
    profile = profile_get(name, remote_addr, cert, key, verify_cert, _raw=True)
    kwargs["type"] = device_type
    for k, v in kwargs.items():
        kwargs[k] = str(v)
    return _set_property_dict_item(profile, "devices", device_name, kwargs)
def profile_device_delete(
    name, device_name, remote_addr=None, cert=None, key=None, verify_cert=True
):
    profile = profile_get(name, remote_addr, cert, key, verify_cert, _raw=True)
    return _delete_property_dict_item(profile, "devices", device_name)
def image_list(
    list_aliases=False, remote_addr=None, cert=None, key=None, verify_cert=True
):
    client = pylxd_client_get(remote_addr, cert, key, verify_cert)
    images = client.images.all()
    if list_aliases:
        return {i.fingerprint: [a["name"] for a in i.aliases] for i in images}
    return map(_pylxd_model_to_dict, images)
def image_get(
    fingerprint, remote_addr=None, cert=None, key=None, verify_cert=True, _raw=False
):
    client = pylxd_client_get(remote_addr, cert, key, verify_cert)
    image = None
    try:
        image = client.images.get(fingerprint)
    except pylxd.exceptions.LXDAPIException:
        raise SaltInvocationError(
            "Image with fingerprint '{}' not found".format(fingerprint)
        )
    if _raw:
        return image
    return _pylxd_model_to_dict(image)
def image_get_by_alias(
    alias, remote_addr=None, cert=None, key=None, verify_cert=True, _raw=False
):
    client = pylxd_client_get(remote_addr, cert, key, verify_cert)
    image = None
    try:
        image = client.images.get_by_alias(alias)
    except pylxd.exceptions.LXDAPIException:
        raise SaltInvocationError("Image with alias '{}' not found".format(alias))
    if _raw:
        return image
    return _pylxd_model_to_dict(image)
def image_delete(image, remote_addr=None, cert=None, key=None, verify_cert=True):
    image = _verify_image(image, remote_addr, cert, key, verify_cert)
    image.delete()
    return True
def image_from_simplestreams(
    server,
    alias,
    remote_addr=None,
    cert=None,
    key=None,
    verify_cert=True,
    aliases=None,
    public=False,
    auto_update=False,
    _raw=False,
):
    if aliases is None:
        aliases = []
    client = pylxd_client_get(remote_addr, cert, key, verify_cert)
    try:
        image = client.images.create_from_simplestreams(
            server, alias, public=public, auto_update=auto_update
        )
    except pylxd.exceptions.LXDAPIException as e:
        raise CommandExecutionError(str(e))
    for alias in aliases:
        image_alias_add(image, alias)
    if _raw:
        return image
    return _pylxd_model_to_dict(image)
def image_from_url(
    url,
    remote_addr=None,
    cert=None,
    key=None,
    verify_cert=True,
    aliases=None,
    public=False,
    auto_update=False,
    _raw=False,
):
    if aliases is None:
        aliases = []
    client = pylxd_client_get(remote_addr, cert, key, verify_cert)
    try:
        image = client.images.create_from_url(
            url, public=public, auto_update=auto_update
        )
    except pylxd.exceptions.LXDAPIException as e:
        raise CommandExecutionError(str(e))
    for alias in aliases:
        image_alias_add(image, alias)
    if _raw:
        return image
    return _pylxd_model_to_dict(image)
def image_from_file(
    filename,
    remote_addr=None,
    cert=None,
    key=None,
    verify_cert=True,
    aliases=None,
    public=False,
    saltenv="base",
    _raw=False,
):
    if aliases is None:
        aliases = []
    cached_file = __salt__["cp.cache_file"](filename, saltenv=saltenv)
    data = b""
    with salt.utils.files.fopen(cached_file, "r+b") as fp:
        data = fp.read()
    client = pylxd_client_get(remote_addr, cert, key, verify_cert)
    try:
        image = client.images.create(data, public=public, wait=True)
    except pylxd.exceptions.LXDAPIException as e:
        raise CommandExecutionError(str(e))
    for alias in aliases:
        image_alias_add(image, alias)
    if _raw:
        return image
    return _pylxd_model_to_dict(image)
def image_copy_lxd(
    source,
    src_remote_addr,
    src_cert,
    src_key,
    src_verify_cert,
    remote_addr,
    cert,
    key,
    verify_cert=True,
    aliases=None,
    public=None,
    auto_update=None,
    _raw=False,
):
    if aliases is None:
        aliases = []
    log.debug(
        'Trying to copy the image "%s" from "%s" to "%s"',
        source,
        src_remote_addr,
        remote_addr,
    )
    src_image = None
    try:
        src_image = image_get_by_alias(
            source, src_remote_addr, src_cert, src_key, src_verify_cert, _raw=True
        )
    except SaltInvocationError:
        src_image = image_get(
            source, src_remote_addr, src_cert, src_key, src_verify_cert, _raw=True
        )
    dest_client = pylxd_client_get(remote_addr, cert, key, verify_cert)
    dest_image = src_image.copy(
        dest_client, public=public, auto_update=auto_update, wait=True
    )
    for alias in aliases:
        image_alias_add(dest_image, alias)
    if _raw:
        return dest_image
    return _pylxd_model_to_dict(dest_image)
def image_alias_add(
    image,
    alias,
    description="",
    remote_addr=None,
    cert=None,
    key=None,
    verify_cert=True,
):
    image = _verify_image(image, remote_addr, cert, key, verify_cert)
    for alias_info in image.aliases:
        if alias_info["name"] == alias:
            return True
    image.add_alias(alias, description)
    return True
def image_alias_delete(
    image, alias, remote_addr=None, cert=None, key=None, verify_cert=True
):
    image = _verify_image(image, remote_addr, cert, key, verify_cert)
    try:
        image.delete_alias(alias)
    except pylxd.exceptions.LXDAPIException:
        return False
    return True
def snapshots_all(container, remote_addr=None, cert=None, key=None, verify_cert=True):
    containers = container_get(
        container, remote_addr, cert, key, verify_cert, _raw=True
    )
    if container:
        containers = [containers]
    ret = {}
    for cont in containers:
        ret.update({cont.name: [{"name": c.name} for c in cont.snapshots.all()]})
    return ret
def snapshots_create(
    container, name=None, remote_addr=None, cert=None, key=None, verify_cert=True
):
    cont = container_get(container, remote_addr, cert, key, verify_cert, _raw=True)
    if not name:
        name = datetime.now().strftime("%Y%m%d%H%M%S")
    cont.snapshots.create(name)
    for c in snapshots_all(container).get(container):
        if c.get("name") == name:
            return {"name": name}
    return {"name": False}
def snapshots_delete(
    container, name, remote_addr=None, cert=None, key=None, verify_cert=True
):
    cont = container_get(container, remote_addr, cert, key, verify_cert, _raw=True)
    try:
        for s in cont.snapshots.all():
            if s.name == name:
                s.delete()
                return True
    except pylxd.exceptions.LXDAPIException:
        pass
    return False
def snapshots_get(
    container, name, remote_addr=None, cert=None, key=None, verify_cert=True
):
    container = container_get(container, remote_addr, cert, key, verify_cert, _raw=True)
    return container.snapshots.get(name)
def normalize_input_values(config, devices):
    if isinstance(config, list):
        if config and "key" in config[0] and "value" in config[0]:
            config = {d["key"]: d["value"] for d in config}
        else:
            config = {}
    if isinstance(config, str):
        raise SaltInvocationError("config can't be a string, validate your YAML input.")
    if isinstance(devices, str):
        raise SaltInvocationError(
            "devices can't be a string, validate your YAML input."
        )
    if config is not None:
        for k, v in config.items():
            config[k] = str(v)
    if devices is not None:
        for dn in devices:
            for k, v in devices[dn].items():
                devices[dn][k] = v
    return (
        config,
        devices,
    )
def sync_config_devices(obj, newconfig, newdevices, test=False):
    changes = {}
    if newconfig is None:
        newconfig = {}
    newconfig = dict(
        list(zip(map(str, newconfig.keys()), map(str, newconfig.values())))
    )
    cck = set(newconfig.keys())
    obj.config = dict(
        list(zip(map(str, obj.config.keys()), map(str, obj.config.values())))
    )
    ock = set(obj.config.keys())
    config_changes = {}
    for k in ock.difference(cck):
        if k.startswith("volatile.") or k.startswith("image."):
            continue
        if not test:
            config_changes[k] = 'Removed config key "{}", its value was "{}"'.format(
                k, obj.config[k]
            )
            del obj.config[k]
        else:
            config_changes[k] = 'Would remove config key "{} with value "{}"'.format(
                k, obj.config[k]
            )
    for k in cck.intersection(ock):
        if k.startswith("volatile.") or k.startswith("image."):
            continue
        if newconfig[k] != obj.config[k]:
            if not test:
                config_changes[
                    k
                ] = 'Changed config key "{}" to "{}", its value was "{}"'.format(
                    k, newconfig[k], obj.config[k]
                )
                obj.config[k] = newconfig[k]
            else:
                config_changes[
                    k
                ] = 'Would change config key "{}" to "{}", its current value is "{}"'.format(
                    k, newconfig[k], obj.config[k]
                )
    for k in cck.difference(ock):
        if k.startswith("volatile.") or k.startswith("image."):
            continue
        if not test:
            config_changes[k] = 'Added config key "{}" = "{}"'.format(k, newconfig[k])
            obj.config[k] = newconfig[k]
        else:
            config_changes[k] = 'Would add config key "{}" = "{}"'.format(
                k, newconfig[k]
            )
    if config_changes:
        changes["config"] = config_changes
    if newdevices is None:
        newdevices = {}
    dk = set(obj.devices.keys())
    ndk = set(newdevices.keys())
    devices_changes = {}
    for k in dk.difference(ndk):
        if k == "root":
            continue
        if not test:
            devices_changes[k] = 'Removed device "{}"'.format(k)
            del obj.devices[k]
        else:
            devices_changes[k] = 'Would remove device "{}"'.format(k)
    for k, v in obj.devices.items():
        if k == "root":
            continue
        if k not in newdevices:
            continue
        if newdevices[k] != v:
            if not test:
                devices_changes[k] = 'Changed device "{}"'.format(k)
                obj.devices[k] = newdevices[k]
            else:
                devices_changes[k] = 'Would change device "{}"'.format(k)
    for k in ndk.difference(dk):
        if k == "root":
            continue
        if not test:
            devices_changes[k] = 'Added device "{}"'.format(k)
            obj.devices[k] = newdevices[k]
        else:
            devices_changes[k] = 'Would add device "{}"'.format(k)
    if devices_changes:
        changes["devices"] = devices_changes
    return changes
def _set_property_dict_item(obj, prop, key, value):
    attr = getattr(obj, prop)
    if prop == "devices":
        device_type = value["type"]
        if device_type == "disk":
            if "path" not in value:
                raise SaltInvocationError("path must be given as parameter")
            if value["path"] != "/" and "source" not in value:
                raise SaltInvocationError("source must be given as parameter")
        for k in value.keys():
            if k.startswith("__"):
                del value[k]
        attr[key] = value
    else:  # config
        attr[key] = str(value)
    pylxd_save_object(obj)
    return _pylxd_model_to_dict(obj)
def _get_property_dict_item(obj, prop, key):
    attr = getattr(obj, prop)
    if key not in attr:
        raise SaltInvocationError("'{}' doesn't exists".format(key))
    return attr[key]
def _delete_property_dict_item(obj, prop, key):
    attr = getattr(obj, prop)
    if key not in attr:
        raise SaltInvocationError("'{}' doesn't exists".format(key))
    del attr[key]
    pylxd_save_object(obj)
    return True
def _verify_image(image, remote_addr=None, cert=None, key=None, verify_cert=True):
    if isinstance(image, str):
        name = image
        image = None
        try:
            image = image_get_by_alias(
                name, remote_addr, cert, key, verify_cert, _raw=True
            )
        except SaltInvocationError:
            image = image_get(name, remote_addr, cert, key, verify_cert, _raw=True)
    elif not hasattr(image, "fingerprint"):
        raise SaltInvocationError("Invalid image '{}'".format(image))
    return image
def _pylxd_model_to_dict(obj):
    marshalled = {}
    for key in obj.__attributes__.keys():
        if hasattr(obj, key):
            marshalled[key] = getattr(obj, key)
    return marshalled
if HAS_PYLXD:
    import pylxd.exceptions  # NOQA
    if not hasattr(pylxd.exceptions, "NotFound"):
        class NotFound(pylxd.exceptions.LXDAPIException):
        pylxd.exceptions.NotFound = NotFound
    try:
        from pylxd.container import Container
    except ImportError:
        from pylxd.models.container import Container
    class FilesManager(Container.FilesManager):
        def put(self, filepath, data, mode=None, uid=None, gid=None):
            headers = {}
            if mode is not None:
                if isinstance(mode, int):
                    mode = oct(mode)
                elif not mode.startswith("0"):
                    mode = "0{}".format(mode)
                headers["X-LXD-mode"] = mode
            if uid is not None:
                headers["X-LXD-uid"] = str(uid)
            if gid is not None:
                headers["X-LXD-gid"] = str(gid)
            response = self._client.api.containers[self._container.name].files.post(
                params={"path": filepath}, data=data, headers=headers
            )
            return response.status_code == 200
    Container.FilesManager = FilesManager
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
