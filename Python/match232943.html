<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for archive.py &amp; network_4.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for archive.py &amp; network_4.py
      </h3>
<h1 align="center">
        1.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>archive.py (1.8971848%)<th>network_4.py (0.97822654%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(7-24)<td><a href="#" name="0">(7-24)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1367-1369)<td><a href="#" name="1">(168-173)</a><td align="center"><font color="#d20000">14</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>archive.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import errno
2 import logging
3 import os
4 import re
5 import shlex
6 import stat
7 import string
8 import tarfile
9 from contextlib import closing
10 from urllib.parse import urlparse
11 import salt.utils.args
12 import salt.utils.files
13 import salt.utils.hashutils
14 import salt.utils.path
15 import salt.utils.platform
16 import salt.utils.url
17 from</b></font> salt.exceptions import CommandExecutionError, CommandNotFoundError
18 log = logging.getLogger(__name__)
19 def _path_is_abs(path):
20     if path is None:
21         return True
22     try:
23         return os.path.isabs(path)
24     except AttributeError:
25         return False
26 def _add_explanation(ret, source_hash_trigger, contents_missing):
27     if source_hash_trigger:
28         ret["comment"] += ", due to source_hash update"
29     elif contents_missing:
30         ret["comment"] += ", due to absence of one or more files/dirs"
31 def _gen_checksum(path):
32     return {
33         "hsum": salt.utils.hashutils.get_hash(path, form=__opts__["hash_type"]),
34         "hash_type": __opts__["hash_type"],
35     }
36 def _checksum_file_path(path):
37     try:
38         relpath = ".".join((os.path.relpath(path, __opts__["cachedir"]), "hash"))
39         if re.match(r"..[/\\]", relpath):
40             relpath = salt.utils.path.join(
41                 "local",
42                 os.path.splitdrive(path)[-1].lstrip("/\\"),
43             )
44     except ValueError as exc:
45         if str(exc).startswith("path is on"):
46             drive, path = os.path.splitdrive(path)
47             relpath = salt.utils.path.join(
48                 "local",
49                 drive.rstrip(":"),
50                 path.lstrip("/\\"),
51             )
52         elif str(exc).startswith("Cannot mix UNC"):
53             relpath = salt.utils.path.join("unc", path)
54         else:
55             raise
56     ret = salt.utils.path.join(__opts__["cachedir"], "archive_hash", relpath)
57     log.debug("Using checksum file %s for cached archive file %s", ret, path)
58     return ret
59 def _update_checksum(path):
60     checksum_file = _checksum_file_path(path)
61     checksum_dir = os.path.dirname(checksum_file)
62     if not os.path.isdir(checksum_dir):
63         os.makedirs(checksum_dir)
64     source_sum = _gen_checksum(path)
65     hash_type = source_sum.get("hash_type")
66     hsum = source_sum.get("hsum")
67     if hash_type and hsum:
68         lines = []
69         try:
70             try:
71                 with salt.utils.files.fopen(checksum_file, "r") as fp_:
72                     for line in fp_:
73                         try:
74                             lines.append(line.rstrip("\n").split(":", 1))
75                         except ValueError:
76                             continue
77             except OSError as exc:
78                 if exc.errno != errno.ENOENT:
79                     raise
80             with salt.utils.files.fopen(checksum_file, "w") as fp_:
81                 for line in lines:
82                     if line[0] == hash_type:
83                         line[1] = hsum
84                     fp_.write("{}:{}\n".format(*line))
85                 if hash_type not in [x[0] for x in lines]:
86                     fp_.write("{}:{}\n".format(hash_type, hsum))
87         except OSError as exc:
88             log.warning(
89                 "Failed to update checksum for %s: %s",
90                 path,
91                 exc.__str__(),
92                 exc_info=True,
93             )
94 def _read_cached_checksum(path, form=None):
95     if form is None:
96         form = __opts__["hash_type"]
97     checksum_file = _checksum_file_path(path)
98     try:
99         with salt.utils.files.fopen(checksum_file, "r") as fp_:
100             for line in fp_:
101                 hash_type, hsum = line.rstrip("\n").split(":", 1)
102                 if hash_type == form:
103                     break
104             else:
105                 return None
106     except (OSError, ValueError):
107         return None
108     else:
109         return {"hash_type": hash_type, "hsum": hsum}
110 def _compare_checksum(cached, source_sum):
111     cached_sum = _read_cached_checksum(
112         cached, form=source_sum.get("hash_type", __opts__["hash_type"])
113     )
114     return source_sum == cached_sum
115 def _is_bsdtar():
116     return "bsdtar" in __salt__["cmd.run"](["tar", "--version"], python_shell=False)
117 def _cleanup_destdir(name):
118     try:
119         os.rmdir(name)
120     except OSError:
121         pass
122 def extracted(
123     name,
124     source,
125     source_hash=None,
126     source_hash_name=None,
127     source_hash_update=False,
128     skip_files_list_verify=False,
129     skip_verify=False,
130     password=None,
131     options=None,
132     list_options=None,
133     force=False,
134     overwrite=False,
135     clean=False,
136     clean_parent=False,
137     user=None,
138     group=None,
139     if_missing=None,
140     trim_output=False,
141     use_cmd_unzip=None,
142     extract_perms=True,
143     enforce_toplevel=True,
144     enforce_ownership_on=None,
145     archive_format=None,
146     use_etag=False,
147     **kwargs
148 ):
149     ret = {"name": name, "result": False, "changes": {}, "comment": ""}
150     kwargs = salt.utils.args.clean_kwargs(**kwargs)
151     if skip_files_list_verify and skip_verify:
152         ret[
153             "comment"
154         ] = 'Only one of "skip_files_list_verify" and "skip_verify" can be set to True'
155         return ret
156     if "keep_source" in kwargs and "keep" in kwargs:
157         ret.setdefault("warnings", []).append(
158             "Both 'keep_source' and 'keep' were used. Since these both "
159             "do the same thing, 'keep' was ignored."
160         )
161         keep_source = bool(kwargs.pop("keep_source"))
162         kwargs.pop("keep")
163     elif "keep_source" in kwargs:
164         keep_source = bool(kwargs.pop("keep_source"))
165     elif "keep" in kwargs:
166         keep_source = bool(kwargs.pop("keep"))
167     else:
168         keep_source = True
169     if not _path_is_abs(name):
170         ret["comment"] = "{} is not an absolute path".format(name)
171         return ret
172     else:
173         if not name:
174             ret["comment"] = "Name of the directory path needs to be specified"
175             return ret
176         name = name.rstrip(os.sep)
177         if os.path.isfile(name):
178             ret["comment"] = "{} exists and is not a directory".format(name)
179             return ret
180         name += os.sep
181     if not _path_is_abs(if_missing):
182         ret["comment"] = "Value for 'if_missing' is not an absolute path"
183         return ret
184     if not _path_is_abs(enforce_ownership_on):
185         ret["comment"] = "Value for 'enforce_ownership_on' is not an absolute path"
186         return ret
187     else:
188         if enforce_ownership_on is not None:
189             try:
190                 not_rel = os.path.relpath(enforce_ownership_on, name).startswith(
191                     ".." + os.sep
192                 )
193             except Exception:  # pylint: disable=broad-except
194                 not_rel = True
195             if not_rel:
196                 ret[
197                     "comment"
198                 ] = "Value for 'enforce_ownership_on' must be within {}".format(name)
199                 return ret
200     if if_missing is not None and os.path.exists(if_missing):
201         ret["result"] = True
202         ret["comment"] = "Path {} exists".format(if_missing)
203         return ret
204     if user or group:
205         if salt.utils.platform.is_windows():
206             ret[
207                 "comment"
208             ] = "User/group ownership cannot be enforced on Windows minions"
209             return ret
210         if user:
211             uid = __salt__["file.user_to_uid"](user)
212             if uid == "":
213                 ret["comment"] = "User {} does not exist".format(user)
214                 return ret
215         else:
216             uid = -1
217         if group:
218             gid = __salt__["file.group_to_gid"](group)
219             if gid == "":
220                 ret["comment"] = "Group {} does not exist".format(group)
221                 return ret
222         else:
223             gid = -1
224     else:
225         uid = gid = -1
226     if source_hash_update and not source_hash:
227         ret.setdefault("warnings", []).append(
228             "The 'source_hash_update' argument is ignored when "
229             "'source_hash' is not also specified."
230         )
231     try:
232         source_match = __salt__["file.source_list"](source, source_hash, __env__)[0]
233     except CommandExecutionError as exc:
234         ret["result"] = False
235         ret["comment"] = exc.strerror
236         return ret
237     if not source_match:
238         ret["result"] = False
239         ret["comment"] = 'Invalid source "{}"'.format(source)
240         return ret
241     urlparsed_source = urlparse(source_match)
242     urlparsed_scheme = urlparsed_source.scheme
243     urlparsed_path = os.path.join(
244         urlparsed_source.netloc, urlparsed_source.path
245     ).rstrip(os.sep)
246     if urlparsed_scheme and urlparsed_scheme.lower() in string.ascii_lowercase:
247         urlparsed_path = ":".join([urlparsed_scheme, urlparsed_path])
248         urlparsed_scheme = "file"
249     source_hash_basename = urlparsed_path or urlparsed_source.netloc
250     source_is_local = urlparsed_scheme in salt.utils.files.LOCAL_PROTOS
251     if source_is_local:
252         source_match = os.path.realpath(os.path.expanduser(urlparsed_path))
253         if not os.path.isfile(source_match):
254             ret["comment"] = "Source file '{}' does not exist".format(
255                 salt.utils.url.redact_http_basic_auth(source_match)
256             )
257             return ret
258     valid_archive_formats = ("tar", "rar", "zip")
259     if not archive_format:
260         archive_format = salt.utils.files.guess_archive_type(source_hash_basename)
261         if archive_format is None:
262             ret["comment"] = (
263                 "Could not guess archive_format from the value of the "
264                 "'source' argument. Please set this archive_format to one "
265                 "of the following: {}".format(", ".join(valid_archive_formats))
266             )
267             return ret
268     try:
269         archive_format = archive_format.lower()
270     except AttributeError:
271         pass
272     if archive_format not in valid_archive_formats:
273         ret["comment"] = (
274             "Invalid archive_format '{}'. Either set it to a supported "
275             "value ({}) or remove this argument and the archive format will "
276             "be guessed based on file extension.".format(
277                 archive_format,
278                 ", ".join(valid_archive_formats),
279             )
280         )
281         return ret
282     if options is not None and not isinstance(options, str):
283         options = str(options)
284     strip_components = None
285     if options and archive_format == "tar":
286         try:
287             strip_components = int(
288                 re.search(
289                     r"""--strip(?:-components)?(?:\s+|=)["']?(\d+)["']?""", options
290                 ).group(1)
291             )
292         except (AttributeError, ValueError):
293             pass
294     if archive_format == "zip":
295         if options:
296             if use_cmd_unzip is None:
297                 log.info(
298                     "Presence of CLI options in archive.extracted state for "
299                     "'%s' implies that use_cmd_unzip is set to True.",
300                     name,
301                 )
302                 use_cmd_unzip = True
303             elif not use_cmd_unzip:
304                 ret["comment"] = (
305                     "'use_cmd_unzip' cannot be set to False if CLI options "
306                     "are being specified (via the 'options' argument). "
307                     "Either remove 'use_cmd_unzip', or set it to True."
308                 )
309                 return ret
310             if use_cmd_unzip:
311                 if "archive.cmd_unzip" not in __salt__:
312                     ret["comment"] = (
313                         "archive.cmd_unzip function not available, unzip might "
314                         "not be installed on minion"
315                     )
316                     return ret
317         if password:
318             if use_cmd_unzip is None:
319                 log.info(
320                     "Presence of a password in archive.extracted state for "
321                     "'%s' implies that use_cmd_unzip is set to False.",
322                     name,
323                 )
324                 use_cmd_unzip = False
325             elif use_cmd_unzip:
326                 ret.setdefault("warnings", []).append(
327                     "Using a password in combination with setting "
328                     "'use_cmd_unzip' to True is considered insecure. It is "
329                     "recommended to remove the 'use_cmd_unzip' argument (or "
330                     "set it to False) and allow Salt to extract the archive "
331                     "using Python's built-in ZIP file support."
332                 )
333     else:
334         if password:
335             ret[
336                 "comment"
337             ] = "The 'password' argument is only supported for zip archives"
338             return ret
339     if archive_format == "rar":
340         if "archive.unrar" not in __salt__:
341             ret["comment"] = (
342                 "archive.unrar function not available, rar/unrar might "
343                 "not be installed on minion"
344             )
345             return ret
346     supports_options = ("tar", "zip")
347     if options and archive_format not in supports_options:
348         ret["comment"] = (
349             "The 'options' argument is only compatible with the following "
350             "archive formats: {}".format(", ".join(supports_options))
351         )
352         return ret
353     if trim_output:
354         if trim_output is True:
355             trim_output = 100
356         elif not isinstance(trim_output, (bool, int)):
357             try:
358                 trim_output = int(trim_output)
359             except TypeError:
360                 ret[
361                     "comment"
362                 ] = "Invalid value for trim_output, must be True/False or an integer"
363                 return ret
364     if source_hash:
365         try:
366             source_sum = __salt__["file.get_source_sum"](
367                 source=source_match,
368                 source_hash=source_hash,
369                 source_hash_name=source_hash_name,
370                 saltenv=__env__,
371             )
372         except CommandExecutionError as exc:
373             ret["comment"] = exc.strerror
374             return ret
375     else:
376         source_sum = {}
377     if skip_files_list_verify:
378         if source_is_local:
379             cached = source_match
380         else:
381             cached = __salt__["cp.is_cached"](source_match, saltenv=__env__)
382         if cached:
383             existing_cached_source_sum = _read_cached_checksum(cached)
384             log.debug(
385                 'Existing source sum is: "%s". Expected source sum is "%s"',
386                 existing_cached_source_sum,
387                 source_sum,
388             )
389         else:
390             parsed = urlparse(source_match)
391             expected_cached_path = salt.utils.path.join(
392                 __opts__["cachedir"], "extrn_files", __env__, parsed.netloc, parsed.path
393             )
394             existing_cached_source_sum = _read_cached_checksum(expected_cached_path)
395         if source_sum and existing_cached_source_sum:
396             if existing_cached_source_sum["hsum"] == source_sum["hsum"]:
397                 ret["result"] = None if __opts__["test"] else True
398                 ret["comment"] = (
399                     "Archive {} existing source sum is the same as the "
400                     "expected one and skip_files_list_verify argument was set "
401                     "to True. Extraction is not needed".format(
402                         salt.utils.url.redact_http_basic_auth(source_match)
403                     )
404                 )
405                 return ret
406         else:
407             log.debug("There is no cached source %s available on minion", source_match)
408     if source_is_local:
409         cached = source_match
410     else:
411         if __opts__["test"]:
412             ret["result"] = None
413             ret["comment"] = (
414                 "Archive {} would be cached (if necessary) and checked to "
415                 "discover if extraction is needed".format(
416                     salt.utils.url.redact_http_basic_auth(source_match)
417                 )
418             )
419             return ret
420         if "file.cached" not in __states__:
421             ret[
422                 "comment"
423             ] = "Unable to cache {}, file.cached state not available".format(
424                 salt.utils.url.redact_http_basic_auth(source_match)
425             )
426             return ret
427         try:
428             result = __states__["file.cached"](
429                 source_match,
430                 source_hash=source_hash,
431                 source_hash_name=source_hash_name,
432                 skip_verify=skip_verify,
433                 saltenv=__env__,
434                 use_etag=use_etag,
435             )
436         except Exception as exc:  # pylint: disable=broad-except
437             msg = "Failed to cache {}: {}".format(
438                 salt.utils.url.redact_http_basic_auth(source_match), exc.__str__()
439             )
440             log.exception(msg)
441             ret["comment"] = msg
442             return ret
443         else:
444             log.debug("file.cached: %s", result)
445         if result["result"]:
446             cached = __salt__["cp.is_cached"](source_match, saltenv=__env__)
447         else:
448             log.debug(
449                 "failed to download %s",
450                 salt.utils.url.redact_http_basic_auth(source_match),
451             )
452             return result
453     existing_cached_source_sum = _read_cached_checksum(cached)
454     if source_hash and source_hash_update and not skip_verify:
455         _update_checksum(cached)
456     if archive_format == "zip" and not password:
457         log.debug("Checking %s to see if it is password-protected", source_match)
458         try:
459             encrypted_zip = __salt__["archive.is_encrypted"](
460                 cached, clean=False, saltenv=__env__, use_etag=use_etag
461             )
462         except CommandExecutionError:
463             pass
464         else:
465             if encrypted_zip:
466                 ret["comment"] = (
467                     "Archive {} is password-protected, but no password was "
468                     "specified. Please set the 'password' argument.".format(
469                         salt.utils.url.redact_http_basic_auth(source_match)
470                     )
471                 )
472                 return ret
473     try:
474         contents = __salt__["archive.list"](
475             cached,
476             archive_format=archive_format,
477             options=list_options,
478             strip_components=strip_components,
479             clean=False,
480             verbose=True,
481             use_etag=use_etag,
482         )
483     except CommandExecutionError as exc:
484         contents = None
485         errors = []
486         if not if_missing:
487             errors.append("'if_missing' must be set")
488         if not enforce_ownership_on and (user or group):
489             errors.append(
490                 "Ownership cannot be managed without setting 'enforce_ownership_on'."
491             )
492         msg = exc.strerror
493         if errors:
494             msg += "\n\n"
495             if archive_format == "tar":
496                 msg += (
497                     "If the source archive is a tar archive compressed using "
498                     "a compression type not natively supported by the tar "
499                     "command, then setting the 'list_options' argument may "
500                     "allow the contents to be listed. Otherwise, if Salt is "
501                     "unable to determine the files/directories in the "
502                     "archive, the following workaround(s) would need to be "
503                     "used for this state to proceed"
504                 )
505             else:
506                 msg += (
507                     "The following workarounds must be used for this state to proceed"
508                 )
509             msg += " (assuming the source file is a valid {} archive):\n".format(
510                 archive_format
511             )
512             for error in errors:
513                 msg += "\n- {}".format(error)
514         ret["comment"] = msg
515         return ret
516     if (
517         enforce_toplevel
518         and contents is not None
519         and (
520             len(contents["top_level_dirs"]) &gt; 1 or len(contents["top_level_files"]) &gt; 0
521         )
522     ):
523         ret["comment"] = (
524             "Archive does not have a single top-level directory. "
525             "To allow this archive to be extracted, set "
526             "'enforce_toplevel' to False. To avoid a "
527             "'{}-bomb' it may also be advisable to set a "
528             "top-level directory by adding it to the 'name' "
529             "value (for example, setting 'name' to {} "
530             "instead of {}).".format(
531                 archive_format,
532                 os.path.join(name, "some_dir"),
533                 name,
534             )
535         )
536         return ret
537     if clean and clean_parent:
538         ret["comment"] = "Only one of 'clean' and 'clean_parent' can be set to True"
539         ret["result"] = False
540         return ret
541     extraction_needed = overwrite
542     contents_missing = False
543     try:
544         if_missing_path_exists = os.path.exists(if_missing)
545     except TypeError:
546         if_missing_path_exists = False
547     if not if_missing_path_exists:
548         if contents is None:
549             try:
550                 os.lstat(if_missing)
551                 extraction_needed = False
552             except OSError as exc:
553                 if exc.errno == errno.ENOENT:
554                     extraction_needed = True
555                 else:
556                     ret["comment"] = (
557                         "Failed to check for existence of if_missing path "
558                         "({}): {}".format(if_missing, exc.__str__())
559                     )
560                     return ret
561         else:
562             incorrect_type = []
563             for path_list, func in (
564                 (contents["dirs"], stat.S_ISDIR),
565                 (
566                     contents["files"],
567                     lambda x: not stat.S_ISLNK(x) and not stat.S_ISDIR(x),
568                 ),
569                 (contents["links"], stat.S_ISLNK),
570             ):
571                 for path in path_list:
572                     full_path = salt.utils.path.join(name, path)
573                     try:
574                         path_mode = os.lstat(full_path.rstrip(os.sep)).st_mode
575                         if not func(path_mode):
576                             incorrect_type.append(path)
577                     except OSError as exc:
578                         if exc.errno == errno.ENOENT:
579                             extraction_needed = True
580                             contents_missing = True
581                         elif exc.errno != errno.ENOTDIR:
582                             ret["comment"] = exc.__str__()
583                             return ret
584             if incorrect_type:
585                 incorrect_paths = "\n\n" + "\n".join(
586                     ["- {}".format(x) for x in incorrect_type]
587                 )
588                 ret["comment"] = (
589                     "The below paths (relative to {}) exist, but are the "
590                     "incorrect type (file instead of directory, symlink "
591                     "instead of file, etc.).".format(name)
592                 )
593                 if __opts__["test"] and clean and contents is not None:
594                     ret["result"] = None
595                     ret["comment"] += (
596                         " Since the 'clean' option is enabled, the "
597                         "destination paths would be cleared and the "
598                         "archive would be extracted.{}".format(incorrect_paths)
599                     )
600                     return ret
601                 if __opts__["test"] and clean_parent and contents is not None:
602                     ret["result"] = None
603                     ret["comment"] += (
604                         " Since the 'clean_parent' option is enabled, the "
605                         "destination parent directory would be removed first "
606                         "and then re-created and the archive would be "
607                         "extracted"
608                     )
609                     return ret
610                 if not (clean and contents is not None):
611                     if not force:
612                         ret["comment"] += (
613                             " To proceed with extraction, set 'force' to "
614                             "True. Note that this will remove these paths "
615                             "before extracting.{}".format(incorrect_paths)
616                         )
617                         return ret
618                     else:
619                         errors = []
620                         for path in incorrect_type:
621                             full_path = os.path.join(name, path)
622                             try:
623                                 salt.utils.files.rm_rf(full_path.rstrip(os.sep))
624                                 ret["changes"].setdefault("removed", []).append(
625                                     full_path
626                                 )
627                                 extraction_needed = True
628                             except OSError as exc:
629                                 if exc.errno != errno.ENOENT:
630                                     errors.append(exc.__str__())
631                         if errors:
632                             msg = (
633                                 "One or more paths existed by were the incorrect "
634                                 "type (i.e. file instead of directory or "
635                                 "vice-versa), but could not be removed. The "
636                                 "following errors were observed:\n"
637                             )
638                             for error in errors:
639                                 msg += "\n- {}".format(error)
640                             ret["comment"] = msg
641                             return ret
642     if (
643         not extraction_needed
644         and source_hash_update
645         and existing_cached_source_sum is not None
646         and not _compare_checksum(cached, existing_cached_source_sum)
647     ):
648         extraction_needed = True
649         source_hash_trigger = True
650     else:
651         source_hash_trigger = False
652     created_destdir = False
653     if extraction_needed:
654         if source_is_local and source_hash and not skip_verify:
655             ret["result"] = __salt__["file.check_hash"](
656                 source_match, source_sum["hsum"]
657             )
658             if not ret["result"]:
659                 ret["comment"] = "{} does not match the desired source_hash {}".format(
660                     salt.utils.url.redact_http_basic_auth(source_match),
661                     source_sum["hsum"],
662                 )
663                 return ret
664         if __opts__["test"]:
665             ret["result"] = None
666             ret["comment"] = "Archive {} would be extracted to {}".format(
667                 salt.utils.url.redact_http_basic_auth(source_match), name
668             )
669             if clean and contents is not None:
670                 ret["comment"] += ", after cleaning destination path(s)"
671             _add_explanation(ret, source_hash_trigger, contents_missing)
672             return ret
673         if clean_parent and contents is not None:
674             errors = []
675             log.debug("Removing directory %s due to clean_parent set to True", name)
676             try:
677                 salt.utils.files.rm_rf(name.rstrip(os.sep))
678                 ret["changes"].setdefault(
679                     "removed",
680                     "Directory {} was removed prior to the extraction".format(name),
681                 )
682             except OSError as exc:
683                 if exc.errno != errno.ENOENT:
684                     errors.append(str(exc))
685             if errors:
686                 msg = (
687                     "Unable to remove the directory {}. The following "
688                     "errors were observed:\n".format(name)
689                 )
690                 for error in errors:
691                     msg += "\n- {}".format(error)
692                 ret["comment"] = msg
693                 return ret
694         if clean and contents is not None:
695             errors = []
696             log.debug("Cleaning archive paths from within %s", name)
697                 full_path = os.path.join(name, path)
698                 try:
699                     log<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.debug("Removing %s", full_path)
700                     salt.utils.files.rm_rf(full_path.rstrip(os.sep))
701                     ret["changes"].setdefault("removed", []).append(</b></font>full_path)
702                 except OSError as exc:
703                     if exc.errno != errno.ENOENT:
704                         errors.append(exc.__str__())
705             if errors:
706                 msg = (
707                     "One or more paths could not be cleaned. The following "
708                     "errors were observed:\n"
709                 )
710                 for error in errors:
711                     msg += "\n- {}".format(error)
712                 ret["comment"] = msg
713                 return ret
714         if not os.path.isdir(name):
715             __states__["file.directory"](name, user=user, makedirs=True)
716             created_destdir = True
717         log.debug("Extracting %s to %s", cached, name)
718         try:
719             if archive_format == "zip":
720                 if use_cmd_unzip:
721                     try:
722                         files = __salt__["archive.cmd_unzip"](
723                             cached,
724                             name,
725                             options=options,
726                             trim_output=trim_output,
727                             password=password,
728                             **kwargs
729                         )
730                     except (CommandExecutionError, CommandNotFoundError) as exc:
731                         ret["comment"] = exc.strerror
732                         return ret
733                 else:
734                     files = __salt__["archive.unzip"](
735                         cached,
736                         name,
737                         options=options,
738                         trim_output=trim_output,
739                         password=password,
740                         extract_perms=extract_perms,
741                         **kwargs
742                     )
743             elif archive_format == "rar":
744                 try:
745                     files = __salt__["archive.unrar"](
746                         cached, name, trim_output=trim_output, **kwargs
747                     )
748                 except (CommandExecutionError, CommandNotFoundError) as exc:
749                     ret["comment"] = exc.strerror
750                     return ret
751             else:
752                 if options is None:
753                     try:
754                         with closing(tarfile.open(cached, "r")) as tar:
755                             tar.extractall(salt.utils.stringutils.to_str(name))
756                             files = tar.getnames()
757                             if trim_output:
758                                 files = files[:trim_output]
759                     except tarfile.ReadError:
760                         if salt.utils.path.which("xz"):
761                             if (
762                                 __salt__["cmd.retcode"](
763                                     ["xz", "-t", cached],
764                                     python_shell=False,
765                                     ignore_retcode=True,
766                                 )
767                                 == 0
768                             ):
769                                 log.debug(
770                                     "Tar file is XZ-compressed, attempting "
771                                     "decompression and extraction using XZ Utils "
772                                     "and the tar command"
773                                 )
774                                 cmd = "xz --decompress --stdout {0} | tar xvf -"
775                                 results = __salt__["cmd.run_all"](
776                                     cmd.format(shlex.quote(cached)),
777                                     cwd=name,
778                                     python_shell=True,
779                                 )
780                                 if results["retcode"] != 0:
781                                     if created_destdir:
782                                         _cleanup_destdir(name)
783                                     ret["result"] = False
784                                     ret["changes"] = results
785                                     return ret
786                                 if _is_bsdtar():
787                                     files = results["stderr"]
788                                 else:
789                                     files = results["stdout"]
790                             else:
791                                 if created_destdir:
792                                     _cleanup_destdir(name)
793                                 ret["result"] = False
794                                 ret["comment"] = (
795                                     "Failed to read from tar archive using "
796                                     "Python's native tar file support. If "
797                                     "archive is compressed using something "
798                                     "other than gzip or bzip2, the "
799                                     "'options' argument may be required to "
800                                     "pass the correct options to the tar "
801                                     "command in order to extract the archive."
802                                 )
803                                 return ret
804                         else:
805                             if created_destdir:
806                                 _cleanup_destdir(name)
807                             ret["result"] = False
808                             ret["comment"] = (
809                                 "Failed to read from tar archive. If it is "
810                                 "XZ-compressed, install xz-utils to attempt "
811                                 "extraction."
812                             )
813                             return ret
814                 else:
815                     if not salt.utils.path.which("tar"):
816                         ret["comment"] = (
817                             "tar command not available, it might not be "
818                             "installed on minion"
819                         )
820                         return ret
821                     tar_opts = [
822                         x
823                         for x in shlex.split(options)
824                         if x not in ("v", "-v", "--verbose")
825                     ]
826                     tar_cmd = ["tar"]
827                     tar_shortopts = "xv"
828                     tar_longopts = []
829                     for position, opt in enumerate(tar_opts):
830                         if opt.startswith("-"):
831                             tar_longopts.append(opt)
832                         else:
833                             if position &gt; 0:
834                                 tar_longopts.append(opt)
835                             else:
836                                 append_opt = opt
837                                 append_opt = append_opt.replace("x", "")
838                                 append_opt = append_opt.replace("f", "")
839                                 tar_shortopts = tar_shortopts + append_opt
840                     if __grains__["os"].lower() == "openbsd":
841                         tar_shortopts = "-" + tar_shortopts
842                     tar_cmd.append(tar_shortopts)
843                     tar_cmd.extend(tar_longopts)
844                     tar_cmd.extend(["-f", cached])
845                     results = __salt__["cmd.run_all"](
846                         tar_cmd, cwd=name, python_shell=False
847                     )
848                     if results["retcode"] != 0:
849                         ret["result"] = False
850                         ret["changes"] = results
851                         return ret
852                     if _is_bsdtar():
853                         files = results["stderr"].splitlines()
854                         if trim_output:
855                             files = files[:trim_output]
856                     else:
857                         files = results["stdout"].splitlines()
858                         if trim_output:
859                             files = files[:trim_output]
860                     if not files:
861                         files = "no tar output so far"
862         except CommandExecutionError as exc:
863             ret["comment"] = exc.strerror
864             return ret
865     enforce_missing = []
866     enforce_failed = []
867     if user or group:
868         if enforce_ownership_on:
869             if os.path.isdir(enforce_ownership_on):
870                 enforce_dirs = [enforce_ownership_on]
871                 enforce_files = []
872                 enforce_links = []
873             else:
874                 enforce_dirs = []
875                 enforce_files = [enforce_ownership_on]
876                 enforce_links = []
877         else:
878             if contents is not None:
879                 enforce_dirs = contents["top_level_dirs"]
880                 enforce_files = contents["top_level_files"]
881                 enforce_links = contents["top_level_links"]
882         recurse = []
883         if user:
884             recurse.append("user")
885         if group:
886             recurse.append("group")
887         recurse_str = ", ".join(recurse)
888         owner_changes = {x: y for x, y in (("user", user), ("group", group)) if y}
889         for dirname in enforce_dirs:
890             full_path = os.path.join(name, dirname)
891             if not os.path.isdir(full_path):
892                 if not __opts__["test"]:
893                     enforce_missing.append(full_path)
894             else:
895                 log.debug(
896                     "Enforcing %s ownership on %s using a file.directory state%s",
897                     recurse_str,
898                     dirname,
899                     " (dry-run only)" if __opts__["test"] else "",
900                 )
901                 dir_result = __states__["file.directory"](
902                     full_path, user=user, group=group, recurse=recurse
903                 )
904                 log.debug("file.directory: %s", dir_result)
905                 if dir_result.get("changes"):
906                     ret["changes"]["updated ownership"] = True
907                 try:
908                     if not dir_result["result"]:
909                         enforce_failed.append(full_path)
910                 except (KeyError, TypeError):
911                     log.warning(
912                         "Bad state return %s for file.directory state on %s",
913                         dir_result,
914                         dirname,
915                     )
916         for filename in enforce_files + enforce_links:
917             full_path = os.path.join(name, filename)
918             try:
919                 file_stat = os.lstat(full_path)
920             except OSError as exc:
921                 if not __opts__["test"]:
922                     if exc.errno == errno.ENOENT:
923                         enforce_missing.append(full_path)
924                     enforce_failed.append(full_path)
925             else:
926                 if (uid != -1 and uid != file_stat.st_uid) or (
927                     gid != -1 and gid != file_stat.st_gid
928                 ):
929                     if __opts__["test"]:
930                         ret["changes"]["updated ownership"] = True
931                     else:
932                         try:
933                             os.lchown(full_path, uid, gid)
934                             ret["changes"]["updated ownership"] = True
935                         except OSError:
936                             enforce_failed.append(filename)
937     if extraction_needed:
938         if len(files) &gt; 0:
939             if created_destdir:
940                 ret["changes"]["directories_created"] = [name]
941             ret["changes"]["extracted_files"] = files
942             ret["comment"] = "{} extracted to {}".format(
943                 salt.utils.url.redact_http_basic_auth(source_match),
944                 name,
945             )
946             _add_explanation(ret, source_hash_trigger, contents_missing)
947             ret["comment"] += ". Output was trimmed to {} number of lines".format(
948                 trim_output
949             )
950             ret["result"] = True
951         else:
952             ret["result"] = False
953             ret["comment"] = "No files were extracted from {}".format(
954                 salt.utils.url.redact_http_basic_auth(source_match)
955             )
956     else:
957         ret["result"] = True
958         if if_missing_path_exists:
959             ret["comment"] = "{} exists".format(if_missing)
960         else:
961             ret["comment"] = "All files in archive are already present"
962         if __opts__["test"]:
963             if ret["changes"].get("updated ownership"):
964                 ret["result"] = None
965                 ret[
966                     "comment"
967                 ] += ". Ownership would be updated on one or more files/directories."
968     if enforce_missing:
969         if not if_missing:
970             ret["result"] = False
971         ret["comment"] += (
972             "\n\nWhile trying to enforce user/group ownership, the following "
973             "paths were missing:\n"
974         )
975         for item in enforce_missing:
976             ret["comment"] += "\n- {}".format(item)
977     if enforce_failed:
978         ret["result"] = False
979         ret["comment"] += (
980             "\n\nWhile trying to enforce user/group ownership, Salt was "
981             "unable to change ownership on the following paths:\n"
982         )
983         for item in enforce_failed:
984             ret["comment"] += "\n- {}".format(item)
985     if not source_is_local:
986         if keep_source:
987             log.debug("Keeping cached source file %s", cached)
988         else:
989             log.debug("Cleaning cached source file %s", cached)
990             result = __states__["file.not_cached"](source_match, saltenv=__env__)
991             if not result["result"]:
992                 ret.setdefault("warnings", []).append(result["comment"])
993     return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>network_4.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import fnmatch
3 import itertools
4 import logging
5 import os
6 import platform
7 import random
8 import re
9 import socket
10 import subprocess
11 import types
12 from collections.abc import Mapping, Sequence
13 from string import ascii_letters, digits
14 import salt.utils.args
15 import salt.utils.files
16 import salt.utils.path
17 import salt.utils.platform
18 import</b></font> salt.utils.stringutils
19 import salt.utils.zeromq
20 from salt._compat import ipaddress
21 from salt.exceptions import SaltClientError, SaltSystemExit
22 from salt.utils.decorators.jinja import jinja_filter
23 from salt.utils.versions import LooseVersion
24 try:
25     import salt.utils.win_network
26     WIN_NETWORK_LOADED = True
27 except ImportError:
28     WIN_NETWORK_LOADED = False
29 log = logging.getLogger(__name__)
30 try:
31     import ctypes
32     import ctypes.util
33     LIBC = ctypes.cdll.LoadLibrary(ctypes.util.find_library("c"))
34     RES_INIT = LIBC.__res_init
35 except (ImportError, OSError, AttributeError, TypeError):
36     pass
37 class Interfaces:
38     __slots__ = ("interfaces",)
39     def __init__(self, interfaces=None):
40         if interfaces is None:
41             interfaces = {}
42         self.interfaces = interfaces
43     def __call__(self, *args, **kwargs):
44         if not self.interfaces:
45             self.interfaces = interfaces()
46         return self.interfaces
47     def clear(self):
48         self.interfaces = {}
49 _get_interfaces = Interfaces()
50 _clear_interfaces = _get_interfaces.clear
51 def sanitize_host(host):
52     """
53     Sanitize host string.
54     https://tools.ietf.org/html/rfc1123#section-2.1
55     """
56     RFC952_characters = ascii_letters + digits + ".-_"
57     return "".join([c for c in host[0:255] if c in RFC952_characters])
58 def isportopen(host, port):
59     """
60     Return status of a port
61     """
62     if not 1 &lt;= int(port) &lt;= 65535:
63         return False
64     sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
65     out = sock.connect_ex((sanitize_host(host), int(port)))
66     return out
67 def host_to_ips(host):
68     """
69     Returns a list of IP addresses of a given hostname or None if not found.
70     """
71     ips = []
72     try:
73         for family, socktype, proto, canonname, sockaddr in socket.getaddrinfo(
74             host, 0, socket.AF_UNSPEC, socket.SOCK_STREAM
75         ):
76             if family == socket.AF_INET:
77                 ip, port = sockaddr
78             elif family == socket.AF_INET6:
79                 ip, port, flow_info, scope_id = sockaddr
80             ips.append(ip)
81         if not ips:
82             ips = None
83     except Exception:  # pylint: disable=broad-except
84         ips = None
85     return ips
86 def _generate_minion_id():
87     """
88     Get list of possible host names and convention names.
89     :return:
90     """
91     class DistinctList(list):
92         """
93         List, which allows one to append only distinct objects.
94         Needs to work on Python 2.6, because of collections.OrderedDict only since 2.7 version.
95         Override 'filter()' for custom filtering.
96         """
97         localhost_matchers = [
98             r"localhost.*",
99             r"ip6-.*",
100             r"127[.]\d",
101             r"0\.0\.0\.0",
102             r"::1.*",
103             r"ipv6-.*",
104             r"fe00::.*",
105             r"fe02::.*",
106             r"1.0.0.*.ip6.arpa",
107         ]
108         def append(self, p_object):
109             if p_object and p_object not in self and not self.filter(p_object):
110                 super().append(p_object)
111             return self
112         def extend(self, iterable):
113             for obj in iterable:
114                 self.append(obj)
115             return self
116         def filter(self, element):
117             "Returns True if element needs to be filtered"
118             for rgx in self.localhost_matchers:
119                 if re.match(rgx, element):
120                     return True
121         def first(self):
122             return self and self[0] or None
123     hostname = socket.gethostname()
124     hosts = (
125         DistinctList()
126         <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.append(
127             salt.utils.stringutils.to_unicode(
128                 socket.getfqdn(salt.utils.stringutils.to_bytes(hostname))
129             )
130         )
131         .append(</b></font>platform.node())
132         .append(hostname)
133     )
134     if not hosts:
135         try:
136             for a_nfo in socket.getaddrinfo(
137                 hosts.first() or "localhost",
138                 None,
139                 socket.AF_INET,
140                 socket.SOCK_RAW,
141                 socket.IPPROTO_IP,
142                 socket.AI_CANONNAME,
143             ):
144                 if len(a_nfo) &gt; 3:
145                     hosts.append(a_nfo[3])
146         except socket.gaierror:
147             log.warning(
148                 "Cannot resolve address %s info via socket: %s",
149                 hosts.first() or "localhost (N/A)",
150                 socket.gaierror,
151             )
152     for f_name in (
153         "/etc/hostname",
154         "/etc/nodename",
155         "/etc/hosts",
156         r"{win}\system32\drivers\etc\hosts".format(win=os.getenv("WINDIR")),
157     ):
158         try:
159             with salt.utils.files.fopen(f_name) as f_hdl:
160                 for line in f_hdl:
161                     line = salt.utils.stringutils.to_unicode(line)
162                     hst = line.strip().split("#")[0].strip().split()
163                     if hst:
164                         if hst[0][:4] in ("127.", "::1") or len(hst) == 1:
165                             hosts.extend(hst)
166         except OSError:
167             pass
168     return hosts.extend(
169         [addr for addr in ip_addrs() if not ipaddress.ip_address(addr).is_loopback]
170     )
171 def generate_minion_id():
172     """
173     Return only first element of the hostname from all possible list.
174     :return:
175     """
176     try:
177         ret = salt.utils.stringutils.to_unicode(_generate_minion_id().first())
178     except TypeError:
179         ret = None
180     return ret or "localhost"
181 def get_socket(addr, type=socket.SOCK_STREAM, proto=0):
182     """
183     Return a socket object for the addr
184     IP-version agnostic
185     """
186     version = ipaddress.ip_address(addr).version
187     if version == 4:
188         family = socket.AF_INET
189     elif version == 6:
190         family = socket.AF_INET6
191     return socket.socket(family, type, proto)
192 def get_fqhostname():
193     """
194     Returns the fully qualified hostname
195     """
196     l = [socket.getfqdn()]
197     try:
198         addrinfo = socket.getaddrinfo(
199             socket.gethostname(),
200             0,
201             socket.AF_UNSPEC,
202             socket.SOCK_STREAM,
203             socket.SOL_TCP,
204             socket.AI_CANONNAME,
205         )
206         for info in addrinfo:
207             if len(info) &gt;= 4 and info[3]:
208                 l = [info[3]]
209     except socket.gaierror:
210         pass
211     return l and l[0] or None
212 def ip_to_host(ip):
213     """
214     Returns the hostname of a given IP
215     """
216     try:
217         hostname, aliaslist, ipaddrlist = socket.gethostbyaddr(ip)
218     except Exception as exc:  # pylint: disable=broad-except
219         log.debug("salt.utils.network.ip_to_host(%r) failed: %s", ip, exc)
220         hostname = None
221     return hostname
222 def is_reachable_host(entity_name):
223     """
224     Returns a bool telling if the entity name is a reachable host (IPv4/IPv6/FQDN/etc).
225     :param hostname:
226     :return:
227     """
228     try:
229         assert type(socket.getaddrinfo(entity_name, 0, 0, 0, 0)) == list
230         ret = True
231     except socket.gaierror:
232         ret = False
233     return ret
234 def is_ip(ip_addr):
235     """
236     Returns a bool telling if the passed IP is a valid IPv4 or IPv6 address.
237     """
238     return is_ipv4(ip_addr) or is_ipv6(ip_addr)
239 def is_ipv4(ip_addr):
240     """
241     Returns a bool telling if the value passed to it was a valid IPv4 address
242     """
243     try:
244         return ipaddress.ip_address(ip_addr).version == 4
245     except ValueError:
246         return False
247 def is_ipv6(ip_addr):
248     """
249     Returns a bool telling if the value passed to it was a valid IPv6 address
250     """
251     try:
252         return ipaddress.ip_address(ip_addr).version == 6
253     except ValueError:
254         return False
255 def is_subnet(cidr):
256     """
257     Returns a bool telling if the passed string is an IPv4 or IPv6 subnet
258     """
259     return is_ipv4_subnet(cidr) or is_ipv6_subnet(cidr)
260 def is_ipv4_subnet(cidr):
261     """
262     Returns a bool telling if the passed string is an IPv4 subnet
263     """
264     try:
265         return "/" in cidr and bool(ipaddress.IPv4Network(cidr))
266     except Exception:  # pylint: disable=broad-except
267         return False
268 def is_ipv6_subnet(cidr):
269     """
270     Returns a bool telling if the passed string is an IPv6 subnet
271     """
272     try:
273         return "/" in cidr and bool(ipaddress.IPv6Network(cidr))
274     except Exception:  # pylint: disable=broad-except
275         return False
276 @jinja_filter("is_ip")
277 def is_ip_filter(ip_addr, options=None):
278     """
279     Returns a bool telling if the passed IP is a valid IPv4 or IPv6 address.
280     """
281     return is_ipv4_filter(ip_addr, options=options) or is_ipv6_filter(
282         ip_addr, options=options
283     )
284 def _ip_options_global(ip_obj, version):
285     return not ip_obj.is_private
286 def _ip_options_multicast(ip_obj, version):
287     return ip_obj.is_multicast
288 def _ip_options_loopback(ip_obj, version):
289     return ip_obj.is_loopback
290 def _ip_options_link_local(ip_obj, version):
291     return ip_obj.is_link_local
292 def _ip_options_private(ip_obj, version):
293     return ip_obj.is_private
294 def _ip_options_reserved(ip_obj, version):
295     return ip_obj.is_reserved
296 def _ip_options_site_local(ip_obj, version):
297     if version == 6:
298         return ip_obj.is_site_local
299     return False
300 def _ip_options_unspecified(ip_obj, version):
301     return ip_obj.is_unspecified
302 def _ip_options(ip_obj, version, options=None):
303     options_fun_map = {
304         "global": _ip_options_global,
305         "link-local": _ip_options_link_local,
306         "linklocal": _ip_options_link_local,
307         "ll": _ip_options_link_local,
308         "link_local": _ip_options_link_local,
309         "loopback": _ip_options_loopback,
310         "lo": _ip_options_loopback,
311         "multicast": _ip_options_multicast,
312         "private": _ip_options_private,
313         "public": _ip_options_global,
314         "reserved": _ip_options_reserved,
315         "site-local": _ip_options_site_local,
316         "sl": _ip_options_site_local,
317         "site_local": _ip_options_site_local,
318         "unspecified": _ip_options_unspecified,
319     }
320     if not options:
321         return str(ip_obj)  # IP version already checked
322     options_list = [option.strip() for option in options.split(",")]
323     for option, fun in options_fun_map.items():
324         if option in options_list:
325             fun_res = fun(ip_obj, version)
326             if not fun_res:
327                 return None
328     return str(ip_obj)
329 def _is_ipv(ip_addr, version, options=None):
330     if not version:
331         version = 4
332     if version not in (4, 6):
333         return None
334     try:
335         ip_obj = ipaddress.ip_address(ip_addr)
336     except ValueError:
337         try:
338             ip_obj = ipaddress.ip_interface(ip_addr)
339         except ValueError:
340             return None
341     if not ip_obj.version == version:
342         return None
343     return _ip_options(ip_obj, version, options=options)
344 @jinja_filter("is_ipv4")
345 def is_ipv4_filter(ip_addr, options=None):
346     """
347     Returns a bool telling if the value passed to it was a valid IPv4 address.
348     ip
349         The IP address.
350     net: False
351         Consider IP addresses followed by netmask.
352     options
353         CSV of options regarding the nature of the IP address. E.g.: loopback, multicast, private etc.
354     """
355     _is_ipv4 = _is_ipv(ip_addr, 4, options=options)
356     return isinstance(_is_ipv4, str)
357 @jinja_filter("is_ipv6")
358 def is_ipv6_filter(ip_addr, options=None):
359     """
360     Returns a bool telling if the value passed to it was a valid IPv6 address.
361     ip
362         The IP address.
363     net: False
364         Consider IP addresses followed by netmask.
365     options
366         CSV of options regarding the nature of the IP address. E.g.: loopback, multicast, private etc.
367     """
368     _is_ipv6 = _is_ipv(ip_addr, 6, options=options)
369     return isinstance(_is_ipv6, str)
370 def _ipv_filter(value, version, options=None):
371     if version not in (4, 6):
372         return
373     if isinstance(value, (str, bytes)):
374         return _is_ipv(
375             value, version, options=options
376         )  # calls is_ipv4 or is_ipv6 for `value`
377     elif isinstance(value, (list, tuple, types.GeneratorType)):
378         return [
379             _is_ipv(addr, version, options=options)
380             for addr in value
381             if _is_ipv(addr, version, options=options) is not None
382         ]
383     return None
384 @jinja_filter("ipv4")
385 def ipv4(value, options=None):
386     """
387     Filters a list and returns IPv4 values only.
388     """
389     return _ipv_filter(value, 4, options=options)
390 @jinja_filter("ipv6")
391 def ipv6(value, options=None):
392     """
393     Filters a list and returns IPv6 values only.
394     """
395     return _ipv_filter(value, 6, options=options)
396 @jinja_filter("ipaddr")
397 def ipaddr(value, options=None):
398     """
399     Filters and returns only valid IP objects.
400     """
401     ipv4_obj = ipv4(value, options=options)
402     ipv6_obj = ipv6(value, options=options)
403     if ipv4_obj is None or ipv6_obj is None:
404         return ipv4_obj or ipv6_obj  # one of them
405     else:
406         return ipv4_obj + ipv6_obj  # extend lists
407 def _filter_ipaddr(value, options, version=None):
408     ipaddr_filter_out = None
409     if version:
410         if version == 4:
411             ipaddr_filter_out = ipv4(value, options)
412         elif version == 6:
413             ipaddr_filter_out = ipv6(value, options)
414     else:
415         ipaddr_filter_out = ipaddr(value, options)
416     if not ipaddr_filter_out:
417         return
418     if not isinstance(ipaddr_filter_out, (list, tuple, types.GeneratorType)):
419         ipaddr_filter_out = [ipaddr_filter_out]
420     return ipaddr_filter_out
421 @jinja_filter("ip_host")
422 def ip_host(value, options=None, version=None):
423     """
424     Returns the interfaces IP address, e.g.: 192.168.0.1/28.
425     """
426     ipaddr_filter_out = _filter_ipaddr(value, options=options, version=version)
427     if not ipaddr_filter_out:
428         return
429     if not isinstance(value, (list, tuple, types.GeneratorType)):
430         return str(ipaddress.ip_interface(ipaddr_filter_out[0]))
431     return [str(ipaddress.ip_interface(ip_a)) for ip_a in ipaddr_filter_out]
432 def _network_hosts(ip_addr_entry):
433     return [
434         str(host) for host in ipaddress.ip_network(ip_addr_entry, strict=False).hosts()
435     ]
436 @jinja_filter("network_hosts")
437 def network_hosts(value, options=None, version=None):
438     """
439     Return the list of hosts within a network.
440     .. note::
441         When running this command with a large IPv6 network, the command will
442         take a long time to gather all of the hosts.
443     """
444     ipaddr_filter_out = _filter_ipaddr(value, options=options, version=version)
445     if not ipaddr_filter_out:
446         return
447     if not isinstance(value, (list, tuple, types.GeneratorType)):
448         return _network_hosts(ipaddr_filter_out[0])
449     return [_network_hosts(ip_a) for ip_a in ipaddr_filter_out]
450 def _network_size(ip_addr_entry):
451     return ipaddress.ip_network(ip_addr_entry, strict=False).num_addresses
452 @jinja_filter("network_size")
453 def network_size(value, options=None, version=None):
454     """
455     Get the size of a network.
456     """
457     ipaddr_filter_out = _filter_ipaddr(value, options=options, version=version)
458     if not ipaddr_filter_out:
459         return
460     if not isinstance(value, (list, tuple, types.GeneratorType)):
461         return _network_size(ipaddr_filter_out[0])
462     return [_network_size(ip_a) for ip_a in ipaddr_filter_out]
463 def natural_ipv4_netmask(ip_addr, fmt="prefixlen"):
464     """
465     Returns the "natural" mask of an IPv4 address
466     """
467     bits = _ipv4_to_bits(ip_addr)
468     if bits.startswith("11"):
469         mask = "24"
470     elif bits.startswith("1"):
471         mask = "16"
472     else:
473         mask = "8"
474     if fmt == "netmask":
475         return cidr_to_ipv4_netmask(mask)
476     else:
477         return "/" + mask
478 def rpad_ipv4_network(ip_addr):
479     """
480     Returns an IP network address padded with zeros.
481     Ex: '192.168.3' -&gt; '192.168.3.0'
482         '10.209' -&gt; '10.209.0.0'
483     """
484     return ".".join(itertools.islice(itertools.chain(ip_addr.split("."), "0000"), 0, 4))
485 def cidr_to_ipv4_netmask(cidr_bits):
486     """
487     Returns an IPv4 netmask
488     """
489     try:
490         cidr_bits = int(cidr_bits)
491         if not 1 &lt;= cidr_bits &lt;= 32:
492             return ""
493     except ValueError:
494         return ""
495     netmask = ""
496     for idx in range(4):
497         if idx:
498             netmask += "."
499         if cidr_bits &gt;= 8:
500             netmask += "255"
501             cidr_bits -= 8
502         else:
503             netmask += "{:d}".format(256 - (2 ** (8 - cidr_bits)))
504             cidr_bits = 0
505     return netmask
506 def _number_of_set_bits_to_ipv4_netmask(set_bits):
507     """
508     Returns an IPv4 netmask from the integer representation of that mask.
509     Ex. 0xffffff00 -&gt; '255.255.255.0'
510     """
511     return cidr_to_ipv4_netmask(_number_of_set_bits(set_bits))
512 def _number_of_set_bits(x):
513     """
514     Returns the number of bits that are set in a 32bit int
515     """
516     x -= (x &gt;&gt; 1) &amp; 0x55555555
517     x = ((x &gt;&gt; 2) &amp; 0x33333333) + (x &amp; 0x33333333)
518     x = ((x &gt;&gt; 4) + x) &amp; 0x0F0F0F0F
519     x += x &gt;&gt; 8
520     x += x &gt;&gt; 16
521     return x &amp; 0x0000003F
522 def _interfaces_ip(out):
523     """
524     Uses ip to return a dictionary of interfaces with various information about
525     each (up/down state, ip address, netmask, and hwaddr)
526     """
527     ret = dict()
528     def parse_network(value, cols):
529         """
530         Return a tuple of ip, netmask, broadcast
531         based on the current set of cols
532         """
533         brd = None
534         scope = None
535         if "/" in value:  # we have a CIDR in this address
536             ip, cidr = value.split("/")
537         else:
538             ip = value
539             cidr = 32
540         if type_ == "inet":
541             mask = cidr_to_ipv4_netmask(int(cidr))
542             if "brd" in cols:
543                 brd = cols[cols.index("brd") + 1]
544         elif type_ == "inet6":
545             mask = cidr
546             if "scope" in cols:
547                 scope = cols[cols.index("scope") + 1]
548         return (ip, mask, brd, scope)
549     groups = re.compile("\r?\n\\d").split(out)
550     for group in groups:
551         iface = None
552         data = dict()
553         for line in group.splitlines():
554             if " " not in line:
555                 continue
556             match = re.match(r"^\d*:\s+([\w.\-]+)(?:@)?([\w.\-]+)?:\s+&lt;(.+)&gt;", line)
557             if match:
558                 iface, parent, attrs = match.groups()
559                 if "UP" in attrs.split(","):
560                     data["up"] = True
561                 else:
562                     data["up"] = False
563                 if parent:
564                     data["parent"] = parent
565                 continue
566             cols = line.split()
567             if len(cols) &gt;= 2:
568                 type_, value = tuple(cols[0:2])
569                 iflabel = cols[-1:][0]
570                 if type_ in ("inet", "inet6"):
571                     ipaddr, netmask, broadcast, scope = parse_network(value, cols)
572                     addr_obj = dict()
573                     if "secondary" not in cols:
574                         if type_ == "inet":
575                             if "inet" not in data:
576                                 data["inet"] = list()
577                             addr_obj["address"] = ipaddr
578                             addr_obj["netmask"] = netmask
579                             addr_obj["broadcast"] = broadcast
580                             addr_obj["label"] = iflabel
581                             data["inet"].append(addr_obj)
582                         elif type_ == "inet6":
583                             if "inet6" not in data:
584                                 data["inet6"] = list()
585                             addr_obj["address"] = ipaddr
586                             addr_obj["prefixlen"] = netmask
587                             addr_obj["scope"] = scope
588                             data["inet6"].append(addr_obj)
589                     else:
590                         if type_ == "inet":
591                             if "secondary" not in data:
592                                 data["secondary"] = list()
593                             addr_obj["type"] = type_
594                             addr_obj["address"] = ipaddr
595                             addr_obj["netmask"] = netmask
596                             addr_obj["broadcast"] = broadcast
597                             addr_obj["label"] = iflabel
598                             data["secondary"].append(addr_obj)
599                         elif type_ == "inet6":
600                             if "secondary" not in data:
601                                 data["secondary"] = list()
602                             addr_obj["type"] = type_
603                             addr_obj["address"] = ipaddr
604                             addr_obj["prefixlen"] = netmask
605                             addr_obj["scope"] = scope
606                             data["secondary"].append(addr_obj)
607                 elif type_.startswith("link"):
608                     data["hwaddr"] = value
609         if iface:
610             ret[iface] = data
611             del iface, data
612     return ret
613 def _interfaces_ifconfig(out):
614     """
615     Uses ifconfig to return a dictionary of interfaces with various information
616     about each (up/down state, ip address, netmask, and hwaddr)
617     """
618     ret = dict()
619     piface = re.compile(r"^([^\s:]+)")
620     pmac = re.compile(".*?(?:HWaddr|ether|address:|lladdr) ([0-9a-fA-F:]+)")
621     if salt.utils.platform.is_sunos():
622         pip = re.compile(r".*?(?:inet\s+)([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)(.*)")
623         pip6 = re.compile(".*?(?:inet6 )([0-9a-fA-F:]+)")
624         pmask6 = re.compile(r".*?(?:inet6 [0-9a-fA-F:]+/(\d+)).*")
625     else:
626         pip = re.compile(r".*?(?:inet addr:|inet [^\d]*)(.*?)\s")
627         pip6 = re.compile(".*?(?:inet6 addr: (.*?)/|inet6 )([0-9a-fA-F:]+)")
628         pmask6 = re.compile(
629             r".*?(?:inet6 addr: [0-9a-fA-F:]+/(\d+)|prefixlen (\d+))(?:"
630             r" Scope:([a-zA-Z]+)| scopeid (0x[0-9a-fA-F]))?"
631         )
632     pmask = re.compile(r".*?(?:Mask:|netmask )(?:((?:0x)?[0-9a-fA-F]{8})|([\d\.]+))")
633     pupdown = re.compile("UP")
634     pbcast = re.compile(r".*?(?:Bcast:|broadcast )([\d\.]+)")
635     groups = re.compile("\r?\n(?=\\S)").split(out)
636     for group in groups:
637         data = dict()
638         iface = ""
639         updown = False
640         for line in group.splitlines():
641             miface = piface.match(line)
642             mmac = pmac.match(line)
643             mip = pip.match(line)
644             mip6 = pip6.match(line)
645             mupdown = pupdown.search(line)
646             if miface:
647                 iface = miface.group(1)
648             if mmac:
649                 data["hwaddr"] = mmac.group(1)
650                 if salt.utils.platform.is_sunos():
651                     expand_mac = []
652                     for chunk in data["hwaddr"].split(":"):
653                         expand_mac.append(
654                             "0{}".format(chunk)
655                             if len(chunk) &lt; 2
656                             else "{}".format(chunk)
657                         )
658                     data["hwaddr"] = ":".join(expand_mac)
659             if mip:
660                 if "inet" not in data:
661                     data["inet"] = list()
662                 addr_obj = dict()
663                 addr_obj["address"] = mip.group(1)
664                 mmask = pmask.match(line)
665                 if mmask:
666                     if mmask.group(1):
667                         mmask = _number_of_set_bits_to_ipv4_netmask(
668                             int(mmask.group(1), 16)
669                         )
670                     else:
671                         mmask = mmask.group(2)
672                     addr_obj["netmask"] = mmask
673                 mbcast = pbcast.match(line)
674                 if mbcast:
675                     addr_obj["broadcast"] = mbcast.group(1)
676                 data["inet"].append(addr_obj)
677             if mupdown:
678                 updown = True
679             if mip6:
680                 if "inet6" not in data:
681                     data["inet6"] = list()
682                 addr_obj = dict()
683                 addr_obj["address"] = mip6.group(1) or mip6.group(2)
684                 mmask6 = pmask6.match(line)
685                 if mmask6:
686                     addr_obj["prefixlen"] = mmask6.group(1) or mmask6.group(2)
687                     if not salt.utils.platform.is_sunos():
688                         ipv6scope = mmask6.group(3) or mmask6.group(4)
689                         addr_obj["scope"] = (
690                             ipv6scope.lower() if ipv6scope is not None else ipv6scope
691                         )
692                 if (
693                     not salt.utils.platform.is_sunos()
694                     or addr_obj["address"] != "::"
695                     and addr_obj["prefixlen"] != 0
696                 ):
697                     data["inet6"].append(addr_obj)
698         data["up"] = updown
699         if iface in ret:
700             ret[iface] = dict(list(data.items()) + list(ret[iface].items()))
701             if "inet" in data:
702                 ret[iface]["inet"].extend(
703                     x for x in data["inet"] if x not in ret[iface]["inet"]
704                 )
705             if "inet6" in data:
706                 ret[iface]["inet6"].extend(
707                     x for x in data["inet6"] if x not in ret[iface]["inet6"]
708                 )
709         else:
710             ret[iface] = data
711         del data
712     return ret
713 def linux_interfaces():
714     """
715     Obtain interface information for *NIX/BSD variants
716     """
717     ifaces = dict()
718     ip_path = salt.utils.path.which("ip")
719     ifconfig_path = None if ip_path else salt.utils.path.which("ifconfig")
720     if ip_path:
721         cmd1 = subprocess.Popen(
722             [ip_path, "link", "show"],
723             close_fds=True,
724             stdout=subprocess.PIPE,
725             stderr=subprocess.STDOUT,
726         ).communicate()[0]
727         cmd2 = subprocess.Popen(
728             [ip_path, "addr", "show"],
729             close_fds=True,
730             stdout=subprocess.PIPE,
731             stderr=subprocess.STDOUT,
732         ).communicate()[0]
733         ifaces = _interfaces_ip(
734             "{}\n{}".format(
735                 salt.utils.stringutils.to_str(cmd1), salt.utils.stringutils.to_str(cmd2)
736             )
737         )
738     elif ifconfig_path:
739         cmd = subprocess.Popen(
740             [ifconfig_path, "-a"],
741             stdout=subprocess.PIPE,
742             stderr=subprocess.STDOUT,
743         ).communicate()[0]
744         ifaces = _interfaces_ifconfig(salt.utils.stringutils.to_str(cmd))
745     return ifaces
746 def _netbsd_interfaces_ifconfig(out):
747     """
748     Uses ifconfig to return a dictionary of interfaces with various information
749     about each (up/down state, ip address, netmask, and hwaddr)
750     """
751     ret = dict()
752     piface = re.compile(r"^([^\s:]+)")
753     pmac = re.compile(".*?address: ([0-9a-f:]+)")
754     pip = re.compile(r".*?inet [^\d]*(.*?)/([\d]*)\s")
755     pip6 = re.compile(r".*?inet6 ([0-9a-f:]+)%([a-zA-Z0-9]*)/([\d]*)\s")
756     pupdown = re.compile("UP")
757     pbcast = re.compile(r".*?broadcast ([\d\.]+)")
758     groups = re.compile("\r?\n(?=\\S)").split(out)
759     for group in groups:
760         data = dict()
761         iface = ""
762         updown = False
763         for line in group.splitlines():
764             miface = piface.match(line)
765             mmac = pmac.match(line)
766             mip = pip.match(line)
767             mip6 = pip6.match(line)
768             mupdown = pupdown.search(line)
769             if miface:
770                 iface = miface.group(1)
771             if mmac:
772                 data["hwaddr"] = mmac.group(1)
773             if mip:
774                 if "inet" not in data:
775                     data["inet"] = list()
776                 addr_obj = dict()
777                 addr_obj["address"] = mip.group(1)
778                 mmask = mip.group(2)
779                 if mip.group(2):
780                     addr_obj["netmask"] = cidr_to_ipv4_netmask(mip.group(2))
781                 mbcast = pbcast.match(line)
782                 if mbcast:
783                     addr_obj["broadcast"] = mbcast.group(1)
784                 data["inet"].append(addr_obj)
785             if mupdown:
786                 updown = True
787             if mip6:
788                 if "inet6" not in data:
789                     data["inet6"] = list()
790                 addr_obj = dict()
791                 addr_obj["address"] = mip6.group(1)
792                 mmask6 = mip6.group(3)
793                 addr_obj["scope"] = mip6.group(2)
794                 addr_obj["prefixlen"] = mip6.group(3)
795                 data["inet6"].append(addr_obj)
796         data["up"] = updown
797         ret[iface] = data
798         del data
799     return ret
800 def _junos_interfaces_ifconfig(out):
801     """
802     Uses ifconfig to return a dictionary of interfaces with various information
803     about each (up/down state, ip address, netmask, and hwaddr)
804     """
805     ret = dict()
806     piface = re.compile(r"^([^\s:]+)")
807     pmac = re.compile("curr media .*? ([0-9a-f:]+)")
808     pip = re.compile(
809         r".*?inet\s*(primary)*\s+mtu"
810         r" (\d+)\s+local=[^\d]*(.*?)\s+dest=[^\d]*(.*?)\/([\d]*)\s+bcast=((?:[0-9]{1,3}\.){3}[0-9]{1,3})"
811     )
812     pip6 = re.compile(
813         r".*?inet6 mtu [^\d]+\s+local=([0-9a-f:]+)%([a-zA-Z0-9]*)/([\d]*)\s"
814     )
815     pupdown = re.compile("UP")
816     pbcast = re.compile(r".*?broadcast ([\d\.]+)")
817     groups = re.compile("\r?\n(?=\\S)").split(out)
818     for group in groups:
819         data = dict()
820         iface = ""
821         updown = False
822         primary = False
823         for line in group.splitlines():
824             miface = piface.match(line)
825             mmac = pmac.match(line)
826             mip = pip.match(line)
827             mip6 = pip6.match(line)
828             mupdown = pupdown.search(line)
829             if miface:
830                 iface = miface.group(1)
831             if mmac:
832                 data["hwaddr"] = mmac.group(1)
833             if mip:
834                 if "primary" in data:
835                     primary = True
836                 if "inet" not in data:
837                     data["inet"] = list()
838                 if mip.group(2):
839                     data["mtu"] = int(mip.group(2))
840                 addr_obj = dict()
841                 addr_obj["address"] = mip.group(3)
842                 mmask = mip.group(5)
843                 if mip.group(5):
844                     addr_obj["netmask"] = cidr_to_ipv4_netmask(mip.group(5))
845                 mbcast = pbcast.match(line)
846                 if mbcast:
847                     addr_obj["broadcast"] = mbcast.group(1)
848                 data["inet"].append(addr_obj)
849             if mupdown:
850                 updown = True
851             if mip6:
852                 if "inet6" not in data:
853                     data["inet6"] = list()
854                 addr_obj = dict()
855                 addr_obj["address"] = mip6.group(1)
856                 mmask6 = mip6.group(3)
857                 addr_obj["scope"] = mip6.group(2)
858                 addr_obj["prefixlen"] = mip6.group(3)
859                 data["inet6"].append(addr_obj)
860         data["up"] = updown
861         ret[iface] = data
862         del data
863     return ret
864 def junos_interfaces():
865     """
866     Obtain interface information for Junos; ifconfig
867     output diverged from other BSD variants (Netmask is now part of the
868     address)
869     """
870     ifconfig_path = salt.utils.path.which("ifconfig")
871     cmd = subprocess.Popen(
872         [ifconfig_path, "-a"],
873         stdout=subprocess.PIPE,
874         stderr=subprocess.STDOUT,
875     ).communicate()[0]
876     return _junos_interfaces_ifconfig(salt.utils.stringutils.to_str(cmd))
877 def netbsd_interfaces():
878     """
879     Obtain interface information for NetBSD &gt;= 8 where the ifconfig
880     output diverged from other BSD variants (Netmask is now part of the
881     address)
882     """
883     if LooseVersion(os.uname()[2]) &lt; LooseVersion("8.0"):
884         return linux_interfaces()
885     ifconfig_path = salt.utils.path.which("ifconfig")
886     cmd = subprocess.Popen(
887         [ifconfig_path, "-a"],
888         stdout=subprocess.PIPE,
889         stderr=subprocess.STDOUT,
890     ).communicate()[0]
891     return _netbsd_interfaces_ifconfig(salt.utils.stringutils.to_str(cmd))
892 def _interfaces_ipconfig(out):
893     """
894     Returns a dictionary of interfaces with various information about each
895     (up/down state, ip address, netmask, and hwaddr)
896     NOTE: This is not used by any function and may be able to be removed in the
897     future.
898     """
899     ifaces = dict()
900     iface = None
901     addr = None
902     adapter_iface_regex = re.compile(r"adapter (\S.+):$")
903     for line in out.splitlines():
904         if not line:
905             continue
906         if line.startswith("Ethernet"):
907             iface = ifaces[adapter_iface_regex.search(line).group(1)]
908             iface["up"] = True
909             addr = {}
910             continue
911         if iface:
912             key, val = line.split(",", 1)
913             key = key.strip(" .")
914             val = val.strip()
915             if addr and key == "Subnet Mask":
916                 addr["netmask"] = val
917             elif key in ("IP Address", "IPv4 Address"):
918                 if "inet" not in iface:
919                     iface["inet"] = list()
920                 addr = {
921                     "address": val.rstrip("(Preferred)"),
922                     "netmask": None,
923                     "broadcast": None,
924                 }  # TODO find the broadcast
925                 iface["inet"].append(addr)
926             elif "IPv6 Address" in key:
927                 if "inet6" not in iface:
928                     iface["inet"] = list()
929                 addr = {"address": val.rstrip("(Preferred)"), "prefixlen": None}
930                 iface["inet6"].append(addr)
931             elif key == "Physical Address":
932                 iface["hwaddr"] = val
933             elif key == "Media State":
934                 iface["up"] = val != "Media disconnected"
935 def win_interfaces():
936     """
937     Obtain interface information for Windows systems
938     """
939     if WIN_NETWORK_LOADED is False:
940         import salt.utils.win_network as _
941     return salt.utils.win_network.get_interface_info()
942 def interfaces():
943     """
944     Return a dictionary of information about all the interfaces on the minion
945     """
946     if salt.utils.platform.is_windows():
947         return win_interfaces()
948     elif salt.utils.platform.is_junos():
949         return junos_interfaces()
950     elif salt.utils.platform.is_netbsd():
951         return netbsd_interfaces()
952     else:
953         return linux_interfaces()
954 def get_net_start(ipaddr, netmask):
955     """
956     Return the address of the network
957     """
958     net = ipaddress.ip_network("{}/{}".format(ipaddr, netmask), strict=False)
959     return str(net.network_address)
960 def get_net_size(mask):
961     """
962     Turns an IPv4 netmask into its corresponding prefix length
963     (255.255.255.0 -&gt; 24 as in 192.168.1.10/24).
964     """
965     binary_str = ""
966     for octet in mask.split("."):
967         binary_str += bin(int(octet))[2:].zfill(8)
968     return len(binary_str.rstrip("0"))
969 def calc_net(ipaddr, netmask=None):
970     """
971     Takes IP (CIDR notation supported) and optionally netmask
972     and returns the network in CIDR-notation.
973     (The IP can be any IP inside the subnet)
974     """
975     if netmask is not None:
976         ipaddr = "{}/{}".format(ipaddr, netmask)
977     return str(ipaddress.ip_network(ipaddr, strict=False))
978 def _ipv4_to_bits(ipaddr):
979     """
980     Accepts an IPv4 dotted quad and returns a string representing its binary
981     counterpart
982     """
983     return "".join([bin(int(x))[2:].rjust(8, "0") for x in ipaddr.split(".")])
984 def _get_iface_info(iface):
985     """
986     If `iface` is available, return interface info and no error, otherwise
987     return no info and log and return an error
988     """
989     iface_info = interfaces()
990     if iface in iface_info.keys():
991         return iface_info, False
992     else:
993         error_msg = 'Interface "{}" not in available interfaces: "{}"'.format(
994             iface, '", "'.join(iface_info.keys())
995         )
996         log.error(error_msg)
997         return None, error_msg
998 def _hw_addr_aix(iface):
999     """
1000     Return the hardware address (a.k.a. MAC address) for a given interface on AIX
1001     MAC address not available in through interfaces
1002     """
1003     cmd = subprocess.Popen(
1004         ["grep", "Hardware Address"],
1005         stdin=subprocess.Popen(
1006             ["entstat", "-d", iface],
1007             stdout=subprocess.PIPE,
1008             stderr=subprocess.STDOUT,
1009         ).stdout,
1010         stdout=subprocess.PIPE,
1011         stderr=subprocess.STDOUT,
1012     ).communicate()[0]
1013     if cmd:
1014         comps = cmd.split(" ")
1015         if len(comps) == 3:
1016             mac_addr = comps[2].strip("'").strip()
1017             return mac_addr
1018     error_msg = 'Interface "{}" either not available or does not contain a hardware address'.format(
1019         iface
1020     )
1021     log.error(error_msg)
1022     return error_msg
1023 def hw_addr(iface):
1024     """
1025     Return the hardware address (a.k.a. MAC address) for a given interface
1026     .. versionchanged:: 2016.11.4
1027         Added support for AIX
1028     """
1029     if salt.utils.platform.is_aix():
1030         return _hw_addr_aix
1031     iface_info, error = _get_iface_info(iface)
1032     if error is False:
1033         return iface_info.get(iface, {}).get("hwaddr", "")
1034     else:
1035         return error
1036 def interface(iface):
1037     """
1038     Return the details of `iface` or an error if it does not exist
1039     """
1040     iface_info, error = _get_iface_info(iface)
1041     if error is False:
1042         return iface_info.get(iface, {}).get("inet", "")
1043     else:
1044         return error
1045 def interface_ip(iface):
1046     """
1047     Return `iface` IPv4 addr or an error if `iface` does not exist
1048     """
1049     iface_info, error = _get_iface_info(iface)
1050     if error is False:
1051         inet = iface_info.get(iface, {}).get("inet", None)
1052         return inet[0].get("address", "") if inet else ""
1053     else:
1054         return error
1055 def _subnets(proto="inet", interfaces_=None):
1056     """
1057     Returns a list of subnets to which the host belongs
1058     """
1059     if interfaces_ is None:
1060         ifaces = interfaces()
1061     elif isinstance(interfaces_, list):
1062         ifaces = {}
1063         for key, value in interfaces().items():
1064             if key in interfaces_:
1065                 ifaces[key] = value
1066     else:
1067         ifaces = {interfaces_: interfaces().get(interfaces_, {})}
1068     ret = set()
1069     if proto == "inet":
1070         subnet = "netmask"
1071         dflt_cidr = 32
1072     elif proto == "inet6":
1073         subnet = "prefixlen"
1074         dflt_cidr = 128
1075     else:
1076         log.error("Invalid proto %s calling subnets()", proto)
1077         return
1078     for ip_info in ifaces.values():
1079         addrs = ip_info.get(proto, [])
1080         addrs.extend(
1081             [addr for addr in ip_info.get("secondary", []) if addr.get("type") == proto]
1082         )
1083         for intf in addrs:
1084             if subnet in intf:
1085                 intf = ipaddress.ip_interface(
1086                     "{}/{}".format(intf["address"], intf[subnet])
1087                 )
1088             else:
1089                 intf = ipaddress.ip_interface(
1090                     "{}/{}".format(intf["address"], dflt_cidr)
1091                 )
1092             if not intf.is_loopback:
1093                 ret.add(intf.network)
1094     return [str(net) for net in sorted(ret)]
1095 def subnets(interfaces=None):
1096     """
1097     Returns a list of IPv4 subnets to which the host belongs
1098     """
1099     return _subnets("inet", interfaces_=interfaces)
1100 def subnets6():
1101     """
1102     Returns a list of IPv6 subnets to which the host belongs
1103     """
1104     return _subnets("inet6")
1105 def in_subnet(cidr, addr=None):
1106     """
1107     Returns True if host or (any of) addrs is within specified subnet, otherwise False
1108     """
1109     try:
1110         cidr = ipaddress.ip_network(cidr)
1111     except ValueError:
1112         log.error("Invalid CIDR '%s'", cidr)
1113         return False
1114     if addr is None:
1115         addr = ip_addrs()
1116         addr.extend(ip_addrs6())
1117     elif not isinstance(addr, (list, tuple)):
1118         addr = (addr,)
1119     return any(ipaddress.ip_address(item) in cidr for item in addr)
1120 def _get_ips(ifaces, proto="inet"):
1121     """
1122     Accepts a dict of interface data and returns a list of dictionaries
1123     """
1124     ret = []
1125     for ip_info in ifaces.values():
1126         ret.extend(ip_info.get(proto, []))
1127         ret.extend(
1128             [addr for addr in ip_info.get("secondary", []) if addr.get("type") == proto]
1129         )
1130     return ret
1131 def _filter_interfaces(interface=None, interface_data=None):
1132     """
1133     Gather interface data if not passed in, and optionally filter by the
1134     specified interface name.
1135     """
1136     ifaces = interface_data if isinstance(interface_data, dict) else interfaces()
1137     if interface is None:
1138         ret = ifaces
1139     else:
1140         interface = salt.utils.args.split_input(interface)
1141         ret = {
1142             k: v
1143             for k, v in ifaces.items()
1144             if any(fnmatch.fnmatch(k, pat) for pat in interface)
1145         }
1146     return ret
1147 def _ip_addrs(
1148     interface=None, include_loopback=False, interface_data=None, proto="inet"
1149 ):
1150     """
1151     Return the full list of IP adresses matching the criteria
1152     proto = inet|inet6
1153     """
1154     addrs = _get_ips(_filter_interfaces(interface, interface_data), proto=proto)
1155     ret = set()
1156     for addr in addrs:
1157         addr = ipaddress.ip_address(addr.get("address"))
1158         if not addr.is_loopback or include_loopback:
1159             ret.add(addr)
1160     return [str(addr) for addr in sorted(ret)]
1161 def ip_addrs(interface=None, include_loopback=False, interface_data=None):
1162     """
1163     Returns a list of IPv4 addresses assigned to the host. 127.0.0.1 is
1164     ignored, unless 'include_loopback=True' is indicated. If 'interface' is
1165     provided, then only IP addresses from that interface will be returned.
1166     """
1167     return _ip_addrs(interface, include_loopback, interface_data, "inet")
1168 def ip_addrs6(interface=None, include_loopback=False, interface_data=None):
1169     """
1170     Returns a list of IPv6 addresses assigned to the host. ::1 is ignored,
1171     unless 'include_loopback=True' is indicated. If 'interface' is provided,
1172     then only IP addresses from that interface will be returned.
1173     """
1174     return _ip_addrs(interface, include_loopback, interface_data, "inet6")
1175 def _ip_networks(
1176     interface=None,
1177     include_loopback=False,
1178     verbose=False,
1179     interface_data=None,
1180     proto="inet",
1181 ):
1182     """
1183     Returns a list of networks to which the minion belongs. The results can be
1184     restricted to a single interface using the ``interface`` argument.
1185     """
1186     addrs = _get_ips(_filter_interfaces(interface, interface_data), proto=proto)
1187     ret = set()
1188     for addr in addrs:
1189         _ip = addr.get("address")
1190         _net = addr.get("netmask" if proto == "inet" else "prefixlen")
1191         if _ip and _net:
1192             try:
1193                 ip_net = ipaddress.ip_network("{}/{}".format(_ip, _net), strict=False)
1194             except Exception:  # pylint: disable=broad-except
1195                 continue
1196             if not ip_net.is_loopback or include_loopback:
1197                 ret.add(ip_net)
1198     if not verbose:
1199         return [str(addr) for addr in sorted(ret)]
1200     verbose_ret = {
1201         str(x): {
1202             "address": str(x.network_address),
1203             "netmask": str(x.netmask),
1204             "num_addresses": x.num_addresses,
1205             "prefixlen": x.prefixlen,
1206         }
1207         for x in ret
1208     }
1209     return verbose_ret
1210 def ip_networks(
1211     interface=None, include_loopback=False, verbose=False, interface_data=None
1212 ):
1213     """
1214     Returns the IPv4 networks to which the minion belongs. Networks will be
1215     returned as a list of network/prefixlen. To get more information about a
1216     each network, use verbose=True and a dictionary with more information will
1217     be returned.
1218     """
1219     return _ip_networks(
1220         interface=interface,
1221         include_loopback=include_loopback,
1222         verbose=verbose,
1223         interface_data=interface_data,
1224         proto="inet",
1225     )
1226 def ip_networks6(
1227     interface=None, include_loopback=False, verbose=False, interface_data=None
1228 ):
1229     """
1230     Returns the IPv6 networks to which the minion belongs. Networks will be
1231     returned as a list of network/prefixlen. To get more information about a
1232     each network, use verbose=True and a dictionary with more information will
1233     be returned.
1234     """
1235     return _ip_networks(
1236         interface=interface,
1237         include_loopback=include_loopback,
1238         verbose=verbose,
1239         interface_data=interface_data,
1240         proto="inet6",
1241     )
1242 def hex2ip(hex_ip, invert=False):
1243     """
1244     Convert a hex string to an ip, if a failure occurs the original hex is
1245     returned. If 'invert=True' assume that ip from /proc/net/&lt;proto&gt;
1246     """
1247     if len(hex_ip) == 32:  # ipv6
1248         ip_addr = []
1249         for i in range(0, 32, 8):
1250             ip_part = hex_ip[i : i + 8]
1251             ip_part = [ip_part[x : x + 2] for x in range(0, 8, 2)]
1252             if invert:
1253                 ip_addr.append("{0[3]}{0[2]}:{0[1]}{0[0]}".format(ip_part))
1254             else:
1255                 ip_addr.append("{0[0]}{0[1]}:{0[2]}{0[3]}".format(ip_part))
1256         try:
1257             address = ipaddress.IPv6Address(":".join(ip_addr))
1258             if address.ipv4_mapped:
1259                 return str(address.ipv4_mapped)
1260             else:
1261                 return address.compressed
1262         except ipaddress.AddressValueError as ex:
1263             log.error("hex2ip - ipv6 address error: %s", ex)
1264             return hex_ip
1265     try:
1266         hip = int(hex_ip, 16)
1267     except ValueError:
1268         return hex_ip
1269     if invert:
1270         return "{3}.{2}.{1}.{0}".format(
1271             hip &gt;&gt; 24 &amp; 255, hip &gt;&gt; 16 &amp; 255, hip &gt;&gt; 8 &amp; 255, hip &amp; 255
1272         )
1273     return "{}.{}.{}.{}".format(
1274         hip &gt;&gt; 24 &amp; 255, hip &gt;&gt; 16 &amp; 255, hip &gt;&gt; 8 &amp; 255, hip &amp; 255
1275     )
1276 def mac2eui64(mac, prefix=None):
1277     """
1278     Convert a MAC address to a EUI64 identifier
1279     or, with prefix provided, a full IPv6 address
1280     """
1281     eui64 = re.sub(r"[.:-]", "", mac).lower()
1282     eui64 = eui64[0:6] + "fffe" + eui64[6:]
1283     eui64 = hex(int(eui64[0:2], 16) | 2)[2:].zfill(2) + eui64[2:]
1284     if prefix is None:
1285         return ":".join(re.findall(r".{4}", eui64))
1286     else:
1287         try:
1288             net = ipaddress.ip_network(prefix, strict=False)
1289             euil = int("0x{}".format(eui64), 16)
1290             return "{}/{}".format(net[euil], net.prefixlen)
1291         except Exception:  # pylint: disable=broad-except
1292             return
1293 def active_tcp():
1294     """
1295     Return a dict describing all active tcp connections as quickly as possible
1296     """
1297     ret = {}
1298     for statf in ["/proc/net/tcp", "/proc/net/tcp6"]:
1299         if not os.path.isfile(statf):
1300             continue
1301         with salt.utils.files.fopen(statf, "rb") as fp_:
1302             for line in fp_:
1303                 line = salt.utils.stringutils.to_unicode(line)
1304                 if line.strip().startswith("sl"):
1305                     continue
1306                 iret = _parse_tcp_line(line)
1307                 slot = next(iter(iret))
1308                 if iret[slot]["state"] == 1:  # 1 is ESTABLISHED
1309                     del iret[slot]["state"]
1310                     ret[len(ret)] = iret[slot]
1311     return ret
1312 def local_port_tcp(port):
1313     """
1314     Return a set of remote ip addrs attached to the specified local port
1315     """
1316     ret = _remotes_on(port, "local_port")
1317     return ret
1318 def remote_port_tcp(port):
1319     """
1320     Return a set of ip addrs the current host is connected to on given port
1321     """
1322     ret = _remotes_on(port, "remote_port")
1323     return ret
1324 def _remotes_on(port, which_end):
1325     """
1326     Return a set of ip addrs active tcp connections
1327     """
1328     port = int(port)
1329     ret = _netlink_tool_remote_on(port, which_end)
1330     if ret is not None:
1331         return ret
1332     ret = set()
1333     proc_available = False
1334     for statf in ["/proc/net/tcp", "/proc/net/tcp6"]:
1335         if not os.path.isfile(statf):
1336             continue
1337         proc_available = True
1338         with salt.utils.files.fopen(statf, "r") as fp_:
1339             for line in fp_:
1340                 line = salt.utils.stringutils.to_unicode(line)
1341                 if line.strip().startswith("sl"):
1342                     continue
1343                 iret = _parse_tcp_line(line)
1344                 slot = next(iter(iret))
1345                 if (
1346                     iret[slot][which_end] == port and iret[slot]["state"] == 1
1347                 ):  # 1 is ESTABLISHED
1348                     ret.add(iret[slot]["remote_addr"])
1349     if not proc_available:  # Fallback to use OS specific tools
1350         if salt.utils.platform.is_sunos():
1351             return _sunos_remotes_on(port, which_end)
1352         if salt.utils.platform.is_freebsd():
1353             return _freebsd_remotes_on(port, which_end)
1354         if salt.utils.platform.is_netbsd():
1355             return _netbsd_remotes_on(port, which_end)
1356         if salt.utils.platform.is_openbsd():
1357             return _openbsd_remotes_on(port, which_end)
1358         if salt.utils.platform.is_windows():
1359             return _windows_remotes_on(port, which_end)
1360         if salt.utils.platform.is_aix():
1361             return _aix_remotes_on(port, which_end)
1362         return _linux_remotes_on(port, which_end)
1363     return ret
1364 def _parse_tcp_line(line):
1365     """
1366     Parse a single line from the contents of /proc/net/tcp or /proc/net/tcp6
1367     """
1368     ret = {}
1369     comps = line.strip().split()
1370     slot = comps[0].rstrip(":")
1371     ret[slot] = {}
1372     l_addr, l_port = comps[1].split(":")
1373     r_addr, r_port = comps[2].split(":")
1374     ret[slot]["local_addr"] = hex2ip(l_addr, True)
1375     ret[slot]["local_port"] = int(l_port, 16)
1376     ret[slot]["remote_addr"] = hex2ip(r_addr, True)
1377     ret[slot]["remote_port"] = int(r_port, 16)
1378     ret[slot]["state"] = int(comps[3], 16)
1379     return ret
1380 def _netlink_tool_remote_on(port, which_end):
1381     """
1382     Returns set of IPv4/IPv6 host addresses of remote established connections
1383     on local or remote tcp port.
1384     Parses output of shell 'ss' to get connections
1385     [root@salt-master ~]# ss -ant
1386     State      Recv-Q Send-Q               Local Address:Port                 Peer Address:Port
1387     LISTEN     0      511                              *:80                              *:*
1388     LISTEN     0      128                              *:22                              *:*
1389     ESTAB      0      0                      127.0.0.1:56726                  127.0.0.1:4505
1390     ESTAB      0      0             [::ffff:127.0.0.1]:41323         [::ffff:127.0.0.1]:4505
1391     """
1392     remotes = set()
1393     valid = False
1394     tcp_end = "dst" if which_end == "remote_port" else "src"
1395     try:
1396         data = subprocess.check_output(
1397             ["ss", "-ant", tcp_end, ":{}".format(port)]
1398         )  # pylint: disable=minimum-python-version
1399     except subprocess.CalledProcessError:
1400         log.error("Failed ss")
1401         raise
1402     except OSError:  # not command "No such file or directory"
1403         return None
1404     lines = salt.utils.stringutils.to_str(data).split("\n")
1405     for line in lines:
1406         if "Address:Port" in line:  # ss tools may not be valid
1407             valid = True
1408             continue
1409         elif "ESTAB" not in line:
1410             continue
1411         chunks = line.split()
1412         remote_host, remote_port = chunks[4].rsplit(":", 1)
1413         remotes.add(remote_host.strip("[]"))
1414     if valid is False:
1415         remotes = None
1416     return remotes
1417 def _sunos_remotes_on(port, which_end):
1418     """
1419     SunOS specific helper function.
1420     Returns set of ipv4 host addresses of remote established connections
1421     on local or remote tcp port.
1422     Parses output of shell 'netstat' to get connections
1423     [root@salt-master ~]# netstat -f inet -n
1424     TCP: IPv4
1425        Local Address        Remote Address    Swind Send-Q Rwind Recv-Q    State
1426        -------------------- -------------------- ----- ------ ----- ------ -----------
1427        10.0.0.101.4505      10.0.0.1.45329       1064800      0 1055864      0 ESTABLISHED
1428        10.0.0.101.4505      10.0.0.100.50798     1064800      0 1055864      0 ESTABLISHED
1429     """
1430     remotes = set()
1431     try:
1432         data = subprocess.check_output(
1433             ["netstat", "-f", "inet", "-n"]
1434         )  # pylint: disable=minimum-python-version
1435     except subprocess.CalledProcessError:
1436         log.error("Failed netstat")
1437         raise
1438     lines = salt.utils.stringutils.to_str(data).split("\n")
1439     for line in lines:
1440         if "ESTABLISHED" not in line:
1441             continue
1442         chunks = line.split()
1443         local_host, local_port = chunks[0].rsplit(".", 1)
1444         remote_host, remote_port = chunks[1].rsplit(".", 1)
1445         if which_end == "remote_port" and int(remote_port) != port:
1446             continue
1447         if which_end == "local_port" and int(local_port) != port:
1448             continue
1449         remotes.add(remote_host)
1450     return remotes
1451 def _freebsd_remotes_on(port, which_end):
1452     """
1453     Returns set of ipv4 host addresses of remote established connections
1454     on local tcp port port.
1455     Parses output of shell 'sockstat' (FreeBSD)
1456     to get connections
1457     $ sudo sockstat -4
1458     USER    COMMAND     PID     FD  PROTO  LOCAL ADDRESS    FOREIGN ADDRESS
1459     root    python2.7   1456    29  tcp4   *:4505           *:*
1460     root    python2.7   1445    17  tcp4   *:4506           *:*
1461     root    python2.7   1294    14  tcp4   127.0.0.1:11813  127.0.0.1:4505
1462     root    python2.7   1294    41  tcp4   127.0.0.1:61115  127.0.0.1:4506
1463     $ sudo sockstat -4 -c -p 4506
1464     USER    COMMAND     PID     FD  PROTO  LOCAL ADDRESS    FOREIGN ADDRESS
1465     root    python2.7   1294    41  tcp4   127.0.0.1:61115  127.0.0.1:4506
1466     """
1467     port = int(port)
1468     remotes = set()
1469     try:
1470         cmd = salt.utils.args.shlex_split("sockstat -4 -c -p {}".format(port))
1471         data = subprocess.check_output(cmd)  # pylint: disable=minimum-python-version
1472     except subprocess.CalledProcessError as ex:
1473         log.error('Failed "sockstat" with returncode = %s', ex.returncode)
1474         raise
1475     lines = salt.utils.stringutils.to_str(data).split("\n")
1476     for line in lines:
1477         chunks = line.split()
1478         if not chunks:
1479             continue
1480         if "COMMAND" in chunks[1]:
1481             continue  # ignore header
1482         if len(chunks) &lt; 2:
1483             continue
1484         local = chunks[-2]
1485         remote = chunks[-1]
1486         lhost, lport = local.split(":")
1487         rhost, rport = remote.split(":")
1488         if which_end == "local" and int(lport) != port:  # ignore if local port not port
1489             continue
1490         if (
1491             which_end == "remote" and int(rport) != port
1492         ):  # ignore if remote port not port
1493             continue
1494         remotes.add(rhost)
1495     return remotes
1496 def _netbsd_remotes_on(port, which_end):
1497     """
1498     Returns set of ipv4 host addresses of remote established connections
1499     on local tcp port port.
1500     Parses output of shell 'sockstat' (NetBSD)
1501     to get connections
1502     $ sudo sockstat -4 -n
1503     USER    COMMAND     PID     FD  PROTO  LOCAL ADDRESS    FOREIGN ADDRESS
1504     root    python2.7   1456    29  tcp    *.4505           *.*
1505     root    python2.7   1445    17  tcp    *.4506           *.*
1506     root    python2.7   1294    14  tcp    127.0.0.1.11813  127.0.0.1.4505
1507     root    python2.7   1294    41  tcp    127.0.0.1.61115  127.0.0.1.4506
1508     $ sudo sockstat -4 -c -n -p 4506
1509     USER    COMMAND     PID     FD  PROTO  LOCAL ADDRESS    FOREIGN ADDRESS
1510     root    python2.7   1294    41  tcp    127.0.0.1.61115  127.0.0.1.4506
1511     """
1512     port = int(port)
1513     remotes = set()
1514     try:
1515         cmd = salt.utils.args.shlex_split("sockstat -4 -c -n -p {}".format(port))
1516         data = subprocess.check_output(cmd)  # pylint: disable=minimum-python-version
1517     except subprocess.CalledProcessError as ex:
1518         log.error('Failed "sockstat" with returncode = %s', ex.returncode)
1519         raise
1520     lines = salt.utils.stringutils.to_str(data).split("\n")
1521     for line in lines:
1522         chunks = line.split()
1523         if not chunks:
1524             continue
1525         if "COMMAND" in chunks[1]:
1526             continue  # ignore header
1527         if len(chunks) &lt; 2:
1528             continue
1529         local = chunks[5].split(".")
1530         lport = local.pop()
1531         lhost = ".".join(local)
1532         remote = chunks[6].split(".")
1533         rport = remote.pop()
1534         rhost = ".".join(remote)
1535         if which_end == "local" and int(lport) != port:  # ignore if local port not port
1536             continue
1537         if (
1538             which_end == "remote" and int(rport) != port
1539         ):  # ignore if remote port not port
1540             continue
1541         remotes.add(rhost)
1542     return remotes
1543 def _openbsd_remotes_on(port, which_end):
1544     """
1545     OpenBSD specific helper function.
1546     Returns set of ipv4 host addresses of remote established connections
1547     on local or remote tcp port.
1548     Parses output of shell 'netstat' to get connections
1549     $ netstat -nf inet
1550     Active Internet connections
1551     Proto   Recv-Q Send-Q  Local Address          Foreign Address        (state)
1552     tcp          0      0  10.0.0.101.4505        10.0.0.1.45329         ESTABLISHED
1553     tcp          0      0  10.0.0.101.4505        10.0.0.100.50798       ESTABLISHED
1554     """
1555     remotes = set()
1556     try:
1557         data = subprocess.check_output(
1558             ["netstat", "-nf", "inet"]
1559         )  # pylint: disable=minimum-python-version
1560     except subprocess.CalledProcessError:
1561         log.error("Failed netstat")
1562         raise
1563     lines = data.split("\n")
1564     for line in lines:
1565         if "ESTABLISHED" not in line:
1566             continue
1567         chunks = line.split()
1568         local_host, local_port = chunks[3].rsplit(".", 1)
1569         remote_host, remote_port = chunks[4].rsplit(".", 1)
1570         if which_end == "remote_port" and int(remote_port) != port:
1571             continue
1572         if which_end == "local_port" and int(local_port) != port:
1573             continue
1574         remotes.add(remote_host)
1575     return remotes
1576 def _windows_remotes_on(port, which_end):
1577     r"""
1578     Windows specific helper function.
1579     Returns set of ipv4 host addresses of remote established connections
1580     on local or remote tcp port.
1581     Parses output of shell 'netstat' to get connections
1582     C:\&gt;netstat -n
1583     Active Connections
1584        Proto  Local Address          Foreign Address        State
1585        TCP    10.2.33.17:3007        130.164.12.233:10123   ESTABLISHED
1586        TCP    10.2.33.17:3389        130.164.30.5:10378     ESTABLISHED
1587     """
1588     remotes = set()
1589     try:
1590         data = subprocess.check_output(
1591             ["netstat", "-n"]
1592         )  # pylint: disable=minimum-python-version
1593     except subprocess.CalledProcessError:
1594         log.error("Failed netstat")
1595         raise
1596     lines = salt.utils.stringutils.to_str(data).split("\n")
1597     for line in lines:
1598         if "ESTABLISHED" not in line:
1599             continue
1600         chunks = line.split()
1601         local_host, local_port = chunks[1].rsplit(":", 1)
1602         remote_host, remote_port = chunks[2].rsplit(":", 1)
1603         if which_end == "remote_port" and int(remote_port) != port:
1604             continue
1605         if which_end == "local_port" and int(local_port) != port:
1606             continue
1607         remotes.add(remote_host)
1608     return remotes
1609 def _linux_remotes_on(port, which_end):
1610     """
1611     Linux specific helper function.
1612     Returns set of ip host addresses of remote established connections
1613     on local tcp port port.
1614     Parses output of shell 'lsof'
1615     to get connections
1616     $ sudo lsof -iTCP:4505 -n
1617     COMMAND   PID USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
1618     Python   9971 root   35u  IPv4 0x18a8464a29ca329d      0t0  TCP *:4505 (LISTEN)
1619     Python   9971 root   37u  IPv4 0x18a8464a29b2b29d      0t0  TCP 127.0.0.1:4505-&gt;127.0.0.1:55703 (ESTABLISHED)
1620     Python  10152 root   22u  IPv4 0x18a8464a29c8cab5      0t0  TCP 127.0.0.1:55703-&gt;127.0.0.1:4505 (ESTABLISHED)
1621     Python  10153 root   22u  IPv4 0x18a8464a29c8cab5      0t0  TCP [fe80::249a]:4505-&gt;[fe80::150]:59367 (ESTABLISHED)
1622     """
1623     remotes = set()
1624     try:
1625         data = subprocess.check_output(
1626             [
1627                 "lsof",
1628                 "-iTCP:{:d}".format(port),
1629                 "-n",
1630                 "-P",
1631             ]  # pylint: disable=minimum-python-version
1632         )
1633     except subprocess.CalledProcessError as ex:
1634         if ex.returncode == 1:
1635             log.warning('"lsof" returncode = 1, likely no active TCP sessions.')
1636             return remotes
1637         log.error('Failed "lsof" with returncode = %s', ex.returncode)
1638         raise
1639     lines = salt.utils.stringutils.to_str(data).split("\n")
1640     for line in lines:
1641         chunks = line.split()
1642         if not chunks:
1643             continue
1644         if "COMMAND" in chunks[0]:
1645             continue  # ignore header
1646         if "ESTABLISHED" not in chunks[-1]:
1647             continue  # ignore if not ESTABLISHED
1648         local, remote = chunks[8].split("-&gt;")
1649         _, lport = local.rsplit(":", 1)
1650         rhost, rport = remote.rsplit(":", 1)
1651         if which_end == "remote_port" and int(rport) != port:
1652             continue
1653         if which_end == "local_port" and int(lport) != port:
1654             continue
1655         remotes.add(rhost.strip("[]"))
1656     return remotes
1657 def _aix_remotes_on(port, which_end):
1658     """
1659     AIX specific helper function.
1660     Returns set of ipv4 host addresses of remote established connections
1661     on local or remote tcp port.
1662     Parses output of shell 'netstat' to get connections
1663     root@la68pp002_pub:/opt/salt/lib/python2.7/site-packages/salt/modules# netstat -f inet -n
1664     Active Internet connections
1665     Proto Recv-Q Send-Q  Local Address          Foreign Address        (state)
1666     tcp4       0      0  172.29.149.95.50093    209.41.78.13.4505      ESTABLISHED
1667     tcp4       0      0  127.0.0.1.9514         *.*                    LISTEN
1668     tcp4       0      0  127.0.0.1.9515         *.*                    LISTEN
1669     tcp4       0      0  127.0.0.1.199          127.0.0.1.32779        ESTABLISHED
1670     tcp4       0      0  127.0.0.1.32779        127.0.0.1.199          ESTABLISHED
1671     tcp4       0     40  172.29.149.95.22       172.29.96.83.41022     ESTABLISHED
1672     tcp4       0      0  172.29.149.95.22       172.29.96.83.41032     ESTABLISHED
1673     tcp4       0      0  127.0.0.1.32771        127.0.0.1.32775        ESTABLISHED
1674     tcp        0      0  127.0.0.1.32775        127.0.0.1.32771        ESTABLISHED
1675     tcp4       0      0  127.0.0.1.32771        127.0.0.1.32776        ESTABLISHED
1676     tcp        0      0  127.0.0.1.32776        127.0.0.1.32771        ESTABLISHED
1677     tcp4       0      0  127.0.0.1.32771        127.0.0.1.32777        ESTABLISHED
1678     tcp        0      0  127.0.0.1.32777        127.0.0.1.32771        ESTABLISHED
1679     tcp4       0      0  127.0.0.1.32771        127.0.0.1.32778        ESTABLISHED
1680     tcp        0      0  127.0.0.1.32778        127.0.0.1.32771        ESTABLISHED
1681     """
1682     remotes = set()
1683     try:
1684         data = subprocess.check_output(
1685             ["netstat", "-f", "inet", "-n"]
1686         )  # pylint: disable=minimum-python-version
1687     except subprocess.CalledProcessError:
1688         log.error("Failed netstat")
1689         raise
1690     lines = salt.utils.stringutils.to_str(data).split("\n")
1691     for line in lines:
1692         if "ESTABLISHED" not in line:
1693             continue
1694         chunks = line.split()
1695         local_host, local_port = chunks[3].rsplit(".", 1)
1696         remote_host, remote_port = chunks[4].rsplit(".", 1)
1697         if which_end == "remote_port" and int(remote_port) != port:
1698             continue
1699         if which_end == "local_port" and int(local_port) != port:
1700             continue
1701         remotes.add(remote_host)
1702     return remotes
1703 @jinja_filter("gen_mac")
1704 def gen_mac(prefix="AC:DE:48"):
1705     """
1706     Generates a MAC address with the defined OUI prefix.
1707     Common prefixes:
1708      - ``00:16:3E`` -- Xen
1709      - ``00:18:51`` -- OpenVZ
1710      - ``00:50:56`` -- VMware (manually generated)
1711      - ``52:54:00`` -- QEMU/KVM
1712      - ``AC:DE:48`` -- PRIVATE
1713     References:
1714      - http://standards.ieee.org/develop/regauth/oui/oui.txt
1715      - https://www.wireshark.org/tools/oui-lookup.html
1716      - https://en.wikipedia.org/wiki/MAC_address
1717     """
1718     return "{}:{:02X}:{:02X}:{:02X}".format(
1719         prefix,
1720         random.randint(0, 0xFF),
1721         random.randint(0, 0xFF),
1722         random.randint(0, 0xFF),
1723     )
1724 @jinja_filter("mac_str_to_bytes")
1725 def mac_str_to_bytes(mac_str):
1726     """
1727     Convert a MAC address string into bytes. Works with or without separators:
1728     b1 = mac_str_to_bytes('08:00:27:13:69:77')
1729     b2 = mac_str_to_bytes('080027136977')
1730     assert b1 == b2
1731     assert isinstance(b1, bytes)
1732     """
1733     if len(mac_str) == 12:
1734         pass
1735     elif len(mac_str) == 17:
1736         sep = mac_str[2]
1737         mac_str = mac_str.replace(sep, "")
1738     else:
1739         raise ValueError("Invalid MAC address")
1740     chars = (int(mac_str[s : s + 2], 16) for s in range(0, 12, 2))
1741     return bytes(chars)
1742 def refresh_dns():
1743     """
1744     issue #21397: force glibc to re-read resolv.conf
1745     """
1746     try:
1747         RES_INIT()
1748     except NameError:
1749         pass
1750 @jinja_filter("dns_check")
1751 def dns_check(addr, port, safe=False, ipv6=None):
1752     """
1753     Return an ip address resolved by dns in a format usable in URLs (ipv6 in brackets).
1754     Obeys system preference for IPv4/6 address resolution - this can be overridden by
1755     the ipv6 flag. Tries to connect to the address before considering it useful. If no
1756     address can be reached, the first one resolved is used as a fallback.
1757     Does not exit on failure, raises an exception.
1758     """
1759     ip_addrs = []
1760     family = (
1761         socket.AF_INET6
1762         if ipv6
1763         else socket.AF_INET
1764         if ipv6 is False
1765         else socket.AF_UNSPEC
1766     )
1767     socket_error = False
1768     try:
1769         refresh_dns()
1770         addrinfo = socket.getaddrinfo(addr, port, family, socket.SOCK_STREAM)
1771         ip_addrs = _test_addrs(addrinfo, port)
1772     except TypeError:
1773         raise SaltSystemExit(
1774             code=42,
1775             msg=(
1776                 "Attempt to resolve address '{}' failed. Invalid or unresolveable"
1777                 " address".format(addr)
1778             ),
1779         )
1780     except OSError:
1781         socket_error = True
1782     if socket_error and ipv6:
1783         try:
1784             refresh_dns()
1785             addrinfo = socket.getaddrinfo(
1786                 addr, port, socket.AF_INET, socket.SOCK_STREAM
1787             )
1788             ip_addrs = _test_addrs(addrinfo, port)
1789         except TypeError:
1790             raise SaltSystemExit(
1791                 code=42,
1792                 msg=(
1793                     "Attempt to resolve address '{}' failed. Invalid or unresolveable"
1794                     " address".format(addr)
1795                 ),
1796             )
1797         except OSError:
1798             error = True
1799     if not ip_addrs:
1800         err = "DNS lookup or connection check of '{}' failed.".format(addr)
1801         if safe:
1802             if salt.log.is_console_configured():
1803                 log.error(err)
1804             raise SaltClientError()
1805         raise SaltSystemExit(code=42, msg=err)
1806     return salt.utils.zeromq.ip_bracket(ip_addrs[0])
1807 def _test_addrs(addrinfo, port):
1808     """
1809     Attempt to connect to all addresses, return one if it succeeds.
1810     Otherwise, return all addrs.
1811     """
1812     ip_addrs = []
1813     for a in addrinfo:
1814         ip_family = a[0]
1815         ip_addr = a[4][0]
1816         if ip_addr in ip_addrs:
1817             continue
1818         ip_addrs.append(ip_addr)
1819         try:
1820             s = socket.socket(ip_family, socket.SOCK_STREAM)
1821             s.settimeout(2)
1822             s.connect((ip_addr, port))
1823             s.close()
1824             ip_addrs = [ip_addr]
1825             break
1826         except OSError:
1827             pass
1828     return ip_addrs
1829 def parse_host_port(host_port):
1830     """
1831     Takes a string argument specifying host or host:port.
1832     Returns a (hostname, port) or (ip_address, port) tuple. If no port is given,
1833     the second (port) element of the returned tuple will be None.
1834     host:port argument, for example, is accepted in the forms of:
1835       - hostname
1836       - hostname:1234
1837       - hostname.domain.tld
1838       - hostname.domain.tld:5678
1839       - [1234::5]:5678
1840       - 1234::5
1841       - 10.11.12.13:4567
1842       - 10.11.12.13
1843     """
1844     host, port = None, None  # default
1845     _s_ = host_port[:]
1846     if _s_[0] == "[":
1847         if "]" in host_port:
1848             host, _s_ = _s_.lstrip("[").rsplit("]", 1)
1849             host = ipaddress.IPv6Address(host).compressed
1850             if _s_[0] == ":":
1851                 port = int(_s_.lstrip(":"))
1852             else:
1853                 if len(_s_) &gt; 1:
1854                     raise ValueError(
1855                         'found ambiguous "{}" port in "{}"'.format(_s_, host_port)
1856                     )
1857     else:
1858         if _s_.count(":") == 1:
1859             host, _hostport_separator_, port = _s_.partition(":")
1860             try:
1861                 port = int(port)
1862             except ValueError as _e_:
1863                 errmsg = 'host_port "{}" port value "{}" is not an integer.'.format(
1864                     host_port, port
1865                 )
1866                 log.error(errmsg)
1867                 raise ValueError(errmsg)
1868         else:
1869             host = _s_
1870     try:
1871         if not isinstance(host, ipaddress._BaseAddress):
1872             host_ip = ipaddress.ip_address(host).compressed
1873             host = host_ip
1874     except ValueError:
1875         log.debug('"%s" Not an IP address? Assuming it is a hostname.', host)
1876         if host != sanitize_host(host):
1877             log.error('bad hostname: "%s"', host)
1878             raise ValueError('bad hostname: "{}"'.format(host))
1879     return host, port
1880 @jinja_filter("filter_by_networks")
1881 def filter_by_networks(values, networks):
1882     """
1883     Returns the list of IPs filtered by the network list.
1884     If the network list is an empty sequence, no IPs are returned.
1885     If the network list is None, all IPs are returned.
1886     {% set networks = ['192.168.0.0/24', 'fe80::/64'] %}
1887     {{ grains['ip_interfaces'] | filter_by_networks(networks) }}
1888     {{ grains['ipv6'] | filter_by_networks(networks) }}
1889     {{ grains['ipv4'] | filter_by_networks(networks) }}
1890     """
1891     _filter = lambda ips, networks: [
1892         ip for ip in ips for net in networks if ipaddress.ip_address(ip) in net
1893     ]
1894     if networks is not None:
1895         networks = [ipaddress.ip_network(network) for network in networks]
1896         if isinstance(values, Mapping):
1897             return {
1898                 interface: _filter(values[interface], networks) for interface in values
1899             }
1900         elif isinstance(values, Sequence):
1901             return _filter(values, networks)
1902         else:
1903             raise ValueError("Do not know how to filter a {}".format(type(values)))
1904     else:
1905         return values
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
