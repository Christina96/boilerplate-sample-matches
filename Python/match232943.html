<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for archive.py &amp; network_4.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for archive.py &amp; network_4.py
      </h3>
<h1 align="center">
        1.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>archive.py (1.8971848%)<th>network_4.py (0.97822654%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(7-24)<td><a href="#" name="0">(7-24)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1367-1369)<td><a href="#" name="1">(168-173)</a><td align="center"><font color="#d20000">14</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>archive.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import errno
2 import logging
3 import os
4 import re
5 import shlex
6 import stat
7 import string
8 import tarfile
9 from contextlib import closing
10 from urllib.parse import urlparse
11 import salt.utils.args
12 import salt.utils.files
13 import salt.utils.hashutils
14 import salt.utils.path
15 import salt.utils.platform
16 import salt.utils.url
17 from</b></font> salt.exceptions import CommandExecutionError, CommandNotFoundError
18 log = logging.getLogger(__name__)
19 def _path_is_abs(path):
20     if path is None:
21         return True
22     try:
23         return os.path.isabs(path)
24     except AttributeError:
25         return False
26 def _add_explanation(ret, source_hash_trigger, contents_missing):
27     if source_hash_trigger:
28         ret["comment"] += ", due to source_hash update"
29     elif contents_missing:
30         ret["comment"] += ", due to absence of one or more files/dirs"
31 def _gen_checksum(path):
32     return {
33         "hsum": salt.utils.hashutils.get_hash(path, form=__opts__["hash_type"]),
34         "hash_type": __opts__["hash_type"],
35     }
36 def _checksum_file_path(path):
37     try:
38         relpath = ".".join((os.path.relpath(path, __opts__["cachedir"]), "hash"))
39         if re.match(r"..[/\\]", relpath):
40             relpath = salt.utils.path.join(
41                 "local",
42                 os.path.splitdrive(path)[-1].lstrip("/\\"),
43             )
44     except ValueError as exc:
45         if str(exc).startswith("path is on"):
46             drive, path = os.path.splitdrive(path)
47             relpath = salt.utils.path.join(
48                 "local",
49                 drive.rstrip(":"),
50                 path.lstrip("/\\"),
51             )
52         elif str(exc).startswith("Cannot mix UNC"):
53             relpath = salt.utils.path.join("unc", path)
54         else:
55             raise
56     ret = salt.utils.path.join(__opts__["cachedir"], "archive_hash", relpath)
57     log.debug("Using checksum file %s for cached archive file %s", ret, path)
58     return ret
59 def _update_checksum(path):
60     checksum_file = _checksum_file_path(path)
61     checksum_dir = os.path.dirname(checksum_file)
62     if not os.path.isdir(checksum_dir):
63         os.makedirs(checksum_dir)
64     source_sum = _gen_checksum(path)
65     hash_type = source_sum.get("hash_type")
66     hsum = source_sum.get("hsum")
67     if hash_type and hsum:
68         lines = []
69         try:
70             try:
71                 with salt.utils.files.fopen(checksum_file, "r") as fp_:
72                     for line in fp_:
73                         try:
74                             lines.append(line.rstrip("\n").split(":", 1))
75                         except ValueError:
76                             continue
77             except OSError as exc:
78                 if exc.errno != errno.ENOENT:
79                     raise
80             with salt.utils.files.fopen(checksum_file, "w") as fp_:
81                 for line in lines:
82                     if line[0] == hash_type:
83                         line[1] = hsum
84                     fp_.write("{}:{}\n".format(*line))
85                 if hash_type not in [x[0] for x in lines]:
86                     fp_.write("{}:{}\n".format(hash_type, hsum))
87         except OSError as exc:
88             log.warning(
89                 "Failed to update checksum for %s: %s",
90                 path,
91                 exc.__str__(),
92                 exc_info=True,
93             )
94 def _read_cached_checksum(path, form=None):
95     if form is None:
96         form = __opts__["hash_type"]
97     checksum_file = _checksum_file_path(path)
98     try:
99         with salt.utils.files.fopen(checksum_file, "r") as fp_:
100             for line in fp_:
101                 hash_type, hsum = line.rstrip("\n").split(":", 1)
102                 if hash_type == form:
103                     break
104             else:
105                 return None
106     except (OSError, ValueError):
107         return None
108     else:
109         return {"hash_type": hash_type, "hsum": hsum}
110 def _compare_checksum(cached, source_sum):
111     cached_sum = _read_cached_checksum(
112         cached, form=source_sum.get("hash_type", __opts__["hash_type"])
113     )
114     return source_sum == cached_sum
115 def _is_bsdtar():
116     return "bsdtar" in __salt__["cmd.run"](["tar", "--version"], python_shell=False)
117 def _cleanup_destdir(name):
118     try:
119         os.rmdir(name)
120     except OSError:
121         pass
122 def extracted(
123     name,
124     source,
125     source_hash=None,
126     source_hash_name=None,
127     source_hash_update=False,
128     skip_files_list_verify=False,
129     skip_verify=False,
130     password=None,
131     options=None,
132     list_options=None,
133     force=False,
134     overwrite=False,
135     clean=False,
136     clean_parent=False,
137     user=None,
138     group=None,
139     if_missing=None,
140     trim_output=False,
141     use_cmd_unzip=None,
142     extract_perms=True,
143     enforce_toplevel=True,
144     enforce_ownership_on=None,
145     archive_format=None,
146     use_etag=False,
147     **kwargs
148 ):
149     ret = {"name": name, "result": False, "changes": {}, "comment": ""}
150     kwargs = salt.utils.args.clean_kwargs(**kwargs)
151     if skip_files_list_verify and skip_verify:
152         ret[
153             "comment"
154         ] = 'Only one of "skip_files_list_verify" and "skip_verify" can be set to True'
155         return ret
156     if "keep_source" in kwargs and "keep" in kwargs:
157         ret.setdefault("warnings", []).append(
158             "Both 'keep_source' and 'keep' were used. Since these both "
159             "do the same thing, 'keep' was ignored."
160         )
161         keep_source = bool(kwargs.pop("keep_source"))
162         kwargs.pop("keep")
163     elif "keep_source" in kwargs:
164         keep_source = bool(kwargs.pop("keep_source"))
165     elif "keep" in kwargs:
166         keep_source = bool(kwargs.pop("keep"))
167     else:
168         keep_source = True
169     if not _path_is_abs(name):
170         ret["comment"] = "{} is not an absolute path".format(name)
171         return ret
172     else:
173         if not name:
174             ret["comment"] = "Name of the directory path needs to be specified"
175             return ret
176         name = name.rstrip(os.sep)
177         if os.path.isfile(name):
178             ret["comment"] = "{} exists and is not a directory".format(name)
179             return ret
180         name += os.sep
181     if not _path_is_abs(if_missing):
182         ret["comment"] = "Value for 'if_missing' is not an absolute path"
183         return ret
184     if not _path_is_abs(enforce_ownership_on):
185         ret["comment"] = "Value for 'enforce_ownership_on' is not an absolute path"
186         return ret
187     else:
188         if enforce_ownership_on is not None:
189             try:
190                 not_rel = os.path.relpath(enforce_ownership_on, name).startswith(
191                     ".." + os.sep
192                 )
193             except Exception:  # pylint: disable=broad-except
194                 not_rel = True
195             if not_rel:
196                 ret[
197                     "comment"
198                 ] = "Value for 'enforce_ownership_on' must be within {}".format(name)
199                 return ret
200     if if_missing is not None and os.path.exists(if_missing):
201         ret["result"] = True
202         ret["comment"] = "Path {} exists".format(if_missing)
203         return ret
204     if user or group:
205         if salt.utils.platform.is_windows():
206             ret[
207                 "comment"
208             ] = "User/group ownership cannot be enforced on Windows minions"
209             return ret
210         if user:
211             uid = __salt__["file.user_to_uid"](user)
212             if uid == "":
213                 ret["comment"] = "User {} does not exist".format(user)
214                 return ret
215         else:
216             uid = -1
217         if group:
218             gid = __salt__["file.group_to_gid"](group)
219             if gid == "":
220                 ret["comment"] = "Group {} does not exist".format(group)
221                 return ret
222         else:
223             gid = -1
224     else:
225         uid = gid = -1
226     if source_hash_update and not source_hash:
227         ret.setdefault("warnings", []).append(
228             "The 'source_hash_update' argument is ignored when "
229             "'source_hash' is not also specified."
230         )
231     try:
232         source_match = __salt__["file.source_list"](source, source_hash, __env__)[0]
233     except CommandExecutionError as exc:
234         ret["result"] = False
235         ret["comment"] = exc.strerror
236         return ret
237     if not source_match:
238         ret["result"] = False
239         ret["comment"] = 'Invalid source "{}"'.format(source)
240         return ret
241     urlparsed_source = urlparse(source_match)
242     urlparsed_scheme = urlparsed_source.scheme
243     urlparsed_path = os.path.join(
244         urlparsed_source.netloc, urlparsed_source.path
245     ).rstrip(os.sep)
246     if urlparsed_scheme and urlparsed_scheme.lower() in string.ascii_lowercase:
247         urlparsed_path = ":".join([urlparsed_scheme, urlparsed_path])
248         urlparsed_scheme = "file"
249     source_hash_basename = urlparsed_path or urlparsed_source.netloc
250     source_is_local = urlparsed_scheme in salt.utils.files.LOCAL_PROTOS
251     if source_is_local:
252         source_match = os.path.realpath(os.path.expanduser(urlparsed_path))
253         if not os.path.isfile(source_match):
254             ret["comment"] = "Source file '{}' does not exist".format(
255                 salt.utils.url.redact_http_basic_auth(source_match)
256             )
257             return ret
258     valid_archive_formats = ("tar", "rar", "zip")
259     if not archive_format:
260         archive_format = salt.utils.files.guess_archive_type(source_hash_basename)
261         if archive_format is None:
262             ret["comment"] = (
263                 "Could not guess archive_format from the value of the "
264                 "'source' argument. Please set this archive_format to one "
265                 "of the following: {}".format(", ".join(valid_archive_formats))
266             )
267             return ret
268     try:
269         archive_format = archive_format.lower()
270     except AttributeError:
271         pass
272     if archive_format not in valid_archive_formats:
273         ret["comment"] = (
274             "Invalid archive_format '{}'. Either set it to a supported "
275             "value ({}) or remove this argument and the archive format will "
276             "be guessed based on file extension.".format(
277                 archive_format,
278                 ", ".join(valid_archive_formats),
279             )
280         )
281         return ret
282     if options is not None and not isinstance(options, str):
283         options = str(options)
284     strip_components = None
285     if options and archive_format == "tar":
286         try:
287             strip_components = int(
288                 re.search(
289                     r"""--strip(?:-components)?(?:\s+|=)["']?(\d+)["']?""", options
290                 ).group(1)
291             )
292         except (AttributeError, ValueError):
293             pass
294     if archive_format == "zip":
295         if options:
296             if use_cmd_unzip is None:
297                 log.info(
298                     "Presence of CLI options in archive.extracted state for "
299                     "'%s' implies that use_cmd_unzip is set to True.",
300                     name,
301                 )
302                 use_cmd_unzip = True
303             elif not use_cmd_unzip:
304                 ret["comment"] = (
305                     "'use_cmd_unzip' cannot be set to False if CLI options "
306                     "are being specified (via the 'options' argument). "
307                     "Either remove 'use_cmd_unzip', or set it to True."
308                 )
309                 return ret
310             if use_cmd_unzip:
311                 if "archive.cmd_unzip" not in __salt__:
312                     ret["comment"] = (
313                         "archive.cmd_unzip function not available, unzip might "
314                         "not be installed on minion"
315                     )
316                     return ret
317         if password:
318             if use_cmd_unzip is None:
319                 log.info(
320                     "Presence of a password in archive.extracted state for "
321                     "'%s' implies that use_cmd_unzip is set to False.",
322                     name,
323                 )
324                 use_cmd_unzip = False
325             elif use_cmd_unzip:
326                 ret.setdefault("warnings", []).append(
327                     "Using a password in combination with setting "
328                     "'use_cmd_unzip' to True is considered insecure. It is "
329                     "recommended to remove the 'use_cmd_unzip' argument (or "
330                     "set it to False) and allow Salt to extract the archive "
331                     "using Python's built-in ZIP file support."
332                 )
333     else:
334         if password:
335             ret[
336                 "comment"
337             ] = "The 'password' argument is only supported for zip archives"
338             return ret
339     if archive_format == "rar":
340         if "archive.unrar" not in __salt__:
341             ret["comment"] = (
342                 "archive.unrar function not available, rar/unrar might "
343                 "not be installed on minion"
344             )
345             return ret
346     supports_options = ("tar", "zip")
347     if options and archive_format not in supports_options:
348         ret["comment"] = (
349             "The 'options' argument is only compatible with the following "
350             "archive formats: {}".format(", ".join(supports_options))
351         )
352         return ret
353     if trim_output:
354         if trim_output is True:
355             trim_output = 100
356         elif not isinstance(trim_output, (bool, int)):
357             try:
358                 trim_output = int(trim_output)
359             except TypeError:
360                 ret[
361                     "comment"
362                 ] = "Invalid value for trim_output, must be True/False or an integer"
363                 return ret
364     if source_hash:
365         try:
366             source_sum = __salt__["file.get_source_sum"](
367                 source=source_match,
368                 source_hash=source_hash,
369                 source_hash_name=source_hash_name,
370                 saltenv=__env__,
371             )
372         except CommandExecutionError as exc:
373             ret["comment"] = exc.strerror
374             return ret
375     else:
376         source_sum = {}
377     if skip_files_list_verify:
378         if source_is_local:
379             cached = source_match
380         else:
381             cached = __salt__["cp.is_cached"](source_match, saltenv=__env__)
382         if cached:
383             existing_cached_source_sum = _read_cached_checksum(cached)
384             log.debug(
385                 'Existing source sum is: "%s". Expected source sum is "%s"',
386                 existing_cached_source_sum,
387                 source_sum,
388             )
389         else:
390             parsed = urlparse(source_match)
391             expected_cached_path = salt.utils.path.join(
392                 __opts__["cachedir"], "extrn_files", __env__, parsed.netloc, parsed.path
393             )
394             existing_cached_source_sum = _read_cached_checksum(expected_cached_path)
395         if source_sum and existing_cached_source_sum:
396             if existing_cached_source_sum["hsum"] == source_sum["hsum"]:
397                 ret["result"] = None if __opts__["test"] else True
398                 ret["comment"] = (
399                     "Archive {} existing source sum is the same as the "
400                     "expected one and skip_files_list_verify argument was set "
401                     "to True. Extraction is not needed".format(
402                         salt.utils.url.redact_http_basic_auth(source_match)
403                     )
404                 )
405                 return ret
406         else:
407             log.debug("There is no cached source %s available on minion", source_match)
408     if source_is_local:
409         cached = source_match
410     else:
411         if __opts__["test"]:
412             ret["result"] = None
413             ret["comment"] = (
414                 "Archive {} would be cached (if necessary) and checked to "
415                 "discover if extraction is needed".format(
416                     salt.utils.url.redact_http_basic_auth(source_match)
417                 )
418             )
419             return ret
420         if "file.cached" not in __states__:
421             ret[
422                 "comment"
423             ] = "Unable to cache {}, file.cached state not available".format(
424                 salt.utils.url.redact_http_basic_auth(source_match)
425             )
426             return ret
427         try:
428             result = __states__["file.cached"](
429                 source_match,
430                 source_hash=source_hash,
431                 source_hash_name=source_hash_name,
432                 skip_verify=skip_verify,
433                 saltenv=__env__,
434                 use_etag=use_etag,
435             )
436         except Exception as exc:  # pylint: disable=broad-except
437             msg = "Failed to cache {}: {}".format(
438                 salt.utils.url.redact_http_basic_auth(source_match), exc.__str__()
439             )
440             log.exception(msg)
441             ret["comment"] = msg
442             return ret
443         else:
444             log.debug("file.cached: %s", result)
445         if result["result"]:
446             cached = __salt__["cp.is_cached"](source_match, saltenv=__env__)
447         else:
448             log.debug(
449                 "failed to download %s",
450                 salt.utils.url.redact_http_basic_auth(source_match),
451             )
452             return result
453     existing_cached_source_sum = _read_cached_checksum(cached)
454     if source_hash and source_hash_update and not skip_verify:
455         _update_checksum(cached)
456     if archive_format == "zip" and not password:
457         log.debug("Checking %s to see if it is password-protected", source_match)
458         try:
459             encrypted_zip = __salt__["archive.is_encrypted"](
460                 cached, clean=False, saltenv=__env__, use_etag=use_etag
461             )
462         except CommandExecutionError:
463             pass
464         else:
465             if encrypted_zip:
466                 ret["comment"] = (
467                     "Archive {} is password-protected, but no password was "
468                     "specified. Please set the 'password' argument.".format(
469                         salt.utils.url.redact_http_basic_auth(source_match)
470                     )
471                 )
472                 return ret
473     try:
474         contents = __salt__["archive.list"](
475             cached,
476             archive_format=archive_format,
477             options=list_options,
478             strip_components=strip_components,
479             clean=False,
480             verbose=True,
481             use_etag=use_etag,
482         )
483     except CommandExecutionError as exc:
484         contents = None
485         errors = []
486         if not if_missing:
487             errors.append("'if_missing' must be set")
488         if not enforce_ownership_on and (user or group):
489             errors.append(
490                 "Ownership cannot be managed without setting 'enforce_ownership_on'."
491             )
492         msg = exc.strerror
493         if errors:
494             msg += "\n\n"
495             if archive_format == "tar":
496                 msg += (
497                     "If the source archive is a tar archive compressed using "
498                     "a compression type not natively supported by the tar "
499                     "command, then setting the 'list_options' argument may "
500                     "allow the contents to be listed. Otherwise, if Salt is "
501                     "unable to determine the files/directories in the "
502                     "archive, the following workaround(s) would need to be "
503                     "used for this state to proceed"
504                 )
505             else:
506                 msg += (
507                     "The following workarounds must be used for this state to proceed"
508                 )
509             msg += " (assuming the source file is a valid {} archive):\n".format(
510                 archive_format
511             )
512             for error in errors:
513                 msg += "\n- {}".format(error)
514         ret["comment"] = msg
515         return ret
516     if (
517         enforce_toplevel
518         and contents is not None
519         and (
520             len(contents["top_level_dirs"]) &gt; 1 or len(contents["top_level_files"]) &gt; 0
521         )
522     ):
523         ret["comment"] = (
524             "Archive does not have a single top-level directory. "
525             "To allow this archive to be extracted, set "
526             "'enforce_toplevel' to False. To avoid a "
527             "'{}-bomb' it may also be advisable to set a "
528             "top-level directory by adding it to the 'name' "
529             "value (for example, setting 'name' to {} "
530             "instead of {}).".format(
531                 archive_format,
532                 os.path.join(name, "some_dir"),
533                 name,
534             )
535         )
536         return ret
537     if clean and clean_parent:
538         ret["comment"] = "Only one of 'clean' and 'clean_parent' can be set to True"
539         ret["result"] = False
540         return ret
541     extraction_needed = overwrite
542     contents_missing = False
543     try:
544         if_missing_path_exists = os.path.exists(if_missing)
545     except TypeError:
546         if_missing_path_exists = False
547     if not if_missing_path_exists:
548         if contents is None:
549             try:
550                 os.lstat(if_missing)
551                 extraction_needed = False
552             except OSError as exc:
553                 if exc.errno == errno.ENOENT:
554                     extraction_needed = True
555                 else:
556                     ret["comment"] = (
557                         "Failed to check for existence of if_missing path "
558                         "({}): {}".format(if_missing, exc.__str__())
559                     )
560                     return ret
561         else:
562             incorrect_type = []
563             for path_list, func in (
564                 (contents["dirs"], stat.S_ISDIR),
565                 (
566                     contents["files"],
567                     lambda x: not stat.S_ISLNK(x) and not stat.S_ISDIR(x),
568                 ),
569                 (contents["links"], stat.S_ISLNK),
570             ):
571                 for path in path_list:
572                     full_path = salt.utils.path.join(name, path)
573                     try:
574                         path_mode = os.lstat(full_path.rstrip(os.sep)).st_mode
575                         if not func(path_mode):
576                             incorrect_type.append(path)
577                     except OSError as exc:
578                         if exc.errno == errno.ENOENT:
579                             extraction_needed = True
580                             contents_missing = True
581                         elif exc.errno != errno.ENOTDIR:
582                             ret["comment"] = exc.__str__()
583                             return ret
584             if incorrect_type:
585                 incorrect_paths = "\n\n" + "\n".join(
586                     ["- {}".format(x) for x in incorrect_type]
587                 )
588                 ret["comment"] = (
589                     "The below paths (relative to {}) exist, but are the "
590                     "incorrect type (file instead of directory, symlink "
591                     "instead of file, etc.).".format(name)
592                 )
593                 if __opts__["test"] and clean and contents is not None:
594                     ret["result"] = None
595                     ret["comment"] += (
596                         " Since the 'clean' option is enabled, the "
597                         "destination paths would be cleared and the "
598                         "archive would be extracted.{}".format(incorrect_paths)
599                     )
600                     return ret
601                 if __opts__["test"] and clean_parent and contents is not None:
602                     ret["result"] = None
603                     ret["comment"] += (
604                         " Since the 'clean_parent' option is enabled, the "
605                         "destination parent directory would be removed first "
606                         "and then re-created and the archive would be "
607                         "extracted"
608                     )
609                     return ret
610                 if not (clean and contents is not None):
611                     if not force:
612                         ret["comment"] += (
613                             " To proceed with extraction, set 'force' to "
614                             "True. Note that this will remove these paths "
615                             "before extracting.{}".format(incorrect_paths)
616                         )
617                         return ret
618                     else:
619                         errors = []
620                         for path in incorrect_type:
621                             full_path = os.path.join(name, path)
622                             try:
623                                 salt.utils.files.rm_rf(full_path.rstrip(os.sep))
624                                 ret["changes"].setdefault("removed", []).append(
625                                     full_path
626                                 )
627                                 extraction_needed = True
628                             except OSError as exc:
629                                 if exc.errno != errno.ENOENT:
630                                     errors.append(exc.__str__())
631                         if errors:
632                             msg = (
633                                 "One or more paths existed by were the incorrect "
634                                 "type (i.e. file instead of directory or "
635                                 "vice-versa), but could not be removed. The "
636                                 "following errors were observed:\n"
637                             )
638                             for error in errors:
639                                 msg += "\n- {}".format(error)
640                             ret["comment"] = msg
641                             return ret
642     if (
643         not extraction_needed
644         and source_hash_update
645         and existing_cached_source_sum is not None
646         and not _compare_checksum(cached, existing_cached_source_sum)
647     ):
648         extraction_needed = True
649         source_hash_trigger = True
650     else:
651         source_hash_trigger = False
652     created_destdir = False
653     if extraction_needed:
654         if source_is_local and source_hash and not skip_verify:
655             ret["result"] = __salt__["file.check_hash"](
656                 source_match, source_sum["hsum"]
657             )
658             if not ret["result"]:
659                 ret["comment"] = "{} does not match the desired source_hash {}".format(
660                     salt.utils.url.redact_http_basic_auth(source_match),
661                     source_sum["hsum"],
662                 )
663                 return ret
664         if __opts__["test"]:
665             ret["result"] = None
666             ret["comment"] = "Archive {} would be extracted to {}".format(
667                 salt.utils.url.redact_http_basic_auth(source_match), name
668             )
669             if clean and contents is not None:
670                 ret["comment"] += ", after cleaning destination path(s)"
671             _add_explanation(ret, source_hash_trigger, contents_missing)
672             return ret
673         if clean_parent and contents is not None:
674             errors = []
675             log.debug("Removing directory %s due to clean_parent set to True", name)
676             try:
677                 salt.utils.files.rm_rf(name.rstrip(os.sep))
678                 ret["changes"].setdefault(
679                     "removed",
680                     "Directory {} was removed prior to the extraction".format(name),
681                 )
682             except OSError as exc:
683                 if exc.errno != errno.ENOENT:
684                     errors.append(str(exc))
685             if errors:
686                 msg = (
687                     "Unable to remove the directory {}. The following "
688                     "errors were observed:\n".format(name)
689                 )
690                 for error in errors:
691                     msg += "\n- {}".format(error)
692                 ret["comment"] = msg
693                 return ret
694         if clean and contents is not None:
695             errors = []
696             log.debug("Cleaning archive paths from within %s", name)
697 <a name="1"></a>            for path in contents["top_level_dirs"] + contents["top_level_files"]:
698                 full_path = os.path.join(name, path)
699                 try:
700                     log<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.debug("Removing %s", full_path)
701                     salt.utils.files.rm_rf(full_path.rstrip(os.sep))
702                     ret["changes"].setdefault("removed", []).append(</b></font>full_path)
703                 except OSError as exc:
704                     if exc.errno != errno.ENOENT:
705                         errors.append(exc.__str__())
706             if errors:
707                 msg = (
708                     "One or more paths could not be cleaned. The following "
709                     "errors were observed:\n"
710                 )
711                 for error in errors:
712                     msg += "\n- {}".format(error)
713                 ret["comment"] = msg
714                 return ret
715         if not os.path.isdir(name):
716             __states__["file.directory"](name, user=user, makedirs=True)
717             created_destdir = True
718         log.debug("Extracting %s to %s", cached, name)
719         try:
720             if archive_format == "zip":
721                 if use_cmd_unzip:
722                     try:
723                         files = __salt__["archive.cmd_unzip"](
724                             cached,
725                             name,
726                             options=options,
727                             trim_output=trim_output,
728                             password=password,
729                             **kwargs
730                         )
731                     except (CommandExecutionError, CommandNotFoundError) as exc:
732                         ret["comment"] = exc.strerror
733                         return ret
734                 else:
735                     files = __salt__["archive.unzip"](
736                         cached,
737                         name,
738                         options=options,
739                         trim_output=trim_output,
740                         password=password,
741                         extract_perms=extract_perms,
742                         **kwargs
743                     )
744             elif archive_format == "rar":
745                 try:
746                     files = __salt__["archive.unrar"](
747                         cached, name, trim_output=trim_output, **kwargs
748                     )
749                 except (CommandExecutionError, CommandNotFoundError) as exc:
750                     ret["comment"] = exc.strerror
751                     return ret
752             else:
753                 if options is None:
754                     try:
755                         with closing(tarfile.open(cached, "r")) as tar:
756                             tar.extractall(salt.utils.stringutils.to_str(name))
757                             files = tar.getnames()
758                             if trim_output:
759                                 files = files[:trim_output]
760                     except tarfile.ReadError:
761                         if salt.utils.path.which("xz"):
762                             if (
763                                 __salt__["cmd.retcode"](
764                                     ["xz", "-t", cached],
765                                     python_shell=False,
766                                     ignore_retcode=True,
767                                 )
768                                 == 0
769                             ):
770                                 log.debug(
771                                     "Tar file is XZ-compressed, attempting "
772                                     "decompression and extraction using XZ Utils "
773                                     "and the tar command"
774                                 )
775                                 cmd = "xz --decompress --stdout {0} | tar xvf -"
776                                 results = __salt__["cmd.run_all"](
777                                     cmd.format(shlex.quote(cached)),
778                                     cwd=name,
779                                     python_shell=True,
780                                 )
781                                 if results["retcode"] != 0:
782                                     if created_destdir:
783                                         _cleanup_destdir(name)
784                                     ret["result"] = False
785                                     ret["changes"] = results
786                                     return ret
787                                 if _is_bsdtar():
788                                     files = results["stderr"]
789                                 else:
790                                     files = results["stdout"]
791                             else:
792                                 if created_destdir:
793                                     _cleanup_destdir(name)
794                                 ret["result"] = False
795                                 ret["comment"] = (
796                                     "Failed to read from tar archive using "
797                                     "Python's native tar file support. If "
798                                     "archive is compressed using something "
799                                     "other than gzip or bzip2, the "
800                                     "'options' argument may be required to "
801                                     "pass the correct options to the tar "
802                                     "command in order to extract the archive."
803                                 )
804                                 return ret
805                         else:
806                             if created_destdir:
807                                 _cleanup_destdir(name)
808                             ret["result"] = False
809                             ret["comment"] = (
810                                 "Failed to read from tar archive. If it is "
811                                 "XZ-compressed, install xz-utils to attempt "
812                                 "extraction."
813                             )
814                             return ret
815                 else:
816                     if not salt.utils.path.which("tar"):
817                         ret["comment"] = (
818                             "tar command not available, it might not be "
819                             "installed on minion"
820                         )
821                         return ret
822                     tar_opts = [
823                         x
824                         for x in shlex.split(options)
825                         if x not in ("v", "-v", "--verbose")
826                     ]
827                     tar_cmd = ["tar"]
828                     tar_shortopts = "xv"
829                     tar_longopts = []
830                     for position, opt in enumerate(tar_opts):
831                         if opt.startswith("-"):
832                             tar_longopts.append(opt)
833                         else:
834                             if position &gt; 0:
835                                 tar_longopts.append(opt)
836                             else:
837                                 append_opt = opt
838                                 append_opt = append_opt.replace("x", "")
839                                 append_opt = append_opt.replace("f", "")
840                                 tar_shortopts = tar_shortopts + append_opt
841                     if __grains__["os"].lower() == "openbsd":
842                         tar_shortopts = "-" + tar_shortopts
843                     tar_cmd.append(tar_shortopts)
844                     tar_cmd.extend(tar_longopts)
845                     tar_cmd.extend(["-f", cached])
846                     results = __salt__["cmd.run_all"](
847                         tar_cmd, cwd=name, python_shell=False
848                     )
849                     if results["retcode"] != 0:
850                         ret["result"] = False
851                         ret["changes"] = results
852                         return ret
853                     if _is_bsdtar():
854                         files = results["stderr"].splitlines()
855                         if trim_output:
856                             files = files[:trim_output]
857                     else:
858                         files = results["stdout"].splitlines()
859                         if trim_output:
860                             files = files[:trim_output]
861                     if not files:
862                         files = "no tar output so far"
863         except CommandExecutionError as exc:
864             ret["comment"] = exc.strerror
865             return ret
866     enforce_missing = []
867     enforce_failed = []
868     if user or group:
869         if enforce_ownership_on:
870             if os.path.isdir(enforce_ownership_on):
871                 enforce_dirs = [enforce_ownership_on]
872                 enforce_files = []
873                 enforce_links = []
874             else:
875                 enforce_dirs = []
876                 enforce_files = [enforce_ownership_on]
877                 enforce_links = []
878         else:
879             if contents is not None:
880                 enforce_dirs = contents["top_level_dirs"]
881                 enforce_files = contents["top_level_files"]
882                 enforce_links = contents["top_level_links"]
883         recurse = []
884         if user:
885             recurse.append("user")
886         if group:
887             recurse.append("group")
888         recurse_str = ", ".join(recurse)
889         owner_changes = {x: y for x, y in (("user", user), ("group", group)) if y}
890         for dirname in enforce_dirs:
891             full_path = os.path.join(name, dirname)
892             if not os.path.isdir(full_path):
893                 if not __opts__["test"]:
894                     enforce_missing.append(full_path)
895             else:
896                 log.debug(
897                     "Enforcing %s ownership on %s using a file.directory state%s",
898                     recurse_str,
899                     dirname,
900                     " (dry-run only)" if __opts__["test"] else "",
901                 )
902                 dir_result = __states__["file.directory"](
903                     full_path, user=user, group=group, recurse=recurse
904                 )
905                 log.debug("file.directory: %s", dir_result)
906                 if dir_result.get("changes"):
907                     ret["changes"]["updated ownership"] = True
908                 try:
909                     if not dir_result["result"]:
910                         enforce_failed.append(full_path)
911                 except (KeyError, TypeError):
912                     log.warning(
913                         "Bad state return %s for file.directory state on %s",
914                         dir_result,
915                         dirname,
916                     )
917         for filename in enforce_files + enforce_links:
918             full_path = os.path.join(name, filename)
919             try:
920                 file_stat = os.lstat(full_path)
921             except OSError as exc:
922                 if not __opts__["test"]:
923                     if exc.errno == errno.ENOENT:
924                         enforce_missing.append(full_path)
925                     enforce_failed.append(full_path)
926             else:
927                 if (uid != -1 and uid != file_stat.st_uid) or (
928                     gid != -1 and gid != file_stat.st_gid
929                 ):
930                     if __opts__["test"]:
931                         ret["changes"]["updated ownership"] = True
932                     else:
933                         try:
934                             os.lchown(full_path, uid, gid)
935                             ret["changes"]["updated ownership"] = True
936                         except OSError:
937                             enforce_failed.append(filename)
938     if extraction_needed:
939         if len(files) &gt; 0:
940             if created_destdir:
941                 ret["changes"]["directories_created"] = [name]
942             ret["changes"]["extracted_files"] = files
943             ret["comment"] = "{} extracted to {}".format(
944                 salt.utils.url.redact_http_basic_auth(source_match),
945                 name,
946             )
947             _add_explanation(ret, source_hash_trigger, contents_missing)
948             ret["comment"] += ". Output was trimmed to {} number of lines".format(
949                 trim_output
950             )
951             ret["result"] = True
952         else:
953             ret["result"] = False
954             ret["comment"] = "No files were extracted from {}".format(
955                 salt.utils.url.redact_http_basic_auth(source_match)
956             )
957     else:
958         ret["result"] = True
959         if if_missing_path_exists:
960             ret["comment"] = "{} exists".format(if_missing)
961         else:
962             ret["comment"] = "All files in archive are already present"
963         if __opts__["test"]:
964             if ret["changes"].get("updated ownership"):
965                 ret["result"] = None
966                 ret[
967                     "comment"
968                 ] += ". Ownership would be updated on one or more files/directories."
969     if enforce_missing:
970         if not if_missing:
971             ret["result"] = False
972         ret["comment"] += (
973             "\n\nWhile trying to enforce user/group ownership, the following "
974             "paths were missing:\n"
975         )
976         for item in enforce_missing:
977             ret["comment"] += "\n- {}".format(item)
978     if enforce_failed:
979         ret["result"] = False
980         ret["comment"] += (
981             "\n\nWhile trying to enforce user/group ownership, Salt was "
982             "unable to change ownership on the following paths:\n"
983         )
984         for item in enforce_failed:
985             ret["comment"] += "\n- {}".format(item)
986     if not source_is_local:
987         if keep_source:
988             log.debug("Keeping cached source file %s", cached)
989         else:
990             log.debug("Cleaning cached source file %s", cached)
991             result = __states__["file.not_cached"](source_match, saltenv=__env__)
992             if not result["result"]:
993                 ret.setdefault("warnings", []).append(result["comment"])
994     return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>network_4.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import fnmatch
2 import itertools
3 import logging
4 import os
5 import platform
6 import random
7 import re
8 import socket
9 import subprocess
10 import types
11 from collections.abc import Mapping, Sequence
12 from string import ascii_letters, digits
13 import salt.utils.args
14 import salt.utils.files
15 import salt.utils.path
16 import salt.utils.platform
17 import</b></font> salt.utils.stringutils
18 import salt.utils.zeromq
19 from salt._compat import ipaddress
20 from salt.exceptions import SaltClientError, SaltSystemExit
21 from salt.utils.decorators.jinja import jinja_filter
22 from salt.utils.versions import LooseVersion
23 try:
24     import salt.utils.win_network
25     WIN_NETWORK_LOADED = True
26 except ImportError:
27     WIN_NETWORK_LOADED = False
28 log = logging.getLogger(__name__)
29 try:
30     import ctypes
31     import ctypes.util
32     LIBC = ctypes.cdll.LoadLibrary(ctypes.util.find_library("c"))
33     RES_INIT = LIBC.__res_init
34 except (ImportError, OSError, AttributeError, TypeError):
35     pass
36 class Interfaces:
37     __slots__ = ("interfaces",)
38     def __init__(self, interfaces=None):
39         if interfaces is None:
40             interfaces = {}
41         self.interfaces = interfaces
42     def __call__(self, *args, **kwargs):
43         if not self.interfaces:
44             self.interfaces = interfaces()
45         return self.interfaces
46     def clear(self):
47         self.interfaces = {}
48 _get_interfaces = Interfaces()
49 _clear_interfaces = _get_interfaces.clear
50 def sanitize_host(host):
51     RFC952_characters = ascii_letters + digits + ".-_"
52     return "".join([c for c in host[0:255] if c in RFC952_characters])
53 def isportopen(host, port):
54     if not 1 &lt;= int(port) &lt;= 65535:
55         return False
56     sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
57     out = sock.connect_ex((sanitize_host(host), int(port)))
58     return out
59 def host_to_ips(host):
60     ips = []
61     try:
62         for family, socktype, proto, canonname, sockaddr in socket.getaddrinfo(
63             host, 0, socket.AF_UNSPEC, socket.SOCK_STREAM
64         ):
65             if family == socket.AF_INET:
66                 ip, port = sockaddr
67             elif family == socket.AF_INET6:
68                 ip, port, flow_info, scope_id = sockaddr
69             ips.append(ip)
70         if not ips:
71             ips = None
72     except Exception:  # pylint: disable=broad-except
73         ips = None
74     return ips
75 def _generate_minion_id():
76     class DistinctList(list):
77         localhost_matchers = [
78             r"localhost.*",
79             r"ip6-.*",
80             r"127[.]\d",
81             r"0\.0\.0\.0",
82             r"::1.*",
83             r"ipv6-.*",
84             r"fe00::.*",
85             r"fe02::.*",
86             r"1.0.0.*.ip6.arpa",
87         ]
88         def append(self, p_object):
89             if p_object and p_object not in self and not self.filter(p_object):
90                 super().append(p_object)
91             return self
92         def extend(self, iterable):
93             for obj in iterable:
94                 self.append(obj)
95             return self
96         def filter(self, element):
97             "Returns True if element needs to be filtered"
98             for rgx in self.localhost_matchers:
99                 if re.match(rgx, element):
100                     return True
101         def first(self):
102             return self and self[0] or None
103     hostname = socket.gethostname()
104 <a name="1"></a>
105     hosts = (
106         DistinctList()
107         <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.append(
108             salt.utils.stringutils.to_unicode(
109                 socket.getfqdn(salt.utils.stringutils.to_bytes(hostname))
110             )
111         )
112         .append(</b></font>platform.node())
113         .append(hostname)
114     )
115     if not hosts:
116         try:
117             for a_nfo in socket.getaddrinfo(
118                 hosts.first() or "localhost",
119                 None,
120                 socket.AF_INET,
121                 socket.SOCK_RAW,
122                 socket.IPPROTO_IP,
123                 socket.AI_CANONNAME,
124             ):
125                 if len(a_nfo) &gt; 3:
126                     hosts.append(a_nfo[3])
127         except socket.gaierror:
128             log.warning(
129                 "Cannot resolve address %s info via socket: %s",
130                 hosts.first() or "localhost (N/A)",
131                 socket.gaierror,
132             )
133     for f_name in (
134         "/etc/hostname",
135         "/etc/nodename",
136         "/etc/hosts",
137         r"{win}\system32\drivers\etc\hosts".format(win=os.getenv("WINDIR")),
138     ):
139         try:
140             with salt.utils.files.fopen(f_name) as f_hdl:
141                 for line in f_hdl:
142                     line = salt.utils.stringutils.to_unicode(line)
143                     hst = line.strip().split("#")[0].strip().split()
144                     if hst:
145                         if hst[0][:4] in ("127.", "::1") or len(hst) == 1:
146                             hosts.extend(hst)
147         except OSError:
148             pass
149     return hosts.extend(
150         [addr for addr in ip_addrs() if not ipaddress.ip_address(addr).is_loopback]
151     )
152 def generate_minion_id():
153     try:
154         ret = salt.utils.stringutils.to_unicode(_generate_minion_id().first())
155     except TypeError:
156         ret = None
157     return ret or "localhost"
158 def get_socket(addr, type=socket.SOCK_STREAM, proto=0):
159     version = ipaddress.ip_address(addr).version
160     if version == 4:
161         family = socket.AF_INET
162     elif version == 6:
163         family = socket.AF_INET6
164     return socket.socket(family, type, proto)
165 def get_fqhostname():
166     l = [socket.getfqdn()]
167     try:
168         addrinfo = socket.getaddrinfo(
169             socket.gethostname(),
170             0,
171             socket.AF_UNSPEC,
172             socket.SOCK_STREAM,
173             socket.SOL_TCP,
174             socket.AI_CANONNAME,
175         )
176         for info in addrinfo:
177             if len(info) &gt;= 4 and info[3]:
178                 l = [info[3]]
179     except socket.gaierror:
180         pass
181     return l and l[0] or None
182 def ip_to_host(ip):
183     try:
184         hostname, aliaslist, ipaddrlist = socket.gethostbyaddr(ip)
185     except Exception as exc:  # pylint: disable=broad-except
186         log.debug("salt.utils.network.ip_to_host(%r) failed: %s", ip, exc)
187         hostname = None
188     return hostname
189 def is_reachable_host(entity_name):
190     try:
191         assert type(socket.getaddrinfo(entity_name, 0, 0, 0, 0)) == list
192         ret = True
193     except socket.gaierror:
194         ret = False
195     return ret
196 def is_ip(ip_addr):
197     return is_ipv4(ip_addr) or is_ipv6(ip_addr)
198 def is_ipv4(ip_addr):
199     try:
200         return ipaddress.ip_address(ip_addr).version == 4
201     except ValueError:
202         return False
203 def is_ipv6(ip_addr):
204     try:
205         return ipaddress.ip_address(ip_addr).version == 6
206     except ValueError:
207         return False
208 def is_subnet(cidr):
209     return is_ipv4_subnet(cidr) or is_ipv6_subnet(cidr)
210 def is_ipv4_subnet(cidr):
211     try:
212         return "/" in cidr and bool(ipaddress.IPv4Network(cidr))
213     except Exception:  # pylint: disable=broad-except
214         return False
215 def is_ipv6_subnet(cidr):
216     try:
217         return "/" in cidr and bool(ipaddress.IPv6Network(cidr))
218     except Exception:  # pylint: disable=broad-except
219         return False
220 @jinja_filter("is_ip")
221 def is_ip_filter(ip_addr, options=None):
222     return is_ipv4_filter(ip_addr, options=options) or is_ipv6_filter(
223         ip_addr, options=options
224     )
225 def _ip_options_global(ip_obj, version):
226     return not ip_obj.is_private
227 def _ip_options_multicast(ip_obj, version):
228     return ip_obj.is_multicast
229 def _ip_options_loopback(ip_obj, version):
230     return ip_obj.is_loopback
231 def _ip_options_link_local(ip_obj, version):
232     return ip_obj.is_link_local
233 def _ip_options_private(ip_obj, version):
234     return ip_obj.is_private
235 def _ip_options_reserved(ip_obj, version):
236     return ip_obj.is_reserved
237 def _ip_options_site_local(ip_obj, version):
238     if version == 6:
239         return ip_obj.is_site_local
240     return False
241 def _ip_options_unspecified(ip_obj, version):
242     return ip_obj.is_unspecified
243 def _ip_options(ip_obj, version, options=None):
244     options_fun_map = {
245         "global": _ip_options_global,
246         "link-local": _ip_options_link_local,
247         "linklocal": _ip_options_link_local,
248         "ll": _ip_options_link_local,
249         "link_local": _ip_options_link_local,
250         "loopback": _ip_options_loopback,
251         "lo": _ip_options_loopback,
252         "multicast": _ip_options_multicast,
253         "private": _ip_options_private,
254         "public": _ip_options_global,
255         "reserved": _ip_options_reserved,
256         "site-local": _ip_options_site_local,
257         "sl": _ip_options_site_local,
258         "site_local": _ip_options_site_local,
259         "unspecified": _ip_options_unspecified,
260     }
261     if not options:
262         return str(ip_obj)  # IP version already checked
263     options_list = [option.strip() for option in options.split(",")]
264     for option, fun in options_fun_map.items():
265         if option in options_list:
266             fun_res = fun(ip_obj, version)
267             if not fun_res:
268                 return None
269     return str(ip_obj)
270 def _is_ipv(ip_addr, version, options=None):
271     if not version:
272         version = 4
273     if version not in (4, 6):
274         return None
275     try:
276         ip_obj = ipaddress.ip_address(ip_addr)
277     except ValueError:
278         try:
279             ip_obj = ipaddress.ip_interface(ip_addr)
280         except ValueError:
281             return None
282     if not ip_obj.version == version:
283         return None
284     return _ip_options(ip_obj, version, options=options)
285 @jinja_filter("is_ipv4")
286 def is_ipv4_filter(ip_addr, options=None):
287     _is_ipv4 = _is_ipv(ip_addr, 4, options=options)
288     return isinstance(_is_ipv4, str)
289 @jinja_filter("is_ipv6")
290 def is_ipv6_filter(ip_addr, options=None):
291     _is_ipv6 = _is_ipv(ip_addr, 6, options=options)
292     return isinstance(_is_ipv6, str)
293 def _ipv_filter(value, version, options=None):
294     if version not in (4, 6):
295         return
296     if isinstance(value, (str, bytes)):
297         return _is_ipv(
298             value, version, options=options
299         )  # calls is_ipv4 or is_ipv6 for `value`
300     elif isinstance(value, (list, tuple, types.GeneratorType)):
301         return [
302             _is_ipv(addr, version, options=options)
303             for addr in value
304             if _is_ipv(addr, version, options=options) is not None
305         ]
306     return None
307 @jinja_filter("ipv4")
308 def ipv4(value, options=None):
309     return _ipv_filter(value, 4, options=options)
310 @jinja_filter("ipv6")
311 def ipv6(value, options=None):
312     return _ipv_filter(value, 6, options=options)
313 @jinja_filter("ipaddr")
314 def ipaddr(value, options=None):
315     ipv4_obj = ipv4(value, options=options)
316     ipv6_obj = ipv6(value, options=options)
317     if ipv4_obj is None or ipv6_obj is None:
318         return ipv4_obj or ipv6_obj  # one of them
319     else:
320         return ipv4_obj + ipv6_obj  # extend lists
321 def _filter_ipaddr(value, options, version=None):
322     ipaddr_filter_out = None
323     if version:
324         if version == 4:
325             ipaddr_filter_out = ipv4(value, options)
326         elif version == 6:
327             ipaddr_filter_out = ipv6(value, options)
328     else:
329         ipaddr_filter_out = ipaddr(value, options)
330     if not ipaddr_filter_out:
331         return
332     if not isinstance(ipaddr_filter_out, (list, tuple, types.GeneratorType)):
333         ipaddr_filter_out = [ipaddr_filter_out]
334     return ipaddr_filter_out
335 @jinja_filter("ip_host")
336 def ip_host(value, options=None, version=None):
337     ipaddr_filter_out = _filter_ipaddr(value, options=options, version=version)
338     if not ipaddr_filter_out:
339         return
340     if not isinstance(value, (list, tuple, types.GeneratorType)):
341         return str(ipaddress.ip_interface(ipaddr_filter_out[0]))
342     return [str(ipaddress.ip_interface(ip_a)) for ip_a in ipaddr_filter_out]
343 def _network_hosts(ip_addr_entry):
344     return [
345         str(host) for host in ipaddress.ip_network(ip_addr_entry, strict=False).hosts()
346     ]
347 @jinja_filter("network_hosts")
348 def network_hosts(value, options=None, version=None):
349     ipaddr_filter_out = _filter_ipaddr(value, options=options, version=version)
350     if not ipaddr_filter_out:
351         return
352     if not isinstance(value, (list, tuple, types.GeneratorType)):
353         return _network_hosts(ipaddr_filter_out[0])
354     return [_network_hosts(ip_a) for ip_a in ipaddr_filter_out]
355 def _network_size(ip_addr_entry):
356     return ipaddress.ip_network(ip_addr_entry, strict=False).num_addresses
357 @jinja_filter("network_size")
358 def network_size(value, options=None, version=None):
359     ipaddr_filter_out = _filter_ipaddr(value, options=options, version=version)
360     if not ipaddr_filter_out:
361         return
362     if not isinstance(value, (list, tuple, types.GeneratorType)):
363         return _network_size(ipaddr_filter_out[0])
364     return [_network_size(ip_a) for ip_a in ipaddr_filter_out]
365 def natural_ipv4_netmask(ip_addr, fmt="prefixlen"):
366     bits = _ipv4_to_bits(ip_addr)
367     if bits.startswith("11"):
368         mask = "24"
369     elif bits.startswith("1"):
370         mask = "16"
371     else:
372         mask = "8"
373     if fmt == "netmask":
374         return cidr_to_ipv4_netmask(mask)
375     else:
376         return "/" + mask
377 def rpad_ipv4_network(ip_addr):
378     return ".".join(itertools.islice(itertools.chain(ip_addr.split("."), "0000"), 0, 4))
379 def cidr_to_ipv4_netmask(cidr_bits):
380     try:
381         cidr_bits = int(cidr_bits)
382         if not 1 &lt;= cidr_bits &lt;= 32:
383             return ""
384     except ValueError:
385         return ""
386     netmask = ""
387     for idx in range(4):
388         if idx:
389             netmask += "."
390         if cidr_bits &gt;= 8:
391             netmask += "255"
392             cidr_bits -= 8
393         else:
394             netmask += "{:d}".format(256 - (2 ** (8 - cidr_bits)))
395             cidr_bits = 0
396     return netmask
397 def _number_of_set_bits_to_ipv4_netmask(set_bits):
398     return cidr_to_ipv4_netmask(_number_of_set_bits(set_bits))
399 def _number_of_set_bits(x):
400     x -= (x &gt;&gt; 1) &amp; 0x55555555
401     x = ((x &gt;&gt; 2) &amp; 0x33333333) + (x &amp; 0x33333333)
402     x = ((x &gt;&gt; 4) + x) &amp; 0x0F0F0F0F
403     x += x &gt;&gt; 8
404     x += x &gt;&gt; 16
405     return x &amp; 0x0000003F
406 def _interfaces_ip(out):
407     ret = dict()
408     def parse_network(value, cols):
409         brd = None
410         scope = None
411         if "/" in value:  # we have a CIDR in this address
412             ip, cidr = value.split("/")
413         else:
414             ip = value
415             cidr = 32
416         if type_ == "inet":
417             mask = cidr_to_ipv4_netmask(int(cidr))
418             if "brd" in cols:
419                 brd = cols[cols.index("brd") + 1]
420         elif type_ == "inet6":
421             mask = cidr
422             if "scope" in cols:
423                 scope = cols[cols.index("scope") + 1]
424         return (ip, mask, brd, scope)
425     groups = re.compile("\r?\n\\d").split(out)
426     for group in groups:
427         iface = None
428         data = dict()
429         for line in group.splitlines():
430             if " " not in line:
431                 continue
432             match = re.match(r"^\d*:\s+([\w.\-]+)(?:@)?([\w.\-]+)?:\s+&lt;(.+)&gt;", line)
433             if match:
434                 iface, parent, attrs = match.groups()
435                 if "UP" in attrs.split(","):
436                     data["up"] = True
437                 else:
438                     data["up"] = False
439                 if parent:
440                     data["parent"] = parent
441                 continue
442             cols = line.split()
443             if len(cols) &gt;= 2:
444                 type_, value = tuple(cols[0:2])
445                 iflabel = cols[-1:][0]
446                 if type_ in ("inet", "inet6"):
447                     ipaddr, netmask, broadcast, scope = parse_network(value, cols)
448                     addr_obj = dict()
449                     if "secondary" not in cols:
450                         if type_ == "inet":
451                             if "inet" not in data:
452                                 data["inet"] = list()
453                             addr_obj["address"] = ipaddr
454                             addr_obj["netmask"] = netmask
455                             addr_obj["broadcast"] = broadcast
456                             addr_obj["label"] = iflabel
457                             data["inet"].append(addr_obj)
458                         elif type_ == "inet6":
459                             if "inet6" not in data:
460                                 data["inet6"] = list()
461                             addr_obj["address"] = ipaddr
462                             addr_obj["prefixlen"] = netmask
463                             addr_obj["scope"] = scope
464                             data["inet6"].append(addr_obj)
465                     else:
466                         if type_ == "inet":
467                             if "secondary" not in data:
468                                 data["secondary"] = list()
469                             addr_obj["type"] = type_
470                             addr_obj["address"] = ipaddr
471                             addr_obj["netmask"] = netmask
472                             addr_obj["broadcast"] = broadcast
473                             addr_obj["label"] = iflabel
474                             data["secondary"].append(addr_obj)
475                         elif type_ == "inet6":
476                             if "secondary" not in data:
477                                 data["secondary"] = list()
478                             addr_obj["type"] = type_
479                             addr_obj["address"] = ipaddr
480                             addr_obj["prefixlen"] = netmask
481                             addr_obj["scope"] = scope
482                             data["secondary"].append(addr_obj)
483                 elif type_.startswith("link"):
484                     data["hwaddr"] = value
485         if iface:
486             ret[iface] = data
487             del iface, data
488     return ret
489 def _interfaces_ifconfig(out):
490     ret = dict()
491     piface = re.compile(r"^([^\s:]+)")
492     pmac = re.compile(".*?(?:HWaddr|ether|address:|lladdr) ([0-9a-fA-F:]+)")
493     if salt.utils.platform.is_sunos():
494         pip = re.compile(r".*?(?:inet\s+)([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)(.*)")
495         pip6 = re.compile(".*?(?:inet6 )([0-9a-fA-F:]+)")
496         pmask6 = re.compile(r".*?(?:inet6 [0-9a-fA-F:]+/(\d+)).*")
497     else:
498         pip = re.compile(r".*?(?:inet addr:|inet [^\d]*)(.*?)\s")
499         pip6 = re.compile(".*?(?:inet6 addr: (.*?)/|inet6 )([0-9a-fA-F:]+)")
500         pmask6 = re.compile(
501             r".*?(?:inet6 addr: [0-9a-fA-F:]+/(\d+)|prefixlen (\d+))(?:"
502             r" Scope:([a-zA-Z]+)| scopeid (0x[0-9a-fA-F]))?"
503         )
504     pmask = re.compile(r".*?(?:Mask:|netmask )(?:((?:0x)?[0-9a-fA-F]{8})|([\d\.]+))")
505     pupdown = re.compile("UP")
506     pbcast = re.compile(r".*?(?:Bcast:|broadcast )([\d\.]+)")
507     groups = re.compile("\r?\n(?=\\S)").split(out)
508     for group in groups:
509         data = dict()
510         iface = ""
511         updown = False
512         for line in group.splitlines():
513             miface = piface.match(line)
514             mmac = pmac.match(line)
515             mip = pip.match(line)
516             mip6 = pip6.match(line)
517             mupdown = pupdown.search(line)
518             if miface:
519                 iface = miface.group(1)
520             if mmac:
521                 data["hwaddr"] = mmac.group(1)
522                 if salt.utils.platform.is_sunos():
523                     expand_mac = []
524                     for chunk in data["hwaddr"].split(":"):
525                         expand_mac.append(
526                             "0{}".format(chunk)
527                             if len(chunk) &lt; 2
528                             else "{}".format(chunk)
529                         )
530                     data["hwaddr"] = ":".join(expand_mac)
531             if mip:
532                 if "inet" not in data:
533                     data["inet"] = list()
534                 addr_obj = dict()
535                 addr_obj["address"] = mip.group(1)
536                 mmask = pmask.match(line)
537                 if mmask:
538                     if mmask.group(1):
539                         mmask = _number_of_set_bits_to_ipv4_netmask(
540                             int(mmask.group(1), 16)
541                         )
542                     else:
543                         mmask = mmask.group(2)
544                     addr_obj["netmask"] = mmask
545                 mbcast = pbcast.match(line)
546                 if mbcast:
547                     addr_obj["broadcast"] = mbcast.group(1)
548                 data["inet"].append(addr_obj)
549             if mupdown:
550                 updown = True
551             if mip6:
552                 if "inet6" not in data:
553                     data["inet6"] = list()
554                 addr_obj = dict()
555                 addr_obj["address"] = mip6.group(1) or mip6.group(2)
556                 mmask6 = pmask6.match(line)
557                 if mmask6:
558                     addr_obj["prefixlen"] = mmask6.group(1) or mmask6.group(2)
559                     if not salt.utils.platform.is_sunos():
560                         ipv6scope = mmask6.group(3) or mmask6.group(4)
561                         addr_obj["scope"] = (
562                             ipv6scope.lower() if ipv6scope is not None else ipv6scope
563                         )
564                 if (
565                     not salt.utils.platform.is_sunos()
566                     or addr_obj["address"] != "::"
567                     and addr_obj["prefixlen"] != 0
568                 ):
569                     data["inet6"].append(addr_obj)
570         data["up"] = updown
571         if iface in ret:
572             ret[iface] = dict(list(data.items()) + list(ret[iface].items()))
573             if "inet" in data:
574                 ret[iface]["inet"].extend(
575                     x for x in data["inet"] if x not in ret[iface]["inet"]
576                 )
577             if "inet6" in data:
578                 ret[iface]["inet6"].extend(
579                     x for x in data["inet6"] if x not in ret[iface]["inet6"]
580                 )
581         else:
582             ret[iface] = data
583         del data
584     return ret
585 def linux_interfaces():
586     ifaces = dict()
587     ip_path = salt.utils.path.which("ip")
588     ifconfig_path = None if ip_path else salt.utils.path.which("ifconfig")
589     if ip_path:
590         cmd1 = subprocess.Popen(
591             [ip_path, "link", "show"],
592             close_fds=True,
593             stdout=subprocess.PIPE,
594             stderr=subprocess.STDOUT,
595         ).communicate()[0]
596         cmd2 = subprocess.Popen(
597             [ip_path, "addr", "show"],
598             close_fds=True,
599             stdout=subprocess.PIPE,
600             stderr=subprocess.STDOUT,
601         ).communicate()[0]
602         ifaces = _interfaces_ip(
603             "{}\n{}".format(
604                 salt.utils.stringutils.to_str(cmd1), salt.utils.stringutils.to_str(cmd2)
605             )
606         )
607     elif ifconfig_path:
608         cmd = subprocess.Popen(
609             [ifconfig_path, "-a"],
610             stdout=subprocess.PIPE,
611             stderr=subprocess.STDOUT,
612         ).communicate()[0]
613         ifaces = _interfaces_ifconfig(salt.utils.stringutils.to_str(cmd))
614     return ifaces
615 def _netbsd_interfaces_ifconfig(out):
616     ret = dict()
617     piface = re.compile(r"^([^\s:]+)")
618     pmac = re.compile(".*?address: ([0-9a-f:]+)")
619     pip = re.compile(r".*?inet [^\d]*(.*?)/([\d]*)\s")
620     pip6 = re.compile(r".*?inet6 ([0-9a-f:]+)%([a-zA-Z0-9]*)/([\d]*)\s")
621     pupdown = re.compile("UP")
622     pbcast = re.compile(r".*?broadcast ([\d\.]+)")
623     groups = re.compile("\r?\n(?=\\S)").split(out)
624     for group in groups:
625         data = dict()
626         iface = ""
627         updown = False
628         for line in group.splitlines():
629             miface = piface.match(line)
630             mmac = pmac.match(line)
631             mip = pip.match(line)
632             mip6 = pip6.match(line)
633             mupdown = pupdown.search(line)
634             if miface:
635                 iface = miface.group(1)
636             if mmac:
637                 data["hwaddr"] = mmac.group(1)
638             if mip:
639                 if "inet" not in data:
640                     data["inet"] = list()
641                 addr_obj = dict()
642                 addr_obj["address"] = mip.group(1)
643                 mmask = mip.group(2)
644                 if mip.group(2):
645                     addr_obj["netmask"] = cidr_to_ipv4_netmask(mip.group(2))
646                 mbcast = pbcast.match(line)
647                 if mbcast:
648                     addr_obj["broadcast"] = mbcast.group(1)
649                 data["inet"].append(addr_obj)
650             if mupdown:
651                 updown = True
652             if mip6:
653                 if "inet6" not in data:
654                     data["inet6"] = list()
655                 addr_obj = dict()
656                 addr_obj["address"] = mip6.group(1)
657                 mmask6 = mip6.group(3)
658                 addr_obj["scope"] = mip6.group(2)
659                 addr_obj["prefixlen"] = mip6.group(3)
660                 data["inet6"].append(addr_obj)
661         data["up"] = updown
662         ret[iface] = data
663         del data
664     return ret
665 def _junos_interfaces_ifconfig(out):
666     ret = dict()
667     piface = re.compile(r"^([^\s:]+)")
668     pmac = re.compile("curr media .*? ([0-9a-f:]+)")
669     pip = re.compile(
670         r".*?inet\s*(primary)*\s+mtu"
671         r" (\d+)\s+local=[^\d]*(.*?)\s+dest=[^\d]*(.*?)\/([\d]*)\s+bcast=((?:[0-9]{1,3}\.){3}[0-9]{1,3})"
672     )
673     pip6 = re.compile(
674         r".*?inet6 mtu [^\d]+\s+local=([0-9a-f:]+)%([a-zA-Z0-9]*)/([\d]*)\s"
675     )
676     pupdown = re.compile("UP")
677     pbcast = re.compile(r".*?broadcast ([\d\.]+)")
678     groups = re.compile("\r?\n(?=\\S)").split(out)
679     for group in groups:
680         data = dict()
681         iface = ""
682         updown = False
683         primary = False
684         for line in group.splitlines():
685             miface = piface.match(line)
686             mmac = pmac.match(line)
687             mip = pip.match(line)
688             mip6 = pip6.match(line)
689             mupdown = pupdown.search(line)
690             if miface:
691                 iface = miface.group(1)
692             if mmac:
693                 data["hwaddr"] = mmac.group(1)
694             if mip:
695                 if "primary" in data:
696                     primary = True
697                 if "inet" not in data:
698                     data["inet"] = list()
699                 if mip.group(2):
700                     data["mtu"] = int(mip.group(2))
701                 addr_obj = dict()
702                 addr_obj["address"] = mip.group(3)
703                 mmask = mip.group(5)
704                 if mip.group(5):
705                     addr_obj["netmask"] = cidr_to_ipv4_netmask(mip.group(5))
706                 mbcast = pbcast.match(line)
707                 if mbcast:
708                     addr_obj["broadcast"] = mbcast.group(1)
709                 data["inet"].append(addr_obj)
710             if mupdown:
711                 updown = True
712             if mip6:
713                 if "inet6" not in data:
714                     data["inet6"] = list()
715                 addr_obj = dict()
716                 addr_obj["address"] = mip6.group(1)
717                 mmask6 = mip6.group(3)
718                 addr_obj["scope"] = mip6.group(2)
719                 addr_obj["prefixlen"] = mip6.group(3)
720                 data["inet6"].append(addr_obj)
721         data["up"] = updown
722         ret[iface] = data
723         del data
724     return ret
725 def junos_interfaces():
726     ifconfig_path = salt.utils.path.which("ifconfig")
727     cmd = subprocess.Popen(
728         [ifconfig_path, "-a"],
729         stdout=subprocess.PIPE,
730         stderr=subprocess.STDOUT,
731     ).communicate()[0]
732     return _junos_interfaces_ifconfig(salt.utils.stringutils.to_str(cmd))
733 def netbsd_interfaces():
734     if LooseVersion(os.uname()[2]) &lt; LooseVersion("8.0"):
735         return linux_interfaces()
736     ifconfig_path = salt.utils.path.which("ifconfig")
737     cmd = subprocess.Popen(
738         [ifconfig_path, "-a"],
739         stdout=subprocess.PIPE,
740         stderr=subprocess.STDOUT,
741     ).communicate()[0]
742     return _netbsd_interfaces_ifconfig(salt.utils.stringutils.to_str(cmd))
743 def _interfaces_ipconfig(out):
744     ifaces = dict()
745     iface = None
746     addr = None
747     adapter_iface_regex = re.compile(r"adapter (\S.+):$")
748     for line in out.splitlines():
749         if not line:
750             continue
751         if line.startswith("Ethernet"):
752             iface = ifaces[adapter_iface_regex.search(line).group(1)]
753             iface["up"] = True
754             addr = {}
755             continue
756         if iface:
757             key, val = line.split(",", 1)
758             key = key.strip(" .")
759             val = val.strip()
760             if addr and key == "Subnet Mask":
761                 addr["netmask"] = val
762             elif key in ("IP Address", "IPv4 Address"):
763                 if "inet" not in iface:
764                     iface["inet"] = list()
765                 addr = {
766                     "address": val.rstrip("(Preferred)"),
767                     "netmask": None,
768                     "broadcast": None,
769                 }  # TODO find the broadcast
770                 iface["inet"].append(addr)
771             elif "IPv6 Address" in key:
772                 if "inet6" not in iface:
773                     iface["inet"] = list()
774                 addr = {"address": val.rstrip("(Preferred)"), "prefixlen": None}
775                 iface["inet6"].append(addr)
776             elif key == "Physical Address":
777                 iface["hwaddr"] = val
778             elif key == "Media State":
779                 iface["up"] = val != "Media disconnected"
780 def win_interfaces():
781     if WIN_NETWORK_LOADED is False:
782         import salt.utils.win_network as _
783     return salt.utils.win_network.get_interface_info()
784 def interfaces():
785     if salt.utils.platform.is_windows():
786         return win_interfaces()
787     elif salt.utils.platform.is_junos():
788         return junos_interfaces()
789     elif salt.utils.platform.is_netbsd():
790         return netbsd_interfaces()
791     else:
792         return linux_interfaces()
793 def get_net_start(ipaddr, netmask):
794     net = ipaddress.ip_network("{}/{}".format(ipaddr, netmask), strict=False)
795     return str(net.network_address)
796 def get_net_size(mask):
797     binary_str = ""
798     for octet in mask.split("."):
799         binary_str += bin(int(octet))[2:].zfill(8)
800     return len(binary_str.rstrip("0"))
801 def calc_net(ipaddr, netmask=None):
802     if netmask is not None:
803         ipaddr = "{}/{}".format(ipaddr, netmask)
804     return str(ipaddress.ip_network(ipaddr, strict=False))
805 def _ipv4_to_bits(ipaddr):
806     return "".join([bin(int(x))[2:].rjust(8, "0") for x in ipaddr.split(".")])
807 def _get_iface_info(iface):
808     iface_info = interfaces()
809     if iface in iface_info.keys():
810         return iface_info, False
811     else:
812         error_msg = 'Interface "{}" not in available interfaces: "{}"'.format(
813             iface, '", "'.join(iface_info.keys())
814         )
815         log.error(error_msg)
816         return None, error_msg
817 def _hw_addr_aix(iface):
818     cmd = subprocess.Popen(
819         ["grep", "Hardware Address"],
820         stdin=subprocess.Popen(
821             ["entstat", "-d", iface],
822             stdout=subprocess.PIPE,
823             stderr=subprocess.STDOUT,
824         ).stdout,
825         stdout=subprocess.PIPE,
826         stderr=subprocess.STDOUT,
827     ).communicate()[0]
828     if cmd:
829         comps = cmd.split(" ")
830         if len(comps) == 3:
831             mac_addr = comps[2].strip("'").strip()
832             return mac_addr
833     error_msg = 'Interface "{}" either not available or does not contain a hardware address'.format(
834         iface
835     )
836     log.error(error_msg)
837     return error_msg
838 def hw_addr(iface):
839     if salt.utils.platform.is_aix():
840         return _hw_addr_aix
841     iface_info, error = _get_iface_info(iface)
842     if error is False:
843         return iface_info.get(iface, {}).get("hwaddr", "")
844     else:
845         return error
846 def interface(iface):
847     iface_info, error = _get_iface_info(iface)
848     if error is False:
849         return iface_info.get(iface, {}).get("inet", "")
850     else:
851         return error
852 def interface_ip(iface):
853     iface_info, error = _get_iface_info(iface)
854     if error is False:
855         inet = iface_info.get(iface, {}).get("inet", None)
856         return inet[0].get("address", "") if inet else ""
857     else:
858         return error
859 def _subnets(proto="inet", interfaces_=None):
860     if interfaces_ is None:
861         ifaces = interfaces()
862     elif isinstance(interfaces_, list):
863         ifaces = {}
864         for key, value in interfaces().items():
865             if key in interfaces_:
866                 ifaces[key] = value
867     else:
868         ifaces = {interfaces_: interfaces().get(interfaces_, {})}
869     ret = set()
870     if proto == "inet":
871         subnet = "netmask"
872         dflt_cidr = 32
873     elif proto == "inet6":
874         subnet = "prefixlen"
875         dflt_cidr = 128
876     else:
877         log.error("Invalid proto %s calling subnets()", proto)
878         return
879     for ip_info in ifaces.values():
880         addrs = ip_info.get(proto, [])
881         addrs.extend(
882             [addr for addr in ip_info.get("secondary", []) if addr.get("type") == proto]
883         )
884         for intf in addrs:
885             if subnet in intf:
886                 intf = ipaddress.ip_interface(
887                     "{}/{}".format(intf["address"], intf[subnet])
888                 )
889             else:
890                 intf = ipaddress.ip_interface(
891                     "{}/{}".format(intf["address"], dflt_cidr)
892                 )
893             if not intf.is_loopback:
894                 ret.add(intf.network)
895     return [str(net) for net in sorted(ret)]
896 def subnets(interfaces=None):
897     return _subnets("inet", interfaces_=interfaces)
898 def subnets6():
899     return _subnets("inet6")
900 def in_subnet(cidr, addr=None):
901     try:
902         cidr = ipaddress.ip_network(cidr)
903     except ValueError:
904         log.error("Invalid CIDR '%s'", cidr)
905         return False
906     if addr is None:
907         addr = ip_addrs()
908         addr.extend(ip_addrs6())
909     elif not isinstance(addr, (list, tuple)):
910         addr = (addr,)
911     return any(ipaddress.ip_address(item) in cidr for item in addr)
912 def _get_ips(ifaces, proto="inet"):
913     ret = []
914     for ip_info in ifaces.values():
915         ret.extend(ip_info.get(proto, []))
916         ret.extend(
917             [addr for addr in ip_info.get("secondary", []) if addr.get("type") == proto]
918         )
919     return ret
920 def _filter_interfaces(interface=None, interface_data=None):
921     ifaces = interface_data if isinstance(interface_data, dict) else interfaces()
922     if interface is None:
923         ret = ifaces
924     else:
925         interface = salt.utils.args.split_input(interface)
926         ret = {
927             k: v
928             for k, v in ifaces.items()
929             if any(fnmatch.fnmatch(k, pat) for pat in interface)
930         }
931     return ret
932 def _ip_addrs(
933     interface=None, include_loopback=False, interface_data=None, proto="inet"
934 ):
935     addrs = _get_ips(_filter_interfaces(interface, interface_data), proto=proto)
936     ret = set()
937     for addr in addrs:
938         addr = ipaddress.ip_address(addr.get("address"))
939         if not addr.is_loopback or include_loopback:
940             ret.add(addr)
941     return [str(addr) for addr in sorted(ret)]
942 def ip_addrs(interface=None, include_loopback=False, interface_data=None):
943     return _ip_addrs(interface, include_loopback, interface_data, "inet")
944 def ip_addrs6(interface=None, include_loopback=False, interface_data=None):
945     return _ip_addrs(interface, include_loopback, interface_data, "inet6")
946 def _ip_networks(
947     interface=None,
948     include_loopback=False,
949     verbose=False,
950     interface_data=None,
951     proto="inet",
952 ):
953     addrs = _get_ips(_filter_interfaces(interface, interface_data), proto=proto)
954     ret = set()
955     for addr in addrs:
956         _ip = addr.get("address")
957         _net = addr.get("netmask" if proto == "inet" else "prefixlen")
958         if _ip and _net:
959             try:
960                 ip_net = ipaddress.ip_network("{}/{}".format(_ip, _net), strict=False)
961             except Exception:  # pylint: disable=broad-except
962                 continue
963             if not ip_net.is_loopback or include_loopback:
964                 ret.add(ip_net)
965     if not verbose:
966         return [str(addr) for addr in sorted(ret)]
967     verbose_ret = {
968         str(x): {
969             "address": str(x.network_address),
970             "netmask": str(x.netmask),
971             "num_addresses": x.num_addresses,
972             "prefixlen": x.prefixlen,
973         }
974         for x in ret
975     }
976     return verbose_ret
977 def ip_networks(
978     interface=None, include_loopback=False, verbose=False, interface_data=None
979 ):
980     return _ip_networks(
981         interface=interface,
982         include_loopback=include_loopback,
983         verbose=verbose,
984         interface_data=interface_data,
985         proto="inet",
986     )
987 def ip_networks6(
988     interface=None, include_loopback=False, verbose=False, interface_data=None
989 ):
990     return _ip_networks(
991         interface=interface,
992         include_loopback=include_loopback,
993         verbose=verbose,
994         interface_data=interface_data,
995         proto="inet6",
996     )
997 def hex2ip(hex_ip, invert=False):
998     if len(hex_ip) == 32:  # ipv6
999         ip_addr = []
1000         for i in range(0, 32, 8):
1001             ip_part = hex_ip[i : i + 8]
1002             ip_part = [ip_part[x : x + 2] for x in range(0, 8, 2)]
1003             if invert:
1004                 ip_addr.append("{0[3]}{0[2]}:{0[1]}{0[0]}".format(ip_part))
1005             else:
1006                 ip_addr.append("{0[0]}{0[1]}:{0[2]}{0[3]}".format(ip_part))
1007         try:
1008             address = ipaddress.IPv6Address(":".join(ip_addr))
1009             if address.ipv4_mapped:
1010                 return str(address.ipv4_mapped)
1011             else:
1012                 return address.compressed
1013         except ipaddress.AddressValueError as ex:
1014             log.error("hex2ip - ipv6 address error: %s", ex)
1015             return hex_ip
1016     try:
1017         hip = int(hex_ip, 16)
1018     except ValueError:
1019         return hex_ip
1020     if invert:
1021         return "{3}.{2}.{1}.{0}".format(
1022             hip &gt;&gt; 24 &amp; 255, hip &gt;&gt; 16 &amp; 255, hip &gt;&gt; 8 &amp; 255, hip &amp; 255
1023         )
1024     return "{}.{}.{}.{}".format(
1025         hip &gt;&gt; 24 &amp; 255, hip &gt;&gt; 16 &amp; 255, hip &gt;&gt; 8 &amp; 255, hip &amp; 255
1026     )
1027 def mac2eui64(mac, prefix=None):
1028     eui64 = re.sub(r"[.:-]", "", mac).lower()
1029     eui64 = eui64[0:6] + "fffe" + eui64[6:]
1030     eui64 = hex(int(eui64[0:2], 16) | 2)[2:].zfill(2) + eui64[2:]
1031     if prefix is None:
1032         return ":".join(re.findall(r".{4}", eui64))
1033     else:
1034         try:
1035             net = ipaddress.ip_network(prefix, strict=False)
1036             euil = int("0x{}".format(eui64), 16)
1037             return "{}/{}".format(net[euil], net.prefixlen)
1038         except Exception:  # pylint: disable=broad-except
1039             return
1040 def active_tcp():
1041     ret = {}
1042     for statf in ["/proc/net/tcp", "/proc/net/tcp6"]:
1043         if not os.path.isfile(statf):
1044             continue
1045         with salt.utils.files.fopen(statf, "rb") as fp_:
1046             for line in fp_:
1047                 line = salt.utils.stringutils.to_unicode(line)
1048                 if line.strip().startswith("sl"):
1049                     continue
1050                 iret = _parse_tcp_line(line)
1051                 slot = next(iter(iret))
1052                 if iret[slot]["state"] == 1:  # 1 is ESTABLISHED
1053                     del iret[slot]["state"]
1054                     ret[len(ret)] = iret[slot]
1055     return ret
1056 def local_port_tcp(port):
1057     ret = _remotes_on(port, "local_port")
1058     return ret
1059 def remote_port_tcp(port):
1060     ret = _remotes_on(port, "remote_port")
1061     return ret
1062 def _remotes_on(port, which_end):
1063     port = int(port)
1064     ret = _netlink_tool_remote_on(port, which_end)
1065     if ret is not None:
1066         return ret
1067     ret = set()
1068     proc_available = False
1069     for statf in ["/proc/net/tcp", "/proc/net/tcp6"]:
1070         if not os.path.isfile(statf):
1071             continue
1072         proc_available = True
1073         with salt.utils.files.fopen(statf, "r") as fp_:
1074             for line in fp_:
1075                 line = salt.utils.stringutils.to_unicode(line)
1076                 if line.strip().startswith("sl"):
1077                     continue
1078                 iret = _parse_tcp_line(line)
1079                 slot = next(iter(iret))
1080                 if (
1081                     iret[slot][which_end] == port and iret[slot]["state"] == 1
1082                 ):  # 1 is ESTABLISHED
1083                     ret.add(iret[slot]["remote_addr"])
1084     if not proc_available:  # Fallback to use OS specific tools
1085         if salt.utils.platform.is_sunos():
1086             return _sunos_remotes_on(port, which_end)
1087         if salt.utils.platform.is_freebsd():
1088             return _freebsd_remotes_on(port, which_end)
1089         if salt.utils.platform.is_netbsd():
1090             return _netbsd_remotes_on(port, which_end)
1091         if salt.utils.platform.is_openbsd():
1092             return _openbsd_remotes_on(port, which_end)
1093         if salt.utils.platform.is_windows():
1094             return _windows_remotes_on(port, which_end)
1095         if salt.utils.platform.is_aix():
1096             return _aix_remotes_on(port, which_end)
1097         return _linux_remotes_on(port, which_end)
1098     return ret
1099 def _parse_tcp_line(line):
1100     ret = {}
1101     comps = line.strip().split()
1102     slot = comps[0].rstrip(":")
1103     ret[slot] = {}
1104     l_addr, l_port = comps[1].split(":")
1105     r_addr, r_port = comps[2].split(":")
1106     ret[slot]["local_addr"] = hex2ip(l_addr, True)
1107     ret[slot]["local_port"] = int(l_port, 16)
1108     ret[slot]["remote_addr"] = hex2ip(r_addr, True)
1109     ret[slot]["remote_port"] = int(r_port, 16)
1110     ret[slot]["state"] = int(comps[3], 16)
1111     return ret
1112 def _netlink_tool_remote_on(port, which_end):
1113     remotes = set()
1114     valid = False
1115     tcp_end = "dst" if which_end == "remote_port" else "src"
1116     try:
1117         data = subprocess.check_output(
1118             ["ss", "-ant", tcp_end, ":{}".format(port)]
1119         )  # pylint: disable=minimum-python-version
1120     except subprocess.CalledProcessError:
1121         log.error("Failed ss")
1122         raise
1123     except OSError:  # not command "No such file or directory"
1124         return None
1125     lines = salt.utils.stringutils.to_str(data).split("\n")
1126     for line in lines:
1127         if "Address:Port" in line:  # ss tools may not be valid
1128             valid = True
1129             continue
1130         elif "ESTAB" not in line:
1131             continue
1132         chunks = line.split()
1133         remote_host, remote_port = chunks[4].rsplit(":", 1)
1134         remotes.add(remote_host.strip("[]"))
1135     if valid is False:
1136         remotes = None
1137     return remotes
1138 def _sunos_remotes_on(port, which_end):
1139     remotes = set()
1140     try:
1141         data = subprocess.check_output(
1142             ["netstat", "-f", "inet", "-n"]
1143         )  # pylint: disable=minimum-python-version
1144     except subprocess.CalledProcessError:
1145         log.error("Failed netstat")
1146         raise
1147     lines = salt.utils.stringutils.to_str(data).split("\n")
1148     for line in lines:
1149         if "ESTABLISHED" not in line:
1150             continue
1151         chunks = line.split()
1152         local_host, local_port = chunks[0].rsplit(".", 1)
1153         remote_host, remote_port = chunks[1].rsplit(".", 1)
1154         if which_end == "remote_port" and int(remote_port) != port:
1155             continue
1156         if which_end == "local_port" and int(local_port) != port:
1157             continue
1158         remotes.add(remote_host)
1159     return remotes
1160 def _freebsd_remotes_on(port, which_end):
1161     port = int(port)
1162     remotes = set()
1163     try:
1164         cmd = salt.utils.args.shlex_split("sockstat -4 -c -p {}".format(port))
1165         data = subprocess.check_output(cmd)  # pylint: disable=minimum-python-version
1166     except subprocess.CalledProcessError as ex:
1167         log.error('Failed "sockstat" with returncode = %s', ex.returncode)
1168         raise
1169     lines = salt.utils.stringutils.to_str(data).split("\n")
1170     for line in lines:
1171         chunks = line.split()
1172         if not chunks:
1173             continue
1174         if "COMMAND" in chunks[1]:
1175             continue  # ignore header
1176         if len(chunks) &lt; 2:
1177             continue
1178         local = chunks[-2]
1179         remote = chunks[-1]
1180         lhost, lport = local.split(":")
1181         rhost, rport = remote.split(":")
1182         if which_end == "local" and int(lport) != port:  # ignore if local port not port
1183             continue
1184         if (
1185             which_end == "remote" and int(rport) != port
1186         ):  # ignore if remote port not port
1187             continue
1188         remotes.add(rhost)
1189     return remotes
1190 def _netbsd_remotes_on(port, which_end):
1191     port = int(port)
1192     remotes = set()
1193     try:
1194         cmd = salt.utils.args.shlex_split("sockstat -4 -c -n -p {}".format(port))
1195         data = subprocess.check_output(cmd)  # pylint: disable=minimum-python-version
1196     except subprocess.CalledProcessError as ex:
1197         log.error('Failed "sockstat" with returncode = %s', ex.returncode)
1198         raise
1199     lines = salt.utils.stringutils.to_str(data).split("\n")
1200     for line in lines:
1201         chunks = line.split()
1202         if not chunks:
1203             continue
1204         if "COMMAND" in chunks[1]:
1205             continue  # ignore header
1206         if len(chunks) &lt; 2:
1207             continue
1208         local = chunks[5].split(".")
1209         lport = local.pop()
1210         lhost = ".".join(local)
1211         remote = chunks[6].split(".")
1212         rport = remote.pop()
1213         rhost = ".".join(remote)
1214         if which_end == "local" and int(lport) != port:  # ignore if local port not port
1215             continue
1216         if (
1217             which_end == "remote" and int(rport) != port
1218         ):  # ignore if remote port not port
1219             continue
1220         remotes.add(rhost)
1221     return remotes
1222 def _openbsd_remotes_on(port, which_end):
1223     remotes = set()
1224     try:
1225         data = subprocess.check_output(
1226             ["netstat", "-nf", "inet"]
1227         )  # pylint: disable=minimum-python-version
1228     except subprocess.CalledProcessError:
1229         log.error("Failed netstat")
1230         raise
1231     lines = data.split("\n")
1232     for line in lines:
1233         if "ESTABLISHED" not in line:
1234             continue
1235         chunks = line.split()
1236         local_host, local_port = chunks[3].rsplit(".", 1)
1237         remote_host, remote_port = chunks[4].rsplit(".", 1)
1238         if which_end == "remote_port" and int(remote_port) != port:
1239             continue
1240         if which_end == "local_port" and int(local_port) != port:
1241             continue
1242         remotes.add(remote_host)
1243     return remotes
1244 def _windows_remotes_on(port, which_end):
1245     r"""
1246     Windows specific helper function.
1247     Returns set of ipv4 host addresses of remote established connections
1248     on local or remote tcp port.
1249     Parses output of shell 'netstat' to get connections
1250     C:\&gt;netstat -n
1251     Active Connections
1252        Proto  Local Address          Foreign Address        State
1253        TCP    10.2.33.17:3007        130.164.12.233:10123   ESTABLISHED
1254        TCP    10.2.33.17:3389        130.164.30.5:10378     ESTABLISHED
1255     Linux specific helper function.
1256     Returns set of ip host addresses of remote established connections
1257     on local tcp port port.
1258     Parses output of shell 'lsof'
1259     to get connections
1260     $ sudo lsof -iTCP:4505 -n
1261     COMMAND   PID USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
1262     Python   9971 root   35u  IPv4 0x18a8464a29ca329d      0t0  TCP *:4505 (LISTEN)
1263     Python   9971 root   37u  IPv4 0x18a8464a29b2b29d      0t0  TCP 127.0.0.1:4505-&gt;127.0.0.1:55703 (ESTABLISHED)
1264     Python  10152 root   22u  IPv4 0x18a8464a29c8cab5      0t0  TCP 127.0.0.1:55703-&gt;127.0.0.1:4505 (ESTABLISHED)
1265     Python  10153 root   22u  IPv4 0x18a8464a29c8cab5      0t0  TCP [fe80::249a]:4505-&gt;[fe80::150]:59367 (ESTABLISHED)
1266     """
1267     remotes = set()
1268     try:
1269         data = subprocess.check_output(
1270             [
1271                 "lsof",
1272                 "-iTCP:{:d}".format(port),
1273                 "-n",
1274                 "-P",
1275             ]  # pylint: disable=minimum-python-version
1276         )
1277     except subprocess.CalledProcessError as ex:
1278         if ex.returncode == 1:
1279             log.warning('"lsof" returncode = 1, likely no active TCP sessions.')
1280             return remotes
1281         log.error('Failed "lsof" with returncode = %s', ex.returncode)
1282         raise
1283     lines = salt.utils.stringutils.to_str(data).split("\n")
1284     for line in lines:
1285         chunks = line.split()
1286         if not chunks:
1287             continue
1288         if "COMMAND" in chunks[0]:
1289             continue  # ignore header
1290         if "ESTABLISHED" not in chunks[-1]:
1291             continue  # ignore if not ESTABLISHED
1292         local, remote = chunks[8].split("-&gt;")
1293         _, lport = local.rsplit(":", 1)
1294         rhost, rport = remote.rsplit(":", 1)
1295         if which_end == "remote_port" and int(rport) != port:
1296             continue
1297         if which_end == "local_port" and int(lport) != port:
1298             continue
1299         remotes.add(rhost.strip("[]"))
1300     return remotes
1301 def _aix_remotes_on(port, which_end):
1302     remotes = set()
1303     try:
1304         data = subprocess.check_output(
1305             ["netstat", "-f", "inet", "-n"]
1306         )  # pylint: disable=minimum-python-version
1307     except subprocess.CalledProcessError:
1308         log.error("Failed netstat")
1309         raise
1310     lines = salt.utils.stringutils.to_str(data).split("\n")
1311     for line in lines:
1312         if "ESTABLISHED" not in line:
1313             continue
1314         chunks = line.split()
1315         local_host, local_port = chunks[3].rsplit(".", 1)
1316         remote_host, remote_port = chunks[4].rsplit(".", 1)
1317         if which_end == "remote_port" and int(remote_port) != port:
1318             continue
1319         if which_end == "local_port" and int(local_port) != port:
1320             continue
1321         remotes.add(remote_host)
1322     return remotes
1323 @jinja_filter("gen_mac")
1324 def gen_mac(prefix="AC:DE:48"):
1325     return "{}:{:02X}:{:02X}:{:02X}".format(
1326         prefix,
1327         random.randint(0, 0xFF),
1328         random.randint(0, 0xFF),
1329         random.randint(0, 0xFF),
1330     )
1331 @jinja_filter("mac_str_to_bytes")
1332 def mac_str_to_bytes(mac_str):
1333     if len(mac_str) == 12:
1334         pass
1335     elif len(mac_str) == 17:
1336         sep = mac_str[2]
1337         mac_str = mac_str.replace(sep, "")
1338     else:
1339         raise ValueError("Invalid MAC address")
1340     chars = (int(mac_str[s : s + 2], 16) for s in range(0, 12, 2))
1341     return bytes(chars)
1342 def refresh_dns():
1343     try:
1344         RES_INIT()
1345     except NameError:
1346         pass
1347 @jinja_filter("dns_check")
1348 def dns_check(addr, port, safe=False, ipv6=None):
1349     ip_addrs = []
1350     family = (
1351         socket.AF_INET6
1352         if ipv6
1353         else socket.AF_INET
1354         if ipv6 is False
1355         else socket.AF_UNSPEC
1356     )
1357     socket_error = False
1358     try:
1359         refresh_dns()
1360         addrinfo = socket.getaddrinfo(addr, port, family, socket.SOCK_STREAM)
1361         ip_addrs = _test_addrs(addrinfo, port)
1362     except TypeError:
1363         raise SaltSystemExit(
1364             code=42,
1365             msg=(
1366                 "Attempt to resolve address '{}' failed. Invalid or unresolveable"
1367                 " address".format(addr)
1368             ),
1369         )
1370     except OSError:
1371         socket_error = True
1372     if socket_error and ipv6:
1373         try:
1374             refresh_dns()
1375             addrinfo = socket.getaddrinfo(
1376                 addr, port, socket.AF_INET, socket.SOCK_STREAM
1377             )
1378             ip_addrs = _test_addrs(addrinfo, port)
1379         except TypeError:
1380             raise SaltSystemExit(
1381                 code=42,
1382                 msg=(
1383                     "Attempt to resolve address '{}' failed. Invalid or unresolveable"
1384                     " address".format(addr)
1385                 ),
1386             )
1387         except OSError:
1388             error = True
1389     if not ip_addrs:
1390         err = "DNS lookup or connection check of '{}' failed.".format(addr)
1391         if safe:
1392             if salt.log.is_console_configured():
1393                 log.error(err)
1394             raise SaltClientError()
1395         raise SaltSystemExit(code=42, msg=err)
1396     return salt.utils.zeromq.ip_bracket(ip_addrs[0])
1397 def _test_addrs(addrinfo, port):
1398     ip_addrs = []
1399     for a in addrinfo:
1400         ip_family = a[0]
1401         ip_addr = a[4][0]
1402         if ip_addr in ip_addrs:
1403             continue
1404         ip_addrs.append(ip_addr)
1405         try:
1406             s = socket.socket(ip_family, socket.SOCK_STREAM)
1407             s.settimeout(2)
1408             s.connect((ip_addr, port))
1409             s.close()
1410             ip_addrs = [ip_addr]
1411             break
1412         except OSError:
1413             pass
1414     return ip_addrs
1415 def parse_host_port(host_port):
1416     host, port = None, None  # default
1417     _s_ = host_port[:]
1418     if _s_[0] == "[":
1419         if "]" in host_port:
1420             host, _s_ = _s_.lstrip("[").rsplit("]", 1)
1421             host = ipaddress.IPv6Address(host).compressed
1422             if _s_[0] == ":":
1423                 port = int(_s_.lstrip(":"))
1424             else:
1425                 if len(_s_) &gt; 1:
1426                     raise ValueError(
1427                         'found ambiguous "{}" port in "{}"'.format(_s_, host_port)
1428                     )
1429     else:
1430         if _s_.count(":") == 1:
1431             host, _hostport_separator_, port = _s_.partition(":")
1432             try:
1433                 port = int(port)
1434             except ValueError as _e_:
1435                 errmsg = 'host_port "{}" port value "{}" is not an integer.'.format(
1436                     host_port, port
1437                 )
1438                 log.error(errmsg)
1439                 raise ValueError(errmsg)
1440         else:
1441             host = _s_
1442     try:
1443         if not isinstance(host, ipaddress._BaseAddress):
1444             host_ip = ipaddress.ip_address(host).compressed
1445             host = host_ip
1446     except ValueError:
1447         log.debug('"%s" Not an IP address? Assuming it is a hostname.', host)
1448         if host != sanitize_host(host):
1449             log.error('bad hostname: "%s"', host)
1450             raise ValueError('bad hostname: "{}"'.format(host))
1451     return host, port
1452 @jinja_filter("filter_by_networks")
1453 def filter_by_networks(values, networks):
1454     _filter = lambda ips, networks: [
1455         ip for ip in ips for net in networks if ipaddress.ip_address(ip) in net
1456     ]
1457     if networks is not None:
1458         networks = [ipaddress.ip_network(network) for network in networks]
1459         if isinstance(values, Mapping):
1460             return {
1461                 interface: _filter(values[interface], networks) for interface in values
1462             }
1463         elif isinstance(values, Sequence):
1464             return _filter(values, networks)
1465         else:
1466             raise ValueError("Do not know how to filter a {}".format(type(values)))
1467     else:
1468         return values
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
