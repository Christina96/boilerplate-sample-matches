<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for win_system_1.py &amp; zypperpkg.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for win_system_1.py &amp; zypperpkg.py
      </h3>
<h1 align="center">
        2.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>win_system_1.py (4.569055%)<th>zypperpkg.py (1.5167184%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(801-839)<td><a href="#" name="0">(1415-1429)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1235-1287)<td><a href="#" name="1">(2194-2253)</a><td align="center"><font color="#c60000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(611-616)<td><a href="#" name="2">(124-132)</a><td align="center"><font color="#aa0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>win_system_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import ctypes
import logging
import platform
import time
from datetime import datetime
import salt.utils.functools
import salt.utils.locales
import salt.utils.platform
import salt.utils.win_system
import salt.utils.winapi
from salt.exceptions import CommandExecutionError
try:
    import pywintypes
    import win32api
    import win32con
    import win32net
    import wmi
    from ctypes import windll
    HAS_WIN32NET_MODS = True
except ImportError:
    HAS_WIN32NET_MODS = False
log = logging.getLogger(__name__)
__virtualname__ = "system"
def __virtual__():
    if not salt.utils.platform.is_windows():
        return False, "Module win_system: Requires Windows"
    if not HAS_WIN32NET_MODS:
        return False, "Module win_system: Missing win32 modules"
    return __virtualname__
def _convert_minutes_seconds(timeout, in_seconds=False):
    return timeout if in_seconds else timeout * 60
def _convert_date_time_string(dt_string):
    dt_string = dt_string.split(".")[0]
    dt_obj = datetime.strptime(dt_string, "%Y%m%d%H%M%S")
    return dt_obj.strftime("%Y-%m-%d %H:%M:%S")
def halt(timeout=5, in_seconds=False):
    return shutdown(timeout=timeout, in_seconds=in_seconds)
def init(runlevel):  # pylint: disable=unused-argument
    return "Not implemented on Windows at this time."
def poweroff(timeout=5, in_seconds=False):
    return shutdown(timeout=timeout, in_seconds=in_seconds)
def reboot(
    timeout=5,
    in_seconds=False,
    wait_for_reboot=False,  # pylint: disable=redefined-outer-name
    only_on_pending_reboot=False,
):
    ret = shutdown(
        timeout=timeout,
        reboot=True,
        in_seconds=in_seconds,
        only_on_pending_reboot=only_on_pending_reboot,
    )
    if wait_for_reboot:
        seconds = _convert_minutes_seconds(timeout, in_seconds)
        time.sleep(seconds + 30)
    return ret
def shutdown(
    message=None,
    timeout=5,
    force_close=True,
    reboot=False,  # pylint: disable=redefined-outer-name
    in_seconds=False,
    only_on_pending_reboot=False,
):
    timeout = _convert_minutes_seconds(timeout, in_seconds)
    if only_on_pending_reboot and not get_pending_reboot():
        return False
    if message and not isinstance(message, str):
        message = message.decode("utf-8")
    try:
        win32api.InitiateSystemShutdown(
            "127.0.0.1", message, timeout, force_close, reboot
        )
        return True
    except pywintypes.error as exc:
        (number, context, message) = exc.args
        log.error("Failed to shutdown the system")
        log.error("nbr: %s", number)
        log.error("ctx: %s", context)
        log.error("msg: %s", message)
        return False
def shutdown_hard():
    return shutdown(timeout=0)
def shutdown_abort():
    try:
        win32api.AbortSystemShutdown("127.0.0.1")
        return True
    except pywintypes.error as exc:
        (number, context, message) = exc.args
        log.error("Failed to abort system shutdown")
        log.error("nbr: %s", number)
        log.error("ctx: %s", context)
        log.error("msg: %s", message)
        return False
def lock():
    return windll.user32.LockWorkStation()
def set_computer_name(name):
    if windll.kernel32.SetComputerNameExW(
        win32con.ComputerNamePhysicalDnsHostname, name
    ):
        ret = {"Computer Name": {"Current": get_computer_name()}}
        pending = get_pending_computer_name()
        if pending not in (None, False):
            ret["Computer Name"]["Pending"] = pending
        return ret
    return False
def get_pending_computer_name():
    return salt.utils.win_system.get_pending_computer_name()
def get_computer_name():
    return salt.utils.win_system.get_computer_name()
def set_computer_desc(desc=None):
    system_info = win32net.NetServerGetInfo(None, 101)
    if desc is None:
        return False
    system_info["comment"] = desc
    try:
        win32net.NetServerSetInfo(None, 101, system_info)
    except win32net.error as exc:
        (number, context, message) = exc.args
        log.error("Failed to update system")
        log.error("nbr: %s", number)
        log.error("ctx: %s", context)
        log.error("msg: %s", message)
        return False
    return {"Computer Description": get_computer_desc()}
set_computer_description = salt.utils.functools.alias_function(
    set_computer_desc, "set_computer_description"
)
def get_system_info():
    def byte_calc(val):
        val = float(val)
        if val &lt; 2 ** 10:
            return "{:.3f}B".format(val)
        elif val &lt; 2 ** 20:
            return "{:.3f}KB".format(val / 2 ** 10)
        elif val &lt; 2 ** 30:
            return "{:.3f}MB".format(val / 2 ** 20)
        elif val &lt; 2 ** 40:
            return "{:.3f}GB".format(val / 2 ** 30)
        else:
            return "{:.3f}TB".format(val / 2 ** 40)
    os_type = {1: "Work Station", 2: "Domain Controller", 3: "Server"}
    domain_role = {
        0: "Standalone Workstation",
        1: "Member Workstation",
        2: "Standalone Server",
        3: "Member Server",
        4: "Backup Domain Controller",
        5: "Primary Domain Controller",
    }
    warning_states = {
        1: "Other",
        2: "Unknown",
        3: "Safe",
        4: "Warning",
        5: "Critical",
        6: "Non-recoverable",
    }
    pc_system_types = {
        0: "Unspecified",
        1: "Desktop",
        2: "Mobile",
        3: "Workstation",
        4: "Enterprise Server",
        5: "SOHO Server",
        6: "Appliance PC",
        7: "Performance Server",
        8: "Maximum",
    }
    with salt.utils.winapi.Com():
        conn = wmi.WMI()
        system = conn.Win32_OperatingSystem()[0]
        ret = {
            "name": get_computer_name(),
            "description": system.Description,
            "install_date": system.InstallDate,
            "last_boot": system.LastBootUpTime,
            "os_manufacturer": system.Manufacturer,
            "os_name": system.Caption,
            "users": system.NumberOfUsers,
            "organization": system.Organization,
            "os_architecture": system.OSArchitecture,
            "primary": system.Primary,
            "os_type": os_type[system.ProductType],
            "registered_user": system.RegisteredUser,
            "system_directory": system.SystemDirectory,
            "system_drive": system.SystemDrive,
            "os_version": system.Version,
            "windows_directory": system.WindowsDirectory,
        }
        product = conn.Win32_ComputerSystemProduct()[0]
        ret.update({"chassis_sku_number": product.SKUNumber})
        system = conn.Win32_ComputerSystem()[0]
        if platform.release() in ["Vista", "7", "8"]:
            pc_system_type = pc_system_types[system.PCSystemType]
        else:
            pc_system_types.update({8: "Slate", 9: "Maximum"})
            pc_system_type = pc_system_types[system.PCSystemType]
        ret.update(
            {
                "bootup_state": system.BootupState,
                "caption": system.Caption,
                "chassis_bootup_state": warning_states[system.ChassisBootupState],
                "dns_hostname": system.DNSHostname,
                "domain": system.Domain,
                "domain_role": domain_role[system.DomainRole],
                "hardware_manufacturer": system.Manufacturer,
                "hardware_model": system.Model,
                "network_server_mode_enabled": system.NetworkServerModeEnabled,
                "part_of_domain": system.PartOfDomain,
                "pc_system_type": pc_system_type,
                "power_state": system.PowerState,
                "status": system.Status,
                "system_type": system.SystemType,
                "total_physical_memory": byte_calc(system.TotalPhysicalMemory),
                "total_physical_memory_raw": system.TotalPhysicalMemory,
                "thermal_state": warning_states[system.ThermalState],
                "workgroup": system.Workgroup,
<a name="2"></a>            }
        )
        processors = conn.Win32_Processor<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>()
        ret["processors"] = 0
        ret["processors_logical"] = 0
        ret["processor_cores"] = 0
        ret["processor_cores_enabled"] = 0
        ret["processor_manufacturer"] = processors[</b></font>0].Manufacturer
        ret["processor_max_clock_speed"] = str(processors[0].MaxClockSpeed) + "MHz"
        for processor in processors:
            ret["processors"] += 1
            ret["processors_logical"] += processor.NumberOfLogicalProcessors
            ret["processor_cores"] += processor.NumberOfCores
            try:
                ret["processor_cores_enabled"] += processor.NumberOfEnabledCore
            except (AttributeError, TypeError):
                pass
        if ret["processor_cores_enabled"] == 0:
            ret.pop("processor_cores_enabled", False)
        bios = conn.Win32_BIOS()[0]
        ret.update(
            {
                "hardware_serial": bios.SerialNumber,
                "bios_manufacturer": bios.Manufacturer,
                "bios_version": bios.Version,
                "bios_details": bios.BIOSVersion,
                "bios_caption": bios.Caption,
                "bios_description": bios.Description,
            }
        )
        ret["install_date"] = _convert_date_time_string(ret["install_date"])
        ret["last_boot"] = _convert_date_time_string(ret["last_boot"])
    return ret
def get_computer_desc():
    desc = get_system_info()["description"]
    return False if desc is None else desc
get_computer_description = salt.utils.functools.alias_function(
    get_computer_desc, "get_computer_description"
)
def get_hostname():
    cmd = "hostname"
    ret = __salt__["cmd.run"](cmd=cmd)
    return ret
def set_hostname(hostname):
    with salt.utils.winapi.Com():
        conn = wmi.WMI()
        comp = conn.Win32_ComputerSystem()[0]
        return comp.Rename(Name=hostname)
def join_domain(
    domain,
    username=None,
    password=None,
    account_ou=None,
    account_exists=False,
    restart=False,
):
    status = get_domain_workgroup()
    if "Domain" in status:
        if status["Domain"] == domain:
            return "Already joined to {}".format(domain)
    if username and "\\" not in username and "@" not in username:
        username = "{}@{}".format(username, domain)
    if username and password is None:
        return "Must specify a password if you pass a username"
    if isinstance(account_ou, str):
        account_ou = account_ou.split("\\")
        account_ou = "".join(account_ou)
    err = _join_domain(
        domain=domain,
        username=username,
        password=password,
        account_ou=account_ou,
        account_exists=account_exists,
    )
    if not err:
        ret = {"Domain": domain, "Restart": False}
        if restart:
<a name="0"></a>            ret["Restart"] = reboot()
        return ret
    raise CommandExecutionError<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(win32api.FormatMessage(err).rstrip())
def _join_domain(
    domain, username=None, password=None, account_ou=None, account_exists=False
):
    NETSETUP_JOIN_DOMAIN = 0x1  # pylint: disable=invalid-name
    NETSETUP_ACCOUNT_CREATE = 0x2  # pylint: disable=invalid-name
    NETSETUP_DOMAIN_JOIN_IF_JOINED = 0x20  # pylint: disable=invalid-name
    NETSETUP_JOIN_WITH_NEW_NAME = 0x400  # pylint: disable=invalid-name
    join_options = 0x0
    join_options |= NETSETUP_JOIN_DOMAIN
    join_options |=</b></font> NETSETUP_DOMAIN_JOIN_IF_JOINED
    join_options |= NETSETUP_JOIN_WITH_NEW_NAME
    if not account_exists:
        join_options |= NETSETUP_ACCOUNT_CREATE
    with salt.utils.winapi.Com():
        conn = wmi.WMI()
        comp = conn.Win32_ComputerSystem()[0]
        return comp.JoinDomainOrWorkgroup(
            Name=domain,
            Password=password,
            UserName=username,
            AccountOU=account_ou,
            FJoinOptions=join_options,
        )[0]
def unjoin_domain(
    username=None,
    password=None,
    domain=None,
    workgroup="WORKGROUP",
    disable=False,
    restart=False,
):
    status = get_domain_workgroup()
    if "Workgroup" in status:
        if status["Workgroup"] == workgroup:
            return "Already joined to {}".format(workgroup)
    if username and "\\" not in username and "@" not in username:
        if domain:
            username = "{}@{}".format(username, domain)
        else:
            return "Must specify domain if not supplied in username"
    if username and password is None:
        return "Must specify a password if you pass a username"
    NETSETUP_ACCT_DELETE = 0x4  # pylint: disable=invalid-name
    unjoin_options = 0x0
    if disable:
        unjoin_options |= NETSETUP_ACCT_DELETE
    with salt.utils.winapi.Com():
        conn = wmi.WMI()
        comp = conn.Win32_ComputerSystem()[0]
        err = comp.UnjoinDomainOrWorkgroup(
            Password=password, UserName=username, FUnjoinOptions=unjoin_options
        )
        if not err[0]:
            err = comp.JoinDomainOrWorkgroup(Name=workgroup)
            if not err[0]:
                ret = {"Workgroup": workgroup, "Restart": False}
                if restart:
                    ret["Restart"] = reboot()
                return ret
            else:
                log.error(win32api.FormatMessage(err[0]).rstrip())
                log.error("Failed to unjoin the computer from %s", workgroup)
                return False
        else:
            log.error(win32api.FormatMessage(err[0]).rstrip())
            log.error("Failed to unjoin computer from %s", status["Domain"])
            return False
def get_domain_workgroup():
    with salt.utils.winapi.Com():
        conn = wmi.WMI()
        for computer in conn.Win32_ComputerSystem():
            if computer.PartOfDomain:
                return {"Domain": computer.Domain}
            else:
                return {"Workgroup": computer.Domain}
def set_domain_workgroup(workgroup):
    with salt.utils.winapi.Com():
        conn = wmi.WMI()
        comp = conn.Win32_ComputerSystem()[0]
        res = comp.JoinDomainOrWorkgroup(Name=workgroup.upper())
    return True if not res[0] else False
def _try_parse_datetime(time_str, fmts):
    result = None
    for fmt in fmts:
        try:
            result = datetime.strptime(time_str, fmt)
            break
        except ValueError:
            pass
    return result
def get_system_time():
    now = win32api.GetLocalTime()
    meridian = "AM"
    hours = int(now[4])
    if hours == 12:
        meridian = "PM"
    elif hours == 0:
        hours = 12
    elif hours &gt; 12:
        hours = hours - 12
        meridian = "PM"
    return "{:02d}:{:02d}:{:02d} {}".format(hours, now[5], now[6], meridian)
def set_system_time(newtime):
    fmts = ["%I:%M:%S %p", "%I:%M %p", "%H:%M:%S", "%H:%M"]
    dt_obj = _try_parse_datetime(newtime, fmts)
    if dt_obj is None:
        return False
    return set_system_date_time(
        hours=dt_obj.hour, minutes=dt_obj.minute, seconds=dt_obj.second
    )
def set_system_date_time(
    years=None, months=None, days=None, hours=None, minutes=None, seconds=None
):
    try:
        date_time = win32api.GetLocalTime()
    except win32api.error as exc:
        (number, context, message) = exc.args
        log.error("Failed to get local time")
        log.error("nbr: %s", number)
        log.error("ctx: %s", context)
        log.error("msg: %s", message)
        return False
    if years is None:
        years = date_time[0]
    if months is None:
        months = date_time[1]
    if days is None:
        days = date_time[3]
    if hours is None:
        hours = date_time[4]
    if minutes is None:
        minutes = date_time[5]
    if seconds is None:
        seconds = date_time[6]
    try:
        class SYSTEMTIME(ctypes.Structure):
            _fields_ = [
                ("wYear", ctypes.c_int16),
                ("wMonth", ctypes.c_int16),
                ("wDayOfWeek", ctypes.c_int16),
                ("wDay", ctypes.c_int16),
                ("wHour", ctypes.c_int16),
                ("wMinute", ctypes.c_int16),
                ("wSecond", ctypes.c_int16),
                ("wMilliseconds", ctypes.c_int16),
            ]
        system_time = SYSTEMTIME()
        system_time.wYear = int(years)
        system_time.wMonth = int(months)
        system_time.wDay = int(days)
        system_time.wHour = int(hours)
        system_time.wMinute = int(minutes)
        system_time.wSecond = int(seconds)
        system_time_ptr = ctypes.pointer(system_time)
        succeeded = ctypes.windll.kernel32.SetLocalTime(system_time_ptr)
        if succeeded != 0:
            return True
        else:
            log.error("Failed to set local time")
            raise CommandExecutionError(win32api.FormatMessage(succeeded).rstrip())
    except OSError as err:
        log.error("Failed to set local time")
        raise CommandExecutionError(err)
def get_system_date():
    now = win32api.GetLocalTime()
    return "{:02d}/{:02d}/{:04d}".format(now[1], now[3], now[0])
def set_system_date(newdate):
    fmts = ["%Y-%m-%d", "%m-%d-%Y", "%m-%d-%y", "%m/%d/%Y", "%m/%d/%y", "%Y/%m/%d"]
    dt_obj = _try_parse_datetime(newdate, fmts)
    if dt_obj is None:
<a name="1"></a>        return False
    return set_system_date_time(years=dt_obj.year, months=dt_obj.month, days=dt_obj.<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>day)
def start_time_service():
    return __salt__["service.start"]("w32time")
def stop_time_service():
    return __salt__["service.stop"]("w32time")
def get_pending_component_servicing():
    return salt.</b></font>utils.win_system.get_pending_component_servicing()
def get_pending_domain_join():
    return salt.utils.win_system.get_pending_domain_join()
def get_pending_file_rename():
    return salt.utils.win_system.get_pending_file_rename()
def get_pending_servermanager():
    return salt.utils.win_system.get_pending_servermanager()
def get_pending_update():
    return salt.utils.win_system.get_pending_update()
def set_reboot_required_witnessed():
    r"""
    This function is used to remember that an event indicating that a reboot is
    required was witnessed. This function relies on the salt-minion's ability to
    create the following volatile registry key in the *HKLM* hive:
       *SYSTEM\\CurrentControlSet\\Services\\salt-minion\\Volatile-Data*
    Because this registry key is volatile, it will not persist beyond the
    current boot session. Also, in the scope of this key, the name *'Reboot
    required'* will be assigned the value of *1*.
    For the time being, this function is being used whenever an install
    completes with exit code 3010 and can be extended where appropriate in the
    future.
    .. versionadded:: 2016.11.0
    Returns:
        bool: ``True`` if successful, otherwise ``False``
    CLI Example:
    .. code-block:: bash
        salt '*' system.set_reboot_required_witnessed
    Determine if at any time during the current boot session the salt minion
    witnessed an event indicating that a reboot is required.
    This function will return ``True`` if an install completed with exit
    code 3010 during the current boot session and can be extended where
    appropriate in the future.
    .. versionadded:: 2016.11.0
    Returns:
        bool: ``True`` if the ``Requires reboot`` registry flag is set to ``1``,
        otherwise ``False``
    CLI Example:
    .. code-block:: bash
        salt '*' system.get_reboot_required_witnessed
    Determine whether there is a reboot pending.
    .. versionadded:: 2016.11.0
    Returns:
        bool: ``True`` if the system is pending reboot, otherwise ``False``
    CLI Example:
    .. code-block:: bash
        salt '*' system.get_pending_reboot
    Determine which check is signalling that the system is pending a reboot.
    Useful in determining why your system is signalling that it needs a reboot.
    .. versionadded:: 3001
    Returns:
        dict: A dictionary of the results of each system that would indicate a
        pending reboot
    CLI Example:
    .. code-block:: bash
        salt '*' system.get_pending_reboot_details
    Check the Windows Update system for a pending reboot state.
    This leverages the Windows Update System to determine if the system is
    pending a reboot.
    .. versionadded:: 3001
    Returns:
        bool: ``True`` if the Windows Update system reports a pending update,
        otherwise ``False``
    CLI Example:
    .. code-block:: bash
        salt '*' system.get_pending_windows_update
Package support for openSUSE via the zypper package manager
:depends: - ``rpm`` Python module.  Install with ``zypper install rpm-python``
.. important::
    If you feel that Salt should be using this module to manage packages on a
    minion, and it is using a different module (or gives an error similar to
    *'pkg.install' is not available*), see :ref:`here
    &lt;module-provider-override&gt;`.
"""
import configparser
import datetime
import fnmatch
import logging
import os
import re
import time
import urllib.parse
from xml.dom import minidom as dom
from xml.parsers.expat import ExpatError
import salt.utils.data
import salt.utils.environment
import salt.utils.event
import salt.utils.files
import salt.utils.functools
import salt.utils.path
import salt.utils.pkg
import salt.utils.pkg.rpm
import salt.utils.stringutils
import salt.utils.systemd
import salt.utils.versions
from salt.exceptions import CommandExecutionError, MinionError, SaltInvocationError
from salt.utils.versions import LooseVersion
log = logging.getLogger(__name__)
HAS_ZYPP = False
ZYPP_HOME = "/etc/zypp"
LOCKS = "{}/locks".format(ZYPP_HOME)
REPOS = "{}/repos.d".format(ZYPP_HOME)
DEFAULT_PRIORITY = 99
PKG_ARCH_SEPARATOR = "."
__virtualname__ = "pkg"
def __virtual__():
    if __grains__.get("os_family", "") != "Suse":
        return (
            False,
            "Module zypper: non SUSE OS not supported by zypper package manager",
        )
    if not salt.utils.path.which("zypper"):
        return (False, "Module zypper: zypper package manager not found")
    return __virtualname__
class _Zypper:
    SUCCESS_EXIT_CODES = {
        0: "Successful run of zypper with no special info.",
        100: "Patches are available for installation.",
        101: "Security patches are available for installation.",
        102: "Installation successful, reboot required.",
        103: "Installation successful, restart of the package manager itself required.",
    }
    WARNING_EXIT_CODES = {
        6: "No repositories are defined.",
        7: "The ZYPP library is locked.",
        106: (
            "Some repository had to be disabled temporarily because it failed to"
            " refresh. You should check your repository configuration (e.g. zypper ref"
            " -f)."
        ),
        107: (
            "Installation basically succeeded, but some of the packages %post install"
            " scripts returned an error. These packages were successfully unpacked to"
            " disk and are registered in the rpm database, but due to the failed"
            " install script they may not work as expected. The failed scripts output"
            " might reveal what actually went wrong. Any scripts output is also logged"
            " to /var/log/zypp/history."
        ),
    }
    LOCK_EXIT_CODE = 7
    XML_DIRECTIVES = ["-x", "--xmlout"]
    ZYPPER_LOCK = "/var/run/zypp.pid"
    TAG_RELEASED = "zypper/released"
    TAG_BLOCKED = "zypper/blocked"
    def __init__(self):
        self._reset()
    def _reset(self):
        self.__cmd = ["zypper", "--non-interactive"]
<a name="2"></a>        self.__exit_code = 0
        self.__call_result = dict()
        self.__error_msg = ""
        self.__env = salt.utils.environment.get_module_environment(globals<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>())
        self.__xml = False
        self.__no_lock = False
        self.__no_raise = False
        self.__refresh = False
        self.__ignore_repo_failure = False
        self.</b></font>__systemd_scope = False
        self.__root = None
        self.__called = False
    def __call__(self, *args, **kwargs):
        if self.__called:
            self._reset()
        if "no_repo_failure" in kwargs:
            self.__ignore_repo_failure = kwargs["no_repo_failure"]
        if "systemd_scope" in kwargs:
            self.__systemd_scope = kwargs["systemd_scope"]
        if "root" in kwargs:
            self.__root = kwargs["root"]
        return self
    def __getattr__(self, item):
        if self.__called:
            self._reset()
        if item == "xml":
            self.__xml = True
        elif item == "nolock":
            self.__no_lock = True
        elif item == "noraise":
            self.__no_raise = True
        elif item == "refreshable":
            self.__refresh = True
        elif item == "call":
            return self.__call
        else:
            return self.__dict__[item]
        if self.__no_lock:
            self.__no_lock = not self.__refresh
        return self
    @property
    def exit_code(self):
        return self.__exit_code
    @exit_code.setter
    def exit_code(self, exit_code):
        self.__exit_code = int(exit_code or "0")
    @property
    def error_msg(self):
        return self.__error_msg
    @error_msg.setter
    def error_msg(self, msg):
        if self._is_error():
            self.__error_msg = msg and os.linesep.join(msg) or "Check Zypper's logs."
    @property
    def stdout(self):
        return self.__call_result.get("stdout", "")
    @property
    def stderr(self):
        return self.__call_result.get("stderr", "")
    @property
    def pid(self):
        return self.__call_result.get("pid", "")
    def _is_error(self):
        if self.exit_code:
            msg = self.SUCCESS_EXIT_CODES.get(self.exit_code)
            if msg:
                log.info(msg)
            msg = self.WARNING_EXIT_CODES.get(self.exit_code)
            if msg:
                log.warning(msg)
        return (
            self.exit_code not in self.SUCCESS_EXIT_CODES
            and self.exit_code not in self.WARNING_EXIT_CODES
        )
    def _is_lock(self):
        return self.exit_code == self.LOCK_EXIT_CODE
    def _is_xml_mode(self):
        return (
            [itm for itm in self.XML_DIRECTIVES if itm in self.__cmd] and True or False
        )
    def _check_result(self):
        if not self.__call_result:
            raise CommandExecutionError("No output result from Zypper?")
        self.exit_code = self.__call_result["retcode"]
        if self._is_lock():
            return False
        if self._is_error():
            _error_msg = list()
            if not self._is_xml_mode():
                msg = (
                    self.__call_result["stderr"]
                    and self.__call_result["stderr"].strip()
                    or ""
                )
                if msg:
                    _error_msg.append(msg)
            else:
                try:
                    doc = dom.parseString(self.__call_result["stdout"])
                except ExpatError as err:
                    log.error(err)
                    doc = None
                if doc:
                    msg_nodes = doc.getElementsByTagName("message")
                    for node in msg_nodes:
                        if node.getAttribute("type") == "error":
                            _error_msg.append(node.childNodes[0].nodeValue)
                elif self.__call_result["stderr"].strip():
                    _error_msg.append(self.__call_result["stderr"].strip())
            self.error_msg = _error_msg
        return True
    def __call(self, *args, **kwargs):
        self.__called = True
        if self.__xml:
            self.__cmd.append("--xmlout")
        if not self.__refresh and "--no-refresh" not in args:
            self.__cmd.append("--no-refresh")
        if self.__root:
            self.__cmd.extend(["--root", self.__root])
        self.__cmd.extend(args)
        kwargs["output_loglevel"] = "trace"
        kwargs["python_shell"] = False
        kwargs["env"] = self.__env.copy()
        if self.__no_lock:
            kwargs["env"][
                "ZYPP_READONLY_HACK"
            ] = (  # Disables locking for read-only operations. Do not try that at home!
                "1"
            )
        was_blocked = False
        while True:
            cmd = []
            if self.__systemd_scope:
                cmd.extend(["systemd-run", "--scope"])
            cmd.extend(self.__cmd)
            log.debug("Calling Zypper: %s", " ".join(cmd))
            self.__call_result = __salt__["cmd.run_all"](cmd, **kwargs)
            if self._check_result():
                break
            if os.path.exists(self.ZYPPER_LOCK):
                try:
                    with salt.utils.files.fopen(self.ZYPPER_LOCK) as rfh:
                        data = __salt__["ps.proc_info"](
                            int(rfh.readline()),
                            attrs=["pid", "name", "cmdline", "create_time"],
                        )
                        data["cmdline"] = " ".join(data["cmdline"])
                        data["info"] = "Blocking process created at {}.".format(
                            datetime.datetime.utcfromtimestamp(
                                data["create_time"]
                            ).isoformat()
                        )
                        data["success"] = True
                except Exception as err:  # pylint: disable=broad-except
                    data = {
                        "info": (
                            "Unable to retrieve information about blocking process: {}".format(
                                err.message
                            )
                        ),
                        "success": False,
                    }
            else:
                data = {
                    "info": "Zypper is locked, but no Zypper lock has been found.",
                    "success": False,
                }
            if not data["success"]:
                log.debug("Unable to collect data about blocking process.")
            else:
                log.debug("Collected data about blocking process.")
            __salt__["event.fire_master"](data, self.TAG_BLOCKED)
            log.debug(
                "Fired a Zypper blocked event to the master with the data: %s", data
            )
            log.debug("Waiting 5 seconds for Zypper gets released...")
            time.sleep(5)
            if not was_blocked:
                was_blocked = True
        if was_blocked:
            __salt__["event.fire_master"](
                {
                    "success": not self.error_msg,
                    "info": self.error_msg or "Zypper has been released",
                },
                self.TAG_RELEASED,
            )
        if self.error_msg and not self.__no_raise and not self.__ignore_repo_failure:
            raise CommandExecutionError(
                "Zypper command failure: {}".format(self.error_msg)
            )
        return (
            self._is_xml_mode()
            and dom.parseString(
                salt.utils.stringutils.to_str(self.__call_result["stdout"])
            )
            or self.__call_result["stdout"]
        )
__zypper__ = _Zypper()
class Wildcard:
    Z_OP = ["&lt;", "&lt;=", "=", "&gt;=", "&gt;"]
    def __init__(self, zypper):
        self.name = None
        self.version = None
        self.zypper = zypper
        self._attr_solvable_version = "edition"
        self._op = None
    def __call__(self, pkg_name, pkg_version):
        if pkg_version:
            self.name = pkg_name
            self._set_version(pkg_version)  # Dissects possible operator
            versions = sorted(
                LooseVersion(vrs)
                for vrs in self._get_scope_versions(self._get_available_versions())
            )
            return versions and "{}{}".format(self._op or "", versions[-1]) or None
    def _get_available_versions(self):
        solvables = self.zypper.nolock.xml.call(
            "se", "-xv", self.name
        ).getElementsByTagName("solvable")
        if not solvables:
            raise CommandExecutionError(
                "No packages found matching '{}'".format(self.name)
            )
        return sorted(
            {
                slv.getAttribute(self._attr_solvable_version)
                for slv in solvables
                if slv.getAttribute(self._attr_solvable_version)
            }
        )
    def _get_scope_versions(self, pkg_versions):
        get_in_versions = []
        for p_version in pkg_versions:
            if fnmatch.fnmatch(p_version, self.version):
                get_in_versions.append(p_version)
        return get_in_versions
    def _set_version(self, version):
        if not version:
            return
        exact_version = re.sub(r"[&lt;&gt;=+]*", "", version)
        self._op = version.replace(exact_version, "") or None
        if self._op and self._op not in self.Z_OP:
            raise CommandExecutionError(
                'Zypper do not supports operator "{}".'.format(self._op)
            )
        self.version = exact_version
def _systemd_scope():
    return salt.utils.systemd.has_scope(__context__) and __salt__["config.get"](
        "systemd.scope", True
    )
def _clean_cache():
    keys = []
    for cache_name in ["pkg.list_pkgs", "pkg.list_provides"]:
        for contextkey in __context__:
            if contextkey.startswith(cache_name):
                keys.append(contextkey)
    for key in keys:
        __context__.pop(key, None)
def list_upgrades(refresh=True, root=None, **kwargs):
    if refresh:
        refresh_db(root)
    ret = dict()
    cmd = ["list-updates"]
    if "fromrepo" in kwargs:
        repos = kwargs["fromrepo"]
        if isinstance(repos, str):
            repos = [repos]
        for repo in repos:
            cmd.extend(["--repo", repo if isinstance(repo, str) else str(repo)])
        log.debug("Targeting repos: %s", repos)
    for update_node in (
        __zypper__(root=root).nolock.xml.call(*cmd).getElementsByTagName("update")
    ):
        if update_node.getAttribute("kind") == "package":
            ret[update_node.getAttribute("name")] = update_node.getAttribute("edition")
    return ret
list_updates = salt.utils.functools.alias_function(list_upgrades, "list_updates")
def info_installed(*names, **kwargs):
    all_versions = kwargs.get("all_versions", False)
    ret = dict()
    for pkg_name, pkgs_nfo in __salt__["lowpkg.info"](*names, **kwargs).items():
        pkg_nfo = pkgs_nfo if all_versions else [pkgs_nfo]
        for _nfo in pkg_nfo:
            t_nfo = dict()
            for key, value in _nfo.items():
                if key == "source_rpm":
                    t_nfo["source"] = value
                else:
                    t_nfo[key] = value
            if not all_versions:
                ret[pkg_name] = t_nfo
            else:
                ret.setdefault(pkg_name, []).append(t_nfo)
    return ret
def info_available(*names, **kwargs):
    ret = {}
    if not names:
        return ret
    else:
        names = sorted(list(set(names)))
    root = kwargs.get("root", None)
    if kwargs.get("refresh", True):
        refresh_db(root)
    pkg_info = []
    batch = names[:]
    batch_size = 200
    while batch:
        pkg_info.extend(
            re.split(
                r"Information for package*",
                __zypper__(root=root).nolock.call(
                    "info", "-t", "package", *batch[:batch_size]
                ),
            )
        )
        batch = batch[batch_size:]
    for pkg_data in pkg_info:
        nfo = {}
        for line in [data for data in pkg_data.split("\n") if ":" in data]:
            if line.startswith("-----"):
                continue
            kw = [data.strip() for data in line.split(":", 1)]
            if len(kw) == 2 and kw[1]:
                nfo[kw[0].lower()] = kw[1]
        if nfo.get("name"):
            name = nfo.pop("name")
            ret[name] = nfo
        if nfo.get("status"):
            nfo["status"] = nfo.get("status")
        if nfo.get("installed"):
            nfo["installed"] = nfo.get("installed").lower().startswith("yes")
    return ret
def parse_arch(name):
    _name, _arch = None, None
    try:
        _name, _arch = name.rsplit(PKG_ARCH_SEPARATOR, 1)
    except ValueError:
        pass
    if _arch not in salt.utils.pkg.rpm.ARCHES + ("noarch",):
        _name = name
        _arch = None
    return {"name": _name, "arch": _arch}
def latest_version(*names, **kwargs):
    ret = dict()
    if not names:
        return ret
    names = sorted(list(set(names)))
    package_info = info_available(*names, **kwargs)
    for name in names:
        pkg_info = package_info.get(name, {})
        status = pkg_info.get("status", "").lower()
        if status.find("not installed") &gt; -1 or status.find("out-of-date") &gt; -1:
            ret[name] = pkg_info.get("version")
        else:
            ret[name] = ""
    if len(names) == 1 and ret:
        return ret[names[0]]
    return ret
available_version = salt.utils.functools.alias_function(
    latest_version, "available_version"
)
def upgrade_available(name, **kwargs):
    return not not latest_version(name, **kwargs)  # pylint: disable=C0113
def version(*names, **kwargs):
    return __salt__["pkg_resource.version"](*names, **kwargs) or {}
def version_cmp(ver1, ver2, ignore_epoch=False, **kwargs):
    return __salt__["lowpkg.version_cmp"](ver1, ver2, ignore_epoch=ignore_epoch)
def _list_pkgs_from_context(versions_as_list, contextkey, attr):
    return __salt__["pkg_resource.format_pkg_list"](
        __context__[contextkey], versions_as_list, attr
    )
def list_pkgs(versions_as_list=False, root=None, includes=None, **kwargs):
    versions_as_list = salt.utils.data.is_true(versions_as_list)
    if any(
        [salt.utils.data.is_true(kwargs.get(x)) for x in ("removed", "purge_desired")]
    ):
        return {}
    attr = kwargs.get("attr")
    if attr is not None:
        attr = salt.utils.args.split_input(attr)
    includes = includes if includes else []
    contextkey = "pkg.list_pkgs_{}_{}".format(root, includes)
    if contextkey in __context__ and kwargs.get("use_context", True):
        return _list_pkgs_from_context(versions_as_list, contextkey, attr)
    ret = {}
    cmd = ["rpm"]
    if root:
        cmd.extend(["--root", root])
    cmd.extend(
        [
            "-qa",
            "--queryformat",
            salt.utils.pkg.rpm.QUERYFORMAT.replace("%{REPOID}", "(none)") + "\n",
        ]
    )
    output = __salt__["cmd.run"](cmd, python_shell=False, output_loglevel="trace")
    for line in output.splitlines():
        pkginfo = salt.utils.pkg.rpm.parse_pkginfo(line, osarch=__grains__["osarch"])
        if pkginfo:
            pkgver = pkginfo.version
            epoch = None
            release = None
            if ":" in pkgver:
                epoch, pkgver = pkgver.split(":", 1)
            if "-" in pkgver:
                pkgver, release = pkgver.split("-", 1)
            all_attr = {
                "epoch": epoch,
                "version": pkgver,
                "release": release,
                "arch": pkginfo.arch,
                "install_date": pkginfo.install_date,
                "install_date_time_t": pkginfo.install_date_time_t,
            }
            __salt__["pkg_resource.add_pkg"](ret, pkginfo.name, all_attr)
    _ret = {}
    for pkgname in ret:
        if pkgname.startswith("gpg-pubkey"):
            continue
        _ret[pkgname] = sorted(ret[pkgname], key=lambda d: d["version"])
    for include in includes:
        if include == "product":
            products = list_products(all=False, root=root)
            for product in products:
                extended_name = "{}:{}".format(include, product["name"])
                _ret[extended_name] = [
                    {
                        "epoch": product["epoch"],
                        "version": product["version"],
                        "release": product["release"],
                        "arch": product["arch"],
                        "install_date": None,
                        "install_date_time_t": None,
                    }
                ]
        if include in ("pattern", "patch"):
            if include == "pattern":
                elements = list_installed_patterns(root=root)
            elif include == "patch":
                elements = list_installed_patches(root=root)
            else:
                elements = []
            for element in elements:
                extended_name = "{}:{}".format(include, element)
                info = info_available(extended_name, refresh=False, root=root)
                _ret[extended_name] = [
                    {
                        "epoch": None,
                        "version": info[element]["version"],
                        "release": None,
                        "arch": info[element]["arch"],
                        "install_date": None,
                        "install_date_time_t": None,
                    }
                ]
    __context__[contextkey] = _ret
    return __salt__["pkg_resource.format_pkg_list"](
        __context__[contextkey], versions_as_list, attr
    )
def list_repo_pkgs(*args, **kwargs):
    byrepo = kwargs.pop("byrepo", False)
    fromrepo = kwargs.pop("fromrepo", "") or ""
    ret = {}
    targets = [arg if isinstance(arg, str) else str(arg) for arg in args]
    def _is_match(pkgname):
        if not args:
            return True
        for target in targets:
            if fnmatch.fnmatch(pkgname, target):
                return True
        return False
    root = kwargs.get("root") or None
    for node in (
        __zypper__(root=root)
        .xml.call("se", "-s", *targets)
        .getElementsByTagName("solvable")
    ):
        pkginfo = dict(node.attributes.items())
        try:
            if pkginfo["kind"] != "package":
                continue
            reponame = pkginfo["repository"]
            if fromrepo and reponame != fromrepo:
                continue
            pkgname = pkginfo["name"]
            pkgversion = pkginfo["edition"]
        except KeyError:
            continue
        else:
            if _is_match(pkgname):
                repo_dict = ret.setdefault(reponame, {})
                version_list = repo_dict.setdefault(pkgname, set())
                version_list.add(pkgversion)
    if byrepo:
        for reponame in ret:
            for pkgname in ret[reponame]:
                sorted_versions = sorted(
                    (LooseVersion(x) for x in ret[reponame][pkgname]), reverse=True
                )
                ret[reponame][pkgname] = [x.vstring for x in sorted_versions]
        return ret
    else:
        byrepo_ret = {}
        for reponame in ret:
            for pkgname in ret[reponame]:
                byrepo_ret.setdefault(pkgname, []).extend(ret[reponame][pkgname])
        for pkgname in byrepo_ret:
            sorted_versions = sorted(
                (LooseVersion(x) for x in byrepo_ret[pkgname]), reverse=True
            )
            byrepo_ret[pkgname] = [x.vstring for x in sorted_versions]
        return byrepo_ret
def _get_configured_repos(root=None):
    repos = os.path.join(root, os.path.relpath(REPOS, os.path.sep)) if root else REPOS
    repos_cfg = configparser.ConfigParser()
    if os.path.exists(repos):
        repos_cfg.read(
            [
                repos + "/" + fname
                for fname in os.listdir(repos)
                if fname.endswith(".repo")
            ]
        )
    else:
        log.warning("Repositories not found in %s", repos)
    return repos_cfg
def _get_repo_info(alias, repos_cfg=None, root=None):
    try:
        meta = dict((repos_cfg or _get_configured_repos(root=root)).items(alias))
        meta["alias"] = alias
        for key, val in meta.items():
            if val in ["0", "1"]:
                meta[key] = int(meta[key]) == 1
            elif val == "NONE":
                meta[key] = None
        return meta
    except (ValueError, configparser.NoSectionError):
        return {}
def get_repo(repo, root=None, **kwargs):  # pylint: disable=unused-argument
    return _get_repo_info(repo, root=root)
def list_repos(root=None, **kwargs):
    repos_cfg = _get_configured_repos(root=root)
    all_repos = {}
    for alias in repos_cfg.sections():
        all_repos[alias] = _get_repo_info(alias, repos_cfg=repos_cfg, root=root)
    return all_repos
def del_repo(repo, root=None):
    repos_cfg = _get_configured_repos(root=root)
    for alias in repos_cfg.sections():
        if alias == repo:
            doc = __zypper__(root=root).xml.call(
                "rr", "--loose-auth", "--loose-query", alias
            )
            msg = doc.getElementsByTagName("message")
            if doc.getElementsByTagName("progress") and msg:
                return {
                    repo: True,
                    "message": msg[0].childNodes[0].nodeValue,
                }
    raise CommandExecutionError("Repository '{}' not found.".format(repo))
def mod_repo(repo, **kwargs):
    root = kwargs.get("root") or None
    repos_cfg = _get_configured_repos(root=root)
    added = False
    if repo not in repos_cfg.sections():
        url = kwargs.get("url", kwargs.get("mirrorlist", kwargs.get("baseurl")))
        if not url:
            raise CommandExecutionError(
                "Repository '{}' not found, and neither 'baseurl' nor "
                "'mirrorlist' was specified".format(repo)
            )
        if not urllib.parse.urlparse(url).scheme:
            raise CommandExecutionError(
                "Repository '{}' not found and URL for baseurl/mirrorlist "
                "is malformed".format(repo)
            )
        for alias in repos_cfg.sections():
            repo_meta = _get_repo_info(alias, repos_cfg=repos_cfg, root=root)
            new_url = urllib.parse.urlparse(url)
            if not new_url.path:
                new_url = urllib.parse.urlparse.ParseResult(
                    scheme=new_url.scheme,  # pylint: disable=E1123
                    netloc=new_url.netloc,
                    path="/",
                    params=new_url.params,
                    query=new_url.query,
                    fragment=new_url.fragment,
                )
            base_url = urllib.parse.urlparse(repo_meta["baseurl"])
            if new_url == base_url:
                raise CommandExecutionError(
                    "Repository '{}' already exists as '{}'.".format(repo, alias)
                )
        __zypper__(root=root).xml.call("ar", url, repo)
        repos_cfg = _get_configured_repos(root=root)
        if repo not in repos_cfg.sections():
            raise CommandExecutionError(
                "Failed add new repository '{}' for unspecified reason. "
                "Please check zypper logs.".format(repo)
            )
        added = True
    repo_info = _get_repo_info(repo, root=root)
    if (
        not added
        and "baseurl" in kwargs
        and not (kwargs["baseurl"] == repo_info["baseurl"])
    ):
        repo_info.update(kwargs)
        repo_info.setdefault("cache", False)
        del_repo(repo, root=root)
        return mod_repo(repo, root=root, **repo_info)
    cmd_opt = []
    global_cmd_opt = []
    call_refresh = False
    if "enabled" in kwargs:
        cmd_opt.append(kwargs["enabled"] and "--enable" or "--disable")
    if "refresh" in kwargs:
        cmd_opt.append(kwargs["refresh"] and "--refresh" or "--no-refresh")
    if "cache" in kwargs:
        cmd_opt.append(kwargs["cache"] and "--keep-packages" or "--no-keep-packages")
    if "gpgcheck" in kwargs:
        cmd_opt.append(kwargs["gpgcheck"] and "--gpgcheck" or "--no-gpgcheck")
    if "priority" in kwargs:
        cmd_opt.append("--priority={}".format(kwargs.get("priority", DEFAULT_PRIORITY)))
    if "humanname" in kwargs:
        cmd_opt.append("--name='{}'".format(kwargs.get("humanname")))
    if kwargs.get("gpgautoimport") is True:
        global_cmd_opt.append("--gpg-auto-import-keys")
        call_refresh = True
    if cmd_opt:
        cmd_opt = global_cmd_opt + ["mr"] + cmd_opt + [repo]
        __zypper__(root=root).refreshable.xml.call(*cmd_opt)
    comment = None
    if call_refresh:
        refresh_opts = global_cmd_opt + ["refresh"] + [repo]
        __zypper__(root=root).xml.call(*refresh_opts)
    elif not added and not cmd_opt:
        comment = "Specified arguments did not result in modification of repo"
    repo = get_repo(repo, root=root)
    if comment:
        repo["comment"] = comment
    return repo
def refresh_db(force=None, root=None):
    salt.utils.pkg.clear_rtag(__opts__)
    ret = {}
    refresh_opts = ["refresh"]
    if force is None:
        force = __pillar__.get("zypper", {}).get("refreshdb_force", True)
    if force:
        refresh_opts.append("--force")
    out = __zypper__(root=root).refreshable.call(*refresh_opts)
    for line in out.splitlines():
        if not line:
            continue
        if line.strip().startswith("Repository") and "'" in line:
            try:
                key = line.split("'")[1].strip()
                if "is up to date" in line:
                    ret[key] = False
            except IndexError:
                continue
        elif line.strip().startswith("Building") and "'" in line:
            key = line.split("'")[1].strip()
            if "done" in line:
                ret[key] = True
    return ret
<a name="0"></a>
def _find_types(pkgs):
    return sorted({pkg.split<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(":", 1)[0] for pkg in pkgs if len(pkg.split(":", 1)) == 2})
def install(
    name=None,
    refresh=False,
    fromrepo=None,
    pkgs=None,
    sources=None,
    downloadonly=None,
    skip_verify=False,
    version=None,
    ignore_repo_failure=False,
    no_recommends=False,
    root=</b></font>None,
    **kwargs
):
    if refresh:
        refresh_db(root)
    try:
        pkg_params, pkg_type = __salt__["pkg_resource.parse_targets"](
            name, pkgs, sources, **kwargs
        )
    except MinionError as exc:
        raise CommandExecutionError(exc)
    if pkg_params is None or len(pkg_params) == 0:
        return {}
    version_num = Wildcard(__zypper__(root=root))(name, version)
    if version_num:
        if pkgs is None and sources is None:
            pkg_params = {name: version_num}
        else:
            log.warning(
                '"version" parameter will be ignored for multiple package targets'
            )
    if pkg_type == "repository":
        targets = []
        for param, version_num in pkg_params.items():
            if version_num is None:
                log.debug("targeting package: %s", param)
                targets.append(param)
            else:
                prefix, verstr = salt.utils.pkg.split_comparison(version_num)
                if not prefix:
                    prefix = "="
                target = "{}{}{}".format(param, prefix, verstr)
                log.debug("targeting package: %s", target)
                targets.append(target)
    elif pkg_type == "advisory":
        targets = []
        cur_patches = list_patches(root=root)
        for advisory_id in pkg_params:
            if advisory_id not in cur_patches:
                raise CommandExecutionError(
                    'Advisory id "{}" not found'.format(advisory_id)
                )
            else:
                targets.append(advisory_id)
    else:
        targets = pkg_params
    diff_attr = kwargs.get("diff_attr")
    includes = _find_types(targets)
    old = (
        list_pkgs(attr=diff_attr, root=root, includes=includes)
        if not downloadonly
        else list_downloaded(root)
    )
    downgrades = []
    if fromrepo:
        fromrepoopt = ["--force", "--force-resolution", "--from", fromrepo]
        log.info("Targeting repo '%s'", fromrepo)
    else:
        fromrepoopt = ""
    cmd_install = ["install", "--auto-agree-with-licenses"]
    cmd_install.append(
        kwargs.get("resolve_capabilities") and "--capability" or "--name"
    )
    if not refresh:
        cmd_install.insert(0, "--no-refresh")
    if skip_verify:
        cmd_install.insert(0, "--no-gpg-checks")
    if downloadonly:
        cmd_install.append("--download-only")
    if fromrepo:
        cmd_install.extend(fromrepoopt)
    if no_recommends:
        cmd_install.append("--no-recommends")
    errors = []
    if pkg_type == "advisory":
        targets = ["patch:{}".format(t) for t in targets]
    systemd_scope = _systemd_scope()
    while targets:
        cmd = cmd_install + targets[:500]
        targets = targets[500:]
        for line in (
            __zypper__(
                no_repo_failure=ignore_repo_failure,
                systemd_scope=systemd_scope,
                root=root,
            )
            .call(*cmd)
            .splitlines()
        ):
            match = re.match(
                r"^The selected package '([^']+)'.+has lower version", line
            )
            if match:
                downgrades.append(match.group(1))
    while downgrades:
        cmd = cmd_install + ["--force"] + downgrades[:500]
        downgrades = downgrades[500:]
        __zypper__(no_repo_failure=ignore_repo_failure, root=root).call(*cmd)
    _clean_cache()
    new = (
        list_pkgs(attr=diff_attr, root=root, includes=includes)
        if not downloadonly
        else list_downloaded(root)
    )
    ret = salt.utils.data.compare_dicts(old, new)
    if includes:
        _clean_cache()
    if errors:
        raise CommandExecutionError(
            "Problem encountered {} package(s)".format(
                "downloading" if downloadonly else "installing"
            ),
            info={"errors": errors, "changes": ret},
        )
    return ret
def upgrade(
    refresh=True,
    dryrun=False,
    dist_upgrade=False,
    fromrepo=None,
    novendorchange=False,
    skip_verify=False,
    no_recommends=False,
    root=None,
    **kwargs
):  # pylint: disable=unused-argument
    cmd_update = (["dist-upgrade"] if dist_upgrade else ["update"]) + [
        "--auto-agree-with-licenses"
    ]
    if skip_verify:
        cmd_update.insert(0, "--no-gpg-checks")
    if refresh:
        refresh_db(root)
    if dryrun:
        cmd_update.append("--dry-run")
    if fromrepo:
        if isinstance(fromrepo, str):
            fromrepo = [fromrepo]
        for repo in fromrepo:
            cmd_update.extend(["--from" if dist_upgrade else "--repo", repo])
        log.info("Targeting repos: %s", fromrepo)
    if dist_upgrade:
        if novendorchange:
            if __grains__["osrelease_info"][0] &gt; 11:
                cmd_update.append("--no-allow-vendor-change")
                log.info("Disabling vendor changes")
            else:
                log.warning(
                    "Disabling vendor changes is not supported on this Zypper version"
                )
        if no_recommends:
            cmd_update.append("--no-recommends")
            log.info("Disabling recommendations")
        if dryrun:
            log.info("Executing debugsolver and performing a dry-run dist-upgrade")
            __zypper__(systemd_scope=_systemd_scope(), root=root).noraise.call(
                *cmd_update + ["--debug-solver"]
            )
    old = list_pkgs(root=root)
    __zypper__(systemd_scope=_systemd_scope(), root=root).noraise.call(*cmd_update)
    _clean_cache()
    new = list_pkgs(root=root)
    ret = salt.utils.data.compare_dicts(old, new)
    if __zypper__.exit_code not in __zypper__.SUCCESS_EXIT_CODES:
        result = {
            "retcode": __zypper__.exit_code,
            "stdout": __zypper__.stdout,
            "stderr": __zypper__.stderr,
            "pid": __zypper__.pid,
        }
        raise CommandExecutionError(
            "Problem encountered upgrading packages",
            info={"changes": ret, "result": result},
        )
    if dryrun:
        ret = (__zypper__.stdout + os.linesep + __zypper__.stderr).strip()
    return ret
def _uninstall(name=None, pkgs=None, root=None):
    try:
        pkg_params = __salt__["pkg_resource.parse_targets"](name, pkgs)[0]
    except MinionError as exc:
        raise CommandExecutionError(exc)
    includes = _find_types(pkg_params.keys())
    old = list_pkgs(root=root, includes=includes)
    targets = []
    for target in pkg_params:
        if target in old and pkg_params[target] in old[target].split(","):
            targets.append(target + "-" + pkg_params[target])
        elif target in old and not pkg_params[target]:
            targets.append(target)
    if not targets:
        return {}
    systemd_scope = _systemd_scope()
    errors = []
    while targets:
        __zypper__(systemd_scope=systemd_scope, root=root).call(
            "remove", *targets[:500]
        )
        targets = targets[500:]
    _clean_cache()
    new = list_pkgs(root=root, includes=includes)
    ret = salt.utils.data.compare_dicts(old, new)
    if errors:
        raise CommandExecutionError(
            "Problem encountered removing package(s)",
            info={"errors": errors, "changes": ret},
        )
    return ret
def normalize_name(name):
    try:
        arch = name.rsplit(".", 1)[-1]
        if arch not in salt.utils.pkg.rpm.ARCHES + ("noarch",):
            return name
    except ValueError:
        return name
    if arch in (__grains__["osarch"], "noarch") or salt.utils.pkg.rpm.check_32(
        arch, osarch=__grains__["osarch"]
    ):
        return name[: -(len(arch) + 1)]
    return name
def remove(
    name=None, pkgs=None, root=None, **kwargs
):  # pylint: disable=unused-argument
    return _uninstall(name=name, pkgs=pkgs, root=root)
def purge(name=None, pkgs=None, root=None, **kwargs):  # pylint: disable=unused-argument
    return _uninstall(name=name, pkgs=pkgs, root=root)
def list_locks(root=None):
    locks = {}
    _locks = os.path.join(root, os.path.relpath(LOCKS, os.path.sep)) if root else LOCKS
    try:
        with salt.utils.files.fopen(_locks) as fhr:
            items = salt.utils.stringutils.to_unicode(fhr.read()).split("\n\n")
            for meta in [item.split("\n") for item in items]:
                lock = {}
                for element in [el for el in meta if el]:
                    if ":" in element:
                        lock.update(
                            dict([tuple(i.strip() for i in element.split(":", 1))])
                        )
                if lock.get("solvable_name"):
                    locks[lock.pop("solvable_name")] = lock
    except OSError:
        pass
    except Exception:  # pylint: disable=broad-except
        log.warning("Detected a problem when accessing %s", _locks)
    return locks
def clean_locks(root=None):
    LCK = "removed"
    out = {LCK: 0}
    locks = os.path.join(root, os.path.relpath(LOCKS, os.path.sep)) if root else LOCKS
    if not os.path.exists(locks):
        return out
    for node in __zypper__(root=root).xml.call("cl").getElementsByTagName("message"):
        text = node.childNodes[0].nodeValue.lower()
        if text.startswith(LCK):
            out[LCK] = text.split(" ")[1]
            break
    return out
def unhold(name=None, pkgs=None, **kwargs):
    ret = {}
    if not name and not pkgs:
        raise CommandExecutionError("Name or packages must be specified.")
    targets = []
    if pkgs:
        for pkg in salt.utils.data.repack_dictlist(pkgs):
            targets.append(pkg)
    else:
        targets.append(name)
    locks = list_locks()
    removed = []
    missing = []
    for target in targets:
        ret[target] = {"name": target, "changes": {}, "result": True, "comment": ""}
        if locks.get(target):
            removed.append(target)
            ret[target]["changes"]["new"] = ""
            ret[target]["changes"]["old"] = "hold"
            ret[target]["comment"] = "Package {} is no longer held.".format(target)
        else:
            missing.append(target)
            ret[target]["comment"] = "Package {} was already unheld.".format(target)
    if removed:
        __zypper__.call("rl", *removed)
    return ret
def hold(name=None, pkgs=None, **kwargs):
    ret = {}
    if not name and not pkgs:
        raise CommandExecutionError("Name or packages must be specified.")
    targets = []
    if pkgs:
        for pkg in salt.utils.data.repack_dictlist(pkgs):
            targets.append(pkg)
    else:
        targets.append(name)
    locks = list_locks()
    added = []
    for target in targets:
        ret[target] = {"name": target, "changes": {}, "result": True, "comment": ""}
        if not locks.get(target):
            added.append(target)
            ret[target]["changes"]["new"] = "hold"
            ret[target]["changes"]["old"] = ""
            ret[target]["comment"] = "Package {} is now being held.".format(target)
        else:
            ret[target]["comment"] = "Package {} is already set to be held.".format(
                target
            )
<a name="1"></a>    if added:
        __zypper__.call("al", *added)
    r<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>eturn ret
def verify(*names, **kwargs):
    return __salt__["lowpkg.verify"](*names, **kwargs)
def file_list(*packages, **kwargs):
    return __salt__["lowpkg.file_list"](*packages, **kwargs)
def file_dict(*packages, **kwargs):
    return __salt__[</b></font>"lowpkg.file_dict"](*packages, **kwargs)
def modified(*packages, **flags):
    return __salt__["lowpkg.modified"](*packages, **flags)
def owner(*paths, **kwargs):
    return __salt__["lowpkg.owner"](*paths, **kwargs)
def _get_visible_patterns(root=None):
    patterns = {}
    search_patterns = __zypper__(root=root).nolock.xml.call("se", "-t", "pattern")
    for element in search_patterns.getElementsByTagName("solvable"):
        installed = element.getAttribute("status") == "installed"
        patterns[element.getAttribute("name")] = {
            "installed": installed,
            "summary": element.getAttribute("summary"),
        }
    return patterns
def _get_installed_patterns(root=None):
    def _pattern_name(capability):
        return capability.split("=")[-1].strip()
    cmd = ["rpm"]
    if root:
        cmd.extend(["--root", root])
    cmd.extend(["-q", "--provides", "--whatprovides", "pattern()"])
    output = __salt__["cmd.run"](cmd, ignore_retcode=True)
    installed_patterns = {
        _pattern_name(line)
        for line in output.splitlines()
        if line.startswith("pattern() = ") and not _pattern_name(line).startswith(".")
    }
    patterns = {
        k: v for k, v in _get_visible_patterns(root=root).items() if v["installed"]
    }
    for pattern in installed_patterns:
        if pattern not in patterns:
            patterns[pattern] = {
                "installed": True,
                "summary": "Non-visible pattern",
            }
    return patterns
def list_patterns(refresh=False, root=None):
    if refresh:
        refresh_db(root)
    return _get_visible_patterns(root=root)
def list_installed_patterns(root=None):
    return _get_installed_patterns(root=root)
def search(criteria, refresh=False, **kwargs):
    ALLOWED_SEARCH_OPTIONS = {
        "provides": "--provides",
        "recommends": "--recommends",
        "requires": "--requires",
        "suggests": "--suggests",
        "conflicts": "--conflicts",
        "obsoletes": "--obsoletes",
        "file_list": "--file-list",
        "search_descriptions": "--search-descriptions",
        "case_sensitive": "--case-sensitive",
        "installed_only": "--installed-only",
        "not_installed_only": "-u",
        "details": "--details",
    }
    root = kwargs.get("root", None)
    if refresh:
        refresh_db(root)
    cmd = ["search"]
    if kwargs.get("match") == "exact":
        cmd.append("--match-exact")
    elif kwargs.get("match") == "words":
        cmd.append("--match-words")
    elif kwargs.get("match") == "substrings":
        cmd.append("--match-substrings")
    for opt in kwargs:
        if opt in ALLOWED_SEARCH_OPTIONS:
            cmd.append(ALLOWED_SEARCH_OPTIONS.get(opt))
    cmd.append(criteria)
    solvables = (
        __zypper__(root=root)
        .nolock.noraise.xml.call(*cmd)
        .getElementsByTagName("solvable")
    )
    if not solvables:
        raise CommandExecutionError("No packages found matching '{}'".format(criteria))
    out = {}
    for solvable in solvables:
        out[solvable.getAttribute("name")] = dict()
        for k, v in solvable.attributes.items():
            out[solvable.getAttribute("name")][k] = v
    return out
def _get_first_aggregate_text(node_list):
    if not node_list:
        return ""
    out = []
    for node in node_list[0].childNodes:
        if node.nodeType == dom.Document.TEXT_NODE:
            out.append(node.nodeValue)
    return "\n".join(out)
def list_products(all=False, refresh=False, root=None):
    if refresh:
        refresh_db(root)
    ret = list()
    OEM_PATH = "/var/lib/suseRegister/OEM"
    if root:
        OEM_PATH = os.path.join(root, os.path.relpath(OEM_PATH, os.path.sep))
    cmd = list()
    if not all:
        cmd.append("--disable-repositories")
    cmd.append("products")
    if not all:
        cmd.append("-i")
    product_list = (
        __zypper__(root=root).nolock.xml.call(*cmd).getElementsByTagName("product-list")
    )
    if not product_list:
        return ret  # No products found
    for prd in product_list[0].getElementsByTagName("product"):
        p_nfo = dict()
        for k_p_nfo, v_p_nfo in prd.attributes.items():
            if k_p_nfo in ["isbase", "installed"]:
                p_nfo[k_p_nfo] = bool(v_p_nfo in ["true", "1"])
            elif v_p_nfo:
                p_nfo[k_p_nfo] = v_p_nfo
        eol = prd.getElementsByTagName("endoflife")
        if eol:
            p_nfo["eol"] = eol[0].getAttribute("text")
            p_nfo["eol_t"] = int(eol[0].getAttribute("time_t") or 0)
        p_nfo["description"] = " ".join(
            [
                line.strip()
                for line in _get_first_aggregate_text(
                    prd.getElementsByTagName("description")
                ).split(os.linesep)
            ]
        )
        if "productline" in p_nfo and p_nfo["productline"]:
            oem_file = os.path.join(OEM_PATH, p_nfo["productline"])
            if os.path.isfile(oem_file):
                with salt.utils.files.fopen(oem_file, "r") as rfile:
                    oem_release = salt.utils.stringutils.to_unicode(
                        rfile.readline()
                    ).strip()
                    if oem_release:
                        p_nfo["release"] = oem_release
        ret.append(p_nfo)
    return ret
def download(*packages, **kwargs):
    if not packages:
        raise SaltInvocationError("No packages specified")
    root = kwargs.get("root", None)
    refresh = kwargs.get("refresh", False)
    if refresh:
        refresh_db(root)
    pkg_ret = {}
    for dld_result in (
        __zypper__(root=root)
        .xml.call("download", *packages)
        .getElementsByTagName("download-result")
    ):
        repo = dld_result.getElementsByTagName("repository")[0]
        path = dld_result.getElementsByTagName("localfile")[0].getAttribute("path")
        pkg_info = {
            "repository-name": repo.getAttribute("name"),
            "repository-alias": repo.getAttribute("alias"),
            "path": path,
        }
        key = _get_first_aggregate_text(dld_result.getElementsByTagName("name"))
        if __salt__["lowpkg.checksum"](pkg_info["path"], root=root):
            pkg_ret[key] = pkg_info
    if pkg_ret:
        failed = [pkg for pkg in packages if pkg not in pkg_ret]
        if failed:
            pkg_ret[
                "_error"
            ] = "The following package(s) failed to download: {}".format(
                ", ".join(failed)
            )
        return pkg_ret
    raise CommandExecutionError(
        "Unable to download packages: {}".format(", ".join(packages))
    )
def list_downloaded(root=None, **kwargs):
    CACHE_DIR = "/var/cache/zypp/packages/"
    if root:
        CACHE_DIR = os.path.join(root, os.path.relpath(CACHE_DIR, os.path.sep))
    ret = {}
    for root, dirnames, filenames in salt.utils.path.os_walk(CACHE_DIR):
        for filename in fnmatch.filter(filenames, "*.rpm"):
            package_path = os.path.join(root, filename)
            pkg_info = __salt__["lowpkg.bin_pkg_info"](package_path)
            pkg_timestamp = int(os.path.getctime(package_path))
            ret.setdefault(pkg_info["name"], {})[pkg_info["version"]] = {
                "path": package_path,
                "size": os.path.getsize(package_path),
                "creation_date_time_t": pkg_timestamp,
                "creation_date_time": datetime.datetime.utcfromtimestamp(
                    pkg_timestamp
                ).isoformat(),
            }
    return ret
def diff(*paths, **kwargs):
    ret = {}
    pkg_to_paths = {}
    for pth in paths:
        pth_pkg = __salt__["lowpkg.owner"](pth, **kwargs)
        if not pth_pkg:
            ret[pth] = os.path.exists(pth) and "Not managed" or "N/A"
        else:
            if pkg_to_paths.get(pth_pkg) is None:
                pkg_to_paths[pth_pkg] = []
            pkg_to_paths[pth_pkg].append(pth)
    if pkg_to_paths:
        local_pkgs = __salt__["pkg.download"](*pkg_to_paths.keys(), **kwargs)
        for pkg, files in pkg_to_paths.items():
            for path in files:
                ret[path] = (
                    __salt__["lowpkg.diff"](local_pkgs[pkg]["path"], path)
                    or "Unchanged"
                )
    return ret
def _get_patches(installed_only=False, root=None):
    patches = {}
    for element in (
        __zypper__(root=root)
        .nolock.xml.call("se", "-t", "patch")
        .getElementsByTagName("solvable")
    ):
        installed = element.getAttribute("status") == "installed"
        if (installed_only and installed) or not installed_only:
            patches[element.getAttribute("name")] = {
                "installed": installed,
                "summary": element.getAttribute("summary"),
            }
    return patches
def list_patches(refresh=False, root=None, **kwargs):
    if refresh:
        refresh_db(root)
    return _get_patches(root=root)
def list_installed_patches(root=None, **kwargs):
    return _get_patches(installed_only=True, root=root)
def list_provides(root=None, **kwargs):
    ret = __context__.get("pkg.list_provides")
    if not ret:
        cmd = ["rpm"]
        if root:
            cmd.extend(["--root", root])
        cmd.extend(["-qa", "--queryformat", "%{PROVIDES}_|-%{NAME}\n"])
        ret = dict()
        for line in __salt__["cmd.run"](
            cmd, output_loglevel="trace", python_shell=False
        ).splitlines():
            provide, realname = line.split("_|-")
            if provide == realname:
                continue
            if provide not in ret:
                ret[provide] = list()
            ret[provide].append(realname)
        __context__["pkg.list_provides"] = ret
    return ret
def resolve_capabilities(pkgs, refresh=False, root=None, **kwargs):
    if refresh:
        refresh_db(root)
    ret = list()
    for pkg in pkgs:
        if isinstance(pkg, dict):
            name = next(iter(pkg))
            version = pkg[name]
        else:
            name = pkg
            version = None
        if kwargs.get("resolve_capabilities", False):
            try:
                search(name, root=root, match="exact")
            except CommandExecutionError:
                try:
                    result = search(name, root=root, provides=True, match="exact")
                    if len(result) == 1:
                        name = next(iter(result.keys()))
                    elif len(result) &gt; 1:
                        log.warning("Found ambiguous match for capability '%s'.", pkg)
                except CommandExecutionError as exc:
                    log.debug("Search failed with: %s", exc)
        if version:
            ret.append({name: version})
        else:
            ret.append(name)
    return ret
def services_need_restart(root=None, **kwargs):
    cmd = ["ps", "-sss"]
    zypper_output = __zypper__(root=root).nolock.call(*cmd)
    services = zypper_output.split()
    return services
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
