<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for win_system_1.py &amp; zypperpkg.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for win_system_1.py &amp; zypperpkg.py
      </h3>
<h1 align="center">
        2.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>win_system_1.py (4.569055%)<th>zypperpkg.py (1.5167184%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(801-839)<td><a href="#" name="0">(1415-1429)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1235-1287)<td><a href="#" name="1">(2194-2253)</a><td align="center"><font color="#c60000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(611-616)<td><a href="#" name="2">(124-132)</a><td align="center"><font color="#aa0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>win_system_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import ctypes
2 import logging
3 import platform
4 import time
5 from datetime import datetime
6 import salt.utils.functools
7 import salt.utils.locales
8 import salt.utils.platform
9 import salt.utils.win_system
10 import salt.utils.winapi
11 from salt.exceptions import CommandExecutionError
12 try:
13     import pywintypes
14     import win32api
15     import win32con
16     import win32net
17     import wmi
18     from ctypes import windll
19     HAS_WIN32NET_MODS = True
20 except ImportError:
21     HAS_WIN32NET_MODS = False
22 log = logging.getLogger(__name__)
23 __virtualname__ = "system"
24 def __virtual__():
25     if not salt.utils.platform.is_windows():
26         return False, "Module win_system: Requires Windows"
27     if not HAS_WIN32NET_MODS:
28         return False, "Module win_system: Missing win32 modules"
29     return __virtualname__
30 def _convert_minutes_seconds(timeout, in_seconds=False):
31     return timeout if in_seconds else timeout * 60
32 def _convert_date_time_string(dt_string):
33     dt_string = dt_string.split(".")[0]
34     dt_obj = datetime.strptime(dt_string, "%Y%m%d%H%M%S")
35     return dt_obj.strftime("%Y-%m-%d %H:%M:%S")
36 def halt(timeout=5, in_seconds=False):
37     return shutdown(timeout=timeout, in_seconds=in_seconds)
38 def init(runlevel):  # pylint: disable=unused-argument
39     return "Not implemented on Windows at this time."
40 def poweroff(timeout=5, in_seconds=False):
41     return shutdown(timeout=timeout, in_seconds=in_seconds)
42 def reboot(
43     timeout=5,
44     in_seconds=False,
45     wait_for_reboot=False,  # pylint: disable=redefined-outer-name
46     only_on_pending_reboot=False,
47 ):
48     ret = shutdown(
49         timeout=timeout,
50         reboot=True,
51         in_seconds=in_seconds,
52         only_on_pending_reboot=only_on_pending_reboot,
53     )
54     if wait_for_reboot:
55         seconds = _convert_minutes_seconds(timeout, in_seconds)
56         time.sleep(seconds + 30)
57     return ret
58 def shutdown(
59     message=None,
60     timeout=5,
61     force_close=True,
62     reboot=False,  # pylint: disable=redefined-outer-name
63     in_seconds=False,
64     only_on_pending_reboot=False,
65 ):
66     timeout = _convert_minutes_seconds(timeout, in_seconds)
67     if only_on_pending_reboot and not get_pending_reboot():
68         return False
69     if message and not isinstance(message, str):
70         message = message.decode("utf-8")
71     try:
72         win32api.InitiateSystemShutdown(
73             "127.0.0.1", message, timeout, force_close, reboot
74         )
75         return True
76     except pywintypes.error as exc:
77         (number, context, message) = exc.args
78         log.error("Failed to shutdown the system")
79         log.error("nbr: %s", number)
80         log.error("ctx: %s", context)
81         log.error("msg: %s", message)
82         return False
83 def shutdown_hard():
84     return shutdown(timeout=0)
85 def shutdown_abort():
86     try:
87         win32api.AbortSystemShutdown("127.0.0.1")
88         return True
89     except pywintypes.error as exc:
90         (number, context, message) = exc.args
91         log.error("Failed to abort system shutdown")
92         log.error("nbr: %s", number)
93         log.error("ctx: %s", context)
94         log.error("msg: %s", message)
95         return False
96 def lock():
97     return windll.user32.LockWorkStation()
98 def set_computer_name(name):
99     if windll.kernel32.SetComputerNameExW(
100         win32con.ComputerNamePhysicalDnsHostname, name
101     ):
102         ret = {"Computer Name": {"Current": get_computer_name()}}
103         pending = get_pending_computer_name()
104         if pending not in (None, False):
105             ret["Computer Name"]["Pending"] = pending
106         return ret
107     return False
108 def get_pending_computer_name():
109     return salt.utils.win_system.get_pending_computer_name()
110 def get_computer_name():
111     return salt.utils.win_system.get_computer_name()
112 def set_computer_desc(desc=None):
113     system_info = win32net.NetServerGetInfo(None, 101)
114     if desc is None:
115         return False
116     system_info["comment"] = desc
117     try:
118         win32net.NetServerSetInfo(None, 101, system_info)
119     except win32net.error as exc:
120         (number, context, message) = exc.args
121         log.error("Failed to update system")
122         log.error("nbr: %s", number)
123         log.error("ctx: %s", context)
124         log.error("msg: %s", message)
125         return False
126     return {"Computer Description": get_computer_desc()}
127 set_computer_description = salt.utils.functools.alias_function(
128     set_computer_desc, "set_computer_description"
129 )
130 def get_system_info():
131     def byte_calc(val):
132         val = float(val)
133         if val &lt; 2 ** 10:
134             return "{:.3f}B".format(val)
135         elif val &lt; 2 ** 20:
136             return "{:.3f}KB".format(val / 2 ** 10)
137         elif val &lt; 2 ** 30:
138             return "{:.3f}MB".format(val / 2 ** 20)
139         elif val &lt; 2 ** 40:
140             return "{:.3f}GB".format(val / 2 ** 30)
141         else:
142             return "{:.3f}TB".format(val / 2 ** 40)
143     os_type = {1: "Work Station", 2: "Domain Controller", 3: "Server"}
144     domain_role = {
145         0: "Standalone Workstation",
146         1: "Member Workstation",
147         2: "Standalone Server",
148         3: "Member Server",
149         4: "Backup Domain Controller",
150         5: "Primary Domain Controller",
151     }
152     warning_states = {
153         1: "Other",
154         2: "Unknown",
155         3: "Safe",
156         4: "Warning",
157         5: "Critical",
158         6: "Non-recoverable",
159     }
160     pc_system_types = {
161         0: "Unspecified",
162         1: "Desktop",
163         2: "Mobile",
164         3: "Workstation",
165         4: "Enterprise Server",
166         5: "SOHO Server",
167         6: "Appliance PC",
168         7: "Performance Server",
169         8: "Maximum",
170     }
171     with salt.utils.winapi.Com():
172         conn = wmi.WMI()
173         system = conn.Win32_OperatingSystem()[0]
174         ret = {
175             "name": get_computer_name(),
176             "description": system.Description,
177             "install_date": system.InstallDate,
178             "last_boot": system.LastBootUpTime,
179             "os_manufacturer": system.Manufacturer,
180             "os_name": system.Caption,
181             "users": system.NumberOfUsers,
182             "organization": system.Organization,
183             "os_architecture": system.OSArchitecture,
184             "primary": system.Primary,
185             "os_type": os_type[system.ProductType],
186             "registered_user": system.RegisteredUser,
187             "system_directory": system.SystemDirectory,
188             "system_drive": system.SystemDrive,
189             "os_version": system.Version,
190             "windows_directory": system.WindowsDirectory,
191         }
192         product = conn.Win32_ComputerSystemProduct()[0]
193         ret.update({"chassis_sku_number": product.SKUNumber})
194         system = conn.Win32_ComputerSystem()[0]
195         if platform.release() in ["Vista", "7", "8"]:
196             pc_system_type = pc_system_types[system.PCSystemType]
197         else:
198             pc_system_types.update({8: "Slate", 9: "Maximum"})
199             pc_system_type = pc_system_types[system.PCSystemType]
200         ret.update(
201             {
202                 "bootup_state": system.BootupState,
203                 "caption": system.Caption,
204                 "chassis_bootup_state": warning_states[system.ChassisBootupState],
205                 "dns_hostname": system.DNSHostname,
206                 "domain": system.Domain,
207                 "domain_role": domain_role[system.DomainRole],
208                 "hardware_manufacturer": system.Manufacturer,
209                 "hardware_model": system.Model,
210                 "network_server_mode_enabled": system.NetworkServerModeEnabled,
211                 "part_of_domain": system.PartOfDomain,
212                 "pc_system_type": pc_system_type,
213                 "power_state": system.PowerState,
214                 "status": system.Status,
215                 "system_type": system.SystemType,
216                 "total_physical_memory": byte_calc(system.TotalPhysicalMemory),
217                 "total_physical_memory_raw": system.TotalPhysicalMemory,
218                 "thermal_state": warning_states[system.ThermalState],
219                 "workgroup": system.Workgroup,
220         )
221         processors = conn.Win32_Processor<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>()
222         ret["processors"] = 0
223         ret["processors_logical"] = 0
224         ret["processor_cores"] = 0
225         ret["processor_cores_enabled"] = 0
226         ret["processor_manufacturer"] = processors[</b></font>0].Manufacturer
227         ret["processor_max_clock_speed"] = str(processors[0].MaxClockSpeed) + "MHz"
228         for processor in processors:
229             ret["processors"] += 1
230             ret["processors_logical"] += processor.NumberOfLogicalProcessors
231             ret["processor_cores"] += processor.NumberOfCores
232             try:
233                 ret["processor_cores_enabled"] += processor.NumberOfEnabledCore
234             except (AttributeError, TypeError):
235                 pass
236         if ret["processor_cores_enabled"] == 0:
237             ret.pop("processor_cores_enabled", False)
238         bios = conn.Win32_BIOS()[0]
239         ret.update(
240             {
241                 "hardware_serial": bios.SerialNumber,
242                 "bios_manufacturer": bios.Manufacturer,
243                 "bios_version": bios.Version,
244                 "bios_details": bios.BIOSVersion,
245                 "bios_caption": bios.Caption,
246                 "bios_description": bios.Description,
247             }
248         )
249         ret["install_date"] = _convert_date_time_string(ret["install_date"])
250         ret["last_boot"] = _convert_date_time_string(ret["last_boot"])
251     return ret
252 def get_computer_desc():
253     desc = get_system_info()["description"]
254     return False if desc is None else desc
255 get_computer_description = salt.utils.functools.alias_function(
256     get_computer_desc, "get_computer_description"
257 )
258 def get_hostname():
259     cmd = "hostname"
260     ret = __salt__["cmd.run"](cmd=cmd)
261     return ret
262 def set_hostname(hostname):
263     with salt.utils.winapi.Com():
264         conn = wmi.WMI()
265         comp = conn.Win32_ComputerSystem()[0]
266         return comp.Rename(Name=hostname)
267 def join_domain(
268     domain,
269     username=None,
270     password=None,
271     account_ou=None,
272     account_exists=False,
273     restart=False,
274 ):
275     status = get_domain_workgroup()
276     if "Domain" in status:
277         if status["Domain"] == domain:
278             return "Already joined to {}".format(domain)
279     if username and "\\" not in username and "@" not in username:
280         username = "{}@{}".format(username, domain)
281     if username and password is None:
282         return "Must specify a password if you pass a username"
283     if isinstance(account_ou, str):
284         account_ou = account_ou.split("\\")
285         account_ou = "".join(account_ou)
286     err = _join_domain(
287         domain=domain,
288         username=username,
289         password=password,
290         account_ou=account_ou,
291         account_exists=account_exists,
292     )
293     if not err:
294         ret = {"Domain": domain, "Restart": False}
295         if restart:
296         return ret
297     raise CommandExecutionError<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(win32api.FormatMessage(err).rstrip())
298 def _join_domain(
299     domain, username=None, password=None, account_ou=None, account_exists=False
300 ):
301     NETSETUP_JOIN_DOMAIN = 0x1  # pylint: disable=invalid-name
302     NETSETUP_ACCOUNT_CREATE = 0x2  # pylint: disable=invalid-name
303     NETSETUP_DOMAIN_JOIN_IF_JOINED = 0x20  # pylint: disable=invalid-name
304     NETSETUP_JOIN_WITH_NEW_NAME = 0x400  # pylint: disable=invalid-name
305     join_options = 0x0
306     join_options |= NETSETUP_JOIN_DOMAIN
307     join_options |=</b></font> NETSETUP_DOMAIN_JOIN_IF_JOINED
308     join_options |= NETSETUP_JOIN_WITH_NEW_NAME
309     if not account_exists:
310         join_options |= NETSETUP_ACCOUNT_CREATE
311     with salt.utils.winapi.Com():
312         conn = wmi.WMI()
313         comp = conn.Win32_ComputerSystem()[0]
314         return comp.JoinDomainOrWorkgroup(
315             Name=domain,
316             Password=password,
317             UserName=username,
318             AccountOU=account_ou,
319             FJoinOptions=join_options,
320         )[0]
321 def unjoin_domain(
322     username=None,
323     password=None,
324     domain=None,
325     workgroup="WORKGROUP",
326     disable=False,
327     restart=False,
328 ):
329     status = get_domain_workgroup()
330     if "Workgroup" in status:
331         if status["Workgroup"] == workgroup:
332             return "Already joined to {}".format(workgroup)
333     if username and "\\" not in username and "@" not in username:
334         if domain:
335             username = "{}@{}".format(username, domain)
336         else:
337             return "Must specify domain if not supplied in username"
338     if username and password is None:
339         return "Must specify a password if you pass a username"
340     NETSETUP_ACCT_DELETE = 0x4  # pylint: disable=invalid-name
341     unjoin_options = 0x0
342     if disable:
343         unjoin_options |= NETSETUP_ACCT_DELETE
344     with salt.utils.winapi.Com():
345         conn = wmi.WMI()
346         comp = conn.Win32_ComputerSystem()[0]
347         err = comp.UnjoinDomainOrWorkgroup(
348             Password=password, UserName=username, FUnjoinOptions=unjoin_options
349         )
350         if not err[0]:
351             err = comp.JoinDomainOrWorkgroup(Name=workgroup)
352             if not err[0]:
353                 ret = {"Workgroup": workgroup, "Restart": False}
354                 if restart:
355                     ret["Restart"] = reboot()
356                 return ret
357             else:
358                 log.error(win32api.FormatMessage(err[0]).rstrip())
359                 log.error("Failed to unjoin the computer from %s", workgroup)
360                 return False
361         else:
362             log.error(win32api.FormatMessage(err[0]).rstrip())
363             log.error("Failed to unjoin computer from %s", status["Domain"])
364             return False
365 def get_domain_workgroup():
366     with salt.utils.winapi.Com():
367         conn = wmi.WMI()
368         for computer in conn.Win32_ComputerSystem():
369             if computer.PartOfDomain:
370                 return {"Domain": computer.Domain}
371             else:
372                 return {"Workgroup": computer.Domain}
373 def set_domain_workgroup(workgroup):
374     with salt.utils.winapi.Com():
375         conn = wmi.WMI()
376         comp = conn.Win32_ComputerSystem()[0]
377         res = comp.JoinDomainOrWorkgroup(Name=workgroup.upper())
378     return True if not res[0] else False
379 def _try_parse_datetime(time_str, fmts):
380     result = None
381     for fmt in fmts:
382         try:
383             result = datetime.strptime(time_str, fmt)
384             break
385         except ValueError:
386             pass
387     return result
388 def get_system_time():
389     now = win32api.GetLocalTime()
390     meridian = "AM"
391     hours = int(now[4])
392     if hours == 12:
393         meridian = "PM"
394     elif hours == 0:
395         hours = 12
396     elif hours &gt; 12:
397         hours = hours - 12
398         meridian = "PM"
399     return "{:02d}:{:02d}:{:02d} {}".format(hours, now[5], now[6], meridian)
400 def set_system_time(newtime):
401     fmts = ["%I:%M:%S %p", "%I:%M %p", "%H:%M:%S", "%H:%M"]
402     dt_obj = _try_parse_datetime(newtime, fmts)
403     if dt_obj is None:
404         return False
405     return set_system_date_time(
406         hours=dt_obj.hour, minutes=dt_obj.minute, seconds=dt_obj.second
407     )
408 def set_system_date_time(
409     years=None, months=None, days=None, hours=None, minutes=None, seconds=None
410 ):
411     try:
412         date_time = win32api.GetLocalTime()
413     except win32api.error as exc:
414         (number, context, message) = exc.args
415         log.error("Failed to get local time")
416         log.error("nbr: %s", number)
417         log.error("ctx: %s", context)
418         log.error("msg: %s", message)
419         return False
420     if years is None:
421         years = date_time[0]
422     if months is None:
423         months = date_time[1]
424     if days is None:
425         days = date_time[3]
426     if hours is None:
427         hours = date_time[4]
428     if minutes is None:
429         minutes = date_time[5]
430     if seconds is None:
431         seconds = date_time[6]
432     try:
433         class SYSTEMTIME(ctypes.Structure):
434             _fields_ = [
435                 ("wYear", ctypes.c_int16),
436                 ("wMonth", ctypes.c_int16),
437                 ("wDayOfWeek", ctypes.c_int16),
438                 ("wDay", ctypes.c_int16),
439                 ("wHour", ctypes.c_int16),
440                 ("wMinute", ctypes.c_int16),
441                 ("wSecond", ctypes.c_int16),
442                 ("wMilliseconds", ctypes.c_int16),
443             ]
444         system_time = SYSTEMTIME()
445         system_time.wYear = int(years)
446         system_time.wMonth = int(months)
447         system_time.wDay = int(days)
448         system_time.wHour = int(hours)
449         system_time.wMinute = int(minutes)
450         system_time.wSecond = int(seconds)
451         system_time_ptr = ctypes.pointer(system_time)
452         succeeded = ctypes.windll.kernel32.SetLocalTime(system_time_ptr)
453         if succeeded != 0:
454             return True
455         else:
456             log.error("Failed to set local time")
457             raise CommandExecutionError(win32api.FormatMessage(succeeded).rstrip())
458     except OSError as err:
459         log.error("Failed to set local time")
460         raise CommandExecutionError(err)
461 def get_system_date():
462     now = win32api.GetLocalTime()
463     return "{:02d}/{:02d}/{:04d}".format(now[1], now[3], now[0])
464 def set_system_date(newdate):
465     fmts = ["%Y-%m-%d", "%m-%d-%Y", "%m-%d-%y", "%m/%d/%Y", "%m/%d/%y", "%Y/%m/%d"]
466     dt_obj = _try_parse_datetime(newdate, fmts)
467     if dt_obj is None:
468     return set_system_date_time(years=dt_obj.year, months=dt_obj.month, days=dt_obj.<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>day)
469 def start_time_service():
470     return __salt__["service.start"]("w32time")
471 def stop_time_service():
472     return __salt__["service.stop"]("w32time")
473 def get_pending_component_servicing():
474     return salt.</b></font>utils.win_system.get_pending_component_servicing()
475 def get_pending_domain_join():
476     return salt.utils.win_system.get_pending_domain_join()
477 def get_pending_file_rename():
478     return salt.utils.win_system.get_pending_file_rename()
479 def get_pending_servermanager():
480     return salt.utils.win_system.get_pending_servermanager()
481 def get_pending_update():
482     return salt.utils.win_system.get_pending_update()
483 def set_reboot_required_witnessed():
484     r"""
485     This function is used to remember that an event indicating that a reboot is
486     required was witnessed. This function relies on the salt-minion's ability to
487     create the following volatile registry key in the *HKLM* hive:
488        *SYSTEM\\CurrentControlSet\\Services\\salt-minion\\Volatile-Data*
489     Because this registry key is volatile, it will not persist beyond the
490     current boot session. Also, in the scope of this key, the name *'Reboot
491     required'* will be assigned the value of *1*.
492     For the time being, this function is being used whenever an install
493     completes with exit code 3010 and can be extended where appropriate in the
494     future.
495     .. versionadded:: 2016.11.0
496     Returns:
497         bool: ``True`` if successful, otherwise ``False``
498     CLI Example:
499     .. code-block:: bash
500         salt '*' system.set_reboot_required_witnessed
501     Determine if at any time during the current boot session the salt minion
502     witnessed an event indicating that a reboot is required.
503     This function will return ``True`` if an install completed with exit
504     code 3010 during the current boot session and can be extended where
505     appropriate in the future.
506     .. versionadded:: 2016.11.0
507     Returns:
508         bool: ``True`` if the ``Requires reboot`` registry flag is set to ``1``,
509         otherwise ``False``
510     CLI Example:
511     .. code-block:: bash
512         salt '*' system.get_reboot_required_witnessed
513     Determine whether there is a reboot pending.
514     .. versionadded:: 2016.11.0
515     Returns:
516         bool: ``True`` if the system is pending reboot, otherwise ``False``
517     CLI Example:
518     .. code-block:: bash
519         salt '*' system.get_pending_reboot
520     Determine which check is signalling that the system is pending a reboot.
521     Useful in determining why your system is signalling that it needs a reboot.
522     .. versionadded:: 3001
523     Returns:
524         dict: A dictionary of the results of each system that would indicate a
525         pending reboot
526     CLI Example:
527     .. code-block:: bash
528         salt '*' system.get_pending_reboot_details
529     Check the Windows Update system for a pending reboot state.
530     This leverages the Windows Update System to determine if the system is
531     pending a reboot.
532     .. versionadded:: 3001
533     Returns:
534         bool: ``True`` if the Windows Update system reports a pending update,
535         otherwise ``False``
536     CLI Example:
537     .. code-block:: bash
538         salt '*' system.get_pending_windows_update
539 Package support for openSUSE via the zypper package manager
540 :depends: - ``rpm`` Python module.  Install with ``zypper install rpm-python``
541 .. important::
542     If you feel that Salt should be using this module to manage packages on a
543     minion, and it is using a different module (or gives an error similar to
544     *'pkg.install' is not available*), see :ref:`here
545     &lt;module-provider-override&gt;`.
546 """
547 import configparser
548 import datetime
549 import fnmatch
550 import logging
551 import os
552 import re
553 import time
554 import urllib.parse
555 from xml.dom import minidom as dom
556 from xml.parsers.expat import ExpatError
557 import salt.utils.data
558 import salt.utils.environment
559 import salt.utils.event
560 import salt.utils.files
561 import salt.utils.functools
562 import salt.utils.path
563 import salt.utils.pkg
564 import salt.utils.pkg.rpm
565 import salt.utils.stringutils
566 import salt.utils.systemd
567 import salt.utils.versions
568 from salt.exceptions import CommandExecutionError, MinionError, SaltInvocationError
569 from salt.utils.versions import LooseVersion
570 log = logging.getLogger(__name__)
571 HAS_ZYPP = False
572 ZYPP_HOME = "/etc/zypp"
573 LOCKS = "{}/locks".format(ZYPP_HOME)
574 REPOS = "{}/repos.d".format(ZYPP_HOME)
575 DEFAULT_PRIORITY = 99
576 PKG_ARCH_SEPARATOR = "."
577 __virtualname__ = "pkg"
578 def __virtual__():
579     if __grains__.get("os_family", "") != "Suse":
580         return (
581             False,
582             "Module zypper: non SUSE OS not supported by zypper package manager",
583         )
584     if not salt.utils.path.which("zypper"):
585         return (False, "Module zypper: zypper package manager not found")
586     return __virtualname__
587 class _Zypper:
588     SUCCESS_EXIT_CODES = {
589         0: "Successful run of zypper with no special info.",
590         100: "Patches are available for installation.",
591         101: "Security patches are available for installation.",
592         102: "Installation successful, reboot required.",
593         103: "Installation successful, restart of the package manager itself required.",
594     }
595     WARNING_EXIT_CODES = {
596         6: "No repositories are defined.",
597         7: "The ZYPP library is locked.",
598         106: (
599             "Some repository had to be disabled temporarily because it failed to"
600             " refresh. You should check your repository configuration (e.g. zypper ref"
601             " -f)."
602         ),
603         107: (
604             "Installation basically succeeded, but some of the packages %post install"
605             " scripts returned an error. These packages were successfully unpacked to"
606             " disk and are registered in the rpm database, but due to the failed"
607             " install script they may not work as expected. The failed scripts output"
608             " might reveal what actually went wrong. Any scripts output is also logged"
609             " to /var/log/zypp/history."
610         ),
611     }
612     LOCK_EXIT_CODE = 7
613     XML_DIRECTIVES = ["-x", "--xmlout"]
614     ZYPPER_LOCK = "/var/run/zypp.pid"
615     TAG_RELEASED = "zypper/released"
616     TAG_BLOCKED = "zypper/blocked"
617     def __init__(self):
618         self._reset()
619     def _reset(self):
620         self.__cmd = ["zypper", "--non-interactive"]
621         self.__call_result = dict()
622         self.__error_msg = ""
623         self.__env = salt.utils.environment.get_module_environment(globals<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>())
624         self.__xml = False
625         self.__no_lock = False
626         self.__no_raise = False
627         self.__refresh = False
628         self.__ignore_repo_failure = False
629         self.</b></font>__systemd_scope = False
630         self.__root = None
631         self.__called = False
632     def __call__(self, *args, **kwargs):
633         if self.__called:
634             self._reset()
635         if "no_repo_failure" in kwargs:
636             self.__ignore_repo_failure = kwargs["no_repo_failure"]
637         if "systemd_scope" in kwargs:
638             self.__systemd_scope = kwargs["systemd_scope"]
639         if "root" in kwargs:
640             self.__root = kwargs["root"]
641         return self
642     def __getattr__(self, item):
643         if self.__called:
644             self._reset()
645         if item == "xml":
646             self.__xml = True
647         elif item == "nolock":
648             self.__no_lock = True
649         elif item == "noraise":
650             self.__no_raise = True
651         elif item == "refreshable":
652             self.__refresh = True
653         elif item == "call":
654             return self.__call
655         else:
656             return self.__dict__[item]
657         if self.__no_lock:
658             self.__no_lock = not self.__refresh
659         return self
660     @property
661     def exit_code(self):
662         return self.__exit_code
663     @exit_code.setter
664     def exit_code(self, exit_code):
665         self.__exit_code = int(exit_code or "0")
666     @property
667     def error_msg(self):
668         return self.__error_msg
669     @error_msg.setter
670     def error_msg(self, msg):
671         if self._is_error():
672             self.__error_msg = msg and os.linesep.join(msg) or "Check Zypper's logs."
673     @property
674     def stdout(self):
675         return self.__call_result.get("stdout", "")
676     @property
677     def stderr(self):
678         return self.__call_result.get("stderr", "")
679     @property
680     def pid(self):
681         return self.__call_result.get("pid", "")
682     def _is_error(self):
683         if self.exit_code:
684             msg = self.SUCCESS_EXIT_CODES.get(self.exit_code)
685             if msg:
686                 log.info(msg)
687             msg = self.WARNING_EXIT_CODES.get(self.exit_code)
688             if msg:
689                 log.warning(msg)
690         return (
691             self.exit_code not in self.SUCCESS_EXIT_CODES
692             and self.exit_code not in self.WARNING_EXIT_CODES
693         )
694     def _is_lock(self):
695         return self.exit_code == self.LOCK_EXIT_CODE
696     def _is_xml_mode(self):
697         return (
698             [itm for itm in self.XML_DIRECTIVES if itm in self.__cmd] and True or False
699         )
700     def _check_result(self):
701         if not self.__call_result:
702             raise CommandExecutionError("No output result from Zypper?")
703         self.exit_code = self.__call_result["retcode"]
704         if self._is_lock():
705             return False
706         if self._is_error():
707             _error_msg = list()
708             if not self._is_xml_mode():
709                 msg = (
710                     self.__call_result["stderr"]
711                     and self.__call_result["stderr"].strip()
712                     or ""
713                 )
714                 if msg:
715                     _error_msg.append(msg)
716             else:
717                 try:
718                     doc = dom.parseString(self.__call_result["stdout"])
719                 except ExpatError as err:
720                     log.error(err)
721                     doc = None
722                 if doc:
723                     msg_nodes = doc.getElementsByTagName("message")
724                     for node in msg_nodes:
725                         if node.getAttribute("type") == "error":
726                             _error_msg.append(node.childNodes[0].nodeValue)
727                 elif self.__call_result["stderr"].strip():
728                     _error_msg.append(self.__call_result["stderr"].strip())
729             self.error_msg = _error_msg
730         return True
731     def __call(self, *args, **kwargs):
732         self.__called = True
733         if self.__xml:
734             self.__cmd.append("--xmlout")
735         if not self.__refresh and "--no-refresh" not in args:
736             self.__cmd.append("--no-refresh")
737         if self.__root:
738             self.__cmd.extend(["--root", self.__root])
739         self.__cmd.extend(args)
740         kwargs["output_loglevel"] = "trace"
741         kwargs["python_shell"] = False
742         kwargs["env"] = self.__env.copy()
743         if self.__no_lock:
744             kwargs["env"][
745                 "ZYPP_READONLY_HACK"
746             ] = (  # Disables locking for read-only operations. Do not try that at home!
747                 "1"
748             )
749         was_blocked = False
750         while True:
751             cmd = []
752             if self.__systemd_scope:
753                 cmd.extend(["systemd-run", "--scope"])
754             cmd.extend(self.__cmd)
755             log.debug("Calling Zypper: %s", " ".join(cmd))
756             self.__call_result = __salt__["cmd.run_all"](cmd, **kwargs)
757             if self._check_result():
758                 break
759             if os.path.exists(self.ZYPPER_LOCK):
760                 try:
761                     with salt.utils.files.fopen(self.ZYPPER_LOCK) as rfh:
762                         data = __salt__["ps.proc_info"](
763                             int(rfh.readline()),
764                             attrs=["pid", "name", "cmdline", "create_time"],
765                         )
766                         data["cmdline"] = " ".join(data["cmdline"])
767                         data["info"] = "Blocking process created at {}.".format(
768                             datetime.datetime.utcfromtimestamp(
769                                 data["create_time"]
770                             ).isoformat()
771                         )
772                         data["success"] = True
773                 except Exception as err:  # pylint: disable=broad-except
774                     data = {
775                         "info": (
776                             "Unable to retrieve information about blocking process: {}".format(
777                                 err.message
778                             )
779                         ),
780                         "success": False,
781                     }
782             else:
783                 data = {
784                     "info": "Zypper is locked, but no Zypper lock has been found.",
785                     "success": False,
786                 }
787             if not data["success"]:
788                 log.debug("Unable to collect data about blocking process.")
789             else:
790                 log.debug("Collected data about blocking process.")
791             __salt__["event.fire_master"](data, self.TAG_BLOCKED)
792             log.debug(
793                 "Fired a Zypper blocked event to the master with the data: %s", data
794             )
795             log.debug("Waiting 5 seconds for Zypper gets released...")
796             time.sleep(5)
797             if not was_blocked:
798                 was_blocked = True
799         if was_blocked:
800             __salt__["event.fire_master"](
801                 {
802                     "success": not self.error_msg,
803                     "info": self.error_msg or "Zypper has been released",
804                 },
805                 self.TAG_RELEASED,
806             )
807         if self.error_msg and not self.__no_raise and not self.__ignore_repo_failure:
808             raise CommandExecutionError(
809                 "Zypper command failure: {}".format(self.error_msg)
810             )
811         return (
812             self._is_xml_mode()
813             and dom.parseString(
814                 salt.utils.stringutils.to_str(self.__call_result["stdout"])
815             )
816             or self.__call_result["stdout"]
817         )
818 __zypper__ = _Zypper()
819 class Wildcard:
820     Z_OP = ["&lt;", "&lt;=", "=", "&gt;=", "&gt;"]
821     def __init__(self, zypper):
822         self.name = None
823         self.version = None
824         self.zypper = zypper
825         self._attr_solvable_version = "edition"
826         self._op = None
827     def __call__(self, pkg_name, pkg_version):
828         if pkg_version:
829             self.name = pkg_name
830             self._set_version(pkg_version)  # Dissects possible operator
831             versions = sorted(
832                 LooseVersion(vrs)
833                 for vrs in self._get_scope_versions(self._get_available_versions())
834             )
835             return versions and "{}{}".format(self._op or "", versions[-1]) or None
836     def _get_available_versions(self):
837         solvables = self.zypper.nolock.xml.call(
838             "se", "-xv", self.name
839         ).getElementsByTagName("solvable")
840         if not solvables:
841             raise CommandExecutionError(
842                 "No packages found matching '{}'".format(self.name)
843             )
844         return sorted(
845             {
846                 slv.getAttribute(self._attr_solvable_version)
847                 for slv in solvables
848                 if slv.getAttribute(self._attr_solvable_version)
849             }
850         )
851     def _get_scope_versions(self, pkg_versions):
852         get_in_versions = []
853         for p_version in pkg_versions:
854             if fnmatch.fnmatch(p_version, self.version):
855                 get_in_versions.append(p_version)
856         return get_in_versions
857     def _set_version(self, version):
858         if not version:
859             return
860         exact_version = re.sub(r"[&lt;&gt;=+]*", "", version)
861         self._op = version.replace(exact_version, "") or None
862         if self._op and self._op not in self.Z_OP:
863             raise CommandExecutionError(
864                 'Zypper do not supports operator "{}".'.format(self._op)
865             )
866         self.version = exact_version
867 def _systemd_scope():
868     return salt.utils.systemd.has_scope(__context__) and __salt__["config.get"](
869         "systemd.scope", True
870     )
871 def _clean_cache():
872     keys = []
873     for cache_name in ["pkg.list_pkgs", "pkg.list_provides"]:
874         for contextkey in __context__:
875             if contextkey.startswith(cache_name):
876                 keys.append(contextkey)
877     for key in keys:
878         __context__.pop(key, None)
879 def list_upgrades(refresh=True, root=None, **kwargs):
880     if refresh:
881         refresh_db(root)
882     ret = dict()
883     cmd = ["list-updates"]
884     if "fromrepo" in kwargs:
885         repos = kwargs["fromrepo"]
886         if isinstance(repos, str):
887             repos = [repos]
888         for repo in repos:
889             cmd.extend(["--repo", repo if isinstance(repo, str) else str(repo)])
890         log.debug("Targeting repos: %s", repos)
891     for update_node in (
892         __zypper__(root=root).nolock.xml.call(*cmd).getElementsByTagName("update")
893     ):
894         if update_node.getAttribute("kind") == "package":
895             ret[update_node.getAttribute("name")] = update_node.getAttribute("edition")
896     return ret
897 list_updates = salt.utils.functools.alias_function(list_upgrades, "list_updates")
898 def info_installed(*names, **kwargs):
899     all_versions = kwargs.get("all_versions", False)
900     ret = dict()
901     for pkg_name, pkgs_nfo in __salt__["lowpkg.info"](*names, **kwargs).items():
902         pkg_nfo = pkgs_nfo if all_versions else [pkgs_nfo]
903         for _nfo in pkg_nfo:
904             t_nfo = dict()
905             for key, value in _nfo.items():
906                 if key == "source_rpm":
907                     t_nfo["source"] = value
908                 else:
909                     t_nfo[key] = value
910             if not all_versions:
911                 ret[pkg_name] = t_nfo
912             else:
913                 ret.setdefault(pkg_name, []).append(t_nfo)
914     return ret
915 def info_available(*names, **kwargs):
916     ret = {}
917     if not names:
918         return ret
919     else:
920         names = sorted(list(set(names)))
921     root = kwargs.get("root", None)
922     if kwargs.get("refresh", True):
923         refresh_db(root)
924     pkg_info = []
925     batch = names[:]
926     batch_size = 200
927     while batch:
928         pkg_info.extend(
929             re.split(
930                 r"Information for package*",
931                 __zypper__(root=root).nolock.call(
932                     "info", "-t", "package", *batch[:batch_size]
933                 ),
934             )
935         )
936         batch = batch[batch_size:]
937     for pkg_data in pkg_info:
938         nfo = {}
939         for line in [data for data in pkg_data.split("\n") if ":" in data]:
940             if line.startswith("-----"):
941                 continue
942             kw = [data.strip() for data in line.split(":", 1)]
943             if len(kw) == 2 and kw[1]:
944                 nfo[kw[0].lower()] = kw[1]
945         if nfo.get("name"):
946             name = nfo.pop("name")
947             ret[name] = nfo
948         if nfo.get("status"):
949             nfo["status"] = nfo.get("status")
950         if nfo.get("installed"):
951             nfo["installed"] = nfo.get("installed").lower().startswith("yes")
952     return ret
953 def parse_arch(name):
954     _name, _arch = None, None
955     try:
956         _name, _arch = name.rsplit(PKG_ARCH_SEPARATOR, 1)
957     except ValueError:
958         pass
959     if _arch not in salt.utils.pkg.rpm.ARCHES + ("noarch",):
960         _name = name
961         _arch = None
962     return {"name": _name, "arch": _arch}
963 def latest_version(*names, **kwargs):
964     ret = dict()
965     if not names:
966         return ret
967     names = sorted(list(set(names)))
968     package_info = info_available(*names, **kwargs)
969     for name in names:
970         pkg_info = package_info.get(name, {})
971         status = pkg_info.get("status", "").lower()
972         if status.find("not installed") &gt; -1 or status.find("out-of-date") &gt; -1:
973             ret[name] = pkg_info.get("version")
974         else:
975             ret[name] = ""
976     if len(names) == 1 and ret:
977         return ret[names[0]]
978     return ret
979 available_version = salt.utils.functools.alias_function(
980     latest_version, "available_version"
981 )
982 def upgrade_available(name, **kwargs):
983     return not not latest_version(name, **kwargs)  # pylint: disable=C0113
984 def version(*names, **kwargs):
985     return __salt__["pkg_resource.version"](*names, **kwargs) or {}
986 def version_cmp(ver1, ver2, ignore_epoch=False, **kwargs):
987     return __salt__["lowpkg.version_cmp"](ver1, ver2, ignore_epoch=ignore_epoch)
988 def _list_pkgs_from_context(versions_as_list, contextkey, attr):
989     return __salt__["pkg_resource.format_pkg_list"](
990         __context__[contextkey], versions_as_list, attr
991     )
992 def list_pkgs(versions_as_list=False, root=None, includes=None, **kwargs):
993     versions_as_list = salt.utils.data.is_true(versions_as_list)
994     if any(
995         [salt.utils.data.is_true(kwargs.get(x)) for x in ("removed", "purge_desired")]
996     ):
997         return {}
998     attr = kwargs.get("attr")
999     if attr is not None:
1000         attr = salt.utils.args.split_input(attr)
1001     includes = includes if includes else []
1002     contextkey = "pkg.list_pkgs_{}_{}".format(root, includes)
1003     if contextkey in __context__ and kwargs.get("use_context", True):
1004         return _list_pkgs_from_context(versions_as_list, contextkey, attr)
1005     ret = {}
1006     cmd = ["rpm"]
1007     if root:
1008         cmd.extend(["--root", root])
1009     cmd.extend(
1010         [
1011             "-qa",
1012             "--queryformat",
1013             salt.utils.pkg.rpm.QUERYFORMAT.replace("%{REPOID}", "(none)") + "\n",
1014         ]
1015     )
1016     output = __salt__["cmd.run"](cmd, python_shell=False, output_loglevel="trace")
1017     for line in output.splitlines():
1018         pkginfo = salt.utils.pkg.rpm.parse_pkginfo(line, osarch=__grains__["osarch"])
1019         if pkginfo:
1020             pkgver = pkginfo.version
1021             epoch = None
1022             release = None
1023             if ":" in pkgver:
1024                 epoch, pkgver = pkgver.split(":", 1)
1025             if "-" in pkgver:
1026                 pkgver, release = pkgver.split("-", 1)
1027             all_attr = {
1028                 "epoch": epoch,
1029                 "version": pkgver,
1030                 "release": release,
1031                 "arch": pkginfo.arch,
1032                 "install_date": pkginfo.install_date,
1033                 "install_date_time_t": pkginfo.install_date_time_t,
1034             }
1035             __salt__["pkg_resource.add_pkg"](ret, pkginfo.name, all_attr)
1036     _ret = {}
1037     for pkgname in ret:
1038         if pkgname.startswith("gpg-pubkey"):
1039             continue
1040         _ret[pkgname] = sorted(ret[pkgname], key=lambda d: d["version"])
1041     for include in includes:
1042         if include == "product":
1043             products = list_products(all=False, root=root)
1044             for product in products:
1045                 extended_name = "{}:{}".format(include, product["name"])
1046                 _ret[extended_name] = [
1047                     {
1048                         "epoch": product["epoch"],
1049                         "version": product["version"],
1050                         "release": product["release"],
1051                         "arch": product["arch"],
1052                         "install_date": None,
1053                         "install_date_time_t": None,
1054                     }
1055                 ]
1056         if include in ("pattern", "patch"):
1057             if include == "pattern":
1058                 elements = list_installed_patterns(root=root)
1059             elif include == "patch":
1060                 elements = list_installed_patches(root=root)
1061             else:
1062                 elements = []
1063             for element in elements:
1064                 extended_name = "{}:{}".format(include, element)
1065                 info = info_available(extended_name, refresh=False, root=root)
1066                 _ret[extended_name] = [
1067                     {
1068                         "epoch": None,
1069                         "version": info[element]["version"],
1070                         "release": None,
1071                         "arch": info[element]["arch"],
1072                         "install_date": None,
1073                         "install_date_time_t": None,
1074                     }
1075                 ]
1076     __context__[contextkey] = _ret
1077     return __salt__["pkg_resource.format_pkg_list"](
1078         __context__[contextkey], versions_as_list, attr
1079     )
1080 def list_repo_pkgs(*args, **kwargs):
1081     byrepo = kwargs.pop("byrepo", False)
1082     fromrepo = kwargs.pop("fromrepo", "") or ""
1083     ret = {}
1084     targets = [arg if isinstance(arg, str) else str(arg) for arg in args]
1085     def _is_match(pkgname):
1086         if not args:
1087             return True
1088         for target in targets:
1089             if fnmatch.fnmatch(pkgname, target):
1090                 return True
1091         return False
1092     root = kwargs.get("root") or None
1093     for node in (
1094         __zypper__(root=root)
1095         .xml.call("se", "-s", *targets)
1096         .getElementsByTagName("solvable")
1097     ):
1098         pkginfo = dict(node.attributes.items())
1099         try:
1100             if pkginfo["kind"] != "package":
1101                 continue
1102             reponame = pkginfo["repository"]
1103             if fromrepo and reponame != fromrepo:
1104                 continue
1105             pkgname = pkginfo["name"]
1106             pkgversion = pkginfo["edition"]
1107         except KeyError:
1108             continue
1109         else:
1110             if _is_match(pkgname):
1111                 repo_dict = ret.setdefault(reponame, {})
1112                 version_list = repo_dict.setdefault(pkgname, set())
1113                 version_list.add(pkgversion)
1114     if byrepo:
1115         for reponame in ret:
1116             for pkgname in ret[reponame]:
1117                 sorted_versions = sorted(
1118                     (LooseVersion(x) for x in ret[reponame][pkgname]), reverse=True
1119                 )
1120                 ret[reponame][pkgname] = [x.vstring for x in sorted_versions]
1121         return ret
1122     else:
1123         byrepo_ret = {}
1124         for reponame in ret:
1125             for pkgname in ret[reponame]:
1126                 byrepo_ret.setdefault(pkgname, []).extend(ret[reponame][pkgname])
1127         for pkgname in byrepo_ret:
1128             sorted_versions = sorted(
1129                 (LooseVersion(x) for x in byrepo_ret[pkgname]), reverse=True
1130             )
1131             byrepo_ret[pkgname] = [x.vstring for x in sorted_versions]
1132         return byrepo_ret
1133 def _get_configured_repos(root=None):
1134     repos = os.path.join(root, os.path.relpath(REPOS, os.path.sep)) if root else REPOS
1135     repos_cfg = configparser.ConfigParser()
1136     if os.path.exists(repos):
1137         repos_cfg.read(
1138             [
1139                 repos + "/" + fname
1140                 for fname in os.listdir(repos)
1141                 if fname.endswith(".repo")
1142             ]
1143         )
1144     else:
1145         log.warning("Repositories not found in %s", repos)
1146     return repos_cfg
1147 def _get_repo_info(alias, repos_cfg=None, root=None):
1148     try:
1149         meta = dict((repos_cfg or _get_configured_repos(root=root)).items(alias))
1150         meta["alias"] = alias
1151         for key, val in meta.items():
1152             if val in ["0", "1"]:
1153                 meta[key] = int(meta[key]) == 1
1154             elif val == "NONE":
1155                 meta[key] = None
1156         return meta
1157     except (ValueError, configparser.NoSectionError):
1158         return {}
1159 def get_repo(repo, root=None, **kwargs):  # pylint: disable=unused-argument
1160     return _get_repo_info(repo, root=root)
1161 def list_repos(root=None, **kwargs):
1162     repos_cfg = _get_configured_repos(root=root)
1163     all_repos = {}
1164     for alias in repos_cfg.sections():
1165         all_repos[alias] = _get_repo_info(alias, repos_cfg=repos_cfg, root=root)
1166     return all_repos
1167 def del_repo(repo, root=None):
1168     repos_cfg = _get_configured_repos(root=root)
1169     for alias in repos_cfg.sections():
1170         if alias == repo:
1171             doc = __zypper__(root=root).xml.call(
1172                 "rr", "--loose-auth", "--loose-query", alias
1173             )
1174             msg = doc.getElementsByTagName("message")
1175             if doc.getElementsByTagName("progress") and msg:
1176                 return {
1177                     repo: True,
1178                     "message": msg[0].childNodes[0].nodeValue,
1179                 }
1180     raise CommandExecutionError("Repository '{}' not found.".format(repo))
1181 def mod_repo(repo, **kwargs):
1182     root = kwargs.get("root") or None
1183     repos_cfg = _get_configured_repos(root=root)
1184     added = False
1185     if repo not in repos_cfg.sections():
1186         url = kwargs.get("url", kwargs.get("mirrorlist", kwargs.get("baseurl")))
1187         if not url:
1188             raise CommandExecutionError(
1189                 "Repository '{}' not found, and neither 'baseurl' nor "
1190                 "'mirrorlist' was specified".format(repo)
1191             )
1192         if not urllib.parse.urlparse(url).scheme:
1193             raise CommandExecutionError(
1194                 "Repository '{}' not found and URL for baseurl/mirrorlist "
1195                 "is malformed".format(repo)
1196             )
1197         for alias in repos_cfg.sections():
1198             repo_meta = _get_repo_info(alias, repos_cfg=repos_cfg, root=root)
1199             new_url = urllib.parse.urlparse(url)
1200             if not new_url.path:
1201                 new_url = urllib.parse.urlparse.ParseResult(
1202                     scheme=new_url.scheme,  # pylint: disable=E1123
1203                     netloc=new_url.netloc,
1204                     path="/",
1205                     params=new_url.params,
1206                     query=new_url.query,
1207                     fragment=new_url.fragment,
1208                 )
1209             base_url = urllib.parse.urlparse(repo_meta["baseurl"])
1210             if new_url == base_url:
1211                 raise CommandExecutionError(
1212                     "Repository '{}' already exists as '{}'.".format(repo, alias)
1213                 )
1214         __zypper__(root=root).xml.call("ar", url, repo)
1215         repos_cfg = _get_configured_repos(root=root)
1216         if repo not in repos_cfg.sections():
1217             raise CommandExecutionError(
1218                 "Failed add new repository '{}' for unspecified reason. "
1219                 "Please check zypper logs.".format(repo)
1220             )
1221         added = True
1222     repo_info = _get_repo_info(repo, root=root)
1223     if (
1224         not added
1225         and "baseurl" in kwargs
1226         and not (kwargs["baseurl"] == repo_info["baseurl"])
1227     ):
1228         repo_info.update(kwargs)
1229         repo_info.setdefault("cache", False)
1230         del_repo(repo, root=root)
1231         return mod_repo(repo, root=root, **repo_info)
1232     cmd_opt = []
1233     global_cmd_opt = []
1234     call_refresh = False
1235     if "enabled" in kwargs:
1236         cmd_opt.append(kwargs["enabled"] and "--enable" or "--disable")
1237     if "refresh" in kwargs:
1238         cmd_opt.append(kwargs["refresh"] and "--refresh" or "--no-refresh")
1239     if "cache" in kwargs:
1240         cmd_opt.append(kwargs["cache"] and "--keep-packages" or "--no-keep-packages")
1241     if "gpgcheck" in kwargs:
1242         cmd_opt.append(kwargs["gpgcheck"] and "--gpgcheck" or "--no-gpgcheck")
1243     if "priority" in kwargs:
1244         cmd_opt.append("--priority={}".format(kwargs.get("priority", DEFAULT_PRIORITY)))
1245     if "humanname" in kwargs:
1246         cmd_opt.append("--name='{}'".format(kwargs.get("humanname")))
1247     if kwargs.get("gpgautoimport") is True:
1248         global_cmd_opt.append("--gpg-auto-import-keys")
1249         call_refresh = True
1250     if cmd_opt:
1251         cmd_opt = global_cmd_opt + ["mr"] + cmd_opt + [repo]
1252         __zypper__(root=root).refreshable.xml.call(*cmd_opt)
1253     comment = None
1254     if call_refresh:
1255         refresh_opts = global_cmd_opt + ["refresh"] + [repo]
1256         __zypper__(root=root).xml.call(*refresh_opts)
1257     elif not added and not cmd_opt:
1258         comment = "Specified arguments did not result in modification of repo"
1259     repo = get_repo(repo, root=root)
1260     if comment:
1261         repo["comment"] = comment
1262     return repo
1263 def refresh_db(force=None, root=None):
1264     salt.utils.pkg.clear_rtag(__opts__)
1265     ret = {}
1266     refresh_opts = ["refresh"]
1267     if force is None:
1268         force = __pillar__.get("zypper", {}).get("refreshdb_force", True)
1269     if force:
1270         refresh_opts.append("--force")
1271     out = __zypper__(root=root).refreshable.call(*refresh_opts)
1272     for line in out.splitlines():
1273         if not line:
1274             continue
1275         if line.strip().startswith("Repository") and "'" in line:
1276             try:
1277                 key = line.split("'")[1].strip()
1278                 if "is up to date" in line:
1279                     ret[key] = False
1280             except IndexError:
1281                 continue
1282         elif line.strip().startswith("Building") and "'" in line:
1283             key = line.split("'")[1].strip()
1284             if "done" in line:
1285                 ret[key] = True
1286     return ret
1287 def _find_types(pkgs):
1288     return sorted({pkg.split<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(":", 1)[0] for pkg in pkgs if len(pkg.split(":", 1)) == 2})
1289 def install(
1290     name=None,
1291     refresh=False,
1292     fromrepo=None,
1293     pkgs=None,
1294     sources=None,
1295     downloadonly=None,
1296     skip_verify=False,
1297     version=None,
1298     ignore_repo_failure=False,
1299     no_recommends=False,
1300     root=</b></font>None,
1301     **kwargs
1302 ):
1303     if refresh:
1304         refresh_db(root)
1305     try:
1306         pkg_params, pkg_type = __salt__["pkg_resource.parse_targets"](
1307             name, pkgs, sources, **kwargs
1308         )
1309     except MinionError as exc:
1310         raise CommandExecutionError(exc)
1311     if pkg_params is None or len(pkg_params) == 0:
1312         return {}
1313     version_num = Wildcard(__zypper__(root=root))(name, version)
1314     if version_num:
1315         if pkgs is None and sources is None:
1316             pkg_params = {name: version_num}
1317         else:
1318             log.warning(
1319                 '"version" parameter will be ignored for multiple package targets'
1320             )
1321     if pkg_type == "repository":
1322         targets = []
1323         for param, version_num in pkg_params.items():
1324             if version_num is None:
1325                 log.debug("targeting package: %s", param)
1326                 targets.append(param)
1327             else:
1328                 prefix, verstr = salt.utils.pkg.split_comparison(version_num)
1329                 if not prefix:
1330                     prefix = "="
1331                 target = "{}{}{}".format(param, prefix, verstr)
1332                 log.debug("targeting package: %s", target)
1333                 targets.append(target)
1334     elif pkg_type == "advisory":
1335         targets = []
1336         cur_patches = list_patches(root=root)
1337         for advisory_id in pkg_params:
1338             if advisory_id not in cur_patches:
1339                 raise CommandExecutionError(
1340                     'Advisory id "{}" not found'.format(advisory_id)
1341                 )
1342             else:
1343                 targets.append(advisory_id)
1344     else:
1345         targets = pkg_params
1346     diff_attr = kwargs.get("diff_attr")
1347     includes = _find_types(targets)
1348     old = (
1349         list_pkgs(attr=diff_attr, root=root, includes=includes)
1350         if not downloadonly
1351         else list_downloaded(root)
1352     )
1353     downgrades = []
1354     if fromrepo:
1355         fromrepoopt = ["--force", "--force-resolution", "--from", fromrepo]
1356         log.info("Targeting repo '%s'", fromrepo)
1357     else:
1358         fromrepoopt = ""
1359     cmd_install = ["install", "--auto-agree-with-licenses"]
1360     cmd_install.append(
1361         kwargs.get("resolve_capabilities") and "--capability" or "--name"
1362     )
1363     if not refresh:
1364         cmd_install.insert(0, "--no-refresh")
1365     if skip_verify:
1366         cmd_install.insert(0, "--no-gpg-checks")
1367     if downloadonly:
1368         cmd_install.append("--download-only")
1369     if fromrepo:
1370         cmd_install.extend(fromrepoopt)
1371     if no_recommends:
1372         cmd_install.append("--no-recommends")
1373     errors = []
1374     if pkg_type == "advisory":
1375         targets = ["patch:{}".format(t) for t in targets]
1376     systemd_scope = _systemd_scope()
1377     while targets:
1378         cmd = cmd_install + targets[:500]
1379         targets = targets[500:]
1380         for line in (
1381             __zypper__(
1382                 no_repo_failure=ignore_repo_failure,
1383                 systemd_scope=systemd_scope,
1384                 root=root,
1385             )
1386             .call(*cmd)
1387             .splitlines()
1388         ):
1389             match = re.match(
1390                 r"^The selected package '([^']+)'.+has lower version", line
1391             )
1392             if match:
1393                 downgrades.append(match.group(1))
1394     while downgrades:
1395         cmd = cmd_install + ["--force"] + downgrades[:500]
1396         downgrades = downgrades[500:]
1397         __zypper__(no_repo_failure=ignore_repo_failure, root=root).call(*cmd)
1398     _clean_cache()
1399     new = (
1400         list_pkgs(attr=diff_attr, root=root, includes=includes)
1401         if not downloadonly
1402         else list_downloaded(root)
1403     )
1404     ret = salt.utils.data.compare_dicts(old, new)
1405     if includes:
1406         _clean_cache()
1407     if errors:
1408         raise CommandExecutionError(
1409             "Problem encountered {} package(s)".format(
1410                 "downloading" if downloadonly else "installing"
1411             ),
1412             info={"errors": errors, "changes": ret},
1413         )
1414     return ret
1415 def upgrade(
1416     refresh=True,
1417     dryrun=False,
1418     dist_upgrade=False,
1419     fromrepo=None,
1420     novendorchange=False,
1421     skip_verify=False,
1422     no_recommends=False,
1423     root=None,
1424     **kwargs
1425 ):  # pylint: disable=unused-argument
1426     cmd_update = (["dist-upgrade"] if dist_upgrade else ["update"]) + [
1427         "--auto-agree-with-licenses"
1428     ]
1429     if skip_verify:
1430         cmd_update.insert(0, "--no-gpg-checks")
1431     if refresh:
1432         refresh_db(root)
1433     if dryrun:
1434         cmd_update.append("--dry-run")
1435     if fromrepo:
1436         if isinstance(fromrepo, str):
1437             fromrepo = [fromrepo]
1438         for repo in fromrepo:
1439             cmd_update.extend(["--from" if dist_upgrade else "--repo", repo])
1440         log.info("Targeting repos: %s", fromrepo)
1441     if dist_upgrade:
1442         if novendorchange:
1443             if __grains__["osrelease_info"][0] &gt; 11:
1444                 cmd_update.append("--no-allow-vendor-change")
1445                 log.info("Disabling vendor changes")
1446             else:
1447                 log.warning(
1448                     "Disabling vendor changes is not supported on this Zypper version"
1449                 )
1450         if no_recommends:
1451             cmd_update.append("--no-recommends")
1452             log.info("Disabling recommendations")
1453         if dryrun:
1454             log.info("Executing debugsolver and performing a dry-run dist-upgrade")
1455             __zypper__(systemd_scope=_systemd_scope(), root=root).noraise.call(
1456                 *cmd_update + ["--debug-solver"]
1457             )
1458     old = list_pkgs(root=root)
1459     __zypper__(systemd_scope=_systemd_scope(), root=root).noraise.call(*cmd_update)
1460     _clean_cache()
1461     new = list_pkgs(root=root)
1462     ret = salt.utils.data.compare_dicts(old, new)
1463     if __zypper__.exit_code not in __zypper__.SUCCESS_EXIT_CODES:
1464         result = {
1465             "retcode": __zypper__.exit_code,
1466             "stdout": __zypper__.stdout,
1467             "stderr": __zypper__.stderr,
1468             "pid": __zypper__.pid,
1469         }
1470         raise CommandExecutionError(
1471             "Problem encountered upgrading packages",
1472             info={"changes": ret, "result": result},
1473         )
1474     if dryrun:
1475         ret = (__zypper__.stdout + os.linesep + __zypper__.stderr).strip()
1476     return ret
1477 def _uninstall(name=None, pkgs=None, root=None):
1478     try:
1479         pkg_params = __salt__["pkg_resource.parse_targets"](name, pkgs)[0]
1480     except MinionError as exc:
1481         raise CommandExecutionError(exc)
1482     includes = _find_types(pkg_params.keys())
1483     old = list_pkgs(root=root, includes=includes)
1484     targets = []
1485     for target in pkg_params:
1486         if target in old and pkg_params[target] in old[target].split(","):
1487             targets.append(target + "-" + pkg_params[target])
1488         elif target in old and not pkg_params[target]:
1489             targets.append(target)
1490     if not targets:
1491         return {}
1492     systemd_scope = _systemd_scope()
1493     errors = []
1494     while targets:
1495         __zypper__(systemd_scope=systemd_scope, root=root).call(
1496             "remove", *targets[:500]
1497         )
1498         targets = targets[500:]
1499     _clean_cache()
1500     new = list_pkgs(root=root, includes=includes)
1501     ret = salt.utils.data.compare_dicts(old, new)
1502     if errors:
1503         raise CommandExecutionError(
1504             "Problem encountered removing package(s)",
1505             info={"errors": errors, "changes": ret},
1506         )
1507     return ret
1508 def normalize_name(name):
1509     try:
1510         arch = name.rsplit(".", 1)[-1]
1511         if arch not in salt.utils.pkg.rpm.ARCHES + ("noarch",):
1512             return name
1513     except ValueError:
1514         return name
1515     if arch in (__grains__["osarch"], "noarch") or salt.utils.pkg.rpm.check_32(
1516         arch, osarch=__grains__["osarch"]
1517     ):
1518         return name[: -(len(arch) + 1)]
1519     return name
1520 def remove(
1521     name=None, pkgs=None, root=None, **kwargs
1522 ):  # pylint: disable=unused-argument
1523     return _uninstall(name=name, pkgs=pkgs, root=root)
1524 def purge(name=None, pkgs=None, root=None, **kwargs):  # pylint: disable=unused-argument
1525     return _uninstall(name=name, pkgs=pkgs, root=root)
1526 def list_locks(root=None):
1527     locks = {}
1528     _locks = os.path.join(root, os.path.relpath(LOCKS, os.path.sep)) if root else LOCKS
1529     try:
1530         with salt.utils.files.fopen(_locks) as fhr:
1531             items = salt.utils.stringutils.to_unicode(fhr.read()).split("\n\n")
1532             for meta in [item.split("\n") for item in items]:
1533                 lock = {}
1534                 for element in [el for el in meta if el]:
1535                     if ":" in element:
1536                         lock.update(
1537                             dict([tuple(i.strip() for i in element.split(":", 1))])
1538                         )
1539                 if lock.get("solvable_name"):
1540                     locks[lock.pop("solvable_name")] = lock
1541     except OSError:
1542         pass
1543     except Exception:  # pylint: disable=broad-except
1544         log.warning("Detected a problem when accessing %s", _locks)
1545     return locks
1546 def clean_locks(root=None):
1547     LCK = "removed"
1548     out = {LCK: 0}
1549     locks = os.path.join(root, os.path.relpath(LOCKS, os.path.sep)) if root else LOCKS
1550     if not os.path.exists(locks):
1551         return out
1552     for node in __zypper__(root=root).xml.call("cl").getElementsByTagName("message"):
1553         text = node.childNodes[0].nodeValue.lower()
1554         if text.startswith(LCK):
1555             out[LCK] = text.split(" ")[1]
1556             break
1557     return out
1558 def unhold(name=None, pkgs=None, **kwargs):
1559     ret = {}
1560     if not name and not pkgs:
1561         raise CommandExecutionError("Name or packages must be specified.")
1562     targets = []
1563     if pkgs:
1564         for pkg in salt.utils.data.repack_dictlist(pkgs):
1565             targets.append(pkg)
1566     else:
1567         targets.append(name)
1568     locks = list_locks()
1569     removed = []
1570     missing = []
1571     for target in targets:
1572         ret[target] = {"name": target, "changes": {}, "result": True, "comment": ""}
1573         if locks.get(target):
1574             removed.append(target)
1575             ret[target]["changes"]["new"] = ""
1576             ret[target]["changes"]["old"] = "hold"
1577             ret[target]["comment"] = "Package {} is no longer held.".format(target)
1578         else:
1579             missing.append(target)
1580             ret[target]["comment"] = "Package {} was already unheld.".format(target)
1581     if removed:
1582         __zypper__.call("rl", *removed)
1583     return ret
1584 def hold(name=None, pkgs=None, **kwargs):
1585     ret = {}
1586     if not name and not pkgs:
1587         raise CommandExecutionError("Name or packages must be specified.")
1588     targets = []
1589     if pkgs:
1590         for pkg in salt.utils.data.repack_dictlist(pkgs):
1591             targets.append(pkg)
1592     else:
1593         targets.append(name)
1594     locks = list_locks()
1595     added = []
1596     for target in targets:
1597         ret[target] = {"name": target, "changes": {}, "result": True, "comment": ""}
1598         if not locks.get(target):
1599             added.append(target)
1600             ret[target]["changes"]["new"] = "hold"
1601             ret[target]["changes"]["old"] = ""
1602             ret[target]["comment"] = "Package {} is now being held.".format(target)
1603         else:
1604             ret[target]["comment"] = "Package {} is already set to be held.".format(
1605                 target
1606             )
1607         __zypper__.call("al", *added)
1608     r<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>eturn ret
1609 def verify(*names, **kwargs):
1610     return __salt__["lowpkg.verify"](*names, **kwargs)
1611 def file_list(*packages, **kwargs):
1612     return __salt__["lowpkg.file_list"](*packages, **kwargs)
1613 def file_dict(*packages, **kwargs):
1614     return __salt__[</b></font>"lowpkg.file_dict"](*packages, **kwargs)
1615 def modified(*packages, **flags):
1616     return __salt__["lowpkg.modified"](*packages, **flags)
1617 def owner(*paths, **kwargs):
1618     return __salt__["lowpkg.owner"](*paths, **kwargs)
1619 def _get_visible_patterns(root=None):
1620     patterns = {}
1621     search_patterns = __zypper__(root=root).nolock.xml.call("se", "-t", "pattern")
1622     for element in search_patterns.getElementsByTagName("solvable"):
1623         installed = element.getAttribute("status") == "installed"
1624         patterns[element.getAttribute("name")] = {
1625             "installed": installed,
1626             "summary": element.getAttribute("summary"),
1627         }
1628     return patterns
1629 def _get_installed_patterns(root=None):
1630     def _pattern_name(capability):
1631         return capability.split("=")[-1].strip()
1632     cmd = ["rpm"]
1633     if root:
1634         cmd.extend(["--root", root])
1635     cmd.extend(["-q", "--provides", "--whatprovides", "pattern()"])
1636     output = __salt__["cmd.run"](cmd, ignore_retcode=True)
1637     installed_patterns = {
1638         _pattern_name(line)
1639         for line in output.splitlines()
1640         if line.startswith("pattern() = ") and not _pattern_name(line).startswith(".")
1641     }
1642     patterns = {
1643         k: v for k, v in _get_visible_patterns(root=root).items() if v["installed"]
1644     }
1645     for pattern in installed_patterns:
1646         if pattern not in patterns:
1647             patterns[pattern] = {
1648                 "installed": True,
1649                 "summary": "Non-visible pattern",
1650             }
1651     return patterns
1652 def list_patterns(refresh=False, root=None):
1653     if refresh:
1654         refresh_db(root)
1655     return _get_visible_patterns(root=root)
1656 def list_installed_patterns(root=None):
1657     return _get_installed_patterns(root=root)
1658 def search(criteria, refresh=False, **kwargs):
1659     ALLOWED_SEARCH_OPTIONS = {
1660         "provides": "--provides",
1661         "recommends": "--recommends",
1662         "requires": "--requires",
1663         "suggests": "--suggests",
1664         "conflicts": "--conflicts",
1665         "obsoletes": "--obsoletes",
1666         "file_list": "--file-list",
1667         "search_descriptions": "--search-descriptions",
1668         "case_sensitive": "--case-sensitive",
1669         "installed_only": "--installed-only",
1670         "not_installed_only": "-u",
1671         "details": "--details",
1672     }
1673     root = kwargs.get("root", None)
1674     if refresh:
1675         refresh_db(root)
1676     cmd = ["search"]
1677     if kwargs.get("match") == "exact":
1678         cmd.append("--match-exact")
1679     elif kwargs.get("match") == "words":
1680         cmd.append("--match-words")
1681     elif kwargs.get("match") == "substrings":
1682         cmd.append("--match-substrings")
1683     for opt in kwargs:
1684         if opt in ALLOWED_SEARCH_OPTIONS:
1685             cmd.append(ALLOWED_SEARCH_OPTIONS.get(opt))
1686     cmd.append(criteria)
1687     solvables = (
1688         __zypper__(root=root)
1689         .nolock.noraise.xml.call(*cmd)
1690         .getElementsByTagName("solvable")
1691     )
1692     if not solvables:
1693         raise CommandExecutionError("No packages found matching '{}'".format(criteria))
1694     out = {}
1695     for solvable in solvables:
1696         out[solvable.getAttribute("name")] = dict()
1697         for k, v in solvable.attributes.items():
1698             out[solvable.getAttribute("name")][k] = v
1699     return out
1700 def _get_first_aggregate_text(node_list):
1701     if not node_list:
1702         return ""
1703     out = []
1704     for node in node_list[0].childNodes:
1705         if node.nodeType == dom.Document.TEXT_NODE:
1706             out.append(node.nodeValue)
1707     return "\n".join(out)
1708 def list_products(all=False, refresh=False, root=None):
1709     if refresh:
1710         refresh_db(root)
1711     ret = list()
1712     OEM_PATH = "/var/lib/suseRegister/OEM"
1713     if root:
1714         OEM_PATH = os.path.join(root, os.path.relpath(OEM_PATH, os.path.sep))
1715     cmd = list()
1716     if not all:
1717         cmd.append("--disable-repositories")
1718     cmd.append("products")
1719     if not all:
1720         cmd.append("-i")
1721     product_list = (
1722         __zypper__(root=root).nolock.xml.call(*cmd).getElementsByTagName("product-list")
1723     )
1724     if not product_list:
1725         return ret  # No products found
1726     for prd in product_list[0].getElementsByTagName("product"):
1727         p_nfo = dict()
1728         for k_p_nfo, v_p_nfo in prd.attributes.items():
1729             if k_p_nfo in ["isbase", "installed"]:
1730                 p_nfo[k_p_nfo] = bool(v_p_nfo in ["true", "1"])
1731             elif v_p_nfo:
1732                 p_nfo[k_p_nfo] = v_p_nfo
1733         eol = prd.getElementsByTagName("endoflife")
1734         if eol:
1735             p_nfo["eol"] = eol[0].getAttribute("text")
1736             p_nfo["eol_t"] = int(eol[0].getAttribute("time_t") or 0)
1737         p_nfo["description"] = " ".join(
1738             [
1739                 line.strip()
1740                 for line in _get_first_aggregate_text(
1741                     prd.getElementsByTagName("description")
1742                 ).split(os.linesep)
1743             ]
1744         )
1745         if "productline" in p_nfo and p_nfo["productline"]:
1746             oem_file = os.path.join(OEM_PATH, p_nfo["productline"])
1747             if os.path.isfile(oem_file):
1748                 with salt.utils.files.fopen(oem_file, "r") as rfile:
1749                     oem_release = salt.utils.stringutils.to_unicode(
1750                         rfile.readline()
1751                     ).strip()
1752                     if oem_release:
1753                         p_nfo["release"] = oem_release
1754         ret.append(p_nfo)
1755     return ret
1756 def download(*packages, **kwargs):
1757     if not packages:
1758         raise SaltInvocationError("No packages specified")
1759     root = kwargs.get("root", None)
1760     refresh = kwargs.get("refresh", False)
1761     if refresh:
1762         refresh_db(root)
1763     pkg_ret = {}
1764     for dld_result in (
1765         __zypper__(root=root)
1766         .xml.call("download", *packages)
1767         .getElementsByTagName("download-result")
1768     ):
1769         repo = dld_result.getElementsByTagName("repository")[0]
1770         path = dld_result.getElementsByTagName("localfile")[0].getAttribute("path")
1771         pkg_info = {
1772             "repository-name": repo.getAttribute("name"),
1773             "repository-alias": repo.getAttribute("alias"),
1774             "path": path,
1775         }
1776         key = _get_first_aggregate_text(dld_result.getElementsByTagName("name"))
1777         if __salt__["lowpkg.checksum"](pkg_info["path"], root=root):
1778             pkg_ret[key] = pkg_info
1779     if pkg_ret:
1780         failed = [pkg for pkg in packages if pkg not in pkg_ret]
1781         if failed:
1782             pkg_ret[
1783                 "_error"
1784             ] = "The following package(s) failed to download: {}".format(
1785                 ", ".join(failed)
1786             )
1787         return pkg_ret
1788     raise CommandExecutionError(
1789         "Unable to download packages: {}".format(", ".join(packages))
1790     )
1791 def list_downloaded(root=None, **kwargs):
1792     CACHE_DIR = "/var/cache/zypp/packages/"
1793     if root:
1794         CACHE_DIR = os.path.join(root, os.path.relpath(CACHE_DIR, os.path.sep))
1795     ret = {}
1796     for root, dirnames, filenames in salt.utils.path.os_walk(CACHE_DIR):
1797         for filename in fnmatch.filter(filenames, "*.rpm"):
1798             package_path = os.path.join(root, filename)
1799             pkg_info = __salt__["lowpkg.bin_pkg_info"](package_path)
1800             pkg_timestamp = int(os.path.getctime(package_path))
1801             ret.setdefault(pkg_info["name"], {})[pkg_info["version"]] = {
1802                 "path": package_path,
1803                 "size": os.path.getsize(package_path),
1804                 "creation_date_time_t": pkg_timestamp,
1805                 "creation_date_time": datetime.datetime.utcfromtimestamp(
1806                     pkg_timestamp
1807                 ).isoformat(),
1808             }
1809     return ret
1810 def diff(*paths, **kwargs):
1811     ret = {}
1812     pkg_to_paths = {}
1813     for pth in paths:
1814         pth_pkg = __salt__["lowpkg.owner"](pth, **kwargs)
1815         if not pth_pkg:
1816             ret[pth] = os.path.exists(pth) and "Not managed" or "N/A"
1817         else:
1818             if pkg_to_paths.get(pth_pkg) is None:
1819                 pkg_to_paths[pth_pkg] = []
1820             pkg_to_paths[pth_pkg].append(pth)
1821     if pkg_to_paths:
1822         local_pkgs = __salt__["pkg.download"](*pkg_to_paths.keys(), **kwargs)
1823         for pkg, files in pkg_to_paths.items():
1824             for path in files:
1825                 ret[path] = (
1826                     __salt__["lowpkg.diff"](local_pkgs[pkg]["path"], path)
1827                     or "Unchanged"
1828                 )
1829     return ret
1830 def _get_patches(installed_only=False, root=None):
1831     patches = {}
1832     for element in (
1833         __zypper__(root=root)
1834         .nolock.xml.call("se", "-t", "patch")
1835         .getElementsByTagName("solvable")
1836     ):
1837         installed = element.getAttribute("status") == "installed"
1838         if (installed_only and installed) or not installed_only:
1839             patches[element.getAttribute("name")] = {
1840                 "installed": installed,
1841                 "summary": element.getAttribute("summary"),
1842             }
1843     return patches
1844 def list_patches(refresh=False, root=None, **kwargs):
1845     if refresh:
1846         refresh_db(root)
1847     return _get_patches(root=root)
1848 def list_installed_patches(root=None, **kwargs):
1849     return _get_patches(installed_only=True, root=root)
1850 def list_provides(root=None, **kwargs):
1851     ret = __context__.get("pkg.list_provides")
1852     if not ret:
1853         cmd = ["rpm"]
1854         if root:
1855             cmd.extend(["--root", root])
1856         cmd.extend(["-qa", "--queryformat", "%{PROVIDES}_|-%{NAME}\n"])
1857         ret = dict()
1858         for line in __salt__["cmd.run"](
1859             cmd, output_loglevel="trace", python_shell=False
1860         ).splitlines():
1861             provide, realname = line.split("_|-")
1862             if provide == realname:
1863                 continue
1864             if provide not in ret:
1865                 ret[provide] = list()
1866             ret[provide].append(realname)
1867         __context__["pkg.list_provides"] = ret
1868     return ret
1869 def resolve_capabilities(pkgs, refresh=False, root=None, **kwargs):
1870     if refresh:
1871         refresh_db(root)
1872     ret = list()
1873     for pkg in pkgs:
1874         if isinstance(pkg, dict):
1875             name = next(iter(pkg))
1876             version = pkg[name]
1877         else:
1878             name = pkg
1879             version = None
1880         if kwargs.get("resolve_capabilities", False):
1881             try:
1882                 search(name, root=root, match="exact")
1883             except CommandExecutionError:
1884                 try:
1885                     result = search(name, root=root, provides=True, match="exact")
1886                     if len(result) == 1:
1887                         name = next(iter(result.keys()))
1888                     elif len(result) &gt; 1:
1889                         log.warning("Found ambiguous match for capability '%s'.", pkg)
1890                 except CommandExecutionError as exc:
1891                     log.debug("Search failed with: %s", exc)
1892         if version:
1893             ret.append({name: version})
1894         else:
1895             ret.append(name)
1896     return ret
1897 def services_need_restart(root=None, **kwargs):
1898     cmd = ["ps", "-sss"]
1899     zypper_output = __zypper__(root=root).nolock.call(*cmd)
1900     services = zypper_output.split()
1901     return services
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
