<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for win_system_1.py &amp; zypperpkg.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for win_system_1.py &amp; zypperpkg.py
      </h3>
<h1 align="center">
        2.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>win_system_1.py (4.569055%)<th>zypperpkg.py (1.5167184%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(801-839)<td><a href="#" name="0">(1415-1429)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1235-1287)<td><a href="#" name="1">(2194-2253)</a><td align="center"><font color="#c60000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(611-616)<td><a href="#" name="2">(124-132)</a><td align="center"><font color="#aa0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>win_system_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import ctypes
2 import logging
3 import platform
4 import time
5 from datetime import datetime
6 import salt.utils.functools
7 import salt.utils.locales
8 import salt.utils.platform
9 import salt.utils.win_system
10 import salt.utils.winapi
11 from salt.exceptions import CommandExecutionError
12 try:
13     import pywintypes
14     import win32api
15     import win32con
16     import win32net
17     import wmi
18     from ctypes import windll
19     HAS_WIN32NET_MODS = True
20 except ImportError:
21     HAS_WIN32NET_MODS = False
22 log = logging.getLogger(__name__)
23 __virtualname__ = "system"
24 def __virtual__():
25     if not salt.utils.platform.is_windows():
26         return False, "Module win_system: Requires Windows"
27     if not HAS_WIN32NET_MODS:
28         return False, "Module win_system: Missing win32 modules"
29     return __virtualname__
30 def _convert_minutes_seconds(timeout, in_seconds=False):
31     return timeout if in_seconds else timeout * 60
32 def _convert_date_time_string(dt_string):
33     dt_string = dt_string.split(".")[0]
34     dt_obj = datetime.strptime(dt_string, "%Y%m%d%H%M%S")
35     return dt_obj.strftime("%Y-%m-%d %H:%M:%S")
36 def halt(timeout=5, in_seconds=False):
37     return shutdown(timeout=timeout, in_seconds=in_seconds)
38 def init(runlevel):  # pylint: disable=unused-argument
39     return "Not implemented on Windows at this time."
40 def poweroff(timeout=5, in_seconds=False):
41     return shutdown(timeout=timeout, in_seconds=in_seconds)
42 def reboot(
43     timeout=5,
44     in_seconds=False,
45     wait_for_reboot=False,  # pylint: disable=redefined-outer-name
46     only_on_pending_reboot=False,
47 ):
48     ret = shutdown(
49         timeout=timeout,
50         reboot=True,
51         in_seconds=in_seconds,
52         only_on_pending_reboot=only_on_pending_reboot,
53     )
54     if wait_for_reboot:
55         seconds = _convert_minutes_seconds(timeout, in_seconds)
56         time.sleep(seconds + 30)
57     return ret
58 def shutdown(
59     message=None,
60     timeout=5,
61     force_close=True,
62     reboot=False,  # pylint: disable=redefined-outer-name
63     in_seconds=False,
64     only_on_pending_reboot=False,
65 ):
66     timeout = _convert_minutes_seconds(timeout, in_seconds)
67     if only_on_pending_reboot and not get_pending_reboot():
68         return False
69     if message and not isinstance(message, str):
70         message = message.decode("utf-8")
71     try:
72         win32api.InitiateSystemShutdown(
73             "127.0.0.1", message, timeout, force_close, reboot
74         )
75         return True
76     except pywintypes.error as exc:
77         (number, context, message) = exc.args
78         log.error("Failed to shutdown the system")
79         log.error("nbr: %s", number)
80         log.error("ctx: %s", context)
81         log.error("msg: %s", message)
82         return False
83 def shutdown_hard():
84     return shutdown(timeout=0)
85 def shutdown_abort():
86     try:
87         win32api.AbortSystemShutdown("127.0.0.1")
88         return True
89     except pywintypes.error as exc:
90         (number, context, message) = exc.args
91         log.error("Failed to abort system shutdown")
92         log.error("nbr: %s", number)
93         log.error("ctx: %s", context)
94         log.error("msg: %s", message)
95         return False
96 def lock():
97     return windll.user32.LockWorkStation()
98 def set_computer_name(name):
99     if windll.kernel32.SetComputerNameExW(
100         win32con.ComputerNamePhysicalDnsHostname, name
101     ):
102         ret = {"Computer Name": {"Current": get_computer_name()}}
103         pending = get_pending_computer_name()
104         if pending not in (None, False):
105             ret["Computer Name"]["Pending"] = pending
106         return ret
107     return False
108 def get_pending_computer_name():
109     return salt.utils.win_system.get_pending_computer_name()
110 def get_computer_name():
111     return salt.utils.win_system.get_computer_name()
112 def set_computer_desc(desc=None):
113     system_info = win32net.NetServerGetInfo(None, 101)
114     if desc is None:
115         return False
116     system_info["comment"] = desc
117     try:
118         win32net.NetServerSetInfo(None, 101, system_info)
119     except win32net.error as exc:
120         (number, context, message) = exc.args
121         log.error("Failed to update system")
122         log.error("nbr: %s", number)
123         log.error("ctx: %s", context)
124         log.error("msg: %s", message)
125         return False
126     return {"Computer Description": get_computer_desc()}
127 set_computer_description = salt.utils.functools.alias_function(
128     set_computer_desc, "set_computer_description"
129 )
130 def get_system_info():
131     def byte_calc(val):
132         val = float(val)
133         if val &lt; 2 ** 10:
134             return "{:.3f}B".format(val)
135         elif val &lt; 2 ** 20:
136             return "{:.3f}KB".format(val / 2 ** 10)
137         elif val &lt; 2 ** 30:
138             return "{:.3f}MB".format(val / 2 ** 20)
139         elif val &lt; 2 ** 40:
140             return "{:.3f}GB".format(val / 2 ** 30)
141         else:
142             return "{:.3f}TB".format(val / 2 ** 40)
143     os_type = {1: "Work Station", 2: "Domain Controller", 3: "Server"}
144     domain_role = {
145         0: "Standalone Workstation",
146         1: "Member Workstation",
147         2: "Standalone Server",
148         3: "Member Server",
149         4: "Backup Domain Controller",
150         5: "Primary Domain Controller",
151     }
152     warning_states = {
153         1: "Other",
154         2: "Unknown",
155         3: "Safe",
156         4: "Warning",
157         5: "Critical",
158         6: "Non-recoverable",
159     }
160     pc_system_types = {
161         0: "Unspecified",
162         1: "Desktop",
163         2: "Mobile",
164         3: "Workstation",
165         4: "Enterprise Server",
166         5: "SOHO Server",
167         6: "Appliance PC",
168         7: "Performance Server",
169         8: "Maximum",
170     }
171     with salt.utils.winapi.Com():
172         conn = wmi.WMI()
173         system = conn.Win32_OperatingSystem()[0]
174         ret = {
175             "name": get_computer_name(),
176             "description": system.Description,
177             "install_date": system.InstallDate,
178             "last_boot": system.LastBootUpTime,
179             "os_manufacturer": system.Manufacturer,
180             "os_name": system.Caption,
181             "users": system.NumberOfUsers,
182             "organization": system.Organization,
183             "os_architecture": system.OSArchitecture,
184             "primary": system.Primary,
185             "os_type": os_type[system.ProductType],
186             "registered_user": system.RegisteredUser,
187             "system_directory": system.SystemDirectory,
188             "system_drive": system.SystemDrive,
189             "os_version": system.Version,
190             "windows_directory": system.WindowsDirectory,
191         }
192         product = conn.Win32_ComputerSystemProduct()[0]
193         ret.update({"chassis_sku_number": product.SKUNumber})
194         system = conn.Win32_ComputerSystem()[0]
195         if platform.release() in ["Vista", "7", "8"]:
196             pc_system_type = pc_system_types[system.PCSystemType]
197         else:
198             pc_system_types.update({8: "Slate", 9: "Maximum"})
199             pc_system_type = pc_system_types[system.PCSystemType]
200         ret.update(
201             {
202                 "bootup_state": system.BootupState,
203                 "caption": system.Caption,
204                 "chassis_bootup_state": warning_states[system.ChassisBootupState],
205                 "dns_hostname": system.DNSHostname,
206                 "domain": system.Domain,
207                 "domain_role": domain_role[system.DomainRole],
208                 "hardware_manufacturer": system.Manufacturer,
209                 "hardware_model": system.Model,
210                 "network_server_mode_enabled": system.NetworkServerModeEnabled,
211                 "part_of_domain": system.PartOfDomain,
212                 "pc_system_type": pc_system_type,
213                 "power_state": system.PowerState,
214                 "status": system.Status,
215                 "system_type": system.SystemType,
216                 "total_physical_memory": byte_calc(system.TotalPhysicalMemory),
217                 "total_physical_memory_raw": system.TotalPhysicalMemory,
218                 "thermal_state": warning_states[system.ThermalState],
219                 "workgroup": system.Workgroup,
220 <a name="2"></a>            }
221         )
222         processors = conn.Win32_Processor<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>()
223         ret["processors"] = 0
224         ret["processors_logical"] = 0
225         ret["processor_cores"] = 0
226         ret["processor_cores_enabled"] = 0
227         ret["processor_manufacturer"] = processors[</b></font>0].Manufacturer
228         ret["processor_max_clock_speed"] = str(processors[0].MaxClockSpeed) + "MHz"
229         for processor in processors:
230             ret["processors"] += 1
231             ret["processors_logical"] += processor.NumberOfLogicalProcessors
232             ret["processor_cores"] += processor.NumberOfCores
233             try:
234                 ret["processor_cores_enabled"] += processor.NumberOfEnabledCore
235             except (AttributeError, TypeError):
236                 pass
237         if ret["processor_cores_enabled"] == 0:
238             ret.pop("processor_cores_enabled", False)
239         bios = conn.Win32_BIOS()[0]
240         ret.update(
241             {
242                 "hardware_serial": bios.SerialNumber,
243                 "bios_manufacturer": bios.Manufacturer,
244                 "bios_version": bios.Version,
245                 "bios_details": bios.BIOSVersion,
246                 "bios_caption": bios.Caption,
247                 "bios_description": bios.Description,
248             }
249         )
250         ret["install_date"] = _convert_date_time_string(ret["install_date"])
251         ret["last_boot"] = _convert_date_time_string(ret["last_boot"])
252     return ret
253 def get_computer_desc():
254     desc = get_system_info()["description"]
255     return False if desc is None else desc
256 get_computer_description = salt.utils.functools.alias_function(
257     get_computer_desc, "get_computer_description"
258 )
259 def get_hostname():
260     cmd = "hostname"
261     ret = __salt__["cmd.run"](cmd=cmd)
262     return ret
263 def set_hostname(hostname):
264     with salt.utils.winapi.Com():
265         conn = wmi.WMI()
266         comp = conn.Win32_ComputerSystem()[0]
267         return comp.Rename(Name=hostname)
268 def join_domain(
269     domain,
270     username=None,
271     password=None,
272     account_ou=None,
273     account_exists=False,
274     restart=False,
275 ):
276     status = get_domain_workgroup()
277     if "Domain" in status:
278         if status["Domain"] == domain:
279             return "Already joined to {}".format(domain)
280     if username and "\\" not in username and "@" not in username:
281         username = "{}@{}".format(username, domain)
282     if username and password is None:
283         return "Must specify a password if you pass a username"
284     if isinstance(account_ou, str):
285         account_ou = account_ou.split("\\")
286         account_ou = "".join(account_ou)
287     err = _join_domain(
288         domain=domain,
289         username=username,
290         password=password,
291         account_ou=account_ou,
292         account_exists=account_exists,
293     )
294     if not err:
295         ret = {"Domain": domain, "Restart": False}
296         if restart:
297 <a name="0"></a>            ret["Restart"] = reboot()
298         return ret
299     raise CommandExecutionError<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(win32api.FormatMessage(err).rstrip())
300 def _join_domain(
301     domain, username=None, password=None, account_ou=None, account_exists=False
302 ):
303     NETSETUP_JOIN_DOMAIN = 0x1  # pylint: disable=invalid-name
304     NETSETUP_ACCOUNT_CREATE = 0x2  # pylint: disable=invalid-name
305     NETSETUP_DOMAIN_JOIN_IF_JOINED = 0x20  # pylint: disable=invalid-name
306     NETSETUP_JOIN_WITH_NEW_NAME = 0x400  # pylint: disable=invalid-name
307     join_options = 0x0
308     join_options |= NETSETUP_JOIN_DOMAIN
309     join_options |=</b></font> NETSETUP_DOMAIN_JOIN_IF_JOINED
310     join_options |= NETSETUP_JOIN_WITH_NEW_NAME
311     if not account_exists:
312         join_options |= NETSETUP_ACCOUNT_CREATE
313     with salt.utils.winapi.Com():
314         conn = wmi.WMI()
315         comp = conn.Win32_ComputerSystem()[0]
316         return comp.JoinDomainOrWorkgroup(
317             Name=domain,
318             Password=password,
319             UserName=username,
320             AccountOU=account_ou,
321             FJoinOptions=join_options,
322         )[0]
323 def unjoin_domain(
324     username=None,
325     password=None,
326     domain=None,
327     workgroup="WORKGROUP",
328     disable=False,
329     restart=False,
330 ):
331     status = get_domain_workgroup()
332     if "Workgroup" in status:
333         if status["Workgroup"] == workgroup:
334             return "Already joined to {}".format(workgroup)
335     if username and "\\" not in username and "@" not in username:
336         if domain:
337             username = "{}@{}".format(username, domain)
338         else:
339             return "Must specify domain if not supplied in username"
340     if username and password is None:
341         return "Must specify a password if you pass a username"
342     NETSETUP_ACCT_DELETE = 0x4  # pylint: disable=invalid-name
343     unjoin_options = 0x0
344     if disable:
345         unjoin_options |= NETSETUP_ACCT_DELETE
346     with salt.utils.winapi.Com():
347         conn = wmi.WMI()
348         comp = conn.Win32_ComputerSystem()[0]
349         err = comp.UnjoinDomainOrWorkgroup(
350             Password=password, UserName=username, FUnjoinOptions=unjoin_options
351         )
352         if not err[0]:
353             err = comp.JoinDomainOrWorkgroup(Name=workgroup)
354             if not err[0]:
355                 ret = {"Workgroup": workgroup, "Restart": False}
356                 if restart:
357                     ret["Restart"] = reboot()
358                 return ret
359             else:
360                 log.error(win32api.FormatMessage(err[0]).rstrip())
361                 log.error("Failed to unjoin the computer from %s", workgroup)
362                 return False
363         else:
364             log.error(win32api.FormatMessage(err[0]).rstrip())
365             log.error("Failed to unjoin computer from %s", status["Domain"])
366             return False
367 def get_domain_workgroup():
368     with salt.utils.winapi.Com():
369         conn = wmi.WMI()
370         for computer in conn.Win32_ComputerSystem():
371             if computer.PartOfDomain:
372                 return {"Domain": computer.Domain}
373             else:
374                 return {"Workgroup": computer.Domain}
375 def set_domain_workgroup(workgroup):
376     with salt.utils.winapi.Com():
377         conn = wmi.WMI()
378         comp = conn.Win32_ComputerSystem()[0]
379         res = comp.JoinDomainOrWorkgroup(Name=workgroup.upper())
380     return True if not res[0] else False
381 def _try_parse_datetime(time_str, fmts):
382     result = None
383     for fmt in fmts:
384         try:
385             result = datetime.strptime(time_str, fmt)
386             break
387         except ValueError:
388             pass
389     return result
390 def get_system_time():
391     now = win32api.GetLocalTime()
392     meridian = "AM"
393     hours = int(now[4])
394     if hours == 12:
395         meridian = "PM"
396     elif hours == 0:
397         hours = 12
398     elif hours &gt; 12:
399         hours = hours - 12
400         meridian = "PM"
401     return "{:02d}:{:02d}:{:02d} {}".format(hours, now[5], now[6], meridian)
402 def set_system_time(newtime):
403     fmts = ["%I:%M:%S %p", "%I:%M %p", "%H:%M:%S", "%H:%M"]
404     dt_obj = _try_parse_datetime(newtime, fmts)
405     if dt_obj is None:
406         return False
407     return set_system_date_time(
408         hours=dt_obj.hour, minutes=dt_obj.minute, seconds=dt_obj.second
409     )
410 def set_system_date_time(
411     years=None, months=None, days=None, hours=None, minutes=None, seconds=None
412 ):
413     try:
414         date_time = win32api.GetLocalTime()
415     except win32api.error as exc:
416         (number, context, message) = exc.args
417         log.error("Failed to get local time")
418         log.error("nbr: %s", number)
419         log.error("ctx: %s", context)
420         log.error("msg: %s", message)
421         return False
422     if years is None:
423         years = date_time[0]
424     if months is None:
425         months = date_time[1]
426     if days is None:
427         days = date_time[3]
428     if hours is None:
429         hours = date_time[4]
430     if minutes is None:
431         minutes = date_time[5]
432     if seconds is None:
433         seconds = date_time[6]
434     try:
435         class SYSTEMTIME(ctypes.Structure):
436             _fields_ = [
437                 ("wYear", ctypes.c_int16),
438                 ("wMonth", ctypes.c_int16),
439                 ("wDayOfWeek", ctypes.c_int16),
440                 ("wDay", ctypes.c_int16),
441                 ("wHour", ctypes.c_int16),
442                 ("wMinute", ctypes.c_int16),
443                 ("wSecond", ctypes.c_int16),
444                 ("wMilliseconds", ctypes.c_int16),
445             ]
446         system_time = SYSTEMTIME()
447         system_time.wYear = int(years)
448         system_time.wMonth = int(months)
449         system_time.wDay = int(days)
450         system_time.wHour = int(hours)
451         system_time.wMinute = int(minutes)
452         system_time.wSecond = int(seconds)
453         system_time_ptr = ctypes.pointer(system_time)
454         succeeded = ctypes.windll.kernel32.SetLocalTime(system_time_ptr)
455         if succeeded != 0:
456             return True
457         else:
458             log.error("Failed to set local time")
459             raise CommandExecutionError(win32api.FormatMessage(succeeded).rstrip())
460     except OSError as err:
461         log.error("Failed to set local time")
462         raise CommandExecutionError(err)
463 def get_system_date():
464     now = win32api.GetLocalTime()
465     return "{:02d}/{:02d}/{:04d}".format(now[1], now[3], now[0])
466 def set_system_date(newdate):
467     fmts = ["%Y-%m-%d", "%m-%d-%Y", "%m-%d-%y", "%m/%d/%Y", "%m/%d/%y", "%Y/%m/%d"]
468     dt_obj = _try_parse_datetime(newdate, fmts)
469     if dt_obj is None:
470 <a name="1"></a>        return False
471     return set_system_date_time(years=dt_obj.year, months=dt_obj.month, days=dt_obj.<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>day)
472 def start_time_service():
473     return __salt__["service.start"]("w32time")
474 def stop_time_service():
475     return __salt__["service.stop"]("w32time")
476 def get_pending_component_servicing():
477     return salt.</b></font>utils.win_system.get_pending_component_servicing()
478 def get_pending_domain_join():
479     return salt.utils.win_system.get_pending_domain_join()
480 def get_pending_file_rename():
481     return salt.utils.win_system.get_pending_file_rename()
482 def get_pending_servermanager():
483     return salt.utils.win_system.get_pending_servermanager()
484 def get_pending_update():
485     return salt.utils.win_system.get_pending_update()
486 def set_reboot_required_witnessed():
487     r"""
488     This function is used to remember that an event indicating that a reboot is
489     required was witnessed. This function relies on the salt-minion's ability to
490     create the following volatile registry key in the *HKLM* hive:
491        *SYSTEM\\CurrentControlSet\\Services\\salt-minion\\Volatile-Data*
492     Because this registry key is volatile, it will not persist beyond the
493     current boot session. Also, in the scope of this key, the name *'Reboot
494     required'* will be assigned the value of *1*.
495     For the time being, this function is being used whenever an install
496     completes with exit code 3010 and can be extended where appropriate in the
497     future.
498     .. versionadded:: 2016.11.0
499     Returns:
500         bool: ``True`` if successful, otherwise ``False``
501     CLI Example:
502     .. code-block:: bash
503         salt '*' system.set_reboot_required_witnessed
504     Determine if at any time during the current boot session the salt minion
505     witnessed an event indicating that a reboot is required.
506     This function will return ``True`` if an install completed with exit
507     code 3010 during the current boot session and can be extended where
508     appropriate in the future.
509     .. versionadded:: 2016.11.0
510     Returns:
511         bool: ``True`` if the ``Requires reboot`` registry flag is set to ``1``,
512         otherwise ``False``
513     CLI Example:
514     .. code-block:: bash
515         salt '*' system.get_reboot_required_witnessed
516     Determine whether there is a reboot pending.
517     .. versionadded:: 2016.11.0
518     Returns:
519         bool: ``True`` if the system is pending reboot, otherwise ``False``
520     CLI Example:
521     .. code-block:: bash
522         salt '*' system.get_pending_reboot
523     Determine which check is signalling that the system is pending a reboot.
524     Useful in determining why your system is signalling that it needs a reboot.
525     .. versionadded:: 3001
526     Returns:
527         dict: A dictionary of the results of each system that would indicate a
528         pending reboot
529     CLI Example:
530     .. code-block:: bash
531         salt '*' system.get_pending_reboot_details
532     Check the Windows Update system for a pending reboot state.
533     This leverages the Windows Update System to determine if the system is
534     pending a reboot.
535     .. versionadded:: 3001
536     Returns:
537         bool: ``True`` if the Windows Update system reports a pending update,
538         otherwise ``False``
539     CLI Example:
540     .. code-block:: bash
541         salt '*' system.get_pending_windows_update
542 Package support for openSUSE via the zypper package manager
543 :depends: - ``rpm`` Python module.  Install with ``zypper install rpm-python``
544 .. important::
545     If you feel that Salt should be using this module to manage packages on a
546     minion, and it is using a different module (or gives an error similar to
547     *'pkg.install' is not available*), see :ref:`here
548     &lt;module-provider-override&gt;`.
549 """
550 import configparser
551 import datetime
552 import fnmatch
553 import logging
554 import os
555 import re
556 import time
557 import urllib.parse
558 from xml.dom import minidom as dom
559 from xml.parsers.expat import ExpatError
560 import salt.utils.data
561 import salt.utils.environment
562 import salt.utils.event
563 import salt.utils.files
564 import salt.utils.functools
565 import salt.utils.path
566 import salt.utils.pkg
567 import salt.utils.pkg.rpm
568 import salt.utils.stringutils
569 import salt.utils.systemd
570 import salt.utils.versions
571 from salt.exceptions import CommandExecutionError, MinionError, SaltInvocationError
572 from salt.utils.versions import LooseVersion
573 log = logging.getLogger(__name__)
574 HAS_ZYPP = False
575 ZYPP_HOME = "/etc/zypp"
576 LOCKS = "{}/locks".format(ZYPP_HOME)
577 REPOS = "{}/repos.d".format(ZYPP_HOME)
578 DEFAULT_PRIORITY = 99
579 PKG_ARCH_SEPARATOR = "."
580 __virtualname__ = "pkg"
581 def __virtual__():
582     if __grains__.get("os_family", "") != "Suse":
583         return (
584             False,
585             "Module zypper: non SUSE OS not supported by zypper package manager",
586         )
587     if not salt.utils.path.which("zypper"):
588         return (False, "Module zypper: zypper package manager not found")
589     return __virtualname__
590 class _Zypper:
591     SUCCESS_EXIT_CODES = {
592         0: "Successful run of zypper with no special info.",
593         100: "Patches are available for installation.",
594         101: "Security patches are available for installation.",
595         102: "Installation successful, reboot required.",
596         103: "Installation successful, restart of the package manager itself required.",
597     }
598     WARNING_EXIT_CODES = {
599         6: "No repositories are defined.",
600         7: "The ZYPP library is locked.",
601         106: (
602             "Some repository had to be disabled temporarily because it failed to"
603             " refresh. You should check your repository configuration (e.g. zypper ref"
604             " -f)."
605         ),
606         107: (
607             "Installation basically succeeded, but some of the packages %post install"
608             " scripts returned an error. These packages were successfully unpacked to"
609             " disk and are registered in the rpm database, but due to the failed"
610             " install script they may not work as expected. The failed scripts output"
611             " might reveal what actually went wrong. Any scripts output is also logged"
612             " to /var/log/zypp/history."
613         ),
614     }
615     LOCK_EXIT_CODE = 7
616     XML_DIRECTIVES = ["-x", "--xmlout"]
617     ZYPPER_LOCK = "/var/run/zypp.pid"
618     TAG_RELEASED = "zypper/released"
619     TAG_BLOCKED = "zypper/blocked"
620     def __init__(self):
621         self._reset()
622     def _reset(self):
623         self.__cmd = ["zypper", "--non-interactive"]
624 <a name="2"></a>        self.__exit_code = 0
625         self.__call_result = dict()
626         self.__error_msg = ""
627         self.__env = salt.utils.environment.get_module_environment(globals<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>())
628         self.__xml = False
629         self.__no_lock = False
630         self.__no_raise = False
631         self.__refresh = False
632         self.__ignore_repo_failure = False
633         self.</b></font>__systemd_scope = False
634         self.__root = None
635         self.__called = False
636     def __call__(self, *args, **kwargs):
637         if self.__called:
638             self._reset()
639         if "no_repo_failure" in kwargs:
640             self.__ignore_repo_failure = kwargs["no_repo_failure"]
641         if "systemd_scope" in kwargs:
642             self.__systemd_scope = kwargs["systemd_scope"]
643         if "root" in kwargs:
644             self.__root = kwargs["root"]
645         return self
646     def __getattr__(self, item):
647         if self.__called:
648             self._reset()
649         if item == "xml":
650             self.__xml = True
651         elif item == "nolock":
652             self.__no_lock = True
653         elif item == "noraise":
654             self.__no_raise = True
655         elif item == "refreshable":
656             self.__refresh = True
657         elif item == "call":
658             return self.__call
659         else:
660             return self.__dict__[item]
661         if self.__no_lock:
662             self.__no_lock = not self.__refresh
663         return self
664     @property
665     def exit_code(self):
666         return self.__exit_code
667     @exit_code.setter
668     def exit_code(self, exit_code):
669         self.__exit_code = int(exit_code or "0")
670     @property
671     def error_msg(self):
672         return self.__error_msg
673     @error_msg.setter
674     def error_msg(self, msg):
675         if self._is_error():
676             self.__error_msg = msg and os.linesep.join(msg) or "Check Zypper's logs."
677     @property
678     def stdout(self):
679         return self.__call_result.get("stdout", "")
680     @property
681     def stderr(self):
682         return self.__call_result.get("stderr", "")
683     @property
684     def pid(self):
685         return self.__call_result.get("pid", "")
686     def _is_error(self):
687         if self.exit_code:
688             msg = self.SUCCESS_EXIT_CODES.get(self.exit_code)
689             if msg:
690                 log.info(msg)
691             msg = self.WARNING_EXIT_CODES.get(self.exit_code)
692             if msg:
693                 log.warning(msg)
694         return (
695             self.exit_code not in self.SUCCESS_EXIT_CODES
696             and self.exit_code not in self.WARNING_EXIT_CODES
697         )
698     def _is_lock(self):
699         return self.exit_code == self.LOCK_EXIT_CODE
700     def _is_xml_mode(self):
701         return (
702             [itm for itm in self.XML_DIRECTIVES if itm in self.__cmd] and True or False
703         )
704     def _check_result(self):
705         if not self.__call_result:
706             raise CommandExecutionError("No output result from Zypper?")
707         self.exit_code = self.__call_result["retcode"]
708         if self._is_lock():
709             return False
710         if self._is_error():
711             _error_msg = list()
712             if not self._is_xml_mode():
713                 msg = (
714                     self.__call_result["stderr"]
715                     and self.__call_result["stderr"].strip()
716                     or ""
717                 )
718                 if msg:
719                     _error_msg.append(msg)
720             else:
721                 try:
722                     doc = dom.parseString(self.__call_result["stdout"])
723                 except ExpatError as err:
724                     log.error(err)
725                     doc = None
726                 if doc:
727                     msg_nodes = doc.getElementsByTagName("message")
728                     for node in msg_nodes:
729                         if node.getAttribute("type") == "error":
730                             _error_msg.append(node.childNodes[0].nodeValue)
731                 elif self.__call_result["stderr"].strip():
732                     _error_msg.append(self.__call_result["stderr"].strip())
733             self.error_msg = _error_msg
734         return True
735     def __call(self, *args, **kwargs):
736         self.__called = True
737         if self.__xml:
738             self.__cmd.append("--xmlout")
739         if not self.__refresh and "--no-refresh" not in args:
740             self.__cmd.append("--no-refresh")
741         if self.__root:
742             self.__cmd.extend(["--root", self.__root])
743         self.__cmd.extend(args)
744         kwargs["output_loglevel"] = "trace"
745         kwargs["python_shell"] = False
746         kwargs["env"] = self.__env.copy()
747         if self.__no_lock:
748             kwargs["env"][
749                 "ZYPP_READONLY_HACK"
750             ] = (  # Disables locking for read-only operations. Do not try that at home!
751                 "1"
752             )
753         was_blocked = False
754         while True:
755             cmd = []
756             if self.__systemd_scope:
757                 cmd.extend(["systemd-run", "--scope"])
758             cmd.extend(self.__cmd)
759             log.debug("Calling Zypper: %s", " ".join(cmd))
760             self.__call_result = __salt__["cmd.run_all"](cmd, **kwargs)
761             if self._check_result():
762                 break
763             if os.path.exists(self.ZYPPER_LOCK):
764                 try:
765                     with salt.utils.files.fopen(self.ZYPPER_LOCK) as rfh:
766                         data = __salt__["ps.proc_info"](
767                             int(rfh.readline()),
768                             attrs=["pid", "name", "cmdline", "create_time"],
769                         )
770                         data["cmdline"] = " ".join(data["cmdline"])
771                         data["info"] = "Blocking process created at {}.".format(
772                             datetime.datetime.utcfromtimestamp(
773                                 data["create_time"]
774                             ).isoformat()
775                         )
776                         data["success"] = True
777                 except Exception as err:  # pylint: disable=broad-except
778                     data = {
779                         "info": (
780                             "Unable to retrieve information about blocking process: {}".format(
781                                 err.message
782                             )
783                         ),
784                         "success": False,
785                     }
786             else:
787                 data = {
788                     "info": "Zypper is locked, but no Zypper lock has been found.",
789                     "success": False,
790                 }
791             if not data["success"]:
792                 log.debug("Unable to collect data about blocking process.")
793             else:
794                 log.debug("Collected data about blocking process.")
795             __salt__["event.fire_master"](data, self.TAG_BLOCKED)
796             log.debug(
797                 "Fired a Zypper blocked event to the master with the data: %s", data
798             )
799             log.debug("Waiting 5 seconds for Zypper gets released...")
800             time.sleep(5)
801             if not was_blocked:
802                 was_blocked = True
803         if was_blocked:
804             __salt__["event.fire_master"](
805                 {
806                     "success": not self.error_msg,
807                     "info": self.error_msg or "Zypper has been released",
808                 },
809                 self.TAG_RELEASED,
810             )
811         if self.error_msg and not self.__no_raise and not self.__ignore_repo_failure:
812             raise CommandExecutionError(
813                 "Zypper command failure: {}".format(self.error_msg)
814             )
815         return (
816             self._is_xml_mode()
817             and dom.parseString(
818                 salt.utils.stringutils.to_str(self.__call_result["stdout"])
819             )
820             or self.__call_result["stdout"]
821         )
822 __zypper__ = _Zypper()
823 class Wildcard:
824     Z_OP = ["&lt;", "&lt;=", "=", "&gt;=", "&gt;"]
825     def __init__(self, zypper):
826         self.name = None
827         self.version = None
828         self.zypper = zypper
829         self._attr_solvable_version = "edition"
830         self._op = None
831     def __call__(self, pkg_name, pkg_version):
832         if pkg_version:
833             self.name = pkg_name
834             self._set_version(pkg_version)  # Dissects possible operator
835             versions = sorted(
836                 LooseVersion(vrs)
837                 for vrs in self._get_scope_versions(self._get_available_versions())
838             )
839             return versions and "{}{}".format(self._op or "", versions[-1]) or None
840     def _get_available_versions(self):
841         solvables = self.zypper.nolock.xml.call(
842             "se", "-xv", self.name
843         ).getElementsByTagName("solvable")
844         if not solvables:
845             raise CommandExecutionError(
846                 "No packages found matching '{}'".format(self.name)
847             )
848         return sorted(
849             {
850                 slv.getAttribute(self._attr_solvable_version)
851                 for slv in solvables
852                 if slv.getAttribute(self._attr_solvable_version)
853             }
854         )
855     def _get_scope_versions(self, pkg_versions):
856         get_in_versions = []
857         for p_version in pkg_versions:
858             if fnmatch.fnmatch(p_version, self.version):
859                 get_in_versions.append(p_version)
860         return get_in_versions
861     def _set_version(self, version):
862         if not version:
863             return
864         exact_version = re.sub(r"[&lt;&gt;=+]*", "", version)
865         self._op = version.replace(exact_version, "") or None
866         if self._op and self._op not in self.Z_OP:
867             raise CommandExecutionError(
868                 'Zypper do not supports operator "{}".'.format(self._op)
869             )
870         self.version = exact_version
871 def _systemd_scope():
872     return salt.utils.systemd.has_scope(__context__) and __salt__["config.get"](
873         "systemd.scope", True
874     )
875 def _clean_cache():
876     keys = []
877     for cache_name in ["pkg.list_pkgs", "pkg.list_provides"]:
878         for contextkey in __context__:
879             if contextkey.startswith(cache_name):
880                 keys.append(contextkey)
881     for key in keys:
882         __context__.pop(key, None)
883 def list_upgrades(refresh=True, root=None, **kwargs):
884     if refresh:
885         refresh_db(root)
886     ret = dict()
887     cmd = ["list-updates"]
888     if "fromrepo" in kwargs:
889         repos = kwargs["fromrepo"]
890         if isinstance(repos, str):
891             repos = [repos]
892         for repo in repos:
893             cmd.extend(["--repo", repo if isinstance(repo, str) else str(repo)])
894         log.debug("Targeting repos: %s", repos)
895     for update_node in (
896         __zypper__(root=root).nolock.xml.call(*cmd).getElementsByTagName("update")
897     ):
898         if update_node.getAttribute("kind") == "package":
899             ret[update_node.getAttribute("name")] = update_node.getAttribute("edition")
900     return ret
901 list_updates = salt.utils.functools.alias_function(list_upgrades, "list_updates")
902 def info_installed(*names, **kwargs):
903     all_versions = kwargs.get("all_versions", False)
904     ret = dict()
905     for pkg_name, pkgs_nfo in __salt__["lowpkg.info"](*names, **kwargs).items():
906         pkg_nfo = pkgs_nfo if all_versions else [pkgs_nfo]
907         for _nfo in pkg_nfo:
908             t_nfo = dict()
909             for key, value in _nfo.items():
910                 if key == "source_rpm":
911                     t_nfo["source"] = value
912                 else:
913                     t_nfo[key] = value
914             if not all_versions:
915                 ret[pkg_name] = t_nfo
916             else:
917                 ret.setdefault(pkg_name, []).append(t_nfo)
918     return ret
919 def info_available(*names, **kwargs):
920     ret = {}
921     if not names:
922         return ret
923     else:
924         names = sorted(list(set(names)))
925     root = kwargs.get("root", None)
926     if kwargs.get("refresh", True):
927         refresh_db(root)
928     pkg_info = []
929     batch = names[:]
930     batch_size = 200
931     while batch:
932         pkg_info.extend(
933             re.split(
934                 r"Information for package*",
935                 __zypper__(root=root).nolock.call(
936                     "info", "-t", "package", *batch[:batch_size]
937                 ),
938             )
939         )
940         batch = batch[batch_size:]
941     for pkg_data in pkg_info:
942         nfo = {}
943         for line in [data for data in pkg_data.split("\n") if ":" in data]:
944             if line.startswith("-----"):
945                 continue
946             kw = [data.strip() for data in line.split(":", 1)]
947             if len(kw) == 2 and kw[1]:
948                 nfo[kw[0].lower()] = kw[1]
949         if nfo.get("name"):
950             name = nfo.pop("name")
951             ret[name] = nfo
952         if nfo.get("status"):
953             nfo["status"] = nfo.get("status")
954         if nfo.get("installed"):
955             nfo["installed"] = nfo.get("installed").lower().startswith("yes")
956     return ret
957 def parse_arch(name):
958     _name, _arch = None, None
959     try:
960         _name, _arch = name.rsplit(PKG_ARCH_SEPARATOR, 1)
961     except ValueError:
962         pass
963     if _arch not in salt.utils.pkg.rpm.ARCHES + ("noarch",):
964         _name = name
965         _arch = None
966     return {"name": _name, "arch": _arch}
967 def latest_version(*names, **kwargs):
968     ret = dict()
969     if not names:
970         return ret
971     names = sorted(list(set(names)))
972     package_info = info_available(*names, **kwargs)
973     for name in names:
974         pkg_info = package_info.get(name, {})
975         status = pkg_info.get("status", "").lower()
976         if status.find("not installed") &gt; -1 or status.find("out-of-date") &gt; -1:
977             ret[name] = pkg_info.get("version")
978         else:
979             ret[name] = ""
980     if len(names) == 1 and ret:
981         return ret[names[0]]
982     return ret
983 available_version = salt.utils.functools.alias_function(
984     latest_version, "available_version"
985 )
986 def upgrade_available(name, **kwargs):
987     return not not latest_version(name, **kwargs)  # pylint: disable=C0113
988 def version(*names, **kwargs):
989     return __salt__["pkg_resource.version"](*names, **kwargs) or {}
990 def version_cmp(ver1, ver2, ignore_epoch=False, **kwargs):
991     return __salt__["lowpkg.version_cmp"](ver1, ver2, ignore_epoch=ignore_epoch)
992 def _list_pkgs_from_context(versions_as_list, contextkey, attr):
993     return __salt__["pkg_resource.format_pkg_list"](
994         __context__[contextkey], versions_as_list, attr
995     )
996 def list_pkgs(versions_as_list=False, root=None, includes=None, **kwargs):
997     versions_as_list = salt.utils.data.is_true(versions_as_list)
998     if any(
999         [salt.utils.data.is_true(kwargs.get(x)) for x in ("removed", "purge_desired")]
1000     ):
1001         return {}
1002     attr = kwargs.get("attr")
1003     if attr is not None:
1004         attr = salt.utils.args.split_input(attr)
1005     includes = includes if includes else []
1006     contextkey = "pkg.list_pkgs_{}_{}".format(root, includes)
1007     if contextkey in __context__ and kwargs.get("use_context", True):
1008         return _list_pkgs_from_context(versions_as_list, contextkey, attr)
1009     ret = {}
1010     cmd = ["rpm"]
1011     if root:
1012         cmd.extend(["--root", root])
1013     cmd.extend(
1014         [
1015             "-qa",
1016             "--queryformat",
1017             salt.utils.pkg.rpm.QUERYFORMAT.replace("%{REPOID}", "(none)") + "\n",
1018         ]
1019     )
1020     output = __salt__["cmd.run"](cmd, python_shell=False, output_loglevel="trace")
1021     for line in output.splitlines():
1022         pkginfo = salt.utils.pkg.rpm.parse_pkginfo(line, osarch=__grains__["osarch"])
1023         if pkginfo:
1024             pkgver = pkginfo.version
1025             epoch = None
1026             release = None
1027             if ":" in pkgver:
1028                 epoch, pkgver = pkgver.split(":", 1)
1029             if "-" in pkgver:
1030                 pkgver, release = pkgver.split("-", 1)
1031             all_attr = {
1032                 "epoch": epoch,
1033                 "version": pkgver,
1034                 "release": release,
1035                 "arch": pkginfo.arch,
1036                 "install_date": pkginfo.install_date,
1037                 "install_date_time_t": pkginfo.install_date_time_t,
1038             }
1039             __salt__["pkg_resource.add_pkg"](ret, pkginfo.name, all_attr)
1040     _ret = {}
1041     for pkgname in ret:
1042         if pkgname.startswith("gpg-pubkey"):
1043             continue
1044         _ret[pkgname] = sorted(ret[pkgname], key=lambda d: d["version"])
1045     for include in includes:
1046         if include == "product":
1047             products = list_products(all=False, root=root)
1048             for product in products:
1049                 extended_name = "{}:{}".format(include, product["name"])
1050                 _ret[extended_name] = [
1051                     {
1052                         "epoch": product["epoch"],
1053                         "version": product["version"],
1054                         "release": product["release"],
1055                         "arch": product["arch"],
1056                         "install_date": None,
1057                         "install_date_time_t": None,
1058                     }
1059                 ]
1060         if include in ("pattern", "patch"):
1061             if include == "pattern":
1062                 elements = list_installed_patterns(root=root)
1063             elif include == "patch":
1064                 elements = list_installed_patches(root=root)
1065             else:
1066                 elements = []
1067             for element in elements:
1068                 extended_name = "{}:{}".format(include, element)
1069                 info = info_available(extended_name, refresh=False, root=root)
1070                 _ret[extended_name] = [
1071                     {
1072                         "epoch": None,
1073                         "version": info[element]["version"],
1074                         "release": None,
1075                         "arch": info[element]["arch"],
1076                         "install_date": None,
1077                         "install_date_time_t": None,
1078                     }
1079                 ]
1080     __context__[contextkey] = _ret
1081     return __salt__["pkg_resource.format_pkg_list"](
1082         __context__[contextkey], versions_as_list, attr
1083     )
1084 def list_repo_pkgs(*args, **kwargs):
1085     byrepo = kwargs.pop("byrepo", False)
1086     fromrepo = kwargs.pop("fromrepo", "") or ""
1087     ret = {}
1088     targets = [arg if isinstance(arg, str) else str(arg) for arg in args]
1089     def _is_match(pkgname):
1090         if not args:
1091             return True
1092         for target in targets:
1093             if fnmatch.fnmatch(pkgname, target):
1094                 return True
1095         return False
1096     root = kwargs.get("root") or None
1097     for node in (
1098         __zypper__(root=root)
1099         .xml.call("se", "-s", *targets)
1100         .getElementsByTagName("solvable")
1101     ):
1102         pkginfo = dict(node.attributes.items())
1103         try:
1104             if pkginfo["kind"] != "package":
1105                 continue
1106             reponame = pkginfo["repository"]
1107             if fromrepo and reponame != fromrepo:
1108                 continue
1109             pkgname = pkginfo["name"]
1110             pkgversion = pkginfo["edition"]
1111         except KeyError:
1112             continue
1113         else:
1114             if _is_match(pkgname):
1115                 repo_dict = ret.setdefault(reponame, {})
1116                 version_list = repo_dict.setdefault(pkgname, set())
1117                 version_list.add(pkgversion)
1118     if byrepo:
1119         for reponame in ret:
1120             for pkgname in ret[reponame]:
1121                 sorted_versions = sorted(
1122                     (LooseVersion(x) for x in ret[reponame][pkgname]), reverse=True
1123                 )
1124                 ret[reponame][pkgname] = [x.vstring for x in sorted_versions]
1125         return ret
1126     else:
1127         byrepo_ret = {}
1128         for reponame in ret:
1129             for pkgname in ret[reponame]:
1130                 byrepo_ret.setdefault(pkgname, []).extend(ret[reponame][pkgname])
1131         for pkgname in byrepo_ret:
1132             sorted_versions = sorted(
1133                 (LooseVersion(x) for x in byrepo_ret[pkgname]), reverse=True
1134             )
1135             byrepo_ret[pkgname] = [x.vstring for x in sorted_versions]
1136         return byrepo_ret
1137 def _get_configured_repos(root=None):
1138     repos = os.path.join(root, os.path.relpath(REPOS, os.path.sep)) if root else REPOS
1139     repos_cfg = configparser.ConfigParser()
1140     if os.path.exists(repos):
1141         repos_cfg.read(
1142             [
1143                 repos + "/" + fname
1144                 for fname in os.listdir(repos)
1145                 if fname.endswith(".repo")
1146             ]
1147         )
1148     else:
1149         log.warning("Repositories not found in %s", repos)
1150     return repos_cfg
1151 def _get_repo_info(alias, repos_cfg=None, root=None):
1152     try:
1153         meta = dict((repos_cfg or _get_configured_repos(root=root)).items(alias))
1154         meta["alias"] = alias
1155         for key, val in meta.items():
1156             if val in ["0", "1"]:
1157                 meta[key] = int(meta[key]) == 1
1158             elif val == "NONE":
1159                 meta[key] = None
1160         return meta
1161     except (ValueError, configparser.NoSectionError):
1162         return {}
1163 def get_repo(repo, root=None, **kwargs):  # pylint: disable=unused-argument
1164     return _get_repo_info(repo, root=root)
1165 def list_repos(root=None, **kwargs):
1166     repos_cfg = _get_configured_repos(root=root)
1167     all_repos = {}
1168     for alias in repos_cfg.sections():
1169         all_repos[alias] = _get_repo_info(alias, repos_cfg=repos_cfg, root=root)
1170     return all_repos
1171 def del_repo(repo, root=None):
1172     repos_cfg = _get_configured_repos(root=root)
1173     for alias in repos_cfg.sections():
1174         if alias == repo:
1175             doc = __zypper__(root=root).xml.call(
1176                 "rr", "--loose-auth", "--loose-query", alias
1177             )
1178             msg = doc.getElementsByTagName("message")
1179             if doc.getElementsByTagName("progress") and msg:
1180                 return {
1181                     repo: True,
1182                     "message": msg[0].childNodes[0].nodeValue,
1183                 }
1184     raise CommandExecutionError("Repository '{}' not found.".format(repo))
1185 def mod_repo(repo, **kwargs):
1186     root = kwargs.get("root") or None
1187     repos_cfg = _get_configured_repos(root=root)
1188     added = False
1189     if repo not in repos_cfg.sections():
1190         url = kwargs.get("url", kwargs.get("mirrorlist", kwargs.get("baseurl")))
1191         if not url:
1192             raise CommandExecutionError(
1193                 "Repository '{}' not found, and neither 'baseurl' nor "
1194                 "'mirrorlist' was specified".format(repo)
1195             )
1196         if not urllib.parse.urlparse(url).scheme:
1197             raise CommandExecutionError(
1198                 "Repository '{}' not found and URL for baseurl/mirrorlist "
1199                 "is malformed".format(repo)
1200             )
1201         for alias in repos_cfg.sections():
1202             repo_meta = _get_repo_info(alias, repos_cfg=repos_cfg, root=root)
1203             new_url = urllib.parse.urlparse(url)
1204             if not new_url.path:
1205                 new_url = urllib.parse.urlparse.ParseResult(
1206                     scheme=new_url.scheme,  # pylint: disable=E1123
1207                     netloc=new_url.netloc,
1208                     path="/",
1209                     params=new_url.params,
1210                     query=new_url.query,
1211                     fragment=new_url.fragment,
1212                 )
1213             base_url = urllib.parse.urlparse(repo_meta["baseurl"])
1214             if new_url == base_url:
1215                 raise CommandExecutionError(
1216                     "Repository '{}' already exists as '{}'.".format(repo, alias)
1217                 )
1218         __zypper__(root=root).xml.call("ar", url, repo)
1219         repos_cfg = _get_configured_repos(root=root)
1220         if repo not in repos_cfg.sections():
1221             raise CommandExecutionError(
1222                 "Failed add new repository '{}' for unspecified reason. "
1223                 "Please check zypper logs.".format(repo)
1224             )
1225         added = True
1226     repo_info = _get_repo_info(repo, root=root)
1227     if (
1228         not added
1229         and "baseurl" in kwargs
1230         and not (kwargs["baseurl"] == repo_info["baseurl"])
1231     ):
1232         repo_info.update(kwargs)
1233         repo_info.setdefault("cache", False)
1234         del_repo(repo, root=root)
1235         return mod_repo(repo, root=root, **repo_info)
1236     cmd_opt = []
1237     global_cmd_opt = []
1238     call_refresh = False
1239     if "enabled" in kwargs:
1240         cmd_opt.append(kwargs["enabled"] and "--enable" or "--disable")
1241     if "refresh" in kwargs:
1242         cmd_opt.append(kwargs["refresh"] and "--refresh" or "--no-refresh")
1243     if "cache" in kwargs:
1244         cmd_opt.append(kwargs["cache"] and "--keep-packages" or "--no-keep-packages")
1245     if "gpgcheck" in kwargs:
1246         cmd_opt.append(kwargs["gpgcheck"] and "--gpgcheck" or "--no-gpgcheck")
1247     if "priority" in kwargs:
1248         cmd_opt.append("--priority={}".format(kwargs.get("priority", DEFAULT_PRIORITY)))
1249     if "humanname" in kwargs:
1250         cmd_opt.append("--name='{}'".format(kwargs.get("humanname")))
1251     if kwargs.get("gpgautoimport") is True:
1252         global_cmd_opt.append("--gpg-auto-import-keys")
1253         call_refresh = True
1254     if cmd_opt:
1255         cmd_opt = global_cmd_opt + ["mr"] + cmd_opt + [repo]
1256         __zypper__(root=root).refreshable.xml.call(*cmd_opt)
1257     comment = None
1258     if call_refresh:
1259         refresh_opts = global_cmd_opt + ["refresh"] + [repo]
1260         __zypper__(root=root).xml.call(*refresh_opts)
1261     elif not added and not cmd_opt:
1262         comment = "Specified arguments did not result in modification of repo"
1263     repo = get_repo(repo, root=root)
1264     if comment:
1265         repo["comment"] = comment
1266     return repo
1267 def refresh_db(force=None, root=None):
1268     salt.utils.pkg.clear_rtag(__opts__)
1269     ret = {}
1270     refresh_opts = ["refresh"]
1271     if force is None:
1272         force = __pillar__.get("zypper", {}).get("refreshdb_force", True)
1273     if force:
1274         refresh_opts.append("--force")
1275     out = __zypper__(root=root).refreshable.call(*refresh_opts)
1276     for line in out.splitlines():
1277         if not line:
1278             continue
1279         if line.strip().startswith("Repository") and "'" in line:
1280             try:
1281                 key = line.split("'")[1].strip()
1282                 if "is up to date" in line:
1283                     ret[key] = False
1284             except IndexError:
1285                 continue
1286         elif line.strip().startswith("Building") and "'" in line:
1287             key = line.split("'")[1].strip()
1288             if "done" in line:
1289                 ret[key] = True
1290     return ret
1291 <a name="0"></a>
1292 def _find_types(pkgs):
1293     return sorted({pkg.split<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(":", 1)[0] for pkg in pkgs if len(pkg.split(":", 1)) == 2})
1294 def install(
1295     name=None,
1296     refresh=False,
1297     fromrepo=None,
1298     pkgs=None,
1299     sources=None,
1300     downloadonly=None,
1301     skip_verify=False,
1302     version=None,
1303     ignore_repo_failure=False,
1304     no_recommends=False,
1305     root=</b></font>None,
1306     **kwargs
1307 ):
1308     if refresh:
1309         refresh_db(root)
1310     try:
1311         pkg_params, pkg_type = __salt__["pkg_resource.parse_targets"](
1312             name, pkgs, sources, **kwargs
1313         )
1314     except MinionError as exc:
1315         raise CommandExecutionError(exc)
1316     if pkg_params is None or len(pkg_params) == 0:
1317         return {}
1318     version_num = Wildcard(__zypper__(root=root))(name, version)
1319     if version_num:
1320         if pkgs is None and sources is None:
1321             pkg_params = {name: version_num}
1322         else:
1323             log.warning(
1324                 '"version" parameter will be ignored for multiple package targets'
1325             )
1326     if pkg_type == "repository":
1327         targets = []
1328         for param, version_num in pkg_params.items():
1329             if version_num is None:
1330                 log.debug("targeting package: %s", param)
1331                 targets.append(param)
1332             else:
1333                 prefix, verstr = salt.utils.pkg.split_comparison(version_num)
1334                 if not prefix:
1335                     prefix = "="
1336                 target = "{}{}{}".format(param, prefix, verstr)
1337                 log.debug("targeting package: %s", target)
1338                 targets.append(target)
1339     elif pkg_type == "advisory":
1340         targets = []
1341         cur_patches = list_patches(root=root)
1342         for advisory_id in pkg_params:
1343             if advisory_id not in cur_patches:
1344                 raise CommandExecutionError(
1345                     'Advisory id "{}" not found'.format(advisory_id)
1346                 )
1347             else:
1348                 targets.append(advisory_id)
1349     else:
1350         targets = pkg_params
1351     diff_attr = kwargs.get("diff_attr")
1352     includes = _find_types(targets)
1353     old = (
1354         list_pkgs(attr=diff_attr, root=root, includes=includes)
1355         if not downloadonly
1356         else list_downloaded(root)
1357     )
1358     downgrades = []
1359     if fromrepo:
1360         fromrepoopt = ["--force", "--force-resolution", "--from", fromrepo]
1361         log.info("Targeting repo '%s'", fromrepo)
1362     else:
1363         fromrepoopt = ""
1364     cmd_install = ["install", "--auto-agree-with-licenses"]
1365     cmd_install.append(
1366         kwargs.get("resolve_capabilities") and "--capability" or "--name"
1367     )
1368     if not refresh:
1369         cmd_install.insert(0, "--no-refresh")
1370     if skip_verify:
1371         cmd_install.insert(0, "--no-gpg-checks")
1372     if downloadonly:
1373         cmd_install.append("--download-only")
1374     if fromrepo:
1375         cmd_install.extend(fromrepoopt)
1376     if no_recommends:
1377         cmd_install.append("--no-recommends")
1378     errors = []
1379     if pkg_type == "advisory":
1380         targets = ["patch:{}".format(t) for t in targets]
1381     systemd_scope = _systemd_scope()
1382     while targets:
1383         cmd = cmd_install + targets[:500]
1384         targets = targets[500:]
1385         for line in (
1386             __zypper__(
1387                 no_repo_failure=ignore_repo_failure,
1388                 systemd_scope=systemd_scope,
1389                 root=root,
1390             )
1391             .call(*cmd)
1392             .splitlines()
1393         ):
1394             match = re.match(
1395                 r"^The selected package '([^']+)'.+has lower version", line
1396             )
1397             if match:
1398                 downgrades.append(match.group(1))
1399     while downgrades:
1400         cmd = cmd_install + ["--force"] + downgrades[:500]
1401         downgrades = downgrades[500:]
1402         __zypper__(no_repo_failure=ignore_repo_failure, root=root).call(*cmd)
1403     _clean_cache()
1404     new = (
1405         list_pkgs(attr=diff_attr, root=root, includes=includes)
1406         if not downloadonly
1407         else list_downloaded(root)
1408     )
1409     ret = salt.utils.data.compare_dicts(old, new)
1410     if includes:
1411         _clean_cache()
1412     if errors:
1413         raise CommandExecutionError(
1414             "Problem encountered {} package(s)".format(
1415                 "downloading" if downloadonly else "installing"
1416             ),
1417             info={"errors": errors, "changes": ret},
1418         )
1419     return ret
1420 def upgrade(
1421     refresh=True,
1422     dryrun=False,
1423     dist_upgrade=False,
1424     fromrepo=None,
1425     novendorchange=False,
1426     skip_verify=False,
1427     no_recommends=False,
1428     root=None,
1429     **kwargs
1430 ):  # pylint: disable=unused-argument
1431     cmd_update = (["dist-upgrade"] if dist_upgrade else ["update"]) + [
1432         "--auto-agree-with-licenses"
1433     ]
1434     if skip_verify:
1435         cmd_update.insert(0, "--no-gpg-checks")
1436     if refresh:
1437         refresh_db(root)
1438     if dryrun:
1439         cmd_update.append("--dry-run")
1440     if fromrepo:
1441         if isinstance(fromrepo, str):
1442             fromrepo = [fromrepo]
1443         for repo in fromrepo:
1444             cmd_update.extend(["--from" if dist_upgrade else "--repo", repo])
1445         log.info("Targeting repos: %s", fromrepo)
1446     if dist_upgrade:
1447         if novendorchange:
1448             if __grains__["osrelease_info"][0] &gt; 11:
1449                 cmd_update.append("--no-allow-vendor-change")
1450                 log.info("Disabling vendor changes")
1451             else:
1452                 log.warning(
1453                     "Disabling vendor changes is not supported on this Zypper version"
1454                 )
1455         if no_recommends:
1456             cmd_update.append("--no-recommends")
1457             log.info("Disabling recommendations")
1458         if dryrun:
1459             log.info("Executing debugsolver and performing a dry-run dist-upgrade")
1460             __zypper__(systemd_scope=_systemd_scope(), root=root).noraise.call(
1461                 *cmd_update + ["--debug-solver"]
1462             )
1463     old = list_pkgs(root=root)
1464     __zypper__(systemd_scope=_systemd_scope(), root=root).noraise.call(*cmd_update)
1465     _clean_cache()
1466     new = list_pkgs(root=root)
1467     ret = salt.utils.data.compare_dicts(old, new)
1468     if __zypper__.exit_code not in __zypper__.SUCCESS_EXIT_CODES:
1469         result = {
1470             "retcode": __zypper__.exit_code,
1471             "stdout": __zypper__.stdout,
1472             "stderr": __zypper__.stderr,
1473             "pid": __zypper__.pid,
1474         }
1475         raise CommandExecutionError(
1476             "Problem encountered upgrading packages",
1477             info={"changes": ret, "result": result},
1478         )
1479     if dryrun:
1480         ret = (__zypper__.stdout + os.linesep + __zypper__.stderr).strip()
1481     return ret
1482 def _uninstall(name=None, pkgs=None, root=None):
1483     try:
1484         pkg_params = __salt__["pkg_resource.parse_targets"](name, pkgs)[0]
1485     except MinionError as exc:
1486         raise CommandExecutionError(exc)
1487     includes = _find_types(pkg_params.keys())
1488     old = list_pkgs(root=root, includes=includes)
1489     targets = []
1490     for target in pkg_params:
1491         if target in old and pkg_params[target] in old[target].split(","):
1492             targets.append(target + "-" + pkg_params[target])
1493         elif target in old and not pkg_params[target]:
1494             targets.append(target)
1495     if not targets:
1496         return {}
1497     systemd_scope = _systemd_scope()
1498     errors = []
1499     while targets:
1500         __zypper__(systemd_scope=systemd_scope, root=root).call(
1501             "remove", *targets[:500]
1502         )
1503         targets = targets[500:]
1504     _clean_cache()
1505     new = list_pkgs(root=root, includes=includes)
1506     ret = salt.utils.data.compare_dicts(old, new)
1507     if errors:
1508         raise CommandExecutionError(
1509             "Problem encountered removing package(s)",
1510             info={"errors": errors, "changes": ret},
1511         )
1512     return ret
1513 def normalize_name(name):
1514     try:
1515         arch = name.rsplit(".", 1)[-1]
1516         if arch not in salt.utils.pkg.rpm.ARCHES + ("noarch",):
1517             return name
1518     except ValueError:
1519         return name
1520     if arch in (__grains__["osarch"], "noarch") or salt.utils.pkg.rpm.check_32(
1521         arch, osarch=__grains__["osarch"]
1522     ):
1523         return name[: -(len(arch) + 1)]
1524     return name
1525 def remove(
1526     name=None, pkgs=None, root=None, **kwargs
1527 ):  # pylint: disable=unused-argument
1528     return _uninstall(name=name, pkgs=pkgs, root=root)
1529 def purge(name=None, pkgs=None, root=None, **kwargs):  # pylint: disable=unused-argument
1530     return _uninstall(name=name, pkgs=pkgs, root=root)
1531 def list_locks(root=None):
1532     locks = {}
1533     _locks = os.path.join(root, os.path.relpath(LOCKS, os.path.sep)) if root else LOCKS
1534     try:
1535         with salt.utils.files.fopen(_locks) as fhr:
1536             items = salt.utils.stringutils.to_unicode(fhr.read()).split("\n\n")
1537             for meta in [item.split("\n") for item in items]:
1538                 lock = {}
1539                 for element in [el for el in meta if el]:
1540                     if ":" in element:
1541                         lock.update(
1542                             dict([tuple(i.strip() for i in element.split(":", 1))])
1543                         )
1544                 if lock.get("solvable_name"):
1545                     locks[lock.pop("solvable_name")] = lock
1546     except OSError:
1547         pass
1548     except Exception:  # pylint: disable=broad-except
1549         log.warning("Detected a problem when accessing %s", _locks)
1550     return locks
1551 def clean_locks(root=None):
1552     LCK = "removed"
1553     out = {LCK: 0}
1554     locks = os.path.join(root, os.path.relpath(LOCKS, os.path.sep)) if root else LOCKS
1555     if not os.path.exists(locks):
1556         return out
1557     for node in __zypper__(root=root).xml.call("cl").getElementsByTagName("message"):
1558         text = node.childNodes[0].nodeValue.lower()
1559         if text.startswith(LCK):
1560             out[LCK] = text.split(" ")[1]
1561             break
1562     return out
1563 def unhold(name=None, pkgs=None, **kwargs):
1564     ret = {}
1565     if not name and not pkgs:
1566         raise CommandExecutionError("Name or packages must be specified.")
1567     targets = []
1568     if pkgs:
1569         for pkg in salt.utils.data.repack_dictlist(pkgs):
1570             targets.append(pkg)
1571     else:
1572         targets.append(name)
1573     locks = list_locks()
1574     removed = []
1575     missing = []
1576     for target in targets:
1577         ret[target] = {"name": target, "changes": {}, "result": True, "comment": ""}
1578         if locks.get(target):
1579             removed.append(target)
1580             ret[target]["changes"]["new"] = ""
1581             ret[target]["changes"]["old"] = "hold"
1582             ret[target]["comment"] = "Package {} is no longer held.".format(target)
1583         else:
1584             missing.append(target)
1585             ret[target]["comment"] = "Package {} was already unheld.".format(target)
1586     if removed:
1587         __zypper__.call("rl", *removed)
1588     return ret
1589 def hold(name=None, pkgs=None, **kwargs):
1590     ret = {}
1591     if not name and not pkgs:
1592         raise CommandExecutionError("Name or packages must be specified.")
1593     targets = []
1594     if pkgs:
1595         for pkg in salt.utils.data.repack_dictlist(pkgs):
1596             targets.append(pkg)
1597     else:
1598         targets.append(name)
1599     locks = list_locks()
1600     added = []
1601     for target in targets:
1602         ret[target] = {"name": target, "changes": {}, "result": True, "comment": ""}
1603         if not locks.get(target):
1604             added.append(target)
1605             ret[target]["changes"]["new"] = "hold"
1606             ret[target]["changes"]["old"] = ""
1607             ret[target]["comment"] = "Package {} is now being held.".format(target)
1608         else:
1609             ret[target]["comment"] = "Package {} is already set to be held.".format(
1610                 target
1611             )
1612 <a name="1"></a>    if added:
1613         __zypper__.call("al", *added)
1614     r<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>eturn ret
1615 def verify(*names, **kwargs):
1616     return __salt__["lowpkg.verify"](*names, **kwargs)
1617 def file_list(*packages, **kwargs):
1618     return __salt__["lowpkg.file_list"](*packages, **kwargs)
1619 def file_dict(*packages, **kwargs):
1620     return __salt__[</b></font>"lowpkg.file_dict"](*packages, **kwargs)
1621 def modified(*packages, **flags):
1622     return __salt__["lowpkg.modified"](*packages, **flags)
1623 def owner(*paths, **kwargs):
1624     return __salt__["lowpkg.owner"](*paths, **kwargs)
1625 def _get_visible_patterns(root=None):
1626     patterns = {}
1627     search_patterns = __zypper__(root=root).nolock.xml.call("se", "-t", "pattern")
1628     for element in search_patterns.getElementsByTagName("solvable"):
1629         installed = element.getAttribute("status") == "installed"
1630         patterns[element.getAttribute("name")] = {
1631             "installed": installed,
1632             "summary": element.getAttribute("summary"),
1633         }
1634     return patterns
1635 def _get_installed_patterns(root=None):
1636     def _pattern_name(capability):
1637         return capability.split("=")[-1].strip()
1638     cmd = ["rpm"]
1639     if root:
1640         cmd.extend(["--root", root])
1641     cmd.extend(["-q", "--provides", "--whatprovides", "pattern()"])
1642     output = __salt__["cmd.run"](cmd, ignore_retcode=True)
1643     installed_patterns = {
1644         _pattern_name(line)
1645         for line in output.splitlines()
1646         if line.startswith("pattern() = ") and not _pattern_name(line).startswith(".")
1647     }
1648     patterns = {
1649         k: v for k, v in _get_visible_patterns(root=root).items() if v["installed"]
1650     }
1651     for pattern in installed_patterns:
1652         if pattern not in patterns:
1653             patterns[pattern] = {
1654                 "installed": True,
1655                 "summary": "Non-visible pattern",
1656             }
1657     return patterns
1658 def list_patterns(refresh=False, root=None):
1659     if refresh:
1660         refresh_db(root)
1661     return _get_visible_patterns(root=root)
1662 def list_installed_patterns(root=None):
1663     return _get_installed_patterns(root=root)
1664 def search(criteria, refresh=False, **kwargs):
1665     ALLOWED_SEARCH_OPTIONS = {
1666         "provides": "--provides",
1667         "recommends": "--recommends",
1668         "requires": "--requires",
1669         "suggests": "--suggests",
1670         "conflicts": "--conflicts",
1671         "obsoletes": "--obsoletes",
1672         "file_list": "--file-list",
1673         "search_descriptions": "--search-descriptions",
1674         "case_sensitive": "--case-sensitive",
1675         "installed_only": "--installed-only",
1676         "not_installed_only": "-u",
1677         "details": "--details",
1678     }
1679     root = kwargs.get("root", None)
1680     if refresh:
1681         refresh_db(root)
1682     cmd = ["search"]
1683     if kwargs.get("match") == "exact":
1684         cmd.append("--match-exact")
1685     elif kwargs.get("match") == "words":
1686         cmd.append("--match-words")
1687     elif kwargs.get("match") == "substrings":
1688         cmd.append("--match-substrings")
1689     for opt in kwargs:
1690         if opt in ALLOWED_SEARCH_OPTIONS:
1691             cmd.append(ALLOWED_SEARCH_OPTIONS.get(opt))
1692     cmd.append(criteria)
1693     solvables = (
1694         __zypper__(root=root)
1695         .nolock.noraise.xml.call(*cmd)
1696         .getElementsByTagName("solvable")
1697     )
1698     if not solvables:
1699         raise CommandExecutionError("No packages found matching '{}'".format(criteria))
1700     out = {}
1701     for solvable in solvables:
1702         out[solvable.getAttribute("name")] = dict()
1703         for k, v in solvable.attributes.items():
1704             out[solvable.getAttribute("name")][k] = v
1705     return out
1706 def _get_first_aggregate_text(node_list):
1707     if not node_list:
1708         return ""
1709     out = []
1710     for node in node_list[0].childNodes:
1711         if node.nodeType == dom.Document.TEXT_NODE:
1712             out.append(node.nodeValue)
1713     return "\n".join(out)
1714 def list_products(all=False, refresh=False, root=None):
1715     if refresh:
1716         refresh_db(root)
1717     ret = list()
1718     OEM_PATH = "/var/lib/suseRegister/OEM"
1719     if root:
1720         OEM_PATH = os.path.join(root, os.path.relpath(OEM_PATH, os.path.sep))
1721     cmd = list()
1722     if not all:
1723         cmd.append("--disable-repositories")
1724     cmd.append("products")
1725     if not all:
1726         cmd.append("-i")
1727     product_list = (
1728         __zypper__(root=root).nolock.xml.call(*cmd).getElementsByTagName("product-list")
1729     )
1730     if not product_list:
1731         return ret  # No products found
1732     for prd in product_list[0].getElementsByTagName("product"):
1733         p_nfo = dict()
1734         for k_p_nfo, v_p_nfo in prd.attributes.items():
1735             if k_p_nfo in ["isbase", "installed"]:
1736                 p_nfo[k_p_nfo] = bool(v_p_nfo in ["true", "1"])
1737             elif v_p_nfo:
1738                 p_nfo[k_p_nfo] = v_p_nfo
1739         eol = prd.getElementsByTagName("endoflife")
1740         if eol:
1741             p_nfo["eol"] = eol[0].getAttribute("text")
1742             p_nfo["eol_t"] = int(eol[0].getAttribute("time_t") or 0)
1743         p_nfo["description"] = " ".join(
1744             [
1745                 line.strip()
1746                 for line in _get_first_aggregate_text(
1747                     prd.getElementsByTagName("description")
1748                 ).split(os.linesep)
1749             ]
1750         )
1751         if "productline" in p_nfo and p_nfo["productline"]:
1752             oem_file = os.path.join(OEM_PATH, p_nfo["productline"])
1753             if os.path.isfile(oem_file):
1754                 with salt.utils.files.fopen(oem_file, "r") as rfile:
1755                     oem_release = salt.utils.stringutils.to_unicode(
1756                         rfile.readline()
1757                     ).strip()
1758                     if oem_release:
1759                         p_nfo["release"] = oem_release
1760         ret.append(p_nfo)
1761     return ret
1762 def download(*packages, **kwargs):
1763     if not packages:
1764         raise SaltInvocationError("No packages specified")
1765     root = kwargs.get("root", None)
1766     refresh = kwargs.get("refresh", False)
1767     if refresh:
1768         refresh_db(root)
1769     pkg_ret = {}
1770     for dld_result in (
1771         __zypper__(root=root)
1772         .xml.call("download", *packages)
1773         .getElementsByTagName("download-result")
1774     ):
1775         repo = dld_result.getElementsByTagName("repository")[0]
1776         path = dld_result.getElementsByTagName("localfile")[0].getAttribute("path")
1777         pkg_info = {
1778             "repository-name": repo.getAttribute("name"),
1779             "repository-alias": repo.getAttribute("alias"),
1780             "path": path,
1781         }
1782         key = _get_first_aggregate_text(dld_result.getElementsByTagName("name"))
1783         if __salt__["lowpkg.checksum"](pkg_info["path"], root=root):
1784             pkg_ret[key] = pkg_info
1785     if pkg_ret:
1786         failed = [pkg for pkg in packages if pkg not in pkg_ret]
1787         if failed:
1788             pkg_ret[
1789                 "_error"
1790             ] = "The following package(s) failed to download: {}".format(
1791                 ", ".join(failed)
1792             )
1793         return pkg_ret
1794     raise CommandExecutionError(
1795         "Unable to download packages: {}".format(", ".join(packages))
1796     )
1797 def list_downloaded(root=None, **kwargs):
1798     CACHE_DIR = "/var/cache/zypp/packages/"
1799     if root:
1800         CACHE_DIR = os.path.join(root, os.path.relpath(CACHE_DIR, os.path.sep))
1801     ret = {}
1802     for root, dirnames, filenames in salt.utils.path.os_walk(CACHE_DIR):
1803         for filename in fnmatch.filter(filenames, "*.rpm"):
1804             package_path = os.path.join(root, filename)
1805             pkg_info = __salt__["lowpkg.bin_pkg_info"](package_path)
1806             pkg_timestamp = int(os.path.getctime(package_path))
1807             ret.setdefault(pkg_info["name"], {})[pkg_info["version"]] = {
1808                 "path": package_path,
1809                 "size": os.path.getsize(package_path),
1810                 "creation_date_time_t": pkg_timestamp,
1811                 "creation_date_time": datetime.datetime.utcfromtimestamp(
1812                     pkg_timestamp
1813                 ).isoformat(),
1814             }
1815     return ret
1816 def diff(*paths, **kwargs):
1817     ret = {}
1818     pkg_to_paths = {}
1819     for pth in paths:
1820         pth_pkg = __salt__["lowpkg.owner"](pth, **kwargs)
1821         if not pth_pkg:
1822             ret[pth] = os.path.exists(pth) and "Not managed" or "N/A"
1823         else:
1824             if pkg_to_paths.get(pth_pkg) is None:
1825                 pkg_to_paths[pth_pkg] = []
1826             pkg_to_paths[pth_pkg].append(pth)
1827     if pkg_to_paths:
1828         local_pkgs = __salt__["pkg.download"](*pkg_to_paths.keys(), **kwargs)
1829         for pkg, files in pkg_to_paths.items():
1830             for path in files:
1831                 ret[path] = (
1832                     __salt__["lowpkg.diff"](local_pkgs[pkg]["path"], path)
1833                     or "Unchanged"
1834                 )
1835     return ret
1836 def _get_patches(installed_only=False, root=None):
1837     patches = {}
1838     for element in (
1839         __zypper__(root=root)
1840         .nolock.xml.call("se", "-t", "patch")
1841         .getElementsByTagName("solvable")
1842     ):
1843         installed = element.getAttribute("status") == "installed"
1844         if (installed_only and installed) or not installed_only:
1845             patches[element.getAttribute("name")] = {
1846                 "installed": installed,
1847                 "summary": element.getAttribute("summary"),
1848             }
1849     return patches
1850 def list_patches(refresh=False, root=None, **kwargs):
1851     if refresh:
1852         refresh_db(root)
1853     return _get_patches(root=root)
1854 def list_installed_patches(root=None, **kwargs):
1855     return _get_patches(installed_only=True, root=root)
1856 def list_provides(root=None, **kwargs):
1857     ret = __context__.get("pkg.list_provides")
1858     if not ret:
1859         cmd = ["rpm"]
1860         if root:
1861             cmd.extend(["--root", root])
1862         cmd.extend(["-qa", "--queryformat", "%{PROVIDES}_|-%{NAME}\n"])
1863         ret = dict()
1864         for line in __salt__["cmd.run"](
1865             cmd, output_loglevel="trace", python_shell=False
1866         ).splitlines():
1867             provide, realname = line.split("_|-")
1868             if provide == realname:
1869                 continue
1870             if provide not in ret:
1871                 ret[provide] = list()
1872             ret[provide].append(realname)
1873         __context__["pkg.list_provides"] = ret
1874     return ret
1875 def resolve_capabilities(pkgs, refresh=False, root=None, **kwargs):
1876     if refresh:
1877         refresh_db(root)
1878     ret = list()
1879     for pkg in pkgs:
1880         if isinstance(pkg, dict):
1881             name = next(iter(pkg))
1882             version = pkg[name]
1883         else:
1884             name = pkg
1885             version = None
1886         if kwargs.get("resolve_capabilities", False):
1887             try:
1888                 search(name, root=root, match="exact")
1889             except CommandExecutionError:
1890                 try:
1891                     result = search(name, root=root, provides=True, match="exact")
1892                     if len(result) == 1:
1893                         name = next(iter(result.keys()))
1894                     elif len(result) &gt; 1:
1895                         log.warning("Found ambiguous match for capability '%s'.", pkg)
1896                 except CommandExecutionError as exc:
1897                     log.debug("Search failed with: %s", exc)
1898         if version:
1899             ret.append({name: version})
1900         else:
1901             ret.append(name)
1902     return ret
1903 def services_need_restart(root=None, **kwargs):
1904     cmd = ["ps", "-sss"]
1905     zypper_output = __zypper__(root=root).nolock.call(*cmd)
1906     services = zypper_output.split()
1907     return services
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
