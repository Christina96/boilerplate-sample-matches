<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_aix_status.py &amp; test_mine.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_aix_status.py &amp; test_mine.py
      </h3>
<h1 align="center">
        3.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_aix_status.py (16.25%)<th>test_mine.py (1.951952%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(116-160)<td><a href="#" name="0">(471-497)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_aix_status.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import logging
import sys
import pytest
import salt.modules.status as status
from tests.support.mock import MagicMock, patch
log = logging.getLogger(__name__)
@pytest.fixture
def configure_loader_modules():
    return {
        status: {
            "__grains__": {
                "ip4_interfaces": {
                    "en0": ["129.40.94.58"],
                    "en1": ["172.24.94.58"],
                    "lo0": ["127.0.0.1"],
                },
                "ip6_interfaces": {"en0": [], "en1": [], "lo0": ["1"]},
                "kernel": "AIX",
                "osarch": "PowerPC_POWER8",
                "os": "AIX",
                "os_family": "AIX",
                "osmajorrelease": 7,
            },
        },
    }
@pytest.mark.skipif(
    sys.version_info[0] == 3 and sys.version_info[1] &lt;= 5,
    reason="run on Python 3.6 or greater where OrderedDict is default",
)
def test_netdev():
    """
    Test status.netdev for AIX
    :return:
    """
    netstat_inet4_en0 = """Name   Mtu   Network     Address                 Ipkts     Ierrs        Opkts     Oerrs  Coll
en0    1500  link#2      fa.41.f5.e9.bd.20  1523125     0   759364     0     0
en0    1500  129.40.94.5 129.40.94.58      1523125     0   759364     0     0
"""
    netstat_inet4_en1 = """Name   Mtu   Network     Address                 Ipkts     Ierrs        Opkts     Oerrs  Coll
en1    1500  link#3      fa.41.f5.e9.bd.21     1089     0      402     0     0
en1    1500  172.24.94.5 172.24.94.58         1089     0      402     0     0
"""
    netstat_inet4_lo0 = """Name   Mtu   Network     Address                 Ipkts     Ierrs        Opkts     Oerrs  Coll
lo0    16896 link#1                          25568     0    25568     0     0
lo0    16896 127         127.0.0.1           25568     0    25568     0     0
"""
    netstat_inet6_en0 = """Name   Mtu   Network     Address                 Ipkts     Ierrs        Opkts     Oerrs  Coll
en0    1500  link#2      fa.41.f5.e9.bd.20  1523160     0   759397     0     0
"""
    netstat_inet6_en1 = """Name   Mtu   Network     Address                 Ipkts     Ierrs        Opkts     Oerrs  Coll
en1    1500  link#3      fa.41.f5.e9.bd.21     1089     0      402     0     0
"""
    netstat_inet6_lo0 = """Name   Mtu   Network     Address                 Ipkts     Ierrs        Opkts     Oerrs  Coll
lo0    16896 link#1                          25611     0    25611     0     0
lo0    16896 ::1%1                           25611     0    25611     0     0
"""
    netstats_out = MagicMock(
        side_effect=[
            netstat_inet4_en0,
            netstat_inet6_en0,
            netstat_inet4_en1,
            netstat_inet6_en1,
            netstat_inet4_lo0,
            netstat_inet6_lo0,
            netstat_inet4_en0,
            netstat_inet6_en0,
            netstat_inet4_en1,
            netstat_inet6_en1,
            netstat_inet4_lo0,
            netstat_inet6_lo0,
        ]
    )
    with patch.dict(
        status.__grains__,
        {
            "osarch": "PowerPC_POWER8",
            "ip4_interfaces": {
                "en0": ["129.40.94.58"],
                "en1": ["172.24.94.58"],
                "lo0": ["127.0.0.1"],
            },
            "ip6_interfaces": {
                "en0": [],
                "en1": [],
                "lo0": ["::1"],
            },
            "kernel": "AIX",
        },
    ), patch.dict(status.__salt__, {"cmd.run": netstats_out}):
        netdev_out = status.netdev()
        assert netstats_out.call_count == 12
        netstats_out.assert_any_call("netstat -i -n -I en0 -f inet")
        netstats_out.assert_any_call("netstat -i -n -I en1 -f inet")
        netstats_out.assert_any_call("netstat -i -n -I lo0 -f inet")
        netstats_out.assert_any_call("netstat -i -n -I en1 -f inet6")
        netstats_out.assert_any_call("netstat -i -n -I lo0 -f inet6")
        expected <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= {
            "en0": [
                {
                    "ipv4": {
                        "Mtu": "1500",
                        "Network": "129.40.94.5",
                        "Address": "129.40.94.58",
                        "Ipkts": "1523125",
                        "Ierrs": "0",
                        "Opkts": "759364",
                        "Oerrs": "0",
                        "Coll": "0",
                    }
                }
            ],
            "en1": [
                {
                    "ipv4": {
                        "Mtu": "1500",
                        "Network": "172.24.94.5",
                        "Address": "172.24.94.58",
                        "Ipkts": "1089",
                        "Ierrs": "0",
                        "Opkts": "402",
                        "Oerrs": "0",
                        "Coll": "0",
                    }
                }
            ],
            "lo0": [
                {
                    "ipv4": {
                        "Mtu": "16896",
                        "Network": "127",
                        "Address": "127.0.0.1",
                        "Ipkts": "25568",
                        "Ierrs": "0",
                        "Opkts": "25568",
                        "Oerrs": "0",
                        "Coll": "0",
                    }
                },
                {
                    "ipv6": {
                        "Mtu"</b></font>: "16896",
                        "Network": "::1%1",
                        "Address": "25611",
                        "Ipkts": "0",
                        "Ierrs": "25611",
                        "Opkts": "0",
                        "Oerrs": "0",
                    }
                },
            ],
        }
        assert netdev_out == expected
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_mine.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
    :codeauthor: Rupesh Tare &lt;rupesht@saltstack.com&gt;
    :codeauthor: Herbert Buurman &lt;herbert.buurman@ogd.nl&gt;
"""
import pytest
import salt.modules.mine as mine
import salt.utils.mine
from salt.utils.odict import OrderedDict
from tests.support.mock import MagicMock, patch
class FakeCache:
    def __init__(self):
        self.data = {}
    def store(self, bank, key, value):
        self.data[bank, key] = value
        return "FakeCache:StoreSuccess!"
    def fetch(self, bank, key):
        return self.data.get((bank, key), {})
    def debug(self):
        print("{}:FakeCache dump:\n{}".format(__name__, self.data))
@pytest.fixture
def mock_cache():
    cache = FakeCache()
    return cache
@pytest.fixture
def configure_loader_modules(mock_cache):
    mock_match = MagicMock(return_value="webserver")
    return {
        mine: {
            "__salt__": {
                "match.glob": mock_match,
                "match.pcre": mock_match,
                "match.list": mock_match,
                "match.grain": mock_match,
                "match.grain_pcre": mock_match,
                "match.ipcidr": mock_match,
                "match.compound": mock_match,
                "match.pillar": mock_match,
                "match.pillar_pcre": mock_match,
                "data.get": lambda key: mock_cache.fetch("minions/webserver", key),
                "data.update": lambda key, value: mock_cache.store(
                    "minions/webserver", key, value
                ),
            }
        }
    }
def test_get_local_empty():
    """
    Tests getting function data from the local mine that does not exist.
    """
    with patch.dict(mine.__opts__, {"file_client": "local", "id": "webserver"}):
        ret_classic = mine.get("*", "funky.doodle")
        ret_dict = mine.get("*", ["funky.doodle"])
    assert ret_classic == {}
    assert ret_dict == {}
def test_get_local_classic(mock_cache):
    """
    Tests getting function data from the local mine that was stored without minion-side ACL.
    This verifies backwards compatible reads from a salt mine.
    """
    mock_cache.store("minions/webserver", "mine_cache", {"foobard": "barfood"})
    with patch.dict(mine.__opts__, {"file_client": "local", "id": "webserver"}):
        ret_classic = mine.get("*", "foobard")
        ret_dict = mine.get("*", ["foobard"])
    assert ret_classic == {"webserver": "barfood"}
    assert ret_dict == {"foobard": {"webserver": "barfood"}}
def test_send_get_local(mock_cache):
    """
    Tests sending an item to the mine in the minion's local cache,
    and then immediately fetching it again (since tests are executed unordered).
    Also verify that the stored mine cache does not use ACL data structure
    without allow_tgt passed.
    """
    foo_ret = "baz"
    ip_ret = "2001:db8::1:3"
    with patch.dict(
        mine.__opts__, {"file_client": "local", "id": "webserver"}
    ), patch.dict(
        mine.__salt__,
        {
            "network.ip_addrs": MagicMock(return_value=ip_ret),
            "foo.bar": MagicMock(return_value=foo_ret),
        },
    ):
        ret = mine.send("ip_addr", mine_function="network.ip_addrs")
        mine.send("foo.bar")
    assert ret == "FakeCache:StoreSuccess!"
    assert mock_cache.fetch("minions/webserver", "mine_cache") == {
        "ip_addr": ip_ret,
        "foo.bar": foo_ret,
    }
    with patch.dict(mine.__opts__, {"file_client": "local", "id": "webserver"}):
        ret_single = mine.get("*", "ip_addr")
        ret_single_dict = mine.get("*", ["ip_addr"])
        ret_multi = mine.get("*", "ip_addr,foo.bar")
        ret_multi2 = mine.get("*", ["ip_addr", "foo.bar"])
    assert ret_single == {"webserver": ip_ret}
    assert ret_single_dict == {"ip_addr": {"webserver": ip_ret}}
    assert ret_multi == {
        "ip_addr": {"webserver": ip_ret},
        "foo.bar": {"webserver": foo_ret},
    }
    assert ret_multi == ret_multi2
def test_send_get_acl_local(mock_cache):
    """
    Tests sending an item to the mine in the minion's local cache,
    including ACL information (useless when only working locally, but hey),
    and then immediately fetching it again (since tests are executed unordered).
    Also verify that the stored mine cache has the correct structure (with ACL)
    when using allow_tgt and no ACL without allow_tgt.
    """
    foo_ret = "baz"
    ip_ret = "2001:db8::1:3"
    with patch.dict(
        mine.__opts__, {"file_client": "local", "id": "webserver"}
    ), patch.dict(
        mine.__salt__,
        {
            "network.ip_addrs": MagicMock(return_value=ip_ret),
            "foo.bar": MagicMock(return_value=foo_ret),
        },
    ):
        ret = mine.send(
            "ip_addr",
            mine_function="network.ip_addrs",
            allow_tgt="web*",
            allow_tgt_type="glob",
        )
        mine.send("foo.bar")
    assert ret == "FakeCache:StoreSuccess!"
    assert mock_cache.fetch("minions/webserver", "mine_cache") == {
        "ip_addr": {
            salt.utils.mine.MINE_ITEM_ACL_DATA: ip_ret,
            salt.utils.mine.MINE_ITEM_ACL_ID: salt.utils.mine.MINE_ITEM_ACL_VERSION,
            "allow_tgt": "web*",
            "allow_tgt_type": "glob",
        },
        "foo.bar": foo_ret,
    }
    with patch.dict(mine.__opts__, {"file_client": "local", "id": "webserver"}):
        ret_single = mine.get("*", "ip_addr")
    assert ret_single == {"webserver": ip_ret}
def test_send_master():
    """
    Tests sending an item to the mine stored on the master.
    This is done by capturing the load that is sent to the master.
    """
    foo_ret = "baz"
    with patch.object(
        mine, "_mine_send", MagicMock(side_effect=lambda x, y: x)
    ), patch.dict(
        mine.__salt__, {"foo.bar": MagicMock(return_value=foo_ret)}
    ), patch.dict(
        mine.__opts__, {"file_client": "remote", "id": "foo"}
    ):
        ret = mine.send("foo.bar")
    assert ret == {
        "id": "foo",
        "cmd": "_mine",
        "data": {"foo.bar": foo_ret},
        "clear": False,
    }
def test_send_master_acl():
    """
    Tests sending an item to the mine stored on the master. Now with ACL.
    This is done by capturing the load that is sent to the master.
    """
    foo_ret = "baz"
    with patch.object(
        mine, "_mine_send", MagicMock(side_effect=lambda x, y: x)
    ), patch.dict(
        mine.__salt__, {"foo.bar": MagicMock(return_value=foo_ret)}
    ), patch.dict(
        mine.__opts__, {"file_client": "remote", "id": "foo"}
    ):
        ret = mine.send("foo.bar", allow_tgt="roles:web", allow_tgt_type="grains")
    assert ret == {
        "id": "foo",
        "cmd": "_mine",
        "data": {
            "foo.bar": {
                salt.utils.mine.MINE_ITEM_ACL_DATA: foo_ret,
                salt.utils.mine.MINE_ITEM_ACL_ID: salt.utils.mine.MINE_ITEM_ACL_VERSION,
                "allow_tgt": "roles:web",
                "allow_tgt_type": "grains",
            },
        },
        "clear": False,
    }
def test_get_master():
    """
    Tests loading a mine item from the mine stored on the master.
    """
    foo_ret = "baz"
    mock_load = {
        "tgt_type": "qux",
        "tgt": foo_ret,
        "cmd": "_mine_get",
        "fun": "foo.bar",
        "id": "foo",
    }
    with patch.object(mine, "_mine_get", MagicMock(return_value=mock_load)), patch.dict(
        mine.__opts__, {"file_client": "remote", "id": "foo"}
    ):
        assert mine.get("*", "foo.bar") == mock_load
def test_get_master_exclude_minion():
    """
    Tests the exclude_minion-parameter for mine.get
    """
    _mine_get_ret = OrderedDict([("webserver", "value")])
    with patch.object(
        mine, "_mine_get", MagicMock(return_value=_mine_get_ret)
    ), patch.dict(mine.__opts__, {"file_client": "remote", "id": "webserver"}):
        assert mine.get("*", "foo.bar", exclude_minion=False) == {"webserver": "value"}
        assert mine.get("*", "foo.bar", exclude_minion=True) == {}
def test_update_local(mock_cache):
    """
    Tests the ``update``-function on the minion's local cache.
    Updates mine functions from pillar+config only.
    """
    kernel_ret = "Linux!"
    foo_ret = "baz"
    ip_ret = "2001:db8::1:3"
    config_mine_functions = {
        "ip_addr": {"mine_function": "network.ip_addrs"},
        "network.ip_addrs": [],
        "kernel": [
            {"mine_function": "grains.get"},
            "kernel",
            {"allow_tgt": "web*"},
        ],
        "foo.bar": {"allow_tgt": "G@roles:webserver", "allow_tgt_type": "compound"},
    }
    with patch.dict(
        mine.__opts__, {"file_client": "local", "id": "webserver"}
    ), patch.dict(
        mine.__salt__,
        {
            "config.merge": MagicMock(return_value=config_mine_functions),
            "grains.get": lambda x: kernel_ret,
            "network.ip_addrs": MagicMock(return_value=ip_ret),
            "foo.bar": MagicMock(return_value=foo_ret),
        },
    ):
        ret = mine.update()
    assert ret == "FakeCache:StoreSuccess!"
    assert mock_cache.fetch("minions/webserver", "mine_cache") == {
        "ip_addr": ip_ret,
        "network.ip_addrs": ip_ret,
        "foo.bar": {
            salt.utils.mine.MINE_ITEM_ACL_DATA: foo_ret,
            salt.utils.mine.MINE_ITEM_ACL_ID: salt.utils.mine.MINE_ITEM_ACL_VERSION,
            "allow_tgt": "G@roles:webserver",
            "allow_tgt_type": "compound",
        },
        "kernel": {
            salt.utils.mine.MINE_ITEM_ACL_DATA: kernel_ret,
            salt.utils.mine.MINE_ITEM_ACL_ID: salt.utils.mine.MINE_ITEM_ACL_VERSION,
            "allow_tgt": "web*",
        },
    }
def test_update_local_specific(mock_cache):
    """
    Tests the ``update``-function on the minion's local cache.
    Updates mine functions from kwargs only.
    """
    foo_ret = "baz"
    ip_ret = "2001:db8::1:3"
    manual_mine_functions = {
        "ip_addr": {"mine_function": "network.ip_addrs"},
        "network.ip_addrs": [],
        "kernel": [
            {"mine_function": "grains.get"},
            "kernel",
            {"allow_tgt": "web*"},
        ],
        "foo.bar": {"allow_tgt": "G@roles:webserver", "allow_tgt_type": "compound"},
    }
    with patch.dict(
        mine.__opts__, {"file_client": "local", "id": "webserver"}
    ), patch.dict(
        mine.__salt__,
        {
            "config.merge": MagicMock(return_value={}),
            "grains.get": lambda x: "Linux!!",
            "network.ip_addrs": MagicMock(return_value=ip_ret),
            "foo.bar": MagicMock(return_value=foo_ret),
        },
    ):
        ret = mine.update(mine_functions=manual_mine_functions)
    assert ret == "FakeCache:StoreSuccess!"
    assert mock_cache.fetch("minions/webserver", "mine_cache") == {
        "ip_addr": ip_ret,
        "network.ip_addrs": ip_ret,
        "foo.bar": {
            salt.utils.mine.MINE_ITEM_ACL_DATA: foo_ret,
            salt.utils.mine.MINE_ITEM_ACL_ID: salt.utils.mine.MINE_ITEM_ACL_VERSION,
            "allow_tgt": "G@roles:webserver",
            "allow_tgt_type": "compound",
        },
        "kernel": {
            salt.utils.mine.MINE_ITEM_ACL_DATA: "Linux!!",
            salt.utils.mine.MINE_ITEM_ACL_ID: salt.utils.mine.MINE_ITEM_ACL_VERSION,
            "allow_tgt": "web*",
        },
    }
def test_update_master():
    """
    Tests whether the ``update``-function sends the correct data to the master.
    """
    kernel_ret = "Linux!"
    foo_ret = "baz"
    ip_ret = "2001:db8::1:3"
    config_mine_functions = {
        "ip_addr": {"mine_function": "network.ip_addrs"},
        "network.ip_addrs": [],
        "kernel": [{"mine_function": "grains.get"}, "kernel"],
        "foo.bar": {},
    }
    mock_load = {
        "id": "webserver",
        "cmd": "_mine",
        "data": {
            "ip_addr": ip_ret,
            "network.ip_addrs": ip_ret,
            "foo.bar": foo_ret,
            "kernel": kernel_ret,
        },
        "clear": False,
    }
    with patch.object(
        mine, "_mine_send", MagicMock(side_effect=lambda x, y: x)
    ), patch.dict(
        mine.__opts__, {"file_client": "remote", "id": "webserver"}
    ), patch.dict(
        mine.__salt__,
        {
            "config.merge": MagicMock(return_value=config_mine_functions),
            "grains.get": lambda x: kernel_ret,
            "network.ip_addrs": MagicMock(return_value=ip_ret),
            "foo.bar": MagicMock(return_value=foo_ret),
        },
    ):
        assert mine.update() == mock_load
def test_delete_local(mock_cache):
    """
    Tests the ``delete``-function on the minion's local cache.
    """
    mock_cache.store("minions/webserver", "mine_cache", {"foobard": "barfood"})
    with patch.dict(mine.__opts__, {"file_client": "local", "id": "webserver"}):
        ret = mine.delete("foobard")
        assert mock_cache.fetch("minions/webserver", "mine_cache") == {}
def test_delete_master(mock_cache):
    """
    Tests whether the ``delete``-function sends the correct data to the master.
    """
    mock_cache.store("minions/webserver", "mine_cache", {"foobard": "barfood"})
    mock_load = {
        "cmd": "_mine_delete",
        "fun": "foobard",
        "id": "foo",
    }
    with patch.object(
        mine, "_mine_send", MagicMock(side_effect=lambda x, y: x)
    ), patch.dict(mine.__opts__, {"file_client": "remote", "id": "foo"}):
        assert mine.delete("foobard") == mock_load
def test_flush_local(mock_cache):
    """
    Tests the ``flush``-function on the minion's local cache.
    """
    mock_cache.store("minions/webserver", "mine_cache", {"foobard": "barfood"})
    with patch.dict(mine.__opts__, {"file_client": "local", "id": "webserver"}):
        ret = mine.flush()
        assert mock_cache.fetch("minions/webserver", "mine_cache") == {}
def test_flush_master():
    """
    Tests whether the ``flush``-function sends the correct data to the master.
    """
    mock_load = {"cmd": "_mine_flush", "id": "foo"}
    with patch.object(
        mine, "_mine_send", MagicMock(side_effect=lambda x, y: x)
    ), patch.dict(mine.__opts__, {"file_client": "remote", "id": "foo"}):
        assert mine.flush() == mock_load
def test_valid():
    """
    Tests the ``valid``-function.
    Note that mine functions defined as list are returned in dict format.
    Mine functions that do not exist in __salt__ are not returned.
    """
    config_mine_functions = {
        "network.ip_addrs": [],
        "kernel": [
            {"mine_function": "grains.get"},
            "kernel",
            {"os": "win32", "v": "2018"},
        ],
        "fubar": [{"mine_function": "does.not_exist"}],
    }
    with patch.dict(
        mine.__salt__,
        {
            "config.merge": MagicMock(return_value=config_mine_functions),
            "network.ip_addrs": lambda: True,
            "grains.get": lambda: True,
        },
    ):
        ret = mine.valid()
        assert isinstance(ret["kernel"]["grains.get"], list)
        assert len(ret["kernel"]["grains.get"]) == 3
        for item in ("kernel", {"os": "win32"}, {"v": "2018"}):
            assert item in ret["kernel"]["grains.get"]
        ret["kernel"]["grains.get"] = None
        assert ret == {"network.ip_addrs": [], "kernel": {"grains.get": None}}
def test_get_docker():
    """
    aggregation.
    """
    ps_response <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= {
        "localhost": {
            "host": {
                "interfaces": {
                    "docker0": {
                        "hwaddr": "88:99:00:00:99:99",
                        "inet": [
                            {
                                "address": "172.17.42.1",
                                "broadcast": None,
                                "label": "docker0",
                                "netmask": "255.255.0.0",
                            }
                        ],
                        "inet6": [
                            {
                                "address": "ffff::eeee:aaaa:bbbb:8888",
                                "prefixlen": "64",
                            }
                        ],
                        "up": True,
                    },
                    "eth0": {
                        "hwaddr": "88:99:00:99:99:99",
                        "inet": [
                            {
                                "address"</b></font>: "192.168.0.1",
                                "broadcast": "192.168.0.255",
                                "label": "eth0",
                                "netmask": "255.255.255.0",
                            }
                        ],
                        "inet6": [
                            {
                                "address": "ffff::aaaa:aaaa:bbbb:8888",
                                "prefixlen": "64",
                            }
                        ],
                        "up": True,
                    },
                }
            },
            "abcdefhjhi1234567899": {  # container Id
                "Ports": [
                    {
                        "IP": "0.0.0.0",  # we bind on every interfaces
                        "PrivatePort": 80,
                        "PublicPort": 80,
                        "Type": "tcp",
                    }
                ],
                "Image": "image:latest",
                "Info": {"Id": "abcdefhjhi1234567899"},
            },
        }
    }
    with patch.object(mine, "get", return_value=ps_response):
        ret = mine.get_docker()
        ret["image:latest"]["ipv4"][80] = sorted(ret["image:latest"]["ipv4"][80])
        assert ret == {
            "image:latest": {"ipv4": {80: sorted(["172.17.42.1:80", "192.168.0.1:80"])}}
        }
def test_get_docker_with_container_id():
    """
    Test for Get all mine data for 'docker.ps' and run an
    aggregation.
    """
    ps_response = {
        "localhost": {
            "host": {
                "interfaces": {
                    "docker0": {
                        "hwaddr": "88:99:00:00:99:99",
                        "inet": [
                            {
                                "address": "172.17.42.1",
                                "broadcast": None,
                                "label": "docker0",
                                "netmask": "255.255.0.0",
                            }
                        ],
                        "inet6": [
                            {
                                "address": "ffff::eeee:aaaa:bbbb:8888",
                                "prefixlen": "64",
                            }
                        ],
                        "up": True,
                    },
                    "eth0": {
                        "hwaddr": "88:99:00:99:99:99",
                        "inet": [
                            {
                                "address": "192.168.0.1",
                                "broadcast": "192.168.0.255",
                                "label": "eth0",
                                "netmask": "255.255.255.0",
                            }
                        ],
                        "inet6": [
                            {
                                "address": "ffff::aaaa:aaaa:bbbb:8888",
                                "prefixlen": "64",
                            }
                        ],
                        "up": True,
                    },
                }
            },
            "abcdefhjhi1234567899": {  # container Id
                "Ports": [
                    {
                        "IP": "0.0.0.0",  # we bind on every interfaces
                        "PrivatePort": 80,
                        "PublicPort": 80,
                        "Type": "tcp",
                    }
                ],
                "Image": "image:latest",
                "Info": {"Id": "abcdefhjhi1234567899"},
            },
        }
    }
    with patch.object(mine, "get", return_value=ps_response):
        ret = mine.get_docker(with_container_id=True)
        ret["image:latest"]["ipv4"][80] = sorted(ret["image:latest"]["ipv4"][80])
        assert ret == {
            "image:latest": {
                "ipv4": {
                    80: sorted(
                        [
                            ("172.17.42.1:80", "abcdefhjhi1234567899"),
                            ("192.168.0.1:80", "abcdefhjhi1234567899"),
                        ]
                    )
                }
            }
        }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
