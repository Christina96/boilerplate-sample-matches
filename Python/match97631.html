<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_aix_status.py & test_mine.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_aix_status.py & test_mine.py
      </h3>
      <h1 align="center">
        3.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_aix_status.py (16.25%)<TH>test_mine.py (1.951952%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match97631-0.html#0',2,'match97631-1.html#0',3)" NAME="0">(116-160)<TD><A HREF="javascript:ZweiFrames('match97631-0.html#0',2,'match97631-1.html#0',3)" NAME="0">(471-497)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_aix_status.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
import logging
import sys

import pytest
import salt.modules.status as status
from tests.support.mock import MagicMock, patch

log = logging.getLogger(__name__)


@pytest.fixture
def configure_loader_modules():

    return {
        status: {
            &quot;__grains__&quot;: {
                &quot;ip4_interfaces&quot;: {
                    &quot;en0&quot;: [&quot;129.40.94.58&quot;],
                    &quot;en1&quot;: [&quot;172.24.94.58&quot;],
                    &quot;lo0&quot;: [&quot;127.0.0.1&quot;],
                },
                &quot;ip6_interfaces&quot;: {&quot;en0&quot;: [], &quot;en1&quot;: [], &quot;lo0&quot;: [&quot;1&quot;]},
                &quot;kernel&quot;: &quot;AIX&quot;,
                &quot;osarch&quot;: &quot;PowerPC_POWER8&quot;,
                &quot;os&quot;: &quot;AIX&quot;,
                &quot;os_family&quot;: &quot;AIX&quot;,
                &quot;osmajorrelease&quot;: 7,
            },
        },
    }


@pytest.mark.skipif(
    sys.version_info[0] == 3 and sys.version_info[1] &lt;= 5,
    reason=&quot;run on Python 3.6 or greater where OrderedDict is default&quot;,
)
def test_netdev():
    &quot;&quot;&quot;
    Test status.netdev for AIX

    :return:
    &quot;&quot;&quot;
    # Output from netstat -i -n -I &lt;en0|en1|lo0&gt; -f inet
    netstat_inet4_en0 = &quot;&quot;&quot;Name   Mtu   Network     Address                 Ipkts     Ierrs        Opkts     Oerrs  Coll
en0    1500  link#2      fa.41.f5.e9.bd.20  1523125     0   759364     0     0
en0    1500  129.40.94.5 129.40.94.58      1523125     0   759364     0     0
&quot;&quot;&quot;

    netstat_inet4_en1 = &quot;&quot;&quot;Name   Mtu   Network     Address                 Ipkts     Ierrs        Opkts     Oerrs  Coll
en1    1500  link#3      fa.41.f5.e9.bd.21     1089     0      402     0     0
en1    1500  172.24.94.5 172.24.94.58         1089     0      402     0     0
&quot;&quot;&quot;

    netstat_inet4_lo0 = &quot;&quot;&quot;Name   Mtu   Network     Address                 Ipkts     Ierrs        Opkts     Oerrs  Coll
lo0    16896 link#1                          25568     0    25568     0     0
lo0    16896 127         127.0.0.1           25568     0    25568     0     0
&quot;&quot;&quot;

    # Output from netstat -i -n -I &lt;en0|en1|lo0&gt; -f inet6
    netstat_inet6_en0 = &quot;&quot;&quot;Name   Mtu   Network     Address                 Ipkts     Ierrs        Opkts     Oerrs  Coll
en0    1500  link#2      fa.41.f5.e9.bd.20  1523160     0   759397     0     0
&quot;&quot;&quot;

    netstat_inet6_en1 = &quot;&quot;&quot;Name   Mtu   Network     Address                 Ipkts     Ierrs        Opkts     Oerrs  Coll
en1    1500  link#3      fa.41.f5.e9.bd.21     1089     0      402     0     0
&quot;&quot;&quot;

    netstat_inet6_lo0 = &quot;&quot;&quot;Name   Mtu   Network     Address                 Ipkts     Ierrs        Opkts     Oerrs  Coll
lo0    16896 link#1                          25611     0    25611     0     0
lo0    16896 ::1%1                           25611     0    25611     0     0
&quot;&quot;&quot;

    # allow en0, en1 and lo0 for ipv4 and ipv6
    netstats_out = MagicMock(
        side_effect=[
            netstat_inet4_en0,
            netstat_inet6_en0,
            netstat_inet4_en1,
            netstat_inet6_en1,
            netstat_inet4_lo0,
            netstat_inet6_lo0,
            netstat_inet4_en0,
            netstat_inet6_en0,
            netstat_inet4_en1,
            netstat_inet6_en1,
            netstat_inet4_lo0,
            netstat_inet6_lo0,
        ]
    )

    with patch.dict(
        status.__grains__,
        {
            &quot;osarch&quot;: &quot;PowerPC_POWER8&quot;,
            &quot;ip4_interfaces&quot;: {
                &quot;en0&quot;: [&quot;129.40.94.58&quot;],
                &quot;en1&quot;: [&quot;172.24.94.58&quot;],
                &quot;lo0&quot;: [&quot;127.0.0.1&quot;],
            },
            &quot;ip6_interfaces&quot;: {
                &quot;en0&quot;: [],
                &quot;en1&quot;: [],
                &quot;lo0&quot;: [&quot;::1&quot;],
            },
            &quot;kernel&quot;: &quot;AIX&quot;,
        },
    ), patch.dict(status.__salt__, {&quot;cmd.run&quot;: netstats_out}):
        netdev_out = status.netdev()
        assert netstats_out.call_count == 12
        netstats_out.assert_any_call(&quot;netstat -i -n -I en0 -f inet&quot;)
        netstats_out.assert_any_call(&quot;netstat -i -n -I en1 -f inet&quot;)
        netstats_out.assert_any_call(&quot;netstat -i -n -I lo0 -f inet&quot;)
<A NAME="0"></A>        netstats_out.assert_any_call(&quot;netstat -i -n -I en0 -f inet6&quot;)
        netstats_out.assert_any_call(&quot;netstat -i -n -I en1 -f inet6&quot;)
        netstats_out.assert_any_call(&quot;netstat -i -n -I lo0 -f inet6&quot;)
        expected <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match97631-1.html#0',3,'match97631-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>= {
            &quot;en0&quot;: [
                {
                    &quot;ipv4&quot;: {
                        &quot;Mtu&quot;: &quot;1500&quot;,
                        &quot;Network&quot;: &quot;129.40.94.5&quot;,
                        &quot;Address&quot;: &quot;129.40.94.58&quot;,
                        &quot;Ipkts&quot;: &quot;1523125&quot;,
                        &quot;Ierrs&quot;: &quot;0&quot;,
                        &quot;Opkts&quot;: &quot;759364&quot;,
                        &quot;Oerrs&quot;: &quot;0&quot;,
                        &quot;Coll&quot;: &quot;0&quot;,
                    }
                }
            ],
            &quot;en1&quot;: [
                {
                    &quot;ipv4&quot;: {
                        &quot;Mtu&quot;: &quot;1500&quot;,
                        &quot;Network&quot;: &quot;172.24.94.5&quot;,
                        &quot;Address&quot;: &quot;172.24.94.58&quot;,
                        &quot;Ipkts&quot;: &quot;1089&quot;,
                        &quot;Ierrs&quot;: &quot;0&quot;,
                        &quot;Opkts&quot;: &quot;402&quot;,
                        &quot;Oerrs&quot;: &quot;0&quot;,
                        &quot;Coll&quot;: &quot;0&quot;,
                    }
                }
            ],
            &quot;lo0&quot;: [
                {
                    &quot;ipv4&quot;: {
                        &quot;Mtu&quot;: &quot;16896&quot;,
                        &quot;Network&quot;: &quot;127&quot;,
                        &quot;Address&quot;: &quot;127.0.0.1&quot;,
                        &quot;Ipkts&quot;: &quot;25568&quot;,
                        &quot;Ierrs&quot;: &quot;0&quot;,
                        &quot;Opkts&quot;: &quot;25568&quot;,
                        &quot;Oerrs&quot;: &quot;0&quot;,
                        &quot;Coll&quot;: &quot;0&quot;,
                    }
                },
                {
                    &quot;ipv6&quot;: {
                        &quot;Mtu&quot;</B></FONT>: &quot;16896&quot;,
                        &quot;Network&quot;: &quot;::1%1&quot;,
                        &quot;Address&quot;: &quot;25611&quot;,
                        &quot;Ipkts&quot;: &quot;0&quot;,
                        &quot;Ierrs&quot;: &quot;25611&quot;,
                        &quot;Opkts&quot;: &quot;0&quot;,
                        &quot;Oerrs&quot;: &quot;0&quot;,
                    }
                },
            ],
        }
        assert netdev_out == expected
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_mine.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
    :codeauthor: Rupesh Tare &lt;rupesht@saltstack.com&gt;
    :codeauthor: Herbert Buurman &lt;herbert.buurman@ogd.nl&gt;
&quot;&quot;&quot;


import pytest
import salt.modules.mine as mine
import salt.utils.mine
from salt.utils.odict import OrderedDict
from tests.support.mock import MagicMock, patch


class FakeCache:
    def __init__(self):
        self.data = {}

    def store(self, bank, key, value):
        self.data[bank, key] = value
        return &quot;FakeCache:StoreSuccess!&quot;

    def fetch(self, bank, key):
        return self.data.get((bank, key), {})

    def debug(self):
        print(&quot;{}:FakeCache dump:\n{}&quot;.format(__name__, self.data))


@pytest.fixture
def mock_cache():
    cache = FakeCache()
    return cache


@pytest.fixture
def configure_loader_modules(mock_cache):
    mock_match = MagicMock(return_value=&quot;webserver&quot;)
    return {
        mine: {
            &quot;__salt__&quot;: {
                &quot;match.glob&quot;: mock_match,
                &quot;match.pcre&quot;: mock_match,
                &quot;match.list&quot;: mock_match,
                &quot;match.grain&quot;: mock_match,
                &quot;match.grain_pcre&quot;: mock_match,
                &quot;match.ipcidr&quot;: mock_match,
                &quot;match.compound&quot;: mock_match,
                &quot;match.pillar&quot;: mock_match,
                &quot;match.pillar_pcre&quot;: mock_match,
                &quot;data.get&quot;: lambda key: mock_cache.fetch(&quot;minions/webserver&quot;, key),
                &quot;data.update&quot;: lambda key, value: mock_cache.store(
                    &quot;minions/webserver&quot;, key, value
                ),
            }
        }
    }


def test_get_local_empty():
    &quot;&quot;&quot;
    Tests getting function data from the local mine that does not exist.
    &quot;&quot;&quot;
    with patch.dict(mine.__opts__, {&quot;file_client&quot;: &quot;local&quot;, &quot;id&quot;: &quot;webserver&quot;}):
        ret_classic = mine.get(&quot;*&quot;, &quot;funky.doodle&quot;)
        ret_dict = mine.get(&quot;*&quot;, [&quot;funky.doodle&quot;])
    assert ret_classic == {}
    assert ret_dict == {}


def test_get_local_classic(mock_cache):
    &quot;&quot;&quot;
    Tests getting function data from the local mine that was stored without minion-side ACL.
    This verifies backwards compatible reads from a salt mine.
    &quot;&quot;&quot;
    # Prefill minion cache with a non-ACL value
    mock_cache.store(&quot;minions/webserver&quot;, &quot;mine_cache&quot;, {&quot;foobard&quot;: &quot;barfood&quot;})
    with patch.dict(mine.__opts__, {&quot;file_client&quot;: &quot;local&quot;, &quot;id&quot;: &quot;webserver&quot;}):
        ret_classic = mine.get(&quot;*&quot;, &quot;foobard&quot;)
        ret_dict = mine.get(&quot;*&quot;, [&quot;foobard&quot;])
    assert ret_classic == {&quot;webserver&quot;: &quot;barfood&quot;}
    assert ret_dict == {&quot;foobard&quot;: {&quot;webserver&quot;: &quot;barfood&quot;}}


def test_send_get_local(mock_cache):
    &quot;&quot;&quot;
    Tests sending an item to the mine in the minion's local cache,
    and then immediately fetching it again (since tests are executed unordered).
    Also verify that the stored mine cache does not use ACL data structure
    without allow_tgt passed.
    &quot;&quot;&quot;
    foo_ret = &quot;baz&quot;
    ip_ret = &quot;2001:db8::1:3&quot;
    with patch.dict(
        mine.__opts__, {&quot;file_client&quot;: &quot;local&quot;, &quot;id&quot;: &quot;webserver&quot;}
    ), patch.dict(
        mine.__salt__,
        {
            &quot;network.ip_addrs&quot;: MagicMock(return_value=ip_ret),
            &quot;foo.bar&quot;: MagicMock(return_value=foo_ret),
        },
    ):
        ret = mine.send(&quot;ip_addr&quot;, mine_function=&quot;network.ip_addrs&quot;)
        mine.send(&quot;foo.bar&quot;)
    assert ret == &quot;FakeCache:StoreSuccess!&quot;
    assert mock_cache.fetch(&quot;minions/webserver&quot;, &quot;mine_cache&quot;) == {
        &quot;ip_addr&quot;: ip_ret,
        &quot;foo.bar&quot;: foo_ret,
    }
    with patch.dict(mine.__opts__, {&quot;file_client&quot;: &quot;local&quot;, &quot;id&quot;: &quot;webserver&quot;}):
        ret_single = mine.get(&quot;*&quot;, &quot;ip_addr&quot;)
        ret_single_dict = mine.get(&quot;*&quot;, [&quot;ip_addr&quot;])
        ret_multi = mine.get(&quot;*&quot;, &quot;ip_addr,foo.bar&quot;)
        ret_multi2 = mine.get(&quot;*&quot;, [&quot;ip_addr&quot;, &quot;foo.bar&quot;])
    assert ret_single == {&quot;webserver&quot;: ip_ret}
    assert ret_single_dict == {&quot;ip_addr&quot;: {&quot;webserver&quot;: ip_ret}}
    assert ret_multi == {
        &quot;ip_addr&quot;: {&quot;webserver&quot;: ip_ret},
        &quot;foo.bar&quot;: {&quot;webserver&quot;: foo_ret},
    }
    assert ret_multi == ret_multi2


def test_send_get_acl_local(mock_cache):
    &quot;&quot;&quot;
    Tests sending an item to the mine in the minion's local cache,
    including ACL information (useless when only working locally, but hey),
    and then immediately fetching it again (since tests are executed unordered).
    Also verify that the stored mine cache has the correct structure (with ACL)
    when using allow_tgt and no ACL without allow_tgt.
    &quot;&quot;&quot;
    foo_ret = &quot;baz&quot;
    ip_ret = &quot;2001:db8::1:3&quot;
    with patch.dict(
        mine.__opts__, {&quot;file_client&quot;: &quot;local&quot;, &quot;id&quot;: &quot;webserver&quot;}
    ), patch.dict(
        mine.__salt__,
        {
            &quot;network.ip_addrs&quot;: MagicMock(return_value=ip_ret),
            &quot;foo.bar&quot;: MagicMock(return_value=foo_ret),
        },
    ):
        ret = mine.send(
            &quot;ip_addr&quot;,
            mine_function=&quot;network.ip_addrs&quot;,
            allow_tgt=&quot;web*&quot;,
            allow_tgt_type=&quot;glob&quot;,
        )
        mine.send(&quot;foo.bar&quot;)
    assert ret == &quot;FakeCache:StoreSuccess!&quot;
    assert mock_cache.fetch(&quot;minions/webserver&quot;, &quot;mine_cache&quot;) == {
        &quot;ip_addr&quot;: {
            salt.utils.mine.MINE_ITEM_ACL_DATA: ip_ret,
            salt.utils.mine.MINE_ITEM_ACL_ID: salt.utils.mine.MINE_ITEM_ACL_VERSION,
            &quot;allow_tgt&quot;: &quot;web*&quot;,
            &quot;allow_tgt_type&quot;: &quot;glob&quot;,
        },
        &quot;foo.bar&quot;: foo_ret,
    }
    with patch.dict(mine.__opts__, {&quot;file_client&quot;: &quot;local&quot;, &quot;id&quot;: &quot;webserver&quot;}):
        ret_single = mine.get(&quot;*&quot;, &quot;ip_addr&quot;)
    assert ret_single == {&quot;webserver&quot;: ip_ret}


def test_send_master():
    &quot;&quot;&quot;
    Tests sending an item to the mine stored on the master.
    This is done by capturing the load that is sent to the master.
    &quot;&quot;&quot;
    foo_ret = &quot;baz&quot;
    with patch.object(
        mine, &quot;_mine_send&quot;, MagicMock(side_effect=lambda x, y: x)
    ), patch.dict(
        mine.__salt__, {&quot;foo.bar&quot;: MagicMock(return_value=foo_ret)}
    ), patch.dict(
        mine.__opts__, {&quot;file_client&quot;: &quot;remote&quot;, &quot;id&quot;: &quot;foo&quot;}
    ):
        ret = mine.send(&quot;foo.bar&quot;)
    assert ret == {
        &quot;id&quot;: &quot;foo&quot;,
        &quot;cmd&quot;: &quot;_mine&quot;,
        &quot;data&quot;: {&quot;foo.bar&quot;: foo_ret},
        &quot;clear&quot;: False,
    }


def test_send_master_acl():
    &quot;&quot;&quot;
    Tests sending an item to the mine stored on the master. Now with ACL.
    This is done by capturing the load that is sent to the master.
    &quot;&quot;&quot;
    foo_ret = &quot;baz&quot;
    with patch.object(
        mine, &quot;_mine_send&quot;, MagicMock(side_effect=lambda x, y: x)
    ), patch.dict(
        mine.__salt__, {&quot;foo.bar&quot;: MagicMock(return_value=foo_ret)}
    ), patch.dict(
        mine.__opts__, {&quot;file_client&quot;: &quot;remote&quot;, &quot;id&quot;: &quot;foo&quot;}
    ):
        ret = mine.send(&quot;foo.bar&quot;, allow_tgt=&quot;roles:web&quot;, allow_tgt_type=&quot;grains&quot;)
    assert ret == {
        &quot;id&quot;: &quot;foo&quot;,
        &quot;cmd&quot;: &quot;_mine&quot;,
        &quot;data&quot;: {
            &quot;foo.bar&quot;: {
                salt.utils.mine.MINE_ITEM_ACL_DATA: foo_ret,
                salt.utils.mine.MINE_ITEM_ACL_ID: salt.utils.mine.MINE_ITEM_ACL_VERSION,
                &quot;allow_tgt&quot;: &quot;roles:web&quot;,
                &quot;allow_tgt_type&quot;: &quot;grains&quot;,
            },
        },
        &quot;clear&quot;: False,
    }


def test_get_master():
    &quot;&quot;&quot;
    Tests loading a mine item from the mine stored on the master.
    &quot;&quot;&quot;
    foo_ret = &quot;baz&quot;
    mock_load = {
        &quot;tgt_type&quot;: &quot;qux&quot;,
        &quot;tgt&quot;: foo_ret,
        &quot;cmd&quot;: &quot;_mine_get&quot;,
        &quot;fun&quot;: &quot;foo.bar&quot;,
        &quot;id&quot;: &quot;foo&quot;,
    }
    with patch.object(mine, &quot;_mine_get&quot;, MagicMock(return_value=mock_load)), patch.dict(
        mine.__opts__, {&quot;file_client&quot;: &quot;remote&quot;, &quot;id&quot;: &quot;foo&quot;}
    ):
        assert mine.get(&quot;*&quot;, &quot;foo.bar&quot;) == mock_load


def test_get_master_exclude_minion():
    &quot;&quot;&quot;
    Tests the exclude_minion-parameter for mine.get
    &quot;&quot;&quot;
    _mine_get_ret = OrderedDict([(&quot;webserver&quot;, &quot;value&quot;)])
    with patch.object(
        mine, &quot;_mine_get&quot;, MagicMock(return_value=_mine_get_ret)
    ), patch.dict(mine.__opts__, {&quot;file_client&quot;: &quot;remote&quot;, &quot;id&quot;: &quot;webserver&quot;}):
        assert mine.get(&quot;*&quot;, &quot;foo.bar&quot;, exclude_minion=False) == {&quot;webserver&quot;: &quot;value&quot;}
        assert mine.get(&quot;*&quot;, &quot;foo.bar&quot;, exclude_minion=True) == {}


def test_update_local(mock_cache):
    &quot;&quot;&quot;
    Tests the ``update``-function on the minion's local cache.
    Updates mine functions from pillar+config only.
    &quot;&quot;&quot;
    kernel_ret = &quot;Linux!&quot;
    foo_ret = &quot;baz&quot;
    ip_ret = &quot;2001:db8::1:3&quot;
    config_mine_functions = {
        &quot;ip_addr&quot;: {&quot;mine_function&quot;: &quot;network.ip_addrs&quot;},
        &quot;network.ip_addrs&quot;: [],
        &quot;kernel&quot;: [
            {&quot;mine_function&quot;: &quot;grains.get&quot;},
            &quot;kernel&quot;,
            {&quot;allow_tgt&quot;: &quot;web*&quot;},
        ],
        &quot;foo.bar&quot;: {&quot;allow_tgt&quot;: &quot;G@roles:webserver&quot;, &quot;allow_tgt_type&quot;: &quot;compound&quot;},
    }
    with patch.dict(
        mine.__opts__, {&quot;file_client&quot;: &quot;local&quot;, &quot;id&quot;: &quot;webserver&quot;}
    ), patch.dict(
        mine.__salt__,
        {
            &quot;config.merge&quot;: MagicMock(return_value=config_mine_functions),
            &quot;grains.get&quot;: lambda x: kernel_ret,
            &quot;network.ip_addrs&quot;: MagicMock(return_value=ip_ret),
            &quot;foo.bar&quot;: MagicMock(return_value=foo_ret),
        },
    ):
        ret = mine.update()
    assert ret == &quot;FakeCache:StoreSuccess!&quot;
    # Check if the mine entries have been stored properly in the FakeCache.
    assert mock_cache.fetch(&quot;minions/webserver&quot;, &quot;mine_cache&quot;) == {
        &quot;ip_addr&quot;: ip_ret,
        &quot;network.ip_addrs&quot;: ip_ret,
        &quot;foo.bar&quot;: {
            salt.utils.mine.MINE_ITEM_ACL_DATA: foo_ret,
            salt.utils.mine.MINE_ITEM_ACL_ID: salt.utils.mine.MINE_ITEM_ACL_VERSION,
            &quot;allow_tgt&quot;: &quot;G@roles:webserver&quot;,
            &quot;allow_tgt_type&quot;: &quot;compound&quot;,
        },
        &quot;kernel&quot;: {
            salt.utils.mine.MINE_ITEM_ACL_DATA: kernel_ret,
            salt.utils.mine.MINE_ITEM_ACL_ID: salt.utils.mine.MINE_ITEM_ACL_VERSION,
            &quot;allow_tgt&quot;: &quot;web*&quot;,
        },
    }


def test_update_local_specific(mock_cache):
    &quot;&quot;&quot;
    Tests the ``update``-function on the minion's local cache.
    Updates mine functions from kwargs only.
    &quot;&quot;&quot;
    foo_ret = &quot;baz&quot;
    ip_ret = &quot;2001:db8::1:3&quot;
    manual_mine_functions = {
        &quot;ip_addr&quot;: {&quot;mine_function&quot;: &quot;network.ip_addrs&quot;},
        &quot;network.ip_addrs&quot;: [],
        &quot;kernel&quot;: [
            {&quot;mine_function&quot;: &quot;grains.get&quot;},
            &quot;kernel&quot;,
            {&quot;allow_tgt&quot;: &quot;web*&quot;},
        ],
        &quot;foo.bar&quot;: {&quot;allow_tgt&quot;: &quot;G@roles:webserver&quot;, &quot;allow_tgt_type&quot;: &quot;compound&quot;},
    }
    with patch.dict(
        mine.__opts__, {&quot;file_client&quot;: &quot;local&quot;, &quot;id&quot;: &quot;webserver&quot;}
    ), patch.dict(
        mine.__salt__,
        {
            &quot;config.merge&quot;: MagicMock(return_value={}),
            &quot;grains.get&quot;: lambda x: &quot;Linux!!&quot;,
            &quot;network.ip_addrs&quot;: MagicMock(return_value=ip_ret),
            &quot;foo.bar&quot;: MagicMock(return_value=foo_ret),
        },
    ):
        ret = mine.update(mine_functions=manual_mine_functions)
    assert ret == &quot;FakeCache:StoreSuccess!&quot;
    assert mock_cache.fetch(&quot;minions/webserver&quot;, &quot;mine_cache&quot;) == {
        &quot;ip_addr&quot;: ip_ret,
        &quot;network.ip_addrs&quot;: ip_ret,
        &quot;foo.bar&quot;: {
            salt.utils.mine.MINE_ITEM_ACL_DATA: foo_ret,
            salt.utils.mine.MINE_ITEM_ACL_ID: salt.utils.mine.MINE_ITEM_ACL_VERSION,
            &quot;allow_tgt&quot;: &quot;G@roles:webserver&quot;,
            &quot;allow_tgt_type&quot;: &quot;compound&quot;,
        },
        &quot;kernel&quot;: {
            salt.utils.mine.MINE_ITEM_ACL_DATA: &quot;Linux!!&quot;,
            salt.utils.mine.MINE_ITEM_ACL_ID: salt.utils.mine.MINE_ITEM_ACL_VERSION,
            &quot;allow_tgt&quot;: &quot;web*&quot;,
        },
    }


def test_update_master():
    &quot;&quot;&quot;
    Tests whether the ``update``-function sends the correct data to the master.
    &quot;&quot;&quot;
    kernel_ret = &quot;Linux!&quot;
    foo_ret = &quot;baz&quot;
    ip_ret = &quot;2001:db8::1:3&quot;
    config_mine_functions = {
        &quot;ip_addr&quot;: {&quot;mine_function&quot;: &quot;network.ip_addrs&quot;},
        &quot;network.ip_addrs&quot;: [],
        &quot;kernel&quot;: [{&quot;mine_function&quot;: &quot;grains.get&quot;}, &quot;kernel&quot;],
        &quot;foo.bar&quot;: {},
    }
    mock_load = {
        &quot;id&quot;: &quot;webserver&quot;,
        &quot;cmd&quot;: &quot;_mine&quot;,
        &quot;data&quot;: {
            &quot;ip_addr&quot;: ip_ret,
            &quot;network.ip_addrs&quot;: ip_ret,
            &quot;foo.bar&quot;: foo_ret,
            &quot;kernel&quot;: kernel_ret,
        },
        &quot;clear&quot;: False,
    }
    with patch.object(
        mine, &quot;_mine_send&quot;, MagicMock(side_effect=lambda x, y: x)
    ), patch.dict(
        mine.__opts__, {&quot;file_client&quot;: &quot;remote&quot;, &quot;id&quot;: &quot;webserver&quot;}
    ), patch.dict(
        mine.__salt__,
        {
            &quot;config.merge&quot;: MagicMock(return_value=config_mine_functions),
            &quot;grains.get&quot;: lambda x: kernel_ret,
            &quot;network.ip_addrs&quot;: MagicMock(return_value=ip_ret),
            &quot;foo.bar&quot;: MagicMock(return_value=foo_ret),
        },
    ):
        # Verify the correct load
        assert mine.update() == mock_load


def test_delete_local(mock_cache):
    &quot;&quot;&quot;
    Tests the ``delete``-function on the minion's local cache.
    &quot;&quot;&quot;
    # Prefill minion cache with a non-ACL value
    mock_cache.store(&quot;minions/webserver&quot;, &quot;mine_cache&quot;, {&quot;foobard&quot;: &quot;barfood&quot;})
    with patch.dict(mine.__opts__, {&quot;file_client&quot;: &quot;local&quot;, &quot;id&quot;: &quot;webserver&quot;}):
        ret = mine.delete(&quot;foobard&quot;)
        assert mock_cache.fetch(&quot;minions/webserver&quot;, &quot;mine_cache&quot;) == {}


def test_delete_master(mock_cache):
    &quot;&quot;&quot;
    Tests whether the ``delete``-function sends the correct data to the master.
    &quot;&quot;&quot;
    # Prefill minion cache with a non-ACL value
    mock_cache.store(&quot;minions/webserver&quot;, &quot;mine_cache&quot;, {&quot;foobard&quot;: &quot;barfood&quot;})
    mock_load = {
        &quot;cmd&quot;: &quot;_mine_delete&quot;,
        &quot;fun&quot;: &quot;foobard&quot;,
        &quot;id&quot;: &quot;foo&quot;,
    }
    with patch.object(
        mine, &quot;_mine_send&quot;, MagicMock(side_effect=lambda x, y: x)
    ), patch.dict(mine.__opts__, {&quot;file_client&quot;: &quot;remote&quot;, &quot;id&quot;: &quot;foo&quot;}):
        assert mine.delete(&quot;foobard&quot;) == mock_load


def test_flush_local(mock_cache):
    &quot;&quot;&quot;
    Tests the ``flush``-function on the minion's local cache.
    &quot;&quot;&quot;
    # Prefill minion cache with a non-ACL value
    mock_cache.store(&quot;minions/webserver&quot;, &quot;mine_cache&quot;, {&quot;foobard&quot;: &quot;barfood&quot;})
    with patch.dict(mine.__opts__, {&quot;file_client&quot;: &quot;local&quot;, &quot;id&quot;: &quot;webserver&quot;}):
        ret = mine.flush()
        assert mock_cache.fetch(&quot;minions/webserver&quot;, &quot;mine_cache&quot;) == {}


def test_flush_master():
    &quot;&quot;&quot;
    Tests whether the ``flush``-function sends the correct data to the master.
    &quot;&quot;&quot;
    mock_load = {&quot;cmd&quot;: &quot;_mine_flush&quot;, &quot;id&quot;: &quot;foo&quot;}
    with patch.object(
        mine, &quot;_mine_send&quot;, MagicMock(side_effect=lambda x, y: x)
    ), patch.dict(mine.__opts__, {&quot;file_client&quot;: &quot;remote&quot;, &quot;id&quot;: &quot;foo&quot;}):
        assert mine.flush() == mock_load


def test_valid():
    &quot;&quot;&quot;
    Tests the ``valid``-function.
    Note that mine functions defined as list are returned in dict format.
    Mine functions that do not exist in __salt__ are not returned.
    &quot;&quot;&quot;
    config_mine_functions = {
        &quot;network.ip_addrs&quot;: [],
        &quot;kernel&quot;: [
            {&quot;mine_function&quot;: &quot;grains.get&quot;},
            &quot;kernel&quot;,
            {&quot;os&quot;: &quot;win32&quot;, &quot;v&quot;: &quot;2018&quot;},
        ],
        &quot;fubar&quot;: [{&quot;mine_function&quot;: &quot;does.not_exist&quot;}],
    }
    with patch.dict(
        mine.__salt__,
        {
            &quot;config.merge&quot;: MagicMock(return_value=config_mine_functions),
            &quot;network.ip_addrs&quot;: lambda: True,
            &quot;grains.get&quot;: lambda: True,
        },
    ):
        ret = mine.valid()
        # list cant be made to set &quot;dict can't be hashed&quot; and order changes
        assert isinstance(ret[&quot;kernel&quot;][&quot;grains.get&quot;], list)
        assert len(ret[&quot;kernel&quot;][&quot;grains.get&quot;]) == 3
        for item in (&quot;kernel&quot;, {&quot;os&quot;: &quot;win32&quot;}, {&quot;v&quot;: &quot;2018&quot;}):
            assert item in ret[&quot;kernel&quot;][&quot;grains.get&quot;]
        ret[&quot;kernel&quot;][&quot;grains.get&quot;] = None

        assert ret == {&quot;network.ip_addrs&quot;: [], &quot;kernel&quot;: {&quot;grains.get&quot;: None}}


def test_get_docker():
    &quot;&quot;&quot;
<A NAME="0"></A>    Test for Get all mine data for 'docker.ps' and run an
    aggregation.
    &quot;&quot;&quot;
    ps_response <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match97631-0.html#0',2,'match97631-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>= {
        &quot;localhost&quot;: {
            &quot;host&quot;: {
                &quot;interfaces&quot;: {
                    &quot;docker0&quot;: {
                        &quot;hwaddr&quot;: &quot;88:99:00:00:99:99&quot;,
                        &quot;inet&quot;: [
                            {
                                &quot;address&quot;: &quot;172.17.42.1&quot;,
                                &quot;broadcast&quot;: None,
                                &quot;label&quot;: &quot;docker0&quot;,
                                &quot;netmask&quot;: &quot;255.255.0.0&quot;,
                            }
                        ],
                        &quot;inet6&quot;: [
                            {
                                &quot;address&quot;: &quot;ffff::eeee:aaaa:bbbb:8888&quot;,
                                &quot;prefixlen&quot;: &quot;64&quot;,
                            }
                        ],
                        &quot;up&quot;: True,
                    },
                    &quot;eth0&quot;: {
                        &quot;hwaddr&quot;: &quot;88:99:00:99:99:99&quot;,
                        &quot;inet&quot;: [
                            {
                                &quot;address&quot;</B></FONT>: &quot;192.168.0.1&quot;,
                                &quot;broadcast&quot;: &quot;192.168.0.255&quot;,
                                &quot;label&quot;: &quot;eth0&quot;,
                                &quot;netmask&quot;: &quot;255.255.255.0&quot;,
                            }
                        ],
                        &quot;inet6&quot;: [
                            {
                                &quot;address&quot;: &quot;ffff::aaaa:aaaa:bbbb:8888&quot;,
                                &quot;prefixlen&quot;: &quot;64&quot;,
                            }
                        ],
                        &quot;up&quot;: True,
                    },
                }
            },
            &quot;abcdefhjhi1234567899&quot;: {  # container Id
                &quot;Ports&quot;: [
                    {
                        &quot;IP&quot;: &quot;0.0.0.0&quot;,  # we bind on every interfaces
                        &quot;PrivatePort&quot;: 80,
                        &quot;PublicPort&quot;: 80,
                        &quot;Type&quot;: &quot;tcp&quot;,
                    }
                ],
                &quot;Image&quot;: &quot;image:latest&quot;,
                &quot;Info&quot;: {&quot;Id&quot;: &quot;abcdefhjhi1234567899&quot;},
            },
        }
    }
    with patch.object(mine, &quot;get&quot;, return_value=ps_response):
        ret = mine.get_docker()
        # Sort ifaces since that will change between py2 and py3
        ret[&quot;image:latest&quot;][&quot;ipv4&quot;][80] = sorted(ret[&quot;image:latest&quot;][&quot;ipv4&quot;][80])
        assert ret == {
            &quot;image:latest&quot;: {&quot;ipv4&quot;: {80: sorted([&quot;172.17.42.1:80&quot;, &quot;192.168.0.1:80&quot;])}}
        }


def test_get_docker_with_container_id():
    &quot;&quot;&quot;
    Test for Get all mine data for 'docker.ps' and run an
    aggregation.
    &quot;&quot;&quot;
    ps_response = {
        &quot;localhost&quot;: {
            &quot;host&quot;: {
                &quot;interfaces&quot;: {
                    &quot;docker0&quot;: {
                        &quot;hwaddr&quot;: &quot;88:99:00:00:99:99&quot;,
                        &quot;inet&quot;: [
                            {
                                &quot;address&quot;: &quot;172.17.42.1&quot;,
                                &quot;broadcast&quot;: None,
                                &quot;label&quot;: &quot;docker0&quot;,
                                &quot;netmask&quot;: &quot;255.255.0.0&quot;,
                            }
                        ],
                        &quot;inet6&quot;: [
                            {
                                &quot;address&quot;: &quot;ffff::eeee:aaaa:bbbb:8888&quot;,
                                &quot;prefixlen&quot;: &quot;64&quot;,
                            }
                        ],
                        &quot;up&quot;: True,
                    },
                    &quot;eth0&quot;: {
                        &quot;hwaddr&quot;: &quot;88:99:00:99:99:99&quot;,
                        &quot;inet&quot;: [
                            {
                                &quot;address&quot;: &quot;192.168.0.1&quot;,
                                &quot;broadcast&quot;: &quot;192.168.0.255&quot;,
                                &quot;label&quot;: &quot;eth0&quot;,
                                &quot;netmask&quot;: &quot;255.255.255.0&quot;,
                            }
                        ],
                        &quot;inet6&quot;: [
                            {
                                &quot;address&quot;: &quot;ffff::aaaa:aaaa:bbbb:8888&quot;,
                                &quot;prefixlen&quot;: &quot;64&quot;,
                            }
                        ],
                        &quot;up&quot;: True,
                    },
                }
            },
            &quot;abcdefhjhi1234567899&quot;: {  # container Id
                &quot;Ports&quot;: [
                    {
                        &quot;IP&quot;: &quot;0.0.0.0&quot;,  # we bind on every interfaces
                        &quot;PrivatePort&quot;: 80,
                        &quot;PublicPort&quot;: 80,
                        &quot;Type&quot;: &quot;tcp&quot;,
                    }
                ],
                &quot;Image&quot;: &quot;image:latest&quot;,
                &quot;Info&quot;: {&quot;Id&quot;: &quot;abcdefhjhi1234567899&quot;},
            },
        }
    }
    with patch.object(mine, &quot;get&quot;, return_value=ps_response):
        ret = mine.get_docker(with_container_id=True)
        # Sort ifaces since that will change between py2 and py3
        ret[&quot;image:latest&quot;][&quot;ipv4&quot;][80] = sorted(ret[&quot;image:latest&quot;][&quot;ipv4&quot;][80])
        assert ret == {
            &quot;image:latest&quot;: {
                &quot;ipv4&quot;: {
                    80: sorted(
                        [
                            (&quot;172.17.42.1:80&quot;, &quot;abcdefhjhi1234567899&quot;),
                            (&quot;192.168.0.1:80&quot;, &quot;abcdefhjhi1234567899&quot;),
                        ]
                    )
                }
            }
        }
</PRE>
</div>
  </div>
</body>
</html>
