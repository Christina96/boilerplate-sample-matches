<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_aix_status.py &amp; test_mine.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_aix_status.py &amp; test_mine.py
      </h3>
<h1 align="center">
        3.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_aix_status.py (16.25%)<th>test_mine.py (1.951952%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(116-160)<td><a href="#" name="0">(471-497)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_aix_status.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import sys
3 import pytest
4 import salt.modules.status as status
5 from tests.support.mock import MagicMock, patch
6 log = logging.getLogger(__name__)
7 @pytest.fixture
8 def configure_loader_modules():
9     return {
10         status: {
11             "__grains__": {
12                 "ip4_interfaces": {
13                     "en0": ["129.40.94.58"],
14                     "en1": ["172.24.94.58"],
15                     "lo0": ["127.0.0.1"],
16                 },
17                 "ip6_interfaces": {"en0": [], "en1": [], "lo0": ["1"]},
18                 "kernel": "AIX",
19                 "osarch": "PowerPC_POWER8",
20                 "os": "AIX",
21                 "os_family": "AIX",
22                 "osmajorrelease": 7,
23             },
24         },
25     }
26 @pytest.mark.skipif(
27     sys.version_info[0] == 3 and sys.version_info[1] &lt;= 5,
28     reason="run on Python 3.6 or greater where OrderedDict is default",
29 )
30 def test_netdev():
31     netstat_inet4_en0 = """Name   Mtu   Network     Address                 Ipkts     Ierrs        Opkts     Oerrs  Coll
32 en0    1500  link#2      fa.41.f5.e9.bd.20  1523125     0   759364     0     0
33 en0    1500  129.40.94.5 129.40.94.58      1523125     0   759364     0     0
34     netstat_inet4_lo0 = """Name   Mtu   Network     Address                 Ipkts     Ierrs        Opkts     Oerrs  Coll
35 lo0    16896 link#1                          25568     0    25568     0     0
36 lo0    16896 127         127.0.0.1           25568     0    25568     0     0
37     netstat_inet6_en1 = """Name   Mtu   Network     Address                 Ipkts     Ierrs        Opkts     Oerrs  Coll
38 en1    1500  link#3      fa.41.f5.e9.bd.21     1089     0      402     0     0
39     netstats_out = MagicMock(
40         side_effect=[
41             netstat_inet4_en0,
42             netstat_inet6_en0,
43             netstat_inet4_en1,
44             netstat_inet6_en1,
45             netstat_inet4_lo0,
46             netstat_inet6_lo0,
47             netstat_inet4_en0,
48             netstat_inet6_en0,
49             netstat_inet4_en1,
50             netstat_inet6_en1,
51             netstat_inet4_lo0,
52             netstat_inet6_lo0,
53         ]
54     )
55     with patch.dict(
56         status.__grains__,
57         {
58             "osarch": "PowerPC_POWER8",
59             "ip4_interfaces": {
60                 "en0": ["129.40.94.58"],
61                 "en1": ["172.24.94.58"],
62                 "lo0": ["127.0.0.1"],
63             },
64             "ip6_interfaces": {
65                 "en0": [],
66                 "en1": [],
67                 "lo0": ["::1"],
68             },
69             "kernel": "AIX",
70         },
71     ), patch.dict(status.__salt__, {"cmd.run": netstats_out}):
72         netdev_out = status.netdev()
73         assert netstats_out.call_count == 12
74         netstats_out.assert_any_call("netstat -i -n -I en0 -f inet")
75         netstats_out.assert_any_call("netstat -i -n -I en1 -f inet")
76         netstats_out.assert_any_call("netstat -i -n -I lo0 -f inet")
77 <a name="0"></a>        netstats_out.assert_any_call("netstat -i -n -I en0 -f inet6")
78         netstats_out.assert_any_call("netstat -i -n -I en1 -f inet6")
79         netstats_out.assert_any_call("netstat -i -n -I lo0 -f inet6")
80         expected <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= {
81             "en0": [
82                 {
83                     "ipv4": {
84                         "Mtu": "1500",
85                         "Network": "129.40.94.5",
86                         "Address": "129.40.94.58",
87                         "Ipkts": "1523125",
88                         "Ierrs": "0",
89                         "Opkts": "759364",
90                         "Oerrs": "0",
91                         "Coll": "0",
92                     }
93                 }
94             ],
95             "en1": [
96                 {
97                     "ipv4": {
98                         "Mtu": "1500",
99                         "Network": "172.24.94.5",
100                         "Address": "172.24.94.58",
101                         "Ipkts": "1089",
102                         "Ierrs": "0",
103                         "Opkts": "402",
104                         "Oerrs": "0",
105                         "Coll": "0",
106                     }
107                 }
108             ],
109             "lo0": [
110                 {
111                     "ipv4": {
112                         "Mtu": "16896",
113                         "Network": "127",
114                         "Address": "127.0.0.1",
115                         "Ipkts": "25568",
116                         "Ierrs": "0",
117                         "Opkts": "25568",
118                         "Oerrs": "0",
119                         "Coll": "0",
120                     }
121                 },
122                 {
123                     "ipv6": {
124                         "Mtu"</b></font>: "16896",
125                         "Network": "::1%1",
126                         "Address": "25611",
127                         "Ipkts": "0",
128                         "Ierrs": "25611",
129                         "Opkts": "0",
130                         "Oerrs": "0",
131                     }
132                 },
133             ],
134         }
135         assert netdev_out == expected
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_mine.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import pytest
2 import salt.modules.mine as mine
3 import salt.utils.mine
4 from salt.utils.odict import OrderedDict
5 from tests.support.mock import MagicMock, patch
6 class FakeCache:
7     def __init__(self):
8         self.data = {}
9     def store(self, bank, key, value):
10         self.data[bank, key] = value
11         return "FakeCache:StoreSuccess!"
12     def fetch(self, bank, key):
13         return self.data.get((bank, key), {})
14     def debug(self):
15         print("{}:FakeCache dump:\n{}".format(__name__, self.data))
16 @pytest.fixture
17 def mock_cache():
18     cache = FakeCache()
19     return cache
20 @pytest.fixture
21 def configure_loader_modules(mock_cache):
22     mock_match = MagicMock(return_value="webserver")
23     return {
24         mine: {
25             "__salt__": {
26                 "match.glob": mock_match,
27                 "match.pcre": mock_match,
28                 "match.list": mock_match,
29                 "match.grain": mock_match,
30                 "match.grain_pcre": mock_match,
31                 "match.ipcidr": mock_match,
32                 "match.compound": mock_match,
33                 "match.pillar": mock_match,
34                 "match.pillar_pcre": mock_match,
35                 "data.get": lambda key: mock_cache.fetch("minions/webserver", key),
36                 "data.update": lambda key, value: mock_cache.store(
37                     "minions/webserver", key, value
38                 ),
39             }
40         }
41     }
42 def test_get_local_empty():
43     with patch.dict(mine.__opts__, {"file_client": "local", "id": "webserver"}):
44         ret_classic = mine.get("*", "funky.doodle")
45         ret_dict = mine.get("*", ["funky.doodle"])
46     assert ret_classic == {}
47     assert ret_dict == {}
48 def test_get_local_classic(mock_cache):
49     mock_cache.store("minions/webserver", "mine_cache", {"foobard": "barfood"})
50     with patch.dict(mine.__opts__, {"file_client": "local", "id": "webserver"}):
51         ret_classic = mine.get("*", "foobard")
52         ret_dict = mine.get("*", ["foobard"])
53     assert ret_classic == {"webserver": "barfood"}
54     assert ret_dict == {"foobard": {"webserver": "barfood"}}
55 def test_send_get_local(mock_cache):
56     foo_ret = "baz"
57     ip_ret = "2001:db8::1:3"
58     with patch.dict(
59         mine.__opts__, {"file_client": "local", "id": "webserver"}
60     ), patch.dict(
61         mine.__salt__,
62         {
63             "network.ip_addrs": MagicMock(return_value=ip_ret),
64             "foo.bar": MagicMock(return_value=foo_ret),
65         },
66     ):
67         ret = mine.send("ip_addr", mine_function="network.ip_addrs")
68         mine.send("foo.bar")
69     assert ret == "FakeCache:StoreSuccess!"
70     assert mock_cache.fetch("minions/webserver", "mine_cache") == {
71         "ip_addr": ip_ret,
72         "foo.bar": foo_ret,
73     }
74     with patch.dict(mine.__opts__, {"file_client": "local", "id": "webserver"}):
75         ret_single = mine.get("*", "ip_addr")
76         ret_single_dict = mine.get("*", ["ip_addr"])
77         ret_multi = mine.get("*", "ip_addr,foo.bar")
78         ret_multi2 = mine.get("*", ["ip_addr", "foo.bar"])
79     assert ret_single == {"webserver": ip_ret}
80     assert ret_single_dict == {"ip_addr": {"webserver": ip_ret}}
81     assert ret_multi == {
82         "ip_addr": {"webserver": ip_ret},
83         "foo.bar": {"webserver": foo_ret},
84     }
85     assert ret_multi == ret_multi2
86 def test_send_get_acl_local(mock_cache):
87     foo_ret = "baz"
88     ip_ret = "2001:db8::1:3"
89     with patch.dict(
90         mine.__opts__, {"file_client": "local", "id": "webserver"}
91     ), patch.dict(
92         mine.__salt__,
93         {
94             "network.ip_addrs": MagicMock(return_value=ip_ret),
95             "foo.bar": MagicMock(return_value=foo_ret),
96         },
97     ):
98         ret = mine.send(
99             "ip_addr",
100             mine_function="network.ip_addrs",
101             allow_tgt="web*",
102             allow_tgt_type="glob",
103         )
104         mine.send("foo.bar")
105     assert ret == "FakeCache:StoreSuccess!"
106     assert mock_cache.fetch("minions/webserver", "mine_cache") == {
107         "ip_addr": {
108             salt.utils.mine.MINE_ITEM_ACL_DATA: ip_ret,
109             salt.utils.mine.MINE_ITEM_ACL_ID: salt.utils.mine.MINE_ITEM_ACL_VERSION,
110             "allow_tgt": "web*",
111             "allow_tgt_type": "glob",
112         },
113         "foo.bar": foo_ret,
114     }
115     with patch.dict(mine.__opts__, {"file_client": "local", "id": "webserver"}):
116         ret_single = mine.get("*", "ip_addr")
117     assert ret_single == {"webserver": ip_ret}
118 def test_send_master():
119     foo_ret = "baz"
120     with patch.object(
121         mine, "_mine_send", MagicMock(side_effect=lambda x, y: x)
122     ), patch.dict(
123         mine.__salt__, {"foo.bar": MagicMock(return_value=foo_ret)}
124     ), patch.dict(
125         mine.__opts__, {"file_client": "remote", "id": "foo"}
126     ):
127         ret = mine.send("foo.bar")
128     assert ret == {
129         "id": "foo",
130         "cmd": "_mine",
131         "data": {"foo.bar": foo_ret},
132         "clear": False,
133     }
134 def test_send_master_acl():
135     foo_ret = "baz"
136     with patch.object(
137         mine, "_mine_send", MagicMock(side_effect=lambda x, y: x)
138     ), patch.dict(
139         mine.__salt__, {"foo.bar": MagicMock(return_value=foo_ret)}
140     ), patch.dict(
141         mine.__opts__, {"file_client": "remote", "id": "foo"}
142     ):
143         ret = mine.send("foo.bar", allow_tgt="roles:web", allow_tgt_type="grains")
144     assert ret == {
145         "id": "foo",
146         "cmd": "_mine",
147         "data": {
148             "foo.bar": {
149                 salt.utils.mine.MINE_ITEM_ACL_DATA: foo_ret,
150                 salt.utils.mine.MINE_ITEM_ACL_ID: salt.utils.mine.MINE_ITEM_ACL_VERSION,
151                 "allow_tgt": "roles:web",
152                 "allow_tgt_type": "grains",
153             },
154         },
155         "clear": False,
156     }
157 def test_get_master():
158     foo_ret = "baz"
159     mock_load = {
160         "tgt_type": "qux",
161         "tgt": foo_ret,
162         "cmd": "_mine_get",
163         "fun": "foo.bar",
164         "id": "foo",
165     }
166     with patch.object(mine, "_mine_get", MagicMock(return_value=mock_load)), patch.dict(
167         mine.__opts__, {"file_client": "remote", "id": "foo"}
168     ):
169         assert mine.get("*", "foo.bar") == mock_load
170 def test_get_master_exclude_minion():
171     _mine_get_ret = OrderedDict([("webserver", "value")])
172     with patch.object(
173         mine, "_mine_get", MagicMock(return_value=_mine_get_ret)
174     ), patch.dict(mine.__opts__, {"file_client": "remote", "id": "webserver"}):
175         assert mine.get("*", "foo.bar", exclude_minion=False) == {"webserver": "value"}
176         assert mine.get("*", "foo.bar", exclude_minion=True) == {}
177 def test_update_local(mock_cache):
178     kernel_ret = "Linux!"
179     foo_ret = "baz"
180     ip_ret = "2001:db8::1:3"
181     config_mine_functions = {
182         "ip_addr": {"mine_function": "network.ip_addrs"},
183         "network.ip_addrs": [],
184         "kernel": [
185             {"mine_function": "grains.get"},
186             "kernel",
187             {"allow_tgt": "web*"},
188         ],
189         "foo.bar": {"allow_tgt": "G@roles:webserver", "allow_tgt_type": "compound"},
190     }
191     with patch.dict(
192         mine.__opts__, {"file_client": "local", "id": "webserver"}
193     ), patch.dict(
194         mine.__salt__,
195         {
196             "config.merge": MagicMock(return_value=config_mine_functions),
197             "grains.get": lambda x: kernel_ret,
198             "network.ip_addrs": MagicMock(return_value=ip_ret),
199             "foo.bar": MagicMock(return_value=foo_ret),
200         },
201     ):
202         ret = mine.update()
203     assert ret == "FakeCache:StoreSuccess!"
204     assert mock_cache.fetch("minions/webserver", "mine_cache") == {
205         "ip_addr": ip_ret,
206         "network.ip_addrs": ip_ret,
207         "foo.bar": {
208             salt.utils.mine.MINE_ITEM_ACL_DATA: foo_ret,
209             salt.utils.mine.MINE_ITEM_ACL_ID: salt.utils.mine.MINE_ITEM_ACL_VERSION,
210             "allow_tgt": "G@roles:webserver",
211             "allow_tgt_type": "compound",
212         },
213         "kernel": {
214             salt.utils.mine.MINE_ITEM_ACL_DATA: kernel_ret,
215             salt.utils.mine.MINE_ITEM_ACL_ID: salt.utils.mine.MINE_ITEM_ACL_VERSION,
216             "allow_tgt": "web*",
217         },
218     }
219 def test_update_local_specific(mock_cache):
220     foo_ret = "baz"
221     ip_ret = "2001:db8::1:3"
222     manual_mine_functions = {
223         "ip_addr": {"mine_function": "network.ip_addrs"},
224         "network.ip_addrs": [],
225         "kernel": [
226             {"mine_function": "grains.get"},
227             "kernel",
228             {"allow_tgt": "web*"},
229         ],
230         "foo.bar": {"allow_tgt": "G@roles:webserver", "allow_tgt_type": "compound"},
231     }
232     with patch.dict(
233         mine.__opts__, {"file_client": "local", "id": "webserver"}
234     ), patch.dict(
235         mine.__salt__,
236         {
237             "config.merge": MagicMock(return_value={}),
238             "grains.get": lambda x: "Linux!!",
239             "network.ip_addrs": MagicMock(return_value=ip_ret),
240             "foo.bar": MagicMock(return_value=foo_ret),
241         },
242     ):
243         ret = mine.update(mine_functions=manual_mine_functions)
244     assert ret == "FakeCache:StoreSuccess!"
245     assert mock_cache.fetch("minions/webserver", "mine_cache") == {
246         "ip_addr": ip_ret,
247         "network.ip_addrs": ip_ret,
248         "foo.bar": {
249             salt.utils.mine.MINE_ITEM_ACL_DATA: foo_ret,
250             salt.utils.mine.MINE_ITEM_ACL_ID: salt.utils.mine.MINE_ITEM_ACL_VERSION,
251             "allow_tgt": "G@roles:webserver",
252             "allow_tgt_type": "compound",
253         },
254         "kernel": {
255             salt.utils.mine.MINE_ITEM_ACL_DATA: "Linux!!",
256             salt.utils.mine.MINE_ITEM_ACL_ID: salt.utils.mine.MINE_ITEM_ACL_VERSION,
257             "allow_tgt": "web*",
258         },
259     }
260 def test_update_master():
261     kernel_ret = "Linux!"
262     foo_ret = "baz"
263     ip_ret = "2001:db8::1:3"
264     config_mine_functions = {
265         "ip_addr": {"mine_function": "network.ip_addrs"},
266         "network.ip_addrs": [],
267         "kernel": [{"mine_function": "grains.get"}, "kernel"],
268         "foo.bar": {},
269     }
270     mock_load = {
271         "id": "webserver",
272         "cmd": "_mine",
273         "data": {
274             "ip_addr": ip_ret,
275             "network.ip_addrs": ip_ret,
276             "foo.bar": foo_ret,
277             "kernel": kernel_ret,
278         },
279         "clear": False,
280     }
281     with patch.object(
282         mine, "_mine_send", MagicMock(side_effect=lambda x, y: x)
283     ), patch.dict(
284         mine.__opts__, {"file_client": "remote", "id": "webserver"}
285     ), patch.dict(
286         mine.__salt__,
287         {
288             "config.merge": MagicMock(return_value=config_mine_functions),
289             "grains.get": lambda x: kernel_ret,
290             "network.ip_addrs": MagicMock(return_value=ip_ret),
291             "foo.bar": MagicMock(return_value=foo_ret),
292         },
293     ):
294         assert mine.update() == mock_load
295 def test_delete_local(mock_cache):
296     mock_cache.store("minions/webserver", "mine_cache", {"foobard": "barfood"})
297     with patch.dict(mine.__opts__, {"file_client": "local", "id": "webserver"}):
298         ret = mine.delete("foobard")
299         assert mock_cache.fetch("minions/webserver", "mine_cache") == {}
300 def test_delete_master(mock_cache):
301     mock_cache.store("minions/webserver", "mine_cache", {"foobard": "barfood"})
302     mock_load = {
303         "cmd": "_mine_delete",
304         "fun": "foobard",
305         "id": "foo",
306     }
307     with patch.object(
308         mine, "_mine_send", MagicMock(side_effect=lambda x, y: x)
309     ), patch.dict(mine.__opts__, {"file_client": "remote", "id": "foo"}):
310         assert mine.delete("foobard") == mock_load
311 def test_flush_local(mock_cache):
312     mock_cache.store("minions/webserver", "mine_cache", {"foobard": "barfood"})
313     with patch.dict(mine.__opts__, {"file_client": "local", "id": "webserver"}):
314         ret = mine.flush()
315         assert mock_cache.fetch("minions/webserver", "mine_cache") == {}
316 def test_flush_master():
317     mock_load = {"cmd": "_mine_flush", "id": "foo"}
318     with patch.object(
319         mine, "_mine_send", MagicMock(side_effect=lambda x, y: x)
320     ), patch.dict(mine.__opts__, {"file_client": "remote", "id": "foo"}):
321         assert mine.flush() == mock_load
322 def test_valid():
323     config_mine_functions = {
324         "network.ip_addrs": [],
325         "kernel": [
326             {"mine_function": "grains.get"},
327             "kernel",
328             {"os": "win32", "v": "2018"},
329         ],
330         "fubar": [{"mine_function": "does.not_exist"}],
331     }
332     with patch.dict(
333         mine.__salt__,
334         {
335             "config.merge": MagicMock(return_value=config_mine_functions),
336             "network.ip_addrs": lambda: True,
337             "grains.get": lambda: True,
338         },
339     ):
340         ret = mine.valid()
341         assert isinstance(ret["kernel"]["grains.get"], list)
342         assert len(ret["kernel"]["grains.get"]) == 3
343         for item in ("kernel", {"os": "win32"}, {"v": "2018"}):
344             assert item in ret["kernel"]["grains.get"]
345         ret["kernel"]["grains.get"] = None
346         assert ret == {"network.ip_addrs": [], "kernel": {"grains.get": None}}
347 def test_get_docker():
348     ps_response <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= {
349         "localhost": {
350             "host": {
351                 "interfaces": {
352                     "docker0": {
353                         "hwaddr": "88:99:00:00:99:99",
354                         "inet": [
355                             {
356                                 "address": "172.17.42.1",
357                                 "broadcast": None,
358                                 "label": "docker0",
359                                 "netmask": "255.255.0.0",
360                             }
361                         ],
362                         "inet6": [
363                             {
364                                 "address": "ffff::eeee:aaaa:bbbb:8888",
365                                 "prefixlen": "64",
366                             }
367                         ],
368                         "up": True,
369                     },
370                     "eth0": {
371                         "hwaddr": "88:99:00:99:99:99",
372                         "inet": [
373                             {
374                                 "address"</b></font>: "192.168.0.1",
375                                 "broadcast": "192.168.0.255",
376                                 "label": "eth0",
377                                 "netmask": "255.255.255.0",
378                             }
379                         ],
380                         "inet6": [
381                             {
382                                 "address": "ffff::aaaa:aaaa:bbbb:8888",
383                                 "prefixlen": "64",
384                             }
385                         ],
386                         "up": True,
387                     },
388                 }
389             },
390             "abcdefhjhi1234567899": {  # container Id
391                 "Ports": [
392                     {
393                         "IP": "0.0.0.0",  # we bind on every interfaces
394                         "PrivatePort": 80,
395                         "PublicPort": 80,
396                         "Type": "tcp",
397                     }
398                 ],
399                 "Image": "image:latest",
400                 "Info": {"Id": "abcdefhjhi1234567899"},
401             },
402         }
403     }
404     with patch.object(mine, "get", return_value=ps_response):
405         ret = mine.get_docker()
406         ret["image:latest"]["ipv4"][80] = sorted(ret["image:latest"]["ipv4"][80])
407         assert ret == {
408             "image:latest": {"ipv4": {80: sorted(["172.17.42.1:80", "192.168.0.1:80"])}}
409         }
410 def test_get_docker_with_container_id():
411     ps_response = {
412         "localhost": {
413             "host": {
414                 "interfaces": {
415                     "docker0": {
416                         "hwaddr": "88:99:00:00:99:99",
417                         "inet": [
418                             {
419                                 "address": "172.17.42.1",
420                                 "broadcast": None,
421                                 "label": "docker0",
422                                 "netmask": "255.255.0.0",
423                             }
424                         ],
425                         "inet6": [
426                             {
427                                 "address": "ffff::eeee:aaaa:bbbb:8888",
428                                 "prefixlen": "64",
429                             }
430                         ],
431                         "up": True,
432                     },
433                     "eth0": {
434                         "hwaddr": "88:99:00:99:99:99",
435                         "inet": [
436                             {
437                                 "address": "192.168.0.1",
438                                 "broadcast": "192.168.0.255",
439                                 "label": "eth0",
440                                 "netmask": "255.255.255.0",
441                             }
442                         ],
443                         "inet6": [
444                             {
445                                 "address": "ffff::aaaa:aaaa:bbbb:8888",
446                                 "prefixlen": "64",
447                             }
448                         ],
449                         "up": True,
450                     },
451                 }
452             },
453             "abcdefhjhi1234567899": {  # container Id
454                 "Ports": [
455                     {
456                         "IP": "0.0.0.0",  # we bind on every interfaces
457                         "PrivatePort": 80,
458                         "PublicPort": 80,
459                         "Type": "tcp",
460                     }
461                 ],
462                 "Image": "image:latest",
463                 "Info": {"Id": "abcdefhjhi1234567899"},
464             },
465         }
466     }
467     with patch.object(mine, "get", return_value=ps_response):
468         ret = mine.get_docker(with_container_id=True)
469         ret["image:latest"]["ipv4"][80] = sorted(ret["image:latest"]["ipv4"][80])
470         assert ret == {
471             "image:latest": {
472                 "ipv4": {
473                     80: sorted(
474                         [
475                             ("172.17.42.1:80", "abcdefhjhi1234567899"),
476                             ("192.168.0.1:80", "abcdefhjhi1234567899"),
477                         ]
478                     )
479                 }
480             }
481         }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
