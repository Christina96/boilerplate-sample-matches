<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_ordering.py &amp; events_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_ordering.py &amp; events_1.py
      </h3>
<h1 align="center">
        2.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_ordering.py (2.970297%)<th>events_1.py (1.615074%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(63-65)<td><a href="#" name="0">(382-389)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_ordering.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from nose_parameterized import parameterized
2 import pandas as pd
3 from zipline.algorithm import TradingAlgorithm
4 import zipline.api as api
5 import zipline.errors as ze
6 from zipline.finance.execution import StopLimitOrder
7 import zipline.testing.fixtures as zf
8 from zipline.testing.predicates import assert_equal
9 import zipline.test_algorithms as zta
10 def T(s):
11     return pd.Timestamp(s, tz='UTC')
12 class TestOrderMethods(zf.WithConstantEquityMinuteBarData,
13                        zf.WithConstantFutureMinuteBarData,
14                        zf.WithMakeAlgo,
15                        zf.ZiplineTestCase):
16     START_DATE = T('2006-01-03')
17     END_DATE = T('2006-01-06')
18     SIM_PARAMS_START_DATE = T('2006-01-04')
19     ASSET_FINDER_EQUITY_SIDS = (1,)
20     EQUITY_DAILY_BAR_SOURCE_FROM_MINUTE = True
21     FUTURE_DAILY_BAR_SOURCE_FROM_MINUTE = True
22     EQUITY_MINUTE_CONSTANT_LOW = 2.0
23     EQUITY_MINUTE_CONSTANT_OPEN = 2.0
24     EQUITY_MINUTE_CONSTANT_CLOSE = 2.0
25     EQUITY_MINUTE_CONSTANT_HIGH = 2.0
26     EQUITY_MINUTE_CONSTANT_VOLUME = 10000.0
27     FUTURE_MINUTE_CONSTANT_LOW = 2.0
28     FUTURE_MINUTE_CONSTANT_OPEN = 2.0
29     FUTURE_MINUTE_CONSTANT_CLOSE = 2.0
30     FUTURE_MINUTE_CONSTANT_HIGH = 2.0
31     FUTURE_MINUTE_CONSTANT_VOLUME = 10000.0
32     SIM_PARAMS_CAPITAL_BASE = 10000
33     @classmethod
34     def make_futures_info(cls):
35         return pd.DataFrame.from_dict({
36             2: {
37                 'multiplier': 10,
38                 'symbol': 'F',
39                 'exchange': 'TEST'
40             }
41         }, orient='index')
42     @classmethod
43     def init_class_fixtures(cls):
44         super(TestOrderMethods, cls)<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.init_class_fixtures()
45         cls.EQUITY = cls.asset_finder.retrieve_asset(1)
46         cls.FUTURE = cls.asset_finder.retrieve_asset(</b></font>2)
47     @parameterized.expand([
48         ('order', 1),
49         ('order_value', 1000),
50         ('order_target', 1),
51         ('order_target_value', 1000),
52         ('order_percent', 1),
53         ('order_target_percent', 1),
54     ])
55     def test_cannot_order_in_before_trading_start(self, order_method, amount):
56         algotext = """
57 from zipline.api import sid, {order_func}
58 def initialize(context):
59     context.asset = sid(1)
60 def before_trading_start(context, data):
61     {order_func}(context.asset, {arg})
62         result = self.run_algorithm(script=algotext)
63         for orders in result.orders.values:
64             assert_equal(len(orders), 1)
65             assert_equal(orders[0]['amount'], 5000)
66             assert_equal(orders[0]['sid'], self.EQUITY)
67         for i, positions in enumerate(result.positions.values, start=1):
68             assert_equal(len(positions), 1)
69             assert_equal(positions[0]['amount'], 5000.0 * i)
70             assert_equal(positions[0]['sid'], self.EQUITY)
71     @parameterized.expand([
72         ('order_target', 5000),         # 5000 shares times $2 per share
73         ('order_target_value', 10000),  # $10000
74         ('order_target_percent', 1),    # 100% on a $10000 capital base.
75     ])
76     def test_order_equity_targeted(self, order_method, amount):
77         algotext = """
78 import zipline.api as api
79 def initialize(context):
80     api.set_slippage(api.slippage.FixedSlippage(spread=0.0))
81     api.set_commission(api.commission.PerShare(0))
82     context.equity = api.sid(1)
83     api.schedule_function(
84         func=do_order,
85         date_rule=api.date_rules.every_day(),
86         time_rule=api.time_rules.market_open(),
87     )
88 def do_order(context, data):
89     context.ordered = True
90     api.{order_func}(context.equity, {arg})
91         result = self.run_algorithm(script=algotext)
92         for orders in result.orders.values:
93             assert_equal(len(orders), 1)
94             assert_equal(orders[0]['amount'], 500)
95             assert_equal(orders[0]['sid'], self.FUTURE)
96         for i, positions in enumerate(result.positions.values, start=1):
97             assert_equal(len(positions), 1)
98             assert_equal(positions[0]['amount'], 500.0 * i)
99             assert_equal(positions[0]['sid'], self.FUTURE)
100     @parameterized.expand([
101         ('order_target', 500),          # 500 contracts * $2 per contract * 10x
102         ('order_target_value', 10000),  # $10000
103         ('order_target_percent', 1),    # 100% on a $10000 capital base.
104     ])
105     def test_order_future_targeted(self, order_method, amount):
106         algotext = """
107 import zipline.api as api
108 def initialize(context):
109     api.set_slippage(us_futures=api.slippage.FixedSlippage(spread=0.0))
110     api.set_commission(us_futures=api.commission.PerTrade(0.0))
111     context.future = api.sid(2)
112     api.schedule_function(
113         func=do_order,
114         date_rule=api.date_rules.every_day(),
115         time_rule=api.time_rules.market_open(),
116     )
117 def do_order(context, data):
118     context.ordered = True
119     api.{order_func}(context.future, {arg})
120     Converts a UTC tz-naive timestamp to a tz-aware timestamp.
121     Normalize a time. If the time is tz-naive, assume it is UTC.
122     Builds the offset argument for event rules.
123     Builds the date argument for event rules.
124     Builds the time argument for event rules.
125     A preprocessor that coerces integral floats to ints.
126     Receipt of non-integral floats raises a TypeError.
127     This manages the logic for checking the rules and dispatching to the
128     handle_data function of the Events.
129     Parameters
130     ----------
131     create_context : (BarData) -&gt; context manager, optional
132         An optional callback to produce a context manager to wrap the calls
133         to handle_data. This will be passed the current BarData.
134         Adds an event to the manager.
135     An event is a pairing of an EventRule and a callable that will be invoked
136     with the current algorithm context, data, and datetime only when the rule
137     is triggered.
138         Calls the callable only when the rule is triggered.
139         Checks if the rule should trigger with its current state.
140         This method should be pure and NOT mutate any state on the object.
141     A stateless rule has no observable side effects.
142     This is reentrant and will always give the same result for the
143     same datetime.
144     Because these are pure, they can be composed to create new rules.
145         Logical and of two rules, triggers only when both rules trigger.
146         This follows the short circuiting rules for normal and.
147     A rule that composes the results of two rules with some composing function.
148     The composing function should be a binary function that accepts the results
149     first(dt) and second(dt) as positional arguments.
150     For example, operator.and_.
151     If lazy=True, then the lazy composer is used instead. The lazy composer
152     expects a function that takes the two should_trigger functions and the
153     datetime. This is useful of you don't always want to call should_trigger
154     for one of the rules. For example, this is used to implement the &amp; and |
155     operators so that they will have the same short circuit logic that is
156     expected.
157         Composes the two rules with a lazy composer.
158         Lazily ands the two rules. This will NOT call the should_trigger of the
159         second rule if the first one returns False.
160     A rule that always triggers.
161         A should_trigger implementation that will always trigger.
162     A rule that never triggers.
163         A should_trigger implementation that will never trigger.
164     A rule that triggers for some offset after the market opens.
165     Example that triggers after 30 minutes of the market opening:
166     &gt;&gt;&gt; AfterOpen(minutes=30)  # doctest: +ELLIPSIS
167     &lt;zipline.utils.events.AfterOpen object at ...&gt;
168     """
169     def __init__(self, offset=None, **kwargs):
170         self.offset = _build_offset(
171             offset,
172             kwargs,
173             datetime.timedelta(minutes=1),  # Defaults to the first minute.
174         )
175         self._period_start = None
176         self._period_end = None
177         self._period_close = None
178         self._one_minute = datetime.timedelta(minutes=1)
179     def calculate_dates(self, dt):
180         period_start, period_close = self.cal.open_and_close_for_session(
181             self.cal<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.minute_to_session_label(dt),
182         )
183         self._period_start = self.cal.execution_time_from_open(period_start)
184         self._period_close = self.cal.execution_time_from_close(</b></font>period_close)
185         self._period_end = self._period_start + self.offset - self._one_minute
186     def should_trigger(self, dt):
187         if (
188             self._period_start is None or
189             self._period_close &lt;= dt
190         ):
191             self.calculate_dates(dt)
192         return dt == self._period_end
193 class BeforeClose(StatelessRule):
194     def __init__(self, offset=None, **kwargs):
195         self.offset = _build_offset(
196             offset,
197             kwargs,
198             datetime.timedelta(minutes=1),  # Defaults to the last minute.
199         )
200         self._period_start = None
201         self._period_close = None
202         self._period_end = None
203         self._one_minute = datetime.timedelta(minutes=1)
204     def calculate_dates(self, dt):
205         period_end = self.cal.open_and_close_for_session(
206             self.cal.minute_to_session_label(dt),
207         )[1]
208         self._period_end = self.cal.execution_time_from_close(period_end)
209         self._period_start = self._period_end - self.offset
210         self._period_close = self._period_end
211     def should_trigger(self, dt):
212         if self._period_start is None or self._period_close &lt;= dt:
213             self.calculate_dates(dt)
214         return self._period_start == dt
215 class NotHalfDay(StatelessRule):
216     def should_trigger(self, dt):
217         return self.cal.minute_to_session_label(dt) \
218             not in self.cal.early_closes
219 class TradingDayOfWeekRule(six.with_metaclass(ABCMeta, StatelessRule)):
220     @preprocess(n=lossless_float_to_int('TradingDayOfWeekRule'))
221     def __init__(self, n, invert):
222         if not 0 &lt;= n &lt; MAX_WEEK_RANGE:
223             raise _out_of_range_error(MAX_WEEK_RANGE)
224         self.td_delta = (-n - 1) if invert else n
225     def should_trigger(self, dt):
226         val = self.cal.minute_to_session_label(dt, direction="none").value
227         return val in self.execution_period_values
228     @lazyval
229     def execution_period_values(self):
230         sessions = self.cal.all_sessions
231         return set(
232             pd.Series(data=sessions)
233             .groupby(sessions.map(lambda x: x.isocalendar()[0:2]))
234             .nth(self.td_delta)
235             .astype(np.int64)
236         )
237 class NthTradingDayOfWeek(TradingDayOfWeekRule):
238     def __init__(self, n):
239         super(NthTradingDayOfWeek, self).__init__(n, invert=False)
240 class NDaysBeforeLastTradingDayOfWeek(TradingDayOfWeekRule):
241     def __init__(self, n):
242         super(NDaysBeforeLastTradingDayOfWeek, self).__init__(n, invert=True)
243 class TradingDayOfMonthRule(six.with_metaclass(ABCMeta, StatelessRule)):
244     @preprocess(n=lossless_float_to_int('TradingDayOfMonthRule'))
245     def __init__(self, n, invert):
246         if not 0 &lt;= n &lt; MAX_MONTH_RANGE:
247             raise _out_of_range_error(MAX_MONTH_RANGE)
248         if invert:
249             self.td_delta = -n - 1
250         else:
251             self.td_delta = n
252     def should_trigger(self, dt):
253         value = self.cal.minute_to_session_label(dt, direction="none").value
254         return value in self.execution_period_values
255     @lazyval
256     def execution_period_values(self):
257         sessions = self.cal.all_sessions
258         return set(
259             pd.Series(data=sessions)
260             .groupby([sessions.year, sessions.month])
261             .nth(self.td_delta)
262             .astype(np.int64)
263         )
264 class NthTradingDayOfMonth(TradingDayOfMonthRule):
265     def __init__(self, n):
266         super(NthTradingDayOfMonth, self).__init__(n, invert=False)
267 class NDaysBeforeLastTradingDayOfMonth(TradingDayOfMonthRule):
268     def __init__(self, n):
269         super(NDaysBeforeLastTradingDayOfMonth, self).__init__(n, invert=True)
270 class StatefulRule(EventRule):
271     def __init__(self, rule=None):
272         self.rule = rule or Always()
273     @property
274     def cal(self):
275         return self.rule.cal
276     @cal.setter
277     def cal(self, value):
278         self.rule.cal = value
279 class OncePerDay(StatefulRule):
280     def __init__(self, rule=None):
281         self.triggered = False
282         self.date = None
283         self.next_date = None
284         super(OncePerDay, self).__init__(rule)
285     def should_trigger(self, dt):
286         if self.date is None or dt &gt;= self.next_date:
287             self.triggered = False
288             self.date = dt
289             self.next_date = dt + pd.Timedelta(1, unit="d")
290         if not self.triggered and self.rule.should_trigger(dt):
291             self.triggered = True
292             return True
293 class date_rules(object):
294     @staticmethod
295     def every_day():
296         return Always()
297     @staticmethod
298     def month_start(days_offset=0):
299         return NthTradingDayOfMonth(n=days_offset)
300     @staticmethod
301     def month_end(days_offset=0):
302         return NDaysBeforeLastTradingDayOfMonth(n=days_offset)
303     @staticmethod
304     def week_start(days_offset=0):
305         return NthTradingDayOfWeek(n=days_offset)
306     @staticmethod
307     def week_end(days_offset=0):
308         return NDaysBeforeLastTradingDayOfWeek(n=days_offset)
309 class time_rules(object):
310     @staticmethod
311     def market_open(offset=None, hours=None, minutes=None):
312         return AfterOpen(offset=offset, hours=hours, minutes=minutes)
313     @staticmethod
314     def market_close(offset=None, hours=None, minutes=None):
315         return BeforeClose(offset=offset, hours=hours, minutes=minutes)
316     every_minute = Always
317 class calendars(object):
318     US_EQUITIES = sentinel('US_EQUITIES')
319     US_FUTURES = sentinel('US_FUTURES')
320 def _invert(d):
321     return dict(zip(d.values(), d.keys()))
322 _uncalled_rules = _invert(vars(date_rules))
323 _uncalled_rules.update(_invert(vars(time_rules)))
324 def _check_if_not_called(v):
325     try:
326         name = _uncalled_rules[v]
327     except KeyError:
328         if not issubclass(v, EventRule):
329             return
330         name = getattr(v, '__name__', None)
331     msg = 'invalid rule: %r' % (v,)
332     if name is not None:
333         msg += ' (hint: did you mean %s())' % name
334     raise TypeError(msg)
335 def make_eventrule(date_rule, time_rule, cal, half_days=True):
336     _check_if_not_called(date_rule)
337     _check_if_not_called(time_rule)
338     if half_days:
339         inner_rule = date_rule &amp; time_rule
340     else:
341         inner_rule = date_rule &amp; time_rule &amp; NotHalfDay()
342     opd = OncePerDay(rule=inner_rule)
343     opd.cal = cal
344     return opd
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
