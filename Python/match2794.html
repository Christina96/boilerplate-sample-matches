<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_ordering.py &amp; events_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_ordering.py &amp; events_1.py
      </h3>
<h1 align="center">
        2.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_ordering.py (2.970297%)<th>events_1.py (1.615074%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(63-65)<td><a href="#" name="0">(382-389)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_ordering.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from nose_parameterized import parameterized
2 import pandas as pd
3 from zipline.algorithm import TradingAlgorithm
4 import zipline.api as api
5 import zipline.errors as ze
6 from zipline.finance.execution import StopLimitOrder
7 import zipline.testing.fixtures as zf
8 from zipline.testing.predicates import assert_equal
9 import zipline.test_algorithms as zta
10 def T(s):
11     return pd.Timestamp(s, tz='UTC')
12 class TestOrderMethods(zf.WithConstantEquityMinuteBarData,
13                        zf.WithConstantFutureMinuteBarData,
14                        zf.WithMakeAlgo,
15                        zf.ZiplineTestCase):
16     START_DATE = T('2006-01-03')
17     END_DATE = T('2006-01-06')
18     SIM_PARAMS_START_DATE = T('2006-01-04')
19     ASSET_FINDER_EQUITY_SIDS = (1,)
20     EQUITY_DAILY_BAR_SOURCE_FROM_MINUTE = True
21     FUTURE_DAILY_BAR_SOURCE_FROM_MINUTE = True
22     EQUITY_MINUTE_CONSTANT_LOW = 2.0
23     EQUITY_MINUTE_CONSTANT_OPEN = 2.0
24     EQUITY_MINUTE_CONSTANT_CLOSE = 2.0
25     EQUITY_MINUTE_CONSTANT_HIGH = 2.0
26     EQUITY_MINUTE_CONSTANT_VOLUME = 10000.0
27     FUTURE_MINUTE_CONSTANT_LOW = 2.0
28     FUTURE_MINUTE_CONSTANT_OPEN = 2.0
29     FUTURE_MINUTE_CONSTANT_CLOSE = 2.0
30     FUTURE_MINUTE_CONSTANT_HIGH = 2.0
31     FUTURE_MINUTE_CONSTANT_VOLUME = 10000.0
32     SIM_PARAMS_CAPITAL_BASE = 10000
33     @classmethod
34     def make_futures_info(cls):
35         return pd.DataFrame.from_dict({
36             2: {
37                 'multiplier': 10,
38                 'symbol': 'F',
39                 'exchange': 'TEST'
40             }
41         }, orient='index')
42 <a name="0"></a>
43     @classmethod
44     def init_class_fixtures(cls):
45         super(TestOrderMethods, cls)<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.init_class_fixtures()
46         cls.EQUITY = cls.asset_finder.retrieve_asset(1)
47         cls.FUTURE = cls.asset_finder.retrieve_asset(</b></font>2)
48     @parameterized.expand([
49         ('order', 1),
50         ('order_value', 1000),
51         ('order_target', 1),
52         ('order_target_value', 1000),
53         ('order_percent', 1),
54         ('order_target_percent', 1),
55     ])
56     def test_cannot_order_in_before_trading_start(self, order_method, amount):
57         algotext = """
58 from zipline.api import sid, {order_func}
59 def initialize(context):
60     context.asset = sid(1)
61 def before_trading_start(context, data):
62     {order_func}(context.asset, {arg})
63         result = self.run_algorithm(script=algotext)
64         for orders in result.orders.values:
65             assert_equal(len(orders), 1)
66             assert_equal(orders[0]['amount'], 5000)
67             assert_equal(orders[0]['sid'], self.EQUITY)
68         for i, positions in enumerate(result.positions.values, start=1):
69             assert_equal(len(positions), 1)
70             assert_equal(positions[0]['amount'], 5000.0 * i)
71             assert_equal(positions[0]['sid'], self.EQUITY)
72     @parameterized.expand([
73         ('order_target', 5000),         # 5000 shares times $2 per share
74         ('order_target_value', 10000),  # $10000
75         ('order_target_percent', 1),    # 100% on a $10000 capital base.
76     ])
77     def test_order_equity_targeted(self, order_method, amount):
78         algotext = """
79 import zipline.api as api
80 def initialize(context):
81     api.set_slippage(api.slippage.FixedSlippage(spread=0.0))
82     api.set_commission(api.commission.PerShare(0))
83     context.equity = api.sid(1)
84     api.schedule_function(
85         func=do_order,
86         date_rule=api.date_rules.every_day(),
87         time_rule=api.time_rules.market_open(),
88     )
89 def do_order(context, data):
90     context.ordered = True
91     api.{order_func}(context.equity, {arg})
92         result = self.run_algorithm(script=algotext)
93         for orders in result.orders.values:
94             assert_equal(len(orders), 1)
95             assert_equal(orders[0]['amount'], 500)
96             assert_equal(orders[0]['sid'], self.FUTURE)
97         for i, positions in enumerate(result.positions.values, start=1):
98             assert_equal(len(positions), 1)
99             assert_equal(positions[0]['amount'], 500.0 * i)
100             assert_equal(positions[0]['sid'], self.FUTURE)
101     @parameterized.expand([
102         ('order_target', 500),          # 500 contracts * $2 per contract * 10x
103         ('order_target_value', 10000),  # $10000
104         ('order_target_percent', 1),    # 100% on a $10000 capital base.
105     ])
106     def test_order_future_targeted(self, order_method, amount):
107         algotext = """
108 import zipline.api as api
109 def initialize(context):
110     api.set_slippage(us_futures=api.slippage.FixedSlippage(spread=0.0))
111     api.set_commission(us_futures=api.commission.PerTrade(0.0))
112     context.future = api.sid(2)
113     api.schedule_function(
114         func=do_order,
115         date_rule=api.date_rules.every_day(),
116         time_rule=api.time_rules.market_open(),
117     )
118 def do_order(context, data):
119     context.ordered = True
120     api.{order_func}(context.future, {arg})
121     Converts a UTC tz-naive timestamp to a tz-aware timestamp.
122     Normalize a time. If the time is tz-naive, assume it is UTC.
123     Builds the offset argument for event rules.
124     Builds the date argument for event rules.
125     Builds the time argument for event rules.
126     A preprocessor that coerces integral floats to ints.
127     Receipt of non-integral floats raises a TypeError.
128     This manages the logic for checking the rules and dispatching to the
129     handle_data function of the Events.
130     Parameters
131     ----------
132     create_context : (BarData) -&gt; context manager, optional
133         An optional callback to produce a context manager to wrap the calls
134         to handle_data. This will be passed the current BarData.
135         Adds an event to the manager.
136     An event is a pairing of an EventRule and a callable that will be invoked
137     with the current algorithm context, data, and datetime only when the rule
138     is triggered.
139         Calls the callable only when the rule is triggered.
140         Checks if the rule should trigger with its current state.
141         This method should be pure and NOT mutate any state on the object.
142     A stateless rule has no observable side effects.
143     This is reentrant and will always give the same result for the
144     same datetime.
145     Because these are pure, they can be composed to create new rules.
146         Logical and of two rules, triggers only when both rules trigger.
147         This follows the short circuiting rules for normal and.
148     A rule that composes the results of two rules with some composing function.
149     The composing function should be a binary function that accepts the results
150     first(dt) and second(dt) as positional arguments.
151     For example, operator.and_.
152     If lazy=True, then the lazy composer is used instead. The lazy composer
153     expects a function that takes the two should_trigger functions and the
154     datetime. This is useful of you don't always want to call should_trigger
155     for one of the rules. For example, this is used to implement the &amp; and |
156     operators so that they will have the same short circuit logic that is
157     expected.
158         Composes the two rules with a lazy composer.
159         Lazily ands the two rules. This will NOT call the should_trigger of the
160         second rule if the first one returns False.
161     A rule that always triggers.
162         A should_trigger implementation that will always trigger.
163     A rule that never triggers.
164         A should_trigger implementation that will never trigger.
165     A rule that triggers for some offset after the market opens.
166     Example that triggers after 30 minutes of the market opening:
167     &gt;&gt;&gt; AfterOpen(minutes=30)  # doctest: +ELLIPSIS
168     &lt;zipline.utils.events.AfterOpen object at ...&gt;
169     """
170     def __init__(self, offset=None, **kwargs):
171         self.offset = _build_offset(
172             offset,
173             kwargs,
174             datetime.timedelta(minutes=1),  # Defaults to the first minute.
175         )
176         self._period_start = None
177         self._period_end = None
178         self._period_close = None
179         self._one_minute = datetime.timedelta(minutes=1)
180     def calculate_dates(self, dt):
181         period_start, period_close = self.cal.open_and_close_for_session(
182             self.cal<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.minute_to_session_label(dt),
183         )
184         self._period_start = self.cal.execution_time_from_open(period_start)
185         self._period_close = self.cal.execution_time_from_close(</b></font>period_close)
186         self._period_end = self._period_start + self.offset - self._one_minute
187     def should_trigger(self, dt):
188         if (
189             self._period_start is None or
190             self._period_close &lt;= dt
191         ):
192             self.calculate_dates(dt)
193         return dt == self._period_end
194 class BeforeClose(StatelessRule):
195     def __init__(self, offset=None, **kwargs):
196         self.offset = _build_offset(
197             offset,
198             kwargs,
199             datetime.timedelta(minutes=1),  # Defaults to the last minute.
200         )
201         self._period_start = None
202         self._period_close = None
203         self._period_end = None
204         self._one_minute = datetime.timedelta(minutes=1)
205     def calculate_dates(self, dt):
206         period_end = self.cal.open_and_close_for_session(
207             self.cal.minute_to_session_label(dt),
208         )[1]
209         self._period_end = self.cal.execution_time_from_close(period_end)
210         self._period_start = self._period_end - self.offset
211         self._period_close = self._period_end
212     def should_trigger(self, dt):
213         if self._period_start is None or self._period_close &lt;= dt:
214             self.calculate_dates(dt)
215         return self._period_start == dt
216 class NotHalfDay(StatelessRule):
217     def should_trigger(self, dt):
218         return self.cal.minute_to_session_label(dt) \
219             not in self.cal.early_closes
220 class TradingDayOfWeekRule(six.with_metaclass(ABCMeta, StatelessRule)):
221     @preprocess(n=lossless_float_to_int('TradingDayOfWeekRule'))
222     def __init__(self, n, invert):
223         if not 0 &lt;= n &lt; MAX_WEEK_RANGE:
224             raise _out_of_range_error(MAX_WEEK_RANGE)
225         self.td_delta = (-n - 1) if invert else n
226     def should_trigger(self, dt):
227         val = self.cal.minute_to_session_label(dt, direction="none").value
228         return val in self.execution_period_values
229     @lazyval
230     def execution_period_values(self):
231         sessions = self.cal.all_sessions
232         return set(
233             pd.Series(data=sessions)
234             .groupby(sessions.map(lambda x: x.isocalendar()[0:2]))
235             .nth(self.td_delta)
236             .astype(np.int64)
237         )
238 class NthTradingDayOfWeek(TradingDayOfWeekRule):
239     def __init__(self, n):
240         super(NthTradingDayOfWeek, self).__init__(n, invert=False)
241 class NDaysBeforeLastTradingDayOfWeek(TradingDayOfWeekRule):
242     def __init__(self, n):
243         super(NDaysBeforeLastTradingDayOfWeek, self).__init__(n, invert=True)
244 class TradingDayOfMonthRule(six.with_metaclass(ABCMeta, StatelessRule)):
245     @preprocess(n=lossless_float_to_int('TradingDayOfMonthRule'))
246     def __init__(self, n, invert):
247         if not 0 &lt;= n &lt; MAX_MONTH_RANGE:
248             raise _out_of_range_error(MAX_MONTH_RANGE)
249         if invert:
250             self.td_delta = -n - 1
251         else:
252             self.td_delta = n
253     def should_trigger(self, dt):
254         value = self.cal.minute_to_session_label(dt, direction="none").value
255         return value in self.execution_period_values
256     @lazyval
257     def execution_period_values(self):
258         sessions = self.cal.all_sessions
259         return set(
260             pd.Series(data=sessions)
261             .groupby([sessions.year, sessions.month])
262             .nth(self.td_delta)
263             .astype(np.int64)
264         )
265 class NthTradingDayOfMonth(TradingDayOfMonthRule):
266     def __init__(self, n):
267         super(NthTradingDayOfMonth, self).__init__(n, invert=False)
268 class NDaysBeforeLastTradingDayOfMonth(TradingDayOfMonthRule):
269     def __init__(self, n):
270         super(NDaysBeforeLastTradingDayOfMonth, self).__init__(n, invert=True)
271 class StatefulRule(EventRule):
272     def __init__(self, rule=None):
273         self.rule = rule or Always()
274     @property
275     def cal(self):
276         return self.rule.cal
277     @cal.setter
278     def cal(self, value):
279         self.rule.cal = value
280 class OncePerDay(StatefulRule):
281     def __init__(self, rule=None):
282         self.triggered = False
283         self.date = None
284         self.next_date = None
285         super(OncePerDay, self).__init__(rule)
286     def should_trigger(self, dt):
287         if self.date is None or dt &gt;= self.next_date:
288             self.triggered = False
289             self.date = dt
290             self.next_date = dt + pd.Timedelta(1, unit="d")
291         if not self.triggered and self.rule.should_trigger(dt):
292             self.triggered = True
293             return True
294 class date_rules(object):
295     @staticmethod
296     def every_day():
297         return Always()
298     @staticmethod
299     def month_start(days_offset=0):
300         return NthTradingDayOfMonth(n=days_offset)
301     @staticmethod
302     def month_end(days_offset=0):
303         return NDaysBeforeLastTradingDayOfMonth(n=days_offset)
304     @staticmethod
305     def week_start(days_offset=0):
306         return NthTradingDayOfWeek(n=days_offset)
307     @staticmethod
308     def week_end(days_offset=0):
309         return NDaysBeforeLastTradingDayOfWeek(n=days_offset)
310 class time_rules(object):
311     @staticmethod
312     def market_open(offset=None, hours=None, minutes=None):
313         return AfterOpen(offset=offset, hours=hours, minutes=minutes)
314     @staticmethod
315     def market_close(offset=None, hours=None, minutes=None):
316         return BeforeClose(offset=offset, hours=hours, minutes=minutes)
317     every_minute = Always
318 class calendars(object):
319     US_EQUITIES = sentinel('US_EQUITIES')
320     US_FUTURES = sentinel('US_FUTURES')
321 def _invert(d):
322     return dict(zip(d.values(), d.keys()))
323 _uncalled_rules = _invert(vars(date_rules))
324 _uncalled_rules.update(_invert(vars(time_rules)))
325 def _check_if_not_called(v):
326     try:
327         name = _uncalled_rules[v]
328     except KeyError:
329         if not issubclass(v, EventRule):
330             return
331         name = getattr(v, '__name__', None)
332     msg = 'invalid rule: %r' % (v,)
333     if name is not None:
334         msg += ' (hint: did you mean %s())' % name
335     raise TypeError(msg)
336 def make_eventrule(date_rule, time_rule, cal, half_days=True):
337     _check_if_not_called(date_rule)
338     _check_if_not_called(time_rule)
339     if half_days:
340         inner_rule = date_rule &amp; time_rule
341     else:
342         inner_rule = date_rule &amp; time_rule &amp; NotHalfDay()
343     opd = OncePerDay(rule=inner_rule)
344     opd.cal = cal
345     return opd
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
