<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_ordering.py &amp; events_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_ordering.py &amp; events_1.py
      </h3>
<h1 align="center">
        2.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_ordering.py (2.970297%)<th>events_1.py (1.615074%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(63-65)<td><a href="#" name="0">(382-389)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_ordering.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
from nose_parameterized import parameterized
import pandas as pd
from zipline.algorithm import TradingAlgorithm
import zipline.api as api
import zipline.errors as ze
from zipline.finance.execution import StopLimitOrder
import zipline.testing.fixtures as zf
from zipline.testing.predicates import assert_equal
import zipline.test_algorithms as zta
def T(s):
    return pd.Timestamp(s, tz='UTC')
class TestOrderMethods(zf.WithConstantEquityMinuteBarData,
                       zf.WithConstantFutureMinuteBarData,
                       zf.WithMakeAlgo,
                       zf.ZiplineTestCase):
    START_DATE = T('2006-01-03')
    END_DATE = T('2006-01-06')
    SIM_PARAMS_START_DATE = T('2006-01-04')
    ASSET_FINDER_EQUITY_SIDS = (1,)
    EQUITY_DAILY_BAR_SOURCE_FROM_MINUTE = True
    FUTURE_DAILY_BAR_SOURCE_FROM_MINUTE = True
    EQUITY_MINUTE_CONSTANT_LOW = 2.0
    EQUITY_MINUTE_CONSTANT_OPEN = 2.0
    EQUITY_MINUTE_CONSTANT_CLOSE = 2.0
    EQUITY_MINUTE_CONSTANT_HIGH = 2.0
    EQUITY_MINUTE_CONSTANT_VOLUME = 10000.0
    FUTURE_MINUTE_CONSTANT_LOW = 2.0
    FUTURE_MINUTE_CONSTANT_OPEN = 2.0
    FUTURE_MINUTE_CONSTANT_CLOSE = 2.0
    FUTURE_MINUTE_CONSTANT_HIGH = 2.0
    FUTURE_MINUTE_CONSTANT_VOLUME = 10000.0
    SIM_PARAMS_CAPITAL_BASE = 10000
    @classmethod
    def make_futures_info(cls):
        return pd.DataFrame.from_dict({
            2: {
                'multiplier': 10,
                'symbol': 'F',
                'exchange': 'TEST'
            }
        }, orient='index')
<a name="0"></a>
    @classmethod
    def init_class_fixtures(cls):
        super(TestOrderMethods, cls)<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.init_class_fixtures()
        cls.EQUITY = cls.asset_finder.retrieve_asset(1)
        cls.FUTURE = cls.asset_finder.retrieve_asset(</b></font>2)
    @parameterized.expand([
        ('order', 1),
        ('order_value', 1000),
        ('order_target', 1),
        ('order_target_value', 1000),
        ('order_percent', 1),
        ('order_target_percent', 1),
    ])
    def test_cannot_order_in_before_trading_start(self, order_method, amount):
        algotext = """
from zipline.api import sid, {order_func}
def initialize(context):
    context.asset = sid(1)
def before_trading_start(context, data):
    {order_func}(context.asset, {arg})
        result = self.run_algorithm(script=algotext)
        for orders in result.orders.values:
            assert_equal(len(orders), 1)
            assert_equal(orders[0]['amount'], 5000)
            assert_equal(orders[0]['sid'], self.EQUITY)
        for i, positions in enumerate(result.positions.values, start=1):
            assert_equal(len(positions), 1)
            assert_equal(positions[0]['amount'], 5000.0 * i)
            assert_equal(positions[0]['sid'], self.EQUITY)
    @parameterized.expand([
        ('order_target', 5000),         # 5000 shares times $2 per share
        ('order_target_value', 10000),  # $10000
        ('order_target_percent', 1),    # 100% on a $10000 capital base.
    ])
    def test_order_equity_targeted(self, order_method, amount):
        algotext = """
import zipline.api as api
def initialize(context):
    api.set_slippage(api.slippage.FixedSlippage(spread=0.0))
    api.set_commission(api.commission.PerShare(0))
    context.equity = api.sid(1)
    api.schedule_function(
        func=do_order,
        date_rule=api.date_rules.every_day(),
        time_rule=api.time_rules.market_open(),
    )
def do_order(context, data):
    context.ordered = True
    api.{order_func}(context.equity, {arg})
        result = self.run_algorithm(script=algotext)
        for orders in result.orders.values:
            assert_equal(len(orders), 1)
            assert_equal(orders[0]['amount'], 500)
            assert_equal(orders[0]['sid'], self.FUTURE)
        for i, positions in enumerate(result.positions.values, start=1):
            assert_equal(len(positions), 1)
            assert_equal(positions[0]['amount'], 500.0 * i)
            assert_equal(positions[0]['sid'], self.FUTURE)
    @parameterized.expand([
        ('order_target', 500),          # 500 contracts * $2 per contract * 10x
        ('order_target_value', 10000),  # $10000
        ('order_target_percent', 1),    # 100% on a $10000 capital base.
    ])
    def test_order_future_targeted(self, order_method, amount):
        algotext = """
import zipline.api as api
def initialize(context):
    api.set_slippage(us_futures=api.slippage.FixedSlippage(spread=0.0))
    api.set_commission(us_futures=api.commission.PerTrade(0.0))
    context.future = api.sid(2)
    api.schedule_function(
        func=do_order,
        date_rule=api.date_rules.every_day(),
        time_rule=api.time_rules.market_open(),
    )
def do_order(context, data):
    context.ordered = True
    api.{order_func}(context.future, {arg})
    Converts a UTC tz-naive timestamp to a tz-aware timestamp.
    Normalize a time. If the time is tz-naive, assume it is UTC.
    Builds the offset argument for event rules.
    Builds the date argument for event rules.
    Builds the time argument for event rules.
    A preprocessor that coerces integral floats to ints.
    Receipt of non-integral floats raises a TypeError.
    This manages the logic for checking the rules and dispatching to the
    handle_data function of the Events.
    Parameters
    ----------
    create_context : (BarData) -&gt; context manager, optional
        An optional callback to produce a context manager to wrap the calls
        to handle_data. This will be passed the current BarData.
        Adds an event to the manager.
    An event is a pairing of an EventRule and a callable that will be invoked
    with the current algorithm context, data, and datetime only when the rule
    is triggered.
        Calls the callable only when the rule is triggered.
        Checks if the rule should trigger with its current state.
        This method should be pure and NOT mutate any state on the object.
    A stateless rule has no observable side effects.
    This is reentrant and will always give the same result for the
    same datetime.
    Because these are pure, they can be composed to create new rules.
        Logical and of two rules, triggers only when both rules trigger.
        This follows the short circuiting rules for normal and.
    A rule that composes the results of two rules with some composing function.
    The composing function should be a binary function that accepts the results
    first(dt) and second(dt) as positional arguments.
    For example, operator.and_.
    If lazy=True, then the lazy composer is used instead. The lazy composer
    expects a function that takes the two should_trigger functions and the
    datetime. This is useful of you don't always want to call should_trigger
    for one of the rules. For example, this is used to implement the &amp; and |
    operators so that they will have the same short circuit logic that is
    expected.
        Composes the two rules with a lazy composer.
        Lazily ands the two rules. This will NOT call the should_trigger of the
        second rule if the first one returns False.
    A rule that always triggers.
        A should_trigger implementation that will always trigger.
    A rule that never triggers.
        A should_trigger implementation that will never trigger.
    A rule that triggers for some offset after the market opens.
    Example that triggers after 30 minutes of the market opening:
    &gt;&gt;&gt; AfterOpen(minutes=30)  # doctest: +ELLIPSIS
    &lt;zipline.utils.events.AfterOpen object at ...&gt;
    """
    def __init__(self, offset=None, **kwargs):
        self.offset = _build_offset(
            offset,
            kwargs,
            datetime.timedelta(minutes=1),  # Defaults to the first minute.
        )
        self._period_start = None
        self._period_end = None
        self._period_close = None
        self._one_minute = datetime.timedelta(minutes=1)
    def calculate_dates(self, dt):
        period_start, period_close = self.cal.open_and_close_for_session(
            self.cal<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.minute_to_session_label(dt),
        )
        self._period_start = self.cal.execution_time_from_open(period_start)
        self._period_close = self.cal.execution_time_from_close(</b></font>period_close)
        self._period_end = self._period_start + self.offset - self._one_minute
    def should_trigger(self, dt):
        if (
            self._period_start is None or
            self._period_close &lt;= dt
        ):
            self.calculate_dates(dt)
        return dt == self._period_end
class BeforeClose(StatelessRule):
    def __init__(self, offset=None, **kwargs):
        self.offset = _build_offset(
            offset,
            kwargs,
            datetime.timedelta(minutes=1),  # Defaults to the last minute.
        )
        self._period_start = None
        self._period_close = None
        self._period_end = None
        self._one_minute = datetime.timedelta(minutes=1)
    def calculate_dates(self, dt):
        period_end = self.cal.open_and_close_for_session(
            self.cal.minute_to_session_label(dt),
        )[1]
        self._period_end = self.cal.execution_time_from_close(period_end)
        self._period_start = self._period_end - self.offset
        self._period_close = self._period_end
    def should_trigger(self, dt):
        if self._period_start is None or self._period_close &lt;= dt:
            self.calculate_dates(dt)
        return self._period_start == dt
class NotHalfDay(StatelessRule):
    def should_trigger(self, dt):
        return self.cal.minute_to_session_label(dt) \
            not in self.cal.early_closes
class TradingDayOfWeekRule(six.with_metaclass(ABCMeta, StatelessRule)):
    @preprocess(n=lossless_float_to_int('TradingDayOfWeekRule'))
    def __init__(self, n, invert):
        if not 0 &lt;= n &lt; MAX_WEEK_RANGE:
            raise _out_of_range_error(MAX_WEEK_RANGE)
        self.td_delta = (-n - 1) if invert else n
    def should_trigger(self, dt):
        val = self.cal.minute_to_session_label(dt, direction="none").value
        return val in self.execution_period_values
    @lazyval
    def execution_period_values(self):
        sessions = self.cal.all_sessions
        return set(
            pd.Series(data=sessions)
            .groupby(sessions.map(lambda x: x.isocalendar()[0:2]))
            .nth(self.td_delta)
            .astype(np.int64)
        )
class NthTradingDayOfWeek(TradingDayOfWeekRule):
    def __init__(self, n):
        super(NthTradingDayOfWeek, self).__init__(n, invert=False)
class NDaysBeforeLastTradingDayOfWeek(TradingDayOfWeekRule):
    def __init__(self, n):
        super(NDaysBeforeLastTradingDayOfWeek, self).__init__(n, invert=True)
class TradingDayOfMonthRule(six.with_metaclass(ABCMeta, StatelessRule)):
    @preprocess(n=lossless_float_to_int('TradingDayOfMonthRule'))
    def __init__(self, n, invert):
        if not 0 &lt;= n &lt; MAX_MONTH_RANGE:
            raise _out_of_range_error(MAX_MONTH_RANGE)
        if invert:
            self.td_delta = -n - 1
        else:
            self.td_delta = n
    def should_trigger(self, dt):
        value = self.cal.minute_to_session_label(dt, direction="none").value
        return value in self.execution_period_values
    @lazyval
    def execution_period_values(self):
        sessions = self.cal.all_sessions
        return set(
            pd.Series(data=sessions)
            .groupby([sessions.year, sessions.month])
            .nth(self.td_delta)
            .astype(np.int64)
        )
class NthTradingDayOfMonth(TradingDayOfMonthRule):
    def __init__(self, n):
        super(NthTradingDayOfMonth, self).__init__(n, invert=False)
class NDaysBeforeLastTradingDayOfMonth(TradingDayOfMonthRule):
    def __init__(self, n):
        super(NDaysBeforeLastTradingDayOfMonth, self).__init__(n, invert=True)
class StatefulRule(EventRule):
    def __init__(self, rule=None):
        self.rule = rule or Always()
    @property
    def cal(self):
        return self.rule.cal
    @cal.setter
    def cal(self, value):
        self.rule.cal = value
class OncePerDay(StatefulRule):
    def __init__(self, rule=None):
        self.triggered = False
        self.date = None
        self.next_date = None
        super(OncePerDay, self).__init__(rule)
    def should_trigger(self, dt):
        if self.date is None or dt &gt;= self.next_date:
            self.triggered = False
            self.date = dt
            self.next_date = dt + pd.Timedelta(1, unit="d")
        if not self.triggered and self.rule.should_trigger(dt):
            self.triggered = True
            return True
class date_rules(object):
    @staticmethod
    def every_day():
        return Always()
    @staticmethod
    def month_start(days_offset=0):
        return NthTradingDayOfMonth(n=days_offset)
    @staticmethod
    def month_end(days_offset=0):
        return NDaysBeforeLastTradingDayOfMonth(n=days_offset)
    @staticmethod
    def week_start(days_offset=0):
        return NthTradingDayOfWeek(n=days_offset)
    @staticmethod
    def week_end(days_offset=0):
        return NDaysBeforeLastTradingDayOfWeek(n=days_offset)
class time_rules(object):
    @staticmethod
    def market_open(offset=None, hours=None, minutes=None):
        return AfterOpen(offset=offset, hours=hours, minutes=minutes)
    @staticmethod
    def market_close(offset=None, hours=None, minutes=None):
        return BeforeClose(offset=offset, hours=hours, minutes=minutes)
    every_minute = Always
class calendars(object):
    US_EQUITIES = sentinel('US_EQUITIES')
    US_FUTURES = sentinel('US_FUTURES')
def _invert(d):
    return dict(zip(d.values(), d.keys()))
_uncalled_rules = _invert(vars(date_rules))
_uncalled_rules.update(_invert(vars(time_rules)))
def _check_if_not_called(v):
    try:
        name = _uncalled_rules[v]
    except KeyError:
        if not issubclass(v, EventRule):
            return
        name = getattr(v, '__name__', None)
    msg = 'invalid rule: %r' % (v,)
    if name is not None:
        msg += ' (hint: did you mean %s())' % name
    raise TypeError(msg)
def make_eventrule(date_rule, time_rule, cal, half_days=True):
    _check_if_not_called(date_rule)
    _check_if_not_called(time_rule)
    if half_days:
        inner_rule = date_rule &amp; time_rule
    else:
        inner_rule = date_rule &amp; time_rule &amp; NotHalfDay()
    opd = OncePerDay(rule=inner_rule)
    opd.cal = cal
    return opd
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
