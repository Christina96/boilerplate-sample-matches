
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.0914555603263203%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>sonnet-MDEwOlJlcG9zaXRvcnk4NzA2NzIxMg==-flat-conv_transpose_test.py</h3>
            <pre><code>1  import itertools
2  from absl.testing import parameterized
3  import numpy as np
4  from sonnet.src import conv_transpose
5  from sonnet.src import initializers as lib_initializers
6  from sonnet.src import test_utils
7  import tensorflow as tf
8  def create_constant_initializers(w, b, with_bias):
9    if with_bias:
10      return {
11          "w_init": lib_initializers.Constant(w),
12          "b_init": lib_initializers.Constant(b)
13      }
14    else:
15      return {"w_init": lib_initializers.Constant(w)}
16  class ConvTransposeTest(test_utils.TestCase, parameterized.TestCase):
17    @parameterized.parameters(0, 4)
18    def testIncorrectN(self, n):
19      with self.assertRaisesRegex(
20          ValueError,
21          "only support transpose convolution operations for num_spatial_dims"):
22        conv_transpose.ConvNDTranspose(
23            num_spatial_dims=n,
24            output_channels=1,
25            output_shape=None,
26            kernel_shape=3,
27            data_format="NHWC")
28    def testIncorrectPadding(self):
29      with self.assertRaisesRegex(
30          TypeError,
31          "ConvNDTranspose only takes string padding, please provide either"):
32        conv_transpose.ConvNDTranspose(
33            2, output_channels=1, kernel_shape=3, padding=None)
34    def testBiasInitNoBias(self):
35      with self.assertRaisesRegex(
36          ValueError, "When not using a bias the b_init must be None."):
<span onclick='openModal()' class='match'>37        conv_transpose.ConvNDTranspose(
38            2, output_channels=1, kernel_shape=3, with_bias=False,
39            b_init=lib_initializers.Ones(), data_format="NHWC")
</span>40    def testIncorrectOutputShape(self):
41      c = conv_transpose.ConvNDTranspose(
42          num_spatial_dims=2,
43          output_channels=3,
44          kernel_shape=2,
45          output_shape=[1],
46          data_format="NHWC")
47      with self.assertRaisesRegex(
48          ValueError, "The output_shape must be of length 2 but instead was 1."):
49        c(tf.ones([3, 5, 5, 3]))
50    @parameterized.parameters(*itertools.product(
51        [True, False],  # with_bias
52        ["SAME", "VALID"]))  # padding
53    def testGraphConv(self, with_bias, padding):
54      conv1 = conv_transpose.ConvNDTranspose(
55          num_spatial_dims=2,
56          output_channels=1,
57          output_shape=None,
58          kernel_shape=3,
59          stride=1,
60          padding=padding,
61          with_bias=with_bias,
62          data_format="NHWC",
63          **create_constant_initializers(1.0, 1.0, with_bias))
64      conv2 = conv_transpose.ConvNDTranspose(
65          num_spatial_dims=2,
66          output_channels=1,
67          output_shape=None,
68          kernel_shape=3,
69          stride=1,
70          padding=padding,
71          with_bias=with_bias,
72          data_format="NHWC",
73          **create_constant_initializers(1.0, 1.0, with_bias))
74      defun_conv = tf.function(conv2)
75      iterations = 5
76      for _ in range(iterations):
77        x = tf.random.uniform([1, 3, 3, 1])
78        y1 = conv1(x)
79        y2 = defun_conv(x)
80        self.assertAllClose(self.evaluate(y1), self.evaluate(y2), atol=1e-4)
81    def testUnknownBatchSizeNHWC(self):
82      x = tf.TensorSpec([None, 5, 5, 3], dtype=tf.float32)
83      c = conv_transpose.ConvNDTranspose(
84          num_spatial_dims=2,
85          output_channels=2,
86          kernel_shape=3,
87          data_format="NHWC")
88      defun_conv = tf.function(c).get_concrete_function(x)
89      out1 = defun_conv(tf.ones([3, 5, 5, 3]))
90      self.assertEqual(out1.shape, [3, 5, 5, 2])
91      out2 = defun_conv(tf.ones([5, 5, 5, 3]))
92      self.assertEqual(out2.shape, [5, 5, 5, 2])
93    def testUnknownBatchSizeNCHW(self):
94      if self.primary_device == "CPU":
95        self.skipTest("NCHW not supported on CPU")
96      x = tf.TensorSpec([None, 3, 5, 5], dtype=tf.float32)
97      c = conv_transpose.ConvNDTranspose(
98          num_spatial_dims=2,
99          output_channels=2,
100          kernel_shape=3,
101          data_format="NCHW")
102      defun_conv = tf.function(c).get_concrete_function(x)
103      out1 = defun_conv(tf.ones([3, 3, 5, 5]))
104      self.assertEqual(out1.shape, [3, 2, 5, 5])
105      out2 = defun_conv(tf.ones([5, 3, 5, 5]))
106      self.assertEqual(out2.shape, [5, 2, 5, 5])
107    def testUnknownShapeDims(self):
108      x = tf.TensorSpec([3, None, None, 3], dtype=tf.float32)
109      c = conv_transpose.ConvNDTranspose(
110          num_spatial_dims=2,
111          output_channels=2,
112          kernel_shape=3,
113          data_format="NHWC")
114      defun_conv = tf.function(c).get_concrete_function(x)
115      out1 = defun_conv(tf.ones([3, 5, 5, 3]))
116      self.assertEqual(out1.shape, [3, 5, 5, 2])
117      out1 = defun_conv(tf.ones([3, 3, 3, 3]))
118      self.assertEqual(out1.shape, [3, 3, 3, 2])
119    def testGivenOutputShape(self):
120      c = conv_transpose.ConvNDTranspose(
121          num_spatial_dims=2,
122          output_channels=2,
123          kernel_shape=3,
124          output_shape=[5, 5],
125          data_format="NHWC")
126      out1 = c(tf.ones([3, 5, 5, 3]))
127      self.assertEqual(out1.shape, [3, 5, 5, 2])
128    @parameterized.parameters(True, False)
129    def testUnknownChannels(self, autograph):
130      x = tf.TensorSpec([3, 3, 3, None], dtype=tf.float32)
131      c = conv_transpose.ConvNDTranspose(
132          num_spatial_dims=2,
133          output_channels=1,
134          kernel_shape=3,
135          data_format="NHWC")
136      defun_conv = tf.function(c, autograph=autograph)
137      with self.assertRaisesRegex(ValueError,
138                                  "The number of input channels must be known"):
139        defun_conv.get_concrete_function(x)
140    @parameterized.parameters(
141        (1, (3,), 128, 5, "NWC"),
142        (2, (4, 4), 64, 3, "NHWC"),
143        (3, (4, 4, 4), 64, 3, "NDHWC"))
144    def testInitializerVariance(self, num_spatial_dims, kernel_shape,
145                                in_channels, output_channels, data_format):
146      inputs = tf.random.uniform([16] + ([32] * num_spatial_dims) + [in_channels])
147      c = conv_transpose.ConvNDTranspose(
148          num_spatial_dims=num_spatial_dims,
149          kernel_shape=kernel_shape,
150          output_channels=output_channels,
151          data_format=data_format)
152      c(inputs)
153      actual_std = c.w.numpy().std()
154      expected_std = 1 / (np.sqrt(np.prod(kernel_shape + (in_channels,))))
155      rel_diff = np.abs(actual_std - expected_std) / expected_std
156      self.assertLess(rel_diff, 0.5)
157  class Conv2DTransposeTest(test_utils.TestCase, parameterized.TestCase):
158    @parameterized.parameters(True, False)
159    def testComputationPaddingSame(self, with_bias):
160      expected_out = [[4, 6, 4], [6, 9, 6], [4, 6, 4]]
161      expected_out = np.asarray(expected_out, dtype=np.float32)
162      if with_bias:
163        expected_out += 1
164      conv_transpose1 = conv_transpose.Conv2DTranspose(
165          output_channels=1,
166          output_shape=None,
167          kernel_shape=3,
168          stride=1,
169          padding="SAME",
170          with_bias=with_bias,
171          **create_constant_initializers(1.0, 1.0, with_bias))
172      out = conv_transpose1(tf.ones([1, 3, 3, 1], dtype=tf.float32))
173      self.assertEqual(out.shape, [1, 3, 3, 1])
174      out = tf.squeeze(out, axis=(0, 3))
175      self.assertAllClose(self.evaluate(out), expected_out)
176    @parameterized.parameters(True, False)
177    def testComputationPaddingValid(self, with_bias):
178      expected_out = [[1, 2, 3, 2, 1], [2, 4, 6, 4, 2], [3, 6, 9, 6, 3],
179                      [2, 4, 6, 4, 2], [1, 2, 3, 2, 1]]
180      expected_out = np.asarray(expected_out, dtype=np.float32)
181      if with_bias:
182        expected_out += 1
183      conv1 = conv_transpose.Conv2DTranspose(
184          output_channels=1,
185          output_shape=None,
186          kernel_shape=3,
187          stride=1,
188          padding="VALID",
189          with_bias=with_bias,
190          **create_constant_initializers(1.0, 1.0, with_bias))
191      out = conv1(tf.ones([1, 3, 3, 1], dtype=tf.float32))
192      self.assertEqual(out.shape, [1, 5, 5, 1])
193      out = tf.squeeze(out, axis=(0, 3))
194      self.assertAllClose(self.evaluate(out), expected_out)
195    def testShapeDilated(self):
196      if "CPU" == self.primary_device:
197        self.skipTest("Not supported on CPU")
198      conv1 = conv_transpose.Conv2DTranspose(
199          output_channels=1,
200          output_shape=None,
201          kernel_shape=3,
202          rate=2,
203          padding="VALID")
204      out = conv1(tf.ones([1, 3, 3, 1]))
205      self.assertEqual(out.shape, [1, 7, 7, 1])
206  class Conv1DTransposeTest(test_utils.TestCase, parameterized.TestCase):
207    @parameterized.parameters(True, False)
208    def testComputationPaddingSame(self, with_bias):
209      expected_out = [2, 3, 2]
210      expected_out = np.asarray(expected_out, dtype=np.float32)
211      if with_bias:
212        expected_out += 1
213      conv1 = conv_transpose.Conv1DTranspose(
214          output_channels=1,
215          output_shape=None,
216          kernel_shape=3,
217          stride=1,
218          padding="SAME",
219          with_bias=with_bias,
220          **create_constant_initializers(1.0, 1.0, with_bias))
221      out = conv1(tf.ones([1, 3, 1], dtype=tf.float32))
222      self.assertEqual(out.shape, [1, 3, 1])
223      out = tf.squeeze(out, axis=(0, 2))
224      self.assertAllClose(self.evaluate(out), expected_out)
225    @parameterized.parameters(True, False)
226    def testComputationPaddingValid(self, with_bias):
227      expected_out = [1, 2, 3, 2, 1]
228      expected_out = np.asarray(expected_out, dtype=np.float32)
229      if with_bias:
230        expected_out += 1
231      conv1 = conv_transpose.Conv1DTranspose(
232          output_channels=1,
233          output_shape=None,
234          kernel_shape=3,
235          stride=1,
236          padding="VALID",
237          with_bias=with_bias,
238          **create_constant_initializers(1.0, 1.0, with_bias))
239      out = conv1(tf.ones([1, 3, 1], dtype=tf.float32))
240      self.assertEqual(out.shape, [1, 5, 1])
241      out = tf.squeeze(out, axis=(0, 2))
242      self.assertAllClose(self.evaluate(out), expected_out)
243  class Conv3DTransposeTest(test_utils.TestCase, parameterized.TestCase):
244    @parameterized.parameters(True, False)
245    def testComputationPaddingSame(self, with_bias):
246      expected_out = np.asarray([
247          8, 12, 8, 12, 18, 12, 8, 12, 8, 12, 18, 12, 18, 27, 18, 12, 18, 12, 8,
248          12, 8, 12, 18, 12, 8, 12, 8
249      ]).reshape((3, 3, 3))
250      if with_bias:
251        expected_out += 1
252      conv_transpose1 = conv_transpose.Conv3DTranspose(
253          output_channels=1,
254          output_shape=None,
255          kernel_shape=3,
256          stride=1,
257          padding="SAME",
258          with_bias=with_bias,
259          **create_constant_initializers(1.0, 1.0, with_bias))
260      out = conv_transpose1(tf.ones([1, 3, 3, 3, 1], dtype=tf.float32))
261      self.assertEqual(out.shape, [1, 3, 3, 3, 1])
262      out = tf.squeeze(out, axis=(0, 4))
263      self.assertAllClose(self.evaluate(out), expected_out)
264    @parameterized.parameters(True, False)
265    def testComputationPaddingValid(self, with_bias):
266      expected_out = np.asarray([
267          1, 2, 3, 2, 1, 2, 4, 6, 4, 2, 3, 6, 9, 6, 3, 2, 4, 6, 4, 2, 1, 2, 3, 2,
268          1, 2, 4, 6, 4, 2, 4, 8, 12, 8, 4, 6, 12, 18, 12, 6, 4, 8, 12, 8, 4, 2,
269          4, 6, 4, 2, 3, 6, 9, 6, 3, 6, 12, 18, 12, 6, 9, 18, 27, 18, 9, 6, 12,
270          18, 12, 6, 3, 6, 9, 6, 3, 2, 4, 6, 4, 2, 4, 8, 12, 8, 4, 6, 12, 18, 12,
271          6, 4, 8, 12, 8, 4, 2, 4, 6, 4, 2, 1, 2, 3, 2, 1, 2, 4, 6, 4, 2, 3, 6, 9,
272          6, 3, 2, 4, 6, 4, 2, 1, 2, 3, 2, 1.
273      ]).reshape((5, 5, 5))
274      if with_bias:
275        expected_out += 1
276      conv1 = conv_transpose.Conv3DTranspose(
277          output_channels=1,
278          output_shape=None,
279          kernel_shape=3,
280          stride=1,
281          padding="VALID",
282          with_bias=with_bias,
283          **create_constant_initializers(1.0, 1.0, with_bias))
284      out = conv1(tf.ones([1, 3, 3, 3, 1], dtype=tf.float32))
285      self.assertEqual(out.shape, [1, 5, 5, 5, 1])
286      out = tf.squeeze(out, axis=(0, 4))
287      self.assertAllClose(self.evaluate(out), expected_out)
288  if __name__ == "__main__":
289    tf.test.main()
</code></pre>
        </div>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-cmds.py</h3>
            <pre><code>1  import hashlib
2  import io
3  import os
4  import struct
5  import sys
6  import time
7  import zlib
8  from .bin_image import ELFFile, ImageSegment, LoadFirmwareImage
9  from .bin_image import (
10      ESP8266ROMFirmwareImage,
11      ESP8266V2FirmwareImage,
12      ESP8266V3FirmwareImage,
13  )
14  from .loader import (
15      DEFAULT_CONNECT_ATTEMPTS,
16      DEFAULT_TIMEOUT,
17      ERASE_WRITE_TIMEOUT_PER_MB,
18      ESPLoader,
19      timeout_per_mb,
20  )
21  from .targets import CHIP_DEFS, CHIP_LIST, ROM_LIST
22  from .util import (
23      FatalError,
24      NotImplementedInROMError,
25      NotSupportedError,
26      UnsupportedCommandError,
27  )
28  from .util import (
29      div_roundup,
30      flash_size_bytes,
31      get_file_size,
32      hexify,
33      pad_to,
34      print_overwrite,
35  )
36  DETECTED_FLASH_SIZES = {
37      0x12: "256KB",
38      0x13: "512KB",
39      0x14: "1MB",
40      0x15: "2MB",
41      0x16: "4MB",
42      0x17: "8MB",
43      0x18: "16MB",
44      0x19: "32MB",
45      0x1A: "64MB",
46      0x1B: "128MB",
47      0x1C: "256MB",
48      0x20: "64MB",
49      0x21: "128MB",
50      0x22: "256MB",
51      0x32: "256KB",
52      0x33: "512KB",
53      0x34: "1MB",
54      0x35: "2MB",
55      0x36: "4MB",
56      0x37: "8MB",
57      0x38: "16MB",
58      0x39: "32MB",
59      0x3A: "64MB",
60  }
61  FLASH_MODES = {"qio": 0, "qout": 1, "dio": 2, "dout": 3}
62  def detect_chip(
63      port=ESPLoader.DEFAULT_PORT,
64      baud=ESPLoader.ESP_ROM_BAUD,
65      connect_mode="default_reset",
66      trace_enabled=False,
67      connect_attempts=DEFAULT_CONNECT_ATTEMPTS,
68  ):
69      inst = None
70      detect_port = ESPLoader(port, baud, trace_enabled=trace_enabled)
71      if detect_port.serial_port.startswith("rfc2217:"):
72          detect_port.USES_RFC2217 = True
73      detect_port.connect(connect_mode, connect_attempts, detecting=True)
74      try:
75          print("Detecting chip type...", end="")
76          chip_id = detect_port.get_chip_id()
77          for cls in [
78              n for n in ROM_LIST if n.CHIP_NAME not in ("ESP8266", "ESP32", "ESP32S2")
79          ]:
80              if chip_id == cls.IMAGE_CHIP_ID:
81                  inst = cls(detect_port._port, baud, trace_enabled=trace_enabled)
82                  try:
83                      inst.read_reg(
84                          ESPLoader.CHIP_DETECT_MAGIC_REG_ADDR
85                      )  # Dummy read to check Secure Download mode
86                  except UnsupportedCommandError:
87                      inst.secure_download_mode = True
88                  inst._post_connect()
89                  break
90          else:
91              err_msg = f"Unexpected chip ID value {chip_id}."
92      except (UnsupportedCommandError, struct.error, FatalError) as e:
93          print(" Unsupported detection protocol, switching and trying again...")
94          try:
95              if not isinstance(e, struct.error):
96                  detect_port.connect(
97                      connect_mode, connect_attempts, detecting=True, warnings=False
98                  )
99              print("Detecting chip type...", end="")
100              sys.stdout.flush()
101              chip_magic_value = detect_port.read_reg(
102                  ESPLoader.CHIP_DETECT_MAGIC_REG_ADDR
103              )
104              for cls in ROM_LIST:
105                  if chip_magic_value in cls.CHIP_DETECT_MAGIC_VALUE:
106                      inst = cls(detect_port._port, baud, trace_enabled=trace_enabled)
107                      inst._post_connect()
108                      inst.check_chip_id()
109                      break
110              else:
111                  err_msg = f"Unexpected chip magic value {chip_magic_value:#010x}."
112          except UnsupportedCommandError:
113              raise FatalError(
114                  "Unsupported Command Error received. "
115                  "Probably this means Secure Download Mode is enabled, "
116                  "autodetection will not work. Need to manually specify the chip."
117              )
118      finally:
119          if inst is not None:
120              print(" %s" % inst.CHIP_NAME, end="")
121              if detect_port.sync_stub_detected:
122                  inst = inst.STUB_CLASS(inst)
123                  inst.sync_stub_detected = True
124              print("")  # end line
125              return inst
126      raise FatalError(
127          f"{err_msg} Failed to autodetect chip type."
128          "\nProbably it is unsupported by this version of esptool."
129      )
130  def load_ram(esp, args):
131      image = LoadFirmwareImage(esp.CHIP_NAME, args.filename)
132      print("RAM boot...")
133      for seg in image.segments:
134          size = len(seg.data)
135          print("Downloading %d bytes at %08x..." % (size, seg.addr), end=" ")
136          sys.stdout.flush()
137          esp.mem_begin(
138              size, div_roundup(size, esp.ESP_RAM_BLOCK), esp.ESP_RAM_BLOCK, seg.addr
139          )
140          seq = 0
141          while len(seg.data) > 0:
142              esp.mem_block(seg.data[0 : esp.ESP_RAM_BLOCK], seq)
143              seg.data = seg.data[esp.ESP_RAM_BLOCK :]
144              seq += 1
145          print("done!")
146      print("All segments done, executing at %08x" % image.entrypoint)
147      esp.mem_finish(image.entrypoint)
148  def read_mem(esp, args):
149      print("0x%08x = 0x%08x" % (args.address, esp.read_reg(args.address)))
150  def write_mem(esp, args):
151      esp.write_reg(args.address, args.value, args.mask, 0)
152      print("Wrote %08x, mask %08x to %08x" % (args.value, args.mask, args.address))
153  def dump_mem(esp, args):
154      with open(args.filename, "wb") as f:
155          for i in range(args.size // 4):
156              d = esp.read_reg(args.address + (i * 4))
157              f.write(struct.pack(b"<I", d))
158              if f.tell() % 1024 == 0:
159                  print_overwrite(
160                      "%d bytes read... (%d %%)" % (f.tell(), f.tell() * 100 // args.size)
161                  )
162              sys.stdout.flush()
163          print_overwrite("Read %d bytes" % f.tell(), last_line=True)
164      print("Done!")
165  def detect_flash_size(esp, args=None):
166      if esp.secure_download_mode:
167          if args is not None and args.flash_size == "detect":
168              raise FatalError(
169                  "Detecting flash size is not supported in secure download mode. "
170                  "Need to manually specify flash size."
171              )
172          else:
173              return None
174      flash_id = esp.flash_id()
175      size_id = flash_id >> 16
176      flash_size = DETECTED_FLASH_SIZES.get(size_id)
177      if args is not None and args.flash_size == "detect":
178          if flash_size is None:
179              flash_size = "4MB"
180              print(
181                  "Warning: Could not auto-detect Flash size "
182                  f"(FlashID={flash_id:#x}, SizeID={size_id:#x}), defaulting to 4MB"
183              )
184          else:
185              print("Auto-detected Flash size:", flash_size)
186          args.flash_size = flash_size
187      return flash_size
188  def _update_image_flash_params(esp, address, args, image):
189      if len(image) < 8:
190          return image  # not long enough to be a bootloader image
191      magic, _, flash_mode, flash_size_freq = struct.unpack("BBBB", image[:4])
192      if address != esp.BOOTLOADER_FLASH_OFFSET:
193          return image  # not flashing bootloader offset, so don't modify this
194      if (args.flash_mode, args.flash_freq, args.flash_size) == ("keep",) * 3:
195          return image  # all settings are 'keep', not modifying anything
196      if magic != esp.ESP_IMAGE_MAGIC:
197          print(
198              "Warning: Image file at 0x%x doesn't look like an image file, "
199              "so not changing any flash settings." % address
200          )
201          return image
202      try:
203          test_image = esp.BOOTLOADER_IMAGE(io.BytesIO(image))
204          test_image.verify()
205      except Exception:
206          print(
207              "Warning: Image file at 0x%x is not a valid %s image, "
208              "so not changing any flash settings." % (address, esp.CHIP_NAME)
209          )
210          return image
211      sha_implies_keep = args.chip != "esp8266" and image[8 + 15] == 1
212      def print_keep_warning(arg_to_keep, arg_used):
213          print(
214              "Warning: Image file at {addr} is protected with a hash checksum, "
215              "so not changing the flash {arg} setting. "
216              "Use the --flash_{arg}=keep option instead of --flash_{arg}={arg_orig} "
217              "in order to remove this warning, or use the --dont-append-digest option "
218              "for the elf2image command in order to generate an image file "
219              "without a hash checksum".format(
220                  addr=hex(address), arg=arg_to_keep, arg_orig=arg_used
221              )
222          )
223      if args.flash_mode != "keep":
224          new_flash_mode = FLASH_MODES[args.flash_mode]
225          if flash_mode != new_flash_mode and sha_implies_keep:
226              print_keep_warning("mode", args.flash_mode)
227          else:
228              flash_mode = new_flash_mode
229      flash_freq = flash_size_freq & 0x0F
230      if args.flash_freq != "keep":
231          new_flash_freq = esp.parse_flash_freq_arg(args.flash_freq)
232          if flash_freq != new_flash_freq and sha_implies_keep:
233              print_keep_warning("frequency", args.flash_freq)
234          else:
235              flash_freq = new_flash_freq
236      flash_size = flash_size_freq & 0xF0
237      if args.flash_size != "keep":
238          new_flash_size = esp.parse_flash_size_arg(args.flash_size)
239          if flash_size != new_flash_size and sha_implies_keep:
240              print_keep_warning("size", args.flash_size)
241          else:
242              flash_size = new_flash_size
243      flash_params = struct.pack(b"BB", flash_mode, flash_size + flash_freq)
244      if flash_params != image[2:4]:
245          print("Flash params set to 0x%04x" % struct.unpack(">H", flash_params))
246          image = image[0:2] + flash_params + image[4:]
247      return image
248  def write_flash(esp, args):
249      if args.compress is None and not args.no_compress:
250          args.compress = not args.no_stub
251      if not args.force and esp.CHIP_NAME != "ESP8266" and not esp.secure_download_mode:
252          if esp.get_secure_boot_enabled():
253              for address, _ in args.addr_filename:
254                  if address < 0x8000:
255                      raise FatalError(
256                          "Secure Boot detected, writing to flash regions < 0x8000 "
257                          "is disabled to protect the bootloader. "
258                          "Use --force to override, "
259                          "please use with caution, otherwise it may brick your device!"
260                      )
261          for _, argfile in args.addr_filename:
262              try:
263                  image = LoadFirmwareImage(esp.CHIP_NAME, argfile)
264              except (FatalError, struct.error, RuntimeError):
265                  continue
266              finally:
267                  argfile.seek(0)  # LoadFirmwareImage changes the file handle position
268              if image.chip_id != esp.IMAGE_CHIP_ID:
269                  raise FatalError(
270                      f"{argfile.name} is not an {esp.CHIP_NAME} image. "
271                      "Use --force to flash anyway."
272                  )
273              if image.max_rev_full == 0:  # image does not have max/min_rev_full fields
274                  use_rev_full_fields = False
275              elif image.max_rev_full == 65535:  # image has default value of max_rev_full
276                  use_rev_full_fields = True
277                  if (
278                      image.min_rev_full == 0 and image.min_rev != 0
279                  ):  # min_rev_full is not set, min_rev is used
280                      use_rev_full_fields = False
281              else:  # max_rev_full set to a version
282                  use_rev_full_fields = True
283              if use_rev_full_fields:
284                  rev = esp.get_chip_revision()
285                  if rev < image.min_rev_full or rev > image.max_rev_full:
286                      error_str = f"{argfile.name} requires chip revision in range "
287                      error_str += (
288                          f"[v{image.min_rev_full // 100}.{image.min_rev_full % 100} - "
289                      )
290                      if image.max_rev_full == 65535:
291                          error_str += "max rev not set] "
292                      else:
293                          error_str += (
294                              f"v{image.max_rev_full // 100}.{image.max_rev_full % 100}] "
295                          )
296                      error_str += f"(this chip is revision v{rev // 100}.{rev % 100})"
297                      raise FatalError(f"{error_str}. Use --force to flash anyway.")
298              else:
299                  if esp.CHIP_NAME == "ESP32-C3":
300                      rev = esp.get_minor_chip_version()
301                  else:
302                      rev = esp.get_major_chip_version()
303                  if rev < image.min_rev:
304                      raise FatalError(
305                          f"{argfile.name} requires chip revision "
306                          f"{image.min_rev} or higher (this chip is revision {rev}). "
307                          "Use --force to flash anyway."
308                      )
309      if args.encrypt or args.encrypt_files is not None:
310          do_write = True
311          if not esp.secure_download_mode:
312              if esp.get_encrypted_download_disabled():
313                  raise FatalError(
314                      "This chip has encrypt functionality "
315                      "in UART download mode disabled. "
316                      "This is the Flash Encryption configuration for Production mode "
317                      "instead of Development mode."
318                  )
319              crypt_cfg_efuse = esp.get_flash_crypt_config()
320              if crypt_cfg_efuse is not None and crypt_cfg_efuse != 0xF:
321                  print("Unexpected FLASH_CRYPT_CONFIG value: 0x%x" % (crypt_cfg_efuse))
322                  do_write = False
323              enc_key_valid = esp.is_flash_encryption_key_valid()
324              if not enc_key_valid:
325                  print("Flash encryption key is not programmed")
326                  do_write = False
327          files_to_encrypt = args.addr_filename if args.encrypt else args.encrypt_files
328          for address, argfile in files_to_encrypt:
329              if address % esp.FLASH_ENCRYPTED_WRITE_ALIGN:
330                  print(
331                      "File %s address 0x%x is not %d byte aligned, can't flash encrypted"
332                      % (argfile.name, address, esp.FLASH_ENCRYPTED_WRITE_ALIGN)
333                  )
334                  do_write = False
335          if not do_write and not args.ignore_flash_encryption_efuse_setting:
336              raise FatalError(
337                  "Can't perform encrypted flash write, "
338                  "consult Flash Encryption documentation for more information"
339              )
340      else:
341          if not args.force and esp.CHIP_NAME != "ESP8266":
342              if (
343                  esp.CHIP_NAME != "ESP32"
344                  and esp.secure_download_mode
345                  and bin(esp.get_security_info()["flash_crypt_cnt"]).count("1") & 1 != 0
346              ):
347                  raise FatalError(
348                      "WARNING: Detected flash encryption and "
349                      "secure download mode enabled.\n"
350                      "Flashing plaintext binary may brick your device! "
351                      "Use --force to override the warning."
352                  )
353              if (
354                  not esp.secure_download_mode
355                  and esp.get_encrypted_download_disabled()
356                  and esp.get_flash_encryption_enabled()
357              ):
358                  raise FatalError(
359                      "WARNING: Detected flash encryption enabled and "
360                      "download manual encrypt disabled.\n"
361                      "Flashing plaintext binary may brick your device! "
362                      "Use --force to override the warning."
363                  )
364      flash_end = flash_size_bytes(
365          detect_flash_size(esp) if args.flash_size == "keep" else args.flash_size
366      )
367      if flash_end is not None:  # Secure download mode
368          for address, argfile in args.addr_filename:
369              argfile.seek(0, os.SEEK_END)
370              if address + argfile.tell() > flash_end:
371                  raise FatalError(
372                      "File %s (length %d) at offset %d "
373                      "will not fit in %d bytes of flash. "
374                      "Use --flash_size argument, or change flashing address."
375                      % (argfile.name, argfile.tell(), address, flash_end)
376                  )
377              argfile.seek(0)
378      if args.erase_all:
379          erase_flash(esp, args)
380      else:
381          for address, argfile in args.addr_filename:
382              argfile.seek(0, os.SEEK_END)
383              write_end = address + argfile.tell()
384              argfile.seek(0)
385              bytes_over = address % esp.FLASH_SECTOR_SIZE
386              if bytes_over != 0:
387                  print(
388                      "WARNING: Flash address {:#010x} is not aligned "
389                      "to a {:#x} byte flash sector. "
390                      "{:#x} bytes before this address will be erased.".format(
391                          address, esp.FLASH_SECTOR_SIZE, bytes_over
392                      )
393                  )
394              print(
395                  "Flash will be erased from {:#010x} to {:#010x}...".format(
396                      address - bytes_over,
397                      div_roundup(write_end, esp.FLASH_SECTOR_SIZE)
398                      * esp.FLASH_SECTOR_SIZE
399                      - 1,
400                  )
401              )
402      all_files = [
403          (offs, filename, args.encrypt) for (offs, filename) in args.addr_filename
404      ]
405      if args.encrypt_files is not None:
406          encrypted_files_flag = [
407              (offs, filename, True) for (offs, filename) in args.encrypt_files
408          ]
409          all_files = sorted(all_files + encrypted_files_flag, key=lambda x: x[0])
410      for address, argfile, encrypted in all_files:
411          compress = args.compress
412          if compress and encrypted:
413              print("\nWARNING: - compress and encrypt options are mutually exclusive ")
414              print("Will flash %s uncompressed" % argfile.name)
415              compress = False
416          if args.no_stub:
417              print("Erasing flash...")
418          image = pad_to(
419              argfile.read(), esp.FLASH_ENCRYPTED_WRITE_ALIGN if encrypted else 4
420          )
421          if len(image) == 0:
422              print("WARNING: File %s is empty" % argfile.name)
423              continue
424          image = _update_image_flash_params(esp, address, args, image)
425          calcmd5 = hashlib.md5(image).hexdigest()
426          uncsize = len(image)
427          if compress:
428              uncimage = image
429              image = zlib.compress(uncimage, 9)
430              decompress = zlib.decompressobj()
431              blocks = esp.flash_defl_begin(uncsize, len(image), address)
432          else:
433              blocks = esp.flash_begin(uncsize, address, begin_rom_encrypted=encrypted)
<span onclick='openModal()' class='match'>434          argfile.seek(0)  # in case we need it again
435          seq = 0
436          bytes_sent = 0  # bytes sent on wire
437          bytes_written = 0  # bytes written to flash
438          t = time.time()
439          timeout = DEFAULT_TIMEOUT
</span>440          while len(image) > 0:
441              print_overwrite(
442                  "Writing at 0x%08x... (%d %%)"
443                  % (address + bytes_written, 100 * (seq + 1) // blocks)
444              )
445              sys.stdout.flush()
446              block = image[0 : esp.FLASH_WRITE_SIZE]
447              if compress:
448                  block_uncompressed = len(decompress.decompress(block))
449                  bytes_written += block_uncompressed
450                  block_timeout = max(
451                      DEFAULT_TIMEOUT,
452                      timeout_per_mb(ERASE_WRITE_TIMEOUT_PER_MB, block_uncompressed),
453                  )
454                  if not esp.IS_STUB:
455                      timeout = (
456                          block_timeout  # ROM code writes block to flash before ACKing
457                      )
458                  esp.flash_defl_block(block, seq, timeout=timeout)
459                  if esp.IS_STUB:
460                      timeout = block_timeout
461              else:
462                  block = block + b"\xff" * (esp.FLASH_WRITE_SIZE - len(block))
463                  if encrypted:
464                      esp.flash_encrypt_block(block, seq)
465                  else:
466                      esp.flash_block(block, seq)
467                  bytes_written += len(block)
468              bytes_sent += len(block)
469              image = image[esp.FLASH_WRITE_SIZE :]
470              seq += 1
471          if esp.IS_STUB:
472              esp.read_reg(ESPLoader.CHIP_DETECT_MAGIC_REG_ADDR, timeout=timeout)
473          t = time.time() - t
474          speed_msg = ""
475          if compress:
476              if t > 0.0:
477                  speed_msg = " (effective %.1f kbit/s)" % (uncsize / t * 8 / 1000)
478              print_overwrite(
479                  "Wrote %d bytes (%d compressed) at 0x%08x in %.1f seconds%s..."
480                  % (uncsize, bytes_sent, address, t, speed_msg),
481                  last_line=True,
482              )
483          else:
484              if t > 0.0:
485                  speed_msg = " (%.1f kbit/s)" % (bytes_written / t * 8 / 1000)
486              print_overwrite(
487                  "Wrote %d bytes at 0x%08x in %.1f seconds%s..."
488                  % (bytes_written, address, t, speed_msg),
489                  last_line=True,
490              )
491          if not encrypted and not esp.secure_download_mode:
492              try:
493                  res = esp.flash_md5sum(address, uncsize)
494                  if res != calcmd5:
495                      print("File  md5: %s" % calcmd5)
496                      print("Flash md5: %s" % res)
497                      print(
498                          "MD5 of 0xFF is %s"
499                          % (hashlib.md5(b"\xFF" * uncsize).hexdigest())
500                      )
501                      raise FatalError("MD5 of file does not match data in flash!")
502                  else:
503                      print("Hash of data verified.")
504              except NotImplementedInROMError:
505                  pass
506      print("\nLeaving...")
507      if esp.IS_STUB:
508          esp.flash_begin(0, 0)
509          last_file_encrypted = all_files[-1][2]
510          if args.compress and not last_file_encrypted:
511              esp.flash_defl_finish(False)
512          else:
513              esp.flash_finish(False)
514      if args.verify:
515          print("Verifying just-written flash...")
516          print(
517              "(This option is deprecated, "
518              "flash contents are now always read back after flashing.)"
519          )
520          if args.encrypt or args.encrypt_files is not None:
521              print("WARNING: - cannot verify encrypted files, they will be ignored")
522          if not args.encrypt:
523              verify_flash(esp, args)
524  def image_info(args):
525      def v2():
526          def get_key_from_value(dict, val):
527              for key, value in dict.items():
528                  if value == val:
529                      return key
530              return None
531          print()
532          title = "{} image header".format(args.chip.upper())
533          print(title)
534          print("=" * len(title))
535          print("Image version: {}".format(image.version))
536          print(
537              "Entry point: {:#8x}".format(image.entrypoint)
538              if image.entrypoint != 0
539              else "Entry point not set"
540          )
541          print("Segments: {}".format(len(image.segments)))
542          flash_s_bits = image.flash_size_freq & 0xF0  # high four bits
543          flash_s = get_key_from_value(image.ROM_LOADER.FLASH_SIZES, flash_s_bits)
544          print(
545              "Flash size: {}".format(flash_s)
546              if flash_s is not None
547              else "WARNING: Invalid flash size ({:#02x})".format(flash_s_bits)
548          )
549          flash_fr_bits = image.flash_size_freq & 0x0F  # low four bits
550          flash_fr = get_key_from_value(image.ROM_LOADER.FLASH_FREQUENCY, flash_fr_bits)
551          print(
552              "Flash freq: {}".format(flash_fr)
553              if flash_fr is not None
554              else "WARNING: Invalid flash frequency ({:#02x})".format(flash_fr_bits)
555          )
556          flash_mode = get_key_from_value(FLASH_MODES, image.flash_mode)
557          print(
558              "Flash mode: {}".format(flash_mode.upper())
559              if flash_mode is not None
560              else "WARNING: Invalid flash mode ({})".format(image.flash_mode)
561          )
562          if args.chip != "esp8266":
563              print()
564              title = "{} extended image header".format(args.chip.upper())
565              print(title)
566              print("=" * len(title))
567              print(
568                  f"WP pin: {image.wp_pin:#02x}",
569                  *["(disabled)"] if image.wp_pin == image.WP_PIN_DISABLED else [],
570              )
571              print(
572                  "Flash pins drive settings: "
573                  "clk_drv: {:#02x}, q_drv: {:#02x}, d_drv: {:#02x}, "
574                  "cs0_drv: {:#02x}, hd_drv: {:#02x}, wp_drv: {:#02x}".format(
575                      image.clk_drv,
576                      image.q_drv,
577                      image.d_drv,
578                      image.cs_drv,
579                      image.hd_drv,
580                      image.wp_drv,
581                  )
582              )
583              try:
584                  chip = next(
585                      chip
586                      for chip in CHIP_DEFS.values()
587                      if getattr(chip, "IMAGE_CHIP_ID", None) == image.chip_id
588                  )
589                  print(f"Chip ID: {image.chip_id} ({chip.CHIP_NAME})")
590              except StopIteration:
591                  print(f"Chip ID: {image.chip_id} (Unknown ID)")
592              print(
593                  "Minimal chip revision: "
594                  f"v{image.min_rev_full // 100}.{image.min_rev_full % 100}, "
595                  f"(legacy min_rev = {image.min_rev})"
596              )
597              print(
598                  "Maximal chip revision: "
599                  f"v{image.max_rev_full // 100}.{image.max_rev_full % 100}"
600              )
601          print()
602          title = "Segments information"
603          print(title)
604          print("=" * len(title))
605          headers_str = "{:>7}  {:>7}  {:>10}  {:>10}  {:10}"
606          print(
607              headers_str.format(
608                  "Segment", "Length", "Load addr", "File offs", "Memory types"
609              )
610          )
611          print(
612              "{}  {}  {}  {}  {}".format("-" * 7, "-" * 7, "-" * 10, "-" * 10, "-" * 12)
613          )
614          format_str = "{:7}  {:#07x}  {:#010x}  {:#010x}  {}"
615          app_desc = None
616          bootloader_desc = None
617          for idx, seg in enumerate(image.segments, start=1):
618              segs = seg.get_memory_type(image)
619              seg_name = ", ".join(segs)
620              if "DROM" in segs:  # The DROM segment starts with the esp_app_desc_t struct
621                  app_desc = seg.data[:256]
622              elif "DRAM" in segs:
623                  if len(seg.data) >= 80:
624                      bootloader_desc = seg.data[:80]
625              print(
626                  format_str.format(idx, len(seg.data), seg.addr, seg.file_offs, seg_name)
627              )
628          print()
629          title = f"{args.chip.upper()} image footer"
630          print(title)
631          print("=" * len(title))
632          calc_checksum = image.calculate_checksum()
633          print(
634              "Checksum: {:#02x} ({})".format(
635                  image.checksum,
636                  "valid"
637                  if image.checksum == calc_checksum
638                  else "invalid - calculated {:02x}".format(calc_checksum),
639              )
640          )
641          try:
642              digest_msg = "Not appended"
643              if image.append_digest:
644                  is_valid = image.stored_digest == image.calc_digest
645                  digest_msg = "{} ({})".format(
646                      hexify(image.calc_digest, uppercase=False),
647                      "valid" if is_valid else "invalid",
648                  )
649                  print("Validation hash: {}".format(digest_msg))
650          except AttributeError:
651              pass  # ESP8266 image has no append_digest field
652          if app_desc:
653              APP_DESC_STRUCT_FMT = "<II" + "8s" + "32s32s16s16s32s32s" + "80s"
654              (
655                  magic_word,
656                  secure_version,
657                  reserv1,
658                  version,
659                  project_name,
660                  time,
661                  date,
662                  idf_ver,
663                  app_elf_sha256,
664                  reserv2,
665              ) = struct.unpack(APP_DESC_STRUCT_FMT, app_desc)
666              if magic_word == 0xABCD5432:
667                  print()
668                  title = "Application information"
669                  print(title)
670                  print("=" * len(title))
671                  print(f'Project name: {project_name.decode("utf-8")}')
672                  print(f'App version: {version.decode("utf-8")}')
673                  print(f'Compile time: {date.decode("utf-8")} {time.decode("utf-8")}')
674                  print(f"ELF file SHA256: {hexify(app_elf_sha256, uppercase=False)}")
675                  print(f'ESP-IDF: {idf_ver.decode("utf-8")}')
676                  print(f"Secure version: {secure_version}")
677          elif bootloader_desc:
678              BOOTLOADER_DESC_STRUCT_FMT = "<B" + "3s" + "I32s24s" + "16s"
679              (
680                  magic_byte,
681                  reserved,
682                  version,
683                  idf_ver,
684                  date_time,
685                  reserved2,
686              ) = struct.unpack(BOOTLOADER_DESC_STRUCT_FMT, bootloader_desc)
687              if magic_byte == 80:
688                  print()
689                  title = "Bootloader information"
690                  print(title)
691                  print("=" * len(title))
692                  print(f"Bootloader version: {version}")
693                  print(f'ESP-IDF: {idf_ver.decode("utf-8")}')
694                  print(f'Compile time: {date_time.decode("utf-8")}')
695      print(f"File size: {get_file_size(args.filename)} (bytes)")
696      with open(args.filename, "rb") as f:
697          try:
698              common_header = f.read(8)
699              magic = common_header[0]
700          except IndexError:
701              raise FatalError("File is empty")
702          if magic not in [
703              ESPLoader.ESP_IMAGE_MAGIC,
704              ESP8266V2FirmwareImage.IMAGE_V2_MAGIC,
705          ]:
706              raise FatalError(
707                  "This is not a valid image "
708                  "(invalid magic number: {:#x})".format(magic)
709              )
710          if args.chip == "auto":
711              try:
712                  extended_header = f.read(16)
713                  if extended_header[-1] not in [0, 1]:
714                      raise FatalError("Append digest field not 0 or 1")
715                  chip_id = int.from_bytes(extended_header[4:5], "little")
716                  for rom in [n for n in ROM_LIST if n.CHIP_NAME != "ESP8266"]:
717                      if chip_id == rom.IMAGE_CHIP_ID:
718                          args.chip = rom.CHIP_NAME
719                          break
720                  else:
721                      raise FatalError(f"Unknown image chip ID ({chip_id})")
722              except FatalError:
723                  args.chip = "esp8266"
724              print(f"Detected image type: {args.chip.upper()}")
725      image = LoadFirmwareImage(args.chip, args.filename)
726      if args.version == "2":
727          v2()
728          return
729      print("Image version: {}".format(image.version))
730      print(
731          "Entry point: {:8x}".format(image.entrypoint)
732          if image.entrypoint != 0
733          else "Entry point not set"
734      )
735      print("{} segments".format(len(image.segments)))
736      print()
737      idx = 0
738      for seg in image.segments:
739          idx += 1
740          segs = seg.get_memory_type(image)
741          seg_name = ",".join(segs)
742          print("Segment {}: {} [{}]".format(idx, seg, seg_name))
743      calc_checksum = image.calculate_checksum()
744      print(
745          "Checksum: {:02x} ({})".format(
746              image.checksum,
747              "valid"
748              if image.checksum == calc_checksum
749              else "invalid - calculated {:02x}".format(calc_checksum),
750          )
751      )
752      try:
753          digest_msg = "Not appended"
754          if image.append_digest:
755              is_valid = image.stored_digest == image.calc_digest
756              digest_msg = "{} ({})".format(
757                  hexify(image.calc_digest, uppercase=False),
758                  "valid" if is_valid else "invalid",
759              )
760              print("Validation Hash: {}".format(digest_msg))
761      except AttributeError:
762          pass  # ESP8266 image has no append_digest field
763  def make_image(args):
764      print("Creating {} image...".format(args.chip))
765      image = ESP8266ROMFirmwareImage()
766      if len(args.segfile) == 0:
767          raise FatalError("No segments specified")
768      if len(args.segfile) != len(args.segaddr):
769          raise FatalError(
770              "Number of specified files does not match number of specified addresses"
771          )
772      for seg, addr in zip(args.segfile, args.segaddr):
773          with open(seg, "rb") as f:
774              data = f.read()
775              image.segments.append(ImageSegment(addr, data))
776      image.entrypoint = args.entrypoint
777      image.save(args.output)
778      print("Successfully created {} image.".format(args.chip))
779  def elf2image(args):
780      e = ELFFile(args.input)
781      if args.chip == "auto":  # Default to ESP8266 for backwards compatibility
782          args.chip = "esp8266"
783      print("Creating {} image...".format(args.chip))
784      if args.chip != "esp8266":
785          image = CHIP_DEFS[args.chip].BOOTLOADER_IMAGE()
786          if args.chip == "esp32" and args.secure_pad:
787              image.secure_pad = "1"
788          if args.secure_pad_v2:
789              image.secure_pad = "2"
790          image.min_rev = args.min_rev
791          image.min_rev_full = args.min_rev_full
792          image.max_rev_full = args.max_rev_full
793          image.append_digest = args.append_digest
794      elif args.version == "1":  # ESP8266
795          image = ESP8266ROMFirmwareImage()
796      elif args.version == "2":
797          image = ESP8266V2FirmwareImage()
798      else:
799          image = ESP8266V3FirmwareImage()
800      image.entrypoint = e.entrypoint
801      image.flash_mode = FLASH_MODES[args.flash_mode]
802      if args.flash_mmu_page_size:
803          image.set_mmu_page_size(flash_size_bytes(args.flash_mmu_page_size))
804      image.segments = e.segments if args.use_segments else e.sections
805      if args.pad_to_size:
806          image.pad_to_size = flash_size_bytes(args.pad_to_size)
807      image.flash_size_freq = image.ROM_LOADER.parse_flash_size_arg(args.flash_size)
808      image.flash_size_freq += image.ROM_LOADER.parse_flash_freq_arg(args.flash_freq)
809      if args.elf_sha256_offset:
810          image.elf_sha256 = e.sha256()
811          image.elf_sha256_offset = args.elf_sha256_offset
812      before = len(image.segments)
813      image.merge_adjacent_segments()
814      if len(image.segments) != before:
815          delta = before - len(image.segments)
816          print("Merged %d ELF section%s" % (delta, "s" if delta > 1 else ""))
817      image.verify()
818      if args.output is None:
819          args.output = image.default_output_name(args.input)
820      image.save(args.output)
821      print("Successfully created {} image.".format(args.chip))
822  def read_mac(esp, args):
823      mac = esp.read_mac()
824      def print_mac(label, mac):
825          print("%s: %s" % (label, ":".join(map(lambda x: "%02x" % x, mac))))
826      print_mac("MAC", mac)
827  def chip_id(esp, args):
828      try:
829          chipid = esp.chip_id()
830          print("Chip ID: 0x%08x" % chipid)
831      except NotSupportedError:
832          print("Warning: %s has no Chip ID. Reading MAC instead." % esp.CHIP_NAME)
833          read_mac(esp, args)
834  def erase_flash(esp, args):
835      if not args.force and esp.CHIP_NAME != "ESP8266" and not esp.secure_download_mode:
836          if esp.get_flash_encryption_enabled() or esp.get_secure_boot_enabled():
837              raise FatalError(
838                  "Active security features detected, "
839                  "erasing flash is disabled as a safety measure. "
840                  "Use --force to override, "
841                  "please use with caution, otherwise it may brick your device!"
842              )
843      print("Erasing flash (this may take a while)...")
844      t = time.time()
845      esp.erase_flash()
846      print("Chip erase completed successfully in %.1fs" % (time.time() - t))
847  def erase_region(esp, args):
848      if not args.force and esp.CHIP_NAME != "ESP8266" and not esp.secure_download_mode:
849          if esp.get_flash_encryption_enabled() or esp.get_secure_boot_enabled():
850              raise FatalError(
851                  "Active security features detected, "
852                  "erasing flash is disabled as a safety measure. "
853                  "Use --force to override, "
854                  "please use with caution, otherwise it may brick your device!"
855              )
856      print("Erasing region (may be slow depending on size)...")
857      t = time.time()
858      esp.erase_region(args.address, args.size)
859      print("Erase completed successfully in %.1f seconds." % (time.time() - t))
860  def run(esp, args):
861      esp.run()
862  def flash_id(esp, args):
863      flash_id = esp.flash_id()
864      print("Manufacturer: %02x" % (flash_id & 0xFF))
865      flid_lowbyte = (flash_id >> 16) & 0xFF
866      print("Device: %02x%02x" % ((flash_id >> 8) & 0xFF, flid_lowbyte))
867      print(
868          "Detected flash size: %s" % (DETECTED_FLASH_SIZES.get(flid_lowbyte, "Unknown"))
869      )
870      flash_type = esp.flash_type()
871      flash_type_dict = {0: "quad (4 data lines)", 1: "octal (8 data lines)"}
872      flash_type_str = flash_type_dict.get(flash_type)
873      if flash_type_str:
874          print(f"Flash type set in eFuse: {flash_type_str}")
875  def read_flash(esp, args):
876      if args.no_progress:
877          flash_progress = None
878      else:
879          def flash_progress(progress, length):
880              msg = "%d (%d %%)" % (progress, progress * 100.0 / length)
881              padding = "\b" * len(msg)
882              if progress == length:
883                  padding = "\n"
884              sys.stdout.write(msg + padding)
885              sys.stdout.flush()
886      t = time.time()
887      data = esp.read_flash(args.address, args.size, flash_progress)
888      t = time.time() - t
889      speed_msg = " ({:.1f} kbit/s)".format(len(data) / t * 8 / 1000) if t > 0.0 else ""
890      print_overwrite(
891          "Read {:d} bytes at {:#010x} in {:.1f} seconds{}...".format(
892              len(data), args.address, t, speed_msg
893          ),
894          last_line=True,
895      )
896      with open(args.filename, "wb") as f:
897          f.write(data)
898  def verify_flash(esp, args):
899      differences = False
900      for address, argfile in args.addr_filename:
901          image = pad_to(argfile.read(), 4)
902          argfile.seek(0)  # rewind in case we need it again
903          image = _update_image_flash_params(esp, address, args, image)
904          image_size = len(image)
905          print(
906              "Verifying 0x%x (%d) bytes @ 0x%08x in flash against %s..."
907              % (image_size, image_size, address, argfile.name)
908          )
909          digest = esp.flash_md5sum(address, image_size)
910          expected_digest = hashlib.md5(image).hexdigest()
911          if digest == expected_digest:
912              print("-- verify OK (digest matched)")
913              continue
914          else:
915              differences = True
916              if getattr(args, "diff", "no") != "yes":
917                  print("-- verify FAILED (digest mismatch)")
918                  continue
919          flash = esp.read_flash(address, image_size)
920          assert flash != image
921          diff = [i for i in range(image_size) if flash[i] != image[i]]
922          print(
923              "-- verify FAILED: %d differences, first @ 0x%08x"
924              % (len(diff), address + diff[0])
925          )
926          for d in diff:
927              flash_byte = flash[d]
928              image_byte = image[d]
929              print("   %08x %02x %02x" % (address + d, flash_byte, image_byte))
930      if differences:
931          raise FatalError("Verify failed.")
932  def read_flash_status(esp, args):
933      print("Status value: 0x%04x" % esp.read_status(args.bytes))
934  def write_flash_status(esp, args):
935      fmt = "0x%%0%dx" % (args.bytes * 2)
936      args.value = args.value & ((1 << (args.bytes * 8)) - 1)
937      print(("Initial flash status: " + fmt) % esp.read_status(args.bytes))
938      print(("Setting flash status: " + fmt) % args.value)
939      esp.write_status(args.value, args.bytes, args.non_volatile)
940      print(("After flash status:   " + fmt) % esp.read_status(args.bytes))
941  def get_security_info(esp, args):
942      si = esp.get_security_info()
943      print("Flags: {:#010x} ({})".format(si["flags"], bin(si["flags"])))
944      print("Flash_Crypt_Cnt: {:#x}".format(si["flash_crypt_cnt"]))
945      print("Key_Purposes: {}".format(si["key_purposes"]))
946      if si["chip_id"] is not None and si["api_version"] is not None:
947          print("Chip_ID: {}".format(si["chip_id"]))
948          print("Api_Version: {}".format(si["api_version"]))
949  def merge_bin(args):
950      try:
951          chip_class = CHIP_DEFS[args.chip]
952      except KeyError:
953          msg = (
954              "Please specify the chip argument"
955              if args.chip == "auto"
956              else "Invalid chip choice: '{}'".format(args.chip)
957          )
958          msg = msg + " (choose from {})".format(", ".join(CHIP_LIST))
959          raise FatalError(msg)
960      input_files = sorted(args.addr_filename, key=lambda x: x[0])
961      if not input_files:
962          raise FatalError("No input files specified")
963      first_addr = input_files[0][0]
964      if first_addr < args.target_offset:
965          raise FatalError(
966              "Output file target offset is 0x%x. Input file offset 0x%x is before this."
967              % (args.target_offset, first_addr)
968          )
969      if args.format != "raw":
970          raise FatalError(
971              "This version of esptool only supports the 'raw' output format"
972          )
973      with open(args.output, "wb") as of:
974          def pad_to(flash_offs):
975              of.write(b"\xFF" * (flash_offs - args.target_offset - of.tell()))
976          for addr, argfile in input_files:
977              pad_to(addr)
978              image = argfile.read()
979              image = _update_image_flash_params(chip_class, addr, args, image)
980              of.write(image)
981          if args.fill_flash_size:
982              pad_to(flash_size_bytes(args.fill_flash_size))
983          print(
984              "Wrote 0x%x bytes to file %s, ready to flash to offset 0x%x"
985              % (of.tell(), args.output, args.target_offset)
986          )
987  def version(args):
988      from . import __version__
989      print(__version__)
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from sonnet-MDEwOlJlcG9zaXRvcnk4NzA2NzIxMg==-flat-conv_transpose_test.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-cmds.py</div>
                </div>
                <div class="column column_space"><pre><code>37        conv_transpose.ConvNDTranspose(
38            2, output_channels=1, kernel_shape=3, with_bias=False,
39            b_init=lib_initializers.Ones(), data_format="NHWC")
</pre></code></div>
                <div class="column column_space"><pre><code>434          argfile.seek(0)  # in case we need it again
435          seq = 0
436          bytes_sent = 0  # bytes sent on wire
437          bytes_written = 0  # bytes written to flash
438          t = time.time()
439          timeout = DEFAULT_TIMEOUT
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    