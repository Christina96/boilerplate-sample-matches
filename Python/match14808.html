<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for website.py &amp; property.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for website.py &amp; property.py
      </h3>
<h1 align="center">
        1.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>website.py (4.601227%)<th>property.py (1.2531328%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(281-287)<td><a href="#" name="0">(40-46)</a><td align="center"><font color="#ff0000">15</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>website.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 def tag(key, value):
2     start = '&lt;%s&gt;' % key
3     end = '&lt;/%s&gt;' % key
4     return '%s%s%s' % (start, value, end)
5 class WebsiteConfiguration(object):
6     def __init__(self, suffix=None, error_key=None,
7                  redirect_all_requests_to=None, routing_rules=None):
8         self.suffix = suffix
9         self.error_key = error_key
10         self.redirect_all_requests_to = redirect_all_requests_to
11         if routing_rules is not None:
12             self.routing_rules = routing_rules
13         else:
14             self.routing_rules = RoutingRules()
15     def startElement(self, name, attrs, connection):
16         if name == 'RoutingRules':
17             self.routing_rules = RoutingRules()
18             return self.routing_rules
19         elif name == 'IndexDocument':
20             return _XMLKeyValue([('Suffix', 'suffix')], container=self)
21         elif name == 'ErrorDocument':
22             return _XMLKeyValue([('Key', 'error_key')], container=self)
23     def endElement(self, name, value, connection):
24         pass
25     def to_xml(self):
26         parts = ['&lt;?xml version="1.0" encoding="UTF-8"?&gt;',
27           '&lt;WebsiteConfiguration xmlns="http://s3.amazonaws.com/doc/2006-03-01/"&gt;']
28         if self.suffix is not None:
29             parts.append(tag('IndexDocument', tag('Suffix', self.suffix)))
30         if self.error_key is not None:
31             parts.append(tag('ErrorDocument', tag('Key', self.error_key)))
32         if self.redirect_all_requests_to is not None:
33             parts.append(self.redirect_all_requests_to.to_xml())
34         if self.routing_rules:
35             parts.append(self.routing_rules.to_xml())
36         parts.append('&lt;/WebsiteConfiguration&gt;')
37         return ''.join(parts)
38 class _XMLKeyValue(object):
39     def __init__(self, translator, container=None):
40         self.translator = translator
41         if container:
42             self.container = container
43         else:
44             self.container = self
45     def startElement(self, name, attrs, connection):
46         pass
47     def endElement(self, name, value, connection):
48         for xml_key, attr_name in self.translator:
49             if name == xml_key:
50                 setattr(self.container, attr_name, value)
51     def to_xml(self):
52         parts = []
53         for xml_key, attr_name in self.translator:
54             content = getattr(self.container, attr_name)
55             if content is not None:
56                 parts.append(tag(xml_key, content))
57         return ''.join(parts)
58 class RedirectLocation(_XMLKeyValue):
59     TRANSLATOR = [('HostName', 'hostname'),
60                   ('Protocol', 'protocol'),
61                  ]
62     def __init__(self, hostname=None, protocol=None):
63         self.hostname = hostname
64         self.protocol = protocol
65         super(RedirectLocation, self).__init__(self.TRANSLATOR)
66     def to_xml(self):
67         return tag('RedirectAllRequestsTo',
68             super(RedirectLocation, self).to_xml())
69 class RoutingRules(list):
70     def add_rule(self, rule):
71         self.append(rule)
72         return self
73     def startElement(self, name, attrs, connection):
74         if name == 'RoutingRule':
75             rule = RoutingRule(Condition(), Redirect())
76             self.add_rule(rule)
77             return rule
78     def endElement(self, name, value, connection):
79         pass
80     def __repr__(self):
81         return "RoutingRules(%s)" % super(RoutingRules, self).__repr__()
82     def to_xml(self):
83         inner_text = []
84         for rule in self:
85             inner_text.append(rule.to_xml())
86         return tag('RoutingRules', '\n'.join(inner_text))
87 class RoutingRule(object):
88     def __init__(self, condition=None, redirect=None):
89         self.condition = condition
90         self.redirect = redirect
91     def startElement(self, name, attrs, connection):
92         if name == 'Condition':
93             return self.condition
94         elif name == 'Redirect':
95             return self.redirect
96     def endElement(self, name, value, connection):
97         pass
98     def to_xml(self):
99         parts = []
100         if self.condition:
101             parts.append(self.condition.to_xml())
102         if self.redirect:
103             parts.append(self.redirect.to_xml())
104         return tag('RoutingRule', '\n'.join(parts))
105     @classmethod
106     def when(cls, key_prefix=None, http_error_code=None):
107         return cls(Condition(key_prefix=key_prefix,
108                              http_error_code=http_error_code), None)
109     def then_redirect(self, hostname=None, protocol=None, replace_key=None,
110                       replace_key_prefix=None, http_redirect_code=None):
111         self.redirect = Redirect(
112                 hostname=hostname, protocol=protocol,
113                 replace_key=replace_key,
114                 replace_key_prefix=replace_key_prefix,
115                 http_redirect_code=http_redirect_code)
116         return self
117 class Condition(_XMLKeyValue):
118     TRANSLATOR = [
119         ('KeyPrefixEquals', 'key_prefix'),
120         ('HttpErrorCodeReturnedEquals', 'http_error_code'),
121         ]
122     def __init__(self, key_prefix=None, http_error_code=None):
123         self.key_prefix = key_prefix
124         self.http_error_code = http_error_code
125         super(Condition, self).__init__(self.TRANSLATOR)
126     def to_xml(self):
127         return tag('Condition', super(Condition, self).to_xml())
128 class Redirect(_XMLKeyValue):
129     TRANSLATOR = [
130         ('Protocol', 'protocol'),
131         ('HostName', 'hostname'),
132         ('ReplaceKeyWith', 'replace_key'),
133         ('ReplaceKeyPrefixWith', 'replace_key_prefix'),
134         ]
135     def __init__(self, hostname<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None, protocol=None, replace_key=None,
136                  replace_key_prefix=None, http_redirect_code=None):
137         self.hostname = hostname
138         self.protocol = protocol
139         self.replace_key = replace_key
140         self.replace_key_prefix = replace_key_prefix
141         self.http_redirect_code =</b></font> http_redirect_code
142         super(Redirect, self).__init__(self.TRANSLATOR)
143     def to_xml(self):
144         return tag('Redirect', super(Redirect, self).to_xml())
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>property.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import datetime
2 from boto.sdb.db.key import Key
3 from boto.utils import Password
4 from boto.sdb.db.query import Query
5 import re
6 import boto
7 import boto.s3.key
8 from boto.sdb.db.blob import Blob
9 from boto.compat import six, long_type
10 class Property(object):
11     data_type = str
12     type_name = ''
13     verbose_name = ''
14     def __init__(self, verbose_name=None, name=None, default<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None,
15                  required=False, validator=None, choices=None, unique=False):
16         self.verbose_name = verbose_name
17         self.name = name
18         self.default = default
19         self.required = required
20         self.validator =</b></font> validator
21         self.choices = choices
22         if self.name:
23             self.slot_name = '_' + self.name
24         else:
25             self.slot_name = '_'
26         self.unique = unique
27     def __get__(self, obj, objtype):
28         if obj:
29             obj.load()
30             return getattr(obj, self.slot_name)
31         else:
32             return None
33     def __set__(self, obj, value):
34         self.validate(value)
35         try:
36             if obj._loaded and hasattr(obj, "on_set_%s" % self.name):
37                 fnc = getattr(obj, "on_set_%s" % self.name)
38                 value = fnc(value)
39         except Exception:
40             boto.log.exception("Exception running on_set_%s" % self.name)
41         setattr(obj, self.slot_name, value)
42     def __property_config__(self, model_class, property_name):
43         self.model_class = model_class
44         self.name = property_name
45         self.slot_name = '_' + self.name
46     def default_validator(self, value):
47         if isinstance(value, six.string_types) or value == self.default_value():
48             return
49         if not isinstance(value, self.data_type):
50             raise TypeError('Validation Error, %s.%s expecting %s, got %s' % (self.model_class.__name__, self.name, self.data_type, type(value)))
51     def default_value(self):
52         return self.default
53     def validate(self, value):
54         if self.required and value is None:
55             raise ValueError('%s is a required property' % self.name)
56         if self.choices and value and value not in self.choices:
57             raise ValueError('%s not a valid choice for %s.%s' % (value, self.model_class.__name__, self.name))
58         if self.validator:
59             self.validator(value)
60         else:
61             self.default_validator(value)
62         return value
63     def empty(self, value):
64         return not value
65     def get_value_for_datastore(self, model_instance):
66         return getattr(model_instance, self.name)
67     def make_value_from_datastore(self, value):
68         return value
69     def get_choices(self):
70         if callable(self.choices):
71             return self.choices()
72         return self.choices
73 def validate_string(value):
74     if value is None:
75         return
76     elif isinstance(value, six.string_types):
77         if len(value) &gt; 1024:
78             raise ValueError('Length of value greater than maxlength')
79     else:
80         raise TypeError('Expecting String, got %s' % type(value))
81 class StringProperty(Property):
82     type_name = 'String'
83     def __init__(self, verbose_name=None, name=None, default='',
84                  required=False, validator=validate_string,
85                  choices=None, unique=False):
86         super(StringProperty, self).__init__(verbose_name, name, default, required,
87                           validator, choices, unique)
88 class TextProperty(Property):
89     type_name = 'Text'
90     def __init__(self, verbose_name=None, name=None, default='',
91                  required=False, validator=None, choices=None,
92                  unique=False, max_length=None):
93         super(TextProperty, self).__init__(verbose_name, name, default, required,
94                           validator, choices, unique)
95         self.max_length = max_length
96     def validate(self, value):
97         value = super(TextProperty, self).validate(value)
98         if not isinstance(value, six.string_types):
99             raise TypeError('Expecting Text, got %s' % type(value))
100         if self.max_length and len(value) &gt; self.max_length:
101             raise ValueError('Length of value greater than maxlength %s' % self.max_length)
102 class PasswordProperty(StringProperty):
103     data_type = Password
104     type_name = 'Password'
105     def __init__(self, verbose_name=None, name=None, default='', required=False,
106                  validator=None, choices=None, unique=False, hashfunc=None):
107     And the datetime.date objects. It can return either one,
108     depending on the value stored in the database"""
109     data_type = datetime.datetime
110     type_name = 'DateTime'
111     def __init__(self, verbose_name=None, auto_now=False, auto_now_add=False, name=None,
112                  default=None, required=False, validator=None, choices=None, unique=False):
113         super(DateTimeProperty, self).__init__(verbose_name, name, default, required, validator, choices, unique)
114         self.auto_now = auto_now
115         self.auto_now_add = auto_now_add
116     def default_value(self):
117         if self.auto_now or self.auto_now_add:
118             return self.now()
119         return super(DateTimeProperty, self).default_value()
120     def validate(self, value):
121         if value is None:
122             return
123         if isinstance(value, datetime.date):
124             return value
125         return super(DateTimeProperty, self).validate(value)
126     def get_value_for_datastore(self, model_instance):
127         if self.auto_now:
128             setattr(model_instance, self.name, self.now())
129         return super(DateTimeProperty, self).get_value_for_datastore(model_instance)
130     def now(self):
131         return datetime.datetime.utcnow()
132 class DateProperty(Property):
133     data_type = datetime.date
134     type_name = 'Date'
135     def __init__(self, verbose_name=None, auto_now=False, auto_now_add=False, name=None,
136                  default=None, required=False, validator=None, choices=None, unique=False):
137         super(DateProperty, self).__init__(verbose_name, name, default, required, validator, choices, unique)
138         self.auto_now = auto_now
139         self.auto_now_add = auto_now_add
140     def default_value(self):
141         if self.auto_now or self.auto_now_add:
142             return self.now()
143         return super(DateProperty, self).default_value()
144     def validate(self, value):
145         value = super(DateProperty, self).validate(value)
146         if value is None:
147             return
148         if not isinstance(value, self.data_type):
149             raise TypeError('Validation Error, expecting %s, got %s' % (self.data_type, type(value)))
150     def get_value_for_datastore(self, model_instance):
151         if self.auto_now:
152             setattr(model_instance, self.name, self.now())
153         val = super(DateProperty, self).get_value_for_datastore(model_instance)
154         if isinstance(val, datetime.datetime):
155             val = val.date()
156         return val
157     def now(self):
158         return datetime.date.today()
159 class TimeProperty(Property):
160     data_type = datetime.time
161     type_name = 'Time'
162     def __init__(self, verbose_name=None, name=None,
163                  default=None, required=False, validator=None, choices=None, unique=False):
164         super(TimeProperty, self).__init__(verbose_name, name, default, required, validator, choices, unique)
165     def validate(self, value):
166         value = super(TimeProperty, self).validate(value)
167         if value is None:
168             return
169         if not isinstance(value, self.data_type):
170             raise TypeError('Validation Error, expecting %s, got %s' % (self.data_type, type(value)))
171 class ReferenceProperty(Property):
172     data_type = Key
173     type_name = 'Reference'
174     def __init__(self, reference_class=None, collection_name=None,
175                  verbose_name=None, name=None, default=None, required=False, validator=None, choices=None, unique=False):
176         super(ReferenceProperty, self).__init__(verbose_name, name, default, required, validator, choices, unique)
177         self.reference_class = reference_class
178         self.collection_name = collection_name
179     def __get__(self, obj, objtype):
180         if obj:
181             value = getattr(obj, self.slot_name)
182             if value == self.default_value():
183                 return value
184             if isinstance(value, six.string_types):
185                 value = self.reference_class(value)
186                 setattr(obj, self.name, value)
187             return value
188     def __set__(self, obj, value):
189         """Don't allow this object to be associated to itself
190         This causes bad things to happen"""
191         if value is not None and (obj.id == value or (hasattr(value, "id") and obj.id == value.id)):
192             raise ValueError("Can not associate an object with itself!")
193         return super(ReferenceProperty, self).__set__(obj, value)
194     def __property_config__(self, model_class, property_name):
195         super(ReferenceProperty, self).__property_config__(model_class, property_name)
196         if self.collection_name is None:
197             self.collection_name = '%s_%s_set' % (model_class.__name__.lower(), self.name)
198         if hasattr(self.reference_class, self.collection_name):
199             raise ValueError('duplicate property: %s' % self.collection_name)
200         setattr(self.reference_class, self.collection_name,
201                 _ReverseReferenceProperty(model_class, property_name, self.collection_name))
202     def check_uuid(self, value):
203         t = value.split('-')
204         if len(t) != 5:
205             raise ValueError
206     def check_instance(self, value):
207         try:
208             obj_lineage = value.get_lineage()
209             cls_lineage = self.reference_class.get_lineage()
210             if obj_lineage.startswith(cls_lineage):
211                 return
212             raise TypeError('%s not instance of %s' % (obj_lineage, cls_lineage))
213         except:
214             raise ValueError('%s is not a Model' % value)
215     def validate(self, value):
216         if self.validator:
217             self.validator(value)
218         if self.required and value is None:
219             raise ValueError('%s is a required property' % self.name)
220         if value == self.default_value():
221             return
222         if not isinstance(value, six.string_types):
223             self.check_instance(value)
224 class _ReverseReferenceProperty(Property):
225     data_type = Query
226     type_name = 'query'
227     def __init__(self, model, prop, name):
228         self.__model = model
229         self.__property = prop
230         self.collection_name = prop
231         self.name = name
232         self.item_type = model
233     def __get__(self, model_instance, model_class):
234         if model_instance is not None:
235             query = Query(self.__model)
236             if isinstance(self.__property, list):
237                 props = []
238                 for prop in self.__property:
239                     props.append("%s =" % prop)
240                 return query.filter(props, model_instance)
241             else:
242                 return query.filter(self.__property + ' =', model_instance)
243         else:
244             return self
245     def __set__(self, model_instance, value):
246         raise ValueError('Virtual property is read-only')
247 class CalculatedProperty(Property):
248     def __init__(self, verbose_name=None, name=None, default=None,
249                  required=False, validator=None, choices=None,
250                  calculated_type=int, unique=False, use_method=False):
251         super(CalculatedProperty, self).__init__(verbose_name, name, default, required,
252                           validator, choices, unique)
253         self.calculated_type = calculated_type
254         self.use_method = use_method
255     def __get__(self, obj, objtype):
256         value = self.default_value()
257         if obj:
258             try:
259                 value = getattr(obj, self.slot_name)
260                 if self.use_method:
261                     value = value()
262             except AttributeError:
263                 pass
264         return value
265     def __set__(self, obj, value):
266         pass
267     def _set_direct(self, obj, value):
268         if not self.use_method:
269             setattr(obj, self.slot_name, value)
270     def get_value_for_datastore(self, model_instance):
271         if self.calculated_type in [str, int, bool]:
272             value = self.__get__(model_instance, model_instance.__class__)
273             return value
274         else:
275             return None
276 class ListProperty(Property):
277     data_type = list
278     type_name = 'List'
279     def __init__(self, item_type, verbose_name=None, name=None, default=None, **kwds):
280         if default is None:
281             default = []
282         self.item_type = item_type
283         super(ListProperty, self).__init__(verbose_name, name, default=default, required=True, **kwds)
284     def validate(self, value):
285         if self.validator:
286             self.validator(value)
287         if value is not None:
288             if not isinstance(value, list):
289                 value = [value]
290         if self.item_type in six.integer_types:
291             item_type = six.integer_types
292         elif self.item_type in six.string_types:
293             item_type = six.string_types
294         else:
295             item_type = self.item_type
296         for item in value:
297             if not isinstance(item, item_type):
298                 if item_type == six.integer_types:
299                     raise ValueError('Items in the %s list must all be integers.' % self.name)
300                 else:
301                     raise ValueError('Items in the %s list must all be %s instances' %
302                                      (self.name, self.item_type.__name__))
303         return value
304     def empty(self, value):
305         return value is None
306     def default_value(self):
307         return list(super(ListProperty, self).default_value())
308     def __set__(self, obj, value):
309         if self.item_type in six.integer_types:
310             item_type = six.integer_types
311         elif self.item_type in six.string_types:
312             item_type = six.string_types
313         else:
314             item_type = self.item_type
315         if isinstance(value, item_type):
316             value = [value]
317         elif value is None:  # Override to allow them to set this to "None" to remove everything
318             value = []
319         return super(ListProperty, self).__set__(obj, value)
320 class MapProperty(Property):
321     data_type = dict
322     type_name = 'Map'
323     def __init__(self, item_type=str, verbose_name=None, name=None, default=None, **kwds):
324         if default is None:
325             default = {}
326         self.item_type = item_type
327         super(MapProperty, self).__init__(verbose_name, name, default=default, required=True, **kwds)
328     def validate(self, value):
329         value = super(MapProperty, self).validate(value)
330         if value is not None:
331             if not isinstance(value, dict):
332                 raise ValueError('Value must of type dict')
333         if self.item_type in six.integer_types:
334             item_type = six.integer_types
335         elif self.item_type in six.string_types:
336             item_type = six.string_types
337         else:
338             item_type = self.item_type
339         for key in value:
340             if not isinstance(value[key], item_type):
341                 if item_type == six.integer_types:
342                     raise ValueError('Values in the %s Map must all be integers.' % self.name)
343                 else:
344                     raise ValueError('Values in the %s Map must all be %s instances' %
345                                      (self.name, self.item_type.__name__))
346         return value
347     def empty(self, value):
348         return value is None
349     def default_value(self):
350         return {}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
