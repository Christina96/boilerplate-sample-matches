<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for website.py &amp; property.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for website.py &amp; property.py
      </h3>
<h1 align="center">
        1.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>website.py (4.601227%)<th>property.py (1.2531328%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(281-287)<td><a href="#" name="0">(40-46)</a><td align="center"><font color="#ff0000">15</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>website.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
def tag(key, value):
    start = '&lt;%s&gt;' % key
    end = '&lt;/%s&gt;' % key
    return '%s%s%s' % (start, value, end)
class WebsiteConfiguration(object):
    """
    Website configuration for a bucket.
    :ivar suffix: Suffix that is appended to a request that is for a
        "directory" on the website endpoint (e.g. if the suffix is
        index.html and you make a request to samplebucket/images/
        the data that is returned will be for the object with the
        key name images/index.html).  The suffix must not be empty
        and must not include a slash character.
    :ivar error_key: The object key name to use when a 4xx class error
        occurs.  This key identifies the page that is returned when
        such an error occurs.
    :ivar redirect_all_requests_to: Describes the redirect behavior for every
        request to this bucket's website endpoint. If this value is non None,
        no other values are considered when configuring the website
        configuration for the bucket. This is an instance of
        ``RedirectLocation``.
    :ivar routing_rules: ``RoutingRules`` object which specifies conditions
        and redirects that apply when the conditions are met.
    """
    def __init__(self, suffix=None, error_key=None,
                 redirect_all_requests_to=None, routing_rules=None):
        self.suffix = suffix
        self.error_key = error_key
        self.redirect_all_requests_to = redirect_all_requests_to
        if routing_rules is not None:
            self.routing_rules = routing_rules
        else:
            self.routing_rules = RoutingRules()
    def startElement(self, name, attrs, connection):
        if name == 'RoutingRules':
            self.routing_rules = RoutingRules()
            return self.routing_rules
        elif name == 'IndexDocument':
            return _XMLKeyValue([('Suffix', 'suffix')], container=self)
        elif name == 'ErrorDocument':
            return _XMLKeyValue([('Key', 'error_key')], container=self)
    def endElement(self, name, value, connection):
        pass
    def to_xml(self):
        parts = ['&lt;?xml version="1.0" encoding="UTF-8"?&gt;',
          '&lt;WebsiteConfiguration xmlns="http://s3.amazonaws.com/doc/2006-03-01/"&gt;']
        if self.suffix is not None:
            parts.append(tag('IndexDocument', tag('Suffix', self.suffix)))
        if self.error_key is not None:
            parts.append(tag('ErrorDocument', tag('Key', self.error_key)))
        if self.redirect_all_requests_to is not None:
            parts.append(self.redirect_all_requests_to.to_xml())
        if self.routing_rules:
            parts.append(self.routing_rules.to_xml())
        parts.append('&lt;/WebsiteConfiguration&gt;')
        return ''.join(parts)
class _XMLKeyValue(object):
    def __init__(self, translator, container=None):
        self.translator = translator
        if container:
            self.container = container
        else:
            self.container = self
    def startElement(self, name, attrs, connection):
        pass
    def endElement(self, name, value, connection):
        for xml_key, attr_name in self.translator:
            if name == xml_key:
                setattr(self.container, attr_name, value)
    def to_xml(self):
        parts = []
        for xml_key, attr_name in self.translator:
            content = getattr(self.container, attr_name)
            if content is not None:
                parts.append(tag(xml_key, content))
        return ''.join(parts)
class RedirectLocation(_XMLKeyValue):
    """Specify redirect behavior for every request to a bucket's endpoint.
    :ivar hostname: Name of the host where requests will be redirected.
    :ivar protocol: Protocol to use (http, https) when redirecting requests.
        The default is the protocol that is used in the original request.
    """
    TRANSLATOR = [('HostName', 'hostname'),
                  ('Protocol', 'protocol'),
                 ]
    def __init__(self, hostname=None, protocol=None):
        self.hostname = hostname
        self.protocol = protocol
        super(RedirectLocation, self).__init__(self.TRANSLATOR)
    def to_xml(self):
        return tag('RedirectAllRequestsTo',
            super(RedirectLocation, self).to_xml())
class RoutingRules(list):
    def add_rule(self, rule):
        """
        :type rule: :class:`boto.s3.website.RoutingRule`
        :param rule: A routing rule.
        :return: This ``RoutingRules`` object is returned,
            so that it can chain subsequent calls.
        """
        self.append(rule)
        return self
    def startElement(self, name, attrs, connection):
        if name == 'RoutingRule':
            rule = RoutingRule(Condition(), Redirect())
            self.add_rule(rule)
            return rule
    def endElement(self, name, value, connection):
        pass
    def __repr__(self):
        return "RoutingRules(%s)" % super(RoutingRules, self).__repr__()
    def to_xml(self):
        inner_text = []
        for rule in self:
            inner_text.append(rule.to_xml())
        return tag('RoutingRules', '\n'.join(inner_text))
class RoutingRule(object):
    """Represents a single routing rule.
    There are convenience methods to making creating rules
    more concise::
        rule = RoutingRule.when(key_prefix='foo/').then_redirect('example.com')
    :ivar condition: Describes condition that must be met for the
        specified redirect to apply.
    :ivar redirect: Specifies redirect behavior.  You can redirect requests to
        another host, to another page, or with another protocol. In the event
        of an error, you can can specify a different error code to return.
    """
    def __init__(self, condition=None, redirect=None):
        self.condition = condition
        self.redirect = redirect
    def startElement(self, name, attrs, connection):
        if name == 'Condition':
            return self.condition
        elif name == 'Redirect':
            return self.redirect
    def endElement(self, name, value, connection):
        pass
    def to_xml(self):
        parts = []
        if self.condition:
            parts.append(self.condition.to_xml())
        if self.redirect:
            parts.append(self.redirect.to_xml())
        return tag('RoutingRule', '\n'.join(parts))
    @classmethod
    def when(cls, key_prefix=None, http_error_code=None):
        return cls(Condition(key_prefix=key_prefix,
                             http_error_code=http_error_code), None)
    def then_redirect(self, hostname=None, protocol=None, replace_key=None,
                      replace_key_prefix=None, http_redirect_code=None):
        self.redirect = Redirect(
                hostname=hostname, protocol=protocol,
                replace_key=replace_key,
                replace_key_prefix=replace_key_prefix,
                http_redirect_code=http_redirect_code)
        return self
class Condition(_XMLKeyValue):
    """
    :ivar key_prefix: The object key name prefix when the redirect is applied.
        For example, to redirect requests for ExamplePage.html, the key prefix
        will be ExamplePage.html. To redirect request for all pages with the
        prefix docs/, the key prefix will be /docs, which identifies all
        objects in the docs/ folder.
    :ivar http_error_code: The HTTP error code when the redirect is applied. In
        the event of an error, if the error code equals this value, then the
        specified redirect is applied.
    """
    TRANSLATOR = [
        ('KeyPrefixEquals', 'key_prefix'),
        ('HttpErrorCodeReturnedEquals', 'http_error_code'),
        ]
    def __init__(self, key_prefix=None, http_error_code=None):
        self.key_prefix = key_prefix
        self.http_error_code = http_error_code
        super(Condition, self).__init__(self.TRANSLATOR)
    def to_xml(self):
        return tag('Condition', super(Condition, self).to_xml())
class Redirect(_XMLKeyValue):
    """
    :ivar hostname: The host name to use in the redirect request.
    :ivar protocol: The protocol to use in the redirect request.  Can be either
    'http' or 'https'.
    :ivar replace_key: The specific object key to use in the redirect request.
        For example, redirect request to error.html.
    :ivar replace_key_prefix: The object key prefix to use in the redirect
        request. For example, to redirect requests for all pages with prefix
        docs/ (objects in the docs/ folder) to documents/, you can set a
        condition block with KeyPrefixEquals set to docs/ and in the Redirect
        set ReplaceKeyPrefixWith to /documents.
    :ivar http_redirect_code: The HTTP redirect code to use on the response.
    """
    TRANSLATOR = [
        ('Protocol', 'protocol'),
        ('HostName', 'hostname'),
        ('ReplaceKeyWith', 'replace_key'),
        ('ReplaceKeyPrefixWith', 'replace_key_prefix'),
        ]
    def __init__(self, hostname<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None, protocol=None, replace_key=None,
                 replace_key_prefix=None, http_redirect_code=None):
        self.hostname = hostname
        self.protocol = protocol
        self.replace_key = replace_key
        self.replace_key_prefix = replace_key_prefix
        self.http_redirect_code =</b></font> http_redirect_code
        super(Redirect, self).__init__(self.TRANSLATOR)
    def to_xml(self):
        return tag('Redirect', super(Redirect, self).to_xml())
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>property.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import datetime
from boto.sdb.db.key import Key
from boto.utils import Password
from boto.sdb.db.query import Query
import re
import boto
import boto.s3.key
from boto.sdb.db.blob import Blob
from boto.compat import six, long_type
class Property(object):
    data_type = str
    type_name = ''
    verbose_name = ''
    def __init__(self, verbose_name=None, name=None, default<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None,
                 required=False, validator=None, choices=None, unique=False):
        self.verbose_name = verbose_name
        self.name = name
        self.default = default
        self.required = required
        self.validator =</b></font> validator
        self.choices = choices
        if self.name:
            self.slot_name = '_' + self.name
        else:
            self.slot_name = '_'
        self.unique = unique
    def __get__(self, obj, objtype):
        if obj:
            obj.load()
            return getattr(obj, self.slot_name)
        else:
            return None
    def __set__(self, obj, value):
        self.validate(value)
        try:
            if obj._loaded and hasattr(obj, "on_set_%s" % self.name):
                fnc = getattr(obj, "on_set_%s" % self.name)
                value = fnc(value)
        except Exception:
            boto.log.exception("Exception running on_set_%s" % self.name)
        setattr(obj, self.slot_name, value)
    def __property_config__(self, model_class, property_name):
        self.model_class = model_class
        self.name = property_name
        self.slot_name = '_' + self.name
    def default_validator(self, value):
        if isinstance(value, six.string_types) or value == self.default_value():
            return
        if not isinstance(value, self.data_type):
            raise TypeError('Validation Error, %s.%s expecting %s, got %s' % (self.model_class.__name__, self.name, self.data_type, type(value)))
    def default_value(self):
        return self.default
    def validate(self, value):
        if self.required and value is None:
            raise ValueError('%s is a required property' % self.name)
        if self.choices and value and value not in self.choices:
            raise ValueError('%s not a valid choice for %s.%s' % (value, self.model_class.__name__, self.name))
        if self.validator:
            self.validator(value)
        else:
            self.default_validator(value)
        return value
    def empty(self, value):
        return not value
    def get_value_for_datastore(self, model_instance):
        return getattr(model_instance, self.name)
    def make_value_from_datastore(self, value):
        return value
    def get_choices(self):
        if callable(self.choices):
            return self.choices()
        return self.choices
def validate_string(value):
    if value is None:
        return
    elif isinstance(value, six.string_types):
        if len(value) &gt; 1024:
            raise ValueError('Length of value greater than maxlength')
    else:
        raise TypeError('Expecting String, got %s' % type(value))
class StringProperty(Property):
    type_name = 'String'
    def __init__(self, verbose_name=None, name=None, default='',
                 required=False, validator=validate_string,
                 choices=None, unique=False):
        super(StringProperty, self).__init__(verbose_name, name, default, required,
                          validator, choices, unique)
class TextProperty(Property):
    type_name = 'Text'
    def __init__(self, verbose_name=None, name=None, default='',
                 required=False, validator=None, choices=None,
                 unique=False, max_length=None):
        super(TextProperty, self).__init__(verbose_name, name, default, required,
                          validator, choices, unique)
        self.max_length = max_length
    def validate(self, value):
        value = super(TextProperty, self).validate(value)
        if not isinstance(value, six.string_types):
            raise TypeError('Expecting Text, got %s' % type(value))
        if self.max_length and len(value) &gt; self.max_length:
            raise ValueError('Length of value greater than maxlength %s' % self.max_length)
class PasswordProperty(StringProperty):
    """
    Hashed property whose original value can not be
    retrieved, but still can be compared.
    Works by storing a hash of the original value instead
    of the original value.  Once that's done all that
    can be retrieved is the hash.
    The comparison
       obj.password == 'foo'
    generates a hash of 'foo' and compares it to the
    stored hash.
    Underlying data type for hashing, storing, and comparing
    is boto.utils.Password.  The default hash function is
    defined there ( currently sha512 in most cases, md5
    where sha512 is not available )
    It's unlikely you'll ever need to use a different hash
    function, but if you do, you can control the behavior
    in one of two ways:
      1) Specifying hashfunc in PasswordProperty constructor
         import hashlib
         class MyModel(model):
             password = PasswordProperty(hashfunc=hashlib.sha224)
      2) Subclassing Password and PasswordProperty
         class SHA224Password(Password):
             hashfunc=hashlib.sha224
         class SHA224PasswordProperty(PasswordProperty):
             data_type=MyPassword
             type_name="MyPassword"
         class MyModel(Model):
             password = SHA224PasswordProperty()
    """
    data_type = Password
    type_name = 'Password'
    def __init__(self, verbose_name=None, name=None, default='', required=False,
                 validator=None, choices=None, unique=False, hashfunc=None):
        """
           The hashfunc parameter overrides the default hashfunc in boto.utils.Password.
           The remaining parameters are passed through to StringProperty.__init__"""
        super(PasswordProperty, self).__init__(verbose_name, name, default, required,
                                validator, choices, unique)
        self.hashfunc = hashfunc
    def make_value_from_datastore(self, value):
        p = self.data_type(value, hashfunc=self.hashfunc)
        return p
    def get_value_for_datastore(self, model_instance):
        value = super(PasswordProperty, self).get_value_for_datastore(model_instance)
        if value and len(value):
            return str(value)
        else:
            return None
    def __set__(self, obj, value):
        if not isinstance(value, self.data_type):
            p = self.data_type(hashfunc=self.hashfunc)
            p.set(value)
            value = p
        super(PasswordProperty, self).__set__(obj, value)
    def __get__(self, obj, objtype):
        return self.data_type(super(PasswordProperty, self).__get__(obj, objtype), hashfunc=self.hashfunc)
    def validate(self, value):
        value = super(PasswordProperty, self).validate(value)
        if isinstance(value, self.data_type):
            if len(value) &gt; 1024:
                raise ValueError('Length of value greater than maxlength')
        else:
            raise TypeError('Expecting %s, got %s' % (type(self.data_type), type(value)))
class BlobProperty(Property):
    data_type = Blob
    type_name = "blob"
    def __set__(self, obj, value):
        if value != self.default_value():
            if not isinstance(value, Blob):
                oldb = self.__get__(obj, type(obj))
                id = None
                if oldb:
                    id = oldb.id
                b = Blob(value=value, id=id)
                value = b
        super(BlobProperty, self).__set__(obj, value)
class S3KeyProperty(Property):
    data_type = boto.s3.key.Key
    type_name = 'S3Key'
    validate_regex = "^s3:\/\/([^\/]*)\/(.*)$"
    def __init__(self, verbose_name=None, name=None, default=None,
                 required=False, validator=None, choices=None, unique=False):
        super(S3KeyProperty, self).__init__(verbose_name, name, default, required,
                          validator, choices, unique)
    def validate(self, value):
        value = super(S3KeyProperty, self).validate(value)
        if value == self.default_value() or value == str(self.default_value()):
            return self.default_value()
        if isinstance(value, self.data_type):
            return
        match = re.match(self.validate_regex, value)
        if match:
            return
        raise TypeError('Validation Error, expecting %s, got %s' % (self.data_type, type(value)))
    def __get__(self, obj, objtype):
        value = super(S3KeyProperty, self).__get__(obj, objtype)
        if value:
            if isinstance(value, self.data_type):
                return value
            match = re.match(self.validate_regex, value)
            if match:
                s3 = obj._manager.get_s3_connection()
                bucket = s3.get_bucket(match.group(1), validate=False)
                k = bucket.get_key(match.group(2))
                if not k:
                    k = bucket.new_key(match.group(2))
                    k.set_contents_from_string("")
                return k
        else:
            return value
    def get_value_for_datastore(self, model_instance):
        value = super(S3KeyProperty, self).get_value_for_datastore(model_instance)
        if value:
            return "s3://%s/%s" % (value.bucket.name, value.name)
        else:
            return None
class IntegerProperty(Property):
    data_type = int
    type_name = 'Integer'
    def __init__(self, verbose_name=None, name=None, default=0, required=False,
                 validator=None, choices=None, unique=False, max=2147483647, min=-2147483648):
        super(IntegerProperty, self).__init__(verbose_name, name, default, required, validator, choices, unique)
        self.max = max
        self.min = min
    def validate(self, value):
        value = int(value)
        value = super(IntegerProperty, self).validate(value)
        if value &gt; self.max:
            raise ValueError('Maximum value is %d' % self.max)
        if value &lt; self.min:
            raise ValueError('Minimum value is %d' % self.min)
        return value
    def empty(self, value):
        return value is None
    def __set__(self, obj, value):
        if value == "" or value is None:
            value = 0
        return super(IntegerProperty, self).__set__(obj, value)
class LongProperty(Property):
    data_type = long_type
    type_name = 'Long'
    def __init__(self, verbose_name=None, name=None, default=0, required=False,
                 validator=None, choices=None, unique=False):
        super(LongProperty, self).__init__(verbose_name, name, default, required, validator, choices, unique)
    def validate(self, value):
        value = long_type(value)
        value = super(LongProperty, self).validate(value)
        min = -9223372036854775808
        max = 9223372036854775807
        if value &gt; max:
            raise ValueError('Maximum value is %d' % max)
        if value &lt; min:
            raise ValueError('Minimum value is %d' % min)
        return value
    def empty(self, value):
        return value is None
class BooleanProperty(Property):
    data_type = bool
    type_name = 'Boolean'
    def __init__(self, verbose_name=None, name=None, default=False, required=False,
                 validator=None, choices=None, unique=False):
        super(BooleanProperty, self).__init__(verbose_name, name, default, required, validator, choices, unique)
    def empty(self, value):
        return value is None
class FloatProperty(Property):
    data_type = float
    type_name = 'Float'
    def __init__(self, verbose_name=None, name=None, default=0.0, required=False,
                 validator=None, choices=None, unique=False):
        super(FloatProperty, self).__init__(verbose_name, name, default, required, validator, choices, unique)
    def validate(self, value):
        value = float(value)
        value = super(FloatProperty, self).validate(value)
        return value
    def empty(self, value):
        return value is None
class DateTimeProperty(Property):
    """This class handles both the datetime.datetime object
    And the datetime.date objects. It can return either one,
    depending on the value stored in the database"""
    data_type = datetime.datetime
    type_name = 'DateTime'
    def __init__(self, verbose_name=None, auto_now=False, auto_now_add=False, name=None,
                 default=None, required=False, validator=None, choices=None, unique=False):
        super(DateTimeProperty, self).__init__(verbose_name, name, default, required, validator, choices, unique)
        self.auto_now = auto_now
        self.auto_now_add = auto_now_add
    def default_value(self):
        if self.auto_now or self.auto_now_add:
            return self.now()
        return super(DateTimeProperty, self).default_value()
    def validate(self, value):
        if value is None:
            return
        if isinstance(value, datetime.date):
            return value
        return super(DateTimeProperty, self).validate(value)
    def get_value_for_datastore(self, model_instance):
        if self.auto_now:
            setattr(model_instance, self.name, self.now())
        return super(DateTimeProperty, self).get_value_for_datastore(model_instance)
    def now(self):
        return datetime.datetime.utcnow()
class DateProperty(Property):
    data_type = datetime.date
    type_name = 'Date'
    def __init__(self, verbose_name=None, auto_now=False, auto_now_add=False, name=None,
                 default=None, required=False, validator=None, choices=None, unique=False):
        super(DateProperty, self).__init__(verbose_name, name, default, required, validator, choices, unique)
        self.auto_now = auto_now
        self.auto_now_add = auto_now_add
    def default_value(self):
        if self.auto_now or self.auto_now_add:
            return self.now()
        return super(DateProperty, self).default_value()
    def validate(self, value):
        value = super(DateProperty, self).validate(value)
        if value is None:
            return
        if not isinstance(value, self.data_type):
            raise TypeError('Validation Error, expecting %s, got %s' % (self.data_type, type(value)))
    def get_value_for_datastore(self, model_instance):
        if self.auto_now:
            setattr(model_instance, self.name, self.now())
        val = super(DateProperty, self).get_value_for_datastore(model_instance)
        if isinstance(val, datetime.datetime):
            val = val.date()
        return val
    def now(self):
        return datetime.date.today()
class TimeProperty(Property):
    data_type = datetime.time
    type_name = 'Time'
    def __init__(self, verbose_name=None, name=None,
                 default=None, required=False, validator=None, choices=None, unique=False):
        super(TimeProperty, self).__init__(verbose_name, name, default, required, validator, choices, unique)
    def validate(self, value):
        value = super(TimeProperty, self).validate(value)
        if value is None:
            return
        if not isinstance(value, self.data_type):
            raise TypeError('Validation Error, expecting %s, got %s' % (self.data_type, type(value)))
class ReferenceProperty(Property):
    data_type = Key
    type_name = 'Reference'
    def __init__(self, reference_class=None, collection_name=None,
                 verbose_name=None, name=None, default=None, required=False, validator=None, choices=None, unique=False):
        super(ReferenceProperty, self).__init__(verbose_name, name, default, required, validator, choices, unique)
        self.reference_class = reference_class
        self.collection_name = collection_name
    def __get__(self, obj, objtype):
        if obj:
            value = getattr(obj, self.slot_name)
            if value == self.default_value():
                return value
            if isinstance(value, six.string_types):
                value = self.reference_class(value)
                setattr(obj, self.name, value)
            return value
    def __set__(self, obj, value):
        """Don't allow this object to be associated to itself
        This causes bad things to happen"""
        if value is not None and (obj.id == value or (hasattr(value, "id") and obj.id == value.id)):
            raise ValueError("Can not associate an object with itself!")
        return super(ReferenceProperty, self).__set__(obj, value)
    def __property_config__(self, model_class, property_name):
        super(ReferenceProperty, self).__property_config__(model_class, property_name)
        if self.collection_name is None:
            self.collection_name = '%s_%s_set' % (model_class.__name__.lower(), self.name)
        if hasattr(self.reference_class, self.collection_name):
            raise ValueError('duplicate property: %s' % self.collection_name)
        setattr(self.reference_class, self.collection_name,
                _ReverseReferenceProperty(model_class, property_name, self.collection_name))
    def check_uuid(self, value):
        t = value.split('-')
        if len(t) != 5:
            raise ValueError
    def check_instance(self, value):
        try:
            obj_lineage = value.get_lineage()
            cls_lineage = self.reference_class.get_lineage()
            if obj_lineage.startswith(cls_lineage):
                return
            raise TypeError('%s not instance of %s' % (obj_lineage, cls_lineage))
        except:
            raise ValueError('%s is not a Model' % value)
    def validate(self, value):
        if self.validator:
            self.validator(value)
        if self.required and value is None:
            raise ValueError('%s is a required property' % self.name)
        if value == self.default_value():
            return
        if not isinstance(value, six.string_types):
            self.check_instance(value)
class _ReverseReferenceProperty(Property):
    data_type = Query
    type_name = 'query'
    def __init__(self, model, prop, name):
        self.__model = model
        self.__property = prop
        self.collection_name = prop
        self.name = name
        self.item_type = model
    def __get__(self, model_instance, model_class):
        if model_instance is not None:
            query = Query(self.__model)
            if isinstance(self.__property, list):
                props = []
                for prop in self.__property:
                    props.append("%s =" % prop)
                return query.filter(props, model_instance)
            else:
                return query.filter(self.__property + ' =', model_instance)
        else:
            return self
    def __set__(self, model_instance, value):
        raise ValueError('Virtual property is read-only')
class CalculatedProperty(Property):
    def __init__(self, verbose_name=None, name=None, default=None,
                 required=False, validator=None, choices=None,
                 calculated_type=int, unique=False, use_method=False):
        super(CalculatedProperty, self).__init__(verbose_name, name, default, required,
                          validator, choices, unique)
        self.calculated_type = calculated_type
        self.use_method = use_method
    def __get__(self, obj, objtype):
        value = self.default_value()
        if obj:
            try:
                value = getattr(obj, self.slot_name)
                if self.use_method:
                    value = value()
            except AttributeError:
                pass
        return value
    def __set__(self, obj, value):
        pass
    def _set_direct(self, obj, value):
        if not self.use_method:
            setattr(obj, self.slot_name, value)
    def get_value_for_datastore(self, model_instance):
        if self.calculated_type in [str, int, bool]:
            value = self.__get__(model_instance, model_instance.__class__)
            return value
        else:
            return None
class ListProperty(Property):
    data_type = list
    type_name = 'List'
    def __init__(self, item_type, verbose_name=None, name=None, default=None, **kwds):
        if default is None:
            default = []
        self.item_type = item_type
        super(ListProperty, self).__init__(verbose_name, name, default=default, required=True, **kwds)
    def validate(self, value):
        if self.validator:
            self.validator(value)
        if value is not None:
            if not isinstance(value, list):
                value = [value]
        if self.item_type in six.integer_types:
            item_type = six.integer_types
        elif self.item_type in six.string_types:
            item_type = six.string_types
        else:
            item_type = self.item_type
        for item in value:
            if not isinstance(item, item_type):
                if item_type == six.integer_types:
                    raise ValueError('Items in the %s list must all be integers.' % self.name)
                else:
                    raise ValueError('Items in the %s list must all be %s instances' %
                                     (self.name, self.item_type.__name__))
        return value
    def empty(self, value):
        return value is None
    def default_value(self):
        return list(super(ListProperty, self).default_value())
    def __set__(self, obj, value):
        if self.item_type in six.integer_types:
            item_type = six.integer_types
        elif self.item_type in six.string_types:
            item_type = six.string_types
        else:
            item_type = self.item_type
        if isinstance(value, item_type):
            value = [value]
        elif value is None:  # Override to allow them to set this to "None" to remove everything
            value = []
        return super(ListProperty, self).__set__(obj, value)
class MapProperty(Property):
    data_type = dict
    type_name = 'Map'
    def __init__(self, item_type=str, verbose_name=None, name=None, default=None, **kwds):
        if default is None:
            default = {}
        self.item_type = item_type
        super(MapProperty, self).__init__(verbose_name, name, default=default, required=True, **kwds)
    def validate(self, value):
        value = super(MapProperty, self).validate(value)
        if value is not None:
            if not isinstance(value, dict):
                raise ValueError('Value must of type dict')
        if self.item_type in six.integer_types:
            item_type = six.integer_types
        elif self.item_type in six.string_types:
            item_type = six.string_types
        else:
            item_type = self.item_type
        for key in value:
            if not isinstance(value[key], item_type):
                if item_type == six.integer_types:
                    raise ValueError('Values in the %s Map must all be integers.' % self.name)
                else:
                    raise ValueError('Values in the %s Map must all be %s instances' %
                                     (self.name, self.item_type.__name__))
        return value
    def empty(self, value):
        return value is None
    def default_value(self):
        return {}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
