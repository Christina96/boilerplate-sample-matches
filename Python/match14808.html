<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for website.py &amp; property.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for website.py &amp; property.py
      </h3>
<h1 align="center">
        1.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>website.py (4.601227%)<th>property.py (1.2531328%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(281-287)<td><a href="#" name="0">(40-46)</a><td align="center"><font color="#ff0000">15</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>website.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 def tag(key, value):
2     start = '&lt;%s&gt;' % key
3     end = '&lt;/%s&gt;' % key
4     return '%s%s%s' % (start, value, end)
5 class WebsiteConfiguration(object):
6     def __init__(self, suffix=None, error_key=None,
7                  redirect_all_requests_to=None, routing_rules=None):
8         self.suffix = suffix
9         self.error_key = error_key
10         self.redirect_all_requests_to = redirect_all_requests_to
11         if routing_rules is not None:
12             self.routing_rules = routing_rules
13         else:
14             self.routing_rules = RoutingRules()
15     def startElement(self, name, attrs, connection):
16         if name == 'RoutingRules':
17             self.routing_rules = RoutingRules()
18             return self.routing_rules
19         elif name == 'IndexDocument':
20             return _XMLKeyValue([('Suffix', 'suffix')], container=self)
21         elif name == 'ErrorDocument':
22             return _XMLKeyValue([('Key', 'error_key')], container=self)
23     def endElement(self, name, value, connection):
24         pass
25     def to_xml(self):
26         parts = ['&lt;?xml version="1.0" encoding="UTF-8"?&gt;',
27           '&lt;WebsiteConfiguration xmlns="http://s3.amazonaws.com/doc/2006-03-01/"&gt;']
28         if self.suffix is not None:
29             parts.append(tag('IndexDocument', tag('Suffix', self.suffix)))
30         if self.error_key is not None:
31             parts.append(tag('ErrorDocument', tag('Key', self.error_key)))
32         if self.redirect_all_requests_to is not None:
33             parts.append(self.redirect_all_requests_to.to_xml())
34         if self.routing_rules:
35             parts.append(self.routing_rules.to_xml())
36         parts.append('&lt;/WebsiteConfiguration&gt;')
37         return ''.join(parts)
38 class _XMLKeyValue(object):
39     def __init__(self, translator, container=None):
40         self.translator = translator
41         if container:
42             self.container = container
43         else:
44             self.container = self
45     def startElement(self, name, attrs, connection):
46         pass
47     def endElement(self, name, value, connection):
48         for xml_key, attr_name in self.translator:
49             if name == xml_key:
50                 setattr(self.container, attr_name, value)
51     def to_xml(self):
52         parts = []
53         for xml_key, attr_name in self.translator:
54             content = getattr(self.container, attr_name)
55             if content is not None:
56                 parts.append(tag(xml_key, content))
57         return ''.join(parts)
58 class RedirectLocation(_XMLKeyValue):
59     TRANSLATOR = [('HostName', 'hostname'),
60                   ('Protocol', 'protocol'),
61                  ]
62     def __init__(self, hostname=None, protocol=None):
63         self.hostname = hostname
64         self.protocol = protocol
65         super(RedirectLocation, self).__init__(self.TRANSLATOR)
66     def to_xml(self):
67         return tag('RedirectAllRequestsTo',
68             super(RedirectLocation, self).to_xml())
69 class RoutingRules(list):
70     def add_rule(self, rule):
71         self.append(rule)
72         return self
73     def startElement(self, name, attrs, connection):
74         if name == 'RoutingRule':
75             rule = RoutingRule(Condition(), Redirect())
76             self.add_rule(rule)
77             return rule
78     def endElement(self, name, value, connection):
79         pass
80     def __repr__(self):
81         return "RoutingRules(%s)" % super(RoutingRules, self).__repr__()
82     def to_xml(self):
83         inner_text = []
84         for rule in self:
85             inner_text.append(rule.to_xml())
86         return tag('RoutingRules', '\n'.join(inner_text))
87 class RoutingRule(object):
88     def __init__(self, condition=None, redirect=None):
89         self.condition = condition
90         self.redirect = redirect
91     def startElement(self, name, attrs, connection):
92         if name == 'Condition':
93             return self.condition
94         elif name == 'Redirect':
95             return self.redirect
96     def endElement(self, name, value, connection):
97         pass
98     def to_xml(self):
99         parts = []
100         if self.condition:
101             parts.append(self.condition.to_xml())
102         if self.redirect:
103             parts.append(self.redirect.to_xml())
104         return tag('RoutingRule', '\n'.join(parts))
105     @classmethod
106     def when(cls, key_prefix=None, http_error_code=None):
107         return cls(Condition(key_prefix=key_prefix,
108                              http_error_code=http_error_code), None)
109     def then_redirect(self, hostname=None, protocol=None, replace_key=None,
110                       replace_key_prefix=None, http_redirect_code=None):
111         self.redirect = Redirect(
112                 hostname=hostname, protocol=protocol,
113                 replace_key=replace_key,
114                 replace_key_prefix=replace_key_prefix,
115                 http_redirect_code=http_redirect_code)
116         return self
117 class Condition(_XMLKeyValue):
118     TRANSLATOR = [
119         ('KeyPrefixEquals', 'key_prefix'),
120         ('HttpErrorCodeReturnedEquals', 'http_error_code'),
121         ]
122     def __init__(self, key_prefix=None, http_error_code=None):
123         self.key_prefix = key_prefix
124         self.http_error_code = http_error_code
125         super(Condition, self).__init__(self.TRANSLATOR)
126     def to_xml(self):
127         return tag('Condition', super(Condition, self).to_xml())
128 class Redirect(_XMLKeyValue):
129     TRANSLATOR = [
130         ('Protocol', 'protocol'),
131         ('HostName', 'hostname'),
132         ('ReplaceKeyWith', 'replace_key'),
133         ('ReplaceKeyPrefixWith', 'replace_key_prefix'),
134 <a name="0"></a>        ('HttpRedirectCode', 'http_redirect_code'),
135         ]
136     def __init__(self, hostname<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None, protocol=None, replace_key=None,
137                  replace_key_prefix=None, http_redirect_code=None):
138         self.hostname = hostname
139         self.protocol = protocol
140         self.replace_key = replace_key
141         self.replace_key_prefix = replace_key_prefix
142         self.http_redirect_code =</b></font> http_redirect_code
143         super(Redirect, self).__init__(self.TRANSLATOR)
144     def to_xml(self):
145         return tag('Redirect', super(Redirect, self).to_xml())
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>property.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import datetime
2 from boto.sdb.db.key import Key
3 from boto.utils import Password
4 from boto.sdb.db.query import Query
5 import re
6 import boto
7 import boto.s3.key
8 from boto.sdb.db.blob import Blob
9 from boto.compat import six, long_type
10 class Property(object):
11     data_type = str
12     type_name = ''
13 <a name="0"></a>    name = ''
14     verbose_name = ''
15     def __init__(self, verbose_name=None, name=None, default<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None,
16                  required=False, validator=None, choices=None, unique=False):
17         self.verbose_name = verbose_name
18         self.name = name
19         self.default = default
20         self.required = required
21         self.validator =</b></font> validator
22         self.choices = choices
23         if self.name:
24             self.slot_name = '_' + self.name
25         else:
26             self.slot_name = '_'
27         self.unique = unique
28     def __get__(self, obj, objtype):
29         if obj:
30             obj.load()
31             return getattr(obj, self.slot_name)
32         else:
33             return None
34     def __set__(self, obj, value):
35         self.validate(value)
36         try:
37             if obj._loaded and hasattr(obj, "on_set_%s" % self.name):
38                 fnc = getattr(obj, "on_set_%s" % self.name)
39                 value = fnc(value)
40         except Exception:
41             boto.log.exception("Exception running on_set_%s" % self.name)
42         setattr(obj, self.slot_name, value)
43     def __property_config__(self, model_class, property_name):
44         self.model_class = model_class
45         self.name = property_name
46         self.slot_name = '_' + self.name
47     def default_validator(self, value):
48         if isinstance(value, six.string_types) or value == self.default_value():
49             return
50         if not isinstance(value, self.data_type):
51             raise TypeError('Validation Error, %s.%s expecting %s, got %s' % (self.model_class.__name__, self.name, self.data_type, type(value)))
52     def default_value(self):
53         return self.default
54     def validate(self, value):
55         if self.required and value is None:
56             raise ValueError('%s is a required property' % self.name)
57         if self.choices and value and value not in self.choices:
58             raise ValueError('%s not a valid choice for %s.%s' % (value, self.model_class.__name__, self.name))
59         if self.validator:
60             self.validator(value)
61         else:
62             self.default_validator(value)
63         return value
64     def empty(self, value):
65         return not value
66     def get_value_for_datastore(self, model_instance):
67         return getattr(model_instance, self.name)
68     def make_value_from_datastore(self, value):
69         return value
70     def get_choices(self):
71         if callable(self.choices):
72             return self.choices()
73         return self.choices
74 def validate_string(value):
75     if value is None:
76         return
77     elif isinstance(value, six.string_types):
78         if len(value) &gt; 1024:
79             raise ValueError('Length of value greater than maxlength')
80     else:
81         raise TypeError('Expecting String, got %s' % type(value))
82 class StringProperty(Property):
83     type_name = 'String'
84     def __init__(self, verbose_name=None, name=None, default='',
85                  required=False, validator=validate_string,
86                  choices=None, unique=False):
87         super(StringProperty, self).__init__(verbose_name, name, default, required,
88                           validator, choices, unique)
89 class TextProperty(Property):
90     type_name = 'Text'
91     def __init__(self, verbose_name=None, name=None, default='',
92                  required=False, validator=None, choices=None,
93                  unique=False, max_length=None):
94         super(TextProperty, self).__init__(verbose_name, name, default, required,
95                           validator, choices, unique)
96         self.max_length = max_length
97     def validate(self, value):
98         value = super(TextProperty, self).validate(value)
99         if not isinstance(value, six.string_types):
100             raise TypeError('Expecting Text, got %s' % type(value))
101         if self.max_length and len(value) &gt; self.max_length:
102             raise ValueError('Length of value greater than maxlength %s' % self.max_length)
103 class PasswordProperty(StringProperty):
104     data_type = Password
105     type_name = 'Password'
106     def __init__(self, verbose_name=None, name=None, default='', required=False,
107                  validator=None, choices=None, unique=False, hashfunc=None):
108     And the datetime.date objects. It can return either one,
109     depending on the value stored in the database"""
110     data_type = datetime.datetime
111     type_name = 'DateTime'
112     def __init__(self, verbose_name=None, auto_now=False, auto_now_add=False, name=None,
113                  default=None, required=False, validator=None, choices=None, unique=False):
114         super(DateTimeProperty, self).__init__(verbose_name, name, default, required, validator, choices, unique)
115         self.auto_now = auto_now
116         self.auto_now_add = auto_now_add
117     def default_value(self):
118         if self.auto_now or self.auto_now_add:
119             return self.now()
120         return super(DateTimeProperty, self).default_value()
121     def validate(self, value):
122         if value is None:
123             return
124         if isinstance(value, datetime.date):
125             return value
126         return super(DateTimeProperty, self).validate(value)
127     def get_value_for_datastore(self, model_instance):
128         if self.auto_now:
129             setattr(model_instance, self.name, self.now())
130         return super(DateTimeProperty, self).get_value_for_datastore(model_instance)
131     def now(self):
132         return datetime.datetime.utcnow()
133 class DateProperty(Property):
134     data_type = datetime.date
135     type_name = 'Date'
136     def __init__(self, verbose_name=None, auto_now=False, auto_now_add=False, name=None,
137                  default=None, required=False, validator=None, choices=None, unique=False):
138         super(DateProperty, self).__init__(verbose_name, name, default, required, validator, choices, unique)
139         self.auto_now = auto_now
140         self.auto_now_add = auto_now_add
141     def default_value(self):
142         if self.auto_now or self.auto_now_add:
143             return self.now()
144         return super(DateProperty, self).default_value()
145     def validate(self, value):
146         value = super(DateProperty, self).validate(value)
147         if value is None:
148             return
149         if not isinstance(value, self.data_type):
150             raise TypeError('Validation Error, expecting %s, got %s' % (self.data_type, type(value)))
151     def get_value_for_datastore(self, model_instance):
152         if self.auto_now:
153             setattr(model_instance, self.name, self.now())
154         val = super(DateProperty, self).get_value_for_datastore(model_instance)
155         if isinstance(val, datetime.datetime):
156             val = val.date()
157         return val
158     def now(self):
159         return datetime.date.today()
160 class TimeProperty(Property):
161     data_type = datetime.time
162     type_name = 'Time'
163     def __init__(self, verbose_name=None, name=None,
164                  default=None, required=False, validator=None, choices=None, unique=False):
165         super(TimeProperty, self).__init__(verbose_name, name, default, required, validator, choices, unique)
166     def validate(self, value):
167         value = super(TimeProperty, self).validate(value)
168         if value is None:
169             return
170         if not isinstance(value, self.data_type):
171             raise TypeError('Validation Error, expecting %s, got %s' % (self.data_type, type(value)))
172 class ReferenceProperty(Property):
173     data_type = Key
174     type_name = 'Reference'
175     def __init__(self, reference_class=None, collection_name=None,
176                  verbose_name=None, name=None, default=None, required=False, validator=None, choices=None, unique=False):
177         super(ReferenceProperty, self).__init__(verbose_name, name, default, required, validator, choices, unique)
178         self.reference_class = reference_class
179         self.collection_name = collection_name
180     def __get__(self, obj, objtype):
181         if obj:
182             value = getattr(obj, self.slot_name)
183             if value == self.default_value():
184                 return value
185             if isinstance(value, six.string_types):
186                 value = self.reference_class(value)
187                 setattr(obj, self.name, value)
188             return value
189     def __set__(self, obj, value):
190         """Don't allow this object to be associated to itself
191         This causes bad things to happen"""
192         if value is not None and (obj.id == value or (hasattr(value, "id") and obj.id == value.id)):
193             raise ValueError("Can not associate an object with itself!")
194         return super(ReferenceProperty, self).__set__(obj, value)
195     def __property_config__(self, model_class, property_name):
196         super(ReferenceProperty, self).__property_config__(model_class, property_name)
197         if self.collection_name is None:
198             self.collection_name = '%s_%s_set' % (model_class.__name__.lower(), self.name)
199         if hasattr(self.reference_class, self.collection_name):
200             raise ValueError('duplicate property: %s' % self.collection_name)
201         setattr(self.reference_class, self.collection_name,
202                 _ReverseReferenceProperty(model_class, property_name, self.collection_name))
203     def check_uuid(self, value):
204         t = value.split('-')
205         if len(t) != 5:
206             raise ValueError
207     def check_instance(self, value):
208         try:
209             obj_lineage = value.get_lineage()
210             cls_lineage = self.reference_class.get_lineage()
211             if obj_lineage.startswith(cls_lineage):
212                 return
213             raise TypeError('%s not instance of %s' % (obj_lineage, cls_lineage))
214         except:
215             raise ValueError('%s is not a Model' % value)
216     def validate(self, value):
217         if self.validator:
218             self.validator(value)
219         if self.required and value is None:
220             raise ValueError('%s is a required property' % self.name)
221         if value == self.default_value():
222             return
223         if not isinstance(value, six.string_types):
224             self.check_instance(value)
225 class _ReverseReferenceProperty(Property):
226     data_type = Query
227     type_name = 'query'
228     def __init__(self, model, prop, name):
229         self.__model = model
230         self.__property = prop
231         self.collection_name = prop
232         self.name = name
233         self.item_type = model
234     def __get__(self, model_instance, model_class):
235         if model_instance is not None:
236             query = Query(self.__model)
237             if isinstance(self.__property, list):
238                 props = []
239                 for prop in self.__property:
240                     props.append("%s =" % prop)
241                 return query.filter(props, model_instance)
242             else:
243                 return query.filter(self.__property + ' =', model_instance)
244         else:
245             return self
246     def __set__(self, model_instance, value):
247         raise ValueError('Virtual property is read-only')
248 class CalculatedProperty(Property):
249     def __init__(self, verbose_name=None, name=None, default=None,
250                  required=False, validator=None, choices=None,
251                  calculated_type=int, unique=False, use_method=False):
252         super(CalculatedProperty, self).__init__(verbose_name, name, default, required,
253                           validator, choices, unique)
254         self.calculated_type = calculated_type
255         self.use_method = use_method
256     def __get__(self, obj, objtype):
257         value = self.default_value()
258         if obj:
259             try:
260                 value = getattr(obj, self.slot_name)
261                 if self.use_method:
262                     value = value()
263             except AttributeError:
264                 pass
265         return value
266     def __set__(self, obj, value):
267         pass
268     def _set_direct(self, obj, value):
269         if not self.use_method:
270             setattr(obj, self.slot_name, value)
271     def get_value_for_datastore(self, model_instance):
272         if self.calculated_type in [str, int, bool]:
273             value = self.__get__(model_instance, model_instance.__class__)
274             return value
275         else:
276             return None
277 class ListProperty(Property):
278     data_type = list
279     type_name = 'List'
280     def __init__(self, item_type, verbose_name=None, name=None, default=None, **kwds):
281         if default is None:
282             default = []
283         self.item_type = item_type
284         super(ListProperty, self).__init__(verbose_name, name, default=default, required=True, **kwds)
285     def validate(self, value):
286         if self.validator:
287             self.validator(value)
288         if value is not None:
289             if not isinstance(value, list):
290                 value = [value]
291         if self.item_type in six.integer_types:
292             item_type = six.integer_types
293         elif self.item_type in six.string_types:
294             item_type = six.string_types
295         else:
296             item_type = self.item_type
297         for item in value:
298             if not isinstance(item, item_type):
299                 if item_type == six.integer_types:
300                     raise ValueError('Items in the %s list must all be integers.' % self.name)
301                 else:
302                     raise ValueError('Items in the %s list must all be %s instances' %
303                                      (self.name, self.item_type.__name__))
304         return value
305     def empty(self, value):
306         return value is None
307     def default_value(self):
308         return list(super(ListProperty, self).default_value())
309     def __set__(self, obj, value):
310         if self.item_type in six.integer_types:
311             item_type = six.integer_types
312         elif self.item_type in six.string_types:
313             item_type = six.string_types
314         else:
315             item_type = self.item_type
316         if isinstance(value, item_type):
317             value = [value]
318         elif value is None:  # Override to allow them to set this to "None" to remove everything
319             value = []
320         return super(ListProperty, self).__set__(obj, value)
321 class MapProperty(Property):
322     data_type = dict
323     type_name = 'Map'
324     def __init__(self, item_type=str, verbose_name=None, name=None, default=None, **kwds):
325         if default is None:
326             default = {}
327         self.item_type = item_type
328         super(MapProperty, self).__init__(verbose_name, name, default=default, required=True, **kwds)
329     def validate(self, value):
330         value = super(MapProperty, self).validate(value)
331         if value is not None:
332             if not isinstance(value, dict):
333                 raise ValueError('Value must of type dict')
334         if self.item_type in six.integer_types:
335             item_type = six.integer_types
336         elif self.item_type in six.string_types:
337             item_type = six.string_types
338         else:
339             item_type = self.item_type
340         for key in value:
341             if not isinstance(value[key], item_type):
342                 if item_type == six.integer_types:
343                     raise ValueError('Values in the %s Map must all be integers.' % self.name)
344                 else:
345                     raise ValueError('Values in the %s Map must all be %s instances' %
346                                      (self.name, self.item_type.__name__))
347         return value
348     def empty(self, value):
349         return value is None
350     def default_value(self):
351         return {}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
