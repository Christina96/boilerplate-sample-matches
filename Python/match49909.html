<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_debian_ip_1.py & test_sysctl.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_debian_ip_1.py & test_sysctl.py
      </h3>
      <h1 align="center">
        5.7%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_debian_ip_1.py (3.860294%)<TH>test_sysctl.py (11.4754095%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match49909-0.html#0',2,'match49909-1.html#0',3)" NAME="0">(867-871)<TD><A HREF="javascript:ZweiFrames('match49909-0.html#0',2,'match49909-1.html#0',3)" NAME="0">(27-30)</A><TD ALIGN=center><FONT COLOR="#ff0000">16</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match49909-0.html#1',2,'match49909-1.html#1',3)" NAME="1">(1176-1183)<TD><A HREF="javascript:ZweiFrames('match49909-0.html#1',2,'match49909-1.html#1',3)" NAME="1">(73-75)</A><TD ALIGN=center><FONT COLOR="#cf0000">13</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match49909-0.html#2',2,'match49909-1.html#2',3)" NAME="2">(1148-1155)<TD><A HREF="javascript:ZweiFrames('match49909-0.html#2',2,'match49909-1.html#2',3)" NAME="2">(48-50)</A><TD ALIGN=center><FONT COLOR="#cf0000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_debian_ip_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
    :codeauthor: Jayesh Kariya &lt;jayeshk@saltstack.com&gt;
&quot;&quot;&quot;

import tempfile

import jinja2.exceptions
import pytest
import salt.modules.debian_ip as debian_ip
import salt.utils.files
import salt.utils.platform
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import MagicMock, patch
from tests.support.unit import TestCase, skipIf

try:
    from salt.utils.odict import OrderedDict as odict
except ImportError:
    from collections import OrderedDict as odict

# Big pile of interface data for unit tests
#   To skip, search for 'DebianIpTestCase'
# fmt: off
test_interfaces = [
        # Structure
        #{'iface_name': 'ethX', 'iface_type': 'eth', 'enabled': True,
        #    'skip_test': bool(),        # True to disable this test
        #    'build_interface': dict(),  # data read from sls
        #    'get_interface(): OrderedDict(),   # data read from interfaces file
        #    'return': list()},          # jinja-rendered data

        # IPv4-only interface; single address
        {'iface_name': 'eth1', 'iface_type': 'eth', 'enabled': True,
            'build_interface': {
                'proto': 'static',
                'ipaddr': '192.168.4.9',
                'netmask': '255.255.255.0',
                'gateway': '192.168.4.1',
                'enable_ipv6': False,
                'noifupdown': True,
                },
            'get_interface': odict([('eth1', odict([('enabled', True), ('data', odict([
                ('inet', odict([
                    ('addrfam', 'inet'),
                    ('proto', 'static'),
                    ('filename', None),
                    ('address', '192.168.4.9'),
                    ('netmask', '255.255.255.0'),
                    ('gateway', '192.168.4.1'),
                    ])),
                ]))]))]),
            'return': [
                'auto eth1\n',
                'iface eth1 inet static\n',
                '    address 192.168.4.9\n',
                '    netmask 255.255.255.0\n',
                '    gateway 192.168.4.1\n',
                '\n']},

        # IPv6-only; single address
        {'iface_name': 'eth2', 'iface_type': 'eth', 'enabled': True,
            'build_interface': {
                'ipv6proto': 'static',
                'ipv6ipaddr': '2001:db8:dead:beef::3',
                'ipv6netmask': '64',
                'ipv6gateway': '2001:db8:dead:beef::1',
                'enable_ipv6': True,
                'noifupdown': True,
                },
            'get_interface': odict([('eth2', odict([('enabled', True), ('data', odict([
                ('inet6', odict([
                    ('addrfam', 'inet6'),
                    ('proto', 'static'),
                    ('filename', None),
                    ('address', '2001:db8:dead:beef::3'),
                    ('netmask', 64),
                    ('gateway', '2001:db8:dead:beef::1'),
                    ])),
                ]))]))]),
            'return': [
                'auto eth2\n',
                'iface eth2 inet6 static\n',
                '    address 2001:db8:dead:beef::3\n',
                '    netmask 64\n',
                '    gateway 2001:db8:dead:beef::1\n',
                '\n']},

        # IPv6-only; multiple addrs; no gw; first addr from ipv6addr
        {'iface_name': 'eth3', 'iface_type': 'eth', 'enabled': True,
            'build_interface': {
                'ipv6proto': 'static',
                'ipv6ipaddr': '2001:db8:dead:beef::5/64',
                'ipv6ipaddrs': [
                    '2001:db8:dead:beef::7/64',
                    '2001:db8:dead:beef::8/64',
                    '2001:db8:dead:beef::9/64'],
                'enable_ipv6': True,
                'noifupdown': True,
                },
            'get_interface': odict([('eth3', odict([('enabled', True), ('data', odict([
                ('inet6', odict([
                    ('addrfam', 'inet6'),
                    ('proto', 'static'),
                    ('filename', None),
                    ('address', '2001:db8:dead:beef::5/64'),
                    ('addresses', [
                        '2001:db8:dead:beef::7/64',
                        '2001:db8:dead:beef::8/64',
                        '2001:db8:dead:beef::9/64',
                        ]),
                    ])),
                ]))]))]),
            'return': [
                'auto eth3\n',
                'iface eth3 inet6 static\n',
                '    address 2001:db8:dead:beef::5/64\n',
                '    address 2001:db8:dead:beef::7/64\n',
                '    address 2001:db8:dead:beef::8/64\n',
                '    address 2001:db8:dead:beef::9/64\n',
                '\n']},

        # IPv6-only; multiple addresses
        {'iface_name': 'eth4', 'iface_type': 'eth', 'enabled': True,
            'build_interface': {
                'ipv6proto': 'static',
                'ipv6ipaddrs': [
                    '2001:db8:dead:beef::5/64',
                    '2001:db8:dead:beef::7/64',
                    '2001:db8:dead:beef::8/64',
                    '2001:db8:dead:beef::9/64'],
                'ipv6gateway': '2001:db8:dead:beef::1',
                'enable_ipv6': True,
                'noifupdown': True,
                },
            'get_interface': odict([('eth4', odict([('enabled', True), ('data', odict([
                ('inet6', odict([
                    ('addrfam', 'inet6'),
                    ('proto', 'static'),
                    ('filename', None),
                    ('address', '2001:db8:dead:beef::5/64'),
                    ('addresses', [
                        '2001:db8:dead:beef::7/64',
                        '2001:db8:dead:beef::8/64',
                        '2001:db8:dead:beef::9/64',
                        ]),
                    ('gateway', '2001:db8:dead:beef::1'),
                    ])),
                ]))]))]),
            'return': [
                'auto eth4\n',
                'iface eth4 inet6 static\n',
                '    address 2001:db8:dead:beef::5/64\n',
                '    address 2001:db8:dead:beef::7/64\n',
                '    address 2001:db8:dead:beef::8/64\n',
                '    address 2001:db8:dead:beef::9/64\n',
                '    gateway 2001:db8:dead:beef::1\n',
                '\n']},

        # IPv4 and IPv6 settings with v4 disabled
        {'iface_name': 'eth5', 'iface_type': 'eth', 'enabled': True,
            'build_interface': {
                'proto': 'static',
                'ipaddr': '192.168.4.9',
                'netmask': '255.255.255.0',
                'gateway': '192.168.4.1',
                'ipv6proto': 'static',
                'ipv6ipaddr': '2001:db8:dead:beef::3',
                'ipv6netmask': '64',
                'ipv6gateway': '2001:db8:dead:beef::1',
                'enable_ipv4': False,
                'noifupdown': True,
                },
            'get_interface': odict([('eth5', odict([('enabled', True), ('data', odict([
                ('inet6', odict([
                    ('addrfam', 'inet6'),
                    ('proto', 'static'),
                    ('filename', None),
                    ('address', '2001:db8:dead:beef::3'),
                    ('netmask', 64),
                    ('gateway', '2001:db8:dead:beef::1'),
                    ])),
                ]))]))]),
            'return': [
                'auto eth5\n',
                'iface eth5 inet6 static\n',
                '    address 2001:db8:dead:beef::3\n',
                '    netmask 64\n',
                '    gateway 2001:db8:dead:beef::1\n',
                '\n']},

        # IPv4 and IPv6 settings with v6 disabled
        {'iface_name': 'eth6', 'iface_type': 'eth', 'enabled': True,
            'build_interface': {
                'proto': 'static',
                'ipaddr': '192.168.4.9',
                'netmask': '255.255.255.0',
                'gateway': '192.168.4.1',
                'ipv6proto': 'static',
                'ipv6ipaddr': '2001:db8:dead:beef::3',
                'ipv6netmask': '64',
                'ipv6gateway': '2001:db8:dead:beef::1',
                'enable_ipv6': False,
                'noifupdown': True,
                },
            'get_interface': odict([('eth6', odict([('enabled', True), ('data', odict([
                ('inet', odict([
                    ('addrfam', 'inet'),
                    ('proto', 'static'),
                    ('filename', None),
                    ('address', '192.168.4.9'),
                    ('netmask', '255.255.255.0'),
                    ('gateway', '192.168.4.1'),
                    ])),
                ]))]))]),
            'return': [
                'auto eth6\n',
                'iface eth6 inet static\n',
                '    address 192.168.4.9\n',
                '    netmask 255.255.255.0\n',
                '    gateway 192.168.4.1\n',
                '\n']},

        # IPv4 and IPv6; shared/overridden settings
        {'iface_name': 'eth7', 'iface_type': 'eth', 'enabled': True,
            'build_interface': {
                'proto': 'static',
                'ipaddr': '192.168.4.9',
                'netmask': '255.255.255.0',
                'gateway': '192.168.4.1',
                'ipv6proto': 'static',
                'ipv6ipaddr': '2001:db8:dead:beef::3',
                'ipv6netmask': '64',
                'ipv6gateway': '2001:db8:dead:beef::1',
                'ttl': '18',  # shared
                'ipv6ttl': '15',  # overridden for v6
                'mtu': '1480',  # shared
                'enable_ipv6': True,
                'noifupdown': True,
                },
            'get_interface': odict([('eth7', odict([('enabled', True), ('data', odict([
                ('inet', odict([
                    ('addrfam', 'inet'),
                    ('proto', 'static'),
                    ('filename', None),
                    ('address', '192.168.4.9'),
                    ('netmask', '255.255.255.0'),
                    ('gateway', '192.168.4.1'),
                    ('ttl', 18),
                    ('mtu', 1480),
                    ])),
                ('inet6', odict([
                    ('addrfam', 'inet6'),
                    ('proto', 'static'),
                    ('filename', None),
                    ('address', '2001:db8:dead:beef::3'),
                    ('netmask', 64),
                    ('gateway', '2001:db8:dead:beef::1'),
                    ('ttl', 15),
                    ('mtu', 1480),
                    ])),
                ]))]))]),
            'return': [
                'auto eth7\n',
                'iface eth7 inet static\n',
                '    address 192.168.4.9\n',
                '    netmask 255.255.255.0\n',
                '    gateway 192.168.4.1\n',
                '    ttl 18\n',
                '    mtu 1480\n',
                'iface eth7 inet6 static\n',
                '    address 2001:db8:dead:beef::3\n',
                '    netmask 64\n',
                '    gateway 2001:db8:dead:beef::1\n',
                '    ttl 15\n',
                '    mtu 1480\n',
                '\n']},

        # Slave iface
        {'iface_name': 'eth8', 'iface_type': 'slave', 'enabled': True,
            'build_interface': {
                'master': 'bond0',
                'noifupdown': True,
                },
            'get_interface': odict([('eth8', odict([('enabled', True), ('data', odict([
                ('inet', odict([
                    ('addrfam', 'inet'),
                    ('proto', 'manual'),
                    ('filename', None),
                    ('bonding', odict([
                        ('master', 'bond0'),
                        ])),
                    ('bonding_keys', ['master']),
                    ])),
                ]))]))]),
            'return': [
                'auto eth8\n',
                'iface eth8 inet manual\n',
                '    bond-master bond0\n',
                '\n']},

        # Bond; with address IPv4 and IPv6 address; slaves as string
        {'iface_name': 'bond9', 'iface_type': 'bond', 'enabled': True,
            'build_interface': {
                'proto': 'static',
                'ipaddr': '10.1.0.14',
                'netmask': '255.255.255.0',
                'gateway': '10.1.0.1',
                'ipv6proto': 'static',
                'ipv6ipaddr': '2001:db8:dead:c0::3',
                'ipv6netmask': '64',
                'ipv6gateway': '2001:db8:dead:c0::1',
                'mode': '802.3ad',
                'slaves': 'eth4 eth5',
                'enable_ipv6': True,
                'noifupdown': True,
                },
            'get_interface': odict([('bond9', odict([('enabled', True), ('data', odict([
                ('inet', odict([
                    ('addrfam', 'inet'),
                    ('proto', 'static'),
                    ('filename', None),
                    ('address', '10.1.0.14'),
                    ('netmask', '255.255.255.0'),
                    ('gateway', '10.1.0.1'),
                    ('bonding', odict([
                        ('ad_select', '0'),
                        ('downdelay', '200'),
                        ('lacp_rate', '0'),
                        ('miimon', '100'),
                        ('mode', '4'),
                        ('slaves', 'eth4 eth5'),
                        ('updelay', '0'),
                        ('use_carrier', 'on'),
                        ])),
                    ('bonding_keys', [
                        'ad_select',
                        'downdelay',
                        'lacp_rate',
                        'miimon',
                        'mode',
                        'slaves',
                        'updelay',
                        'use_carrier',
                        ]),
                    ])),
                ('inet6', odict([
                    ('addrfam', 'inet6'),
                    ('proto', 'static'),
                    ('filename', None),
                    ('address', '2001:db8:dead:c0::3'),
                    ('netmask', 64),
                    ('gateway', '2001:db8:dead:c0::1'),
                    ('bonding', odict([
                        ('ad_select', '0'),
                        ('downdelay', '200'),
                        ('lacp_rate', '0'),
                        ('miimon', '100'),
                        ('mode', '4'),
                        ('slaves', 'eth4 eth5'),
                        ('updelay', '0'),
                        ('use_carrier', 'on'),
                        ])),
                    ('bonding_keys', [
                        'ad_select',
                        'downdelay',
                        'lacp_rate',
                        'miimon',
                        'mode',
                        'slaves',
                        'updelay',
                        'use_carrier',
                        ]),
                    ])),
                ]))]))]),
            'return': [
                'auto bond9\n',
                'iface bond9 inet static\n',
                '    address 10.1.0.14\n',
                '    netmask 255.255.255.0\n',
                '    gateway 10.1.0.1\n',
                '    bond-ad_select 0\n',
                '    bond-downdelay 200\n',
                '    bond-lacp_rate 0\n',
                '    bond-miimon 100\n',
                '    bond-mode 4\n',
                '    bond-slaves eth4 eth5\n',
                '    bond-updelay 0\n',
                '    bond-use_carrier on\n',
                'iface bond9 inet6 static\n',
                '    address 2001:db8:dead:c0::3\n',
                '    netmask 64\n',
                '    gateway 2001:db8:dead:c0::1\n',
                '    bond-ad_select 0\n',
                '    bond-downdelay 200\n',
                '    bond-lacp_rate 0\n',
                '    bond-miimon 100\n',
                '    bond-mode 4\n',
                '    bond-slaves eth4 eth5\n',
                '    bond-updelay 0\n',
                '    bond-use_carrier on\n',
                '\n']},

        # Bond; with address IPv4 and IPv6 address; slaves as list
        {'iface_name': 'bond10', 'iface_type': 'bond', 'enabled': True,
            'build_interface': {
                'proto': 'static',
                'ipaddr': '10.1.0.14',
                'netmask': '255.255.255.0',
                'gateway': '10.1.0.1',
                'ipv6proto': 'static',
                'ipv6ipaddr': '2001:db8:dead:c0::3',
                'ipv6netmask': '64',
                'ipv6gateway': '2001:db8:dead:c0::1',
                'mode': '802.3ad',
                'slaves': ['eth4', 'eth5'],
                'enable_ipv6': True,
                'noifupdown': True,
                },
            'get_interface': odict([('bond10', odict([('enabled', True), ('data', odict([
                ('inet', odict([
                    ('addrfam', 'inet'),
                    ('proto', 'static'),
                    ('filename', None),
                    ('address', '10.1.0.14'),
                    ('netmask', '255.255.255.0'),
                    ('gateway', '10.1.0.1'),
                    ('bonding', odict([
                        ('ad_select', '0'),
                        ('downdelay', '200'),
                        ('lacp_rate', '0'),
                        ('miimon', '100'),
                        ('mode', '4'),
                        ('slaves', 'eth4 eth5'),
                        ('updelay', '0'),
                        ('use_carrier', 'on'),
                        ])),
                    ('bonding_keys', [
                        'ad_select',
                        'downdelay',
                        'lacp_rate',
                        'miimon',
                        'mode',
                        'slaves',
                        'updelay',
                        'use_carrier',
                        ]),
                    ])),
                ('inet6', odict([
                    ('addrfam', 'inet6'),
                    ('proto', 'static'),
                    ('filename', None),
                    ('address', '2001:db8:dead:c0::3'),
                    ('netmask', 64),
                    ('gateway', '2001:db8:dead:c0::1'),
                    ('bonding', odict([
                        ('ad_select', '0'),
                        ('downdelay', '200'),
                        ('lacp_rate', '0'),
                        ('miimon', '100'),
                        ('mode', '4'),
                        ('slaves', 'eth4 eth5'),
                        ('updelay', '0'),
                        ('use_carrier', 'on'),
                        ])),
                    ('bonding_keys', [
                        'ad_select',
                        'downdelay',
                        'lacp_rate',
                        'miimon',
                        'mode',
                        'slaves',
                        'updelay',
                        'use_carrier',
                        ]),
                    ])),
                ]))]))]),
            'return': [
                'auto bond10\n',
                'iface bond10 inet static\n',
                '    address 10.1.0.14\n',
                '    netmask 255.255.255.0\n',
                '    gateway 10.1.0.1\n',
                '    bond-ad_select 0\n',
                '    bond-downdelay 200\n',
                '    bond-lacp_rate 0\n',
                '    bond-miimon 100\n',
                '    bond-mode 4\n',
                '    bond-slaves eth4 eth5\n',
                '    bond-updelay 0\n',
                '    bond-use_carrier on\n',
                'iface bond10 inet6 static\n',
                '    address 2001:db8:dead:c0::3\n',
                '    netmask 64\n',
                '    gateway 2001:db8:dead:c0::1\n',
                '    bond-ad_select 0\n',
                '    bond-downdelay 200\n',
                '    bond-lacp_rate 0\n',
                '    bond-miimon 100\n',
                '    bond-mode 4\n',
                '    bond-slaves eth4 eth5\n',
                '    bond-updelay 0\n',
                '    bond-use_carrier on\n',
                '\n']},

        # Bond VLAN; with IPv4 address
        {'iface_name': 'bond0.11', 'iface_type': 'vlan', 'enabled': True,
            'build_interface': {
                'proto': 'static',
                'ipaddr': '10.7.0.8',
                'netmask': '255.255.255.0',
                'gateway': '10.7.0.1',
                'slaves': 'eth6 eth7',
                'mode': '802.3ad',
                'enable_ipv6': False,
                'noifupdown': True,
                },
            'get_interface': odict([('bond0.11', odict([('enabled', True), ('data', odict([
                ('inet', odict([
                    ('addrfam', 'inet'),
                    ('proto', 'static'),
                    ('filename', None),
                    ('vlan_raw_device', 'bond1'),
                    ('address', '10.7.0.8'),
                    ('netmask', '255.255.255.0'),
                    ('gateway', '10.7.0.1'),
                    ('mode', '802.3ad'),
                    ])),
                ]))]))]),
            'return': [
                'auto bond0.11\n',
                'iface bond0.11 inet static\n',
                '    vlan-raw-device bond1\n',
                '    address 10.7.0.8\n',
                '    netmask 255.255.255.0\n',
                '    gateway 10.7.0.1\n',
                '    mode 802.3ad\n',
                '\n']},

        # Bond; without address
        {'iface_name': 'bond0.12', 'iface_type': 'vlan', 'enabled': True,
            'build_interface': {
                'proto': 'static',
                'slaves': 'eth6 eth7',
                'mode': '802.3ad',
                'enable_ipv6': False,
                'noifupdown': True,
                },
            'get_interface': odict([('bond0.12', odict([('enabled', True), ('data', odict([
                ('inet', odict([
                    ('addrfam', 'inet'),
                    ('proto', 'static'),
                    ('filename', None),
                    ('vlan_raw_device', 'bond1'),
                    ('mode', '802.3ad'),
                    ])),
                ]))]))]),
            'return': [
                'auto bond0.12\n',
                'iface bond0.12 inet static\n',
                '    vlan-raw-device bond1\n',
                '    mode 802.3ad\n',
                '\n']},

        # Bridged interface
        {'iface_name': 'br0', 'iface_type': 'bridge', 'enabled': True,
            'build_interface': {
                'proto': 'static',
                'ipaddr': '192.168.4.10',
                'netmask': '255.255.255.0',
                'gateway': '192.168.4.1',
                'bridge_ports': 'eth1',
                'enable_ipv6': False,
                'noifupdown': True,
                },
           'get_interface': odict([('br0', odict([('enabled', True), ('data', odict([
                ('inet', odict([
                    ('addrfam', 'inet'),
                    ('proto', 'static'),
                    ('filename', None),
                    ('address', '192.168.4.10'),
                    ('netmask', '255.255.255.0'),
                    ('gateway', '192.168.4.1'),
                    ('bridging', odict([
                        ('ports', 'eth1'),
                    ])),
                    ('bridging_keys', ['ports']),
                    ])),
                ]))]))]),
            'return': [
                'auto br0\n',
                'iface br0 inet static\n',
                '    address 192.168.4.10\n',
                '    netmask 255.255.255.0\n',
                '    gateway 192.168.4.1\n',
                '    bridge_ports eth1\n',
                '\n']},


        # DNS NS as list
        {'iface_name': 'eth13', 'iface_type': 'eth', 'enabled': True,
            'build_interface': {
                'proto': 'static',
                'ipaddr': '192.168.4.9',
                'netmask': '255.255.255.0',
                'gateway': '192.168.4.1',
                'enable_ipv6': False,
                'noifupdown': True,
                'dns': ['8.8.8.8', '8.8.4.4'],
                },
            'get_interface': odict([('eth13', odict([('enabled', True), ('data', odict([
                ('inet', odict([
                    ('addrfam', 'inet'),
                    ('proto', 'static'),
                    ('filename', None),
                    ('address', '192.168.4.9'),
                    ('netmask', '255.255.255.0'),
                    ('gateway', '192.168.4.1'),
                    ('dns_nameservers', ['8.8.8.8', '8.8.4.4']),
                    ])),
                ]))]))]),
            'return': [
                'auto eth13\n',
                'iface eth13 inet static\n',
                '    address 192.168.4.9\n',
                '    netmask 255.255.255.0\n',
                '    gateway 192.168.4.1\n',
                '    dns-nameservers 8.8.8.8 8.8.4.4\n',
                '\n']},

        # DNS NS as string
        {'iface_name': 'eth14', 'iface_type': 'eth', 'enabled': True,
            'build_interface': {
                'proto': 'static',
                'ipaddr': '192.168.4.9',
                'netmask': '255.255.255.0',
                'gateway': '192.168.4.1',
                'enable_ipv6': False,
                'noifupdown': True,
                'dns': '8.8.8.8 8.8.4.4',
                },
            'get_interface': odict([('eth14', odict([('enabled', True), ('data', odict([
                ('inet', odict([
                    ('addrfam', 'inet'),
                    ('proto', 'static'),
                    ('filename', None),
                    ('address', '192.168.4.9'),
                    ('netmask', '255.255.255.0'),
                    ('gateway', '192.168.4.1'),
                    ('dns_nameservers', ['8.8.8.8', '8.8.4.4']),
                    ])),
                ]))]))]),
            'return': [
                'auto eth14\n',
                'iface eth14 inet static\n',
                '    address 192.168.4.9\n',
                '    netmask 255.255.255.0\n',
                '    gateway 192.168.4.1\n',
                '    dns-nameservers 8.8.8.8 8.8.4.4\n',
                '\n']},

        # Loopback; with IPv4 and IPv6 address
        {'iface_name': 'lo15', 'iface_type': 'eth', 'enabled': True,
            'build_interface': {
                'proto': 'loopback',
                'ipaddr': '192.168.4.9',
                'netmask': '255.255.255.0',
                'gateway': '192.168.4.1',
                'enable_ipv6': True,
                'ipv6proto': 'loopback',
                'ipv6ipaddr': 'fc00::1',
                'ipv6netmask': '128',
                'ipv6_autoconf': False,
                'noifupdown': True,
                },
            'get_interface': odict([('lo15', odict([('enabled', True), ('data', odict([
                ('inet', odict([
                    ('addrfam', 'inet'),
                    ('proto', 'loopback'),
                    ('filename', None),
                    ('address', '192.168.4.9'),
                    ('netmask', '255.255.255.0'),
                    ('gateway', '192.168.4.1'),
                    ])),
                ('inet6', odict([
                    ('addrfam', 'inet6'),
                    ('proto', 'loopback'),
                    ('filename', None),
                    ('address', 'fc00::1'),
                    ('netmask', 128),
                    ])),
                ]))]))]),
            'return': [
                'auto lo15\n',
                'iface lo15 inet loopback\n',
                '    address 192.168.4.9\n',
                '    netmask 255.255.255.0\n',
                '    gateway 192.168.4.1\n',
                'iface lo15 inet6 loopback\n',
                '    address fc00::1\n',
                '    netmask 128\n',
                '\n']},

        # Loopback; with only IPv6 address; enabled=False
        {'iface_name': 'lo16', 'iface_type': 'eth', 'enabled': False,
            'build_interface': {
                'enable_ipv6': True,
                'ipv6proto': 'loopback',
                'ipv6ipaddr': 'fc00::1',
                'ipv6netmask': '128',
                'ipv6_autoconf': False,
                'noifupdown': True,
                },
            'get_interface': odict([('lo16', odict([('data', odict([
                ('inet6', odict([
                    ('addrfam', 'inet6'),
                    ('proto', 'loopback'),
                    ('filename', None),
                    ('address', 'fc00::1'),
                    ('netmask', 128),
                    ])),
                ]))]))]),
            'return': [
                'iface lo16 inet6 loopback\n',
                '    address fc00::1\n',
                '    netmask 128\n',
                '\n']},

        # Loopback; without address
        {'iface_name': 'lo17', 'iface_type': 'eth', 'enabled': True,
            'build_interface': {
                'proto': 'loopback',
                'enable_ipv6': False,
                'noifupdown': True,
                },
            'get_interface': odict([('lo17', odict([('enabled', True), ('data', odict([
                ('inet', odict([
                    ('addrfam', 'inet'),
                    ('proto', 'loopback'),
                    ('filename', None),
                    ])),
                ]))]))]),
            'return': [
                'auto lo17\n',
                'iface lo17 inet loopback\n',
                '\n']},

        # IPv4=DHCP; IPv6=Static; with IPv6 netmask
        {'iface_name': 'eth18', 'iface_type': 'eth', 'enabled': True,
            'build_interface': {
                'proto': 'dhcp',
                'enable_ipv6': True,
                'ipv6proto': 'static',
                'ipv6ipaddr': '2001:db8:dead:c0::3',
                'ipv6netmask': '64',
                'ipv6gateway': '2001:db8:dead:c0::1',
                'noifupdown': True,
                },
            'get_interface': odict([('eth18', odict([('enabled', True), ('data', odict([
                ('inet', odict([
                    ('addrfam', 'inet'),
                    ('proto', 'dhcp'),
                    ('filename', None),
                    ])),
                ('inet6', odict([
                    ('addrfam', 'inet6'),
                    ('proto', 'static'),
                    ('filename', None),
                    ('address', '2001:db8:dead:c0::3'),
                    ('netmask', 64),
                    ('gateway', '2001:db8:dead:c0::1'),
                    ])),
                ]))]))]),
            'return': [
                'auto eth18\n',
                'iface eth18 inet dhcp\n',
                'iface eth18 inet6 static\n',
                '    address 2001:db8:dead:c0::3\n',
                '    netmask 64\n',
                '    gateway 2001:db8:dead:c0::1\n',
                '\n']},

        # IPv4=DHCP; IPv6=Static; without IPv6 netmask
        {'iface_name': 'eth19', 'iface_type': 'eth', 'enabled': True,
            'build_interface': {
                'proto': 'dhcp',
                'enable_ipv6': True,
                'ipv6proto': 'static',
                'ipv6ipaddr': '2001:db8:dead:c0::3/64',
                'ipv6gateway': '2001:db8:dead:c0::1',
                'noifupdown': True,
                },
            'get_interface': odict([('eth19', odict([('enabled', True), ('data', odict([
                ('inet', odict([
                    ('addrfam', 'inet'),
                    ('proto', 'dhcp'),
                    ('filename', None),
                    ])),
                ('inet6', odict([
                    ('addrfam', 'inet6'),
                    ('proto', 'static'),
                    ('filename', None),
                    ('address', '2001:db8:dead:c0::3/64'),
                    ('gateway', '2001:db8:dead:c0::1'),
                    ])),
                ]))]))]),
            'return': [
                'auto eth19\n',
                'iface eth19 inet dhcp\n',
                'iface eth19 inet6 static\n',
                '    address 2001:db8:dead:c0::3/64\n',
                '    gateway 2001:db8:dead:c0::1\n',
                '\n']},

        # IPv6-only; static with autoconf and accept_ra forced
        {'iface_name': 'eth20', 'iface_type': 'eth', 'enabled': True,
            'build_interface': {
                'ipv6proto': 'static',
                'ipv6ipaddr': '2001:db8:dead:beef::3/64',
                'ipv6gateway': '2001:db8:dead:beef::1',
                'enable_ipv6': True,
                'autoconf': 1,
                'accept_ra': 2,
                'noifupdown': True,
                },
            'get_interface': odict([('eth20', odict([('enabled', True), ('data', odict([
                ('inet6', odict([
                    ('addrfam', 'inet6'),
                    ('proto', 'static'),
                    ('filename', None),
                    ('autoconf', 1),
                    ('address', '2001:db8:dead:beef::3/64'),
                    ('gateway', '2001:db8:dead:beef::1'),
                    ('accept_ra', 2),
                    ])),
                ]))]))]),
            'return': [
                'auto eth20\n',
                'iface eth20 inet6 static\n',
                '    autoconf 1\n',
                '    address 2001:db8:dead:beef::3/64\n',
                '    gateway 2001:db8:dead:beef::1\n',
                '    accept_ra 2\n',
                '\n']},
        ]
# fmt: on


@skipIf(salt.utils.platform.is_windows(), &quot;Do not run these tests on Windows&quot;)
class DebianIpTestCase(TestCase, LoaderModuleMockMixin):
    &quot;&quot;&quot;
    Test cases for salt.modules.debian_ip
    &quot;&quot;&quot;

    def setup_loader_modules(self):
        return {debian_ip: {}}

    # 'build_bond' function tests: 3

    def test_build_bond(self):
        &quot;&quot;&quot;
        Test if it create a bond script in /etc/modprobe.d with the passed
        settings and load the bonding kernel module.
        &quot;&quot;&quot;
<A NAME="0"></A>        with patch(
            &quot;salt.modules.debian_ip._parse_settings_bond&quot;, MagicMock(return_value={})
        ), patch(&quot;salt.modules.debian_ip._write_file&quot;, MagicMock(return_value=True)):
            mock <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match49909-1.html#0',3,'match49909-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>= MagicMock(return_value=1)
            with patch.dict(debian_ip.__grains__, {&quot;osrelease&quot;: mock}):
                mock = MagicMock(return_value=True)
                with patch.dict(
                    debian_ip.__salt__, {&quot;kmod.load&quot;</B></FONT>: mock, &quot;pkg.install&quot;: mock}
                ):
                    self.assertEqual(debian_ip.build_bond(&quot;bond0&quot;), &quot;&quot;)

    def test_error_message_iface_should_process_non_str_expected(self):
        values = [1, True, False, &quot;no-kaboom&quot;]
        iface = &quot;ethtest&quot;
        option = &quot;test&quot;
        msg = debian_ip._error_msg_iface(iface, option, values)
        self.assertTrue(msg.endswith(&quot;[1|True|False|no-kaboom]&quot;), msg)

    def test_error_message_network_should_process_non_str_expected(self):
        values = [1, True, False, &quot;no-kaboom&quot;]
        msg = debian_ip._error_msg_network(&quot;fnord&quot;, values)
        self.assertTrue(msg.endswith(&quot;[1|True|False|no-kaboom]&quot;), msg)

    def test_build_bond_exception(self):
        &quot;&quot;&quot;
        Test if it create a bond script in /etc/modprobe.d with the passed
        settings and load the bonding kernel module.
        &quot;&quot;&quot;
        with patch(
            &quot;salt.modules.debian_ip._parse_settings_bond&quot;, MagicMock(return_value={})
        ):
            mock = MagicMock(return_value=1)
            with patch.dict(debian_ip.__grains__, {&quot;osrelease&quot;: mock}):
                mock = MagicMock(
                    side_effect=jinja2.exceptions.TemplateNotFound(&quot;error&quot;)
                )
                with patch.object(jinja2.Environment, &quot;get_template&quot;, mock):
                    self.assertEqual(debian_ip.build_bond(&quot;bond0&quot;), &quot;&quot;)

    def test_build_bond_data(self):
        &quot;&quot;&quot;
        Test if it create a bond script in /etc/modprobe.d with the passed
        settings and load the bonding kernel module.
        &quot;&quot;&quot;
        with patch(
            &quot;salt.modules.debian_ip._parse_settings_bond&quot;, MagicMock(return_value={})
        ), patch(&quot;salt.modules.debian_ip._read_temp&quot;, MagicMock(return_value=True)):
            mock = MagicMock(return_value=1)
            with patch.dict(debian_ip.__grains__, {&quot;osrelease&quot;: mock}):
                self.assertTrue(debian_ip.build_bond(&quot;bond0&quot;, test=&quot;True&quot;))

    # 'build_routes' function tests: 2

    def test_build_routes(self):
        &quot;&quot;&quot;
        Test if it add route scripts for a network interface using up commands.
        &quot;&quot;&quot;
        with patch(
            &quot;salt.modules.debian_ip._parse_routes&quot;,
            MagicMock(return_value={&quot;routes&quot;: []}),
        ), patch(
            &quot;salt.modules.debian_ip._write_file_routes&quot;, MagicMock(return_value=True)
        ), patch(
            &quot;salt.modules.debian_ip._read_file&quot;, MagicMock(return_value=&quot;salt&quot;)
        ):
            self.assertEqual(debian_ip.build_routes(&quot;eth0&quot;), &quot;saltsalt&quot;)

    def test_build_routes_exception(self):
        &quot;&quot;&quot;
        Test if it add route scripts for a network interface using up commands.
        &quot;&quot;&quot;
        with patch(
            &quot;salt.modules.debian_ip._parse_routes&quot;,
            MagicMock(return_value={&quot;routes&quot;: []}),
        ):
            self.assertTrue(debian_ip.build_routes(&quot;eth0&quot;, test=&quot;True&quot;))

            mock = MagicMock(side_effect=jinja2.exceptions.TemplateNotFound(&quot;err&quot;))
            with patch.object(jinja2.Environment, &quot;get_template&quot;, mock):
                self.assertEqual(debian_ip.build_routes(&quot;eth0&quot;), &quot;&quot;)

    # 'down' function tests: 1

    def test_down(self):
        &quot;&quot;&quot;
        Test if it shutdown a network interface
        &quot;&quot;&quot;
        self.assertEqual(debian_ip.down(&quot;eth0&quot;, &quot;slave&quot;), None)

        mock = MagicMock(return_value=&quot;Salt&quot;)
        with patch.dict(debian_ip.__salt__, {&quot;cmd.run&quot;: mock}):
            self.assertEqual(debian_ip.down(&quot;eth0&quot;, &quot;eth&quot;), &quot;Salt&quot;)

    # 'get_bond' function tests: 1

    def test_get_bond(self):
        &quot;&quot;&quot;
        Test if it return the content of a bond script
        &quot;&quot;&quot;
        self.assertEqual(debian_ip.get_bond(&quot;bond0&quot;), &quot;&quot;)

    # '_parse_interfaces' function tests: 1

    def test_parse_interfaces(self):
        &quot;&quot;&quot;
        Test if it returns the correct data for parsed configuration file
        &quot;&quot;&quot;
        with tempfile.NamedTemporaryFile(mode=&quot;r&quot;, delete=True) as tfile:
            for iface in test_interfaces:
                iname = iface[&quot;iface_name&quot;]
                if iface.get(&quot;skip_test&quot;, False):
                    continue
                with salt.utils.files.fopen(str(tfile.name), &quot;w&quot;) as fh:
                    fh.writelines(iface[&quot;return&quot;])
                for inet in [&quot;inet&quot;, &quot;inet6&quot;]:
                    if inet in iface[&quot;get_interface&quot;][iname][&quot;data&quot;]:
                        iface[&quot;get_interface&quot;][iname][&quot;data&quot;][inet][&quot;filename&quot;] = str(
                            tfile.name
                        )
                self.assertDictEqual(
                    debian_ip._parse_interfaces([str(tfile.name)]),
                    iface[&quot;get_interface&quot;],
                )

    # 'get_interface' function tests: 1

    def test_get_interface(self):
        &quot;&quot;&quot;
        Test if it return the contents of an interface script
        &quot;&quot;&quot;
        for iface in test_interfaces:
            if iface.get(&quot;skip_test&quot;, False):
                continue
            with patch.object(
                debian_ip,
                &quot;_parse_interfaces&quot;,
                MagicMock(return_value=iface[&quot;get_interface&quot;]),
            ):
                self.assertListEqual(
                    debian_ip.get_interface(iface[&quot;iface_name&quot;]), iface[&quot;return&quot;]
                )

    # 'build_interface' function tests: 1

    def test_build_interface(self):
        &quot;&quot;&quot;
        Test if it builds an interface script for a network interface.
        &quot;&quot;&quot;
        with patch(
            &quot;salt.modules.debian_ip._write_file_ifaces&quot;, MagicMock(return_value=&quot;salt&quot;)
        ):
            self.assertEqual(
                debian_ip.build_interface(&quot;eth0&quot;, &quot;eth&quot;, &quot;enabled&quot;),
                [&quot;s\n&quot;, &quot;a\n&quot;, &quot;l\n&quot;, &quot;t\n&quot;],
            )

            self.assertTrue(
                debian_ip.build_interface(&quot;eth0&quot;, &quot;eth&quot;, &quot;enabled&quot;, test=&quot;True&quot;)
            )

            with patch.object(
                debian_ip, &quot;_parse_settings_eth&quot;, MagicMock(return_value={&quot;routes&quot;: []})
            ):
                for eth_t in [&quot;bridge&quot;, &quot;slave&quot;, &quot;bond&quot;]:
                    self.assertRaises(
                        AttributeError,
                        debian_ip.build_interface,
                        &quot;eth0&quot;,
                        eth_t,
                        &quot;enabled&quot;,
                    )

            self.assertTrue(
                debian_ip.build_interface(&quot;eth0&quot;, &quot;eth&quot;, &quot;enabled&quot;, test=&quot;True&quot;)
            )

        with tempfile.NamedTemporaryFile(mode=&quot;r&quot;, delete=True) as tfile:
            with patch(&quot;salt.modules.debian_ip._DEB_NETWORK_FILE&quot;, str(tfile.name)):
                for iface in test_interfaces:
                    if iface.get(&quot;skip_test&quot;, False):
                        continue
                    # Skip tests that require __salt__['pkg.install']()
                    if iface[&quot;iface_type&quot;] in [&quot;bridge&quot;, &quot;pppoe&quot;, &quot;vlan&quot;]:
                        continue
                    self.assertListEqual(
                        debian_ip.build_interface(
                            iface=iface[&quot;iface_name&quot;],
                            iface_type=iface[&quot;iface_type&quot;],
                            enabled=iface[&quot;enabled&quot;],
                            interface_file=tfile.name,
                            **iface[&quot;build_interface&quot;]
                        ),
                        iface[&quot;return&quot;],
                    )

    # 'up' function tests: 1

    def test_up(self):
        &quot;&quot;&quot;
        Test if it start up a network interface
        &quot;&quot;&quot;
        self.assertEqual(debian_ip.down(&quot;eth0&quot;, &quot;slave&quot;), None)

        mock = MagicMock(return_value=&quot;Salt&quot;)
        with patch.dict(debian_ip.__salt__, {&quot;cmd.run&quot;: mock}):
            self.assertEqual(debian_ip.up(&quot;eth0&quot;, &quot;eth&quot;), &quot;Salt&quot;)

    # 'get_network_settings' function tests: 1

    def test_get_network_settings(self):
        &quot;&quot;&quot;
        Test if it return the contents of the global network script.
        &quot;&quot;&quot;
        with patch.dict(
            debian_ip.__grains__, {&quot;osfullname&quot;: &quot;Ubuntu&quot;, &quot;osrelease&quot;: &quot;14&quot;}
        ), patch(
            &quot;salt.modules.debian_ip._parse_hostname&quot;,
            MagicMock(return_value=&quot;SaltStack&quot;),
        ), patch(
            &quot;salt.modules.debian_ip._parse_domainname&quot;,
            MagicMock(return_value=&quot;saltstack.com&quot;),
        ):
            mock_avai = MagicMock(return_value=True)
            with patch.dict(
                debian_ip.__salt__,
                {&quot;service.available&quot;: mock_avai, &quot;service.status&quot;: mock_avai},
            ):
                self.assertEqual(
                    debian_ip.get_network_settings(),
                    [
                        &quot;NETWORKING=yes\n&quot;,
                        &quot;HOSTNAME=SaltStack\n&quot;,
                        &quot;DOMAIN=saltstack.com\n&quot;,
                    ],
                )

                mock = MagicMock(
                    side_effect=jinja2.exceptions.TemplateNotFound(&quot;error&quot;)
                )
                with patch.object(jinja2.Environment, &quot;get_template&quot;, mock):
                    self.assertEqual(debian_ip.get_network_settings(), &quot;&quot;)

    # 'get_routes' function tests: 1

    def test_get_routes(self):
        &quot;&quot;&quot;
        Test if it return the routes for the interface
        &quot;&quot;&quot;
        with patch(&quot;salt.modules.debian_ip._read_file&quot;, MagicMock(return_value=&quot;salt&quot;)):
            self.assertEqual(debian_ip.get_routes(&quot;eth0&quot;), &quot;saltsalt&quot;)

    # 'apply_network_settings' function tests: 1

    @pytest.mark.slow_test
    def test_apply_network_settings(self):
        &quot;&quot;&quot;
        Test if it apply global network configuration.
        &quot;&quot;&quot;
        mock = MagicMock(return_value=True)
        with patch.dict(
            debian_ip.__salt__,
            {&quot;network.mod_hostname&quot;: mock, &quot;service.stop&quot;: mock, &quot;service.start&quot;: mock},
        ):
            self.assertEqual(debian_ip.apply_network_settings(), True)

    # 'build_network_settings' function tests: 1

    def test_build_network_settings(self):
        &quot;&quot;&quot;
        Test if it build the global network script.
        &quot;&quot;&quot;
        with patch(
            &quot;salt.modules.debian_ip._parse_network_settings&quot;,
            MagicMock(
                return_value={
                    &quot;networking&quot;: &quot;yes&quot;,
                    &quot;hostname&quot;: &quot;Salt.saltstack.com&quot;,
                    &quot;domainname&quot;: &quot;saltstack.com&quot;,
                    &quot;search&quot;: &quot;test.saltstack.com&quot;,
                }
            ),
<A NAME="2"></A>        ), patch(
            &quot;salt.modules.debian_ip._write_file_network&quot;, MagicMock(return_value=True)
        ):
            <FONT color="#980517"><A HREF="javascript:ZweiFrames('match49909-1.html#2',3,'match49909-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>with patch.dict(
                debian_ip.__grains__, {&quot;osfullname&quot;: &quot;Ubuntu&quot;, &quot;osrelease&quot;: &quot;14&quot;}
            ):
                mock = MagicMock(return_value=True)
                with patch.dict(
                    debian_ip.__salt__,
                    {
                        &quot;service.available&quot;</B></FONT>: mock,
                        &quot;service.disable&quot;: mock,
                        &quot;service.enable&quot;: mock,
                    },
                ):
                    self.assertEqual(
                        debian_ip.build_network_settings(),
                        [
                            &quot;NETWORKING=yes\n&quot;,
                            &quot;HOSTNAME=Salt\n&quot;,
                            &quot;DOMAIN=saltstack.com\n&quot;,
                            &quot;SEARCH=test.saltstack.com\n&quot;,
                        ],
                    )

                    mock = MagicMock(
                        side_effect=jinja2.exceptions.TemplateNotFound(&quot;error&quot;)
                    )
<A NAME="1"></A>                    with patch.object(jinja2.Environment, &quot;get_template&quot;, mock):
                        self.assertEqual(debian_ip.build_network_settings(), &quot;&quot;)

            <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match49909-1.html#1',3,'match49909-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>with patch.dict(
                debian_ip.__grains__, {&quot;osfullname&quot;: &quot;Ubuntu&quot;, &quot;osrelease&quot;: &quot;10&quot;}
            ):
                mock = MagicMock(return_value=True)
                with patch.dict(
                    debian_ip.__salt__,
                    {
                        &quot;service.available&quot;</B></FONT>: mock,
                        &quot;service.disable&quot;: mock,
                        &quot;service.enable&quot;: mock,
                    },
                ):
                    mock = MagicMock(
                        side_effect=jinja2.exceptions.TemplateNotFound(&quot;error&quot;)
                    )
                    with patch.object(jinja2.Environment, &quot;get_template&quot;, mock):
                        self.assertEqual(debian_ip.build_network_settings(), &quot;&quot;)

                    with patch.object(
                        debian_ip, &quot;_read_temp&quot;, MagicMock(return_value=True)
                    ):
                        self.assertTrue(debian_ip.build_network_settings(test=&quot;True&quot;))
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_sysctl.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
    :codeauthor: Jayesh Kariya &lt;jayeshk@saltstack.com&gt;
&quot;&quot;&quot;

import pytest
import salt.states.sysctl as sysctl
from salt.exceptions import CommandExecutionError
from tests.support.mock import MagicMock, patch


@pytest.fixture
def configure_loader_modules():
    return {sysctl: {}}


def test_empty_config_file_and_value_not_found():
    &quot;&quot;&quot;
    Test sysctl.present for an unknown sysctl, not present in config file
    &quot;&quot;&quot;
    name = &quot;some.unknown.oid&quot;
    value = &quot;1&quot;
    comment = &quot;Sysctl option {} would be changed to {}&quot;.format(name, value)

<A NAME="0"></A>    ret = {&quot;name&quot;: name, &quot;result&quot;: None, &quot;changes&quot;: {}, &quot;comment&quot;: comment}

    with patch.dict(sysctl.__opts__, {&quot;test&quot;: True}):
        mock_show <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49909-0.html#0',2,'match49909-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>= MagicMock(return_value={})
        with patch.dict(sysctl.__salt__, {&quot;sysctl.show&quot;: mock_show}):
            mock_get = MagicMock(return_value=&quot;&quot;)
            with patch.dict(sysctl.__salt__, {&quot;sysctl.get&quot;</B></FONT>: mock_get}):
                assert sysctl.present(name, value) == ret


def test_inaccessible_config_file():
    &quot;&quot;&quot;
    Test sysctl.present with a config file that cannot be opened
    &quot;&quot;&quot;
    name = &quot;some.unknown.oid&quot;
    value = &quot;1&quot;
    config = &quot;/etc/sysctl.conf&quot;
    comment = (
        &quot;Sysctl option {} might be changed, we failed to check &quot;
        &quot;config file at {}. The file is either unreadable, or &quot;
        &quot;missing.&quot;.format(name, config)
<A NAME="2"></A>    )
    ret = {&quot;name&quot;: name, &quot;result&quot;: None, &quot;changes&quot;: {}, &quot;comment&quot;: comment}

    <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49909-0.html#2',2,'match49909-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>with patch.dict(sysctl.__opts__, {&quot;test&quot;: True}):
        mock = MagicMock(return_value=None)
        with patch.dict(sysctl.__salt__, {&quot;sysctl.show&quot;</B></FONT>: mock}):
            assert sysctl.present(name, value) == ret


def test_to_be_changed_not_configured():
    &quot;&quot;&quot;
    Test sysctl.present for a sysctl that isn't in the config file and must
    be changed.
    &quot;&quot;&quot;
    name = &quot;vfs.usermount&quot;
    value = &quot;1&quot;
    comment = &quot;Sysctl option {} set to be changed to {}&quot;.format(name, value)
    ret = {&quot;name&quot;: name, &quot;result&quot;: None, &quot;changes&quot;: {}, &quot;comment&quot;: comment}

    def mock_current(config_file=None):
        &quot;&quot;&quot;
        Mock return value for __salt__.
        &quot;&quot;&quot;
        if config_file is None:
            return {name: &quot;0&quot;}
<A NAME="1"></A>        return {}

    with patch.dict(sysctl.__opts__, {&quot;test&quot;: True}):
        <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match49909-0.html#1',2,'match49909-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>with patch.dict(sysctl.__salt__, {&quot;sysctl.show&quot;: mock_current}):
            mock_get = MagicMock(return_value=&quot;0&quot;)
            with patch.dict(sysctl.__salt__, {&quot;sysctl.get&quot;</B></FONT>: mock_get}):
                assert sysctl.present(name, value) == ret


def test_not_to_be_changed_not_configured():
    &quot;&quot;&quot;
    Test sysctl.present for a sysctl that isn't in the config file but
    already has the correct value
    &quot;&quot;&quot;
    name = &quot;some.unknown.oid&quot;
    value = &quot;1&quot;
    comment = (
        &quot;Sysctl value is currently set on the running system but &quot;
        &quot;not in a config file. Sysctl option {} set to be &quot;
        &quot;changed to 1 in config file.&quot;.format(name)
    )

    ret = {&quot;name&quot;: name, &quot;result&quot;: None, &quot;changes&quot;: {}, &quot;comment&quot;: comment}

    def mock_current(config_file=None):
        if config_file is None:
            return {name: value}
        return {}

    with patch.dict(sysctl.__opts__, {&quot;test&quot;: True}):
        with patch.dict(sysctl.__salt__, {&quot;sysctl.show&quot;: mock_current}):
            mock_get = MagicMock(return_value=value)
            with patch.dict(sysctl.__salt__, {&quot;sysctl.get&quot;: mock_get}):
                assert sysctl.present(name, value) == ret


def test_configured_but_unknown():
    &quot;&quot;&quot;
    Test sysctl.present for a sysctl that is already configured but is
    not known by the system.  For example, a sysctl used by a kernel module
    that isn't loaded.
    &quot;&quot;&quot;
    name = &quot;vfs.usermount&quot;
    value = &quot;1&quot;
    comment = (
        &quot;Sysctl value {0} is present in configuration file but is not &quot;
        &quot;present in the running config. The value {0} is set to be &quot;
        &quot;changed to {1}&quot;.format(name, value)
    )
    ret = {&quot;name&quot;: name, &quot;result&quot;: None, &quot;changes&quot;: {}, &quot;comment&quot;: comment}

    def mock_config(config_file=None):
        if config_file is None:
            return {}
        return {name: value}

    with patch.dict(sysctl.__opts__, {&quot;test&quot;: True}):
        with patch.dict(sysctl.__salt__, {&quot;sysctl.show&quot;: mock_config}):
            mock_get = MagicMock(return_value=&quot;&quot;)
            with patch.dict(sysctl.__salt__, {&quot;sysctl.get&quot;: mock_get}):
                assert sysctl.present(name, value) == ret


def test_no_change():
    &quot;&quot;&quot;
    Test sysctl.present for an already-configured value
    &quot;&quot;&quot;
    name = &quot;vfs.usermount&quot;
    value = &quot;1&quot;
    comment = &quot;Sysctl value {} = {} is already set&quot;.format(name, value)
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;changes&quot;: {}, &quot;comment&quot;: comment}

    def mock_config(config_file=None):
        if config_file is None:
            return {}
        return {name: value}

    with patch.dict(sysctl.__opts__, {&quot;test&quot;: True}):
        with patch.dict(sysctl.__salt__, {&quot;sysctl.show&quot;: mock_config}):
            mock_get = MagicMock(return_value=value)
            with patch.dict(sysctl.__salt__, {&quot;sysctl.get&quot;: mock_get}):
                assert sysctl.present(name, value) == ret


def test_change():
    &quot;&quot;&quot;
    Test sysctl.present for a value whose configuration must change
    &quot;&quot;&quot;
    name = &quot;vfs.usermount&quot;
    old_value = &quot;2&quot;
    value = &quot;1&quot;
    comment = &quot;Sysctl option {} would be changed to {}&quot;.format(name, value)
    ret = {&quot;name&quot;: name, &quot;result&quot;: None, &quot;changes&quot;: {}, &quot;comment&quot;: comment}

    def mock_config(config_file=None):
        if config_file is None:
            return {name: old_value}
        return {name: old_value}

    with patch.dict(sysctl.__opts__, {&quot;test&quot;: True}):
        with patch.dict(sysctl.__salt__, {&quot;sysctl.show&quot;: mock_config}):
            mock_get = MagicMock(return_value=old_value)
            with patch.dict(sysctl.__salt__, {&quot;sysctl.get&quot;: mock_get}):
                assert sysctl.present(name, value) == ret


def test_failed_to_set():
    &quot;&quot;&quot;
    Test sysctl.present when the sysctl command fails to change a value
    &quot;&quot;&quot;
    name = &quot;net.isr.maxthreads&quot;
    value = &quot;8&quot;
    comment = &quot;Failed to set {} to {}: &quot;.format(name, value)
    ret = {&quot;name&quot;: name, &quot;result&quot;: False, &quot;changes&quot;: {}, &quot;comment&quot;: comment}

    with patch.dict(sysctl.__opts__, {&quot;test&quot;: False}):
        mock = MagicMock(side_effect=CommandExecutionError)
        with patch.dict(sysctl.__salt__, {&quot;sysctl.persist&quot;: mock}):
            assert sysctl.present(name, value) == ret


def test_already_set():
    &quot;&quot;&quot;
    Test sysctl.present when the value is already set
    &quot;&quot;&quot;
    name = &quot;vfs.usermount&quot;
    value = &quot;1&quot;
    comment = &quot;Sysctl value {} = {} is already set&quot;.format(name, value)
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;changes&quot;: {}, &quot;comment&quot;: comment}
    with patch.dict(sysctl.__opts__, {&quot;test&quot;: False}):
        mock = MagicMock(return_value=&quot;Already set&quot;)
        with patch.dict(sysctl.__salt__, {&quot;sysctl.persist&quot;: mock}):
            assert sysctl.present(name, value) == ret


def test_updated():
    &quot;&quot;&quot;
    Test sysctl.present when the value is not already set
    &quot;&quot;&quot;
    name = &quot;vfs.usermount&quot;
    value = &quot;1&quot;
    comment = &quot;Updated sysctl value {} = {}&quot;.format(name, value)
    changes = {name: value}
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;changes&quot;: changes, &quot;comment&quot;: comment}
    with patch.dict(sysctl.__opts__, {&quot;test&quot;: False}):
        mock = MagicMock(return_value=&quot;Updated&quot;)
        with patch.dict(sysctl.__salt__, {&quot;sysctl.persist&quot;: mock}):
            assert sysctl.present(name, value) == ret
</PRE>
</div>
  </div>
</body>
</html>
