<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for __init___3.py &amp; test_salt_key.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for __init___3.py &amp; test_salt_key.py
      </h3>
<h1 align="center">
        3.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>__init___3.py (3.4188035%)<th>test_salt_key.py (3.02267%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(14-25)<td><a href="#" name="0">(1-14)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>__init___3.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
Make api awesomeness
"""
import copy
import inspect
import logging
import os
import salt.client
import salt.client.ssh.client
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import salt.config
import salt.daemons.masterapi
import salt.exceptions
import salt.log  # pylint: disable=W0611
import salt.runner
import salt.syspaths
import salt.utils.args
import salt.utils.minions
import salt.wheel
from salt.defaults import DEFAULT_TARGET_DELIM
log = logging.</b></font>getLogger(__name__)
class NetapiClient:
    """
    Provide a uniform method of accessing the various client interfaces in Salt
    in the form of low-data data structures. For example:
    &gt;&gt;&gt; client = NetapiClient(__opts__)
    &gt;&gt;&gt; lowstate = {'client': 'local', 'tgt': '*', 'fun': 'test.ping', 'arg': ''}
    &gt;&gt;&gt; client.run(lowstate)
    """
    def __init__(self, opts):
        self.opts = opts
        apiopts = copy.deepcopy(self.opts)
        apiopts["enable_ssh_minions"] = True
        apiopts["cachedir"] = os.path.join(opts["cachedir"], "saltapi")
        if not os.path.exists(apiopts["cachedir"]):
            os.makedirs(apiopts["cachedir"])
        self.resolver = salt.auth.Resolver(apiopts)
        self.loadauth = salt.auth.LoadAuth(apiopts)
        self.key = salt.daemons.masterapi.access_keys(apiopts)
        self.ckminions = salt.utils.minions.CkMinions(apiopts)
    def _is_master_running(self):
        """
        Perform a lightweight check to see if the master daemon is running
        Note, this will return an invalid success if the master crashed or was
        not shut down cleanly.
        """
        if salt.utils.platform.is_windows():
            return True
        if self.opts["transport"] == "tcp":
            ipc_file = "publish_pull.ipc"
        else:
            ipc_file = "workers.ipc"
        return os.path.exists(os.path.join(self.opts["sock_dir"], ipc_file))
    def _prep_auth_info(self, clear_load):
        sensitive_load_keys = []
        key = None
        if "token" in clear_load:
            auth_type = "token"
            err_name = "TokenAuthenticationError"
            sensitive_load_keys = ["token"]
            return auth_type, err_name, key, sensitive_load_keys
        elif "eauth" in clear_load:
            auth_type = "eauth"
            err_name = "EauthAuthenticationError"
            sensitive_load_keys = ["username", "password"]
            return auth_type, err_name, key, sensitive_load_keys
        raise salt.exceptions.EauthAuthenticationError(
            "No authentication credentials given"
        )
    def _authorize_ssh(self, low):
        auth_type, err_name, key, sensitive_load_keys = self._prep_auth_info(low)
        auth_check = self.loadauth.check_authentication(low, auth_type, key=key)
        auth_list = auth_check.get("auth_list", [])
        error = auth_check.get("error")
        if error:
            raise salt.exceptions.EauthAuthenticationError(error)
        delimiter = low.get("kwargs", {}).get("delimiter", DEFAULT_TARGET_DELIM)
        _res = self.ckminions.check_minions(
            low["tgt"], low.get("tgt_type", "glob"), delimiter
        )
        minions = _res.get("minions", list())
        missing = _res.get("missing", list())
        authorized = self.ckminions.auth_check(
            auth_list,
            low["fun"],
            low.get("arg", []),
            low["tgt"],
            low.get("tgt_type", "glob"),
            minions=minions,
        )
        if not authorized:
            raise salt.exceptions.EauthAuthenticationError(
                "Authorization error occurred."
            )
    def run(self, low):
        """
        Execute the specified function in the specified client by passing the
        lowstate
        """
        if not self._is_master_running():
            raise salt.exceptions.SaltDaemonNotRunning("Salt Master is not available.")
        if low.get("client") not in CLIENTS:
            raise salt.exceptions.SaltInvocationError(
                "Invalid client specified: '{}'".format(low.get("client"))
            )
        if not ("token" in low or "eauth" in low):
            raise salt.exceptions.EauthAuthenticationError(
                "No authentication credentials given"
            )
        if low.get("raw_shell") and not self.opts.get("netapi_allow_raw_shell"):
            raise salt.exceptions.EauthAuthenticationError(
                "Raw shell option not allowed."
            )
        if low["client"] == "ssh":
            self._authorize_ssh(low)
        l_fun = getattr(self, low["client"])
        f_call = salt.utils.args.format_call(l_fun, low)
        return l_fun(*f_call.get("args", ()), **f_call.get("kwargs", {}))
    def local_async(self, *args, **kwargs):
        """
        Run :ref:`execution modules &lt;all-salt.modules&gt;` asynchronously
        Wraps :py:meth:`salt.client.LocalClient.run_job`.
        :return: job ID
        """
        with salt.client.get_local_client(mopts=self.opts) as client:
            return client.run_job(*args, **kwargs)
    def local(self, *args, **kwargs):
        """
        Run :ref:`execution modules &lt;all-salt.modules&gt;` synchronously
        See :py:meth:`salt.client.LocalClient.cmd` for all available
        parameters.
        Sends a command from the master to the targeted minions. This is the
        same interface that Salt's own CLI uses. Note the ``arg`` and ``kwarg``
        parameters are sent down to the minion(s) and the given function,
        ``fun``, is called with those parameters.
        :return: Returns the result from the execution module
        """
        with salt.client.get_local_client(mopts=self.opts) as client:
            return client.cmd(*args, **kwargs)
    def local_subset(self, *args, **kwargs):
        """
        Run :ref:`execution modules &lt;all-salt.modules&gt;` against subsets of minions
        .. versionadded:: 2016.3.0
        Wraps :py:meth:`salt.client.LocalClient.cmd_subset`
        """
        with salt.client.get_local_client(mopts=self.opts) as client:
            return client.cmd_subset(*args, **kwargs)
    def local_batch(self, *args, **kwargs):
        """
        Run :ref:`execution modules &lt;all-salt.modules&gt;` against batches of minions
        .. versionadded:: 0.8.4
        Wraps :py:meth:`salt.client.LocalClient.cmd_batch`
        :return: Returns the result from the exeuction module for each batch of
            returns
        """
        with salt.client.get_local_client(mopts=self.opts) as client:
            return client.cmd_batch(*args, **kwargs)
    def ssh(self, *args, **kwargs):
        """
        Run salt-ssh commands synchronously
        Wraps :py:meth:`salt.client.ssh.client.SSHClient.cmd_sync`.
        :return: Returns the result from the salt-ssh command
        """
        with salt.client.ssh.client.SSHClient(
            mopts=self.opts, disable_custom_roster=True
        ) as client:
            return client.cmd_sync(kwargs)
    def runner(self, fun, timeout=None, full_return=False, **kwargs):
        """
        Run `runner modules &lt;all-salt.runners&gt;` synchronously
        Wraps :py:meth:`salt.runner.RunnerClient.cmd_sync`.
        Note that runner functions must be called using keyword arguments.
        Positional arguments are not supported.
        :return: Returns the result from the runner module
        """
        kwargs["fun"] = fun
        runner = salt.runner.RunnerClient(self.opts)
        return runner.cmd_sync(kwargs, timeout=timeout, full_return=full_return)
    def runner_async(self, fun, **kwargs):
        """
        Run `runner modules &lt;all-salt.runners&gt;` asynchronously
        Wraps :py:meth:`salt.runner.RunnerClient.cmd_async`.
        Note that runner functions must be called using keyword arguments.
        Positional arguments are not supported.
        :return: event data and a job ID for the executed function.
        """
        kwargs["fun"] = fun
        runner = salt.runner.RunnerClient(self.opts)
        return runner.cmd_async(kwargs)
    def wheel(self, fun, **kwargs):
        """
        Run :ref:`wheel modules &lt;all-salt.wheel&gt;` synchronously
        Wraps :py:meth:`salt.wheel.WheelClient.master_call`.
        Note that wheel functions must be called using keyword arguments.
        Positional arguments are not supported.
        :return: Returns the result from the wheel module
        """
        kwargs["fun"] = fun
        wheel = salt.wheel.WheelClient(self.opts)
        return wheel.cmd_sync(kwargs)
    def wheel_async(self, fun, **kwargs):
        """
        Run :ref:`wheel modules &lt;all-salt.wheel&gt;` asynchronously
        Wraps :py:meth:`salt.wheel.WheelClient.master_call`.
        Note that wheel functions must be called using keyword arguments.
        Positional arguments are not supported.
        :return: Returns the result from the wheel module
        """
        kwargs["fun"] = fun
        wheel = salt.wheel.WheelClient(self.opts)
        return wheel.cmd_async(kwargs)
CLIENTS = [
    name
    for name, _ in inspect.getmembers(NetapiClient, predicate=None)
    if not (name == "run" or name.startswith("_"))
]
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_salt_key.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import os
import re
import textwrap
import pytest
import salt.utils.files
import salt.utils.platform
import salt.utils.pycrypto
import salt.utils.yaml
from saltfactories.utils import random_string
pytestmark = [
    pytest</b></font>.mark.slow_test,
    pytest.mark.windows_whitelisted,
]
USERA = "saltdev-key"
USERA_PWD = "saltdev"
PUB_KEY = textwrap.dedent(
    """\
        -----BEGIN PUBLIC KEY-----
        MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAoqIZDtcQtqUNs0wC7qQz
        JwFhXAVNT5C8M8zhI+pFtF/63KoN5k1WwAqP2j3LquTG68WpxcBwLtKfd7FVA/Kr
        OF3kXDWFnDi+HDchW2lJObgfzLckWNRFaF8SBvFM2dys3CGSgCV0S/qxnRAjrJQb
        B3uQwtZ64ncJAlkYpArv3GwsfRJ5UUQnYPDEJwGzMskZ0pHd60WwM1gMlfYmNX5O
        RBEjybyNpYDzpda6e6Ypsn6ePGLkP/tuwUf+q9wpbRE3ZwqERC2XRPux+HX2rGP+
        mkzpmuHkyi2wV33A9pDfMgRHdln2CLX0KgfRGixUQhW1o+Kmfv2rq4sGwpCgLbTh
        NwIDAQAB
        -----END PUBLIC KEY-----
        """
)
@pytest.fixture(scope="module")
def saltdev_account(sminion):
    try:
        assert sminion.functions.user.add(USERA, createhome=False)
        assert sminion.functions.shadow.set_password(
            USERA,
            USERA_PWD
            if salt.utils.platform.is_darwin()
            else salt.utils.pycrypto.gen_hash(password=USERA_PWD),
        )
        assert USERA in sminion.functions.user.list_users()
        yield
    finally:
        sminion.functions.user.delete(USERA, remove=True)
def test_remove_key(salt_master, salt_key_cli):
    """
    test salt-key -d usage
    """
    min_name = random_string("minibar-")
    pki_dir = salt_master.config["pki_dir"]
    key = os.path.join(pki_dir, "minions", min_name)
    with salt.utils.files.fopen(key, "w") as fp:
        fp.write(PUB_KEY)
    try:
        ret = salt_key_cli.run("-p", min_name)
        assert ret.exitcode == 0
        assert "minions" in ret.json
        assert min_name in ret.json["minions"]
        assert "-----BEGIN PUBLIC KEY-----" in ret.json["minions"][min_name]
        ret = salt_key_cli.run("-d", min_name, "-y")
        assert ret.exitcode == 0
        assert "minions" in ret.stdout
        assert min_name in ret.stdout
        ret = salt_key_cli.run("-p", min_name)
        assert ret.exitcode == 0
        assert ret.json == {}
    finally:
        if os.path.exists(key):
            os.unlink(key)
@pytest.mark.skip_if_not_root
@pytest.mark.destructive_test
@pytest.mark.skip_on_windows(reason="PAM is not supported on Windows")
def test_remove_key_eauth(salt_key_cli, salt_master, saltdev_account):
    """
    test salt-key -d usage
    """
    min_name = random_string("minibar-")
    pki_dir = salt_master.config["pki_dir"]
    key = os.path.join(pki_dir, "minions", min_name)
    with salt.utils.files.fopen(key, "w") as fp:
        fp.write(PUB_KEY)
    try:
        ret = salt_key_cli.run("-p", min_name)
        assert ret.exitcode == 0
        assert "minions" in ret.json
        assert min_name in ret.json["minions"]
        assert "-----BEGIN PUBLIC KEY-----" in ret.json["minions"][min_name]
        ret = salt_key_cli.run(
            "-d",
            min_name,
            "-y",
            "--eauth",
            "pam",
            "--username",
            USERA,
            "--password",
            USERA_PWD,
        )
        assert ret.exitcode == 0
        assert "minions" in ret.stdout
        assert min_name in ret.stdout
        ret = salt_key_cli.run("-p", min_name)
        assert ret.exitcode == 0
        assert ret.json == {}
    finally:
        if os.path.exists(key):
            os.unlink(key)
@pytest.mark.parametrize("key_type", ("acc", "pre", "den", "un", "rej"))
def test_list_accepted_args(salt_key_cli, key_type):
    """
    test salt-key -l for accepted arguments
    """
    ret = salt_key_cli.run("-l", key_type)
    assert ret.exitcode == 0
    assert "error:" not in ret.stdout
    ret = salt_key_cli.run("-l", "foo-{}".format(key_type))
    assert ret.exitcode != 0
    assert "error:" in ret.stderr
def test_list_all(salt_key_cli, salt_minion, salt_sub_minion):
    """
    test salt-key -L
    """
    ret = salt_key_cli.run("-L")
    assert ret.exitcode == 0
    expected = {
        "minions_rejected": [],
        "minions_denied": [],
        "minions_pre": [],
        "minions": [salt_minion.id, salt_sub_minion.id],
    }
    assert ret.json == expected
def test_list_all_yaml_out(salt_key_cli, salt_minion, salt_sub_minion):
    """
    test salt-key -L --out=yaml
    """
    ret = salt_key_cli.run("-L", "--out=yaml")
    assert ret.exitcode == 0
    output = salt.utils.yaml.safe_load(ret.stdout)
    expected = {
        "minions_rejected": [],
        "minions_denied": [],
        "minions_pre": [],
        "minions": [salt_minion.id, salt_sub_minion.id],
    }
    assert output == expected
def test_list_all_raw_out(salt_key_cli, salt_minion, salt_sub_minion):
    """
    test salt-key -L --out=raw
    """
    ret = salt_key_cli.run("-L", "--out=raw")
    assert ret.exitcode == 0
    output = ast.literal_eval(ret.stdout)
    expected = {
        "minions_rejected": [],
        "minions_denied": [],
        "minions_pre": [],
        "minions": [salt_minion.id, salt_sub_minion.id],
    }
    assert output == expected
def test_list_acc(salt_key_cli, salt_minion, salt_sub_minion):
    """
    test salt-key -l acc
    """
    ret = salt_key_cli.run("-l", "acc")
    assert ret.exitcode == 0
    expected = {"minions": [salt_minion.id, salt_sub_minion.id]}
    assert ret.json == expected
@pytest.mark.skip_if_not_root
@pytest.mark.destructive_test
@pytest.mark.skip_on_windows(reason="PAM is not supported on Windows")
def test_list_acc_eauth(salt_key_cli, saltdev_account, salt_minion, salt_sub_minion):
    """
    test salt-key -l with eauth
    """
    ret = salt_key_cli.run(
        "-l", "acc", "--eauth", "pam", "--username", USERA, "--password", USERA_PWD
    )
    assert ret.exitcode == 0
    expected = {"minions": [salt_minion.id, salt_sub_minion.id]}
    assert ret.json == expected
@pytest.mark.skip_if_not_root
@pytest.mark.destructive_test
@pytest.mark.skip_on_windows(reason="PAM is not supported on Windows")
def test_list_acc_eauth_bad_creds(salt_key_cli, saltdev_account):
    """
    test salt-key -l with eauth and bad creds
    """
    ret = salt_key_cli.run(
        "-l",
        "acc",
        "--eauth",
        "pam",
        "--username",
        USERA,
        "--password",
        "wrongpassword",
    )
    assert (
        ret.stdout
        == 'Authentication failure of type "eauth" occurred for user {}.'.format(USERA)
    )
def test_list_acc_wrong_eauth(salt_key_cli):
    """
    test salt-key -l with wrong eauth
    """
    ret = salt_key_cli.run(
        "-l",
        "acc",
        "--eauth",
        "wrongeauth",
        "--username",
        USERA,
        "--password",
        USERA_PWD,
    )
    assert ret.exitcode == 0, ret
    assert re.search(
        r"^The specified external authentication system \"wrongeauth\" is not"
        r" available\nAvailable eauth types: auto, .*",
        ret.stdout.replace("\r\n", "\n"),
    )
def test_list_un(salt_key_cli):
    """
    test salt-key -l un
    """
    ret = salt_key_cli.run("-l", "un")
    assert ret.exitcode == 0
    expected = {"minions_pre": []}
    assert ret.json == expected
def test_keys_generation(salt_key_cli, tmp_path):
    ret = salt_key_cli.run("--gen-keys", "minibar", "--gen-keys-dir", str(tmp_path))
    assert ret.exitcode == 0
    try:
        key_names = ("minibar.pub", "minibar.pem")
        for fname in key_names:
            fpath = tmp_path / fname
            assert fpath.is_file()
    finally:
        for filename in tmp_path.iterdir():
            filename.chmod(0o700)
def test_keys_generation_keysize_min(salt_key_cli, tmp_path):
    ret = salt_key_cli.run(
        "--gen-keys", "minibar", "--gen-keys-dir", str(tmp_path), "--keysize", "1024"
    )
    assert ret.exitcode != 0
    assert "error: The minimum value for keysize is 2048" in ret.stderr
def test_keys_generation_keysize_max(salt_key_cli, tmp_path):
    ret = salt_key_cli.run(
        "--gen-keys", "minibar", "--gen-keys-dir", str(tmp_path), "--keysize", "32769"
    )
    assert ret.exitcode != 0
    assert "error: The maximum value for keysize is 32768" in ret.stderr
def test_accept_bad_key(salt_master, salt_key_cli):
    """
    test salt-key -d usage
    """
    min_name = random_string("minibar-")
    pki_dir = salt_master.config["pki_dir"]
    key = os.path.join(pki_dir, "minions_pre", min_name)
    with salt.utils.files.fopen(key, "w") as fp:
        fp.write("")
    try:
        ret = salt_key_cli.run("-y", "-a", min_name)
        assert ret.exitcode == 0
        assert "invalid key for {}".format(min_name) in ret.stderr
    finally:
        if os.path.exists(key):
            os.remove(key)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
