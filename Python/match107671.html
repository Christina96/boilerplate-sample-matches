<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for __init___3.py &amp; test_salt_key.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for __init___3.py &amp; test_salt_key.py
      </h3>
<h1 align="center">
        3.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>__init___3.py (3.4188035%)<th>test_salt_key.py (3.02267%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(14-25)<td><a href="#" name="0">(1-14)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>__init___3.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import inspect
3 import logging
4 import os
5 <a name="0"></a>import salt.auth
6 import salt.client
7 import salt.client.ssh.client
8 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import salt.config
9 import salt.daemons.masterapi
10 import salt.exceptions
11 import salt.log  # pylint: disable=W0611
12 import salt.runner
13 import salt.syspaths
14 import salt.utils.args
15 import salt.utils.minions
16 import salt.wheel
17 from salt.defaults import DEFAULT_TARGET_DELIM
18 log = logging.</b></font>getLogger(__name__)
19 class NetapiClient:
20     def __init__(self, opts):
21         self.opts = opts
22         apiopts = copy.deepcopy(self.opts)
23         apiopts["enable_ssh_minions"] = True
24         apiopts["cachedir"] = os.path.join(opts["cachedir"], "saltapi")
25         if not os.path.exists(apiopts["cachedir"]):
26             os.makedirs(apiopts["cachedir"])
27         self.resolver = salt.auth.Resolver(apiopts)
28         self.loadauth = salt.auth.LoadAuth(apiopts)
29         self.key = salt.daemons.masterapi.access_keys(apiopts)
30         self.ckminions = salt.utils.minions.CkMinions(apiopts)
31     def _is_master_running(self):
32         if salt.utils.platform.is_windows():
33             return True
34         if self.opts["transport"] == "tcp":
35             ipc_file = "publish_pull.ipc"
36         else:
37             ipc_file = "workers.ipc"
38         return os.path.exists(os.path.join(self.opts["sock_dir"], ipc_file))
39     def _prep_auth_info(self, clear_load):
40         sensitive_load_keys = []
41         key = None
42         if "token" in clear_load:
43             auth_type = "token"
44             err_name = "TokenAuthenticationError"
45             sensitive_load_keys = ["token"]
46             return auth_type, err_name, key, sensitive_load_keys
47         elif "eauth" in clear_load:
48             auth_type = "eauth"
49             err_name = "EauthAuthenticationError"
50             sensitive_load_keys = ["username", "password"]
51             return auth_type, err_name, key, sensitive_load_keys
52         raise salt.exceptions.EauthAuthenticationError(
53             "No authentication credentials given"
54         )
55     def _authorize_ssh(self, low):
56         auth_type, err_name, key, sensitive_load_keys = self._prep_auth_info(low)
57         auth_check = self.loadauth.check_authentication(low, auth_type, key=key)
58         auth_list = auth_check.get("auth_list", [])
59         error = auth_check.get("error")
60         if error:
61             raise salt.exceptions.EauthAuthenticationError(error)
62         delimiter = low.get("kwargs", {}).get("delimiter", DEFAULT_TARGET_DELIM)
63         _res = self.ckminions.check_minions(
64             low["tgt"], low.get("tgt_type", "glob"), delimiter
65         )
66         minions = _res.get("minions", list())
67         missing = _res.get("missing", list())
68         authorized = self.ckminions.auth_check(
69             auth_list,
70             low["fun"],
71             low.get("arg", []),
72             low["tgt"],
73             low.get("tgt_type", "glob"),
74             minions=minions,
75         )
76         if not authorized:
77             raise salt.exceptions.EauthAuthenticationError(
78                 "Authorization error occurred."
79             )
80     def run(self, low):
81         if not self._is_master_running():
82             raise salt.exceptions.SaltDaemonNotRunning("Salt Master is not available.")
83         if low.get("client") not in CLIENTS:
84             raise salt.exceptions.SaltInvocationError(
85                 "Invalid client specified: '{}'".format(low.get("client"))
86             )
87         if not ("token" in low or "eauth" in low):
88             raise salt.exceptions.EauthAuthenticationError(
89                 "No authentication credentials given"
90             )
91         if low.get("raw_shell") and not self.opts.get("netapi_allow_raw_shell"):
92             raise salt.exceptions.EauthAuthenticationError(
93                 "Raw shell option not allowed."
94             )
95         if low["client"] == "ssh":
96             self._authorize_ssh(low)
97         l_fun = getattr(self, low["client"])
98         f_call = salt.utils.args.format_call(l_fun, low)
99         return l_fun(*f_call.get("args", ()), **f_call.get("kwargs", {}))
100     def local_async(self, *args, **kwargs):
101         with salt.client.get_local_client(mopts=self.opts) as client:
102             return client.run_job(*args, **kwargs)
103     def local(self, *args, **kwargs):
104         with salt.client.get_local_client(mopts=self.opts) as client:
105             return client.cmd(*args, **kwargs)
106     def local_subset(self, *args, **kwargs):
107         with salt.client.get_local_client(mopts=self.opts) as client:
108             return client.cmd_subset(*args, **kwargs)
109     def local_batch(self, *args, **kwargs):
110         with salt.client.get_local_client(mopts=self.opts) as client:
111             return client.cmd_batch(*args, **kwargs)
112     def ssh(self, *args, **kwargs):
113         with salt.client.ssh.client.SSHClient(
114             mopts=self.opts, disable_custom_roster=True
115         ) as client:
116             return client.cmd_sync(kwargs)
117     def runner(self, fun, timeout=None, full_return=False, **kwargs):
118         kwargs["fun"] = fun
119         runner = salt.runner.RunnerClient(self.opts)
120         return runner.cmd_sync(kwargs, timeout=timeout, full_return=full_return)
121     def runner_async(self, fun, **kwargs):
122         kwargs["fun"] = fun
123         runner = salt.runner.RunnerClient(self.opts)
124         return runner.cmd_async(kwargs)
125     def wheel(self, fun, **kwargs):
126         kwargs["fun"] = fun
127         wheel = salt.wheel.WheelClient(self.opts)
128         return wheel.cmd_sync(kwargs)
129     def wheel_async(self, fun, **kwargs):
130         kwargs["fun"] = fun
131         wheel = salt.wheel.WheelClient(self.opts)
132         return wheel.cmd_async(kwargs)
133 CLIENTS = [
134     name
135     for name, _ in inspect.getmembers(NetapiClient, predicate=None)
136     if not (name == "run" or name.startswith("_"))
137 ]
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_salt_key.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a><font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import ast
2 import os
3 import re
4 import textwrap
5 import pytest
6 import salt.utils.files
7 import salt.utils.platform
8 import salt.utils.pycrypto
9 import salt.utils.yaml
10 from saltfactories.utils import random_string
11 pytestmark = [
12     pytest</b></font>.mark.slow_test,
13     pytest.mark.windows_whitelisted,
14 ]
15 USERA = "saltdev-key"
16 USERA_PWD = "saltdev"
17 PUB_KEY = textwrap.dedent(
18 )
19 @pytest.fixture(scope="module")
20 def saltdev_account(sminion):
21     try:
22         assert sminion.functions.user.add(USERA, createhome=False)
23         assert sminion.functions.shadow.set_password(
24             USERA,
25             USERA_PWD
26             if salt.utils.platform.is_darwin()
27             else salt.utils.pycrypto.gen_hash(password=USERA_PWD),
28         )
29         assert USERA in sminion.functions.user.list_users()
30         yield
31     finally:
32         sminion.functions.user.delete(USERA, remove=True)
33 def test_remove_key(salt_master, salt_key_cli):
34     min_name = random_string("minibar-")
35     pki_dir = salt_master.config["pki_dir"]
36     key = os.path.join(pki_dir, "minions", min_name)
37     with salt.utils.files.fopen(key, "w") as fp:
38         fp.write(PUB_KEY)
39     try:
40         ret = salt_key_cli.run("-p", min_name)
41         assert ret.exitcode == 0
42         assert "minions" in ret.json
43         assert min_name in ret.json["minions"]
44         assert "-----BEGIN PUBLIC KEY-----" in ret.json["minions"][min_name]
45         ret = salt_key_cli.run("-d", min_name, "-y")
46         assert ret.exitcode == 0
47         assert "minions" in ret.stdout
48         assert min_name in ret.stdout
49         ret = salt_key_cli.run("-p", min_name)
50         assert ret.exitcode == 0
51         assert ret.json == {}
52     finally:
53         if os.path.exists(key):
54             os.unlink(key)
55 @pytest.mark.skip_if_not_root
56 @pytest.mark.destructive_test
57 @pytest.mark.skip_on_windows(reason="PAM is not supported on Windows")
58 def test_remove_key_eauth(salt_key_cli, salt_master, saltdev_account):
59     min_name = random_string("minibar-")
60     pki_dir = salt_master.config["pki_dir"]
61     key = os.path.join(pki_dir, "minions", min_name)
62     with salt.utils.files.fopen(key, "w") as fp:
63         fp.write(PUB_KEY)
64     try:
65         ret = salt_key_cli.run("-p", min_name)
66         assert ret.exitcode == 0
67         assert "minions" in ret.json
68         assert min_name in ret.json["minions"]
69         assert "-----BEGIN PUBLIC KEY-----" in ret.json["minions"][min_name]
70         ret = salt_key_cli.run(
71             "-d",
72             min_name,
73             "-y",
74             "--eauth",
75             "pam",
76             "--username",
77             USERA,
78             "--password",
79             USERA_PWD,
80         )
81         assert ret.exitcode == 0
82         assert "minions" in ret.stdout
83         assert min_name in ret.stdout
84         ret = salt_key_cli.run("-p", min_name)
85         assert ret.exitcode == 0
86         assert ret.json == {}
87     finally:
88         if os.path.exists(key):
89             os.unlink(key)
90 @pytest.mark.parametrize("key_type", ("acc", "pre", "den", "un", "rej"))
91 def test_list_accepted_args(salt_key_cli, key_type):
92     ret = salt_key_cli.run("-l", key_type)
93     assert ret.exitcode == 0
94     assert "error:" not in ret.stdout
95     ret = salt_key_cli.run("-l", "foo-{}".format(key_type))
96     assert ret.exitcode != 0
97     assert "error:" in ret.stderr
98 def test_list_all(salt_key_cli, salt_minion, salt_sub_minion):
99     ret = salt_key_cli.run("-L")
100     assert ret.exitcode == 0
101     expected = {
102         "minions_rejected": [],
103         "minions_denied": [],
104         "minions_pre": [],
105         "minions": [salt_minion.id, salt_sub_minion.id],
106     }
107     assert ret.json == expected
108 def test_list_all_yaml_out(salt_key_cli, salt_minion, salt_sub_minion):
109     ret = salt_key_cli.run("-L", "--out=yaml")
110     assert ret.exitcode == 0
111     output = salt.utils.yaml.safe_load(ret.stdout)
112     expected = {
113         "minions_rejected": [],
114         "minions_denied": [],
115         "minions_pre": [],
116         "minions": [salt_minion.id, salt_sub_minion.id],
117     }
118     assert output == expected
119 def test_list_all_raw_out(salt_key_cli, salt_minion, salt_sub_minion):
120     ret = salt_key_cli.run("-L", "--out=raw")
121     assert ret.exitcode == 0
122     output = ast.literal_eval(ret.stdout)
123     expected = {
124         "minions_rejected": [],
125         "minions_denied": [],
126         "minions_pre": [],
127         "minions": [salt_minion.id, salt_sub_minion.id],
128     }
129     assert output == expected
130 def test_list_acc(salt_key_cli, salt_minion, salt_sub_minion):
131     ret = salt_key_cli.run("-l", "acc")
132     assert ret.exitcode == 0
133     expected = {"minions": [salt_minion.id, salt_sub_minion.id]}
134     assert ret.json == expected
135 @pytest.mark.skip_if_not_root
136 @pytest.mark.destructive_test
137 @pytest.mark.skip_on_windows(reason="PAM is not supported on Windows")
138 def test_list_acc_eauth(salt_key_cli, saltdev_account, salt_minion, salt_sub_minion):
139     ret = salt_key_cli.run(
140         "-l", "acc", "--eauth", "pam", "--username", USERA, "--password", USERA_PWD
141     )
142     assert ret.exitcode == 0
143     expected = {"minions": [salt_minion.id, salt_sub_minion.id]}
144     assert ret.json == expected
145 @pytest.mark.skip_if_not_root
146 @pytest.mark.destructive_test
147 @pytest.mark.skip_on_windows(reason="PAM is not supported on Windows")
148 def test_list_acc_eauth_bad_creds(salt_key_cli, saltdev_account):
149     ret = salt_key_cli.run(
150         "-l",
151         "acc",
152         "--eauth",
153         "pam",
154         "--username",
155         USERA,
156         "--password",
157         "wrongpassword",
158     )
159     assert (
160         ret.stdout
161         == 'Authentication failure of type "eauth" occurred for user {}.'.format(USERA)
162     )
163 def test_list_acc_wrong_eauth(salt_key_cli):
164     ret = salt_key_cli.run(
165         "-l",
166         "acc",
167         "--eauth",
168         "wrongeauth",
169         "--username",
170         USERA,
171         "--password",
172         USERA_PWD,
173     )
174     assert ret.exitcode == 0, ret
175     assert re.search(
176         r"^The specified external authentication system \"wrongeauth\" is not"
177         r" available\nAvailable eauth types: auto, .*",
178         ret.stdout.replace("\r\n", "\n"),
179     )
180 def test_list_un(salt_key_cli):
181     ret = salt_key_cli.run("-l", "un")
182     assert ret.exitcode == 0
183     expected = {"minions_pre": []}
184     assert ret.json == expected
185 def test_keys_generation(salt_key_cli, tmp_path):
186     ret = salt_key_cli.run("--gen-keys", "minibar", "--gen-keys-dir", str(tmp_path))
187     assert ret.exitcode == 0
188     try:
189         key_names = ("minibar.pub", "minibar.pem")
190         for fname in key_names:
191             fpath = tmp_path / fname
192             assert fpath.is_file()
193     finally:
194         for filename in tmp_path.iterdir():
195             filename.chmod(0o700)
196 def test_keys_generation_keysize_min(salt_key_cli, tmp_path):
197     ret = salt_key_cli.run(
198         "--gen-keys", "minibar", "--gen-keys-dir", str(tmp_path), "--keysize", "1024"
199     )
200     assert ret.exitcode != 0
201     assert "error: The minimum value for keysize is 2048" in ret.stderr
202 def test_keys_generation_keysize_max(salt_key_cli, tmp_path):
203     ret = salt_key_cli.run(
204         "--gen-keys", "minibar", "--gen-keys-dir", str(tmp_path), "--keysize", "32769"
205     )
206     assert ret.exitcode != 0
207     assert "error: The maximum value for keysize is 32768" in ret.stderr
208 def test_accept_bad_key(salt_master, salt_key_cli):
209     min_name = random_string("minibar-")
210     pki_dir = salt_master.config["pki_dir"]
211     key = os.path.join(pki_dir, "minions_pre", min_name)
212     with salt.utils.files.fopen(key, "w") as fp:
213         fp.write("")
214     try:
215         ret = salt_key_cli.run("-y", "-a", min_name)
216         assert ret.exitcode == 0
217         assert "invalid key for {}".format(min_name) in ret.stderr
218     finally:
219         if os.path.exists(key):
220             os.remove(key)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
