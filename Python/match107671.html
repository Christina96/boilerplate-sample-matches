<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for __init___3.py &amp; test_salt_key.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for __init___3.py &amp; test_salt_key.py
      </h3>
<h1 align="center">
        3.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>__init___3.py (3.4188035%)<th>test_salt_key.py (3.02267%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(14-25)<td><a href="#" name="0">(1-14)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>__init___3.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import inspect
3 import logging
4 import os
5 import salt.client
6 import salt.client.ssh.client
7 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import salt.config
8 import salt.daemons.masterapi
9 import salt.exceptions
10 import salt.log  # pylint: disable=W0611
11 import salt.runner
12 import salt.syspaths
13 import salt.utils.args
14 import salt.utils.minions
15 import salt.wheel
16 from salt.defaults import DEFAULT_TARGET_DELIM
17 log = logging.</b></font>getLogger(__name__)
18 class NetapiClient:
19     def __init__(self, opts):
20         self.opts = opts
21         apiopts = copy.deepcopy(self.opts)
22         apiopts["enable_ssh_minions"] = True
23         apiopts["cachedir"] = os.path.join(opts["cachedir"], "saltapi")
24         if not os.path.exists(apiopts["cachedir"]):
25             os.makedirs(apiopts["cachedir"])
26         self.resolver = salt.auth.Resolver(apiopts)
27         self.loadauth = salt.auth.LoadAuth(apiopts)
28         self.key = salt.daemons.masterapi.access_keys(apiopts)
29         self.ckminions = salt.utils.minions.CkMinions(apiopts)
30     def _is_master_running(self):
31         if salt.utils.platform.is_windows():
32             return True
33         if self.opts["transport"] == "tcp":
34             ipc_file = "publish_pull.ipc"
35         else:
36             ipc_file = "workers.ipc"
37         return os.path.exists(os.path.join(self.opts["sock_dir"], ipc_file))
38     def _prep_auth_info(self, clear_load):
39         sensitive_load_keys = []
40         key = None
41         if "token" in clear_load:
42             auth_type = "token"
43             err_name = "TokenAuthenticationError"
44             sensitive_load_keys = ["token"]
45             return auth_type, err_name, key, sensitive_load_keys
46         elif "eauth" in clear_load:
47             auth_type = "eauth"
48             err_name = "EauthAuthenticationError"
49             sensitive_load_keys = ["username", "password"]
50             return auth_type, err_name, key, sensitive_load_keys
51         raise salt.exceptions.EauthAuthenticationError(
52             "No authentication credentials given"
53         )
54     def _authorize_ssh(self, low):
55         auth_type, err_name, key, sensitive_load_keys = self._prep_auth_info(low)
56         auth_check = self.loadauth.check_authentication(low, auth_type, key=key)
57         auth_list = auth_check.get("auth_list", [])
58         error = auth_check.get("error")
59         if error:
60             raise salt.exceptions.EauthAuthenticationError(error)
61         delimiter = low.get("kwargs", {}).get("delimiter", DEFAULT_TARGET_DELIM)
62         _res = self.ckminions.check_minions(
63             low["tgt"], low.get("tgt_type", "glob"), delimiter
64         )
65         minions = _res.get("minions", list())
66         missing = _res.get("missing", list())
67         authorized = self.ckminions.auth_check(
68             auth_list,
69             low["fun"],
70             low.get("arg", []),
71             low["tgt"],
72             low.get("tgt_type", "glob"),
73             minions=minions,
74         )
75         if not authorized:
76             raise salt.exceptions.EauthAuthenticationError(
77                 "Authorization error occurred."
78             )
79     def run(self, low):
80         if not self._is_master_running():
81             raise salt.exceptions.SaltDaemonNotRunning("Salt Master is not available.")
82         if low.get("client") not in CLIENTS:
83             raise salt.exceptions.SaltInvocationError(
84                 "Invalid client specified: '{}'".format(low.get("client"))
85             )
86         if not ("token" in low or "eauth" in low):
87             raise salt.exceptions.EauthAuthenticationError(
88                 "No authentication credentials given"
89             )
90         if low.get("raw_shell") and not self.opts.get("netapi_allow_raw_shell"):
91             raise salt.exceptions.EauthAuthenticationError(
92                 "Raw shell option not allowed."
93             )
94         if low["client"] == "ssh":
95             self._authorize_ssh(low)
96         l_fun = getattr(self, low["client"])
97         f_call = salt.utils.args.format_call(l_fun, low)
98         return l_fun(*f_call.get("args", ()), **f_call.get("kwargs", {}))
99     def local_async(self, *args, **kwargs):
100         with salt.client.get_local_client(mopts=self.opts) as client:
101             return client.run_job(*args, **kwargs)
102     def local(self, *args, **kwargs):
103         with salt.client.get_local_client(mopts=self.opts) as client:
104             return client.cmd(*args, **kwargs)
105     def local_subset(self, *args, **kwargs):
106         with salt.client.get_local_client(mopts=self.opts) as client:
107             return client.cmd_subset(*args, **kwargs)
108     def local_batch(self, *args, **kwargs):
109         with salt.client.get_local_client(mopts=self.opts) as client:
110             return client.cmd_batch(*args, **kwargs)
111     def ssh(self, *args, **kwargs):
112         with salt.client.ssh.client.SSHClient(
113             mopts=self.opts, disable_custom_roster=True
114         ) as client:
115             return client.cmd_sync(kwargs)
116     def runner(self, fun, timeout=None, full_return=False, **kwargs):
117         kwargs["fun"] = fun
118         runner = salt.runner.RunnerClient(self.opts)
119         return runner.cmd_sync(kwargs, timeout=timeout, full_return=full_return)
120     def runner_async(self, fun, **kwargs):
121         kwargs["fun"] = fun
122         runner = salt.runner.RunnerClient(self.opts)
123         return runner.cmd_async(kwargs)
124     def wheel(self, fun, **kwargs):
125         kwargs["fun"] = fun
126         wheel = salt.wheel.WheelClient(self.opts)
127         return wheel.cmd_sync(kwargs)
128     def wheel_async(self, fun, **kwargs):
129         kwargs["fun"] = fun
130         wheel = salt.wheel.WheelClient(self.opts)
131         return wheel.cmd_async(kwargs)
132 CLIENTS = [
133     name
134     for name, _ in inspect.getmembers(NetapiClient, predicate=None)
135     if not (name == "run" or name.startswith("_"))
136 ]
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_salt_key.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import os
2 import re
3 import textwrap
4 import pytest
5 import salt.utils.files
6 import salt.utils.platform
7 import salt.utils.pycrypto
8 import salt.utils.yaml
9 from saltfactories.utils import random_string
10 pytestmark = [
11     pytest</b></font>.mark.slow_test,
12     pytest.mark.windows_whitelisted,
13 ]
14 USERA = "saltdev-key"
15 USERA_PWD = "saltdev"
16 PUB_KEY = textwrap.dedent(
17 )
18 @pytest.fixture(scope="module")
19 def saltdev_account(sminion):
20     try:
21         assert sminion.functions.user.add(USERA, createhome=False)
22         assert sminion.functions.shadow.set_password(
23             USERA,
24             USERA_PWD
25             if salt.utils.platform.is_darwin()
26             else salt.utils.pycrypto.gen_hash(password=USERA_PWD),
27         )
28         assert USERA in sminion.functions.user.list_users()
29         yield
30     finally:
31         sminion.functions.user.delete(USERA, remove=True)
32 def test_remove_key(salt_master, salt_key_cli):
33     min_name = random_string("minibar-")
34     pki_dir = salt_master.config["pki_dir"]
35     key = os.path.join(pki_dir, "minions", min_name)
36     with salt.utils.files.fopen(key, "w") as fp:
37         fp.write(PUB_KEY)
38     try:
39         ret = salt_key_cli.run("-p", min_name)
40         assert ret.exitcode == 0
41         assert "minions" in ret.json
42         assert min_name in ret.json["minions"]
43         assert "-----BEGIN PUBLIC KEY-----" in ret.json["minions"][min_name]
44         ret = salt_key_cli.run("-d", min_name, "-y")
45         assert ret.exitcode == 0
46         assert "minions" in ret.stdout
47         assert min_name in ret.stdout
48         ret = salt_key_cli.run("-p", min_name)
49         assert ret.exitcode == 0
50         assert ret.json == {}
51     finally:
52         if os.path.exists(key):
53             os.unlink(key)
54 @pytest.mark.skip_if_not_root
55 @pytest.mark.destructive_test
56 @pytest.mark.skip_on_windows(reason="PAM is not supported on Windows")
57 def test_remove_key_eauth(salt_key_cli, salt_master, saltdev_account):
58     min_name = random_string("minibar-")
59     pki_dir = salt_master.config["pki_dir"]
60     key = os.path.join(pki_dir, "minions", min_name)
61     with salt.utils.files.fopen(key, "w") as fp:
62         fp.write(PUB_KEY)
63     try:
64         ret = salt_key_cli.run("-p", min_name)
65         assert ret.exitcode == 0
66         assert "minions" in ret.json
67         assert min_name in ret.json["minions"]
68         assert "-----BEGIN PUBLIC KEY-----" in ret.json["minions"][min_name]
69         ret = salt_key_cli.run(
70             "-d",
71             min_name,
72             "-y",
73             "--eauth",
74             "pam",
75             "--username",
76             USERA,
77             "--password",
78             USERA_PWD,
79         )
80         assert ret.exitcode == 0
81         assert "minions" in ret.stdout
82         assert min_name in ret.stdout
83         ret = salt_key_cli.run("-p", min_name)
84         assert ret.exitcode == 0
85         assert ret.json == {}
86     finally:
87         if os.path.exists(key):
88             os.unlink(key)
89 @pytest.mark.parametrize("key_type", ("acc", "pre", "den", "un", "rej"))
90 def test_list_accepted_args(salt_key_cli, key_type):
91     ret = salt_key_cli.run("-l", key_type)
92     assert ret.exitcode == 0
93     assert "error:" not in ret.stdout
94     ret = salt_key_cli.run("-l", "foo-{}".format(key_type))
95     assert ret.exitcode != 0
96     assert "error:" in ret.stderr
97 def test_list_all(salt_key_cli, salt_minion, salt_sub_minion):
98     ret = salt_key_cli.run("-L")
99     assert ret.exitcode == 0
100     expected = {
101         "minions_rejected": [],
102         "minions_denied": [],
103         "minions_pre": [],
104         "minions": [salt_minion.id, salt_sub_minion.id],
105     }
106     assert ret.json == expected
107 def test_list_all_yaml_out(salt_key_cli, salt_minion, salt_sub_minion):
108     ret = salt_key_cli.run("-L", "--out=yaml")
109     assert ret.exitcode == 0
110     output = salt.utils.yaml.safe_load(ret.stdout)
111     expected = {
112         "minions_rejected": [],
113         "minions_denied": [],
114         "minions_pre": [],
115         "minions": [salt_minion.id, salt_sub_minion.id],
116     }
117     assert output == expected
118 def test_list_all_raw_out(salt_key_cli, salt_minion, salt_sub_minion):
119     ret = salt_key_cli.run("-L", "--out=raw")
120     assert ret.exitcode == 0
121     output = ast.literal_eval(ret.stdout)
122     expected = {
123         "minions_rejected": [],
124         "minions_denied": [],
125         "minions_pre": [],
126         "minions": [salt_minion.id, salt_sub_minion.id],
127     }
128     assert output == expected
129 def test_list_acc(salt_key_cli, salt_minion, salt_sub_minion):
130     ret = salt_key_cli.run("-l", "acc")
131     assert ret.exitcode == 0
132     expected = {"minions": [salt_minion.id, salt_sub_minion.id]}
133     assert ret.json == expected
134 @pytest.mark.skip_if_not_root
135 @pytest.mark.destructive_test
136 @pytest.mark.skip_on_windows(reason="PAM is not supported on Windows")
137 def test_list_acc_eauth(salt_key_cli, saltdev_account, salt_minion, salt_sub_minion):
138     ret = salt_key_cli.run(
139         "-l", "acc", "--eauth", "pam", "--username", USERA, "--password", USERA_PWD
140     )
141     assert ret.exitcode == 0
142     expected = {"minions": [salt_minion.id, salt_sub_minion.id]}
143     assert ret.json == expected
144 @pytest.mark.skip_if_not_root
145 @pytest.mark.destructive_test
146 @pytest.mark.skip_on_windows(reason="PAM is not supported on Windows")
147 def test_list_acc_eauth_bad_creds(salt_key_cli, saltdev_account):
148     ret = salt_key_cli.run(
149         "-l",
150         "acc",
151         "--eauth",
152         "pam",
153         "--username",
154         USERA,
155         "--password",
156         "wrongpassword",
157     )
158     assert (
159         ret.stdout
160         == 'Authentication failure of type "eauth" occurred for user {}.'.format(USERA)
161     )
162 def test_list_acc_wrong_eauth(salt_key_cli):
163     ret = salt_key_cli.run(
164         "-l",
165         "acc",
166         "--eauth",
167         "wrongeauth",
168         "--username",
169         USERA,
170         "--password",
171         USERA_PWD,
172     )
173     assert ret.exitcode == 0, ret
174     assert re.search(
175         r"^The specified external authentication system \"wrongeauth\" is not"
176         r" available\nAvailable eauth types: auto, .*",
177         ret.stdout.replace("\r\n", "\n"),
178     )
179 def test_list_un(salt_key_cli):
180     ret = salt_key_cli.run("-l", "un")
181     assert ret.exitcode == 0
182     expected = {"minions_pre": []}
183     assert ret.json == expected
184 def test_keys_generation(salt_key_cli, tmp_path):
185     ret = salt_key_cli.run("--gen-keys", "minibar", "--gen-keys-dir", str(tmp_path))
186     assert ret.exitcode == 0
187     try:
188         key_names = ("minibar.pub", "minibar.pem")
189         for fname in key_names:
190             fpath = tmp_path / fname
191             assert fpath.is_file()
192     finally:
193         for filename in tmp_path.iterdir():
194             filename.chmod(0o700)
195 def test_keys_generation_keysize_min(salt_key_cli, tmp_path):
196     ret = salt_key_cli.run(
197         "--gen-keys", "minibar", "--gen-keys-dir", str(tmp_path), "--keysize", "1024"
198     )
199     assert ret.exitcode != 0
200     assert "error: The minimum value for keysize is 2048" in ret.stderr
201 def test_keys_generation_keysize_max(salt_key_cli, tmp_path):
202     ret = salt_key_cli.run(
203         "--gen-keys", "minibar", "--gen-keys-dir", str(tmp_path), "--keysize", "32769"
204     )
205     assert ret.exitcode != 0
206     assert "error: The maximum value for keysize is 32768" in ret.stderr
207 def test_accept_bad_key(salt_master, salt_key_cli):
208     min_name = random_string("minibar-")
209     pki_dir = salt_master.config["pki_dir"]
210     key = os.path.join(pki_dir, "minions_pre", min_name)
211     with salt.utils.files.fopen(key, "w") as fp:
212         fp.write("")
213     try:
214         ret = salt_key_cli.run("-y", "-a", min_name)
215         assert ret.exitcode == 0
216         assert "invalid key for {}".format(min_name) in ret.stderr
217     finally:
218         if os.path.exists(key):
219             os.remove(key)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
