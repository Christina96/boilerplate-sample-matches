<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for __init___3.py & test_salt_key.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for __init___3.py & test_salt_key.py
      </h3>
      <h1 align="center">
        3.2%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>__init___3.py (3.4188035%)<TH>test_salt_key.py (3.02267%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match107671-0.html#0',2,'match107671-1.html#0',3)" NAME="0">(14-25)<TD><A HREF="javascript:ZweiFrames('match107671-0.html#0',2,'match107671-1.html#0',3)" NAME="0">(1-14)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>__init___3.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Make api awesomeness
&quot;&quot;&quot;


import copy
import inspect
import logging
import os

<A NAME="0"></A>import salt.auth
import salt.client
import salt.client.ssh.client
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match107671-1.html#0',3,'match107671-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import salt.config
import salt.daemons.masterapi
import salt.exceptions
import salt.log  # pylint: disable=W0611
import salt.runner
import salt.syspaths
import salt.utils.args
import salt.utils.minions
import salt.wheel
from salt.defaults import DEFAULT_TARGET_DELIM

log = logging.</B></FONT>getLogger(__name__)


class NetapiClient:
    &quot;&quot;&quot;
    Provide a uniform method of accessing the various client interfaces in Salt
    in the form of low-data data structures. For example:

    &gt;&gt;&gt; client = NetapiClient(__opts__)
    &gt;&gt;&gt; lowstate = {'client': 'local', 'tgt': '*', 'fun': 'test.ping', 'arg': ''}
    &gt;&gt;&gt; client.run(lowstate)
    &quot;&quot;&quot;

    def __init__(self, opts):
        self.opts = opts
        apiopts = copy.deepcopy(self.opts)
        apiopts[&quot;enable_ssh_minions&quot;] = True
        apiopts[&quot;cachedir&quot;] = os.path.join(opts[&quot;cachedir&quot;], &quot;saltapi&quot;)
        if not os.path.exists(apiopts[&quot;cachedir&quot;]):
            os.makedirs(apiopts[&quot;cachedir&quot;])
        self.resolver = salt.auth.Resolver(apiopts)
        self.loadauth = salt.auth.LoadAuth(apiopts)
        self.key = salt.daemons.masterapi.access_keys(apiopts)
        self.ckminions = salt.utils.minions.CkMinions(apiopts)

    def _is_master_running(self):
        &quot;&quot;&quot;
        Perform a lightweight check to see if the master daemon is running

        Note, this will return an invalid success if the master crashed or was
        not shut down cleanly.
        &quot;&quot;&quot;
        # Windows doesn't have IPC. Assume the master is running.
        # At worse, it will error 500.
        if salt.utils.platform.is_windows():
            return True

        if self.opts[&quot;transport&quot;] == &quot;tcp&quot;:
            ipc_file = &quot;publish_pull.ipc&quot;
        else:
            ipc_file = &quot;workers.ipc&quot;
        return os.path.exists(os.path.join(self.opts[&quot;sock_dir&quot;], ipc_file))

    def _prep_auth_info(self, clear_load):
        sensitive_load_keys = []
        key = None
        if &quot;token&quot; in clear_load:
            auth_type = &quot;token&quot;
            err_name = &quot;TokenAuthenticationError&quot;
            sensitive_load_keys = [&quot;token&quot;]
            return auth_type, err_name, key, sensitive_load_keys
        elif &quot;eauth&quot; in clear_load:
            auth_type = &quot;eauth&quot;
            err_name = &quot;EauthAuthenticationError&quot;
            sensitive_load_keys = [&quot;username&quot;, &quot;password&quot;]
            return auth_type, err_name, key, sensitive_load_keys
        raise salt.exceptions.EauthAuthenticationError(
            &quot;No authentication credentials given&quot;
        )

    def _authorize_ssh(self, low):
        auth_type, err_name, key, sensitive_load_keys = self._prep_auth_info(low)
        auth_check = self.loadauth.check_authentication(low, auth_type, key=key)
        auth_list = auth_check.get(&quot;auth_list&quot;, [])
        error = auth_check.get(&quot;error&quot;)
        if error:
            raise salt.exceptions.EauthAuthenticationError(error)
        delimiter = low.get(&quot;kwargs&quot;, {}).get(&quot;delimiter&quot;, DEFAULT_TARGET_DELIM)
        _res = self.ckminions.check_minions(
            low[&quot;tgt&quot;], low.get(&quot;tgt_type&quot;, &quot;glob&quot;), delimiter
        )
        minions = _res.get(&quot;minions&quot;, list())
        missing = _res.get(&quot;missing&quot;, list())
        authorized = self.ckminions.auth_check(
            auth_list,
            low[&quot;fun&quot;],
            low.get(&quot;arg&quot;, []),
            low[&quot;tgt&quot;],
            low.get(&quot;tgt_type&quot;, &quot;glob&quot;),
            minions=minions,
        )
        if not authorized:
            raise salt.exceptions.EauthAuthenticationError(
                &quot;Authorization error occurred.&quot;
            )

    def run(self, low):
        &quot;&quot;&quot;
        Execute the specified function in the specified client by passing the
        lowstate
        &quot;&quot;&quot;
        # Eauth currently requires a running daemon and commands run through
        # this method require eauth so perform a quick check to raise a
        # more meaningful error.
        if not self._is_master_running():
            raise salt.exceptions.SaltDaemonNotRunning(&quot;Salt Master is not available.&quot;)

        if low.get(&quot;client&quot;) not in CLIENTS:
            raise salt.exceptions.SaltInvocationError(
                &quot;Invalid client specified: '{}'&quot;.format(low.get(&quot;client&quot;))
            )

        if not (&quot;token&quot; in low or &quot;eauth&quot; in low):
            raise salt.exceptions.EauthAuthenticationError(
                &quot;No authentication credentials given&quot;
            )

        if low.get(&quot;raw_shell&quot;) and not self.opts.get(&quot;netapi_allow_raw_shell&quot;):
            raise salt.exceptions.EauthAuthenticationError(
                &quot;Raw shell option not allowed.&quot;
            )

        if low[&quot;client&quot;] == &quot;ssh&quot;:
            self._authorize_ssh(low)

        l_fun = getattr(self, low[&quot;client&quot;])
        f_call = salt.utils.args.format_call(l_fun, low)
        return l_fun(*f_call.get(&quot;args&quot;, ()), **f_call.get(&quot;kwargs&quot;, {}))

    def local_async(self, *args, **kwargs):
        &quot;&quot;&quot;
        Run :ref:`execution modules &lt;all-salt.modules&gt;` asynchronously

        Wraps :py:meth:`salt.client.LocalClient.run_job`.

        :return: job ID
        &quot;&quot;&quot;
        with salt.client.get_local_client(mopts=self.opts) as client:
            return client.run_job(*args, **kwargs)

    def local(self, *args, **kwargs):
        &quot;&quot;&quot;
        Run :ref:`execution modules &lt;all-salt.modules&gt;` synchronously

        See :py:meth:`salt.client.LocalClient.cmd` for all available
        parameters.

        Sends a command from the master to the targeted minions. This is the
        same interface that Salt's own CLI uses. Note the ``arg`` and ``kwarg``
        parameters are sent down to the minion(s) and the given function,
        ``fun``, is called with those parameters.

        :return: Returns the result from the execution module
        &quot;&quot;&quot;
        with salt.client.get_local_client(mopts=self.opts) as client:
            return client.cmd(*args, **kwargs)

    def local_subset(self, *args, **kwargs):
        &quot;&quot;&quot;
        Run :ref:`execution modules &lt;all-salt.modules&gt;` against subsets of minions

        .. versionadded:: 2016.3.0

        Wraps :py:meth:`salt.client.LocalClient.cmd_subset`
        &quot;&quot;&quot;
        with salt.client.get_local_client(mopts=self.opts) as client:
            return client.cmd_subset(*args, **kwargs)

    def local_batch(self, *args, **kwargs):
        &quot;&quot;&quot;
        Run :ref:`execution modules &lt;all-salt.modules&gt;` against batches of minions

        .. versionadded:: 0.8.4

        Wraps :py:meth:`salt.client.LocalClient.cmd_batch`

        :return: Returns the result from the exeuction module for each batch of
            returns
        &quot;&quot;&quot;
        with salt.client.get_local_client(mopts=self.opts) as client:
            return client.cmd_batch(*args, **kwargs)

    def ssh(self, *args, **kwargs):
        &quot;&quot;&quot;
        Run salt-ssh commands synchronously

        Wraps :py:meth:`salt.client.ssh.client.SSHClient.cmd_sync`.

        :return: Returns the result from the salt-ssh command
        &quot;&quot;&quot;
        with salt.client.ssh.client.SSHClient(
            mopts=self.opts, disable_custom_roster=True
        ) as client:
            return client.cmd_sync(kwargs)

    def runner(self, fun, timeout=None, full_return=False, **kwargs):
        &quot;&quot;&quot;
        Run `runner modules &lt;all-salt.runners&gt;` synchronously

        Wraps :py:meth:`salt.runner.RunnerClient.cmd_sync`.

        Note that runner functions must be called using keyword arguments.
        Positional arguments are not supported.

        :return: Returns the result from the runner module
        &quot;&quot;&quot;
        kwargs[&quot;fun&quot;] = fun
        runner = salt.runner.RunnerClient(self.opts)
        return runner.cmd_sync(kwargs, timeout=timeout, full_return=full_return)

    def runner_async(self, fun, **kwargs):
        &quot;&quot;&quot;
        Run `runner modules &lt;all-salt.runners&gt;` asynchronously

        Wraps :py:meth:`salt.runner.RunnerClient.cmd_async`.

        Note that runner functions must be called using keyword arguments.
        Positional arguments are not supported.

        :return: event data and a job ID for the executed function.
        &quot;&quot;&quot;
        kwargs[&quot;fun&quot;] = fun
        runner = salt.runner.RunnerClient(self.opts)
        return runner.cmd_async(kwargs)

    def wheel(self, fun, **kwargs):
        &quot;&quot;&quot;
        Run :ref:`wheel modules &lt;all-salt.wheel&gt;` synchronously

        Wraps :py:meth:`salt.wheel.WheelClient.master_call`.

        Note that wheel functions must be called using keyword arguments.
        Positional arguments are not supported.

        :return: Returns the result from the wheel module
        &quot;&quot;&quot;
        kwargs[&quot;fun&quot;] = fun
        wheel = salt.wheel.WheelClient(self.opts)
        return wheel.cmd_sync(kwargs)

    def wheel_async(self, fun, **kwargs):
        &quot;&quot;&quot;
        Run :ref:`wheel modules &lt;all-salt.wheel&gt;` asynchronously

        Wraps :py:meth:`salt.wheel.WheelClient.master_call`.

        Note that wheel functions must be called using keyword arguments.
        Positional arguments are not supported.

        :return: Returns the result from the wheel module
        &quot;&quot;&quot;
        kwargs[&quot;fun&quot;] = fun
        wheel = salt.wheel.WheelClient(self.opts)
        return wheel.cmd_async(kwargs)


CLIENTS = [
    name
    for name, _ in inspect.getmembers(NetapiClient, predicate=None)
    if not (name == &quot;run&quot; or name.startswith(&quot;_&quot;))
]
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_salt_key.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
<A NAME="0"></A><FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match107671-0.html#0',2,'match107671-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import ast
import os
import re
import textwrap

import pytest
import salt.utils.files
import salt.utils.platform
import salt.utils.pycrypto
import salt.utils.yaml
from saltfactories.utils import random_string

pytestmark = [
    pytest</B></FONT>.mark.slow_test,
    pytest.mark.windows_whitelisted,
]

USERA = &quot;saltdev-key&quot;
USERA_PWD = &quot;saltdev&quot;
PUB_KEY = textwrap.dedent(
    &quot;&quot;&quot;\
        -----BEGIN PUBLIC KEY-----
        MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAoqIZDtcQtqUNs0wC7qQz
        JwFhXAVNT5C8M8zhI+pFtF/63KoN5k1WwAqP2j3LquTG68WpxcBwLtKfd7FVA/Kr
        OF3kXDWFnDi+HDchW2lJObgfzLckWNRFaF8SBvFM2dys3CGSgCV0S/qxnRAjrJQb
        B3uQwtZ64ncJAlkYpArv3GwsfRJ5UUQnYPDEJwGzMskZ0pHd60WwM1gMlfYmNX5O
        RBEjybyNpYDzpda6e6Ypsn6ePGLkP/tuwUf+q9wpbRE3ZwqERC2XRPux+HX2rGP+
        mkzpmuHkyi2wV33A9pDfMgRHdln2CLX0KgfRGixUQhW1o+Kmfv2rq4sGwpCgLbTh
        NwIDAQAB
        -----END PUBLIC KEY-----
        &quot;&quot;&quot;
)


@pytest.fixture(scope=&quot;module&quot;)
def saltdev_account(sminion):
    try:
        assert sminion.functions.user.add(USERA, createhome=False)
        assert sminion.functions.shadow.set_password(
            USERA,
            USERA_PWD
            if salt.utils.platform.is_darwin()
            else salt.utils.pycrypto.gen_hash(password=USERA_PWD),
        )
        assert USERA in sminion.functions.user.list_users()
        # Run tests
        yield
    finally:
        sminion.functions.user.delete(USERA, remove=True)


def test_remove_key(salt_master, salt_key_cli):
    &quot;&quot;&quot;
    test salt-key -d usage
    &quot;&quot;&quot;
    min_name = random_string(&quot;minibar-&quot;)
    pki_dir = salt_master.config[&quot;pki_dir&quot;]
    key = os.path.join(pki_dir, &quot;minions&quot;, min_name)

    with salt.utils.files.fopen(key, &quot;w&quot;) as fp:
        fp.write(PUB_KEY)

    try:
        # Check Key
        ret = salt_key_cli.run(&quot;-p&quot;, min_name)
        assert ret.exitcode == 0
        assert &quot;minions&quot; in ret.json
        assert min_name in ret.json[&quot;minions&quot;]
        assert &quot;-----BEGIN PUBLIC KEY-----&quot; in ret.json[&quot;minions&quot;][min_name]
        # Remove Key
        ret = salt_key_cli.run(&quot;-d&quot;, min_name, &quot;-y&quot;)
        assert ret.exitcode == 0
        # We can't load JSON because we print to stdout!
        # &gt;&gt;&gt;&gt;&gt; STDOUT &gt;&gt;&gt;&gt;&gt;
        # The following keys are going to be deleted:
        # {
        #     &quot;minions&quot;: [
        #         &quot;minibar&quot;
        #     ]
        # }
        # Key for minion minibar deleted.
        # &lt;&lt;&lt;&lt;&lt; STDOUT &lt;&lt;&lt;&lt;&lt;
        assert &quot;minions&quot; in ret.stdout
        assert min_name in ret.stdout
        # Check Key
        ret = salt_key_cli.run(&quot;-p&quot;, min_name)
        assert ret.exitcode == 0
        assert ret.json == {}
    finally:
        if os.path.exists(key):
            os.unlink(key)


@pytest.mark.skip_if_not_root
@pytest.mark.destructive_test
@pytest.mark.skip_on_windows(reason=&quot;PAM is not supported on Windows&quot;)
def test_remove_key_eauth(salt_key_cli, salt_master, saltdev_account):
    &quot;&quot;&quot;
    test salt-key -d usage
    &quot;&quot;&quot;
    min_name = random_string(&quot;minibar-&quot;)
    pki_dir = salt_master.config[&quot;pki_dir&quot;]
    key = os.path.join(pki_dir, &quot;minions&quot;, min_name)

    with salt.utils.files.fopen(key, &quot;w&quot;) as fp:
        fp.write(PUB_KEY)

    try:
        # Check Key
        ret = salt_key_cli.run(&quot;-p&quot;, min_name)
        assert ret.exitcode == 0
        assert &quot;minions&quot; in ret.json
        assert min_name in ret.json[&quot;minions&quot;]
        assert &quot;-----BEGIN PUBLIC KEY-----&quot; in ret.json[&quot;minions&quot;][min_name]
        # Remove Key
        ret = salt_key_cli.run(
            &quot;-d&quot;,
            min_name,
            &quot;-y&quot;,
            &quot;--eauth&quot;,
            &quot;pam&quot;,
            &quot;--username&quot;,
            USERA,
            &quot;--password&quot;,
            USERA_PWD,
        )
        assert ret.exitcode == 0
        # We can't load JSON because we print to stdout!
        # &gt;&gt;&gt;&gt;&gt; STDOUT &gt;&gt;&gt;&gt;&gt;
        # The following keys are going to be deleted:
        # {
        #     &quot;minions&quot;: [
        #         &quot;minibar&quot;
        #     ]
        # }
        # Key for minion minibar deleted.
        # &lt;&lt;&lt;&lt;&lt; STDOUT &lt;&lt;&lt;&lt;&lt;
        assert &quot;minions&quot; in ret.stdout
        assert min_name in ret.stdout
        # Check Key
        ret = salt_key_cli.run(&quot;-p&quot;, min_name)
        assert ret.exitcode == 0
        assert ret.json == {}
    finally:
        if os.path.exists(key):
            os.unlink(key)


@pytest.mark.parametrize(&quot;key_type&quot;, (&quot;acc&quot;, &quot;pre&quot;, &quot;den&quot;, &quot;un&quot;, &quot;rej&quot;))
def test_list_accepted_args(salt_key_cli, key_type):
    &quot;&quot;&quot;
    test salt-key -l for accepted arguments
    &quot;&quot;&quot;
    # Should not trigger any error
    ret = salt_key_cli.run(&quot;-l&quot;, key_type)
    assert ret.exitcode == 0
    assert &quot;error:&quot; not in ret.stdout
    # Should throw an error now
    ret = salt_key_cli.run(&quot;-l&quot;, &quot;foo-{}&quot;.format(key_type))
    assert ret.exitcode != 0
    assert &quot;error:&quot; in ret.stderr


def test_list_all(salt_key_cli, salt_minion, salt_sub_minion):
    &quot;&quot;&quot;
    test salt-key -L
    &quot;&quot;&quot;
    ret = salt_key_cli.run(&quot;-L&quot;)
    assert ret.exitcode == 0
    expected = {
        &quot;minions_rejected&quot;: [],
        &quot;minions_denied&quot;: [],
        &quot;minions_pre&quot;: [],
        &quot;minions&quot;: [salt_minion.id, salt_sub_minion.id],
    }
    assert ret.json == expected


def test_list_all_yaml_out(salt_key_cli, salt_minion, salt_sub_minion):
    &quot;&quot;&quot;
    test salt-key -L --out=yaml
    &quot;&quot;&quot;
    ret = salt_key_cli.run(&quot;-L&quot;, &quot;--out=yaml&quot;)
    assert ret.exitcode == 0
    output = salt.utils.yaml.safe_load(ret.stdout)
    expected = {
        &quot;minions_rejected&quot;: [],
        &quot;minions_denied&quot;: [],
        &quot;minions_pre&quot;: [],
        &quot;minions&quot;: [salt_minion.id, salt_sub_minion.id],
    }
    assert output == expected


def test_list_all_raw_out(salt_key_cli, salt_minion, salt_sub_minion):
    &quot;&quot;&quot;
    test salt-key -L --out=raw
    &quot;&quot;&quot;
    ret = salt_key_cli.run(&quot;-L&quot;, &quot;--out=raw&quot;)
    assert ret.exitcode == 0
    output = ast.literal_eval(ret.stdout)
    expected = {
        &quot;minions_rejected&quot;: [],
        &quot;minions_denied&quot;: [],
        &quot;minions_pre&quot;: [],
        &quot;minions&quot;: [salt_minion.id, salt_sub_minion.id],
    }
    assert output == expected


def test_list_acc(salt_key_cli, salt_minion, salt_sub_minion):
    &quot;&quot;&quot;
    test salt-key -l acc
    &quot;&quot;&quot;
    ret = salt_key_cli.run(&quot;-l&quot;, &quot;acc&quot;)
    assert ret.exitcode == 0
    expected = {&quot;minions&quot;: [salt_minion.id, salt_sub_minion.id]}
    assert ret.json == expected


@pytest.mark.skip_if_not_root
@pytest.mark.destructive_test
@pytest.mark.skip_on_windows(reason=&quot;PAM is not supported on Windows&quot;)
def test_list_acc_eauth(salt_key_cli, saltdev_account, salt_minion, salt_sub_minion):
    &quot;&quot;&quot;
    test salt-key -l with eauth
    &quot;&quot;&quot;
    ret = salt_key_cli.run(
        &quot;-l&quot;, &quot;acc&quot;, &quot;--eauth&quot;, &quot;pam&quot;, &quot;--username&quot;, USERA, &quot;--password&quot;, USERA_PWD
    )
    assert ret.exitcode == 0
    expected = {&quot;minions&quot;: [salt_minion.id, salt_sub_minion.id]}
    assert ret.json == expected


@pytest.mark.skip_if_not_root
@pytest.mark.destructive_test
@pytest.mark.skip_on_windows(reason=&quot;PAM is not supported on Windows&quot;)
def test_list_acc_eauth_bad_creds(salt_key_cli, saltdev_account):
    &quot;&quot;&quot;
    test salt-key -l with eauth and bad creds
    &quot;&quot;&quot;
    ret = salt_key_cli.run(
        &quot;-l&quot;,
        &quot;acc&quot;,
        &quot;--eauth&quot;,
        &quot;pam&quot;,
        &quot;--username&quot;,
        USERA,
        &quot;--password&quot;,
        &quot;wrongpassword&quot;,
    )
    assert (
        ret.stdout
        == 'Authentication failure of type &quot;eauth&quot; occurred for user {}.'.format(USERA)
    )


def test_list_acc_wrong_eauth(salt_key_cli):
    &quot;&quot;&quot;
    test salt-key -l with wrong eauth
    &quot;&quot;&quot;
    ret = salt_key_cli.run(
        &quot;-l&quot;,
        &quot;acc&quot;,
        &quot;--eauth&quot;,
        &quot;wrongeauth&quot;,
        &quot;--username&quot;,
        USERA,
        &quot;--password&quot;,
        USERA_PWD,
    )
    assert ret.exitcode == 0, ret
    assert re.search(
        r&quot;^The specified external authentication system \&quot;wrongeauth\&quot; is not&quot;
        r&quot; available\nAvailable eauth types: auto, .*&quot;,
        ret.stdout.replace(&quot;\r\n&quot;, &quot;\n&quot;),
    )


def test_list_un(salt_key_cli):
    &quot;&quot;&quot;
    test salt-key -l un
    &quot;&quot;&quot;
    ret = salt_key_cli.run(&quot;-l&quot;, &quot;un&quot;)
    assert ret.exitcode == 0
    expected = {&quot;minions_pre&quot;: []}
    assert ret.json == expected


def test_keys_generation(salt_key_cli, tmp_path):
    ret = salt_key_cli.run(&quot;--gen-keys&quot;, &quot;minibar&quot;, &quot;--gen-keys-dir&quot;, str(tmp_path))
    assert ret.exitcode == 0
    try:
        key_names = (&quot;minibar.pub&quot;, &quot;minibar.pem&quot;)
        for fname in key_names:
            fpath = tmp_path / fname
            assert fpath.is_file()
    finally:
        for filename in tmp_path.iterdir():
            filename.chmod(0o700)


def test_keys_generation_keysize_min(salt_key_cli, tmp_path):
    ret = salt_key_cli.run(
        &quot;--gen-keys&quot;, &quot;minibar&quot;, &quot;--gen-keys-dir&quot;, str(tmp_path), &quot;--keysize&quot;, &quot;1024&quot;
    )
    assert ret.exitcode != 0
    assert &quot;error: The minimum value for keysize is 2048&quot; in ret.stderr


def test_keys_generation_keysize_max(salt_key_cli, tmp_path):
    ret = salt_key_cli.run(
        &quot;--gen-keys&quot;, &quot;minibar&quot;, &quot;--gen-keys-dir&quot;, str(tmp_path), &quot;--keysize&quot;, &quot;32769&quot;
    )
    assert ret.exitcode != 0
    assert &quot;error: The maximum value for keysize is 32768&quot; in ret.stderr


def test_accept_bad_key(salt_master, salt_key_cli):
    &quot;&quot;&quot;
    test salt-key -d usage
    &quot;&quot;&quot;
    min_name = random_string(&quot;minibar-&quot;)
    pki_dir = salt_master.config[&quot;pki_dir&quot;]
    key = os.path.join(pki_dir, &quot;minions_pre&quot;, min_name)

    with salt.utils.files.fopen(key, &quot;w&quot;) as fp:
        fp.write(&quot;&quot;)

    try:
        # Check Key
        ret = salt_key_cli.run(&quot;-y&quot;, &quot;-a&quot;, min_name)
        assert ret.exitcode == 0
        assert &quot;invalid key for {}&quot;.format(min_name) in ret.stderr
    finally:
        if os.path.exists(key):
            os.remove(key)
</PRE>
</div>
  </div>
</body>
</html>
