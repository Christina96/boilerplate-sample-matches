
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.1502683363148485%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-helper.py</h3>
            <pre><code>1  import asyncio
2  import math
3  import os
4  import re
5  import sys
6  import time
7  from traceback import format_exc
8  from urllib.parse import unquote
9  from urllib.request import urlretrieve
10  from .. import run_as_module
11  if run_as_module:
12      from ..configs import Var
13  try:
14      from aiohttp import ClientSession as aiohttp_client
15  except ImportError:
16      aiohttp_client = None
17      try:
18          import requests
19      except ImportError:
20          requests = None
21  try:
22      import heroku3
23  except ImportError:
24      heroku3 = None
25  try:
26      from git import Repo
27      from git.exc import GitCommandError, InvalidGitRepositoryError, NoSuchPathError
28  except ImportError:
29      Repo = None
30  import asyncio
31  import multiprocessing
32  from concurrent.futures import ThreadPoolExecutor
33  from functools import partial, wraps
34  from telethon.helpers import _maybe_await
35  from telethon.tl import types
36  from telethon.utils import get_display_name
37  from .._misc import CMD_HELP
38  from .._misc._wrappers import eod, eor
39  from ..exceptions import DependencyMissingError
40  from . import *
41  if run_as_module:
42      from ..dB._core import ADDONS, HELP, LIST, LOADED
43  from ..version import ultroid_version
44  from .FastTelethon import download_file as downloadable
45  from .FastTelethon import upload_file as uploadable
46  def run_async(function):
47      @wraps(function)
48      async def wrapper(*args, **kwargs):
49          return await asyncio.get_event_loop().run_in_executor(
50              ThreadPoolExecutor(max_workers=multiprocessing.cpu_count() * 5),
51              partial(function, *args, **kwargs),
52          )
53      return wrapper
54  def make_mention(user, custom=None):
55      if user.username:
56          return f"@{user.username}"
57      return inline_mention(user, custom=custom)
58  def inline_mention(user, custom=None, html=False):
59      mention_text = get_display_name(user) or "Deleted Account" if not custom else custom
60      if isinstance(user, types.User):
61          if html:
62              return f"<a href=tg://user?id={user.id}>{mention_text}</a>"
63          return f"[{mention_text}](tg://user?id={user.id})"
64      if isinstance(user, types.Channel) and user.username:
65          if html:
66              return f"<a href=https://t.me/{user.username}>{mention_text}</a>"
67          return f"[{mention_text}](https://t.me/{user.username})"
68      return mention_text
69  def un_plug(shortname):
70      from .. import asst, ultroid_bot
71      try:
72          all_func = LOADED[shortname]
73          for client in [ultroid_bot, asst]:
74              for x, _ in client.list_event_handlers():
75                  if x in all_func:
76                      client.remove_event_handler(x)
77          del LOADED[shortname]
78          del LIST[shortname]
79          ADDONS.remove(shortname)
80      except (ValueError, KeyError):
81          name = f"addons.{shortname}"
82          for client in [ultroid_bot, asst]:
83              for i in reversed(range(len(client._event_builders))):
84                  ev, cb = client._event_builders[i]
85                  if cb.__module__ == name:
86                      del client._event_builders[i]
87                      try:
88                          del LOADED[shortname]
89                          del LIST[shortname]
90                          ADDONS.remove(shortname)
91                      except KeyError:
92                          pass
93  if run_as_module:
94      async def safeinstall(event):
95          from .. import HNDLR
96          from ..startup.utils import load_addons
97          if not event.reply_to:
98              return await eod(
99                  event, f"Please use `{HNDLR}install` as reply to a .py file."
100              )
101          ok = await eor(event, "`Installing...`")
102          reply = await event.get_reply_message()
103          if not (
104              reply.media
105              and hasattr(reply.media, "document")
106              and reply.file.name
107              and reply.file.name.endswith(".py")
108          ):
109              return await eod(ok, "`Please reply to any python plugin`")
110          plug = reply.file.name.replace(".py", "")
111          if plug in list(LOADED):
112              return await eod(ok, f"Plugin `{plug}` is already installed.")
113          sm = reply.file.name.replace("_", "-").replace("|", "-")
114          dl = await reply.download_media(f"addons/{sm}")
115          if event.text[9:] != "f":
116              read = open(dl).read()
117              for dan in KEEP_SAFE().All:
118                  if re.search(dan, read):
119                      os.remove(dl)
120                      return await ok.edit(
121                          f"**Installation Aborted.**\n**Reason:** Occurance of `{dan}` in `{reply.file.name}`.\n\nIf you trust the provider and/or know what you're doing, use `{HNDLR}install f` to force install.",
122                      )
123          try:
124              load_addons(dl)  # dl.split("/")[-1].replace(".py", ""))
125          except BaseException:
126              os.remove(dl)
127              return await eor(ok, f"**ERROR**\n\n`{format_exc()}`", time=30)
128          plug = sm.replace(".py", "")
129          if plug in HELP:
130              output = "**Plugin** - `{}`\n".format(plug)
131              for i in HELP[plug]:
132                  output += i
133              output += "\n¬© @TeamUltroid"
134              await eod(ok, f"‚úì `Ultroid - Installed`: `{plug}` ‚úì\n\n{output}")
135          elif plug in CMD_HELP:
136              output = f"Plugin Name-{plug}\n\n‚úò Commands Available-\n\n"
137              output += str(CMD_HELP[plug])
138              await eod(ok, f"‚úì `Ultroid - Installed`: `{plug}` ‚úì\n\n{output}")
139          else:
140              try:
141                  x = f"Plugin Name-{plug}\n\n‚úò Commands Available-\n\n"
142                  for d in LIST[plug]:
143                      x += HNDLR + d + "\n"
144                  await eod(ok, f"‚úì `Ultroid - Installed`: `{plug}` ‚úì\n\n`{x}`")
145              except BaseException:
146                  await eod(ok, f"‚úì `Ultroid - Installed`: `{plug}` ‚úì")
147      async def heroku_logs(event):
148          from .. import LOGS
149          xx = await eor(event, "`Processing...`")
150          if not (Var.HEROKU_API and Var.HEROKU_APP_NAME):
151              return await xx.edit(
152                  "Please set `HEROKU_APP_NAME` and `HEROKU_API` in vars."
153              )
154          try:
155              app = (heroku3.from_key(Var.HEROKU_API)).app(Var.HEROKU_APP_NAME)
156          except BaseException as se:
157              LOGS.info(se)
158              return await xx.edit(
159                  "`HEROKU_API` and `HEROKU_APP_NAME` is wrong! Kindly re-check in config vars."
160              )
161          await xx.edit("`Downloading Logs...`")
162          ok = app.get_log()
163          with open("ultroid-heroku.log", "w") as log:
164              log.write(ok)
165          await event.client.send_file(
166              event.chat_id,
167              file="ultroid-heroku.log",
168              thumb=ULTConfig.thumb,
169              caption="**Ultroid Heroku Logs.**",
170          )
171          os.remove("ultroid-heroku.log")
172          await xx.delete()
173      async def def_logs(ult, file):
174          await ult.respond(
175              "**Ultroid Logs.**",
176              file=file,
177              thumb=ULTConfig.thumb,
178          )
179      async def updateme_requirements():
180          await bash(
181              f"{sys.executable} -m pip install --no-cache-dir -r requirements.txt"
182          )
183      @run_async
184      def gen_chlog(repo, diff):
185          UPSTREAM_REPO_URL = (
186              Repo().remotes[0].config_reader.get("url").replace(".git", "")
187          )
188          ac_br = repo.active_branch.name
189          ch_log = tldr_log = ""
190          ch = f"<b>Ultroid {ultroid_version} updates for <a href={UPSTREAM_REPO_URL}/tree/{ac_br}>[{ac_br}]</a>:</b>"
191          ch_tl = f"Ultroid {ultroid_version} updates for {ac_br}:"
192          d_form = "%d/%m/%y || %H:%M"
193          for c in repo.iter_commits(diff):
194              ch_log += f"\n\nüí¨ <b>{c.count()}</b> üóì <b>[{c.committed_datetime.strftime(d_form)}]</b>\n<b><a href={UPSTREAM_REPO_URL.rstrip('/')}/commit/{c}>[{c.summary}]</a></b> üë®‚Äçüíª <code>{c.author}</code>"
195              tldr_log += f"\n\nüí¨ {c.count()} üóì [{c.committed_datetime.strftime(d_form)}]\n[{c.summary}] üë®‚Äçüíª {c.author}"
196          if ch_log:
197              return str(ch + ch_log), str(ch_tl + tldr_log)
198          return ch_log, tldr_log
199  async def bash(cmd, run_code=0):
200      process = await asyncio.create_subprocess_shell(
201          cmd,
202          stdout=asyncio.subprocess.PIPE,
203          stderr=asyncio.subprocess.PIPE,
204      )
205      stdout, stderr = await process.communicate()
206      err = stderr.decode().strip() or None
207      out = stdout.decode().strip()
208      if not run_code and err:
209          if match := re.match("\/bin\/sh: (.*): ?(\w+): not found", err):
210              return out, f"{match.group(2).upper()}_NOT_FOUND"
211      return out, err
212  async def updater():
213      from .. import LOGS
214      try:
215          off_repo = Repo().remotes[0].config_reader.get("url").replace(".git", "")
216      except Exception as er:
217          LOGS.exception(er)
218          return
219      try:
220          repo = Repo()
221      except NoSuchPathError as error:
222          LOGS.info(f"`directory {error} is not found`")
223          Repo().__del__()
224          return
225      except GitCommandError as error:
226          LOGS.info(f"`Early failure! {error}`")
227          Repo().__del__()
228          return
229      except InvalidGitRepositoryError:
<span onclick='openModal()' class='match'>230          repo = Repo.init()
231          origin = repo.create_remote("upstream", off_repo)
232          origin.fetch()
233          repo.create_head("main", origin.refs.main)
</span>234          repo.heads.main.set_tracking_branch(origin.refs.main)
235          repo.heads.main.checkout(True)
236      ac_br = repo.active_branch.name
237      repo.create_remote("upstream", off_repo) if "upstream" not in repo.remotes else None
238      ups_rem = repo.remote("upstream")
239      ups_rem.fetch(ac_br)
240      changelog, tl_chnglog = await gen_chlog(repo, f"HEAD..upstream/{ac_br}")
241      return bool(changelog)
242  async def uploader(file, name, taime, event, msg):
243      with open(file, "rb") as f:
244          result = await uploadable(
245              client=event.client,
246              file=f,
247              filename=name,
248              progress_callback=lambda d, t: asyncio.get_event_loop().create_task(
249                  progress(
250                      d,
251                      t,
252                      event,
253                      taime,
254                      msg,
255                  ),
256              ),
257          )
258      return result
259  async def downloader(filename, file, event, taime, msg):
260      with open(filename, "wb") as fk:
261          result = await downloadable(
262              client=event.client,
263              location=file,
264              out=fk,
265              progress_callback=lambda d, t: asyncio.get_event_loop().create_task(
266                  progress(
267                      d,
268                      t,
269                      event,
270                      taime,
271                      msg,
272                  ),
273              ),
274          )
275      return result
276  async def async_searcher(
277      url: str,
278      post: bool = False,
279      head: bool = False,
280      headers: dict = None,
281      evaluate=None,
282      object: bool = False,
283      re_json: bool = False,
284      re_content: bool = False,
285      *args,
286      **kwargs,
287  ):
288      if aiohttp_client:
289          async with aiohttp_client(headers=headers) as client:
290              method = client.head if head else (client.post if post else client.get)
291              data = await method(url, *args, **kwargs)
292              if evaluate:
293                  return await evaluate(data)
294              if re_json:
295                  return await data.json()
296              if re_content:
297                  return await data.read()
298              if head or object:
299                  return data
300              return await data.text()
301      else:
302          raise DependencyMissingError("install 'aiohttp' to use this.")
303  async def download_file(link, name, validate=False):
304      async def _download(content):
305          if validate and "application/json" in content.headers.get("Content-Type"):
306              return None, await content.json()
307          with open(name, "wb") as file:
308              file.write(await content.read())
309          return name, ""
310      return await async_searcher(link, evaluate=_download)
311  async def fast_download(download_url, filename=None, progress_callback=None):
312      if not aiohttp_client:
313          return await download_file(download_url, filename)[0], None
314      async with aiohttp_client() as session:
315          async with session.get(download_url, timeout=None) as response:
316              if not filename:
317                  filename = unquote(download_url.rpartition("/")[-1])
318              total_size = int(response.headers.get("content-length", 0)) or None
319              downloaded_size = 0
320              start_time = time.time()
321              with open(filename, "wb") as f:
322                  async for chunk in response.content.iter_chunked(1024):
323                      if chunk:
324                          f.write(chunk)
325                          downloaded_size += len(chunk)
326                      if progress_callback and total_size:
327                          await _maybe_await(
328                              progress_callback(downloaded_size, total_size)
329                          )
330              return filename, time.time() - start_time
331  def mediainfo(media):
332      xx = str((str(media)).split("(", maxsplit=1)[0])
333      m = ""
334      if xx == "MessageMediaDocument":
335          mim = media.document.mime_type
336          if mim == "application/x-tgsticker":
337              m = "sticker animated"
338          elif "image" in mim:
339              if mim == "image/webp":
340                  m = "sticker"
341              elif mim == "image/gif":
342                  m = "gif as doc"
343              else:
344                  m = "pic as doc"
345          elif "video" in mim:
346              if "DocumentAttributeAnimated" in str(media):
347                  m = "gif"
348              elif "DocumentAttributeVideo" in str(media):
349                  i = str(media.document.attributes[0])
350                  if "supports_streaming=True" in i:
351                      m = "video"
352                  m = "video as doc"
353              else:
354                  m = "video"
355          elif "audio" in mim:
356              m = "audio"
357          else:
358              m = "document"
359      elif xx == "MessageMediaPhoto":
360          m = "pic"
361      elif xx == "MessageMediaWebPage":
362          m = "web"
363      return m
364  def time_formatter(milliseconds):
365      minutes, seconds = divmod(int(milliseconds / 1000), 60)
366      hours, minutes = divmod(minutes, 60)
367      days, hours = divmod(hours, 24)
368      weeks, days = divmod(days, 7)
369      tmp = (
370          ((str(weeks) + "w:") if weeks else "")
371          + ((str(days) + "d:") if days else "")
372          + ((str(hours) + "h:") if hours else "")
373          + ((str(minutes) + "m:") if minutes else "")
374          + ((str(seconds) + "s") if seconds else "")
375      )
376      if not tmp:
377          return "0s"
378      if tmp.endswith(":"):
379          return tmp[:-1]
380      return tmp
381  def humanbytes(size):
382      if not size:
383          return "0 B"
384      for unit in ["", "K", "M", "G", "T"]:
385          if size < 1024:
386              break
387          size /= 1024
388      if isinstance(size, int):
389          size = f"{size}{unit}B"
390      elif isinstance(size, float):
391          size = f"{size:.2f}{unit}B"
392      return size
393  def numerize(number):
394      if not number:
395          return None
396      unit = ""
397      for unit in ["", "K", "M", "B", "T"]:
398          if number < 1000:
399              break
400          number /= 1000
401      if isinstance(number, int):
402          number = f"{number}{unit}"
403      elif isinstance(number, float):
404          number = f"{number:.2f}{unit}"
405      return number
406  No_Flood = {}
407  async def progress(current, total, event, start, type_of_ps, file_name=None):
408      now = time.time()
409      if No_Flood.get(event.chat_id):
410          if No_Flood[event.chat_id].get(event.id):
411              if (now - No_Flood[event.chat_id][event.id]) < 1.1:
412                  return
413          else:
414              No_Flood[event.chat_id].update({event.id: now})
415      else:
416          No_Flood.update({event.chat_id: {event.id: now}})
417      diff = time.time() - start
418      if round(diff % 10.00) == 0 or current == total:
419          percentage = current * 100 / total
420          speed = current / diff
421          time_to_completion = round((total - current) / speed) * 1000
422          progress_str = "`[{0}{1}] {2}%`\n\n".format(
423              "".join("‚óè" for i in range(math.floor(percentage / 5))),
424              "".join("" for i in range(20 - math.floor(percentage / 5))),
425              round(percentage, 2),
426          )
427          tmp = (
428              progress_str
429              + "`{0} of {1}`\n\n`‚ú¶ Speed: {2}/s`\n\n`‚ú¶ ETA: {3}`\n\n".format(
430                  humanbytes(current),
431                  humanbytes(total),
432                  humanbytes(speed),
433                  time_formatter(time_to_completion),
434              )
435          )
436          if file_name:
437              await event.edit(
438                  "`‚ú¶ {}`\n\n`File Name: {}`\n\n{}".format(type_of_ps, file_name, tmp)
439              )
440          else:
441              await event.edit("`‚ú¶ {}`\n\n{}".format(type_of_ps, tmp))
442  async def restart(ult=None):
443      if Var.HEROKU_APP_NAME and Var.HEROKU_API:
444          try:
445              Heroku = heroku3.from_key(Var.HEROKU_API)
446              app = Heroku.apps()[Var.HEROKU_APP_NAME]
447              if ult:
448                  await ult.edit("`Restarting your app, please wait for a minute!`")
449              app.restart()
450          except BaseException as er:
451              if ult:
452                  return await eor(
453                      ult,
454                      "`HEROKU_API` or `HEROKU_APP_NAME` is wrong! Kindly re-check in config vars.",
455                  )
456              LOGS.exception(er)
457      else:
458          if len(sys.argv) == 1:
459              os.execl(sys.executable, sys.executable, "-m", "pyUltroid")
460          else:
461              os.execl(
462                  sys.executable,
463                  sys.executable,
464                  "-m",
465                  "pyUltroid",
466                  sys.argv[1],
467                  sys.argv[2],
468                  sys.argv[3],
469                  sys.argv[4],
470                  sys.argv[5],
471                  sys.argv[6],
472              )
473  async def shutdown(ult):
474      from .. import HOSTED_ON, LOGS
475      ult = await eor(ult, "Shutting Down")
476      if HOSTED_ON == "heroku":
477          if not (Var.HEROKU_APP_NAME and Var.HEROKU_API):
478              return await ult.edit("Please Fill `HEROKU_APP_NAME` and `HEROKU_API`")
479          dynotype = os.getenv("DYNO").split(".")[0]
480          try:
481              Heroku = heroku3.from_key(Var.HEROKU_API)
482              app = Heroku.apps()[Var.HEROKU_APP_NAME]
483              await ult.edit("`Shutting Down your app, please wait for a minute!`")
484              app.process_formation()[dynotype].scale(0)
485          except BaseException as e:
486              LOGS.exception(e)
487              return await ult.edit(
488                  "`HEROKU_API` and `HEROKU_APP_NAME` is wrong! Kindly re-check in config vars."
489              )
490      else:
491          sys.exit()
</code></pre>
        </div>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-loader.py</h3>
            <pre><code>1  import base64
2  import hashlib
3  import itertools
4  import json
5  import os
6  import re
7  import string
8  import struct
9  import sys
10  import time
11  from .config import load_config_file
12  from .reset import (
13      ClassicReset,
14      CustomReset,
15      DEFAULT_RESET_DELAY,
16      HardReset,
17      USBJTAGSerialReset,
18      UnixTightReset,
19  )
20  from .util import FatalError, NotImplementedInROMError, UnsupportedCommandError
21  from .util import byte, hexify, mask_to_shift, pad_to, strip_chip_name
22  try:
23      import serial
24  except ImportError:
25      print(
26          "Pyserial is not installed for %s. "
27          "Check the README for installation instructions." % (sys.executable)
28      )
29      raise
30  try:
31      if "serialization" in serial.__doc__ and "deserialization" in serial.__doc__:
32          raise ImportError(
33              "esptool.py depends on pyserial, but there is a conflict with a currently "
34              "installed package named 'serial'.\n"
35              "You may work around this by 'pip uninstall serial; pip install pyserial' "
36              "but this may break other installed Python software "
37              "that depends on 'serial'.\n"
38              "There is no good fix for this right now, "
39              "apart from configuring virtualenvs. "
40              "See https://github.com/espressif/esptool/issues/269#issuecomment-385298196"
41              " for discussion of the underlying issue(s)."
42          )
43  except TypeError:
44      pass  # __doc__ returns None for pyserial
45  try:
46      import serial.tools.list_ports as list_ports
47  except ImportError:
48      print(
49          "The installed version (%s) of pyserial appears to be too old for esptool.py "
50          "(Python interpreter %s). Check the README for installation instructions."
51          % (sys.VERSION, sys.executable)
52      )
53      raise
54  except Exception:
55      if sys.platform == "darwin":
56          list_ports = None
57      else:
58          raise
59  cfg, _ = load_config_file()
60  cfg = cfg["esptool"]
61  DEFAULT_TIMEOUT = cfg.getfloat("timeout", 3)
62  CHIP_ERASE_TIMEOUT = cfg.getfloat("chip_erase_timeout", 120)
63  MAX_TIMEOUT = cfg.getfloat("max_timeout", CHIP_ERASE_TIMEOUT * 2)
64  SYNC_TIMEOUT = cfg.getfloat("sync_timeout", 0.1)
65  MD5_TIMEOUT_PER_MB = cfg.getfloat("md5_timeout_per_mb", 8)
66  ERASE_REGION_TIMEOUT_PER_MB = cfg.getfloat("erase_region_timeout_per_mb", 30)
67  ERASE_WRITE_TIMEOUT_PER_MB = cfg.getfloat("erase_write_timeout_per_mb", 40)
68  MEM_END_ROM_TIMEOUT = cfg.getfloat("mem_end_rom_timeout", 0.2)
69  DEFAULT_SERIAL_WRITE_TIMEOUT = cfg.getfloat("serial_write_timeout", 10)
70  DEFAULT_CONNECT_ATTEMPTS = cfg.getint("connect_attempts", 7)
71  WRITE_BLOCK_ATTEMPTS = cfg.getint("write_block_attempts", 3)
72  STUBS_DIR = os.path.join(os.path.dirname(__file__), "targets", "stub_flasher")
73  def get_stub_json_path(chip_name):
74      chip_name = strip_chip_name(chip_name)
75      chip_name = chip_name.replace("esp", "")
76      return os.path.join(STUBS_DIR, f"stub_flasher_{chip_name}.json")
77  def timeout_per_mb(seconds_per_mb, size_bytes):
78      result = seconds_per_mb * (size_bytes / 1e6)
79      if result < DEFAULT_TIMEOUT:
80          return DEFAULT_TIMEOUT
81      return result
82  def check_supported_function(func, check_func):
83      def inner(*args, **kwargs):
84          obj = args[0]
85          if check_func(obj):
86              return func(*args, **kwargs)
87          else:
88              raise NotImplementedInROMError(obj, func)
89      return inner
90  def stub_function_only(func):
91      return check_supported_function(func, lambda o: o.IS_STUB)
92  def stub_and_esp32_function_only(func):
93      return check_supported_function(
94          func, lambda o: o.IS_STUB or o.CHIP_NAME not in ["ESP8266"]
95      )
96  def esp32s3_or_newer_function_only(func):
97      return check_supported_function(
98          func, lambda o: o.CHIP_NAME not in ["ESP8266", "ESP32", "ESP32-S2"]
99      )
100  class StubFlasher:
101      def __init__(self, json_path):
102          with open(json_path) as json_file:
103              stub = json.load(json_file)
104          self.text = base64.b64decode(stub["text"])
105          self.text_start = stub["text_start"]
106          self.entry = stub["entry"]
107          try:
108              self.data = base64.b64decode(stub["data"])
109              self.data_start = stub["data_start"]
110          except KeyError:
111              self.data = None
112              self.data_start = None
113  class ESPLoader(object):
114      CHIP_NAME = "Espressif device"
115      IS_STUB = False
116      FPGA_SLOW_BOOT = False
117      DEFAULT_PORT = "/dev/ttyUSB0"
118      USES_RFC2217 = False
119      ESP_FLASH_BEGIN = 0x02
120      ESP_FLASH_DATA = 0x03
121      ESP_FLASH_END = 0x04
122      ESP_MEM_BEGIN = 0x05
123      ESP_MEM_END = 0x06
124      ESP_MEM_DATA = 0x07
125      ESP_SYNC = 0x08
126      ESP_WRITE_REG = 0x09
127      ESP_READ_REG = 0x0A
128      ESP_SPI_SET_PARAMS = 0x0B
129      ESP_SPI_ATTACH = 0x0D
130      ESP_READ_FLASH_SLOW = 0x0E  # ROM only, much slower than the stub flash read
131      ESP_CHANGE_BAUDRATE = 0x0F
132      ESP_FLASH_DEFL_BEGIN = 0x10
133      ESP_FLASH_DEFL_DATA = 0x11
134      ESP_FLASH_DEFL_END = 0x12
135      ESP_SPI_FLASH_MD5 = 0x13
136      ESP_GET_SECURITY_INFO = 0x14
137      ESP_ERASE_FLASH = 0xD0
138      ESP_ERASE_REGION = 0xD1
139      ESP_READ_FLASH = 0xD2
140      ESP_RUN_USER_CODE = 0xD3
141      ESP_FLASH_ENCRYPT_DATA = 0xD4
142      ROM_INVALID_RECV_MSG = 0x05  # response if an invalid message is received
143      ESP_RAM_BLOCK = 0x1800
144      FLASH_WRITE_SIZE = 0x400
145      ESP_ROM_BAUD = 115200
146      ESP_IMAGE_MAGIC = 0xE9
147      ESP_CHECKSUM_MAGIC = 0xEF
148      FLASH_SECTOR_SIZE = 0x1000
149      UART_DATE_REG_ADDR = 0x60000078
150      CHIP_DETECT_MAGIC_REG_ADDR = 0x40001000
151      UART_CLKDIV_MASK = 0xFFFFF
152      IROM_MAP_START = 0x40200000
153      IROM_MAP_END = 0x40300000
154      STATUS_BYTES_LENGTH = 2
155      BOOTLOADER_FLASH_OFFSET = 0x0
156      SUPPORTS_ENCRYPTED_FLASH = False
157      sync_stub_detected = False
158      USB_JTAG_SERIAL_PID = 0x1001
159      UNSUPPORTED_CHIPS = {6: "ESP32-S3(beta 3)"}
160      def __init__(self, port=DEFAULT_PORT, baud=ESP_ROM_BAUD, trace_enabled=False):
161          self.secure_download_mode = False
162          self.stub_is_disabled = False
163          self.cache = {
164              "flash_id": None,
165              "chip_id": None,
166              "uart_no": None,
167          }
168          if isinstance(port, str):
169              try:
170                  self._port = serial.serial_for_url(port)
171              except serial.serialutil.SerialException:
172                  raise FatalError(f"Could not open {port}, the port doesn't exist")
173          else:
174              self._port = port
175          self._slip_reader = slip_reader(self._port, self.trace)
176          self._set_port_baudrate(baud)
177          self._trace_enabled = trace_enabled
178          try:
179              self._port.write_timeout = DEFAULT_SERIAL_WRITE_TIMEOUT
180          except NotImplementedError:
181              self._port.write_timeout = None
182      @property
183      def serial_port(self):
184          return self._port.port
185      def _set_port_baudrate(self, baud):
186          try:
187              self._port.baudrate = baud
188          except IOError:
189              raise FatalError(
190                  "Failed to set baud rate %d. The driver may not support this rate."
191                  % baud
192              )
193      def read(self):
194          return next(self._slip_reader)
195      def write(self, packet):
196          buf = (
197              b"\xc0"
198              + (packet.replace(b"\xdb", b"\xdb\xdd").replace(b"\xc0", b"\xdb\xdc"))
199              + b"\xc0"
200          )
201          self.trace("Write %d bytes: %s", len(buf), HexFormatter(buf))
202          self._port.write(buf)
203      def trace(self, message, *format_args):
204          if self._trace_enabled:
205              now = time.time()
206              try:
207                  delta = now - self._last_trace
208              except AttributeError:
209                  delta = 0.0
210              self._last_trace = now
211              prefix = "TRACE +%.3f " % delta
212              print(prefix + (message % format_args))
213      @staticmethod
214      def checksum(data, state=ESP_CHECKSUM_MAGIC):
215          for b in data:
216              state ^= b
217          return state
218      def command(
219          self,
220          op=None,
221          data=b"",
222          chk=0,
223          wait_response=True,
224          timeout=DEFAULT_TIMEOUT,
225      ):
226          saved_timeout = self._port.timeout
227          new_timeout = min(timeout, MAX_TIMEOUT)
228          if new_timeout != saved_timeout:
229              self._port.timeout = new_timeout
230          try:
231              if op is not None:
232                  self.trace(
233                      "command op=0x%02x data len=%s wait_response=%d "
234                      "timeout=%.3f data=%s",
235                      op,
236                      len(data),
237                      1 if wait_response else 0,
238                      timeout,
239                      HexFormatter(data),
240                  )
241                  pkt = struct.pack(b"<BBHI", 0x00, op, len(data), chk) + data
242                  self.write(pkt)
243              if not wait_response:
244                  return
245              for retry in range(100):
246                  p = self.read()
247                  if len(p) < 8:
248                      continue
249                  (resp, op_ret, len_ret, val) = struct.unpack("<BBHI", p[:8])
250                  if resp != 1:
251                      continue
252                  data = p[8:]
253                  if op is None or op_ret == op:
254                      return val, data
255                  if byte(data, 0) != 0 and byte(data, 1) == self.ROM_INVALID_RECV_MSG:
256                      self.flush_input()
257                      raise UnsupportedCommandError(self, op)
258          finally:
259              if new_timeout != saved_timeout:
260                  self._port.timeout = saved_timeout
261          raise FatalError("Response doesn't match request")
262      def check_command(
263          self, op_description, op=None, data=b"", chk=0, timeout=DEFAULT_TIMEOUT
264      ):
265          val, data = self.command(op, data, chk, timeout=timeout)
266          if len(data) < self.STATUS_BYTES_LENGTH:
267              raise FatalError(
268                  "Failed to %s. Only got %d byte status response."
269                  % (op_description, len(data))
270              )
271          status_bytes = data[-self.STATUS_BYTES_LENGTH :]
272          if byte(status_bytes, 0) != 0:
273              raise FatalError.WithResult("Failed to %s" % op_description, status_bytes)
274          if len(data) > self.STATUS_BYTES_LENGTH:
275              return data[: -self.STATUS_BYTES_LENGTH]
276          else:
277              return val
278      def flush_input(self):
279          self._port.flushInput()
280          self._slip_reader = slip_reader(self._port, self.trace)
281      def sync(self):
282          val, _ = self.command(
283              self.ESP_SYNC, b"\x07\x07\x12\x20" + 32 * b"\x55", timeout=SYNC_TIMEOUT
284          )
285          self.sync_stub_detected = val == 0
286          for _ in range(7):
287              val, _ = self.command()
288              self.sync_stub_detected &= val == 0
289      def _get_pid(self):
290          if list_ports is None:
291              print(
292                  "\nListing all serial ports is currently not available. "
293                  "Can't get device PID."
294              )
295              return
296          active_port = self._port.port
297          if not active_port.lower().startswith(("com", "/dev/")):
298              print(
299                  "\nDevice PID identification is only supported on "
300                  "COM and /dev/ serial ports."
301              )
302              return
303          if active_port.startswith("/dev/") and os.path.islink(active_port):
304              active_port = os.path.realpath(active_port)
305          active_ports = [active_port]
306          if sys.platform == "darwin" and "tty" in active_port:
307              active_ports.append(active_port.replace("tty", "cu"))
308          ports = list_ports.comports()
309          for p in ports:
310              if p.device in active_ports:
311                  return p.pid
312          print(
313              "\nFailed to get PID of a device on {}, "
314              "using standard reset sequence.".format(active_port)
315          )
316      def _connect_attempt(self, reset_strategy, mode="default_reset"):
317          last_error = None
318          boot_log_detected = False
319          download_mode = False
320          if mode == "no_reset_no_sync":
321              return last_error
322          if mode != "no_reset":
323              if not self.USES_RFC2217:  # Might block on rfc2217 ports
324                  self._port.reset_input_buffer()
325              reset_strategy()  # Reset the chip to bootloader (download mode)
326              waiting = self._port.inWaiting()
327              read_bytes = self._port.read(waiting)
328              data = re.search(
329                  b"boot:(0x[0-9a-fA-F]+)(.*waiting for download)?", read_bytes, re.DOTALL
330              )
331              if data is not None:
332                  boot_log_detected = True
333                  boot_mode = data.group(1)
334                  download_mode = data.group(2) is not None
335          for _ in range(5):
336              try:
337                  self.flush_input()
338                  self._port.flushOutput()
339                  self.sync()
340                  return None
341              except FatalError as e:
342                  print(".", end="")
343                  sys.stdout.flush()
344                  time.sleep(0.05)
345                  last_error = e
346          if boot_log_detected:
347              last_error = FatalError(
348                  "Wrong boot mode detected ({})! "
349                  "The chip needs to be in download mode.".format(
350                      boot_mode.decode("utf-8")
351                  )
352              )
353              if download_mode:
354                  last_error = FatalError(
355                      "Download mode successfully detected, but getting no sync reply: "
356                      "The serial TX path seems to be down."
357                  )
358          return last_error
359      def get_memory_region(self, name):
360          try:
361              return [(start, end) for (start, end, n) in self.MEMORY_MAP if n == name][0]
362          except IndexError:
363              return None
364      def _construct_reset_strategy_sequence(self, mode):
365          cfg_custom_reset_sequence = cfg.get("custom_reset_sequence")
366          if cfg_custom_reset_sequence is not None:
367              return (CustomReset(self._port, cfg_custom_reset_sequence),)
368          cfg_reset_delay = cfg.getfloat("reset_delay")
369          if cfg_reset_delay is not None:
370              delay = extra_delay = cfg_reset_delay
371          else:
372              delay = DEFAULT_RESET_DELAY
373              extra_delay = DEFAULT_RESET_DELAY + 0.5
374          if (
375              self.FPGA_SLOW_BOOT
376              and os.environ.get("ESPTOOL_ENV_FPGA", "").strip() == "1"
377          ):
378              delay = extra_delay = 7
379          if mode == "usb_reset" or self._get_pid() == self.USB_JTAG_SERIAL_PID:
380              return (USBJTAGSerialReset(self._port),)
381          if os.name != "nt" and not self._port.name.startswith("rfc2217:"):
382              return (
383                  UnixTightReset(self._port, delay),
384                  UnixTightReset(self._port, extra_delay),
385                  ClassicReset(self._port, delay),
386                  ClassicReset(self._port, extra_delay),
387              )
388          return (
389              ClassicReset(self._port, delay),
390              ClassicReset(self._port, extra_delay),
391          )
392      def connect(
393          self,
394          mode="default_reset",
395          attempts=DEFAULT_CONNECT_ATTEMPTS,
396          detecting=False,
397          warnings=True,
398      ):
399          if warnings and mode in ["no_reset", "no_reset_no_sync"]:
400              print(
401                  'WARNING: Pre-connection option "{}" was selected.'.format(mode),
402                  "Connection may fail if the chip is not in bootloader "
403                  "or flasher stub mode.",
404              )
405          print("Connecting...", end="")
406          sys.stdout.flush()
407          last_error = None
408          reset_sequence = self._construct_reset_strategy_sequence(mode)
409          try:
410              for _, reset_strategy in zip(
411                  range(attempts) if attempts > 0 else itertools.count(),
412                  itertools.cycle(reset_sequence),
413              ):
414                  last_error = self._connect_attempt(reset_strategy, mode)
415                  if last_error is None:
416                      break
417          finally:
418              print("")  # end 'Connecting...' line
419          if last_error is not None:
420              raise FatalError(
421                  "Failed to connect to {}: {}"
422                  "\nFor troubleshooting steps visit: "
423                  "https://docs.espressif.com/projects/esptool/en/latest/troubleshooting.html".format(  # noqa E501
424                      self.CHIP_NAME, last_error
425                  )
426              )
427          if not detecting:
428              try:
429                  from .targets import ROM_LIST
430                  chip_magic_value = self.read_reg(ESPLoader.CHIP_DETECT_MAGIC_REG_ADDR)
431                  if chip_magic_value not in self.CHIP_DETECT_MAGIC_VALUE:
432                      actually = None
433                      for cls in ROM_LIST:
434                          if chip_magic_value in cls.CHIP_DETECT_MAGIC_VALUE:
435                              actually = cls
436                              break
437                      if warnings and actually is None:
438                          print(
439                              "WARNING: This chip doesn't appear to be a %s "
440                              "(chip magic value 0x%08x). "
441                              "Probably it is unsupported by this version of esptool."
442                              % (self.CHIP_NAME, chip_magic_value)
443                          )
444                      else:
445                          raise FatalError(
446                              "This chip is %s not %s. Wrong --chip argument?"
447                              % (actually.CHIP_NAME, self.CHIP_NAME)
448                          )
449              except UnsupportedCommandError:
450                  self.secure_download_mode = True
451              try:
452                  self.check_chip_id()
453              except UnsupportedCommandError:
454                  if self.secure_download_mode:
455                      self._connect_attempt(mode, reset_sequence[0])
456                      self.check_chip_id()
457                  else:
458                      raise
459              self._post_connect()
460      def _post_connect(self):
461          pass
462      def read_reg(self, addr, timeout=DEFAULT_TIMEOUT):
463          val, data = self.command(
464              self.ESP_READ_REG, struct.pack("<I", addr), timeout=timeout
465          )
466          if byte(data, 0) != 0:
467              raise FatalError.WithResult(
468                  "Failed to read register address %08x" % addr, data
469              )
470          return val
471      def write_reg(self, addr, value, mask=0xFFFFFFFF, delay_us=0, delay_after_us=0):
472          command = struct.pack("<IIII", addr, value, mask, delay_us)
473          if delay_after_us > 0:
474              command += struct.pack(
475                  "<IIII", self.UART_DATE_REG_ADDR, 0, 0, delay_after_us
476              )
477          return self.check_command("write target memory", self.ESP_WRITE_REG, command)
478      def update_reg(self, addr, mask, new_val):
479          shift = mask_to_shift(mask)
480          val = self.read_reg(addr)
481          val &= ~mask
482          val |= (new_val << shift) & mask
483          self.write_reg(addr, val)
484          return val
485      def mem_begin(self, size, blocks, blocksize, offset):
486          if self.IS_STUB:
487              stub = StubFlasher(get_stub_json_path(self.CHIP_NAME))
488              load_start = offset
489              load_end = offset + size
490              for start, end in [
491                  (stub.data_start, stub.data_start + len(stub.data)),
492                  (stub.text_start, stub.text_start + len(stub.text)),
493              ]:
494                  if load_start < end and load_end > start:
495                      raise FatalError(
496                          "Software loader is resident at 0x%08x-0x%08x. "
497                          "Can't load binary at overlapping address range 0x%08x-0x%08x. "
498                          "Either change binary loading address, or use the --no-stub "
499                          "option to disable the software loader."
500                          % (start, end, load_start, load_end)
501                      )
502          return self.check_command(
503              "enter RAM download mode",
504              self.ESP_MEM_BEGIN,
505              struct.pack("<IIII", size, blocks, blocksize, offset),
506          )
507      def mem_block(self, data, seq):
508          return self.check_command(
509              "write to target RAM",
510              self.ESP_MEM_DATA,
511              struct.pack("<IIII", len(data), seq, 0, 0) + data,
512              self.checksum(data),
513          )
514      def mem_finish(self, entrypoint=0):
515          timeout = DEFAULT_TIMEOUT if self.IS_STUB else MEM_END_ROM_TIMEOUT
516          data = struct.pack("<II", int(entrypoint == 0), entrypoint)
517          try:
518              return self.check_command(
519                  "leave RAM download mode", self.ESP_MEM_END, data=data, timeout=timeout
520              )
521          except FatalError:
522              if self.IS_STUB:
523                  raise
524              pass
525      def flash_begin(self, size, offset, begin_rom_encrypted=False):
526          num_blocks = (size + self.FLASH_WRITE_SIZE - 1) // self.FLASH_WRITE_SIZE
527          erase_size = self.get_erase_size(offset, size)
528          t = time.time()
529          if self.IS_STUB:
530              timeout = DEFAULT_TIMEOUT
531          else:
532              timeout = timeout_per_mb(
533                  ERASE_REGION_TIMEOUT_PER_MB, size
534              )  # ROM performs the erase up front
535          params = struct.pack(
536              "<IIII", erase_size, num_blocks, self.FLASH_WRITE_SIZE, offset
537          )
538          if self.SUPPORTS_ENCRYPTED_FLASH and not self.IS_STUB:
539              params += struct.pack("<I", 1 if begin_rom_encrypted else 0)
540          self.check_command(
541              "enter Flash download mode", self.ESP_FLASH_BEGIN, params, timeout=timeout
542          )
543          if size != 0 and not self.IS_STUB:
544              print("Took %.2fs to erase flash block" % (time.time() - t))
545          return num_blocks
546      def flash_block(self, data, seq, timeout=DEFAULT_TIMEOUT):
547          for attempts_left in range(WRITE_BLOCK_ATTEMPTS - 1, -1, -1):
548              try:
549                  self.check_command(
550                      "write to target Flash after seq %d" % seq,
551                      self.ESP_FLASH_DATA,
552                      struct.pack("<IIII", len(data), seq, 0, 0) + data,
553                      self.checksum(data),
554                      timeout=timeout,
555                  )
556                  break
557              except FatalError:
558                  if attempts_left:
559                      self.trace(
560                          "Block write failed, "
561                          f"retrying with {attempts_left} attempts left"
562                      )
563                  else:
564                      raise
565      def flash_encrypt_block(self, data, seq, timeout=DEFAULT_TIMEOUT):
566          if self.SUPPORTS_ENCRYPTED_FLASH and not self.IS_STUB:
567              return self.flash_block(data, seq, timeout)
568          for attempts_left in range(WRITE_BLOCK_ATTEMPTS - 1, -1, -1):
569              try:
570                  self.check_command(
571                      "Write encrypted to target Flash after seq %d" % seq,
572                      self.ESP_FLASH_ENCRYPT_DATA,
573                      struct.pack("<IIII", len(data), seq, 0, 0) + data,
574                      self.checksum(data),
575                      timeout=timeout,
576                  )
577                  break
578              except FatalError:
579                  if attempts_left:
580                      self.trace(
581                          "Encrypted block write failed, "
582                          f"retrying with {attempts_left} attempts left"
583                      )
584                  else:
585                      raise
586      def flash_finish(self, reboot=False):
587          pkt = struct.pack("<I", int(not reboot))
588          self.check_command("leave Flash mode", self.ESP_FLASH_END, pkt)
589      def run(self, reboot=False):
590          self.flash_begin(0, 0)
591          self.flash_finish(reboot)
592      def flash_id(self):
593          if self.cache["flash_id"] is None:
594              SPIFLASH_RDID = 0x9F
595              self.cache["flash_id"] = self.run_spiflash_command(SPIFLASH_RDID, b"", 24)
596          return self.cache["flash_id"]
597      def flash_type(self):
598          return None  # not implemented for all chip targets
599      def get_security_info(self):
600          res = self.check_command("get security info", self.ESP_GET_SECURITY_INFO, b"")
601          esp32s2 = True if len(res) == 12 else False
602          res = struct.unpack("<IBBBBBBBB" if esp32s2 else "<IBBBBBBBBII", res)
603          return {
604              "flags": res[0],
605              "flash_crypt_cnt": res[1],
606              "key_purposes": res[2:9],
607              "chip_id": None if esp32s2 else res[9],
608              "api_version": None if esp32s2 else res[10],
609          }
610      @esp32s3_or_newer_function_only
611      def get_chip_id(self):
612          if self.cache["chip_id"] is None:
613              res = self.check_command(
614                  "get security info", self.ESP_GET_SECURITY_INFO, b""
615              )
616              res = struct.unpack(
617                  "<IBBBBBBBBI", res[:16]
618              )  # 4b flags, 1b flash_crypt_cnt, 7*1b key_purposes, 4b chip_id
619              self.cache["chip_id"] = res[9]  # 2/4 status bytes invariant
620          return self.cache["chip_id"]
621      def get_uart_no(self):
622          if self.cache["uart_no"] is None:
623              self.cache["uart_no"] = self.read_reg(self.UARTDEV_BUF_NO) & 0xFF
624          return self.cache["uart_no"]
625      @classmethod
626      def parse_flash_size_arg(cls, arg):
627          try:
628              return cls.FLASH_SIZES[arg]
629          except KeyError:
630              raise FatalError(
631                  "Flash size '%s' is not supported by this chip type. "
632                  "Supported sizes: %s" % (arg, ", ".join(cls.FLASH_SIZES.keys()))
633              )
634      @classmethod
635      def parse_flash_freq_arg(cls, arg):
636          if arg is None:
637              return 0
638          try:
639              return cls.FLASH_FREQUENCY[arg]
640          except KeyError:
641              raise FatalError(
642                  "Flash frequency '%s' is not supported by this chip type. "
643                  "Supported frequencies: %s"
644                  % (arg, ", ".join(cls.FLASH_FREQUENCY.keys()))
645              )
646      def run_stub(self, stub=None):
647          if stub is None:
648              stub = StubFlasher(get_stub_json_path(self.CHIP_NAME))
649          if self.sync_stub_detected:
650              print("Stub is already running. No upload is necessary.")
651              return self.STUB_CLASS(self)
652          print("Uploading stub...")
653          for field in [stub.text, stub.data]:
654              if field is not None:
655                  offs = stub.text_start if field == stub.text else stub.data_start
656                  length = len(field)
657                  blocks = (length + self.ESP_RAM_BLOCK - 1) // self.ESP_RAM_BLOCK
658                  self.mem_begin(length, blocks, self.ESP_RAM_BLOCK, offs)
659                  for seq in range(blocks):
660                      from_offs = seq * self.ESP_RAM_BLOCK
661                      to_offs = from_offs + self.ESP_RAM_BLOCK
662                      self.mem_block(field[from_offs:to_offs], seq)
663          print("Running stub...")
664          self.mem_finish(stub.entry)
665          try:
666              p = self.read()
667          except StopIteration:
668              raise FatalError(
669                  "Failed to start stub. There was no response."
670                  "\nTry increasing timeouts, for more information see: "
671                  "https://docs.espressif.com/projects/esptool/en/latest/esptool/configuration-file.html"  # noqa E501
672              )
673          if p != b"OHAI":
674              raise FatalError(f"Failed to start stub. Unexpected response: {p}")
675          print("Stub running...")
676          return self.STUB_CLASS(self)
677      @stub_and_esp32_function_only
678      def flash_defl_begin(self, size, compsize, offset):
679          num_blocks = (compsize + self.FLASH_WRITE_SIZE - 1) // self.FLASH_WRITE_SIZE
680          erase_blocks = (size + self.FLASH_WRITE_SIZE - 1) // self.FLASH_WRITE_SIZE
681          t = time.time()
682          if self.IS_STUB:
683              write_size = (
684                  size  # stub expects number of bytes here, manages erasing internally
685              )
686              timeout = DEFAULT_TIMEOUT
687          else:
688              write_size = (
689                  erase_blocks * self.FLASH_WRITE_SIZE
690              )  # ROM expects rounded up to erase block size
691              timeout = timeout_per_mb(
692                  ERASE_REGION_TIMEOUT_PER_MB, write_size
693              )  # ROM performs the erase up front
694          print("Compressed %d bytes to %d..." % (size, compsize))
695          params = struct.pack(
696              "<IIII", write_size, num_blocks, self.FLASH_WRITE_SIZE, offset
697          )
698          if self.SUPPORTS_ENCRYPTED_FLASH and not self.IS_STUB:
699              params += struct.pack("<I", 0)
700          self.check_command(
701              "enter compressed flash mode",
702              self.ESP_FLASH_DEFL_BEGIN,
703              params,
704              timeout=timeout,
705          )
706          if size != 0 and not self.IS_STUB:
707              print("Took %.2fs to erase flash block" % (time.time() - t))
708          return num_blocks
709      @stub_and_esp32_function_only
710      def flash_defl_block(self, data, seq, timeout=DEFAULT_TIMEOUT):
711          for attempts_left in range(WRITE_BLOCK_ATTEMPTS - 1, -1, -1):
712              try:
713                  self.check_command(
714                      "write compressed data to flash after seq %d" % seq,
715                      self.ESP_FLASH_DEFL_DATA,
716                      struct.pack("<IIII", len(data), seq, 0, 0) + data,
717                      self.checksum(data),
718                      timeout=timeout,
719                  )
720                  break
721              except FatalError:
722                  if attempts_left:
723                      self.trace(
724                          "Compressed block write failed, "
725                          f"retrying with {attempts_left} attempts left"
726                      )
727                  else:
728                      raise
729      @stub_and_esp32_function_only
730      def flash_defl_finish(self, reboot=False):
731          if not reboot and not self.IS_STUB:
732              return
733          pkt = struct.pack("<I", int(not reboot))
734          self.check_command("leave compressed flash mode", self.ESP_FLASH_DEFL_END, pkt)
735          self.in_bootloader = False
736      @stub_and_esp32_function_only
737      def flash_md5sum(self, addr, size):
738          timeout = timeout_per_mb(MD5_TIMEOUT_PER_MB, size)
739          res = self.check_command(
740              "calculate md5sum",
741              self.ESP_SPI_FLASH_MD5,
742              struct.pack("<IIII", addr, size, 0, 0),
743              timeout=timeout,
744          )
745          if len(res) == 32:
746              return res.decode("utf-8")  # already hex formatted
747          elif len(res) == 16:
748              return hexify(res).lower()
749          else:
750              raise FatalError("MD5Sum command returned unexpected result: %r" % res)
751      @stub_and_esp32_function_only
752      def change_baud(self, baud):
753          print("Changing baud rate to %d" % baud)
754          second_arg = self._port.baudrate if self.IS_STUB else 0
755          self.command(self.ESP_CHANGE_BAUDRATE, struct.pack("<II", baud, second_arg))
756          print("Changed.")
757          self._set_port_baudrate(baud)
758          time.sleep(0.05)  # get rid of crap sent during baud rate change
759          self.flush_input()
760      @stub_function_only
761      def erase_flash(self):
762          self.check_command(
763              "erase flash", self.ESP_ERASE_FLASH, timeout=CHIP_ERASE_TIMEOUT
764          )
765      @stub_function_only
766      def erase_region(self, offset, size):
767          if offset % self.FLASH_SECTOR_SIZE != 0:
768              raise FatalError("Offset to erase from must be a multiple of 4096")
769          if size % self.FLASH_SECTOR_SIZE != 0:
770              raise FatalError("Size of data to erase must be a multiple of 4096")
771          timeout = timeout_per_mb(ERASE_REGION_TIMEOUT_PER_MB, size)
772          self.check_command(
773              "erase region",
774              self.ESP_ERASE_REGION,
775              struct.pack("<II", offset, size),
776              timeout=timeout,
777          )
778      def read_flash_slow(self, offset, length, progress_fn):
779          raise NotImplementedInROMError(self, self.read_flash_slow)
780      def read_flash(self, offset, length, progress_fn=None):
781          if not self.IS_STUB:
782              return self.read_flash_slow(offset, length, progress_fn)  # ROM-only routine
783          self.check_command(
784              "read flash",
785              self.ESP_READ_FLASH,
786              struct.pack("<IIII", offset, length, self.FLASH_SECTOR_SIZE, 64),
787          )
788          data = b""
789          while len(data) < length:
790              p = self.read()
791              data += p
792              if len(data) < length and len(p) < self.FLASH_SECTOR_SIZE:
793                  raise FatalError(
794                      "Corrupt data, expected 0x%x bytes but received 0x%x bytes"
795                      % (self.FLASH_SECTOR_SIZE, len(p))
796                  )
797              self.write(struct.pack("<I", len(data)))
798              if progress_fn and (len(data) % 1024 == 0 or len(data) == length):
799                  progress_fn(len(data), length)
800          if progress_fn:
801              progress_fn(len(data), length)
802          if len(data) > length:
803              raise FatalError("Read more than expected")
804          digest_frame = self.read()
805          if len(digest_frame) != 16:
806              raise FatalError("Expected digest, got: %s" % hexify(digest_frame))
<span onclick='openModal()' class='match'>807          expected_digest = hexify(digest_frame).upper()
808          digest = hashlib.md5(data).hexdigest().upper()
</span>809          if digest != expected_digest:
810              raise FatalError(
811                  "Digest mismatch: expected %s, got %s" % (expected_digest, digest)
812              )
813          return data
814      def flash_spi_attach(self, hspi_arg):
815          arg = struct.pack("<I", hspi_arg)
816          if not self.IS_STUB:
817              is_legacy = 0
818              arg += struct.pack("BBBB", is_legacy, 0, 0, 0)
819          self.check_command("configure SPI flash pins", self.ESP_SPI_ATTACH, arg)
820      def flash_set_parameters(self, size):
821          fl_id = 0
822          total_size = size
823          block_size = 64 * 1024
824          sector_size = 4 * 1024
825          page_size = 256
826          status_mask = 0xFFFF
827          self.check_command(
828              "set SPI params",
829              self.ESP_SPI_SET_PARAMS,
830              struct.pack(
831                  "<IIIIII",
832                  fl_id,
833                  total_size,
834                  block_size,
835                  sector_size,
836                  page_size,
837                  status_mask,
838              ),
839          )
840      def run_spiflash_command(
841          self,
842          spiflash_command,
843          data=b"",
844          read_bits=0,
845          addr=None,
846          addr_len=0,
847          dummy_len=0,
848      ):
849          SPI_USR_COMMAND = 1 << 31
850          SPI_USR_ADDR = 1 << 30
851          SPI_USR_DUMMY = 1 << 29
852          SPI_USR_MISO = 1 << 28
853          SPI_USR_MOSI = 1 << 27
854          base = self.SPI_REG_BASE
855          SPI_CMD_REG = base + 0x00
856          SPI_ADDR_REG = base + 0x04
857          SPI_USR_REG = base + self.SPI_USR_OFFS
858          SPI_USR1_REG = base + self.SPI_USR1_OFFS
859          SPI_USR2_REG = base + self.SPI_USR2_OFFS
860          SPI_W0_REG = base + self.SPI_W0_OFFS
861          if self.SPI_MOSI_DLEN_OFFS is not None:
862              def set_data_lengths(mosi_bits, miso_bits):
863                  SPI_MOSI_DLEN_REG = base + self.SPI_MOSI_DLEN_OFFS
864                  SPI_MISO_DLEN_REG = base + self.SPI_MISO_DLEN_OFFS
865                  if mosi_bits > 0:
866                      self.write_reg(SPI_MOSI_DLEN_REG, mosi_bits - 1)
867                  if miso_bits > 0:
868                      self.write_reg(SPI_MISO_DLEN_REG, miso_bits - 1)
869                  flags = 0
870                  if dummy_len > 0:
871                      flags |= dummy_len - 1
872                  if addr_len > 0:
873                      flags |= (addr_len - 1) << SPI_USR_ADDR_LEN_SHIFT
874                  if flags:
875                      self.write_reg(SPI_USR1_REG, flags)
876          else:
877              def set_data_lengths(mosi_bits, miso_bits):
878                  SPI_DATA_LEN_REG = SPI_USR1_REG
879                  SPI_MOSI_BITLEN_S = 17
880                  SPI_MISO_BITLEN_S = 8
881                  mosi_mask = 0 if (mosi_bits == 0) else (mosi_bits - 1)
882                  miso_mask = 0 if (miso_bits == 0) else (miso_bits - 1)
883                  flags = (miso_mask << SPI_MISO_BITLEN_S) | (
884                      mosi_mask << SPI_MOSI_BITLEN_S
885                  )
886                  if dummy_len > 0:
887                      flags |= dummy_len - 1
888                  if addr_len > 0:
889                      flags |= (addr_len - 1) << SPI_USR_ADDR_LEN_SHIFT
890                  self.write_reg(SPI_DATA_LEN_REG, flags)
891          SPI_CMD_USR = 1 << 18
892          SPI_USR2_COMMAND_LEN_SHIFT = 28
893          SPI_USR_ADDR_LEN_SHIFT = 26
894          if read_bits > 32:
895              raise FatalError(
896                  "Reading more than 32 bits back from a SPI flash "
897                  "operation is unsupported"
898              )
899          if len(data) > 64:
900              raise FatalError(
901                  "Writing more than 64 bytes of data with one SPI "
902                  "command is unsupported"
903              )
904          data_bits = len(data) * 8
905          old_spi_usr = self.read_reg(SPI_USR_REG)
906          old_spi_usr2 = self.read_reg(SPI_USR2_REG)
907          flags = SPI_USR_COMMAND
908          if read_bits > 0:
909              flags |= SPI_USR_MISO
910          if data_bits > 0:
911              flags |= SPI_USR_MOSI
912          if addr_len > 0:
913              flags |= SPI_USR_ADDR
914          if dummy_len > 0:
915              flags |= SPI_USR_DUMMY
916          set_data_lengths(data_bits, read_bits)
917          self.write_reg(SPI_USR_REG, flags)
918          self.write_reg(
919              SPI_USR2_REG, (7 << SPI_USR2_COMMAND_LEN_SHIFT) | spiflash_command
920          )
921          if addr and addr_len > 0:
922              self.write_reg(SPI_ADDR_REG, addr)
923          if data_bits == 0:
924              self.write_reg(SPI_W0_REG, 0)  # clear data register before we read it
925          else:
926              data = pad_to(data, 4, b"\00")  # pad to 32-bit multiple
927              words = struct.unpack("I" * (len(data) // 4), data)
928              next_reg = SPI_W0_REG
929              for word in words:
930                  self.write_reg(next_reg, word)
931                  next_reg += 4
932          self.write_reg(SPI_CMD_REG, SPI_CMD_USR)
933          def wait_done():
934              for _ in range(10):
935                  if (self.read_reg(SPI_CMD_REG) & SPI_CMD_USR) == 0:
936                      return
937              raise FatalError("SPI command did not complete in time")
938          wait_done()
939          status = self.read_reg(SPI_W0_REG)
940          self.write_reg(SPI_USR_REG, old_spi_usr)
941          self.write_reg(SPI_USR2_REG, old_spi_usr2)
942          return status
943      def read_spiflash_sfdp(self, addr, read_bits):
944          CMD_RDSFDP = 0x5A
945          return self.run_spiflash_command(
946              CMD_RDSFDP, read_bits=read_bits, addr=addr, addr_len=24, dummy_len=8
947          )
948      def read_status(self, num_bytes=2):
949          SPIFLASH_RDSR = 0x05
950          SPIFLASH_RDSR2 = 0x35
951          SPIFLASH_RDSR3 = 0x15
952          status = 0
953          shift = 0
954          for cmd in [SPIFLASH_RDSR, SPIFLASH_RDSR2, SPIFLASH_RDSR3][0:num_bytes]:
955              status += self.run_spiflash_command(cmd, read_bits=8) << shift
956              shift += 8
957          return status
958      def write_status(self, new_status, num_bytes=2, set_non_volatile=False):
959          SPIFLASH_WRSR = 0x01
960          SPIFLASH_WRSR2 = 0x31
961          SPIFLASH_WRSR3 = 0x11
962          SPIFLASH_WEVSR = 0x50
963          SPIFLASH_WREN = 0x06
964          SPIFLASH_WRDI = 0x04
965          enable_cmd = SPIFLASH_WREN if set_non_volatile else SPIFLASH_WEVSR
966          if num_bytes == 2:
967              self.run_spiflash_command(enable_cmd)
968              self.run_spiflash_command(SPIFLASH_WRSR, struct.pack("<H", new_status))
969          for cmd in [SPIFLASH_WRSR, SPIFLASH_WRSR2, SPIFLASH_WRSR3][0:num_bytes]:
970              self.run_spiflash_command(enable_cmd)
971              self.run_spiflash_command(cmd, struct.pack("B", new_status & 0xFF))
972              new_status >>= 8
973          self.run_spiflash_command(SPIFLASH_WRDI)
974      def get_crystal_freq(self):
975          uart_div = self.read_reg(self.UART_CLKDIV_REG) & self.UART_CLKDIV_MASK
976          est_xtal = (self._port.baudrate * uart_div) / 1e6 / self.XTAL_CLK_DIVIDER
977          norm_xtal = 40 if est_xtal > 33 else 26
978          if abs(norm_xtal - est_xtal) > 1:
979              print(
980                  "WARNING: Detected crystal freq %.2fMHz is quite different to "
981                  "normalized freq %dMHz. Unsupported crystal in use?"
982                  % (est_xtal, norm_xtal)
983              )
984          return norm_xtal
985      def hard_reset(self):
986          print("Hard resetting via RTS pin...")
987          HardReset(self._port)()
988      def soft_reset(self, stay_in_bootloader):
989          if not self.IS_STUB:
990              if stay_in_bootloader:
991                  return  # ROM bootloader is already in bootloader!
992              else:
993                  self.flash_begin(0, 0)
994                  self.flash_finish(False)
995          else:
996              if stay_in_bootloader:
997                  self.flash_begin(0, 0)
998                  self.flash_finish(True)
999              elif self.CHIP_NAME != "ESP8266":
1000                  raise FatalError(
1001                      "Soft resetting is currently only supported on ESP8266"
1002                  )
1003              else:
1004                  self.command(self.ESP_RUN_USER_CODE, wait_response=False)
1005      def check_chip_id(self):
1006          try:
1007              chip_id = self.get_chip_id()
1008              if chip_id != self.IMAGE_CHIP_ID:
1009                  print(
1010                      "WARNING: Chip ID {} ({}) doesn't match expected Chip ID {}. "
1011                      "esptool may not work correctly.".format(
1012                          chip_id,
1013                          self.UNSUPPORTED_CHIPS.get(chip_id, "Unknown"),
1014                          self.IMAGE_CHIP_ID,
1015                      )
1016                  )
1017                  self.stub_is_disabled = True
1018          except NotImplementedInROMError:
1019              pass
1020  def slip_reader(port, trace_function):
1021      def detect_panic_handler(input):
1022          guru_meditation = (
1023              rb"G?uru Meditation Error: (?:Core \d panic'ed \(([a-zA-Z ]*)\))?"
1024          )
1025          fatal_exception = rb"F?atal exception \(\d+\): (?:([a-zA-Z ]*)?.*epc)?"
1026          data = re.search(
1027              rb"".join([rb"(?:", guru_meditation, rb"|", fatal_exception, rb")"]),
1028              input,
1029              re.DOTALL,
1030          )
1031          if data is not None:
1032              cause = [
1033                  "({})".format(i.decode("utf-8"))
1034                  for i in [data.group(1), data.group(2)]
1035                  if i is not None
1036              ]
1037              cause = f" {cause[0]}" if len(cause) else ""
1038              msg = f"Guru Meditation Error detected{cause}"
1039              raise FatalError(msg)
1040      partial_packet = None
1041      in_escape = False
1042      successful_slip = False
1043      while True:
1044          waiting = port.inWaiting()
1045          read_bytes = port.read(1 if waiting == 0 else waiting)
1046          if read_bytes == b"":
1047              if partial_packet is None:  # fail due to no data
1048                  msg = (
1049                      "Serial data stream stopped: Possible serial noise or corruption."
1050                      if successful_slip
1051                      else "No serial data received."
1052                  )
1053              else:  # fail during packet transfer
1054                  msg = "Packet content transfer stopped (received {} bytes)".format(
1055                      len(partial_packet)
1056                  )
1057              trace_function(msg)
1058              raise FatalError(msg)
1059          trace_function("Read %d bytes: %s", len(read_bytes), HexFormatter(read_bytes))
1060          for b in read_bytes:
1061              b = bytes([b])
1062              if partial_packet is None:  # waiting for packet header
1063                  if b == b"\xc0":
1064                      partial_packet = b""
1065                  else:
1066                      trace_function("Read invalid data: %s", HexFormatter(read_bytes))
1067                      remaining_data = port.read(port.inWaiting())
1068                      trace_function(
1069                          "Remaining data in serial buffer: %s",
1070                          HexFormatter(remaining_data),
1071                      )
1072                      detect_panic_handler(read_bytes + remaining_data)
1073                      raise FatalError(
1074                          "Invalid head of packet (0x%s): "
1075                          "Possible serial noise or corruption." % hexify(b)
1076                      )
1077              elif in_escape:  # part-way through escape sequence
1078                  in_escape = False
1079                  if b == b"\xdc":
1080                      partial_packet += b"\xc0"
1081                  elif b == b"\xdd":
1082                      partial_packet += b"\xdb"
1083                  else:
1084                      trace_function("Read invalid data: %s", HexFormatter(read_bytes))
1085                      remaining_data = port.read(port.inWaiting())
1086                      trace_function(
1087                          "Remaining data in serial buffer: %s",
1088                          HexFormatter(remaining_data),
1089                      )
1090                      detect_panic_handler(read_bytes + remaining_data)
1091                      raise FatalError("Invalid SLIP escape (0xdb, 0x%s)" % (hexify(b)))
1092              elif b == b"\xdb":  # start of escape sequence
1093                  in_escape = True
1094              elif b == b"\xc0":  # end of packet
1095                  trace_function("Received full packet: %s", HexFormatter(partial_packet))
1096                  yield partial_packet
1097                  partial_packet = None
1098                  successful_slip = True
1099              else:  # normal byte in packet
1100                  partial_packet += b
1101  class HexFormatter(object):
1102      def __init__(self, binary_string, auto_split=True):
1103          self._s = binary_string
1104          self._auto_split = auto_split
1105      def __str__(self):
1106          if self._auto_split and len(self._s) > 16:
1107              result = ""
1108              s = self._s
1109              while len(s) > 0:
1110                  line = s[:16]
1111                  ascii_line = "".join(
1112                      c
1113                      if (
1114                          c == " "
1115                          or (c in string.printable and c not in string.whitespace)
1116                      )
1117                      else "."
1118                      for c in line.decode("ascii", "replace")
1119                  )
1120                  s = s[16:]
1121                  result += "\n    %-16s %-16s | %s" % (
1122                      hexify(line[:8], False),
1123                      hexify(line[8:], False),
1124                      ascii_line,
1125                  )
1126              return result
1127          else:
1128              return hexify(self._s, False)
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-helper.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-loader.py</div>
                </div>
                <div class="column column_space"><pre><code>230          repo = Repo.init()
231          origin = repo.create_remote("upstream", off_repo)
232          origin.fetch()
233          repo.create_head("main", origin.refs.main)
</pre></code></div>
                <div class="column column_space"><pre><code>807          expected_digest = hexify(digest_frame).upper()
808          digest = hashlib.md5(data).hexdigest().upper()
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    