<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_aptpkg_1.py &amp; test_thin_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_aptpkg_1.py &amp; test_thin_1.py
      </h3>
<h1 align="center">
        4.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_aptpkg_1.py (5.063291%)<th>test_thin_1.py (3.4102306%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(196-206)<td><a href="#" name="0">(95-105)</a><td align="center"><font color="#ff0000">20</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(984-987)<td><a href="#" name="1">(1202-1206)</a><td align="center"><font color="#990000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(933-936)<td><a href="#" name="2">(67-70)</a><td align="center"><font color="#990000">12</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(751-772)<td><a href="#" name="3">(153-162)</a><td align="center"><font color="#990000">12</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(9-26)<td><a href="#" name="4">(16-28)</a><td align="center"><font color="#990000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_aptpkg_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import copy
3 import logging
4 import os
5 import pathlib
6 import textwrap
7 import pytest
8 import salt.modules.aptpkg as aptpkg
9 import salt.modules.pkg_resource as pkg_resource
10 from salt.exceptions import (
11     CommandExecutionError,
12     CommandNotFoundError,
13     SaltInvocationError,
14 )
15 from tests.support.mock import MagicMock, Mock, call, mock_open, patch
16 try:
17     from</b></font> aptsources import sourceslist  # pylint: disable=unused-import
18     HAS_APTSOURCES = True
19 except ImportError:
20     HAS_APTSOURCES = False
21 log = logging.getLogger(__name__)
22 @pytest.fixture(scope="module")
23 def repo_keys_var():
24     return {
25         "46181433FBB75451": {
26             "algorithm": 17,
27             "bits": 1024,
28             "capability": "scSC",
29             "date_creation": 1104433784,
30             "date_expiration": None,
31             "fingerprint": "C5986B4F1257FFA86632CBA746181433FBB75451",
32             "keyid": "46181433FBB75451",
33             "uid": "Ubuntu CD Image Automatic Signing Key &lt;cdimage@ubuntu.com&gt;",
34             "uid_hash": "B4D41942D4B35FF44182C7F9D00C99AF27B93AD0",
35             "validity": "-",
36         }
37     }
38 @pytest.fixture(scope="module")
39 def packages_var():
40     return {"wget": "1.15-1ubuntu1.14.04.2"}
41 @pytest.fixture(scope="module")
42 def lowpkg_files_var():
43     return {
44         "errors": {},
45         "packages": {
46             "wget": [
47                 "/.",
48                 "/etc",
49                 "/etc/wgetrc",
50                 "/usr",
51                 "/usr/bin",
52                 "/usr/bin/wget",
53                 "/usr/share",
54                 "/usr/share/info",
55                 "/usr/share/info/wget.info.gz",
56                 "/usr/share/doc",
57                 "/usr/share/doc/wget",
58                 "/usr/share/doc/wget/MAILING-LIST",
59                 "/usr/share/doc/wget/NEWS.gz",
60                 "/usr/share/doc/wget/AUTHORS",
61                 "/usr/share/doc/wget/copyright",
62                 "/usr/share/doc/wget/changelog.Debian.gz",
63                 "/usr/share/doc/wget/README",
64                 "/usr/share/man",
65                 "/usr/share/man/man1",
66                 "/usr/share/man/man1/wget.1.gz",
67             ]
68         },
69     }
70 @pytest.fixture(scope="module")
71 def lowpkg_info_var():
72     return {
73         "wget": {
74             "architecture": "amd64",
75             "description": "retrieves files from the web",
76             "homepage": "http://www.gnu.org/software/wget/",
77             "install_date": "2016-08-30T22:20:15Z",
78             "maintainer": "Ubuntu Developers &lt;ubuntu-devel-discuss@lists.ubuntu.com&gt;",
79             "name": "wget",
80             "section": "web",
81             "source": "wget",
82             "version": "1.15-1ubuntu1.14.04.2",
83             "status": "ii",
84         },
85         "apache2": {
86             "architecture": "amd64",
87             "description": """Apache HTTP Server
88      The Apache HTTP Server Project's goal is to build a secure, efficient and
89      extensible HTTP server as standards-compliant open source software. The
90      result has long been the number one web server on the Internet.
91      .
92      Installing this package results in a full installation, including the
93      configuration files, init scripts and support scripts.""",
94             "homepage": "http://httpd.apache.org/",
95             "install_date": "2016-08-30T22:20:15Z",
96             "maintainer": "Ubuntu Developers &lt;ubuntu-devel-discuss@lists.ubuntu.com&gt;",
97             "name": "apache2",
98             "section": "httpd",
99             "source": "apache2",
100             "version": "2.4.18-2ubuntu3.9",
101             "status": "rc",
102         },
103     }
104 @pytest.fixture(scope="module")
105 def apt_q_update_var():
106     return """
107     Get:1 http://security.ubuntu.com trusty-security InRelease [65 kB]
108     Get:2 http://security.ubuntu.com trusty-security/main Sources [120 kB]
109     Get:3 http://security.ubuntu.com trusty-security/main amd64 Packages [548 kB]
110     Get:4 http://security.ubuntu.com trusty-security/main i386 Packages [507 kB]
111     Hit http://security.ubuntu.com trusty-security/main Translation-en
112     Fetched 1240 kB in 10s (124 kB/s)
113     Reading package lists...
114     """
115 @pytest.fixture(scope="module")
116 def apt_q_update_error_var():
117     return """
118     Err http://security.ubuntu.com trusty InRelease
119     Err http://security.ubuntu.com trusty Release.gpg
120     Unable to connect to security.ubuntu.com:http:
121     Reading package lists...
122     W: Failed to fetch http://security.ubuntu.com/ubuntu/dists/trusty/InRelease
123     W: Failed to fetch http://security.ubuntu.com/ubuntu/dists/trusty/Release.gpg  Unable to connect to security.ubuntu.com:http:
124     W: Some index files failed to download. They have been ignored, or old ones used instead.
125     """
126 @pytest.fixture(scope="module")
127 def autoremove_var():
128     return """
129     Reading package lists... Done
130     Building dependency tree
131     Reading state information... Done
132     0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
133     """
134 @pytest.fixture(scope="module")
135 def upgrade_var():
136     return """
137     Reading package lists...
138     Building dependency tree...
139     Reading state information...
140     0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
141     """
142 @pytest.fixture(scope="module")
143 def uninstall_var():
144     return {"tmux": {"new": "", "old": "1.8-5"}}
145 @pytest.fixture(scope="module")
146 def install_var():
147     return {"tmux": {"new": "1.8-5", "old": ""}}
148 def _get_uri(repo):
149     """
150     Get the URI portion of the a string
151     """
152     splits = repo.split()
153     for val in splits:
154         if any(val.startswith(x) for x in ("http://", "https://", "ftp://")):
155             return val
156 class MockSourceEntry:
157     def __init__(self, uri, source_type, line, invalid, dist="", file=None):
158         self<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.uri = uri
159         self.type = source_type
160         self.line = line
161         self.invalid = invalid
162         self.file = file
163         self.disabled = False
164         self.dist = dist
165         self.comps = []
166         self.architectures = []
167     def</b></font> mysplit(self, line):
168         return line.split()
169 class MockSourceList:
170     def __init__(self):
171         self.list = []
172     def __iter__(self):
173         yield from self.list
174     def save(self):
175         pass
176 @pytest.fixture
177 def configure_loader_modules():
178     return {aptpkg: {"__grains__": {}}}
179 def test_version(lowpkg_info_var):
180     """
181     Test - Returns a string representing the package version or an empty string if
182     not installed.
183     """
184     version = lowpkg_info_var["wget"]["version"]
185     mock = MagicMock(return_value=version)
186     with patch.dict(aptpkg.__salt__, {"pkg_resource.version": mock}):
187         assert aptpkg.version(*["wget"]) == version
188 def test_upgrade_available():
189     """
190     Test - Check whether or not an upgrade is available for a given package.
191     """
192     with patch("salt.modules.aptpkg.latest_version", MagicMock(return_value="")):
193         assert aptpkg.upgrade_available("wget") is False
194 def test_add_repo_key(repo_keys_var):
195     """
196     Test - Add a repo key.
197     """
198     with patch(
199         "salt.modules.aptpkg.get_repo_keys", MagicMock(return_value=repo_keys_var)
200     ):
201         mock = MagicMock(return_value={"retcode": 0, "stdout": "OK"})
202         with patch.dict(aptpkg.__salt__, {"cmd.run_all": mock}):
203             assert (
204                 aptpkg.add_repo_key(keyserver="keyserver.ubuntu.com", keyid="FBB75451")
205                 is True
206             )
207 def test_add_repo_key_failed(repo_keys_var):
208     """
209     Test - Add a repo key using incomplete input data.
210     """
211     with patch(
212         "salt.modules.aptpkg.get_repo_keys", MagicMock(return_value=repo_keys_var)
213     ):
214         kwargs = {"keyserver": "keyserver.ubuntu.com"}
215         mock = MagicMock(return_value={"retcode": 0, "stdout": "OK"})
216         with patch.dict(aptpkg.__salt__, {"cmd.run_all": mock}):
217             with pytest.raises(SaltInvocationError):
218                 aptpkg.add_repo_key(**kwargs)
219 def test_get_repo_keys(repo_keys_var):
220     """
221     Test - List known repo key details.
222     """
223     APT_KEY_LIST = r"""
224     pub:-:1024:17:46181433FBB75451:1104433784:::-:::scSC:
225     fpr:::::::::C5986B4F1257FFA86632CBA746181433FBB75451:
226     uid:-::::1104433784::B4D41942D4B35FF44182C7F9D00C99AF27B93AD0::Ubuntu CD Image Automatic Signing Key &lt;cdimage@ubuntu.com&gt;:
227     """
228     mock = MagicMock(return_value={"retcode": 0, "stdout": APT_KEY_LIST})
229     with patch.dict(aptpkg.__salt__, {"cmd.run_all": mock}):
230         assert aptpkg.get_repo_keys() == repo_keys_var
231 def test_file_dict(lowpkg_files_var):
232     """
233     Test - List the files that belong to a package, grouped by package.
234     """
235     mock = MagicMock(return_value=lowpkg_files_var)
236     with patch.dict(aptpkg.__salt__, {"lowpkg.file_dict": mock}):
237         assert aptpkg.file_dict("wget") == lowpkg_files_var
238 def test_file_list(lowpkg_files_var):
239     """
240     Test - List the files that belong to a package.
241     """
242     files = {
243         "errors": lowpkg_files_var["errors"],
244         "files": lowpkg_files_var["packages"]["wget"],
245     }
246     mock = MagicMock(return_value=files)
247     with patch.dict(aptpkg.__salt__, {"lowpkg.file_list": mock}):
248         assert aptpkg.file_list("wget") == files
249 def test_get_selections():
250     """
251     Test - View package state from the dpkg database.
252     """
253     selections = {"install": ["wget"]}
254     mock = MagicMock(return_value="wget\t\t\t\t\t\tinstall")
255     with patch.dict(aptpkg.__salt__, {"cmd.run_stdout": mock}):
256         assert aptpkg.get_selections("wget") == selections
257 def test_info_installed(lowpkg_info_var):
258     """
259     Test - Return the information of the named package(s) installed on the system.
260     """
261     names = {"group": "section", "packager": "maintainer", "url": "homepage"}
262     installed = copy.deepcopy({"wget": lowpkg_info_var["wget"]})
263     for name in names:
264         if installed["wget"].get(names[name], False):
265             installed["wget"][name] = installed["wget"].pop(names[name])
266     mock = MagicMock(return_value=lowpkg_info_var)
267     with patch.dict(aptpkg.__salt__, {"lowpkg.info": mock}):
268         del installed["wget"]["status"]
269         assert aptpkg.info_installed("wget") == installed
270         assert len(aptpkg.info_installed()) == 1
271 def test_owner():
272     """
273     Test - Return the name of the package that owns the file.
274     """
275     paths = ["/usr/bin/wget"]
276     mock = MagicMock(return_value="wget: /usr/bin/wget")
277     with patch.dict(aptpkg.__salt__, {"cmd.run_stdout": mock}):
278         assert aptpkg.owner(*paths) == "wget"
279 def test_refresh_db(apt_q_update_var):
280     """
281     Test - Updates the APT database to latest packages based upon repositories.
282     """
283     refresh_db = {
284         "http://security.ubuntu.com trusty-security InRelease": True,
285         "http://security.ubuntu.com trusty-security/main Sources": True,
286         "http://security.ubuntu.com trusty-security/main Translation-en": None,
287         "http://security.ubuntu.com trusty-security/main amd64 Packages": True,
288         "http://security.ubuntu.com trusty-security/main i386 Packages": True,
289     }
290     mock = MagicMock(return_value={"retcode": 0, "stdout": apt_q_update_var})
291     with patch("salt.utils.pkg.clear_rtag", MagicMock()):
292         with patch.dict(
293             aptpkg.__salt__,
294             {"cmd.run_all": mock, "config.get": MagicMock(return_value=False)},
295         ):
296             assert aptpkg.refresh_db() == refresh_db
297 def test_refresh_db_failed(apt_q_update_error_var):
298     """
299     Test - Update the APT database using unreachable repositories.
300     """
301     kwargs = {"failhard": True}
302     mock = MagicMock(return_value={"retcode": 0, "stdout": apt_q_update_error_var})
303     with patch("salt.utils.pkg.clear_rtag", MagicMock()):
304         with patch.dict(
305             aptpkg.__salt__,
306             {"cmd.run_all": mock, "config.get": MagicMock(return_value=False)},
307         ):
308             with pytest.raises(CommandExecutionError):
309                 aptpkg.refresh_db(**kwargs)
310 def test_autoremove(packages_var, autoremove_var):
311     """
312     Test - Remove packages not required by another package.
313     """
314     with patch("salt.modules.aptpkg.list_pkgs", MagicMock(return_value=packages_var)):
315         patch_kwargs = {
316             "__salt__": {
317                 "config.get": MagicMock(return_value=True),
318                 "cmd.run_all": MagicMock(
319                     return_value=MagicMock(return_value=autoremove_var)
320                 ),
321             }
322         }
323         with patch.multiple(aptpkg, **patch_kwargs):
324             assert aptpkg.autoremove() == {}
325             assert aptpkg.autoremove(purge=True) == {}
326             assert aptpkg.autoremove(list_only=True) == []
327             assert aptpkg.autoremove(list_only=True, purge=True) == []
328 def test_install(install_var):
329     """
330     Test - Install packages.
331     """
332     with patch("salt.modules.aptpkg.install", MagicMock(return_value=install_var)):
333         assert aptpkg.install(name="tmux") == install_var
334         kwargs = {"force_conf_new": True}
335         assert aptpkg.install(name="tmux", **kwargs) == install_var
336 def test_remove(uninstall_var):
337     """
338     Test - Remove packages.
339     """
340     with patch("salt.modules.aptpkg._uninstall", MagicMock(return_value=uninstall_var)):
341         assert aptpkg.remove(name="tmux") == uninstall_var
342 def test_purge(uninstall_var):
343     """
344     Test - Remove packages along with all configuration files.
345     """
346     with patch("salt.modules.aptpkg._uninstall", MagicMock(return_value=uninstall_var)):
347         assert aptpkg.purge(name="tmux") == uninstall_var
348 def test_upgrade(uninstall_var, upgrade_var):
349     """
350     Test - Upgrades all packages.
351     """
352     with patch("salt.utils.pkg.clear_rtag", MagicMock()):
353         with patch(
354             "salt.modules.aptpkg.list_pkgs", MagicMock(return_value=uninstall_var)
355         ):
356             mock_cmd = MagicMock(return_value={"retcode": 0, "stdout": upgrade_var})
357             patch_kwargs = {
358                 "__salt__": {
359                     "config.get": MagicMock(return_value=True),
360                     "cmd.run_all": mock_cmd,
361                 }
362             }
363             with patch.multiple(aptpkg, **patch_kwargs):
364                 assert aptpkg.upgrade() == dict()
365                 kwargs = {"force_conf_new": True}
366                 assert aptpkg.upgrade(**kwargs) == dict()
367 def test_upgrade_downloadonly(uninstall_var, upgrade_var):
368     """
369     Tests the download-only options for upgrade.
370     """
371     with patch("salt.utils.pkg.clear_rtag", MagicMock()):
372         with patch(
373             "salt.modules.aptpkg.list_pkgs", MagicMock(return_value=uninstall_var)
374         ):
375             mock_cmd = MagicMock(return_value={"retcode": 0, "stdout": upgrade_var})
376             patch_kwargs = {
377                 "__salt__": {
378                     "config.get": MagicMock(return_value=True),
379                     "cmd.run_all": mock_cmd,
380                 },
381             }
382             with patch.multiple(aptpkg, **patch_kwargs):
383                 aptpkg.upgrade()
384                 args_matching = [
385                     True
386                     for args in patch_kwargs["__salt__"]["cmd.run_all"].call_args[0]
387                     if "--download-only" in args
388                 ]
389                 assert any(args_matching) is False
390                 aptpkg.upgrade(downloadonly=True)
391                 args_matching = [
392                     True
393                     for args in patch_kwargs["__salt__"]["cmd.run_all"].call_args[0]
394                     if "--download-only" in args
395                 ]
396                 assert any(args_matching) is True
397                 aptpkg.upgrade(download_only=True)
398                 args_matching = [
399                     True
400                     for args in patch_kwargs["__salt__"]["cmd.run_all"].call_args[0]
401                     if "--download-only" in args
402                 ]
403                 assert any(args_matching) is True
404 def test_upgrade_allow_downgrades(uninstall_var, upgrade_var):
405     """
406     Tests the allow_downgrades option for upgrade.
407     """
408     with patch("salt.utils.pkg.clear_rtag", MagicMock()):
409         with patch(
410             "salt.modules.aptpkg.list_pkgs", MagicMock(return_value=uninstall_var)
411         ):
412             mock_cmd = MagicMock(return_value={"retcode": 0, "stdout": upgrade_var})
413             patch_kwargs = {
414                 "__salt__": {
415                     "config.get": MagicMock(return_value=True),
416                     "cmd.run_all": mock_cmd,
417                 },
418             }
419             with patch.multiple(aptpkg, **patch_kwargs):
420                 aptpkg.upgrade()
421                 args_matching = [
422                     True
423                     for args in patch_kwargs["__salt__"]["cmd.run_all"].call_args[0]
424                     if "--allow-downgrades" in args
425                 ]
426                 assert any(args_matching) is False
427                 aptpkg.upgrade(allow_downgrades=True)
428                 args_matching = [
429                     True
430                     for args in patch_kwargs["__salt__"]["cmd.run_all"].call_args[0]
431                     if "--allow-downgrades" in args
432                 ]
433                 assert any(args_matching) is True
434 def test_show():
435     """
436     Test that the pkg.show function properly parses apt-cache show output.
437     This test uses an abridged output per package, for simplicity.
438     """
439     show_mock_success = MagicMock(
440         return_value={
441             "retcode": 0,
442             "pid": 12345,
443             "stderr": "",
444             "stdout": textwrap.dedent(
445                 """\
446             Package: foo1.0
447             Architecture: amd64
448             Version: 1.0.5-3ubuntu4
449             Description: A silly package (1.0 release cycle)
450             Provides: foo
451             Suggests: foo-doc
452             Package: foo1.0
453             Architecture: amd64
454             Version: 1.0.4-2ubuntu1
455             Description: A silly package (1.0 release cycle)
456             Provides: foo
457             Suggests: foo-doc
458             Package: foo-doc
459             Architecture: all
460             Version: 1.0.5-3ubuntu4
461             Description: Silly documentation for a silly package (1.0 release cycle)
462             Package: foo-doc
463             Architecture: all
464             Version: 1.0.4-2ubuntu1
465             Description: Silly documentation for a silly package (1.0 release cycle)
466             """
467             ),
468         }
469     )
470     show_mock_failure = MagicMock(
471         return_value={
472             "retcode": 1,
473             "pid": 12345,
474             "stderr": textwrap.dedent(
475                 """\
476             N: Unable to locate package foo*
477             N: Couldn't find any package by glob 'foo*'
478             N: Couldn't find any package by regex 'foo*'
479             E: No packages found
480             """
481             ),
482             "stdout": "",
483         }
484     )
485     refresh_mock = Mock()
486     expected = {
487         "foo1.0": {
488             "1.0.5-3ubuntu4": {
489                 "Architecture": "amd64",
490                 "Description": "A silly package (1.0 release cycle)",
491                 "Provides": "foo",
492                 "Suggests": "foo-doc",
493             },
494             "1.0.4-2ubuntu1": {
495                 "Architecture": "amd64",
496                 "Description": "A silly package (1.0 release cycle)",
497                 "Provides": "foo",
498                 "Suggests": "foo-doc",
499             },
500         },
501         "foo-doc": {
502             "1.0.5-3ubuntu4": {
503                 "Architecture": "all",
504                 "Description": (
505                     "Silly documentation for a silly package (1.0 release cycle)"
506                 ),
507             },
508             "1.0.4-2ubuntu1": {
509                 "Architecture": "all",
510                 "Description": (
511                     "Silly documentation for a silly package (1.0 release cycle)"
512                 ),
513             },
514         },
515     }
516     filtered = copy.deepcopy(expected)
517     for k1 in filtered:
518         for k2 in filtered[k1]:
519             for k3 in list(filtered[k1][k2]):
520                 if k3 not in ("Description", "Provides"):
521                     filtered[k1][k2].pop(k3)
522     with patch.dict(aptpkg.__salt__, {"cmd.run_all": show_mock_success}), patch.object(
523         aptpkg, "refresh_db", refresh_mock
524     ):
525         assert aptpkg.show("foo*") == expected
526         refresh_mock.assert_not_called()
527         refresh_mock.reset_mock()
528         assert aptpkg.show("foo*", refresh=True) == expected
529         refresh_mock.assert_called_once()
530         refresh_mock.reset_mock()
531         assert aptpkg.show("foo*", filter="description,provides") == filtered
532         refresh_mock.assert_not_called()
533         refresh_mock.reset_mock()
534     with patch.dict(aptpkg.__salt__, {"cmd.run_all": show_mock_failure}), patch.object(
535         aptpkg, "refresh_db", refresh_mock
536     ):
537         assert aptpkg.show("foo*") == {}
538         refresh_mock.assert_not_called()
539         refresh_mock.reset_mock()
540         assert aptpkg.show("foo*", refresh=True) == {}
541         refresh_mock.assert_called_once()
542         refresh_mock.reset_mock()
543 @pytest.mark.skipif(
544     not (pathlib.Path("/etc") / "apt" / "sources.list").is_file(),
545     reason="Requires sources.list file",
546 )
547 def test_mod_repo_enabled():
548     """
549     Checks if a repo is enabled or disabled depending on the passed kwargs.
550     """
551     with patch.dict(
552         aptpkg.__salt__,
553         {"config.option": MagicMock(), "no_proxy": MagicMock(return_value=False)},
554     ):
555         with patch("salt.modules.aptpkg.refresh_db", MagicMock(return_value={})):
556             with patch(
557                 "salt.utils.data.is_true", MagicMock(return_value=True)
558             ) as data_is_true:
559                 with patch("salt.modules.aptpkg.SourcesList", MagicMock(), create=True):
560                     with patch(
561                         "salt.modules.aptpkg.SourceEntry", MagicMock(), create=True
562                     ):
563                         repo = aptpkg.mod_repo("foo", enabled=False)
564                         data_is_true.assert_called_with(False)
565                         data_is_true.reset_mock()
566                         repo = aptpkg.mod_repo("foo", disabled=True)
567                         data_is_true.assert_called_with(True)
568                         data_is_true.reset_mock()
569                         repo = aptpkg.mod_repo("foo", enabled=True)
570                         data_is_true.assert_called_with(True)
571                         data_is_true.reset_mock()
572                         repo = aptpkg.mod_repo("foo", disabled=False)
573                         data_is_true.assert_called_with(False)
574 def test_mod_repo_match():
575     """
576     Checks if a repo is matched without taking into account any ending "/" in the uri.
577     """
578     source_type = "deb"
579     source_uri = "http://cdn-aws.deb.debian.org/debian/"
580     source_line = "deb http://cdn-aws.deb.debian.org/debian/ stretch main\n"
581     mock_source = MockSourceEntry(
582         source_uri, source_type, source_line, False, "stretch"
583     )
584     mock_source_list = MockSourceList()
585     mock_source_list.list = [mock_source]
586     with patch.dict(
587         aptpkg.__salt__,
588         {"config.option": MagicMock(), "no_proxy": MagicMock(return_value=False)},
589     ):
590         with patch("salt.modules.aptpkg.refresh_db", MagicMock(return_value={})):
591             with patch("salt.utils.data.is_true", MagicMock(return_value=True)):
592                 with patch("salt.modules.aptpkg.SourceEntry", MagicMock(), create=True):
593                     with patch(
594                         "salt.modules.aptpkg.SourcesList",
595                         MagicMock(return_value=mock_source_list),
596                         create=True,
597                     ):
598                         with patch(
599                             "salt.modules.aptpkg._split_repo_str",
600                             MagicMock(
601                                 return_value=(
602                                     "deb",
603                                     [],
604                                     "http://cdn-aws.deb.debian.org/debian/",
605                                     "stretch",
606                                     ["main"],
607                                 )
608                             ),
609                         ):
610                             source_line_no_slash = (
611                                 "deb http://cdn-aws.deb.debian.org/debian"
612                                 " stretch main"
613                             )
614                             repo = aptpkg.mod_repo(source_line_no_slash, enabled=False)
615                             assert repo[source_line_no_slash]["uri"] == source_uri
616 @patch("salt.utils.path.os_walk", MagicMock(return_value=[("test", "test", "test")]))
617 @patch("os.path.getsize", MagicMock(return_value=123456))
618 @patch(
619     "fnmatch.filter",
620     MagicMock<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(return_value=["/var/cache/apt/archive/test_package.rpm"]),
621 )
622 def test_list_downloaded():
623     """
624     Test downloaded packages listing.
625     :return:
626     """
627     DOWNLOADED_RET = {
628         "test-package": {
629             "1.0": {
630                 "path": "/var/cache/apt/archive/test_package.rpm",
631                 "size": 123456,
632                 "creation_date_time_t": 1234567890,
633                 "creation_date_time": "2009-02-13T23:31:30",
634             }
635         }
636     }
637     with patch.dict(
638         aptpkg.__salt__,
639         {
640             "lowpkg.bin_pkg_info"</b></font>: MagicMock(
641                 return_value={"name": "test-package", "version": "1.0"}
642             )
643         },
644     ):
645         list_downloaded = aptpkg.list_downloaded()
646         assert len(list_downloaded) == 1
647         assert list_downloaded == DOWNLOADED_RET
648 def test__skip_source():
649     """
650     Test __skip_source.
651     :return:
652     """
653     source_type = "deb"
654     source_uri = "http://cdn-aws.deb.debian.org/debian"
655     source_line = "deb http://cdn-aws.deb.debian.org/debian stretch main\n"
656     mock_source = MockSourceEntry(source_uri, source_type, source_line, False)
657     ret = aptpkg._skip_source(mock_source)
658     assert ret is False
659     source_type = "ded"
660     source_uri = "http://cdn-aws.deb.debian.org/debian"
661     source_line = "deb http://cdn-aws.deb.debian.org/debian stretch main\n"
662     mock_source = MockSourceEntry(source_uri, source_type, source_line, True)
663     ret = aptpkg._skip_source(mock_source)
664     assert ret is True
665     source_type = "deb"
666     source_uri = "http://cdn-aws.deb.debian.org/debian"
667     source_line = "deb [http://cdn-aws.deb.debian.org/debian] stretch main\n"
668     mock_source = MockSourceEntry(source_uri, source_type, source_line, True)
669     ret = aptpkg._skip_source(mock_source)
670     assert ret is False
671 def test_normalize_name():
672     """
673     Test that package is normalized only when it should be
674     """
675     with patch.dict(aptpkg.__grains__, {"osarch": "amd64"}):
676         result = aptpkg.normalize_name("foo")
677         assert result == "foo", result
678         result = aptpkg.normalize_name("foo:amd64")
679         assert result == "foo", result
680         result = aptpkg.normalize_name("foo:any")
681         assert result == "foo", result
682         result = aptpkg.normalize_name("foo:all")
683         assert result == "foo", result
684         result = aptpkg.normalize_name("foo:i386")
685         assert result == "foo:i386", result
686 def test_list_repos():
687     """
688     Checks results from list_repos
689     """
690     source_type = "deb"
691     source_uri = "http://cdn-aws.deb.debian.org/debian/"
692     source_line = "deb http://cdn-aws.deb.debian.org/debian/ stretch main\n"
693     mock_source = MockSourceEntry(source_uri, source_type, source_line, False)
694     mock_source_list = MockSourceList()
695     mock_source_list.list = [mock_source]
696     with patch("salt.modules.aptpkg.SourcesList", MagicMock(), create=True):
697         with patch("salt.modules.aptpkg.SourceEntry", MagicMock(), create=True):
698             with patch(
699                 "salt.modules.aptpkg.SourcesList",
700                 MagicMock(return_value=mock_source_list),
701                 create=True,
702             ):
703                 repos = aptpkg.list_repos()
704                 assert source_uri in repos
705                 assert isinstance(repos[source_uri], list)
706                 assert len(repos[source_uri]) == 1
707                 assert "line" in repos[source_uri][0]
708                 _uri = _get_uri(repos[source_uri][0]["line"])
709                 assert _uri[-1] == "/"
710                 assert "uri" in repos[source_uri][0]
711                 assert repos[source_uri][0]["uri"][-1] == "/"
712 @pytest.mark.skipif(
713     HAS_APTSOURCES is False, reason="The 'aptsources' library is missing."
714 )
715 def test_expand_repo_def():
716     """
717     Checks results from expand_repo_def
718     """
719     source_type = "deb"
720     source_uri = "http://cdn-aws.deb.debian.org/debian/"
721     source_line = "deb http://cdn-aws.deb.debian.org/debian/ stretch main\n"
722     source_file = "/etc/apt/sources.list"
723     repo = "deb http://cdn-aws.deb.debian.org/debian/ stretch main\n"
724     sanitized = aptpkg.expand_repo_def(repo=repo, file=source_file)
725     assert isinstance(sanitized, dict)
726     assert "uri" in sanitized
727     assert sanitized["uri"][-1] == "/"
728     repo = "deb http://cdn-aws.deb.debian.org/debian/ stretch main\n"
729     sanitized = aptpkg.expand_repo_def(
730         repo=repo, file=source_file, architectures="amd64"
731     )
732     assert isinstance(sanitized, dict)
733     assert "line" in sanitized
734     assert (
735         sanitized["line"]
736         == "deb [arch=amd64] http://cdn-aws.deb.debian.org/debian/ stretch main"
737     )
738 def test_list_pkgs():
739     """
740     Test packages listing.
741     :return:
742     """
743     def _add_data(data, key, value):
744         data.setdefault(key, []).append(value)
745     apt_out = [
746         "install ok installed accountsservice 0.6.55-0ubuntu12~20.04.1 amd64",
747         "install ok installed acpid 1:2.0.32-1ubuntu1 amd64",
748         "install ok installed adduser 3.118ubuntu2 all",
749         "install ok installed alsa-topology-conf 1.2.2-1 all",
750         "install ok installed alsa-ucm-conf 1.2.2-1ubuntu0.4 all",
751         "install ok installed apparmor 2.13.3-7ubuntu5.1 amd64",
752         "install ok installed apport 2.20.11-0ubuntu27.9 all",
753         "install ok installed apport-symptoms 0.23 all",
754         "install ok installed apt 2.0.2ubuntu0.1 amd64",
755         "install ok installed at 3.1.23-1ubuntu1 amd64",
756     ]
757     with patch.dict(aptpkg<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.__grains__, {"osarch": "x86_64"}), patch.dict(
758         aptpkg.__salt__,
759         {"cmd.run_stdout": MagicMock(return_value=os.linesep.join(apt_out))},
760     ), patch.</b></font>dict(aptpkg.__salt__, {"pkg_resource.add_pkg": _add_data}), patch.dict(
761         aptpkg.__salt__,
762         {"pkg_resource.format_pkg_list": pkg_resource.format_pkg_list},
763     ), patch.dict(
764         aptpkg.__salt__, {"pkg_resource.sort_pkglist": pkg_resource.sort_pkglist}
765     ):
766         pkgs = aptpkg.list_pkgs(versions_as_list=True)
767         for pkg_name, pkg_version in {
768             "accountsservice": "0.6.55-0ubuntu12~20.04.1",
769             "acpid": "1:2.0.32-1ubuntu1",
770             "adduser": "3.118ubuntu2",
771             "alsa-topology-conf": "1.2.2-1",
772             "alsa-ucm-conf": "1.2.2-1ubuntu0.4",
773             "apparmor": "2.13.3-7ubuntu5.1",
774             "apport": "2.20.11-0ubuntu27.9",
775             "apport-symptoms": "0.23",
776             "apt": "2.0.2ubuntu0.1",
777             "apt-utils": "2.0.2ubuntu0.1",
778             "at": "3.1.23-1ubuntu1",
779         }.items():
780             assert pkgs[pkg_name] == [pkg_version]
781 def test_list_pkgs_no_context():
782     """
783     Test packages listing and ensure __context__ for pkg.list_pkgs is absent.
784     :return:
785     """
786     def _add_data(data, key, value):
787         data.setdefault(key, []).append(value)
788     apt_out = [
789         "install ok installed accountsservice 0.6.55-0ubuntu12~20.04.1 amd64",
790         "install ok installed acpid 1:2.0.32-1ubuntu1 amd64",
791         "install ok installed adduser 3.118ubuntu2 all",
792         "install ok installed alsa-topology-conf 1.2.2-1 all",
793         "install ok installed alsa-ucm-conf 1.2.2-1ubuntu0.4 all",
794         "install ok installed apparmor 2.13.3-7ubuntu5.1 amd64",
795         "install ok installed apport 2.20.11-0ubuntu27.9 all",
796         "install ok installed apport-symptoms 0.23 all",
797         "install ok installed apt 2.0.2ubuntu0.1 amd64",
798         "install ok installed apt-utils 2.0.2ubuntu0.1 amd64",
799         "install ok installed at 3.1.23-1ubuntu1 amd64",
800     with patch.dict(aptpkg.__grains__, {"osarch": "x86_64"}), patch.dict(
801         aptpkg.__salt__,
802         {"cmd.run_stdout": MagicMock(return_value<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=os.linesep.join(apt_out))},
803     ), patch.dict(aptpkg.__salt__, {"pkg_resource.add_pkg": _add_data}), patch.dict(
804         aptpkg.__salt__,
805         {"pkg_resource.format_pkg_list"</b></font>: pkg_resource.format_pkg_list},
806     ), patch.dict(
807         aptpkg.__salt__, {"pkg_resource.sort_pkglist": pkg_resource.sort_pkglist}
808     ), patch.object(
809         aptpkg, "_list_pkgs_from_context"
810     ) as list_pkgs_context_mock:
811         pkgs = aptpkg.list_pkgs(versions_as_list=True, use_context=False)
812         list_pkgs_context_mock.assert_not_called()
813         list_pkgs_context_mock.reset_mock()
814         pkgs = aptpkg.list_pkgs(versions_as_list=True, use_context=False)
815         list_pkgs_context_mock.assert_not_called()
816         list_pkgs_context_mock.reset_mock()
817 def test_call_apt_default():
818     """
819     Call default apt.
820     :return:
821     """
822     with patch.dict(
823         aptpkg.__salt__,
824         {"cmd.run_all": MagicMock(), "config.get": MagicMock(return_value=False)},
825     ):
826         aptpkg._call_apt(["apt-get", "install", "emacs"])  # pylint: disable=W0106
827         aptpkg.__salt__["cmd.run_all"].assert_called_once_with(
828             ["apt-get", "install", "emacs"],
829             env={},
830             output_loglevel="trace",
831             python_shell=False,
832         )
833 @patch("salt.utils.systemd.has_scope", MagicMock(return_value=True))
834 def test_call_apt_in_scope():
835     """
836     Call apt within the scope.
837     :return:
838     """
839     with patch.dict(
840         aptpkg.__salt__,
841         {"cmd.run_all": MagicMock(), "config.get": MagicMock(return_value=True)},
842     ):
843         aptpkg._call_apt(["apt-get", "purge", "vim"])  # pylint: disable=W0106
844         aptpkg.__salt__["cmd.run_all"].assert_called_once_with(
845             [
846                 "systemd-run",
847                 "--scope",
848                 "--description",
849                 '"salt.modules.aptpkg"',
850                 "apt-get",
851                 "purge",
852                 "vim",
853             ],
854             env={},
855             output_loglevel="trace",
856             python_shell=False,
857         )
858 def test_call_apt_with_kwargs():
859     """
860     Call apt with the optinal keyword arguments.
861     :return:
862     """
863     with patch.dict(
864         aptpkg.__salt__,
865         {"cmd.run_all": MagicMock(), "config.get": MagicMock(return_value=False)},
866     ):
867         aptpkg._call_apt(
868             ["dpkg", "-l", "python"],
869             python_shell=True,
870             output_loglevel="quiet",
871             ignore_retcode=False,
872             username="Darth Vader",
873         )  # pylint: disable=W0106
874         aptpkg.__salt__["cmd.run_all"].assert_called_once_with(
875             ["dpkg", "-l", "python"],
876             env={},
877             ignore_retcode=False,
878             output_loglevel="quiet",
879             python_shell=True,
880             username="Darth Vader",
881         )
882 def test_call_apt_dpkg_lock():
883     """
884     Call apt and ensure the dpkg locking is handled
885     :return:
886     """
887     cmd_side_effect = [
888         {"stderr": "Could not get lock"},
889         {"stderr": "Could not get lock"},
890         {"stderr": "Could not get lock"},
891         {"stderr": "Could not get lock"},
892         {"stderr": "", "stdout": ""},
893     ]
894     cmd_mock = MagicMock(side_effect=cmd_side_effect)
895     cmd_call = (
896         call(
897             ["dpkg", "-l", "python"],
898             env={},
899             ignore_retcode=False,
900             output_loglevel="quiet",
901             python_shell=True,
902             username="Darth Vader",
903         ),
904     )
905     expected_calls = [cmd_call * 5]
906     with patch.dict(
907         aptpkg.__salt__,
908         {"cmd.run_all": cmd_mock, "config.get": MagicMock(return_value=False)},
909     ):
910         with patch("salt.modules.aptpkg.time.sleep", MagicMock()) as sleep_mock:
911             aptpkg._call_apt(
912                 ["dpkg", "-l", "python"],
913                 python_shell=True,
914                 output_loglevel="quiet",
915                 ignore_retcode=False,
916                 username="Darth Vader",
917             )  # pylint: disable=W0106
918             assert sleep_mock.call_count &gt;= 4
919             assert cmd_mock.call_count == 5
920             cmd_mock.has_calls(expected_calls)
921 def test_services_need_restart_checkrestart_missing():
922     with patch("salt.utils.path.which_bin", Mock(return_value=None)):
923         with pytest.raises(CommandNotFoundError):
924             aptpkg.services_need_restart()
925 @patch("salt.utils.path.which_bin", Mock(return_value="/usr/sbin/checkrestart"))
926 def test_services_need_restart():
927     """
928     Test that checkrestart output is parsed correctly
929     """
930     cr_output = """
931 PROCESSES: 24
932 PROGRAMS: 17
933 PACKAGES: 8
934 SERVICE:rsyslog,385,/usr/sbin/rsyslogd
935 SERVICE:cups-daemon,390,/usr/sbin/cupsd
936     """
937     with patch.dict(aptpkg.__salt__, {"cmd.run_stdout": Mock(return_value=cr_output)}):
938         assert sorted(aptpkg.services_need_restart()) == [
939             "cups-daemon",
940             "rsyslog",
941         ]
942 @pytest.mark.skipif(
943     HAS_APTSOURCES is True, reason="Only run test with python3-apt library is missing."
944 )
945 def test_sourceslist_multiple_comps():
946     """
947     Test SourcesList when repo has multiple comps
948     """
949     repo_line = "deb http://archive.ubuntu.com/ubuntu/ focal-updates main restricted"
950     with patch.object(aptpkg, "HAS_APT", return_value=True):
951         with patch("salt.utils.files.fopen", mock_open(read_data=repo_line)):
952             with patch("pathlib.Path.is_file", side_effect=[True, False]):
953                 sources = aptpkg.SourcesList()
954                 for source in sources:
955                     assert source.type == "deb"
956                     assert source.uri == "http://archive.ubuntu.com/ubuntu/"
957                     assert source.comps == ["main", "restricted"]
958                     assert source.dist == "focal-updates"
959 @pytest.mark.skipif(
960     HAS_APTSOURCES is True, reason="Only run test with python3-apt library is missing."
961 )
962 @pytest.mark.parametrize(
963     "repo_line",
964     [
965         "deb [ arch=amd64 ] http://archive.ubuntu.com/ubuntu/ focal-updates main restricted",
966         "deb [arch=amd64 ] http://archive.ubuntu.com/ubuntu/ focal-updates main restricted",
967         "deb [arch=amd64 test=one ] http://archive.ubuntu.com/ubuntu/ focal-updates main restricted",
968         "deb [arch=amd64,armel test=one ] http://archive.ubuntu.com/ubuntu/ focal-updates main restricted",
969         "deb [ arch=amd64,armel test=one ] http://archive.ubuntu.com/ubuntu/ focal-updates main restricted",
970         "deb [ arch=amd64,armel test=one] http://archive.ubuntu.com/ubuntu/ focal-updates main restricted",
971         "deb [arch=amd64] http://archive.ubuntu.com/ubuntu/ focal-updates main restricted",
972     ],
973 )
974 def test_sourceslist_architectures(repo_line):
975     """
976     Test SourcesList when architectures is in repo
977     """
978     with patch("salt.utils.files.fopen", mock_open(read_data=repo_line)):
979         with patch("pathlib.Path.is_file", side_effect=[True, False]):
980             sources = aptpkg.SourcesList()
981             for source in sources:
982                 assert source.type == "deb"
983                 assert source.uri == "http://archive.ubuntu.com/ubuntu/"
984                 assert source.comps == ["main", "restricted"]
985                 assert source.dist == "focal-updates"
986                 if "," in repo_line:
987                     assert source.architectures == ["amd64", "armel"]
988                 else:
989                     assert source.architectures == ["amd64"]
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_thin_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2     :codeauthor: :email:`Bo Maryniuk &lt;bo@suse.de&gt;`
3 """
4 import copy
5 import os
6 import pathlib
7 import shutil
8 import sys
9 import tarfile
10 import tempfile
11 import pytest
12 import salt.exceptions
13 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import salt.utils.hashutils
14 import salt.utils.json
15 import salt.utils.platform
16 import salt.utils.stringutils
17 from salt.utils import thin
18 from salt.utils.stringutils import to_bytes as bts
19 from tests.support.helpers import TstSuiteLoggingHandler, VirtualEnv
20 from tests.support.mock import MagicMock, patch
21 from tests.support.runtests import RUNTIME_VARS
22 from tests.support.unit import TestCase, skipIf
23 try:
24     import</b></font> pytest
25 except ImportError:
26     pytest = None
27 def patch_if(condition, *args, **kwargs):
28     """
29     Return a patch decorator if the provided condition is met
30     """
31     if condition:
32         return patch(*args, **kwargs)
33     def inner(func):
34         return func
35     return inner
36 @skipIf(pytest is None, "PyTest is missing")
37 class SSHThinTestCase(TestCase):
38     """
39     TestCase for SaltSSH-related parts.
40     """
41     def setUp(self):
42         self.jinja_fp = os.path.dirname(jinja2.__file__)
43         self.ext_conf = {
44             "test": {
45                 "py-version": [2, 7],
46                 "path": RUNTIME_VARS.SALT_CODE_DIR,
47                 "dependencies": {"jinja2": self.jinja_fp},
48             }
49         }
50         self.tops = copy.deepcopy(self.ext_conf)
51         self.tops["test"]["dependencies"] = [self.jinja_fp]
52         self.digest = salt.utils.hashutils.DigestCollector()
53         self.exp_files = [
54             <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>os.path.join("salt", "payload.py"),
55             os.path.join("jinja2", "__init__.py"),
56         ]
57         lib_root = os.path.join(RUNTIME_VARS.</b></font>TMP, "fake-libs")
58         self.fake_libs = {
59             "distro": os.path.join(lib_root, "distro"),
60             "jinja2": os.path.join(lib_root, "jinja2"),
61             "yaml": os.path.join(lib_root, "yaml"),
62             "tornado": os.path.join(lib_root, "tornado"),
63             "msgpack": os.path.join(lib_root, "msgpack"),
64         }
65         code_dir = pathlib.Path(RUNTIME_VARS.CODE_DIR).resolve()
66         self.exp_ret = {
67             "distro": str(code_dir / "distro.py"),
68             "jinja2": str(code_dir / "jinja2"),
69             "yaml": str(code_dir / "yaml"),
70             "tornado": str(code_dir / "tornado"),
71             "msgpack": str(code_dir / "msgpack"),
72             "certifi": str(code_dir / "certifi"),
73             "singledispatch": str(code_dir / "singledispatch.py"),
74         }
75         self.exc_libs = ["jinja2", "yaml"]
76     def tearDown(self):
77             if os.path.exists(fp):
78                 shutil.rmtree(fp)
79         self<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.exc_libs = None
80         self.jinja_fp = None
81         self.ext_conf = None
82         self.tops = None
83         self.tar = None
84         self.digest = None
85         self.exp_files = None
86         self.fake_libs = None
87         self.exp_ret = None
88     def</b></font> _popen(self, return_value=None, side_effect=None, returncode=0):
89         """
90         Fake subprocess.Popen
91         :return:
92         """
93         proc = MagicMock()
94         proc.communicate = MagicMock(return_value=return_value, side_effect=side_effect)
95         proc.returncode = returncode
96         popen = MagicMock(return_value=proc)
97         return popen
98     def _version_info(self, major=None, minor=None):
99         """
100         Fake version info.
101         :param major:
102         :param minor:
103         :return:
104         """
105         class VersionInfo(tuple):
106             pass
107         vi = VersionInfo([major, minor])
108         vi.major = major or sys.version_info.major
109         vi.minor = minor or sys.version_info.minor
110         return vi
111     def _tarfile(self, getinfo=False):
112         """
113         Fake tarfile handler.
114         :return:
115         """
116         spec = ["add", "close"]
117         if getinfo:
118             spec.append("getinfo")
119         tf = MagicMock()
120         tf.open = MagicMock(return_value=MagicMock(spec=spec))
121     @patch("salt.utils.thin.log", MagicMock())
122     @patch("salt.utils.thin.os.path.isfile", MagicMock<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(return_value=False))
123     def test_get_ext_tops_cfg_missing_dependencies(self):
124         """
125         Test thin.get_ext_tops contains all required dependencies.
126         :return:
127         """
128         cfg = {"namespace": {"py-version": [0, 0], "path": "/foo", "dependencies": []}}
129         with pytest.raises(salt.exceptions.</b></font>SaltSystemExit) as err:
130             thin.get_ext_tops(cfg)
131         self.assertIn("Missing dependencies", str(err.value))
132         self.assertTrue(thin.log.error.called)
133         self.assertIn("Missing dependencies", thin.log.error.call_args[0][0])
134         self.assertIn("jinja2, yaml, tornado, msgpack", thin.log.error.call_args[0][0])
135     @patch("salt.exceptions.SaltSystemExit", Exception)
136     @patch("salt.utils.thin.log", MagicMock())
137     @patch("salt.utils.thin.os.path.isfile", MagicMock(return_value=False))
138     def test_get_ext_tops_cfg_missing_interpreter(self):
139         """
140         Test thin.get_ext_tops contains interpreter configuration.
141         :return:
142         """
143         cfg = {"namespace": {"path": "/foo", "dependencies": []}}
144         with pytest.raises(salt.exceptions.SaltSystemExit) as err:
145             thin.get_ext_tops(cfg)
146         self.assertIn("missing specific locked Python version", str(err.value))
147     @patch("salt.exceptions.SaltSystemExit", Exception)
148     @patch("salt.utils.thin.log", MagicMock())
149     @patch("salt.utils.thin.os.path.isfile", MagicMock(return_value=False))
150     def test_get_ext_tops_cfg_wrong_interpreter(self):
151         """
152         Test thin.get_ext_tops contains correct interpreter configuration.
153         :return:
154         """
155         cfg = {"namespace": {"path": "/foo", "py-version": 2, "dependencies": []}}
156         with pytest.raises(salt.exceptions.SaltSystemExit) as err:
157             thin.get_ext_tops(cfg)
158         self.assertIn(
159             "specific locked Python version should be a list of major/minor version",
160             str(err.value),
161         )
162     @patch("salt.exceptions.SaltSystemExit", Exception)
163     @patch("salt.utils.thin.log", MagicMock())
164     @patch("salt.utils.thin.os.path.isfile", MagicMock(return_value=False))
165     def test_get_ext_tops_cfg_interpreter(self):
166         """
167         Test thin.get_ext_tops interpreter configuration.
168         :return:
169         """
170         cfg = {
171             "namespace": {
172                 "path": "/foo",
173                 "py-version": [2, 6],
174                 "dependencies": {
175                     "jinja2": "",
176                     "yaml": "",
177                     "tornado": "",
178                     "msgpack": "",
179                 },
180             }
181         }
182         with pytest.raises(salt.exceptions.SaltSystemExit):
183             thin.get_ext_tops(cfg)
184         assert len(thin.log.warning.mock_calls) == 4
185         assert sorted(x[1][1] for x in thin.log.warning.mock_calls) == [
186             "jinja2",
187             "msgpack",
188             "tornado",
189             "yaml",
190         ]
191         assert (
192             "Module test has missing configuration"
193             == thin.log.warning.mock_calls[0][1][0] % "test"
194         )
195     @patch("salt.utils.thin.log", MagicMock())
196     @patch("salt.utils.thin.os.path.isfile", MagicMock(return_value=False))
197     def test_get_ext_tops_dependency_config_check(self):
198         """
199         Test thin.get_ext_tops dependencies are importable
200         :return:
201         """
202         cfg = {
203             "namespace": {
204                 "path": "/foo",
205                 "py-version": [2, 6],
206                 "dependencies": {
207                     "jinja2": "/jinja/foo.py",
208                     "yaml": "/yaml/",
209                     "tornado": "/tornado/wrong.rb",
210                     "msgpack": "msgpack.sh",
211                 },
212             }
213         }
214         with pytest.raises(salt.exceptions.SaltSystemExit) as err:
215             thin.get_ext_tops(cfg)
216         self.assertIn(
217             "Missing dependencies for the alternative version in the "
218             "external configuration",
219             str(err.value),
220         )
221         messages = {}
222         for cl in thin.log.warning.mock_calls:
223             messages[cl[1][1]] = cl[1][0] % (cl[1][1], cl[1][2])
224         for mod in ["tornado", "yaml", "msgpack"]:
225             self.assertIn("not a Python importable module", messages[mod])
226         self.assertIn(
227             "configured with not a file or does not exist", messages["jinja2"]
228         )
229     @patch("salt.exceptions.SaltSystemExit", Exception)
230     @patch("salt.utils.thin.log", MagicMock())
231     @patch("salt.utils.thin.os.path.isfile", MagicMock(return_value=True))
232     def test_get_ext_tops_config_pass(self):
233         """
234         Test thin.get_ext_tops configuration
235         :return:
236         """
237         cfg = {
238             "namespace": {
239                 "path": "/foo",
240                 "py-version": [2, 6],
241                 "dependencies": {
242                     "jinja2": "/jinja/foo.py",
243                     "yaml": "/yaml/",
244                     "tornado": "/tornado/tornado.py",
245                     "msgpack": "msgpack.py",
246                     "distro": "distro.py",
247                 },
248             }
249         }
250         out = thin.get_ext_tops(cfg)
251         assert out["namespace"]["py-version"] == cfg["namespace"]["py-version"]
252         assert out["namespace"]["path"] == cfg["namespace"]["path"]
253         assert sorted(out["namespace"]["dependencies"]) == sorted(
254             [
255                 "/tornado/tornado.py",
256                 "/jinja/foo.py",
257                 "/yaml/",
258                 "msgpack.py",
259                 "distro.py",
260             ]
261         )
262     @patch("salt.utils.thin.sys.argv", [None, '{"foo": "bar"}'])
263     @patch("salt.utils.thin.get_tops", lambda **kw: kw)
264     def test_gte(self):
265         """
266         Test thin.gte external call for processing the info about tops per interpreter.
267         :return:
268         """
269         assert salt.utils.json.loads(thin.gte()).get("foo") == "bar"
270     def test_add_dep_path(self):
271         """
272         Test thin._add_dependency function to setup dependency paths
273         :return:
274         """
275         container = []
276         for pth in ["/foo/bar.py", "/something/else/__init__.py"]:
277             thin._add_dependency(container, type("obj", (), {"__file__": pth})())
278         assert "__init__" not in container[1]
279         assert container == ["/foo/bar.py", "/something/else"]
280     def test_thin_path(self):
281         """
282         Test thin.thin_path returns the expected path.
283         :return:
284         """
285         path = os.sep + os.path.join("path", "to")
286         expected = os.path.join(path, "thin", "thin.tgz")
287         self.assertEqual(thin.thin_path(path), expected)
288     def test_get_salt_call_script(self):
289         """
290         Test get salt-call script rendered.
291         :return:
292         """
293         out = thin._get_salt_call("foo", "bar", py26=[2, 6], py27=[2, 7], py34=[3, 4])
294         for line in salt.utils.stringutils.to_str(out).split(os.linesep):
295             if line.startswith("namespaces = {"):
296                 data = salt.utils.json.loads(line.replace("namespaces = ", "").strip())
297                 assert data.get("py26") == [2, 6]
298                 assert data.get("py27") == [2, 7]
299                 assert data.get("py34") == [3, 4]
300             if line.startswith("syspaths = "):
301                 data = salt.utils.json.loads(line.replace("syspaths = ", ""))
302                 assert data == ["foo", "bar"]
303     def test_get_ext_namespaces_empty(self):
304         """
305         Test thin._get_ext_namespaces function returns an empty dictionary on nothing
306         :return:
307         """
308         for obj in [None, {}, []]:
309             assert thin._get_ext_namespaces(obj) == {}
310     def test_get_ext_namespaces(self):
311         """
312         Test thin._get_ext_namespaces function returns namespaces properly out of the config.
313         :return:
314         """
315         cfg = {"ns": {"py-version": [2, 7]}}
316         assert thin._get_ext_namespaces(cfg).get("ns") == (
317             2,
318             7,
319         )
320         assert isinstance(thin._get_ext_namespaces(cfg).get("ns"), tuple)
321     def test_get_ext_namespaces_failure(self):
322         """
323         Test thin._get_ext_namespaces function raises an exception
324         if python major/minor version is not configured.
325         :return:
326         """
327         with pytest.raises(salt.exceptions.SaltSystemExit):
328             thin._get_ext_namespaces({"ns": {}})
329     @patch(
330         "salt.utils.thin.distro",
331         type("distro", (), {"__file__": "/site-packages/distro"}),
332     )
333     @patch(
334         "salt.utils.thin.salt",
335         type("salt", (), {"__file__": "/site-packages/salt"}),
336     )
337     @patch(
338         "salt.utils.thin.jinja2",
339         type("jinja2", (), {"__file__": "/site-packages/jinja2"}),
340     )
341     @patch(
342         "salt.utils.thin.yaml",
343         type("yaml", (), {"__file__": "/site-packages/yaml"}),
344     )
345     @patch(
346         "salt.utils.thin.tornado",
347         type("tornado", (), {"__file__": "/site-packages/tornado"}),
348     )
349     @patch(
350         "salt.utils.thin.msgpack",
351         type("msgpack", (), {"__file__": "/site-packages/msgpack"}),
352     )
353     @patch(
354         "salt.utils.thin.certifi",
355         type("certifi", (), {"__file__": "/site-packages/certifi"}),
356     )
357     @patch(
358         "salt.utils.thin.singledispatch",
359         type("singledispatch", (), {"__file__": "/site-packages/sdp"}),
360     )
361     @patch(
362         "salt.utils.thin.singledispatch_helpers",
363         type("singledispatch_helpers", (), {"__file__": "/site-packages/sdp_hlp"}),
364     )
365     @patch(
366         "salt.utils.thin.ssl_match_hostname",
367         type("ssl_match_hostname", (), {"__file__": "/site-packages/ssl_mh"}),
368     )
369     @patch(
370         "salt.utils.thin.markupsafe",
371         type("markupsafe", (), {"__file__": "/site-packages/markupsafe"}),
372     )
373     @patch(
374         "salt.utils.thin.backports_abc",
375         type("backports_abc", (), {"__file__": "/site-packages/backports_abc"}),
376     )
377     @patch(
378         "salt.utils.thin.concurrent",
379         type("concurrent", (), {"__file__": "/site-packages/concurrent"}),
380     )
381     @patch(
382         "salt.utils.thin.py_contextvars",
383         type("contextvars", (), {"__file__": "/site-packages/contextvars"}),
384     )
385     @patch_if(
386         salt.utils.thin.has_immutables,
387         "salt.utils.thin.immutables",
388         type("immutables", (), {"__file__": "/site-packages/immutables"}),
389     )
390     @patch("salt.utils.thin.log", MagicMock())
391     def test_get_tops(self):
392         """
393         Test thin.get_tops to get top directories, based on the interpreter.
394         :return:
395         """
396         base_tops = [
397             "distro",
398             "salt",
399             "jinja2",
400             "yaml",
401             "tornado",
402             "msgpack",
403             "certifi",
404             "sdp",
405             "sdp_hlp",
406             "ssl_mh",
407             "markupsafe",
408             "backports_abc",
409             "concurrent",
410             "contextvars",
411         ]
412         if salt.utils.thin.has_immutables:
413             base_tops.extend(["immutables"])
414         tops = []
415         for top in thin.get_tops(extra_mods="foo,bar"):
416             if top.find("/") != -1:
417                 spl = "/"
418             else:
419                 spl = os.sep
420             tops.append(top.rsplit(spl, 1)[-1])
421         assert len(tops) == len(base_tops)
422         assert sorted(tops) == sorted(base_tops), sorted(tops)
423     @patch(
424         "salt.utils.thin.distro",
425         type("distro", (), {"__file__": "/site-packages/distro"}),
426     )
427     @patch(
428         "salt.utils.thin.salt",
429         type("salt", (), {"__file__": "/site-packages/salt"}),
430     )
431     @patch(
432         "salt.utils.thin.jinja2",
433         type("jinja2", (), {"__file__": "/site-packages/jinja2"}),
434     )
435     @patch(
436         "salt.utils.thin.yaml",
437         type("yaml", (), {"__file__": "/site-packages/yaml"}),
438     )
439     @patch(
440         "salt.utils.thin.tornado",
441         type("tornado", (), {"__file__": "/site-packages/tornado"}),
442     )
443     @patch(
444         "salt.utils.thin.msgpack",
445         type("msgpack", (), {"__file__": "/site-packages/msgpack"}),
446     )
447     @patch(
448         "salt.utils.thin.certifi",
449         type("certifi", (), {"__file__": "/site-packages/certifi"}),
450     )
451     @patch(
452         "salt.utils.thin.singledispatch",
453         type("singledispatch", (), {"__file__": "/site-packages/sdp"}),
454     )
455     @patch(
456         "salt.utils.thin.singledispatch_helpers",
457         type("singledispatch_helpers", (), {"__file__": "/site-packages/sdp_hlp"}),
458     )
459     @patch(
460         "salt.utils.thin.ssl_match_hostname",
461         type("ssl_match_hostname", (), {"__file__": "/site-packages/ssl_mh"}),
462     )
463     @patch(
464         "salt.utils.thin.markupsafe",
465         type("markupsafe", (), {"__file__": "/site-packages/markupsafe"}),
466     )
467     @patch(
468         "salt.utils.thin.backports_abc",
469         type("backports_abc", (), {"__file__": "/site-packages/backports_abc"}),
470     )
471     @patch(
472         "salt.utils.thin.concurrent",
473         type("concurrent", (), {"__file__": "/site-packages/concurrent"}),
474     )
475     @patch(
476         "salt.utils.thin.py_contextvars",
477         type("contextvars", (), {"__file__": "/site-packages/contextvars"}),
478     )
479     @patch_if(
480         salt.utils.thin.has_immutables,
481         "salt.utils.thin.immutables",
482         type("immutables", (), {"__file__": "/site-packages/immutables"}),
483     )
484     @patch("salt.utils.thin.log", MagicMock())
485     def test_get_tops_extra_mods(self):
486         """
487         Test thin.get_tops to get extra-modules alongside the top directories, based on the interpreter.
488         :return:
489         """
490         base_tops = [
491             "distro",
492             "salt",
493             "jinja2",
494             "yaml",
495             "tornado",
496             "msgpack",
497             "certifi",
498             "sdp",
499             "sdp_hlp",
500             "ssl_mh",
501             "concurrent",
502             "markupsafe",
503             "backports_abc",
504             "contextvars",
505             "foo",
506             "bar.py",
507         ]
508         if salt.utils.thin.has_immutables:
509             base_tops.extend(["immutables"])
510         libs = salt.utils.thin.find_site_modules("contextvars")
511         foo = {"__file__": os.sep + os.path.join("custom", "foo", "__init__.py")}
512         bar = {"__file__": os.sep + os.path.join("custom", "bar")}
513         with patch("salt.utils.thin.find_site_modules", MagicMock(side_effect=[libs])):
514             with patch(
515                 "builtins.__import__",
516                 MagicMock(side_effect=[type("foo", (), foo), type("bar", (), bar)]),
517             ):
518                 tops = []
519                 for top in thin.get_tops(extra_mods="foo,bar"):
520                     if top.find("/") != -1:
521                         spl = "/"
522                     else:
523                         spl = os.sep
524                     tops.append(top.rsplit(spl, 1)[-1])
525         self.assertEqual(len(tops), len(base_tops))
526         self.assertListEqual(sorted(tops), sorted(base_tops))
527     @patch(
528         "salt.utils.thin.distro",
529         type("distro", (), {"__file__": "/site-packages/distro"}),
530     )
531     @patch(
532         "salt.utils.thin.salt",
533         type("salt", (), {"__file__": "/site-packages/salt"}),
534     )
535     @patch(
536         "salt.utils.thin.jinja2",
537         type("jinja2", (), {"__file__": "/site-packages/jinja2"}),
538     )
539     @patch(
540         "salt.utils.thin.yaml",
541         type("yaml", (), {"__file__": "/site-packages/yaml"}),
542     )
543     @patch(
544         "salt.utils.thin.tornado",
545         type("tornado", (), {"__file__": "/site-packages/tornado"}),
546     )
547     @patch(
548         "salt.utils.thin.msgpack",
549         type("msgpack", (), {"__file__": "/site-packages/msgpack"}),
550     )
551     @patch(
552         "salt.utils.thin.certifi",
553         type("certifi", (), {"__file__": "/site-packages/certifi"}),
554     )
555     @patch(
556         "salt.utils.thin.singledispatch",
557         type("singledispatch", (), {"__file__": "/site-packages/sdp"}),
558     )
559     @patch(
560         "salt.utils.thin.singledispatch_helpers",
561         type("singledispatch_helpers", (), {"__file__": "/site-packages/sdp_hlp"}),
562     )
563     @patch(
564         "salt.utils.thin.ssl_match_hostname",
565         type("ssl_match_hostname", (), {"__file__": "/site-packages/ssl_mh"}),
566     )
567     @patch(
568         "salt.utils.thin.markupsafe",
569         type("markupsafe", (), {"__file__": "/site-packages/markupsafe"}),
570     )
571     @patch(
572         "salt.utils.thin.backports_abc",
573         type("backports_abc", (), {"__file__": "/site-packages/backports_abc"}),
574     )
575     @patch(
576         "salt.utils.thin.concurrent",
577         type("concurrent", (), {"__file__": "/site-packages/concurrent"}),
578     )
579     @patch(
580         "salt.utils.thin.py_contextvars",
581         type("contextvars", (), {"__file__": "/site-packages/contextvars"}),
582     )
583     @patch_if(
584         salt.utils.thin.has_immutables,
585         "salt.utils.thin.immutables",
586         type("immutables", (), {"__file__": "/site-packages/immutables"}),
587     )
588     @patch("salt.utils.thin.log", MagicMock())
589     def test_get_tops_so_mods(self):
590         """
591         Test thin.get_tops to get extra-modules alongside the top directories, based on the interpreter.
592         :return:
593         """
594         base_tops = [
595             "distro",
596             "salt",
597             "jinja2",
598             "yaml",
599             "tornado",
600             "msgpack",
601             "certifi",
602             "sdp",
603             "sdp_hlp",
604             "ssl_mh",
605             "concurrent",
606             "markupsafe",
607             "backports_abc",
608             "contextvars",
609             "foo.so",
610             "bar.so",
611         ]
612         if salt.utils.thin.has_immutables:
613             base_tops.extend(["immutables"])
614         libs = salt.utils.thin.find_site_modules("contextvars")
615         with patch("salt.utils.thin.find_site_modules", MagicMock(side_effect=[libs])):
616             with patch(
617                 "builtins.__import__",
618                 MagicMock(
619                     side_effect=[
620                         type("salt", (), {"__file__": "/custom/foo.so"}),
621                         type("salt", (), {"__file__": "/custom/bar.so"}),
622                     ]
623                 ),
624             ):
625                 tops = []
626                 for top in thin.get_tops(so_mods="foo,bar"):
627                     if top.find("/") != -1:
628                         spl = "/"
629                     else:
630                         spl = os.sep
631                     tops.append(top.rsplit(spl, 1)[-1])
632         assert len(tops) == len(base_tops)
633         assert sorted(tops) == sorted(base_tops)
634     @patch("salt.utils.thin.gen_thin", MagicMock(return_value="/path/to/thin/thin.tgz"))
635     @patch("salt.utils.hashutils.get_hash", MagicMock(return_value=12345))
636     def test_thin_sum(self):
637         """
638         Test thin.thin_sum function.
639         :return:
640         """
641         assert thin.thin_sum("/cachedir", form="sha256")[1] == 12345
642         thin.salt.utils.hashutils.get_hash.assert_called()
643         assert thin.salt.utils.hashutils.get_hash.call_count == 1
644         path, form = thin.salt.utils.hashutils.get_hash.call_args[0]
645         assert path == "/path/to/thin/thin.tgz"
646         assert form == "sha256"
647     @patch("salt.utils.thin.gen_min", MagicMock(return_value="/path/to/thin/min.tgz"))
648     @patch("salt.utils.hashutils.get_hash", MagicMock(return_value=12345))
649     def test_min_sum(self):
650         """
651         Test thin.thin_sum function.
652         :return:
653         """
654         assert thin.min_sum("/cachedir", form="sha256") == 12345
655         thin.salt.utils.hashutils.get_hash.assert_called()
656         assert thin.salt.utils.hashutils.get_hash.call_count == 1
657         path, form = thin.salt.utils.hashutils.get_hash.call_args[0]
658         assert path == "/path/to/thin/min.tgz"
659         assert form == "sha256"
660     @patch("salt.utils.thin.sys.version_info", (2, 5))
661     @patch("salt.exceptions.SaltSystemExit", Exception)
662     def test_gen_thin_fails_ancient_python_version(self):
663         """
664         Test thin.gen_thin function raises an exception
665         if Python major/minor version is lower than 2.6
666         :return:
667         """
668         with pytest.raises(salt.exceptions.SaltSystemExit) as err:
669             thin.sys.exc_clear = lambda: None
670             thin.gen_thin("")
671         self.assertIn(
672             'The minimum required python version to run salt-ssh is "3"',
673             str(err.value),
674         )
675     @patch("salt.exceptions.SaltSystemExit", Exception)
676     @patch("salt.utils.thin.log", MagicMock())
677     @patch("salt.utils.thin.os.makedirs", MagicMock())
678     @patch("salt.utils.files.fopen", MagicMock())
679     @patch("salt.utils.thin._get_salt_call", MagicMock())
680     @patch("salt.utils.thin._get_ext_namespaces", MagicMock())
681     @patch("salt.utils.thin.get_tops", MagicMock(return_value=["/foo3", "/bar3"]))
682     @patch("salt.utils.thin.get_ext_tops", MagicMock(return_value={}))
683     @patch("salt.utils.thin.os.path.isfile", MagicMock())
684     @patch("salt.utils.thin.os.path.isdir", MagicMock(return_value=True))
685     @patch("salt.utils.thin.log", MagicMock())
686     @patch("salt.utils.thin.os.remove", MagicMock())
687     @patch("salt.utils.thin.os.path.exists", MagicMock())
688     @patch("salt.utils.path.os_walk", MagicMock(return_value=[]))
689     @patch(
690         "salt.utils.thin.subprocess.Popen",
691         _popen(
692             None,
693             side_effect=[(bts("2.7"), bts("")), (bts('["/foo27", "/bar27"]'), bts(""))],
694         ),
695     )
696     @patch("salt.utils.thin.tarfile", MagicMock())
697     @patch("salt.utils.thin.zipfile", MagicMock())
698     @patch("salt.utils.thin.os.getcwd", MagicMock())
699     @patch("salt.utils.thin.os.access", MagicMock(return_value=True))
700     @patch("salt.utils.thin.os.chdir", MagicMock())
701     @patch("salt.utils.thin.os.close", MagicMock())
702     @patch("salt.utils.thin.tempfile.mkdtemp", MagicMock())
703     @patch(
704         "salt.utils.thin.tempfile.mkstemp", MagicMock(return_value=(3, ".temporary"))
705     )
706     @patch("salt.utils.thin.shutil", MagicMock())
707     @patch("salt.utils.thin.sys.version_info", _version_info(None, 3, 6))
708     @patch("salt.utils.path.which", MagicMock(return_value="/usr/bin/python"))
709     def test_gen_thin_compression_fallback_py3(self):
710         """
711         Test thin.gen_thin function if fallbacks to the gzip compression, once setup wrong.
712         NOTE: Py2 version of this test is not required, as code shares the same spot across the versions.
713         :return:
714         """
715         thin.gen_thin("", compress="arj")
716         thin.log.warning.assert_called()
717         pt, msg = thin.log.warning.mock_calls[0][1]
718         assert (
719             pt % msg
720             == 'Unknown compression type: "arj". Falling back to "gzip" compression.'
721         )
722         thin.zipfile.ZipFile.assert_not_called()
723         thin.tarfile.open.assert_called()
724     @patch("salt.exceptions.SaltSystemExit", Exception)
725     @patch("salt.utils.thin.log", MagicMock())
726     @patch("salt.utils.thin.os.makedirs", MagicMock())
727     @patch("salt.utils.files.fopen", MagicMock())
728     @patch("salt.utils.thin._get_salt_call", MagicMock())
729     @patch("salt.utils.thin._get_ext_namespaces", MagicMock())
730     @patch("salt.utils.thin.get_tops", MagicMock(return_value=["/foo3", "/bar3"]))
731     @patch("salt.utils.thin.get_ext_tops", MagicMock(return_value={}))
732     @patch("salt.utils.thin.os.path.isfile", MagicMock())
733     @patch("salt.utils.thin.os.path.isdir", MagicMock(return_value=False))
734     @patch("salt.utils.thin.log", MagicMock())
735     @patch("salt.utils.thin.os.remove", MagicMock())
736     @patch("salt.utils.thin.os.path.exists", MagicMock())
737     @patch("salt.utils.path.os_walk", MagicMock(return_value=[]))
738     @patch(
739         "salt.utils.thin.subprocess.Popen",
740         _popen(
741             None,
742             side_effect=[(bts("2.7"), bts("")), (bts('["/foo27", "/bar27"]'), bts(""))],
743         ),
744     )
745     @patch("salt.utils.thin.tarfile", MagicMock())
746     @patch("salt.utils.thin.zipfile", MagicMock())
747     @patch("salt.utils.thin.os.getcwd", MagicMock())
748     @patch("salt.utils.thin.os.access", MagicMock(return_value=True))
749     @patch("salt.utils.thin.os.chdir", MagicMock())
750     @patch("salt.utils.thin.os.close", MagicMock())
751     @patch("salt.utils.thin.tempfile.mkdtemp", MagicMock(return_value=""))
752     @patch(
753         "salt.utils.thin.tempfile.mkstemp", MagicMock(return_value=(3, ".temporary"))
754     )
755     @patch("salt.utils.thin.shutil", MagicMock())
756     @patch("salt.utils.thin.sys.version_info", _version_info(None, 3, 6))
757     @patch("salt.utils.path.which", MagicMock(return_value="/usr/bin/python"))
758     def test_gen_thin_control_files_written_py3(self):
759         """
760         Test thin.gen_thin function if control files are written (version, salt-call etc).
761         :return:
762         """
763         thin.gen_thin("")
764         arc_name, arc_mode = thin.tarfile.method_calls[0][1]
765         self.assertEqual(arc_name, ".temporary")
766         self.assertEqual(arc_mode, "w:gz")
767         for idx, fname in enumerate(
768             ["version", ".thin-gen-py-version", "salt-call", "supported-versions"]
769         ):
770             name = thin.tarfile.open().method_calls[idx + 2][1][0]
771             self.assertEqual(name, fname)
772         thin.tarfile.open().close.assert_called()
773     @patch("salt.exceptions.SaltSystemExit", Exception)
774     @patch("salt.utils.thin.log", MagicMock())
775     @patch("salt.utils.thin.os.makedirs", MagicMock())
776     @patch("salt.utils.files.fopen", MagicMock())
777     @patch("salt.utils.thin._get_salt_call", MagicMock())
778     @patch("salt.utils.thin._get_ext_namespaces", MagicMock())
779     @patch("salt.utils.thin.get_tops", MagicMock(return_value=["/salt", "/bar3"]))
780     @patch("salt.utils.thin.get_ext_tops", MagicMock(return_value={}))
781     @patch("salt.utils.thin.os.path.isfile", MagicMock())
782     @patch("salt.utils.thin.os.path.isdir", MagicMock(return_value=True))
783     @patch("salt.utils.thin.log", MagicMock())
784     @patch("salt.utils.thin.os.remove", MagicMock())
785     @patch("salt.utils.thin.os.path.exists", MagicMock())
786     @patch(
787         "salt.utils.path.os_walk",
788         MagicMock(
789             return_value=(
790                 ("root", [], ["r1", "r2", "r3"]),
791                 ("root2", [], ["r4", "r5", "r6"]),
792             )
793         ),
794     )
795     @patch("salt.utils.thin.tarfile", _tarfile(None))
796     @patch("salt.utils.thin.zipfile", MagicMock())
797     @patch(
798         "salt.utils.thin.os.getcwd",
799         MagicMock(return_value=os.path.join(RUNTIME_VARS.TMP, "fake-cwd")),
800     )
801     @patch("salt.utils.thin.os.chdir", MagicMock())
802     @patch("salt.utils.thin.os.close", MagicMock())
803     @patch("salt.utils.thin.tempfile.mkdtemp", MagicMock(return_value=""))
804     @patch(
805         "salt.utils.thin.tempfile.mkstemp", MagicMock(return_value=(3, ".temporary"))
806     )
807     @patch("salt.utils.thin.shutil", MagicMock())
808     @patch("salt.utils.thin.sys.version_info", _version_info(None, 3, 6))
809     @patch("salt.utils.hashutils.DigestCollector", MagicMock())
810     @patch("salt.utils.path.which", MagicMock(return_value="/usr/bin/python"))
811     def test_gen_thin_main_content_files_written_py3(self):
812         """
813         Test thin.gen_thin function if main content files are written.
814         NOTE: Py2 version of this test is not required, as code shares the same spot across the versions.
815         :return:
816         """
817         thin.gen_thin("")
818         files = []
819         for py in ("py3", "pyall"):
820             for i in range(1, 4):
821                 files.append(os.path.join(py, "root", "r{}".format(i)))
822             for i in range(4, 7):
823                 files.append(os.path.join(py, "root2", "r{}".format(i)))
824         for cl in thin.tarfile.open().method_calls[:-6]:
825             arcname = cl[2].get("arcname")
826             self.assertIn(arcname, files)
827             files.pop(files.index(arcname))
828         self.assertFalse(files)
829     @patch("salt.exceptions.SaltSystemExit", Exception)
830     @patch("salt.utils.thin.log", MagicMock())
831     @patch("salt.utils.thin.os.makedirs", MagicMock())
832     @patch("salt.utils.files.fopen", MagicMock())
833     @patch("salt.utils.thin._get_salt_call", MagicMock())
834     @patch("salt.utils.thin._get_ext_namespaces", MagicMock())
835     @patch("salt.utils.thin.get_tops", MagicMock(return_value=[]))
836     @patch(
837         "salt.utils.thin.get_ext_tops",
838         MagicMock(
839             return_value={
840                 "namespace": {
841                     "py-version": [3, 0],
842                     "path": "/opt/2015.8/salt",
843                     "dependencies": ["/opt/certifi", "/opt/whatever"],
844                 }
845             }
846         ),
847     )
848     @patch("salt.utils.thin.os.path.isfile", MagicMock())
849     @patch("salt.utils.thin.os.path.isdir", MagicMock(return_value=True))
850     @patch("salt.utils.thin.log", MagicMock())
851     @patch("salt.utils.thin.os.remove", MagicMock())
852     @patch("salt.utils.thin.os.path.exists", MagicMock())
853     @patch(
854         "salt.utils.path.os_walk",
855         MagicMock(
856             return_value=(
857                 ("root", [], ["r1", "r2", "r3"]),
858                 ("root2", [], ["r4", "r5", "r6"]),
859             )
860         ),
861     )
862     @patch("salt.utils.thin.tarfile", _tarfile(None))
863     @patch("salt.utils.thin.zipfile", MagicMock())
864     @patch(
865         "salt.utils.thin.os.getcwd",
866         MagicMock(return_value=os.path.join(RUNTIME_VARS.TMP, "fake-cwd")),
867     )
868     @patch("salt.utils.thin.os.chdir", MagicMock())
869     @patch("salt.utils.thin.os.close", MagicMock())
870     @patch("salt.utils.thin.tempfile.mkdtemp", MagicMock(return_value=""))
871     @patch(
872         "salt.utils.thin.tempfile.mkstemp", MagicMock(return_value=(3, ".temporary"))
873     )
874     @patch("salt.utils.thin.shutil", MagicMock())
875     @patch("salt.utils.thin.sys.version_info", _version_info(None, 3, 6))
876     @patch("salt.utils.hashutils.DigestCollector", MagicMock())
877     @patch("salt.utils.path.which", MagicMock(return_value="/usr/bin/python"))
878     def test_gen_thin_ext_alternative_content_files_written_py3(self):
879         """
880         Test thin.gen_thin function if external alternative content files are written.
881         :return:
882         """
883         ext_conf = {
884             "namespace": {
885                 "py-version": [3, 0],
886                 "path": "/opt/2015.8/salt",
887                 "dependencies": {
888                     "certifi": "/opt/certifi",
889                     "whatever": "/opt/whatever",
890                 },
891             }
892         }
893         thin.gen_thin("", extended_cfg=ext_conf)
894         files = []
895         for py in ("pyall", "pyall", "py3"):
896             for i in range(1, 4):
897                 files.append(os.path.join("namespace", py, "root", "r{}".format(i)))
898             for i in range(4, 7):
899                 files.append(os.path.join("namespace", py, "root2", "r{}".format(i)))
900         for idx, cl in enumerate(thin.tarfile.open().method_calls[:-6]):
901             arcname = cl[2].get("arcname")
902             self.assertIn(arcname, files)
903             files.pop(files.index(arcname))
904         self.assertFalse(files)
905     def test_get_supported_py_config_typecheck(self):
906         """
907         Test collecting proper py-versions. Should return bytes type.
908         :return:
909         """
910         tops = {}
911         ext_cfg = {}
912         out = thin._get_supported_py_config(tops=tops, extended_cfg=ext_cfg)
913         assert type(salt.utils.stringutils.to_bytes("")) == type(out)
914     def test_get_supported_py_config_base_tops(self):
915         """
916         Test collecting proper py-versions. Should return proper base tops.
917         :return:
918         """
919         tops = {"3": ["/groundkeepers", "/stole"], "2": ["/the-root", "/password"]}
920         ext_cfg = {}
921         out = (
922             salt.utils.stringutils.to_str(
923                 thin._get_supported_py_config(tops=tops, extended_cfg=ext_cfg)
924             )
925             .strip()
926             .split(os.linesep)
927         )
928         self.assertEqual(len(out), 2)
929         for t_line in ["py3:3:0", "py2:2:7"]:
930             self.assertIn(t_line, out)
931     def test_get_supported_py_config_ext_tops(self):
932         """
933         Test collecting proper py-versions. Should return proper ext conf tops.
934         :return:
935         """
936         tops = {}
937         ext_cfg = {
938             "solar-interference": {"py-version": [2, 6]},
939             "second-system-effect": {"py-version": [2, 7]},
940         }
941         out = (
942             salt.utils.stringutils.to_str(
943                 thin._get_supported_py_config(tops=tops, extended_cfg=ext_cfg)
944             )
945             .strip()
946             .split(os.linesep)
947         )
948         for t_line in ["second-system-effect:2:7", "solar-interference:2:6"]:
949             self.assertIn(t_line, out)
950     @patch("salt.exceptions.SaltSystemExit", Exception)
951     @patch("salt.utils.thin.log", MagicMock())
952     @patch("salt.utils.thin.os.makedirs", MagicMock())
953     @patch("salt.utils.files.fopen", MagicMock())
954     @patch("salt.utils.thin._get_salt_call", MagicMock())
955     @patch("salt.utils.thin._get_ext_namespaces", MagicMock())
956     @patch("salt.utils.thin.get_tops", MagicMock(return_value=["/foo3", "/bar3"]))
957     @patch("salt.utils.thin.get_ext_tops", MagicMock(return_value={}))
958     @patch("salt.utils.thin.os.path.isfile", MagicMock())
959     @patch("salt.utils.thin.os.path.isdir", MagicMock(return_value=False))
960     @patch("salt.utils.thin.log", MagicMock())
961     @patch("salt.utils.thin.os.remove", MagicMock())
962     @patch("salt.utils.thin.os.path.exists", MagicMock())
963     @patch("salt.utils.path.os_walk", MagicMock(return_value=[]))
964     @patch(
965         "salt.utils.thin.subprocess.Popen",
966         _popen(
967             None,
968             side_effect=[(bts("2.7"), bts("")), (bts('["/foo27", "/bar27"]'), bts(""))],
969         ),
970     )
971     @patch("salt.utils.thin.tarfile", MagicMock())
972     @patch("salt.utils.thin.zipfile", MagicMock())
973     @patch("salt.utils.thin.os.getcwd", MagicMock())
974     @patch("salt.utils.thin.os.access", MagicMock(return_value=False))
975     @patch("salt.utils.thin.os.chdir", MagicMock())
976     @patch("salt.utils.thin.os.close", MagicMock())
977     @patch("salt.utils.thin.tempfile.mkdtemp", MagicMock(return_value=""))
978     @patch(
979         "salt.utils.thin.tempfile.mkstemp", MagicMock(return_value=(3, ".temporary"))
980     )
981     @patch("salt.utils.thin.shutil", MagicMock())
982     @patch("salt.utils.thin.sys.version_info", _version_info(None, 3, 6))
983     def test_gen_thin_control_files_written_access_denied_cwd(self):
984         """
985         Test thin.gen_thin function if control files are written (version, salt-call etc)
986         when the current working directory is inaccessible, eg. Salt is configured to run as
987         a non-root user but the command is executed in a directory that the user does not
988         have permissions to.  Issue #54317.
989         NOTE: Py2 version of this test is not required, as code shares the same spot across the versions.
990         :return:
991         """
992         thin.gen_thin("")
993         arc_name, arc_mode = thin.tarfile.method_calls[0][1]
994         self.assertEqual(arc_name, ".temporary")
995         self.assertEqual(arc_mode, "w:gz")
996         for idx, fname in enumerate(
997             ["version", ".thin-gen-py-version", "salt-call", "supported-versions"]
998         ):
999             name = thin.tarfile.open().method_calls[idx + 2][1][0]
1000             self.assertEqual(name, fname)
1001         thin.tarfile.open().close.assert_called()
1002     def test_get_tops_python(self):
1003         """
1004         test get_tops_python
1005         """
1006         patch_proc = patch(
1007             "salt.utils.thin.subprocess.Popen",
1008             self._popen(
1009                 None,
1010                 side_effect=[
1011                     (bts("jinja2/__init__.py"), bts("")),
1012                     (bts("yaml/__init__.py"), bts("")),
1013                     (bts("tornado/__init__.py"), bts("")),
1014                     (bts("msgpack/__init__.py"), bts("")),
1015                     (bts("certifi/__init__.py"), bts("")),
1016                     (bts("singledispatch.py"), bts("")),
1017                     (bts(""), bts("")),
1018                     (bts(""), bts("")),
1019                     (bts(""), bts("")),
1020                     (bts(""), bts("")),
1021                     (bts(""), bts("")),
1022                     (bts("distro.py"), bts("")),
1023                 ],
1024             ),
1025         )
1026         patch_os = patch("os.path.exists", return_value=True)
1027         patch_which = patch("salt.utils.path.which", return_value=True)
1028         with patch_proc, patch_os, patch_which:
1029             with TstSuiteLoggingHandler() as log_handler:
1030                 exp_ret = copy.deepcopy(self.exp_ret)
1031                 ret = thin.get_tops_python("python3.7", ext_py_ver=[3, 7])
1032                 if salt.utils.platform.is_windows():
1033                     for key, value in ret.items():
1034                         ret[key] = str(pathlib.Path(value).resolve(strict=False))
1035                     for key, value in exp_ret.items():
1036                         exp_ret[key] = str(pathlib.Path(value).resolve(strict=False))
1037                 assert ret == exp_ret
1038                 assert (
1039                     "ERROR:Could not auto detect file location for module concurrent"
1040                     " for python version python3.7" in log_handler.messages
1041                 )
1042     def test_get_tops_python_exclude(self):
1043         """
1044         test get_tops_python when excluding modules
1045         """
1046         patch_proc = patch(
1047             "salt.utils.thin.subprocess.Popen",
1048             self._popen(
1049                 None,
1050                 side_effect=[
1051                     (bts("tornado/__init__.py"), bts("")),
1052                     (bts("msgpack/__init__.py"), bts("")),
1053                     (bts("certifi/__init__.py"), bts("")),
1054                     (bts("singledispatch.py"), bts("")),
1055                     (bts(""), bts("")),
1056                     (bts(""), bts("")),
1057                     (bts(""), bts("")),
1058                     (bts(""), bts("")),
1059                     (bts(""), bts("")),
1060                     (bts("distro.py"), bts("")),
1061                 ],
1062             ),
1063         )
1064         exp_ret = copy.deepcopy(self.exp_ret)
1065         for lib in self.exc_libs:
1066             exp_ret.pop(lib)
1067         patch_os = patch("os.path.exists", return_value=True)
1068         patch_which = patch("salt.utils.path.which", return_value=True)
1069         with patch_proc, patch_os, patch_which:
1070             ret = thin.get_tops_python(
1071                 "python3.7", exclude=self.exc_libs, ext_py_ver=[3, 7]
1072             )
1073             if salt.utils.platform.is_windows():
1074                 for key, value in ret.items():
1075                     ret[key] = str(pathlib.Path(value).resolve(strict=False))
1076                 for key, value in exp_ret.items():
1077                     exp_ret[key] = str(pathlib.Path(value).resolve(strict=False))
1078             assert ret == exp_ret
1079     def test_pack_alternatives_exclude(self):
1080         """
1081         test pack_alternatives when mixing
1082         manually set dependencies and auto
1083         detecting other modules.
1084         """
1085         patch_proc = patch(
1086             "salt.utils.thin.subprocess.Popen",
1087             self._popen(
1088                 None,
1089                 side_effect=[
1090                     (bts(self.fake_libs["distro"]), bts("")),
1091                     (bts(self.fake_libs["yaml"]), bts("")),
1092                     (bts(self.fake_libs["tornado"]), bts("")),
1093                     (bts(self.fake_libs["msgpack"]), bts("")),
1094                     (bts(""), bts("")),
1095                     (bts(""), bts("")),
1096                     (bts(""), bts("")),
1097                     (bts(""), bts("")),
1098                     (bts(""), bts("")),
1099                     (bts(""), bts("")),
1100                     (bts(""), bts("")),
1101                 ],
1102             ),
1103         )
1104         patch_os = patch("os.path.exists", return_value=True)
1105         ext_conf = copy.deepcopy(self.ext_conf)
1106         ext_conf["test"]["auto_detect"] = True
1107         for lib in self.fake_libs.values():
1108             os.makedirs(lib)
1109                 fp_.write("test")
1110         exp_files <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= self.exp_files.copy()
1111         exp_files.extend(
1112             [
1113                 os.path.join("yaml", "__init__.py"),
1114                 os.path.</b></font>join("tornado", "__init__.py"),
1115                 os.path.join("msgpack", "__init__.py"),
1116             ]
1117         )
1118         patch_which = patch("salt.utils.path.which", return_value=True)
1119         with patch_os, patch_proc, patch_which:
1120             thin._pack_alternative(ext_conf, self.digest, self.tar)
1121             calls = self.tar.mock_calls
1122             for _file in exp_files:
1123                 assert [x for x in calls if "{}".format(_file) in x[-2]]
1124     def test_pack_alternatives(self):
1125         """
1126         test thin._pack_alternatives
1127         """
1128         with patch("salt.utils.thin.get_ext_tops", MagicMock(return_value=self.tops)):
1129             thin._pack_alternative(self.ext_conf, self.digest, self.tar)
1130             calls = self.tar.mock_calls
1131             for _file in self.exp_files:
1132                 assert [x for x in calls if "{}".format(_file) in x[-2]]
1133                 assert [
1134                     x
1135                     for x in calls
1136                     if os.path.join("test", "pyall", _file) in x[-1]["arcname"]
1137                 ]
1138     def test_pack_alternatives_not_normalized(self):
1139         """
1140         test thin._pack_alternatives when the path
1141         is not normalized
1142         """
1143         tops = copy.deepcopy(self.tops)
1144         tops["test"]["dependencies"] = [self.jinja_fp + "/"]
1145         with patch("salt.utils.thin.get_ext_tops", MagicMock(return_value=tops)):
1146             thin._pack_alternative(self.ext_conf, self.digest, self.tar)
1147             calls = self.tar.mock_calls
1148             for _file in self.exp_files:
1149                 assert [x for x in calls if "{}".format(_file) in x[-2]]
1150                 assert [
1151                     x
1152                     for x in calls
1153                     if os.path.join("test", "pyall", _file) in x[-1]["arcname"]
1154                 ]
1155     def test_pack_alternatives_path_doesnot_exist(self):
1156         """
1157         test thin._pack_alternatives when the path
1158         doesnt exist. Check error log message
1159         and expect that because the directory
1160         does not exist jinja2 does not get
1161         added to the tar
1162         """
1163         bad_path = os.path.join(tempfile.gettempdir(), "doesnotexisthere")
1164         tops = copy.deepcopy(self.tops)
1165         tops["test"]["dependencies"] = [bad_path]
1166         with patch("salt.utils.thin.get_ext_tops", MagicMock(return_value=tops)):
1167             with TstSuiteLoggingHandler() as log_handler:
1168                 thin._pack_alternative(self.ext_conf, self.digest, self.tar)
1169                 msg = "ERROR:File path {} does not exist. Unable to add to salt-ssh thin".format(
1170                     bad_path
1171                 )
1172                 assert msg in log_handler.messages
1173         calls = self.tar.mock_calls
1174         for _file in self.exp_files:
1175             arg = [x for x in calls if "{}".format(_file) in x[-2]]
1176             kwargs = [
1177                 x
1178                 for x in calls
1179                 if os.path.join("test", "pyall", _file) in x[-1]["arcname"]
1180             ]
1181             if "jinja2" in _file:
1182                 assert not arg
1183                 assert not kwargs
1184             else:
1185                 assert arg
1186                 assert kwargs
1187     def test_pack_alternatives_auto_detect(self):
1188         """
1189         test thin._pack_alternatives when auto_detect
1190         is enabled
1191         """
1192         ext_conf = copy.deepcopy(self.ext_conf)
1193         ext_conf["test"]["auto_detect"] = True
1194         for lib in self.fake_libs.values():
1195             os.makedirs(lib)
1196             with salt.utils.files.fopen(os.path.join(lib, "__init__.py"), "w+") as fp_:
1197                 fp_.write("test")
1198         patch_tops_py = patch(
1199             "salt.utils.thin.get_tops_python", return_value=self.fake_libs
1200         )
1201         exp_files = self.exp_files.copy()
1202         exp_files.extend(
1203             [
1204                 os.path.join("yaml", "__init__.py"),
1205                 os.path.join("tornado", "__init__.py"),
1206                 os.path.join("msgpack", "__init__.py"),
1207             ]
1208         )
1209         with patch_tops_py:
1210             thin._pack_alternative(ext_conf, self.digest, self.tar)
1211             calls = self.tar.mock_calls
1212             for _file in exp_files:
1213                 assert [x for x in calls if "{}".format(_file) in x[-2]]
1214     def test_pack_alternatives_empty_dependencies(self):
1215         """
1216         test _pack_alternatives when dependencies is not
1217         set in the config.
1218         """
1219         ext_conf = copy.deepcopy(self.ext_conf)
1220         ext_conf["test"]["auto_detect"] = True
1221         ext_conf["test"].pop("dependencies")
1222         for lib in self.fake_libs.values():
1223             os.makedirs(lib)
1224             with salt.utils.files.fopen(os.path.join(lib, "__init__.py"), "w+") as fp_:
1225                 fp_.write("test")
1226         patch_tops_py = patch(
1227             "salt.utils.thin.get_tops_python", return_value=self.fake_libs
1228         )
1229         exp_files = self.exp_files.copy()
1230         exp_files.extend(
1231             [
1232                 os.path.join("yaml", "__init__.py"),
1233                 os.path.join("tornado", "__init__.py"),
1234                 os.path.join("msgpack", "__init__.py"),
1235             ]
1236         )
1237         with patch_tops_py:
1238             thin._pack_alternative(ext_conf, self.digest, self.tar)
1239             calls = self.tar.mock_calls
1240             for _file in exp_files:
1241                 assert [x for x in calls if "{}".format(_file) in x[-2]]
1242     @pytest.mark.slow_test
1243     @skipIf(
1244         salt.utils.platform.is_windows(), "salt-ssh does not deploy to/from windows"
1245     )
1246     def test_thin_dir(self):
1247         """
1248         Test the thin dir to make sure salt-call can run
1249         Run salt call via a python in a new virtual environment to ensure
1250         salt-call has all dependencies needed.
1251         """
1252         with VirtualEnv() as venv:
1253             salt.utils.thin.gen_thin(str(venv.venv_dir))
1254             thin_dir = venv.venv_dir / "thin"
1255             thin_archive = thin_dir / "thin.tgz"
1256             tar = tarfile.open(str(thin_archive))
1257             tar.extractall(str(thin_dir))
1258             tar.close()
1259             ret = venv.run(
1260                 venv.venv_python,
1261                 str(thin_dir / "salt-call"),
1262                 "--version",
1263                 check=False,
1264             )
1265             assert ret.exitcode == 0, ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
