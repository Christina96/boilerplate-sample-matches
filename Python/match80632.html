<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_aptpkg_1.py &amp; test_thin_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_aptpkg_1.py &amp; test_thin_1.py
      </h3>
<h1 align="center">
        4.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_aptpkg_1.py (5.063291%)<th>test_thin_1.py (3.4102306%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(196-206)<td><a href="#" name="0">(95-105)</a><td align="center"><font color="#ff0000">20</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(984-987)<td><a href="#" name="1">(1202-1206)</a><td align="center"><font color="#990000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(933-936)<td><a href="#" name="2">(67-70)</a><td align="center"><font color="#990000">12</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(751-772)<td><a href="#" name="3">(153-162)</a><td align="center"><font color="#990000">12</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(9-26)<td><a href="#" name="4">(16-28)</a><td align="center"><font color="#990000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_aptpkg_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
    :synopsis: Unit Tests for Advanced Packaging Tool module 'module.aptpkg'
    :platform: Linux
    :maturity: develop
    versionadded:: 2017.7.0
<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import copy
import logging
import os
import pathlib
import textwrap
import pytest
import salt.modules.aptpkg as aptpkg
import salt.modules.pkg_resource as pkg_resource
from salt.exceptions import (
    CommandExecutionError,
    CommandNotFoundError,
    SaltInvocationError,
)
from tests.support.mock import MagicMock, Mock, call, mock_open, patch
try:
    from</b></font> aptsources import sourceslist  # pylint: disable=unused-import
    HAS_APTSOURCES = True
except ImportError:
    HAS_APTSOURCES = False
log = logging.getLogger(__name__)
@pytest.fixture(scope="module")
def repo_keys_var():
    return {
        "46181433FBB75451": {
            "algorithm": 17,
            "bits": 1024,
            "capability": "scSC",
            "date_creation": 1104433784,
            "date_expiration": None,
            "fingerprint": "C5986B4F1257FFA86632CBA746181433FBB75451",
            "keyid": "46181433FBB75451",
            "uid": "Ubuntu CD Image Automatic Signing Key &lt;cdimage@ubuntu.com&gt;",
            "uid_hash": "B4D41942D4B35FF44182C7F9D00C99AF27B93AD0",
            "validity": "-",
        }
    }
@pytest.fixture(scope="module")
def packages_var():
    return {"wget": "1.15-1ubuntu1.14.04.2"}
@pytest.fixture(scope="module")
def lowpkg_files_var():
    return {
        "errors": {},
        "packages": {
            "wget": [
                "/.",
                "/etc",
                "/etc/wgetrc",
                "/usr",
                "/usr/bin",
                "/usr/bin/wget",
                "/usr/share",
                "/usr/share/info",
                "/usr/share/info/wget.info.gz",
                "/usr/share/doc",
                "/usr/share/doc/wget",
                "/usr/share/doc/wget/MAILING-LIST",
                "/usr/share/doc/wget/NEWS.gz",
                "/usr/share/doc/wget/AUTHORS",
                "/usr/share/doc/wget/copyright",
                "/usr/share/doc/wget/changelog.Debian.gz",
                "/usr/share/doc/wget/README",
                "/usr/share/man",
                "/usr/share/man/man1",
                "/usr/share/man/man1/wget.1.gz",
            ]
        },
    }
@pytest.fixture(scope="module")
def lowpkg_info_var():
    return {
        "wget": {
            "architecture": "amd64",
            "description": "retrieves files from the web",
            "homepage": "http://www.gnu.org/software/wget/",
            "install_date": "2016-08-30T22:20:15Z",
            "maintainer": "Ubuntu Developers &lt;ubuntu-devel-discuss@lists.ubuntu.com&gt;",
            "name": "wget",
            "section": "web",
            "source": "wget",
            "version": "1.15-1ubuntu1.14.04.2",
            "status": "ii",
        },
        "apache2": {
            "architecture": "amd64",
            "description": """Apache HTTP Server
     The Apache HTTP Server Project's goal is to build a secure, efficient and
     extensible HTTP server as standards-compliant open source software. The
     result has long been the number one web server on the Internet.
     .
     Installing this package results in a full installation, including the
     configuration files, init scripts and support scripts.""",
            "homepage": "http://httpd.apache.org/",
            "install_date": "2016-08-30T22:20:15Z",
            "maintainer": "Ubuntu Developers &lt;ubuntu-devel-discuss@lists.ubuntu.com&gt;",
            "name": "apache2",
            "section": "httpd",
            "source": "apache2",
            "version": "2.4.18-2ubuntu3.9",
            "status": "rc",
        },
    }
@pytest.fixture(scope="module")
def apt_q_update_var():
    return """
    Get:1 http://security.ubuntu.com trusty-security InRelease [65 kB]
    Get:2 http://security.ubuntu.com trusty-security/main Sources [120 kB]
    Get:3 http://security.ubuntu.com trusty-security/main amd64 Packages [548 kB]
    Get:4 http://security.ubuntu.com trusty-security/main i386 Packages [507 kB]
    Hit http://security.ubuntu.com trusty-security/main Translation-en
    Fetched 1240 kB in 10s (124 kB/s)
    Reading package lists...
    """
@pytest.fixture(scope="module")
def apt_q_update_error_var():
    return """
    Err http://security.ubuntu.com trusty InRelease
    Err http://security.ubuntu.com trusty Release.gpg
    Unable to connect to security.ubuntu.com:http:
    Reading package lists...
    W: Failed to fetch http://security.ubuntu.com/ubuntu/dists/trusty/InRelease
    W: Failed to fetch http://security.ubuntu.com/ubuntu/dists/trusty/Release.gpg  Unable to connect to security.ubuntu.com:http:
    W: Some index files failed to download. They have been ignored, or old ones used instead.
    """
@pytest.fixture(scope="module")
def autoremove_var():
    return """
    Reading package lists... Done
    Building dependency tree
    Reading state information... Done
    0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
    """
@pytest.fixture(scope="module")
def upgrade_var():
    return """
    Reading package lists...
    Building dependency tree...
    Reading state information...
    0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
    """
@pytest.fixture(scope="module")
def uninstall_var():
    return {"tmux": {"new": "", "old": "1.8-5"}}
@pytest.fixture(scope="module")
def install_var():
    return {"tmux": {"new": "1.8-5", "old": ""}}
def _get_uri(repo):
    """
    Get the URI portion of the a string
    """
    splits = repo.split()
    for val in splits:
        if any(val.startswith(x) for x in ("http://", "https://", "ftp://")):
            return val
class MockSourceEntry:
    def __init__(self, uri, source_type, line, invalid, dist="", file=None):
        self<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.uri = uri
        self.type = source_type
        self.line = line
        self.invalid = invalid
        self.file = file
        self.disabled = False
        self.dist = dist
        self.comps = []
        self.architectures = []
    def</b></font> mysplit(self, line):
        return line.split()
class MockSourceList:
    def __init__(self):
        self.list = []
    def __iter__(self):
        yield from self.list
    def save(self):
        pass
@pytest.fixture
def configure_loader_modules():
    return {aptpkg: {"__grains__": {}}}
def test_version(lowpkg_info_var):
    """
    Test - Returns a string representing the package version or an empty string if
    not installed.
    """
    version = lowpkg_info_var["wget"]["version"]
    mock = MagicMock(return_value=version)
    with patch.dict(aptpkg.__salt__, {"pkg_resource.version": mock}):
        assert aptpkg.version(*["wget"]) == version
def test_upgrade_available():
    """
    Test - Check whether or not an upgrade is available for a given package.
    """
    with patch("salt.modules.aptpkg.latest_version", MagicMock(return_value="")):
        assert aptpkg.upgrade_available("wget") is False
def test_add_repo_key(repo_keys_var):
    """
    Test - Add a repo key.
    """
    with patch(
        "salt.modules.aptpkg.get_repo_keys", MagicMock(return_value=repo_keys_var)
    ):
        mock = MagicMock(return_value={"retcode": 0, "stdout": "OK"})
        with patch.dict(aptpkg.__salt__, {"cmd.run_all": mock}):
            assert (
                aptpkg.add_repo_key(keyserver="keyserver.ubuntu.com", keyid="FBB75451")
                is True
            )
def test_add_repo_key_failed(repo_keys_var):
    """
    Test - Add a repo key using incomplete input data.
    """
    with patch(
        "salt.modules.aptpkg.get_repo_keys", MagicMock(return_value=repo_keys_var)
    ):
        kwargs = {"keyserver": "keyserver.ubuntu.com"}
        mock = MagicMock(return_value={"retcode": 0, "stdout": "OK"})
        with patch.dict(aptpkg.__salt__, {"cmd.run_all": mock}):
            with pytest.raises(SaltInvocationError):
                aptpkg.add_repo_key(**kwargs)
def test_get_repo_keys(repo_keys_var):
    """
    Test - List known repo key details.
    """
    APT_KEY_LIST = r"""
    pub:-:1024:17:46181433FBB75451:1104433784:::-:::scSC:
    fpr:::::::::C5986B4F1257FFA86632CBA746181433FBB75451:
    uid:-::::1104433784::B4D41942D4B35FF44182C7F9D00C99AF27B93AD0::Ubuntu CD Image Automatic Signing Key &lt;cdimage@ubuntu.com&gt;:
    """
    mock = MagicMock(return_value={"retcode": 0, "stdout": APT_KEY_LIST})
    with patch.dict(aptpkg.__salt__, {"cmd.run_all": mock}):
        assert aptpkg.get_repo_keys() == repo_keys_var
def test_file_dict(lowpkg_files_var):
    """
    Test - List the files that belong to a package, grouped by package.
    """
    mock = MagicMock(return_value=lowpkg_files_var)
    with patch.dict(aptpkg.__salt__, {"lowpkg.file_dict": mock}):
        assert aptpkg.file_dict("wget") == lowpkg_files_var
def test_file_list(lowpkg_files_var):
    """
    Test - List the files that belong to a package.
    """
    files = {
        "errors": lowpkg_files_var["errors"],
        "files": lowpkg_files_var["packages"]["wget"],
    }
    mock = MagicMock(return_value=files)
    with patch.dict(aptpkg.__salt__, {"lowpkg.file_list": mock}):
        assert aptpkg.file_list("wget") == files
def test_get_selections():
    """
    Test - View package state from the dpkg database.
    """
    selections = {"install": ["wget"]}
    mock = MagicMock(return_value="wget\t\t\t\t\t\tinstall")
    with patch.dict(aptpkg.__salt__, {"cmd.run_stdout": mock}):
        assert aptpkg.get_selections("wget") == selections
def test_info_installed(lowpkg_info_var):
    """
    Test - Return the information of the named package(s) installed on the system.
    """
    names = {"group": "section", "packager": "maintainer", "url": "homepage"}
    installed = copy.deepcopy({"wget": lowpkg_info_var["wget"]})
    for name in names:
        if installed["wget"].get(names[name], False):
            installed["wget"][name] = installed["wget"].pop(names[name])
    mock = MagicMock(return_value=lowpkg_info_var)
    with patch.dict(aptpkg.__salt__, {"lowpkg.info": mock}):
        del installed["wget"]["status"]
        assert aptpkg.info_installed("wget") == installed
        assert len(aptpkg.info_installed()) == 1
def test_owner():
    """
    Test - Return the name of the package that owns the file.
    """
    paths = ["/usr/bin/wget"]
    mock = MagicMock(return_value="wget: /usr/bin/wget")
    with patch.dict(aptpkg.__salt__, {"cmd.run_stdout": mock}):
        assert aptpkg.owner(*paths) == "wget"
def test_refresh_db(apt_q_update_var):
    """
    Test - Updates the APT database to latest packages based upon repositories.
    """
    refresh_db = {
        "http://security.ubuntu.com trusty-security InRelease": True,
        "http://security.ubuntu.com trusty-security/main Sources": True,
        "http://security.ubuntu.com trusty-security/main Translation-en": None,
        "http://security.ubuntu.com trusty-security/main amd64 Packages": True,
        "http://security.ubuntu.com trusty-security/main i386 Packages": True,
    }
    mock = MagicMock(return_value={"retcode": 0, "stdout": apt_q_update_var})
    with patch("salt.utils.pkg.clear_rtag", MagicMock()):
        with patch.dict(
            aptpkg.__salt__,
            {"cmd.run_all": mock, "config.get": MagicMock(return_value=False)},
        ):
            assert aptpkg.refresh_db() == refresh_db
def test_refresh_db_failed(apt_q_update_error_var):
    """
    Test - Update the APT database using unreachable repositories.
    """
    kwargs = {"failhard": True}
    mock = MagicMock(return_value={"retcode": 0, "stdout": apt_q_update_error_var})
    with patch("salt.utils.pkg.clear_rtag", MagicMock()):
        with patch.dict(
            aptpkg.__salt__,
            {"cmd.run_all": mock, "config.get": MagicMock(return_value=False)},
        ):
            with pytest.raises(CommandExecutionError):
                aptpkg.refresh_db(**kwargs)
def test_autoremove(packages_var, autoremove_var):
    """
    Test - Remove packages not required by another package.
    """
    with patch("salt.modules.aptpkg.list_pkgs", MagicMock(return_value=packages_var)):
        patch_kwargs = {
            "__salt__": {
                "config.get": MagicMock(return_value=True),
                "cmd.run_all": MagicMock(
                    return_value=MagicMock(return_value=autoremove_var)
                ),
            }
        }
        with patch.multiple(aptpkg, **patch_kwargs):
            assert aptpkg.autoremove() == {}
            assert aptpkg.autoremove(purge=True) == {}
            assert aptpkg.autoremove(list_only=True) == []
            assert aptpkg.autoremove(list_only=True, purge=True) == []
def test_install(install_var):
    """
    Test - Install packages.
    """
    with patch("salt.modules.aptpkg.install", MagicMock(return_value=install_var)):
        assert aptpkg.install(name="tmux") == install_var
        kwargs = {"force_conf_new": True}
        assert aptpkg.install(name="tmux", **kwargs) == install_var
def test_remove(uninstall_var):
    """
    Test - Remove packages.
    """
    with patch("salt.modules.aptpkg._uninstall", MagicMock(return_value=uninstall_var)):
        assert aptpkg.remove(name="tmux") == uninstall_var
def test_purge(uninstall_var):
    """
    Test - Remove packages along with all configuration files.
    """
    with patch("salt.modules.aptpkg._uninstall", MagicMock(return_value=uninstall_var)):
        assert aptpkg.purge(name="tmux") == uninstall_var
def test_upgrade(uninstall_var, upgrade_var):
    """
    Test - Upgrades all packages.
    """
    with patch("salt.utils.pkg.clear_rtag", MagicMock()):
        with patch(
            "salt.modules.aptpkg.list_pkgs", MagicMock(return_value=uninstall_var)
        ):
            mock_cmd = MagicMock(return_value={"retcode": 0, "stdout": upgrade_var})
            patch_kwargs = {
                "__salt__": {
                    "config.get": MagicMock(return_value=True),
                    "cmd.run_all": mock_cmd,
                }
            }
            with patch.multiple(aptpkg, **patch_kwargs):
                assert aptpkg.upgrade() == dict()
                kwargs = {"force_conf_new": True}
                assert aptpkg.upgrade(**kwargs) == dict()
def test_upgrade_downloadonly(uninstall_var, upgrade_var):
    """
    Tests the download-only options for upgrade.
    """
    with patch("salt.utils.pkg.clear_rtag", MagicMock()):
        with patch(
            "salt.modules.aptpkg.list_pkgs", MagicMock(return_value=uninstall_var)
        ):
            mock_cmd = MagicMock(return_value={"retcode": 0, "stdout": upgrade_var})
            patch_kwargs = {
                "__salt__": {
                    "config.get": MagicMock(return_value=True),
                    "cmd.run_all": mock_cmd,
                },
            }
            with patch.multiple(aptpkg, **patch_kwargs):
                aptpkg.upgrade()
                args_matching = [
                    True
                    for args in patch_kwargs["__salt__"]["cmd.run_all"].call_args[0]
                    if "--download-only" in args
                ]
                assert any(args_matching) is False
                aptpkg.upgrade(downloadonly=True)
                args_matching = [
                    True
                    for args in patch_kwargs["__salt__"]["cmd.run_all"].call_args[0]
                    if "--download-only" in args
                ]
                assert any(args_matching) is True
                aptpkg.upgrade(download_only=True)
                args_matching = [
                    True
                    for args in patch_kwargs["__salt__"]["cmd.run_all"].call_args[0]
                    if "--download-only" in args
                ]
                assert any(args_matching) is True
def test_upgrade_allow_downgrades(uninstall_var, upgrade_var):
    """
    Tests the allow_downgrades option for upgrade.
    """
    with patch("salt.utils.pkg.clear_rtag", MagicMock()):
        with patch(
            "salt.modules.aptpkg.list_pkgs", MagicMock(return_value=uninstall_var)
        ):
            mock_cmd = MagicMock(return_value={"retcode": 0, "stdout": upgrade_var})
            patch_kwargs = {
                "__salt__": {
                    "config.get": MagicMock(return_value=True),
                    "cmd.run_all": mock_cmd,
                },
            }
            with patch.multiple(aptpkg, **patch_kwargs):
                aptpkg.upgrade()
                args_matching = [
                    True
                    for args in patch_kwargs["__salt__"]["cmd.run_all"].call_args[0]
                    if "--allow-downgrades" in args
                ]
                assert any(args_matching) is False
                aptpkg.upgrade(allow_downgrades=True)
                args_matching = [
                    True
                    for args in patch_kwargs["__salt__"]["cmd.run_all"].call_args[0]
                    if "--allow-downgrades" in args
                ]
                assert any(args_matching) is True
def test_show():
    """
    Test that the pkg.show function properly parses apt-cache show output.
    This test uses an abridged output per package, for simplicity.
    """
    show_mock_success = MagicMock(
        return_value={
            "retcode": 0,
            "pid": 12345,
            "stderr": "",
            "stdout": textwrap.dedent(
                """\
            Package: foo1.0
            Architecture: amd64
            Version: 1.0.5-3ubuntu4
            Description: A silly package (1.0 release cycle)
            Provides: foo
            Suggests: foo-doc
            Package: foo1.0
            Architecture: amd64
            Version: 1.0.4-2ubuntu1
            Description: A silly package (1.0 release cycle)
            Provides: foo
            Suggests: foo-doc
            Package: foo-doc
            Architecture: all
            Version: 1.0.5-3ubuntu4
            Description: Silly documentation for a silly package (1.0 release cycle)
            Package: foo-doc
            Architecture: all
            Version: 1.0.4-2ubuntu1
            Description: Silly documentation for a silly package (1.0 release cycle)
            """
            ),
        }
    )
    show_mock_failure = MagicMock(
        return_value={
            "retcode": 1,
            "pid": 12345,
            "stderr": textwrap.dedent(
                """\
            N: Unable to locate package foo*
            N: Couldn't find any package by glob 'foo*'
            N: Couldn't find any package by regex 'foo*'
            E: No packages found
            """
            ),
            "stdout": "",
        }
    )
    refresh_mock = Mock()
    expected = {
        "foo1.0": {
            "1.0.5-3ubuntu4": {
                "Architecture": "amd64",
                "Description": "A silly package (1.0 release cycle)",
                "Provides": "foo",
                "Suggests": "foo-doc",
            },
            "1.0.4-2ubuntu1": {
                "Architecture": "amd64",
                "Description": "A silly package (1.0 release cycle)",
                "Provides": "foo",
                "Suggests": "foo-doc",
            },
        },
        "foo-doc": {
            "1.0.5-3ubuntu4": {
                "Architecture": "all",
                "Description": (
                    "Silly documentation for a silly package (1.0 release cycle)"
                ),
            },
            "1.0.4-2ubuntu1": {
                "Architecture": "all",
                "Description": (
                    "Silly documentation for a silly package (1.0 release cycle)"
                ),
            },
        },
    }
    filtered = copy.deepcopy(expected)
    for k1 in filtered:
        for k2 in filtered[k1]:
            for k3 in list(filtered[k1][k2]):
                if k3 not in ("Description", "Provides"):
                    filtered[k1][k2].pop(k3)
    with patch.dict(aptpkg.__salt__, {"cmd.run_all": show_mock_success}), patch.object(
        aptpkg, "refresh_db", refresh_mock
    ):
        assert aptpkg.show("foo*") == expected
        refresh_mock.assert_not_called()
        refresh_mock.reset_mock()
        assert aptpkg.show("foo*", refresh=True) == expected
        refresh_mock.assert_called_once()
        refresh_mock.reset_mock()
        assert aptpkg.show("foo*", filter="description,provides") == filtered
        refresh_mock.assert_not_called()
        refresh_mock.reset_mock()
    with patch.dict(aptpkg.__salt__, {"cmd.run_all": show_mock_failure}), patch.object(
        aptpkg, "refresh_db", refresh_mock
    ):
        assert aptpkg.show("foo*") == {}
        refresh_mock.assert_not_called()
        refresh_mock.reset_mock()
        assert aptpkg.show("foo*", refresh=True) == {}
        refresh_mock.assert_called_once()
        refresh_mock.reset_mock()
@pytest.mark.skipif(
    not (pathlib.Path("/etc") / "apt" / "sources.list").is_file(),
    reason="Requires sources.list file",
)
def test_mod_repo_enabled():
    """
    Checks if a repo is enabled or disabled depending on the passed kwargs.
    """
    with patch.dict(
        aptpkg.__salt__,
        {"config.option": MagicMock(), "no_proxy": MagicMock(return_value=False)},
    ):
        with patch("salt.modules.aptpkg.refresh_db", MagicMock(return_value={})):
            with patch(
                "salt.utils.data.is_true", MagicMock(return_value=True)
            ) as data_is_true:
                with patch("salt.modules.aptpkg.SourcesList", MagicMock(), create=True):
                    with patch(
                        "salt.modules.aptpkg.SourceEntry", MagicMock(), create=True
                    ):
                        repo = aptpkg.mod_repo("foo", enabled=False)
                        data_is_true.assert_called_with(False)
                        data_is_true.reset_mock()
                        repo = aptpkg.mod_repo("foo", disabled=True)
                        data_is_true.assert_called_with(True)
                        data_is_true.reset_mock()
                        repo = aptpkg.mod_repo("foo", enabled=True)
                        data_is_true.assert_called_with(True)
                        data_is_true.reset_mock()
                        repo = aptpkg.mod_repo("foo", disabled=False)
                        data_is_true.assert_called_with(False)
def test_mod_repo_match():
    """
    Checks if a repo is matched without taking into account any ending "/" in the uri.
    """
    source_type = "deb"
    source_uri = "http://cdn-aws.deb.debian.org/debian/"
    source_line = "deb http://cdn-aws.deb.debian.org/debian/ stretch main\n"
    mock_source = MockSourceEntry(
        source_uri, source_type, source_line, False, "stretch"
    )
    mock_source_list = MockSourceList()
    mock_source_list.list = [mock_source]
    with patch.dict(
        aptpkg.__salt__,
        {"config.option": MagicMock(), "no_proxy": MagicMock(return_value=False)},
    ):
        with patch("salt.modules.aptpkg.refresh_db", MagicMock(return_value={})):
            with patch("salt.utils.data.is_true", MagicMock(return_value=True)):
                with patch("salt.modules.aptpkg.SourceEntry", MagicMock(), create=True):
                    with patch(
                        "salt.modules.aptpkg.SourcesList",
                        MagicMock(return_value=mock_source_list),
                        create=True,
                    ):
                        with patch(
                            "salt.modules.aptpkg._split_repo_str",
                            MagicMock(
                                return_value=(
                                    "deb",
                                    [],
                                    "http://cdn-aws.deb.debian.org/debian/",
                                    "stretch",
                                    ["main"],
                                )
                            ),
                        ):
                            source_line_no_slash = (
                                "deb http://cdn-aws.deb.debian.org/debian"
                                " stretch main"
                            )
                            repo = aptpkg.mod_repo(source_line_no_slash, enabled=False)
                            assert repo[source_line_no_slash]["uri"] == source_uri
@patch("salt.utils.path.os_walk", MagicMock(return_value=[("test", "test", "test")]))
@patch("os.path.getsize", MagicMock(return_value=123456))
@patch(
    "fnmatch.filter",
    MagicMock<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(return_value=["/var/cache/apt/archive/test_package.rpm"]),
)
def test_list_downloaded():
    """
    Test downloaded packages listing.
    :return:
    """
    DOWNLOADED_RET = {
        "test-package": {
            "1.0": {
                "path": "/var/cache/apt/archive/test_package.rpm",
                "size": 123456,
                "creation_date_time_t": 1234567890,
                "creation_date_time": "2009-02-13T23:31:30",
            }
        }
    }
    with patch.dict(
        aptpkg.__salt__,
        {
            "lowpkg.bin_pkg_info"</b></font>: MagicMock(
                return_value={"name": "test-package", "version": "1.0"}
            )
        },
    ):
        list_downloaded = aptpkg.list_downloaded()
        assert len(list_downloaded) == 1
        assert list_downloaded == DOWNLOADED_RET
def test__skip_source():
    """
    Test __skip_source.
    :return:
    """
    source_type = "deb"
    source_uri = "http://cdn-aws.deb.debian.org/debian"
    source_line = "deb http://cdn-aws.deb.debian.org/debian stretch main\n"
    mock_source = MockSourceEntry(source_uri, source_type, source_line, False)
    ret = aptpkg._skip_source(mock_source)
    assert ret is False
    source_type = "ded"
    source_uri = "http://cdn-aws.deb.debian.org/debian"
    source_line = "deb http://cdn-aws.deb.debian.org/debian stretch main\n"
    mock_source = MockSourceEntry(source_uri, source_type, source_line, True)
    ret = aptpkg._skip_source(mock_source)
    assert ret is True
    source_type = "deb"
    source_uri = "http://cdn-aws.deb.debian.org/debian"
    source_line = "deb [http://cdn-aws.deb.debian.org/debian] stretch main\n"
    mock_source = MockSourceEntry(source_uri, source_type, source_line, True)
    ret = aptpkg._skip_source(mock_source)
    assert ret is False
def test_normalize_name():
    """
    Test that package is normalized only when it should be
    """
    with patch.dict(aptpkg.__grains__, {"osarch": "amd64"}):
        result = aptpkg.normalize_name("foo")
        assert result == "foo", result
        result = aptpkg.normalize_name("foo:amd64")
        assert result == "foo", result
        result = aptpkg.normalize_name("foo:any")
        assert result == "foo", result
        result = aptpkg.normalize_name("foo:all")
        assert result == "foo", result
        result = aptpkg.normalize_name("foo:i386")
        assert result == "foo:i386", result
def test_list_repos():
    """
    Checks results from list_repos
    """
    source_type = "deb"
    source_uri = "http://cdn-aws.deb.debian.org/debian/"
    source_line = "deb http://cdn-aws.deb.debian.org/debian/ stretch main\n"
    mock_source = MockSourceEntry(source_uri, source_type, source_line, False)
    mock_source_list = MockSourceList()
    mock_source_list.list = [mock_source]
    with patch("salt.modules.aptpkg.SourcesList", MagicMock(), create=True):
        with patch("salt.modules.aptpkg.SourceEntry", MagicMock(), create=True):
            with patch(
                "salt.modules.aptpkg.SourcesList",
                MagicMock(return_value=mock_source_list),
                create=True,
            ):
                repos = aptpkg.list_repos()
                assert source_uri in repos
                assert isinstance(repos[source_uri], list)
                assert len(repos[source_uri]) == 1
                assert "line" in repos[source_uri][0]
                _uri = _get_uri(repos[source_uri][0]["line"])
                assert _uri[-1] == "/"
                assert "uri" in repos[source_uri][0]
                assert repos[source_uri][0]["uri"][-1] == "/"
@pytest.mark.skipif(
    HAS_APTSOURCES is False, reason="The 'aptsources' library is missing."
)
def test_expand_repo_def():
    """
    Checks results from expand_repo_def
    """
    source_type = "deb"
    source_uri = "http://cdn-aws.deb.debian.org/debian/"
    source_line = "deb http://cdn-aws.deb.debian.org/debian/ stretch main\n"
    source_file = "/etc/apt/sources.list"
    repo = "deb http://cdn-aws.deb.debian.org/debian/ stretch main\n"
    sanitized = aptpkg.expand_repo_def(repo=repo, file=source_file)
    assert isinstance(sanitized, dict)
    assert "uri" in sanitized
    assert sanitized["uri"][-1] == "/"
    repo = "deb http://cdn-aws.deb.debian.org/debian/ stretch main\n"
    sanitized = aptpkg.expand_repo_def(
        repo=repo, file=source_file, architectures="amd64"
    )
    assert isinstance(sanitized, dict)
    assert "line" in sanitized
    assert (
        sanitized["line"]
        == "deb [arch=amd64] http://cdn-aws.deb.debian.org/debian/ stretch main"
    )
def test_list_pkgs():
    """
    Test packages listing.
    :return:
    """
    def _add_data(data, key, value):
        data.setdefault(key, []).append(value)
    apt_out = [
        "install ok installed accountsservice 0.6.55-0ubuntu12~20.04.1 amd64",
        "install ok installed acpid 1:2.0.32-1ubuntu1 amd64",
        "install ok installed adduser 3.118ubuntu2 all",
        "install ok installed alsa-topology-conf 1.2.2-1 all",
        "install ok installed alsa-ucm-conf 1.2.2-1ubuntu0.4 all",
        "install ok installed apparmor 2.13.3-7ubuntu5.1 amd64",
        "install ok installed apport 2.20.11-0ubuntu27.9 all",
        "install ok installed apport-symptoms 0.23 all",
        "install ok installed apt 2.0.2ubuntu0.1 amd64",
        "install ok installed at 3.1.23-1ubuntu1 amd64",
    ]
    with patch.dict(aptpkg<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.__grains__, {"osarch": "x86_64"}), patch.dict(
        aptpkg.__salt__,
        {"cmd.run_stdout": MagicMock(return_value=os.linesep.join(apt_out))},
    ), patch.</b></font>dict(aptpkg.__salt__, {"pkg_resource.add_pkg": _add_data}), patch.dict(
        aptpkg.__salt__,
        {"pkg_resource.format_pkg_list": pkg_resource.format_pkg_list},
    ), patch.dict(
        aptpkg.__salt__, {"pkg_resource.sort_pkglist": pkg_resource.sort_pkglist}
    ):
        pkgs = aptpkg.list_pkgs(versions_as_list=True)
        for pkg_name, pkg_version in {
            "accountsservice": "0.6.55-0ubuntu12~20.04.1",
            "acpid": "1:2.0.32-1ubuntu1",
            "adduser": "3.118ubuntu2",
            "alsa-topology-conf": "1.2.2-1",
            "alsa-ucm-conf": "1.2.2-1ubuntu0.4",
            "apparmor": "2.13.3-7ubuntu5.1",
            "apport": "2.20.11-0ubuntu27.9",
            "apport-symptoms": "0.23",
            "apt": "2.0.2ubuntu0.1",
            "apt-utils": "2.0.2ubuntu0.1",
            "at": "3.1.23-1ubuntu1",
        }.items():
            assert pkgs[pkg_name] == [pkg_version]
def test_list_pkgs_no_context():
    """
    Test packages listing and ensure __context__ for pkg.list_pkgs is absent.
    :return:
    """
    def _add_data(data, key, value):
        data.setdefault(key, []).append(value)
    apt_out = [
        "install ok installed accountsservice 0.6.55-0ubuntu12~20.04.1 amd64",
        "install ok installed acpid 1:2.0.32-1ubuntu1 amd64",
        "install ok installed adduser 3.118ubuntu2 all",
        "install ok installed alsa-topology-conf 1.2.2-1 all",
        "install ok installed alsa-ucm-conf 1.2.2-1ubuntu0.4 all",
        "install ok installed apparmor 2.13.3-7ubuntu5.1 amd64",
        "install ok installed apport 2.20.11-0ubuntu27.9 all",
        "install ok installed apport-symptoms 0.23 all",
        "install ok installed apt 2.0.2ubuntu0.1 amd64",
        "install ok installed apt-utils 2.0.2ubuntu0.1 amd64",
        "install ok installed at 3.1.23-1ubuntu1 amd64",
    with patch.dict(aptpkg.__grains__, {"osarch": "x86_64"}), patch.dict(
        aptpkg.__salt__,
        {"cmd.run_stdout": MagicMock(return_value<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=os.linesep.join(apt_out))},
    ), patch.dict(aptpkg.__salt__, {"pkg_resource.add_pkg": _add_data}), patch.dict(
        aptpkg.__salt__,
        {"pkg_resource.format_pkg_list"</b></font>: pkg_resource.format_pkg_list},
    ), patch.dict(
        aptpkg.__salt__, {"pkg_resource.sort_pkglist": pkg_resource.sort_pkglist}
    ), patch.object(
        aptpkg, "_list_pkgs_from_context"
    ) as list_pkgs_context_mock:
        pkgs = aptpkg.list_pkgs(versions_as_list=True, use_context=False)
        list_pkgs_context_mock.assert_not_called()
        list_pkgs_context_mock.reset_mock()
        pkgs = aptpkg.list_pkgs(versions_as_list=True, use_context=False)
        list_pkgs_context_mock.assert_not_called()
        list_pkgs_context_mock.reset_mock()
def test_call_apt_default():
    """
    Call default apt.
    :return:
    """
    with patch.dict(
        aptpkg.__salt__,
        {"cmd.run_all": MagicMock(), "config.get": MagicMock(return_value=False)},
    ):
        aptpkg._call_apt(["apt-get", "install", "emacs"])  # pylint: disable=W0106
        aptpkg.__salt__["cmd.run_all"].assert_called_once_with(
            ["apt-get", "install", "emacs"],
            env={},
            output_loglevel="trace",
            python_shell=False,
        )
@patch("salt.utils.systemd.has_scope", MagicMock(return_value=True))
def test_call_apt_in_scope():
    """
    Call apt within the scope.
    :return:
    """
    with patch.dict(
        aptpkg.__salt__,
        {"cmd.run_all": MagicMock(), "config.get": MagicMock(return_value=True)},
    ):
        aptpkg._call_apt(["apt-get", "purge", "vim"])  # pylint: disable=W0106
        aptpkg.__salt__["cmd.run_all"].assert_called_once_with(
            [
                "systemd-run",
                "--scope",
                "--description",
                '"salt.modules.aptpkg"',
                "apt-get",
                "purge",
                "vim",
            ],
            env={},
            output_loglevel="trace",
            python_shell=False,
        )
def test_call_apt_with_kwargs():
    """
    Call apt with the optinal keyword arguments.
    :return:
    """
    with patch.dict(
        aptpkg.__salt__,
        {"cmd.run_all": MagicMock(), "config.get": MagicMock(return_value=False)},
    ):
        aptpkg._call_apt(
            ["dpkg", "-l", "python"],
            python_shell=True,
            output_loglevel="quiet",
            ignore_retcode=False,
            username="Darth Vader",
        )  # pylint: disable=W0106
        aptpkg.__salt__["cmd.run_all"].assert_called_once_with(
            ["dpkg", "-l", "python"],
            env={},
            ignore_retcode=False,
            output_loglevel="quiet",
            python_shell=True,
            username="Darth Vader",
        )
def test_call_apt_dpkg_lock():
    """
    Call apt and ensure the dpkg locking is handled
    :return:
    """
    cmd_side_effect = [
        {"stderr": "Could not get lock"},
        {"stderr": "Could not get lock"},
        {"stderr": "Could not get lock"},
        {"stderr": "Could not get lock"},
        {"stderr": "", "stdout": ""},
    ]
    cmd_mock = MagicMock(side_effect=cmd_side_effect)
    cmd_call = (
        call(
            ["dpkg", "-l", "python"],
            env={},
            ignore_retcode=False,
            output_loglevel="quiet",
            python_shell=True,
            username="Darth Vader",
        ),
    )
    expected_calls = [cmd_call * 5]
    with patch.dict(
        aptpkg.__salt__,
        {"cmd.run_all": cmd_mock, "config.get": MagicMock(return_value=False)},
    ):
        with patch("salt.modules.aptpkg.time.sleep", MagicMock()) as sleep_mock:
            aptpkg._call_apt(
                ["dpkg", "-l", "python"],
                python_shell=True,
                output_loglevel="quiet",
                ignore_retcode=False,
                username="Darth Vader",
            )  # pylint: disable=W0106
            assert sleep_mock.call_count &gt;= 4
            assert cmd_mock.call_count == 5
            cmd_mock.has_calls(expected_calls)
def test_services_need_restart_checkrestart_missing():
    with patch("salt.utils.path.which_bin", Mock(return_value=None)):
        with pytest.raises(CommandNotFoundError):
            aptpkg.services_need_restart()
@patch("salt.utils.path.which_bin", Mock(return_value="/usr/sbin/checkrestart"))
def test_services_need_restart():
    """
    Test that checkrestart output is parsed correctly
    """
    cr_output = """
PROCESSES: 24
PROGRAMS: 17
PACKAGES: 8
SERVICE:rsyslog,385,/usr/sbin/rsyslogd
SERVICE:cups-daemon,390,/usr/sbin/cupsd
    """
    with patch.dict(aptpkg.__salt__, {"cmd.run_stdout": Mock(return_value=cr_output)}):
        assert sorted(aptpkg.services_need_restart()) == [
            "cups-daemon",
            "rsyslog",
        ]
@pytest.mark.skipif(
    HAS_APTSOURCES is True, reason="Only run test with python3-apt library is missing."
)
def test_sourceslist_multiple_comps():
    """
    Test SourcesList when repo has multiple comps
    """
    repo_line = "deb http://archive.ubuntu.com/ubuntu/ focal-updates main restricted"
    with patch.object(aptpkg, "HAS_APT", return_value=True):
        with patch("salt.utils.files.fopen", mock_open(read_data=repo_line)):
            with patch("pathlib.Path.is_file", side_effect=[True, False]):
                sources = aptpkg.SourcesList()
                for source in sources:
                    assert source.type == "deb"
                    assert source.uri == "http://archive.ubuntu.com/ubuntu/"
                    assert source.comps == ["main", "restricted"]
                    assert source.dist == "focal-updates"
@pytest.mark.skipif(
    HAS_APTSOURCES is True, reason="Only run test with python3-apt library is missing."
)
@pytest.mark.parametrize(
    "repo_line",
    [
        "deb [ arch=amd64 ] http://archive.ubuntu.com/ubuntu/ focal-updates main restricted",
        "deb [arch=amd64 ] http://archive.ubuntu.com/ubuntu/ focal-updates main restricted",
        "deb [arch=amd64 test=one ] http://archive.ubuntu.com/ubuntu/ focal-updates main restricted",
        "deb [arch=amd64,armel test=one ] http://archive.ubuntu.com/ubuntu/ focal-updates main restricted",
        "deb [ arch=amd64,armel test=one ] http://archive.ubuntu.com/ubuntu/ focal-updates main restricted",
        "deb [ arch=amd64,armel test=one] http://archive.ubuntu.com/ubuntu/ focal-updates main restricted",
        "deb [arch=amd64] http://archive.ubuntu.com/ubuntu/ focal-updates main restricted",
    ],
)
def test_sourceslist_architectures(repo_line):
    """
    Test SourcesList when architectures is in repo
    """
    with patch("salt.utils.files.fopen", mock_open(read_data=repo_line)):
        with patch("pathlib.Path.is_file", side_effect=[True, False]):
            sources = aptpkg.SourcesList()
            for source in sources:
                assert source.type == "deb"
                assert source.uri == "http://archive.ubuntu.com/ubuntu/"
                assert source.comps == ["main", "restricted"]
                assert source.dist == "focal-updates"
                if "," in repo_line:
                    assert source.architectures == ["amd64", "armel"]
                else:
                    assert source.architectures == ["amd64"]
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_thin_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
    :codeauthor: :email:`Bo Maryniuk &lt;bo@suse.de&gt;`
"""
import copy
import os
import pathlib
import shutil
import sys
import tarfile
import tempfile
import pytest
import salt.exceptions
<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import salt.utils.hashutils
import salt.utils.json
import salt.utils.platform
import salt.utils.stringutils
from salt.utils import thin
from salt.utils.stringutils import to_bytes as bts
from tests.support.helpers import TstSuiteLoggingHandler, VirtualEnv
from tests.support.mock import MagicMock, patch
from tests.support.runtests import RUNTIME_VARS
from tests.support.unit import TestCase, skipIf
try:
    import</b></font> pytest
except ImportError:
    pytest = None
def patch_if(condition, *args, **kwargs):
    """
    Return a patch decorator if the provided condition is met
    """
    if condition:
        return patch(*args, **kwargs)
    def inner(func):
        return func
    return inner
@skipIf(pytest is None, "PyTest is missing")
class SSHThinTestCase(TestCase):
    """
    TestCase for SaltSSH-related parts.
    """
    def setUp(self):
        self.jinja_fp = os.path.dirname(jinja2.__file__)
        self.ext_conf = {
            "test": {
                "py-version": [2, 7],
                "path": RUNTIME_VARS.SALT_CODE_DIR,
                "dependencies": {"jinja2": self.jinja_fp},
            }
        }
        self.tops = copy.deepcopy(self.ext_conf)
        self.tops["test"]["dependencies"] = [self.jinja_fp]
        self.digest = salt.utils.hashutils.DigestCollector()
        self.exp_files = [
            <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>os.path.join("salt", "payload.py"),
            os.path.join("jinja2", "__init__.py"),
        ]
        lib_root = os.path.join(RUNTIME_VARS.</b></font>TMP, "fake-libs")
        self.fake_libs = {
            "distro": os.path.join(lib_root, "distro"),
            "jinja2": os.path.join(lib_root, "jinja2"),
            "yaml": os.path.join(lib_root, "yaml"),
            "tornado": os.path.join(lib_root, "tornado"),
            "msgpack": os.path.join(lib_root, "msgpack"),
        }
        code_dir = pathlib.Path(RUNTIME_VARS.CODE_DIR).resolve()
        self.exp_ret = {
            "distro": str(code_dir / "distro.py"),
            "jinja2": str(code_dir / "jinja2"),
            "yaml": str(code_dir / "yaml"),
            "tornado": str(code_dir / "tornado"),
            "msgpack": str(code_dir / "msgpack"),
            "certifi": str(code_dir / "certifi"),
            "singledispatch": str(code_dir / "singledispatch.py"),
        }
        self.exc_libs = ["jinja2", "yaml"]
    def tearDown(self):
            if os.path.exists(fp):
                shutil.rmtree(fp)
        self<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.exc_libs = None
        self.jinja_fp = None
        self.ext_conf = None
        self.tops = None
        self.tar = None
        self.digest = None
        self.exp_files = None
        self.fake_libs = None
        self.exp_ret = None
    def</b></font> _popen(self, return_value=None, side_effect=None, returncode=0):
        """
        Fake subprocess.Popen
        :return:
        """
        proc = MagicMock()
        proc.communicate = MagicMock(return_value=return_value, side_effect=side_effect)
        proc.returncode = returncode
        popen = MagicMock(return_value=proc)
        return popen
    def _version_info(self, major=None, minor=None):
        """
        Fake version info.
        :param major:
        :param minor:
        :return:
        """
        class VersionInfo(tuple):
            pass
        vi = VersionInfo([major, minor])
        vi.major = major or sys.version_info.major
        vi.minor = minor or sys.version_info.minor
        return vi
    def _tarfile(self, getinfo=False):
        """
        Fake tarfile handler.
        :return:
        """
        spec = ["add", "close"]
        if getinfo:
            spec.append("getinfo")
        tf = MagicMock()
        tf.open = MagicMock(return_value=MagicMock(spec=spec))
    @patch("salt.utils.thin.log", MagicMock())
    @patch("salt.utils.thin.os.path.isfile", MagicMock<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(return_value=False))
    def test_get_ext_tops_cfg_missing_dependencies(self):
        """
        Test thin.get_ext_tops contains all required dependencies.
        :return:
        """
        cfg = {"namespace": {"py-version": [0, 0], "path": "/foo", "dependencies": []}}
        with pytest.raises(salt.exceptions.</b></font>SaltSystemExit) as err:
            thin.get_ext_tops(cfg)
        self.assertIn("Missing dependencies", str(err.value))
        self.assertTrue(thin.log.error.called)
        self.assertIn("Missing dependencies", thin.log.error.call_args[0][0])
        self.assertIn("jinja2, yaml, tornado, msgpack", thin.log.error.call_args[0][0])
    @patch("salt.exceptions.SaltSystemExit", Exception)
    @patch("salt.utils.thin.log", MagicMock())
    @patch("salt.utils.thin.os.path.isfile", MagicMock(return_value=False))
    def test_get_ext_tops_cfg_missing_interpreter(self):
        """
        Test thin.get_ext_tops contains interpreter configuration.
        :return:
        """
        cfg = {"namespace": {"path": "/foo", "dependencies": []}}
        with pytest.raises(salt.exceptions.SaltSystemExit) as err:
            thin.get_ext_tops(cfg)
        self.assertIn("missing specific locked Python version", str(err.value))
    @patch("salt.exceptions.SaltSystemExit", Exception)
    @patch("salt.utils.thin.log", MagicMock())
    @patch("salt.utils.thin.os.path.isfile", MagicMock(return_value=False))
    def test_get_ext_tops_cfg_wrong_interpreter(self):
        """
        Test thin.get_ext_tops contains correct interpreter configuration.
        :return:
        """
        cfg = {"namespace": {"path": "/foo", "py-version": 2, "dependencies": []}}
        with pytest.raises(salt.exceptions.SaltSystemExit) as err:
            thin.get_ext_tops(cfg)
        self.assertIn(
            "specific locked Python version should be a list of major/minor version",
            str(err.value),
        )
    @patch("salt.exceptions.SaltSystemExit", Exception)
    @patch("salt.utils.thin.log", MagicMock())
    @patch("salt.utils.thin.os.path.isfile", MagicMock(return_value=False))
    def test_get_ext_tops_cfg_interpreter(self):
        """
        Test thin.get_ext_tops interpreter configuration.
        :return:
        """
        cfg = {
            "namespace": {
                "path": "/foo",
                "py-version": [2, 6],
                "dependencies": {
                    "jinja2": "",
                    "yaml": "",
                    "tornado": "",
                    "msgpack": "",
                },
            }
        }
        with pytest.raises(salt.exceptions.SaltSystemExit):
            thin.get_ext_tops(cfg)
        assert len(thin.log.warning.mock_calls) == 4
        assert sorted(x[1][1] for x in thin.log.warning.mock_calls) == [
            "jinja2",
            "msgpack",
            "tornado",
            "yaml",
        ]
        assert (
            "Module test has missing configuration"
            == thin.log.warning.mock_calls[0][1][0] % "test"
        )
    @patch("salt.utils.thin.log", MagicMock())
    @patch("salt.utils.thin.os.path.isfile", MagicMock(return_value=False))
    def test_get_ext_tops_dependency_config_check(self):
        """
        Test thin.get_ext_tops dependencies are importable
        :return:
        """
        cfg = {
            "namespace": {
                "path": "/foo",
                "py-version": [2, 6],
                "dependencies": {
                    "jinja2": "/jinja/foo.py",
                    "yaml": "/yaml/",
                    "tornado": "/tornado/wrong.rb",
                    "msgpack": "msgpack.sh",
                },
            }
        }
        with pytest.raises(salt.exceptions.SaltSystemExit) as err:
            thin.get_ext_tops(cfg)
        self.assertIn(
            "Missing dependencies for the alternative version in the "
            "external configuration",
            str(err.value),
        )
        messages = {}
        for cl in thin.log.warning.mock_calls:
            messages[cl[1][1]] = cl[1][0] % (cl[1][1], cl[1][2])
        for mod in ["tornado", "yaml", "msgpack"]:
            self.assertIn("not a Python importable module", messages[mod])
        self.assertIn(
            "configured with not a file or does not exist", messages["jinja2"]
        )
    @patch("salt.exceptions.SaltSystemExit", Exception)
    @patch("salt.utils.thin.log", MagicMock())
    @patch("salt.utils.thin.os.path.isfile", MagicMock(return_value=True))
    def test_get_ext_tops_config_pass(self):
        """
        Test thin.get_ext_tops configuration
        :return:
        """
        cfg = {
            "namespace": {
                "path": "/foo",
                "py-version": [2, 6],
                "dependencies": {
                    "jinja2": "/jinja/foo.py",
                    "yaml": "/yaml/",
                    "tornado": "/tornado/tornado.py",
                    "msgpack": "msgpack.py",
                    "distro": "distro.py",
                },
            }
        }
        out = thin.get_ext_tops(cfg)
        assert out["namespace"]["py-version"] == cfg["namespace"]["py-version"]
        assert out["namespace"]["path"] == cfg["namespace"]["path"]
        assert sorted(out["namespace"]["dependencies"]) == sorted(
            [
                "/tornado/tornado.py",
                "/jinja/foo.py",
                "/yaml/",
                "msgpack.py",
                "distro.py",
            ]
        )
    @patch("salt.utils.thin.sys.argv", [None, '{"foo": "bar"}'])
    @patch("salt.utils.thin.get_tops", lambda **kw: kw)
    def test_gte(self):
        """
        Test thin.gte external call for processing the info about tops per interpreter.
        :return:
        """
        assert salt.utils.json.loads(thin.gte()).get("foo") == "bar"
    def test_add_dep_path(self):
        """
        Test thin._add_dependency function to setup dependency paths
        :return:
        """
        container = []
        for pth in ["/foo/bar.py", "/something/else/__init__.py"]:
            thin._add_dependency(container, type("obj", (), {"__file__": pth})())
        assert "__init__" not in container[1]
        assert container == ["/foo/bar.py", "/something/else"]
    def test_thin_path(self):
        """
        Test thin.thin_path returns the expected path.
        :return:
        """
        path = os.sep + os.path.join("path", "to")
        expected = os.path.join(path, "thin", "thin.tgz")
        self.assertEqual(thin.thin_path(path), expected)
    def test_get_salt_call_script(self):
        """
        Test get salt-call script rendered.
        :return:
        """
        out = thin._get_salt_call("foo", "bar", py26=[2, 6], py27=[2, 7], py34=[3, 4])
        for line in salt.utils.stringutils.to_str(out).split(os.linesep):
            if line.startswith("namespaces = {"):
                data = salt.utils.json.loads(line.replace("namespaces = ", "").strip())
                assert data.get("py26") == [2, 6]
                assert data.get("py27") == [2, 7]
                assert data.get("py34") == [3, 4]
            if line.startswith("syspaths = "):
                data = salt.utils.json.loads(line.replace("syspaths = ", ""))
                assert data == ["foo", "bar"]
    def test_get_ext_namespaces_empty(self):
        """
        Test thin._get_ext_namespaces function returns an empty dictionary on nothing
        :return:
        """
        for obj in [None, {}, []]:
            assert thin._get_ext_namespaces(obj) == {}
    def test_get_ext_namespaces(self):
        """
        Test thin._get_ext_namespaces function returns namespaces properly out of the config.
        :return:
        """
        cfg = {"ns": {"py-version": [2, 7]}}
        assert thin._get_ext_namespaces(cfg).get("ns") == (
            2,
            7,
        )
        assert isinstance(thin._get_ext_namespaces(cfg).get("ns"), tuple)
    def test_get_ext_namespaces_failure(self):
        """
        Test thin._get_ext_namespaces function raises an exception
        if python major/minor version is not configured.
        :return:
        """
        with pytest.raises(salt.exceptions.SaltSystemExit):
            thin._get_ext_namespaces({"ns": {}})
    @patch(
        "salt.utils.thin.distro",
        type("distro", (), {"__file__": "/site-packages/distro"}),
    )
    @patch(
        "salt.utils.thin.salt",
        type("salt", (), {"__file__": "/site-packages/salt"}),
    )
    @patch(
        "salt.utils.thin.jinja2",
        type("jinja2", (), {"__file__": "/site-packages/jinja2"}),
    )
    @patch(
        "salt.utils.thin.yaml",
        type("yaml", (), {"__file__": "/site-packages/yaml"}),
    )
    @patch(
        "salt.utils.thin.tornado",
        type("tornado", (), {"__file__": "/site-packages/tornado"}),
    )
    @patch(
        "salt.utils.thin.msgpack",
        type("msgpack", (), {"__file__": "/site-packages/msgpack"}),
    )
    @patch(
        "salt.utils.thin.certifi",
        type("certifi", (), {"__file__": "/site-packages/certifi"}),
    )
    @patch(
        "salt.utils.thin.singledispatch",
        type("singledispatch", (), {"__file__": "/site-packages/sdp"}),
    )
    @patch(
        "salt.utils.thin.singledispatch_helpers",
        type("singledispatch_helpers", (), {"__file__": "/site-packages/sdp_hlp"}),
    )
    @patch(
        "salt.utils.thin.ssl_match_hostname",
        type("ssl_match_hostname", (), {"__file__": "/site-packages/ssl_mh"}),
    )
    @patch(
        "salt.utils.thin.markupsafe",
        type("markupsafe", (), {"__file__": "/site-packages/markupsafe"}),
    )
    @patch(
        "salt.utils.thin.backports_abc",
        type("backports_abc", (), {"__file__": "/site-packages/backports_abc"}),
    )
    @patch(
        "salt.utils.thin.concurrent",
        type("concurrent", (), {"__file__": "/site-packages/concurrent"}),
    )
    @patch(
        "salt.utils.thin.py_contextvars",
        type("contextvars", (), {"__file__": "/site-packages/contextvars"}),
    )
    @patch_if(
        salt.utils.thin.has_immutables,
        "salt.utils.thin.immutables",
        type("immutables", (), {"__file__": "/site-packages/immutables"}),
    )
    @patch("salt.utils.thin.log", MagicMock())
    def test_get_tops(self):
        """
        Test thin.get_tops to get top directories, based on the interpreter.
        :return:
        """
        base_tops = [
            "distro",
            "salt",
            "jinja2",
            "yaml",
            "tornado",
            "msgpack",
            "certifi",
            "sdp",
            "sdp_hlp",
            "ssl_mh",
            "markupsafe",
            "backports_abc",
            "concurrent",
            "contextvars",
        ]
        if salt.utils.thin.has_immutables:
            base_tops.extend(["immutables"])
        tops = []
        for top in thin.get_tops(extra_mods="foo,bar"):
            if top.find("/") != -1:
                spl = "/"
            else:
                spl = os.sep
            tops.append(top.rsplit(spl, 1)[-1])
        assert len(tops) == len(base_tops)
        assert sorted(tops) == sorted(base_tops), sorted(tops)
    @patch(
        "salt.utils.thin.distro",
        type("distro", (), {"__file__": "/site-packages/distro"}),
    )
    @patch(
        "salt.utils.thin.salt",
        type("salt", (), {"__file__": "/site-packages/salt"}),
    )
    @patch(
        "salt.utils.thin.jinja2",
        type("jinja2", (), {"__file__": "/site-packages/jinja2"}),
    )
    @patch(
        "salt.utils.thin.yaml",
        type("yaml", (), {"__file__": "/site-packages/yaml"}),
    )
    @patch(
        "salt.utils.thin.tornado",
        type("tornado", (), {"__file__": "/site-packages/tornado"}),
    )
    @patch(
        "salt.utils.thin.msgpack",
        type("msgpack", (), {"__file__": "/site-packages/msgpack"}),
    )
    @patch(
        "salt.utils.thin.certifi",
        type("certifi", (), {"__file__": "/site-packages/certifi"}),
    )
    @patch(
        "salt.utils.thin.singledispatch",
        type("singledispatch", (), {"__file__": "/site-packages/sdp"}),
    )
    @patch(
        "salt.utils.thin.singledispatch_helpers",
        type("singledispatch_helpers", (), {"__file__": "/site-packages/sdp_hlp"}),
    )
    @patch(
        "salt.utils.thin.ssl_match_hostname",
        type("ssl_match_hostname", (), {"__file__": "/site-packages/ssl_mh"}),
    )
    @patch(
        "salt.utils.thin.markupsafe",
        type("markupsafe", (), {"__file__": "/site-packages/markupsafe"}),
    )
    @patch(
        "salt.utils.thin.backports_abc",
        type("backports_abc", (), {"__file__": "/site-packages/backports_abc"}),
    )
    @patch(
        "salt.utils.thin.concurrent",
        type("concurrent", (), {"__file__": "/site-packages/concurrent"}),
    )
    @patch(
        "salt.utils.thin.py_contextvars",
        type("contextvars", (), {"__file__": "/site-packages/contextvars"}),
    )
    @patch_if(
        salt.utils.thin.has_immutables,
        "salt.utils.thin.immutables",
        type("immutables", (), {"__file__": "/site-packages/immutables"}),
    )
    @patch("salt.utils.thin.log", MagicMock())
    def test_get_tops_extra_mods(self):
        """
        Test thin.get_tops to get extra-modules alongside the top directories, based on the interpreter.
        :return:
        """
        base_tops = [
            "distro",
            "salt",
            "jinja2",
            "yaml",
            "tornado",
            "msgpack",
            "certifi",
            "sdp",
            "sdp_hlp",
            "ssl_mh",
            "concurrent",
            "markupsafe",
            "backports_abc",
            "contextvars",
            "foo",
            "bar.py",
        ]
        if salt.utils.thin.has_immutables:
            base_tops.extend(["immutables"])
        libs = salt.utils.thin.find_site_modules("contextvars")
        foo = {"__file__": os.sep + os.path.join("custom", "foo", "__init__.py")}
        bar = {"__file__": os.sep + os.path.join("custom", "bar")}
        with patch("salt.utils.thin.find_site_modules", MagicMock(side_effect=[libs])):
            with patch(
                "builtins.__import__",
                MagicMock(side_effect=[type("foo", (), foo), type("bar", (), bar)]),
            ):
                tops = []
                for top in thin.get_tops(extra_mods="foo,bar"):
                    if top.find("/") != -1:
                        spl = "/"
                    else:
                        spl = os.sep
                    tops.append(top.rsplit(spl, 1)[-1])
        self.assertEqual(len(tops), len(base_tops))
        self.assertListEqual(sorted(tops), sorted(base_tops))
    @patch(
        "salt.utils.thin.distro",
        type("distro", (), {"__file__": "/site-packages/distro"}),
    )
    @patch(
        "salt.utils.thin.salt",
        type("salt", (), {"__file__": "/site-packages/salt"}),
    )
    @patch(
        "salt.utils.thin.jinja2",
        type("jinja2", (), {"__file__": "/site-packages/jinja2"}),
    )
    @patch(
        "salt.utils.thin.yaml",
        type("yaml", (), {"__file__": "/site-packages/yaml"}),
    )
    @patch(
        "salt.utils.thin.tornado",
        type("tornado", (), {"__file__": "/site-packages/tornado"}),
    )
    @patch(
        "salt.utils.thin.msgpack",
        type("msgpack", (), {"__file__": "/site-packages/msgpack"}),
    )
    @patch(
        "salt.utils.thin.certifi",
        type("certifi", (), {"__file__": "/site-packages/certifi"}),
    )
    @patch(
        "salt.utils.thin.singledispatch",
        type("singledispatch", (), {"__file__": "/site-packages/sdp"}),
    )
    @patch(
        "salt.utils.thin.singledispatch_helpers",
        type("singledispatch_helpers", (), {"__file__": "/site-packages/sdp_hlp"}),
    )
    @patch(
        "salt.utils.thin.ssl_match_hostname",
        type("ssl_match_hostname", (), {"__file__": "/site-packages/ssl_mh"}),
    )
    @patch(
        "salt.utils.thin.markupsafe",
        type("markupsafe", (), {"__file__": "/site-packages/markupsafe"}),
    )
    @patch(
        "salt.utils.thin.backports_abc",
        type("backports_abc", (), {"__file__": "/site-packages/backports_abc"}),
    )
    @patch(
        "salt.utils.thin.concurrent",
        type("concurrent", (), {"__file__": "/site-packages/concurrent"}),
    )
    @patch(
        "salt.utils.thin.py_contextvars",
        type("contextvars", (), {"__file__": "/site-packages/contextvars"}),
    )
    @patch_if(
        salt.utils.thin.has_immutables,
        "salt.utils.thin.immutables",
        type("immutables", (), {"__file__": "/site-packages/immutables"}),
    )
    @patch("salt.utils.thin.log", MagicMock())
    def test_get_tops_so_mods(self):
        """
        Test thin.get_tops to get extra-modules alongside the top directories, based on the interpreter.
        :return:
        """
        base_tops = [
            "distro",
            "salt",
            "jinja2",
            "yaml",
            "tornado",
            "msgpack",
            "certifi",
            "sdp",
            "sdp_hlp",
            "ssl_mh",
            "concurrent",
            "markupsafe",
            "backports_abc",
            "contextvars",
            "foo.so",
            "bar.so",
        ]
        if salt.utils.thin.has_immutables:
            base_tops.extend(["immutables"])
        libs = salt.utils.thin.find_site_modules("contextvars")
        with patch("salt.utils.thin.find_site_modules", MagicMock(side_effect=[libs])):
            with patch(
                "builtins.__import__",
                MagicMock(
                    side_effect=[
                        type("salt", (), {"__file__": "/custom/foo.so"}),
                        type("salt", (), {"__file__": "/custom/bar.so"}),
                    ]
                ),
            ):
                tops = []
                for top in thin.get_tops(so_mods="foo,bar"):
                    if top.find("/") != -1:
                        spl = "/"
                    else:
                        spl = os.sep
                    tops.append(top.rsplit(spl, 1)[-1])
        assert len(tops) == len(base_tops)
        assert sorted(tops) == sorted(base_tops)
    @patch("salt.utils.thin.gen_thin", MagicMock(return_value="/path/to/thin/thin.tgz"))
    @patch("salt.utils.hashutils.get_hash", MagicMock(return_value=12345))
    def test_thin_sum(self):
        """
        Test thin.thin_sum function.
        :return:
        """
        assert thin.thin_sum("/cachedir", form="sha256")[1] == 12345
        thin.salt.utils.hashutils.get_hash.assert_called()
        assert thin.salt.utils.hashutils.get_hash.call_count == 1
        path, form = thin.salt.utils.hashutils.get_hash.call_args[0]
        assert path == "/path/to/thin/thin.tgz"
        assert form == "sha256"
    @patch("salt.utils.thin.gen_min", MagicMock(return_value="/path/to/thin/min.tgz"))
    @patch("salt.utils.hashutils.get_hash", MagicMock(return_value=12345))
    def test_min_sum(self):
        """
        Test thin.thin_sum function.
        :return:
        """
        assert thin.min_sum("/cachedir", form="sha256") == 12345
        thin.salt.utils.hashutils.get_hash.assert_called()
        assert thin.salt.utils.hashutils.get_hash.call_count == 1
        path, form = thin.salt.utils.hashutils.get_hash.call_args[0]
        assert path == "/path/to/thin/min.tgz"
        assert form == "sha256"
    @patch("salt.utils.thin.sys.version_info", (2, 5))
    @patch("salt.exceptions.SaltSystemExit", Exception)
    def test_gen_thin_fails_ancient_python_version(self):
        """
        Test thin.gen_thin function raises an exception
        if Python major/minor version is lower than 2.6
        :return:
        """
        with pytest.raises(salt.exceptions.SaltSystemExit) as err:
            thin.sys.exc_clear = lambda: None
            thin.gen_thin("")
        self.assertIn(
            'The minimum required python version to run salt-ssh is "3"',
            str(err.value),
        )
    @patch("salt.exceptions.SaltSystemExit", Exception)
    @patch("salt.utils.thin.log", MagicMock())
    @patch("salt.utils.thin.os.makedirs", MagicMock())
    @patch("salt.utils.files.fopen", MagicMock())
    @patch("salt.utils.thin._get_salt_call", MagicMock())
    @patch("salt.utils.thin._get_ext_namespaces", MagicMock())
    @patch("salt.utils.thin.get_tops", MagicMock(return_value=["/foo3", "/bar3"]))
    @patch("salt.utils.thin.get_ext_tops", MagicMock(return_value={}))
    @patch("salt.utils.thin.os.path.isfile", MagicMock())
    @patch("salt.utils.thin.os.path.isdir", MagicMock(return_value=True))
    @patch("salt.utils.thin.log", MagicMock())
    @patch("salt.utils.thin.os.remove", MagicMock())
    @patch("salt.utils.thin.os.path.exists", MagicMock())
    @patch("salt.utils.path.os_walk", MagicMock(return_value=[]))
    @patch(
        "salt.utils.thin.subprocess.Popen",
        _popen(
            None,
            side_effect=[(bts("2.7"), bts("")), (bts('["/foo27", "/bar27"]'), bts(""))],
        ),
    )
    @patch("salt.utils.thin.tarfile", MagicMock())
    @patch("salt.utils.thin.zipfile", MagicMock())
    @patch("salt.utils.thin.os.getcwd", MagicMock())
    @patch("salt.utils.thin.os.access", MagicMock(return_value=True))
    @patch("salt.utils.thin.os.chdir", MagicMock())
    @patch("salt.utils.thin.os.close", MagicMock())
    @patch("salt.utils.thin.tempfile.mkdtemp", MagicMock())
    @patch(
        "salt.utils.thin.tempfile.mkstemp", MagicMock(return_value=(3, ".temporary"))
    )
    @patch("salt.utils.thin.shutil", MagicMock())
    @patch("salt.utils.thin.sys.version_info", _version_info(None, 3, 6))
    @patch("salt.utils.path.which", MagicMock(return_value="/usr/bin/python"))
    def test_gen_thin_compression_fallback_py3(self):
        """
        Test thin.gen_thin function if fallbacks to the gzip compression, once setup wrong.
        NOTE: Py2 version of this test is not required, as code shares the same spot across the versions.
        :return:
        """
        thin.gen_thin("", compress="arj")
        thin.log.warning.assert_called()
        pt, msg = thin.log.warning.mock_calls[0][1]
        assert (
            pt % msg
            == 'Unknown compression type: "arj". Falling back to "gzip" compression.'
        )
        thin.zipfile.ZipFile.assert_not_called()
        thin.tarfile.open.assert_called()
    @patch("salt.exceptions.SaltSystemExit", Exception)
    @patch("salt.utils.thin.log", MagicMock())
    @patch("salt.utils.thin.os.makedirs", MagicMock())
    @patch("salt.utils.files.fopen", MagicMock())
    @patch("salt.utils.thin._get_salt_call", MagicMock())
    @patch("salt.utils.thin._get_ext_namespaces", MagicMock())
    @patch("salt.utils.thin.get_tops", MagicMock(return_value=["/foo3", "/bar3"]))
    @patch("salt.utils.thin.get_ext_tops", MagicMock(return_value={}))
    @patch("salt.utils.thin.os.path.isfile", MagicMock())
    @patch("salt.utils.thin.os.path.isdir", MagicMock(return_value=False))
    @patch("salt.utils.thin.log", MagicMock())
    @patch("salt.utils.thin.os.remove", MagicMock())
    @patch("salt.utils.thin.os.path.exists", MagicMock())
    @patch("salt.utils.path.os_walk", MagicMock(return_value=[]))
    @patch(
        "salt.utils.thin.subprocess.Popen",
        _popen(
            None,
            side_effect=[(bts("2.7"), bts("")), (bts('["/foo27", "/bar27"]'), bts(""))],
        ),
    )
    @patch("salt.utils.thin.tarfile", MagicMock())
    @patch("salt.utils.thin.zipfile", MagicMock())
    @patch("salt.utils.thin.os.getcwd", MagicMock())
    @patch("salt.utils.thin.os.access", MagicMock(return_value=True))
    @patch("salt.utils.thin.os.chdir", MagicMock())
    @patch("salt.utils.thin.os.close", MagicMock())
    @patch("salt.utils.thin.tempfile.mkdtemp", MagicMock(return_value=""))
    @patch(
        "salt.utils.thin.tempfile.mkstemp", MagicMock(return_value=(3, ".temporary"))
    )
    @patch("salt.utils.thin.shutil", MagicMock())
    @patch("salt.utils.thin.sys.version_info", _version_info(None, 3, 6))
    @patch("salt.utils.path.which", MagicMock(return_value="/usr/bin/python"))
    def test_gen_thin_control_files_written_py3(self):
        """
        Test thin.gen_thin function if control files are written (version, salt-call etc).
        :return:
        """
        thin.gen_thin("")
        arc_name, arc_mode = thin.tarfile.method_calls[0][1]
        self.assertEqual(arc_name, ".temporary")
        self.assertEqual(arc_mode, "w:gz")
        for idx, fname in enumerate(
            ["version", ".thin-gen-py-version", "salt-call", "supported-versions"]
        ):
            name = thin.tarfile.open().method_calls[idx + 2][1][0]
            self.assertEqual(name, fname)
        thin.tarfile.open().close.assert_called()
    @patch("salt.exceptions.SaltSystemExit", Exception)
    @patch("salt.utils.thin.log", MagicMock())
    @patch("salt.utils.thin.os.makedirs", MagicMock())
    @patch("salt.utils.files.fopen", MagicMock())
    @patch("salt.utils.thin._get_salt_call", MagicMock())
    @patch("salt.utils.thin._get_ext_namespaces", MagicMock())
    @patch("salt.utils.thin.get_tops", MagicMock(return_value=["/salt", "/bar3"]))
    @patch("salt.utils.thin.get_ext_tops", MagicMock(return_value={}))
    @patch("salt.utils.thin.os.path.isfile", MagicMock())
    @patch("salt.utils.thin.os.path.isdir", MagicMock(return_value=True))
    @patch("salt.utils.thin.log", MagicMock())
    @patch("salt.utils.thin.os.remove", MagicMock())
    @patch("salt.utils.thin.os.path.exists", MagicMock())
    @patch(
        "salt.utils.path.os_walk",
        MagicMock(
            return_value=(
                ("root", [], ["r1", "r2", "r3"]),
                ("root2", [], ["r4", "r5", "r6"]),
            )
        ),
    )
    @patch("salt.utils.thin.tarfile", _tarfile(None))
    @patch("salt.utils.thin.zipfile", MagicMock())
    @patch(
        "salt.utils.thin.os.getcwd",
        MagicMock(return_value=os.path.join(RUNTIME_VARS.TMP, "fake-cwd")),
    )
    @patch("salt.utils.thin.os.chdir", MagicMock())
    @patch("salt.utils.thin.os.close", MagicMock())
    @patch("salt.utils.thin.tempfile.mkdtemp", MagicMock(return_value=""))
    @patch(
        "salt.utils.thin.tempfile.mkstemp", MagicMock(return_value=(3, ".temporary"))
    )
    @patch("salt.utils.thin.shutil", MagicMock())
    @patch("salt.utils.thin.sys.version_info", _version_info(None, 3, 6))
    @patch("salt.utils.hashutils.DigestCollector", MagicMock())
    @patch("salt.utils.path.which", MagicMock(return_value="/usr/bin/python"))
    def test_gen_thin_main_content_files_written_py3(self):
        """
        Test thin.gen_thin function if main content files are written.
        NOTE: Py2 version of this test is not required, as code shares the same spot across the versions.
        :return:
        """
        thin.gen_thin("")
        files = []
        for py in ("py3", "pyall"):
            for i in range(1, 4):
                files.append(os.path.join(py, "root", "r{}".format(i)))
            for i in range(4, 7):
                files.append(os.path.join(py, "root2", "r{}".format(i)))
        for cl in thin.tarfile.open().method_calls[:-6]:
            arcname = cl[2].get("arcname")
            self.assertIn(arcname, files)
            files.pop(files.index(arcname))
        self.assertFalse(files)
    @patch("salt.exceptions.SaltSystemExit", Exception)
    @patch("salt.utils.thin.log", MagicMock())
    @patch("salt.utils.thin.os.makedirs", MagicMock())
    @patch("salt.utils.files.fopen", MagicMock())
    @patch("salt.utils.thin._get_salt_call", MagicMock())
    @patch("salt.utils.thin._get_ext_namespaces", MagicMock())
    @patch("salt.utils.thin.get_tops", MagicMock(return_value=[]))
    @patch(
        "salt.utils.thin.get_ext_tops",
        MagicMock(
            return_value={
                "namespace": {
                    "py-version": [3, 0],
                    "path": "/opt/2015.8/salt",
                    "dependencies": ["/opt/certifi", "/opt/whatever"],
                }
            }
        ),
    )
    @patch("salt.utils.thin.os.path.isfile", MagicMock())
    @patch("salt.utils.thin.os.path.isdir", MagicMock(return_value=True))
    @patch("salt.utils.thin.log", MagicMock())
    @patch("salt.utils.thin.os.remove", MagicMock())
    @patch("salt.utils.thin.os.path.exists", MagicMock())
    @patch(
        "salt.utils.path.os_walk",
        MagicMock(
            return_value=(
                ("root", [], ["r1", "r2", "r3"]),
                ("root2", [], ["r4", "r5", "r6"]),
            )
        ),
    )
    @patch("salt.utils.thin.tarfile", _tarfile(None))
    @patch("salt.utils.thin.zipfile", MagicMock())
    @patch(
        "salt.utils.thin.os.getcwd",
        MagicMock(return_value=os.path.join(RUNTIME_VARS.TMP, "fake-cwd")),
    )
    @patch("salt.utils.thin.os.chdir", MagicMock())
    @patch("salt.utils.thin.os.close", MagicMock())
    @patch("salt.utils.thin.tempfile.mkdtemp", MagicMock(return_value=""))
    @patch(
        "salt.utils.thin.tempfile.mkstemp", MagicMock(return_value=(3, ".temporary"))
    )
    @patch("salt.utils.thin.shutil", MagicMock())
    @patch("salt.utils.thin.sys.version_info", _version_info(None, 3, 6))
    @patch("salt.utils.hashutils.DigestCollector", MagicMock())
    @patch("salt.utils.path.which", MagicMock(return_value="/usr/bin/python"))
    def test_gen_thin_ext_alternative_content_files_written_py3(self):
        """
        Test thin.gen_thin function if external alternative content files are written.
        :return:
        """
        ext_conf = {
            "namespace": {
                "py-version": [3, 0],
                "path": "/opt/2015.8/salt",
                "dependencies": {
                    "certifi": "/opt/certifi",
                    "whatever": "/opt/whatever",
                },
            }
        }
        thin.gen_thin("", extended_cfg=ext_conf)
        files = []
        for py in ("pyall", "pyall", "py3"):
            for i in range(1, 4):
                files.append(os.path.join("namespace", py, "root", "r{}".format(i)))
            for i in range(4, 7):
                files.append(os.path.join("namespace", py, "root2", "r{}".format(i)))
        for idx, cl in enumerate(thin.tarfile.open().method_calls[:-6]):
            arcname = cl[2].get("arcname")
            self.assertIn(arcname, files)
            files.pop(files.index(arcname))
        self.assertFalse(files)
    def test_get_supported_py_config_typecheck(self):
        """
        Test collecting proper py-versions. Should return bytes type.
        :return:
        """
        tops = {}
        ext_cfg = {}
        out = thin._get_supported_py_config(tops=tops, extended_cfg=ext_cfg)
        assert type(salt.utils.stringutils.to_bytes("")) == type(out)
    def test_get_supported_py_config_base_tops(self):
        """
        Test collecting proper py-versions. Should return proper base tops.
        :return:
        """
        tops = {"3": ["/groundkeepers", "/stole"], "2": ["/the-root", "/password"]}
        ext_cfg = {}
        out = (
            salt.utils.stringutils.to_str(
                thin._get_supported_py_config(tops=tops, extended_cfg=ext_cfg)
            )
            .strip()
            .split(os.linesep)
        )
        self.assertEqual(len(out), 2)
        for t_line in ["py3:3:0", "py2:2:7"]:
            self.assertIn(t_line, out)
    def test_get_supported_py_config_ext_tops(self):
        """
        Test collecting proper py-versions. Should return proper ext conf tops.
        :return:
        """
        tops = {}
        ext_cfg = {
            "solar-interference": {"py-version": [2, 6]},
            "second-system-effect": {"py-version": [2, 7]},
        }
        out = (
            salt.utils.stringutils.to_str(
                thin._get_supported_py_config(tops=tops, extended_cfg=ext_cfg)
            )
            .strip()
            .split(os.linesep)
        )
        for t_line in ["second-system-effect:2:7", "solar-interference:2:6"]:
            self.assertIn(t_line, out)
    @patch("salt.exceptions.SaltSystemExit", Exception)
    @patch("salt.utils.thin.log", MagicMock())
    @patch("salt.utils.thin.os.makedirs", MagicMock())
    @patch("salt.utils.files.fopen", MagicMock())
    @patch("salt.utils.thin._get_salt_call", MagicMock())
    @patch("salt.utils.thin._get_ext_namespaces", MagicMock())
    @patch("salt.utils.thin.get_tops", MagicMock(return_value=["/foo3", "/bar3"]))
    @patch("salt.utils.thin.get_ext_tops", MagicMock(return_value={}))
    @patch("salt.utils.thin.os.path.isfile", MagicMock())
    @patch("salt.utils.thin.os.path.isdir", MagicMock(return_value=False))
    @patch("salt.utils.thin.log", MagicMock())
    @patch("salt.utils.thin.os.remove", MagicMock())
    @patch("salt.utils.thin.os.path.exists", MagicMock())
    @patch("salt.utils.path.os_walk", MagicMock(return_value=[]))
    @patch(
        "salt.utils.thin.subprocess.Popen",
        _popen(
            None,
            side_effect=[(bts("2.7"), bts("")), (bts('["/foo27", "/bar27"]'), bts(""))],
        ),
    )
    @patch("salt.utils.thin.tarfile", MagicMock())
    @patch("salt.utils.thin.zipfile", MagicMock())
    @patch("salt.utils.thin.os.getcwd", MagicMock())
    @patch("salt.utils.thin.os.access", MagicMock(return_value=False))
    @patch("salt.utils.thin.os.chdir", MagicMock())
    @patch("salt.utils.thin.os.close", MagicMock())
    @patch("salt.utils.thin.tempfile.mkdtemp", MagicMock(return_value=""))
    @patch(
        "salt.utils.thin.tempfile.mkstemp", MagicMock(return_value=(3, ".temporary"))
    )
    @patch("salt.utils.thin.shutil", MagicMock())
    @patch("salt.utils.thin.sys.version_info", _version_info(None, 3, 6))
    def test_gen_thin_control_files_written_access_denied_cwd(self):
        """
        Test thin.gen_thin function if control files are written (version, salt-call etc)
        when the current working directory is inaccessible, eg. Salt is configured to run as
        a non-root user but the command is executed in a directory that the user does not
        have permissions to.  Issue #54317.
        NOTE: Py2 version of this test is not required, as code shares the same spot across the versions.
        :return:
        """
        thin.gen_thin("")
        arc_name, arc_mode = thin.tarfile.method_calls[0][1]
        self.assertEqual(arc_name, ".temporary")
        self.assertEqual(arc_mode, "w:gz")
        for idx, fname in enumerate(
            ["version", ".thin-gen-py-version", "salt-call", "supported-versions"]
        ):
            name = thin.tarfile.open().method_calls[idx + 2][1][0]
            self.assertEqual(name, fname)
        thin.tarfile.open().close.assert_called()
    def test_get_tops_python(self):
        """
        test get_tops_python
        """
        patch_proc = patch(
            "salt.utils.thin.subprocess.Popen",
            self._popen(
                None,
                side_effect=[
                    (bts("jinja2/__init__.py"), bts("")),
                    (bts("yaml/__init__.py"), bts("")),
                    (bts("tornado/__init__.py"), bts("")),
                    (bts("msgpack/__init__.py"), bts("")),
                    (bts("certifi/__init__.py"), bts("")),
                    (bts("singledispatch.py"), bts("")),
                    (bts(""), bts("")),
                    (bts(""), bts("")),
                    (bts(""), bts("")),
                    (bts(""), bts("")),
                    (bts(""), bts("")),
                    (bts("distro.py"), bts("")),
                ],
            ),
        )
        patch_os = patch("os.path.exists", return_value=True)
        patch_which = patch("salt.utils.path.which", return_value=True)
        with patch_proc, patch_os, patch_which:
            with TstSuiteLoggingHandler() as log_handler:
                exp_ret = copy.deepcopy(self.exp_ret)
                ret = thin.get_tops_python("python3.7", ext_py_ver=[3, 7])
                if salt.utils.platform.is_windows():
                    for key, value in ret.items():
                        ret[key] = str(pathlib.Path(value).resolve(strict=False))
                    for key, value in exp_ret.items():
                        exp_ret[key] = str(pathlib.Path(value).resolve(strict=False))
                assert ret == exp_ret
                assert (
                    "ERROR:Could not auto detect file location for module concurrent"
                    " for python version python3.7" in log_handler.messages
                )
    def test_get_tops_python_exclude(self):
        """
        test get_tops_python when excluding modules
        """
        patch_proc = patch(
            "salt.utils.thin.subprocess.Popen",
            self._popen(
                None,
                side_effect=[
                    (bts("tornado/__init__.py"), bts("")),
                    (bts("msgpack/__init__.py"), bts("")),
                    (bts("certifi/__init__.py"), bts("")),
                    (bts("singledispatch.py"), bts("")),
                    (bts(""), bts("")),
                    (bts(""), bts("")),
                    (bts(""), bts("")),
                    (bts(""), bts("")),
                    (bts(""), bts("")),
                    (bts("distro.py"), bts("")),
                ],
            ),
        )
        exp_ret = copy.deepcopy(self.exp_ret)
        for lib in self.exc_libs:
            exp_ret.pop(lib)
        patch_os = patch("os.path.exists", return_value=True)
        patch_which = patch("salt.utils.path.which", return_value=True)
        with patch_proc, patch_os, patch_which:
            ret = thin.get_tops_python(
                "python3.7", exclude=self.exc_libs, ext_py_ver=[3, 7]
            )
            if salt.utils.platform.is_windows():
                for key, value in ret.items():
                    ret[key] = str(pathlib.Path(value).resolve(strict=False))
                for key, value in exp_ret.items():
                    exp_ret[key] = str(pathlib.Path(value).resolve(strict=False))
            assert ret == exp_ret
    def test_pack_alternatives_exclude(self):
        """
        test pack_alternatives when mixing
        manually set dependencies and auto
        detecting other modules.
        """
        patch_proc = patch(
            "salt.utils.thin.subprocess.Popen",
            self._popen(
                None,
                side_effect=[
                    (bts(self.fake_libs["distro"]), bts("")),
                    (bts(self.fake_libs["yaml"]), bts("")),
                    (bts(self.fake_libs["tornado"]), bts("")),
                    (bts(self.fake_libs["msgpack"]), bts("")),
                    (bts(""), bts("")),
                    (bts(""), bts("")),
                    (bts(""), bts("")),
                    (bts(""), bts("")),
                    (bts(""), bts("")),
                    (bts(""), bts("")),
                    (bts(""), bts("")),
                ],
            ),
        )
        patch_os = patch("os.path.exists", return_value=True)
        ext_conf = copy.deepcopy(self.ext_conf)
        ext_conf["test"]["auto_detect"] = True
        for lib in self.fake_libs.values():
            os.makedirs(lib)
                fp_.write("test")
        exp_files <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= self.exp_files.copy()
        exp_files.extend(
            [
                os.path.join("yaml", "__init__.py"),
                os.path.</b></font>join("tornado", "__init__.py"),
                os.path.join("msgpack", "__init__.py"),
            ]
        )
        patch_which = patch("salt.utils.path.which", return_value=True)
        with patch_os, patch_proc, patch_which:
            thin._pack_alternative(ext_conf, self.digest, self.tar)
            calls = self.tar.mock_calls
            for _file in exp_files:
                assert [x for x in calls if "{}".format(_file) in x[-2]]
    def test_pack_alternatives(self):
        """
        test thin._pack_alternatives
        """
        with patch("salt.utils.thin.get_ext_tops", MagicMock(return_value=self.tops)):
            thin._pack_alternative(self.ext_conf, self.digest, self.tar)
            calls = self.tar.mock_calls
            for _file in self.exp_files:
                assert [x for x in calls if "{}".format(_file) in x[-2]]
                assert [
                    x
                    for x in calls
                    if os.path.join("test", "pyall", _file) in x[-1]["arcname"]
                ]
    def test_pack_alternatives_not_normalized(self):
        """
        test thin._pack_alternatives when the path
        is not normalized
        """
        tops = copy.deepcopy(self.tops)
        tops["test"]["dependencies"] = [self.jinja_fp + "/"]
        with patch("salt.utils.thin.get_ext_tops", MagicMock(return_value=tops)):
            thin._pack_alternative(self.ext_conf, self.digest, self.tar)
            calls = self.tar.mock_calls
            for _file in self.exp_files:
                assert [x for x in calls if "{}".format(_file) in x[-2]]
                assert [
                    x
                    for x in calls
                    if os.path.join("test", "pyall", _file) in x[-1]["arcname"]
                ]
    def test_pack_alternatives_path_doesnot_exist(self):
        """
        test thin._pack_alternatives when the path
        doesnt exist. Check error log message
        and expect that because the directory
        does not exist jinja2 does not get
        added to the tar
        """
        bad_path = os.path.join(tempfile.gettempdir(), "doesnotexisthere")
        tops = copy.deepcopy(self.tops)
        tops["test"]["dependencies"] = [bad_path]
        with patch("salt.utils.thin.get_ext_tops", MagicMock(return_value=tops)):
            with TstSuiteLoggingHandler() as log_handler:
                thin._pack_alternative(self.ext_conf, self.digest, self.tar)
                msg = "ERROR:File path {} does not exist. Unable to add to salt-ssh thin".format(
                    bad_path
                )
                assert msg in log_handler.messages
        calls = self.tar.mock_calls
        for _file in self.exp_files:
            arg = [x for x in calls if "{}".format(_file) in x[-2]]
            kwargs = [
                x
                for x in calls
                if os.path.join("test", "pyall", _file) in x[-1]["arcname"]
            ]
            if "jinja2" in _file:
                assert not arg
                assert not kwargs
            else:
                assert arg
                assert kwargs
    def test_pack_alternatives_auto_detect(self):
        """
        test thin._pack_alternatives when auto_detect
        is enabled
        """
        ext_conf = copy.deepcopy(self.ext_conf)
        ext_conf["test"]["auto_detect"] = True
        for lib in self.fake_libs.values():
            os.makedirs(lib)
            with salt.utils.files.fopen(os.path.join(lib, "__init__.py"), "w+") as fp_:
                fp_.write("test")
        patch_tops_py = patch(
            "salt.utils.thin.get_tops_python", return_value=self.fake_libs
        )
        exp_files = self.exp_files.copy()
        exp_files.extend(
            [
                os.path.join("yaml", "__init__.py"),
                os.path.join("tornado", "__init__.py"),
                os.path.join("msgpack", "__init__.py"),
            ]
        )
        with patch_tops_py:
            thin._pack_alternative(ext_conf, self.digest, self.tar)
            calls = self.tar.mock_calls
            for _file in exp_files:
                assert [x for x in calls if "{}".format(_file) in x[-2]]
    def test_pack_alternatives_empty_dependencies(self):
        """
        test _pack_alternatives when dependencies is not
        set in the config.
        """
        ext_conf = copy.deepcopy(self.ext_conf)
        ext_conf["test"]["auto_detect"] = True
        ext_conf["test"].pop("dependencies")
        for lib in self.fake_libs.values():
            os.makedirs(lib)
            with salt.utils.files.fopen(os.path.join(lib, "__init__.py"), "w+") as fp_:
                fp_.write("test")
        patch_tops_py = patch(
            "salt.utils.thin.get_tops_python", return_value=self.fake_libs
        )
        exp_files = self.exp_files.copy()
        exp_files.extend(
            [
                os.path.join("yaml", "__init__.py"),
                os.path.join("tornado", "__init__.py"),
                os.path.join("msgpack", "__init__.py"),
            ]
        )
        with patch_tops_py:
            thin._pack_alternative(ext_conf, self.digest, self.tar)
            calls = self.tar.mock_calls
            for _file in exp_files:
                assert [x for x in calls if "{}".format(_file) in x[-2]]
    @pytest.mark.slow_test
    @skipIf(
        salt.utils.platform.is_windows(), "salt-ssh does not deploy to/from windows"
    )
    def test_thin_dir(self):
        """
        Test the thin dir to make sure salt-call can run
        Run salt call via a python in a new virtual environment to ensure
        salt-call has all dependencies needed.
        """
        with VirtualEnv() as venv:
            salt.utils.thin.gen_thin(str(venv.venv_dir))
            thin_dir = venv.venv_dir / "thin"
            thin_archive = thin_dir / "thin.tgz"
            tar = tarfile.open(str(thin_archive))
            tar.extractall(str(thin_dir))
            tar.close()
            ret = venv.run(
                venv.venv_python,
                str(thin_dir / "salt-call"),
                "--version",
                check=False,
            )
            assert ret.exitcode == 0, ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
