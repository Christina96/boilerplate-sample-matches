<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_aptpkg_1.py & test_thin_1.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_aptpkg_1.py & test_thin_1.py
      </h3>
      <h1 align="center">
        4.0%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_aptpkg_1.py (5.063291%)<TH>test_thin_1.py (3.4102306%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match80632-0.html#0',2,'match80632-1.html#0',3)" NAME="0">(196-206)<TD><A HREF="javascript:ZweiFrames('match80632-0.html#0',2,'match80632-1.html#0',3)" NAME="0">(95-105)</A><TD ALIGN=center><FONT COLOR="#ff0000">20</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match80632-0.html#1',2,'match80632-1.html#1',3)" NAME="1">(984-987)<TD><A HREF="javascript:ZweiFrames('match80632-0.html#1',2,'match80632-1.html#1',3)" NAME="1">(1202-1206)</A><TD ALIGN=center><FONT COLOR="#990000">12</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match80632-0.html#2',2,'match80632-1.html#2',3)" NAME="2">(933-936)<TD><A HREF="javascript:ZweiFrames('match80632-0.html#2',2,'match80632-1.html#2',3)" NAME="2">(67-70)</A><TD ALIGN=center><FONT COLOR="#990000">12</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match80632-0.html#3',2,'match80632-1.html#3',3)" NAME="3">(751-772)<TD><A HREF="javascript:ZweiFrames('match80632-0.html#3',2,'match80632-1.html#3',3)" NAME="3">(153-162)</A><TD ALIGN=center><FONT COLOR="#990000">12</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match80632-0.html#4',2,'match80632-1.html#4',3)" NAME="4">(9-26)<TD><A HREF="javascript:ZweiFrames('match80632-0.html#4',2,'match80632-1.html#4',3)" NAME="4">(16-28)</A><TD ALIGN=center><FONT COLOR="#990000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_aptpkg_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
    :synopsis: Unit Tests for Advanced Packaging Tool module 'module.aptpkg'
    :platform: Linux
    :maturity: develop
    versionadded:: 2017.7.0
<A NAME="4"></A>&quot;&quot;&quot;


<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match80632-1.html#4',3,'match80632-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import copy
import logging
import os
import pathlib
import textwrap

import pytest
import salt.modules.aptpkg as aptpkg
import salt.modules.pkg_resource as pkg_resource
from salt.exceptions import (
    CommandExecutionError,
    CommandNotFoundError,
    SaltInvocationError,
)
from tests.support.mock import MagicMock, Mock, call, mock_open, patch

try:
    from</B></FONT> aptsources import sourceslist  # pylint: disable=unused-import

    HAS_APTSOURCES = True
except ImportError:
    HAS_APTSOURCES = False

log = logging.getLogger(__name__)


@pytest.fixture(scope=&quot;module&quot;)
def repo_keys_var():
    return {
        &quot;46181433FBB75451&quot;: {
            &quot;algorithm&quot;: 17,
            &quot;bits&quot;: 1024,
            &quot;capability&quot;: &quot;scSC&quot;,
            &quot;date_creation&quot;: 1104433784,
            &quot;date_expiration&quot;: None,
            &quot;fingerprint&quot;: &quot;C5986B4F1257FFA86632CBA746181433FBB75451&quot;,
            &quot;keyid&quot;: &quot;46181433FBB75451&quot;,
            &quot;uid&quot;: &quot;Ubuntu CD Image Automatic Signing Key &lt;cdimage@ubuntu.com&gt;&quot;,
            &quot;uid_hash&quot;: &quot;B4D41942D4B35FF44182C7F9D00C99AF27B93AD0&quot;,
            &quot;validity&quot;: &quot;-&quot;,
        }
    }


@pytest.fixture(scope=&quot;module&quot;)
def packages_var():
    return {&quot;wget&quot;: &quot;1.15-1ubuntu1.14.04.2&quot;}


@pytest.fixture(scope=&quot;module&quot;)
def lowpkg_files_var():
    return {
        &quot;errors&quot;: {},
        &quot;packages&quot;: {
            &quot;wget&quot;: [
                &quot;/.&quot;,
                &quot;/etc&quot;,
                &quot;/etc/wgetrc&quot;,
                &quot;/usr&quot;,
                &quot;/usr/bin&quot;,
                &quot;/usr/bin/wget&quot;,
                &quot;/usr/share&quot;,
                &quot;/usr/share/info&quot;,
                &quot;/usr/share/info/wget.info.gz&quot;,
                &quot;/usr/share/doc&quot;,
                &quot;/usr/share/doc/wget&quot;,
                &quot;/usr/share/doc/wget/MAILING-LIST&quot;,
                &quot;/usr/share/doc/wget/NEWS.gz&quot;,
                &quot;/usr/share/doc/wget/AUTHORS&quot;,
                &quot;/usr/share/doc/wget/copyright&quot;,
                &quot;/usr/share/doc/wget/changelog.Debian.gz&quot;,
                &quot;/usr/share/doc/wget/README&quot;,
                &quot;/usr/share/man&quot;,
                &quot;/usr/share/man/man1&quot;,
                &quot;/usr/share/man/man1/wget.1.gz&quot;,
            ]
        },
    }


@pytest.fixture(scope=&quot;module&quot;)
def lowpkg_info_var():
    return {
        &quot;wget&quot;: {
            &quot;architecture&quot;: &quot;amd64&quot;,
            &quot;description&quot;: &quot;retrieves files from the web&quot;,
            &quot;homepage&quot;: &quot;http://www.gnu.org/software/wget/&quot;,
            &quot;install_date&quot;: &quot;2016-08-30T22:20:15Z&quot;,
            &quot;maintainer&quot;: &quot;Ubuntu Developers &lt;ubuntu-devel-discuss@lists.ubuntu.com&gt;&quot;,
            &quot;name&quot;: &quot;wget&quot;,
            &quot;section&quot;: &quot;web&quot;,
            &quot;source&quot;: &quot;wget&quot;,
            &quot;version&quot;: &quot;1.15-1ubuntu1.14.04.2&quot;,
            &quot;status&quot;: &quot;ii&quot;,
        },
        &quot;apache2&quot;: {
            &quot;architecture&quot;: &quot;amd64&quot;,
            &quot;description&quot;: &quot;&quot;&quot;Apache HTTP Server
     The Apache HTTP Server Project's goal is to build a secure, efficient and
     extensible HTTP server as standards-compliant open source software. The
     result has long been the number one web server on the Internet.
     .
     Installing this package results in a full installation, including the
     configuration files, init scripts and support scripts.&quot;&quot;&quot;,
            &quot;homepage&quot;: &quot;http://httpd.apache.org/&quot;,
            &quot;install_date&quot;: &quot;2016-08-30T22:20:15Z&quot;,
            &quot;maintainer&quot;: &quot;Ubuntu Developers &lt;ubuntu-devel-discuss@lists.ubuntu.com&gt;&quot;,
            &quot;name&quot;: &quot;apache2&quot;,
            &quot;section&quot;: &quot;httpd&quot;,
            &quot;source&quot;: &quot;apache2&quot;,
            &quot;version&quot;: &quot;2.4.18-2ubuntu3.9&quot;,
            &quot;status&quot;: &quot;rc&quot;,
        },
    }


@pytest.fixture(scope=&quot;module&quot;)
def apt_q_update_var():
    return &quot;&quot;&quot;
    Get:1 http://security.ubuntu.com trusty-security InRelease [65 kB]
    Get:2 http://security.ubuntu.com trusty-security/main Sources [120 kB]
    Get:3 http://security.ubuntu.com trusty-security/main amd64 Packages [548 kB]
    Get:4 http://security.ubuntu.com trusty-security/main i386 Packages [507 kB]
    Hit http://security.ubuntu.com trusty-security/main Translation-en
    Fetched 1240 kB in 10s (124 kB/s)
    Reading package lists...
    &quot;&quot;&quot;


@pytest.fixture(scope=&quot;module&quot;)
def apt_q_update_error_var():
    return &quot;&quot;&quot;
    Err http://security.ubuntu.com trusty InRelease

    Err http://security.ubuntu.com trusty Release.gpg
    Unable to connect to security.ubuntu.com:http:
    Reading package lists...
    W: Failed to fetch http://security.ubuntu.com/ubuntu/dists/trusty/InRelease

    W: Failed to fetch http://security.ubuntu.com/ubuntu/dists/trusty/Release.gpg  Unable to connect to security.ubuntu.com:http:

    W: Some index files failed to download. They have been ignored, or old ones used instead.
    &quot;&quot;&quot;


@pytest.fixture(scope=&quot;module&quot;)
def autoremove_var():
    return &quot;&quot;&quot;
    Reading package lists... Done
    Building dependency tree
    Reading state information... Done
    0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
    &quot;&quot;&quot;


@pytest.fixture(scope=&quot;module&quot;)
def upgrade_var():
    return &quot;&quot;&quot;
    Reading package lists...
    Building dependency tree...
    Reading state information...
    0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
    &quot;&quot;&quot;


@pytest.fixture(scope=&quot;module&quot;)
def uninstall_var():
    return {&quot;tmux&quot;: {&quot;new&quot;: &quot;&quot;, &quot;old&quot;: &quot;1.8-5&quot;}}


@pytest.fixture(scope=&quot;module&quot;)
def install_var():
    return {&quot;tmux&quot;: {&quot;new&quot;: &quot;1.8-5&quot;, &quot;old&quot;: &quot;&quot;}}


def _get_uri(repo):
    &quot;&quot;&quot;
    Get the URI portion of the a string
    &quot;&quot;&quot;
    splits = repo.split()
    for val in splits:
        if any(val.startswith(x) for x in (&quot;http://&quot;, &quot;https://&quot;, &quot;ftp://&quot;)):
            return val

<A NAME="0"></A>
class MockSourceEntry:
    def __init__(self, uri, source_type, line, invalid, dist=&quot;&quot;, file=None):
        self<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match80632-1.html#0',3,'match80632-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.uri = uri
        self.type = source_type
        self.line = line
        self.invalid = invalid
        self.file = file
        self.disabled = False
        self.dist = dist
        self.comps = []
        self.architectures = []

    def</B></FONT> mysplit(self, line):
        return line.split()


class MockSourceList:
    def __init__(self):
        self.list = []

    def __iter__(self):
        yield from self.list

    def save(self):
        pass


@pytest.fixture
def configure_loader_modules():
    return {aptpkg: {&quot;__grains__&quot;: {}}}


def test_version(lowpkg_info_var):
    &quot;&quot;&quot;
    Test - Returns a string representing the package version or an empty string if
    not installed.
    &quot;&quot;&quot;
    version = lowpkg_info_var[&quot;wget&quot;][&quot;version&quot;]
    mock = MagicMock(return_value=version)
    with patch.dict(aptpkg.__salt__, {&quot;pkg_resource.version&quot;: mock}):
        assert aptpkg.version(*[&quot;wget&quot;]) == version


def test_upgrade_available():
    &quot;&quot;&quot;
    Test - Check whether or not an upgrade is available for a given package.
    &quot;&quot;&quot;
    with patch(&quot;salt.modules.aptpkg.latest_version&quot;, MagicMock(return_value=&quot;&quot;)):
        assert aptpkg.upgrade_available(&quot;wget&quot;) is False


def test_add_repo_key(repo_keys_var):
    &quot;&quot;&quot;
    Test - Add a repo key.
    &quot;&quot;&quot;
    with patch(
        &quot;salt.modules.aptpkg.get_repo_keys&quot;, MagicMock(return_value=repo_keys_var)
    ):
        mock = MagicMock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: &quot;OK&quot;})
        with patch.dict(aptpkg.__salt__, {&quot;cmd.run_all&quot;: mock}):
            assert (
                aptpkg.add_repo_key(keyserver=&quot;keyserver.ubuntu.com&quot;, keyid=&quot;FBB75451&quot;)
                is True
            )


def test_add_repo_key_failed(repo_keys_var):
    &quot;&quot;&quot;
    Test - Add a repo key using incomplete input data.
    &quot;&quot;&quot;
    with patch(
        &quot;salt.modules.aptpkg.get_repo_keys&quot;, MagicMock(return_value=repo_keys_var)
    ):
        kwargs = {&quot;keyserver&quot;: &quot;keyserver.ubuntu.com&quot;}
        mock = MagicMock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: &quot;OK&quot;})
        with patch.dict(aptpkg.__salt__, {&quot;cmd.run_all&quot;: mock}):
            with pytest.raises(SaltInvocationError):
                aptpkg.add_repo_key(**kwargs)


def test_get_repo_keys(repo_keys_var):
    &quot;&quot;&quot;
    Test - List known repo key details.
    &quot;&quot;&quot;
    APT_KEY_LIST = r&quot;&quot;&quot;
    pub:-:1024:17:46181433FBB75451:1104433784:::-:::scSC:
    fpr:::::::::C5986B4F1257FFA86632CBA746181433FBB75451:
    uid:-::::1104433784::B4D41942D4B35FF44182C7F9D00C99AF27B93AD0::Ubuntu CD Image Automatic Signing Key &lt;cdimage@ubuntu.com&gt;:
    &quot;&quot;&quot;

    mock = MagicMock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: APT_KEY_LIST})
    with patch.dict(aptpkg.__salt__, {&quot;cmd.run_all&quot;: mock}):
        assert aptpkg.get_repo_keys() == repo_keys_var


def test_file_dict(lowpkg_files_var):
    &quot;&quot;&quot;
    Test - List the files that belong to a package, grouped by package.
    &quot;&quot;&quot;
    mock = MagicMock(return_value=lowpkg_files_var)
    with patch.dict(aptpkg.__salt__, {&quot;lowpkg.file_dict&quot;: mock}):
        assert aptpkg.file_dict(&quot;wget&quot;) == lowpkg_files_var


def test_file_list(lowpkg_files_var):
    &quot;&quot;&quot;
    Test - List the files that belong to a package.
    &quot;&quot;&quot;
    files = {
        &quot;errors&quot;: lowpkg_files_var[&quot;errors&quot;],
        &quot;files&quot;: lowpkg_files_var[&quot;packages&quot;][&quot;wget&quot;],
    }
    mock = MagicMock(return_value=files)
    with patch.dict(aptpkg.__salt__, {&quot;lowpkg.file_list&quot;: mock}):
        assert aptpkg.file_list(&quot;wget&quot;) == files


def test_get_selections():
    &quot;&quot;&quot;
    Test - View package state from the dpkg database.
    &quot;&quot;&quot;
    selections = {&quot;install&quot;: [&quot;wget&quot;]}
    mock = MagicMock(return_value=&quot;wget\t\t\t\t\t\tinstall&quot;)
    with patch.dict(aptpkg.__salt__, {&quot;cmd.run_stdout&quot;: mock}):
        assert aptpkg.get_selections(&quot;wget&quot;) == selections


def test_info_installed(lowpkg_info_var):
    &quot;&quot;&quot;
    Test - Return the information of the named package(s) installed on the system.
    &quot;&quot;&quot;
    names = {&quot;group&quot;: &quot;section&quot;, &quot;packager&quot;: &quot;maintainer&quot;, &quot;url&quot;: &quot;homepage&quot;}

    installed = copy.deepcopy({&quot;wget&quot;: lowpkg_info_var[&quot;wget&quot;]})
    for name in names:
        if installed[&quot;wget&quot;].get(names[name], False):
            installed[&quot;wget&quot;][name] = installed[&quot;wget&quot;].pop(names[name])

    mock = MagicMock(return_value=lowpkg_info_var)
    with patch.dict(aptpkg.__salt__, {&quot;lowpkg.info&quot;: mock}):
        del installed[&quot;wget&quot;][&quot;status&quot;]
        assert aptpkg.info_installed(&quot;wget&quot;) == installed
        assert len(aptpkg.info_installed()) == 1


def test_owner():
    &quot;&quot;&quot;
    Test - Return the name of the package that owns the file.
    &quot;&quot;&quot;
    paths = [&quot;/usr/bin/wget&quot;]
    mock = MagicMock(return_value=&quot;wget: /usr/bin/wget&quot;)
    with patch.dict(aptpkg.__salt__, {&quot;cmd.run_stdout&quot;: mock}):
        assert aptpkg.owner(*paths) == &quot;wget&quot;


def test_refresh_db(apt_q_update_var):
    &quot;&quot;&quot;
    Test - Updates the APT database to latest packages based upon repositories.
    &quot;&quot;&quot;
    refresh_db = {
        &quot;http://security.ubuntu.com trusty-security InRelease&quot;: True,
        &quot;http://security.ubuntu.com trusty-security/main Sources&quot;: True,
        &quot;http://security.ubuntu.com trusty-security/main Translation-en&quot;: None,
        &quot;http://security.ubuntu.com trusty-security/main amd64 Packages&quot;: True,
        &quot;http://security.ubuntu.com trusty-security/main i386 Packages&quot;: True,
    }
    mock = MagicMock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: apt_q_update_var})
    with patch(&quot;salt.utils.pkg.clear_rtag&quot;, MagicMock()):
        with patch.dict(
            aptpkg.__salt__,
            {&quot;cmd.run_all&quot;: mock, &quot;config.get&quot;: MagicMock(return_value=False)},
        ):
            assert aptpkg.refresh_db() == refresh_db


def test_refresh_db_failed(apt_q_update_error_var):
    &quot;&quot;&quot;
    Test - Update the APT database using unreachable repositories.
    &quot;&quot;&quot;
    kwargs = {&quot;failhard&quot;: True}
    mock = MagicMock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: apt_q_update_error_var})
    with patch(&quot;salt.utils.pkg.clear_rtag&quot;, MagicMock()):
        with patch.dict(
            aptpkg.__salt__,
            {&quot;cmd.run_all&quot;: mock, &quot;config.get&quot;: MagicMock(return_value=False)},
        ):
            with pytest.raises(CommandExecutionError):
                aptpkg.refresh_db(**kwargs)


def test_autoremove(packages_var, autoremove_var):
    &quot;&quot;&quot;
    Test - Remove packages not required by another package.
    &quot;&quot;&quot;
    with patch(&quot;salt.modules.aptpkg.list_pkgs&quot;, MagicMock(return_value=packages_var)):
        patch_kwargs = {
            &quot;__salt__&quot;: {
                &quot;config.get&quot;: MagicMock(return_value=True),
                &quot;cmd.run_all&quot;: MagicMock(
                    return_value=MagicMock(return_value=autoremove_var)
                ),
            }
        }
        with patch.multiple(aptpkg, **patch_kwargs):
            assert aptpkg.autoremove() == {}
            assert aptpkg.autoremove(purge=True) == {}
            assert aptpkg.autoremove(list_only=True) == []
            assert aptpkg.autoremove(list_only=True, purge=True) == []


def test_install(install_var):
    &quot;&quot;&quot;
    Test - Install packages.
    &quot;&quot;&quot;
    with patch(&quot;salt.modules.aptpkg.install&quot;, MagicMock(return_value=install_var)):
        assert aptpkg.install(name=&quot;tmux&quot;) == install_var
        kwargs = {&quot;force_conf_new&quot;: True}
        assert aptpkg.install(name=&quot;tmux&quot;, **kwargs) == install_var


def test_remove(uninstall_var):
    &quot;&quot;&quot;
    Test - Remove packages.
    &quot;&quot;&quot;
    with patch(&quot;salt.modules.aptpkg._uninstall&quot;, MagicMock(return_value=uninstall_var)):
        assert aptpkg.remove(name=&quot;tmux&quot;) == uninstall_var


def test_purge(uninstall_var):
    &quot;&quot;&quot;
    Test - Remove packages along with all configuration files.
    &quot;&quot;&quot;
    with patch(&quot;salt.modules.aptpkg._uninstall&quot;, MagicMock(return_value=uninstall_var)):
        assert aptpkg.purge(name=&quot;tmux&quot;) == uninstall_var


def test_upgrade(uninstall_var, upgrade_var):
    &quot;&quot;&quot;
    Test - Upgrades all packages.
    &quot;&quot;&quot;
    with patch(&quot;salt.utils.pkg.clear_rtag&quot;, MagicMock()):
        with patch(
            &quot;salt.modules.aptpkg.list_pkgs&quot;, MagicMock(return_value=uninstall_var)
        ):
            mock_cmd = MagicMock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: upgrade_var})
            patch_kwargs = {
                &quot;__salt__&quot;: {
                    &quot;config.get&quot;: MagicMock(return_value=True),
                    &quot;cmd.run_all&quot;: mock_cmd,
                }
            }
            with patch.multiple(aptpkg, **patch_kwargs):
                assert aptpkg.upgrade() == dict()
                kwargs = {&quot;force_conf_new&quot;: True}
                assert aptpkg.upgrade(**kwargs) == dict()


def test_upgrade_downloadonly(uninstall_var, upgrade_var):
    &quot;&quot;&quot;
    Tests the download-only options for upgrade.
    &quot;&quot;&quot;
    with patch(&quot;salt.utils.pkg.clear_rtag&quot;, MagicMock()):
        with patch(
            &quot;salt.modules.aptpkg.list_pkgs&quot;, MagicMock(return_value=uninstall_var)
        ):
            mock_cmd = MagicMock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: upgrade_var})
            patch_kwargs = {
                &quot;__salt__&quot;: {
                    &quot;config.get&quot;: MagicMock(return_value=True),
                    &quot;cmd.run_all&quot;: mock_cmd,
                },
            }
            with patch.multiple(aptpkg, **patch_kwargs):
                aptpkg.upgrade()
                args_matching = [
                    True
                    for args in patch_kwargs[&quot;__salt__&quot;][&quot;cmd.run_all&quot;].call_args[0]
                    if &quot;--download-only&quot; in args
                ]
                # Here we shouldn't see the parameter and args_matching should be empty.
                assert any(args_matching) is False

                aptpkg.upgrade(downloadonly=True)
                args_matching = [
                    True
                    for args in patch_kwargs[&quot;__salt__&quot;][&quot;cmd.run_all&quot;].call_args[0]
                    if &quot;--download-only&quot; in args
                ]
                # --download-only should be in the args list and we should have at least on True in the list.
                assert any(args_matching) is True

                aptpkg.upgrade(download_only=True)
                args_matching = [
                    True
                    for args in patch_kwargs[&quot;__salt__&quot;][&quot;cmd.run_all&quot;].call_args[0]
                    if &quot;--download-only&quot; in args
                ]
                # --download-only should be in the args list and we should have at least on True in the list.
                assert any(args_matching) is True


def test_upgrade_allow_downgrades(uninstall_var, upgrade_var):
    &quot;&quot;&quot;
    Tests the allow_downgrades option for upgrade.
    &quot;&quot;&quot;
    with patch(&quot;salt.utils.pkg.clear_rtag&quot;, MagicMock()):
        with patch(
            &quot;salt.modules.aptpkg.list_pkgs&quot;, MagicMock(return_value=uninstall_var)
        ):
            mock_cmd = MagicMock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: upgrade_var})
            patch_kwargs = {
                &quot;__salt__&quot;: {
                    &quot;config.get&quot;: MagicMock(return_value=True),
                    &quot;cmd.run_all&quot;: mock_cmd,
                },
            }
            with patch.multiple(aptpkg, **patch_kwargs):
                aptpkg.upgrade()
                args_matching = [
                    True
                    for args in patch_kwargs[&quot;__salt__&quot;][&quot;cmd.run_all&quot;].call_args[0]
                    if &quot;--allow-downgrades&quot; in args
                ]
                # Here we shouldn't see the parameter and args_matching should be empty.
                assert any(args_matching) is False

                aptpkg.upgrade(allow_downgrades=True)
                args_matching = [
                    True
                    for args in patch_kwargs[&quot;__salt__&quot;][&quot;cmd.run_all&quot;].call_args[0]
                    if &quot;--allow-downgrades&quot; in args
                ]
                # --allow-downgrades should be in the args list and we should have at least on True in the list.
                assert any(args_matching) is True


def test_show():
    &quot;&quot;&quot;
    Test that the pkg.show function properly parses apt-cache show output.
    This test uses an abridged output per package, for simplicity.
    &quot;&quot;&quot;
    show_mock_success = MagicMock(
        return_value={
            &quot;retcode&quot;: 0,
            &quot;pid&quot;: 12345,
            &quot;stderr&quot;: &quot;&quot;,
            &quot;stdout&quot;: textwrap.dedent(
                &quot;&quot;&quot;\
            Package: foo1.0
            Architecture: amd64
            Version: 1.0.5-3ubuntu4
            Description: A silly package (1.0 release cycle)
            Provides: foo
            Suggests: foo-doc

            Package: foo1.0
            Architecture: amd64
            Version: 1.0.4-2ubuntu1
            Description: A silly package (1.0 release cycle)
            Provides: foo
            Suggests: foo-doc

            Package: foo-doc
            Architecture: all
            Version: 1.0.5-3ubuntu4
            Description: Silly documentation for a silly package (1.0 release cycle)

            Package: foo-doc
            Architecture: all
            Version: 1.0.4-2ubuntu1
            Description: Silly documentation for a silly package (1.0 release cycle)

            &quot;&quot;&quot;
            ),
        }
    )

    show_mock_failure = MagicMock(
        return_value={
            &quot;retcode&quot;: 1,
            &quot;pid&quot;: 12345,
            &quot;stderr&quot;: textwrap.dedent(
                &quot;&quot;&quot;\
            N: Unable to locate package foo*
            N: Couldn't find any package by glob 'foo*'
            N: Couldn't find any package by regex 'foo*'
            E: No packages found
            &quot;&quot;&quot;
            ),
            &quot;stdout&quot;: &quot;&quot;,
        }
    )

    refresh_mock = Mock()

    expected = {
        &quot;foo1.0&quot;: {
            &quot;1.0.5-3ubuntu4&quot;: {
                &quot;Architecture&quot;: &quot;amd64&quot;,
                &quot;Description&quot;: &quot;A silly package (1.0 release cycle)&quot;,
                &quot;Provides&quot;: &quot;foo&quot;,
                &quot;Suggests&quot;: &quot;foo-doc&quot;,
            },
            &quot;1.0.4-2ubuntu1&quot;: {
                &quot;Architecture&quot;: &quot;amd64&quot;,
                &quot;Description&quot;: &quot;A silly package (1.0 release cycle)&quot;,
                &quot;Provides&quot;: &quot;foo&quot;,
                &quot;Suggests&quot;: &quot;foo-doc&quot;,
            },
        },
        &quot;foo-doc&quot;: {
            &quot;1.0.5-3ubuntu4&quot;: {
                &quot;Architecture&quot;: &quot;all&quot;,
                &quot;Description&quot;: (
                    &quot;Silly documentation for a silly package (1.0 release cycle)&quot;
                ),
            },
            &quot;1.0.4-2ubuntu1&quot;: {
                &quot;Architecture&quot;: &quot;all&quot;,
                &quot;Description&quot;: (
                    &quot;Silly documentation for a silly package (1.0 release cycle)&quot;
                ),
            },
        },
    }

    # Make a copy of the above dict and strip out some keys to produce the
    # expected filtered result.
    filtered = copy.deepcopy(expected)
    for k1 in filtered:
        for k2 in filtered[k1]:
            # Using list() because we will modify the dict during iteration
            for k3 in list(filtered[k1][k2]):
                if k3 not in (&quot;Description&quot;, &quot;Provides&quot;):
                    filtered[k1][k2].pop(k3)

    with patch.dict(aptpkg.__salt__, {&quot;cmd.run_all&quot;: show_mock_success}), patch.object(
        aptpkg, &quot;refresh_db&quot;, refresh_mock
    ):

        # Test success (no refresh)
        assert aptpkg.show(&quot;foo*&quot;) == expected
        refresh_mock.assert_not_called()
        refresh_mock.reset_mock()

        # Test success (with refresh)
        assert aptpkg.show(&quot;foo*&quot;, refresh=True) == expected
        refresh_mock.assert_called_once()
        refresh_mock.reset_mock()

        # Test filtered return
        assert aptpkg.show(&quot;foo*&quot;, filter=&quot;description,provides&quot;) == filtered
        refresh_mock.assert_not_called()
        refresh_mock.reset_mock()

    with patch.dict(aptpkg.__salt__, {&quot;cmd.run_all&quot;: show_mock_failure}), patch.object(
        aptpkg, &quot;refresh_db&quot;, refresh_mock
    ):

        # Test failure (no refresh)
        assert aptpkg.show(&quot;foo*&quot;) == {}
        refresh_mock.assert_not_called()
        refresh_mock.reset_mock()

        # Test failure (with refresh)
        assert aptpkg.show(&quot;foo*&quot;, refresh=True) == {}
        refresh_mock.assert_called_once()
        refresh_mock.reset_mock()


@pytest.mark.skipif(
    not (pathlib.Path(&quot;/etc&quot;) / &quot;apt&quot; / &quot;sources.list&quot;).is_file(),
    reason=&quot;Requires sources.list file&quot;,
)
def test_mod_repo_enabled():
    &quot;&quot;&quot;
    Checks if a repo is enabled or disabled depending on the passed kwargs.
    &quot;&quot;&quot;
    with patch.dict(
        aptpkg.__salt__,
        {&quot;config.option&quot;: MagicMock(), &quot;no_proxy&quot;: MagicMock(return_value=False)},
    ):
        with patch(&quot;salt.modules.aptpkg.refresh_db&quot;, MagicMock(return_value={})):
            with patch(
                &quot;salt.utils.data.is_true&quot;, MagicMock(return_value=True)
            ) as data_is_true:
                with patch(&quot;salt.modules.aptpkg.SourcesList&quot;, MagicMock(), create=True):
                    with patch(
                        &quot;salt.modules.aptpkg.SourceEntry&quot;, MagicMock(), create=True
                    ):
                        repo = aptpkg.mod_repo(&quot;foo&quot;, enabled=False)
                        data_is_true.assert_called_with(False)
                        # with disabled=True; should call salt.utils.data.is_true True
                        data_is_true.reset_mock()
                        repo = aptpkg.mod_repo(&quot;foo&quot;, disabled=True)
                        data_is_true.assert_called_with(True)
                        # with enabled=True; should call salt.utils.data.is_true with False
                        data_is_true.reset_mock()
                        repo = aptpkg.mod_repo(&quot;foo&quot;, enabled=True)
                        data_is_true.assert_called_with(True)
                        # with disabled=True; should call salt.utils.data.is_true False
                        data_is_true.reset_mock()
                        repo = aptpkg.mod_repo(&quot;foo&quot;, disabled=False)
                        data_is_true.assert_called_with(False)


def test_mod_repo_match():
    &quot;&quot;&quot;
    Checks if a repo is matched without taking into account any ending &quot;/&quot; in the uri.
    &quot;&quot;&quot;
    source_type = &quot;deb&quot;
    source_uri = &quot;http://cdn-aws.deb.debian.org/debian/&quot;
    source_line = &quot;deb http://cdn-aws.deb.debian.org/debian/ stretch main\n&quot;

    mock_source = MockSourceEntry(
        source_uri, source_type, source_line, False, &quot;stretch&quot;
    )
    mock_source_list = MockSourceList()
    mock_source_list.list = [mock_source]

    with patch.dict(
        aptpkg.__salt__,
        {&quot;config.option&quot;: MagicMock(), &quot;no_proxy&quot;: MagicMock(return_value=False)},
    ):
        with patch(&quot;salt.modules.aptpkg.refresh_db&quot;, MagicMock(return_value={})):
            with patch(&quot;salt.utils.data.is_true&quot;, MagicMock(return_value=True)):
                with patch(&quot;salt.modules.aptpkg.SourceEntry&quot;, MagicMock(), create=True):
                    with patch(
                        &quot;salt.modules.aptpkg.SourcesList&quot;,
                        MagicMock(return_value=mock_source_list),
                        create=True,
                    ):
                        with patch(
                            &quot;salt.modules.aptpkg._split_repo_str&quot;,
                            MagicMock(
                                return_value=(
                                    &quot;deb&quot;,
                                    [],
                                    &quot;http://cdn-aws.deb.debian.org/debian/&quot;,
                                    &quot;stretch&quot;,
                                    [&quot;main&quot;],
                                )
                            ),
                        ):
                            source_line_no_slash = (
                                &quot;deb http://cdn-aws.deb.debian.org/debian&quot;
                                &quot; stretch main&quot;
                            )
                            repo = aptpkg.mod_repo(source_line_no_slash, enabled=False)
                            assert repo[source_line_no_slash][&quot;uri&quot;] == source_uri


@patch(&quot;salt.utils.path.os_walk&quot;, MagicMock(return_value=[(&quot;test&quot;, &quot;test&quot;, &quot;test&quot;)]))
@patch(&quot;os.path.getsize&quot;, MagicMock(return_value=123456))
<A NAME="3"></A>@patch(&quot;os.path.getctime&quot;, MagicMock(return_value=1234567890.123456))
@patch(
    &quot;fnmatch.filter&quot;,
    MagicMock<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match80632-1.html#3',3,'match80632-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>(return_value=[&quot;/var/cache/apt/archive/test_package.rpm&quot;]),
)
def test_list_downloaded():
    &quot;&quot;&quot;
    Test downloaded packages listing.
    :return:
    &quot;&quot;&quot;
    DOWNLOADED_RET = {
        &quot;test-package&quot;: {
            &quot;1.0&quot;: {
                &quot;path&quot;: &quot;/var/cache/apt/archive/test_package.rpm&quot;,
                &quot;size&quot;: 123456,
                &quot;creation_date_time_t&quot;: 1234567890,
                &quot;creation_date_time&quot;: &quot;2009-02-13T23:31:30&quot;,
            }
        }
    }

    with patch.dict(
        aptpkg.__salt__,
        {
            &quot;lowpkg.bin_pkg_info&quot;</B></FONT>: MagicMock(
                return_value={&quot;name&quot;: &quot;test-package&quot;, &quot;version&quot;: &quot;1.0&quot;}
            )
        },
    ):
        list_downloaded = aptpkg.list_downloaded()
        assert len(list_downloaded) == 1
        assert list_downloaded == DOWNLOADED_RET


def test__skip_source():
    &quot;&quot;&quot;
    Test __skip_source.
    :return:
    &quot;&quot;&quot;
    # Valid source
    source_type = &quot;deb&quot;
    source_uri = &quot;http://cdn-aws.deb.debian.org/debian&quot;
    source_line = &quot;deb http://cdn-aws.deb.debian.org/debian stretch main\n&quot;

    mock_source = MockSourceEntry(source_uri, source_type, source_line, False)

    ret = aptpkg._skip_source(mock_source)
    assert ret is False

    # Invalid source type
    source_type = &quot;ded&quot;
    source_uri = &quot;http://cdn-aws.deb.debian.org/debian&quot;
    source_line = &quot;deb http://cdn-aws.deb.debian.org/debian stretch main\n&quot;

    mock_source = MockSourceEntry(source_uri, source_type, source_line, True)

    ret = aptpkg._skip_source(mock_source)
    assert ret is True

    # Invalid source type , not skipped
    source_type = &quot;deb&quot;
    source_uri = &quot;http://cdn-aws.deb.debian.org/debian&quot;
    source_line = &quot;deb [http://cdn-aws.deb.debian.org/debian] stretch main\n&quot;

    mock_source = MockSourceEntry(source_uri, source_type, source_line, True)

    ret = aptpkg._skip_source(mock_source)
    assert ret is False


def test_normalize_name():
    &quot;&quot;&quot;
    Test that package is normalized only when it should be
    &quot;&quot;&quot;
    with patch.dict(aptpkg.__grains__, {&quot;osarch&quot;: &quot;amd64&quot;}):
        result = aptpkg.normalize_name(&quot;foo&quot;)
        assert result == &quot;foo&quot;, result
        result = aptpkg.normalize_name(&quot;foo:amd64&quot;)
        assert result == &quot;foo&quot;, result
        result = aptpkg.normalize_name(&quot;foo:any&quot;)
        assert result == &quot;foo&quot;, result
        result = aptpkg.normalize_name(&quot;foo:all&quot;)
        assert result == &quot;foo&quot;, result
        result = aptpkg.normalize_name(&quot;foo:i386&quot;)
        assert result == &quot;foo:i386&quot;, result


def test_list_repos():
    &quot;&quot;&quot;
    Checks results from list_repos
    &quot;&quot;&quot;
    # Valid source
    source_type = &quot;deb&quot;
    source_uri = &quot;http://cdn-aws.deb.debian.org/debian/&quot;
    source_line = &quot;deb http://cdn-aws.deb.debian.org/debian/ stretch main\n&quot;

    mock_source = MockSourceEntry(source_uri, source_type, source_line, False)
    mock_source_list = MockSourceList()
    mock_source_list.list = [mock_source]

    with patch(&quot;salt.modules.aptpkg.SourcesList&quot;, MagicMock(), create=True):
        with patch(&quot;salt.modules.aptpkg.SourceEntry&quot;, MagicMock(), create=True):
            with patch(
                &quot;salt.modules.aptpkg.SourcesList&quot;,
                MagicMock(return_value=mock_source_list),
                create=True,
            ):
                repos = aptpkg.list_repos()
                assert source_uri in repos

                assert isinstance(repos[source_uri], list)
                assert len(repos[source_uri]) == 1

                # Make sure last character in of the URI in line is still a /
                assert &quot;line&quot; in repos[source_uri][0]
                _uri = _get_uri(repos[source_uri][0][&quot;line&quot;])
                assert _uri[-1] == &quot;/&quot;

                # Make sure last character in URI is still a /
                assert &quot;uri&quot; in repos[source_uri][0]
                assert repos[source_uri][0][&quot;uri&quot;][-1] == &quot;/&quot;


@pytest.mark.skipif(
    HAS_APTSOURCES is False, reason=&quot;The 'aptsources' library is missing.&quot;
)
def test_expand_repo_def():
    &quot;&quot;&quot;
    Checks results from expand_repo_def
    &quot;&quot;&quot;
    source_type = &quot;deb&quot;
    source_uri = &quot;http://cdn-aws.deb.debian.org/debian/&quot;
    source_line = &quot;deb http://cdn-aws.deb.debian.org/debian/ stretch main\n&quot;
    source_file = &quot;/etc/apt/sources.list&quot;

    # Valid source
    repo = &quot;deb http://cdn-aws.deb.debian.org/debian/ stretch main\n&quot;
    sanitized = aptpkg.expand_repo_def(repo=repo, file=source_file)

    assert isinstance(sanitized, dict)
    assert &quot;uri&quot; in sanitized

    # Make sure last character in of the URI is still a /
    assert sanitized[&quot;uri&quot;][-1] == &quot;/&quot;

    # Pass the architecture and make sure it is added the the line attribute
    repo = &quot;deb http://cdn-aws.deb.debian.org/debian/ stretch main\n&quot;
    sanitized = aptpkg.expand_repo_def(
        repo=repo, file=source_file, architectures=&quot;amd64&quot;
    )

    # Make sure line is in the dict
    assert isinstance(sanitized, dict)
    assert &quot;line&quot; in sanitized

    # Make sure the architecture is in line
    assert (
        sanitized[&quot;line&quot;]
        == &quot;deb [arch=amd64] http://cdn-aws.deb.debian.org/debian/ stretch main&quot;
    )


def test_list_pkgs():
    &quot;&quot;&quot;
    Test packages listing.

    :return:
    &quot;&quot;&quot;

    def _add_data(data, key, value):
        data.setdefault(key, []).append(value)

    apt_out = [
        &quot;install ok installed accountsservice 0.6.55-0ubuntu12~20.04.1 amd64&quot;,
        &quot;install ok installed acpid 1:2.0.32-1ubuntu1 amd64&quot;,
        &quot;install ok installed adduser 3.118ubuntu2 all&quot;,
        &quot;install ok installed alsa-topology-conf 1.2.2-1 all&quot;,
        &quot;install ok installed alsa-ucm-conf 1.2.2-1ubuntu0.4 all&quot;,
        &quot;install ok installed apparmor 2.13.3-7ubuntu5.1 amd64&quot;,
        &quot;install ok installed apport 2.20.11-0ubuntu27.9 all&quot;,
        &quot;install ok installed apport-symptoms 0.23 all&quot;,
        &quot;install ok installed apt 2.0.2ubuntu0.1 amd64&quot;,
<A NAME="2"></A>        &quot;install ok installed apt-utils 2.0.2ubuntu0.1 amd64&quot;,
        &quot;install ok installed at 3.1.23-1ubuntu1 amd64&quot;,
    ]
    with patch.dict(aptpkg<FONT color="#980517"><A HREF="javascript:ZweiFrames('match80632-1.html#2',3,'match80632-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.__grains__, {&quot;osarch&quot;: &quot;x86_64&quot;}), patch.dict(
        aptpkg.__salt__,
        {&quot;cmd.run_stdout&quot;: MagicMock(return_value=os.linesep.join(apt_out))},
    ), patch.</B></FONT>dict(aptpkg.__salt__, {&quot;pkg_resource.add_pkg&quot;: _add_data}), patch.dict(
        aptpkg.__salt__,
        {&quot;pkg_resource.format_pkg_list&quot;: pkg_resource.format_pkg_list},
    ), patch.dict(
        aptpkg.__salt__, {&quot;pkg_resource.sort_pkglist&quot;: pkg_resource.sort_pkglist}
    ):
        pkgs = aptpkg.list_pkgs(versions_as_list=True)
        for pkg_name, pkg_version in {
            &quot;accountsservice&quot;: &quot;0.6.55-0ubuntu12~20.04.1&quot;,
            &quot;acpid&quot;: &quot;1:2.0.32-1ubuntu1&quot;,
            &quot;adduser&quot;: &quot;3.118ubuntu2&quot;,
            &quot;alsa-topology-conf&quot;: &quot;1.2.2-1&quot;,
            &quot;alsa-ucm-conf&quot;: &quot;1.2.2-1ubuntu0.4&quot;,
            &quot;apparmor&quot;: &quot;2.13.3-7ubuntu5.1&quot;,
            &quot;apport&quot;: &quot;2.20.11-0ubuntu27.9&quot;,
            &quot;apport-symptoms&quot;: &quot;0.23&quot;,
            &quot;apt&quot;: &quot;2.0.2ubuntu0.1&quot;,
            &quot;apt-utils&quot;: &quot;2.0.2ubuntu0.1&quot;,
            &quot;at&quot;: &quot;3.1.23-1ubuntu1&quot;,
        }.items():
            assert pkgs[pkg_name] == [pkg_version]


def test_list_pkgs_no_context():
    &quot;&quot;&quot;
    Test packages listing and ensure __context__ for pkg.list_pkgs is absent.

    :return:
    &quot;&quot;&quot;

    def _add_data(data, key, value):
        data.setdefault(key, []).append(value)

    apt_out = [
        &quot;install ok installed accountsservice 0.6.55-0ubuntu12~20.04.1 amd64&quot;,
        &quot;install ok installed acpid 1:2.0.32-1ubuntu1 amd64&quot;,
        &quot;install ok installed adduser 3.118ubuntu2 all&quot;,
        &quot;install ok installed alsa-topology-conf 1.2.2-1 all&quot;,
        &quot;install ok installed alsa-ucm-conf 1.2.2-1ubuntu0.4 all&quot;,
        &quot;install ok installed apparmor 2.13.3-7ubuntu5.1 amd64&quot;,
        &quot;install ok installed apport 2.20.11-0ubuntu27.9 all&quot;,
        &quot;install ok installed apport-symptoms 0.23 all&quot;,
        &quot;install ok installed apt 2.0.2ubuntu0.1 amd64&quot;,
        &quot;install ok installed apt-utils 2.0.2ubuntu0.1 amd64&quot;,
        &quot;install ok installed at 3.1.23-1ubuntu1 amd64&quot;,
<A NAME="1"></A>    ]
    with patch.dict(aptpkg.__grains__, {&quot;osarch&quot;: &quot;x86_64&quot;}), patch.dict(
        aptpkg.__salt__,
        {&quot;cmd.run_stdout&quot;: MagicMock(return_value<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match80632-1.html#1',3,'match80632-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>=os.linesep.join(apt_out))},
    ), patch.dict(aptpkg.__salt__, {&quot;pkg_resource.add_pkg&quot;: _add_data}), patch.dict(
        aptpkg.__salt__,
        {&quot;pkg_resource.format_pkg_list&quot;</B></FONT>: pkg_resource.format_pkg_list},
    ), patch.dict(
        aptpkg.__salt__, {&quot;pkg_resource.sort_pkglist&quot;: pkg_resource.sort_pkglist}
    ), patch.object(
        aptpkg, &quot;_list_pkgs_from_context&quot;
    ) as list_pkgs_context_mock:
        pkgs = aptpkg.list_pkgs(versions_as_list=True, use_context=False)
        list_pkgs_context_mock.assert_not_called()
        list_pkgs_context_mock.reset_mock()

        pkgs = aptpkg.list_pkgs(versions_as_list=True, use_context=False)
        list_pkgs_context_mock.assert_not_called()
        list_pkgs_context_mock.reset_mock()


def test_call_apt_default():
    &quot;&quot;&quot;
    Call default apt.
    :return:
    &quot;&quot;&quot;
    with patch.dict(
        aptpkg.__salt__,
        {&quot;cmd.run_all&quot;: MagicMock(), &quot;config.get&quot;: MagicMock(return_value=False)},
    ):
        aptpkg._call_apt([&quot;apt-get&quot;, &quot;install&quot;, &quot;emacs&quot;])  # pylint: disable=W0106
        aptpkg.__salt__[&quot;cmd.run_all&quot;].assert_called_once_with(
            [&quot;apt-get&quot;, &quot;install&quot;, &quot;emacs&quot;],
            env={},
            output_loglevel=&quot;trace&quot;,
            python_shell=False,
        )


@patch(&quot;salt.utils.systemd.has_scope&quot;, MagicMock(return_value=True))
def test_call_apt_in_scope():
    &quot;&quot;&quot;
    Call apt within the scope.
    :return:
    &quot;&quot;&quot;
    with patch.dict(
        aptpkg.__salt__,
        {&quot;cmd.run_all&quot;: MagicMock(), &quot;config.get&quot;: MagicMock(return_value=True)},
    ):
        aptpkg._call_apt([&quot;apt-get&quot;, &quot;purge&quot;, &quot;vim&quot;])  # pylint: disable=W0106
        aptpkg.__salt__[&quot;cmd.run_all&quot;].assert_called_once_with(
            [
                &quot;systemd-run&quot;,
                &quot;--scope&quot;,
                &quot;--description&quot;,
                '&quot;salt.modules.aptpkg&quot;',
                &quot;apt-get&quot;,
                &quot;purge&quot;,
                &quot;vim&quot;,
            ],
            env={},
            output_loglevel=&quot;trace&quot;,
            python_shell=False,
        )


def test_call_apt_with_kwargs():
    &quot;&quot;&quot;
    Call apt with the optinal keyword arguments.
    :return:
    &quot;&quot;&quot;
    with patch.dict(
        aptpkg.__salt__,
        {&quot;cmd.run_all&quot;: MagicMock(), &quot;config.get&quot;: MagicMock(return_value=False)},
    ):
        aptpkg._call_apt(
            [&quot;dpkg&quot;, &quot;-l&quot;, &quot;python&quot;],
            python_shell=True,
            output_loglevel=&quot;quiet&quot;,
            ignore_retcode=False,
            username=&quot;Darth Vader&quot;,
        )  # pylint: disable=W0106
        aptpkg.__salt__[&quot;cmd.run_all&quot;].assert_called_once_with(
            [&quot;dpkg&quot;, &quot;-l&quot;, &quot;python&quot;],
            env={},
            ignore_retcode=False,
            output_loglevel=&quot;quiet&quot;,
            python_shell=True,
            username=&quot;Darth Vader&quot;,
        )


def test_call_apt_dpkg_lock():
    &quot;&quot;&quot;
    Call apt and ensure the dpkg locking is handled
    :return:
    &quot;&quot;&quot;
    cmd_side_effect = [
        {&quot;stderr&quot;: &quot;Could not get lock&quot;},
        {&quot;stderr&quot;: &quot;Could not get lock&quot;},
        {&quot;stderr&quot;: &quot;Could not get lock&quot;},
        {&quot;stderr&quot;: &quot;Could not get lock&quot;},
        {&quot;stderr&quot;: &quot;&quot;, &quot;stdout&quot;: &quot;&quot;},
    ]

    cmd_mock = MagicMock(side_effect=cmd_side_effect)
    cmd_call = (
        call(
            [&quot;dpkg&quot;, &quot;-l&quot;, &quot;python&quot;],
            env={},
            ignore_retcode=False,
            output_loglevel=&quot;quiet&quot;,
            python_shell=True,
            username=&quot;Darth Vader&quot;,
        ),
    )
    expected_calls = [cmd_call * 5]

    with patch.dict(
        aptpkg.__salt__,
        {&quot;cmd.run_all&quot;: cmd_mock, &quot;config.get&quot;: MagicMock(return_value=False)},
    ):
        with patch(&quot;salt.modules.aptpkg.time.sleep&quot;, MagicMock()) as sleep_mock:
            aptpkg._call_apt(
                [&quot;dpkg&quot;, &quot;-l&quot;, &quot;python&quot;],
                python_shell=True,
                output_loglevel=&quot;quiet&quot;,
                ignore_retcode=False,
                username=&quot;Darth Vader&quot;,
            )  # pylint: disable=W0106

            # We should have sleept at least 4 times
            assert sleep_mock.call_count &gt;= 4

            # We should attempt to call the cmd 5 times
            assert cmd_mock.call_count == 5
            cmd_mock.has_calls(expected_calls)


def test_services_need_restart_checkrestart_missing():
    &quot;&quot;&quot;Test that the user is informed about the required dependency.&quot;&quot;&quot;

    with patch(&quot;salt.utils.path.which_bin&quot;, Mock(return_value=None)):
        with pytest.raises(CommandNotFoundError):
            aptpkg.services_need_restart()


@patch(&quot;salt.utils.path.which_bin&quot;, Mock(return_value=&quot;/usr/sbin/checkrestart&quot;))
def test_services_need_restart():
    &quot;&quot;&quot;
    Test that checkrestart output is parsed correctly
    &quot;&quot;&quot;
    cr_output = &quot;&quot;&quot;
PROCESSES: 24
PROGRAMS: 17
PACKAGES: 8
SERVICE:rsyslog,385,/usr/sbin/rsyslogd
SERVICE:cups-daemon,390,/usr/sbin/cupsd
    &quot;&quot;&quot;

    with patch.dict(aptpkg.__salt__, {&quot;cmd.run_stdout&quot;: Mock(return_value=cr_output)}):
        assert sorted(aptpkg.services_need_restart()) == [
            &quot;cups-daemon&quot;,
            &quot;rsyslog&quot;,
        ]


@pytest.mark.skipif(
    HAS_APTSOURCES is True, reason=&quot;Only run test with python3-apt library is missing.&quot;
)
def test_sourceslist_multiple_comps():
    &quot;&quot;&quot;
    Test SourcesList when repo has multiple comps
    &quot;&quot;&quot;
    repo_line = &quot;deb http://archive.ubuntu.com/ubuntu/ focal-updates main restricted&quot;
    with patch.object(aptpkg, &quot;HAS_APT&quot;, return_value=True):
        with patch(&quot;salt.utils.files.fopen&quot;, mock_open(read_data=repo_line)):
            with patch(&quot;pathlib.Path.is_file&quot;, side_effect=[True, False]):
                sources = aptpkg.SourcesList()
                for source in sources:
                    assert source.type == &quot;deb&quot;
                    assert source.uri == &quot;http://archive.ubuntu.com/ubuntu/&quot;
                    assert source.comps == [&quot;main&quot;, &quot;restricted&quot;]
                    assert source.dist == &quot;focal-updates&quot;


@pytest.mark.skipif(
    HAS_APTSOURCES is True, reason=&quot;Only run test with python3-apt library is missing.&quot;
)
@pytest.mark.parametrize(
    &quot;repo_line&quot;,
    [
        &quot;deb [ arch=amd64 ] http://archive.ubuntu.com/ubuntu/ focal-updates main restricted&quot;,
        &quot;deb [arch=amd64 ] http://archive.ubuntu.com/ubuntu/ focal-updates main restricted&quot;,
        &quot;deb [arch=amd64 test=one ] http://archive.ubuntu.com/ubuntu/ focal-updates main restricted&quot;,
        &quot;deb [arch=amd64,armel test=one ] http://archive.ubuntu.com/ubuntu/ focal-updates main restricted&quot;,
        &quot;deb [ arch=amd64,armel test=one ] http://archive.ubuntu.com/ubuntu/ focal-updates main restricted&quot;,
        &quot;deb [ arch=amd64,armel test=one] http://archive.ubuntu.com/ubuntu/ focal-updates main restricted&quot;,
        &quot;deb [arch=amd64] http://archive.ubuntu.com/ubuntu/ focal-updates main restricted&quot;,
    ],
)
def test_sourceslist_architectures(repo_line):
    &quot;&quot;&quot;
    Test SourcesList when architectures is in repo
    &quot;&quot;&quot;
    with patch(&quot;salt.utils.files.fopen&quot;, mock_open(read_data=repo_line)):
        with patch(&quot;pathlib.Path.is_file&quot;, side_effect=[True, False]):
            sources = aptpkg.SourcesList()
            for source in sources:
                assert source.type == &quot;deb&quot;
                assert source.uri == &quot;http://archive.ubuntu.com/ubuntu/&quot;
                assert source.comps == [&quot;main&quot;, &quot;restricted&quot;]
                assert source.dist == &quot;focal-updates&quot;
                if &quot;,&quot; in repo_line:
                    assert source.architectures == [&quot;amd64&quot;, &quot;armel&quot;]
                else:
                    assert source.architectures == [&quot;amd64&quot;]
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_thin_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
    :codeauthor: :email:`Bo Maryniuk &lt;bo@suse.de&gt;`
&quot;&quot;&quot;

import copy
import os
import pathlib
import shutil
import sys
import tarfile
import tempfile

<A NAME="4"></A>import jinja2
import pytest
import salt.exceptions
<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match80632-0.html#4',2,'match80632-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import salt.utils.hashutils
import salt.utils.json
import salt.utils.platform
import salt.utils.stringutils
from salt.utils import thin
from salt.utils.stringutils import to_bytes as bts
from tests.support.helpers import TstSuiteLoggingHandler, VirtualEnv
from tests.support.mock import MagicMock, patch
from tests.support.runtests import RUNTIME_VARS
from tests.support.unit import TestCase, skipIf

try:
    import</B></FONT> pytest
except ImportError:
    pytest = None


def patch_if(condition, *args, **kwargs):
    &quot;&quot;&quot;
    Return a patch decorator if the provided condition is met
    &quot;&quot;&quot;
    if condition:
        return patch(*args, **kwargs)

    def inner(func):
        return func

    return inner


@skipIf(pytest is None, &quot;PyTest is missing&quot;)
class SSHThinTestCase(TestCase):
    &quot;&quot;&quot;
    TestCase for SaltSSH-related parts.
    &quot;&quot;&quot;

    def setUp(self):
        self.jinja_fp = os.path.dirname(jinja2.__file__)

        self.ext_conf = {
            &quot;test&quot;: {
                &quot;py-version&quot;: [2, 7],
                &quot;path&quot;: RUNTIME_VARS.SALT_CODE_DIR,
                &quot;dependencies&quot;: {&quot;jinja2&quot;: self.jinja_fp},
            }
        }
        self.tops = copy.deepcopy(self.ext_conf)
        self.tops[&quot;test&quot;][&quot;dependencies&quot;] = [self.jinja_fp]
<A NAME="2"></A>        self.tar = self._tarfile(None).open()
        self.digest = salt.utils.hashutils.DigestCollector()
        self.exp_files = [
            <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match80632-0.html#2',2,'match80632-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>os.path.join(&quot;salt&quot;, &quot;payload.py&quot;),
            os.path.join(&quot;jinja2&quot;, &quot;__init__.py&quot;),
        ]
        lib_root = os.path.join(RUNTIME_VARS.</B></FONT>TMP, &quot;fake-libs&quot;)
        self.fake_libs = {
            &quot;distro&quot;: os.path.join(lib_root, &quot;distro&quot;),
            &quot;jinja2&quot;: os.path.join(lib_root, &quot;jinja2&quot;),
            &quot;yaml&quot;: os.path.join(lib_root, &quot;yaml&quot;),
            &quot;tornado&quot;: os.path.join(lib_root, &quot;tornado&quot;),
            &quot;msgpack&quot;: os.path.join(lib_root, &quot;msgpack&quot;),
        }

        code_dir = pathlib.Path(RUNTIME_VARS.CODE_DIR).resolve()
        self.exp_ret = {
            &quot;distro&quot;: str(code_dir / &quot;distro.py&quot;),
            &quot;jinja2&quot;: str(code_dir / &quot;jinja2&quot;),
            &quot;yaml&quot;: str(code_dir / &quot;yaml&quot;),
            &quot;tornado&quot;: str(code_dir / &quot;tornado&quot;),
            &quot;msgpack&quot;: str(code_dir / &quot;msgpack&quot;),
            &quot;certifi&quot;: str(code_dir / &quot;certifi&quot;),
            &quot;singledispatch&quot;: str(code_dir / &quot;singledispatch.py&quot;),
        }
        self.exc_libs = [&quot;jinja2&quot;, &quot;yaml&quot;]

    def tearDown(self):
<A NAME="0"></A>        for lib, fp in self.fake_libs.items():
            if os.path.exists(fp):
                shutil.rmtree(fp)
        self<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match80632-0.html#0',2,'match80632-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.exc_libs = None
        self.jinja_fp = None
        self.ext_conf = None
        self.tops = None
        self.tar = None
        self.digest = None
        self.exp_files = None
        self.fake_libs = None
        self.exp_ret = None

    def</B></FONT> _popen(self, return_value=None, side_effect=None, returncode=0):
        &quot;&quot;&quot;
        Fake subprocess.Popen

        :return:
        &quot;&quot;&quot;

        proc = MagicMock()
        proc.communicate = MagicMock(return_value=return_value, side_effect=side_effect)
        proc.returncode = returncode
        popen = MagicMock(return_value=proc)

        return popen

    def _version_info(self, major=None, minor=None):
        &quot;&quot;&quot;
        Fake version info.

        :param major:
        :param minor:
        :return:
        &quot;&quot;&quot;

        class VersionInfo(tuple):
            pass

        vi = VersionInfo([major, minor])
        vi.major = major or sys.version_info.major
        vi.minor = minor or sys.version_info.minor

        return vi

    def _tarfile(self, getinfo=False):
        &quot;&quot;&quot;
        Fake tarfile handler.

        :return:
        &quot;&quot;&quot;
        spec = [&quot;add&quot;, &quot;close&quot;]
        if getinfo:
            spec.append(&quot;getinfo&quot;)

        tf = MagicMock()
        tf.open = MagicMock(return_value=MagicMock(spec=spec))

<A NAME="3"></A>        return tf

    @patch(&quot;salt.utils.thin.log&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.path.isfile&quot;, MagicMock<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match80632-0.html#3',2,'match80632-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>(return_value=False))
    def test_get_ext_tops_cfg_missing_dependencies(self):
        &quot;&quot;&quot;
        Test thin.get_ext_tops contains all required dependencies.

        :return:
        &quot;&quot;&quot;
        cfg = {&quot;namespace&quot;: {&quot;py-version&quot;: [0, 0], &quot;path&quot;: &quot;/foo&quot;, &quot;dependencies&quot;: []}}

        with pytest.raises(salt.exceptions.</B></FONT>SaltSystemExit) as err:
            thin.get_ext_tops(cfg)
        self.assertIn(&quot;Missing dependencies&quot;, str(err.value))
        self.assertTrue(thin.log.error.called)
        self.assertIn(&quot;Missing dependencies&quot;, thin.log.error.call_args[0][0])
        self.assertIn(&quot;jinja2, yaml, tornado, msgpack&quot;, thin.log.error.call_args[0][0])

    @patch(&quot;salt.exceptions.SaltSystemExit&quot;, Exception)
    @patch(&quot;salt.utils.thin.log&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.path.isfile&quot;, MagicMock(return_value=False))
    def test_get_ext_tops_cfg_missing_interpreter(self):
        &quot;&quot;&quot;
        Test thin.get_ext_tops contains interpreter configuration.

        :return:
        &quot;&quot;&quot;
        cfg = {&quot;namespace&quot;: {&quot;path&quot;: &quot;/foo&quot;, &quot;dependencies&quot;: []}}
        with pytest.raises(salt.exceptions.SaltSystemExit) as err:
            thin.get_ext_tops(cfg)
        self.assertIn(&quot;missing specific locked Python version&quot;, str(err.value))

    @patch(&quot;salt.exceptions.SaltSystemExit&quot;, Exception)
    @patch(&quot;salt.utils.thin.log&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.path.isfile&quot;, MagicMock(return_value=False))
    def test_get_ext_tops_cfg_wrong_interpreter(self):
        &quot;&quot;&quot;
        Test thin.get_ext_tops contains correct interpreter configuration.

        :return:
        &quot;&quot;&quot;
        cfg = {&quot;namespace&quot;: {&quot;path&quot;: &quot;/foo&quot;, &quot;py-version&quot;: 2, &quot;dependencies&quot;: []}}

        with pytest.raises(salt.exceptions.SaltSystemExit) as err:
            thin.get_ext_tops(cfg)
        self.assertIn(
            &quot;specific locked Python version should be a list of major/minor version&quot;,
            str(err.value),
        )

    @patch(&quot;salt.exceptions.SaltSystemExit&quot;, Exception)
    @patch(&quot;salt.utils.thin.log&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.path.isfile&quot;, MagicMock(return_value=False))
    def test_get_ext_tops_cfg_interpreter(self):
        &quot;&quot;&quot;
        Test thin.get_ext_tops interpreter configuration.

        :return:
        &quot;&quot;&quot;
        cfg = {
            &quot;namespace&quot;: {
                &quot;path&quot;: &quot;/foo&quot;,
                &quot;py-version&quot;: [2, 6],
                &quot;dependencies&quot;: {
                    &quot;jinja2&quot;: &quot;&quot;,
                    &quot;yaml&quot;: &quot;&quot;,
                    &quot;tornado&quot;: &quot;&quot;,
                    &quot;msgpack&quot;: &quot;&quot;,
                },
            }
        }

        with pytest.raises(salt.exceptions.SaltSystemExit):
            thin.get_ext_tops(cfg)
        assert len(thin.log.warning.mock_calls) == 4
        assert sorted(x[1][1] for x in thin.log.warning.mock_calls) == [
            &quot;jinja2&quot;,
            &quot;msgpack&quot;,
            &quot;tornado&quot;,
            &quot;yaml&quot;,
        ]
        assert (
            &quot;Module test has missing configuration&quot;
            == thin.log.warning.mock_calls[0][1][0] % &quot;test&quot;
        )

    @patch(&quot;salt.utils.thin.log&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.path.isfile&quot;, MagicMock(return_value=False))
    def test_get_ext_tops_dependency_config_check(self):
        &quot;&quot;&quot;
        Test thin.get_ext_tops dependencies are importable

        :return:
        &quot;&quot;&quot;
        cfg = {
            &quot;namespace&quot;: {
                &quot;path&quot;: &quot;/foo&quot;,
                &quot;py-version&quot;: [2, 6],
                &quot;dependencies&quot;: {
                    &quot;jinja2&quot;: &quot;/jinja/foo.py&quot;,
                    &quot;yaml&quot;: &quot;/yaml/&quot;,
                    &quot;tornado&quot;: &quot;/tornado/wrong.rb&quot;,
                    &quot;msgpack&quot;: &quot;msgpack.sh&quot;,
                },
            }
        }

        with pytest.raises(salt.exceptions.SaltSystemExit) as err:
            thin.get_ext_tops(cfg)

        self.assertIn(
            &quot;Missing dependencies for the alternative version in the &quot;
            &quot;external configuration&quot;,
            str(err.value),
        )

        messages = {}
        for cl in thin.log.warning.mock_calls:
            messages[cl[1][1]] = cl[1][0] % (cl[1][1], cl[1][2])
        for mod in [&quot;tornado&quot;, &quot;yaml&quot;, &quot;msgpack&quot;]:
            self.assertIn(&quot;not a Python importable module&quot;, messages[mod])
        self.assertIn(
            &quot;configured with not a file or does not exist&quot;, messages[&quot;jinja2&quot;]
        )

    @patch(&quot;salt.exceptions.SaltSystemExit&quot;, Exception)
    @patch(&quot;salt.utils.thin.log&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.path.isfile&quot;, MagicMock(return_value=True))
    def test_get_ext_tops_config_pass(self):
        &quot;&quot;&quot;
        Test thin.get_ext_tops configuration

        :return:
        &quot;&quot;&quot;
        cfg = {
            &quot;namespace&quot;: {
                &quot;path&quot;: &quot;/foo&quot;,
                &quot;py-version&quot;: [2, 6],
                &quot;dependencies&quot;: {
                    &quot;jinja2&quot;: &quot;/jinja/foo.py&quot;,
                    &quot;yaml&quot;: &quot;/yaml/&quot;,
                    &quot;tornado&quot;: &quot;/tornado/tornado.py&quot;,
                    &quot;msgpack&quot;: &quot;msgpack.py&quot;,
                    &quot;distro&quot;: &quot;distro.py&quot;,
                },
            }
        }
        out = thin.get_ext_tops(cfg)
        assert out[&quot;namespace&quot;][&quot;py-version&quot;] == cfg[&quot;namespace&quot;][&quot;py-version&quot;]
        assert out[&quot;namespace&quot;][&quot;path&quot;] == cfg[&quot;namespace&quot;][&quot;path&quot;]
        assert sorted(out[&quot;namespace&quot;][&quot;dependencies&quot;]) == sorted(
            [
                &quot;/tornado/tornado.py&quot;,
                &quot;/jinja/foo.py&quot;,
                &quot;/yaml/&quot;,
                &quot;msgpack.py&quot;,
                &quot;distro.py&quot;,
            ]
        )

    @patch(&quot;salt.utils.thin.sys.argv&quot;, [None, '{&quot;foo&quot;: &quot;bar&quot;}'])
    @patch(&quot;salt.utils.thin.get_tops&quot;, lambda **kw: kw)
    def test_gte(self):
        &quot;&quot;&quot;
        Test thin.gte external call for processing the info about tops per interpreter.

        :return:
        &quot;&quot;&quot;
        assert salt.utils.json.loads(thin.gte()).get(&quot;foo&quot;) == &quot;bar&quot;

    def test_add_dep_path(self):
        &quot;&quot;&quot;
        Test thin._add_dependency function to setup dependency paths
        :return:
        &quot;&quot;&quot;
        container = []
        for pth in [&quot;/foo/bar.py&quot;, &quot;/something/else/__init__.py&quot;]:
            thin._add_dependency(container, type(&quot;obj&quot;, (), {&quot;__file__&quot;: pth})())
        assert &quot;__init__&quot; not in container[1]
        assert container == [&quot;/foo/bar.py&quot;, &quot;/something/else&quot;]

    def test_thin_path(self):
        &quot;&quot;&quot;
        Test thin.thin_path returns the expected path.

        :return:
        &quot;&quot;&quot;
        path = os.sep + os.path.join(&quot;path&quot;, &quot;to&quot;)
        expected = os.path.join(path, &quot;thin&quot;, &quot;thin.tgz&quot;)
        self.assertEqual(thin.thin_path(path), expected)

    def test_get_salt_call_script(self):
        &quot;&quot;&quot;
        Test get salt-call script rendered.

        :return:
        &quot;&quot;&quot;
        out = thin._get_salt_call(&quot;foo&quot;, &quot;bar&quot;, py26=[2, 6], py27=[2, 7], py34=[3, 4])
        for line in salt.utils.stringutils.to_str(out).split(os.linesep):
            if line.startswith(&quot;namespaces = {&quot;):
                data = salt.utils.json.loads(line.replace(&quot;namespaces = &quot;, &quot;&quot;).strip())
                assert data.get(&quot;py26&quot;) == [2, 6]
                assert data.get(&quot;py27&quot;) == [2, 7]
                assert data.get(&quot;py34&quot;) == [3, 4]
            if line.startswith(&quot;syspaths = &quot;):
                data = salt.utils.json.loads(line.replace(&quot;syspaths = &quot;, &quot;&quot;))
                assert data == [&quot;foo&quot;, &quot;bar&quot;]

    def test_get_ext_namespaces_empty(self):
        &quot;&quot;&quot;
        Test thin._get_ext_namespaces function returns an empty dictionary on nothing
        :return:
        &quot;&quot;&quot;
        for obj in [None, {}, []]:
            assert thin._get_ext_namespaces(obj) == {}

    def test_get_ext_namespaces(self):
        &quot;&quot;&quot;
        Test thin._get_ext_namespaces function returns namespaces properly out of the config.
        :return:
        &quot;&quot;&quot;
        cfg = {&quot;ns&quot;: {&quot;py-version&quot;: [2, 7]}}
        assert thin._get_ext_namespaces(cfg).get(&quot;ns&quot;) == (
            2,
            7,
        )
        assert isinstance(thin._get_ext_namespaces(cfg).get(&quot;ns&quot;), tuple)

    def test_get_ext_namespaces_failure(self):
        &quot;&quot;&quot;
        Test thin._get_ext_namespaces function raises an exception
        if python major/minor version is not configured.
        :return:
        &quot;&quot;&quot;
        with pytest.raises(salt.exceptions.SaltSystemExit):
            thin._get_ext_namespaces({&quot;ns&quot;: {}})

    @patch(
        &quot;salt.utils.thin.distro&quot;,
        type(&quot;distro&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/distro&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.salt&quot;,
        type(&quot;salt&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/salt&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.jinja2&quot;,
        type(&quot;jinja2&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/jinja2&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.yaml&quot;,
        type(&quot;yaml&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/yaml&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.tornado&quot;,
        type(&quot;tornado&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/tornado&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.msgpack&quot;,
        type(&quot;msgpack&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/msgpack&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.certifi&quot;,
        type(&quot;certifi&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/certifi&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.singledispatch&quot;,
        type(&quot;singledispatch&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/sdp&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.singledispatch_helpers&quot;,
        type(&quot;singledispatch_helpers&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/sdp_hlp&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.ssl_match_hostname&quot;,
        type(&quot;ssl_match_hostname&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/ssl_mh&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.markupsafe&quot;,
        type(&quot;markupsafe&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/markupsafe&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.backports_abc&quot;,
        type(&quot;backports_abc&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/backports_abc&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.concurrent&quot;,
        type(&quot;concurrent&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/concurrent&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.py_contextvars&quot;,
        type(&quot;contextvars&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/contextvars&quot;}),
    )
    @patch_if(
        salt.utils.thin.has_immutables,
        &quot;salt.utils.thin.immutables&quot;,
        type(&quot;immutables&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/immutables&quot;}),
    )
    @patch(&quot;salt.utils.thin.log&quot;, MagicMock())
    def test_get_tops(self):
        &quot;&quot;&quot;
        Test thin.get_tops to get top directories, based on the interpreter.
        :return:
        &quot;&quot;&quot;
        base_tops = [
            &quot;distro&quot;,
            &quot;salt&quot;,
            &quot;jinja2&quot;,
            &quot;yaml&quot;,
            &quot;tornado&quot;,
            &quot;msgpack&quot;,
            &quot;certifi&quot;,
            &quot;sdp&quot;,
            &quot;sdp_hlp&quot;,
            &quot;ssl_mh&quot;,
            &quot;markupsafe&quot;,
            &quot;backports_abc&quot;,
            &quot;concurrent&quot;,
            &quot;contextvars&quot;,
        ]
        if salt.utils.thin.has_immutables:
            base_tops.extend([&quot;immutables&quot;])
        tops = []
        for top in thin.get_tops(extra_mods=&quot;foo,bar&quot;):
            if top.find(&quot;/&quot;) != -1:
                spl = &quot;/&quot;
            else:
                spl = os.sep
            tops.append(top.rsplit(spl, 1)[-1])
        assert len(tops) == len(base_tops)
        assert sorted(tops) == sorted(base_tops), sorted(tops)

    @patch(
        &quot;salt.utils.thin.distro&quot;,
        type(&quot;distro&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/distro&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.salt&quot;,
        type(&quot;salt&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/salt&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.jinja2&quot;,
        type(&quot;jinja2&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/jinja2&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.yaml&quot;,
        type(&quot;yaml&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/yaml&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.tornado&quot;,
        type(&quot;tornado&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/tornado&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.msgpack&quot;,
        type(&quot;msgpack&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/msgpack&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.certifi&quot;,
        type(&quot;certifi&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/certifi&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.singledispatch&quot;,
        type(&quot;singledispatch&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/sdp&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.singledispatch_helpers&quot;,
        type(&quot;singledispatch_helpers&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/sdp_hlp&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.ssl_match_hostname&quot;,
        type(&quot;ssl_match_hostname&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/ssl_mh&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.markupsafe&quot;,
        type(&quot;markupsafe&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/markupsafe&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.backports_abc&quot;,
        type(&quot;backports_abc&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/backports_abc&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.concurrent&quot;,
        type(&quot;concurrent&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/concurrent&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.py_contextvars&quot;,
        type(&quot;contextvars&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/contextvars&quot;}),
    )
    @patch_if(
        salt.utils.thin.has_immutables,
        &quot;salt.utils.thin.immutables&quot;,
        type(&quot;immutables&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/immutables&quot;}),
    )
    @patch(&quot;salt.utils.thin.log&quot;, MagicMock())
    def test_get_tops_extra_mods(self):
        &quot;&quot;&quot;
        Test thin.get_tops to get extra-modules alongside the top directories, based on the interpreter.
        :return:
        &quot;&quot;&quot;
        base_tops = [
            &quot;distro&quot;,
            &quot;salt&quot;,
            &quot;jinja2&quot;,
            &quot;yaml&quot;,
            &quot;tornado&quot;,
            &quot;msgpack&quot;,
            &quot;certifi&quot;,
            &quot;sdp&quot;,
            &quot;sdp_hlp&quot;,
            &quot;ssl_mh&quot;,
            &quot;concurrent&quot;,
            &quot;markupsafe&quot;,
            &quot;backports_abc&quot;,
            &quot;contextvars&quot;,
            &quot;foo&quot;,
            &quot;bar.py&quot;,
        ]
        if salt.utils.thin.has_immutables:
            base_tops.extend([&quot;immutables&quot;])
        libs = salt.utils.thin.find_site_modules(&quot;contextvars&quot;)
        foo = {&quot;__file__&quot;: os.sep + os.path.join(&quot;custom&quot;, &quot;foo&quot;, &quot;__init__.py&quot;)}
        bar = {&quot;__file__&quot;: os.sep + os.path.join(&quot;custom&quot;, &quot;bar&quot;)}
        with patch(&quot;salt.utils.thin.find_site_modules&quot;, MagicMock(side_effect=[libs])):
            with patch(
                &quot;builtins.__import__&quot;,
                MagicMock(side_effect=[type(&quot;foo&quot;, (), foo), type(&quot;bar&quot;, (), bar)]),
            ):
                tops = []
                for top in thin.get_tops(extra_mods=&quot;foo,bar&quot;):
                    if top.find(&quot;/&quot;) != -1:
                        spl = &quot;/&quot;
                    else:
                        spl = os.sep
                    tops.append(top.rsplit(spl, 1)[-1])
        self.assertEqual(len(tops), len(base_tops))
        self.assertListEqual(sorted(tops), sorted(base_tops))

    @patch(
        &quot;salt.utils.thin.distro&quot;,
        type(&quot;distro&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/distro&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.salt&quot;,
        type(&quot;salt&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/salt&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.jinja2&quot;,
        type(&quot;jinja2&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/jinja2&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.yaml&quot;,
        type(&quot;yaml&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/yaml&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.tornado&quot;,
        type(&quot;tornado&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/tornado&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.msgpack&quot;,
        type(&quot;msgpack&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/msgpack&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.certifi&quot;,
        type(&quot;certifi&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/certifi&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.singledispatch&quot;,
        type(&quot;singledispatch&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/sdp&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.singledispatch_helpers&quot;,
        type(&quot;singledispatch_helpers&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/sdp_hlp&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.ssl_match_hostname&quot;,
        type(&quot;ssl_match_hostname&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/ssl_mh&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.markupsafe&quot;,
        type(&quot;markupsafe&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/markupsafe&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.backports_abc&quot;,
        type(&quot;backports_abc&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/backports_abc&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.concurrent&quot;,
        type(&quot;concurrent&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/concurrent&quot;}),
    )
    @patch(
        &quot;salt.utils.thin.py_contextvars&quot;,
        type(&quot;contextvars&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/contextvars&quot;}),
    )
    @patch_if(
        salt.utils.thin.has_immutables,
        &quot;salt.utils.thin.immutables&quot;,
        type(&quot;immutables&quot;, (), {&quot;__file__&quot;: &quot;/site-packages/immutables&quot;}),
    )
    @patch(&quot;salt.utils.thin.log&quot;, MagicMock())
    def test_get_tops_so_mods(self):
        &quot;&quot;&quot;
        Test thin.get_tops to get extra-modules alongside the top directories, based on the interpreter.
        :return:
        &quot;&quot;&quot;
        base_tops = [
            &quot;distro&quot;,
            &quot;salt&quot;,
            &quot;jinja2&quot;,
            &quot;yaml&quot;,
            &quot;tornado&quot;,
            &quot;msgpack&quot;,
            &quot;certifi&quot;,
            &quot;sdp&quot;,
            &quot;sdp_hlp&quot;,
            &quot;ssl_mh&quot;,
            &quot;concurrent&quot;,
            &quot;markupsafe&quot;,
            &quot;backports_abc&quot;,
            &quot;contextvars&quot;,
            &quot;foo.so&quot;,
            &quot;bar.so&quot;,
        ]
        if salt.utils.thin.has_immutables:
            base_tops.extend([&quot;immutables&quot;])
        libs = salt.utils.thin.find_site_modules(&quot;contextvars&quot;)
        with patch(&quot;salt.utils.thin.find_site_modules&quot;, MagicMock(side_effect=[libs])):
            with patch(
                &quot;builtins.__import__&quot;,
                MagicMock(
                    side_effect=[
                        type(&quot;salt&quot;, (), {&quot;__file__&quot;: &quot;/custom/foo.so&quot;}),
                        type(&quot;salt&quot;, (), {&quot;__file__&quot;: &quot;/custom/bar.so&quot;}),
                    ]
                ),
            ):
                tops = []
                for top in thin.get_tops(so_mods=&quot;foo,bar&quot;):
                    if top.find(&quot;/&quot;) != -1:
                        spl = &quot;/&quot;
                    else:
                        spl = os.sep
                    tops.append(top.rsplit(spl, 1)[-1])
        assert len(tops) == len(base_tops)
        assert sorted(tops) == sorted(base_tops)

    @patch(&quot;salt.utils.thin.gen_thin&quot;, MagicMock(return_value=&quot;/path/to/thin/thin.tgz&quot;))
    @patch(&quot;salt.utils.hashutils.get_hash&quot;, MagicMock(return_value=12345))
    def test_thin_sum(self):
        &quot;&quot;&quot;
        Test thin.thin_sum function.

        :return:
        &quot;&quot;&quot;
        assert thin.thin_sum(&quot;/cachedir&quot;, form=&quot;sha256&quot;)[1] == 12345
        thin.salt.utils.hashutils.get_hash.assert_called()
        assert thin.salt.utils.hashutils.get_hash.call_count == 1

        path, form = thin.salt.utils.hashutils.get_hash.call_args[0]
        assert path == &quot;/path/to/thin/thin.tgz&quot;
        assert form == &quot;sha256&quot;

    @patch(&quot;salt.utils.thin.gen_min&quot;, MagicMock(return_value=&quot;/path/to/thin/min.tgz&quot;))
    @patch(&quot;salt.utils.hashutils.get_hash&quot;, MagicMock(return_value=12345))
    def test_min_sum(self):
        &quot;&quot;&quot;
        Test thin.thin_sum function.

        :return:
        &quot;&quot;&quot;
        assert thin.min_sum(&quot;/cachedir&quot;, form=&quot;sha256&quot;) == 12345
        thin.salt.utils.hashutils.get_hash.assert_called()
        assert thin.salt.utils.hashutils.get_hash.call_count == 1

        path, form = thin.salt.utils.hashutils.get_hash.call_args[0]
        assert path == &quot;/path/to/thin/min.tgz&quot;
        assert form == &quot;sha256&quot;

    @patch(&quot;salt.utils.thin.sys.version_info&quot;, (2, 5))
    @patch(&quot;salt.exceptions.SaltSystemExit&quot;, Exception)
    def test_gen_thin_fails_ancient_python_version(self):
        &quot;&quot;&quot;
        Test thin.gen_thin function raises an exception
        if Python major/minor version is lower than 2.6

        :return:
        &quot;&quot;&quot;
        with pytest.raises(salt.exceptions.SaltSystemExit) as err:
            thin.sys.exc_clear = lambda: None
            thin.gen_thin(&quot;&quot;)
        self.assertIn(
            'The minimum required python version to run salt-ssh is &quot;3&quot;',
            str(err.value),
        )

    @patch(&quot;salt.exceptions.SaltSystemExit&quot;, Exception)
    @patch(&quot;salt.utils.thin.log&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.makedirs&quot;, MagicMock())
    @patch(&quot;salt.utils.files.fopen&quot;, MagicMock())
    @patch(&quot;salt.utils.thin._get_salt_call&quot;, MagicMock())
    @patch(&quot;salt.utils.thin._get_ext_namespaces&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.get_tops&quot;, MagicMock(return_value=[&quot;/foo3&quot;, &quot;/bar3&quot;]))
    @patch(&quot;salt.utils.thin.get_ext_tops&quot;, MagicMock(return_value={}))
    @patch(&quot;salt.utils.thin.os.path.isfile&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.path.isdir&quot;, MagicMock(return_value=True))
    @patch(&quot;salt.utils.thin.log&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.remove&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.path.exists&quot;, MagicMock())
    @patch(&quot;salt.utils.path.os_walk&quot;, MagicMock(return_value=[]))
    @patch(
        &quot;salt.utils.thin.subprocess.Popen&quot;,
        _popen(
            None,
            side_effect=[(bts(&quot;2.7&quot;), bts(&quot;&quot;)), (bts('[&quot;/foo27&quot;, &quot;/bar27&quot;]'), bts(&quot;&quot;))],
        ),
    )
    @patch(&quot;salt.utils.thin.tarfile&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.zipfile&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.getcwd&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.access&quot;, MagicMock(return_value=True))
    @patch(&quot;salt.utils.thin.os.chdir&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.close&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.tempfile.mkdtemp&quot;, MagicMock())
    @patch(
        &quot;salt.utils.thin.tempfile.mkstemp&quot;, MagicMock(return_value=(3, &quot;.temporary&quot;))
    )
    @patch(&quot;salt.utils.thin.shutil&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.sys.version_info&quot;, _version_info(None, 3, 6))
    @patch(&quot;salt.utils.path.which&quot;, MagicMock(return_value=&quot;/usr/bin/python&quot;))
    def test_gen_thin_compression_fallback_py3(self):
        &quot;&quot;&quot;
        Test thin.gen_thin function if fallbacks to the gzip compression, once setup wrong.
        NOTE: Py2 version of this test is not required, as code shares the same spot across the versions.

        :return:
        &quot;&quot;&quot;
        thin.gen_thin(&quot;&quot;, compress=&quot;arj&quot;)
        thin.log.warning.assert_called()
        pt, msg = thin.log.warning.mock_calls[0][1]
        assert (
            pt % msg
            == 'Unknown compression type: &quot;arj&quot;. Falling back to &quot;gzip&quot; compression.'
        )
        thin.zipfile.ZipFile.assert_not_called()
        thin.tarfile.open.assert_called()

    @patch(&quot;salt.exceptions.SaltSystemExit&quot;, Exception)
    @patch(&quot;salt.utils.thin.log&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.makedirs&quot;, MagicMock())
    @patch(&quot;salt.utils.files.fopen&quot;, MagicMock())
    @patch(&quot;salt.utils.thin._get_salt_call&quot;, MagicMock())
    @patch(&quot;salt.utils.thin._get_ext_namespaces&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.get_tops&quot;, MagicMock(return_value=[&quot;/foo3&quot;, &quot;/bar3&quot;]))
    @patch(&quot;salt.utils.thin.get_ext_tops&quot;, MagicMock(return_value={}))
    @patch(&quot;salt.utils.thin.os.path.isfile&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.path.isdir&quot;, MagicMock(return_value=False))
    @patch(&quot;salt.utils.thin.log&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.remove&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.path.exists&quot;, MagicMock())
    @patch(&quot;salt.utils.path.os_walk&quot;, MagicMock(return_value=[]))
    @patch(
        &quot;salt.utils.thin.subprocess.Popen&quot;,
        _popen(
            None,
            side_effect=[(bts(&quot;2.7&quot;), bts(&quot;&quot;)), (bts('[&quot;/foo27&quot;, &quot;/bar27&quot;]'), bts(&quot;&quot;))],
        ),
    )
    @patch(&quot;salt.utils.thin.tarfile&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.zipfile&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.getcwd&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.access&quot;, MagicMock(return_value=True))
    @patch(&quot;salt.utils.thin.os.chdir&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.close&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.tempfile.mkdtemp&quot;, MagicMock(return_value=&quot;&quot;))
    @patch(
        &quot;salt.utils.thin.tempfile.mkstemp&quot;, MagicMock(return_value=(3, &quot;.temporary&quot;))
    )
    @patch(&quot;salt.utils.thin.shutil&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.sys.version_info&quot;, _version_info(None, 3, 6))
    @patch(&quot;salt.utils.path.which&quot;, MagicMock(return_value=&quot;/usr/bin/python&quot;))
    def test_gen_thin_control_files_written_py3(self):
        &quot;&quot;&quot;
        Test thin.gen_thin function if control files are written (version, salt-call etc).
        :return:
        &quot;&quot;&quot;
        thin.gen_thin(&quot;&quot;)
        arc_name, arc_mode = thin.tarfile.method_calls[0][1]
        self.assertEqual(arc_name, &quot;.temporary&quot;)
        self.assertEqual(arc_mode, &quot;w:gz&quot;)
        for idx, fname in enumerate(
            [&quot;version&quot;, &quot;.thin-gen-py-version&quot;, &quot;salt-call&quot;, &quot;supported-versions&quot;]
        ):
            name = thin.tarfile.open().method_calls[idx + 2][1][0]
            self.assertEqual(name, fname)
        thin.tarfile.open().close.assert_called()

    @patch(&quot;salt.exceptions.SaltSystemExit&quot;, Exception)
    @patch(&quot;salt.utils.thin.log&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.makedirs&quot;, MagicMock())
    @patch(&quot;salt.utils.files.fopen&quot;, MagicMock())
    @patch(&quot;salt.utils.thin._get_salt_call&quot;, MagicMock())
    @patch(&quot;salt.utils.thin._get_ext_namespaces&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.get_tops&quot;, MagicMock(return_value=[&quot;/salt&quot;, &quot;/bar3&quot;]))
    @patch(&quot;salt.utils.thin.get_ext_tops&quot;, MagicMock(return_value={}))
    @patch(&quot;salt.utils.thin.os.path.isfile&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.path.isdir&quot;, MagicMock(return_value=True))
    @patch(&quot;salt.utils.thin.log&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.remove&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.path.exists&quot;, MagicMock())
    @patch(
        &quot;salt.utils.path.os_walk&quot;,
        MagicMock(
            return_value=(
                (&quot;root&quot;, [], [&quot;r1&quot;, &quot;r2&quot;, &quot;r3&quot;]),
                (&quot;root2&quot;, [], [&quot;r4&quot;, &quot;r5&quot;, &quot;r6&quot;]),
            )
        ),
    )
    @patch(&quot;salt.utils.thin.tarfile&quot;, _tarfile(None))
    @patch(&quot;salt.utils.thin.zipfile&quot;, MagicMock())
    @patch(
        &quot;salt.utils.thin.os.getcwd&quot;,
        MagicMock(return_value=os.path.join(RUNTIME_VARS.TMP, &quot;fake-cwd&quot;)),
    )
    @patch(&quot;salt.utils.thin.os.chdir&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.close&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.tempfile.mkdtemp&quot;, MagicMock(return_value=&quot;&quot;))
    @patch(
        &quot;salt.utils.thin.tempfile.mkstemp&quot;, MagicMock(return_value=(3, &quot;.temporary&quot;))
    )
    @patch(&quot;salt.utils.thin.shutil&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.sys.version_info&quot;, _version_info(None, 3, 6))
    @patch(&quot;salt.utils.hashutils.DigestCollector&quot;, MagicMock())
    @patch(&quot;salt.utils.path.which&quot;, MagicMock(return_value=&quot;/usr/bin/python&quot;))
    def test_gen_thin_main_content_files_written_py3(self):
        &quot;&quot;&quot;
        Test thin.gen_thin function if main content files are written.
        NOTE: Py2 version of this test is not required, as code shares the same spot across the versions.

        :return:
        &quot;&quot;&quot;
        thin.gen_thin(&quot;&quot;)
        files = []
        for py in (&quot;py3&quot;, &quot;pyall&quot;):
            for i in range(1, 4):
                files.append(os.path.join(py, &quot;root&quot;, &quot;r{}&quot;.format(i)))
            for i in range(4, 7):
                files.append(os.path.join(py, &quot;root2&quot;, &quot;r{}&quot;.format(i)))
        for cl in thin.tarfile.open().method_calls[:-6]:
            arcname = cl[2].get(&quot;arcname&quot;)
            self.assertIn(arcname, files)
            files.pop(files.index(arcname))
        self.assertFalse(files)

    @patch(&quot;salt.exceptions.SaltSystemExit&quot;, Exception)
    @patch(&quot;salt.utils.thin.log&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.makedirs&quot;, MagicMock())
    @patch(&quot;salt.utils.files.fopen&quot;, MagicMock())
    @patch(&quot;salt.utils.thin._get_salt_call&quot;, MagicMock())
    @patch(&quot;salt.utils.thin._get_ext_namespaces&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.get_tops&quot;, MagicMock(return_value=[]))
    @patch(
        &quot;salt.utils.thin.get_ext_tops&quot;,
        MagicMock(
            return_value={
                &quot;namespace&quot;: {
                    &quot;py-version&quot;: [3, 0],
                    &quot;path&quot;: &quot;/opt/2015.8/salt&quot;,
                    &quot;dependencies&quot;: [&quot;/opt/certifi&quot;, &quot;/opt/whatever&quot;],
                }
            }
        ),
    )
    @patch(&quot;salt.utils.thin.os.path.isfile&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.path.isdir&quot;, MagicMock(return_value=True))
    @patch(&quot;salt.utils.thin.log&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.remove&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.path.exists&quot;, MagicMock())
    @patch(
        &quot;salt.utils.path.os_walk&quot;,
        MagicMock(
            return_value=(
                (&quot;root&quot;, [], [&quot;r1&quot;, &quot;r2&quot;, &quot;r3&quot;]),
                (&quot;root2&quot;, [], [&quot;r4&quot;, &quot;r5&quot;, &quot;r6&quot;]),
            )
        ),
    )
    @patch(&quot;salt.utils.thin.tarfile&quot;, _tarfile(None))
    @patch(&quot;salt.utils.thin.zipfile&quot;, MagicMock())
    @patch(
        &quot;salt.utils.thin.os.getcwd&quot;,
        MagicMock(return_value=os.path.join(RUNTIME_VARS.TMP, &quot;fake-cwd&quot;)),
    )
    @patch(&quot;salt.utils.thin.os.chdir&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.close&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.tempfile.mkdtemp&quot;, MagicMock(return_value=&quot;&quot;))
    @patch(
        &quot;salt.utils.thin.tempfile.mkstemp&quot;, MagicMock(return_value=(3, &quot;.temporary&quot;))
    )
    @patch(&quot;salt.utils.thin.shutil&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.sys.version_info&quot;, _version_info(None, 3, 6))
    @patch(&quot;salt.utils.hashutils.DigestCollector&quot;, MagicMock())
    @patch(&quot;salt.utils.path.which&quot;, MagicMock(return_value=&quot;/usr/bin/python&quot;))
    def test_gen_thin_ext_alternative_content_files_written_py3(self):
        &quot;&quot;&quot;
        Test thin.gen_thin function if external alternative content files are written.
        :return:
        &quot;&quot;&quot;
        ext_conf = {
            &quot;namespace&quot;: {
                &quot;py-version&quot;: [3, 0],
                &quot;path&quot;: &quot;/opt/2015.8/salt&quot;,
                &quot;dependencies&quot;: {
                    &quot;certifi&quot;: &quot;/opt/certifi&quot;,
                    &quot;whatever&quot;: &quot;/opt/whatever&quot;,
                },
            }
        }

        thin.gen_thin(&quot;&quot;, extended_cfg=ext_conf)
        files = []
        for py in (&quot;pyall&quot;, &quot;pyall&quot;, &quot;py3&quot;):
            for i in range(1, 4):
                files.append(os.path.join(&quot;namespace&quot;, py, &quot;root&quot;, &quot;r{}&quot;.format(i)))
            for i in range(4, 7):
                files.append(os.path.join(&quot;namespace&quot;, py, &quot;root2&quot;, &quot;r{}&quot;.format(i)))

        for idx, cl in enumerate(thin.tarfile.open().method_calls[:-6]):
            arcname = cl[2].get(&quot;arcname&quot;)
            self.assertIn(arcname, files)
            files.pop(files.index(arcname))
        self.assertFalse(files)

    def test_get_supported_py_config_typecheck(self):
        &quot;&quot;&quot;
        Test collecting proper py-versions. Should return bytes type.
        :return:
        &quot;&quot;&quot;
        tops = {}
        ext_cfg = {}
        out = thin._get_supported_py_config(tops=tops, extended_cfg=ext_cfg)
        assert type(salt.utils.stringutils.to_bytes(&quot;&quot;)) == type(out)

    def test_get_supported_py_config_base_tops(self):
        &quot;&quot;&quot;
        Test collecting proper py-versions. Should return proper base tops.
        :return:
        &quot;&quot;&quot;
        tops = {&quot;3&quot;: [&quot;/groundkeepers&quot;, &quot;/stole&quot;], &quot;2&quot;: [&quot;/the-root&quot;, &quot;/password&quot;]}
        ext_cfg = {}
        out = (
            salt.utils.stringutils.to_str(
                thin._get_supported_py_config(tops=tops, extended_cfg=ext_cfg)
            )
            .strip()
            .split(os.linesep)
        )
        self.assertEqual(len(out), 2)
        for t_line in [&quot;py3:3:0&quot;, &quot;py2:2:7&quot;]:
            self.assertIn(t_line, out)

    def test_get_supported_py_config_ext_tops(self):
        &quot;&quot;&quot;
        Test collecting proper py-versions. Should return proper ext conf tops.
        :return:
        &quot;&quot;&quot;
        tops = {}
        ext_cfg = {
            &quot;solar-interference&quot;: {&quot;py-version&quot;: [2, 6]},
            &quot;second-system-effect&quot;: {&quot;py-version&quot;: [2, 7]},
        }
        out = (
            salt.utils.stringutils.to_str(
                thin._get_supported_py_config(tops=tops, extended_cfg=ext_cfg)
            )
            .strip()
            .split(os.linesep)
        )
        for t_line in [&quot;second-system-effect:2:7&quot;, &quot;solar-interference:2:6&quot;]:
            self.assertIn(t_line, out)

    @patch(&quot;salt.exceptions.SaltSystemExit&quot;, Exception)
    @patch(&quot;salt.utils.thin.log&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.makedirs&quot;, MagicMock())
    @patch(&quot;salt.utils.files.fopen&quot;, MagicMock())
    @patch(&quot;salt.utils.thin._get_salt_call&quot;, MagicMock())
    @patch(&quot;salt.utils.thin._get_ext_namespaces&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.get_tops&quot;, MagicMock(return_value=[&quot;/foo3&quot;, &quot;/bar3&quot;]))
    @patch(&quot;salt.utils.thin.get_ext_tops&quot;, MagicMock(return_value={}))
    @patch(&quot;salt.utils.thin.os.path.isfile&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.path.isdir&quot;, MagicMock(return_value=False))
    @patch(&quot;salt.utils.thin.log&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.remove&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.path.exists&quot;, MagicMock())
    @patch(&quot;salt.utils.path.os_walk&quot;, MagicMock(return_value=[]))
    @patch(
        &quot;salt.utils.thin.subprocess.Popen&quot;,
        _popen(
            None,
            side_effect=[(bts(&quot;2.7&quot;), bts(&quot;&quot;)), (bts('[&quot;/foo27&quot;, &quot;/bar27&quot;]'), bts(&quot;&quot;))],
        ),
    )
    @patch(&quot;salt.utils.thin.tarfile&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.zipfile&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.getcwd&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.access&quot;, MagicMock(return_value=False))
    @patch(&quot;salt.utils.thin.os.chdir&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.os.close&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.tempfile.mkdtemp&quot;, MagicMock(return_value=&quot;&quot;))
    @patch(
        &quot;salt.utils.thin.tempfile.mkstemp&quot;, MagicMock(return_value=(3, &quot;.temporary&quot;))
    )
    @patch(&quot;salt.utils.thin.shutil&quot;, MagicMock())
    @patch(&quot;salt.utils.thin.sys.version_info&quot;, _version_info(None, 3, 6))
    def test_gen_thin_control_files_written_access_denied_cwd(self):
        &quot;&quot;&quot;
        Test thin.gen_thin function if control files are written (version, salt-call etc)
        when the current working directory is inaccessible, eg. Salt is configured to run as
        a non-root user but the command is executed in a directory that the user does not
        have permissions to.  Issue #54317.

        NOTE: Py2 version of this test is not required, as code shares the same spot across the versions.

        :return:
        &quot;&quot;&quot;
        thin.gen_thin(&quot;&quot;)
        arc_name, arc_mode = thin.tarfile.method_calls[0][1]
        self.assertEqual(arc_name, &quot;.temporary&quot;)
        self.assertEqual(arc_mode, &quot;w:gz&quot;)
        for idx, fname in enumerate(
            [&quot;version&quot;, &quot;.thin-gen-py-version&quot;, &quot;salt-call&quot;, &quot;supported-versions&quot;]
        ):
            name = thin.tarfile.open().method_calls[idx + 2][1][0]
            self.assertEqual(name, fname)
        thin.tarfile.open().close.assert_called()

    def test_get_tops_python(self):
        &quot;&quot;&quot;
        test get_tops_python
        &quot;&quot;&quot;
        patch_proc = patch(
            &quot;salt.utils.thin.subprocess.Popen&quot;,
            self._popen(
                None,
                side_effect=[
                    (bts(&quot;jinja2/__init__.py&quot;), bts(&quot;&quot;)),
                    (bts(&quot;yaml/__init__.py&quot;), bts(&quot;&quot;)),
                    (bts(&quot;tornado/__init__.py&quot;), bts(&quot;&quot;)),
                    (bts(&quot;msgpack/__init__.py&quot;), bts(&quot;&quot;)),
                    (bts(&quot;certifi/__init__.py&quot;), bts(&quot;&quot;)),
                    (bts(&quot;singledispatch.py&quot;), bts(&quot;&quot;)),
                    (bts(&quot;&quot;), bts(&quot;&quot;)),
                    (bts(&quot;&quot;), bts(&quot;&quot;)),
                    (bts(&quot;&quot;), bts(&quot;&quot;)),
                    (bts(&quot;&quot;), bts(&quot;&quot;)),
                    (bts(&quot;&quot;), bts(&quot;&quot;)),
                    (bts(&quot;distro.py&quot;), bts(&quot;&quot;)),
                ],
            ),
        )

        patch_os = patch(&quot;os.path.exists&quot;, return_value=True)
        patch_which = patch(&quot;salt.utils.path.which&quot;, return_value=True)
        with patch_proc, patch_os, patch_which:
            with TstSuiteLoggingHandler() as log_handler:
                exp_ret = copy.deepcopy(self.exp_ret)
                ret = thin.get_tops_python(&quot;python3.7&quot;, ext_py_ver=[3, 7])
                if salt.utils.platform.is_windows():
                    for key, value in ret.items():
                        ret[key] = str(pathlib.Path(value).resolve(strict=False))
                    for key, value in exp_ret.items():
                        exp_ret[key] = str(pathlib.Path(value).resolve(strict=False))
                assert ret == exp_ret
                assert (
                    &quot;ERROR:Could not auto detect file location for module concurrent&quot;
                    &quot; for python version python3.7&quot; in log_handler.messages
                )

    def test_get_tops_python_exclude(self):
        &quot;&quot;&quot;
        test get_tops_python when excluding modules
        &quot;&quot;&quot;
        patch_proc = patch(
            &quot;salt.utils.thin.subprocess.Popen&quot;,
            self._popen(
                None,
                side_effect=[
                    (bts(&quot;tornado/__init__.py&quot;), bts(&quot;&quot;)),
                    (bts(&quot;msgpack/__init__.py&quot;), bts(&quot;&quot;)),
                    (bts(&quot;certifi/__init__.py&quot;), bts(&quot;&quot;)),
                    (bts(&quot;singledispatch.py&quot;), bts(&quot;&quot;)),
                    (bts(&quot;&quot;), bts(&quot;&quot;)),
                    (bts(&quot;&quot;), bts(&quot;&quot;)),
                    (bts(&quot;&quot;), bts(&quot;&quot;)),
                    (bts(&quot;&quot;), bts(&quot;&quot;)),
                    (bts(&quot;&quot;), bts(&quot;&quot;)),
                    (bts(&quot;distro.py&quot;), bts(&quot;&quot;)),
                ],
            ),
        )
        exp_ret = copy.deepcopy(self.exp_ret)
        for lib in self.exc_libs:
            exp_ret.pop(lib)

        patch_os = patch(&quot;os.path.exists&quot;, return_value=True)
        patch_which = patch(&quot;salt.utils.path.which&quot;, return_value=True)
        with patch_proc, patch_os, patch_which:
            ret = thin.get_tops_python(
                &quot;python3.7&quot;, exclude=self.exc_libs, ext_py_ver=[3, 7]
            )
            if salt.utils.platform.is_windows():
                for key, value in ret.items():
                    ret[key] = str(pathlib.Path(value).resolve(strict=False))
                for key, value in exp_ret.items():
                    exp_ret[key] = str(pathlib.Path(value).resolve(strict=False))
            assert ret == exp_ret

    def test_pack_alternatives_exclude(self):
        &quot;&quot;&quot;
        test pack_alternatives when mixing
        manually set dependencies and auto
        detecting other modules.
        &quot;&quot;&quot;
        patch_proc = patch(
            &quot;salt.utils.thin.subprocess.Popen&quot;,
            self._popen(
                None,
                side_effect=[
                    (bts(self.fake_libs[&quot;distro&quot;]), bts(&quot;&quot;)),
                    (bts(self.fake_libs[&quot;yaml&quot;]), bts(&quot;&quot;)),
                    (bts(self.fake_libs[&quot;tornado&quot;]), bts(&quot;&quot;)),
                    (bts(self.fake_libs[&quot;msgpack&quot;]), bts(&quot;&quot;)),
                    (bts(&quot;&quot;), bts(&quot;&quot;)),
                    (bts(&quot;&quot;), bts(&quot;&quot;)),
                    (bts(&quot;&quot;), bts(&quot;&quot;)),
                    (bts(&quot;&quot;), bts(&quot;&quot;)),
                    (bts(&quot;&quot;), bts(&quot;&quot;)),
                    (bts(&quot;&quot;), bts(&quot;&quot;)),
                    (bts(&quot;&quot;), bts(&quot;&quot;)),
                ],
            ),
        )

        patch_os = patch(&quot;os.path.exists&quot;, return_value=True)
        ext_conf = copy.deepcopy(self.ext_conf)
        ext_conf[&quot;test&quot;][&quot;auto_detect&quot;] = True

        for lib in self.fake_libs.values():
            os.makedirs(lib)
<A NAME="1"></A>            with salt.utils.files.fopen(os.path.join(lib, &quot;__init__.py&quot;), &quot;w+&quot;) as fp_:
                fp_.write(&quot;test&quot;)

        exp_files <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match80632-0.html#1',2,'match80632-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>= self.exp_files.copy()
        exp_files.extend(
            [
                os.path.join(&quot;yaml&quot;, &quot;__init__.py&quot;),
                os.path.</B></FONT>join(&quot;tornado&quot;, &quot;__init__.py&quot;),
                os.path.join(&quot;msgpack&quot;, &quot;__init__.py&quot;),
            ]
        )

        patch_which = patch(&quot;salt.utils.path.which&quot;, return_value=True)

        with patch_os, patch_proc, patch_which:
            thin._pack_alternative(ext_conf, self.digest, self.tar)
            calls = self.tar.mock_calls
            for _file in exp_files:
                assert [x for x in calls if &quot;{}&quot;.format(_file) in x[-2]]

    def test_pack_alternatives(self):
        &quot;&quot;&quot;
        test thin._pack_alternatives
        &quot;&quot;&quot;
        with patch(&quot;salt.utils.thin.get_ext_tops&quot;, MagicMock(return_value=self.tops)):
            thin._pack_alternative(self.ext_conf, self.digest, self.tar)
            calls = self.tar.mock_calls
            for _file in self.exp_files:
                assert [x for x in calls if &quot;{}&quot;.format(_file) in x[-2]]
                assert [
                    x
                    for x in calls
                    if os.path.join(&quot;test&quot;, &quot;pyall&quot;, _file) in x[-1][&quot;arcname&quot;]
                ]

    def test_pack_alternatives_not_normalized(self):
        &quot;&quot;&quot;
        test thin._pack_alternatives when the path
        is not normalized
        &quot;&quot;&quot;
        tops = copy.deepcopy(self.tops)
        tops[&quot;test&quot;][&quot;dependencies&quot;] = [self.jinja_fp + &quot;/&quot;]
        with patch(&quot;salt.utils.thin.get_ext_tops&quot;, MagicMock(return_value=tops)):
            thin._pack_alternative(self.ext_conf, self.digest, self.tar)
            calls = self.tar.mock_calls
            for _file in self.exp_files:
                assert [x for x in calls if &quot;{}&quot;.format(_file) in x[-2]]
                assert [
                    x
                    for x in calls
                    if os.path.join(&quot;test&quot;, &quot;pyall&quot;, _file) in x[-1][&quot;arcname&quot;]
                ]

    def test_pack_alternatives_path_doesnot_exist(self):
        &quot;&quot;&quot;
        test thin._pack_alternatives when the path
        doesnt exist. Check error log message
        and expect that because the directory
        does not exist jinja2 does not get
        added to the tar
        &quot;&quot;&quot;
        bad_path = os.path.join(tempfile.gettempdir(), &quot;doesnotexisthere&quot;)
        tops = copy.deepcopy(self.tops)
        tops[&quot;test&quot;][&quot;dependencies&quot;] = [bad_path]
        with patch(&quot;salt.utils.thin.get_ext_tops&quot;, MagicMock(return_value=tops)):
            with TstSuiteLoggingHandler() as log_handler:
                thin._pack_alternative(self.ext_conf, self.digest, self.tar)
                msg = &quot;ERROR:File path {} does not exist. Unable to add to salt-ssh thin&quot;.format(
                    bad_path
                )
                assert msg in log_handler.messages
        calls = self.tar.mock_calls
        for _file in self.exp_files:
            arg = [x for x in calls if &quot;{}&quot;.format(_file) in x[-2]]
            kwargs = [
                x
                for x in calls
                if os.path.join(&quot;test&quot;, &quot;pyall&quot;, _file) in x[-1][&quot;arcname&quot;]
            ]
            if &quot;jinja2&quot; in _file:
                assert not arg
                assert not kwargs
            else:
                assert arg
                assert kwargs

    def test_pack_alternatives_auto_detect(self):
        &quot;&quot;&quot;
        test thin._pack_alternatives when auto_detect
        is enabled
        &quot;&quot;&quot;
        ext_conf = copy.deepcopy(self.ext_conf)
        ext_conf[&quot;test&quot;][&quot;auto_detect&quot;] = True

        for lib in self.fake_libs.values():
            os.makedirs(lib)
            with salt.utils.files.fopen(os.path.join(lib, &quot;__init__.py&quot;), &quot;w+&quot;) as fp_:
                fp_.write(&quot;test&quot;)

        patch_tops_py = patch(
            &quot;salt.utils.thin.get_tops_python&quot;, return_value=self.fake_libs
        )

        exp_files = self.exp_files.copy()
        exp_files.extend(
            [
                os.path.join(&quot;yaml&quot;, &quot;__init__.py&quot;),
                os.path.join(&quot;tornado&quot;, &quot;__init__.py&quot;),
                os.path.join(&quot;msgpack&quot;, &quot;__init__.py&quot;),
            ]
        )
        with patch_tops_py:
            thin._pack_alternative(ext_conf, self.digest, self.tar)
            calls = self.tar.mock_calls
            for _file in exp_files:
                assert [x for x in calls if &quot;{}&quot;.format(_file) in x[-2]]

    def test_pack_alternatives_empty_dependencies(self):
        &quot;&quot;&quot;
        test _pack_alternatives when dependencies is not
        set in the config.
        &quot;&quot;&quot;
        ext_conf = copy.deepcopy(self.ext_conf)
        ext_conf[&quot;test&quot;][&quot;auto_detect&quot;] = True
        ext_conf[&quot;test&quot;].pop(&quot;dependencies&quot;)

        for lib in self.fake_libs.values():
            os.makedirs(lib)
            with salt.utils.files.fopen(os.path.join(lib, &quot;__init__.py&quot;), &quot;w+&quot;) as fp_:
                fp_.write(&quot;test&quot;)

        patch_tops_py = patch(
            &quot;salt.utils.thin.get_tops_python&quot;, return_value=self.fake_libs
        )

        exp_files = self.exp_files.copy()
        exp_files.extend(
            [
                os.path.join(&quot;yaml&quot;, &quot;__init__.py&quot;),
                os.path.join(&quot;tornado&quot;, &quot;__init__.py&quot;),
                os.path.join(&quot;msgpack&quot;, &quot;__init__.py&quot;),
            ]
        )
        with patch_tops_py:
            thin._pack_alternative(ext_conf, self.digest, self.tar)
            calls = self.tar.mock_calls
            for _file in exp_files:
                assert [x for x in calls if &quot;{}&quot;.format(_file) in x[-2]]

    @pytest.mark.slow_test
    @skipIf(
        salt.utils.platform.is_windows(), &quot;salt-ssh does not deploy to/from windows&quot;
    )
    def test_thin_dir(self):
        &quot;&quot;&quot;
        Test the thin dir to make sure salt-call can run

        Run salt call via a python in a new virtual environment to ensure
        salt-call has all dependencies needed.
        &quot;&quot;&quot;
        # This was previously an integration test and is now here, as a unit test.
        # Should actually be a functional test
        with VirtualEnv() as venv:
            salt.utils.thin.gen_thin(str(venv.venv_dir))
            thin_dir = venv.venv_dir / &quot;thin&quot;
            thin_archive = thin_dir / &quot;thin.tgz&quot;
            tar = tarfile.open(str(thin_archive))
            tar.extractall(str(thin_dir))
            tar.close()
            ret = venv.run(
                venv.venv_python,
                str(thin_dir / &quot;salt-call&quot;),
                &quot;--version&quot;,
                check=False,
            )
            assert ret.exitcode == 0, ret
</PRE>
</div>
  </div>
</body>
</html>
