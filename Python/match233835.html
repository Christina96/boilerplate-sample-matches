<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for mixins.py &amp; selinux_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for mixins.py &amp; selinux_1.py
      </h3>
<h1 align="center">
        1.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>mixins.py (1.1070111%)<th>selinux_1.py (1.5189873%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(67-74)<td><a href="#" name="0">(684-690)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mixins.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import atexit
2 import copy
3 import functools
4 import logging
5 import multiprocessing
6 import os
7 import pprint
8 import queue
9 import subprocess
10 import tempfile
11 import time
12 import xml.etree.ElementTree as etree
13 import salt.config
14 import salt.exceptions
15 import salt.utils.event
16 import salt.utils.files
17 import salt.utils.functools
18 import salt.utils.path
19 import salt.utils.process
20 import salt.utils.stringutils
21 import salt.utils.yaml
22 import salt.version
23 from salt.utils.immutabletypes import freeze
24 from salt.utils.verify import verify_env
25 from saltfactories.utils import random_string
26 from tests.support.paths import CODE_DIR
27 from tests.support.pytest.loader import LoaderModuleMock
28 from tests.support.runtests import RUNTIME_VARS
29 log = logging.getLogger(__name__)
30 class CheckShellBinaryNameAndVersionMixin:
31     _call_binary_ = None
32     _call_binary_expected_version_ = None
33     def test_version_includes_binary_name(self):
34         if getattr(self, "_call_binary_", None) is None:
35             self.skipTest("'_call_binary_' not defined.")
36         if self._call_binary_expected_version_ is None:
37             self._call_binary_expected_version_ = salt.version.__version__
38         out = "\n".join(self.run_script(self._call_binary_, "--version"))
39         try:
40 <a name="0"></a>            self.assertIn(self._call_binary_, out)
41         except AssertionError:
42             alternate_binary_name = self._call_binary_<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.replace("-", "_")
43             errmsg = "Neither '{}' or '{}' were found as part of the binary name in:\n'{}'".format(
44                 self._call_binary_, alternate_binary_name, out
45             )
46             self.assertIn(alternate_binary_name, out, msg=errmsg)
47         self.assertIn(self.</b></font>_call_binary_expected_version_, out)
48 class AdaptedConfigurationTestCaseMixin:
49     __slots__ = ()
50     @staticmethod
51     def get_temp_config(config_for, **config_overrides):
52         rootdir = config_overrides.get(
53             "root_dir", tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
54         )
55         if not os.path.exists(rootdir):
56             os.makedirs(rootdir)
57         conf_dir = config_overrides.pop("conf_dir", os.path.join(rootdir, "conf"))
58         for key in ("cachedir", "pki_dir", "sock_dir"):
59             if key not in config_overrides:
60                 config_overrides[key] = key
61         if "log_file" not in config_overrides:
62             config_overrides["log_file"] = "logs/{}.log".format(config_for)
63         if "user" not in config_overrides:
64             config_overrides["user"] = RUNTIME_VARS.RUNNING_TESTS_USER
65         config_overrides["root_dir"] = rootdir
66         cdict = AdaptedConfigurationTestCaseMixin.get_config(
67             config_for, from_scratch=True
68         )
69         if config_for in ("master", "client_config"):
70             rdict = salt.config.apply_master_config(config_overrides, cdict)
71         if config_for == "minion":
72             minion_id = (
73                 config_overrides.get("id")
74                 or config_overrides.get("minion_id")
75                 or cdict.get("id")
76                 or cdict.get("minion_id")
77                 or random_string("temp-minion-")
78             )
79             config_overrides["minion_id"] = config_overrides["id"] = minion_id
80             rdict = salt.config.apply_minion_config(
81                 config_overrides, cdict, cache_minion_id=False, minion_id=minion_id
82             )
83         verify_env(
84             [
85                 os.path.join(rdict["pki_dir"], "minions"),
86                 os.path.join(rdict["pki_dir"], "minions_pre"),
87                 os.path.join(rdict["pki_dir"], "minions_rejected"),
88                 os.path.join(rdict["pki_dir"], "minions_denied"),
89                 os.path.join(rdict["cachedir"], "jobs"),
90                 os.path.join(rdict["cachedir"], "tokens"),
91                 os.path.join(rdict["root_dir"], "cache", "tokens"),
92                 os.path.join(rdict["pki_dir"], "accepted"),
93                 os.path.join(rdict["pki_dir"], "rejected"),
94                 os.path.join(rdict["pki_dir"], "pending"),
95                 os.path.dirname(rdict["log_file"]),
96                 rdict["sock_dir"],
97                 conf_dir,
98             ],
99             RUNTIME_VARS.RUNNING_TESTS_USER,
100             root_dir=rdict["root_dir"],
101         )
102         rdict["conf_file"] = os.path.join(conf_dir, config_for)
103         with salt.utils.files.fopen(rdict["conf_file"], "w") as wfh:
104             salt.utils.yaml.safe_dump(rdict, wfh, default_flow_style=False)
105         return rdict
106     @staticmethod
107     def get_config(config_for, from_scratch=False):
108         if from_scratch:
109             if config_for in ("master", "syndic_master", "mm_master", "mm_sub_master"):
110                 return salt.config.master_config(
111                     AdaptedConfigurationTestCaseMixin.get_config_file_path(config_for)
112                 )
113             elif config_for in ("minion", "sub_minion"):
114                 return salt.config.minion_config(
115                     AdaptedConfigurationTestCaseMixin.get_config_file_path(config_for),
116                     cache_minion_id=False,
117                 )
118             elif config_for in ("syndic",):
119                 return salt.config.syndic_config(
120                     AdaptedConfigurationTestCaseMixin.get_config_file_path(config_for),
121                     AdaptedConfigurationTestCaseMixin.get_config_file_path("minion"),
122                 )
123             elif config_for == "client_config":
124                 return salt.config.client_config(
125                     AdaptedConfigurationTestCaseMixin.get_config_file_path("master")
126                 )
127         if config_for not in RUNTIME_VARS.RUNTIME_CONFIGS:
128             if config_for in ("master", "syndic_master", "mm_master", "mm_sub_master"):
129                 RUNTIME_VARS.RUNTIME_CONFIGS[config_for] = freeze(
130                     salt.config.master_config(
131                         AdaptedConfigurationTestCaseMixin.get_config_file_path(
132                             config_for
133                         )
134                     )
135                 )
136             elif config_for in ("minion", "sub_minion"):
137                 RUNTIME_VARS.RUNTIME_CONFIGS[config_for] = freeze(
138                     salt.config.minion_config(
139                         AdaptedConfigurationTestCaseMixin.get_config_file_path(
140                             config_for
141                         )
142                     )
143                 )
144             elif config_for in ("syndic",):
145                 RUNTIME_VARS.RUNTIME_CONFIGS[config_for] = freeze(
146                     salt.config.syndic_config(
147                         AdaptedConfigurationTestCaseMixin.get_config_file_path(
148                             config_for
149                         ),
150                         AdaptedConfigurationTestCaseMixin.get_config_file_path(
151                             "minion"
152                         ),
153                     )
154                 )
155             elif config_for == "client_config":
156                 RUNTIME_VARS.RUNTIME_CONFIGS[config_for] = freeze(
157                     salt.config.client_config(
158                         AdaptedConfigurationTestCaseMixin.get_config_file_path("master")
159                     )
160                 )
161         return RUNTIME_VARS.RUNTIME_CONFIGS[config_for]
162     @property
163     def config_dir(self):
164         return RUNTIME_VARS.TMP_CONF_DIR
165     def get_config_dir(self):
166         log.warning("Use the config_dir attribute instead of calling get_config_dir()")
167         return self.config_dir
168     @staticmethod
169     def get_config_file_path(filename):
170         if filename == "master":
171             return os.path.join(RUNTIME_VARS.TMP_CONF_DIR, filename)
172         if filename == "minion":
173             return os.path.join(RUNTIME_VARS.TMP_MINION_CONF_DIR, filename)
174         if filename == "syndic_master":
175             return os.path.join(RUNTIME_VARS.TMP_SYNDIC_MASTER_CONF_DIR, "master")
176         if filename == "syndic":
177             return os.path.join(RUNTIME_VARS.TMP_SYNDIC_MINION_CONF_DIR, "minion")
178         if filename == "sub_minion":
179             return os.path.join(RUNTIME_VARS.TMP_SUB_MINION_CONF_DIR, "minion")
180         if filename == "mm_master":
181             return os.path.join(RUNTIME_VARS.TMP_MM_CONF_DIR, "master")
182         if filename == "mm_sub_master":
183             return os.path.join(RUNTIME_VARS.TMP_MM_SUB_CONF_DIR, "master")
184         if filename == "mm_minion":
185             return os.path.join(RUNTIME_VARS.TMP_MM_MINION_CONF_DIR, "minion")
186         if filename == "mm_sub_minion":
187             return os.path.join(RUNTIME_VARS.TMP_MM_SUB_MINION_CONF_DIR, "minion")
188         return os.path.join(RUNTIME_VARS.TMP_CONF_DIR, filename)
189     @property
190     def master_opts(self):
191         return self.get_config("master")
192     @property
193     def minion_opts(self):
194         return self.get_config("minion")
195     @property
196     def sub_minion_opts(self):
197         return self.get_config("sub_minion")
198 class SaltClientTestCaseMixin(AdaptedConfigurationTestCaseMixin):
199     _salt_client_config_file_name_ = "master"
200     @property
201     def client(self):
202         import salt.client
203         if "runtime_client" not in RUNTIME_VARS.RUNTIME_CONFIGS:
204             mopts = self.get_config(
205                 self._salt_client_config_file_name_, from_scratch=True
206             )
207             RUNTIME_VARS.RUNTIME_CONFIGS[
208                 "runtime_client"
209             ] = salt.client.get_local_client(mopts=mopts)
210         return RUNTIME_VARS.RUNTIME_CONFIGS["runtime_client"]
211 class ShellCaseCommonTestsMixin(CheckShellBinaryNameAndVersionMixin):
212     _call_binary_expected_version_ = salt.version.__version__
213     def test_salt_with_git_version(self):
214         if getattr(self, "_call_binary_", None) is None:
215             self.skipTest("'_call_binary_' not defined.")
216         from salt.version import __version_info__, SaltStackVersion
217         git = salt.utils.path.which("git")
218         if not git:
219             self.skipTest("The git binary is not available")
220         opts = {
221             "stdout": subprocess.PIPE,
222             "stderr": subprocess.PIPE,
223             "cwd": CODE_DIR,
224         }
225         if not salt.utils.platform.is_windows():
226             opts["close_fds"] = True
227         process = subprocess.Popen(
228             [git, "describe", "--tags", "--first-parent", "--match", "v[0-9]*"], **opts
229         )
230         out, err = process.communicate()
231         if process.returncode != 0:
232             process = subprocess.Popen(
233                 [git, "describe", "--tags", "--match", "v[0-9]*"], **opts
234             )
235             out, err = process.communicate()
236         if not out:
237             self.skipTest(
238                 "Failed to get the output of 'git describe'. Error: '{}'".format(
239                     salt.utils.stringutils.to_str(err)
240                 )
241             )
242         parsed_version = SaltStackVersion.parse(out)
243         if parsed_version.info &lt; __version_info__:
244             self.skipTest(
245                 "We're likely about to release a new version. This test "
246                 "would fail. Parsed('{}') &lt; Expected('{}')".format(
247                     parsed_version.info, __version_info__
248                 )
249             )
250         elif parsed_version.info != __version_info__:
251             self.skipTest(
252                 "In order to get the proper salt version with the "
253                 "git hash you need to update salt's local git "
254                 "tags. Something like: 'git fetch --tags' or "
255                 "'git fetch --tags upstream' if you followed "
256                 "salt's contribute documentation. The version "
257                 "string WILL NOT include the git hash."
258             )
259         out = "\n".join(self.run_script(self._call_binary_, "--version"))
260         self.assertIn(parsed_version.string, out)
261 class _FixLoaderModuleMockMixinMroOrder(type):
262     def __new__(mcs, cls_name, cls_bases, cls_dict):
263         if cls_name == "LoaderModuleMockMixin":
264             return super().__new__(mcs, cls_name, cls_bases, cls_dict)
265         bases = list(cls_bases)
266         for idx, base in enumerate(bases):
267             if base.__name__ == "LoaderModuleMockMixin":
268                 bases.insert(0, bases.pop(idx))
269                 break
270         instance = super().__new__(mcs, cls_name, tuple(bases), cls_dict)
271         instance.setUp = LoaderModuleMockMixin.__setup_loader_modules_mocks__(
272             instance.setUp
273         )
274         return instance
275 class LoaderModuleMockMixin(metaclass=_FixLoaderModuleMockMixinMroOrder):
276     @staticmethod
277     def __setup_loader_modules_mocks__(setup_func):
278         @functools.wraps(setup_func)
279         def wrapper(self):
280             loader_modules_configs = self.setup_loader_modules()
281             if not isinstance(loader_modules_configs, dict):
282                 raise RuntimeError(
283                     "{}.setup_loader_modules() must return a dictionary where the keys"
284                     " are the modules that require loader mocking setup and the values,"
285                     " the global module variables for each of the module being mocked."
286                     " For example '__salt__', '__opts__', etc.".format(
287                         self.__class__.__name__
288                     )
289                 )
290             mocker = LoaderModuleMock(loader_modules_configs)
291             mocker.start()
292             self.addCleanup(mocker.stop)
293             return setup_func(self)
294         return wrapper
295     def setup_loader_modules(self):
296         raise NotImplementedError(
297             "'{}.setup_loader_modules()' must be implemented".format(
298                 self.__class__.__name__
299             )
300         )
301 class XMLEqualityMixin:
302     def assertEqualXML(self, e1, e2):
303         if isinstance(e1, bytes):
304             e1 = e1.decode("utf-8")
305         if isinstance(e2, bytes):
306             e2 = e2.decode("utf-8")
307         if isinstance(e1, str):
308             e1 = etree.XML(e1)
309         if isinstance(e2, str):
310             e2 = etree.XML(e2)
311         if e1.tag != e2.tag:
312             return False
313         if e1.text != e2.text:
314             return False
315         if e1.tail != e2.tail:
316             return False
317         if e1.attrib != e2.attrib:
318             return False
319         if len(e1) != len(e2):
320             return False
321         return all(self.assertEqualXML(c1, c2) for c1, c2 in zip(e1, e2))
322 class SaltReturnAssertsMixin:
323     def assertReturnSaltType(self, ret):
324         try:
325             self.assertTrue(isinstance(ret, dict))
326         except AssertionError:
327             raise AssertionError(
328                 "{} is not dict. Salt returned: {}".format(type(ret).__name__, ret)
329             )
330     def assertReturnNonEmptySaltType(self, ret):
331         self.assertReturnSaltType(ret)
332         try:
333             self.assertNotEqual(ret, {})
334         except AssertionError:
335             raise AssertionError(
336                 "{} is equal to {}. Salt returned an empty dictionary."
337             )
338     def __return_valid_keys(self, keys):
339         if isinstance(keys, tuple):
340             keys = list(keys)
341         elif isinstance(keys, str):
342             keys = [keys]
343         elif not isinstance(keys, list):
344             raise RuntimeError("The passed keys need to be a list")
345         return keys
346     def __getWithinSaltReturn(self, ret, keys):
347         self.assertReturnNonEmptySaltType(ret)
348         ret_data = []
349         for part in ret.values():
350             keys = self.__return_valid_keys(keys)
351             okeys = keys[:]
352             try:
353                 ret_item = part[okeys.pop(0)]
354             except (KeyError, TypeError):
355                 raise AssertionError(
356                     "Could not get ret{} from salt's return: {}".format(
357                         "".join(["['{}']".format(k) for k in keys]), part
358                     )
359                 )
360             while okeys:
361                 try:
362                     ret_item = ret_item[okeys.pop(0)]
363                 except (KeyError, TypeError):
364                     raise AssertionError(
365                         "Could not get ret{} from salt's return: {}".format(
366                             "".join(["['{}']".format(k) for k in keys]), part
367                         )
368                     )
369             ret_data.append(ret_item)
370         return ret_data
371     def assertSaltTrueReturn(self, ret):
372         try:
373             for saltret in self.__getWithinSaltReturn(ret, "result"):
374                 self.assertTrue(saltret)
375         except AssertionError:
376             log.info("Salt Full Return:\n%s", pprint.pformat(ret))
377             try:
378                 raise AssertionError(
379                     "{result} is not True. Salt Comment:\n{comment}".format(
380                         **(next(iter(ret.values())))
381                     )
382                 )
383             except (AttributeError, IndexError):
384                 raise AssertionError(
385                     "Failed to get result. Salt Returned:\n{}".format(
386                         pprint.pformat(ret)
387                     )
388                 )
389     def assertSaltFalseReturn(self, ret):
390         try:
391             for saltret in self.__getWithinSaltReturn(ret, "result"):
392                 self.assertFalse(saltret)
393         except AssertionError:
394             log.info("Salt Full Return:\n%s", pprint.pformat(ret))
395             try:
396                 raise AssertionError(
397                     "{result} is not False. Salt Comment:\n{comment}".format(
398                         **(next(iter(ret.values())))
399                     )
400                 )
401             except (AttributeError, IndexError):
402                 raise AssertionError(
403                     "Failed to get result. Salt Returned: {}".format(ret)
404                 )
405     def assertSaltNoneReturn(self, ret):
406         try:
407             for saltret in self.__getWithinSaltReturn(ret, "result"):
408                 self.assertIsNone(saltret)
409         except AssertionError:
410             log.info("Salt Full Return:\n%s", pprint.pformat(ret))
411             try:
412                 raise AssertionError(
413                     "{result} is not None. Salt Comment:\n{comment}".format(
414                         **(next(iter(ret.values())))
415                     )
416                 )
417             except (AttributeError, IndexError):
418                 raise AssertionError(
419                     "Failed to get result. Salt Returned: {}".format(ret)
420                 )
421     def assertInSaltComment(self, in_comment, ret):
422         for saltret in self.__getWithinSaltReturn(ret, "comment"):
423             self.assertIn(in_comment, saltret)
424     def assertNotInSaltComment(self, not_in_comment, ret):
425         for saltret in self.__getWithinSaltReturn(ret, "comment"):
426             self.assertNotIn(not_in_comment, saltret)
427     def assertSaltCommentRegexpMatches(self, ret, pattern):
428         return self.assertInSaltReturnRegexpMatches(ret, pattern, "comment")
429     def assertInSaltStateWarning(self, in_comment, ret):
430         for saltret in self.__getWithinSaltReturn(ret, "warnings"):
431             self.assertIn(in_comment, saltret)
432     def assertNotInSaltStateWarning(self, not_in_comment, ret):
433         for saltret in self.__getWithinSaltReturn(ret, "warnings"):
434             self.assertNotIn(not_in_comment, saltret)
435     def assertInSaltReturn(self, item_to_check, ret, keys):
436         for saltret in self.__getWithinSaltReturn(ret, keys):
437             self.assertIn(item_to_check, saltret)
438     def assertNotInSaltReturn(self, item_to_check, ret, keys):
439         for saltret in self.__getWithinSaltReturn(ret, keys):
440             self.assertNotIn(item_to_check, saltret)
441     def assertInSaltReturnRegexpMatches(self, ret, pattern, keys=()):
442         for saltret in self.__getWithinSaltReturn(ret, keys):
443             self.assertRegex(saltret, pattern)
444     def assertSaltStateChangesEqual(self, ret, comparison, keys=()):
445         keys = ["changes"] + self.__return_valid_keys(keys)
446         for saltret in self.__getWithinSaltReturn(ret, keys):
447             self.assertEqual(saltret, comparison)
448     def assertSaltStateChangesNotEqual(self, ret, comparison, keys=()):
449         keys = ["changes"] + self.__return_valid_keys(keys)
450         for saltret in self.__getWithinSaltReturn(ret, keys):
451             self.assertNotEqual(saltret, comparison)
452 def _fetch_events(q, opts):
453     def _clean_queue():
454         log.info("Cleaning queue!")
455         while not q.empty():
456             queue_item = q.get()
457             queue_item.task_done()
458     atexit.register(_clean_queue)
459     with salt.utils.event.get_event(
460         "minion", sock_dir=opts["sock_dir"], opts=opts
461     ) as event:
462         while not event.connect_pull(30):
463             time.sleep(1)
464         q.put("CONNECTED")
465         while True:
466             try:
467                 events = event.get_event(full=False)
468             except Exception as exc:  # pylint: disable=broad-except
469                 log.exception("Exception caught while getting events %r", exc)
470             q.put(events)
471 class SaltMinionEventAssertsMixin:
472     @classmethod
473     def setUpClass(cls):
474         opts = copy.deepcopy(RUNTIME_VARS.RUNTIME_CONFIGS["minion"])
475         cls.q = multiprocessing.Queue()
476         cls.fetch_proc = salt.utils.process.SignalHandlingProcess(
477             target=_fetch_events,
478             args=(cls.q, opts),
479             name="Process-{}-Queue".format(cls.__name__),
480         )
481         cls.fetch_proc.start()
482         msg = cls.q.get(block=True)
483         if msg != "CONNECTED":
484             raise RuntimeError("Unexpected message in test's event queue")
485     @classmethod
486     def tearDownClass(cls):
487         cls.fetch_proc.join()
488         del cls.q
489         del cls.fetch_proc
490     def assertMinionEventFired(self, tag):
491         raise salt.exceptions.NotImplemented("assertMinionEventFired() not implemented")
492     def assertMinionEventReceived(self, desired_event, timeout=5, sleep_time=0.5):
493         start = time.time()
494         while True:
495             try:
496                 event = self.q.get(False)
497             except queue.Empty:
498                 time.sleep(sleep_time)
499                 if time.time() - start &gt;= timeout:
500                     break
501                 continue
502             if isinstance(event, dict):
503                 event.pop("_stamp")
504             if desired_event == event:
505                 self.fetch_proc.terminate()
506                 return True
507             if time.time() - start &gt;= timeout:
508                 break
509         self.fetch_proc.terminate()
510         raise AssertionError(
511             "Event {} was not received by minion".format(desired_event)
512         )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>selinux_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import os
2 import re
3 import salt.utils.decorators as decorators
4 import salt.utils.files
5 import salt.utils.path
6 import salt.utils.stringutils
7 import salt.utils.versions
8 from salt.exceptions import CommandExecutionError, SaltInvocationError
9 _SELINUX_FILETYPES = {
10     "a": "all files",
11     "f": "regular file",
12     "d": "directory",
13     "c": "character device",
14     "b": "block device",
15     "s": "socket",
16     "l": "symbolic link",
17     "p": "named pipe",
18 }
19 def __virtual__():
20     required_cmds = ("semanage", "setsebool", "semodule")
21     for cmd in required_cmds:
22         if not salt.utils.path.which(cmd):
23             return (False, cmd + " is not in the path")
24     if __grains__["kernel"] == "Linux":
25         return "selinux"
26     return (False, "Module only works on Linux with selinux installed")
27 @decorators.memoize
28 def selinux_fs_path():
29     try:
30         for directory in ("/sys/fs/selinux", "/selinux"):
31             if os.path.isdir(directory):
32                 if os.path.isfile(os.path.join(directory, "enforce")):
33                     return directory
34         return None
35     except AttributeError:
36         return None
37 def getenforce():
38     _selinux_fs_path = selinux_fs_path()
39     if _selinux_fs_path is None:
40         return "Disabled"
41     try:
42         enforce = os.path.join(_selinux_fs_path, "enforce")
43         with salt.utils.files.fopen(enforce, "r") as _fp:
44             if salt.utils.stringutils.to_unicode(_fp.readline()).strip() == "0":
45                 return "Permissive"
46             else:
47                 return "Enforcing"
48     except (OSError, AttributeError):
49         return "Disabled"
50 def getconfig():
51     try:
52         config = "/etc/selinux/config"
53         with salt.utils.files.fopen(config, "r") as _fp:
54             for line in _fp:
55                 line = salt.utils.stringutils.to_unicode(line)
56                 if line.strip().startswith("SELINUX="):
57                     return line.split("=")[1].capitalize().strip()
58     except (OSError, AttributeError):
59         return None
60     return None
61 def setenforce(mode):
62     if isinstance(mode, str):
63         if mode.lower() == "enforcing":
64             mode = "1"
65             modestring = "Enforcing"
66         elif mode.lower() == "permissive":
67             mode = "0"
68             modestring = "Permissive"
69         elif mode.lower() == "disabled":
70             mode = "0"
71             modestring = "Disabled"
72         else:
73             return "Invalid mode {}".format(mode)
74     elif isinstance(mode, int):
75         if mode:
76             mode = "1"
77         else:
78             mode = "0"
79     else:
80         return "Invalid mode {}".format(mode)
81     if getenforce() != "Disabled":
82         enforce = os.path.join(selinux_fs_path(), "enforce")
83         try:
84             with salt.utils.files.fopen(enforce, "w") as _fp:
85                 _fp.write(salt.utils.stringutils.to_str(mode))
86         except OSError as exc:
87             msg = "Could not write SELinux enforce file: {0}"
88             raise CommandExecutionError(msg.format(exc))
89     config = "/etc/selinux/config"
90     try:
91         with salt.utils.files.fopen(config, "r") as _cf:
92             conf = _cf.read()
93         try:
94             with salt.utils.files.fopen(config, "w") as _cf:
95                 conf = re.sub(r"\nSELINUX=.*\n", "\nSELINUX=" + modestring + "\n", conf)
96                 _cf.write(salt.utils.stringutils.to_str(conf))
97         except OSError as exc:
98             msg = "Could not write SELinux config file: {0}"
99             raise CommandExecutionError(msg.format(exc))
100     except OSError as exc:
101         msg = "Could not read SELinux config file: {0}"
102         raise CommandExecutionError(msg.format(exc))
103     return getenforce()
104 def getsebool(boolean):
105     return list_sebool().get(boolean, {})
106 def setsebool(boolean, value, persist=False):
107     if persist:
108         cmd = "setsebool -P {} {}".format(boolean, value)
109     else:
110         cmd = "setsebool {} {}".format(boolean, value)
111     return not __salt__["cmd.retcode"](cmd, python_shell=False)
112 def setsebools(pairs, persist=False):
113     if not isinstance(pairs, dict):
114         return {}
115     if persist:
116         cmd = "setsebool -P "
117     else:
118         cmd = "setsebool "
119     for boolean, value in pairs.items():
120         cmd = "{} {}={}".format(cmd, boolean, value)
121     return not __salt__["cmd.retcode"](cmd, python_shell=False)
122 def list_sebool():
123     bdata = __salt__["cmd.run"]("semanage boolean -l").splitlines()
124     ret = {}
125     for line in bdata[1:]:
126         if not line.strip():
127             continue
128         comps = line.split()
129         ret[comps[0]] = {
130             "State": comps[1][1:],
131             "Default": comps[3][:-1],
132             "Description": " ".join(comps[4:]),
133         }
134     return ret
135 def getsemod(module):
136     return list_semod().get(module, {})
137 def setsemod(module, state):
138     if state.lower() == "enabled":
139         cmd = "semodule -e {}".format(module)
140     elif state.lower() == "disabled":
141         cmd = "semodule -d {}".format(module)
142     return not __salt__["cmd.retcode"](cmd)
143 def install_semod(module_path):
144     if module_path.find("salt://") == 0:
145         module_path = __salt__["cp.cache_file"](module_path)
146     cmd = "semodule -i {}".format(module_path)
147     return not __salt__["cmd.retcode"](cmd)
148 def remove_semod(module):
149     cmd = "semodule -r {}".format(module)
150     return not __salt__["cmd.retcode"](cmd)
151 def list_semod():
152     helptext = __salt__["cmd.run"]("semodule -h").splitlines()
153     semodule_version = ""
154     for line in helptext:
155         if line.strip().startswith("full"):
156             semodule_version = "new"
157     if semodule_version == "new":
158         mdata = __salt__["cmd.run"]("semodule -lfull").splitlines()
159         ret = {}
160         for line in mdata:
161             if not line.strip():
162                 continue
163             comps = line.split()
164             if len(comps) == 4:
165                 ret[comps[1]] = {"Enabled": False, "Version": None}
166             else:
167                 ret[comps[1]] = {"Enabled": True, "Version": None}
168     else:
169         mdata = __salt__["cmd.run"]("semodule -l").splitlines()
170         ret = {}
171         for line in mdata:
172             if not line.strip():
173                 continue
174             comps = line.split()
175             if len(comps) == 3:
176                 ret[comps[0]] = {"Enabled": False, "Version": comps[1]}
177             else:
178                 ret[comps[0]] = {"Enabled": True, "Version": comps[1]}
179     return ret
180 def _validate_filetype(filetype):
181     if filetype not in _SELINUX_FILETYPES.keys():
182         raise SaltInvocationError("Invalid filetype given: {}".format(filetype))
183     return True
184 def _parse_protocol_port(name, protocol, port):
185     protocol_port_pattern = r"^(tcp|udp)\/(([\d]+)\-?[\d]+)$"
186     name_parts = re.match(protocol_port_pattern, name)
187     if not name_parts:
188         name_parts = re.match(protocol_port_pattern, "{}/{}".format(protocol, port))
189     if not name_parts:
190         raise SaltInvocationError(
191             'Invalid name "{}" format and protocol and port not provided or invalid:'
192             ' "{}" "{}".'.format(name, protocol, port)
193         )
194     return name_parts.group(1), name_parts.group(2)
195 def _context_dict_to_string(context):
196     return "{sel_user}:{sel_role}:{sel_type}:{sel_level}".format(**context)
197 def _context_string_to_dict(context):
198     if not re.match("[^:]+:[^:]+:[^:]+:[^:]+$", context):
199         raise SaltInvocationError(
200             "Invalid SELinux context string: {0}. "
201             + 'Expected "sel_user:sel_role:sel_type:sel_level"'
202         )
203     context_list = context.split(":", 3)
204     ret = {}
205     for index, value in enumerate(["sel_user", "sel_role", "sel_type", "sel_level"]):
206         ret[value] = context_list[index]
207     return ret
208 def filetype_id_to_string(filetype="a"):
209     _validate_filetype(filetype)
210     return _SELINUX_FILETYPES.get(filetype, "error")
211 def fcontext_get_policy(
212     name, filetype=None, sel_type=None, sel_user=None, sel_level=None
213 ):
214     if filetype:
215         _validate_filetype(filetype)
216     re_spacer = "[ ]+"
217     cmd_kwargs = {
218         "spacer": re_spacer,
219         "filespec": re.escape(name),
220         "sel_user": sel_user or "[^:]+",
221         "sel_role": "[^:]+",  # se_role for file context is always object_r
222         "sel_type": sel_type or "[^:]+",
223         "sel_level": sel_level or "[^:]+",
224     }
225     cmd_kwargs["filetype"] = (
226         "[[:alpha:] ]+" if filetype is None else filetype_id_to_string(filetype)
227     )
228     cmd = (
229         "semanage fcontext -l | egrep "
230         + "'^{filespec}{spacer}{filetype}{spacer}{sel_user}:{sel_role}:{sel_type}:{sel_level}$'".format(
231             **cmd_kwargs
232         )
233     )
234     current_entry_text = __salt__["cmd.shell"](cmd, ignore_retcode=True)
235     if current_entry_text == "":
236         return None
237     parts = re.match(
238         r"^({filespec}) +([a-z ]+) (.*)$".format(**{"filespec": re.escape(name)}),
239         current_entry_text,
240     )
241     ret = {
242         "filespec": parts.group(1).strip(),
243         "filetype": parts.group(2).strip(),
244     }
245     ret.update(_context_string_to_dict(parts.group(3).strip()))
246     return ret
247 def fcontext_add_policy(
248     name, filetype=None, sel_type=None, sel_user=None, sel_level=None
249 ):
250     return _fcontext_add_or_delete_policy(
251         "add", name, filetype, sel_type, sel_user, sel_level
252     )
253 def fcontext_delete_policy(
254     name, filetype=None, sel_type=None, sel_user=None, sel_level=None
255 ):
256     return _fcontext_add_or_delete_policy(
257         "delete", name, filetype, sel_type, sel_user, sel_level
258     )
259 def _fcontext_add_or_delete_policy(
260     action, name, filetype=None, sel_type=None, sel_user=None, sel_level=None
261 ):
262     if action not in ["add", "delete"]:
263         raise SaltInvocationError(
264             'Actions supported are "add" and "delete", not "{}".'.format(action)
265         )
266     cmd = "semanage fcontext --{}".format(action)
267     if filetype is not None and filetype != "a":
268         _validate_filetype(filetype)
269         cmd += " --ftype {}".format(filetype)
270     if sel_type is not None:
271         cmd += " --type {}".format(sel_type)
272     if sel_user is not None:
273         cmd += " --seuser {}".format(sel_user)
274     if sel_level is not None:
275         cmd += " --range {}".format(sel_level)
276     cmd += " " + re.escape(name)
277     return __salt__["cmd.run_all"](cmd)
278 def fcontext_policy_is_applied(name, recursive=False):
279     cmd = "restorecon -n -v "
280     if recursive:
281         cmd += "-R "
282     cmd += re.escape(name)
283     return __salt__["cmd.run_all"](cmd).get("stdout")
284 def fcontext_apply_policy(name, recursive=False):
285     ret = {}
286     changes_text = fcontext_policy_is_applied(name, recursive)
287     cmd = "restorecon -v -F "
288     if recursive:
289         cmd += "-R "
290     cmd += re.escape(name)
291     apply_ret = __salt__["cmd.run_all"](cmd)
292 <a name="0"></a>    ret.update(apply_ret)
293     if apply_ret["retcode"] == 0:
294         changes_list = []
295         if changes_text<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.startswith("Would relabel"):
296             changes_list = re.findall(
297                 "Would relabel (.*) from (.*) to (.*)$", changes_text, re.M
298             )
299         elif changes_text.startswith("restorecon reset"):
300             changes_list = re.findall(
301                 "restorecon reset (.*) context (.*)-&gt;(.*)$", changes_text, re.</b></font>M
302             )
303         else:
304             ret["retcode"] = 1
305             ret["error"] = "Unrecognized response from restorecon command."
306             return ret
307         if changes_list:
308             ret.update({"changes": {}})
309         for item in changes_list:
310             filespec = item[0]
311             old = _context_string_to_dict(item[1])
312             new = _context_string_to_dict(item[2])
313             intersect = {}
314             for key, value in old.items():
315                 if new.get(key) == value:
316                     intersect.update({key: value})
317             for key in intersect:
318                 del old[key]
319                 del new[key]
320             ret["changes"].update({filespec: {"old": old, "new": new}})
321     return ret
322 def port_get_policy(name, sel_type=None, protocol=None, port=None):
323     (protocol, port) = _parse_protocol_port(name, protocol, port)
324     re_spacer = "[ ]+"
325     re_sel_type = sel_type if sel_type else r"\w+"
326     cmd_kwargs = {
327         "spacer": re_spacer,
328         "sel_type": re_sel_type,
329         "protocol": protocol,
330         "port": port,
331     }
332     cmd = (
333         "semanage port -l | egrep "
334         + "'^{sel_type}{spacer}{protocol}{spacer}((.*)*)[ ]{port}($|,)'".format(
335             **cmd_kwargs
336         )
337     )
338     port_policy = __salt__["cmd.shell"](cmd, ignore_retcode=True)
339     if port_policy == "":
340         return None
341     parts = re.match(r"^(\w+)[ ]+(\w+)[ ]+([\d\-, ]+)", port_policy)
342     return {
343         "sel_type": parts.group(1).strip(),
344         "protocol": parts.group(2).strip(),
345         "port": parts.group(3).strip(),
346     }
347 def port_add_policy(name, sel_type=None, protocol=None, port=None, sel_range=None):
348     return _port_add_or_delete_policy("add", name, sel_type, protocol, port, sel_range)
349 def port_delete_policy(name, protocol=None, port=None):
350     return _port_add_or_delete_policy("delete", name, None, protocol, port, None)
351 def _port_add_or_delete_policy(
352     action, name, sel_type=None, protocol=None, port=None, sel_range=None
353 ):
354     if action not in ["add", "delete"]:
355         raise SaltInvocationError(
356             'Actions supported are "add" and "delete", not "{}".'.format(action)
357         )
358     if action == "add" and not sel_type:
359         raise SaltInvocationError("SELinux Type is required to add a policy")
360     (protocol, port) = _parse_protocol_port(name, protocol, port)
361     cmd = "semanage port --{} --proto {}".format(action, protocol)
362     if sel_type:
363         cmd += " --type {}".format(sel_type)
364     if sel_range:
365         cmd += " --range {}".format(sel_range)
366     cmd += " {}".format(port)
367     return __salt__["cmd.run_all"](cmd)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
