<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for mixins.py &amp; selinux_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for mixins.py &amp; selinux_1.py
      </h3>
<h1 align="center">
        1.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>mixins.py (1.1070111%)<th>selinux_1.py (1.5189873%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(67-74)<td><a href="#" name="0">(684-690)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mixins.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import atexit
2 import copy
3 import functools
4 import logging
5 import multiprocessing
6 import os
7 import pprint
8 import queue
9 import subprocess
10 import tempfile
11 import time
12 import xml.etree.ElementTree as etree
13 import salt.config
14 import salt.exceptions
15 import salt.utils.event
16 import salt.utils.files
17 import salt.utils.functools
18 import salt.utils.path
19 import salt.utils.process
20 import salt.utils.stringutils
21 import salt.utils.yaml
22 import salt.version
23 from salt.utils.immutabletypes import freeze
24 from salt.utils.verify import verify_env
25 from saltfactories.utils import random_string
26 from tests.support.paths import CODE_DIR
27 from tests.support.pytest.loader import LoaderModuleMock
28 from tests.support.runtests import RUNTIME_VARS
29 log = logging.getLogger(__name__)
30 class CheckShellBinaryNameAndVersionMixin:
31     _call_binary_ = None
32     _call_binary_expected_version_ = None
33     def test_version_includes_binary_name(self):
34         if getattr(self, "_call_binary_", None) is None:
35             self.skipTest("'_call_binary_' not defined.")
36         if self._call_binary_expected_version_ is None:
37             self._call_binary_expected_version_ = salt.version.__version__
38         out = "\n".join(self.run_script(self._call_binary_, "--version"))
39         try:
40         except AssertionError:
41             alternate_binary_name = self._call_binary_<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.replace("-", "_")
42             errmsg = "Neither '{}' or '{}' were found as part of the binary name in:\n'{}'".format(
43                 self._call_binary_, alternate_binary_name, out
44             )
45             self.assertIn(alternate_binary_name, out, msg=errmsg)
46         self.assertIn(self.</b></font>_call_binary_expected_version_, out)
47 class AdaptedConfigurationTestCaseMixin:
48     __slots__ = ()
49     @staticmethod
50     def get_temp_config(config_for, **config_overrides):
51         rootdir = config_overrides.get(
52             "root_dir", tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
53         )
54         if not os.path.exists(rootdir):
55             os.makedirs(rootdir)
56         conf_dir = config_overrides.pop("conf_dir", os.path.join(rootdir, "conf"))
57         for key in ("cachedir", "pki_dir", "sock_dir"):
58             if key not in config_overrides:
59                 config_overrides[key] = key
60         if "log_file" not in config_overrides:
61             config_overrides["log_file"] = "logs/{}.log".format(config_for)
62         if "user" not in config_overrides:
63             config_overrides["user"] = RUNTIME_VARS.RUNNING_TESTS_USER
64         config_overrides["root_dir"] = rootdir
65         cdict = AdaptedConfigurationTestCaseMixin.get_config(
66             config_for, from_scratch=True
67         )
68         if config_for in ("master", "client_config"):
69             rdict = salt.config.apply_master_config(config_overrides, cdict)
70         if config_for == "minion":
71             minion_id = (
72                 config_overrides.get("id")
73                 or config_overrides.get("minion_id")
74                 or cdict.get("id")
75                 or cdict.get("minion_id")
76                 or random_string("temp-minion-")
77             )
78             config_overrides["minion_id"] = config_overrides["id"] = minion_id
79             rdict = salt.config.apply_minion_config(
80                 config_overrides, cdict, cache_minion_id=False, minion_id=minion_id
81             )
82         verify_env(
83             [
84                 os.path.join(rdict["pki_dir"], "minions"),
85                 os.path.join(rdict["pki_dir"], "minions_pre"),
86                 os.path.join(rdict["pki_dir"], "minions_rejected"),
87                 os.path.join(rdict["pki_dir"], "minions_denied"),
88                 os.path.join(rdict["cachedir"], "jobs"),
89                 os.path.join(rdict["cachedir"], "tokens"),
90                 os.path.join(rdict["root_dir"], "cache", "tokens"),
91                 os.path.join(rdict["pki_dir"], "accepted"),
92                 os.path.join(rdict["pki_dir"], "rejected"),
93                 os.path.join(rdict["pki_dir"], "pending"),
94                 os.path.dirname(rdict["log_file"]),
95                 rdict["sock_dir"],
96                 conf_dir,
97             ],
98             RUNTIME_VARS.RUNNING_TESTS_USER,
99             root_dir=rdict["root_dir"],
100         )
101         rdict["conf_file"] = os.path.join(conf_dir, config_for)
102         with salt.utils.files.fopen(rdict["conf_file"], "w") as wfh:
103             salt.utils.yaml.safe_dump(rdict, wfh, default_flow_style=False)
104         return rdict
105     @staticmethod
106     def get_config(config_for, from_scratch=False):
107         if from_scratch:
108             if config_for in ("master", "syndic_master", "mm_master", "mm_sub_master"):
109                 return salt.config.master_config(
110                     AdaptedConfigurationTestCaseMixin.get_config_file_path(config_for)
111                 )
112             elif config_for in ("minion", "sub_minion"):
113                 return salt.config.minion_config(
114                     AdaptedConfigurationTestCaseMixin.get_config_file_path(config_for),
115                     cache_minion_id=False,
116                 )
117             elif config_for in ("syndic",):
118                 return salt.config.syndic_config(
119                     AdaptedConfigurationTestCaseMixin.get_config_file_path(config_for),
120                     AdaptedConfigurationTestCaseMixin.get_config_file_path("minion"),
121                 )
122             elif config_for == "client_config":
123                 return salt.config.client_config(
124                     AdaptedConfigurationTestCaseMixin.get_config_file_path("master")
125                 )
126         if config_for not in RUNTIME_VARS.RUNTIME_CONFIGS:
127             if config_for in ("master", "syndic_master", "mm_master", "mm_sub_master"):
128                 RUNTIME_VARS.RUNTIME_CONFIGS[config_for] = freeze(
129                     salt.config.master_config(
130                         AdaptedConfigurationTestCaseMixin.get_config_file_path(
131                             config_for
132                         )
133                     )
134                 )
135             elif config_for in ("minion", "sub_minion"):
136                 RUNTIME_VARS.RUNTIME_CONFIGS[config_for] = freeze(
137                     salt.config.minion_config(
138                         AdaptedConfigurationTestCaseMixin.get_config_file_path(
139                             config_for
140                         )
141                     )
142                 )
143             elif config_for in ("syndic",):
144                 RUNTIME_VARS.RUNTIME_CONFIGS[config_for] = freeze(
145                     salt.config.syndic_config(
146                         AdaptedConfigurationTestCaseMixin.get_config_file_path(
147                             config_for
148                         ),
149                         AdaptedConfigurationTestCaseMixin.get_config_file_path(
150                             "minion"
151                         ),
152                     )
153                 )
154             elif config_for == "client_config":
155                 RUNTIME_VARS.RUNTIME_CONFIGS[config_for] = freeze(
156                     salt.config.client_config(
157                         AdaptedConfigurationTestCaseMixin.get_config_file_path("master")
158                     )
159                 )
160         return RUNTIME_VARS.RUNTIME_CONFIGS[config_for]
161     @property
162     def config_dir(self):
163         return RUNTIME_VARS.TMP_CONF_DIR
164     def get_config_dir(self):
165         log.warning("Use the config_dir attribute instead of calling get_config_dir()")
166         return self.config_dir
167     @staticmethod
168     def get_config_file_path(filename):
169         if filename == "master":
170             return os.path.join(RUNTIME_VARS.TMP_CONF_DIR, filename)
171         if filename == "minion":
172             return os.path.join(RUNTIME_VARS.TMP_MINION_CONF_DIR, filename)
173         if filename == "syndic_master":
174             return os.path.join(RUNTIME_VARS.TMP_SYNDIC_MASTER_CONF_DIR, "master")
175         if filename == "syndic":
176             return os.path.join(RUNTIME_VARS.TMP_SYNDIC_MINION_CONF_DIR, "minion")
177         if filename == "sub_minion":
178             return os.path.join(RUNTIME_VARS.TMP_SUB_MINION_CONF_DIR, "minion")
179         if filename == "mm_master":
180             return os.path.join(RUNTIME_VARS.TMP_MM_CONF_DIR, "master")
181         if filename == "mm_sub_master":
182             return os.path.join(RUNTIME_VARS.TMP_MM_SUB_CONF_DIR, "master")
183         if filename == "mm_minion":
184             return os.path.join(RUNTIME_VARS.TMP_MM_MINION_CONF_DIR, "minion")
185         if filename == "mm_sub_minion":
186             return os.path.join(RUNTIME_VARS.TMP_MM_SUB_MINION_CONF_DIR, "minion")
187         return os.path.join(RUNTIME_VARS.TMP_CONF_DIR, filename)
188     @property
189     def master_opts(self):
190         return self.get_config("master")
191     @property
192     def minion_opts(self):
193         return self.get_config("minion")
194     @property
195     def sub_minion_opts(self):
196         return self.get_config("sub_minion")
197 class SaltClientTestCaseMixin(AdaptedConfigurationTestCaseMixin):
198     _salt_client_config_file_name_ = "master"
199     @property
200     def client(self):
201         import salt.client
202         if "runtime_client" not in RUNTIME_VARS.RUNTIME_CONFIGS:
203             mopts = self.get_config(
204                 self._salt_client_config_file_name_, from_scratch=True
205             )
206             RUNTIME_VARS.RUNTIME_CONFIGS[
207                 "runtime_client"
208             ] = salt.client.get_local_client(mopts=mopts)
209         return RUNTIME_VARS.RUNTIME_CONFIGS["runtime_client"]
210 class ShellCaseCommonTestsMixin(CheckShellBinaryNameAndVersionMixin):
211     _call_binary_expected_version_ = salt.version.__version__
212     def test_salt_with_git_version(self):
213         if getattr(self, "_call_binary_", None) is None:
214             self.skipTest("'_call_binary_' not defined.")
215         from salt.version import __version_info__, SaltStackVersion
216         git = salt.utils.path.which("git")
217         if not git:
218             self.skipTest("The git binary is not available")
219         opts = {
220             "stdout": subprocess.PIPE,
221             "stderr": subprocess.PIPE,
222             "cwd": CODE_DIR,
223         }
224         if not salt.utils.platform.is_windows():
225             opts["close_fds"] = True
226         process = subprocess.Popen(
227             [git, "describe", "--tags", "--first-parent", "--match", "v[0-9]*"], **opts
228         )
229         out, err = process.communicate()
230         if process.returncode != 0:
231             process = subprocess.Popen(
232                 [git, "describe", "--tags", "--match", "v[0-9]*"], **opts
233             )
234             out, err = process.communicate()
235         if not out:
236             self.skipTest(
237                 "Failed to get the output of 'git describe'. Error: '{}'".format(
238                     salt.utils.stringutils.to_str(err)
239                 )
240             )
241         parsed_version = SaltStackVersion.parse(out)
242         if parsed_version.info &lt; __version_info__:
243             self.skipTest(
244                 "We're likely about to release a new version. This test "
245                 "would fail. Parsed('{}') &lt; Expected('{}')".format(
246                     parsed_version.info, __version_info__
247                 )
248             )
249         elif parsed_version.info != __version_info__:
250             self.skipTest(
251                 "In order to get the proper salt version with the "
252                 "git hash you need to update salt's local git "
253                 "tags. Something like: 'git fetch --tags' or "
254                 "'git fetch --tags upstream' if you followed "
255                 "salt's contribute documentation. The version "
256                 "string WILL NOT include the git hash."
257             )
258         out = "\n".join(self.run_script(self._call_binary_, "--version"))
259         self.assertIn(parsed_version.string, out)
260 class _FixLoaderModuleMockMixinMroOrder(type):
261     def __new__(mcs, cls_name, cls_bases, cls_dict):
262         if cls_name == "LoaderModuleMockMixin":
263             return super().__new__(mcs, cls_name, cls_bases, cls_dict)
264         bases = list(cls_bases)
265         for idx, base in enumerate(bases):
266             if base.__name__ == "LoaderModuleMockMixin":
267                 bases.insert(0, bases.pop(idx))
268                 break
269         instance = super().__new__(mcs, cls_name, tuple(bases), cls_dict)
270         instance.setUp = LoaderModuleMockMixin.__setup_loader_modules_mocks__(
271             instance.setUp
272         )
273         return instance
274 class LoaderModuleMockMixin(metaclass=_FixLoaderModuleMockMixinMroOrder):
275     @staticmethod
276     def __setup_loader_modules_mocks__(setup_func):
277         @functools.wraps(setup_func)
278         def wrapper(self):
279             loader_modules_configs = self.setup_loader_modules()
280             if not isinstance(loader_modules_configs, dict):
281                 raise RuntimeError(
282                     "{}.setup_loader_modules() must return a dictionary where the keys"
283                     " are the modules that require loader mocking setup and the values,"
284                     " the global module variables for each of the module being mocked."
285                     " For example '__salt__', '__opts__', etc.".format(
286                         self.__class__.__name__
287                     )
288                 )
289             mocker = LoaderModuleMock(loader_modules_configs)
290             mocker.start()
291             self.addCleanup(mocker.stop)
292             return setup_func(self)
293         return wrapper
294     def setup_loader_modules(self):
295         raise NotImplementedError(
296             "'{}.setup_loader_modules()' must be implemented".format(
297                 self.__class__.__name__
298             )
299         )
300 class XMLEqualityMixin:
301     def assertEqualXML(self, e1, e2):
302         if isinstance(e1, bytes):
303             e1 = e1.decode("utf-8")
304         if isinstance(e2, bytes):
305             e2 = e2.decode("utf-8")
306         if isinstance(e1, str):
307             e1 = etree.XML(e1)
308         if isinstance(e2, str):
309             e2 = etree.XML(e2)
310         if e1.tag != e2.tag:
311             return False
312         if e1.text != e2.text:
313             return False
314         if e1.tail != e2.tail:
315             return False
316         if e1.attrib != e2.attrib:
317             return False
318         if len(e1) != len(e2):
319             return False
320         return all(self.assertEqualXML(c1, c2) for c1, c2 in zip(e1, e2))
321 class SaltReturnAssertsMixin:
322     def assertReturnSaltType(self, ret):
323         try:
324             self.assertTrue(isinstance(ret, dict))
325         except AssertionError:
326             raise AssertionError(
327                 "{} is not dict. Salt returned: {}".format(type(ret).__name__, ret)
328             )
329     def assertReturnNonEmptySaltType(self, ret):
330         self.assertReturnSaltType(ret)
331         try:
332             self.assertNotEqual(ret, {})
333         except AssertionError:
334             raise AssertionError(
335                 "{} is equal to {}. Salt returned an empty dictionary."
336             )
337     def __return_valid_keys(self, keys):
338         if isinstance(keys, tuple):
339             keys = list(keys)
340         elif isinstance(keys, str):
341             keys = [keys]
342         elif not isinstance(keys, list):
343             raise RuntimeError("The passed keys need to be a list")
344         return keys
345     def __getWithinSaltReturn(self, ret, keys):
346         self.assertReturnNonEmptySaltType(ret)
347         ret_data = []
348         for part in ret.values():
349             keys = self.__return_valid_keys(keys)
350             okeys = keys[:]
351             try:
352                 ret_item = part[okeys.pop(0)]
353             except (KeyError, TypeError):
354                 raise AssertionError(
355                     "Could not get ret{} from salt's return: {}".format(
356                         "".join(["['{}']".format(k) for k in keys]), part
357                     )
358                 )
359             while okeys:
360                 try:
361                     ret_item = ret_item[okeys.pop(0)]
362                 except (KeyError, TypeError):
363                     raise AssertionError(
364                         "Could not get ret{} from salt's return: {}".format(
365                             "".join(["['{}']".format(k) for k in keys]), part
366                         )
367                     )
368             ret_data.append(ret_item)
369         return ret_data
370     def assertSaltTrueReturn(self, ret):
371         try:
372             for saltret in self.__getWithinSaltReturn(ret, "result"):
373                 self.assertTrue(saltret)
374         except AssertionError:
375             log.info("Salt Full Return:\n%s", pprint.pformat(ret))
376             try:
377                 raise AssertionError(
378                     "{result} is not True. Salt Comment:\n{comment}".format(
379                         **(next(iter(ret.values())))
380                     )
381                 )
382             except (AttributeError, IndexError):
383                 raise AssertionError(
384                     "Failed to get result. Salt Returned:\n{}".format(
385                         pprint.pformat(ret)
386                     )
387                 )
388     def assertSaltFalseReturn(self, ret):
389         try:
390             for saltret in self.__getWithinSaltReturn(ret, "result"):
391                 self.assertFalse(saltret)
392         except AssertionError:
393             log.info("Salt Full Return:\n%s", pprint.pformat(ret))
394             try:
395                 raise AssertionError(
396                     "{result} is not False. Salt Comment:\n{comment}".format(
397                         **(next(iter(ret.values())))
398                     )
399                 )
400             except (AttributeError, IndexError):
401                 raise AssertionError(
402                     "Failed to get result. Salt Returned: {}".format(ret)
403                 )
404     def assertSaltNoneReturn(self, ret):
405         try:
406             for saltret in self.__getWithinSaltReturn(ret, "result"):
407                 self.assertIsNone(saltret)
408         except AssertionError:
409             log.info("Salt Full Return:\n%s", pprint.pformat(ret))
410             try:
411                 raise AssertionError(
412                     "{result} is not None. Salt Comment:\n{comment}".format(
413                         **(next(iter(ret.values())))
414                     )
415                 )
416             except (AttributeError, IndexError):
417                 raise AssertionError(
418                     "Failed to get result. Salt Returned: {}".format(ret)
419                 )
420     def assertInSaltComment(self, in_comment, ret):
421         for saltret in self.__getWithinSaltReturn(ret, "comment"):
422             self.assertIn(in_comment, saltret)
423     def assertNotInSaltComment(self, not_in_comment, ret):
424         for saltret in self.__getWithinSaltReturn(ret, "comment"):
425             self.assertNotIn(not_in_comment, saltret)
426     def assertSaltCommentRegexpMatches(self, ret, pattern):
427         return self.assertInSaltReturnRegexpMatches(ret, pattern, "comment")
428     def assertInSaltStateWarning(self, in_comment, ret):
429         for saltret in self.__getWithinSaltReturn(ret, "warnings"):
430             self.assertIn(in_comment, saltret)
431     def assertNotInSaltStateWarning(self, not_in_comment, ret):
432         for saltret in self.__getWithinSaltReturn(ret, "warnings"):
433             self.assertNotIn(not_in_comment, saltret)
434     def assertInSaltReturn(self, item_to_check, ret, keys):
435         for saltret in self.__getWithinSaltReturn(ret, keys):
436             self.assertIn(item_to_check, saltret)
437     def assertNotInSaltReturn(self, item_to_check, ret, keys):
438         for saltret in self.__getWithinSaltReturn(ret, keys):
439             self.assertNotIn(item_to_check, saltret)
440     def assertInSaltReturnRegexpMatches(self, ret, pattern, keys=()):
441         for saltret in self.__getWithinSaltReturn(ret, keys):
442             self.assertRegex(saltret, pattern)
443     def assertSaltStateChangesEqual(self, ret, comparison, keys=()):
444         keys = ["changes"] + self.__return_valid_keys(keys)
445         for saltret in self.__getWithinSaltReturn(ret, keys):
446             self.assertEqual(saltret, comparison)
447     def assertSaltStateChangesNotEqual(self, ret, comparison, keys=()):
448         keys = ["changes"] + self.__return_valid_keys(keys)
449         for saltret in self.__getWithinSaltReturn(ret, keys):
450             self.assertNotEqual(saltret, comparison)
451 def _fetch_events(q, opts):
452     def _clean_queue():
453         log.info("Cleaning queue!")
454         while not q.empty():
455             queue_item = q.get()
456             queue_item.task_done()
457     atexit.register(_clean_queue)
458     with salt.utils.event.get_event(
459         "minion", sock_dir=opts["sock_dir"], opts=opts
460     ) as event:
461         while not event.connect_pull(30):
462             time.sleep(1)
463         q.put("CONNECTED")
464         while True:
465             try:
466                 events = event.get_event(full=False)
467             except Exception as exc:  # pylint: disable=broad-except
468                 log.exception("Exception caught while getting events %r", exc)
469             q.put(events)
470 class SaltMinionEventAssertsMixin:
471     @classmethod
472     def setUpClass(cls):
473         opts = copy.deepcopy(RUNTIME_VARS.RUNTIME_CONFIGS["minion"])
474         cls.q = multiprocessing.Queue()
475         cls.fetch_proc = salt.utils.process.SignalHandlingProcess(
476             target=_fetch_events,
477             args=(cls.q, opts),
478             name="Process-{}-Queue".format(cls.__name__),
479         )
480         cls.fetch_proc.start()
481         msg = cls.q.get(block=True)
482         if msg != "CONNECTED":
483             raise RuntimeError("Unexpected message in test's event queue")
484     @classmethod
485     def tearDownClass(cls):
486         cls.fetch_proc.join()
487         del cls.q
488         del cls.fetch_proc
489     def assertMinionEventFired(self, tag):
490         raise salt.exceptions.NotImplemented("assertMinionEventFired() not implemented")
491     def assertMinionEventReceived(self, desired_event, timeout=5, sleep_time=0.5):
492         start = time.time()
493         while True:
494             try:
495                 event = self.q.get(False)
496             except queue.Empty:
497                 time.sleep(sleep_time)
498                 if time.time() - start &gt;= timeout:
499                     break
500                 continue
501             if isinstance(event, dict):
502                 event.pop("_stamp")
503             if desired_event == event:
504                 self.fetch_proc.terminate()
505                 return True
506             if time.time() - start &gt;= timeout:
507                 break
508         self.fetch_proc.terminate()
509         raise AssertionError(
510             "Event {} was not received by minion".format(desired_event)
511         )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>selinux_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import os
2 import re
3 import salt.utils.decorators as decorators
4 import salt.utils.files
5 import salt.utils.path
6 import salt.utils.stringutils
7 import salt.utils.versions
8 from salt.exceptions import CommandExecutionError, SaltInvocationError
9 _SELINUX_FILETYPES = {
10     "a": "all files",
11     "f": "regular file",
12     "d": "directory",
13     "c": "character device",
14     "b": "block device",
15     "s": "socket",
16     "l": "symbolic link",
17     "p": "named pipe",
18 }
19 def __virtual__():
20     required_cmds = ("semanage", "setsebool", "semodule")
21     for cmd in required_cmds:
22         if not salt.utils.path.which(cmd):
23             return (False, cmd + " is not in the path")
24     if __grains__["kernel"] == "Linux":
25         return "selinux"
26     return (False, "Module only works on Linux with selinux installed")
27 @decorators.memoize
28 def selinux_fs_path():
29     try:
30         for directory in ("/sys/fs/selinux", "/selinux"):
31             if os.path.isdir(directory):
32                 if os.path.isfile(os.path.join(directory, "enforce")):
33                     return directory
34         return None
35     except AttributeError:
36         return None
37 def getenforce():
38     _selinux_fs_path = selinux_fs_path()
39     if _selinux_fs_path is None:
40         return "Disabled"
41     try:
42         enforce = os.path.join(_selinux_fs_path, "enforce")
43         with salt.utils.files.fopen(enforce, "r") as _fp:
44             if salt.utils.stringutils.to_unicode(_fp.readline()).strip() == "0":
45                 return "Permissive"
46             else:
47                 return "Enforcing"
48     except (OSError, AttributeError):
49         return "Disabled"
50 def getconfig():
51     try:
52         config = "/etc/selinux/config"
53         with salt.utils.files.fopen(config, "r") as _fp:
54             for line in _fp:
55                 line = salt.utils.stringutils.to_unicode(line)
56                 if line.strip().startswith("SELINUX="):
57                     return line.split("=")[1].capitalize().strip()
58     except (OSError, AttributeError):
59         return None
60     return None
61 def setenforce(mode):
62     if isinstance(mode, str):
63         if mode.lower() == "enforcing":
64             mode = "1"
65             modestring = "Enforcing"
66         elif mode.lower() == "permissive":
67             mode = "0"
68             modestring = "Permissive"
69         elif mode.lower() == "disabled":
70             mode = "0"
71             modestring = "Disabled"
72         else:
73             return "Invalid mode {}".format(mode)
74     elif isinstance(mode, int):
75         if mode:
76             mode = "1"
77         else:
78             mode = "0"
79     else:
80         return "Invalid mode {}".format(mode)
81     if getenforce() != "Disabled":
82         enforce = os.path.join(selinux_fs_path(), "enforce")
83         try:
84             with salt.utils.files.fopen(enforce, "w") as _fp:
85                 _fp.write(salt.utils.stringutils.to_str(mode))
86         except OSError as exc:
87             msg = "Could not write SELinux enforce file: {0}"
88             raise CommandExecutionError(msg.format(exc))
89     config = "/etc/selinux/config"
90     try:
91         with salt.utils.files.fopen(config, "r") as _cf:
92             conf = _cf.read()
93         try:
94             with salt.utils.files.fopen(config, "w") as _cf:
95                 conf = re.sub(r"\nSELINUX=.*\n", "\nSELINUX=" + modestring + "\n", conf)
96                 _cf.write(salt.utils.stringutils.to_str(conf))
97         except OSError as exc:
98             msg = "Could not write SELinux config file: {0}"
99             raise CommandExecutionError(msg.format(exc))
100     except OSError as exc:
101         msg = "Could not read SELinux config file: {0}"
102         raise CommandExecutionError(msg.format(exc))
103     return getenforce()
104 def getsebool(boolean):
105     return list_sebool().get(boolean, {})
106 def setsebool(boolean, value, persist=False):
107     if persist:
108         cmd = "setsebool -P {} {}".format(boolean, value)
109     else:
110         cmd = "setsebool {} {}".format(boolean, value)
111     return not __salt__["cmd.retcode"](cmd, python_shell=False)
112 def setsebools(pairs, persist=False):
113     if not isinstance(pairs, dict):
114         return {}
115     if persist:
116         cmd = "setsebool -P "
117     else:
118         cmd = "setsebool "
119     for boolean, value in pairs.items():
120         cmd = "{} {}={}".format(cmd, boolean, value)
121     return not __salt__["cmd.retcode"](cmd, python_shell=False)
122 def list_sebool():
123     bdata = __salt__["cmd.run"]("semanage boolean -l").splitlines()
124     ret = {}
125     for line in bdata[1:]:
126         if not line.strip():
127             continue
128         comps = line.split()
129         ret[comps[0]] = {
130             "State": comps[1][1:],
131             "Default": comps[3][:-1],
132             "Description": " ".join(comps[4:]),
133         }
134     return ret
135 def getsemod(module):
136     return list_semod().get(module, {})
137 def setsemod(module, state):
138     if state.lower() == "enabled":
139         cmd = "semodule -e {}".format(module)
140     elif state.lower() == "disabled":
141         cmd = "semodule -d {}".format(module)
142     return not __salt__["cmd.retcode"](cmd)
143 def install_semod(module_path):
144     if module_path.find("salt://") == 0:
145         module_path = __salt__["cp.cache_file"](module_path)
146     cmd = "semodule -i {}".format(module_path)
147     return not __salt__["cmd.retcode"](cmd)
148 def remove_semod(module):
149     cmd = "semodule -r {}".format(module)
150     return not __salt__["cmd.retcode"](cmd)
151 def list_semod():
152     helptext = __salt__["cmd.run"]("semodule -h").splitlines()
153     semodule_version = ""
154     for line in helptext:
155         if line.strip().startswith("full"):
156             semodule_version = "new"
157     if semodule_version == "new":
158         mdata = __salt__["cmd.run"]("semodule -lfull").splitlines()
159         ret = {}
160         for line in mdata:
161             if not line.strip():
162                 continue
163             comps = line.split()
164             if len(comps) == 4:
165                 ret[comps[1]] = {"Enabled": False, "Version": None}
166             else:
167                 ret[comps[1]] = {"Enabled": True, "Version": None}
168     else:
169         mdata = __salt__["cmd.run"]("semodule -l").splitlines()
170         ret = {}
171         for line in mdata:
172             if not line.strip():
173                 continue
174             comps = line.split()
175             if len(comps) == 3:
176                 ret[comps[0]] = {"Enabled": False, "Version": comps[1]}
177             else:
178                 ret[comps[0]] = {"Enabled": True, "Version": comps[1]}
179     return ret
180 def _validate_filetype(filetype):
181     if filetype not in _SELINUX_FILETYPES.keys():
182         raise SaltInvocationError("Invalid filetype given: {}".format(filetype))
183     return True
184 def _parse_protocol_port(name, protocol, port):
185     protocol_port_pattern = r"^(tcp|udp)\/(([\d]+)\-?[\d]+)$"
186     name_parts = re.match(protocol_port_pattern, name)
187     if not name_parts:
188         name_parts = re.match(protocol_port_pattern, "{}/{}".format(protocol, port))
189     if not name_parts:
190         raise SaltInvocationError(
191             'Invalid name "{}" format and protocol and port not provided or invalid:'
192             ' "{}" "{}".'.format(name, protocol, port)
193         )
194     return name_parts.group(1), name_parts.group(2)
195 def _context_dict_to_string(context):
196     return "{sel_user}:{sel_role}:{sel_type}:{sel_level}".format(**context)
197 def _context_string_to_dict(context):
198     if not re.match("[^:]+:[^:]+:[^:]+:[^:]+$", context):
199         raise SaltInvocationError(
200             "Invalid SELinux context string: {0}. "
201             + 'Expected "sel_user:sel_role:sel_type:sel_level"'
202         )
203     context_list = context.split(":", 3)
204     ret = {}
205     for index, value in enumerate(["sel_user", "sel_role", "sel_type", "sel_level"]):
206         ret[value] = context_list[index]
207     return ret
208 def filetype_id_to_string(filetype="a"):
209     _validate_filetype(filetype)
210     return _SELINUX_FILETYPES.get(filetype, "error")
211 def fcontext_get_policy(
212     name, filetype=None, sel_type=None, sel_user=None, sel_level=None
213 ):
214     if filetype:
215         _validate_filetype(filetype)
216     re_spacer = "[ ]+"
217     cmd_kwargs = {
218         "spacer": re_spacer,
219         "filespec": re.escape(name),
220         "sel_user": sel_user or "[^:]+",
221         "sel_role": "[^:]+",  # se_role for file context is always object_r
222         "sel_type": sel_type or "[^:]+",
223         "sel_level": sel_level or "[^:]+",
224     }
225     cmd_kwargs["filetype"] = (
226         "[[:alpha:] ]+" if filetype is None else filetype_id_to_string(filetype)
227     )
228     cmd = (
229         "semanage fcontext -l | egrep "
230         + "'^{filespec}{spacer}{filetype}{spacer}{sel_user}:{sel_role}:{sel_type}:{sel_level}$'".format(
231             **cmd_kwargs
232         )
233     )
234     current_entry_text = __salt__["cmd.shell"](cmd, ignore_retcode=True)
235     if current_entry_text == "":
236         return None
237     parts = re.match(
238         r"^({filespec}) +([a-z ]+) (.*)$".format(**{"filespec": re.escape(name)}),
239         current_entry_text,
240     )
241     ret = {
242         "filespec": parts.group(1).strip(),
243         "filetype": parts.group(2).strip(),
244     }
245     ret.update(_context_string_to_dict(parts.group(3).strip()))
246     return ret
247 def fcontext_add_policy(
248     name, filetype=None, sel_type=None, sel_user=None, sel_level=None
249 ):
250     return _fcontext_add_or_delete_policy(
251         "add", name, filetype, sel_type, sel_user, sel_level
252     )
253 def fcontext_delete_policy(
254     name, filetype=None, sel_type=None, sel_user=None, sel_level=None
255 ):
256     return _fcontext_add_or_delete_policy(
257         "delete", name, filetype, sel_type, sel_user, sel_level
258     )
259 def _fcontext_add_or_delete_policy(
260     action, name, filetype=None, sel_type=None, sel_user=None, sel_level=None
261 ):
262     if action not in ["add", "delete"]:
263         raise SaltInvocationError(
264             'Actions supported are "add" and "delete", not "{}".'.format(action)
265         )
266     cmd = "semanage fcontext --{}".format(action)
267     if filetype is not None and filetype != "a":
268         _validate_filetype(filetype)
269         cmd += " --ftype {}".format(filetype)
270     if sel_type is not None:
271         cmd += " --type {}".format(sel_type)
272     if sel_user is not None:
273         cmd += " --seuser {}".format(sel_user)
274     if sel_level is not None:
275         cmd += " --range {}".format(sel_level)
276     cmd += " " + re.escape(name)
277     return __salt__["cmd.run_all"](cmd)
278 def fcontext_policy_is_applied(name, recursive=False):
279     cmd = "restorecon -n -v "
280     if recursive:
281         cmd += "-R "
282     cmd += re.escape(name)
283     return __salt__["cmd.run_all"](cmd).get("stdout")
284 def fcontext_apply_policy(name, recursive=False):
285     ret = {}
286     changes_text = fcontext_policy_is_applied(name, recursive)
287     cmd = "restorecon -v -F "
288     if recursive:
289         cmd += "-R "
290     cmd += re.escape(name)
291     apply_ret = __salt__["cmd.run_all"](cmd)
292     if apply_ret["retcode"] == 0:
293         changes_list = []
294         if changes_text<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.startswith("Would relabel"):
295             changes_list = re.findall(
296                 "Would relabel (.*) from (.*) to (.*)$", changes_text, re.M
297             )
298         elif changes_text.startswith("restorecon reset"):
299             changes_list = re.findall(
300                 "restorecon reset (.*) context (.*)-&gt;(.*)$", changes_text, re.</b></font>M
301             )
302         else:
303             ret["retcode"] = 1
304             ret["error"] = "Unrecognized response from restorecon command."
305             return ret
306         if changes_list:
307             ret.update({"changes": {}})
308         for item in changes_list:
309             filespec = item[0]
310             old = _context_string_to_dict(item[1])
311             new = _context_string_to_dict(item[2])
312             intersect = {}
313             for key, value in old.items():
314                 if new.get(key) == value:
315                     intersect.update({key: value})
316             for key in intersect:
317                 del old[key]
318                 del new[key]
319             ret["changes"].update({filespec: {"old": old, "new": new}})
320     return ret
321 def port_get_policy(name, sel_type=None, protocol=None, port=None):
322     (protocol, port) = _parse_protocol_port(name, protocol, port)
323     re_spacer = "[ ]+"
324     re_sel_type = sel_type if sel_type else r"\w+"
325     cmd_kwargs = {
326         "spacer": re_spacer,
327         "sel_type": re_sel_type,
328         "protocol": protocol,
329         "port": port,
330     }
331     cmd = (
332         "semanage port -l | egrep "
333         + "'^{sel_type}{spacer}{protocol}{spacer}((.*)*)[ ]{port}($|,)'".format(
334             **cmd_kwargs
335         )
336     )
337     port_policy = __salt__["cmd.shell"](cmd, ignore_retcode=True)
338     if port_policy == "":
339         return None
340     parts = re.match(r"^(\w+)[ ]+(\w+)[ ]+([\d\-, ]+)", port_policy)
341     return {
342         "sel_type": parts.group(1).strip(),
343         "protocol": parts.group(2).strip(),
344         "port": parts.group(3).strip(),
345     }
346 def port_add_policy(name, sel_type=None, protocol=None, port=None, sel_range=None):
347     return _port_add_or_delete_policy("add", name, sel_type, protocol, port, sel_range)
348 def port_delete_policy(name, protocol=None, port=None):
349     return _port_add_or_delete_policy("delete", name, None, protocol, port, None)
350 def _port_add_or_delete_policy(
351     action, name, sel_type=None, protocol=None, port=None, sel_range=None
352 ):
353     if action not in ["add", "delete"]:
354         raise SaltInvocationError(
355             'Actions supported are "add" and "delete", not "{}".'.format(action)
356         )
357     if action == "add" and not sel_type:
358         raise SaltInvocationError("SELinux Type is required to add a policy")
359     (protocol, port) = _parse_protocol_port(name, protocol, port)
360     cmd = "semanage port --{} --proto {}".format(action, protocol)
361     if sel_type:
362         cmd += " --type {}".format(sel_type)
363     if sel_range:
364         cmd += " --range {}".format(sel_range)
365     cmd += " {}".format(port)
366     return __salt__["cmd.run_all"](cmd)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
