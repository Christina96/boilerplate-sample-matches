<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_openvswitch_port.py & test_gpg_2.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_openvswitch_port.py & test_gpg_2.py
      </h3>
      <h1 align="center">
        5.6%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_openvswitch_port.py (16.455696%)<TH>test_gpg_2.py (3.3854167%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match52067-0.html#0',2,'match52067-1.html#0',3)" NAME="0">(1-15)<TD><A HREF="javascript:ZweiFrames('match52067-0.html#0',2,'match52067-1.html#0',3)" NAME="0">(7-24)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_openvswitch_port.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
<A NAME="0"></A><FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match52067-1.html#0',3,'match52067-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import pytest
import salt.states.openvswitch_port as openvswitch_port
from tests.support.mock import MagicMock, patch


@pytest.fixture
def configure_loader_modules():
    return {openvswitch_port: {&quot;__opts__&quot;: {&quot;test&quot;: False}}}


def test_present():
    &quot;&quot;&quot;
    Test to verify that the named port exists on bridge, eventually creates it.
    &quot;&quot;&quot;
    name =</B></FONT> &quot;salt&quot;
    bridge = &quot;br-salt&quot;

    ret = {&quot;name&quot;: name, &quot;result&quot;: None, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}

    mock = MagicMock(return_value=True)
    mock_l = MagicMock(return_value=[&quot;salt&quot;])
    mock_n = MagicMock(return_value=[])

    with patch.dict(
        openvswitch_port.__salt__,
        {
            &quot;openvswitch.bridge_exists&quot;: mock,
            &quot;openvswitch.interface_get_type&quot;: MagicMock(return_value='&quot;&quot;'),
            &quot;openvswitch.port_list&quot;: mock_l,
        },
    ):
        comt = &quot;Port salt already exists.&quot;
        ret.update({&quot;comment&quot;: comt, &quot;result&quot;: True})
        assert openvswitch_port.present(name, bridge) == ret

    with patch.dict(
        openvswitch_port.__salt__,
        {
            &quot;openvswitch.bridge_exists&quot;: mock,
            &quot;openvswitch.interface_get_type&quot;: MagicMock(return_value='&quot;&quot;'),
            &quot;openvswitch.port_list&quot;: mock_n,
            &quot;openvswitch.port_add&quot;: mock,
        },
    ):
        comt = &quot;Port salt created on bridge br-salt.&quot;
        ret.update(
            {
                &quot;comment&quot;: comt,
                &quot;result&quot;: True,
                &quot;changes&quot;: {
                    &quot;salt&quot;: {
                        &quot;new&quot;: &quot;Created port salt on bridge br-salt.&quot;,
                        &quot;old&quot;: &quot;No port named salt present.&quot;,
                    },
                },
            }
        )
        assert openvswitch_port.present(name, bridge) == ret
    with patch.dict(
        openvswitch_port.__salt__,
        {
            &quot;openvswitch.bridge_exists&quot;: mock,
            &quot;openvswitch.port_list&quot;: mock_n,
            &quot;openvswitch.port_add&quot;: mock,
            &quot;openvswitch.interface_get_options&quot;: mock_n,
            &quot;openvswitch.interface_get_type&quot;: MagicMock(return_value=&quot;&quot;),
            &quot;openvswitch.port_create_gre&quot;: mock,
            &quot;dig.check_ip&quot;: mock,
        },
    ):
        comt = &quot;Port salt created on bridge br-salt.&quot;
        ret.update(
            {
                &quot;result&quot;: True,
                &quot;comment&quot;: (
                    &quot;Created GRE tunnel interface salt with remote ip 10.0.0.1  and key&quot;
                    &quot; 1 on bridge br-salt.&quot;
                ),
                &quot;changes&quot;: {
                    &quot;salt&quot;: {
                        &quot;new&quot;: (
                            &quot;Created GRE tunnel interface salt with remote ip 10.0.0.1&quot;
                            &quot; and key 1 on bridge br-salt.&quot;
                        ),
                        &quot;old&quot;: (
                            &quot;No GRE tunnel interface salt with remote ip 10.0.0.1 and&quot;
                            &quot; key 1 on bridge br-salt present.&quot;
                        ),
                    },
                },
            }
        )
        assert (
            openvswitch_port.present(
                name, bridge, tunnel_type=&quot;gre&quot;, id=1, remote=&quot;10.0.0.1&quot;
            )
            == ret
        )
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_gpg_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
import os
from subprocess import PIPE
from textwrap import dedent
<A NAME="0"></A>
import pytest
import salt.config
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match52067-0.html#0',2,'match52067-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import salt.renderers.gpg as gpg
from salt.exceptions import SaltRenderError
from tests.support.mock import MagicMock, Mock, call, patch


@pytest.fixture
def configure_loader_modules():
    &quot;&quot;&quot;
    GPG renderer configuration
    &quot;&quot;&quot;
    return {gpg: {&quot;__opts__&quot;: {&quot;gpg_decrypt_must_succeed&quot;: True}}}


def test__get_gpg_exec():
    &quot;&quot;&quot;
    test _get_gpg_exec
    &quot;&quot;&quot;
    gpg_exec =</B></FONT> &quot;/bin/gpg&quot;

    with patch(&quot;salt.utils.path.which&quot;, MagicMock(return_value=gpg_exec)):
        assert gpg._get_gpg_exec() == gpg_exec

    with patch(&quot;salt.utils.path.which&quot;, MagicMock(return_value=False)):
        pytest.raises(SaltRenderError, gpg._get_gpg_exec)


def test__decrypt_ciphertext():
    &quot;&quot;&quot;
    test _decrypt_ciphertext
    &quot;&quot;&quot;
    key_dir = &quot;/etc/salt/gpgkeys&quot;
    secret = &quot;Use more salt.&quot;
    crypted = &quot;-----BEGIN PGP MESSAGE-----!@#$%^&amp;*()_+-----END PGP MESSAGE-----&quot;

    multisecret = &quot;password is {0} and salt is {0}&quot;.format(secret)
    multicrypted = &quot;password is {0} and salt is {0}&quot;.format(crypted)

    class GPGDecrypt:
        def communicate(self, *args, **kwargs):
            return [secret, None]

    class GPGNotDecrypt:
        def communicate(self, *args, **kwargs):
            return [None, &quot;decrypt error&quot;]

    with patch(
        &quot;salt.renderers.gpg._get_key_dir&quot;, MagicMock(return_value=key_dir)
    ), patch(&quot;salt.utils.path.which&quot;, MagicMock()):
        with patch(&quot;salt.renderers.gpg.Popen&quot;, MagicMock(return_value=GPGDecrypt())):
            assert gpg._decrypt_ciphertexts(crypted) == secret
            assert gpg._decrypt_ciphertexts(multicrypted) == multisecret
        with patch(&quot;salt.renderers.gpg.Popen&quot;, MagicMock(return_value=GPGNotDecrypt())):
            with pytest.raises(SaltRenderError) as decrypt_error:
                gpg._decrypt_ciphertexts(crypted)
            # Assertions must be made after closure of context manager
            assert decrypt_error.value.args[0].startswith(&quot;Could not decrypt cipher &quot;)
            assert crypted in decrypt_error.value.args[0]
            assert &quot;decrypt error&quot; in decrypt_error.value.args[0]
            with pytest.raises(SaltRenderError) as multidecrypt_error:
                gpg._decrypt_ciphertexts(multicrypted)
            assert multidecrypt_error.value.args[0].startswith(
                &quot;Could not decrypt cipher &quot;
            )
            # Function will raise on a single ciphertext even if multiple are passed
            assert crypted in multidecrypt_error.value.args[0]
            assert &quot;decrypt error&quot; in multidecrypt_error.value.args[0]


def test__decrypt_object():
    &quot;&quot;&quot;
    test _decrypt_object
    &quot;&quot;&quot;
    secret = &quot;Use more salt.&quot;
    crypted = &quot;-----BEGIN PGP MESSAGE-----!@#$%^&amp;*()_+-----END PGP MESSAGE-----&quot;

    secret_map = {&quot;secret&quot;: secret}
    crypted_map = {&quot;secret&quot;: crypted}

    secret_list = [secret]
    crypted_list = [crypted]

    with patch(
        &quot;salt.renderers.gpg._decrypt_ciphertext&quot;, MagicMock(return_value=secret)
    ):
        assert gpg._decrypt_object(secret) == secret
        assert gpg._decrypt_object(crypted) == secret
        assert gpg._decrypt_object(crypted_map) == secret_map
        assert gpg._decrypt_object(crypted_list) == secret_list
        assert gpg._decrypt_object(None) is None


def test_render():
    &quot;&quot;&quot;
    test render
    &quot;&quot;&quot;
    key_dir = &quot;/etc/salt/gpgkeys&quot;
    secret = &quot;Use more salt.&quot;
    crypted = &quot;-----BEGIN PGP MESSAGE-----!@#$%^&amp;*()_+&quot;

    with patch(&quot;salt.renderers.gpg._get_gpg_exec&quot;, MagicMock(return_value=True)):
        with patch(&quot;salt.renderers.gpg._get_key_dir&quot;, MagicMock(return_value=key_dir)):
            with patch(
                &quot;salt.renderers.gpg._decrypt_object&quot;, MagicMock(return_value=secret)
            ):
                assert gpg.render(crypted) == secret


def test_render_bytes():
    &quot;&quot;&quot;
    test rendering bytes
    &quot;&quot;&quot;
    key_dir = &quot;/etc/salt/gpgkeys&quot;
    binfo = b&quot;User more salt.&quot;

    with patch(&quot;salt.renderers.gpg._get_gpg_exec&quot;, MagicMock(return_value=True)):
        with patch(&quot;salt.renderers.gpg._get_key_dir&quot;, MagicMock(return_value=key_dir)):
            assert gpg.render(binfo) == binfo.decode()


def test_multi_render():
    key_dir = &quot;/etc/salt/gpgkeys&quot;
    secret = &quot;Use more salt.&quot;
    expected = &quot;\n&quot;.join([secret] * 3)
    crypted = dedent(
        &quot;&quot;&quot;\
        -----BEGIN PGP MESSAGE-----
        !@#$%^&amp;*()_+
        -----END PGP MESSAGE-----
        -----BEGIN PGP MESSAGE-----
        !@#$%^&amp;*()_+
        -----END PGP MESSAGE-----
        -----BEGIN PGP MESSAGE-----
        !@#$%^&amp;*()_+
        -----END PGP MESSAGE-----
    &quot;&quot;&quot;
    )

    with patch(&quot;salt.renderers.gpg._get_gpg_exec&quot;, MagicMock(return_value=True)):
        with patch(&quot;salt.renderers.gpg._get_key_dir&quot;, MagicMock(return_value=key_dir)):
            with patch(
                &quot;salt.renderers.gpg._decrypt_ciphertext&quot;,
                MagicMock(return_value=secret),
            ):
                assert gpg.render(crypted) == expected


def test_render_with_binary_data_should_return_binary_data():
    key_dir = &quot;/etc/salt/gpgkeys&quot;
    secret = b&quot;Use\x8b more\x8b salt.&quot;
    expected = b&quot;\n&quot;.join([secret] * 3)
    crypted = dedent(
        &quot;&quot;&quot;\
        -----BEGIN PGP MESSAGE-----
        !@#$%^&amp;*()_+
        -----END PGP MESSAGE-----
        -----BEGIN PGP MESSAGE-----
        !@#$%^&amp;*()_+
        -----END PGP MESSAGE-----
        -----BEGIN PGP MESSAGE-----
        !@#$%^&amp;*()_+
        -----END PGP MESSAGE-----
    &quot;&quot;&quot;
    )

    with patch(&quot;salt.renderers.gpg._get_gpg_exec&quot;, MagicMock(return_value=True)):
        with patch(&quot;salt.renderers.gpg._get_key_dir&quot;, MagicMock(return_value=key_dir)):
            with patch(
                &quot;salt.renderers.gpg._decrypt_ciphertext&quot;,
                MagicMock(return_value=secret),
            ):
                assert gpg.render(crypted, encoding=&quot;utf-8&quot;) == expected


def test_render_with_translate_newlines_should_translate_newlines():
    key_dir = &quot;/etc/salt/gpgkeys&quot;
    secret = b&quot;Use\x8b more\x8b salt.&quot;
    expected = b&quot;\n\n&quot;.join([secret] * 3)
    crypted = dedent(
        &quot;&quot;&quot;\
        -----BEGIN PGP MESSAGE-----
        !@#$%^&amp;*()_+
        -----END PGP MESSAGE-----\\n
        -----BEGIN PGP MESSAGE-----
        !@#$%^&amp;*()_+
        -----END PGP MESSAGE-----\\n
        -----BEGIN PGP MESSAGE-----
        !@#$%^&amp;*()_+
        -----END PGP MESSAGE-----
    &quot;&quot;&quot;
    )

    with patch(&quot;salt.renderers.gpg._get_gpg_exec&quot;, MagicMock(return_value=True)):
        with patch(&quot;salt.renderers.gpg._get_key_dir&quot;, MagicMock(return_value=key_dir)):
            with patch(
                &quot;salt.renderers.gpg._decrypt_ciphertext&quot;,
                MagicMock(return_value=secret),
            ):
                assert (
                    gpg.render(crypted, translate_newlines=True, encoding=&quot;utf-8&quot;)
                    == expected
                )


def test_render_without_cache():
    key_dir = &quot;/etc/salt/gpgkeys&quot;
    secret = &quot;Use more salt.&quot;
    expected = &quot;\n&quot;.join([secret] * 3)
    crypted = dedent(
        &quot;&quot;&quot;\
        -----BEGIN PGP MESSAGE-----
        !@#$%^&amp;*()_+
        -----END PGP MESSAGE-----
        -----BEGIN PGP MESSAGE-----
        !@#$%^&amp;*()_+
        -----END PGP MESSAGE-----
        -----BEGIN PGP MESSAGE-----
        !@#$%^&amp;*()_+
        -----END PGP MESSAGE-----
    &quot;&quot;&quot;
    )

    with patch(&quot;salt.renderers.gpg.Popen&quot;) as popen_mock:
        popen_mock.return_value = Mock(
            communicate=lambda *args, **kwargs: (secret, None),
        )
        with patch(
            &quot;salt.renderers.gpg._get_gpg_exec&quot;,
            MagicMock(return_value=&quot;/usr/bin/gpg&quot;),
        ):
            with patch(
                &quot;salt.renderers.gpg._get_key_dir&quot;, MagicMock(return_value=key_dir)
            ):
                assert gpg.render(crypted) == expected
                gpg_call = call(
                    [
                        &quot;/usr/bin/gpg&quot;,
                        &quot;--homedir&quot;,
                        &quot;/etc/salt/gpgkeys&quot;,
                        &quot;--status-fd&quot;,
                        &quot;2&quot;,
                        &quot;--no-tty&quot;,
                        &quot;-d&quot;,
                    ],
                    shell=False,
                    stderr=PIPE,
                    stdin=PIPE,
                    stdout=PIPE,
                )
                popen_mock.assert_has_calls([gpg_call] * 3)


def test_render_with_cache():
    key_dir = &quot;/etc/salt/gpgkeys&quot;
    secret = &quot;Use more salt.&quot;
    expected = &quot;\n&quot;.join([secret] * 3)
    crypted = dedent(
        &quot;&quot;&quot;\
        -----BEGIN PGP MESSAGE-----
        !@#$%^&amp;*()_+
        -----END PGP MESSAGE-----
        -----BEGIN PGP MESSAGE-----
        !@#$%^&amp;*()_+
        -----END PGP MESSAGE-----
        -----BEGIN PGP MESSAGE-----
        !@#$%^&amp;*()_+
        -----END PGP MESSAGE-----
    &quot;&quot;&quot;
    )

    minion_opts = salt.config.DEFAULT_MINION_OPTS.copy()
    minion_opts[&quot;gpg_cache&quot;] = True
    with patch.dict(gpg.__opts__, minion_opts):
        with patch(&quot;salt.renderers.gpg.Popen&quot;) as popen_mock:
            popen_mock.return_value = Mock(
                communicate=lambda *args, **kwargs: (secret, None),
            )
            with patch(
                &quot;salt.renderers.gpg._get_gpg_exec&quot;,
                MagicMock(return_value=&quot;/usr/bin/gpg&quot;),
            ):
                with patch(
                    &quot;salt.renderers.gpg._get_key_dir&quot;,
                    MagicMock(return_value=key_dir),
                ):
                    with patch(
                        &quot;salt.utils.atomicfile.atomic_open&quot;,
                        MagicMock(),
                    ) as atomic_open_mock:
                        assert gpg.render(crypted) == expected
                        gpg_call = call(
                            [
                                &quot;/usr/bin/gpg&quot;,
                                &quot;--homedir&quot;,
                                &quot;/etc/salt/gpgkeys&quot;,
                                &quot;--status-fd&quot;,
                                &quot;2&quot;,
                                &quot;--no-tty&quot;,
                                &quot;-d&quot;,
                            ],
                            shell=False,
                            stderr=PIPE,
                            stdin=PIPE,
                            stdout=PIPE,
                        )
                        popen_mock.assert_has_calls([gpg_call] * 1)
                        atomic_open_mock.assert_has_calls(
                            [
                                call(
                                    os.path.join(minion_opts[&quot;cachedir&quot;], &quot;gpg_cache&quot;),
                                    &quot;wb+&quot;,
                                )
                            ]
                        )
</PRE>
</div>
  </div>
</body>
</html>
