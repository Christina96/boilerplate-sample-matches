<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for vsanmgmtObjects.py &amp; test_virt_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for vsanmgmtObjects.py &amp; test_virt_1.py
      </h3>
<h1 align="center">
        13.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>vsanmgmtObjects.py (54.909985%)<th>test_virt_1.py (7.989046%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1086-1424)<td><a href="#" name="0">(4790-4976)</a><td align="center"><font color="#ff0000">80</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(970-1080)<td><a href="#" name="1">(2373-2456)</a><td align="center"><font color="#660000">32</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(3751-3907)<td><a href="#" name="2">(570-582)</a><td align="center"><font color="#590000">28</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(62-193)<td><a href="#" name="3">(5087-5133)</a><td align="center"><font color="#590000">28</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(2997-3078)<td><a href="#" name="4">(6013-6021)</a><td align="center"><font color="#560000">27</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(800-883)<td><a href="#" name="5">(3836-3873)</a><td align="center"><font color="#520000">26</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(3128-3183)<td><a href="#" name="6">(6421-6426)</a><td align="center"><font color="#490000">23</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(2537-2599)<td><a href="#" name="7">(6007-6013)</a><td align="center"><font color="#490000">23</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(2325-2381)<td><a href="#" name="8">(6756-6781)</a><td align="center"><font color="#490000">23</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(2486-2534)<td><a href="#" name="9">(5190-5202)</a><td align="center"><font color="#420000">21</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(1511-1592)<td><a href="#" name="10">(732-762)</a><td align="center"><font color="#420000">21</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(2664-2718)<td><a href="#" name="11">(6988-6995)</a><td align="center"><font color="#390000">18</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(236-307)<td><a href="#" name="12">(1475-1501)</a><td align="center"><font color="#390000">18</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(1621-1693)<td><a href="#" name="13">(4006-4034)</a><td align="center"><font color="#360000">17</font>
<tr onclick='openModal("#842dce")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#842dce"><font color="#842dce">-</font><td><a href="#" name="14">(508-583)<td><a href="#" name="14">(6681-6708)</a><td align="center"><font color="#360000">17</font>
<tr onclick='openModal("#f52887")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f52887"><font color="#f52887">-</font><td><a href="#" name="15">(3548-3595)<td><a href="#" name="15">(5998-6006)</a><td align="center"><font color="#330000">16</font>
<tr onclick='openModal("#2981b2")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#2981b2"><font color="#2981b2">-</font><td><a href="#" name="16">(3496-3533)<td><a href="#" name="16">(5903-5911)</a><td align="center"><font color="#330000">16</font>
<tr onclick='openModal("#3090c7")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3090c7"><font color="#3090c7">-</font><td><a href="#" name="17">(406-448)<td><a href="#" name="17">(6310-6345)</a><td align="center"><font color="#330000">16</font>
<tr onclick='openModal("#800517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#800517"><font color="#800517">-</font><td><a href="#" name="18">(2131-2171)<td><a href="#" name="18">(6858-6866)</a><td align="center"><font color="#2f0000">15</font>
<tr onclick='openModal("#f62817")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f62817"><font color="#f62817">-</font><td><a href="#" name="19">(3373-3397)<td><a href="#" name="19">(1331-1341)</a><td align="center"><font color="#2c0000">14</font>
<tr onclick='openModal("#4e9258")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4e9258"><font color="#4e9258">-</font><td><a href="#" name="20">(2814-2859)<td><a href="#" name="20">(122-142)</a><td align="center"><font color="#2c0000">14</font>
<tr onclick='openModal("#947010")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#947010"><font color="#947010">-</font><td><a href="#" name="21">(2051-2081)<td><a href="#" name="21">(6021-6026)</a><td align="center"><font color="#2c0000">14</font>
<tr onclick='openModal("#4cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4cc417"><font color="#4cc417">-</font><td><a href="#" name="22">(3613-3645)<td><a href="#" name="22">(3922-3933)</a><td align="center"><font color="#290000">13</font>
<tr onclick='openModal("#f660ab")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f660ab"><font color="#f660ab">-</font><td><a href="#" name="23">(3412-3431)<td><a href="#" name="23">(3225-3247)</a><td align="center"><font color="#290000">13</font>
<tr onclick='openModal("#79764d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#79764d"><font color="#79764d">-</font><td><a href="#" name="24">(2741-2782)<td><a href="#" name="24">(1729-1737)</a><td align="center"><font color="#290000">13</font>
<tr onclick='openModal("#5eac10")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#5eac10"><font color="#5eac10">-</font><td><a href="#" name="25">(2384-2428)<td><a href="#" name="25">(822-833)</a><td align="center"><font color="#290000">13</font>
<tr onclick='openModal("#68818b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#68818b"><font color="#68818b">-</font><td><a href="#" name="26">(2242-2266)<td><a href="#" name="26">(2647-2661)</a><td align="center"><font color="#290000">13</font>
<tr onclick='openModal("#e77471")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#e77471"><font color="#e77471">-</font><td><a href="#" name="27">(2210-2232)<td><a href="#" name="27">(2338-2372)</a><td align="center"><font color="#290000">13</font>
<tr onclick='openModal("#717d7d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#717d7d"><font color="#717d7d">-</font><td><a href="#" name="28">(2083-2115)<td><a href="#" name="28">(2200-2209)</a><td align="center"><font color="#290000">13</font>
<tr onclick='openModal("#af7a82")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#af7a82"><font color="#af7a82">-</font><td><a href="#" name="29">(450-494)<td><a href="#" name="29">(7006-7016)</a><td align="center"><font color="#290000">13</font>
<tr onclick='openModal("#ae694a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ae694a"><font color="#ae694a">-</font><td><a href="#" name="30">(3655-3688)<td><a href="#" name="30">(6490-6492)</a><td align="center"><font color="#260000">12</font>
<tr onclick='openModal("#3ea99f")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3ea99f"><font color="#3ea99f">-</font><td><a href="#" name="31">(3437-3459)<td><a href="#" name="31">(6487-6489)</a><td align="center"><font color="#260000">12</font>
<tr onclick='openModal("#5b8daf")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#5b8daf"><font color="#5b8daf">-</font><td><a href="#" name="32">(1879-1912)<td><a href="#" name="32">(5557-5565)</a><td align="center"><font color="#260000">12</font>
<tr onclick='openModal("#736aff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#736aff"><font color="#736aff">-</font><td><a href="#" name="33">(665-704)<td><a href="#" name="33">(1346-1355)</a><td align="center"><font color="#260000">12</font>
<tr onclick='openModal("#827d6b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#827d6b"><font color="#827d6b">-</font><td><a href="#" name="34">(590-644)<td><a href="#" name="34">(3333-3354)</a><td align="center"><font color="#260000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>vsanmgmtObjects.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from pyVmomi.VmomiSupport import (
2     CreateDataType,
3     CreateManagedType,
4     CreateEnumType,
5     AddVersion,
6     AddVersionParent,
7     F_LINK,
8     F_LINKABLE,
9     F_OPTIONAL,
10 )
11 CreateManagedType(
12     "vim.cluster.VsanPerformanceManager",
13     "VsanPerformanceManager",
14     "vmodl.ManagedObject",
15     "vim.version.version9",
16     [],
17     [
18         (
19             "setStatsObjectPolicy",
20             "VsanPerfSetStatsObjectPolicy",
21             "vim.version.version9",
22             (
23                 (
24                     "cluster",
25                     "vim.ComputeResource",
26                     "vim.version.version9",
27                     0 | F_OPTIONAL,
28                     None,
29                 ),
30                 (
31                     "profile",
32                     "vim.vm.ProfileSpec",
33                     "vim.version.version9",
34                     0 | F_OPTIONAL,
35                     None,
36                 ),
37             ),
38             (0, "boolean", "boolean"),
39             "System.Read",
40             None,
41         ),
42         (
43             "deleteStatsObject",
44             "VsanPerfDeleteStatsObject",
45             "vim.version.version9",
46             (
47                 (
48                     "cluster",
49                     "vim.ComputeResource",
50                     "vim.version.version9",
51                     0 | F_OPTIONAL,
52                     None,
53                 ),
54             ),
55             (0, "boolean", "boolean"),
56             "System.Read",
57 <a name="3"></a>            None,
58         ),
59         (
60             <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"createStatsObjectTask",
61             "VsanPerfCreateStatsObjectTask",
62             "vim.version.version9",
63             (
64                 (
65                     "cluster",
66                     "vim.ComputeResource",
67                     "vim.version.version9",
68                     0 | F_OPTIONAL,
69                     None,
70                 ),
71                 (
72                     "profile",
73                     "vim.vm.ProfileSpec",
74                     "vim.version.version9",
75                     0 | F_OPTIONAL,
76                     None,
77                 ),
78             ),
79             (0, "vim.Task", "vim.Task"),
80             "System.Read",
81             None,
82         ),
83         (
84             "deleteStatsObjectTask",
85             "VsanPerfDeleteStatsObjectTask",
86             "vim.version.version9",
87             (
88                 (
89                     "cluster",
90                     "vim.ComputeResource",
91                     "vim.version.version9",
92                     0 | F_OPTIONAL,
93                     None,
94                 ),
95             ),
96             (0, "vim.Task", "vim.Task"),
97             "System.Read",
98             None,
99         ),
100         (
101             "queryClusterHealth",
102             "VsanPerfQueryClusterHealth",
103             "vim.version.version9",
104             (
105                 (
106                     "cluster",
107                     "vim.ClusterComputeResource",
108                     "vim.version.version9",
109                     0,
110                     None,
111                 ),
112             ),
113             (0, "vmodl.DynamicData[]", "vmodl.DynamicData[]"),
114             "System.Read",
115             None,
116         ),
117         (
118             "queryStatsObjectInformation",
119             "VsanPerfQueryStatsObjectInformation",
120             "vim.version.version9",
121             (
122                 (
123                     "cluster",
124                     "vim.ComputeResource",
125                     "vim.version.version9",
126                     0 | F_OPTIONAL,
127                     None,
128                 ),
129             ),
130             (
131                 0,
132                 "vim.cluster.VsanObjectInformation",
133                 "vim.cluster.VsanObjectInformation",
134             ),
135             "System.Read",
136             None,
137         ),
138         (
139             "queryNodeInformation",
140             "VsanPerfQueryNodeInformation",
141             "vim.version.version9",
142             (
143                 (
144                     "cluster",
145                     "vim.ComputeResource",
146                     "vim.version.version9",
147                     0 | F_OPTIONAL,
148                     None,
149                 ),
150             ),
151             (
152                 0 | F_OPTIONAL,
153                 "vim.cluster.VsanPerfNodeInformation[]",
154                 "vim.cluster.VsanPerfNodeInformation[]",
155             ),
156             "System.Read",
157             None,
158         ),
159         (
160             "queryVsanPerf",
161             "VsanPerfQueryPerf",
162             "vim.version.version9",
163             (
164                 (
165                     "querySpecs",
166                     "vim.cluster.VsanPerfQuerySpec[]",
167                     "vim.version.version9",
168                     0,
169                     None,
170                 ),
171                 (
172                     "cluster",
173                     "vim.ComputeResource",
174                     "vim.version.version9",
175                     0 | F_OPTIONAL,
176                     None,
177                 ),
178             ),
179             (
180                 0,
181                 "vim.cluster.VsanPerfEntityMetricCSV[]",
182                 "vim.cluster.VsanPerfEntityMetricCSV[]",
183             ),
184             "System.Read",
185             None,
186         ),
187         (
188             "getSupportedEntityTypes",
189             "VsanPerfGetSupportedEntityTypes",
190             "vim.version.version9",
191             tuple(</b></font>),
192             (
193                 0 | F_OPTIONAL,
194                 "vim.cluster.VsanPerfEntityType[]",
195                 "vim.cluster.VsanPerfEntityType[]",
196             ),
197             "System.Read",
198             None,
199         ),
200         (
201             "createStatsObject",
202             "VsanPerfCreateStatsObject",
203             "vim.version.version9",
204             (
205                 (
206                     "cluster",
207                     "vim.ComputeResource",
208                     "vim.version.version9",
209                     0 | F_OPTIONAL,
210                     None,
211                 ),
212                 (
213                     "profile",
214                     "vim.vm.ProfileSpec",
215                     "vim.version.version9",
216                     0 | F_OPTIONAL,
217                     None,
218                 ),
219             ),
220             (0, "string", "string"),
221             "System.Read",
222             None,
223         ),
224     ],
225 )
226 CreateManagedType(
227     "vim.cluster.VsanVcDiskManagementSystem",
228     "VimClusterVsanVcDiskManagementSystem",
229     "vmodl.ManagedObject",
230     "vim.version.version10",
231 <a name="12"></a>    [],
232     [
233         (
234             <font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"initializeDiskMappings",
235             "InitializeDiskMappings",
236             "vim.version.version10",
237             (
238                 (
239                     "spec",
240                     "vim.vsan.host.DiskMappingCreationSpec",
241                     "vim.version.version10",
242                     0,
243                     None,
244                 ),
245             ),
246             (0, "vim.Task", "vim.Task"),
247             "System.Read",
248             None,
249         ),
250         (
251             "retrieveAllFlashCapabilities",
252             "RetrieveAllFlashCapabilities",
253             "vim.version.version10",
254             (
255                 (
256                     "cluster",
257                     "vim.ClusterComputeResource",
258                     "vim.version.version10",
259                     0,
260                     None,
261                 ),
262             ),
263             (
264                 0 | F_OPTIONAL,
265                 "vim.vsan.host.VsanHostCapability[]",
266                 "vim.vsan.host.VsanHostCapability[]",
267             ),
268             "System.Read",
269             None,
270         ),
271         (
272             "queryDiskMappings",
273             "QueryDiskMappings",
274             "vim.version.version10",
275             (("host", "vim.HostSystem", "vim.version.version10", 0, None),),
276             (
277                 0 | F_OPTIONAL,
278                 "vim.vsan.host.DiskMapInfoEx[]",
279                 "vim.vsan.host.DiskMapInfoEx[]",
280             ),
281             "System.Read",
282             None,
283         ),
284     ],
285 )
286 CreateManagedType(
287     "vim.cluster.VsanObjectSystem",
288     "VsanObjectSystem",
289     "vmodl.ManagedObject",
290     "vim.version.version9",
291     [],
292     [
293         (
294             "setVsanObjectPolicy",
295             "VosSetVsanObjectPolicy",
296             "vim.version.version9",
297             (
298                 (
299                     "cluster",
300                     "vim.ComputeResource",
301                     "vim.version.version9",
302                     0 | F_OPTIONAL,
303                     None,
304                 ),
305                 ("vsanObjectUuid"</b></font>, "string", "vim.version.version9", 0, None),
306                 (
307                     "profile",
308                     "vim.vm.ProfileSpec",
309                     "vim.version.version9",
310                     0 | F_OPTIONAL,
311                     None,
312                 ),
313             ),
314             (0, "boolean", "boolean"),
315             "System.Read",
316             None,
317         ),
318         (
319             "queryObjectIdentities",
320             "VsanQueryObjectIdentities",
321             "vim.version.version9",
322             (
323                 (
324                     "cluster",
325                     "vim.ComputeResource",
326                     "vim.version.version9",
327                     0 | F_OPTIONAL,
328                     None,
329                 ),
330                 ("objUuids", "string[]", "vim.version.version9", 0 | F_OPTIONAL, None),
331                 (
332                     "includeHealth",
333                     "boolean",
334                     "vim.version.version9",
335                     0 | F_OPTIONAL,
336                     None,
337                 ),
338                 (
339                     "includeObjIdentity",
340                     "boolean",
341                     "vim.version.version9",
342                     0 | F_OPTIONAL,
343                     None,
344                 ),
345                 (
346                     "includeSpaceSummary",
347                     "boolean",
348                     "vim.version.version9",
349                     0 | F_OPTIONAL,
350                     None,
351                 ),
352             ),
353             (
354                 0 | F_OPTIONAL,
355                 "vim.cluster.VsanObjectIdentityAndHealth",
356                 "vim.cluster.VsanObjectIdentityAndHealth",
357             ),
358             "System.Read",
359             None,
360         ),
361         (
362             "queryVsanObjectInformation",
363             "VosQueryVsanObjectInformation",
364             "vim.version.version9",
365             (
366                 (
367                     "cluster",
368                     "vim.ComputeResource",
369                     "vim.version.version9",
370                     0 | F_OPTIONAL,
371                     None,
372                 ),
373                 (
374                     "vsanObjectQuerySpecs",
375                     "vim.cluster.VsanObjectQuerySpec[]",
376                     "vim.version.version9",
377                     0,
378                     None,
379                 ),
380             ),
381             (
382                 0,
383                 "vim.cluster.VsanObjectInformation[]",
384                 "vim.cluster.VsanObjectInformation[]",
385             ),
386             "System.Read",
387             None,
388         ),
389     ],
390 )
391 CreateManagedType(
392     "vim.host.VsanStretchedClusterSystem",
393     "VimHostVsanStretchedClusterSystem",
394     "vmodl.ManagedObject",
395     "vim.version.version10",
396     [],
397     [
398         (
399             "getStretchedClusterInfoFromCmmds",
400             "VSANHostGetStretchedClusterInfoFromCmmds",
401 <a name="17"></a>            "vim.version.version10",
402             tuple(),
403             (
404                 <font color="#3090c7"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>0 | F_OPTIONAL,
405                 "vim.host.VSANStretchedClusterHostInfo[]",
406                 "vim.host.VSANStretchedClusterHostInfo[]",
407             ),
408             "System.Read",
409             None,
410         ),
411         (
412             "witnessJoinVsanCluster",
413             "VSANWitnessJoinVsanCluster",
414             "vim.version.version10",
415             (
416                 ("clusterUuid", "string", "vim.version.version10", 0, None),
417                 ("preferredFd", "string", "vim.version.version10", 0, None),
418                 (
419                     "disableVsanAllowed",
420                     "boolean",
421                     "vim.version.version10",
422                     0 | F_OPTIONAL,
423                     None,
424                 ),
425             ),
426             (0, "void", "void"),
427             "System.Read",
428             None,
429         ),
430         (
431             "witnessSetPreferredFaultDomain",
432             "VSANWitnessSetPreferredFaultDomain",
433             "vim.version.version10",
434             (("preferredFd", "string", "vim.version.version10", 0, None),),
435             (0, "void", "void"),
436             "System.Read",
437             None,
438         ),
439         (
440             "addUnicastAgent",
441             "VSANHostAddUnicastAgent",
442             "vim.version.version10",
443             (
444                 ("witnessAddress", "string", "vim.version.version10", 0, None),
445 <a name="29"></a>                ("witnessPort", "int", "vim.version.version10", 0 | F_OPTIONAL, None),
446                 ("overwrite"</b></font>, "boolean", "vim.version.version10", 0 | F_OPTIONAL, None),
447             ),
448             (<font color="#af7a82"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>0, "void", "void"),
449             "System.Read",
450             None,
451         ),
452         (
453             "clusterGetPreferredFaultDomain",
454             "VSANClusterGetPreferredFaultDomain",
455             "vim.version.version10",
456             tuple(),
457             (
458                 0 | F_OPTIONAL,
459                 "vim.host.VSANCmmdsPreferredFaultDomainInfo",
460                 "vim.host.VSANCmmdsPreferredFaultDomainInfo",
461             ),
462             "System.Read",
463             None,
464         ),
465         (
466             "witnessLeaveVsanCluster",
467             "VSANWitnessLeaveVsanCluster",
468             "vim.version.version10",
469             tuple(),
470             (0, "void", "void"),
471             "System.Read",
472             None,
473         ),
474         (
475             "getStretchedClusterCapability",
476             "VSANHostGetStretchedClusterCapability",
477             "vim.version.version10",
478             tuple(),
479             (
480                 0,
481                 "vim.host.VSANStretchedClusterHostCapability",
482                 "vim.host.VSANStretchedClusterHostCapability",
483             ),
484             "System.Read",
485             None,
486         ),
487         (
488             "removeUnicastAgent",
489             "VSANHostRemoveUnicastAgent",
490             "vim.version.version10",
491             (
492                 ("witnessAddress"</b></font>, "string", "vim.version.version10", 0, None),
493                 (
494                     "ignoreExistence",
495                     "boolean",
496                     "vim.version.version10",
497                     0 | F_OPTIONAL,
498                     None,
499                 ),
500             ),
501             (0, "void", "void"),
502             "System.Read",
503 <a name="14"></a>            None,
504         ),
505         (
506             <font color="#842dce"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"listUnicastAgent",
507             "VSANHostListUnicastAgent",
508             "vim.version.version10",
509             tuple(),
510             (0, "string", "string"),
511             "System.Read",
512             None,
513         ),
514     ],
515 )
516 CreateManagedType(
517     "vim.VsanUpgradeSystemEx",
518     "VsanUpgradeSystemEx",
519     "vmodl.ManagedObject",
520     "vim.version.version10",
521     [],
522     [
523         (
524             "performUpgrade",
525             "PerformVsanUpgradeEx",
526             "vim.version.version10",
527             (
528                 (
529                     "cluster",
530                     "vim.ClusterComputeResource",
531                     "vim.version.version10",
532                     0,
533                     None,
534                 ),
535                 (
536                     "performObjectUpgrade",
537                     "boolean",
538                     "vim.version.version10",
539                     0 | F_OPTIONAL,
540                     None,
541                 ),
542                 (
543                     "downgradeFormat",
544                     "boolean",
545                     "vim.version.version10",
546                     0 | F_OPTIONAL,
547                     None,
548                 ),
549                 (
550                     "allowReducedRedundancy",
551                     "boolean",
552                     "vim.version.version10",
553                     0 | F_OPTIONAL,
554                     None,
555                 ),
556                 (
557                     "excludeHosts",
558                     "vim.HostSystem[]",
559                     "vim.version.version10",
560                     0 | F_OPTIONAL,
561                     None,
562                 ),
563                 (
564                     "spec",
565                     "vim.cluster.VsanDiskFormatConversionSpec",
566                     "vim.version.version10",
567                     0 | F_OPTIONAL,
568                     None,
569                 ),
570             ),
571             (0, "vim.Task", "vim.Task"),
572             "System.Read",
573             None,
574         ),
575         (
576             "performUpgradePreflightCheck",
577             "PerformVsanUpgradePreflightCheckEx",
578             "vim.version.version10",
579             (
580                 (
581                     "cluster"</b></font>,
582                     "vim.ClusterComputeResource",
583                     "vim.version.version10",
584                     0,
585 <a name="34"></a>                    None,
586                 ),
587                 (
588                     <font color="#827d6b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"downgradeFormat",
589                     "boolean",
590                     "vim.version.version10",
591                     0 | F_OPTIONAL,
592                     None,
593                 ),
594                 (
595                     "spec",
596                     "vim.cluster.VsanDiskFormatConversionSpec",
597                     "vim.version.version10",
598                     0 | F_OPTIONAL,
599                     None,
600                 ),
601             ),
602             (
603                 0,
604                 "vim.cluster.VsanDiskFormatConversionCheckResult",
605                 "vim.cluster.VsanDiskFormatConversionCheckResult",
606             ),
607             "System.Read",
608             None,
609         ),
610         (
611             "retrieveSupportedFormatVersion",
612             "RetrieveSupportedVsanFormatVersion",
613             "vim.version.version10",
614             (
615                 (
616                     "cluster",
617                     "vim.ClusterComputeResource",
618                     "vim.version.version10",
619                     0,
620                     None,
621                 ),
622             ),
623             (0, "int", "int"),
624             "System.Read",
625             None,
626         ),
627     ],
628 )
629 CreateManagedType(
630     "vim.cluster.VsanCapabilitySystem",
631     "VsanCapabilitySystem",
632     "vmodl.ManagedObject",
633     "vim.version.version10",
634     [],
635     [
636         (
637             "getCapabilities",
638             "VsanGetCapabilities",
639             "vim.version.version10",
640             (
641                 (
642                     "targets"</b></font>,
643                     "vmodl.ManagedObject[]",
644                     "vim.version.version10",
645                     0 | F_OPTIONAL,
646                     None,
647                 ),
648             ),
649             (0, "vim.cluster.VsanCapability[]", "vim.cluster.VsanCapability[]"),
650             "System.Read",
651             None,
652         ),
653     ],
654 )
655 CreateManagedType(
656     "vim.cluster.VsanSpaceReportSystem",
657     "VsanSpaceReportSystem",
658     "vmodl.ManagedObject",
659     "vim.version.version9",
660 <a name="33"></a>    [],
661     [
662         (
663             <font color="#736aff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"querySpaceUsage",
664             "VsanQuerySpaceUsage",
665             "vim.version.version9",
666             (("cluster", "vim.ComputeResource", "vim.version.version9", 0, None),),
667             (0, "vim.cluster.VsanSpaceUsage", "vim.cluster.VsanSpaceUsage"),
668             "System.Read",
669             None,
670         ),
671     ],
672 )
673 CreateManagedType(
674     "vim.cluster.VsanVcClusterConfigSystem",
675     "VsanVcClusterConfigSystem",
676     "vmodl.ManagedObject",
677     "vim.version.version10",
678     [],
679     [
680         (
681             "getConfigInfoEx",
682             "VsanClusterGetConfig",
683             "vim.version.version10",
684             (
685                 (
686                     "cluster",
687                     "vim.ClusterComputeResource",
688                     "vim.version.version10",
689                     0,
690                     None,
691                 ),
692             ),
693             (0, "vim.vsan.ConfigInfoEx", "vim.vsan.ConfigInfoEx"),
694             "System.Read",
695             None,
696         ),
697         (
698             "reconfigureEx",
699             "VsanClusterReconfig",
700             "vim.version.version10",
701             (
702                 (</b></font>
703                     "cluster",
704                     "vim.ClusterComputeResource",
705                     "vim.version.version10",
706                     0,
707                     None,
708                 ),
709                 (
710                     "vsanReconfigSpec",
711                     "vim.vsan.ReconfigSpec",
712                     "vim.version.version10",
713                     0,
714                     None,
715                 ),
716             ),
717             (0, "vim.Task", "vim.Task"),
718             "System.Read",
719             None,
720         ),
721     ],
722 )
723 CreateManagedType(
724     "vim.host.VsanHealthSystem",
725     "HostVsanHealthSystem",
726     "vmodl.ManagedObject",
727     "vim.version.version9",
728     [],
729     [
730         (
731             "queryAdvCfg",
732             "VsanHostQueryAdvCfg",
733             "vim.version.version9",
734             (("options", "string[]", "vim.version.version9", 0, None),),
735             (0, "vim.option.OptionValue[]", "vim.option.OptionValue[]"),
736             "System.Read",
737             None,
738         ),
739         (
740             "queryPhysicalDiskHealthSummary",
741             "VsanHostQueryPhysicalDiskHealthSummary",
742             "vim.version.version9",
743             tuple(),
744             (
745                 0,
746                 "vim.host.VsanPhysicalDiskHealthSummary",
747                 "vim.host.VsanPhysicalDiskHealthSummary",
748             ),
749             "System.Read",
750             None,
751         ),
752         (
753             "startProactiveRebalance",
754             "VsanStartProactiveRebalance",
755             "vim.version.version9",
756             (
757                 ("timeSpan", "int", "vim.version.version9", 0 | F_OPTIONAL, None),
758                 (
759                     "varianceThreshold",
760                     "float",
761                     "vim.version.version9",
762                     0 | F_OPTIONAL,
763                     None,
764                 ),
765                 ("timeThreshold", "int", "vim.version.version9", 0 | F_OPTIONAL, None),
766                 ("rateThreshold", "int", "vim.version.version9", 0 | F_OPTIONAL, None),
767             ),
768             (0, "boolean", "boolean"),
769             "System.Read",
770             None,
771         ),
772         (
773             "queryHostInfoByUuids",
774             "VsanHostQueryHostInfoByUuids",
775             "vim.version.version9",
776             (("uuids", "string[]", "vim.version.version9", 0, None),),
777             (
778                 0,
779                 "vim.host.VsanQueryResultHostInfo[]",
780                 "vim.host.VsanQueryResultHostInfo[]",
781             ),
782             "System.Read",
783             None,
784         ),
785         (
786             "queryVersion",
787             "VsanHostQueryHealthSystemVersion",
788             "vim.version.version9",
789             tuple(),
790             (0, "string", "string"),
791             "System.Read",
792             None,
793         ),
794         (
795 <a name="5"></a>            "queryVerifyNetworkSettings",
796             "VsanHostQueryVerifyNetworkSettings",
797             "vim.version.version9",
798             (<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("peers", "string[]", "vim.version.version9", 0 | F_OPTIONAL, None),),
799             (0, "vim.host.VsanNetworkHealthResult", "vim.host.VsanNetworkHealthResult"),
800             "System.Read",
801             None,
802         ),
803         (
804             "queryRunIperfClient",
805             "VsanHostQueryRunIperfClient",
806             "vim.version.version9",
807             (
808                 ("multicast", "boolean", "vim.version.version9", 0, None),
809                 ("serverIp", "string", "vim.version.version9", 0, None),
810             ),
811             (
812                 0,
813                 "vim.host.VsanNetworkLoadTestResult",
814                 "vim.host.VsanNetworkLoadTestResult",
815             ),
816             "System.Read",
817             None,
818         ),
819         (
820             "runVmdkLoadTest",
821             "VsanHostRunVmdkLoadTest",
822             "vim.version.version9",
823             (
824                 ("runname", "string", "vim.version.version9", 0, None),
825                 ("durationSec", "int", "vim.version.version9", 0, None),
826                 (
827                     "specs",
828                     "vim.host.VsanVmdkLoadTestSpec[]",
829                     "vim.version.version9",
830                     0,
831                     None,
832                 ),
833             ),
834             (
835                 0,
836                 "vim.host.VsanVmdkLoadTestResult[]",
837                 "vim.host.VsanVmdkLoadTestResult[]",
838             ),
839             "System.Read",
840             None,
841         ),
842         (
843             "queryObjectHealthSummary",
844             "VsanHostQueryObjectHealthSummary",
845             "vim.version.version9",
846             (
847                 ("objUuids", "string[]", "vim.version.version9", 0 | F_OPTIONAL, None),
848                 (
849                     "includeObjUuids",
850                     "boolean",
851                     "vim.version.version9",
852                     0 | F_OPTIONAL,
853                     None,
854                 ),
855                 (
856                     "localHostOnly",
857                     "boolean",
858                     "vim.version.version9",
859                     0 | F_OPTIONAL,
860                     None,
861                 ),
862             ),
863             (0, "vim.host.VsanObjectOverallHealth", "vim.host.VsanObjectOverallHealth"),
864             "System.Read",
865             None,
866         ),
867         (
868             "getHclInfo",
869             "VsanGetHclInfo",
870             "vim.version.version9",
871             tuple(),
872             (0, "vim.host.VsanHostHclInfo", "vim.host.VsanHostHclInfo"),
873             "System.Read",
874             None,
875         ),
876         (
877             "cleanupVmdkLoadTest",
878             "VsanHostCleanupVmdkLoadTest",
879             "vim.version.version9",
880             (
881                 ("runname"</b></font>, "string", "vim.version.version9", 0, None),
882                 (
883                     "specs",
884                     "vim.host.VsanVmdkLoadTestSpec[]",
885                     "vim.version.version9",
886                     0 | F_OPTIONAL,
887                     None,
888                 ),
889             ),
890             (0, "string", "string"),
891             "System.Read",
892             None,
893         ),
894         (
895             "waitForVsanHealthGenerationIdChange",
896             "VsanWaitForVsanHealthGenerationIdChange",
897             "vim.version.version9",
898             (("timeout", "int", "vim.version.version9", 0, None),),
899             (0, "boolean", "boolean"),
900             "System.Read",
901             None,
902         ),
903         (
904             "stopProactiveRebalance",
905             "VsanStopProactiveRebalance",
906             "vim.version.version9",
907             tuple(),
908             (0, "boolean", "boolean"),
909             "System.Read",
910             None,
911         ),
912         (
913             "repairImmediateObjects",
914             "VsanHostRepairImmediateObjects",
915             "vim.version.version9",
916             (
917                 ("uuids", "string[]", "vim.version.version9", 0 | F_OPTIONAL, None),
918                 ("repairType", "string", "vim.version.version9", 0 | F_OPTIONAL, None),
919             ),
920             (0, "vim.host.VsanRepairObjectsResult", "vim.host.VsanRepairObjectsResult"),
921             "System.Read",
922             None,
923         ),
924         (
925             "prepareVmdkLoadTest",
926             "VsanHostPrepareVmdkLoadTest",
927             "vim.version.version9",
928             (
929                 ("runname", "string", "vim.version.version9", 0, None),
930                 (
931                     "specs",
932                     "vim.host.VsanVmdkLoadTestSpec[]",
933                     "vim.version.version9",
934                     0,
935                     None,
936                 ),
937             ),
938             (0, "string", "string"),
939             "System.Read",
940             None,
941         ),
942         (
943             "queryRunIperfServer",
944             "VsanHostQueryRunIperfServer",
945             "vim.version.version9",
946             (
947                 ("multicast", "boolean", "vim.version.version9", 0, None),
948                 ("serverIp", "string", "vim.version.version9", 0 | F_OPTIONAL, None),
949             ),
950             (
951                 0,
952                 "vim.host.VsanNetworkLoadTestResult",
953                 "vim.host.VsanNetworkLoadTestResult",
954             ),
955             "System.Read",
956             None,
957         ),
958         (
959             "queryCheckLimits",
960             "VsanHostQueryCheckLimits",
961             "vim.version.version9",
962             tuple(),
963             (0, "vim.host.VsanLimitHealthResult", "vim.host.VsanLimitHealthResult"),
964             "System.Read",
965 <a name="1"></a>            None,
966         ),
967         (
968             <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"getProactiveRebalanceInfo",
969             "VsanGetProactiveRebalanceInfo",
970             "vim.version.version9",
971             tuple(),
972             (
973                 0,
974                 "vim.host.VsanProactiveRebalanceInfoEx",
975                 "vim.host.VsanProactiveRebalanceInfoEx",
976             ),
977             "System.Read",
978             None,
979         ),
980         (
981             "checkClomdLiveness",
982             "VsanHostClomdLiveness",
983             "vim.version.version9",
984             tuple(),
985             (0, "boolean", "boolean"),
986             "System.Read",
987             None,
988         ),
989     ],
990 )
991 CreateManagedType(
992     "vim.cluster.VsanVcClusterHealthSystem",
993     "VsanVcClusterHealthSystem",
994     "vmodl.ManagedObject",
995     "vim.version.version9",
996     [],
997     [
998         (
999             "queryClusterCreateVmHealthHistoryTest",
1000             "VsanQueryVcClusterCreateVmHealthHistoryTest",
1001             "vim.version.version9",
1002             (
1003                 (
1004                     "cluster",
1005                     "vim.ClusterComputeResource",
1006                     "vim.version.version9",
1007                     0,
1008                     None,
1009                 ),
1010                 ("count", "int", "vim.version.version9", 0 | F_OPTIONAL, None),
1011             ),
1012             (
1013                 0 | F_OPTIONAL,
1014                 "vim.cluster.VsanClusterCreateVmHealthTestResult[]",
1015                 "vim.cluster.VsanClusterCreateVmHealthTestResult[]",
1016             ),
1017             "System.Read",
1018             None,
1019         ),
1020         (
1021             "setLogLevel",
1022             "VsanHealthSetLogLevel",
1023             "vim.version.version9",
1024             (
1025                 (
1026                     "level",
1027                     "vim.cluster.VsanHealthLogLevelEnum",
1028                     "vim.version.version9",
1029                     0 | F_OPTIONAL,
1030                     None,
1031                 ),
1032             ),
1033             (0, "void", "void"),
1034             "System.Read",
1035             None,
1036         ),
1037         (
1038             "testVsanClusterTelemetryProxy",
1039             "VsanHealthTestVsanClusterTelemetryProxy",
1040             "vim.version.version9",
1041             (
1042                 (
1043                     "proxyConfig",
1044                     "vim.cluster.VsanClusterTelemetryProxyConfig",
1045                     "vim.version.version9",
1046                     0,
1047                     None,
1048                 ),
1049             ),
1050             (0, "boolean", "boolean"),
1051             "System.Read",
1052             None,
1053         ),
1054         (
1055             "uploadHclDb",
1056             "VsanVcUploadHclDb",
1057             "vim.version.version9",
1058             (("db", "string", "vim.version.version9", 0, None),),
1059             (0, "boolean", "boolean"),
1060             "System.Read",
1061             None,
1062         ),
1063         (
1064             "updateHclDbFromWeb",
1065             "VsanVcUpdateHclDbFromWeb",
1066             "vim.version.version9",
1067             (("url", "string", "vim.version.version9", 0 | F_OPTIONAL, None),),
1068             (0, "boolean", "boolean"),
1069             "System.Read",
1070             None,
1071         ),
1072         (
1073             "repairClusterObjectsImmediate",
1074             "VsanHealthRepairClusterObjectsImmediate",
1075             "vim.version.version9",
1076             (
1077                 (
1078                     "cluster"</b></font>,
1079                     "vim.ClusterComputeResource",
1080                     "vim.version.version9",
1081 <a name="0"></a>                    0,
1082                     None,
1083                 ),
1084                 (<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"uuids", "string[]", "vim.version.version9", 0 | F_OPTIONAL, None),
1085             ),
1086             (0, "vim.Task", "vim.Task"),
1087             "System.Read",
1088             None,
1089         ),
1090         (
1091             "queryClusterNetworkPerfTest",
1092             "VsanQueryVcClusterNetworkPerfTest",
1093             "vim.version.version9",
1094             (
1095                 (
1096                     "cluster",
1097                     "vim.ClusterComputeResource",
1098                     "vim.version.version9",
1099                     0,
1100                     None,
1101                 ),
1102                 ("multicast", "boolean", "vim.version.version9", 0, None),
1103             ),
1104             (
1105                 0,
1106                 "vim.cluster.VsanClusterNetworkLoadTestResult",
1107                 "vim.cluster.VsanClusterNetworkLoadTestResult",
1108             ),
1109             "System.Read",
1110             None,
1111         ),
1112         (
1113             "queryClusterVmdkLoadHistoryTest",
1114             "VsanQueryVcClusterVmdkLoadHistoryTest",
1115             "vim.version.version9",
1116             (
1117                 (
1118                     "cluster",
1119                     "vim.ClusterComputeResource",
1120                     "vim.version.version9",
1121                     0,
1122                     None,
1123                 ),
1124                 ("count", "int", "vim.version.version9", 0 | F_OPTIONAL, None),
1125                 ("taskId", "string", "vim.version.version9", 0 | F_OPTIONAL, None),
1126             ),
1127             (
1128                 0 | F_OPTIONAL,
1129                 "vim.cluster.VsanClusterVmdkLoadTestResult[]",
1130                 "vim.cluster.VsanClusterVmdkLoadTestResult[]",
1131             ),
1132             "System.Read",
1133             None,
1134         ),
1135         (
1136             "queryVsanClusterHealthCheckInterval",
1137             "VsanHealthQueryVsanClusterHealthCheckInterval",
1138             "vim.version.version9",
1139             (
1140                 (
1141                     "cluster",
1142                     "vim.ClusterComputeResource",
1143                     "vim.version.version9",
1144                     0,
1145                     None,
1146                 ),
1147             ),
1148             (0, "int", "int"),
1149             "System.Read",
1150             None,
1151         ),
1152         (
1153             "queryClusterCreateVmHealthTest",
1154             "VsanQueryVcClusterCreateVmHealthTest",
1155             "vim.version.version9",
1156             (
1157                 (
1158                     "cluster",
1159                     "vim.ClusterComputeResource",
1160                     "vim.version.version9",
1161                     0,
1162                     None,
1163                 ),
1164                 ("timeout", "int", "vim.version.version9", 0, None),
1165             ),
1166             (
1167                 0,
1168                 "vim.cluster.VsanClusterCreateVmHealthTestResult",
1169                 "vim.cluster.VsanClusterCreateVmHealthTestResult",
1170             ),
1171             "System.Read",
1172             None,
1173         ),
1174         (
1175             "getClusterHclInfo",
1176             "VsanVcClusterGetHclInfo",
1177             "vim.version.version9",
1178             (
1179                 (
1180                     "cluster",
1181                     "vim.ClusterComputeResource",
1182                     "vim.version.version9",
1183                     0,
1184                     None,
1185                 ),
1186                 (
1187                     "includeHostsResult",
1188                     "boolean",
1189                     "vim.version.version9",
1190                     0 | F_OPTIONAL,
1191                     None,
1192                 ),
1193             ),
1194             (0, "vim.cluster.VsanClusterHclInfo", "vim.cluster.VsanClusterHclInfo"),
1195             "System.Read",
1196             None,
1197         ),
1198         (
1199             "queryAttachToSrHistory",
1200             "VsanQueryAttachToSrHistory",
1201             "vim.version.version9",
1202             (
1203                 (
1204                     "cluster",
1205                     "vim.ClusterComputeResource",
1206                     "vim.version.version9",
1207                     0,
1208                     None,
1209                 ),
1210                 ("count", "int", "vim.version.version9", 0 | F_OPTIONAL, None),
1211                 ("taskId", "string", "vim.version.version9", 0 | F_OPTIONAL, None),
1212             ),
1213             (
1214                 0 | F_OPTIONAL,
1215                 "vim.cluster.VsanAttachToSrOperation[]",
1216                 "vim.cluster.VsanAttachToSrOperation[]",
1217             ),
1218             "System.Read",
1219             None,
1220         ),
1221         (
1222             "rebalanceCluster",
1223             "VsanRebalanceCluster",
1224             "vim.version.version9",
1225             (
1226                 (
1227                     "cluster",
1228                     "vim.ClusterComputeResource",
1229                     "vim.version.version9",
1230                     0,
1231                     None,
1232                 ),
1233                 (
1234                     "targetHosts",
1235                     "vim.HostSystem[]",
1236                     "vim.version.version9",
1237                     0 | F_OPTIONAL,
1238                     None,
1239                 ),
1240             ),
1241             (0, "vim.Task", "vim.Task"),
1242             "System.Read",
1243             None,
1244         ),
1245         (
1246             "runVmdkLoadTest",
1247             "VsanVcClusterRunVmdkLoadTest",
1248             "vim.version.version9",
1249             (
1250                 (
1251                     "cluster",
1252                     "vim.ClusterComputeResource",
1253                     "vim.version.version9",
1254                     0,
1255                     None,
1256                 ),
1257                 ("runname", "string", "vim.version.version9", 0, None),
1258                 ("durationSec", "int", "vim.version.version9", 0 | F_OPTIONAL, None),
1259                 (
1260                     "specs",
1261                     "vim.host.VsanVmdkLoadTestSpec[]",
1262                     "vim.version.version9",
1263                     0 | F_OPTIONAL,
1264                     None,
1265                 ),
1266                 ("action", "string", "vim.version.version9", 0 | F_OPTIONAL, None),
1267             ),
1268             (0, "vim.Task", "vim.Task"),
1269             "System.Read",
1270             None,
1271         ),
1272         (
1273             "sendVsanTelemetry",
1274             "VsanHealthSendVsanTelemetry",
1275             "vim.version.version9",
1276             (
1277                 (
1278                     "cluster",
1279                     "vim.ClusterComputeResource",
1280                     "vim.version.version9",
1281                     0,
1282                     None,
1283                 ),
1284             ),
1285             (0, "void", "void"),
1286             "System.Read",
1287             None,
1288         ),
1289         (
1290             "queryClusterNetworkPerfHistoryTest",
1291             "VsanQueryVcClusterNetworkPerfHistoryTest",
1292             "vim.version.version9",
1293             (
1294                 (
1295                     "cluster",
1296                     "vim.ClusterComputeResource",
1297                     "vim.version.version9",
1298                     0,
1299                     None,
1300                 ),
1301                 ("count", "int", "vim.version.version9", 0 | F_OPTIONAL, None),
1302             ),
1303             (
1304                 0 | F_OPTIONAL,
1305                 "vim.cluster.VsanClusterNetworkLoadTestResult[]",
1306                 "vim.cluster.VsanClusterNetworkLoadTestResult[]",
1307             ),
1308             "System.Read",
1309             None,
1310         ),
1311         (
1312             "queryClusterHealthSummary",
1313             "VsanQueryVcClusterHealthSummary",
1314             "vim.version.version9",
1315             (
1316                 (
1317                     "cluster",
1318                     "vim.ClusterComputeResource",
1319                     "vim.version.version9",
1320                     0,
1321                     None,
1322                 ),
1323                 (
1324                     "vmCreateTimeout",
1325                     "int",
1326                     "vim.version.version9",
1327                     0 | F_OPTIONAL,
1328                     None,
1329                 ),
1330                 ("objUuids", "string[]", "vim.version.version9", 0 | F_OPTIONAL, None),
1331                 (
1332                     "includeObjUuids",
1333                     "boolean",
1334                     "vim.version.version9",
1335                     0 | F_OPTIONAL,
1336                     None,
1337                 ),
1338                 ("fields", "string[]", "vim.version.version9", 0 | F_OPTIONAL, None),
1339                 (
1340                     "fetchFromCache",
1341                     "boolean",
1342                     "vim.version.version9",
1343                     0 | F_OPTIONAL,
1344                     None,
1345                 ),
1346             ),
1347             (
1348                 0,
1349                 "vim.cluster.VsanClusterHealthSummary",
1350                 "vim.cluster.VsanClusterHealthSummary",
1351             ),
1352             "System.Read",
1353             None,
1354         ),
1355         (
1356             "stopRebalanceCluster",
1357             "VsanStopRebalanceCluster",
1358             "vim.version.version9",
1359             (
1360                 (
1361                     "cluster",
1362                     "vim.ClusterComputeResource",
1363                     "vim.version.version9",
1364                     0,
1365                     None,
1366                 ),
1367                 (
1368                     "targetHosts",
1369                     "vim.HostSystem[]",
1370                     "vim.version.version9",
1371                     0 | F_OPTIONAL,
1372                     None,
1373                 ),
1374             ),
1375             (0, "vim.Task", "vim.Task"),
1376             "System.Read",
1377             None,
1378         ),
1379         (
1380             "queryVsanClusterHealthConfig",
1381             "VsanHealthQueryVsanClusterHealthConfig",
1382             "vim.version.version9",
1383             (
1384                 (
1385                     "cluster",
1386                     "vim.ClusterComputeResource",
1387                     "vim.version.version9",
1388                     0,
1389                     None,
1390                 ),
1391             ),
1392             (
1393                 0,
1394                 "vim.cluster.VsanClusterHealthConfigs",
1395                 "vim.cluster.VsanClusterHealthConfigs",
1396             ),
1397             "System.Read",
1398             None,
1399         ),
1400         (
1401             "attachVsanSupportBundleToSr",
1402             "VsanAttachVsanSupportBundleToSr",
1403             "vim.version.version9",
1404             (
1405                 (
1406                     "cluster",
1407                     "vim.ClusterComputeResource",
1408                     "vim.version.version9",
1409                     0,
1410                     None,
1411                 ),
1412                 ("srNumber", "string", "vim.version.version9", 0, None),
1413             ),
1414             (0, "vim.Task", "vim.Task"),
1415             "System.Read",
1416             None,
1417         ),
1418         (
1419             "queryClusterVmdkWorkloadTypes",
1420             "VsanQueryVcClusterVmdkWorkloadTypes",
1421             "vim.version.version9",
1422             tuple(</b></font>),
1423             (
1424                 0,
1425                 "vim.cluster.VsanStorageWorkloadType[]",
1426                 "vim.cluster.VsanStorageWorkloadType[]",
1427             ),
1428             "System.Read",
1429             None,
1430         ),
1431         (
1432             "queryVerifyClusterHealthSystemVersions",
1433             "VsanVcClusterQueryVerifyHealthSystemVersions",
1434             "vim.version.version9",
1435             (
1436                 (
1437                     "cluster",
1438                     "vim.ClusterComputeResource",
1439                     "vim.version.version9",
1440                     0,
1441                     None,
1442                 ),
1443             ),
1444             (
1445                 0,
1446                 "vim.cluster.VsanClusterHealthSystemVersionResult",
1447                 "vim.cluster.VsanClusterHealthSystemVersionResult",
1448             ),
1449             "System.Read",
1450             None,
1451         ),
1452         (
1453             "isRebalanceRunning",
1454             "VsanHealthIsRebalanceRunning",
1455             "vim.version.version9",
1456             (
1457                 (
1458                     "cluster",
1459                     "vim.ClusterComputeResource",
1460                     "vim.version.version9",
1461                     0,
1462                     None,
1463                 ),
1464                 (
1465                     "targetHosts",
1466                     "vim.HostSystem[]",
1467                     "vim.version.version9",
1468                     0 | F_OPTIONAL,
1469                     None,
1470                 ),
1471             ),
1472             (0, "boolean", "boolean"),
1473             "System.Read",
1474             None,
1475         ),
1476         (
1477             "setVsanClusterHealthCheckInterval",
1478             "VsanHealthSetVsanClusterHealthCheckInterval",
1479             "vim.version.version9",
1480             (
1481                 (
1482                     "cluster",
1483                     "vim.ClusterComputeResource",
1484                     "vim.version.version9",
1485                     0,
1486                     None,
1487                 ),
1488                 (
1489                     "vsanClusterHealthCheckInterval",
1490                     "int",
1491                     "vim.version.version9",
1492                     0,
1493                     None,
1494                 ),
1495             ),
1496             (0, "void", "void"),
1497             "System.Read",
1498             None,
1499         ),
1500     ],
1501 )
1502 CreateManagedType(
1503     "vim.cluster.VsanVcStretchedClusterSystem",
1504     "VimClusterVsanVcStretchedClusterSystem",
1505     "vmodl.ManagedObject",
1506 <a name="10"></a>    "vim.version.version10",
1507     [],
1508     [
1509         <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(
1510             "isWitnessHost",
1511             "VSANVcIsWitnessHost",
1512             "vim.version.version10",
1513             (("host", "vim.HostSystem", "vim.version.version10", 0, None),),
1514             (0, "boolean", "boolean"),
1515             "System.Read",
1516             None,
1517         ),
1518         (
1519             "setPreferredFaultDomain",
1520             "VSANVcSetPreferredFaultDomain",
1521             "vim.version.version10",
1522             (
1523                 (
1524                     "cluster",
1525                     "vim.ClusterComputeResource",
1526                     "vim.version.version10",
1527                     0,
1528                     None,
1529                 ),
1530                 ("preferredFd", "string", "vim.version.version10", 0, None),
1531                 (
1532                     "witnessHost",
1533                     "vim.HostSystem",
1534                     "vim.version.version10",
1535                     0 | F_OPTIONAL,
1536                     None,
1537                 ),
1538             ),
1539             (0, "vim.Task", "vim.Task"),
1540             "System.Read",
1541             None,
1542         ),
1543         (
1544             "getPreferredFaultDomain",
1545             "VSANVcGetPreferredFaultDomain",
1546             "vim.version.version10",
1547             (
1548                 (
1549                     "cluster",
1550                     "vim.ClusterComputeResource",
1551                     "vim.version.version10",
1552                     0,
1553                     None,
1554                 ),
1555             ),
1556             (
1557                 0 | F_OPTIONAL,
1558                 "vim.cluster.VSANPreferredFaultDomainInfo",
1559                 "vim.cluster.VSANPreferredFaultDomainInfo",
1560             ),
1561             "System.Read",
1562             None,
1563         ),
1564         (
1565             "getWitnessHosts",
1566             "VSANVcGetWitnessHosts",
1567             "vim.version.version10",
1568             (
1569                 (
1570                     "cluster",
1571                     "vim.ClusterComputeResource",
1572                     "vim.version.version10",
1573                     0,
1574                     None,
1575                 ),
1576             ),
1577             (
1578                 0 | F_OPTIONAL,
1579                 "vim.cluster.VSANWitnessHostInfo[]",
1580                 "vim.cluster.VSANWitnessHostInfo[]",
1581             ),
1582             "System.Read",
1583             None,
1584         ),
1585         (
1586             "retrieveStretchedClusterVcCapability",
1587             "VSANVcRetrieveStretchedClusterVcCapability",
1588             "vim.version.version10",
1589             (
1590                 (</b></font>
1591                     "cluster",
1592                     "vim.ClusterComputeResource",
1593                     "vim.version.version10",
1594                     0,
1595                     None,
1596                 ),
1597                 (
1598                     "verifyAllConnected",
1599                     "boolean",
1600                     "vim.version.version10",
1601                     0 | F_OPTIONAL,
1602                     None,
1603                 ),
1604             ),
1605             (
1606                 0 | F_OPTIONAL,
1607                 "vim.cluster.VSANStretchedClusterCapability[]",
1608                 "vim.cluster.VSANStretchedClusterCapability[]",
1609             ),
1610             "System.Read",
1611             None,
1612         ),
1613         (
1614             "convertToStretchedCluster",
1615             "VSANVcConvertToStretchedCluster",
1616 <a name="13"></a>            "vim.version.version10",
1617             (
1618                 (
1619                     <font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"cluster",
1620                     "vim.ClusterComputeResource",
1621                     "vim.version.version10",
1622                     0,
1623                     None,
1624                 ),
1625                 (
1626                     "faultDomainConfig",
1627                     "vim.cluster.VSANStretchedClusterFaultDomainConfig",
1628                     "vim.version.version10",
1629                     0,
1630                     None,
1631                 ),
1632                 ("witnessHost", "vim.HostSystem", "vim.version.version10", 0, None),
1633                 ("preferredFd", "string", "vim.version.version10", 0, None),
1634                 (
1635                     "diskMapping",
1636                     "vim.vsan.host.DiskMapping",
1637                     "vim.version.version10",
1638                     0 | F_OPTIONAL,
1639                     None,
1640                 ),
1641             ),
1642             (0, "vim.Task", "vim.Task"),
1643             "System.Read",
1644             None,
1645         ),
1646         (
1647             "removeWitnessHost",
1648             "VSANVcRemoveWitnessHost",
1649             "vim.version.version10",
1650             (
1651                 (
1652                     "cluster",
1653                     "vim.ClusterComputeResource",
1654                     "vim.version.version10",
1655                     0,
1656                     None,
1657                 ),
1658                 (
1659                     "witnessHost",
1660                     "vim.HostSystem",
1661                     "vim.version.version10",
1662                     0 | F_OPTIONAL,
1663                     None,
1664                 ),
1665                 (
1666                     "witnessAddress",
1667                     "string",
1668                     "vim.version.version10",
1669                     0 | F_OPTIONAL,
1670                     None,
1671                 ),
1672             ),
1673             (0, "vim.Task", "vim.Task"),
1674             "System.Read",
1675             None,
1676         ),
1677     ],
1678 )
1679 CreateManagedType(
1680     "vim.cluster.VsanClusterHealthSystem",
1681     "VsanClusterHealthSystem",
1682     "vmodl.ManagedObject",
1683     "vim.version.version9",
1684     [],
1685     [
1686         (
1687             "queryPhysicalDiskHealthSummary",
1688             "VsanQueryClusterPhysicalDiskHealthSummary",
1689             "vim.version.version9",
1690             (
1691                 ("hosts"</b></font>, "string[]", "vim.version.version9", 0, None),
1692                 ("esxRootPassword", "string", "vim.version.version9", 0, None),
1693             ),
1694             (
1695                 0,
1696                 "vim.host.VsanPhysicalDiskHealthSummary[]",
1697                 "vim.host.VsanPhysicalDiskHealthSummary[]",
1698             ),
1699             "System.Read",
1700             None,
1701         ),
1702         (
1703             "queryClusterNetworkPerfTest",
1704             "VsanQueryClusterNetworkPerfTest",
1705             "vim.version.version9",
1706             (
1707                 ("hosts", "string[]", "vim.version.version9", 0, None),
1708                 ("esxRootPassword", "string", "vim.version.version9", 0, None),
1709                 ("multicast", "boolean", "vim.version.version9", 0, None),
1710             ),
1711             (
1712                 0,
1713                 "vim.cluster.VsanClusterNetworkLoadTestResult",
1714                 "vim.cluster.VsanClusterNetworkLoadTestResult",
1715             ),
1716             "System.Read",
1717             None,
1718         ),
1719         (
1720             "queryAdvCfgSync",
1721             "VsanQueryClusterAdvCfgSync",
1722             "vim.version.version9",
1723             (
1724                 ("hosts", "string[]", "vim.version.version9", 0, None),
1725                 ("esxRootPassword", "string", "vim.version.version9", 0, None),
1726             ),
1727             (
1728                 0,
1729                 "vim.cluster.VsanClusterAdvCfgSyncResult[]",
1730                 "vim.cluster.VsanClusterAdvCfgSyncResult[]",
1731             ),
1732             "System.Read",
1733             None,
1734         ),
1735         (
1736             "repairClusterImmediateObjects",
1737             "VsanRepairClusterImmediateObjects",
1738             "vim.version.version9",
1739             (
1740                 ("hosts", "string[]", "vim.version.version9", 0, None),
1741                 ("esxRootPassword", "string", "vim.version.version9", 0, None),
1742                 ("uuids", "string[]", "vim.version.version9", 0 | F_OPTIONAL, None),
1743             ),
1744             (
1745                 0,
1746                 "vim.cluster.VsanClusterHealthSystemObjectsRepairResult",
1747                 "vim.cluster.VsanClusterHealthSystemObjectsRepairResult",
1748             ),
1749             "System.Read",
1750             None,
1751         ),
1752         (
1753             "queryVerifyClusterNetworkSettings",
1754             "VsanQueryVerifyClusterNetworkSettings",
1755             "vim.version.version9",
1756             (
1757                 ("hosts", "string[]", "vim.version.version9", 0, None),
1758                 ("esxRootPassword", "string", "vim.version.version9", 0, None),
1759             ),
1760             (
1761                 0,
1762                 "vim.cluster.VsanClusterNetworkHealthResult",
1763                 "vim.cluster.VsanClusterNetworkHealthResult",
1764             ),
1765             "System.Read",
1766             None,
1767         ),
1768         (
1769             "queryClusterCreateVmHealthTest",
1770             "VsanQueryClusterCreateVmHealthTest",
1771             "vim.version.version9",
1772             (
1773                 ("hosts", "string[]", "vim.version.version9", 0, None),
1774                 ("esxRootPassword", "string", "vim.version.version9", 0, None),
1775                 ("timeout", "int", "vim.version.version9", 0, None),
1776             ),
1777             (
1778                 0,
1779                 "vim.cluster.VsanClusterCreateVmHealthTestResult",
1780                 "vim.cluster.VsanClusterCreateVmHealthTestResult",
1781             ),
1782             "System.Read",
1783             None,
1784         ),
1785         (
1786             "queryClusterHealthSystemVersions",
1787             "VsanQueryClusterHealthSystemVersions",
1788             "vim.version.version9",
1789             (
1790                 ("hosts", "string[]", "vim.version.version9", 0, None),
1791                 ("esxRootPassword", "string", "vim.version.version9", 0, None),
1792             ),
1793             (
1794                 0,
1795                 "vim.cluster.VsanClusterHealthSystemVersionResult",
1796                 "vim.cluster.VsanClusterHealthSystemVersionResult",
1797             ),
1798             "System.Read",
1799             None,
1800         ),
1801         (
1802             "getClusterHclInfo",
1803             "VsanClusterGetHclInfo",
1804             "vim.version.version9",
1805             (
1806                 ("hosts", "string[]", "vim.version.version9", 0, None),
1807                 ("esxRootPassword", "string", "vim.version.version9", 0, None),
1808             ),
1809             (0, "vim.cluster.VsanClusterHclInfo", "vim.cluster.VsanClusterHclInfo"),
1810             "System.Read",
1811             None,
1812         ),
1813         (
1814             "queryCheckLimits",
1815             "VsanQueryClusterCheckLimits",
1816             "vim.version.version9",
1817             (
1818                 ("hosts", "string[]", "vim.version.version9", 0, None),
1819                 ("esxRootPassword", "string", "vim.version.version9", 0, None),
1820             ),
1821             (
1822                 0,
1823                 "vim.cluster.VsanClusterLimitHealthResult",
1824                 "vim.cluster.VsanClusterLimitHealthResult",
1825             ),
1826             "System.Read",
1827             None,
1828         ),
1829         (
1830             "queryCaptureVsanPcap",
1831             "VsanQueryClusterCaptureVsanPcap",
1832             "vim.version.version9",
1833             (
1834                 ("hosts", "string[]", "vim.version.version9", 0, None),
1835                 ("esxRootPassword", "string", "vim.version.version9", 0, None),
1836                 ("duration", "int", "vim.version.version9", 0, None),
1837                 (
1838                     "vmknic",
1839                     "vim.cluster.VsanClusterHostVmknicMapping[]",
1840                     "vim.version.version9",
1841                     0 | F_OPTIONAL,
1842                     None,
1843                 ),
1844                 (
1845                     "includeRawPcap",
1846                     "boolean",
1847                     "vim.version.version9",
1848                     0 | F_OPTIONAL,
1849                     None,
1850                 ),
1851                 (
1852                     "includeIgmp",
1853                     "boolean",
1854                     "vim.version.version9",
1855                     0 | F_OPTIONAL,
1856                     None,
1857                 ),
1858                 (
1859                     "cmmdsMsgTypeFilter",
1860                     "string[]",
1861                     "vim.version.version9",
1862                     0 | F_OPTIONAL,
1863                     None,
1864                 ),
1865                 ("cmmdsPorts", "int[]", "vim.version.version9", 0 | F_OPTIONAL, None),
1866                 ("clusterUuid", "string", "vim.version.version9", 0 | F_OPTIONAL, None),
1867             ),
1868             (
1869                 0,
1870                 "vim.cluster.VsanVsanClusterPcapResult",
1871                 "vim.cluster.VsanVsanClusterPcapResult",
1872             ),
1873             "System.Read",
1874 <a name="32"></a>            None,
1875         ),
1876         (
1877             <font color="#5b8daf"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"checkClusterClomdLiveness",
1878             "VsanCheckClusterClomdLiveness",
1879             "vim.version.version9",
1880             (
1881                 ("hosts", "string[]", "vim.version.version9", 0, None),
1882                 ("esxRootPassword", "string", "vim.version.version9", 0, None),
1883             ),
1884             (
1885                 0,
1886                 "vim.cluster.VsanClusterClomdLivenessResult",
1887                 "vim.cluster.VsanClusterClomdLivenessResult",
1888             ),
1889             "System.Read",
1890             None,
1891         ),
1892     ],
1893 )
1894 CreateDataType(
1895     "vim.host.VSANCmmdsNodeInfo",
1896     "VimHostVSANCmmdsNodeInfo",
1897     "vmodl.DynamicData",
1898     "vim.version.version10",
1899     [
1900         ("nodeUuid", "string", "vim.version.version10", 0),
1901         ("isWitness", "boolean", "vim.version.version10", 0),
1902     ],
1903 )
1904 CreateDataType(
1905     "vim.host.VsanPhysicalDiskHealth",
1906     "VsanPhysicalDiskHealth",
1907     "vmodl.DynamicData",
1908     "vim.version.version9",
1909     [
1910         ("name"</b></font>, "string", "vim.version.version9", 0),
1911         ("uuid", "string", "vim.version.version9", 0),
1912         ("inCmmds", "boolean", "vim.version.version9", 0),
1913         ("inVsi", "boolean", "vim.version.version9", 0),
1914         ("dedupScope", "long", "vim.version.version9", 0 | F_OPTIONAL),
1915         ("formatVersion", "int", "vim.version.version9", 0 | F_OPTIONAL),
1916         ("isAllFlash", "int", "vim.version.version9", 0 | F_OPTIONAL),
1917         ("congestionValue", "int", "vim.version.version9", 0 | F_OPTIONAL),
1918         ("congestionArea", "string", "vim.version.version9", 0 | F_OPTIONAL),
1919         ("congestionHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
1920         ("metadataHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
1921         (
1922             "operationalHealthDescription",
1923             "string",
1924             "vim.version.version9",
1925             0 | F_OPTIONAL,
1926         ),
1927         ("operationalHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
1928         ("dedupUsageHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
1929         ("capacityHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
1930         ("summaryHealth", "string", "vim.version.version9", 0),
1931         ("capacity", "long", "vim.version.version9", 0 | F_OPTIONAL),
1932         ("usedCapacity", "long", "vim.version.version9", 0 | F_OPTIONAL),
1933         ("reservedCapacity", "long", "vim.version.version9", 0 | F_OPTIONAL),
1934         ("totalBytes", "long", "vim.version.version9", 0 | F_OPTIONAL),
1935         ("freeBytes", "long", "vim.version.version9", 0 | F_OPTIONAL),
1936         ("hashedBytes", "long", "vim.version.version9", 0 | F_OPTIONAL),
1937         ("dedupedBytes", "long", "vim.version.version9", 0 | F_OPTIONAL),
1938         ("scsiDisk", "vim.host.ScsiDisk", "vim.version.version9", 0 | F_OPTIONAL),
1939         ("usedComponents", "long", "vim.version.version9", 0 | F_OPTIONAL),
1940         ("maxComponents", "long", "vim.version.version9", 0 | F_OPTIONAL),
1941         ("compLimitHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
1942     ],
1943 )
1944 CreateDataType(
1945     "vim.vsan.DataEfficiencyConfig",
1946     "VsanDataEfficiencyConfig",
1947     "vmodl.DynamicData",
1948     "vim.version.version10",
1949     [
1950         ("dedupEnabled", "boolean", "vim.version.version10", 0),
1951         ("compressionEnabled", "boolean", "vim.version.version10", 0 | F_OPTIONAL),
1952     ],
1953 )
1954 CreateDataType(
1955     "vim.cluster.StorageComplianceResult",
1956     "VsanStorageComplianceResult",
1957     "vmodl.DynamicData",
1958     "vim.version.version9",
1959     [
1960         ("checkTime", "vmodl.DateTime", "vim.version.version9", 0 | F_OPTIONAL),
1961         ("profile", "string", "vim.version.version9", 0 | F_OPTIONAL),
1962         ("objectUUID", "string", "vim.version.version9", 0 | F_OPTIONAL),
1963         (
1964             "complianceStatus",
1965             "vim.cluster.StorageComplianceStatus",
1966             "vim.version.version9",
1967             0,
1968         ),
1969         ("mismatch", "boolean", "vim.version.version9", 0),
1970         (
1971             "violatedPolicies",
1972             "vim.cluster.StoragePolicyStatus[]",
1973             "vim.version.version9",
1974             0 | F_OPTIONAL,
1975         ),
1976         (
1977             "operationalStatus",
1978             "vim.cluster.StorageOperationalStatus",
1979             "vim.version.version9",
1980             0 | F_OPTIONAL,
1981         ),
1982     ],
1983 )
1984 CreateDataType(
1985     "vim.cluster.VsanClusterHealthGroup",
1986     "VsanClusterHealthGroup",
1987     "vmodl.DynamicData",
1988     "vim.version.version9",
1989     [
1990         ("groupId", "string", "vim.version.version9", 0),
1991         ("groupName", "string", "vim.version.version9", 0),
1992         ("groupHealth", "string", "vim.version.version9", 0),
1993         (
1994             "groupTests",
1995             "vim.cluster.VsanClusterHealthTest[]",
1996             "vim.version.version9",
1997             0 | F_OPTIONAL,
1998         ),
1999         (
2000             "groupDetails",
2001             "vim.cluster.VsanClusterHealthResultBase[]",
2002             "vim.version.version9",
2003             0 | F_OPTIONAL,
2004         ),
2005     ],
2006 )
2007 CreateDataType(
2008     "vim.cluster.VsanSpaceUsageDetailResult",
2009     "VsanSpaceUsageDetailResult",
2010     "vmodl.DynamicData",
2011     "vim.version.version9",
2012     [
2013         (
2014             "spaceUsageByObjectType",
2015             "vim.cluster.VsanObjectSpaceSummary[]",
2016             "vim.version.version9",
2017             0 | F_OPTIONAL,
2018         )
2019     ],
2020 )
2021 CreateDataType(
2022     "vim.cluster.VsanAttachToSrOperation",
2023     "VsanAttachToSrOperation",
2024     "vmodl.DynamicData",
2025     "vim.version.version9",
2026     [
2027         ("task", "vim.Task", "vim.version.version9", 0 | F_OPTIONAL),
2028         ("success", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2029         ("timestamp", "vmodl.DateTime", "vim.version.version9", 0 | F_OPTIONAL),
2030         ("srNumber", "string", "vim.version.version9", 0),
2031     ],
2032 )
2033 CreateDataType(
2034     "vim.cluster.VsanObjectSpaceSummary",
2035     "VsanObjectSpaceSummary",
2036     "vmodl.DynamicData",
2037     "vim.version.version9",
2038     [
2039         (
2040             "objType",
2041             "vim.cluster.VsanObjectTypeEnum",
2042             "vim.version.version9",
2043             0 | F_OPTIONAL,
2044         ),
2045         ("overheadB", "long", "vim.version.version9", 0 | F_OPTIONAL),
2046 <a name="21"></a>        ("temporaryOverheadB", "long", "vim.version.version9", 0 | F_OPTIONAL),
2047         ("primaryCapacityB", "long", "vim.version.version9", 0 | F_OPTIONAL),
2048         ("provisionCapacityB", "long", "vim.version.version9", 0 | F_OPTIONAL),
2049         (<font color="#947010"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"reservedCapacityB", "long", "vim.version.version9", 0 | F_OPTIONAL),
2050         ("overReservedB", "long", "vim.version.version9", 0 | F_OPTIONAL),
2051         ("physicalUsedB", "long", "vim.version.version9", 0 | F_OPTIONAL),
2052         ("usedB", "long", "vim.version.version9", 0 | F_OPTIONAL),
2053     ],
2054 )
2055 CreateDataType(
2056     "vim.cluster.VsanClusterHclInfo",
2057     "VsanClusterHclInfo",
2058     "vmodl.DynamicData",
2059     "vim.version.version9",
2060     [
2061         ("hclDbLastUpdate", "vmodl.DateTime", "vim.version.version9", 0 | F_OPTIONAL),
2062         ("hclDbAgeHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
2063         (
2064             "hostResults",
2065             "vim.host.VsanHostHclInfo[]",
2066             "vim.version.version9",
2067             0 | F_OPTIONAL,
2068         ),
2069     ],
2070 )
2071 CreateDataType(
2072     "vim.cluster.VsanPerfGraph",
2073     "VsanPerfGraph",
2074     "vmodl.DynamicData",
2075     "vim.version.version9",
2076     [
2077         ("id", "string", "vim.version.version9", 0),
2078 <a name="28"></a>        ("metrics", "vim.cluster.VsanPerfMetricId[]", "vim.version.version9", 0),
2079         ("unit"</b></font>, "vim.cluster.VsanPerfStatsUnitType", "vim.version.version9", 0),
2080         (
2081             <font color="#717d7d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"threshold",
2082             "vim.cluster.VsanPerfThreshold",
2083             "vim.version.version9",
2084             0 | F_OPTIONAL,
2085         ),
2086         ("name", "string", "vim.version.version9", 0 | F_OPTIONAL),
2087         ("description", "string", "vim.version.version9", 0 | F_OPTIONAL),
2088     ],
2089 )
2090 CreateDataType(
2091     "vim.cluster.VsanClusterHealthResultBase",
2092     "VsanClusterHealthResultBase",
2093     "vmodl.DynamicData",
2094     "vim.version.version9",
2095     [("label", "string", "vim.version.version9", 0 | F_OPTIONAL)],
2096 )
2097 CreateDataType(
2098     "vim.cluster.VsanPerfTopEntity",
2099     "VsanPerfTopEntity",
2100     "vmodl.DynamicData",
2101     "vim.version.version9",
2102     [
2103         ("entityRefId", "string", "vim.version.version9", 0),
2104         ("value", "string", "vim.version.version9", 0),
2105     ],
2106 )
2107 CreateDataType(
2108     "vim.cluster.VsanClusterBalancePerDiskInfo",
2109     "VsanClusterBalancePerDiskInfo",
2110     "vmodl.DynamicData",
2111     "vim.version.version9",
2112     [
2113         ("uuid"</b></font>, "string", "vim.version.version9", 0 | F_OPTIONAL),
2114         ("fullness", "long", "vim.version.version9", 0),
2115         ("variance", "long", "vim.version.version9", 0),
2116         ("fullnessAboveThreshold", "long", "vim.version.version9", 0),
2117         ("dataToMoveB", "long", "vim.version.version9", 0),
2118     ],
2119 )
2120 CreateDataType(
2121     "vim.cluster.VsanClusterHealthTest",
2122     "VsanClusterHealthTest",
2123     "vmodl.DynamicData",
2124     "vim.version.version9",
2125     [
2126 <a name="18"></a>        ("testId", "string", "vim.version.version9", 0 | F_OPTIONAL),
2127         ("testName", "string", "vim.version.version9", 0 | F_OPTIONAL),
2128         ("testDescription", "string", "vim.version.version9", 0 | F_OPTIONAL),
2129         (<font color="#800517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"testShortDescription", "string", "vim.version.version9", 0 | F_OPTIONAL),
2130         ("testHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
2131         (
2132             "testDetails",
2133             "vim.cluster.VsanClusterHealthResultBase[]",
2134             "vim.version.version9",
2135             0 | F_OPTIONAL,
2136         ),
2137         (
2138             "testActions",
2139             "vim.cluster.VsanClusterHealthAction[]",
2140             "vim.version.version9",
2141             0 | F_OPTIONAL,
2142         ),
2143     ],
2144 )
2145 CreateDataType(
2146     "vim.cluster.StoragePolicyStatus",
2147     "VsanStoragePolicyStatus",
2148     "vmodl.DynamicData",
2149     "vim.version.version9",
2150     [
2151         ("id", "string", "vim.version.version9", 0 | F_OPTIONAL),
2152         ("expectedValue", "string", "vim.version.version9", 0 | F_OPTIONAL),
2153         ("currentValue", "string", "vim.version.version9", 0 | F_OPTIONAL),
2154     ],
2155 )
2156 CreateDataType(
2157     "vim.cluster.VsanPerfMemberInfo",
2158     "VsanPerfMemberInfo",
2159     "vmodl.DynamicData",
2160     "vim.version.version9",
2161     [("thumbprint", "string", "vim.version.version9", 0)],
2162 )
2163 CreateDataType(
2164     "vim.cluster.VsanPerfMetricId",
2165     "VsanPerfMetricId",
2166     "vmodl.DynamicData",
2167     "vim.version.version9",
2168     [
2169         ("label"</b></font>, "string", "vim.version.version9", 0),
2170         ("group", "string", "vim.version.version9", 0 | F_OPTIONAL),
2171         (
2172             "rollupType",
2173             "vim.cluster.VsanPerfSummaryType",
2174             "vim.version.version9",
2175             0 | F_OPTIONAL,
2176         ),
2177         (
2178             "statsType",
2179             "vim.cluster.VsanPerfStatsType",
2180             "vim.version.version9",
2181             0 | F_OPTIONAL,
2182         ),
2183         ("name", "string", "vim.version.version9", 0 | F_OPTIONAL),
2184         ("description", "string", "vim.version.version9", 0 | F_OPTIONAL),
2185         ("metricsCollectInterval", "int", "vim.version.version9", 0 | F_OPTIONAL),
2186     ],
2187 )
2188 CreateDataType(
2189     "vim.cluster.VSANWitnessHostInfo",
2190     "VimClusterVSANWitnessHostInfo",
2191     "vmodl.DynamicData",
2192     "vim.version.version10",
2193     [
2194         ("nodeUuid", "string", "vim.version.version10", 0),
2195         ("faultDomainName", "string", "vim.version.version10", 0 | F_OPTIONAL),
2196         ("preferredFdName", "string", "vim.version.version10", 0 | F_OPTIONAL),
2197         ("preferredFdUuid", "string", "vim.version.version10", 0 | F_OPTIONAL),
2198         ("unicastAgentAddr", "string", "vim.version.version10", 0 | F_OPTIONAL),
2199         ("host", "vim.HostSystem", "vim.version.version10", 0 | F_OPTIONAL),
2200     ],
2201 )
2202 CreateDataType(
2203     "vim.cluster.VsanHealthExtMgmtPreCheckResult",
2204     "VsanHealthExtMgmtPreCheckResult",
2205 <a name="27"></a>    "vmodl.DynamicData",
2206     "vim.version.version9",
2207     [
2208         (<font color="#e77471"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"overallResult", "boolean", "vim.version.version9", 0),
2209         ("esxVersionCheckPassed", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2210         ("drsCheckPassed", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2211         ("eamConnectionCheckPassed", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2212         ("installStateCheckPassed", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2213         ("results", "vim.cluster.VsanClusterHealthTest[]", "vim.version.version9", 0),
2214         ("vumRegistered", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2215     ],
2216 )
2217 CreateDataType(
2218     "vim.vsan.upgradesystem.HostWithHybridDiskgroupIssue",
2219     "VsanHostWithHybridDiskgroupIssue",
2220     "vim.VsanUpgradeSystem.PreflightCheckIssue",
2221     "vim.version.version10",
2222     [("hosts", "vim.HostSystem[]", "vim.version.version10", 0)],
2223 )
2224 CreateDataType(
2225     "vim.cluster.VsanPerfMetricSeriesCSV",
2226     "VsanPerfMetricSeriesCSV",
2227     "vmodl.DynamicData",
2228     "vim.version.version9",
2229     [
2230         ("metricId"</b></font>, "vim.cluster.VsanPerfMetricId", "vim.version.version9", 0),
2231         ("values", "string", "vim.version.version9", 0 | F_OPTIONAL),
2232     ],
2233 )
2234 CreateDataType(
2235     "vim.cluster.VsanPerfQuerySpec",
2236     "VsanPerfQuerySpec",
2237 <a name="26"></a>    "vmodl.DynamicData",
2238     "vim.version.version9",
2239     [
2240         <font color="#68818b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("entityRefId", "string", "vim.version.version9", 0),
2241         ("startTime", "vmodl.DateTime", "vim.version.version9", 0 | F_OPTIONAL),
2242         ("endTime", "vmodl.DateTime", "vim.version.version9", 0 | F_OPTIONAL),
2243         ("group", "string", "vim.version.version9", 0 | F_OPTIONAL),
2244         ("labels", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2245         ("interval", "int", "vim.version.version9", 0 | F_OPTIONAL),
2246     ],
2247 )
2248 CreateDataType(
2249     "vim.host.VsanRepairObjectsResult",
2250     "VsanRepairObjectsResult",
2251     "vmodl.DynamicData",
2252     "vim.version.version9",
2253     [
2254         ("inQueueObjects", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2255         (
2256             "failedRepairObjects",
2257             "vim.host.VsanFailedRepairObjectResult[]",
2258             "vim.version.version9",
2259             0 | F_OPTIONAL,
2260         ),
2261         ("notInQueueObjects", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2262     ],
2263 )
2264 CreateDataType(</b></font>
2265     "vim.cluster.VsanClusterNetworkPartitionInfo",
2266     "VsanClusterNetworkPartitionInfo",
2267     "vmodl.DynamicData",
2268     "vim.version.version9",
2269     [("hosts", "string[]", "vim.version.version9", 0 | F_OPTIONAL)],
2270 )
2271 CreateDataType(
2272     "vim.vsan.upgradesystem.MixedEsxVersionIssue",
2273     "VsanMixedEsxVersionIssue",
2274     "vim.VsanUpgradeSystem.PreflightCheckIssue",
2275     "vim.version.version10",
2276     [],
2277 )
2278 CreateDataType(
2279     "vim.cluster.VsanClusterClomdLivenessResult",
2280     "VsanClusterClomdLivenessResult",
2281     "vmodl.DynamicData",
2282     "vim.version.version9",
2283     [
2284         (
2285             "clomdLivenessResult",
2286             "vim.cluster.VsanHostClomdLivenessResult[]",
2287             "vim.version.version9",
2288             0 | F_OPTIONAL,
2289         ),
2290         ("issueFound", "boolean", "vim.version.version9", 0),
2291     ],
2292 )
2293 CreateDataType(
2294     "vim.cluster.VsanVsanClusterPcapResult",
2295     "VsanVsanClusterPcapResult",
2296     "vmodl.DynamicData",
2297     "vim.version.version9",
2298     [
2299         ("pkts", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2300         (
2301             "groups",
2302             "vim.cluster.VsanVsanClusterPcapGroup[]",
2303             "vim.version.version9",
2304             0 | F_OPTIONAL,
2305         ),
2306         ("issues", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2307         (
2308             "hostResults",
2309             "vim.host.VsanVsanPcapResult[]",
2310             "vim.version.version9",
2311             0 | F_OPTIONAL,
2312         ),
2313     ],
2314 )
2315 CreateDataType(
2316     "vim.cluster.VsanPerfMasterInformation",
2317     "VsanPerfMasterInformation",
2318     "vmodl.DynamicData",
2319     "vim.version.version9",
2320 <a name="8"></a>    [
2321         ("secSinceLastStatsWrite", "long", "vim.version.version9", 0 | F_OPTIONAL),
2322         ("secSinceLastStatsCollect", "long", "vim.version.version9", 0 | F_OPTIONAL),
2323         (<font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"statsIntervalSec", "long", "vim.version.version9", 0),
2324         (
2325             "collectionFailureHostUuids",
2326             "string[]",
2327             "vim.version.version9",
2328             0 | F_OPTIONAL,
2329         ),
2330         ("renamedStatsDirectories", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2331         ("statsDirectoryPercentFree", "long", "vim.version.version9", 0 | F_OPTIONAL),
2332     ],
2333 )
2334 CreateDataType(
2335     "vim.cluster.VsanHostCreateVmHealthTestResult",
2336     "VsanHostCreateVmHealthTestResult",
2337     "vmodl.DynamicData",
2338     "vim.version.version9",
2339     [
2340         ("hostname", "string", "vim.version.version9", 0),
2341         ("state", "string", "vim.version.version9", 0),
2342         ("fault", "vmodl.MethodFault", "vim.version.version9", 0 | F_OPTIONAL),
2343     ],
2344 )
2345 CreateDataType(
2346     "vim.cluster.VsanDiskFormatConversionCheckResult",
2347     "VsanDiskFormatConversionCheckResult",
2348     "vim.VsanUpgradeSystem.PreflightCheckResult",
2349     "vim.version.version10",
2350     [
2351         ("isSupported", "boolean", "vim.version.version10", 0),
2352         ("targetVersion", "int", "vim.version.version10", 0 | F_OPTIONAL),
2353     ],
2354 )
2355 CreateDataType(
2356     "vim.cluster.VsanClusterHealthSystemObjectsRepairResult",
2357     "VsanClusterHealthSystemObjectsRepairResult",
2358     "vmodl.DynamicData",
2359     "vim.version.version9",
2360     [
2361         ("inRepairingQueueObjects", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2362         (
2363             "failedRepairObjects",
2364             "vim.host.VsanFailedRepairObjectResult[]",
2365             "vim.version.version9",
2366             0 | F_OPTIONAL,
2367         ),
2368         ("issueFound", "boolean", "vim.version.version9", 0),
2369     ],
2370 )
2371 CreateDataType(
2372     "vim.host.VsanHostHclInfo",
2373     "VsanHostHclInfo",
2374     "vmodl.DynamicData",
2375     "vim.version.version9",
2376     [
2377         ("hostname", "string", "vim.version.version9", 0),
2378         ("hclChecked", "boolean", "vim.version.version9", 0),
2379 <a name="25"></a>        ("releaseName"</b></font>, "string", "vim.version.version9", 0 | F_OPTIONAL),
2380         ("error", "vmodl.MethodFault", "vim.version.version9", 0 | F_OPTIONAL),
2381         (
2382             <font color="#5eac10"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"controllers",
2383             "vim.host.VsanHclControllerInfo[]",
2384             "vim.version.version9",
2385             0 | F_OPTIONAL,
2386         ),
2387     ],
2388 )
2389 CreateDataType(
2390     "vim.cluster.VSANStretchedClusterCapability",
2391     "VimClusterVSANStretchedClusterCapability",
2392     "vmodl.DynamicData",
2393     "vim.version.version10",
2394     [
2395         ("hostMoId", "string", "vim.version.version10", 0),
2396         ("connStatus", "string", "vim.version.version10", 0 | F_OPTIONAL),
2397         ("isSupported", "boolean", "vim.version.version10", 0 | F_OPTIONAL),
2398         (
2399             "hostCapability",
2400             "vim.host.VSANStretchedClusterHostCapability",
2401             "vim.version.version10",
2402             0 | F_OPTIONAL,
2403         ),
2404     ],
2405 )
2406 CreateDataType(
2407     "vim.cluster.VsanDiskMappingsConfigSpec",
2408     "VimClusterVsanDiskMappingsConfigSpec",
2409     "vmodl.DynamicData",
2410     "vim.version.version10",
2411     [
2412         (
2413             "hostDiskMappings",
2414             "vim.cluster.VsanHostDiskMapping[]",
2415             "vim.version.version10",
2416             0,
2417         )
2418     ],
2419 )
2420 CreateDataType(
2421     "vim.host.VsanHostVmdkLoadTestResult",
2422     "VsanHostVmdkLoadTestResult",
2423     "vmodl.DynamicData",
2424     "vim.version.version9",
2425     [
2426         ("hostname"</b></font>, "string", "vim.version.version9", 0),
2427         ("issueFound", "boolean", "vim.version.version9", 0),
2428         ("faultMessage", "string", "vim.version.version9", 0 | F_OPTIONAL),
2429         (
2430             "vmdkResults",
2431             "vim.host.VsanVmdkLoadTestResult[]",
2432             "vim.version.version9",
2433             0 | F_OPTIONAL,
2434         ),
2435     ],
2436 )
2437 CreateDataType(
2438     "vim.vsan.ReconfigSpec",
2439     "VimVsanReconfigSpec",
2440     "vmodl.DynamicData",
2441     "vim.version.version10",
2442     [
2443         (
2444             "vsanClusterConfig",
2445             "vim.vsan.cluster.ConfigInfo",
2446             "vim.version.version10",
2447             0 | F_OPTIONAL,
2448         ),
2449         (
2450             "dataEfficiencyConfig",
2451             "vim.vsan.DataEfficiencyConfig",
2452             "vim.version.version10",
2453             0 | F_OPTIONAL,
2454         ),
2455         (
2456             "diskMappingSpec",
2457             "vim.cluster.VsanDiskMappingsConfigSpec",
2458             "vim.version.version10",
2459             0 | F_OPTIONAL,
2460         ),
2461         (
2462             "faultDomainsSpec",
2463             "vim.cluster.VsanFaultDomainsConfigSpec",
2464             "vim.version.version10",
2465             0 | F_OPTIONAL,
2466         ),
2467         ("modify", "boolean", "vim.version.version10", 0),
2468         ("allowReducedRedundancy", "boolean", "vim.version.version10", 0 | F_OPTIONAL),
2469     ],
2470 )
2471 CreateDataType(
2472     "vim.host.VsanNetworkPeerHealthResult",
2473     "VsanNetworkPeerHealthResult",
2474     "vmodl.DynamicData",
2475     "vim.version.version9",
2476     [
2477         ("peer", "string", "vim.version.version9", 0 | F_OPTIONAL),
2478         ("peerHostname", "string", "vim.version.version9", 0 | F_OPTIONAL),
2479         ("peerVmknicName", "string", "vim.version.version9", 0 | F_OPTIONAL),
2480         ("smallPingTestSuccessPct", "int", "vim.version.version9", 0 | F_OPTIONAL),
2481 <a name="9"></a>        ("largePingTestSuccessPct", "int", "vim.version.version9", 0 | F_OPTIONAL),
2482         ("maxLatencyUs", "long", "vim.version.version9", 0 | F_OPTIONAL),
2483         ("onSameIpSubnet", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2484         (<font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"sourceVmknicName", "string", "vim.version.version9", 0 | F_OPTIONAL),
2485     ],
2486 )
2487 CreateDataType(
2488     "vim.cluster.VsanWitnessSpec",
2489     "VimClusterVsanWitnessSpec",
2490     "vmodl.DynamicData",
2491     "vim.version.version10",
2492     [
2493         ("host", "vim.HostSystem", "vim.version.version10", 0),
2494         ("preferredFaultDomainName", "string", "vim.version.version10", 0),
2495         (
2496             "diskMapping",
2497             "vim.vsan.host.DiskMapping",
2498             "vim.version.version10",
2499             0 | F_OPTIONAL,
2500         ),
2501     ],
2502 )
2503 CreateDataType(
2504     "vim.vsan.host.DiskMappingCreationSpec",
2505     "VimVsanHostDiskMappingCreationSpec",
2506     "vmodl.DynamicData",
2507     "vim.version.version10",
2508     [
2509         ("host", "vim.HostSystem", "vim.version.version10", 0),
2510         ("cacheDisks", "vim.host.ScsiDisk[]", "vim.version.version10", 0 | F_OPTIONAL),
2511         ("capacityDisks", "vim.host.ScsiDisk[]", "vim.version.version10", 0),
2512         (
2513             "creationType",
2514             "vim.vsan.host.DiskMappingCreationType",
2515             "vim.version.version10",
2516             0,
2517         ),
2518     ],
2519 )
2520 CreateDataType(
2521     "vim.host.VsanLimitHealthResult",
2522     "VsanLimitHealthResult",
2523     "vmodl.DynamicData",
2524     "vim.version.version9",
2525     [
2526         ("hostname", "string", "vim.version.version9", 0 | F_OPTIONAL),
2527         ("issueFound", "boolean", "vim.version.version9", 0),
2528         ("maxComponents", "int", "vim.version.version9", 0),
2529         ("freeComponents", "int", "vim.version.version9", 0),
2530         ("componentLimitHealth", "string", "vim.version.version9", 0),
2531         ("lowestFreeDiskSpacePct", "int", "vim.version.version9", 0),
2532 <a name="7"></a>        ("usedDiskSpaceB"</b></font>, "long", "vim.version.version9", 0),
2533         ("totalDiskSpaceB", "long", "vim.version.version9", 0),
2534         ("diskFreeSpaceHealth", "string", "vim.version.version9", 0),
2535         (<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"reservedRcSizeB", "long", "vim.version.version9", 0),
2536         ("totalRcSizeB", "long", "vim.version.version9", 0),
2537         ("rcFreeReservationHealth", "string", "vim.version.version9", 0),
2538     ],
2539 )
2540 CreateDataType(
2541     "vim.cluster.VSANPreferredFaultDomainInfo",
2542     "VimClusterVSANPreferredFaultDomainInfo",
2543     "vmodl.DynamicData",
2544     "vim.version.version10",
2545     [
2546         ("preferredFaultDomainName", "string", "vim.version.version10", 0),
2547         ("preferredFaultDomainId", "string", "vim.version.version10", 0),
2548     ],
2549 )
2550 CreateDataType(
2551     "vim.host.VsanObjectOverallHealth",
2552     "VsanObjectOverallHealth",
2553     "vmodl.DynamicData",
2554     "vim.version.version9",
2555     [
2556         (
2557             "objectHealthDetail",
2558             "vim.host.VsanObjectHealth[]",
2559             "vim.version.version9",
2560             0 | F_OPTIONAL,
2561         ),
2562         ("objectVersionCompliance", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2563     ],
2564 )
2565 CreateDataType(
2566     "vim.cluster.VsanVsanClusterPcapGroup",
2567     "VsanVsanClusterPcapGroup",
2568     "vmodl.DynamicData",
2569     "vim.version.version9",
2570     [
2571         ("master", "string", "vim.version.version9", 0),
2572         ("members", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2573     ],
2574 )
2575 CreateDataType(
2576     "vim.cluster.VsanClusterHealthResultColumnInfo",
2577     "VsanClusterHealthResultColumnInfo",
2578     "vmodl.DynamicData",
2579     "vim.version.version9",
2580     [
2581         ("label", "string", "vim.version.version9", 0),
2582         ("type", "string", "vim.version.version9", 0),
2583     ],
2584 )
2585 CreateDataType(
2586     "vim.cluster.VsanClusterNetworkHealthResult",
2587     "VsanClusterNetworkHealthResult",
2588     "vmodl.DynamicData",
2589     "vim.version.version9",
2590     [
2591         (
2592             "hostResults",
2593             "vim.host.VsanNetworkHealthResult[]",
2594             "vim.version.version9",
2595             0 | F_OPTIONAL,
2596         ),
2597         ("issueFound"</b></font>, "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2598         ("vsanVmknicPresent", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2599         ("matchingMulticastConfig", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2600         ("matchingIpSubnets", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2601         ("pingTestSuccess", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2602         ("largePingTestSuccess", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2603         ("potentialMulticastIssue", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2604         ("otherHostsInVsanCluster", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2605         (
2606             "partitions",
2607             "vim.cluster.VsanClusterNetworkPartitionInfo[]",
2608             "vim.version.version9",
2609             0 | F_OPTIONAL,
2610         ),
2611         ("hostsWithVsanDisabled", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2612         ("hostsDisconnected", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2613         ("hostsCommFailure", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2614         (
2615             "hostsInEsxMaintenanceMode",
2616             "string[]",
2617             "vim.version.version9",
2618             0 | F_OPTIONAL,
2619         ),
2620         (
2621             "hostsInVsanMaintenanceMode",
2622             "string[]",
2623             "vim.version.version9",
2624             0 | F_OPTIONAL,
2625         ),
2626         (
2627             "infoAboutUnexpectedHosts",
2628             "vim.host.VsanQueryResultHostInfo[]",
2629             "vim.version.version9",
2630             0 | F_OPTIONAL,
2631         ),
2632     ],
2633 )
2634 CreateDataType(
2635     "vim.cluster.VsanPerfNodeInformation",
2636     "VsanPerfNodeInformation",
2637     "vmodl.DynamicData",
2638     "vim.version.version9",
2639     [
2640         ("version", "string", "vim.version.version9", 0),
2641         ("hostname", "string", "vim.version.version9", 0 | F_OPTIONAL),
2642         ("error", "vmodl.MethodFault", "vim.version.version9", 0 | F_OPTIONAL),
2643         ("isCmmdsMaster", "boolean", "vim.version.version9", 0),
2644         ("isStatsMaster", "boolean", "vim.version.version9", 0),
2645         ("vsanMasterUuid", "string", "vim.version.version9", 0 | F_OPTIONAL),
2646         ("vsanNodeUuid", "string", "vim.version.version9", 0 | F_OPTIONAL),
2647         (
2648             "masterInfo",
2649             "vim.cluster.VsanPerfMasterInformation",
2650             "vim.version.version9",
2651             0 | F_OPTIONAL,
2652         ),
2653     ],
2654 )
2655 CreateDataType(
2656     "vim.cluster.VsanPerfEntityMetricCSV",
2657     "VsanPerfEntityMetricCSV",
2658     "vmodl.DynamicData",
2659 <a name="11"></a>    "vim.version.version9",
2660     [
2661         ("entityRefId", "string", "vim.version.version9", 0),
2662         (<font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"sampleInfo", "string", "vim.version.version9", 0 | F_OPTIONAL),
2663         (
2664             "value",
2665             "vim.cluster.VsanPerfMetricSeriesCSV[]",
2666             "vim.version.version9",
2667             0 | F_OPTIONAL,
2668         ),
2669     ],
2670 )
2671 CreateDataType(
2672     "vim.vsan.upgradesystem.DiskUnhealthIssue",
2673     "VsanDiskUnhealthIssue",
2674     "vim.VsanUpgradeSystem.PreflightCheckIssue",
2675     "vim.version.version10",
2676     [("uuids", "string[]", "vim.version.version10", 0)],
2677 )
2678 CreateDataType(
2679     "vim.cluster.VsanFaultDomainSpec",
2680     "VimClusterVsanFaultDomainSpec",
2681     "vmodl.DynamicData",
2682     "vim.version.version10",
2683     [
2684         ("hosts", "vim.HostSystem[]", "vim.version.version10", 0),
2685         ("name", "string", "vim.version.version10", 0),
2686     ],
2687 )
2688 CreateDataType(
2689     "vim.vsan.upgradesystem.ObjectInaccessibleIssue",
2690     "VsanObjectInaccessibleIssue",
2691     "vim.VsanUpgradeSystem.PreflightCheckIssue",
2692     "vim.version.version10",
2693     [("uuids", "string[]", "vim.version.version10", 0)],
2694 )
2695 CreateDataType(
2696     "vim.cluster.VsanDiskFormatConversionSpec",
2697     "VsanDiskFormatConversionSpec",
2698     "vmodl.DynamicData",
2699     "vim.version.version10",
2700     [
2701         (
2702             "dataEfficiencyConfig",
2703             "vim.vsan.DataEfficiencyConfig",
2704             "vim.version.version10",
2705             0 | F_OPTIONAL,
2706         )
2707     ],
2708 )
2709 CreateDataType(
2710     "vim.cluster.VsanClusterHealthAction",
2711     "VsanClusterHealthAction",
2712     "vmodl.DynamicData",
2713     "vim.version.version9",
2714     [
2715         (
2716             "actionId"</b></font>,
2717             "vim.cluster.VsanClusterHealthActionIdEnum",
2718             "vim.version.version9",
2719             0,
2720         ),
2721         ("actionLabel", "vmodl.LocalizableMessage", "vim.version.version9", 0),
2722         ("actionDescription", "vmodl.LocalizableMessage", "vim.version.version9", 0),
2723         ("enabled", "boolean", "vim.version.version9", 0),
2724     ],
2725 )
2726 CreateDataType(
2727     "vim.cluster.VsanClusterHealthSystemVersionResult",
2728     "VsanClusterHealthSystemVersionResult",
2729     "vmodl.DynamicData",
2730     "vim.version.version9",
2731     [
2732         (
2733             "hostResults",
2734             "vim.cluster.VsanHostHealthSystemVersionResult[]",
2735             "vim.version.version9",
2736 <a name="24"></a>            0 | F_OPTIONAL,
2737         ),
2738         ("vcVersion", "string", "vim.version.version9", 0 | F_OPTIONAL),
2739         (<font color="#79764d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"issueFound", "boolean", "vim.version.version9", 0),
2740     ],
2741 )
2742 CreateDataType(
2743     "vim.cluster.VsanClusterHealthResultRow",
2744     "VsanClusterHealthResultRow",
2745     "vmodl.DynamicData",
2746     "vim.version.version9",
2747     [
2748         ("values", "string[]", "vim.version.version9", 0),
2749         (
2750             "nestedRows",
2751             "vim.cluster.VsanClusterHealthResultRow[]",
2752             "vim.version.version9",
2753             0 | F_OPTIONAL,
2754         ),
2755     ],
2756 )
2757 CreateDataType(
2758     "vim.cluster.VsanClusterHealthSystemStatusResult",
2759     "VsanClusterHealthSystemStatusResult",
2760     "vmodl.DynamicData",
2761     "vim.version.version9",
2762     [
2763         ("status", "string", "vim.version.version9", 0),
2764         ("goalState", "string", "vim.version.version9", 0),
2765         ("untrackedHosts", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2766         (
2767             "trackedHostsStatus",
2768             "vim.host.VsanHostHealthSystemStatusResult[]",
2769             "vim.version.version9",
2770             0 | F_OPTIONAL,
2771         ),
2772     ],
2773 )
2774 CreateDataType(
2775     "vim.cluster.VsanHostDiskMapping",
2776     "VimClusterVsanHostDiskMapping",
2777     "vmodl.DynamicData",
2778     "vim.version.version10",
2779     [
2780         (</b></font>"host", "vim.HostSystem", "vim.version.version10", 0),
2781         ("cacheDisks", "vim.host.ScsiDisk[]", "vim.version.version10", 0 | F_OPTIONAL),
2782         ("capacityDisks", "vim.host.ScsiDisk[]", "vim.version.version10", 0),
2783         ("type", "vim.cluster.VsanDiskGroupCreationType", "vim.version.version10", 0),
2784     ],
2785 )
2786 CreateDataType(
2787     "vim.cluster.VSANStretchedClusterFaultDomainConfig",
2788     "VimClusterVSANStretchedClusterFaultDomainConfig",
2789     "vmodl.DynamicData",
2790     "vim.version.version10",
2791     [
2792         ("firstFdName", "string", "vim.version.version10", 0),
2793         ("firstFdHosts", "vim.HostSystem[]", "vim.version.version10", 0),
2794         ("secondFdName", "string", "vim.version.version10", 0),
2795         ("secondFdHosts", "vim.HostSystem[]", "vim.version.version10", 0),
2796     ],
2797 )
2798 CreateDataType(
2799     "vim.host.VSANStretchedClusterHostInfo",
2800     "VimHostVSANStretchedClusterHostInfo",
2801     "vmodl.DynamicData",
2802     "vim.version.version10",
2803     [
2804         ("nodeInfo", "vim.host.VSANCmmdsNodeInfo", "vim.version.version10", 0),
2805         (
2806             "faultDomainInfo",
2807             "vim.host.VSANCmmdsFaultDomainInfo",
2808             "vim.version.version10",
2809 <a name="20"></a>            0 | F_OPTIONAL,
2810         ),
2811         (
2812             <font color="#4e9258"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"preferredFaultDomainInfo",
2813             "vim.host.VSANCmmdsPreferredFaultDomainInfo",
2814             "vim.version.version10",
2815             0 | F_OPTIONAL,
2816         ),
2817     ],
2818 )
2819 CreateDataType(
2820     "vim.vsan.upgradesystem.HigherObjectsPresentDuringDowngradeIssue",
2821     "VsanHigherObjectsPresentDuringDowngradeIssue",
2822     "vim.VsanUpgradeSystem.PreflightCheckIssue",
2823     "vim.version.version10",
2824     [("uuids", "string[]", "vim.version.version10", 0)],
2825 )
2826 CreateDataType(
2827     "vim.host.VSANCmmdsFaultDomainInfo",
2828     "VimHostVSANCmmdsFaultDomainInfo",
2829     "vmodl.DynamicData",
2830     "vim.version.version10",
2831     [
2832         ("faultDomainId", "string", "vim.version.version10", 0),
2833         ("faultDomainName", "string", "vim.version.version10", 0),
2834     ],
2835 )
2836 CreateDataType(
2837     "vim.fault.VsanNodeNotMaster",
2838     "VsanNodeNotMaster",
2839     "vim.fault.VimFault",
2840     "vim.version.version9",
2841     [
2842         ("vsanMasterUuid", "string", "vim.version.version9", 0 | F_OPTIONAL),
2843         (
2844             "cmmdsMasterButNotStatsMaster",
2845             "boolean",
2846             "vim.version.version9",
2847             0 | F_OPTIONAL,
2848         ),
2849     ],
2850 )
2851 CreateDataType(
2852     "vim.cluster.VsanHostHealthSystemVersionResult",
2853     "VsanHostHealthSystemVersionResult",
2854     "vmodl.DynamicData",
2855     "vim.version.version9",
2856     [
2857         (</b></font>"hostname", "string", "vim.version.version9", 0),
2858         ("version", "string", "vim.version.version9", 0 | F_OPTIONAL),
2859         ("error", "vmodl.MethodFault", "vim.version.version9", 0 | F_OPTIONAL),
2860     ],
2861 )
2862 CreateDataType(
2863     "vim.cluster.VsanClusterHealthConfigs",
2864     "VsanClusterHealthConfigs",
2865     "vmodl.DynamicData",
2866     "vim.version.version9",
2867     [
2868         ("enableVsanTelemetry", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2869         ("vsanTelemetryInterval", "int", "vim.version.version9", 0 | F_OPTIONAL),
2870         (
2871             "vsanTelemetryProxy",
2872             "vim.cluster.VsanClusterTelemetryProxyConfig",
2873             "vim.version.version9",
2874             0 | F_OPTIONAL,
2875         ),
2876         (
2877             "configs",
2878             "vim.cluster.VsanClusterHealthResultKeyValuePair[]",
2879             "vim.version.version9",
2880             0 | F_OPTIONAL,
2881         ),
2882     ],
2883 )
2884 CreateDataType(
2885     "vim.cluster.VsanClusterWhatifHostFailuresResult",
2886     "VsanClusterWhatifHostFailuresResult",
2887     "vmodl.DynamicData",
2888     "vim.version.version9",
2889     [
2890         ("numFailures", "long", "vim.version.version9", 0),
2891         ("totalUsedCapacityB", "long", "vim.version.version9", 0),
2892         ("totalCapacityB", "long", "vim.version.version9", 0),
2893         ("totalRcReservationB", "long", "vim.version.version9", 0),
2894         ("totalRcSizeB", "long", "vim.version.version9", 0),
2895         ("usedComponents", "long", "vim.version.version9", 0),
2896         ("totalComponents", "long", "vim.version.version9", 0),
2897         ("componentLimitHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
2898         ("diskFreeSpaceHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
2899         ("rcFreeReservationHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
2900     ],
2901 )
2902 CreateDataType(
2903     "vim.cluster.VsanObjectIdentityAndHealth",
2904     "VsanObjectIdentityAndHealth",
2905     "vmodl.DynamicData",
2906     "vim.version.version9",
2907     [
2908         (
2909             "identities",
2910             "vim.cluster.VsanObjectIdentity[]",
2911             "vim.version.version9",
2912             0 | F_OPTIONAL,
2913         ),
2914         (
2915             "health",
2916             "vim.host.VsanObjectOverallHealth",
2917             "vim.version.version9",
2918             0 | F_OPTIONAL,
2919         ),
2920         (
2921             "spaceSummary",
2922             "vim.cluster.VsanObjectSpaceSummary[]",
2923             "vim.version.version9",
2924             0 | F_OPTIONAL,
2925         ),
2926         ("rawData", "string", "vim.version.version9", 0 | F_OPTIONAL),
2927     ],
2928 )
2929 CreateDataType(
2930     "vim.host.VsanHclControllerInfo",
2931     "VsanHclControllerInfo",
2932     "vmodl.DynamicData",
2933     "vim.version.version9",
2934     [
2935         ("deviceName", "string", "vim.version.version9", 0),
2936         ("deviceDisplayName", "string", "vim.version.version9", 0 | F_OPTIONAL),
2937         ("driverName", "string", "vim.version.version9", 0 | F_OPTIONAL),
2938         ("driverVersion", "string", "vim.version.version9", 0 | F_OPTIONAL),
2939         ("vendorId", "long", "vim.version.version9", 0 | F_OPTIONAL),
2940         ("deviceId", "long", "vim.version.version9", 0 | F_OPTIONAL),
2941         ("subVendorId", "long", "vim.version.version9", 0 | F_OPTIONAL),
2942         ("subDeviceId", "long", "vim.version.version9", 0 | F_OPTIONAL),
2943         ("extraInfo", "vim.KeyValue[]", "vim.version.version9", 0 | F_OPTIONAL),
2944         ("deviceOnHcl", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2945         ("releaseSupported", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2946         ("releasesOnHcl", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2947         ("driverVersionsOnHcl", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2948         ("driverVersionSupported", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2949         ("fwVersionSupported", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2950         ("fwVersionOnHcl", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2951         ("cacheConfigSupported", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2952         ("cacheConfigOnHcl", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2953         ("raidConfigSupported", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2954         ("raidConfigOnHcl", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2955         ("fwVersion", "string", "vim.version.version9", 0 | F_OPTIONAL),
2956         ("raidConfig", "string", "vim.version.version9", 0 | F_OPTIONAL),
2957         ("cacheConfig", "string", "vim.version.version9", 0 | F_OPTIONAL),
2958         (
2959             "cimProviderInfo",
2960             "vim.host.VsanHostCimProviderInfo",
2961             "vim.version.version9",
2962             0 | F_OPTIONAL,
2963         ),
2964     ],
2965 )
2966 CreateDataType(
2967     "vim.cluster.VsanClusterHealthResultKeyValuePair",
2968     "VsanClusterHealthResultKeyValuePair",
2969     "vmodl.DynamicData",
2970     "vim.version.version9",
2971     [
2972         ("key", "string", "vim.version.version9", 0 | F_OPTIONAL),
2973         ("value", "string", "vim.version.version9", 0 | F_OPTIONAL),
2974     ],
2975 )
2976 CreateDataType(
2977     "vim.cluster.StorageOperationalStatus",
2978     "VsanStorageOperationalStatus",
2979     "vmodl.DynamicData",
2980     "vim.version.version9",
2981     [
2982         ("healthy", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2983         ("operationETA", "vmodl.DateTime", "vim.version.version9", 0 | F_OPTIONAL),
2984         ("operationProgress", "long", "vim.version.version9", 0 | F_OPTIONAL),
2985         ("transitional", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2986     ],
2987 )
2988 CreateDataType(
2989     "vim.cluster.VsanSpaceUsage",
2990     "VsanSpaceUsage",
2991     "vmodl.DynamicData",
2992 <a name="4"></a>    "vim.version.version9",
2993     [
2994         ("totalCapacityB", "long", "vim.version.version9", 0),
2995         (<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"freeCapacityB", "long", "vim.version.version9", 0 | F_OPTIONAL),
2996         (
2997             "spaceOverview",
2998             "vim.cluster.VsanObjectSpaceSummary",
2999             "vim.version.version9",
3000             0 | F_OPTIONAL,
3001         ),
3002         (
3003             "spaceDetail",
3004             "vim.cluster.VsanSpaceUsageDetailResult",
3005             "vim.version.version9",
3006             0 | F_OPTIONAL,
3007         ),
3008     ],
3009 )
3010 CreateDataType(
3011     "vim.cluster.VsanClusterHealthResultTable",
3012     "VsanClusterHealthResultTable",
3013     "vim.cluster.VsanClusterHealthResultBase",
3014     "vim.version.version9",
3015     [
3016         (
3017             "columns",
3018             "vim.cluster.VsanClusterHealthResultColumnInfo[]",
3019             "vim.version.version9",
3020             0 | F_OPTIONAL,
3021         ),
3022         (
3023             "rows",
3024             "vim.cluster.VsanClusterHealthResultRow[]",
3025             "vim.version.version9",
3026             0 | F_OPTIONAL,
3027         ),
3028     ],
3029 )
3030 CreateDataType(
3031     "vim.cluster.VsanClusterConfig",
3032     "VsanClusterConfig",
3033     "vmodl.DynamicData",
3034     "vim.version.version9",
3035     [
3036         ("config", "vim.vsan.cluster.ConfigInfo", "vim.version.version9", 0),
3037         ("name", "string", "vim.version.version9", 0),
3038         ("hosts", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
3039     ],
3040 )
3041 CreateDataType(
3042     "vim.vsan.host.VsanHostCapability",
3043     "VimVsanHostVsanHostCapability",
3044     "vmodl.DynamicData",
3045     "vim.version.version10",
3046     [
3047         ("host", "vim.HostSystem", "vim.version.version10", 0),
3048         ("isSupported", "boolean", "vim.version.version10", 0),
3049         ("isLicensed", "boolean", "vim.version.version10", 0),
3050     ],
3051 )
3052 CreateDataType(
3053     "vim.cluster.VsanPerfThreshold",
3054     "VsanPerfThreshold",
3055     "vmodl.DynamicData",
3056     "vim.version.version9",
3057     [
3058         (
3059             "direction",
3060             "vim.cluster.VsanPerfThresholdDirectionType",
3061             "vim.version.version9",
3062             0,
3063         ),
3064         ("yellow", "string", "vim.version.version9", 0 | F_OPTIONAL),
3065         ("red", "string", "vim.version.version9", 0 | F_OPTIONAL),
3066     ],
3067 )
3068 CreateDataType(
3069     "vim.host.VsanNetworkHealthResult",
3070     "VsanNetworkHealthResult",
3071     "vmodl.DynamicData",
3072     "vim.version.version9",
3073     [
3074         ("host", "vim.HostSystem", "vim.version.version9", 0 | F_OPTIONAL),
3075         ("hostname", "string", "vim.version.version9", 0 | F_OPTIONAL),
3076         ("vsanVmknicPresent"</b></font>, "boolean", "vim.version.version9", 0 | F_OPTIONAL),
3077         ("ipSubnets", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
3078         ("issueFound", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
3079         (
3080             "peerHealth",
3081             "vim.host.VsanNetworkPeerHealthResult[]",
3082             "vim.version.version9",
3083             0 | F_OPTIONAL,
3084         ),
3085         ("multicastConfig", "string", "vim.version.version9", 0 | F_OPTIONAL),
3086     ],
3087 )
3088 CreateDataType(
3089     "vim.vsan.ConfigInfoEx",
3090     "VsanConfigInfoEx",
3091     "vim.vsan.cluster.ConfigInfo",
3092     "vim.version.version10",
3093     [
3094         (
3095             "dataEfficiencyConfig",
3096             "vim.vsan.DataEfficiencyConfig",
3097             "vim.version.version10",
3098             0 | F_OPTIONAL,
3099         )
3100     ],
3101 )
3102 CreateDataType(
3103     "vim.host.VsanVmdkLoadTestResult",
3104     "VsanVmdkLoadTestResult",
3105     "vmodl.DynamicData",
3106     "vim.version.version9",
3107     [
3108         ("success", "boolean", "vim.version.version9", 0),
3109         ("faultMessage", "string", "vim.version.version9", 0 | F_OPTIONAL),
3110         ("spec", "vim.host.VsanVmdkLoadTestSpec", "vim.version.version9", 0),
3111         ("actualDurationSec", "int", "vim.version.version9", 0 | F_OPTIONAL),
3112         ("totalBytes", "long", "vim.version.version9", 0 | F_OPTIONAL),
3113         ("iops", "long", "vim.version.version9", 0 | F_OPTIONAL),
3114         ("tputBps", "long", "vim.version.version9", 0 | F_OPTIONAL),
3115         ("avgLatencyUs", "long", "vim.version.version9", 0 | F_OPTIONAL),
3116         ("maxLatencyUs", "long", "vim.version.version9", 0 | F_OPTIONAL),
3117         ("numIoAboveLatencyThreshold", "long", "vim.version.version9", 0 | F_OPTIONAL),
3118     ],
3119 )
3120 CreateDataType(
3121     "vim.cluster.VsanClusterVMsHealthOverallResult",
3122     "VsanClusterVMsHealthOverAllResult",
3123 <a name="6"></a>    "vmodl.DynamicData",
3124     "vim.version.version9",
3125     [
3126         <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(
3127             "healthStateList",
3128             "vim.cluster.VsanClusterVMsHealthSummaryResult[]",
3129             "vim.version.version9",
3130             0 | F_OPTIONAL,
3131         ),
3132         ("overallHealthState", "string", "vim.version.version9", 0 | F_OPTIONAL),
3133     ],
3134 )
3135 CreateDataType(
3136     "vim.host.VsanHostHealthSystemStatusResult",
3137     "VsanHostHealthSystemStatusResult",
3138     "vmodl.DynamicData",
3139     "vim.version.version9",
3140     [
3141         ("hostname", "string", "vim.version.version9", 0),
3142         ("status", "string", "vim.version.version9", 0),
3143         ("issues", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
3144     ],
3145 )
3146 CreateDataType(
3147     "vim.cluster.VsanClusterAdvCfgSyncResult",
3148     "VsanClusterAdvCfgSyncResult",
3149     "vmodl.DynamicData",
3150     "vim.version.version9",
3151     [
3152         ("inSync", "boolean", "vim.version.version9", 0),
3153         ("name", "string", "vim.version.version9", 0),
3154         (
3155             "hostValues",
3156             "vim.cluster.VsanClusterAdvCfgSyncHostResult[]",
3157             "vim.version.version9",
3158             0 | F_OPTIONAL,
3159         ),
3160     ],
3161 )
3162 CreateDataType(
3163     "vim.host.VsanQueryResultHostInfo",
3164     "VsanQueryResultHostInfo",
3165     "vmodl.DynamicData",
3166     "vim.version.version9",
3167     [
3168         ("uuid", "string", "vim.version.version9", 0 | F_OPTIONAL),
3169         ("hostnameInCmmds", "string", "vim.version.version9", 0 | F_OPTIONAL),
3170         ("vsanIpv4Addresses", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
3171     ],
3172 )
3173 CreateDataType(
3174     "vim.vsan.host.DiskMapInfoEx",
3175     "VimVsanHostDiskMapInfoEx",
3176     "vmodl.DynamicData",
3177     "vim.version.version10",
3178     [
3179         ("mapping", "vim.vsan.host.DiskMapping", "vim.version.version10", 0),
3180         ("isMounted", "boolean", "vim.version.version10", 0),
3181         ("isAllFlash"</b></font>, "boolean", "vim.version.version10", 0),
3182         ("isDataEfficiency", "boolean", "vim.version.version10", 0 | F_OPTIONAL),
3183     ],
3184 )
3185 CreateDataType(
3186     "vim.host.VsanVmdkLoadTestSpec",
3187     "VsanVmdkLoadTestSpec",
3188     "vmodl.DynamicData",
3189     "vim.version.version9",
3190     [
3191         (
3192             "vmdkCreateSpec",
3193             "vim.VirtualDiskManager.FileBackedVirtualDiskSpec",
3194             "vim.version.version9",
3195             0 | F_OPTIONAL,
3196         ),
3197         (
3198             "vmdkIOSpec",
3199             "vim.host.VsanVmdkIOLoadSpec",
3200             "vim.version.version9",
3201             0 | F_OPTIONAL,
3202         ),
3203         (
3204             "vmdkIOSpecSequence",
3205             "vim.host.VsanVmdkIOLoadSpec[]",
3206             "vim.version.version9",
3207             0 | F_OPTIONAL,
3208         ),
3209         ("stepDurationSec", "long", "vim.version.version9", 0 | F_OPTIONAL),
3210     ],
3211 )
3212 CreateDataType(
3213     "vim.cluster.VsanClusterHealthSummary",
3214     "VsanClusterHealthSummary",
3215     "vmodl.DynamicData",
3216     "vim.version.version9",
3217     [
3218         (
3219             "clusterStatus",
3220             "vim.cluster.VsanClusterHealthSystemStatusResult",
3221             "vim.version.version9",
3222             0 | F_OPTIONAL,
3223         ),
3224         ("timestamp", "vmodl.DateTime", "vim.version.version9", 0 | F_OPTIONAL),
3225         (
3226             "clusterVersions",
3227             "vim.cluster.VsanClusterHealthSystemVersionResult",
3228             "vim.version.version9",
3229             0 | F_OPTIONAL,
3230         ),
3231         (
3232             "objectHealth",
3233             "vim.host.VsanObjectOverallHealth",
3234             "vim.version.version9",
3235             0 | F_OPTIONAL,
3236         ),
3237         (
3238             "vmHealth",
3239             "vim.cluster.VsanClusterVMsHealthOverallResult",
3240             "vim.version.version9",
3241             0 | F_OPTIONAL,
3242         ),
3243         (
3244             "networkHealth",
3245             "vim.cluster.VsanClusterNetworkHealthResult",
3246             "vim.version.version9",
3247             0 | F_OPTIONAL,
3248         ),
3249         (
3250             "limitHealth",
3251             "vim.cluster.VsanClusterLimitHealthResult",
3252             "vim.version.version9",
3253             0 | F_OPTIONAL,
3254         ),
3255         (
3256             "advCfgSync",
3257             "vim.cluster.VsanClusterAdvCfgSyncResult[]",
3258             "vim.version.version9",
3259             0 | F_OPTIONAL,
3260         ),
3261         (
3262             "createVmHealth",
3263             "vim.cluster.VsanHostCreateVmHealthTestResult[]",
3264             "vim.version.version9",
3265             0 | F_OPTIONAL,
3266         ),
3267         (
3268             "physicalDisksHealth",
3269             "vim.host.VsanPhysicalDiskHealthSummary[]",
3270             "vim.version.version9",
3271             0 | F_OPTIONAL,
3272         ),
3273         (
3274             "hclInfo",
3275             "vim.cluster.VsanClusterHclInfo",
3276             "vim.version.version9",
3277             0 | F_OPTIONAL,
3278         ),
3279         (
3280             "groups",
3281             "vim.cluster.VsanClusterHealthGroup[]",
3282             "vim.version.version9",
3283             0 | F_OPTIONAL,
3284         ),
3285         ("overallHealth", "string", "vim.version.version9", 0),
3286         ("overallHealthDescription", "string", "vim.version.version9", 0),
3287         (
3288             "clomdLiveness",
3289             "vim.cluster.VsanClusterClomdLivenessResult",
3290             "vim.version.version9",
3291             0 | F_OPTIONAL,
3292         ),
3293         (
3294             "diskBalance",
3295             "vim.cluster.VsanClusterBalanceSummary",
3296             "vim.version.version9",
3297             0 | F_OPTIONAL,
3298         ),
3299     ],
3300 )
3301 CreateDataType(
3302     "vim.cluster.VsanPerfEntityType",
3303     "VsanPerfEntityType",
3304     "vmodl.DynamicData",
3305     "vim.version.version9",
3306     [
3307         ("name", "string", "vim.version.version9", 0),
3308         ("id", "string", "vim.version.version9", 0),
3309         ("graphs", "vim.cluster.VsanPerfGraph[]", "vim.version.version9", 0),
3310         ("description", "string", "vim.version.version9", 0 | F_OPTIONAL),
3311     ],
3312 )
3313 CreateDataType(
3314     "vim.host.VsanNetworkLoadTestResult",
3315     "VsanNetworkLoadTestResult",
3316     "vmodl.DynamicData",
3317     "vim.version.version9",
3318     [
3319         ("hostname", "string", "vim.version.version9", 0),
3320         ("status", "string", "vim.version.version9", 0 | F_OPTIONAL),
3321         ("client", "boolean", "vim.version.version9", 0),
3322         ("bandwidthBps", "long", "vim.version.version9", 0),
3323         ("totalBytes", "long", "vim.version.version9", 0),
3324         ("lostDatagrams", "long", "vim.version.version9", 0 | F_OPTIONAL),
3325         ("lossPct", "long", "vim.version.version9", 0 | F_OPTIONAL),
3326         ("sentDatagrams", "long", "vim.version.version9", 0 | F_OPTIONAL),
3327         ("jitterMs", "float", "vim.version.version9", 0 | F_OPTIONAL),
3328     ],
3329 )
3330 CreateDataType(
3331     "vim.host.VsanPhysicalDiskHealthSummary",
3332     "VsanPhysicalDiskHealthSummary",
3333     "vmodl.DynamicData",
3334     "vim.version.version9",
3335     [
3336         ("overallHealth", "string", "vim.version.version9", 0),
3337         (
3338             "heapsWithIssues",
3339             "vim.host.VsanResourceHealth[]",
3340             "vim.version.version9",
3341             0 | F_OPTIONAL,
3342         ),
3343         (
3344             "slabsWithIssues",
3345             "vim.host.VsanResourceHealth[]",
3346             "vim.version.version9",
3347             0 | F_OPTIONAL,
3348         ),
3349         (
3350             "disks",
3351             "vim.host.VsanPhysicalDiskHealth[]",
3352             "vim.version.version9",
3353             0 | F_OPTIONAL,
3354         ),
3355         (
3356             "componentsWithIssues",
3357             "vim.host.VsanResourceHealth[]",
3358             "vim.version.version9",
3359             0 | F_OPTIONAL,
3360         ),
3361         ("hostname", "string", "vim.version.version9", 0 | F_OPTIONAL),
3362         ("hostDedupScope", "int", "vim.version.version9", 0 | F_OPTIONAL),
3363         ("error", "vmodl.MethodFault", "vim.version.version9", 0 | F_OPTIONAL),
3364     ],
3365 )
3366 CreateDataType(
3367     "vim.vsan.host.VsanDiskManagementSystemCapability",
3368 <a name="19"></a>    "VimVsanHostVsanDiskManagementSystemCapability",
3369     "vmodl.DynamicData",
3370     "vim.version.version10",
3371     [(<font color="#f62817"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"version", "string", "vim.version.version10", 0)],
3372 )
3373 CreateDataType(
3374     "vim.host.VsanHostCimProviderInfo",
3375     "VsanHostCimProviderInfo",
3376     "vmodl.DynamicData",
3377     "vim.version.version9",
3378     [
3379         ("cimProviderSupported", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
3380         ("installedCIMProvider", "string", "vim.version.version9", 0 | F_OPTIONAL),
3381         ("cimProviderOnHcl", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
3382     ],
3383 )
3384 CreateDataType(
3385     "vim.cluster.VsanObjectInformation",
3386     "VsanObjectInformation",
3387     "vmodl.DynamicData",
3388     "vim.version.version9",
3389     [
3390         ("directoryName", "string", "vim.version.version9", 0 | F_OPTIONAL),
3391         ("vsanObjectUuid", "string", "vim.version.version9", 0 | F_OPTIONAL),
3392         ("vsanHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
3393         ("policyAttributes", "vim.KeyValue[]", "vim.version.version9", 0 | F_OPTIONAL),
3394         ("spbmProfileUuid", "string", "vim.version.version9", 0 | F_OPTIONAL),
3395         ("spbmProfileGenerationId"</b></font>, "string", "vim.version.version9", 0 | F_OPTIONAL),
3396         (
3397             "spbmComplianceResult",
3398             "vim.cluster.StorageComplianceResult",
3399             "vim.version.version9",
3400             0 | F_OPTIONAL,
3401         ),
3402     ],
3403 )
3404 CreateDataType(
3405     "vim.cluster.VsanObjectIdentity",
3406     "VsanObjectIdentity",
3407 <a name="23"></a>    "vmodl.DynamicData",
3408     "vim.version.version9",
3409     [
3410         <font color="#f660ab"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("uuid", "string", "vim.version.version9", 0),
3411         ("type", "string", "vim.version.version9", 0),
3412         ("vmInstanceUuid", "string", "vim.version.version9", 0 | F_OPTIONAL),
3413         ("vmNsObjectUuid", "string", "vim.version.version9", 0 | F_OPTIONAL),
3414         ("vm", "vim.VirtualMachine", "vim.version.version9", 0 | F_OPTIONAL),
3415         ("description", "string", "vim.version.version9", 0 | F_OPTIONAL),
3416     ],
3417 )
3418 CreateDataType(
3419     "vim.host.VsanResourceHealth",
3420     "VsanResourceHealth",
3421     "vmodl.DynamicData",
3422     "vim.version.version9",
3423     [
3424         ("resource", "string", "vim.version.version9", 0),
3425         ("health", "string", "vim.version.version9", 0),
3426         ("description", "string", "vim.version.version9", 0 | F_OPTIONAL),
3427     ],
3428 )
3429 CreateDataType(</b></font>
3430     "vim.cluster.VsanCapability",
3431     "VsanCapability",
3432 <a name="31"></a>    "vmodl.DynamicData",
3433     "vim.version.version10",
3434     [
3435         <font color="#3ea99f"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("target", "vmodl.ManagedObject", "vim.version.version10", 0 | F_OPTIONAL),
3436         ("capabilities", "string[]", "vim.version.version10", 0 | F_OPTIONAL),
3437     ],
3438 )
3439 CreateDataType(
3440     "vim.cluster.VsanHostClomdLivenessResult",
3441     "VsanHostClomdLivenessResult",
3442     "vmodl.DynamicData",
3443     "vim.version.version9",
3444     [
3445         ("hostname", "string", "vim.version.version9", 0),
3446         ("clomdStat", "string", "vim.version.version9", 0),
3447         ("error", "vmodl.MethodFault", "vim.version.version9", 0 | F_OPTIONAL),
3448     ],
3449 )
3450 CreateDataType(
3451     "vim.cluster.VsanObjectQuerySpec",
3452     "VsanObjectQuerySpec",
3453     "vmodl.DynamicData",
3454     "vim.version.version9",
3455     [
3456         ("uuid", "string", "vim.version.version9", 0),
3457         ("spbmProfileGenerationId"</b></font>, "string", "vim.version.version9", 0 | F_OPTIONAL),
3458     ],
3459 )
3460 CreateDataType(
3461     "vim.cluster.VsanClusterLimitHealthResult",
3462     "VsanClusterLimitHealthResult",
3463     "vmodl.DynamicData",
3464     "vim.version.version9",
3465     [
3466         ("issueFound", "boolean", "vim.version.version9", 0),
3467         ("componentLimitHealth", "string", "vim.version.version9", 0),
3468         ("diskFreeSpaceHealth", "string", "vim.version.version9", 0),
3469         ("rcFreeReservationHealth", "string", "vim.version.version9", 0),
3470         (
3471             "hostResults",
3472             "vim.host.VsanLimitHealthResult[]",
3473             "vim.version.version9",
3474             0 | F_OPTIONAL,
3475         ),
3476         (
3477             "whatifHostFailures",
3478             "vim.cluster.VsanClusterWhatifHostFailuresResult[]",
3479             "vim.version.version9",
3480             0 | F_OPTIONAL,
3481         ),
3482         ("hostsCommFailure", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
3483     ],
3484 )
3485 CreateDataType(
3486     "vim.cluster.VsanStorageWorkloadType",
3487     "VsanStorageWorkloadType",
3488     "vmodl.DynamicData",
3489     "vim.version.version9",
3490     [
3491 <a name="16"></a>        ("specs", "vim.host.VsanVmdkLoadTestSpec[]", "vim.version.version9", 0),
3492         ("typeId", "string", "vim.version.version9", 0),
3493         ("name", "string", "vim.version.version9", 0),
3494         (<font color="#2981b2"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"description", "string", "vim.version.version9", 0),
3495     ],
3496 )
3497 CreateDataType(
3498     "vim.cluster.VsanClusterAdvCfgSyncHostResult",
3499     "VsanClusterAdvCfgSyncHostResult",
3500     "vmodl.DynamicData",
3501     "vim.version.version9",
3502     [
3503         ("hostname", "string", "vim.version.version9", 0),
3504         ("value", "string", "vim.version.version9", 0),
3505     ],
3506 )
3507 CreateDataType(
3508     "vim.vsan.upgradesystem.ObjectPolicyIssue",
3509     "VsanObjectPolicyIssue",
3510     "vim.VsanUpgradeSystem.PreflightCheckIssue",
3511     "vim.version.version10",
3512     [("uuids", "string[]", "vim.version.version10", 0)],
3513 )
3514 CreateDataType(
3515     "vim.cluster.VsanPerfTopEntities",
3516     "VsanPerfTopEntities",
3517     "vmodl.DynamicData",
3518     "vim.version.version9",
3519     [
3520         ("metricId", "vim.cluster.VsanPerfMetricId", "vim.version.version9", 0),
3521         ("entities", "vim.cluster.VsanPerfTopEntity[]", "vim.version.version9", 0),
3522     ],
3523 )
3524 CreateDataType(
3525     "vim.host.VsanProactiveRebalanceInfoEx",
3526     "VsanProactiveRebalanceInfoEx",
3527     "vmodl.DynamicData",
3528     "vim.version.version9",
3529     [
3530         ("running", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
3531         ("startTs"</b></font>, "vmodl.DateTime", "vim.version.version9", 0 | F_OPTIONAL),
3532         ("stopTs", "vmodl.DateTime", "vim.version.version9", 0 | F_OPTIONAL),
3533         ("varianceThreshold", "float", "vim.version.version9", 0 | F_OPTIONAL),
3534         ("timeThreshold", "int", "vim.version.version9", 0 | F_OPTIONAL),
3535         ("rateThreshold", "int", "vim.version.version9", 0 | F_OPTIONAL),
3536         ("hostname", "string", "vim.version.version9", 0 | F_OPTIONAL),
3537         ("error", "vmodl.MethodFault", "vim.version.version9", 0 | F_OPTIONAL),
3538     ],
3539 )
3540 CreateDataType(
3541     "vim.cluster.VsanClusterProactiveTestResult",
3542     "VsanClusterProactiveTestResult",
3543 <a name="15"></a>    "vmodl.DynamicData",
3544     "vim.version.version9",
3545     [
3546         <font color="#f52887"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("overallStatus", "string", "vim.version.version9", 0),
3547         ("overallStatusDescription", "string", "vim.version.version9", 0),
3548         ("timestamp", "vmodl.DateTime", "vim.version.version9", 0),
3549         (
3550             "healthTest",
3551             "vim.cluster.VsanClusterHealthTest",
3552             "vim.version.version9",
3553             0 | F_OPTIONAL,
3554         ),
3555     ],
3556 )
3557 CreateDataType(
3558     "vim.host.VSANCmmdsPreferredFaultDomainInfo",
3559     "VimHostVSANCmmdsPreferredFaultDomainInfo",
3560     "vmodl.DynamicData",
3561     "vim.version.version10",
3562     [
3563         ("preferredFaultDomainId", "string", "vim.version.version10", 0),
3564         ("preferredFaultDomainName", "string", "vim.version.version10", 0),
3565     ],
3566 )
3567 CreateDataType(
3568     "vim.cluster.VsanFaultDomainsConfigSpec",
3569     "VimClusterVsanFaultDomainsConfigSpec",
3570     "vmodl.DynamicData",
3571     "vim.version.version10",
3572     [
3573         (
3574             "faultDomains",
3575             "vim.cluster.VsanFaultDomainSpec[]",
3576             "vim.version.version10",
3577             0,
3578         ),
3579         (
3580             "witness",
3581             "vim.cluster.VsanWitnessSpec",
3582             "vim.version.version10",
3583             0 | F_OPTIONAL,
3584         ),
3585     ],
3586 )
3587 CreateDataType(
3588     "vim.cluster.VsanClusterHostVmknicMapping",
3589     "VsanClusterHostVmknicMapping",
3590     "vmodl.DynamicData",
3591     "vim.version.version9",
3592     [
3593         ("host"</b></font>, "string", "vim.version.version9", 0),
3594         ("vmknic", "string", "vim.version.version9", 0),
3595     ],
3596 )
3597 CreateDataType(
3598     "vim.cluster.VsanClusterVmdkLoadTestResult",
3599     "VsanClusterVmdkLoadTestResult",
3600     "vmodl.DynamicData",
3601     "vim.version.version9",
3602     [
3603         ("task", "vim.Task", "vim.version.version9", 0 | F_OPTIONAL),
3604         (
3605             "clusterResult",
3606             "vim.cluster.VsanClusterProactiveTestResult",
3607             "vim.version.version9",
3608 <a name="22"></a>            0 | F_OPTIONAL,
3609         ),
3610         (
3611             <font color="#4cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"hostResults",
3612             "vim.host.VsanHostVmdkLoadTestResult[]",
3613             "vim.version.version9",
3614             0 | F_OPTIONAL,
3615         ),
3616     ],
3617 )
3618 CreateDataType(
3619     "vim.cluster.VsanClusterVMsHealthSummaryResult",
3620     "VsanClusterVMsHealthSummaryResult",
3621     "vmodl.DynamicData",
3622     "vim.version.version9",
3623     [
3624         ("numVMs", "int", "vim.version.version9", 0),
3625         ("state", "string", "vim.version.version9", 0 | F_OPTIONAL),
3626         ("health", "string", "vim.version.version9", 0),
3627         ("vmInstanceUuids", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
3628     ],
3629 )
3630 CreateDataType(
3631     "vim.host.VSANStretchedClusterHostCapability",
3632     "VimHostVSANStretchedClusterHostCapability",
3633     "vmodl.DynamicData",
3634     "vim.version.version10",
3635     [("featureVersion", "string", "vim.version.version10", 0)],
3636 )
3637 CreateDataType(
3638     "vim.host.VsanFailedRepairObjectResult",
3639     "VsanFailedRepairObjectResult",
3640     "vmodl.DynamicData",
3641     "vim.version.version9",
3642     [
3643         ("uuid"</b></font>, "string", "vim.version.version9", 0),
3644         ("errMessage", "string", "vim.version.version9", 0 | F_OPTIONAL),
3645     ],
3646 )
3647 CreateDataType(
3648     "vim.cluster.VsanClusterCreateVmHealthTestResult",
3649     "VsanClusterCreateVmHealthTestResult",
3650 <a name="30"></a>    "vmodl.DynamicData",
3651     "vim.version.version9",
3652     [
3653         <font color="#ae694a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(
3654             "clusterResult",
3655             "vim.cluster.VsanClusterProactiveTestResult",
3656             "vim.version.version9",
3657             0,
3658         ),
3659         (
3660             "hostResults",
3661             "vim.cluster.VsanHostCreateVmHealthTestResult[]",
3662             "vim.version.version9",
3663             0 | F_OPTIONAL,
3664         ),
3665     ],
3666 )
3667 CreateDataType(
3668     "vim.host.VsanObjectHealth",
3669     "VsanObjectHealth",
3670     "vmodl.DynamicData",
3671     "vim.version.version9",
3672     [
3673         ("numObjects", "int", "vim.version.version9", 0),
3674         ("health", "vim.host.VsanObjectHealthState", "vim.version.version9", 0),
3675         ("objUuids", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
3676     ],
3677 )
3678 CreateDataType(
3679     "vim.cluster.VsanClusterBalanceSummary",
3680     "VsanClusterBalanceSummary",
3681     "vmodl.DynamicData",
3682     "vim.version.version9",
3683     [
3684         ("varianceThreshold", "long", "vim.version.version9", 0),
3685         (
3686             "disks"</b></font>,
3687             "vim.cluster.VsanClusterBalancePerDiskInfo[]",
3688             "vim.version.version9",
3689             0 | F_OPTIONAL,
3690         ),
3691     ],
3692 )
3693 CreateDataType(
3694     "vim.cluster.VsanClusterTelemetryProxyConfig",
3695     "VsanClusterTelemetryProxyConfig",
3696     "vmodl.DynamicData",
3697     "vim.version.version9",
3698     [
3699         ("host", "string", "vim.version.version9", 0 | F_OPTIONAL),
3700         ("port", "int", "vim.version.version9", 0 | F_OPTIONAL),
3701         ("user", "string", "vim.version.version9", 0 | F_OPTIONAL),
3702         ("password", "string", "vim.version.version9", 0 | F_OPTIONAL),
3703         ("autoDiscovered", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
3704     ],
3705 )
3706 CreateDataType(
3707     "vim.host.VsanVmdkIOLoadSpec",
3708     "VsanVmdkIOLoadSpec",
3709     "vmodl.DynamicData",
3710     "vim.version.version9",
3711     [
3712         ("readPct", "int", "vim.version.version9", 0),
3713         ("oio", "int", "vim.version.version9", 0),
3714         ("iosizeB", "int", "vim.version.version9", 0),
3715         ("dataSizeMb", "long", "vim.version.version9", 0),
3716         ("random", "boolean", "vim.version.version9", 0),
3717         ("startOffsetB", "long", "vim.version.version9", 0 | F_OPTIONAL),
3718     ],
3719 )
3720 CreateDataType(
3721     "vim.host.VsanVsanPcapResult",
3722     "VsanVsanPcapResult",
3723     "vmodl.DynamicData",
3724     "vim.version.version9",
3725     [
3726         ("calltime", "float", "vim.version.version9", 0),
3727         ("vmknic", "string", "vim.version.version9", 0),
3728         ("tcpdumpFilter", "string", "vim.version.version9", 0),
3729         ("snaplen", "int", "vim.version.version9", 0),
3730         ("pkts", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
3731         ("pcap", "string", "vim.version.version9", 0 | F_OPTIONAL),
3732         ("error", "vmodl.MethodFault", "vim.version.version9", 0 | F_OPTIONAL),
3733         ("hostname", "string", "vim.version.version9", 0 | F_OPTIONAL),
3734     ],
3735 )
3736 CreateDataType(
3737     "vim.cluster.VsanClusterNetworkLoadTestResult",
3738     "VsanClusterNetworkLoadTestResult",
3739     "vmodl.DynamicData",
3740     "vim.version.version9",
3741     [
3742         (
3743             "clusterResult",
3744             "vim.cluster.VsanClusterProactiveTestResult",
3745             "vim.version.version9",
3746 <a name="2"></a>            0,
3747         ),
3748         (
3749             <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"hostResults",
3750             "vim.host.VsanNetworkLoadTestResult[]",
3751             "vim.version.version9",
3752             0 | F_OPTIONAL,
3753         ),
3754     ],
3755 )
3756 CreateDataType(
3757     "vim.vsan.upgradesystem.HostPropertyRetrieveIssue",
3758     "VsanHostPropertyRetrieveIssue",
3759     "vim.VsanUpgradeSystem.PreflightCheckIssue",
3760     "vim.version.version10",
3761     [("hosts", "vim.HostSystem[]", "vim.version.version10", 0)],
3762 )
3763 CreateEnumType(
3764     "vim.host.VsanObjectHealthState",
3765     "VsanObjectHealthState",
3766     "vim.version.version9",
3767     [
3768         "inaccessible",
3769         "reducedavailabilitywithnorebuild",
3770         "reducedavailabilitywithnorebuilddelaytimer",
3771         "reducedavailabilitywithactiverebuild",
3772         "datamove",
3773         "nonavailabilityrelatedreconfig",
3774         "nonavailabilityrelatedincompliance",
3775         "healthy",
3776     ],
3777 )
3778 CreateEnumType(
3779     "vim.cluster.VsanObjectTypeEnum",
3780     "VsanObjectTypeEnum",
3781     "vim.version.version9",
3782     [
3783         "vmswap",
3784         "vdisk",
3785         "namespace",
3786         "vmem",
3787         "statsdb",
3788         "iscsi",
3789         "other",
3790         "fileSystemOverhead",
3791         "dedupOverhead",
3792         "checksumOverhead",
3793     ],
3794 )
3795 CreateEnumType(
3796     "vim.cluster.VsanCapabilityType",
3797     "VsanCapabilityType",
3798     "vim.version.version10",
3799     [
3800         "capability",
3801         "allflash",
3802         "stretchedcluster",
3803         "dataefficiency",
3804         "clusterconfig",
3805         "upgrade",
3806         "objectidentities",
3807     ],
3808 )
3809 CreateEnumType(
3810     "vim.cluster.VsanHealthLogLevelEnum",
3811     "VsanHealthLogLevelEnum",
3812     "vim.version.version9",
3813     [
3814         "INFO",
3815         "WARNING",
3816         "ERROR",
3817         "DEBUG",
3818         "CRITICAL",
3819     ],
3820 )
3821 CreateEnumType(
3822     "vim.cluster.VsanPerfSummaryType",
3823     "VsanPerfSummaryType",
3824     "vim.version.version9",
3825     [
3826         "average",
3827         "maximum",
3828         "minimum",
3829         "latest",
3830         "summation",
3831         "none",
3832     ],
3833 )
3834 CreateEnumType(
3835     "vim.cluster.StorageComplianceStatus",
3836     "VsanStorageComplianceStatus",
3837     "vim.version.version9",
3838     [
3839         "compliant",
3840         "nonCompliant",
3841         "unknown",
3842         "notApplicable",
3843     ],
3844 )
3845 CreateEnumType(
3846     "vim.cluster.VsanPerfStatsUnitType",
3847     "VsanPerfStatsUnitType",
3848     "vim.version.version9",
3849     [
3850         "number",
3851         "time_ms",
3852         "percentage",
3853         "size_bytes",
3854         "rate_bytes",
3855     ],
3856 )
3857 CreateEnumType(
3858     "vim.cluster.VsanPerfThresholdDirectionType",
3859     "VsanPerfThresholdDirectionType",
3860     "vim.version.version9",
3861     [
3862         "upper",
3863         "lower",
3864     ],
3865 )
3866 CreateEnumType(
3867     "vim.cluster.VsanPerfStatsType",
3868     "VsanPerfStatsType",
3869     "vim.version.version9",
3870     [
3871         "absolute",
3872         "delta",
3873         "rate",
3874     ],
3875 )
3876 CreateEnumType(
3877     "vim.vsan.host.DiskMappingCreationType",
3878     "VimVsanHostDiskMappingCreationType",
3879     "vim.version.version10",
3880     [
3881         "hybrid",
3882         "allFlash",
3883     ],
3884 )
3885 CreateEnumType(
3886     "vim.cluster.VsanClusterHealthActionIdEnum",
3887     "VsanClusterHealthActionIdEnum",
3888     "vim.version.version9",
3889     [
3890         "RepairClusterObjectsAction",
3891         "UploadHclDb",
3892         "UpdateHclDbFromInternet",
3893         "EnableHealthService",
3894         "DiskBalance",
3895         "StopDiskBalance",
3896         "RemediateDedup",
3897         "UpgradeVsanDiskFormat",
3898     ],
3899 )
3900 CreateEnumType(
3901     "vim.cluster.VsanDiskGroupCreationType",
3902     "VimClusterVsanDiskGroupCreationType",
3903     "vim.version.version10",
3904     [
3905         "allflash"</b></font>,
3906         "hybrid",
3907     ],
3908 )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_virt_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import datetime
2 import os
3 import shutil
4 import tempfile
5 import xml.etree.ElementTree as ET
6 import salt.config
7 import salt.modules.config as config
8 import salt.modules.virt as virt
9 import salt.syspaths
10 import salt.utils.yaml
11 from salt.exceptions import CommandExecutionError, SaltInvocationError
12 from tests.support.helpers import dedent
13 from tests.support.mixins import LoaderModuleMockMixin
14 from tests.support.mock import MagicMock, patch
15 from tests.support.unit import TestCase
16 class LibvirtMock(MagicMock):  # pylint: disable=too-many-ancestors
17     class virDomain(MagicMock):
18     class libvirtError(Exception):
19         def __init__(self, msg):
20             super().__init__(msg)
21             self.msg = msg
22         def get_error_message(self):
23             return self.msg
24 class VirtTestCase(TestCase, LoaderModuleMockMixin):
25     def setup_loader_modules(self):
26         self.mock_libvirt = LibvirtMock()
27         self.mock_conn = MagicMock()
28         self.mock_conn.getStoragePoolCapabilities.return_value = (
29             "&lt;storagepoolCapabilities/&gt;"
30         )
31         self.mock_libvirt.openAuth.return_value = self.mock_conn
32         self.mock_popen = MagicMock()
33         self.addCleanup(delattr, self, "mock_libvirt")
34         self.addCleanup(delattr, self, "mock_conn")
35         self.addCleanup(delattr, self, "mock_popen")
36         self.mock_subprocess = MagicMock()
37         self.mock_subprocess.return_value = (
38             self.mock_subprocess
39         )  # pylint: disable=no-member
40         self.mock_subprocess.Popen.return_value = (
41             self.mock_popen
42         )  # pylint: disable=no-member
43         loader_globals = {
44             "__salt__": {"config.get": config.get, "config.option": config.option},
45             "libvirt": self.mock_libvirt,
46             "subprocess": self.mock_subprocess,
47         }
48         return {virt: loader_globals, config: loader_globals}
49     def set_mock_vm(self, name, xml):
50         self.mock_conn.listDefinedDomains.return_value = [
51             name
52         ]  # pylint: disable=no-member
53         mock_domain = self.mock_libvirt.virDomain()
54         self.mock_conn.lookupByName.return_value = (
55             mock_domain  # pylint: disable=no-member
56         )
57         mock_domain.XMLDesc.return_value = xml  # pylint: disable=no-member
58         mock_domain.info.return_value = [
59             4,
60             2048 * 1024,
61             1024 * 1024,
62             2,
63             1234,
64         ]  # pylint: disable=no-member
65         mock_domain.ID.return_value = 1
66         mock_domain.name.return_value = name
67         return mock_domain
68     def assert_equal_unit(self, actual, expected, unit="KiB"):
69         self.assertEqual(actual.get("unit"), unit)
70         self.assertEqual(actual.text, str(expected))
71     def test_disk_profile_merge(self):
72         root_dir = os.path.join(salt.syspaths.ROOT_DIR, "srv", "salt-images")
73         userdisks = [
74             {"name": "system", "image": "/path/to/image"},
75 <a name="20"></a>            {"name": "data", "size": 16384, "format": "raw"},
76         ]
77         disks = virt<font color="#4e9258"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>._disk_profile(self.mock_conn, "default", "kvm", userdisks, "myvm")
78         self.assertEqual(
79             [
80                 {
81                     "name": "system",
82                     "device": "disk",
83                     "size": 8192,
84                     "format": "qcow2",
85                     "model": "virtio",
86                     "filename": "myvm_system.qcow2",
87                     "image": "/path/to/image",
88                     "source_file": "{}{}myvm_system.qcow2".format(root_dir, os.sep),
89                 },
90                 {
91                     "name": "data",
92                     "device": "disk",
93                     "size": 16384,
94                     "format": "raw",
95                     "model": "virtio",
96                     "filename": "myvm_data.raw",
97                     "source_file": "{}{}myvm_data.raw".format(root_dir, os.</b></font>sep),
98                 },
99             ],
100             disks,
101         )
102     def test_boot_default_dev(self):
103         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
104         nicp = virt._nic_profile("default", "kvm")
105         xml_data = virt._gen_xml(
106             self.mock_conn, "hello", 1, 512, diskp, nicp, "kvm", "hvm", "x86_64"
107         )
108         root = ET.fromstring(xml_data)
109         self.assertEqual(root.find("os/boot").attrib["dev"], "hd")
110         self.assertEqual(root.find("os/type").attrib["arch"], "x86_64")
111         self.assertEqual(root.find("os/type").text, "hvm")
112     def test_boot_custom_dev(self):
113         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
114         nicp = virt._nic_profile("default", "kvm")
115         xml_data = virt._gen_xml(
116             self.mock_conn,
117             "hello",
118             1,
119             512,
120             diskp,
121             nicp,
122             "kvm",
123             "hvm",
124             "x86_64",
125             boot_dev="cdrom",
126         )
127         root = ET.fromstring(xml_data)
128         self.assertEqual(root.find("os/boot").attrib["dev"], "cdrom")
129     def test_boot_multiple_devs(self):
130         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
131         nicp = virt._nic_profile("default", "kvm")
132         xml_data = virt._gen_xml(
133             self.mock_conn,
134             "hello",
135             1,
136             512,
137             diskp,
138             nicp,
139             "kvm",
140             "hvm",
141             "x86_64",
142             boot_dev="cdrom network",
143         )
144         root = ET.fromstring(xml_data)
145         devs = root.findall(".//boot")
146         self.assertTrue(len(devs) == 2)
147     def test_gen_xml_no_nic(self):
148         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
149         nicp = virt._nic_profile("default", "kvm")
150         xml_data = virt._gen_xml(
151             self.mock_conn,
152             "hello",
153             1,
154             512,
155             diskp,
156             nicp,
157             "kvm",
158             "hvm",
159             "x86_64",
160             serials=[{"type": "pty"}],
161         )
162         root = ET.fromstring(xml_data)
163         self.assertEqual(root.find("devices/serial").attrib["type"], "pty")
164     def test_gen_xml_for_telnet_serial(self):
165         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
166         nicp = virt._nic_profile("default", "kvm")
167         xml_data = virt._gen_xml(
168             self.mock_conn,
169             "hello",
170             1,
171             512,
172             diskp,
173             nicp,
174             "kvm",
175             "hvm",
176             "x86_64",
177             serials=[{"type": "tcp", "port": 22223, "protocol": "telnet"}],
178         )
179         root = ET.fromstring(xml_data)
180         self.assertEqual(root.find("devices/serial").attrib["type"], "tcp")
181         self.assertEqual(root.find("devices/serial/source").attrib["service"], "22223")
182         self.assertEqual(root.find("devices/serial/protocol").attrib["type"], "telnet")
183     def test_gen_xml_for_telnet_serial_unspecified_port(self):
184         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
185         nicp = virt._nic_profile("default", "kvm")
186         xml_data = virt._gen_xml(
187             self.mock_conn,
188             "hello",
189             1,
190             512,
191             diskp,
192             nicp,
193             "kvm",
194             "hvm",
195             "x86_64",
196             serials=[{"type": "tcp"}],
197         )
198         root = ET.fromstring(xml_data)
199         self.assertEqual(root.find("devices/serial").attrib["type"], "tcp")
200         self.assertEqual(root.find("devices/serial/source").attrib["service"], "23023")
201         self.assertFalse("tls" in root.find("devices/serial/source").keys())
202         self.assertEqual(root.find("devices/serial/protocol").attrib["type"], "telnet")
203     def test_gen_xml_for_chardev_types(self):
204         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
205         nicp = virt._nic_profile("default", "kvm")
206         xml_data = virt._gen_xml(
207             self.mock_conn,
208             "hello",
209             1,
210             512,
211             diskp,
212             nicp,
213             "kvm",
214             "hvm",
215             "x86_64",
216             consoles=[
217                 {"type": "pty", "path": "/dev/pts/2", "target_port": 2},
218                 {"type": "pty", "target_type": "usb-serial"},
219                 {"type": "stdio"},
220                 {"type": "file", "path": "/path/to/serial.log"},
221             ],
222             serials=[
223                 {"type": "pipe", "path": "/tmp/mypipe"},
224                 {"type": "udp", "host": "127.0.0.1", "port": 1234},
225                 {"type": "tcp", "port": 22223, "protocol": "raw", "tls": True},
226                 {"type": "unix", "path": "/path/to/socket"},
227             ],
228         )
229         root = ET.fromstring(xml_data)
230         self.assertEqual(root.find("devices/console[1]").attrib["type"], "pty")
231         self.assertEqual(
232             root.find("devices/console[1]/source").attrib["path"], "/dev/pts/2"
233         )
234         self.assertEqual(root.find("devices/console[1]/target").attrib["port"], "2")
235         self.assertEqual(root.find("devices/console[2]").attrib["type"], "pty")
236         self.assertIsNone(root.find("devices/console[2]/source"))
237         self.assertEqual(
238             root.find("devices/console[2]/target").attrib["type"], "usb-serial"
239         )
240         self.assertEqual(root.find("devices/console[3]").attrib["type"], "stdio")
241         self.assertIsNone(root.find("devices/console[3]/source"))
242         self.assertEqual(root.find("devices/console[4]").attrib["type"], "file")
243         self.assertEqual(
244             root.find("devices/console[4]/source").attrib["path"], "/path/to/serial.log"
245         )
246         self.assertEqual(root.find("devices/serial[1]").attrib["type"], "pipe")
247         self.assertEqual(
248             root.find("devices/serial[1]/source").attrib["path"], "/tmp/mypipe"
249         )
250         self.assertEqual(root.find("devices/serial[2]").attrib["type"], "udp")
251         self.assertEqual(root.find("devices/serial[2]/source").attrib["mode"], "bind")
252         self.assertEqual(
253             root.find("devices/serial[2]/source").attrib["service"], "1234"
254         )
255         self.assertEqual(
256             root.find("devices/serial[2]/source").attrib["host"], "127.0.0.1"
257         )
258         self.assertEqual(root.find("devices/serial[3]").attrib["type"], "tcp")
259         self.assertEqual(root.find("devices/serial[3]/source").attrib["mode"], "bind")
260         self.assertEqual(
261             root.find("devices/serial[3]/source").attrib["service"], "22223"
262         )
263         self.assertEqual(root.find("devices/serial[3]/source").attrib["tls"], "yes")
264         self.assertEqual(root.find("devices/serial[3]/protocol").attrib["type"], "raw")
265         self.assertEqual(root.find("devices/serial[4]").attrib["type"], "unix")
266         self.assertEqual(
267             root.find("devices/serial[4]/source").attrib["path"], "/path/to/socket"
268         )
269     def test_gen_xml_no_nic_console(self):
270         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
271         nicp = virt._nic_profile("default", "kvm")
272         xml_data = virt._gen_xml(
273             self.mock_conn,
274             "hello",
275             1,
276             512,
277             diskp,
278             nicp,
279             "kvm",
280             "hvm",
281             "x86_64",
282             consoles=[{"type": "pty"}],
283         )
284         root = ET.fromstring(xml_data)
285         self.assertEqual(root.find("devices/console").attrib["type"], "pty")
286     def test_gen_xml_for_telnet_console(self):
287         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
288         nicp = virt._nic_profile("default", "kvm")
289         xml_data = virt._gen_xml(
290             self.mock_conn,
291             "hello",
292             1,
293             512,
294             diskp,
295             nicp,
296             "kvm",
297             "hvm",
298             "x86_64",
299             consoles=[{"type": "tcp", "port": 22223, "protocol": "telnet"}],
300         )
301         root = ET.fromstring(xml_data)
302         self.assertEqual(root.find("devices/console").attrib["type"], "tcp")
303         self.assertEqual(root.find("devices/console/source").attrib["service"], "22223")
304         self.assertEqual(root.find("devices/console/protocol").attrib["type"], "telnet")
305     def test_gen_xml_for_telnet_console_unspecified_port(self):
306         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
307         nicp = virt._nic_profile("default", "kvm")
308         xml_data = virt._gen_xml(
309             self.mock_conn,
310             "hello",
311             1,
312             512,
313             diskp,
314             nicp,
315             "kvm",
316             "hvm",
317             "x86_64",
318             consoles=[{"type": "tcp"}],
319         )
320         root = ET.fromstring(xml_data)
321         self.assertEqual(root.find("devices/console").attrib["type"], "tcp")
322         self.assertEqual(root.find("devices/console/source").attrib["service"], "23023")
323         self.assertEqual(root.find("devices/console/protocol").attrib["type"], "telnet")
324     def test_gen_xml_for_serial_no_console(self):
325         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
326         nicp = virt._nic_profile("default", "kvm")
327         xml_data = virt._gen_xml(
328             self.mock_conn,
329             "hello",
330             1,
331             512,
332             diskp,
333             nicp,
334             "kvm",
335             "hvm",
336             "x86_64",
337             serials=[{"type": "pty"}],
338             consoles=[],
339         )
340         root = ET.fromstring(xml_data)
341         self.assertEqual(root.find("devices/serial").attrib["type"], "pty")
342         self.assertEqual(root.find("devices/console"), None)
343     def test_gen_xml_for_telnet_no_console(self):
344         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
345         nicp = virt._nic_profile("default", "kvm")
346         xml_data = virt._gen_xml(
347             self.mock_conn,
348             "hello",
349             1,
350             512,
351             diskp,
352             nicp,
353             "kvm",
354             "hvm",
355             "x86_64",
356             serials=[{"type": "tcp", "port": 22223, "protocol": "telnet"}],
357             consoles=[],
358         )
359         root = ET.fromstring(xml_data)
360         self.assertEqual(root.find("devices/serial").attrib["type"], "tcp")
361         self.assertEqual(root.find("devices/console"), None)
362     def test_gen_xml_nographics_default(self):
363         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
364         nicp = virt._nic_profile("default", "kvm")
365         xml_data = virt._gen_xml(
366             self.mock_conn, "hello", 1, 512, diskp, nicp, "kvm", "hvm", "x86_64"
367         )
368         root = ET.fromstring(xml_data)
369         self.assertIsNone(root.find("devices/graphics"))
370     def test_gen_xml_noloader_default(self):
371         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
372         nicp = virt._nic_profile("default", "kvm")
373         xml_data = virt._gen_xml(
374             self.mock_conn, "hello", 1, 512, diskp, nicp, "kvm", "hvm", "x86_64"
375         )
376         root = ET.fromstring(xml_data)
377         self.assertIsNone(root.find("os/loader"))
378     def test_gen_xml_vnc_default(self):
379         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
380         nicp = virt._nic_profile("default", "kvm")
381         xml_data = virt._gen_xml(
382             self.mock_conn,
383             "hello",
384             1,
385             512,
386             diskp,
387             nicp,
388             "kvm",
389             "hvm",
390             "x86_64",
391             graphics={
392                 "type": "vnc",
393                 "port": 1234,
394                 "tlsPort": 5678,
395                 "listen": {"type": "address", "address": "myhost"},
396             },
397         )
398         root = ET.fromstring(xml_data)
399         self.assertEqual(root.find("devices/graphics").attrib["type"], "vnc")
400         self.assertEqual(root.find("devices/graphics").attrib["autoport"], "no")
401         self.assertEqual(root.find("devices/graphics").attrib["port"], "1234")
402         self.assertFalse("tlsPort" in root.find("devices/graphics").attrib)
403         self.assertEqual(root.find("devices/graphics").attrib["listen"], "myhost")
404         self.assertEqual(root.find("devices/graphics/listen").attrib["type"], "address")
405         self.assertEqual(
406             root.find("devices/graphics/listen").attrib["address"], "myhost"
407         )
408     def test_gen_xml_memory(self):
409         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
410         nicp = virt._nic_profile("default", "kvm")
411         xml_data = virt._gen_xml(
412             self.mock_conn,
413             "hello",
414             1,
415             {
416                 "boot": "512m",
417                 "current": "256m",
418                 "max": "1g",
419                 "hard_limit": "1024",
420                 "soft_limit": "512m",
421                 "swap_hard_limit": "1g",
422                 "min_guarantee": "256m",
423                 "hugepages": [
424                     {"size": "128m"},
425                     {"nodeset": "0", "size": "256m"},
426                     {"nodeset": "1", "size": "512m"},
427                 ],
428                 "nosharepages": True,
429                 "locked": True,
430                 "source": "file",
431                 "access": "shared",
432                 "allocation": "immediate",
433                 "discard": True,
434             },
435             diskp,
436             nicp,
437             "kvm",
438             "hvm",
439             "x86_64",
440         )
441         root = ET.fromstring(xml_data)
442         self.assert_equal_unit(root.find("memory"), 512 * 1024)
443         self.assert_equal_unit(root.find("currentMemory"), 256 * 1024)
444         self.assert_equal_unit(root.find("maxMemory"), 1024 * 1024)
445         self.assertFalse("slots" in root.find("maxMemory").keys())
446         self.assert_equal_unit(root.find("memtune/hard_limit"), 1024 * 1024)
447         self.assert_equal_unit(root.find("memtune/soft_limit"), 512 * 1024)
448         self.assert_equal_unit(root.find("memtune/swap_hard_limit"), 1024 ** 2)
449         self.assert_equal_unit(root.find("memtune/min_guarantee"), 256 * 1024)
450 <a name="2"></a>        self.assertEqual(
451             [
452                 {"nodeset": page.get("nodeset"), "size": page.get("size")}
453                 for page in root<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.findall("memoryBacking/hugepages/page")
454             ],
455             [
456                 {"nodeset": None, "size": str(128 * 1024)},
457                 {"nodeset": "0", "size": str(256 * 1024)},
458                 {"nodeset": "1", "size": str(512 * 1024)},
459             ],
460         )
461         self.assertIsNotNone(root.find("memoryBacking/nosharepages"))
462         self.assertIsNotNone(root.find("memoryBacking/locked"))
463         self.assertIsNotNone(root.find("memoryBacking/discard"))
464         self.assertEqual(root.find("memoryBacking/source").get("type"), "file")
465         self.</b></font>assertEqual(root.find("memoryBacking/access").get("mode"), "shared")
466         self.assertEqual(root.find("memoryBacking/allocation").get("mode"), "immediate")
467     def test_gen_xml_cpu(self):
468         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
469         nicp = virt._nic_profile("default", "kvm")
470         xml_data = virt._gen_xml(
471             self.mock_conn,
472             "hello",
473             {
474                 "maximum": 12,
475                 "placement": "static",
476                 "cpuset": "0-11",
477                 "current": 5,
478                 "mode": "custom",
479                 "match": "minimum",
480                 "check": "full",
481                 "vendor": "Intel",
482                 "model": {
483                     "name": "core2duo",
484                     "fallback": "allow",
485                     "vendor_id": "GenuineIntel",
486                 },
487                 "cache": {"level": 3, "mode": "emulate"},
488                 "features": {"lahf": "optional", "vmx": "require"},
489                 "vcpus": {
490                     0: {"enabled": True, "hotpluggable": True},
491                     1: {"enabled": False},
492                 },
493             },
494             512,
495             diskp,
496             nicp,
497             "kvm",
498             "hvm",
499             "x86_64",
500         )
501         root = ET.fromstring(xml_data)
502         self.assertEqual(root.find("vcpu").get("current"), "5")
503         self.assertEqual(root.find("vcpu").get("placement"), "static")
504         self.assertEqual(root.find("vcpu").get("cpuset"), "0-11")
505         self.assertEqual(root.find("vcpu").text, "12")
506         self.assertEqual(root.find("cpu").get("match"), "minimum")
507         self.assertEqual(root.find("cpu").get("mode"), "custom")
508         self.assertEqual(root.find("cpu").get("check"), "full")
509         self.assertEqual(root.find("cpu/vendor").text, "Intel")
510         self.assertEqual(root.find("cpu/model").text, "core2duo")
511         self.assertEqual(root.find("cpu/model").get("fallback"), "allow")
512         self.assertEqual(root.find("cpu/model").get("vendor_id"), "GenuineIntel")
513         self.assertEqual(root.find("cpu/cache").get("level"), "3")
514         self.assertEqual(root.find("cpu/cache").get("mode"), "emulate")
515         self.assertEqual(
516             {f.get("name"): f.get("policy") for f in root.findall("cpu/feature")},
517             {"lahf": "optional", "vmx": "require"},
518         )
519         self.assertEqual(
520             {
521                 v.get("id"): {
522                     "enabled": v.get("enabled"),
523                     "hotpluggable": v.get("hotpluggable"),
524                 }
525                 for v in root.findall("vcpus/vcpu")
526             },
527             {
528                 "0": {"enabled": "yes", "hotpluggable": "yes"},
529                 "1": {"enabled": "no", "hotpluggable": None},
530             },
531         )
532     def test_gen_xml_cpu_topology(self):
533         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
534         nicp = virt._nic_profile("default", "kvm")
535         xml_data = virt._gen_xml(
536             self.mock_conn,
537             "hello",
538             {"maximum": 1, "topology": {"sockets": 4, "cores": 16, "threads": 2}},
539             512,
540             diskp,
541             nicp,
542             "kvm",
543             "hvm",
544             "x86_64",
545         )
546         root = ET.fromstring(xml_data)
547         self.assertEqual(root.find("cpu/topology").get("sockets"), "4")
548         self.assertEqual(root.find("cpu/topology").get("cores"), "16")
549         self.assertEqual(root.find("cpu/topology").get("threads"), "2")
550     def test_gen_xml_cpu_numa(self):
551         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
552         nicp = virt._nic_profile("default", "kvm")
553         xml_data = virt._gen_xml(
554             self.mock_conn,
555             "hello",
556             {
557                 "maximum": 1,
558                 "numa": {
559                     0: {
560                         "cpus": "0-3",
561                         "memory": "1g",
562                         "discard": True,
563                         "distances": {0: 10, 1: 20},
564                     },
565                     1: {"cpus": "4-7", "memory": "2g", "distances": {0: 20, 1: 10}},
566                 },
567             },
568             512,
569             diskp,
570             nicp,
571             "kvm",
572             "hvm",
573             "x86_64",
574         )
575         root = ET.fromstring(xml_data)
576         cell0 = root.find("cpu/numa/cell[@id='0']")
577         self.assertEqual(cell0.get("cpus"), "0-3")
578         self.assertIsNone(cell0.get("unit"))
579         self.assertEqual(cell0.get("memory"), str(1024 ** 2))
580         self.assertEqual(cell0.get("discard"), "yes")
581         self.assertEqual(
582             {d.get("id"): d.get("value") for d in cell0.findall("distances/sibling")},
583             {"0": "10", "1": "20"},
584         )
585         cell1 = root.find("cpu/numa/cell[@id='1']")
586         self.assertEqual(cell1.get("cpus"), "4-7")
587         self.assertIsNone(cell0.get("unit"))
588         self.assertEqual(cell1.get("memory"), str(2 * 1024 ** 2))
589         self.assertFalse("discard" in cell1.keys())
590         self.assertEqual(
591             {d.get("id"): d.get("value") for d in cell1.findall("distances/sibling")},
592             {"0": "20", "1": "10"},
593         )
594     def test_gen_xml_cputune(self):
595 <a name="10"></a>        diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
596         nicp = virt._nic_profile("default", "kvm")
597         cputune = {
598             <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"shares": 2048,
599             "period": 122000,
600             "quota": -1,
601             "global_period": 1000000,
602             "global_quota": -3,
603             "emulator_period": 1200000,
604             "emulator_quota": -10,
605             "iothread_period": 133000,
606             "iothread_quota": -1,
607             "vcpupin": {0: "1-4,^2", 1: "0,1", 2: "2,3", 3: "0,4"},
608             "emulatorpin": "1-3",
609             "iothreadpin": {1: "5-6", 2: "7-8"},
610             "vcpusched": [
611                 {"scheduler": "fifo", "priority": 1, "vcpus": "0"},
612                 {"scheduler": "fifo", "priority": 2, "vcpus": "1"},
613                 {"scheduler": "idle", "priority": 3, "vcpus": "2"},
614             ],
615             "iothreadsched": [
616                 {"scheduler": "idle"},
617                 {"scheduler": "batch", "iothreads": "5-7", "priority": 1},
618             ],
619             "emulatorsched": {"scheduler": "rr", "priority": 2},
620             "cachetune": {
621                 "0-3": {
622                     0: {"level": 3, "type": "both", "size": 3},
623                     1: {"level": 3, "type": "both", "size": 3},
624                     "monitor": {1: 3, "0-3": 3},
625                 },
626                 "4-5": {"monitor": {4: 3, 5: 2}},
627             },
628             "memorytune": {"0-2": {0: 60}, "3-4": {0</b></font>: 50, 1: 70}},
629         }
630         xml_data = virt._gen_xml(
631             self.mock_conn,
632             "hello",
633             {"maximum": 1, "tuning": cputune, "iothreads": 2},
634             512,
635             diskp,
636             nicp,
637             "kvm",
638             "hvm",
639             "x86_64",
640         )
641         root = ET.fromstring(xml_data)
642         self.assertEqual(root.find("cputune").find("shares").text, "2048")
643         self.assertEqual(root.find("cputune").find("period").text, "122000")
644         self.assertEqual(root.find("cputune").find("quota").text, "-1")
645         self.assertEqual(root.find("cputune").find("global_period").text, "1000000")
646         self.assertEqual(root.find("cputune").find("global_quota").text, "-3")
647         self.assertEqual(root.find("cputune").find("emulator_period").text, "1200000")
648         self.assertEqual(root.find("cputune").find("emulator_quota").text, "-10")
649         self.assertEqual(root.find("cputune").find("iothread_period").text, "133000")
650         self.assertEqual(root.find("cputune").find("iothread_quota").text, "-1")
651         self.assertEqual(
652             root.find("cputune").find("vcpupin[@vcpu='0']").attrib.get("cpuset"),
653             "1-4,^2",
654         )
655         self.assertEqual(
656             root.find("cputune").find("vcpupin[@vcpu='1']").attrib.get("cpuset"),
657             "0,1",
658         )
659         self.assertEqual(
660             root.find("cputune").find("vcpupin[@vcpu='2']").attrib.get("cpuset"),
661             "2,3",
662         )
663         self.assertEqual(
664             root.find("cputune").find("vcpupin[@vcpu='3']").attrib.get("cpuset"),
665             "0,4",
666         )
667         self.assertEqual(
668             root.find("cputune").find("emulatorpin").attrib.get("cpuset"), "1-3"
669         )
670         self.assertEqual(
671             root.find("cputune")
672             .find("iothreadpin[@iothread='1']")
673             .attrib.get("cpuset"),
674             "5-6",
675         )
676         self.assertEqual(
677             root.find("cputune")
678             .find("iothreadpin[@iothread='2']")
679             .attrib.get("cpuset"),
680             "7-8",
681         )
682         self.assertDictEqual(
683             {
684                 s.get("vcpus"): {
685 <a name="25"></a>                    "scheduler": s.get("scheduler"),
686                     "priority": s.get("priority"),
687                 }
688                 for s in root<font color="#5eac10"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.findall("cputune/vcpusched")
689             },
690             {
691                 "0": {"scheduler": "fifo", "priority": "1"},
692                 "1": {"scheduler": "fifo", "priority": "2"},
693                 "2": {"scheduler": "idle", "priority": "3"},
694             },
695         )
696         self.assertDictEqual(
697             {
698                 s.get("iothreads"): {
699                     "scheduler": s.</b></font>get("scheduler"),
700                     "priority": s.get("priority"),
701                 }
702                 for s in root.findall("cputune/iothreadsched")
703             },
704             {
705                 None: {"scheduler": "idle", "priority": None},
706                 "5-7": {"scheduler": "batch", "priority": "1"},
707             },
708         )
709         self.assertEqual(root.find("cputune/emulatorsched").get("scheduler"), "rr")
710         self.assertEqual(root.find("cputune/emulatorsched").get("priority"), "2")
711         self.assertEqual(
712             root.find("./cputune/cachetune[@vcpus='0-3']").attrib.get("vcpus"), "0-3"
713         )
714         self.assertEqual(
715             root.find("./cputune/cachetune[@vcpus='0-3']/cache[@id='0']").attrib.get(
716                 "level"
717             ),
718             "3",
719         )
720         self.assertEqual(
721             root.find("./cputune/cachetune[@vcpus='0-3']/cache[@id='0']").attrib.get(
722                 "type"
723             ),
724             "both",
725         )
726         self.assertEqual(
727             root.find(
728                 "./cputune/cachetune[@vcpus='0-3']/monitor[@vcpus='1']"
729             ).attrib.get("level"),
730             "3",
731         )
732         self.assertNotEqual(
733             root.find("./cputune/cachetune[@vcpus='0-3']/monitor[@vcpus='1']"), None
734         )
735         self.assertNotEqual(
736             root.find("./cputune/cachetune[@vcpus='4-5']").attrib.get("vcpus"), None
737         )
738         self.assertEqual(
739             root.find("./cputune/cachetune[@vcpus='4-5']/cache[@id='0']"), None
740         )
741         self.assertEqual(
742             root.find(
743                 "./cputune/cachetune[@vcpus='4-5']/monitor[@vcpus='4']"
744             ).attrib.get("level"),
745             "3",
746         )
747         self.assertEqual(
748             root.find(
749                 "./cputune/cachetune[@vcpus='4-5']/monitor[@vcpus='5']"
750             ).attrib.get("level"),
751             "2",
752         )
753         self.assertNotEqual(root.find("./cputune/memorytune[@vcpus='0-2']"), None)
754         self.assertEqual(
755             root.find("./cputune/memorytune[@vcpus='0-2']/node[@id='0']").attrib.get(
756                 "bandwidth"
757             ),
758             "60",
759         )
760         self.assertNotEqual(root.find("./cputune/memorytune[@vcpus='3-4']"), None)
761         self.assertEqual(
762             root.find("./cputune/memorytune[@vcpus='3-4']/node[@id='0']").attrib.get(
763                 "bandwidth"
764             ),
765             "50",
766         )
767         self.assertEqual(
768             root.find("./cputune/memorytune[@vcpus='3-4']/node[@id='1']").attrib.get(
769                 "bandwidth"
770             ),
771             "70",
772         )
773         self.assertEqual(root.find("iothreads").text, "2")
774     def test_default_disk_profile_hypervisor_esxi(self):
775         mock = MagicMock(return_value={})
776         with patch.dict(
777             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
778         ):
779             ret = virt._disk_profile(
780                 self.mock_conn, "nonexistent", "vmware", None, "test-vm"
781             )
782             self.assertTrue(len(ret) == 1)
783             found = [disk for disk in ret if disk["name"] == "system"]
784             self.assertTrue(bool(found))
785             system = found[0]
786             self.assertEqual(system["format"], "vmdk")
787             self.assertEqual(system["model"], "scsi")
788             self.assertTrue(int(system["size"]) &gt;= 1)
789     def test_default_disk_profile_hypervisor_kvm(self):
790         mock = MagicMock(side_effect=[{}, "/images/dir"])
791         with patch.dict(
792             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
793         ):
794             ret = virt._disk_profile(
795                 self.mock_conn, "nonexistent", "kvm", None, "test-vm"
796             )
797             self.assertTrue(len(ret) == 1)
798             found = [disk for disk in ret if disk["name"] == "system"]
799             self.assertTrue(bool(found))
800             system = found[0]
801             self.assertEqual(system["format"], "qcow2")
802             self.assertEqual(system["model"], "virtio")
803             self.assertTrue(int(system["size"]) &gt;= 1)
804     def test_default_disk_profile_hypervisor_xen(self):
805         mock = MagicMock(side_effect=[{}, "/images/dir"])
806         with patch.dict(
807             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
808         ):
809             ret = virt._disk_profile(
810                 self.mock_conn, "nonexistent", "xen", None, "test-vm"
811             )
812             self.assertTrue(len(ret) == 1)
813             found = [disk for disk in ret if disk["name"] == "system"]
814             self.assertTrue(bool(found))
815             system = found[0]
816             self.assertEqual(system["format"], "qcow2")
817             self.assertEqual(system["model"], "xen")
818             self.assertTrue(int(system["size"]) &gt;= 1)
819     def test_default_nic_profile_hypervisor_esxi(self):
820         mock = MagicMock(return_value={})
821         with patch.dict(
822             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
823         ):
824             ret = virt._nic_profile("nonexistent", "vmware")
825             self.assertTrue(len(ret) == 1)
826             eth0 = ret[0]
827             self.assertEqual(eth0["name"], "eth0")
828             self.assertEqual(eth0["type"], "bridge")
829             self.assertEqual(eth0["source"], "DEFAULT")
830             self.assertEqual(eth0["model"], "e1000")
831     def test_default_nic_profile_hypervisor_kvm(self):
832         mock = MagicMock(return_value={})
833         with patch.dict(
834             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
835         ):
836             ret = virt._nic_profile("nonexistent", "kvm")
837             self.assertTrue(len(ret) == 1)
838             eth0 = ret[0]
839             self.assertEqual(eth0["name"], "eth0")
840             self.assertEqual(eth0["type"], "bridge")
841             self.assertEqual(eth0["source"], "br0")
842             self.assertEqual(eth0["model"], "virtio")
843     def test_default_nic_profile_hypervisor_xen(self):
844         mock = MagicMock(return_value={})
845         with patch.dict(
846             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
847         ):
848             ret = virt._nic_profile("nonexistent", "xen")
849             self.assertTrue(len(ret) == 1)
850             eth0 = ret[0]
851             self.assertEqual(eth0["name"], "eth0")
852             self.assertEqual(eth0["type"], "bridge")
853             self.assertEqual(eth0["source"], "br0")
854             self.assertFalse(eth0["model"])
855     def test_gen_vol_xml_esx(self):
856         xml_data = virt._gen_vol_xml("vmname/system.vmdk", 8192, format="vmdk")
857         root = ET.fromstring(xml_data)
858         self.assertIsNone(root.get("type"))
859         self.assertEqual(root.find("name").text, "vmname/system.vmdk")
860         self.assertEqual(root.find("capacity").attrib["unit"], "KiB")
861         self.assertEqual(root.find("capacity").text, str(8192 * 1024))
862         self.assertEqual(root.find("allocation").text, str(0))
863         self.assertEqual(root.find("target/format").get("type"), "vmdk")
864         self.assertIsNone(root.find("target/permissions"))
865         self.assertIsNone(root.find("target/nocow"))
866         self.assertIsNone(root.find("backingStore"))
867     def test_gen_vol_xml_file(self):
868         xml_data = virt._gen_vol_xml(
869             "myvm_system.qcow2",
870             8192,
871             format="qcow2",
872             allocation=4096,
873             type="file",
874             permissions={
875                 "mode": "0775",
876                 "owner": "123",
877                 "group": "456",
878                 "label": "sec_label",
879             },
880             backing_store={"path": "/backing/image", "format": "raw"},
881             nocow=True,
882         )
883         root = ET.fromstring(xml_data)
884         self.assertEqual(root.get("type"), "file")
885         self.assertEqual(root.find("name").text, "myvm_system.qcow2")
886         self.assertIsNone(root.find("key"))
887         self.assertIsNone(root.find("target/path"))
888         self.assertEqual(root.find("target/format").get("type"), "qcow2")
889         self.assertEqual(root.find("capacity").attrib["unit"], "KiB")
890         self.assertEqual(root.find("capacity").text, str(8192 * 1024))
891         self.assertEqual(root.find("capacity").attrib["unit"], "KiB")
892         self.assertEqual(root.find("allocation").text, str(4096 * 1024))
893         self.assertEqual(root.find("target/permissions/mode").text, "0775")
894         self.assertEqual(root.find("target/permissions/owner").text, "123")
895         self.assertEqual(root.find("target/permissions/group").text, "456")
896         self.assertEqual(root.find("target/permissions/label").text, "sec_label")
897         self.assertIsNotNone(root.find("target/nocow"))
898         self.assertEqual(root.find("backingStore/path").text, "/backing/image")
899         self.assertEqual(root.find("backingStore/format").get("type"), "raw")
900     def test_gen_xml_for_kvm_default_profile(self):
901         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
902         nicp = virt._nic_profile("default", "kvm")
903         xml_data = virt._gen_xml(
904             self.mock_conn,
905             "hello",
906             1,
907             512,
908             diskp,
909             nicp,
910             "kvm",
911             "hvm",
912             "x86_64",
913         )
914         root = ET.fromstring(xml_data)
915         self.assertEqual(root.attrib["type"], "kvm")
916         self.assertEqual(root.find("vcpu").text, "1")
917         self.assertEqual(root.find("memory").text, str(512 * 1024))
918         self.assertEqual(root.find("memory").attrib["unit"], "KiB")
919         disks = root.findall(".//disk")
920         self.assertEqual(len(disks), 1)
921         disk = disks[0]
922         root_dir = salt.config.DEFAULT_MINION_OPTS.get("root_dir")
923         self.assertTrue(disk.find("source").attrib["file"].startswith(root_dir))
924         self.assertTrue("hello_system" in disk.find("source").attrib["file"])
925         self.assertEqual(disk.find("target").attrib["dev"], "vda")
926         self.assertEqual(disk.find("target").attrib["bus"], "virtio")
927         self.assertEqual(disk.find("driver").attrib["name"], "qemu")
928         self.assertEqual(disk.find("driver").attrib["type"], "qcow2")
929         interfaces = root.findall(".//interface")
930         self.assertEqual(len(interfaces), 1)
931         iface = interfaces[0]
932         self.assertEqual(iface.attrib["type"], "bridge")
933         self.assertEqual(iface.find("source").attrib["bridge"], "br0")
934         self.assertEqual(iface.find("model").attrib["type"], "virtio")
935     def test_gen_xml_for_esxi_default_profile(self):
936         diskp = virt._disk_profile(self.mock_conn, "default", "vmware", [], "hello")
937         nicp = virt._nic_profile("default", "vmware")
938         xml_data = virt._gen_xml(
939             self.mock_conn,
940             "hello",
941             1,
942             512,
943             diskp,
944             nicp,
945             "vmware",
946             "hvm",
947             "x86_64",
948         )
949         root = ET.fromstring(xml_data)
950         self.assertEqual(root.attrib["type"], "vmware")
951         self.assertEqual(root.find("vcpu").text, "1")
952         self.assertEqual(root.find("memory").text, str(512 * 1024))
953         self.assertEqual(root.find("memory").attrib["unit"], "KiB")
954         disks = root.findall(".//disk")
955         self.assertEqual(len(disks), 1)
956         disk = disks[0]
957         self.assertTrue("[0]" in disk.find("source").attrib["file"])
958         self.assertTrue("hello_system" in disk.find("source").attrib["file"])
959         self.assertEqual(disk.find("target").attrib["dev"], "sda")
960         self.assertEqual(disk.find("target").attrib["bus"], "scsi")
961         self.assertEqual(disk.find("address").attrib["unit"], "0")
962         interfaces = root.findall(".//interface")
963         self.assertEqual(len(interfaces), 1)
964         iface = interfaces[0]
965         self.assertEqual(iface.attrib["type"], "bridge")
966         self.assertEqual(iface.find("source").attrib["bridge"], "DEFAULT")
967         self.assertEqual(iface.find("model").attrib["type"], "e1000")
968     def test_gen_xml_for_esxi_custom_profile(self):
969         disks = {
970             "noeffect": [
971                 {"first": {"size": 8192, "pool": "datastore1"}},
972                 {"second": {"size": 4096, "pool": "datastore2"}},
973             ]
974         }
975         nics = {
976             "noeffect": [
977                 {"name": "eth1", "source": "ONENET"},
978                 {"name": "eth2", "source": "TWONET"},
979             ]
980         }
981         with patch.dict(
982             virt.__salt__,  # pylint: disable=no-member
983             {"config.get": MagicMock(side_effect=[disks, nics])},
984         ):
985             diskp = virt._disk_profile(
986                 self.mock_conn, "noeffect", "vmware", [], "hello"
987             )
988             nicp = virt._nic_profile("noeffect", "vmware")
989             xml_data = virt._gen_xml(
990                 self.mock_conn,
991                 "hello",
992                 1,
993                 512,
994                 diskp,
995                 nicp,
996                 "vmware",
997                 "hvm",
998                 "x86_64",
999             )
1000             root = ET.fromstring(xml_data)
1001             self.assertEqual(root.attrib["type"], "vmware")
1002             self.assertEqual(root.find("vcpu").text, "1")
1003             self.assertEqual(root.find("memory").text, str(512 * 1024))
1004             self.assertEqual(root.find("memory").attrib["unit"], "KiB")
1005             self.assertTrue(len(root.findall(".//disk")) == 2)
1006             self.assertTrue(len(root.findall(".//interface")) == 2)
1007     def test_gen_xml_for_kvm_custom_profile(self):
1008         disks = {
1009             "noeffect": [
1010                 {"first": {"size": 8192, "pool": "/var/lib/images"}},
1011                 {"second": {"size": 4096, "pool": "/var/lib/images"}},
1012             ]
1013         }
1014         nics = {
1015             "noeffect": [
1016                 {"name": "eth1", "source": "b2"},
1017                 {"name": "eth2", "source": "b2"},
1018             ]
1019         }
1020         with patch.dict(
1021             virt.__salt__,  # pylint: disable=no-member
1022             {"config.get": MagicMock(side_effect=[disks, nics])},
1023         ):
1024             diskp = virt._disk_profile(self.mock_conn, "noeffect", "kvm", [], "hello")
1025             nicp = virt._nic_profile("noeffect", "kvm")
1026             xml_data = virt._gen_xml(
1027                 self.mock_conn,
1028                 "hello",
1029                 1,
1030                 512,
1031                 diskp,
1032                 nicp,
1033                 "kvm",
1034                 "hvm",
1035                 "x86_64",
1036             )
1037             root = ET.fromstring(xml_data)
1038             self.assertEqual(root.attrib["type"], "kvm")
1039             self.assertEqual(root.find("vcpu").text, "1")
1040             self.assertEqual(root.find("memory").text, str(512 * 1024))
1041             self.assertEqual(root.find("memory").attrib["unit"], "KiB")
1042             disks = root.findall(".//disk")
1043             self.assertTrue(len(disks) == 2)
1044             self.assertEqual(disks[0].find("target").get("dev"), "vda")
1045             self.assertEqual(disks[1].find("target").get("dev"), "vdb")
1046             self.assertTrue(len(root.findall(".//interface")) == 2)
1047     def test_disk_profile_kvm_disk_pool(self):
1048         disks = {
1049             "noeffect": [
1050                 {"first": {"size": 8192, "pool": "mypool"}},
1051                 {"second": {"size": 4096}},
1052             ]
1053         }
1054         with patch.dict(
1055             virt.__salt__,
1056             {
1057                 "config.get": MagicMock(
1058                     side_effect=[
1059                         disks,
1060                         os.path.join(salt.syspaths.ROOT_DIR, "default", "path"),
1061                     ]
1062                 )
1063             },
1064         ):
1065             diskp = virt._disk_profile(self.mock_conn, "noeffect", "kvm", [], "hello")
1066             pools_path = (
1067                 os.path.join(salt.syspaths.ROOT_DIR, "pools", "mypool") + os.sep
1068             )
1069             default_path = (
1070                 os.path.join(salt.syspaths.ROOT_DIR, "default", "path") + os.sep
1071             )
1072             self.assertEqual(len(diskp), 2)
1073             self.assertTrue(diskp[1]["source_file"].startswith(default_path))
1074     def test_disk_profile_kvm_disk_external_image(self):
1075         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
1076             diskp = virt._disk_profile(
1077                 self.mock_conn,
1078                 None,
1079                 "kvm",
1080                 [{"name": "mydisk", "source_file": "/path/to/my/image.qcow2"}],
1081                 "hello",
1082             )
1083             self.assertEqual(len(diskp), 1)
1084             self.assertEqual(diskp[0]["source_file"], "/path/to/my/image.qcow2")
1085     def test_disk_profile_cdrom_default(self):
1086         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
1087             diskp = virt._disk_profile(
1088                 self.mock_conn,
1089                 None,
1090                 "kvm",
1091                 [
1092                     {
1093                         "name": "mydisk",
1094                         "device": "cdrom",
1095                         "source_file": "/path/to/my.iso",
1096                     }
1097                 ],
1098                 "hello",
1099             )
1100             self.assertEqual(len(diskp), 1)
1101             self.assertEqual(diskp[0]["model"], "ide")
1102             self.assertEqual(diskp[0]["format"], "raw")
1103     def test_disk_profile_pool_disk_type(self):
1104         self.mock_conn.listStoragePools.return_value = ["test-vdb"]
1105         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = """
1106             &lt;pool type="disk"&gt;
1107               &lt;name&gt;test-vdb&lt;/name&gt;
1108               &lt;source&gt;
1109                 &lt;device path='/dev/vdb'/&gt;
1110               &lt;/source&gt;
1111               &lt;target&gt;
1112                 &lt;path&gt;/dev&lt;/path&gt;
1113               &lt;/target&gt;
1114             &lt;/pool&gt;
1115         """
1116 <a name="19"></a>        self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = (
1117             []
1118         )
1119         diskp = virt<font color="#f62817"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>._disk_profile(
1120             self.mock_conn,
1121             None,
1122             "kvm",
1123             [{"name": "mydisk", "pool": "test-vdb"}],
1124             "hello",
1125         )
1126         self.assertEqual(diskp[0]["filename"], "vdb1")
1127         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.</b></font>return_value = [
1128             "vdb1",
1129 <a name="33"></a>            "vdb2",
1130         ]
1131         diskp = virt._disk_profile(
1132             self<font color="#736aff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.mock_conn,
1133             None,
1134             "kvm",
1135             [{"name": "mydisk", "pool": "test-vdb"}],
1136             "hello",
1137         )
1138         self.assertEqual(diskp[0]["filename"], "vdb3")
1139         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.</b></font>return_value = [
1140             "vdb1",
1141             "vdb3",
1142         ]
1143         diskp = virt._disk_profile(
1144             self.mock_conn,
1145             None,
1146             "kvm",
1147             [{"name": "mydisk", "pool": "test-vdb"}],
1148             "hello",
1149         )
1150         self.assertEqual(diskp[0]["filename"], "vdb2")
1151         diskp = virt._disk_profile(
1152             self.mock_conn,
1153             None,
1154             "kvm",
1155             [{"name": "mydisk", "pool": "test-vdb", "source_file": "vdb1"}],
1156             "hello",
1157         )
1158         self.assertEqual(diskp[0]["filename"], "vdb1")
1159     def test_gen_xml_volume(self):
1160         self.mock_conn.listStoragePools.return_value = ["default"]
1161         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
1162             "&lt;pool type='dir'/&gt;"
1163         )
1164         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = [
1165             "myvolume"
1166         ]
1167         diskp = virt._disk_profile(
1168             self.mock_conn,
1169             None,
1170             "kvm",
1171             [
1172                 {"name": "system", "pool": "default"},
1173                 {"name": "data", "pool": "default", "source_file": "myvolume"},
1174             ],
1175             "hello",
1176         )
1177         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
1178             "&lt;pool type='dir'/&gt;"
1179         )
1180         nicp = virt._nic_profile(None, "kvm")
1181         xml_data = virt._gen_xml(
1182             self.mock_conn,
1183             "hello",
1184             1,
1185             512,
1186             diskp,
1187             nicp,
1188             "kvm",
1189             "hvm",
1190             "x86_64",
1191         )
1192         root = ET.fromstring(xml_data)
1193         disk = root.findall(".//disk")[0]
1194         self.assertEqual(disk.attrib["device"], "disk")
1195         self.assertEqual(disk.attrib["type"], "volume")
1196         source = disk.find("source")
1197         self.assertEqual("default", source.attrib["pool"])
1198         self.assertEqual("hello_system", source.attrib["volume"])
1199         self.assertEqual("myvolume", root.find(".//disk[2]/source").get("volume"))
1200         self.mock_conn.listStoragePools.return_value = ["test-rbd"]
1201         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = """
1202             &lt;pool type='rbd'&gt;
1203               &lt;name&gt;test-rbd&lt;/name&gt;
1204               &lt;uuid&gt;ede33e0a-9df0-479f-8afd-55085a01b244&lt;/uuid&gt;
1205               &lt;capacity unit='bytes'&gt;526133493760&lt;/capacity&gt;
1206               &lt;allocation unit='bytes'&gt;589928&lt;/allocation&gt;
1207               &lt;available unit='bytes'&gt;515081306112&lt;/available&gt;
1208               &lt;source&gt;
1209                 &lt;host name='ses2.tf.local'/&gt;
1210                 &lt;host name='ses3.tf.local' port='1234'/&gt;
1211                 &lt;name&gt;libvirt-pool&lt;/name&gt;
1212                 &lt;auth type='ceph' username='libvirt'&gt;
1213                   &lt;secret usage='pool_test-rbd'/&gt;
1214                 &lt;/auth&gt;
1215               &lt;/source&gt;
1216             &lt;/pool&gt;
1217         """
1218         self.mock_conn.getStoragePoolCapabilities.return_value = """
1219             &lt;storagepoolCapabilities&gt;
1220               &lt;pool type='rbd' supported='yes'&gt;
1221                 &lt;volOptions&gt;
1222                   &lt;defaultFormat type='raw'/&gt;
1223                   &lt;enum name='targetFormatType'&gt;
1224                   &lt;/enum&gt;
1225                 &lt;/volOptions&gt;
1226               &lt;/pool&gt;
1227             &lt;/storagepoolCapabilities&gt;
1228         """
1229         diskp = virt._disk_profile(
1230             self.mock_conn,
1231             None,
1232             "kvm",
1233             [{"name": "system", "pool": "test-rbd"}],
1234             "test-vm",
1235         )
1236         xml_data = virt._gen_xml(
1237             self.mock_conn,
1238             "hello",
1239             1,
1240             512,
1241             diskp,
1242             nicp,
1243             "kvm",
1244             "hvm",
1245             "x86_64",
1246         )
1247         root = ET.fromstring(xml_data)
1248 <a name="12"></a>        disk = root.findall(".//disk")[0]
1249         self.assertDictEqual(
1250             {
1251                 <font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"type": "network",
1252                 "device": "disk",
1253                 "source": {
1254                     "protocol": "rbd",
1255                     "name": "libvirt-pool/test-vm_system",
1256                     "host": [
1257                         {"name": "ses2.tf.local"},
1258                         {"name": "ses3.tf.local", "port": "1234"},
1259                     ],
1260                     "auth": {
1261                         "username": "libvirt",
1262                         "secret": {"type": "ceph", "usage": "pool_test-rbd"},
1263                     },
1264                 },
1265                 "target": {"dev": "vda", "bus": "virtio"},
1266                 "driver": {
1267                     "name": "qemu",
1268                     "type": "raw",
1269                     "cache": "none",
1270                     "io": "native",
1271                 },
1272             },
1273             salt.utils.xmlutil.to_dict(disk, True),
1274         )
1275         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.</b></font>return_value = """
1276             &lt;pool type='rbd'&gt;
1277               &lt;name&gt;test-rbd&lt;/name&gt;
1278               &lt;uuid&gt;ede33e0a-9df0-479f-8afd-55085a01b244&lt;/uuid&gt;
1279               &lt;capacity unit='bytes'&gt;526133493760&lt;/capacity&gt;
1280               &lt;allocation unit='bytes'&gt;589928&lt;/allocation&gt;
1281               &lt;available unit='bytes'&gt;515081306112&lt;/available&gt;
1282               &lt;source&gt;
1283                 &lt;host name='ses2.tf.local'/&gt;
1284                 &lt;host name='ses3.tf.local' port='1234'/&gt;
1285                 &lt;name&gt;libvirt-pool&lt;/name&gt;
1286                 &lt;auth type='ceph' username='libvirt'&gt;
1287                   &lt;secret uuid='some-uuid'/&gt;
1288                 &lt;/auth&gt;
1289               &lt;/source&gt;
1290             &lt;/pool&gt;
1291         """
1292         self.mock_conn.secretLookupByUUIDString.return_value.usageID.return_value = (
1293             "pool_test-rbd"
1294         )
1295         diskp = virt._disk_profile(
1296             self.mock_conn,
1297             None,
1298             "kvm",
1299             [{"name": "system", "pool": "test-rbd"}],
1300             "test-vm",
1301         )
1302         xml_data = virt._gen_xml(
1303             self.mock_conn,
1304             "hello",
1305             1,
1306             512,
1307             diskp,
1308             nicp,
1309             "kvm",
1310             "hvm",
1311             "x86_64",
1312         )
1313         root = ET.fromstring(xml_data)
1314         self.assertDictEqual(
1315             {
1316                 "username": "libvirt",
1317                 "secret": {"type": "ceph", "usage": "pool_test-rbd"},
1318             },
1319             salt.utils.xmlutil.to_dict(root.find(".//disk/source/auth"), True),
1320         )
1321         self.mock_conn.secretLookupByUUIDString.assert_called_once_with("some-uuid")
1322         self.mock_conn.getStoragePoolCapabilities.return_value = """
1323             &lt;storagepoolCapabilities&gt;
1324               &lt;pool type='disk' supported='yes'&gt;
1325                 &lt;volOptions&gt;
1326                   &lt;defaultFormat type='none'/&gt;
1327                   &lt;enum name='targetFormatType'&gt;
1328                     &lt;value&gt;none&lt;/value&gt;
1329                     &lt;value&gt;linux&lt;/value&gt;
1330                     &lt;value&gt;fat16&lt;/value&gt;
1331                   &lt;/enum&gt;
1332                 &lt;/volOptions&gt;
1333               &lt;/pool&gt;
1334             &lt;/storagepoolCapabilities&gt;
1335         """
1336         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = """
1337             &lt;pool type='disk'&gt;
1338               &lt;name&gt;test-vdb&lt;/name&gt;
1339               &lt;source&gt;
1340                 &lt;device path='/dev/vdb'/&gt;
1341                 &lt;format type='gpt'/&gt;
1342               &lt;/source&gt;
1343             &lt;/pool&gt;
1344         """
1345         self.mock_conn.listStoragePools.return_value = ["test-vdb"]
1346         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = [
1347             "vdb1",
1348         ]
1349         diskp = virt._disk_profile(
1350             self.mock_conn,
1351             None,
1352             "kvm",
1353             [{"name": "system", "pool": "test-vdb"}],
1354             "test-vm",
1355         )
1356         xml_data = virt._gen_xml(
1357             self.mock_conn,
1358             "hello",
1359             1,
1360             512,
1361             diskp,
1362             nicp,
1363             "kvm",
1364             "hvm",
1365             "x86_64",
1366         )
1367         root = ET.fromstring(xml_data)
1368         disk = root.findall(".//disk")[0]
1369         self.assertEqual(disk.attrib["type"], "volume")
1370         source = disk.find("source")
1371         self.assertEqual("test-vdb", source.attrib["pool"])
1372         self.assertEqual("vdb2", source.attrib["volume"])
1373         self.assertEqual("raw", disk.find("driver").get("type"))
1374     def test_get_xml_volume_xen_dir(self):
1375         self.mock_conn.listStoragePools.return_value = ["default"]
1376         pool_mock = MagicMock()
1377         pool_mock.XMLDesc.return_value = (
1378             "&lt;pool type='dir'&gt;&lt;target&gt;&lt;path&gt;/path/to/images&lt;/path&gt;&lt;/target&gt;&lt;/pool&gt;"
1379         )
1380         volume_xml = "&lt;volume&gt;&lt;target&gt;&lt;path&gt;/path/to/images/hello_system&lt;/path&gt;&lt;/target&gt;&lt;/volume&gt;"
1381         pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = volume_xml
1382         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
1383         diskp = virt._disk_profile(
1384             self.mock_conn,
1385             None,
1386             "xen",
1387             [{"name": "system", "pool": "default"}],
1388             "hello",
1389         )
1390         xml_data = virt._gen_xml(
1391             self.mock_conn,
1392             "hello",
1393             1,
1394             512,
1395             diskp,
1396             [],
1397             "xen",
1398             "hvm",
1399             "x86_64",
1400         )
1401         root = ET.fromstring(xml_data)
1402         disk = root.findall(".//disk")[0]
1403         self.assertEqual(disk.attrib["type"], "file")
1404         self.assertEqual(
1405             "/path/to/images/hello_system", disk.find("source").attrib["file"]
1406         )
1407     def test_get_xml_volume_xen_block(self):
1408         self.mock_conn.listStoragePools.return_value = ["default"]
1409         pool_mock = MagicMock()
1410         pool_mock.listVolumes.return_value = ["vol01"]
1411         volume_xml = "&lt;volume&gt;&lt;target&gt;&lt;path&gt;/dev/to/vol01&lt;/path&gt;&lt;/target&gt;&lt;/volume&gt;"
1412         pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = volume_xml
1413         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
1414         for pool_type in ["logical", "disk", "iscsi", "scsi"]:
1415             pool_mock.XMLDesc.return_value = "&lt;pool type='{}'&gt;&lt;source&gt;&lt;device path='/dev/sda'/&gt;&lt;/source&gt;&lt;/pool&gt;".format(
1416                 pool_type
1417             )
1418             diskp = virt._disk_profile(
1419                 self.mock_conn,
1420                 None,
1421                 "xen",
1422                 [{"name": "system", "pool": "default", "source_file": "vol01"}],
1423                 "hello",
1424             )
1425             xml_data = virt._gen_xml(
1426                 self.mock_conn,
1427                 "hello",
1428                 1,
1429                 512,
1430                 diskp,
1431                 [],
1432                 "xen",
1433                 "hvm",
1434                 "x86_64",
1435             )
1436             root = ET.fromstring(xml_data)
1437             disk = root.findall(".//disk")[0]
1438             self.assertEqual(disk.attrib["type"], "block")
1439             self.assertEqual("/dev/to/vol01", disk.find("source").attrib["dev"])
1440     def test_gen_xml_cdrom(self):
1441         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
1442             "&lt;pool type='dir'/&gt;"
1443         )
1444         diskp = virt._disk_profile(
1445             self.mock_conn,
1446             None,
1447             "kvm",
1448             [
1449                 {"name": "system", "pool": "default"},
1450                 {
1451                     "name": "tested",
1452                     "device": "cdrom",
1453                     "source_file": None,
1454                     "model": "ide",
1455                 },
1456                 {
1457                     "name": "remote",
1458                     "device": "cdrom",
1459                     "source_file": (
1460                         "http://myhost:8080/url/to/image?query=foo&amp;filter=bar"
1461                     ),
1462                     "model": "ide",
1463                 },
1464             ],
1465             "hello",
1466         )
1467         nicp = virt._nic_profile(None, "kvm")
1468         xml_data = virt._gen_xml(
1469             self.mock_conn,
1470             "hello",
1471             1,
1472             512,
1473             diskp,
1474             nicp,
1475             "kvm",
1476             "hvm",
1477             "x86_64",
1478         )
1479         root = ET.fromstring(xml_data)
1480         disk = root.findall(".//disk")[1]
1481         self.assertEqual(disk.get("type"), "file")
1482         self.assertEqual(disk.attrib["device"], "cdrom")
1483         self.assertIsNone(disk.find("source"))
1484         self.assertEqual(disk.find("target").get("dev"), "hda")
1485 <a name="24"></a>
1486         disk = root.findall(".//disk")[2]
1487         self.assertEqual(disk.get("type"), "network")
1488         self<font color="#79764d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertEqual(disk.attrib["device"], "cdrom")
1489         self.assertEqual(
1490             {
1491                 "protocol": "http",
1492                 "name": "/url/to/image",
1493                 "query": "query=foo&amp;filter=bar",
1494                 "host": {"name": "myhost", "port": "8080"},
1495             },
1496             salt.utils.xmlutil.to_dict(disk.</b></font>find("source"), True),
1497         )
1498     def test_controller_for_esxi(self):
1499         diskp = virt._disk_profile(self.mock_conn, "default", "vmware", [], "hello")
1500         nicp = virt._nic_profile("default", "vmware")
1501         xml_data = virt._gen_xml(
1502             self.mock_conn,
1503             "hello",
1504             1,
1505             512,
1506             diskp,
1507             nicp,
1508             "vmware",
1509             "hvm",
1510             "x86_64",
1511         )
1512         root = ET.fromstring(xml_data)
1513         controllers = root.findall(".//devices/controller")
1514         self.assertTrue(len(controllers) == 1)
1515         controller = controllers[0]
1516         self.assertEqual(controller.attrib["model"], "lsilogic")
1517     def test_controller_for_kvm(self):
1518         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
1519         nicp = virt._nic_profile("default", "kvm")
1520         xml_data = virt._gen_xml(
1521             self.mock_conn,
1522             "hello",
1523             1,
1524             512,
1525             diskp,
1526             nicp,
1527             "kvm",
1528             "hvm",
1529             "x86_64",
1530         )
1531         root = ET.fromstring(xml_data)
1532         controllers = root.findall(".//devices/controller")
1533         self.assertTrue(len(controllers) == 0)
1534     def test_diff_disks(self):
1535         old_disks = ET.fromstring(
1536         ).findall("disk")
1537         new_disks = ET.fromstring(
1538         ).findall("disk")
1539         ret = virt._diff_disk_lists(old_disks, new_disks)
1540         self.assertEqual(
1541             [
1542                 disk.find("source").get("file")
1543                 if disk.find("source") is not None
1544                 else None
1545                 for disk in ret["unchanged"]
1546             ],
1547             [],
1548         )
1549         self.assertEqual(
1550             [
1551                 disk.find("source").get("file")
1552                 if disk.find("source") is not None
1553                 else None
1554                 for disk in ret["new"]
1555             ],
1556             ["/path/to/img3.qcow2", "/path/to/img0.qcow2", "/path/to/img4.qcow2", None],
1557         )
1558         self.assertEqual(
1559             [disk.find("target").get("dev") for disk in ret["sorted"]],
1560             ["vda", "vdb", "vdc", "hda"],
1561         )
1562         self.assertEqual(
1563             [
1564                 disk.find("source").get("file")
1565                 if disk.find("source") is not None
1566                 else None
1567                 for disk in ret["sorted"]
1568             ],
1569             ["/path/to/img3.qcow2", "/path/to/img0.qcow2", "/path/to/img4.qcow2", None],
1570         )
1571         self.assertEqual(ret["new"][1].find("target").get("bus"), "virtio")
1572         self.assertEqual(
1573             [
1574                 disk.find("source").get("file")
1575                 if disk.find("source") is not None
1576                 else None
1577                 for disk in ret["deleted"]
1578             ],
1579             [
1580                 "/path/to/img0.qcow2",
1581                 "/path/to/img1.qcow2",
1582                 "/path/to/img2.qcow2",
1583                 "/path/to/img4.qcow2",
1584                 None,
1585             ],
1586         )
1587     def test_init(self):
1588         xml = """
1589 &lt;capabilities&gt;
1590   &lt;host&gt;
1591     &lt;uuid&gt;44454c4c-3400-105a-8033-b3c04f4b344a&lt;/uuid&gt;
1592     &lt;cpu&gt;
1593       &lt;arch&gt;x86_64&lt;/arch&gt;
1594       &lt;model&gt;Nehalem&lt;/model&gt;
1595       &lt;vendor&gt;Intel&lt;/vendor&gt;
1596       &lt;microcode version='25'/&gt;
1597       &lt;topology sockets='1' cores='4' threads='2'/&gt;
1598       &lt;feature name='vme'/&gt;
1599       &lt;feature name='ds'/&gt;
1600       &lt;feature name='acpi'/&gt;
1601       &lt;pages unit='KiB' size='4'/&gt;
1602       &lt;pages unit='KiB' size='2048'/&gt;
1603     &lt;/cpu&gt;
1604     &lt;power_management&gt;
1605       &lt;suspend_mem/&gt;
1606       &lt;suspend_disk/&gt;
1607       &lt;suspend_hybrid/&gt;
1608     &lt;/power_management&gt;
1609     &lt;migration_features&gt;
1610       &lt;live/&gt;
1611       &lt;uri_transports&gt;
1612         &lt;uri_transport&gt;tcp&lt;/uri_transport&gt;
1613         &lt;uri_transport&gt;rdma&lt;/uri_transport&gt;
1614       &lt;/uri_transports&gt;
1615     &lt;/migration_features&gt;
1616     &lt;topology&gt;
1617       &lt;cells num='1'&gt;
1618         &lt;cell id='0'&gt;
1619           &lt;memory unit='KiB'&gt;12367120&lt;/memory&gt;
1620           &lt;pages unit='KiB' size='4'&gt;3091780&lt;/pages&gt;
1621           &lt;pages unit='KiB' size='2048'&gt;0&lt;/pages&gt;
1622           &lt;distances&gt;
1623             &lt;sibling id='0' value='10'/&gt;
1624           &lt;/distances&gt;
1625           &lt;cpus num='8'&gt;
1626             &lt;cpu id='0' socket_id='0' core_id='0' siblings='0,4'/&gt;
1627             &lt;cpu id='1' socket_id='0' core_id='1' siblings='1,5'/&gt;
1628             &lt;cpu id='2' socket_id='0' core_id='2' siblings='2,6'/&gt;
1629             &lt;cpu id='3' socket_id='0' core_id='3' siblings='3,7'/&gt;
1630             &lt;cpu id='4' socket_id='0' core_id='0' siblings='0,4'/&gt;
1631             &lt;cpu id='5' socket_id='0' core_id='1' siblings='1,5'/&gt;
1632             &lt;cpu id='6' socket_id='0' core_id='2' siblings='2,6'/&gt;
1633             &lt;cpu id='7' socket_id='0' core_id='3' siblings='3,7'/&gt;
1634           &lt;/cpus&gt;
1635         &lt;/cell&gt;
1636       &lt;/cells&gt;
1637     &lt;/topology&gt;
1638     &lt;cache&gt;
1639       &lt;bank id='0' level='3' type='both' size='8' unit='MiB' cpus='0-7'/&gt;
1640     &lt;/cache&gt;
1641     &lt;secmodel&gt;
1642       &lt;model&gt;apparmor&lt;/model&gt;
1643       &lt;doi&gt;0&lt;/doi&gt;
1644     &lt;/secmodel&gt;
1645     &lt;secmodel&gt;
1646       &lt;model&gt;dac&lt;/model&gt;
1647       &lt;doi&gt;0&lt;/doi&gt;
1648       &lt;baselabel type='kvm'&gt;+487:+486&lt;/baselabel&gt;
1649       &lt;baselabel type='qemu'&gt;+487:+486&lt;/baselabel&gt;
1650     &lt;/secmodel&gt;
1651   &lt;/host&gt;
1652   &lt;guest&gt;
1653     &lt;os_type&gt;hvm&lt;/os_type&gt;
1654     &lt;arch name='i686'&gt;
1655       &lt;wordsize&gt;32&lt;/wordsize&gt;
1656       &lt;emulator&gt;/usr/bin/qemu-system-i386&lt;/emulator&gt;
1657       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
1658       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
1659       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
1660       &lt;domain type='qemu'/&gt;
1661       &lt;domain type='kvm'&gt;
1662         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
1663         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
1664         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
1665         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
1666       &lt;/domain&gt;
1667     &lt;/arch&gt;
1668     &lt;features&gt;
1669       &lt;cpuselection/&gt;
1670       &lt;deviceboot/&gt;
1671       &lt;disksnapshot default='on' toggle='no'/&gt;
1672       &lt;acpi default='on' toggle='yes'/&gt;
1673       &lt;apic default='on' toggle='no'/&gt;
1674       &lt;pae/&gt;
1675       &lt;nonpae/&gt;
1676     &lt;/features&gt;
1677   &lt;/guest&gt;
1678   &lt;guest&gt;
1679     &lt;os_type&gt;hvm&lt;/os_type&gt;
1680     &lt;arch name='x86_64'&gt;
1681       &lt;wordsize&gt;64&lt;/wordsize&gt;
1682       &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
1683       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
1684       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
1685       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
1686       &lt;domain type='qemu'/&gt;
1687       &lt;domain type='kvm'&gt;
1688         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
1689         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
1690         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
1691         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
1692       &lt;/domain&gt;
1693     &lt;/arch&gt;
1694     &lt;features&gt;
1695       &lt;cpuselection/&gt;
1696       &lt;deviceboot/&gt;
1697       &lt;disksnapshot default='on' toggle='no'/&gt;
1698       &lt;acpi default='on' toggle='yes'/&gt;
1699       &lt;apic default='on' toggle='no'/&gt;
1700     &lt;/features&gt;
1701   &lt;/guest&gt;
1702 &lt;/capabilities&gt;
1703         """
1704         self.mock_conn.getCapabilities.return_value = xml  # pylint: disable=no-member
1705         root_dir = os.path.join(salt.syspaths.ROOT_DIR, "srv", "salt-images")
1706         defineMock = MagicMock(return_value=1)
1707         self.mock_conn.defineXML = defineMock
1708         mock_chmod = MagicMock()
1709         mock_run = MagicMock()
1710         with patch.dict(
1711             os.__dict__, {"chmod": mock_chmod, "makedirs": MagicMock()}
1712         ):  # pylint: disable=no-member
1713             with patch.dict(
1714                 virt.__salt__, {"cmd.run": mock_run}
1715             ):  # pylint: disable=no-member
1716                 virt.init(
1717                     "test vm", 2, 1234, nic=None, disk=None, seed=False, start=False
1718                 )
1719                 definition = defineMock.call_args_list[0][0][0]
1720                 self.assertFalse("&lt;interface" in definition)
1721                 self.assertFalse("&lt;disk" in definition)
1722                 defineMock.reset_mock()
1723                 mock_run.reset_mock()
1724                 boot = {
1725                     "kernel": "/root/f8-i386-vmlinuz",
1726                     "initrd": "/root/f8-i386-initrd",
1727                     "cmdline": "console=ttyS0 ks=http://example.com/f8-i386/os/",
1728                 }
1729                 retval = virt.init(
1730                     "test vm boot params",
1731                     2,
1732                     1234,
1733                     nic=None,
1734                     disk=None,
1735                     seed=False,
1736                     start=False,
1737                     boot=boot,
1738                 )
1739                 definition = defineMock.call_args_list[0][0][0]
1740                 self.assertEqual("&lt;kernel" in definition, True)
1741                 self.assertEqual("&lt;initrd" in definition, True)
1742                 self.assertEqual("&lt;cmdline" in definition, True)
1743                 self.assertEqual(retval, True)
1744                 mock_response = MagicMock()
1745                 mock_response.read = MagicMock(return_value="filecontent")
1746                 cache_dir = tempfile.mkdtemp()
1747                 with patch.dict(virt.__dict__, {"CACHE_DIR": cache_dir}):
1748                     with patch(
1749                         "urllib.request.urlopen",
1750                         MagicMock(return_value=mock_response),
1751                     ):
1752                         with patch(
1753                             "salt.utils.files.fopen", return_value=mock_response
1754                         ):
1755                             defineMock.reset_mock()
1756                             mock_run.reset_mock()
1757                             boot = {
1758                                 "kernel": "https://www.example.com/download/vmlinuz",
1759                                 "initrd": "",
1760                                 "cmdline": (
1761                                     "console=ttyS0 ks=http://example.com/f8-i386/os/"
1762                                 ),
1763                             }
1764                             retval = virt.init(
1765                                 "test remote vm boot params",
1766                                 2,
1767                                 1234,
1768                                 nic=None,
1769                                 disk=None,
1770                                 seed=False,
1771                                 start=False,
1772                                 boot=boot,
1773                             )
1774                             definition = defineMock.call_args_list[0][0][0]
1775                             self.assertEqual(cache_dir in definition, True)
1776                     shutil.rmtree(cache_dir)
1777                 defineMock.reset_mock()
1778                 mock_run.reset_mock()
1779                 pool_mock = MagicMock()
1780                 pool_mock.XMLDesc.return_value = '&lt;pool type="dir"/&gt;'
1781                 self.mock_conn.storagePoolLookupByName.return_value = pool_mock
1782                 virt.init(
1783                     "test vm",
1784                     2,
1785                     1234,
1786                     nic=None,
1787                     disk=None,
1788                     disks=[
1789                         {"name": "system", "size": 10240},
1790                         {
1791                             "name": "cddrive",
1792                             "device": "cdrom",
1793                             "source_file": None,
1794                             "model": "ide",
1795                         },
1796                     ],
1797                     seed=False,
1798                     start=False,
1799                 )
1800                 definition = ET.fromstring(defineMock.call_args_list[0][0][0])
1801                 expected_disk_path = os.path.join(root_dir, "test vm_system.qcow2")
1802                 self.assertEqual(
1803                     expected_disk_path,
1804                     definition.find("./devices/disk[1]/source").get("file"),
1805                 )
1806                 self.assertIsNone(definition.find("./devices/disk[2]/source"))
1807                 self.assertEqual(
1808                     mock_run.call_args[0][0],
1809                     'qemu-img create -f qcow2 "{}" 10240M'.format(expected_disk_path),
1810                 )
1811                 self.assertEqual(mock_chmod.call_args[0][0], expected_disk_path)
1812                 defineMock.reset_mock()
1813                 mock_run.reset_mock()
1814                 vol_mock = MagicMock()
1815                 pool_mock.storageVolLookupByName.return_value = vol_mock
1816                 pool_mock.listVolumes.return_value = ["test vm_data"]
1817                 stream_mock = MagicMock()
1818                 self.mock_conn.newStream.return_value = stream_mock
1819                 self.mock_conn.listStoragePools.return_value = ["default", "test"]
1820                 with patch.dict(
1821                     os.__dict__, {"open": MagicMock(), "close": MagicMock()}
1822                 ):
1823                     cache_mock = MagicMock()
1824                     with patch.dict(virt.__salt__, {"cp.cache_file": cache_mock}):
1825                         virt.init(
1826                             "test vm",
1827                             2,
1828                             1234,
1829                             nic=None,
1830                             disk=None,
1831                             disks=[
1832                                 {
1833                                     "name": "system",
1834                                     "size": 10240,
1835                                     "image": "/path/to/image",
1836                                     "pool": "test",
1837                                 },
1838                                 {"name": "data", "size": 10240, "pool": "default"},
1839                                 {
1840                                     "name": "test",
1841                                     "size": 1024,
1842                                     "pool": "default",
1843                                     "format": "qcow2",
1844                                     "backing_store_path": "/backing/path",
1845                                     "backing_store_format": "raw",
1846                                 },
1847                             ],
1848                             seed=False,
1849                             start=False,
1850                         )
1851                         definition = ET.fromstring(defineMock.call_args_list[0][0][0])
1852                         self.assertTrue(
1853                             all(
1854                                 [
1855                                     disk.get("type") == "volume"
1856                                     for disk in definition.findall("./devices/disk")
1857                                 ]
1858                             )
1859                         )
1860                         self.assertEqual(
1861                             ["test", "default", "default"],
1862                             [
1863                                 src.get("pool")
1864                                 for src in definition.findall("./devices/disk/source")
1865                             ],
1866                         )
1867                         self.assertEqual(
1868                             ["test vm_system", "test vm_data", "test vm_test"],
1869                             [
1870                                 src.get("volume")
1871                                 for src in definition.findall("./devices/disk/source")
1872                             ],
1873                         )
1874 <a name="28"></a>
1875                         create_calls = pool_mock.createXML.call_args_list
1876                         vol_names = [
1877                             ET.fromstring(call<font color="#717d7d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>[0][0]).find("name").text
1878                             for call in create_calls
1879                         ]
1880                         self.assertEqual(
1881                             ["test vm_system", "test vm_test"],
1882                             vol_names,
1883                         )
1884                         stream_mock.sendAll.assert_called_once()
1885                         stream_mock.finish.</b></font>assert_called_once()
1886                         vol_mock.upload.assert_called_once_with(stream_mock, 0, 0, 0)
1887     def test_update_backing_store(self):
1888         xml = """
1889             &lt;domain type='kvm' id='7'&gt;
1890               &lt;name&gt;my_vm&lt;/name&gt;
1891               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
1892               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
1893               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
1894               &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
1895               &lt;os&gt;
1896                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
1897               &lt;/os&gt;
1898               &lt;devices&gt;
1899                 &lt;disk type='volume' device='disk'&gt;
1900                   &lt;driver name='qemu' type='qcow2' cache='none' io='native'/&gt;
1901                   &lt;source pool='default' volume='my_vm_system' index='1'/&gt;
1902                   &lt;backingStore type='file' index='2'&gt;
1903                     &lt;format type='qcow2'/&gt;
1904                     &lt;source file='/path/to/base.qcow2'/&gt;
1905                     &lt;backingStore/&gt;
1906                   &lt;/backingStore&gt;
1907                   &lt;target dev='vda' bus='virtio'/&gt;
1908                   &lt;alias name='virtio-disk0'/&gt;
1909                   &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x04' function='0x0'/&gt;
1910                 &lt;/disk&gt;
1911               &lt;/devices&gt;
1912             &lt;/domain&gt;
1913         """
1914         domain_mock = self.set_mock_vm("my_vm", xml)
1915         domain_mock.OSType.return_value = "hvm"
1916         self.mock_conn.defineXML.return_value = True
1917         updatedev_mock = MagicMock(return_value=0)
1918         domain_mock.updateDeviceFlags = updatedev_mock
1919         self.mock_conn.listStoragePools.return_value = ["default"]
1920         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
1921             "&lt;pool type='dir'/&gt;"
1922         )
1923         ret = virt.update(
1924             "my_vm",
1925             disks=[
1926                 {
1927                     "name": "system",
1928                     "pool": "default",
1929                     "backing_store_path": "/path/to/base.qcow2",
1930                     "backing_store_format": "qcow2",
1931                 },
1932             ],
1933         )
1934         self.assertFalse(ret["definition"])
1935         self.assertFalse(ret["disk"]["attached"])
1936         self.assertFalse(ret["disk"]["detached"])
1937     def test_update_removables(self):
1938         xml = """
1939             &lt;domain type='kvm' id='7'&gt;
1940               &lt;name&gt;my_vm&lt;/name&gt;
1941               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
1942               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
1943               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
1944               &lt;os&gt;
1945                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
1946               &lt;/os&gt;
1947               &lt;devices&gt;
1948                 &lt;disk type='network' device='cdrom'&gt;
1949                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1950                   &lt;source protocol='https' name='/dvd-image-1.iso'&gt;
1951                     &lt;host name='test-srv.local' port='80'/&gt;
1952                   &lt;/source&gt;
1953                   &lt;backingStore/&gt;
1954                   &lt;target dev='hda' bus='ide'/&gt;
1955                   &lt;readonly/&gt;
1956                   &lt;alias name='ide0-0-0'/&gt;
1957                   &lt;address type='drive' controller='0' bus='0' target='0' unit='0'/&gt;
1958                 &lt;/disk&gt;
1959                 &lt;disk type='file' device='cdrom'&gt;
1960                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1961                   &lt;target dev='hdb' bus='ide'/&gt;
1962                   &lt;readonly/&gt;
1963                   &lt;alias name='ide0-0-1'/&gt;
1964                   &lt;address type='drive' controller='0' bus='0' target='0' unit='1'/&gt;
1965                 &lt;/disk&gt;
1966                 &lt;disk type='file' device='cdrom'&gt;
1967                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1968                   &lt;source file='/srv/dvd-image-2.iso'/&gt;
1969                   &lt;backingStore/&gt;
1970                   &lt;target dev='hdc' bus='ide'/&gt;
1971                   &lt;readonly/&gt;
1972                   &lt;alias name='ide0-0-2'/&gt;
1973                   &lt;address type='drive' controller='0' bus='0' target='0' unit='2'/&gt;
1974                 &lt;/disk&gt;
1975                 &lt;disk type='file' device='cdrom'&gt;
1976                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1977                   &lt;source file='/srv/dvd-image-3.iso'/&gt;
1978                   &lt;backingStore/&gt;
1979                   &lt;target dev='hdd' bus='ide'/&gt;
1980                   &lt;readonly/&gt;
1981                   &lt;alias name='ide0-0-3'/&gt;
1982                   &lt;address type='drive' controller='0' bus='0' target='0' unit='3'/&gt;
1983                 &lt;/disk&gt;
1984                 &lt;disk type='network' device='cdrom'&gt;
1985                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1986                   &lt;source protocol='https' name='/dvd-image-6.iso'&gt;
1987                     &lt;host name='test-srv.local' port='80'/&gt;
1988                   &lt;/source&gt;
1989                   &lt;backingStore/&gt;
1990                   &lt;target dev='hde' bus='ide'/&gt;
1991                   &lt;readonly/&gt;
1992                 &lt;/disk&gt;
1993               &lt;/devices&gt;
1994             &lt;/domain&gt;
1995         """
1996         domain_mock = self.set_mock_vm("my_vm", xml)
1997         domain_mock.OSType.return_value = "hvm"
1998         self.mock_conn.defineXML.return_value = True
1999         updatedev_mock = MagicMock(return_value=0)
2000         domain_mock.updateDeviceFlags = updatedev_mock
2001 <a name="27"></a>        ret = virt.update(
2002             "my_vm",
2003             disks=[
2004                 <font color="#e77471"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
2005                     "name": "dvd1",
2006                     "device": "cdrom",
2007                     "source_file": None,
2008                     "model": "ide",
2009                 },
2010                 {
2011                     "name": "dvd2",
2012                     "device": "cdrom",
2013                     "source_file": "/srv/dvd-image-4.iso",
2014                     "model": "ide",
2015                 },
2016                 {
2017                     "name": "dvd3",
2018                     "device": "cdrom",
2019                     "source_file": "/srv/dvd-image-2.iso",
2020                     "model": "ide",
2021                 },
2022                 {
2023                     "name": "dvd4",
2024                     "device": "cdrom",
2025                     "source_file": "/srv/dvd-image-5.iso",
2026                     "model": "ide",
2027                 },
2028                 {
2029                     "name": "dvd5",
2030                     "device": "cdrom",
2031                     "source_file": "/srv/dvd-image-6.iso",
2032                     "model": "ide",
2033                 },
2034             ],
2035         )
2036 <a name="1"></a>
2037         self.assertTrue(ret["definition"])
2038         self.assertFalse(ret["disk"].</b></font>get("attached"))
2039         self<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertFalse(ret["disk"].get("detached"))
2040         self.assertEqual(
2041             [
2042                 {
2043                     "type": "file",
2044                     "device": "cdrom",
2045                     "driver": {
2046                         "name": "qemu",
2047                         "type": "raw",
2048                         "cache": "none",
2049                         "io": "native",
2050                     },
2051                     "backingStore": None,
2052                     "target": {"dev": "hda", "bus": "ide"},
2053                     "readonly": None,
2054                     "alias": {"name": "ide0-0-0"},
2055                     "address": {
2056                         "type": "drive",
2057                         "controller": "0",
2058                         "bus": "0",
2059                         "target": "0",
2060                         "unit": "0",
2061                     },
2062                 },
2063                 {
2064                     "type": "file",
2065                     "device": "cdrom",
2066                     "driver": {
2067                         "name": "qemu",
2068                         "type": "raw",
2069                         "cache": "none",
2070                         "io": "native",
2071                     },
2072                     "target": {"dev": "hdb", "bus": "ide"},
2073                     "readonly": None,
2074                     "alias": {"name": "ide0-0-1"},
2075                     "address": {
2076                         "type": "drive",
2077                         "controller": "0",
2078                         "bus": "0",
2079                         "target": "0",
2080                         "unit": "1",
2081                     },
2082                     "source": {"file": "/srv/dvd-image-4.iso"},
2083                 },
2084                 {
2085                     "type": "file",
2086                     "device": "cdrom",
2087                     "driver": {
2088                         "name": "qemu",
2089                         "type": "raw",
2090                         "cache": "none",
2091                         "io": "native",
2092                     },
2093                     "backingStore": None,
2094                     "target": {"dev": "hdd", "bus": "ide"},
2095                     "readonly": None,
2096                     "alias": {"name": "ide0-0-3"},
2097                     "address": {
2098                         "type": "drive",
2099                         "controller": "0",
2100                         "bus": "0",
2101                         "target": "0",
2102                         "unit": "3",
2103                     },
2104                     "source": {"file": "/srv/dvd-image-5.iso"},
2105                 },
2106                 {
2107                     "type": "file",
2108                     "device": "cdrom",
2109                     "driver": {
2110                         "name": "qemu",
2111                         "type": "raw",
2112                         "cache": "none",
2113                         "io": "native",
2114                     },
2115                     "backingStore": None,
2116                     "target": {"dev": "hde", "bus": "ide"},
2117                     "readonly": None,
2118                     "source": {"file": "/srv/dvd-image-6.iso"},
2119                 },
2120             ],
2121             [
2122                 salt.utils.</b></font>xmlutil.to_dict(ET.fromstring(disk), True)
2123                 for disk in ret["disk"]["updated"]
2124             ],
2125         )
2126     def test_update_xen_boot_params(self):
2127         root_dir = os.path.join(salt.syspaths.ROOT_DIR, "srv", "salt-images")
2128         xml_boot = """
2129             &lt;domain type='xen' id='8'&gt;
2130               &lt;name&gt;vm&lt;/name&gt;
2131               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
2132               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
2133               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
2134               &lt;os&gt;
2135                 &lt;type arch='x86_64' machine='xenfv'&gt;hvm&lt;/type&gt;
2136                 &lt;loader type='rom'&gt;/usr/lib/xen/boot/hvmloader&lt;/loader&gt;
2137               &lt;/os&gt;
2138             &lt;/domain&gt;
2139         """
2140         domain_mock_boot = self.set_mock_vm("vm", xml_boot)
2141         domain_mock_boot.OSType = MagicMock(return_value="hvm")
2142         define_mock_boot = MagicMock(return_value=True)
2143         define_mock_boot.setVcpusFlags = MagicMock(return_value=0)
2144         self.mock_conn.defineXML = define_mock_boot
2145         self.assertEqual(
2146             {
2147                 "cpu": False,
2148                 "definition": True,
2149                 "disk": {"attached": [], "detached": [], "updated": []},
2150                 "interface": {"attached": [], "detached": []},
2151             },
2152             virt.update("vm", cpu=2),
2153         )
2154         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2155         self.assertEqual(setxml.find("os").find("loader").attrib.get("type"), "rom")
2156         self.assertEqual(
2157             setxml.find("os").find("loader").text, "/usr/lib/xen/boot/hvmloader"
2158         )
2159     def test_update_existing_boot_params(self):
2160         xml_boot = """
2161             &lt;domain type='kvm' id='8'&gt;
2162               &lt;name&gt;vm_with_boot_param&lt;/name&gt;
2163               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
2164               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
2165               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
2166               &lt;os&gt;
2167                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
2168                 &lt;kernel&gt;/boot/oldkernel&lt;/kernel&gt;
2169                 &lt;initrd&gt;/boot/initrdold.img&lt;/initrd&gt;
2170                 &lt;cmdline&gt;console=ttyS0 ks=http://example.com/old/os/&lt;/cmdline&gt;
2171                 &lt;loader&gt;/usr/share/old/OVMF_CODE.fd&lt;/loader&gt;
2172                 &lt;nvram&gt;/usr/share/old/OVMF_VARS.ms.fd&lt;/nvram&gt;
2173               &lt;/os&gt;
2174             &lt;/domain&gt;
2175         """
2176         domain_mock_boot = self.set_mock_vm("vm_with_boot_param", xml_boot)
2177         domain_mock_boot.OSType = MagicMock(return_value="hvm")
2178         define_mock_boot = MagicMock(return_value=True)
2179         self.mock_conn.defineXML = define_mock_boot
2180         boot_new = {
2181             "kernel": "/root/new-vmlinuz",
2182             "initrd": "/root/new-initrd",
2183             "cmdline": "console=ttyS0 ks=http://example.com/new/os/",
2184         }
2185         uefi_boot_new = {
2186             "loader": "/usr/share/new/OVMF_CODE.fd",
2187             "nvram": "/usr/share/new/OVMF_VARS.ms.fd",
2188         }
2189         self.assertEqual(
2190             {
2191                 "definition": True,
2192                 "disk": {"attached": [], "detached": [], "updated": []},
2193                 "interface": {"attached": [], "detached": []},
2194             },
2195             virt.update("vm_with_boot_param", boot=boot_new),
2196         )
2197         setxml_boot = ET.fromstring(define_mock_boot.call_args[0][0])
2198         self.assertEqual(
2199             setxml_boot.find("os").find("kernel").text, "/root/new-vmlinuz"
2200         )
2201         self.assertEqual(setxml_boot.find("os").find("initrd").text, "/root/new-initrd")
2202         self.assertEqual(
2203             setxml_boot.find("os").find("cmdline").text,
2204             "console=ttyS0 ks=http://example.com/new/os/",
2205         )
2206         self.assertEqual(
2207             {
2208                 "definition": True,
2209                 "disk": {"attached": [], "detached": [], "updated": []},
2210                 "interface": {"attached": [], "detached": []},
2211             },
2212             virt.update("vm_with_boot_param", boot=uefi_boot_new),
2213         )
2214         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2215         self.assertEqual(
2216             setxml.find("os").find("loader").text, "/usr/share/new/OVMF_CODE.fd"
2217         )
2218         self.assertEqual(setxml.find("os").find("loader").attrib.get("readonly"), "yes")
2219         self.assertEqual(setxml.find("os").find("loader").attrib["type"], "pflash")
2220         self.assertEqual(
2221             setxml.find("os").find("nvram").attrib["template"],
2222             "/usr/share/new/OVMF_VARS.ms.fd",
2223         )
2224         kernel_none = {
2225             "kernel": None,
2226             "initrd": None,
2227             "cmdline": None,
2228         }
2229         uefi_none = {"loader": None, "nvram": None}
2230         self.assertEqual(
2231             {
2232                 "definition": True,
2233                 "disk": {"attached": [], "detached": [], "updated": []},
2234                 "interface": {"attached": [], "detached": []},
2235             },
2236             virt.update("vm_with_boot_param", boot=kernel_none),
2237         )
2238         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2239         self.assertEqual(setxml.find("os").find("kernel"), None)
2240         self.assertEqual(setxml.find("os").find("initrd"), None)
2241         self.assertEqual(setxml.find("os").find("cmdline"), None)
2242         self.assertEqual(
2243             {
2244                 "definition": True,
2245                 "disk": {"attached": [], "detached": [], "updated": []},
2246                 "interface": {"attached": [], "detached": []},
2247             },
2248             virt.update("vm_with_boot_param", boot={"efi": False}),
2249         )
2250         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2251         self.assertEqual(setxml.find("os").find("nvram"), None)
2252         self.assertEqual(setxml.find("os").find("loader"), None)
2253         self.assertEqual(
2254             {
2255                 "definition": True,
2256                 "disk": {"attached": [], "detached": [], "updated": []},
2257                 "interface": {"attached": [], "detached": []},
2258             },
2259             virt.update("vm_with_boot_param", boot=uefi_none),
2260         )
2261         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2262         self.assertEqual(setxml.find("os").find("loader"), None)
2263         self.assertEqual(setxml.find("os").find("nvram"), None)
2264     def test_update_existing_numatune_params(self):
2265         xml_numatune = """
2266             &lt;domain type='kvm' id='8'&gt;
2267               &lt;name&gt;vm_with_numatune_param&lt;/name&gt;
2268               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
2269               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
2270               &lt;maxMemory slots="12" unit="bytes"&gt;1048576&lt;/maxMemory&gt;
2271               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
2272               &lt;numatune&gt;
2273                 &lt;memory mode="strict" nodeset="0-11"/&gt;
2274                 &lt;memnode cellid="1" mode="strict" nodeset="3"/&gt;
2275                 &lt;memnode cellid="3" mode="preferred" nodeset="7"/&gt;
2276               &lt;/numatune&gt;
2277               &lt;os&gt;
2278                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
2279               &lt;/os&gt;
2280               &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
2281             &lt;/domain&gt;
2282         """
2283         domain_mock = self.set_mock_vm("vm_with_numatune_param", xml_numatune)
2284         domain_mock.OSType = MagicMock(return_value="hvm")
2285         define_mock = MagicMock(return_value=True)
2286         self.mock_conn.defineXML = define_mock
2287 <a name="26"></a>
2288         numatune = {
2289             <font color="#68818b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"memory": {"mode": "preferred", "nodeset": "0-5"},
2290             "memnodes": {
2291                 0: {"mode": "strict", "nodeset": "4"},
2292                 3: {"mode": "preferred", "nodeset": "7"},
2293                 4: {"mode": "strict", "nodeset": "6"},
2294             },
2295         }
2296         self.assertEqual(
2297             {
2298                 "definition": True,
2299                 "disk": {"attached": [], "detached": [], "updated": []},
2300                 "interface": {"attached": [], "detached": []},
2301             },
2302             virt.update(</b></font>"vm_with_numatune_param", numatune=numatune),
2303         )
2304         setxml = ET.fromstring(define_mock.call_args[0][0])
2305         self.assertEqual(
2306             setxml.find("numatune").find("memory").attrib.get("mode"), "preferred"
2307         )
2308         self.assertEqual(
2309             setxml.find("numatune").find("memory").attrib.get("nodeset"),
2310             ",".join([str(i) for i in range(0, 6)]),
2311         )
2312         self.assertEqual(
2313             setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("mode"), "strict"
2314         )
2315         self.assertEqual(
2316             setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("nodeset"), "4"
2317         )
2318         self.assertEqual(setxml.find("./numatune/memnode/[@cellid='1']"), None)
2319         self.assertEqual(
2320             setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("mode"),
2321             "preferred",
2322         )
2323         self.assertEqual(
2324             setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("nodeset"), "7"
2325         )
2326         self.assertEqual(
2327             setxml.find("./numatune/memnode/[@cellid='4']").attrib.get("mode"), "strict"
2328         )
2329         self.assertEqual(
2330             setxml.find("./numatune/memnode/[@cellid='4']").attrib.get("nodeset"), "6"
2331         )
2332         self.assertEqual(setxml.find("./numatune/memnode/[@cellid='2']"), None)
2333         numatune_mem_none = {
2334             "memory": None,
2335             "memnodes": {
2336                 0: {"mode": "strict", "nodeset": "4"},
2337                 3: {"mode": "preferred", "nodeset": "7"},
2338                 4: {"mode": "strict", "nodeset": "6"},
2339             },
2340         }
2341         self.assertEqual(
2342             {
2343                 "definition": True,
2344                 "disk": {"attached": [], "detached": [], "updated": []},
2345                 "interface": {"attached": [], "detached": []},
2346             },
2347             virt.update("vm_with_numatune_param", numatune=numatune_mem_none),
2348         )
2349         setxml = ET.fromstring(define_mock.call_args[0][0])
2350         self.assertEqual(setxml.find("numatune").find("memory"), None)
2351         self.assertEqual(
2352             setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("mode"), "strict"
2353         )
2354         self.assertEqual(
2355             setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("nodeset"), "4"
2356         )
2357         self.assertEqual(
2358             setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("mode"),
2359             "preferred",
2360         )
2361         self.assertEqual(
2362             setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("nodeset"), "7"
2363         )
2364         self.assertEqual(setxml.find("./numatune/memnode/[@cellid='2']"), None)
2365         numatune_mnodes_none = {
2366             "memory": {"mode": "preferred", "nodeset": "0-5"},
2367             "memnodes": None,
2368         }
2369         self.assertEqual(
2370             {
2371                 "definition": True,
2372                 "disk": {"attached": [], "detached": [], "updated": []},
2373                 "interface": {"attached": [], "detached": []},
2374             },
2375             virt.update("vm_with_numatune_param", numatune=numatune_mnodes_none),
2376         )
2377         setxml = ET.fromstring(define_mock.call_args[0][0])
2378         self.assertEqual(
2379             setxml.find("numatune").find("memory").attrib.get("mode"), "preferred"
2380         )
2381         self.assertEqual(
2382             setxml.find("numatune").find("memory").attrib.get("nodeset"),
2383             ",".join([str(i) for i in range(0, 6)]),
2384         )
2385         self.assertEqual(setxml.find("./numatune/memnode"), None)
2386         numatune_without_change = {
2387             "memory": {"mode": "strict", "nodeset": "0-5,6,7-11"},
2388             "memnodes": {
2389                 1: {"mode": "strict", "nodeset": "3"},
2390                 3: {"mode": "preferred", "nodeset": "7"},
2391             },
2392         }
2393         self.assertEqual(
2394             {
2395                 "definition": False,
2396                 "disk": {"attached": [], "detached": [], "updated": []},
2397                 "interface": {"attached": [], "detached": []},
2398             },
2399             virt.update("vm_with_numatune_param", numatune=numatune_without_change),
2400         )
2401         self.assertEqual(
2402             {
2403                 "definition": True,
2404                 "disk": {"attached": [], "detached": [], "updated": []},
2405                 "interface": {"attached": [], "detached": []},
2406             },
2407             virt.update(
2408                 "vm_with_numatune_param", numatune={"memory": None, "memnodes": None}
2409             ),
2410         )
2411         setxml = ET.fromstring(define_mock.call_args[0][0])
2412         self.assertEqual(setxml.find("numatune"), None)
2413     def test_update_existing_cpu_params(self):
2414         xml_with_existing_params = """
2415             &lt;domain type='kvm' id='8'&gt;
2416               &lt;name&gt;vm_with_boot_param&lt;/name&gt;
2417               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
2418               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
2419               &lt;vcpu placement="static" cpuset="0-11" current="3"&gt;6&lt;/vcpu&gt;
2420               &lt;vcpus&gt;
2421                 &lt;vcpu id="0" enabled="yes" hotpluggable="no" order="1"/&gt;
2422                 &lt;vcpu id="1" enabled="no" hotpluggable="yes"/&gt;
2423                 &lt;vcpu id="2" enabled="no" hotpluggable="yes"/&gt;
2424                 &lt;vcpu id="3" enabled="no" hotpluggable="yes"/&gt;
2425                 &lt;vcpu id="4" enabled="no" hotpluggable="yes"/&gt;
2426                 &lt;vcpu id="5" enabled="no" hotpluggable="yes"/&gt;
2427                 &lt;vcpu id="6" enabled="no" hotpluggable="yes"/&gt;
2428                 &lt;vcpu id="7" enabled="no" hotpluggable="yes"/&gt;
2429                 &lt;vcpu id="8" enabled="no" hotpluggable="yes"/&gt;
2430                 &lt;vcpu id="9" enabled="no" hotpluggable="yes"/&gt;
2431                 &lt;vcpu id="10" enabled="no" hotpluggable="yes"/&gt;
2432                 &lt;vcpu id="11" enabled="no" hotpluggable="yes"/&gt;
2433               &lt;/vcpus&gt;
2434               &lt;cpu mode="custom" match="exact" check="full"&gt;
2435                  &lt;model fallback="allow" vendor_id="Genuine20201"&gt;core2duo&lt;/model&gt;
2436                  &lt;vendor&gt;Intel&lt;/vendor&gt;
2437                  &lt;topology sockets="2" cores="5" threads="2"/&gt;
2438                  &lt;cache level="3" mode="emulate"/&gt;
2439                  &lt;feature policy="optional" name="lahf_lm"/&gt;
2440                  &lt;feature policy="require" name="pcid"/&gt;
2441                  &lt;numa&gt;
2442                     &lt;cell id="0" cpus="0-3" memory="1073741824" unit="KiB" discard="no"&gt;
2443                         &lt;distances&gt;
2444                             &lt;sibling id="0" value="10"/&gt;
2445                             &lt;sibling id="1" value="21"/&gt;
2446                             &lt;sibling id="2" value="31"/&gt;
2447                             &lt;sibling id="3" value="41"/&gt;
2448                         &lt;/distances&gt;
2449                     &lt;/cell&gt;
2450                     &lt;cell id="1" cpus="4-6" memory="1073741824" unit="KiB" memAccess="private"&gt;
2451                         &lt;distances&gt;
2452                             &lt;sibling id="0" value="21"/&gt;
2453                             &lt;sibling id="1" value="10"/&gt;
2454                             &lt;sibling id="2" value="21"/&gt;
2455                             &lt;sibling id="3" value="31"/&gt;
2456                         &lt;/distances&gt;
2457                     &lt;/cell&gt;
2458                  &lt;/numa&gt;
2459               &lt;/cpu&gt;
2460               &lt;os&gt;
2461                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
2462               &lt;/os&gt;
2463               &lt;/domain&gt;
2464          """
2465         domain_mock = self.set_mock_vm(
2466             "vm_with_existing_param", xml_with_existing_params
2467         )
2468         domain_mock.OSType = MagicMock(return_value="hvm")
2469         define_mock = MagicMock(return_value=True)
2470         self.mock_conn.defineXML = define_mock
2471         setvcpus_mock = MagicMock(return_value=0)
2472         domain_mock.setVcpusFlags = setvcpus_mock
2473         cpu_attr = {"placement": "static", "cpuset": "0-5", "current": 3, "maximum": 5}
2474         self.assertEqual(
2475             {
2476                 "definition": True,
2477                 "cpu": True,
2478                 "disk": {"attached": [], "detached": [], "updated": []},
2479                 "interface": {"attached": [], "detached": []},
2480             },
2481             virt.update("vm_with_existing_param", cpu=cpu_attr),
2482         )
2483         setxml = ET.fromstring(define_mock.call_args[0][0])
2484         self.assertEqual(setxml.find("vcpu").text, "5")
2485         self.assertEqual(setxml.find("vcpu").attrib["placement"], "static")
2486         self.assertEqual(
2487             setxml.find("vcpu").attrib["cpuset"],
2488             ",".join([str(i) for i in range(0, 6)]),
2489         )
2490         self.assertEqual(setxml.find("vcpu").attrib["current"], "3")
2491         cpu_none = {"placement": "auto", "cpuset": None, "current": 2, "maximum": 5}
2492         self.assertEqual(
2493             {
2494                 "definition": True,
2495                 "cpu": True,
2496                 "disk": {"attached": [], "detached": [], "updated": []},
2497                 "interface": {"attached": [], "detached": []},
2498             },
2499             virt.update("vm_with_existing_param", cpu=cpu_none),
2500         )
2501         setxml = ET.fromstring(define_mock.call_args[0][0])
2502         self.assertEqual(setxml.find("vcpu").text, "5")
2503         self.assertEqual(setxml.find("vcpu").attrib["placement"], "auto")
2504         self.assertEqual(setxml.find("vcpu").attrib.get("cpuset"), None)
2505         self.assertEqual(setxml.find("vcpu").attrib.get("current"), "2")
2506         vcpus = {
2507             "vcpus": {
2508                 "0": {"enabled": False, "hotpluggable": True, "order": 5},
2509                 "3": {"enabled": True, "hotpluggable": False, "order": 3},
2510                 "7": {"enabled": True, "hotpluggable": False},
2511             }
2512         }
2513         self.assertEqual(
2514             {
2515                 "definition": True,
2516                 "disk": {"attached": [], "detached": [], "updated": []},
2517                 "interface": {"attached": [], "detached": []},
2518             },
2519             virt.update("vm_with_existing_param", cpu=vcpus),
2520         )
2521         setxml = ET.fromstring(define_mock.call_args[0][0])
2522         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']").attrib["id"], "0")
2523         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']").attrib["enabled"], "no")
2524         self.assertEqual(
2525             setxml.find("./vcpus/vcpu/[@id='0']").attrib["hotpluggable"], "yes"
2526         )
2527         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']").attrib["order"], "5")
2528         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["id"], "3")
2529         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["enabled"], "yes")
2530         self.assertEqual(
2531             setxml.find("./vcpus/vcpu/[@id='3']").attrib["hotpluggable"], "no"
2532         )
2533         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["order"], "3")
2534         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='7']").attrib["id"], "7")
2535         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='7']").attrib["enabled"], "yes")
2536         self.assertEqual(
2537             setxml.find("./vcpus/vcpu/[@id='7']").attrib["hotpluggable"], "no"
2538         )
2539         self.assertEqual(
2540             setxml.find("./vcpus/vcpu/[@id='7']").attrib.get("order"), None
2541         )
2542         ind_vcpu = {
2543             "vcpus": {"3": {"enabled": True, "hotpluggable": False, "order": None}}
2544         }
2545         self.assertEqual(
2546             {
2547                 "definition": True,
2548                 "disk": {"attached": [], "detached": [], "updated": []},
2549                 "interface": {"attached": [], "detached": []},
2550             },
2551             virt.update("vm_with_existing_param", cpu=ind_vcpu),
2552         )
2553         setxml = ET.fromstring(define_mock.call_args[0][0])
2554         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']"), None)
2555         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["enabled"], "yes")
2556         self.assertEqual(
2557             setxml.find("./vcpus/vcpu/[@id='3']").attrib["hotpluggable"], "no"
2558         )
2559         self.assertEqual(
2560             setxml.find("./vcpus/vcpu/[@id='3']").attrib.get("order"), None
2561         )
2562         vcpus_none = {"vcpus": None}
2563         self.assertEqual(
2564             {
2565                 "definition": True,
2566                 "disk": {"attached": [], "detached": [], "updated": []},
2567                 "interface": {"attached": [], "detached": []},
2568             },
2569             virt.update("vm_with_existing_param", cpu=vcpus_none),
2570         )
2571         setxml = ET.fromstring(define_mock.call_args[0][0])
2572         self.assertEqual(setxml.find("vcpus"), None)
2573         cpu_atr_none = {"match": None, "mode": None, "check": None}
2574         self.assertEqual(
2575             {
2576                 "definition": True,
2577                 "disk": {"attached": [], "detached": [], "updated": []},
2578                 "interface": {"attached": [], "detached": []},
2579             },
2580             virt.update("vm_with_existing_param", cpu=cpu_atr_none),
2581         )
2582         setxml = ET.fromstring(define_mock.call_args[0][0])
2583         self.assertEqual(setxml.find("cpu").attrib, {})
2584         cpu_atr_mn = {"match": None}
2585         self.assertEqual(
2586             {
2587                 "definition": True,
2588                 "disk": {"attached": [], "detached": [], "updated": []},
2589                 "interface": {"attached": [], "detached": []},
2590             },
2591             virt.update("vm_with_existing_param", cpu=cpu_atr_mn),
2592         )
2593         setxml = ET.fromstring(define_mock.call_args[0][0])
2594         self.assertEqual(setxml.find("cpu").attrib.get("match"), None)
2595         self.assertEqual(setxml.find("cpu").attrib.get("mode"), "custom")
2596         self.assertEqual(setxml.find("cpu").attrib.get("check"), "full")
2597         cpu_model_none = {"model": None}
2598         self.assertEqual(
2599             {
2600                 "definition": True,
2601                 "disk": {"attached": [], "detached": [], "updated": []},
2602                 "interface": {"attached": [], "detached": []},
2603             },
2604             virt.update("vm_with_existing_param", cpu=cpu_model_none),
2605         )
2606         setxml = ET.fromstring(define_mock.call_args[0][0])
2607         self.assertEqual(setxml.find("cpu").find("model"), None)
2608         cpu_model_atr_none = {
2609             "model": {"name": "coresolo", "fallback": "forbid", "vendor_id": None}
2610         }
2611         self.assertEqual(
2612             {
2613                 "definition": True,
2614                 "disk": {"attached": [], "detached": [], "updated": []},
2615                 "interface": {"attached": [], "detached": []},
2616             },
2617             virt.update("vm_with_existing_param", cpu=cpu_model_atr_none),
2618         )
2619         setxml = ET.fromstring(define_mock.call_args[0][0])
2620         self.assertEqual(setxml.find("cpu").find("model").attrib.get("vendor_id"), None)
2621         self.assertEqual(
2622             setxml.find("cpu").find("model").attrib.get("fallback"), "forbid"
2623         )
2624         self.assertEqual(setxml.find("cpu").find("model").text, "coresolo")
2625         cpu_model_atr = {
2626             "model": {
2627                 "name": "coresolo",
2628                 "fallback": "forbid",
2629                 "vendor_id": "AuthenticAMD",
2630             }
2631         }
2632         self.assertEqual(
2633             {
2634                 "definition": True,
2635                 "disk": {"attached": [], "detached": [], "updated": []},
2636                 "interface": {"attached": [], "detached": []},
2637             },
2638             virt.update("vm_with_existing_param", cpu=cpu_model_atr),
2639         )
2640         setxml = ET.fromstring(define_mock.call_args[0][0])
2641         self.assertEqual(
2642             setxml.find("cpu").find("model").attrib.get("fallback"), "forbid"
2643         )
2644         self.assertEqual(
2645             setxml.find("cpu").find("model").attrib.get("vendor_id"), "AuthenticAMD"
2646         )
2647         self.assertEqual(setxml.find("cpu").find("model").text, "coresolo")
2648         cpu_vendor = {"vendor": "AMD"}
2649         self.assertEqual(
2650             {
2651                 "definition": True,
2652                 "disk": {"attached": [], "detached": [], "updated": []},
2653                 "interface": {"attached": [], "detached": []},
2654             },
2655             virt.update("vm_with_existing_param", cpu=cpu_vendor),
2656         )
2657         setxml = ET.fromstring(define_mock.call_args[0][0])
2658         self.assertEqual(setxml.find("cpu").find("vendor").text, "AMD")
2659         cpu_vendor_none = {"vendor": None}
2660         self.assertEqual(
2661             {
2662                 "definition": True,
2663                 "disk": {"attached": [], "detached": [], "updated": []},
2664                 "interface": {"attached": [], "detached": []},
2665             },
2666             virt.update("vm_with_existing_param", cpu=cpu_vendor_none),
2667         )
2668         setxml = ET.fromstring(define_mock.call_args[0][0])
2669         self.assertEqual(setxml.find("cpu").find("vendor"), None)
2670         cpu_topology = {"topology": {"sockets": 1, "cores": 12, "threads": 1}}
2671         self.assertEqual(
2672             {
2673                 "definition": True,
2674                 "disk": {"attached": [], "detached": [], "updated": []},
2675                 "interface": {"attached": [], "detached": []},
2676             },
2677             virt.update("vm_with_existing_param", cpu=cpu_topology),
2678         )
2679         setxml = ET.fromstring(define_mock.call_args[0][0])
2680         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("sockets"), "1")
2681         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("cores"), "12")
2682         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("threads"), "1")
2683         cpu_topology_atr_none = {
2684             "topology": {"sockets": None, "cores": 12, "threads": 1}
2685         }
2686         self.assertEqual(
2687             {
2688                 "definition": True,
2689                 "disk": {"attached": [], "detached": [], "updated": []},
2690                 "interface": {"attached": [], "detached": []},
2691             },
2692             virt.update("vm_with_existing_param", cpu=cpu_topology_atr_none),
2693         )
2694         setxml = ET.fromstring(define_mock.call_args[0][0])
2695         self.assertEqual(
2696             setxml.find("cpu").find("topology").attrib.get("sockets"), None
2697         )
2698         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("cores"), "12")
2699         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("threads"), "1")
2700         cpu_topology_none = {"topology": None}
2701         self.assertEqual(
2702             {
2703                 "definition": True,
2704                 "disk": {"attached": [], "detached": [], "updated": []},
2705                 "interface": {"attached": [], "detached": []},
2706             },
2707             virt.update("vm_with_existing_param", cpu=cpu_topology_none),
2708         )
2709         setxml = ET.fromstring(define_mock.call_args[0][0])
2710         self.assertEqual(setxml.find("cpu").find("topology"), None)
2711         cpu_cache = {"cache": {"mode": "passthrough", "level": 2}}
2712         self.assertEqual(
2713             {
2714                 "definition": True,
2715                 "disk": {"attached": [], "detached": [], "updated": []},
2716                 "interface": {"attached": [], "detached": []},
2717             },
2718             virt.update("vm_with_existing_param", cpu=cpu_cache),
2719         )
2720         setxml = ET.fromstring(define_mock.call_args[0][0])
2721         self.assertEqual(setxml.find("cpu").find("cache").attrib.get("level"), "2")
2722         self.assertEqual(
2723             setxml.find("cpu").find("cache").attrib.get("mode"), "passthrough"
2724         )
2725         cpu_cache_atr_none = {"cache": {"mode": "passthrough", "level": None}}
2726         self.assertEqual(
2727             {
2728                 "definition": True,
2729                 "disk": {"attached": [], "detached": [], "updated": []},
2730                 "interface": {"attached": [], "detached": []},
2731             },
2732             virt.update("vm_with_existing_param", cpu=cpu_cache_atr_none),
2733         )
2734         setxml = ET.fromstring(define_mock.call_args[0][0])
2735         self.assertEqual(setxml.find("cpu").find("cache").attrib.get("level"), None)
2736         self.assertEqual(
2737             setxml.find("cpu").find("cache").attrib.get("mode"), "passthrough"
2738         )
2739         cpu_cache_none = {"cache": None}
2740         self.assertEqual(
2741             {
2742                 "definition": True,
2743                 "disk": {"attached": [], "detached": [], "updated": []},
2744                 "interface": {"attached": [], "detached": []},
2745             },
2746             virt.update("vm_with_existing_param", cpu=cpu_cache_none),
2747         )
2748         setxml = ET.fromstring(define_mock.call_args[0][0])
2749         self.assertEqual(setxml.find("cpu").find("cache"), None)
2750         cpu_feature = {"features": {"lahf_lm": "require", "pcid": "optional"}}
2751         self.assertEqual(
2752             {
2753                 "definition": True,
2754                 "disk": {"attached": [], "detached": [], "updated": []},
2755                 "interface": {"attached": [], "detached": []},
2756             },
2757             virt.update("vm_with_existing_param", cpu=cpu_feature),
2758         )
2759         setxml = ET.fromstring(define_mock.call_args[0][0])
2760         self.assertEqual(
2761             setxml.find("./cpu/feature[@name='pcid']").attrib.get("policy"), "optional"
2762         )
2763         self.assertEqual(
2764             setxml.find("./cpu/feature[@name='lahf_lm']").attrib.get("policy"),
2765             "require",
2766         )
2767         cpu_feature_atr_none = {"features": {"pcid": "optional", "lahf_lm": "disable"}}
2768         self.assertEqual(
2769             {
2770                 "definition": True,
2771                 "disk": {"attached": [], "detached": [], "updated": []},
2772                 "interface": {"attached": [], "detached": []},
2773             },
2774             virt.update("vm_with_existing_param", cpu=cpu_feature_atr_none),
2775         )
2776         setxml = ET.fromstring(define_mock.call_args[0][0])
2777         self.assertEqual(
2778             setxml.find("./cpu/feature[@name='lahf_lm']").attrib.get("policy"),
2779             "disable",
2780         )
2781         self.assertEqual(
2782             setxml.find("./cpu/feature[@name='pcid']").attrib.get("policy"), "optional"
2783         )
2784         cpu_feature_none = {"features": {"lahf_lm": None, "pcid": None}}
2785         self.assertEqual(
2786             {
2787                 "definition": True,
2788                 "disk": {"attached": [], "detached": [], "updated": []},
2789                 "interface": {"attached": [], "detached": []},
2790             },
2791             virt.update("vm_with_existing_param", cpu=cpu_feature_none),
2792         )
2793         setxml = ET.fromstring(define_mock.call_args[0][0])
2794         self.assertEqual(setxml.find("./cpu/feature"), None)
2795 <a name="23"></a>
2796         numa_cell = {
2797             <font color="#f660ab"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"numa": {
2798                 0: {
2799                     "cpus": "0-6",
2800                     "memory": "512m",
2801                     "discard": True,
2802                     "distances": {0: 15, 1: 16, 2: 17, 3: 18},
2803                 },
2804                 1: {
2805                     "cpus": "7-12",
2806                     "memory": "2g",
2807                     "discard": True,
2808                     "memAccess": "shared",
2809                     "distances": {0: 23, 1: 24, 2: 25, 3: 26},
2810                 },
2811             }
2812         }
2813         self.assertEqual(
2814             {
2815                 "definition": True,
2816                 "disk": {"attached": [], "detached": [], "updated": []},
2817                 "interface": {"attached": [], "detached": []},
2818             },
2819             virt.update(</b></font>"vm_with_existing_param", cpu=numa_cell),
2820         )
2821         setxml = ET.fromstring(define_mock.call_args[0][0])
2822         self.assertEqual(
2823             setxml.find("./cpu/numa/cell/[@id='0']").attrib["cpus"],
2824             ",".join([str(i) for i in range(0, 7)]),
2825         )
2826         self.assertEqual(
2827             setxml.find("./cpu/numa/cell/[@id='0']").attrib["memory"],
2828             str(512 * 1024 ** 2),
2829         )
2830         self.assertEqual(
2831             setxml.find("./cpu/numa/cell/[@id='0']").get("unit"),
2832             "bytes",
2833         )
2834         self.assertEqual(
2835             setxml.find("./cpu/numa/cell/[@id='0']").attrib["discard"], "yes"
2836         )
2837         self.assertEqual(
2838             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='0']").attrib[
2839                 "value"
2840             ],
2841             "15",
2842         )
2843         self.assertEqual(
2844             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='1']").attrib[
2845                 "value"
2846             ],
2847             "16",
2848         )
2849         self.assertEqual(
2850             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='2']").attrib[
2851                 "value"
2852             ],
2853             "17",
2854         )
2855         self.assertEqual(
2856             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='3']").attrib[
2857                 "value"
2858             ],
2859             "18",
2860         )
2861         self.assertEqual(
2862             setxml.find("./cpu/numa/cell/[@id='1']").attrib["cpus"],
2863             ",".join([str(i) for i in range(7, 13)]),
2864         )
2865         self.assertEqual(
2866             setxml.find("./cpu/numa/cell/[@id='1']").attrib["memory"],
2867             str(int(2 * 1024 ** 3)),
2868         )
2869         self.assertEqual(
2870             setxml.find("./cpu/numa/cell/[@id='1']").get("unit"),
2871             "bytes",
2872         )
2873         self.assertEqual(
2874             setxml.find("./cpu/numa/cell/[@id='1']").attrib["discard"], "yes"
2875         )
2876         self.assertEqual(
2877             setxml.find("./cpu/numa/cell/[@id='1']").attrib["memAccess"], "shared"
2878         )
2879         self.assertEqual(
2880             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='0']").attrib[
2881                 "value"
2882             ],
2883             "23",
2884         )
2885         self.assertEqual(
2886             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='1']").attrib[
2887                 "value"
2888             ],
2889             "24",
2890         )
2891         self.assertEqual(
2892             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='2']").attrib[
2893                 "value"
2894             ],
2895             "25",
2896         )
2897         self.assertEqual(
2898             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='3']").attrib[
2899                 "value"
2900             ],
2901             "26",
2902 <a name="34"></a>        )
2903         numa_cell_atr_none = {
2904             <font color="#827d6b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"numa": {
2905                 "0": {
2906                     "cpus": "0-6",
2907                     "memory": "512m",
2908                     "discard": False,
2909                     "distances": {0: 15, 2: 17, 3: 18},
2910                 },
2911                 "1": {
2912                     "cpus": "7-12",
2913                     "memory": "2g",
2914                     "discard": True,
2915                     "distances": {0: 23, 1: 24, 2: 25},
2916                 },
2917             }
2918         }
2919         self.assertEqual(
2920             {
2921                 "definition": True,
2922                 "disk": {"attached": [], "detached": [], "updated": []},
2923                 "interface": {"attached": [], "detached": []},
2924             },
2925             virt.</b></font>update("vm_with_existing_param", cpu=numa_cell_atr_none),
2926         )
2927         setxml = ET.fromstring(define_mock.call_args[0][0])
2928         self.assertEqual(
2929             setxml.find("./cpu/numa/cell/[@id='0']").attrib["cpus"],
2930             ",".join([str(i) for i in range(0, 7)]),
2931         )
2932         self.assertEqual(
2933             setxml.find("./cpu/numa/cell/[@id='0']").attrib["memory"],
2934             str(512 * 1024 ** 2),
2935         )
2936         self.assertEqual(
2937             setxml.find("./cpu/numa/cell/[@id='0']").get("unit"),
2938             "bytes",
2939         )
2940         self.assertEqual(
2941             setxml.find("./cpu/numa/cell/[@id='0']").attrib.get("discard"), "no"
2942         )
2943         self.assertEqual(
2944             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='0']").attrib[
2945                 "value"
2946             ],
2947             "15",
2948         )
2949         self.assertEqual(
2950             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='1']"), None
2951         )
2952         self.assertEqual(
2953             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='2']").attrib[
2954                 "value"
2955             ],
2956             "17",
2957         )
2958         self.assertEqual(
2959             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='3']").attrib[
2960                 "value"
2961             ],
2962             "18",
2963         )
2964         self.assertEqual(
2965             setxml.find("./cpu/numa/cell/[@id='1']").attrib["cpus"],
2966             ",".join([str(i) for i in range(7, 13)]),
2967         )
2968         self.assertEqual(
2969             setxml.find("./cpu/numa/cell/[@id='1']").attrib["memory"],
2970             str(int(2 * 1024 ** 3)),
2971         )
2972         self.assertEqual(
2973             setxml.find("./cpu/numa/cell/[@id='1']").attrib["discard"], "yes"
2974         )
2975         self.assertEqual(
2976             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='0']").attrib[
2977                 "value"
2978             ],
2979             "23",
2980         )
2981         self.assertEqual(
2982             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='1']").attrib[
2983                 "value"
2984             ],
2985             "24",
2986         )
2987         self.assertEqual(
2988             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='2']").attrib[
2989                 "value"
2990             ],
2991             "25",
2992         )
2993         self.assertEqual(
2994             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='3']"), None
2995         )
2996         self.assertEqual(
2997             setxml.find("./cpu/numa/cell/[@id='1']").attrib["cpus"],
2998             ",".join([str(i) for i in range(7, 13)]),
2999         )
3000         self.assertEqual(
3001             setxml.find("./cpu/numa/cell/[@id='1']").attrib["memory"],
3002             str(int(1024 ** 3 * 2)),
3003         )
3004         self.assertEqual(
3005             setxml.find("./cpu/numa/cell/[@id='1']").attrib["discard"], "yes"
3006         )
3007         self.assertEqual(
3008             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='0']").attrib[
3009                 "value"
3010             ],
3011             "23",
3012         )
3013         self.assertEqual(
3014             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='1']").attrib[
3015                 "value"
3016             ],
3017             "24",
3018         )
3019         self.assertEqual(
3020             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='2']").attrib[
3021                 "value"
3022             ],
3023             "25",
3024         )
3025         self.assertEqual(
3026             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='3']"),
3027             None,
3028         )
3029     def test_update_memtune_params(self):
3030         xml_with_memtune_params = """
3031             &lt;domain type='kvm' id='8'&gt;
3032               &lt;name&gt;vm_with_boot_param&lt;/name&gt;
3033               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
3034               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
3035               &lt;maxMemory slots="12" unit="bytes"&gt;1048576&lt;/maxMemory&gt;
3036               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
3037               &lt;memtune&gt;
3038                 &lt;hard_limit unit="KiB"&gt;1048576&lt;/hard_limit&gt;
3039                 &lt;soft_limit unit="KiB"&gt;2097152&lt;/soft_limit&gt;
3040                 &lt;swap_hard_limit unit="KiB"&gt;2621440&lt;/swap_hard_limit&gt;
3041                 &lt;min_guarantee unit='KiB'&gt;671088&lt;/min_guarantee&gt;
3042               &lt;/memtune&gt;
3043               &lt;os&gt;
3044                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
3045               &lt;/os&gt;
3046             &lt;/domain&gt;
3047         """
3048         domain_mock = self.set_mock_vm("vm_with_memtune_param", xml_with_memtune_params)
3049         domain_mock.OSType = MagicMock(return_value="hvm")
3050         define_mock = MagicMock(return_value=True)
3051         self.mock_conn.defineXML = define_mock
3052         memtune_new_val = {
3053             "boot": "0.7g",
3054             "current": "2.5g",
3055             "max": "3096m",
3056             "slots": "10",
3057             "soft_limit": "2048m",
3058             "hard_limit": "1024",
3059             "swap_hard_limit": "2.5g",
3060             "min_guarantee": "1 g",
3061         }
3062         domain_mock.setMemoryFlags.return_value = 0
3063         self.assertEqual(
3064             {
3065                 "definition": True,
3066                 "disk": {"attached": [], "detached": [], "updated": []},
3067                 "interface": {"attached": [], "detached": []},
3068                 "mem": True,
3069             },
3070             virt.update("vm_with_memtune_param", mem=memtune_new_val),
3071         )
3072         self.assertEqual(
3073             domain_mock.setMemoryFlags.call_args[0][0], int(2.5 * 1024 ** 2)
3074         )
3075         setxml = ET.fromstring(define_mock.call_args[0][0])
3076         self.assertEqual(
3077             setxml.find("memtune").find("soft_limit").text, str(2048 * 1024)
3078         )
3079         self.assertEqual(
3080             setxml.find("memtune").find("hard_limit").text, str(1024 * 1024)
3081         )
3082         self.assertEqual(
3083             setxml.find("memtune").find("swap_hard_limit").text,
3084             str(int(2.5 * 1024 ** 2)),
3085         )
3086         self.assertEqual(
3087             setxml.find("memtune").find("swap_hard_limit").get("unit"),
3088             "KiB",
3089         )
3090         self.assertEqual(
3091             setxml.find("memtune").find("min_guarantee").text, str(1 * 1024 ** 3)
3092         )
3093         self.assertEqual(
3094             setxml.find("memtune").find("min_guarantee").attrib.get("unit"), "bytes"
3095         )
3096         self.assertEqual(setxml.find("maxMemory").text, str(3096 * 1024 ** 2))
3097         self.assertEqual(setxml.find("maxMemory").attrib.get("slots"), "10")
3098         self.assertEqual(setxml.find("currentMemory").text, str(int(2.5 * 1024 ** 3)))
3099         self.assertEqual(setxml.find("memory").text, str(int(0.7 * 1024 ** 3)))
3100         max_slot_reverse = {
3101             "slots": "10",
3102             "max": "3096m",
3103         }
3104         self.assertEqual(
3105             {
3106                 "definition": True,
3107                 "disk": {"attached": [], "detached": [], "updated": []},
3108                 "interface": {"attached": [], "detached": []},
3109             },
3110             virt.update("vm_with_memtune_param", mem=max_slot_reverse),
3111         )
3112         setxml = ET.fromstring(define_mock.call_args[0][0])
3113         self.assertEqual(setxml.find("maxMemory").text, str(3096 * 1024 ** 2))
3114         self.assertEqual(setxml.find("maxMemory").get("unit"), "bytes")
3115         self.assertEqual(setxml.find("maxMemory").attrib.get("slots"), "10")
3116         max_swap_none = {
3117             "boot": "0.7g",
3118             "current": "2.5g",
3119             "max": None,
3120             "slots": "10",
3121             "soft_limit": "2048m",
3122             "hard_limit": "1024",
3123             "swap_hard_limit": None,
3124             "min_guarantee": "1 g",
3125         }
3126         domain_mock.setMemoryFlags.reset_mock()
3127         self.assertEqual(
3128             {
3129                 "definition": True,
3130                 "disk": {"attached": [], "detached": [], "updated": []},
3131                 "interface": {"attached": [], "detached": []},
3132                 "mem": True,
3133             },
3134             virt.update("vm_with_memtune_param", mem=max_swap_none),
3135         )
3136         self.assertEqual(
3137             domain_mock.setMemoryFlags.call_args[0][0], int(2.5 * 1024 ** 2)
3138         )
3139         setxml = ET.fromstring(define_mock.call_args[0][0])
3140         self.assertEqual(
3141             setxml.find("memtune").find("soft_limit").text, str(2048 * 1024)
3142         )
3143         self.assertEqual(
3144             setxml.find("memtune").find("hard_limit").text, str(1024 * 1024)
3145         )
3146         self.assertEqual(setxml.find("memtune").find("swap_hard_limit"), None)
3147         self.assertEqual(
3148             setxml.find("memtune").find("min_guarantee").text, str(1 * 1024 ** 3)
3149         )
3150         self.assertEqual(
3151             setxml.find("memtune").find("min_guarantee").attrib.get("unit"), "bytes"
3152         )
3153         self.assertEqual(setxml.find("maxMemory").text, None)
3154         self.assertEqual(setxml.find("currentMemory").text, str(int(2.5 * 1024 ** 3)))
3155         self.assertEqual(setxml.find("memory").text, str(int(0.7 * 1024 ** 3)))
3156         memtune_none = {
3157             "soft_limit": None,
3158             "hard_limit": None,
3159             "swap_hard_limit": None,
3160             "min_guarantee": None,
3161         }
3162         self.assertEqual(
3163             {
3164                 "definition": True,
3165                 "disk": {"attached": [], "detached": [], "updated": []},
3166                 "interface": {"attached": [], "detached": []},
3167             },
3168             virt.update("vm_with_memtune_param", mem=memtune_none),
3169         )
3170         setxml = ET.fromstring(define_mock.call_args[0][0])
3171         self.assertEqual(setxml.find("memtune").find("soft_limit"), None)
3172         self.assertEqual(setxml.find("memtune").find("hard_limit"), None)
3173         self.assertEqual(setxml.find("memtune").find("swap_hard_limit"), None)
3174         self.assertEqual(setxml.find("memtune").find("min_guarantee"), None)
3175         max_none = {
3176             "max": None,
3177         }
3178         self.assertEqual(
3179             {
3180                 "definition": True,
3181                 "disk": {"attached": [], "detached": [], "updated": []},
3182                 "interface": {"attached": [], "detached": []},
3183             },
3184             virt.update("vm_with_memtune_param", mem=max_none),
3185         )
3186         setxml = ET.fromstring(define_mock.call_args[0][0])
3187         self.assertEqual(setxml.find("maxMemory"), None)
3188         self.assertEqual(setxml.find("currentMemory").text, str(int(1 * 1024 ** 2)))
3189         self.assertEqual(setxml.find("memory").text, str(int(1 * 1024 ** 2)))
3190     def test_update_exist_memorybacking_params(self):
3191         xml_with_memback_params = """
3192             &lt;domain type='kvm' id='8'&gt;
3193               &lt;name&gt;vm_with_memback_param&lt;/name&gt;
3194               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
3195               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
3196               &lt;maxMemory slots="12" unit="KiB"&gt;1048576&lt;/maxMemory&gt;
3197               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
3198               &lt;memoryBacking&gt;
3199                 &lt;hugepages&gt;
3200                   &lt;page size="2048" unit="KiB"/&gt;
3201                   &lt;page size="3145728" nodeset="1-4,^3" unit="KiB"/&gt;
3202                   &lt;page size="1048576" nodeset="3" unit="KiB"/&gt;
3203                 &lt;/hugepages&gt;
3204                 &lt;nosharepages/&gt;
3205                 &lt;locked/&gt;
3206                 &lt;source type="file"/&gt;
3207                 &lt;access mode="shared"/&gt;
3208                 &lt;discard/&gt;
3209               &lt;/memoryBacking&gt;
3210               &lt;os&gt;
3211                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
3212               &lt;/os&gt;
3213               &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
3214             &lt;/domain&gt;
3215         """
3216         domain_mock = self.set_mock_vm("vm_with_memback_param", xml_with_memback_params)
3217         domain_mock.OSType = MagicMock(return_value="hvm")
3218         define_mock = MagicMock(return_value=True)
3219         self.mock_conn.defineXML = define_mock
3220         mem_back_param = {
3221             "hugepages": [
3222                 {"nodeset": "1-4,^3", "size": "1g"},
3223                 {"nodeset": "3", "size": "2g"},
3224             ],
3225             "nosharepages": None,
3226             "locked": None,
3227             "source": "anonymous",
3228             "access": "private",
3229             "allocation": "ondemand",
3230             "discard": None,
3231         }
3232         self.assertEqual(
3233             {
3234                 "definition": True,
3235                 "disk": {"attached": [], "detached": [], "updated": []},
3236                 "interface": {"attached": [], "detached": []},
3237             },
3238             virt.update("vm_with_memback_param", mem=mem_back_param),
3239         )
3240         setxml = ET.fromstring(define_mock.call_args[0][0])
3241         self.assertDictEqual(
3242             {
3243                 p.get("nodeset"): {"size": p.get("size"), "unit": p.get("unit")}
3244                 for p in setxml.findall("memoryBacking/hugepages/page")
3245             },
3246             {
3247                 "1,2,4": {"size": str(1024 ** 3), "unit": "bytes"},
3248                 "3": {"size": str(2 * 1024 ** 3), "unit": "bytes"},
3249             },
3250         )
3251         self.assertEqual(setxml.find("./memoryBacking/nosharepages"), None)
3252         self.assertEqual(setxml.find("./memoryBacking/locked"), None)
3253         self.assertEqual(
3254             setxml.find("./memoryBacking/source").attrib["type"], "anonymous"
3255         )
3256         self.assertEqual(
3257             setxml.find("./memoryBacking/access").attrib["mode"], "private"
3258         )
3259         self.assertEqual(
3260             setxml.find("./memoryBacking/allocation").attrib["mode"], "ondemand"
3261         )
3262         self.assertEqual(setxml.find("./memoryBacking/discard"), None)
3263         unchanged_page = {
3264             "hugepages": [
3265                 {"size": "2m"},
3266                 {"nodeset": "1-4,^3", "size": "3g"},
3267                 {"nodeset": "3", "size": "1g"},
3268             ],
3269         }
3270         self.assertEqual(
3271             {
3272                 "definition": False,
3273                 "disk": {"attached": [], "detached": [], "updated": []},
3274                 "interface": {"attached": [], "detached": []},
3275             },
3276             virt.update("vm_with_memback_param", mem=unchanged_page),
3277         )
3278     def test_update_iothreads_params(self):
3279         xml_with_iothreads_params = """
3280             &lt;domain type='kvm' id='8'&gt;
3281               &lt;name&gt;xml_with_iothreads_params&lt;/name&gt;
3282               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
3283               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
3284               &lt;maxMemory slots="12" unit="KiB"&gt;1048576&lt;/maxMemory&gt;
3285               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
3286               &lt;iothreads&gt;6&lt;/iothreads&gt;
3287               &lt;os&gt;
3288                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
3289               &lt;/os&gt;
3290             &lt;/domain&gt;
3291         """
3292         domain_mock = self.set_mock_vm(
3293             "xml_with_iothreads_params", xml_with_iothreads_params
3294         )
3295         domain_mock.OSType = MagicMock(return_value="hvm")
3296         define_mock = MagicMock(return_value=True)
3297         self.mock_conn.defineXML = define_mock
3298         self.assertEqual(
3299             {
3300                 "definition": True,
3301                 "disk": {"attached": [], "detached": [], "updated": []},
3302                 "interface": {"attached": [], "detached": []},
3303             },
3304             virt.update("xml_with_iothreads_params", cpu={"iothreads": 7}),
3305         )
3306         setxml = ET.fromstring(define_mock.call_args[0][0])
3307         self.assertEqual(setxml.find("iothreads").text, "7")
3308     def test_update_cputune_paramters(self):
3309         xml_with_cputune_params = """
3310                     &lt;domain type='kvm' id='8'&gt;
3311                       &lt;name&gt;xml_with_cputune_params&lt;/name&gt;
3312                       &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
3313                       &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
3314                       &lt;maxMemory slots="12" unit="KiB"&gt;1048576&lt;/maxMemory&gt;
3315                       &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
3316                       &lt;iothreads&gt;4&lt;/iothreads&gt;
3317                       &lt;cputune&gt;
3318                         &lt;shares&gt;2048&lt;/shares&gt;
3319                         &lt;period&gt;1000000&lt;/period&gt;
3320                         &lt;quota&gt;-1&lt;/quota&gt;
3321                         &lt;global_period&gt;1000000&lt;/global_period&gt;
3322                         &lt;global_quota&gt;-1&lt;/global_quota&gt;
3323                         &lt;emulator_period&gt;1000000&lt;/emulator_period&gt;
3324                         &lt;emulator_quota&gt;-1&lt;/emulator_quota&gt;
3325                         &lt;iothread_period&gt;1000000&lt;/iothread_period&gt;
3326                         &lt;iothread_quota&gt;-1&lt;/iothread_quota&gt;
3327                         &lt;vcpupin vcpu="0" cpuset="0-2"/&gt;
3328                         &lt;vcpupin vcpu="1" cpuset="3"/&gt;
3329                         &lt;vcpupin vcpu="2" cpuset="4"/&gt;
3330                         &lt;vcpupin vcpu="3" cpuset="5-7"/&gt;
3331                         &lt;emulatorpin cpuset="1-2"/&gt;
3332                         &lt;iothreadpin iothread="1" cpuset="1-5"/&gt;
3333                         &lt;iothreadpin iothread="2" cpuset="6-7"/&gt;
3334                         &lt;vcpusched vcpus="0" scheduler="idle" priority="3"/&gt;
3335                         &lt;vcpusched vcpus="1" scheduler="rr" priority="1"/&gt;
3336                         &lt;vcpusched vcpus="2" scheduler="fifo" priority="2"/&gt;
3337                         &lt;iothreadsched iothreads="4" scheduler="fifo"/&gt;
3338                         &lt;emulatorsched scheduler="idle"/&gt;
3339                         &lt;cachetune vcpus="0-4"&gt;
3340                           &lt;cache id="0" level="2" type="both" size="4" unit="KiB"/&gt;
3341                           &lt;cache id="1" level="2" type="both" size="4" unit="KiB"/&gt;
3342                           &lt;monitor level="5" vcpus="0-2"/&gt;
3343                           &lt;monitor level="6" vcpus="1-3"/&gt;
3344                         &lt;/cachetune&gt;
3345                         &lt;cachetune vcpus="5-8"&gt;
3346                           &lt;monitor level="5" vcpus="5-6"/&gt;
3347                           &lt;monitor level="3" vcpus="7-8"/&gt;
3348                         &lt;/cachetune&gt;
3349                         &lt;memorytune vcpus="0-6"&gt;
3350                           &lt;node id="0" bandwidth="45"/&gt;
3351                         &lt;/memorytune&gt;
3352                         &lt;memorytune vcpus="7-8"&gt;
3353                           &lt;node id="0" bandwidth="120"/&gt;
3354                         &lt;/memorytune&gt;
3355                       &lt;/cputune&gt;
3356                       &lt;os&gt;
3357                         &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
3358                       &lt;/os&gt;
3359                     &lt;/domain&gt;
3360                 """
3361         domain_mock = self.set_mock_vm(
3362             "xml_with_cputune_params", xml_with_cputune_params
3363         )
3364         domain_mock.OSType = MagicMock(return_value="hvm")
3365         define_mock = MagicMock(return_value=True)
3366         self.mock_conn.defineXML = define_mock
3367 <a name="5"></a>
3368         cputune = {
3369             <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"shares": 1024,
3370             "period": 5000,
3371             "quota": -20,
3372             "global_period": 4000,
3373             "global_quota": -30,
3374             "emulator_period": 3000,
3375             "emulator_quota": -4,
3376             "iothread_period": 7000,
3377             "iothread_quota": -5,
3378             "vcpupin": {0: "1-4,^2", 1: "0,1", 2: "2,3", 3: "0,4"},
3379             "emulatorpin": "1-3",
3380             "iothreadpin": {1: "5-6", 2: "7-8"},
3381             "vcpusched": [
3382                 {"scheduler": "fifo", "priority": 1, "vcpus": "0"},
3383                 {"scheduler": "fifo", "priority": 2, "vcpus": "1"},
3384                 {"scheduler": "idle", "priority": 3, "vcpus": "2"},
3385             ],
3386             "iothreadsched": [
3387                 {"scheduler": "batch", "iothreads": "5-7", "priority": 1}
3388             ],
3389             "emulatorsched": {"scheduler": "rr", "priority": 2},
3390             "cachetune": {
3391                 "0-3": {
3392                     0: {"level": 3, "type": "both", "size": 3},
3393                     1: {"level": 3, "type": "both", "size": 3},
3394                     "monitor": {1: 3, "0-3": 3},
3395                 },
3396                 "4-5": {"monitor": {4: 3, 5: 2}},
3397             },
3398             "memorytune": {"0-2": {0: 60}, "3-4": {0: 50, 1: 70}},
3399         }
3400         self.assertEqual(
3401             {
3402                 "definition": True,
3403                 "disk": {"attached": [], "detached": [], "updated": []},
3404                 "interface": {"attached": [], "detached": []},
3405             },
3406             virt.</b></font>update("xml_with_cputune_params", cpu={"tuning": cputune}),
3407         )
3408         setxml = ET.fromstring(define_mock.call_args[0][0])
3409         self.assertEqual(setxml.find("cputune").find("shares").text, "1024")
3410         self.assertEqual(setxml.find("cputune").find("period").text, "5000")
3411         self.assertEqual(setxml.find("cputune").find("quota").text, "-20")
3412         self.assertEqual(setxml.find("cputune").find("global_period").text, "4000")
3413         self.assertEqual(setxml.find("cputune").find("global_quota").text, "-30")
3414         self.assertEqual(setxml.find("cputune").find("emulator_period").text, "3000")
3415         self.assertEqual(setxml.find("cputune").find("emulator_quota").text, "-4")
3416         self.assertEqual(setxml.find("cputune").find("iothread_period").text, "7000")
3417         self.assertEqual(setxml.find("cputune").find("iothread_quota").text, "-5")
3418         self.assertEqual(
3419             setxml.find("cputune").find("vcpupin[@vcpu='0']").attrib.get("cpuset"),
3420             "1,3,4",
3421         )
3422         self.assertEqual(
3423             setxml.find("cputune").find("vcpupin[@vcpu='1']").attrib.get("cpuset"),
3424             "0,1",
3425         )
3426         self.assertEqual(
3427             setxml.find("cputune").find("vcpupin[@vcpu='2']").attrib.get("cpuset"),
3428             "2,3",
3429         )
3430         self.assertEqual(
3431             setxml.find("cputune").find("vcpupin[@vcpu='3']").attrib.get("cpuset"),
3432             "0,4",
3433         )
3434         self.assertEqual(
3435             setxml.find("cputune").find("emulatorpin").attrib.get("cpuset"), "1,2,3"
3436         )
3437         self.assertEqual(
3438             setxml.find("cputune")
3439             .find("iothreadpin[@iothread='1']")
3440             .attrib.get("cpuset"),
3441             "5,6",
3442         )
3443         self.assertEqual(
3444             setxml.find("cputune")
3445             .find("iothreadpin[@iothread='2']")
3446             .attrib.get("cpuset"),
3447             "7,8",
3448         )
3449         self.assertDictEqual(
3450             {
3451                 s.get("vcpus"): {
3452 <a name="22"></a>                    "scheduler": s.get("scheduler"),
3453                     "priority": s.get("priority"),
3454                 }
3455                 for s in setxml<font color="#4cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.findall("cputune/vcpusched")
3456             },
3457             {
3458                 "0": {"scheduler": "fifo", "priority": "1"},
3459                 "1": {"scheduler": "fifo", "priority": "2"},
3460                 "2": {"scheduler": "idle", "priority": "3"},
3461             },
3462         )
3463         self.assertDictEqual(
3464             {
3465                 s.get("iothreads"): {
3466                     "scheduler": s.</b></font>get("scheduler"),
3467                     "priority": s.get("priority"),
3468                 }
3469                 for s in setxml.findall("cputune/iothreadsched")
3470             },
3471             {"5,6,7": {"scheduler": "batch", "priority": "1"}},
3472         )
3473         self.assertEqual(setxml.find("cputune/emulatorsched").get("scheduler"), "rr")
3474         self.assertEqual(setxml.find("cputune/emulatorsched").get("priority"), "2")
3475         self.assertIsNotNone(setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']"))
3476         self.assertEqual(
3477             setxml.find(
3478                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3479             ).attrib.get("level"),
3480             "3",
3481         )
3482         self.assertEqual(
3483             setxml.find(
3484                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3485             ).attrib.get("type"),
3486             "both",
3487         )
3488         self.assertEqual(
3489             setxml.find(
3490                 "./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='1']"
3491             ).attrib.get("level"),
3492             "3",
3493         )
3494         self.assertNotEqual(
3495             setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='1']"),
3496             None,
3497         )
3498         self.assertNotEqual(
3499             setxml.find("./cputune/cachetune[@vcpus='4,5']").attrib.get("vcpus"), None
3500         )
3501         self.assertEqual(
3502             setxml.find("./cputune/cachetune[@vcpus='4,5']/cache[@id='0']"), None
3503         )
3504         self.assertEqual(
3505             setxml.find(
3506                 "./cputune/cachetune[@vcpus='4,5']/monitor[@vcpus='4']"
3507             ).attrib.get("level"),
3508             "3",
3509         )
3510         self.assertEqual(
3511             setxml.find(
3512                 "./cputune/cachetune[@vcpus='4,5']/monitor[@vcpus='5']"
3513             ).attrib.get("level"),
3514             "2",
3515         )
3516         self.assertNotEqual(setxml.find("./cputune/memorytune[@vcpus='0,1,2']"), None)
3517         self.assertEqual(
3518             setxml.find(
3519                 "./cputune/memorytune[@vcpus='0,1,2']/node[@id='0']"
3520             ).attrib.get("bandwidth"),
3521             "60",
3522         )
3523         self.assertNotEqual(setxml.find("./cputune/memorytune[@vcpus='3,4']"), None)
3524         self.assertEqual(
3525             setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='0']").attrib.get(
3526                 "bandwidth"
3527             ),
3528             "50",
3529         )
3530         self.assertEqual(
3531             setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='1']").attrib.get(
3532                 "bandwidth"
3533             ),
3534             "70",
3535         )
3536 <a name="13"></a>
3537         cputune = {
3538             <font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"shares": None,
3539             "period": 20000,
3540             "quota": None,
3541             "global_period": 5000,
3542             "global_quota": None,
3543             "emulator_period": 2000,
3544             "emulator_quota": -4,
3545             "iothread_period": None,
3546             "iothread_quota": -5,
3547             "vcpupin": {0: "1-4,^2", 2: "2,4"},
3548             "emulatorpin": None,
3549             "iothreadpin": {1: "5-6"},
3550             "vcpusched": [{"scheduler": "idle", "priority": 5, "vcpus": "1"}],
3551             "iothreadsched": None,
3552             "cachetune": {
3553                 "0-3": {
3554                     0: {"level": 4, "type": "data", "size": 7},
3555                     "monitor": {"1-2": 11},
3556                 },
3557             },
3558             "memorytune": {"3-4": {0: 37, 1: 73}},
3559         }
3560         self.assertEqual(
3561             {
3562                 "definition": True,
3563                 "disk": {"attached": [], "detached": [], "updated": []},
3564                 "interface": {"attached": [], "detached": []},
3565             },
3566             virt.</b></font>update("xml_with_cputune_params", cpu={"tuning": cputune}),
3567         )
3568         setxml = ET.fromstring(define_mock.call_args[0][0])
3569         self.assertEqual(setxml.find("cputune").find("shares"), None)
3570         self.assertEqual(setxml.find("cputune").find("period").text, "20000")
3571         self.assertEqual(setxml.find("cputune").find("quota"), None)
3572         self.assertEqual(setxml.find("cputune").find("global_period").text, "5000")
3573         self.assertEqual(setxml.find("cputune").find("global_quota"), None)
3574         self.assertEqual(setxml.find("cputune").find("emulator_period").text, "2000")
3575         self.assertEqual(setxml.find("cputune").find("emulator_quota").text, "-4")
3576         self.assertEqual(setxml.find("cputune").find("iothread_period"), None)
3577         self.assertEqual(setxml.find("cputune").find("iothread_quota").text, "-5")
3578         self.assertEqual(
3579             setxml.find("cputune").find("vcpupin[@vcpu='0']").attrib.get("cpuset"),
3580             "1,3,4",
3581         )
3582         self.assertEqual(setxml.find("cputune").find("vcpupin[@vcpu='1']"), None)
3583         self.assertEqual(
3584             setxml.find("cputune").find("vcpupin[@vcpu='2']").attrib.get("cpuset"),
3585             "2,4",
3586         )
3587         self.assertEqual(setxml.find("cputune").find("vcpupin[@vcpu='3']"), None)
3588         self.assertEqual(setxml.find("cputune").find("emulatorpin"), None)
3589         self.assertEqual(
3590             setxml.find("cputune")
3591             .find("iothreadpin[@iothread='1']")
3592             .attrib.get("cpuset"),
3593             "5,6",
3594         )
3595         self.assertEqual(
3596             setxml.find("cputune").find("iothreadpin[@iothread='2']"), None
3597         )
3598         self.assertDictEqual(
3599             {
3600                 s.get("vcpus"): {
3601                     "scheduler": s.get("scheduler"),
3602                     "priority": s.get("priority"),
3603                 }
3604                 for s in setxml.findall("cputune/vcpusched")
3605             },
3606             {"1": {"scheduler": "idle", "priority": "5"}},
3607         )
3608         self.assertEqual(setxml.find("cputune").find("iothreadsched"), None)
3609         self.assertIsNotNone(setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']"))
3610         self.assertEqual(
3611             setxml.find(
3612                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3613             ).attrib.get("size"),
3614             "7",
3615         )
3616         self.assertEqual(
3617             setxml.find(
3618                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3619             ).attrib.get("level"),
3620             "4",
3621         )
3622         self.assertEqual(
3623             setxml.find(
3624                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3625             ).attrib.get("type"),
3626             "data",
3627         )
3628         self.assertEqual(
3629             setxml.find(
3630                 "./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='1,2']"
3631             ).attrib.get("level"),
3632             "11",
3633         )
3634         self.assertEqual(
3635             setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='3,4']"),
3636             None,
3637         )
3638         self.assertEqual(
3639             setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='1']"), None
3640         )
3641         self.assertEqual(setxml.find("./cputune/cachetune[@vcpus='4,5']"), None)
3642         self.assertEqual(setxml.find("./cputune/memorytune[@vcpus='0,1,2']"), None)
3643         self.assertEqual(
3644             setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='0']").attrib.get(
3645                 "bandwidth"
3646             ),
3647             "37",
3648         )
3649         self.assertEqual(
3650             setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='1']").attrib.get(
3651                 "bandwidth"
3652             ),
3653             "73",
3654         )
3655         cputune_subelement = {
3656             "vcpupin": None,
3657             "iothreadpin": None,
3658             "vcpusched": None,
3659             "iothreadsched": None,
3660             "cachetune": None,
3661             "memorytune": None,
3662         }
3663         self.assertEqual(
3664             {
3665                 "definition": True,
3666                 "disk": {"attached": [], "detached": [], "updated": []},
3667                 "interface": {"attached": [], "detached": []},
3668             },
3669             virt.update("xml_with_cputune_params", cpu={"tuning": cputune_subelement}),
3670         )
3671         setxml = ET.fromstring(define_mock.call_args[0][0])
3672         self.assertEqual(setxml.find("cputune").find("vcpupin"), None)
3673         self.assertEqual(setxml.find("cputune").find("iothreadpin"), None)
3674         self.assertEqual(setxml.find("cputune").find("vcpusched"), None)
3675         self.assertEqual(setxml.find("cputune").find("iothreadsched"), None)
3676         self.assertEqual(setxml.find("cputune").find("cachetune"), None)
3677         self.assertEqual(setxml.find("cputune").find("memorytune"), None)
3678     def test_handle_unit(self):
3679         valid_case = [
3680             ("2", 2097152),
3681             ("42", 44040192),
3682             ("5b", 5),
3683             ("2.3Kib", 2355),
3684             ("5.8Kb", 5800),
3685             ("16MiB", 16777216),
3686             ("20 GB", 20000000000),
3687             ("16KB", 16000),
3688             (".5k", 512),
3689             ("2.k", 2048),
3690         ]
3691         for key, val in valid_case:
3692             self.assertEqual(virt._handle_unit(key), val)
3693         invalid_case = [
3694             ("9ib", "invalid units"),
3695             ("8byte", "invalid units"),
3696             ("512bytes", "invalid units"),
3697             ("4 Kbytes", "invalid units"),
3698             ("3.4.MB", "invalid number"),
3699             ("", "invalid number"),
3700             ("bytes", "invalid number"),
3701             ("2HB", "invalid units"),
3702         ]
3703         for key, val in invalid_case:
3704             with self.assertRaises(SaltInvocationError):
3705                 virt._handle_unit(key)
3706     def test_mixed_dict_and_list_as_profile_objects(self):
3707         yaml_config = """
3708           virt:
3709              nic:
3710                 new-listonly-profile:
3711                    - bridge: br0
3712                      name: eth0
3713                    - model: virtio
3714                      name: eth1
3715                      source: test_network
3716                      type: network
3717                 new-list-with-legacy-names:
3718                    - eth0:
3719                         bridge: br0
3720                    - eth1:
3721                         bridge: br1
3722                         model: virtio
3723                 non-default-legacy-profile:
3724                    eth0:
3725                       bridge: br0
3726                    eth1:
3727                       bridge: br1
3728                       model: virtio
3729         Test virt.get_xml()
3730         domain = self.set_mock_vm("test-vm", xml)
3731         self.assertEqual(xml, virt.get_xml("test-vm"))
3732         self.assertEqual(xml, virt.get_xml(domain))
3733     def test_get_loader(self):
3734         xml = """&lt;domain type='kvm' id='7'&gt;
3735               &lt;name&gt;test-vm&lt;/name&gt;
3736               &lt;os&gt;
3737                 &lt;loader readonly='yes' type='pflash'&gt;/foo/bar&lt;/loader&gt;
3738               &lt;/os&gt;
3739             &lt;/domain&gt;
3740         """
3741         self.set_mock_vm("test-vm", xml)
3742         loader = virt.get_loader("test-vm")
3743         self.assertEqual("/foo/bar", loader["path"])
3744         self.assertEqual("yes", loader["readonly"])
3745     def test_cpu_baseline(self):
3746         capabilities_xml = dedent(
3747         Make sure that qemu-img info output is properly parsed
3748         Test virt.purge() with default parameters
3749         self.set_mock_vm("test-vm", xml)
3750         qemu_infos = """[{
3751             "virtual-size": 25769803776,
3752             "filename": "/disks/test.qcow2",
3753             "cluster-size": 65536,
3754             "format": "qcow2",
3755             "actual-size": 217088,
3756             "format-specific": {
3757                 "type": "qcow2",
3758                 "data": {
3759                     "compat": "1.1",
3760                     "lazy-refcounts": false,
3761                     "refcount-bits": 16,
3762                     "corrupt": false
3763                 }
3764             },
3765             "dirty-flag": false
3766         }]"""
3767         self.mock_popen.communicate.return_value = [qemu_infos, ""]
3768         self.mock_popen.returncode = 0
3769         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
3770             res = virt.purge("test-vm")
3771             self.assertTrue(res)
3772             mock_remove.assert_called_once()
3773             mock_remove.assert_any_call("/disks/test.qcow2")
3774     @patch("salt.modules.virt.stop", return_value=True)
3775     @patch("salt.modules.virt.undefine")
3776     def test_purge_volumes(self, mock_undefine, mock_stop):
3777         xml = """&lt;domain type='kvm' id='7'&gt;
3778               &lt;name&gt;test-vm&lt;/name&gt;
3779               &lt;devices&gt;
3780                 &lt;disk type='volume' device='disk'&gt;
3781                   &lt;driver name='qemu' type='qcow2' cache='none' io='native'/&gt;
3782                   &lt;source pool='default' volume='vm05_system'/&gt;
3783                   &lt;backingStore type='file' index='1'&gt;
3784                     &lt;format type='qcow2'/&gt;
3785                     &lt;source file='/var/lib/libvirt/images/vm04_system.qcow2'/&gt;
3786                     &lt;backingStore type='file' index='2'&gt;
3787                       &lt;format type='qcow2'/&gt;
3788                       &lt;source file='/var/testsuite-data/disk-image-template.qcow2'/&gt;
3789                       &lt;backingStore/&gt;
3790                     &lt;/backingStore&gt;
3791                   &lt;/backingStore&gt;
3792                   &lt;target dev='vda' bus='virtio'/&gt;
3793                   &lt;alias name='virtio-disk0'/&gt;
3794                   &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x04' function='0x0'/&gt;
3795                 &lt;/disk&gt;
3796               &lt;/devices&gt;
3797             &lt;/domain&gt;
3798         """
3799         self.set_mock_vm("test-vm", xml)
3800         pool_mock = MagicMock()
3801         pool_mock.storageVolLookupByName.return_value.info.return_value = [
3802             0,
3803             1234567,
3804             12345,
3805         ]
3806         pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = [
3807         ]
3808         pool_mock.listVolumes.return_value = ["vm05_system", "vm04_system.qcow2"]
3809         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
3810         self.mock_conn.listStoragePools.return_value = ["default"]
3811         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=False)}):
3812             res = virt.purge("test-vm")
3813             self.assertTrue(res)
3814             pool_mock.storageVolLookupByName.return_value.delete.assert_called_once()
3815     @patch("salt.modules.virt.stop", return_value=True)
3816     @patch("salt.modules.virt.undefine")
3817     def test_purge_rbd(self, mock_undefine, mock_stop):
3818         xml = """&lt;domain type='kvm' id='7'&gt;
3819               &lt;name&gt;test-vm&lt;/name&gt;
3820               &lt;devices&gt;
3821                 &lt;disk type="network" device="disk"&gt;
3822                   &lt;driver name='raw' type='qcow2'/&gt;
3823                   &lt;source protocol='rbd' name='libvirt-pool/my_vm_data2'&gt;
3824                     &lt;host name='ses2.tf.local'/&gt;
3825                     &lt;host name='ses3.tf.local' port='1234'/&gt;
3826                     &lt;auth username='libvirt'&gt;
3827                       &lt;secret type='ceph' usage='pool_test-rbd'/&gt;
3828                     &lt;/auth&gt;
3829                   &lt;/source&gt;
3830                   &lt;target dev='vdc' bus='virtio'/&gt;
3831                   &lt;alias name='virtio-disk2'/&gt;
3832                   &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x07' function='0x2'/&gt;
3833                 &lt;/disk&gt;
3834               &lt;/devices&gt;
3835             &lt;/domain&gt;
3836         """
3837         self.set_mock_vm("test-vm", xml)
3838         pool_mock = MagicMock()
3839         pool_mock.storageVolLookupByName.return_value.info.return_value = [
3840             0,
3841             1234567,
3842             12345,
3843         ]
3844         pool_mock.XMLDesc.return_value = """
3845         &lt;pool type='rbd'&gt;
3846           &lt;name&gt;test-ses&lt;/name&gt;
3847           &lt;source&gt;
3848             &lt;host name='ses2.tf.local'/&gt;
3849             &lt;name&gt;libvirt-pool&lt;/name&gt;
3850             &lt;auth type='ceph' username='libvirt'&gt;
3851               &lt;secret usage='pool_test-ses'/&gt;
3852             &lt;/auth&gt;
3853           &lt;/source&gt;
3854         &lt;/pool&gt;
3855         """
3856         pool_mock.name.return_value = "test-ses"
3857         pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = [
3858         ]
3859         pool_mock.listVolumes.return_value = ["my_vm_data2"]
3860         self.mock_conn.listAllStoragePools.return_value = [pool_mock]
3861         self.mock_conn.listStoragePools.return_value = ["test-ses"]
3862         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
3863         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=False)}):
3864             res = virt.purge("test-vm")
3865             self.assertTrue(res)
3866             pool_mock.storageVolLookupByName.return_value.delete.assert_called_once()
3867     @patch("salt.modules.virt.stop", return_value=True)
3868     @patch("salt.modules.virt.undefine")
3869     @patch("os.remove")
3870     def test_purge_removable(self, mock_remove, mock_undefine, mock_stop):
3871         xml = """&lt;domain type="kvm" id="7"&gt;
3872               &lt;name&gt;test-vm&lt;/name&gt;
3873               &lt;devices&gt;
3874                 &lt;disk type='file' device='disk'&gt;
3875                 &lt;driver name='qemu' type='qcow2'/&gt;
3876                 &lt;source file='/disks/test.qcow2'/&gt;
3877                 &lt;target dev='vda' bus='virtio'/&gt;
3878               &lt;/disk&gt;
3879               &lt;disk type='file' device='cdrom'&gt;
3880                 &lt;driver name='qemu' type='raw'/&gt;
3881                 &lt;source file='/disks/test-cdrom.iso'/&gt;
3882                 &lt;target dev='hda' bus='ide'/&gt;
3883                 &lt;readonly/&gt;
3884               &lt;/disk&gt;
3885               &lt;disk type='file' device='floppy'&gt;
3886                 &lt;driver name='qemu' type='raw'/&gt;
3887                 &lt;source file='/disks/test-floppy.iso'/&gt;
3888                 &lt;target dev='hdb' bus='ide'/&gt;
3889                 &lt;readonly/&gt;
3890               &lt;/disk&gt;
3891               &lt;/devices&gt;
3892             &lt;/domain&gt;
3893         """
3894         self.set_mock_vm("test-vm", xml)
3895         qemu_infos = """[{
3896             "virtual-size": 25769803776,
3897             "filename": "/disks/test.qcow2",
3898             "cluster-size": 65536,
3899             "format": "qcow2",
3900             "actual-size": 217088,
3901             "format-specific": {
3902                 "type": "qcow2",
3903                 "data": {
3904                     "compat": "1.1",
3905                     "lazy-refcounts": false,
3906                     "refcount-bits": 16,
3907                     "corrupt": false
3908                 }
3909             },
3910             "dirty-flag": false
3911         }]"""
3912         self.mock_popen.communicate.return_value = [qemu_infos, ""]
3913         self.mock_popen.returncode = 0
3914         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
3915             res = virt.purge("test-vm", removables=True)
3916             self.assertTrue(res)
3917             mock_remove.assert_any_call("/disks/test.qcow2")
3918             mock_remove.assert_any_call("/disks/test-cdrom.iso")
3919     def test_capabilities(self):
3920         xml = """
3921 &lt;capabilities&gt;
3922   &lt;host&gt;
3923     &lt;uuid&gt;44454c4c-3400-105a-8033-b3c04f4b344a&lt;/uuid&gt;
3924     &lt;cpu&gt;
3925       &lt;arch&gt;x86_64&lt;/arch&gt;
3926       &lt;model&gt;Nehalem&lt;/model&gt;
3927       &lt;vendor&gt;Intel&lt;/vendor&gt;
3928       &lt;microcode version='25'/&gt;
3929       &lt;topology sockets='1' cores='4' threads='2'/&gt;
3930       &lt;feature name='vme'/&gt;
3931       &lt;feature name='ds'/&gt;
3932       &lt;feature name='acpi'/&gt;
3933       &lt;pages unit='KiB' size='4'/&gt;
3934       &lt;pages unit='KiB' size='2048'/&gt;
3935     &lt;/cpu&gt;
3936     &lt;power_management&gt;
3937       &lt;suspend_mem/&gt;
3938       &lt;suspend_disk/&gt;
3939       &lt;suspend_hybrid/&gt;
3940     &lt;/power_management&gt;
3941     &lt;migration_features&gt;
3942       &lt;live/&gt;
3943       &lt;uri_transports&gt;
3944         &lt;uri_transport&gt;tcp&lt;/uri_transport&gt;
3945         &lt;uri_transport&gt;rdma&lt;/uri_transport&gt;
3946       &lt;/uri_transports&gt;
3947     &lt;/migration_features&gt;
3948     &lt;topology&gt;
3949       &lt;cells num='1'&gt;
3950         &lt;cell id='0'&gt;
3951           &lt;memory unit='KiB'&gt;12367120&lt;/memory&gt;
3952           &lt;pages unit='KiB' size='4'&gt;3091780&lt;/pages&gt;
3953           &lt;pages unit='KiB' size='2048'&gt;0&lt;/pages&gt;
3954           &lt;distances&gt;
3955             &lt;sibling id='0' value='10'/&gt;
3956           &lt;/distances&gt;
3957           &lt;cpus num='8'&gt;
3958             &lt;cpu id='0' socket_id='0' core_id='0' siblings='0,4'/&gt;
3959             &lt;cpu id='1' socket_id='0' core_id='1' siblings='1,5'/&gt;
3960             &lt;cpu id='2' socket_id='0' core_id='2' siblings='2,6'/&gt;
3961             &lt;cpu id='3' socket_id='0' core_id='3' siblings='3,7'/&gt;
3962             &lt;cpu id='4' socket_id='0' core_id='0' siblings='0,4'/&gt;
3963             &lt;cpu id='5' socket_id='0' core_id='1' siblings='1,5'/&gt;
3964             &lt;cpu id='6' socket_id='0' core_id='2' siblings='2,6'/&gt;
3965             &lt;cpu id='7' socket_id='0' core_id='3' siblings='3,7'/&gt;
3966           &lt;/cpus&gt;
3967         &lt;/cell&gt;
3968       &lt;/cells&gt;
3969     &lt;/topology&gt;
3970     &lt;cache&gt;
3971       &lt;bank id='0' level='3' type='both' size='8' unit='MiB' cpus='0-7'/&gt;
3972     &lt;/cache&gt;
3973     &lt;secmodel&gt;
3974       &lt;model&gt;apparmor&lt;/model&gt;
3975       &lt;doi&gt;0&lt;/doi&gt;
3976     &lt;/secmodel&gt;
3977     &lt;secmodel&gt;
3978       &lt;model&gt;dac&lt;/model&gt;
3979       &lt;doi&gt;0&lt;/doi&gt;
3980       &lt;baselabel type='kvm'&gt;+487:+486&lt;/baselabel&gt;
3981       &lt;baselabel type='qemu'&gt;+487:+486&lt;/baselabel&gt;
3982     &lt;/secmodel&gt;
3983   &lt;/host&gt;
3984   &lt;guest&gt;
3985     &lt;os_type&gt;hvm&lt;/os_type&gt;
3986     &lt;arch name='i686'&gt;
3987       &lt;wordsize&gt;32&lt;/wordsize&gt;
3988       &lt;emulator&gt;/usr/bin/qemu-system-i386&lt;/emulator&gt;
3989       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
3990       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
3991       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
3992       &lt;domain type='qemu'/&gt;
3993       &lt;domain type='kvm'&gt;
3994         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
3995         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
3996         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
3997         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
3998       &lt;/domain&gt;
3999     &lt;/arch&gt;
4000     &lt;features&gt;
4001       &lt;cpuselection/&gt;
4002       &lt;deviceboot/&gt;
4003       &lt;disksnapshot default='on' toggle='no'/&gt;
4004       &lt;acpi default='off' toggle='yes'/&gt;
4005       &lt;apic default='on' toggle='no'/&gt;
4006       &lt;pae/&gt;
4007       &lt;nonpae/&gt;
4008     &lt;/features&gt;
4009   &lt;/guest&gt;
4010   &lt;guest&gt;
4011     &lt;os_type&gt;hvm&lt;/os_type&gt;
4012     &lt;arch name='x86_64'&gt;
4013       &lt;wordsize&gt;64&lt;/wordsize&gt;
4014       &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
4015       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
4016       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
4017       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
4018       &lt;domain type='qemu'/&gt;
4019       &lt;domain type='kvm'&gt;
4020         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
4021         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
4022         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
4023         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
4024       &lt;/domain&gt;
4025     &lt;/arch&gt;
4026     &lt;features&gt;
4027       &lt;cpuselection/&gt;
4028       &lt;deviceboot/&gt;
4029       &lt;disksnapshot default='on' toggle='no'/&gt;
4030       &lt;acpi default='on' toggle='yes'/&gt;
4031       &lt;apic default='off' toggle='no'/&gt;
4032     &lt;/features&gt;
4033   &lt;/guest&gt;
4034   &lt;guest&gt;
4035     &lt;os_type&gt;xen&lt;/os_type&gt;
4036     &lt;arch name='x86_64'&gt;
4037       &lt;wordsize&gt;64&lt;/wordsize&gt;
4038       &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
4039       &lt;machine&gt;xenpv&lt;/machine&gt;
4040       &lt;domain type='xen'/&gt;
4041     &lt;/arch&gt;
4042   &lt;/guest&gt;
4043 &lt;/capabilities&gt;
4044         """
4045         self.mock_conn.getCapabilities.return_value = xml  # pylint: disable=no-member
4046 <a name="0"></a>        caps = virt.capabilities()
4047         expected = {
4048             <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"host": {
4049                 "uuid": "44454c4c-3400-105a-8033-b3c04f4b344a",
4050                 "cpu": {
4051                     "arch": "x86_64",
4052                     "model": "Nehalem",
4053                     "vendor": "Intel",
4054                     "microcode": "25",
4055                     "sockets": 1,
4056                     "cores": 4,
4057                     "threads": 2,
4058                     "features": ["vme", "ds", "acpi"],
4059                     "pages": [{"size": "4 KiB"}, {"size": "2048 KiB"}],
4060                 },
4061                 "power_management": ["suspend_mem", "suspend_disk", "suspend_hybrid"],
4062                 "migration": {"live": True, "transports": ["tcp", "rdma"]},
4063                 "topology": {
4064                     "cells": [
4065                         {
4066                             "id": 0,
4067                             "memory": "12367120 KiB",
4068                             "pages": [
4069                                 {"size": "4 KiB", "available": 3091780},
4070                                 {"size": "2048 KiB", "available": 0},
4071                             ],
4072                             "distances": {0: 10},
4073                             "cpus": [
4074                                 {
4075                                     "id": 0,
4076                                     "socket_id": 0,
4077                                     "core_id": 0,
4078                                     "siblings": "0,4",
4079                                 },
4080                                 {
4081                                     "id": 1,
4082                                     "socket_id": 0,
4083                                     "core_id": 1,
4084                                     "siblings": "1,5",
4085                                 },
4086                                 {
4087                                     "id": 2,
4088                                     "socket_id": 0,
4089                                     "core_id": 2,
4090                                     "siblings": "2,6",
4091                                 },
4092                                 {
4093                                     "id": 3,
4094                                     "socket_id": 0,
4095                                     "core_id": 3,
4096                                     "siblings": "3,7",
4097                                 },
4098                                 {
4099                                     "id": 4,
4100                                     "socket_id": 0,
4101                                     "core_id": 0,
4102                                     "siblings": "0,4",
4103                                 },
4104                                 {
4105                                     "id": 5,
4106                                     "socket_id": 0,
4107                                     "core_id": 1,
4108                                     "siblings": "1,5",
4109                                 },
4110                                 {
4111                                     "id": 6,
4112                                     "socket_id": 0,
4113                                     "core_id": 2,
4114                                     "siblings": "2,6",
4115                                 },
4116                                 {
4117                                     "id": 7,
4118                                     "socket_id": 0,
4119                                     "core_id": 3,
4120                                     "siblings": "3,7",
4121                                 },
4122                             ],
4123                         }
4124                     ]
4125                 },
4126                 "cache": {
4127                     "banks": [
4128                         {
4129                             "id": 0,
4130                             "level": 3,
4131                             "type": "both",
4132                             "size": "8 MiB",
4133                             "cpus": "0-7",
4134                         }
4135                     ]
4136                 },
4137                 "security": [
4138                     {"model": "apparmor", "doi": "0", "baselabels": []},
4139                     {
4140                         "model": "dac",
4141                         "doi": "0",
4142                         "baselabels": [
4143                             {"type": "kvm", "label": "+487:+486"},
4144                             {"type": "qemu", "label": "+487:+486"},
4145                         ],
4146                     },
4147                 ],
4148             },
4149             "guests": [
4150                 {
4151                     "os_type": "hvm",
4152                     "arch": {
4153                         "name": "i686",
4154                         "wordsize": 32,
4155                         "emulator": "/usr/bin/qemu-system-i386",
4156                         "machines": {
4157                             "pc-i440fx-2.6": {
4158                                 "maxcpus": 255,
4159                                 "alternate_names": ["pc"],
4160                             },
4161                             "pc-0.12": {"maxcpus": 255, "alternate_names": []},
4162                         },
4163                         "domains": {
4164                             "qemu": {"emulator": None, "machines": {}},
4165                             "kvm": {
4166                                 "emulator": "/usr/bin/qemu-kvm",
4167                                 "machines": {
4168                                     "pc-i440fx-2.6": {
4169                                         "maxcpus": 255,
4170                                         "alternate_names": ["pc"],
4171                                     },
4172                                     "pc-0.12": {"maxcpus": 255, "alternate_names": []},
4173                                 },
4174                             },
4175                         },
4176                     },
4177                     "features": {
4178                         "cpuselection": {"default": True, "toggle": False},
4179                         "deviceboot": {"default": True, "toggle": False},
4180                         "disksnapshot": {"default": True, "toggle": False},
4181                         "acpi": {"default": False, "toggle": True},
4182                         "apic": {"default": True, "toggle": False},
4183                         "pae": {"default": True, "toggle": False},
4184                         "nonpae": {"default": True, "toggle": False},
4185                     },
4186                 },
4187                 {
4188                     "os_type": "hvm",
4189                     "arch": {
4190                         "name": "x86_64",
4191                         "wordsize": 64,
4192                         "emulator": "/usr/bin/qemu-system-x86_64",
4193                         "machines": {
4194                             "pc-i440fx-2.6": {
4195                                 "maxcpus": 255,
4196                                 "alternate_names": ["pc"],
4197                             },
4198                             "pc-0.12": {"maxcpus": 255, "alternate_names": []},
4199                         },
4200                         "domains": {
4201                             "qemu": {"emulator": None, "machines": {}},
4202                             "kvm": {
4203                                 "emulator": "/usr/bin/qemu-kvm",
4204                                 "machines": {
4205                                     "pc-i440fx-2.6": {
4206                                         "maxcpus": 255,
4207                                         "alternate_names": ["pc"],
4208                                     },
4209                                     "pc-0.12": {"maxcpus": 255, "alternate_names": []},
4210                                 },
4211                             },
4212                         },
4213                     },
4214                     "features": {
4215                         "cpuselection": {"default": True, "toggle": False},
4216                         "deviceboot": {"default": True, "toggle": False},
4217                         "disksnapshot": {"default": True, "toggle": False},
4218                         "acpi": {"default": True, "toggle": True},
4219                         "apic": {"default": False, "toggle": False},
4220                     },
4221                 },
4222                 {
4223                     "os_type": "xen",
4224                     "arch": {
4225                         "name": "x86_64",
4226                         "wordsize": 64,
4227                         "emulator": "/usr/bin/qemu-system-x86_64",
4228                         "machines": {"xenpv": {"alternate_names": []}},
4229                         "domains": {"xen": {"emulator": None, "machines": {}}},
4230                     },
4231                 },
4232             ],
4233         }
4234         self.assertEqual(</b></font>expected, caps)
4235     def test_domain_capabilities(self):
4236         xml = """
4237 &lt;domainCapabilities&gt;
4238   &lt;path&gt;/usr/bin/qemu-system-aarch64&lt;/path&gt;
4239   &lt;domain&gt;kvm&lt;/domain&gt;
4240   &lt;machine&gt;virt-2.12&lt;/machine&gt;
4241   &lt;arch&gt;aarch64&lt;/arch&gt;
4242   &lt;vcpu max='255'/&gt;
4243   &lt;iothreads supported='yes'/&gt;
4244   &lt;os supported='yes'&gt;
4245     &lt;loader supported='yes'&gt;
4246       &lt;value&gt;/usr/share/AAVMF/AAVMF_CODE.fd&lt;/value&gt;
4247       &lt;value&gt;/usr/share/AAVMF/AAVMF32_CODE.fd&lt;/value&gt;
4248       &lt;value&gt;/usr/share/OVMF/OVMF_CODE.fd&lt;/value&gt;
4249       &lt;enum name='type'&gt;
4250         &lt;value&gt;rom&lt;/value&gt;
4251         &lt;value&gt;pflash&lt;/value&gt;
4252       &lt;/enum&gt;
4253       &lt;enum name='readonly'&gt;
4254         &lt;value&gt;yes&lt;/value&gt;
4255         &lt;value&gt;no&lt;/value&gt;
4256       &lt;/enum&gt;
4257     &lt;/loader&gt;
4258   &lt;/os&gt;
4259   &lt;cpu&gt;
4260     &lt;mode name='host-passthrough' supported='yes'/&gt;
4261     &lt;mode name='host-model' supported='yes'&gt;
4262       &lt;model fallback='forbid'&gt;sample-cpu&lt;/model&gt;
4263       &lt;vendor&gt;ACME&lt;/vendor&gt;
4264       &lt;feature policy='require' name='vme'/&gt;
4265       &lt;feature policy='require' name='ss'/&gt;
4266     &lt;/mode&gt;
4267     &lt;mode name='custom' supported='yes'&gt;
4268       &lt;model usable='unknown'&gt;pxa262&lt;/model&gt;
4269       &lt;model usable='yes'&gt;pxa270-a0&lt;/model&gt;
4270       &lt;model usable='no'&gt;arm1136&lt;/model&gt;
4271     &lt;/mode&gt;
4272   &lt;/cpu&gt;
4273   &lt;devices&gt;
4274     &lt;disk supported='yes'&gt;
4275       &lt;enum name='diskDevice'&gt;
4276         &lt;value&gt;disk&lt;/value&gt;
4277         &lt;value&gt;cdrom&lt;/value&gt;
4278         &lt;value&gt;floppy&lt;/value&gt;
4279         &lt;value&gt;lun&lt;/value&gt;
4280       &lt;/enum&gt;
4281       &lt;enum name='bus'&gt;
4282         &lt;value&gt;fdc&lt;/value&gt;
4283         &lt;value&gt;scsi&lt;/value&gt;
4284         &lt;value&gt;virtio&lt;/value&gt;
4285         &lt;value&gt;usb&lt;/value&gt;
4286         &lt;value&gt;sata&lt;/value&gt;
4287       &lt;/enum&gt;
4288     &lt;/disk&gt;
4289     &lt;graphics supported='yes'&gt;
4290       &lt;enum name='type'&gt;
4291         &lt;value&gt;sdl&lt;/value&gt;
4292         &lt;value&gt;vnc&lt;/value&gt;
4293       &lt;/enum&gt;
4294     &lt;/graphics&gt;
4295     &lt;video supported='yes'&gt;
4296       &lt;enum name='modelType'&gt;
4297         &lt;value&gt;vga&lt;/value&gt;
4298         &lt;value&gt;virtio&lt;/value&gt;
4299       &lt;/enum&gt;
4300     &lt;/video&gt;
4301     &lt;hostdev supported='yes'&gt;
4302       &lt;enum name='mode'&gt;
4303         &lt;value&gt;subsystem&lt;/value&gt;
4304       &lt;/enum&gt;
4305       &lt;enum name='startupPolicy'&gt;
4306         &lt;value&gt;default&lt;/value&gt;
4307         &lt;value&gt;mandatory&lt;/value&gt;
4308         &lt;value&gt;requisite&lt;/value&gt;
4309         &lt;value&gt;optional&lt;/value&gt;
4310       &lt;/enum&gt;
4311       &lt;enum name='subsysType'&gt;
4312         &lt;value&gt;usb&lt;/value&gt;
4313         &lt;value&gt;pci&lt;/value&gt;
4314         &lt;value&gt;scsi&lt;/value&gt;
4315       &lt;/enum&gt;
4316       &lt;enum name='capsType'/&gt;
4317       &lt;enum name='pciBackend'&gt;
4318         &lt;value&gt;default&lt;/value&gt;
4319         &lt;value&gt;kvm&lt;/value&gt;
4320         &lt;value&gt;vfio&lt;/value&gt;
4321       &lt;/enum&gt;
4322     &lt;/hostdev&gt;
4323   &lt;/devices&gt;
4324   &lt;features&gt;
4325     &lt;gic supported='yes'&gt;
4326       &lt;enum name='version'&gt;
4327         &lt;value&gt;3&lt;/value&gt;
4328       &lt;/enum&gt;
4329     &lt;/gic&gt;
4330     &lt;vmcoreinfo supported='yes'/&gt;
4331   &lt;/features&gt;
4332 &lt;/domainCapabilities&gt;
4333         """
4334         self.mock_conn.getDomainCapabilities.return_value = (
4335             xml  # pylint: disable=no-member
4336         )
4337 <a name="3"></a>        caps = virt.domain_capabilities()
4338         expected = {
4339             <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"emulator": "/usr/bin/qemu-system-aarch64",
4340             "domain": "kvm",
4341             "machine": "virt-2.12",
4342             "arch": "aarch64",
4343             "max_vcpus": 255,
4344             "iothreads": True,
4345             "os": {
4346                 "loader": {
4347                     "type": ["rom", "pflash"],
4348                     "readonly": ["yes", "no"],
4349                     "values": [
4350                         "/usr/share/AAVMF/AAVMF_CODE.fd",
4351                         "/usr/share/AAVMF/AAVMF32_CODE.fd",
4352                         "/usr/share/OVMF/OVMF_CODE.fd",
4353                     ],
4354                 }
4355             },
4356             "cpu": {
4357                 "host-passthrough": True,
4358                 "host-model": {
4359                     "model": {"name": "sample-cpu", "fallback": "forbid"},
4360                     "vendor": "ACME",
4361                     "features": {"vme": "require", "ss": "require"},
4362                 },
4363                 "custom": {
4364                     "models": {"pxa262": "unknown", "pxa270-a0": "yes", "arm1136": "no"}
4365                 },
4366             },
4367             "devices": {
4368                 "disk": {
4369                     "diskDevice": ["disk", "cdrom", "floppy", "lun"],
4370                     "bus": ["fdc", "scsi", "virtio", "usb", "sata"],
4371                 },
4372                 "graphics": {"type": ["sdl", "vnc"]},
4373                 "video": {"modelType": ["vga", "virtio"]},
4374                 "hostdev": {
4375                     "mode": ["subsystem"],
4376                     "startupPolicy": ["default", "mandatory", "requisite", "optional"],
4377                     "subsysType": ["usb", "pci", "scsi"],
4378                     "capsType": [],
4379                     "pciBackend": ["default", "kvm", "vfio"],
4380                 },
4381             },
4382             "features": {"gic": {"version": ["3"]}, "vmcoreinfo": {}},
4383         }
4384         self.assertEqual(</b></font>expected, caps)
4385     def test_all_capabilities(self):
4386         domainXml = """
4387 &lt;domainCapabilities&gt;
4388   &lt;path&gt;/usr/bin/qemu-system-x86_64&lt;/path&gt;
4389   &lt;domain&gt;kvm&lt;/domain&gt;
4390   &lt;machine&gt;virt-2.12&lt;/machine&gt;
4391   &lt;arch&gt;x86_64&lt;/arch&gt;
4392   &lt;vcpu max='255'/&gt;
4393   &lt;iothreads supported='yes'/&gt;
4394 &lt;/domainCapabilities&gt;
4395         """
4396         hostXml = """
4397 &lt;capabilities&gt;
4398   &lt;host&gt;
4399     &lt;uuid&gt;44454c4c-3400-105a-8033-b3c04f4b344a&lt;/uuid&gt;
4400     &lt;cpu&gt;
4401       &lt;arch&gt;x86_64&lt;/arch&gt;
4402       &lt;model&gt;Nehalem&lt;/model&gt;
4403       &lt;vendor&gt;Intel&lt;/vendor&gt;
4404       &lt;microcode version='25'/&gt;
4405       &lt;topology sockets='1' cores='4' threads='2'/&gt;
4406     &lt;/cpu&gt;
4407   &lt;/host&gt;
4408   &lt;guest&gt;
4409     &lt;os_type&gt;hvm&lt;/os_type&gt;
4410     &lt;arch name='x86_64'&gt;
4411       &lt;wordsize&gt;64&lt;/wordsize&gt;
4412       &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
4413       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
4414       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
4415       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
4416       &lt;domain type='qemu'/&gt;
4417       &lt;domain type='kvm'&gt;
4418         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
4419         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
4420         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
4421         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
4422       &lt;/domain&gt;
4423     &lt;/arch&gt;
4424   &lt;/guest&gt;
4425 &lt;/capabilities&gt;
4426         """
4427         self.mock_conn.getCapabilities.return_value = hostXml
4428         self.mock_conn.getDomainCapabilities.side_effect = [
4429             domainXml,
4430             domainXml.replace("&lt;domain&gt;kvm", "&lt;domain&gt;qemu"),
4431         ]
4432         caps = virt.all_capabilities()
4433         self<font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertEqual(
4434             "44454c4c-3400-105a-8033-b3c04f4b344a", caps["host"]["host"]["uuid"]
4435         )
4436         self.assertEqual(
4437             {"qemu", "kvm"},
4438             {domainCaps["domain"] for domainCaps in caps["domains"]},
4439         )
4440         self.assertEqual(
4441             {call[0] for call in self.mock_conn.getDomainCapabilities.call_args_list},
4442             {
4443                 ("/usr/bin/qemu-system-x86_64", "x86_64", None, "kvm"),
4444                 ("/usr/bin/qemu-system-x86_64"</b></font>, "x86_64", None, "qemu"),
4445             },
4446         )
4447     def test_network_tag(self):
4448         xml_data = virt._gen_net_xml("network", "main", "bridge", "openvswitch", 1001)
4449         root = ET.fromstring(xml_data)
4450         self.assertEqual(root.find("name").text, "network")
4451         self.assertEqual(root.find("bridge").attrib["name"], "main")
4452         self.assertEqual(root.find("forward").attrib["mode"], "bridge")
4453         self.assertEqual(root.find("virtualport").attrib["type"], "openvswitch")
4454         self.assertEqual(root.find("vlan/tag").attrib["id"], "1001")
4455     def test_list_networks(self):
4456         names = ["net1", "default", "net2"]
4457         net_mocks = [MagicMock(), MagicMock(), MagicMock()]
4458         for i, value in enumerate(names):
4459             net_mocks[i].name.return_value = value
4460         self.mock_conn.listAllNetworks.return_value = (
4461             net_mocks  # pylint: disable=no-member
4462         )
4463         actual = virt.list_networks()
4464         self.assertEqual(names, actual)
4465     def test_network_info(self):
4466         self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV4 = 0
4467         self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV6 = 1
4468         net_mock = MagicMock()
4469         net_mock.name.return_value = "foo"
4470         net_mock.UUIDString.return_value = "some-uuid"
4471         net_mock.bridgeName.return_value = "br0"
4472         net_mock.autostart.return_value = True
4473         net_mock.isActive.return_value = False
4474         net_mock.isPersistent.return_value = True
4475         net_mock.DHCPLeases.return_value = [
4476             {
4477                 "iface": "virbr0",
4478                 "expirytime": 1527757552,
4479                 "type": 0,
4480                 "mac": "52:54:00:01:71:bd",
4481                 "ipaddr": "192.168.122.45",
4482                 "prefix": 24,
4483                 "hostname": "py3-test",
4484                 "clientid": "01:52:54:00:01:71:bd",
4485                 "iaid": None,
4486             }
4487         ]
4488         self.mock_conn.listAllNetworks.return_value = [net_mock]
4489         net = virt.network_info("foo")
4490         self.assertEqual(
4491             {
4492                 "foo": {
4493                     "uuid": "some-uuid",
4494                     "bridge": "br0",
4495                     "autostart": True,
4496                     "active": False,
4497                     "persistent": True,
4498                     "leases": [
4499                         {
4500                             "iface": "virbr0",
4501                             "expirytime": 1527757552,
4502                             "type": "ipv4",
4503                             "mac": "52:54:00:01:71:bd",
4504                             "ipaddr": "192.168.122.45",
4505                             "prefix": 24,
4506                             "hostname": "py3-test",
4507                             "clientid": "01:52:54:00:01:71:bd",
4508                             "iaid": None,
4509                         }
4510                     ],
4511                 }
4512             },
4513             net,
4514         )
4515     def test_network_info_all(self):
4516         self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV4 = 0
4517         self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV6 = 1
4518         net_mocks = []
4519         for i in range(2):
4520             net_mock = MagicMock()
4521             net_mock.name.return_value = "net{}".format(i)
4522             net_mock.UUIDString.return_value = "some-uuid"
4523             net_mock.bridgeName.return_value = "br{}".format(i)
4524             net_mock.autostart.return_value = True
4525             net_mock.isActive.return_value = False
4526             net_mock.isPersistent.return_value = True
4527             net_mock.DHCPLeases.return_value = []
4528             net_mocks.append(net_mock)
4529         self.mock_conn.listAllNetworks.return_value = net_mocks
4530         net = virt.network_info()
4531         self.assertEqual(
4532             {
4533                 "net0": {
4534                     "uuid": "some-uuid",
4535                     "bridge": "br0",
4536                     "autostart": True,
4537                     "active": False,
4538                     "persistent": True,
4539                     "leases": [],
4540                 },
4541                 "net1": {
4542                     "uuid": "some-uuid",
4543                     "bridge": "br1",
4544                     "autostart": True,
4545                     "active": False,
4546                     "persistent": True,
4547                     "leases": [],
4548                 },
4549             },
4550             net,
4551         )
4552     def test_network_info_notfound(self):
4553         self.mock_conn.listAllNetworks.return_value = []
4554         net = virt.network_info("foo")
4555         self.assertEqual({}, net)
4556     def test_network_get_xml(self):
4557         network_mock = MagicMock()
4558         network_mock.XMLDesc.return_value = "&lt;net&gt;Raw XML&lt;/net&gt;"
4559         self.mock_conn.networkLookupByName.return_value = network_mock
4560         self.assertEqual("&lt;net&gt;Raw XML&lt;/net&gt;", virt.network_get_xml("default"))
4561     def test_pool(self):
4562         xml_data = virt._gen_pool_xml("pool", "logical", "/dev/base")
4563         root = ET.fromstring(xml_data)
4564         self.assertEqual(root.find("name").text, "pool")
4565         self.assertEqual(root.attrib["type"], "logical")
4566         self.assertEqual(root.find("target/path").text, "/dev/base")
4567     def test_pool_with_source(self):
4568         xml_data = virt._gen_pool_xml(
4569             "pool", "logical", "/dev/base", source_devices=[{"path": "/dev/sda"}]
4570         )
4571         root = ET.fromstring(xml_data)
4572         self.assertEqual(root.find("name").text, "pool")
4573         self.assertEqual(root.attrib["type"], "logical")
4574         self.assertEqual(root.find("target/path").text, "/dev/base")
4575         self.assertEqual(root.find("source/device").attrib["path"], "/dev/sda")
4576     def test_pool_with_scsi(self):
4577         xml_data = virt._gen_pool_xml(
4578             "pool",
4579             "scsi",
4580             "/dev/disk/by-path",
4581             source_devices=[{"path": "/dev/sda"}],
4582             source_adapter={
4583                 "type": "scsi_host",
4584                 "parent_address": {
4585                     "unique_id": 5,
4586                     "address": {
4587                         "domain": "0x0000",
4588                         "bus": "0x00",
4589                         "slot": "0x1f",
4590                         "function": "0x2",
4591                     },
4592                 },
4593             },
4594             source_name="srcname",
4595         )
4596         root = ET.fromstring(xml_data)
4597         self.assertEqual(root.find("name").text, "pool")
4598         self.assertEqual(root.attrib["type"], "scsi")
4599         self.assertEqual(root.find("target/path").text, "/dev/disk/by-path")
4600         self.assertEqual(root.find("source/device"), None)
4601         self.assertEqual(root.find("source/name"), None)
4602         self.assertEqual(root.find("source/adapter").attrib["type"], "scsi_host")
4603         self.assertEqual(
4604             root.find("source/adapter/parentaddr").attrib["unique_id"], "5"
4605         )
4606         self.assertEqual(
4607             root.find("source/adapter/parentaddr/address").attrib["domain"], "0x0000"
4608         )
4609         self.assertEqual(
4610             root.find("source/adapter/parentaddr/address").attrib["bus"], "0x00"
4611         )
4612         self.assertEqual(
4613             root.find("source/adapter/parentaddr/address").attrib["slot"], "0x1f"
4614         )
4615         self.assertEqual(
4616             root.find("source/adapter/parentaddr/address").attrib["function"], "0x2"
4617         )
4618     def test_pool_with_rbd(self):
4619         xml_data = virt._gen_pool_xml(
4620             "pool",
4621             "rbd",
4622             source_devices=[{"path": "/dev/sda"}],
4623             source_hosts=["1.2.3.4", "my.ceph.monitor:69"],
4624             source_auth={
4625                 "type": "ceph",
4626                 "username": "admin",
4627                 "secret": {"type": "uuid", "value": "someuuid"},
4628             },
4629             source_name="srcname",
4630             source_adapter={"type": "scsi_host", "name": "host0"},
4631             source_dir="/some/dir",
4632             source_format="fmt",
4633         )
4634         root = ET.fromstring(xml_data)
4635         self.assertEqual(root.find("name").text, "pool")
4636         self.assertEqual(root.attrib["type"], "rbd")
4637         self.assertEqual(root.find("target"), None)
4638         self.assertEqual(root.find("source/device"), None)
4639         self.assertEqual(root.find("source/name").text, "srcname")
4640         self.assertEqual(root.find("source/adapter"), None)
4641         self.assertEqual(root.find("source/dir"), None)
4642         self.assertEqual(root.find("source/format"), None)
4643         self.assertEqual(root.findall("source/host")[0].attrib["name"], "1.2.3.4")
4644         self.assertTrue("port" not in root.findall("source/host")[0].attrib)
4645         self.assertEqual(
4646             root.findall("source/host")[1].attrib["name"], "my.ceph.monitor"
4647         )
4648         self.assertEqual(root.findall("source/host")[1].attrib["port"], "69")
4649         self.assertEqual(root.find("source/auth").attrib["type"], "ceph")
4650         self.assertEqual(root.find("source/auth").attrib["username"], "admin")
4651         self.assertEqual(root.find("source/auth/secret").attrib["uuid"], "someuuid")
4652     def test_pool_with_netfs(self):
4653         xml_data = virt._gen_pool_xml(
4654             "pool",
4655             "netfs",
4656             target="/path/to/target",
4657             permissions={
4658                 "mode": "0770",
4659                 "owner": 1000,
4660                 "group": 100,
4661                 "label": "seclabel",
4662             },
4663             source_devices=[{"path": "/dev/sda"}],
4664             source_hosts=["nfs.host"],
4665             source_name="srcname",
4666             source_adapter={"type": "scsi_host", "name": "host0"},
4667             source_dir="/some/dir",
4668             source_format="nfs",
4669         )
4670         root = ET.fromstring(xml_data)
4671         self.assertEqual(root.find("name").text, "pool")
4672         self.assertEqual(root.attrib["type"], "netfs")
4673         self.assertEqual(root.find("target/path").text, "/path/to/target")
4674         self.assertEqual(root.find("target/permissions/mode").text, "0770")
4675         self.assertEqual(root.find("target/permissions/owner").text, "1000")
4676         self.assertEqual(root.find("target/permissions/group").text, "100")
4677         self.assertEqual(root.find("target/permissions/label").text, "seclabel")
4678         self.assertEqual(root.find("source/device"), None)
4679         self.assertEqual(root.find("source/name"), None)
4680         self.assertEqual(root.find("source/adapter"), None)
4681         self.assertEqual(root.find("source/dir").attrib["path"], "/some/dir")
4682         self.assertEqual(root.find("source/format").attrib["type"], "nfs")
4683         self.assertEqual(root.find("source/host").attrib["name"], "nfs.host")
4684         self.assertEqual(root.find("source/auth"), None)
4685     def test_pool_with_iscsi_direct(self):
4686         xml_data = virt._gen_pool_xml(
4687             "pool",
4688             "iscsi-direct",
4689             source_hosts=["iscsi.example.com"],
4690             source_devices=[{"path": "iqn.2013-06.com.example:iscsi-pool"}],
4691             source_initiator="iqn.2013-06.com.example:iscsi-initiator",
4692         )
4693         root = ET.fromstring(xml_data)
4694         self.assertEqual(root.find("name").text, "pool")
4695         self.assertEqual(root.attrib["type"], "iscsi-direct")
4696         self.assertEqual(root.find("target"), None)
4697         self.assertEqual(
4698             root.find("source/device").attrib["path"],
4699             "iqn.2013-06.com.example:iscsi-pool",
4700         )
4701         self.assertEqual(
4702             root.findall("source/host")[0].attrib["name"], "iscsi.example.com"
4703         )
4704         self.assertEqual(
4705             root.find("source/initiator/iqn").attrib["name"],
4706             "iqn.2013-06.com.example:iscsi-initiator",
4707         )
4708     def test_pool_define(self):
4709         mock_pool = MagicMock()
4710         mock_secret = MagicMock()
4711         mock_secret_define = MagicMock(return_value=mock_secret)
4712         self.mock_conn.secretDefineXML = mock_secret_define
4713         self.mock_conn.storagePoolCreateXML = MagicMock(return_value=mock_pool)
4714         self.mock_conn.storagePoolDefineXML = MagicMock(return_value=mock_pool)
4715         mocks = [
4716             mock_pool,
4717             mock_secret,
4718             mock_secret_define,
4719             self.mock_conn.storagePoolCreateXML,
4720             self.mock_conn.secretDefineXML,
4721             self.mock_conn.storagePoolDefineXML,
4722         ]
4723         self.assertTrue(
4724             virt.pool_define(
4725                 "default",
4726                 "rbd",
4727 <a name="32"></a>                source_hosts=["one.example.com", "two.example.com"],
4728                 source_name="rbdvol",
4729                 source_auth={
4730                     <font color="#5b8daf"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"type": "ceph",
4731                     "username": "admin",
4732                     "secret": {"type": "uuid", "value": "someuuid"},
4733                 },
4734             )
4735         )
4736         self.mock_conn.storagePoolDefineXML.assert_called_once()
4737         self.mock_conn.storagePoolCreateXML.assert_not_called()
4738         mock_pool.create.</b></font>assert_called_once()
4739         mock_secret_define.assert_not_called()
4740         for mock in mocks:
4741             mock.reset_mock()
4742         self.assertTrue(
4743             virt.pool_define(
4744                 "default",
4745                 "rbd",
4746                 transient=True,
4747                 source_hosts=["one.example.com", "two.example.com"],
4748                 source_name="rbdvol",
4749                 source_auth={"username": "admin", "password": "c2VjcmV0"},
4750             )
4751         )
4752         self.mock_conn.storagePoolDefineXML.assert_not_called()
4753         pool_xml = self.mock_conn.storagePoolCreateXML.call_args[0][0]
4754         root = ET.fromstring(pool_xml)
4755         self.assertEqual(root.find("source/auth").attrib["type"], "ceph")
4756         self.assertEqual(root.find("source/auth").attrib["username"], "admin")
4757         self.assertEqual(
4758             root.find("source/auth/secret").attrib["usage"], "pool_default"
4759         )
4760         mock_pool.create.assert_not_called()
4761         mock_secret.setValue.assert_called_once_with(b"secret")
4762         secret_xml = mock_secret_define.call_args[0][0]
4763         root = ET.fromstring(secret_xml)
4764         self.assertEqual(root.find("usage/name").text, "pool_default")
4765         self.assertEqual(root.find("usage").attrib["type"], "ceph")
4766         self.assertEqual(root.attrib["private"], "yes")
4767         self.assertEqual(
4768             root.find("description").text, "Passphrase for default pool created by Salt"
4769         )
4770         for mock in mocks:
4771             mock.reset_mock()
4772         self.assertTrue(
4773             virt.pool_define(
4774                 "default",
4775                 "iscsi",
4776                 target="/dev/disk/by-path",
4777                 source_hosts=["iscsi.example.com"],
4778                 source_devices=[{"path": "iqn.2013-06.com.example:iscsi-pool"}],
4779                 source_auth={"username": "admin", "password": "secret"},
4780                 start=False,
4781             )
4782         )
4783         self.mock_conn.storagePoolCreateXML.assert_not_called()
4784         pool_xml = self.mock_conn.storagePoolDefineXML.call_args[0][0]
4785         root = ET.fromstring(pool_xml)
4786         self.assertEqual(root.find("source/auth").attrib["type"], "chap")
4787         self.assertEqual(root.find("source/auth").attrib["username"], "admin")
4788         self.assertEqual(
4789             root.find("source/auth/secret").attrib["usage"], "pool_default"
4790         )
4791         mock_pool.create.assert_not_called()
4792         mock_secret.setValue.assert_called_once_with("secret")
4793         secret_xml = mock_secret_define.call_args[0][0]
4794         root = ET.fromstring(secret_xml)
4795         self.assertEqual(root.find("usage/target").text, "pool_default")
4796         self.assertEqual(root.find("usage").attrib["type"], "iscsi")
4797         self.assertEqual(root.attrib["private"], "yes")
4798         self.assertEqual(
4799             root.find("description").text, "Passphrase for default pool created by Salt"
4800         )
4801     def test_list_pools(self):
4802         names = ["pool1", "default", "pool2"]
4803         pool_mocks = [MagicMock(), MagicMock(), MagicMock()]
4804         for i, value in enumerate(names):
4805             pool_mocks[i].name.return_value = value
4806         self.mock_conn.listAllStoragePools.return_value = (
4807             pool_mocks  # pylint: disable=no-member
4808         )
4809         actual = virt.list_pools()
4810         self.assertEqual(names, actual)
4811     def test_pool_info(self):
4812         pool_mock = MagicMock()
4813         pool_mock.name.return_value = "foo"
4814         pool_mock.UUIDString.return_value = "some-uuid"
4815         pool_mock.info.return_value = [0, 1234, 5678, 123]
4816         pool_mock.autostart.return_value = True
4817         pool_mock.isPersistent.return_value = True
4818         pool_mock.XMLDesc.return_value = """&lt;pool type='dir'&gt;
4819   &lt;name&gt;default&lt;/name&gt;
4820   &lt;uuid&gt;d92682d0-33cf-4e10-9837-a216c463e158&lt;/uuid&gt;
4821   &lt;capacity unit='bytes'&gt;854374301696&lt;/capacity&gt;
4822   &lt;allocation unit='bytes'&gt;596275986432&lt;/allocation&gt;
4823   &lt;available unit='bytes'&gt;258098315264&lt;/available&gt;
4824   &lt;source&gt;
4825   &lt;/source&gt;
4826   &lt;target&gt;
4827     &lt;path&gt;/srv/vms&lt;/path&gt;
4828     &lt;permissions&gt;
4829       &lt;mode&gt;0755&lt;/mode&gt;
4830       &lt;owner&gt;0&lt;/owner&gt;
4831       &lt;group&gt;0&lt;/group&gt;
4832     &lt;/permissions&gt;
4833   &lt;/target&gt;
4834 &lt;/pool&gt;"""
4835         self.mock_conn.listAllStoragePools.return_value = [pool_mock]
4836         pool = virt.pool_info("foo")
4837         self.assertEqual(
4838             {
4839                 "foo": {
4840                     "uuid": "some-uuid",
4841                     "state": "inactive",
4842                     "capacity": 1234,
4843                     "allocation": 5678,
4844                     "free": 123,
4845                     "autostart": True,
4846                     "persistent": True,
4847                     "type": "dir",
4848                     "target_path": "/srv/vms",
4849                 }
4850             },
4851             pool,
4852         )
4853     def test_pool_info_notarget(self):
4854         pool_mock = MagicMock()
4855         pool_mock.name.return_value = "ceph"
4856         pool_mock.UUIDString.return_value = "some-uuid"
4857         pool_mock.info.return_value = [0, 0, 0, 0]
4858         pool_mock.autostart.return_value = True
4859         pool_mock.isPersistent.return_value = True
4860         pool_mock.XMLDesc.return_value = """&lt;pool type='rbd'&gt;
4861   &lt;name&gt;ceph&lt;/name&gt;
4862   &lt;uuid&gt;some-uuid&lt;/uuid&gt;
4863   &lt;capacity unit='bytes'&gt;0&lt;/capacity&gt;
4864   &lt;allocation unit='bytes'&gt;0&lt;/allocation&gt;
4865   &lt;available unit='bytes'&gt;0&lt;/available&gt;
4866   &lt;source&gt;
4867     &lt;host name='localhost' port='6789'/&gt;
4868     &lt;host name='localhost' port='6790'/&gt;
4869     &lt;name&gt;rbd&lt;/name&gt;
4870     &lt;auth type='ceph' username='admin'&gt;
4871       &lt;secret uuid='2ec115d7-3a88-3ceb-bc12-0ac909a6fd87'/&gt;
4872     &lt;/auth&gt;
4873   &lt;/source&gt;
4874 &lt;/pool&gt;"""
4875         self.mock_conn.listAllStoragePools.return_value = [pool_mock]
4876         pool = virt.pool_info("ceph")
4877         self.assertEqual(
4878             {
4879                 "ceph": {
4880                     "uuid": "some-uuid",
4881                     "state": "inactive",
4882                     "capacity": 0,
4883                     "allocation": 0,
4884                     "free": 0,
4885                     "autostart": True,
4886                     "persistent": True,
4887                     "type": "rbd",
4888                     "target_path": None,
4889                 }
4890             },
4891             pool,
4892         )
4893     def test_pool_info_notfound(self):
4894         self.mock_conn.listAllStoragePools.return_value = []
4895         pool = virt.pool_info("foo")
4896         self.assertEqual({}, pool)
4897     def test_pool_info_all(self):
4898         pool_mocks = []
4899         for i in range(2):
4900             pool_mock = MagicMock()
4901             pool_mock.name.return_value = "pool{}".format(i)
4902             pool_mock.UUIDString.return_value = "some-uuid-{}".format(i)
4903             pool_mock.info.return_value = [0, 1234, 5678, 123]
4904             pool_mock.autostart.return_value = True
4905             pool_mock.isPersistent.return_value = True
4906             pool_mock.XMLDesc.return_value = """&lt;pool type='dir'&gt;
4907   &lt;name&gt;default&lt;/name&gt;
4908   &lt;uuid&gt;d92682d0-33cf-4e10-9837-a216c463e158&lt;/uuid&gt;
4909   &lt;capacity unit='bytes'&gt;854374301696&lt;/capacity&gt;
4910   &lt;allocation unit='bytes'&gt;596275986432&lt;/allocation&gt;
4911   &lt;available unit='bytes'&gt;258098315264&lt;/available&gt;
4912   &lt;source&gt;
4913   &lt;/source&gt;
4914   &lt;target&gt;
4915     &lt;path&gt;/srv/vms&lt;/path&gt;
4916     &lt;permissions&gt;
4917       &lt;mode&gt;0755&lt;/mode&gt;
4918       &lt;owner&gt;0&lt;/owner&gt;
4919       &lt;group&gt;0&lt;/group&gt;
4920     &lt;/permissions&gt;
4921   &lt;/target&gt;
4922 &lt;/pool&gt;"""
4923             pool_mocks.append(pool_mock)
4924         self.mock_conn.listAllStoragePools.return_value = pool_mocks
4925         pool = virt.pool_info()
4926         self.assertEqual(
4927             {
4928                 "pool0": {
4929                     "uuid": "some-uuid-0",
4930                     "state": "inactive",
4931                     "capacity": 1234,
4932                     "allocation": 5678,
4933                     "free": 123,
4934                     "autostart": True,
4935                     "persistent": True,
4936                     "type": "dir",
4937                     "target_path": "/srv/vms",
4938                 },
4939                 "pool1": {
4940                     "uuid": "some-uuid-1",
4941                     "state": "inactive",
4942                     "capacity": 1234,
4943                     "allocation": 5678,
4944                     "free": 123,
4945                     "autostart": True,
4946                     "persistent": True,
4947                     "type": "dir",
4948                     "target_path": "/srv/vms",
4949                 },
4950             },
4951             pool,
4952         )
4953     def test_pool_get_xml(self):
4954         pool_mock = MagicMock()
4955         pool_mock.XMLDesc.return_value = "&lt;pool&gt;Raw XML&lt;/pool&gt;"
4956         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
4957         self.assertEqual("&lt;pool&gt;Raw XML&lt;/pool&gt;", virt.pool_get_xml("default"))
4958     def test_pool_list_volumes(self):
4959         names = ["volume1", "volume2"]
4960         mock_pool = MagicMock()
4961         mock_pool.listVolumes.return_value = names
4962         self.mock_conn.storagePoolLookupByName.return_value = mock_pool
4963         self.assertEqual(names, virt.pool_list_volumes("default"))
4964     @patch("salt.modules.virt._is_bhyve_hyper", return_value=False)
4965     @patch("salt.modules.virt._is_kvm_hyper", return_value=True)
4966     @patch("salt.modules.virt._is_xen_hyper", return_value=False)
4967     def test_get_hypervisor(self, isxen_mock, iskvm_mock, is_bhyve_mock):
4968         self.assertEqual("kvm", virt.get_hypervisor())
4969         iskvm_mock.return_value = False
4970         self.assertIsNone(virt.get_hypervisor())
4971         is_bhyve_mock.return_value = False
4972         self.assertIsNone(virt.get_hypervisor())
4973         isxen_mock.return_value = True
4974         self.assertEqual("xen", virt.get_hypervisor())
4975     def test_pool_delete(self):
4976         mock_pool = MagicMock()
4977         mock_pool.delete = MagicMock(return_value=0)
4978         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mock_pool)
4979         res = virt.pool_delete("test-pool")
4980         self.assertTrue(res)
4981         self.mock_conn.storagePoolLookupByName.assert_called_once_with("test-pool")
4982         mock_pool.delete.assert_called_once_with(
4983             self.mock_libvirt.VIR_STORAGE_POOL_DELETE_NORMAL
4984         )
4985     def test_pool_undefine_secret(self):
4986         mock_pool = MagicMock()
4987         mock_pool.undefine = MagicMock(return_value=0)
4988         mock_pool.XMLDesc.return_value = """
4989             &lt;pool type='rbd'&gt;
4990               &lt;name&gt;test-ses&lt;/name&gt;
4991               &lt;source&gt;
4992                 &lt;host name='myhost'/&gt;
4993                 &lt;name&gt;libvirt-pool&lt;/name&gt;
4994                 &lt;auth type='ceph' username='libvirt'&gt;
4995                   &lt;secret usage='pool_test-ses'/&gt;
4996                 &lt;/auth&gt;
4997               &lt;/source&gt;
4998             &lt;/pool&gt;
4999         """
5000         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mock_pool)
5001         mock_undefine = MagicMock(return_value=0)
5002 <a name="16"></a>        self.mock_conn.secretLookupByUsage.return_value.undefine = mock_undefine
5003         res = virt.pool_undefine("test-ses")
5004         self<font color="#2981b2"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertTrue(res)
5005         self.mock_conn.storagePoolLookupByName.assert_called_once_with("test-ses")
5006         mock_pool.undefine.assert_called_once_with()
5007         self.mock_conn.secretLookupByUsage.assert_called_once_with(
5008             self.mock_libvirt.VIR_SECRET_USAGE_TYPE_CEPH, "pool_test-ses"
5009         )
5010         mock_undefine.</b></font>assert_called_once()
5011     def test_full_info(self):
5012         xml = """&lt;domain type='kvm' id='7'&gt;
5013               &lt;uuid&gt;28deee33-4859-4f23-891c-ee239cffec94&lt;/uuid&gt;
5014               &lt;name&gt;test-vm&lt;/name&gt;
5015               &lt;on_poweroff&gt;destroy&lt;/on_poweroff&gt;
5016               &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
5017               &lt;on_crash&gt;destroy&lt;/on_crash&gt;
5018               &lt;devices&gt;
5019                 &lt;disk type='file' device='disk'&gt;
5020                 &lt;driver name='qemu' type='qcow2'/&gt;
5021                 &lt;source file='/disks/test.qcow2'/&gt;
5022                 &lt;target dev='vda' bus='virtio'/&gt;
5023               &lt;/disk&gt;
5024               &lt;disk type='file' device='cdrom'&gt;
5025                 &lt;driver name='qemu' type='raw'/&gt;
5026                 &lt;source file='/disks/test-cdrom.iso'/&gt;
5027                 &lt;target dev='hda' bus='ide'/&gt;
5028                 &lt;readonly/&gt;
5029               &lt;/disk&gt;
5030               &lt;interface type='bridge'&gt;
5031                 &lt;mac address='ac:de:48:b6:8b:59'/&gt;
5032                 &lt;source bridge='br0'/&gt;
5033                 &lt;model type='virtio'/&gt;
5034                 &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x03' function='0x0'/&gt;
5035               &lt;/interface&gt;
5036               &lt;graphics type='vnc' port='5900' autoport='yes' listen='0.0.0.0'&gt;
5037                 &lt;listen type='address' address='0.0.0.0'/&gt;
5038               &lt;/graphics&gt;
5039               &lt;/devices&gt;
5040             &lt;/domain&gt;
5041         """
5042         self.set_mock_vm("test-vm", xml)
5043         qemu_infos = """[{
5044             "virtual-size": 25769803776,
5045             "filename": "/disks/test.qcow2",
5046             "cluster-size": 65536,
5047             "format": "qcow2",
5048             "actual-size": 217088,
5049             "format-specific": {
5050                 "type": "qcow2",
5051                 "data": {
5052                     "compat": "1.1",
5053                     "lazy-refcounts": false,
5054                     "refcount-bits": 16,
5055                     "corrupt": false
5056                 }
5057             },
5058             "full-backing-filename": "/disks/mybacking.qcow2",
5059             "backing-filename": "mybacking.qcow2",
5060             "dirty-flag": false
5061         },
5062         {
5063             "virtual-size": 25769803776,
5064             "filename": "/disks/mybacking.qcow2",
5065             "cluster-size": 65536,
5066             "format": "qcow2",
5067             "actual-size": 393744384,
5068             "format-specific": {
5069                 "type": "qcow2",
5070                 "data": {
5071                     "compat": "1.1",
5072                     "lazy-refcounts": false,
5073                     "refcount-bits": 16,
5074                     "corrupt": false
5075                 }
5076             },
5077             "dirty-flag": false
5078         }]"""
5079         self.mock_popen.communicate.return_value = [qemu_infos, ""]
5080         self.mock_popen.returncode = 0
5081         self.mock_conn.getInfo = MagicMock(
5082             return_value=["x86_64", 4096, 8, 2712, 1, 2, 4, 2]
5083         )
5084         actual = virt.full_info()
5085         qemu_img_call = [
5086             call
5087             for call in self.mock_subprocess.Popen<font color="#f52887"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.call_args_list
5088             if "qemu-img" in call[0][0]
5089         ][0]
5090         self.assertIn("info", qemu_img_call[0][0])
5091         self.assertIn("-U", qemu_img_call[0][0])
5092         self.assertEqual(2816, actual["freemem"])
5093         self.</b></font>assertEqual(6, actual["freecpu"])
5094         self.assertEqual(4, actual<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["node_info"]["cpucores"])
5095         self.assertEqual(2712, actual["node_info"]["cpumhz"])
5096         self.assertEqual("x86_64", actual["node_info"]["cpumodel"])
5097 <a name="4"></a>        self.assertEqual(8, actual["node_info"]["cpus"])
5098         self.assertEqual(2, actual["node_info"]["cputhreads"])
5099         self.assertEqual(1, actual["node_info"]["numanodes"])
5100         self.</b></font>assertEqual(4096, actual<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["node_info"]["phymemory"])
5101         self.assertEqual(2, actual["node_info"]["sockets"])
5102         self.assertEqual(2, actual["vm_info"]["test-vm"]["cpu"])
5103 <a name="21"></a>        self.assertEqual(1234, actual["vm_info"]["test-vm"]["cputime"])
5104         self.assertEqual(1024 * 1024, actual["vm_info"]["test-vm"]["mem"])
5105         self.assertEqual(2048 * 1024, actual["vm_info"]["test-vm"]["maxMem"])
5106         self.</b></font>assertEqual("shutdown", actual<font color="#947010"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["vm_info"]["test-vm"]["state"])
5107         self.assertEqual(
5108             "28deee33-4859-4f23-891c-ee239cffec94", actual["vm_info"]["test-vm"]["uuid"]
5109         )
5110         self.assertEqual("destroy", actual["vm_info"]["test-vm"]["on_crash"])
5111         self.</b></font>assertEqual("restart", actual["vm_info"]["test-vm"]["on_reboot"])
5112         self.assertEqual("destroy", actual["vm_info"]["test-vm"]["on_poweroff"])
5113         nic = actual["vm_info"]["test-vm"]["nics"]["ac:de:48:b6:8b:59"]
5114         self.assertEqual("bridge", nic["type"])
5115         self.assertEqual("ac:de:48:b6:8b:59", nic["mac"])
5116         disks = actual["vm_info"]["test-vm"]["disks"]
5117         disk = disks.get("vda")
5118         self.assertEqual("/disks/test.qcow2", disk["file"])
5119         self.assertEqual("disk", disk["type"])
5120         self.assertEqual("/disks/mybacking.qcow2", disk["backing file"]["file"])
5121         cdrom = disks.get("hda")
5122         self.assertEqual("/disks/test-cdrom.iso", cdrom["file"])
5123         self.assertEqual("cdrom", cdrom["type"])
5124         self.assertFalse("backing file" in cdrom.keys())
5125         graphics = actual["vm_info"]["test-vm"]["graphics"]
5126         self.assertEqual("vnc", graphics["type"])
5127         self.assertEqual("5900", graphics["port"])
5128         self.assertEqual("0.0.0.0", graphics["listen"])
5129     def test_pool_update(self):
5130         current_xml = """&lt;pool type='dir'&gt;
5131           &lt;name&gt;default&lt;/name&gt;
5132           &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
5133           &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
5134           &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
5135           &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
5136           &lt;source&gt;
5137           &lt;/source&gt;
5138           &lt;target&gt;
5139             &lt;path&gt;/path/to/pool&lt;/path&gt;
5140             &lt;permissions&gt;
5141               &lt;mode&gt;0775&lt;/mode&gt;
5142               &lt;owner&gt;0&lt;/owner&gt;
5143               &lt;group&gt;100&lt;/group&gt;
5144             &lt;/permissions&gt;
5145           &lt;/target&gt;
5146         &lt;/pool&gt;"""
5147         expected_xml = (
5148             '&lt;pool type="netfs"&gt;'
5149             "&lt;name&gt;default&lt;/name&gt;"
5150             "&lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;"
5151             '&lt;capacity unit="bytes"&gt;1999421108224&lt;/capacity&gt;'
5152             '&lt;allocation unit="bytes"&gt;713207042048&lt;/allocation&gt;'
5153             '&lt;available unit="bytes"&gt;1286214066176&lt;/available&gt;'
5154             "&lt;target&gt;"
5155             "&lt;path&gt;/mnt/cifs&lt;/path&gt;"
5156             "&lt;permissions&gt;"
5157             "&lt;mode&gt;0774&lt;/mode&gt;"
5158             "&lt;owner&gt;1234&lt;/owner&gt;"
5159             "&lt;group&gt;123&lt;/group&gt;"
5160             "&lt;/permissions&gt;"
5161             "&lt;/target&gt;"
5162             "&lt;source&gt;"
5163             '&lt;dir path="samba_share" /&gt;'
5164             '&lt;host name="one.example.com" /&gt;'
5165             '&lt;host name="two.example.com" /&gt;'
5166             '&lt;format type="cifs" /&gt;'
5167             "&lt;/source&gt;"
5168             "&lt;/pool&gt;"
5169         )
5170         mocked_pool = MagicMock()
5171         mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
5172         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
5173         self.mock_conn.storagePoolDefineXML = MagicMock()
5174         self.assertTrue(
5175             virt.pool_update(
5176                 "default",
5177                 "netfs",
5178                 target="/mnt/cifs",
5179                 permissions={"mode": "0774", "owner": "1234", "group": "123"},
5180                 source_format="cifs",
5181                 source_dir="samba_share",
5182                 source_hosts=["one.example.com", "two.example.com"],
5183             )
5184         )
5185         self.mock_conn.storagePoolDefineXML.assert_called_once_with(expected_xml)
5186     def test_pool_update_nochange(self):
5187         current_xml = """&lt;pool type='dir'&gt;
5188           &lt;name&gt;default&lt;/name&gt;
5189           &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
5190           &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
5191           &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
5192           &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
5193           &lt;source&gt;
5194           &lt;/source&gt;
5195           &lt;target&gt;
5196             &lt;path&gt;/path/to/pool&lt;/path&gt;
5197             &lt;permissions&gt;
5198               &lt;mode&gt;0775&lt;/mode&gt;
5199               &lt;owner&gt;0&lt;/owner&gt;
5200               &lt;group&gt;100&lt;/group&gt;
5201             &lt;/permissions&gt;
5202           &lt;/target&gt;
5203         &lt;/pool&gt;"""
5204         mocked_pool = MagicMock()
5205         mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
5206         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
5207         self.mock_conn.storagePoolDefineXML = MagicMock()
5208         self.assertFalse(
5209             virt.pool_update(
5210                 "default",
5211                 "dir",
5212                 target="/path/to/pool",
5213                 permissions={"mode": "0775", "owner": "0", "group": "100"},
5214                 test=True,
5215             )
5216         )
5217         self.mock_conn.storagePoolDefineXML.assert_not_called()
5218     def test_pool_update_password(self):
5219         current_xml = """&lt;pool type='rbd'&gt;
5220           &lt;name&gt;default&lt;/name&gt;
5221           &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
5222           &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
5223           &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
5224           &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
5225           &lt;source&gt;
5226             &lt;name&gt;iscsi-images&lt;/name&gt;
5227             &lt;host name='ses4.tf.local'/&gt;
5228             &lt;host name='ses5.tf.local'/&gt;
5229             &lt;auth username='libvirt' type='ceph'&gt;
5230               &lt;secret uuid='14e9a0f1-8fbf-4097-b816-5b094c182212'/&gt;
5231             &lt;/auth&gt;
5232           &lt;/source&gt;
5233         &lt;/pool&gt;"""
5234         mock_secret = MagicMock()
5235         self.mock_conn.secretLookupByUUIDString = MagicMock(return_value=mock_secret)
5236         mocked_pool = MagicMock()
5237         mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
5238         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
5239         self.mock_conn.storagePoolDefineXML = MagicMock()
5240         self.assertFalse(
5241             virt.pool_update(
5242                 "default",
5243                 "rbd",
5244                 source_name="iscsi-images",
5245                 source_hosts=["ses4.tf.local", "ses5.tf.local"],
5246                 source_auth={"username": "libvirt", "password": "c2VjcmV0"},
5247             )
5248         )
5249         self.mock_conn.storagePoolDefineXML.assert_not_called()
5250         mock_secret.setValue.assert_called_once_with(b"secret")
5251         self.mock_conn.secretLookupByUUIDString = MagicMock(
5252             side_effect=self.mock_libvirt.libvirtError("secret not found")
5253         )
5254         self.assertFalse(
5255             virt.pool_update(
5256                 "default",
5257                 "rbd",
5258                 source_name="iscsi-images",
5259                 source_hosts=["ses4.tf.local", "ses5.tf.local"],
5260                 source_auth={"username": "libvirt", "password": "c2VjcmV0"},
5261             )
5262         )
5263         self.mock_conn.storagePoolDefineXML.assert_not_called()
5264         self.mock_conn.secretDefineXML.assert_called_once()
5265         mock_secret.setValue.assert_called_once_with(b"secret")
5266     def test_pool_update_password_create(self):
5267         current_xml = """&lt;pool type='rbd'&gt;
5268           &lt;name&gt;default&lt;/name&gt;
5269           &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
5270           &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
5271           &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
5272           &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
5273           &lt;source&gt;
5274             &lt;name&gt;iscsi-images&lt;/name&gt;
5275             &lt;host name='ses4.tf.local'/&gt;
5276             &lt;host name='ses5.tf.local'/&gt;
5277           &lt;/source&gt;
5278         &lt;/pool&gt;"""
5279         expected_xml = (
5280             '&lt;pool type="rbd"&gt;'
5281             "&lt;name&gt;default&lt;/name&gt;"
5282             "&lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;"
5283             '&lt;capacity unit="bytes"&gt;1999421108224&lt;/capacity&gt;'
5284             '&lt;allocation unit="bytes"&gt;713207042048&lt;/allocation&gt;'
5285             '&lt;available unit="bytes"&gt;1286214066176&lt;/available&gt;'
5286             "&lt;source&gt;"
5287             '&lt;host name="ses4.tf.local" /&gt;'
5288             '&lt;host name="ses5.tf.local" /&gt;'
5289             '&lt;auth type="ceph" username="libvirt"&gt;'
5290             '&lt;secret usage="pool_default" /&gt;'
5291             "&lt;/auth&gt;"
5292             "&lt;name&gt;iscsi-images&lt;/name&gt;"
5293             "&lt;/source&gt;"
5294             "&lt;/pool&gt;"
5295         )
5296         mock_secret = MagicMock()
5297         self.mock_conn.secretDefineXML = MagicMock(return_value=mock_secret)
5298         mocked_pool = MagicMock()
5299         mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
5300         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
5301         self.mock_conn.storagePoolDefineXML = MagicMock()
5302         self.assertTrue(
5303             virt.pool_update(
5304                 "default",
5305                 "rbd",
5306                 source_name="iscsi-images",
5307                 source_hosts=["ses4.tf.local", "ses5.tf.local"],
5308                 source_auth={"username": "libvirt", "password": "c2VjcmV0"},
5309             )
5310         )
5311         self.mock_conn.storagePoolDefineXML.assert_called_once_with(expected_xml)
5312         mock_secret.setValue.assert_called_once_with(b"secret")
5313     def test_volume_infos(self):
5314         vms_disks = [
5315         ]
5316         mock_vms = []
5317         for idx, disk in enumerate(vms_disks):
5318             vm = MagicMock()
5319             vm.name.return_value = "vm{}".format(idx)
5320             vm.XMLDesc.return_value = """
5321                     &lt;domain type='kvm' id='1'&gt;
5322                       &lt;name&gt;vm{}&lt;/name&gt;
5323                       &lt;devices&gt;{}&lt;/devices&gt;
5324                     &lt;/domain&gt;
5325                 """.format(
5326                 idx, disk
5327             )
5328 <a name="17"></a>            mock_vms.append(vm)
5329         mock_pool_data = [
5330             <font color="#3090c7"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
5331                 "name": "pool0",
5332                 "state": self.mock_libvirt.VIR_STORAGE_POOL_RUNNING,
5333                 "volumes": [
5334                     {
5335                         "key": "/key/of/vol0",
5336                         "name": "vol0",
5337                         "path": "/path/to/vol0.qcow2",
5338                         "info": [0, 123456789, 123456],
5339                         "backingStore": None,
5340                     }
5341                 ],
5342             },
5343             {
5344                 "name": "pool1",
5345                 "state": self.mock_libvirt.VIR_STORAGE_POOL_RUNNING,
5346                 "volumes": [
5347                     {
5348                         "key": "/key/of/vol0bad",
5349                         "name": "vol0bad",
5350                         "path": "/path/to/vol0bad.qcow2",
5351                         "info": None,
5352                         "backingStore": None,
5353                     },
5354                     {
5355                         "key": "/key/of/vol1",
5356                         "name": "vol1",
5357                         "path": "/path/to/vol1.qcow2",
5358                         "info": [0, 12345, 1234],
5359                         "backingStore": None,
5360                     },
5361                     {
5362                         "key": "/key/of/vol2",
5363                         "name": "vol2",
5364                         "path": "/path/to/vol2.qcow2",
5365                         "info": [0</b></font>, 12345, 1234],
5366                         "backingStore": "/path/to/vol0.qcow2",
5367                     },
5368                 ],
5369             },
5370         ]
5371         mock_pools = []
5372         for pool_data in mock_pool_data:
5373             mock_pool = MagicMock()
5374             mock_pool.name.return_value = pool_data["name"]  # pylint: disable=no-member
5375             mock_pool.info.return_value = [pool_data["state"]]
5376             mock_volumes = []
5377             for vol_data in pool_data["volumes"]:
5378                 mock_volume = MagicMock()
5379                 mock_volume.name.return_value = vol_data["name"]
5380                 mock_volume.key.return_value = vol_data["key"]
5381                 mock_volume.path.return_value = "/path/to/{}.qcow2".format(
5382                     vol_data["name"]
5383                 )
5384                 if vol_data["info"]:
5385                     mock_volume.info.return_value = vol_data["info"]
5386                     backing_store = (
5387                             vol_data["backingStore"]
5388                         )
5389                         if vol_data["backingStore"]
5390                         else "&lt;backingStore/&gt;"
5391                     )
5392                     mock_volume.XMLDesc.return_value = """
5393                         &lt;volume type='file'&gt;
5394                           &lt;name&gt;{0}&lt;/name&gt;
5395                           &lt;target&gt;
5396                             &lt;format type="qcow2"/&gt;
5397                             &lt;path&gt;/path/to/{0}.qcow2&lt;/path&gt;
5398                           &lt;/target&gt;
5399                           {1}
5400                         &lt;/volume&gt;
5401                     """.format(
5402                         vol_data["name"], backing_store
5403                     )
5404                 else:
5405                     mock_volume.info.side_effect = self.mock_libvirt.libvirtError(
5406                         "No such volume"
5407                     )
5408                     mock_volume.XMLDesc.side_effect = self.mock_libvirt.libvirtError(
5409                         "No such volume"
5410                     )
5411                 mock_volumes.append(mock_volume)
5412             mock_pool.listAllVolumes.return_value = (
5413                 mock_volumes  # pylint: disable=no-member
5414             )
5415             mock_pools.append(mock_pool)
5416         inactive_pool = MagicMock()
5417         inactive_pool.name.return_value = "pool2"
5418         inactive_pool.info.return_value = [self.mock_libvirt.VIR_STORAGE_POOL_INACTIVE]
5419         inactive_pool.listAllVolumes.side_effect = self.mock_libvirt.libvirtError(
5420             "pool is inactive"
5421         )
5422         mock_pools.append(inactive_pool)
5423         self.mock_conn.listAllStoragePools.return_value = (
5424             mock_pools  # pylint: disable=no-member
5425         )
5426         with patch("salt.modules.virt._get_domain", MagicMock(return_value=mock_vms)):
5427 <a name="6"></a>            actual = virt.volume_infos("pool0", "vol0")
5428             self.assertEqual(1, len(actual.keys()))
5429             self.assertEqual(1, len(actual["pool0"].keys()))
5430             self.assertEqual(["vm0", "vm2"], sorted(actual["pool0"]<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["vol0"]["used_by"]))
5431             self.assertEqual("/path/to/vol0.qcow2", actual["pool0"]["vol0"]["path"])
5432             self.assertEqual("file", actual["pool0"]["vol0"]["type"])
5433             self.assertEqual("/key/of/vol0", actual["pool0"]["vol0"]["key"])
5434             self.assertEqual(123456789, actual["pool0"]["vol0"]["capacity"])
5435             self.</b></font>assertEqual(123456, actual["pool0"]["vol0"]["allocation"])
5436             self.assertEqual(
5437                 virt.volume_infos("pool1", None),
5438                 {
5439                     "pool1": {
5440                         "vol1": {
5441                             "type": "file",
5442                             "key": "/key/of/vol1",
5443                             "path": "/path/to/vol1.qcow2",
5444                             "capacity": 12345,
5445                             "allocation": 1234,
5446                             "used_by": [],
5447                             "backing_store": None,
5448                             "format": "qcow2",
5449                         },
5450                         "vol2": {
5451                             "type": "file",
5452                             "key": "/key/of/vol2",
5453                             "path": "/path/to/vol2.qcow2",
5454                             "capacity": 12345,
5455                             "allocation": 1234,
5456                             "used_by": ["vm2"],
5457                             "backing_store": {
5458                                 "path": "/path/to/vol0.qcow2",
5459                                 "format": "qcow2",
5460                             },
5461                             "format": "qcow2",
5462                         },
5463                     }
5464                 },
5465             )
5466             self.assertEqual(
5467                 virt.volume_infos(None, "vol2"),
5468                 {
5469                     "pool1": {
5470                         "vol2": {
5471                             "type": "file",
5472                             "key": "/key/of/vol2",
5473                             "path": "/path/to/vol2.qcow2",
5474                             "capacity": 12345,
5475                             "allocation": 1234,
5476                             "used_by": ["vm2"],
5477                             "backing_store": {
5478                                 "path": "/path/to/vol0.qcow2",
5479                                 "format": "qcow2",
5480                             },
5481                             "format": "qcow2",
5482                         }
5483                     }
5484                 },
5485             )
5486         with patch(
5487             "salt.modules.virt._get_domain", MagicMock(return_value=mock_vms[0])
5488         ):
5489 <a name="31"></a>            actual = virt.volume_infos("pool0", "vol0")
5490             self.assertEqual(1, len(actual.keys()))
5491             self.assertEqual(1, len(actual["pool0"].keys()))
5492 <a name="30"></a>            self.assertEqual(["vm0"], sorted(actual["pool0"]<font color="#3ea99f"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["vol0"]["used_by"]))
5493             self.assertEqual("/path/to/vol0.qcow2", actual["pool0"]["vol0"]["path"])
5494             self.assertEqual("file", actual["pool0"]["vol0"][</b></font>"type"])
5495             self.assertEqual("/key/of/vol0", actual["pool0"]<font color="#ae694a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["vol0"]["key"])
5496             self.assertEqual(123456789, actual["pool0"]["vol0"]["capacity"])
5497             self.assertEqual(123456, actual["pool0"]["vol0"][</b></font>"allocation"])
5498             self.assertEqual(
5499                 virt.volume_infos("pool1", None),
5500                 {
5501                     "pool1": {
5502                         "vol1": {
5503                             "type": "file",
5504                             "key": "/key/of/vol1",
5505                             "path": "/path/to/vol1.qcow2",
5506                             "capacity": 12345,
5507                             "allocation": 1234,
5508                             "used_by": [],
5509                             "backing_store": None,
5510                             "format": "qcow2",
5511                         },
5512                         "vol2": {
5513                             "type": "file",
5514                             "key": "/key/of/vol2",
5515                             "path": "/path/to/vol2.qcow2",
5516                             "capacity": 12345,
5517                             "allocation": 1234,
5518                             "used_by": [],
5519                             "backing_store": {
5520                                 "path": "/path/to/vol0.qcow2",
5521                                 "format": "qcow2",
5522                             },
5523                             "format": "qcow2",
5524                         },
5525                     }
5526                 },
5527             )
5528             self.assertEqual(
5529                 virt.volume_infos(None, "vol2"),
5530                 {
5531                     "pool1": {
5532                         "vol2": {
5533                             "type": "file",
5534                             "key": "/key/of/vol2",
5535                             "path": "/path/to/vol2.qcow2",
5536                             "capacity": 12345,
5537                             "allocation": 1234,
5538                             "used_by": [],
5539                             "backing_store": {
5540                                 "path": "/path/to/vol0.qcow2",
5541                                 "format": "qcow2",
5542                             },
5543                             "format": "qcow2",
5544                         }
5545                     }
5546                 },
5547             )
5548         with patch(
5549             "salt.modules.virt._get_domain",
5550             MagicMock(side_effect=CommandExecutionError("no VM")),
5551         ):
5552             actual = virt.volume_infos("pool0", "vol0")
5553             self.assertEqual(1, len(actual.keys()))
5554             self.assertEqual(1, len(actual["pool0"].keys()))
5555             self.assertEqual([], sorted(actual["pool0"]["vol0"]["used_by"]))
5556             self.assertEqual("/path/to/vol0.qcow2", actual["pool0"]["vol0"]["path"])
5557             self.assertEqual("file", actual["pool0"]["vol0"]["type"])
5558             self.assertEqual("/key/of/vol0", actual["pool0"]["vol0"]["key"])
5559             self.assertEqual(123456789, actual["pool0"]["vol0"]["capacity"])
5560             self.assertEqual(123456, actual["pool0"]["vol0"]["allocation"])
5561             self.assertEqual(
5562                 virt.volume_infos("pool1", None),
5563                 {
5564                     "pool1": {
5565                         "vol1": {
5566                             "type": "file",
5567                             "key": "/key/of/vol1",
5568                             "path": "/path/to/vol1.qcow2",
5569                             "capacity": 12345,
5570                             "allocation": 1234,
5571                             "used_by": [],
5572                             "backing_store": None,
5573                             "format": "qcow2",
5574                         },
5575                         "vol2": {
5576                             "type": "file",
5577                             "key": "/key/of/vol2",
5578                             "path": "/path/to/vol2.qcow2",
5579                             "capacity": 12345,
5580                             "allocation": 1234,
5581                             "used_by": [],
5582                             "backing_store": {
5583                                 "path": "/path/to/vol0.qcow2",
5584                                 "format": "qcow2",
5585                             },
5586                             "format": "qcow2",
5587                         },
5588                     }
5589                 },
5590             )
5591             self.assertEqual(
5592                 virt.volume_infos(None, "vol2"),
5593                 {
5594                     "pool1": {
5595                         "vol2": {
5596                             "type": "file",
5597                             "key": "/key/of/vol2",
5598                             "path": "/path/to/vol2.qcow2",
5599                             "capacity": 12345,
5600                             "allocation": 1234,
5601                             "used_by": [],
5602                             "backing_store": {
5603                                 "path": "/path/to/vol0.qcow2",
5604                                 "format": "qcow2",
5605                             },
5606                             "format": "qcow2",
5607                         }
5608                     }
5609                 },
5610             )
5611     def test_volume_delete(self):
5612         mock_delete = MagicMock(side_effect=[0, 1])
5613         mock_volume = MagicMock()
5614         mock_volume.delete = mock_delete  # pylint: disable=no-member
5615         mock_pool = MagicMock()
5616         mock_pool.storageVolLookupByName.side_effect = [
5617             mock_volume,
5618             mock_volume,
5619             self.mock_libvirt.libvirtError("Missing volume"),
5620             mock_volume,
5621         ]
5622         self.mock_conn.storagePoolLookupByName.side_effect = [
5623             mock_pool,
5624             mock_pool,
5625             mock_pool,
5626             self.mock_libvirt.libvirtError("Missing pool"),
5627         ]
5628         self.assertTrue(virt.volume_delete("default", "test_volume"))
5629         self.assertFalse(virt.volume_delete("default", "test_volume"))
5630         with self.assertRaises(self.mock_libvirt.libvirtError):
5631             virt.volume_delete("default", "missing")
5632             virt.volume_delete("missing", "test_volume")
5633         self.assertEqual(mock_delete.call_count, 2)
5634     def test_pool_capabilities(self):
5635         xml_caps = """
5636 &lt;storagepoolCapabilities&gt;
5637   &lt;pool type='disk' supported='yes'&gt;
5638     &lt;poolOptions&gt;
5639       &lt;defaultFormat type='unknown'/&gt;
5640       &lt;enum name='sourceFormatType'&gt;
5641         &lt;value&gt;unknown&lt;/value&gt;
5642         &lt;value&gt;dos&lt;/value&gt;
5643         &lt;value&gt;dvh&lt;/value&gt;
5644       &lt;/enum&gt;
5645     &lt;/poolOptions&gt;
5646     &lt;volOptions&gt;
5647       &lt;defaultFormat type='none'/&gt;
5648       &lt;enum name='targetFormatType'&gt;
5649         &lt;value&gt;none&lt;/value&gt;
5650         &lt;value&gt;linux&lt;/value&gt;
5651       &lt;/enum&gt;
5652     &lt;/volOptions&gt;
5653   &lt;/pool&gt;
5654   &lt;pool type='iscsi' supported='yes'&gt;
5655   &lt;/pool&gt;
5656   &lt;pool type='rbd' supported='yes'&gt;
5657     &lt;volOptions&gt;
5658       &lt;defaultFormat type='raw'/&gt;
5659       &lt;enum name='targetFormatType'&gt;
5660       &lt;/enum&gt;
5661     &lt;/volOptions&gt;
5662   &lt;/pool&gt;
5663   &lt;pool type='sheepdog' supported='no'&gt;
5664   &lt;/pool&gt;
5665 &lt;/storagepoolCapabilities&gt;
5666 <a name="14"></a>        """
5667         self.mock_conn.getStoragePoolCapabilities = MagicMock(return_value=xml_caps)
5668         actual = virt<font color="#842dce"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.pool_capabilities()
5669         self.assertEqual(
5670             {
5671                 "computed": False,
5672                 "pool_types": [
5673                     {
5674                         "name": "disk",
5675                         "supported": True,
5676                         "options": {
5677                             "pool": {
5678                                 "default_format": "unknown",
5679                                 "sourceFormatType": ["unknown", "dos", "dvh"],
5680                             },
5681                             "volume": {
5682                                 "default_format": "none",
5683                                 "targetFormatType": ["none", "linux"],
5684                             },
5685                         },
5686                     },
5687                     {"name": "iscsi", "supported": True},
5688                     {
5689                         "name": "rbd",
5690                         "supported": True,
5691                         "options": {
5692                             "volume": {"default_format": "raw", "targetFormatType": []}
5693                         },
5694                     },
5695                     {"name"</b></font>: "sheepdog", "supported": False},
5696                 ],
5697             },
5698             actual,
5699         )
5700     @patch("salt.modules.virt.get_hypervisor", return_value="kvm")
5701     def test_pool_capabilities_computed(self, mock_get_hypervisor):
5702         self.mock_conn.getLibVersion = MagicMock(return_value=4006000)
5703         del self.mock_conn.getStoragePoolCapabilities
5704         actual = virt.pool_capabilities()
5705         self.assertTrue(actual["computed"])
5706         backends = actual["pool_types"]
5707         self.assertFalse(
5708             [backend for backend in backends if backend["name"] == "iscsi-direct"][0][
5709                 "supported"
5710             ]
5711         )
5712         self.assertTrue(
5713             [backend for backend in backends if backend["name"] == "gluster"][0][
5714                 "supported"
5715             ]
5716         )
5717         self.assertFalse(
5718             [backend for backend in backends if backend["name"] == "zfs"][0][
5719                 "supported"
5720             ]
5721         )
5722         mock_get_hypervisor.return_value = "xen"
5723         backends = virt.pool_capabilities()["pool_types"]
5724         self.assertFalse(
5725             [backend for backend in backends if backend["name"] == "gluster"][0][
5726                 "supported"
5727             ]
5728         )
5729 <a name="8"></a>        mock_get_hypervisor.return_value = "bhyve"
5730         backends = virt.pool_capabilities()["pool_types"]
5731         self.assertFalse(
5732             [backend for backend in backends if backend<font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["name"] == "gluster"][0][
5733                 "supported"
5734             ]
5735         )
5736         self.assertTrue(
5737             [backend for backend in backends if backend["name"] == "zfs"][0][
5738                 "supported"
5739             ]
5740         )
5741         self.assertNotIn(
5742             "options",
5743             [backend for backend in backends if backend["name"] == "iscsi"][0],
5744         )
5745         self.assertNotIn(
5746             "pool",
5747             [backend for backend in backends if backend["name"] == "dir"][0]["options"],
5748         )
5749         self.assertNotIn(
5750             "volume",
5751             [backend for backend in backends if backend["name"] == "logical"][0][
5752                 "options"
5753             ],
5754         )
5755         self.</b></font>assertEqual(
5756             {
5757                 "pool": {
5758                     "default_format": "auto",
5759                     "sourceFormatType": ["auto", "nfs", "glusterfs", "cifs"],
5760                 },
5761                 "volume": {
5762                     "default_format": "raw",
5763                     "targetFormatType": [
5764                         "none",
5765                         "raw",
5766                         "dir",
5767                         "bochs",
5768                         "cloop",
5769                         "dmg",
5770                         "iso",
5771                         "vpc",
5772                         "vdi",
5773                         "fat",
5774                         "vhd",
5775                         "ploop",
5776                         "cow",
5777                         "qcow",
5778                         "qcow2",
5779                         "qed",
5780                         "vmdk",
5781                     ],
5782                 },
5783             },
5784             [backend for backend in backends if backend["name"] == "netfs"][0][
5785                 "options"
5786             ],
5787         )
5788     def test_get_domain(self):
5789         self.mock_conn.listDomainsID.return_value = []
5790         self.mock_conn.listDefinedDomains.return_value = []
5791         self.assertEqual([], virt._get_domain(self.mock_conn))
5792         self.assertRaisesRegex(
5793             CommandExecutionError,
5794             "No virtual machines found.",
5795             virt._get_domain,
5796             self.mock_conn,
5797             "vm2",
5798         )
5799         self.mock_conn.listDomainsID.return_value = [1]
5800         def create_mock_vm(idx):
5801             mock_vm = MagicMock()
5802             mock_vm.name.return_value = "vm{}".format(idx)
5803             return mock_vm
5804         mock_vms = [create_mock_vm(idx) for idx in range(3)]
5805         self.mock_conn.lookupByID.return_value = mock_vms[0]
5806         self.mock_conn.listDefinedDomains.return_value = ["vm1", "vm2"]
5807         self.mock_conn.lookupByName.side_effect = mock_vms
5808         self.assertEqual(mock_vms, virt._get_domain(self.mock_conn))
5809         self.mock_conn.lookupByName.side_effect = None
5810         self.mock_conn.lookupByName.return_value = mock_vms[0]
5811         self.assertEqual(mock_vms[0], virt._get_domain(self.mock_conn, inactive=False))
5812         self.mock_conn.lookupByName.return_value = None
5813         self.mock_conn.lookupByName.side_effect = [mock_vms[1], mock_vms[2]]
5814         self.assertEqual(
5815             [mock_vms[1], mock_vms[2]], virt._get_domain(self.mock_conn, active=False)
5816         )
5817 <a name="18"></a>
5818         self.mock_conn.reset_mock()
5819         self.mock_conn.lookupByName.return_value = None
5820         self.mock_conn.lookupByName.side_effect = [<font color="#800517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>mock_vms[1], mock_vms[2]]
5821         self.assertEqual(
5822             [mock_vms[1], mock_vms[2]], virt._get_domain(self.mock_conn, "vm1", "vm2")
5823         )
5824         self.assertRaisesRegex(
5825             CommandExecutionError,
5826             'The VM "vm2" is not present',
5827             virt._get_domain,
5828             self.</b></font>mock_conn,
5829             "vm2",
5830             inactive=False,
5831         )
5832     def test_volume_define(self):
5833         pool_mock = MagicMock()
5834         pool_mock.XMLDesc.return_value = "&lt;pool type='dir'&gt;&lt;/pool&gt;"
5835         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
5836         self.assertTrue(
5837             virt.volume_define(
5838                 "testpool",
5839                 "myvm_system.qcow2",
5840                 8192,
5841                 allocation=4096,
5842                 format="qcow2",
5843                 type="file",
5844             )
5845         )
5846         expected_xml = (
5847             "&lt;volume type='file'&gt;\n"
5848             "  &lt;name&gt;myvm_system.qcow2&lt;/name&gt;\n"
5849             "  &lt;source&gt;\n"
5850             "  &lt;/source&gt;\n"
5851             "  &lt;capacity unit='KiB'&gt;8388608&lt;/capacity&gt;\n"
5852             "  &lt;allocation unit='KiB'&gt;4194304&lt;/allocation&gt;\n"
5853             "  &lt;target&gt;\n"
5854             "    &lt;format type='qcow2'/&gt;\n"
5855             "  &lt;/target&gt;\n"
5856             "&lt;/volume&gt;"
5857         )
5858         pool_mock.createXML.assert_called_once_with(expected_xml, 0)
5859         pool_mock.reset_mock()
5860         self.assertTrue(
5861             virt.volume_define(
5862                 "testpool",
5863                 "myvm_system.qcow2",
5864                 8192,
5865                 allocation=4096,
5866                 format="qcow2",
5867                 type="file",
5868                 backing_store={"path": "/path/to/base.raw", "format": "raw"},
5869             )
5870         )
5871         expected_xml = (
5872             "&lt;volume type='file'&gt;\n"
5873             "  &lt;name&gt;myvm_system.qcow2&lt;/name&gt;\n"
5874             "  &lt;source&gt;\n"
5875             "  &lt;/source&gt;\n"
5876             "  &lt;capacity unit='KiB'&gt;8388608&lt;/capacity&gt;\n"
5877             "  &lt;allocation unit='KiB'&gt;4194304&lt;/allocation&gt;\n"
5878             "  &lt;target&gt;\n"
5879             "    &lt;format type='qcow2'/&gt;\n"
5880             "  &lt;/target&gt;\n"
5881             "  &lt;backingStore&gt;\n"
5882             "    &lt;path&gt;/path/to/base.raw&lt;/path&gt;\n"
5883             "    &lt;format type='raw'/&gt;\n"
5884             "  &lt;/backingStore&gt;\n"
5885             "&lt;/volume&gt;"
5886         )
5887         pool_mock.createXML.assert_called_once_with(expected_xml, 0)
5888         pool_mock.reset_mock()
5889         pool_mock.XMLDesc.return_value = "&lt;pool type='logical'&gt;&lt;/pool&gt;"
5890         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
5891         self.assertTrue(
5892             virt.volume_define(
5893                 "testVG",
5894                 "myvm_system",
5895                 8192,
5896                 backing_store={"path": "/dev/testVG/base"},
5897             )
5898         )
5899         expected_xml = (
5900             "&lt;volume&gt;\n"
5901             "  &lt;name&gt;myvm_system&lt;/name&gt;\n"
5902             "  &lt;source&gt;\n"
5903             "  &lt;/source&gt;\n"
5904             "  &lt;capacity unit='KiB'&gt;8388608&lt;/capacity&gt;\n"
5905             "  &lt;allocation unit='KiB'&gt;8388608&lt;/allocation&gt;\n"
5906             "  &lt;target&gt;\n"
5907             "  &lt;/target&gt;\n"
5908             "  &lt;backingStore&gt;\n"
5909             "    &lt;path&gt;/dev/testVG/base&lt;/path&gt;\n"
5910             "  &lt;/backingStore&gt;\n"
5911             "&lt;/volume&gt;"
5912         )
5913         pool_mock.createXML.assert_called_once_with(expected_xml, 0)
5914     def test_volume_upload(self):
5915         pool_mock = MagicMock()
5916         vol_mock = MagicMock()
5917         pool_mock.storageVolLookupByName.return_value = vol_mock
5918         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
5919         stream_mock = MagicMock()
5920         self.mock_conn.newStream.return_value = stream_mock
5921         open_mock = MagicMock()
5922         close_mock = MagicMock()
5923         with patch.dict(
5924             os.__dict__, {"open": open_mock, "close": close_mock}
5925             self.assertTrue(virt.volume_upload("pool0", "vol1.qcow2", "/path/to/file"))
5926             stream_mock<font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.sendAll.assert_called_once()
5927             stream_mock.finish.assert_called_once()
5928             self.mock_conn.close.assert_called_once()
5929             vol_mock.upload.assert_called_once_with(stream_mock, 0, 0, 0)
5930             stream_mock.sendAll.reset_mock()
5931             vol_mock.upload.</b></font>reset_mock()
5932             self.assertTrue(
5933                 virt.volume_upload(
5934                     "pool0",
5935                     "vol1.qcow2",
5936                     "/path/to/file",
5937                     offset=123,
5938                     length=456,
5939 <a name="29"></a>                    sparse=True,
5940                 )
5941             )
5942             stream_mock<font color="#af7a82"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.sendAll.assert_not_called()
5943             stream_mock.sparseSendAll.assert_called_once()
5944             vol_mock.upload.assert_called_once_with(
5945                 stream_mock,
5946                 123,
5947                 456,
5948                 self.mock_libvirt.VIR_STORAGE_VOL_UPLOAD_SPARSE_STREAM,
5949             )
5950             vol_mock.upload.</b></font>side_effect = self.mock_libvirt.libvirtError("Unsupported")
5951             self.assertRaisesRegex(
5952                 CommandExecutionError,
5953                 "Unsupported",
5954                 virt.volume_upload,
5955                 "pool0",
5956                 "vol1.qcow2",
5957                 "/path/to/file",
5958             )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
