<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for vsanmgmtObjects.py &amp; test_virt_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for vsanmgmtObjects.py &amp; test_virt_1.py
      </h3>
<h1 align="center">
        13.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>vsanmgmtObjects.py (54.909985%)<th>test_virt_1.py (7.989046%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1086-1424)<td><a href="#" name="0">(4790-4976)</a><td align="center"><font color="#ff0000">80</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(970-1080)<td><a href="#" name="1">(2373-2456)</a><td align="center"><font color="#660000">32</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(3751-3907)<td><a href="#" name="2">(570-582)</a><td align="center"><font color="#590000">28</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(62-193)<td><a href="#" name="3">(5087-5133)</a><td align="center"><font color="#590000">28</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(2997-3078)<td><a href="#" name="4">(6013-6021)</a><td align="center"><font color="#560000">27</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(800-883)<td><a href="#" name="5">(3836-3873)</a><td align="center"><font color="#520000">26</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(3128-3183)<td><a href="#" name="6">(6421-6426)</a><td align="center"><font color="#490000">23</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(2537-2599)<td><a href="#" name="7">(6007-6013)</a><td align="center"><font color="#490000">23</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(2325-2381)<td><a href="#" name="8">(6756-6781)</a><td align="center"><font color="#490000">23</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(2486-2534)<td><a href="#" name="9">(5190-5202)</a><td align="center"><font color="#420000">21</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(1511-1592)<td><a href="#" name="10">(732-762)</a><td align="center"><font color="#420000">21</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(2664-2718)<td><a href="#" name="11">(6988-6995)</a><td align="center"><font color="#390000">18</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(236-307)<td><a href="#" name="12">(1475-1501)</a><td align="center"><font color="#390000">18</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(1621-1693)<td><a href="#" name="13">(4006-4034)</a><td align="center"><font color="#360000">17</font>
<tr onclick='openModal("#842dce")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#842dce"><font color="#842dce">-</font><td><a href="#" name="14">(508-583)<td><a href="#" name="14">(6681-6708)</a><td align="center"><font color="#360000">17</font>
<tr onclick='openModal("#f52887")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f52887"><font color="#f52887">-</font><td><a href="#" name="15">(3548-3595)<td><a href="#" name="15">(5998-6006)</a><td align="center"><font color="#330000">16</font>
<tr onclick='openModal("#2981b2")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#2981b2"><font color="#2981b2">-</font><td><a href="#" name="16">(3496-3533)<td><a href="#" name="16">(5903-5911)</a><td align="center"><font color="#330000">16</font>
<tr onclick='openModal("#3090c7")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3090c7"><font color="#3090c7">-</font><td><a href="#" name="17">(406-448)<td><a href="#" name="17">(6310-6345)</a><td align="center"><font color="#330000">16</font>
<tr onclick='openModal("#800517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#800517"><font color="#800517">-</font><td><a href="#" name="18">(2131-2171)<td><a href="#" name="18">(6858-6866)</a><td align="center"><font color="#2f0000">15</font>
<tr onclick='openModal("#f62817")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f62817"><font color="#f62817">-</font><td><a href="#" name="19">(3373-3397)<td><a href="#" name="19">(1331-1341)</a><td align="center"><font color="#2c0000">14</font>
<tr onclick='openModal("#4e9258")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4e9258"><font color="#4e9258">-</font><td><a href="#" name="20">(2814-2859)<td><a href="#" name="20">(122-142)</a><td align="center"><font color="#2c0000">14</font>
<tr onclick='openModal("#947010")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#947010"><font color="#947010">-</font><td><a href="#" name="21">(2051-2081)<td><a href="#" name="21">(6021-6026)</a><td align="center"><font color="#2c0000">14</font>
<tr onclick='openModal("#4cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4cc417"><font color="#4cc417">-</font><td><a href="#" name="22">(3613-3645)<td><a href="#" name="22">(3922-3933)</a><td align="center"><font color="#290000">13</font>
<tr onclick='openModal("#f660ab")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f660ab"><font color="#f660ab">-</font><td><a href="#" name="23">(3412-3431)<td><a href="#" name="23">(3225-3247)</a><td align="center"><font color="#290000">13</font>
<tr onclick='openModal("#79764d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#79764d"><font color="#79764d">-</font><td><a href="#" name="24">(2741-2782)<td><a href="#" name="24">(1729-1737)</a><td align="center"><font color="#290000">13</font>
<tr onclick='openModal("#5eac10")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#5eac10"><font color="#5eac10">-</font><td><a href="#" name="25">(2384-2428)<td><a href="#" name="25">(822-833)</a><td align="center"><font color="#290000">13</font>
<tr onclick='openModal("#68818b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#68818b"><font color="#68818b">-</font><td><a href="#" name="26">(2242-2266)<td><a href="#" name="26">(2647-2661)</a><td align="center"><font color="#290000">13</font>
<tr onclick='openModal("#e77471")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#e77471"><font color="#e77471">-</font><td><a href="#" name="27">(2210-2232)<td><a href="#" name="27">(2338-2372)</a><td align="center"><font color="#290000">13</font>
<tr onclick='openModal("#717d7d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#717d7d"><font color="#717d7d">-</font><td><a href="#" name="28">(2083-2115)<td><a href="#" name="28">(2200-2209)</a><td align="center"><font color="#290000">13</font>
<tr onclick='openModal("#af7a82")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#af7a82"><font color="#af7a82">-</font><td><a href="#" name="29">(450-494)<td><a href="#" name="29">(7006-7016)</a><td align="center"><font color="#290000">13</font>
<tr onclick='openModal("#ae694a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ae694a"><font color="#ae694a">-</font><td><a href="#" name="30">(3655-3688)<td><a href="#" name="30">(6490-6492)</a><td align="center"><font color="#260000">12</font>
<tr onclick='openModal("#3ea99f")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3ea99f"><font color="#3ea99f">-</font><td><a href="#" name="31">(3437-3459)<td><a href="#" name="31">(6487-6489)</a><td align="center"><font color="#260000">12</font>
<tr onclick='openModal("#5b8daf")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#5b8daf"><font color="#5b8daf">-</font><td><a href="#" name="32">(1879-1912)<td><a href="#" name="32">(5557-5565)</a><td align="center"><font color="#260000">12</font>
<tr onclick='openModal("#736aff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#736aff"><font color="#736aff">-</font><td><a href="#" name="33">(665-704)<td><a href="#" name="33">(1346-1355)</a><td align="center"><font color="#260000">12</font>
<tr onclick='openModal("#827d6b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#827d6b"><font color="#827d6b">-</font><td><a href="#" name="34">(590-644)<td><a href="#" name="34">(3333-3354)</a><td align="center"><font color="#260000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>vsanmgmtObjects.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from pyVmomi.VmomiSupport import (
2     CreateDataType,
3     CreateManagedType,
4     CreateEnumType,
5     AddVersion,
6     AddVersionParent,
7     F_LINK,
8     F_LINKABLE,
9     F_OPTIONAL,
10 )
11 CreateManagedType(
12     "vim.cluster.VsanPerformanceManager",
13     "VsanPerformanceManager",
14     "vmodl.ManagedObject",
15     "vim.version.version9",
16     [],
17     [
18         (
19             "setStatsObjectPolicy",
20             "VsanPerfSetStatsObjectPolicy",
21             "vim.version.version9",
22             (
23                 (
24                     "cluster",
25                     "vim.ComputeResource",
26                     "vim.version.version9",
27                     0 | F_OPTIONAL,
28                     None,
29                 ),
30                 (
31                     "profile",
32                     "vim.vm.ProfileSpec",
33                     "vim.version.version9",
34                     0 | F_OPTIONAL,
35                     None,
36                 ),
37             ),
38             (0, "boolean", "boolean"),
39             "System.Read",
40             None,
41         ),
42         (
43             "deleteStatsObject",
44             "VsanPerfDeleteStatsObject",
45             "vim.version.version9",
46             (
47                 (
48                     "cluster",
49                     "vim.ComputeResource",
50                     "vim.version.version9",
51                     0 | F_OPTIONAL,
52                     None,
53                 ),
54             ),
55             (0, "boolean", "boolean"),
56             "System.Read",
57         ),
58         (
59             <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"createStatsObjectTask",
60             "VsanPerfCreateStatsObjectTask",
61             "vim.version.version9",
62             (
63                 (
64                     "cluster",
65                     "vim.ComputeResource",
66                     "vim.version.version9",
67                     0 | F_OPTIONAL,
68                     None,
69                 ),
70                 (
71                     "profile",
72                     "vim.vm.ProfileSpec",
73                     "vim.version.version9",
74                     0 | F_OPTIONAL,
75                     None,
76                 ),
77             ),
78             (0, "vim.Task", "vim.Task"),
79             "System.Read",
80             None,
81         ),
82         (
83             "deleteStatsObjectTask",
84             "VsanPerfDeleteStatsObjectTask",
85             "vim.version.version9",
86             (
87                 (
88                     "cluster",
89                     "vim.ComputeResource",
90                     "vim.version.version9",
91                     0 | F_OPTIONAL,
92                     None,
93                 ),
94             ),
95             (0, "vim.Task", "vim.Task"),
96             "System.Read",
97             None,
98         ),
99         (
100             "queryClusterHealth",
101             "VsanPerfQueryClusterHealth",
102             "vim.version.version9",
103             (
104                 (
105                     "cluster",
106                     "vim.ClusterComputeResource",
107                     "vim.version.version9",
108                     0,
109                     None,
110                 ),
111             ),
112             (0, "vmodl.DynamicData[]", "vmodl.DynamicData[]"),
113             "System.Read",
114             None,
115         ),
116         (
117             "queryStatsObjectInformation",
118             "VsanPerfQueryStatsObjectInformation",
119             "vim.version.version9",
120             (
121                 (
122                     "cluster",
123                     "vim.ComputeResource",
124                     "vim.version.version9",
125                     0 | F_OPTIONAL,
126                     None,
127                 ),
128             ),
129             (
130                 0,
131                 "vim.cluster.VsanObjectInformation",
132                 "vim.cluster.VsanObjectInformation",
133             ),
134             "System.Read",
135             None,
136         ),
137         (
138             "queryNodeInformation",
139             "VsanPerfQueryNodeInformation",
140             "vim.version.version9",
141             (
142                 (
143                     "cluster",
144                     "vim.ComputeResource",
145                     "vim.version.version9",
146                     0 | F_OPTIONAL,
147                     None,
148                 ),
149             ),
150             (
151                 0 | F_OPTIONAL,
152                 "vim.cluster.VsanPerfNodeInformation[]",
153                 "vim.cluster.VsanPerfNodeInformation[]",
154             ),
155             "System.Read",
156             None,
157         ),
158         (
159             "queryVsanPerf",
160             "VsanPerfQueryPerf",
161             "vim.version.version9",
162             (
163                 (
164                     "querySpecs",
165                     "vim.cluster.VsanPerfQuerySpec[]",
166                     "vim.version.version9",
167                     0,
168                     None,
169                 ),
170                 (
171                     "cluster",
172                     "vim.ComputeResource",
173                     "vim.version.version9",
174                     0 | F_OPTIONAL,
175                     None,
176                 ),
177             ),
178             (
179                 0,
180                 "vim.cluster.VsanPerfEntityMetricCSV[]",
181                 "vim.cluster.VsanPerfEntityMetricCSV[]",
182             ),
183             "System.Read",
184             None,
185         ),
186         (
187             "getSupportedEntityTypes",
188             "VsanPerfGetSupportedEntityTypes",
189             "vim.version.version9",
190             tuple(</b></font>),
191             (
192                 0 | F_OPTIONAL,
193                 "vim.cluster.VsanPerfEntityType[]",
194                 "vim.cluster.VsanPerfEntityType[]",
195             ),
196             "System.Read",
197             None,
198         ),
199         (
200             "createStatsObject",
201             "VsanPerfCreateStatsObject",
202             "vim.version.version9",
203             (
204                 (
205                     "cluster",
206                     "vim.ComputeResource",
207                     "vim.version.version9",
208                     0 | F_OPTIONAL,
209                     None,
210                 ),
211                 (
212                     "profile",
213                     "vim.vm.ProfileSpec",
214                     "vim.version.version9",
215                     0 | F_OPTIONAL,
216                     None,
217                 ),
218             ),
219             (0, "string", "string"),
220             "System.Read",
221             None,
222         ),
223     ],
224 )
225 CreateManagedType(
226     "vim.cluster.VsanVcDiskManagementSystem",
227     "VimClusterVsanVcDiskManagementSystem",
228     "vmodl.ManagedObject",
229     "vim.version.version10",
230     [
231         (
232             <font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"initializeDiskMappings",
233             "InitializeDiskMappings",
234             "vim.version.version10",
235             (
236                 (
237                     "spec",
238                     "vim.vsan.host.DiskMappingCreationSpec",
239                     "vim.version.version10",
240                     0,
241                     None,
242                 ),
243             ),
244             (0, "vim.Task", "vim.Task"),
245             "System.Read",
246             None,
247         ),
248         (
249             "retrieveAllFlashCapabilities",
250             "RetrieveAllFlashCapabilities",
251             "vim.version.version10",
252             (
253                 (
254                     "cluster",
255                     "vim.ClusterComputeResource",
256                     "vim.version.version10",
257                     0,
258                     None,
259                 ),
260             ),
261             (
262                 0 | F_OPTIONAL,
263                 "vim.vsan.host.VsanHostCapability[]",
264                 "vim.vsan.host.VsanHostCapability[]",
265             ),
266             "System.Read",
267             None,
268         ),
269         (
270             "queryDiskMappings",
271             "QueryDiskMappings",
272             "vim.version.version10",
273             (("host", "vim.HostSystem", "vim.version.version10", 0, None),),
274             (
275                 0 | F_OPTIONAL,
276                 "vim.vsan.host.DiskMapInfoEx[]",
277                 "vim.vsan.host.DiskMapInfoEx[]",
278             ),
279             "System.Read",
280             None,
281         ),
282     ],
283 )
284 CreateManagedType(
285     "vim.cluster.VsanObjectSystem",
286     "VsanObjectSystem",
287     "vmodl.ManagedObject",
288     "vim.version.version9",
289     [],
290     [
291         (
292             "setVsanObjectPolicy",
293             "VosSetVsanObjectPolicy",
294             "vim.version.version9",
295             (
296                 (
297                     "cluster",
298                     "vim.ComputeResource",
299                     "vim.version.version9",
300                     0 | F_OPTIONAL,
301                     None,
302                 ),
303                 ("vsanObjectUuid"</b></font>, "string", "vim.version.version9", 0, None),
304                 (
305                     "profile",
306                     "vim.vm.ProfileSpec",
307                     "vim.version.version9",
308                     0 | F_OPTIONAL,
309                     None,
310                 ),
311             ),
312             (0, "boolean", "boolean"),
313             "System.Read",
314             None,
315         ),
316         (
317             "queryObjectIdentities",
318             "VsanQueryObjectIdentities",
319             "vim.version.version9",
320             (
321                 (
322                     "cluster",
323                     "vim.ComputeResource",
324                     "vim.version.version9",
325                     0 | F_OPTIONAL,
326                     None,
327                 ),
328                 ("objUuids", "string[]", "vim.version.version9", 0 | F_OPTIONAL, None),
329                 (
330                     "includeHealth",
331                     "boolean",
332                     "vim.version.version9",
333                     0 | F_OPTIONAL,
334                     None,
335                 ),
336                 (
337                     "includeObjIdentity",
338                     "boolean",
339                     "vim.version.version9",
340                     0 | F_OPTIONAL,
341                     None,
342                 ),
343                 (
344                     "includeSpaceSummary",
345                     "boolean",
346                     "vim.version.version9",
347                     0 | F_OPTIONAL,
348                     None,
349                 ),
350             ),
351             (
352                 0 | F_OPTIONAL,
353                 "vim.cluster.VsanObjectIdentityAndHealth",
354                 "vim.cluster.VsanObjectIdentityAndHealth",
355             ),
356             "System.Read",
357             None,
358         ),
359         (
360             "queryVsanObjectInformation",
361             "VosQueryVsanObjectInformation",
362             "vim.version.version9",
363             (
364                 (
365                     "cluster",
366                     "vim.ComputeResource",
367                     "vim.version.version9",
368                     0 | F_OPTIONAL,
369                     None,
370                 ),
371                 (
372                     "vsanObjectQuerySpecs",
373                     "vim.cluster.VsanObjectQuerySpec[]",
374                     "vim.version.version9",
375                     0,
376                     None,
377                 ),
378             ),
379             (
380                 0,
381                 "vim.cluster.VsanObjectInformation[]",
382                 "vim.cluster.VsanObjectInformation[]",
383             ),
384             "System.Read",
385             None,
386         ),
387     ],
388 )
389 CreateManagedType(
390     "vim.host.VsanStretchedClusterSystem",
391     "VimHostVsanStretchedClusterSystem",
392     "vmodl.ManagedObject",
393     "vim.version.version10",
394     [],
395     [
396         (
397             "getStretchedClusterInfoFromCmmds",
398             "VSANHostGetStretchedClusterInfoFromCmmds",
399             tuple(),
400             (
401                 <font color="#3090c7"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>0 | F_OPTIONAL,
402                 "vim.host.VSANStretchedClusterHostInfo[]",
403                 "vim.host.VSANStretchedClusterHostInfo[]",
404             ),
405             "System.Read",
406             None,
407         ),
408         (
409             "witnessJoinVsanCluster",
410             "VSANWitnessJoinVsanCluster",
411             "vim.version.version10",
412             (
413                 ("clusterUuid", "string", "vim.version.version10", 0, None),
414                 ("preferredFd", "string", "vim.version.version10", 0, None),
415                 (
416                     "disableVsanAllowed",
417                     "boolean",
418                     "vim.version.version10",
419                     0 | F_OPTIONAL,
420                     None,
421                 ),
422             ),
423             (0, "void", "void"),
424             "System.Read",
425             None,
426         ),
427         (
428             "witnessSetPreferredFaultDomain",
429             "VSANWitnessSetPreferredFaultDomain",
430             "vim.version.version10",
431             (("preferredFd", "string", "vim.version.version10", 0, None),),
432             (0, "void", "void"),
433             "System.Read",
434             None,
435         ),
436         (
437             "addUnicastAgent",
438             "VSANHostAddUnicastAgent",
439             "vim.version.version10",
440             (
441                 ("witnessAddress", "string", "vim.version.version10", 0, None),
442                 ("overwrite"</b></font>, "boolean", "vim.version.version10", 0 | F_OPTIONAL, None),
443             ),
444             (<font color="#af7a82"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>0, "void", "void"),
445             "System.Read",
446             None,
447         ),
448         (
449             "clusterGetPreferredFaultDomain",
450             "VSANClusterGetPreferredFaultDomain",
451             "vim.version.version10",
452             tuple(),
453             (
454                 0 | F_OPTIONAL,
455                 "vim.host.VSANCmmdsPreferredFaultDomainInfo",
456                 "vim.host.VSANCmmdsPreferredFaultDomainInfo",
457             ),
458             "System.Read",
459             None,
460         ),
461         (
462             "witnessLeaveVsanCluster",
463             "VSANWitnessLeaveVsanCluster",
464             "vim.version.version10",
465             tuple(),
466             (0, "void", "void"),
467             "System.Read",
468             None,
469         ),
470         (
471             "getStretchedClusterCapability",
472             "VSANHostGetStretchedClusterCapability",
473             "vim.version.version10",
474             tuple(),
475             (
476                 0,
477                 "vim.host.VSANStretchedClusterHostCapability",
478                 "vim.host.VSANStretchedClusterHostCapability",
479             ),
480             "System.Read",
481             None,
482         ),
483         (
484             "removeUnicastAgent",
485             "VSANHostRemoveUnicastAgent",
486             "vim.version.version10",
487             (
488                 ("witnessAddress"</b></font>, "string", "vim.version.version10", 0, None),
489                 (
490                     "ignoreExistence",
491                     "boolean",
492                     "vim.version.version10",
493                     0 | F_OPTIONAL,
494                     None,
495                 ),
496             ),
497             (0, "void", "void"),
498             "System.Read",
499         ),
500         (
501             <font color="#842dce"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"listUnicastAgent",
502             "VSANHostListUnicastAgent",
503             "vim.version.version10",
504             tuple(),
505             (0, "string", "string"),
506             "System.Read",
507             None,
508         ),
509     ],
510 )
511 CreateManagedType(
512     "vim.VsanUpgradeSystemEx",
513     "VsanUpgradeSystemEx",
514     "vmodl.ManagedObject",
515     "vim.version.version10",
516     [],
517     [
518         (
519             "performUpgrade",
520             "PerformVsanUpgradeEx",
521             "vim.version.version10",
522             (
523                 (
524                     "cluster",
525                     "vim.ClusterComputeResource",
526                     "vim.version.version10",
527                     0,
528                     None,
529                 ),
530                 (
531                     "performObjectUpgrade",
532                     "boolean",
533                     "vim.version.version10",
534                     0 | F_OPTIONAL,
535                     None,
536                 ),
537                 (
538                     "downgradeFormat",
539                     "boolean",
540                     "vim.version.version10",
541                     0 | F_OPTIONAL,
542                     None,
543                 ),
544                 (
545                     "allowReducedRedundancy",
546                     "boolean",
547                     "vim.version.version10",
548                     0 | F_OPTIONAL,
549                     None,
550                 ),
551                 (
552                     "excludeHosts",
553                     "vim.HostSystem[]",
554                     "vim.version.version10",
555                     0 | F_OPTIONAL,
556                     None,
557                 ),
558                 (
559                     "spec",
560                     "vim.cluster.VsanDiskFormatConversionSpec",
561                     "vim.version.version10",
562                     0 | F_OPTIONAL,
563                     None,
564                 ),
565             ),
566             (0, "vim.Task", "vim.Task"),
567             "System.Read",
568             None,
569         ),
570         (
571             "performUpgradePreflightCheck",
572             "PerformVsanUpgradePreflightCheckEx",
573             "vim.version.version10",
574             (
575                 (
576                     "cluster"</b></font>,
577                     "vim.ClusterComputeResource",
578                     "vim.version.version10",
579                     0,
580                 ),
581                 (
582                     <font color="#827d6b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"downgradeFormat",
583                     "boolean",
584                     "vim.version.version10",
585                     0 | F_OPTIONAL,
586                     None,
587                 ),
588                 (
589                     "spec",
590                     "vim.cluster.VsanDiskFormatConversionSpec",
591                     "vim.version.version10",
592                     0 | F_OPTIONAL,
593                     None,
594                 ),
595             ),
596             (
597                 0,
598                 "vim.cluster.VsanDiskFormatConversionCheckResult",
599                 "vim.cluster.VsanDiskFormatConversionCheckResult",
600             ),
601             "System.Read",
602             None,
603         ),
604         (
605             "retrieveSupportedFormatVersion",
606             "RetrieveSupportedVsanFormatVersion",
607             "vim.version.version10",
608             (
609                 (
610                     "cluster",
611                     "vim.ClusterComputeResource",
612                     "vim.version.version10",
613                     0,
614                     None,
615                 ),
616             ),
617             (0, "int", "int"),
618             "System.Read",
619             None,
620         ),
621     ],
622 )
623 CreateManagedType(
624     "vim.cluster.VsanCapabilitySystem",
625     "VsanCapabilitySystem",
626     "vmodl.ManagedObject",
627     "vim.version.version10",
628     [],
629     [
630         (
631             "getCapabilities",
632             "VsanGetCapabilities",
633             "vim.version.version10",
634             (
635                 (
636                     "targets"</b></font>,
637                     "vmodl.ManagedObject[]",
638                     "vim.version.version10",
639                     0 | F_OPTIONAL,
640                     None,
641                 ),
642             ),
643             (0, "vim.cluster.VsanCapability[]", "vim.cluster.VsanCapability[]"),
644             "System.Read",
645             None,
646         ),
647     ],
648 )
649 CreateManagedType(
650     "vim.cluster.VsanSpaceReportSystem",
651     "VsanSpaceReportSystem",
652     "vmodl.ManagedObject",
653     "vim.version.version9",
654     [
655         (
656             <font color="#736aff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"querySpaceUsage",
657             "VsanQuerySpaceUsage",
658             "vim.version.version9",
659             (("cluster", "vim.ComputeResource", "vim.version.version9", 0, None),),
660             (0, "vim.cluster.VsanSpaceUsage", "vim.cluster.VsanSpaceUsage"),
661             "System.Read",
662             None,
663         ),
664     ],
665 )
666 CreateManagedType(
667     "vim.cluster.VsanVcClusterConfigSystem",
668     "VsanVcClusterConfigSystem",
669     "vmodl.ManagedObject",
670     "vim.version.version10",
671     [],
672     [
673         (
674             "getConfigInfoEx",
675             "VsanClusterGetConfig",
676             "vim.version.version10",
677             (
678                 (
679                     "cluster",
680                     "vim.ClusterComputeResource",
681                     "vim.version.version10",
682                     0,
683                     None,
684                 ),
685             ),
686             (0, "vim.vsan.ConfigInfoEx", "vim.vsan.ConfigInfoEx"),
687             "System.Read",
688             None,
689         ),
690         (
691             "reconfigureEx",
692             "VsanClusterReconfig",
693             "vim.version.version10",
694             (
695                 (</b></font>
696                     "cluster",
697                     "vim.ClusterComputeResource",
698                     "vim.version.version10",
699                     0,
700                     None,
701                 ),
702                 (
703                     "vsanReconfigSpec",
704                     "vim.vsan.ReconfigSpec",
705                     "vim.version.version10",
706                     0,
707                     None,
708                 ),
709             ),
710             (0, "vim.Task", "vim.Task"),
711             "System.Read",
712             None,
713         ),
714     ],
715 )
716 CreateManagedType(
717     "vim.host.VsanHealthSystem",
718     "HostVsanHealthSystem",
719     "vmodl.ManagedObject",
720     "vim.version.version9",
721     [],
722     [
723         (
724             "queryAdvCfg",
725             "VsanHostQueryAdvCfg",
726             "vim.version.version9",
727             (("options", "string[]", "vim.version.version9", 0, None),),
728             (0, "vim.option.OptionValue[]", "vim.option.OptionValue[]"),
729             "System.Read",
730             None,
731         ),
732         (
733             "queryPhysicalDiskHealthSummary",
734             "VsanHostQueryPhysicalDiskHealthSummary",
735             "vim.version.version9",
736             tuple(),
737             (
738                 0,
739                 "vim.host.VsanPhysicalDiskHealthSummary",
740                 "vim.host.VsanPhysicalDiskHealthSummary",
741             ),
742             "System.Read",
743             None,
744         ),
745         (
746             "startProactiveRebalance",
747             "VsanStartProactiveRebalance",
748             "vim.version.version9",
749             (
750                 ("timeSpan", "int", "vim.version.version9", 0 | F_OPTIONAL, None),
751                 (
752                     "varianceThreshold",
753                     "float",
754                     "vim.version.version9",
755                     0 | F_OPTIONAL,
756                     None,
757                 ),
758                 ("timeThreshold", "int", "vim.version.version9", 0 | F_OPTIONAL, None),
759                 ("rateThreshold", "int", "vim.version.version9", 0 | F_OPTIONAL, None),
760             ),
761             (0, "boolean", "boolean"),
762             "System.Read",
763             None,
764         ),
765         (
766             "queryHostInfoByUuids",
767             "VsanHostQueryHostInfoByUuids",
768             "vim.version.version9",
769             (("uuids", "string[]", "vim.version.version9", 0, None),),
770             (
771                 0,
772                 "vim.host.VsanQueryResultHostInfo[]",
773                 "vim.host.VsanQueryResultHostInfo[]",
774             ),
775             "System.Read",
776             None,
777         ),
778         (
779             "queryVersion",
780             "VsanHostQueryHealthSystemVersion",
781             "vim.version.version9",
782             tuple(),
783             (0, "string", "string"),
784             "System.Read",
785             None,
786         ),
787         (
788             "VsanHostQueryVerifyNetworkSettings",
789             "vim.version.version9",
790             (<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("peers", "string[]", "vim.version.version9", 0 | F_OPTIONAL, None),),
791             (0, "vim.host.VsanNetworkHealthResult", "vim.host.VsanNetworkHealthResult"),
792             "System.Read",
793             None,
794         ),
795         (
796             "queryRunIperfClient",
797             "VsanHostQueryRunIperfClient",
798             "vim.version.version9",
799             (
800                 ("multicast", "boolean", "vim.version.version9", 0, None),
801                 ("serverIp", "string", "vim.version.version9", 0, None),
802             ),
803             (
804                 0,
805                 "vim.host.VsanNetworkLoadTestResult",
806                 "vim.host.VsanNetworkLoadTestResult",
807             ),
808             "System.Read",
809             None,
810         ),
811         (
812             "runVmdkLoadTest",
813             "VsanHostRunVmdkLoadTest",
814             "vim.version.version9",
815             (
816                 ("runname", "string", "vim.version.version9", 0, None),
817                 ("durationSec", "int", "vim.version.version9", 0, None),
818                 (
819                     "specs",
820                     "vim.host.VsanVmdkLoadTestSpec[]",
821                     "vim.version.version9",
822                     0,
823                     None,
824                 ),
825             ),
826             (
827                 0,
828                 "vim.host.VsanVmdkLoadTestResult[]",
829                 "vim.host.VsanVmdkLoadTestResult[]",
830             ),
831             "System.Read",
832             None,
833         ),
834         (
835             "queryObjectHealthSummary",
836             "VsanHostQueryObjectHealthSummary",
837             "vim.version.version9",
838             (
839                 ("objUuids", "string[]", "vim.version.version9", 0 | F_OPTIONAL, None),
840                 (
841                     "includeObjUuids",
842                     "boolean",
843                     "vim.version.version9",
844                     0 | F_OPTIONAL,
845                     None,
846                 ),
847                 (
848                     "localHostOnly",
849                     "boolean",
850                     "vim.version.version9",
851                     0 | F_OPTIONAL,
852                     None,
853                 ),
854             ),
855             (0, "vim.host.VsanObjectOverallHealth", "vim.host.VsanObjectOverallHealth"),
856             "System.Read",
857             None,
858         ),
859         (
860             "getHclInfo",
861             "VsanGetHclInfo",
862             "vim.version.version9",
863             tuple(),
864             (0, "vim.host.VsanHostHclInfo", "vim.host.VsanHostHclInfo"),
865             "System.Read",
866             None,
867         ),
868         (
869             "cleanupVmdkLoadTest",
870             "VsanHostCleanupVmdkLoadTest",
871             "vim.version.version9",
872             (
873                 ("runname"</b></font>, "string", "vim.version.version9", 0, None),
874                 (
875                     "specs",
876                     "vim.host.VsanVmdkLoadTestSpec[]",
877                     "vim.version.version9",
878                     0 | F_OPTIONAL,
879                     None,
880                 ),
881             ),
882             (0, "string", "string"),
883             "System.Read",
884             None,
885         ),
886         (
887             "waitForVsanHealthGenerationIdChange",
888             "VsanWaitForVsanHealthGenerationIdChange",
889             "vim.version.version9",
890             (("timeout", "int", "vim.version.version9", 0, None),),
891             (0, "boolean", "boolean"),
892             "System.Read",
893             None,
894         ),
895         (
896             "stopProactiveRebalance",
897             "VsanStopProactiveRebalance",
898             "vim.version.version9",
899             tuple(),
900             (0, "boolean", "boolean"),
901             "System.Read",
902             None,
903         ),
904         (
905             "repairImmediateObjects",
906             "VsanHostRepairImmediateObjects",
907             "vim.version.version9",
908             (
909                 ("uuids", "string[]", "vim.version.version9", 0 | F_OPTIONAL, None),
910                 ("repairType", "string", "vim.version.version9", 0 | F_OPTIONAL, None),
911             ),
912             (0, "vim.host.VsanRepairObjectsResult", "vim.host.VsanRepairObjectsResult"),
913             "System.Read",
914             None,
915         ),
916         (
917             "prepareVmdkLoadTest",
918             "VsanHostPrepareVmdkLoadTest",
919             "vim.version.version9",
920             (
921                 ("runname", "string", "vim.version.version9", 0, None),
922                 (
923                     "specs",
924                     "vim.host.VsanVmdkLoadTestSpec[]",
925                     "vim.version.version9",
926                     0,
927                     None,
928                 ),
929             ),
930             (0, "string", "string"),
931             "System.Read",
932             None,
933         ),
934         (
935             "queryRunIperfServer",
936             "VsanHostQueryRunIperfServer",
937             "vim.version.version9",
938             (
939                 ("multicast", "boolean", "vim.version.version9", 0, None),
940                 ("serverIp", "string", "vim.version.version9", 0 | F_OPTIONAL, None),
941             ),
942             (
943                 0,
944                 "vim.host.VsanNetworkLoadTestResult",
945                 "vim.host.VsanNetworkLoadTestResult",
946             ),
947             "System.Read",
948             None,
949         ),
950         (
951             "queryCheckLimits",
952             "VsanHostQueryCheckLimits",
953             "vim.version.version9",
954             tuple(),
955             (0, "vim.host.VsanLimitHealthResult", "vim.host.VsanLimitHealthResult"),
956             "System.Read",
957         ),
958         (
959             <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"getProactiveRebalanceInfo",
960             "VsanGetProactiveRebalanceInfo",
961             "vim.version.version9",
962             tuple(),
963             (
964                 0,
965                 "vim.host.VsanProactiveRebalanceInfoEx",
966                 "vim.host.VsanProactiveRebalanceInfoEx",
967             ),
968             "System.Read",
969             None,
970         ),
971         (
972             "checkClomdLiveness",
973             "VsanHostClomdLiveness",
974             "vim.version.version9",
975             tuple(),
976             (0, "boolean", "boolean"),
977             "System.Read",
978             None,
979         ),
980     ],
981 )
982 CreateManagedType(
983     "vim.cluster.VsanVcClusterHealthSystem",
984     "VsanVcClusterHealthSystem",
985     "vmodl.ManagedObject",
986     "vim.version.version9",
987     [],
988     [
989         (
990             "queryClusterCreateVmHealthHistoryTest",
991             "VsanQueryVcClusterCreateVmHealthHistoryTest",
992             "vim.version.version9",
993             (
994                 (
995                     "cluster",
996                     "vim.ClusterComputeResource",
997                     "vim.version.version9",
998                     0,
999                     None,
1000                 ),
1001                 ("count", "int", "vim.version.version9", 0 | F_OPTIONAL, None),
1002             ),
1003             (
1004                 0 | F_OPTIONAL,
1005                 "vim.cluster.VsanClusterCreateVmHealthTestResult[]",
1006                 "vim.cluster.VsanClusterCreateVmHealthTestResult[]",
1007             ),
1008             "System.Read",
1009             None,
1010         ),
1011         (
1012             "setLogLevel",
1013             "VsanHealthSetLogLevel",
1014             "vim.version.version9",
1015             (
1016                 (
1017                     "level",
1018                     "vim.cluster.VsanHealthLogLevelEnum",
1019                     "vim.version.version9",
1020                     0 | F_OPTIONAL,
1021                     None,
1022                 ),
1023             ),
1024             (0, "void", "void"),
1025             "System.Read",
1026             None,
1027         ),
1028         (
1029             "testVsanClusterTelemetryProxy",
1030             "VsanHealthTestVsanClusterTelemetryProxy",
1031             "vim.version.version9",
1032             (
1033                 (
1034                     "proxyConfig",
1035                     "vim.cluster.VsanClusterTelemetryProxyConfig",
1036                     "vim.version.version9",
1037                     0,
1038                     None,
1039                 ),
1040             ),
1041             (0, "boolean", "boolean"),
1042             "System.Read",
1043             None,
1044         ),
1045         (
1046             "uploadHclDb",
1047             "VsanVcUploadHclDb",
1048             "vim.version.version9",
1049             (("db", "string", "vim.version.version9", 0, None),),
1050             (0, "boolean", "boolean"),
1051             "System.Read",
1052             None,
1053         ),
1054         (
1055             "updateHclDbFromWeb",
1056             "VsanVcUpdateHclDbFromWeb",
1057             "vim.version.version9",
1058             (("url", "string", "vim.version.version9", 0 | F_OPTIONAL, None),),
1059             (0, "boolean", "boolean"),
1060             "System.Read",
1061             None,
1062         ),
1063         (
1064             "repairClusterObjectsImmediate",
1065             "VsanHealthRepairClusterObjectsImmediate",
1066             "vim.version.version9",
1067             (
1068                 (
1069                     "cluster"</b></font>,
1070                     "vim.ClusterComputeResource",
1071                     "vim.version.version9",
1072                     None,
1073                 ),
1074                 (<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"uuids", "string[]", "vim.version.version9", 0 | F_OPTIONAL, None),
1075             ),
1076             (0, "vim.Task", "vim.Task"),
1077             "System.Read",
1078             None,
1079         ),
1080         (
1081             "queryClusterNetworkPerfTest",
1082             "VsanQueryVcClusterNetworkPerfTest",
1083             "vim.version.version9",
1084             (
1085                 (
1086                     "cluster",
1087                     "vim.ClusterComputeResource",
1088                     "vim.version.version9",
1089                     0,
1090                     None,
1091                 ),
1092                 ("multicast", "boolean", "vim.version.version9", 0, None),
1093             ),
1094             (
1095                 0,
1096                 "vim.cluster.VsanClusterNetworkLoadTestResult",
1097                 "vim.cluster.VsanClusterNetworkLoadTestResult",
1098             ),
1099             "System.Read",
1100             None,
1101         ),
1102         (
1103             "queryClusterVmdkLoadHistoryTest",
1104             "VsanQueryVcClusterVmdkLoadHistoryTest",
1105             "vim.version.version9",
1106             (
1107                 (
1108                     "cluster",
1109                     "vim.ClusterComputeResource",
1110                     "vim.version.version9",
1111                     0,
1112                     None,
1113                 ),
1114                 ("count", "int", "vim.version.version9", 0 | F_OPTIONAL, None),
1115                 ("taskId", "string", "vim.version.version9", 0 | F_OPTIONAL, None),
1116             ),
1117             (
1118                 0 | F_OPTIONAL,
1119                 "vim.cluster.VsanClusterVmdkLoadTestResult[]",
1120                 "vim.cluster.VsanClusterVmdkLoadTestResult[]",
1121             ),
1122             "System.Read",
1123             None,
1124         ),
1125         (
1126             "queryVsanClusterHealthCheckInterval",
1127             "VsanHealthQueryVsanClusterHealthCheckInterval",
1128             "vim.version.version9",
1129             (
1130                 (
1131                     "cluster",
1132                     "vim.ClusterComputeResource",
1133                     "vim.version.version9",
1134                     0,
1135                     None,
1136                 ),
1137             ),
1138             (0, "int", "int"),
1139             "System.Read",
1140             None,
1141         ),
1142         (
1143             "queryClusterCreateVmHealthTest",
1144             "VsanQueryVcClusterCreateVmHealthTest",
1145             "vim.version.version9",
1146             (
1147                 (
1148                     "cluster",
1149                     "vim.ClusterComputeResource",
1150                     "vim.version.version9",
1151                     0,
1152                     None,
1153                 ),
1154                 ("timeout", "int", "vim.version.version9", 0, None),
1155             ),
1156             (
1157                 0,
1158                 "vim.cluster.VsanClusterCreateVmHealthTestResult",
1159                 "vim.cluster.VsanClusterCreateVmHealthTestResult",
1160             ),
1161             "System.Read",
1162             None,
1163         ),
1164         (
1165             "getClusterHclInfo",
1166             "VsanVcClusterGetHclInfo",
1167             "vim.version.version9",
1168             (
1169                 (
1170                     "cluster",
1171                     "vim.ClusterComputeResource",
1172                     "vim.version.version9",
1173                     0,
1174                     None,
1175                 ),
1176                 (
1177                     "includeHostsResult",
1178                     "boolean",
1179                     "vim.version.version9",
1180                     0 | F_OPTIONAL,
1181                     None,
1182                 ),
1183             ),
1184             (0, "vim.cluster.VsanClusterHclInfo", "vim.cluster.VsanClusterHclInfo"),
1185             "System.Read",
1186             None,
1187         ),
1188         (
1189             "queryAttachToSrHistory",
1190             "VsanQueryAttachToSrHistory",
1191             "vim.version.version9",
1192             (
1193                 (
1194                     "cluster",
1195                     "vim.ClusterComputeResource",
1196                     "vim.version.version9",
1197                     0,
1198                     None,
1199                 ),
1200                 ("count", "int", "vim.version.version9", 0 | F_OPTIONAL, None),
1201                 ("taskId", "string", "vim.version.version9", 0 | F_OPTIONAL, None),
1202             ),
1203             (
1204                 0 | F_OPTIONAL,
1205                 "vim.cluster.VsanAttachToSrOperation[]",
1206                 "vim.cluster.VsanAttachToSrOperation[]",
1207             ),
1208             "System.Read",
1209             None,
1210         ),
1211         (
1212             "rebalanceCluster",
1213             "VsanRebalanceCluster",
1214             "vim.version.version9",
1215             (
1216                 (
1217                     "cluster",
1218                     "vim.ClusterComputeResource",
1219                     "vim.version.version9",
1220                     0,
1221                     None,
1222                 ),
1223                 (
1224                     "targetHosts",
1225                     "vim.HostSystem[]",
1226                     "vim.version.version9",
1227                     0 | F_OPTIONAL,
1228                     None,
1229                 ),
1230             ),
1231             (0, "vim.Task", "vim.Task"),
1232             "System.Read",
1233             None,
1234         ),
1235         (
1236             "runVmdkLoadTest",
1237             "VsanVcClusterRunVmdkLoadTest",
1238             "vim.version.version9",
1239             (
1240                 (
1241                     "cluster",
1242                     "vim.ClusterComputeResource",
1243                     "vim.version.version9",
1244                     0,
1245                     None,
1246                 ),
1247                 ("runname", "string", "vim.version.version9", 0, None),
1248                 ("durationSec", "int", "vim.version.version9", 0 | F_OPTIONAL, None),
1249                 (
1250                     "specs",
1251                     "vim.host.VsanVmdkLoadTestSpec[]",
1252                     "vim.version.version9",
1253                     0 | F_OPTIONAL,
1254                     None,
1255                 ),
1256                 ("action", "string", "vim.version.version9", 0 | F_OPTIONAL, None),
1257             ),
1258             (0, "vim.Task", "vim.Task"),
1259             "System.Read",
1260             None,
1261         ),
1262         (
1263             "sendVsanTelemetry",
1264             "VsanHealthSendVsanTelemetry",
1265             "vim.version.version9",
1266             (
1267                 (
1268                     "cluster",
1269                     "vim.ClusterComputeResource",
1270                     "vim.version.version9",
1271                     0,
1272                     None,
1273                 ),
1274             ),
1275             (0, "void", "void"),
1276             "System.Read",
1277             None,
1278         ),
1279         (
1280             "queryClusterNetworkPerfHistoryTest",
1281             "VsanQueryVcClusterNetworkPerfHistoryTest",
1282             "vim.version.version9",
1283             (
1284                 (
1285                     "cluster",
1286                     "vim.ClusterComputeResource",
1287                     "vim.version.version9",
1288                     0,
1289                     None,
1290                 ),
1291                 ("count", "int", "vim.version.version9", 0 | F_OPTIONAL, None),
1292             ),
1293             (
1294                 0 | F_OPTIONAL,
1295                 "vim.cluster.VsanClusterNetworkLoadTestResult[]",
1296                 "vim.cluster.VsanClusterNetworkLoadTestResult[]",
1297             ),
1298             "System.Read",
1299             None,
1300         ),
1301         (
1302             "queryClusterHealthSummary",
1303             "VsanQueryVcClusterHealthSummary",
1304             "vim.version.version9",
1305             (
1306                 (
1307                     "cluster",
1308                     "vim.ClusterComputeResource",
1309                     "vim.version.version9",
1310                     0,
1311                     None,
1312                 ),
1313                 (
1314                     "vmCreateTimeout",
1315                     "int",
1316                     "vim.version.version9",
1317                     0 | F_OPTIONAL,
1318                     None,
1319                 ),
1320                 ("objUuids", "string[]", "vim.version.version9", 0 | F_OPTIONAL, None),
1321                 (
1322                     "includeObjUuids",
1323                     "boolean",
1324                     "vim.version.version9",
1325                     0 | F_OPTIONAL,
1326                     None,
1327                 ),
1328                 ("fields", "string[]", "vim.version.version9", 0 | F_OPTIONAL, None),
1329                 (
1330                     "fetchFromCache",
1331                     "boolean",
1332                     "vim.version.version9",
1333                     0 | F_OPTIONAL,
1334                     None,
1335                 ),
1336             ),
1337             (
1338                 0,
1339                 "vim.cluster.VsanClusterHealthSummary",
1340                 "vim.cluster.VsanClusterHealthSummary",
1341             ),
1342             "System.Read",
1343             None,
1344         ),
1345         (
1346             "stopRebalanceCluster",
1347             "VsanStopRebalanceCluster",
1348             "vim.version.version9",
1349             (
1350                 (
1351                     "cluster",
1352                     "vim.ClusterComputeResource",
1353                     "vim.version.version9",
1354                     0,
1355                     None,
1356                 ),
1357                 (
1358                     "targetHosts",
1359                     "vim.HostSystem[]",
1360                     "vim.version.version9",
1361                     0 | F_OPTIONAL,
1362                     None,
1363                 ),
1364             ),
1365             (0, "vim.Task", "vim.Task"),
1366             "System.Read",
1367             None,
1368         ),
1369         (
1370             "queryVsanClusterHealthConfig",
1371             "VsanHealthQueryVsanClusterHealthConfig",
1372             "vim.version.version9",
1373             (
1374                 (
1375                     "cluster",
1376                     "vim.ClusterComputeResource",
1377                     "vim.version.version9",
1378                     0,
1379                     None,
1380                 ),
1381             ),
1382             (
1383                 0,
1384                 "vim.cluster.VsanClusterHealthConfigs",
1385                 "vim.cluster.VsanClusterHealthConfigs",
1386             ),
1387             "System.Read",
1388             None,
1389         ),
1390         (
1391             "attachVsanSupportBundleToSr",
1392             "VsanAttachVsanSupportBundleToSr",
1393             "vim.version.version9",
1394             (
1395                 (
1396                     "cluster",
1397                     "vim.ClusterComputeResource",
1398                     "vim.version.version9",
1399                     0,
1400                     None,
1401                 ),
1402                 ("srNumber", "string", "vim.version.version9", 0, None),
1403             ),
1404             (0, "vim.Task", "vim.Task"),
1405             "System.Read",
1406             None,
1407         ),
1408         (
1409             "queryClusterVmdkWorkloadTypes",
1410             "VsanQueryVcClusterVmdkWorkloadTypes",
1411             "vim.version.version9",
1412             tuple(</b></font>),
1413             (
1414                 0,
1415                 "vim.cluster.VsanStorageWorkloadType[]",
1416                 "vim.cluster.VsanStorageWorkloadType[]",
1417             ),
1418             "System.Read",
1419             None,
1420         ),
1421         (
1422             "queryVerifyClusterHealthSystemVersions",
1423             "VsanVcClusterQueryVerifyHealthSystemVersions",
1424             "vim.version.version9",
1425             (
1426                 (
1427                     "cluster",
1428                     "vim.ClusterComputeResource",
1429                     "vim.version.version9",
1430                     0,
1431                     None,
1432                 ),
1433             ),
1434             (
1435                 0,
1436                 "vim.cluster.VsanClusterHealthSystemVersionResult",
1437                 "vim.cluster.VsanClusterHealthSystemVersionResult",
1438             ),
1439             "System.Read",
1440             None,
1441         ),
1442         (
1443             "isRebalanceRunning",
1444             "VsanHealthIsRebalanceRunning",
1445             "vim.version.version9",
1446             (
1447                 (
1448                     "cluster",
1449                     "vim.ClusterComputeResource",
1450                     "vim.version.version9",
1451                     0,
1452                     None,
1453                 ),
1454                 (
1455                     "targetHosts",
1456                     "vim.HostSystem[]",
1457                     "vim.version.version9",
1458                     0 | F_OPTIONAL,
1459                     None,
1460                 ),
1461             ),
1462             (0, "boolean", "boolean"),
1463             "System.Read",
1464             None,
1465         ),
1466         (
1467             "setVsanClusterHealthCheckInterval",
1468             "VsanHealthSetVsanClusterHealthCheckInterval",
1469             "vim.version.version9",
1470             (
1471                 (
1472                     "cluster",
1473                     "vim.ClusterComputeResource",
1474                     "vim.version.version9",
1475                     0,
1476                     None,
1477                 ),
1478                 (
1479                     "vsanClusterHealthCheckInterval",
1480                     "int",
1481                     "vim.version.version9",
1482                     0,
1483                     None,
1484                 ),
1485             ),
1486             (0, "void", "void"),
1487             "System.Read",
1488             None,
1489         ),
1490     ],
1491 )
1492 CreateManagedType(
1493     "vim.cluster.VsanVcStretchedClusterSystem",
1494     "VimClusterVsanVcStretchedClusterSystem",
1495     "vmodl.ManagedObject",
1496     [],
1497     [
1498         <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(
1499             "isWitnessHost",
1500             "VSANVcIsWitnessHost",
1501             "vim.version.version10",
1502             (("host", "vim.HostSystem", "vim.version.version10", 0, None),),
1503             (0, "boolean", "boolean"),
1504             "System.Read",
1505             None,
1506         ),
1507         (
1508             "setPreferredFaultDomain",
1509             "VSANVcSetPreferredFaultDomain",
1510             "vim.version.version10",
1511             (
1512                 (
1513                     "cluster",
1514                     "vim.ClusterComputeResource",
1515                     "vim.version.version10",
1516                     0,
1517                     None,
1518                 ),
1519                 ("preferredFd", "string", "vim.version.version10", 0, None),
1520                 (
1521                     "witnessHost",
1522                     "vim.HostSystem",
1523                     "vim.version.version10",
1524                     0 | F_OPTIONAL,
1525                     None,
1526                 ),
1527             ),
1528             (0, "vim.Task", "vim.Task"),
1529             "System.Read",
1530             None,
1531         ),
1532         (
1533             "getPreferredFaultDomain",
1534             "VSANVcGetPreferredFaultDomain",
1535             "vim.version.version10",
1536             (
1537                 (
1538                     "cluster",
1539                     "vim.ClusterComputeResource",
1540                     "vim.version.version10",
1541                     0,
1542                     None,
1543                 ),
1544             ),
1545             (
1546                 0 | F_OPTIONAL,
1547                 "vim.cluster.VSANPreferredFaultDomainInfo",
1548                 "vim.cluster.VSANPreferredFaultDomainInfo",
1549             ),
1550             "System.Read",
1551             None,
1552         ),
1553         (
1554             "getWitnessHosts",
1555             "VSANVcGetWitnessHosts",
1556             "vim.version.version10",
1557             (
1558                 (
1559                     "cluster",
1560                     "vim.ClusterComputeResource",
1561                     "vim.version.version10",
1562                     0,
1563                     None,
1564                 ),
1565             ),
1566             (
1567                 0 | F_OPTIONAL,
1568                 "vim.cluster.VSANWitnessHostInfo[]",
1569                 "vim.cluster.VSANWitnessHostInfo[]",
1570             ),
1571             "System.Read",
1572             None,
1573         ),
1574         (
1575             "retrieveStretchedClusterVcCapability",
1576             "VSANVcRetrieveStretchedClusterVcCapability",
1577             "vim.version.version10",
1578             (
1579                 (</b></font>
1580                     "cluster",
1581                     "vim.ClusterComputeResource",
1582                     "vim.version.version10",
1583                     0,
1584                     None,
1585                 ),
1586                 (
1587                     "verifyAllConnected",
1588                     "boolean",
1589                     "vim.version.version10",
1590                     0 | F_OPTIONAL,
1591                     None,
1592                 ),
1593             ),
1594             (
1595                 0 | F_OPTIONAL,
1596                 "vim.cluster.VSANStretchedClusterCapability[]",
1597                 "vim.cluster.VSANStretchedClusterCapability[]",
1598             ),
1599             "System.Read",
1600             None,
1601         ),
1602         (
1603             "convertToStretchedCluster",
1604             "VSANVcConvertToStretchedCluster",
1605             (
1606                 (
1607                     <font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"cluster",
1608                     "vim.ClusterComputeResource",
1609                     "vim.version.version10",
1610                     0,
1611                     None,
1612                 ),
1613                 (
1614                     "faultDomainConfig",
1615                     "vim.cluster.VSANStretchedClusterFaultDomainConfig",
1616                     "vim.version.version10",
1617                     0,
1618                     None,
1619                 ),
1620                 ("witnessHost", "vim.HostSystem", "vim.version.version10", 0, None),
1621                 ("preferredFd", "string", "vim.version.version10", 0, None),
1622                 (
1623                     "diskMapping",
1624                     "vim.vsan.host.DiskMapping",
1625                     "vim.version.version10",
1626                     0 | F_OPTIONAL,
1627                     None,
1628                 ),
1629             ),
1630             (0, "vim.Task", "vim.Task"),
1631             "System.Read",
1632             None,
1633         ),
1634         (
1635             "removeWitnessHost",
1636             "VSANVcRemoveWitnessHost",
1637             "vim.version.version10",
1638             (
1639                 (
1640                     "cluster",
1641                     "vim.ClusterComputeResource",
1642                     "vim.version.version10",
1643                     0,
1644                     None,
1645                 ),
1646                 (
1647                     "witnessHost",
1648                     "vim.HostSystem",
1649                     "vim.version.version10",
1650                     0 | F_OPTIONAL,
1651                     None,
1652                 ),
1653                 (
1654                     "witnessAddress",
1655                     "string",
1656                     "vim.version.version10",
1657                     0 | F_OPTIONAL,
1658                     None,
1659                 ),
1660             ),
1661             (0, "vim.Task", "vim.Task"),
1662             "System.Read",
1663             None,
1664         ),
1665     ],
1666 )
1667 CreateManagedType(
1668     "vim.cluster.VsanClusterHealthSystem",
1669     "VsanClusterHealthSystem",
1670     "vmodl.ManagedObject",
1671     "vim.version.version9",
1672     [],
1673     [
1674         (
1675             "queryPhysicalDiskHealthSummary",
1676             "VsanQueryClusterPhysicalDiskHealthSummary",
1677             "vim.version.version9",
1678             (
1679                 ("hosts"</b></font>, "string[]", "vim.version.version9", 0, None),
1680                 ("esxRootPassword", "string", "vim.version.version9", 0, None),
1681             ),
1682             (
1683                 0,
1684                 "vim.host.VsanPhysicalDiskHealthSummary[]",
1685                 "vim.host.VsanPhysicalDiskHealthSummary[]",
1686             ),
1687             "System.Read",
1688             None,
1689         ),
1690         (
1691             "queryClusterNetworkPerfTest",
1692             "VsanQueryClusterNetworkPerfTest",
1693             "vim.version.version9",
1694             (
1695                 ("hosts", "string[]", "vim.version.version9", 0, None),
1696                 ("esxRootPassword", "string", "vim.version.version9", 0, None),
1697                 ("multicast", "boolean", "vim.version.version9", 0, None),
1698             ),
1699             (
1700                 0,
1701                 "vim.cluster.VsanClusterNetworkLoadTestResult",
1702                 "vim.cluster.VsanClusterNetworkLoadTestResult",
1703             ),
1704             "System.Read",
1705             None,
1706         ),
1707         (
1708             "queryAdvCfgSync",
1709             "VsanQueryClusterAdvCfgSync",
1710             "vim.version.version9",
1711             (
1712                 ("hosts", "string[]", "vim.version.version9", 0, None),
1713                 ("esxRootPassword", "string", "vim.version.version9", 0, None),
1714             ),
1715             (
1716                 0,
1717                 "vim.cluster.VsanClusterAdvCfgSyncResult[]",
1718                 "vim.cluster.VsanClusterAdvCfgSyncResult[]",
1719             ),
1720             "System.Read",
1721             None,
1722         ),
1723         (
1724             "repairClusterImmediateObjects",
1725             "VsanRepairClusterImmediateObjects",
1726             "vim.version.version9",
1727             (
1728                 ("hosts", "string[]", "vim.version.version9", 0, None),
1729                 ("esxRootPassword", "string", "vim.version.version9", 0, None),
1730                 ("uuids", "string[]", "vim.version.version9", 0 | F_OPTIONAL, None),
1731             ),
1732             (
1733                 0,
1734                 "vim.cluster.VsanClusterHealthSystemObjectsRepairResult",
1735                 "vim.cluster.VsanClusterHealthSystemObjectsRepairResult",
1736             ),
1737             "System.Read",
1738             None,
1739         ),
1740         (
1741             "queryVerifyClusterNetworkSettings",
1742             "VsanQueryVerifyClusterNetworkSettings",
1743             "vim.version.version9",
1744             (
1745                 ("hosts", "string[]", "vim.version.version9", 0, None),
1746                 ("esxRootPassword", "string", "vim.version.version9", 0, None),
1747             ),
1748             (
1749                 0,
1750                 "vim.cluster.VsanClusterNetworkHealthResult",
1751                 "vim.cluster.VsanClusterNetworkHealthResult",
1752             ),
1753             "System.Read",
1754             None,
1755         ),
1756         (
1757             "queryClusterCreateVmHealthTest",
1758             "VsanQueryClusterCreateVmHealthTest",
1759             "vim.version.version9",
1760             (
1761                 ("hosts", "string[]", "vim.version.version9", 0, None),
1762                 ("esxRootPassword", "string", "vim.version.version9", 0, None),
1763                 ("timeout", "int", "vim.version.version9", 0, None),
1764             ),
1765             (
1766                 0,
1767                 "vim.cluster.VsanClusterCreateVmHealthTestResult",
1768                 "vim.cluster.VsanClusterCreateVmHealthTestResult",
1769             ),
1770             "System.Read",
1771             None,
1772         ),
1773         (
1774             "queryClusterHealthSystemVersions",
1775             "VsanQueryClusterHealthSystemVersions",
1776             "vim.version.version9",
1777             (
1778                 ("hosts", "string[]", "vim.version.version9", 0, None),
1779                 ("esxRootPassword", "string", "vim.version.version9", 0, None),
1780             ),
1781             (
1782                 0,
1783                 "vim.cluster.VsanClusterHealthSystemVersionResult",
1784                 "vim.cluster.VsanClusterHealthSystemVersionResult",
1785             ),
1786             "System.Read",
1787             None,
1788         ),
1789         (
1790             "getClusterHclInfo",
1791             "VsanClusterGetHclInfo",
1792             "vim.version.version9",
1793             (
1794                 ("hosts", "string[]", "vim.version.version9", 0, None),
1795                 ("esxRootPassword", "string", "vim.version.version9", 0, None),
1796             ),
1797             (0, "vim.cluster.VsanClusterHclInfo", "vim.cluster.VsanClusterHclInfo"),
1798             "System.Read",
1799             None,
1800         ),
1801         (
1802             "queryCheckLimits",
1803             "VsanQueryClusterCheckLimits",
1804             "vim.version.version9",
1805             (
1806                 ("hosts", "string[]", "vim.version.version9", 0, None),
1807                 ("esxRootPassword", "string", "vim.version.version9", 0, None),
1808             ),
1809             (
1810                 0,
1811                 "vim.cluster.VsanClusterLimitHealthResult",
1812                 "vim.cluster.VsanClusterLimitHealthResult",
1813             ),
1814             "System.Read",
1815             None,
1816         ),
1817         (
1818             "queryCaptureVsanPcap",
1819             "VsanQueryClusterCaptureVsanPcap",
1820             "vim.version.version9",
1821             (
1822                 ("hosts", "string[]", "vim.version.version9", 0, None),
1823                 ("esxRootPassword", "string", "vim.version.version9", 0, None),
1824                 ("duration", "int", "vim.version.version9", 0, None),
1825                 (
1826                     "vmknic",
1827                     "vim.cluster.VsanClusterHostVmknicMapping[]",
1828                     "vim.version.version9",
1829                     0 | F_OPTIONAL,
1830                     None,
1831                 ),
1832                 (
1833                     "includeRawPcap",
1834                     "boolean",
1835                     "vim.version.version9",
1836                     0 | F_OPTIONAL,
1837                     None,
1838                 ),
1839                 (
1840                     "includeIgmp",
1841                     "boolean",
1842                     "vim.version.version9",
1843                     0 | F_OPTIONAL,
1844                     None,
1845                 ),
1846                 (
1847                     "cmmdsMsgTypeFilter",
1848                     "string[]",
1849                     "vim.version.version9",
1850                     0 | F_OPTIONAL,
1851                     None,
1852                 ),
1853                 ("cmmdsPorts", "int[]", "vim.version.version9", 0 | F_OPTIONAL, None),
1854                 ("clusterUuid", "string", "vim.version.version9", 0 | F_OPTIONAL, None),
1855             ),
1856             (
1857                 0,
1858                 "vim.cluster.VsanVsanClusterPcapResult",
1859                 "vim.cluster.VsanVsanClusterPcapResult",
1860             ),
1861             "System.Read",
1862         ),
1863         (
1864             <font color="#5b8daf"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"checkClusterClomdLiveness",
1865             "VsanCheckClusterClomdLiveness",
1866             "vim.version.version9",
1867             (
1868                 ("hosts", "string[]", "vim.version.version9", 0, None),
1869                 ("esxRootPassword", "string", "vim.version.version9", 0, None),
1870             ),
1871             (
1872                 0,
1873                 "vim.cluster.VsanClusterClomdLivenessResult",
1874                 "vim.cluster.VsanClusterClomdLivenessResult",
1875             ),
1876             "System.Read",
1877             None,
1878         ),
1879     ],
1880 )
1881 CreateDataType(
1882     "vim.host.VSANCmmdsNodeInfo",
1883     "VimHostVSANCmmdsNodeInfo",
1884     "vmodl.DynamicData",
1885     "vim.version.version10",
1886     [
1887         ("nodeUuid", "string", "vim.version.version10", 0),
1888         ("isWitness", "boolean", "vim.version.version10", 0),
1889     ],
1890 )
1891 CreateDataType(
1892     "vim.host.VsanPhysicalDiskHealth",
1893     "VsanPhysicalDiskHealth",
1894     "vmodl.DynamicData",
1895     "vim.version.version9",
1896     [
1897         ("name"</b></font>, "string", "vim.version.version9", 0),
1898         ("uuid", "string", "vim.version.version9", 0),
1899         ("inCmmds", "boolean", "vim.version.version9", 0),
1900         ("inVsi", "boolean", "vim.version.version9", 0),
1901         ("dedupScope", "long", "vim.version.version9", 0 | F_OPTIONAL),
1902         ("formatVersion", "int", "vim.version.version9", 0 | F_OPTIONAL),
1903         ("isAllFlash", "int", "vim.version.version9", 0 | F_OPTIONAL),
1904         ("congestionValue", "int", "vim.version.version9", 0 | F_OPTIONAL),
1905         ("congestionArea", "string", "vim.version.version9", 0 | F_OPTIONAL),
1906         ("congestionHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
1907         ("metadataHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
1908         (
1909             "operationalHealthDescription",
1910             "string",
1911             "vim.version.version9",
1912             0 | F_OPTIONAL,
1913         ),
1914         ("operationalHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
1915         ("dedupUsageHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
1916         ("capacityHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
1917         ("summaryHealth", "string", "vim.version.version9", 0),
1918         ("capacity", "long", "vim.version.version9", 0 | F_OPTIONAL),
1919         ("usedCapacity", "long", "vim.version.version9", 0 | F_OPTIONAL),
1920         ("reservedCapacity", "long", "vim.version.version9", 0 | F_OPTIONAL),
1921         ("totalBytes", "long", "vim.version.version9", 0 | F_OPTIONAL),
1922         ("freeBytes", "long", "vim.version.version9", 0 | F_OPTIONAL),
1923         ("hashedBytes", "long", "vim.version.version9", 0 | F_OPTIONAL),
1924         ("dedupedBytes", "long", "vim.version.version9", 0 | F_OPTIONAL),
1925         ("scsiDisk", "vim.host.ScsiDisk", "vim.version.version9", 0 | F_OPTIONAL),
1926         ("usedComponents", "long", "vim.version.version9", 0 | F_OPTIONAL),
1927         ("maxComponents", "long", "vim.version.version9", 0 | F_OPTIONAL),
1928         ("compLimitHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
1929     ],
1930 )
1931 CreateDataType(
1932     "vim.vsan.DataEfficiencyConfig",
1933     "VsanDataEfficiencyConfig",
1934     "vmodl.DynamicData",
1935     "vim.version.version10",
1936     [
1937         ("dedupEnabled", "boolean", "vim.version.version10", 0),
1938         ("compressionEnabled", "boolean", "vim.version.version10", 0 | F_OPTIONAL),
1939     ],
1940 )
1941 CreateDataType(
1942     "vim.cluster.StorageComplianceResult",
1943     "VsanStorageComplianceResult",
1944     "vmodl.DynamicData",
1945     "vim.version.version9",
1946     [
1947         ("checkTime", "vmodl.DateTime", "vim.version.version9", 0 | F_OPTIONAL),
1948         ("profile", "string", "vim.version.version9", 0 | F_OPTIONAL),
1949         ("objectUUID", "string", "vim.version.version9", 0 | F_OPTIONAL),
1950         (
1951             "complianceStatus",
1952             "vim.cluster.StorageComplianceStatus",
1953             "vim.version.version9",
1954             0,
1955         ),
1956         ("mismatch", "boolean", "vim.version.version9", 0),
1957         (
1958             "violatedPolicies",
1959             "vim.cluster.StoragePolicyStatus[]",
1960             "vim.version.version9",
1961             0 | F_OPTIONAL,
1962         ),
1963         (
1964             "operationalStatus",
1965             "vim.cluster.StorageOperationalStatus",
1966             "vim.version.version9",
1967             0 | F_OPTIONAL,
1968         ),
1969     ],
1970 )
1971 CreateDataType(
1972     "vim.cluster.VsanClusterHealthGroup",
1973     "VsanClusterHealthGroup",
1974     "vmodl.DynamicData",
1975     "vim.version.version9",
1976     [
1977         ("groupId", "string", "vim.version.version9", 0),
1978         ("groupName", "string", "vim.version.version9", 0),
1979         ("groupHealth", "string", "vim.version.version9", 0),
1980         (
1981             "groupTests",
1982             "vim.cluster.VsanClusterHealthTest[]",
1983             "vim.version.version9",
1984             0 | F_OPTIONAL,
1985         ),
1986         (
1987             "groupDetails",
1988             "vim.cluster.VsanClusterHealthResultBase[]",
1989             "vim.version.version9",
1990             0 | F_OPTIONAL,
1991         ),
1992     ],
1993 )
1994 CreateDataType(
1995     "vim.cluster.VsanSpaceUsageDetailResult",
1996     "VsanSpaceUsageDetailResult",
1997     "vmodl.DynamicData",
1998     "vim.version.version9",
1999     [
2000         (
2001             "spaceUsageByObjectType",
2002             "vim.cluster.VsanObjectSpaceSummary[]",
2003             "vim.version.version9",
2004             0 | F_OPTIONAL,
2005         )
2006     ],
2007 )
2008 CreateDataType(
2009     "vim.cluster.VsanAttachToSrOperation",
2010     "VsanAttachToSrOperation",
2011     "vmodl.DynamicData",
2012     "vim.version.version9",
2013     [
2014         ("task", "vim.Task", "vim.version.version9", 0 | F_OPTIONAL),
2015         ("success", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2016         ("timestamp", "vmodl.DateTime", "vim.version.version9", 0 | F_OPTIONAL),
2017         ("srNumber", "string", "vim.version.version9", 0),
2018     ],
2019 )
2020 CreateDataType(
2021     "vim.cluster.VsanObjectSpaceSummary",
2022     "VsanObjectSpaceSummary",
2023     "vmodl.DynamicData",
2024     "vim.version.version9",
2025     [
2026         (
2027             "objType",
2028             "vim.cluster.VsanObjectTypeEnum",
2029             "vim.version.version9",
2030             0 | F_OPTIONAL,
2031         ),
2032         ("overheadB", "long", "vim.version.version9", 0 | F_OPTIONAL),
2033         ("primaryCapacityB", "long", "vim.version.version9", 0 | F_OPTIONAL),
2034         ("provisionCapacityB", "long", "vim.version.version9", 0 | F_OPTIONAL),
2035         (<font color="#947010"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"reservedCapacityB", "long", "vim.version.version9", 0 | F_OPTIONAL),
2036         ("overReservedB", "long", "vim.version.version9", 0 | F_OPTIONAL),
2037         ("physicalUsedB", "long", "vim.version.version9", 0 | F_OPTIONAL),
2038         ("usedB", "long", "vim.version.version9", 0 | F_OPTIONAL),
2039     ],
2040 )
2041 CreateDataType(
2042     "vim.cluster.VsanClusterHclInfo",
2043     "VsanClusterHclInfo",
2044     "vmodl.DynamicData",
2045     "vim.version.version9",
2046     [
2047         ("hclDbLastUpdate", "vmodl.DateTime", "vim.version.version9", 0 | F_OPTIONAL),
2048         ("hclDbAgeHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
2049         (
2050             "hostResults",
2051             "vim.host.VsanHostHclInfo[]",
2052             "vim.version.version9",
2053             0 | F_OPTIONAL,
2054         ),
2055     ],
2056 )
2057 CreateDataType(
2058     "vim.cluster.VsanPerfGraph",
2059     "VsanPerfGraph",
2060     "vmodl.DynamicData",
2061     "vim.version.version9",
2062     [
2063         ("id", "string", "vim.version.version9", 0),
2064         ("unit"</b></font>, "vim.cluster.VsanPerfStatsUnitType", "vim.version.version9", 0),
2065         (
2066             <font color="#717d7d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"threshold",
2067             "vim.cluster.VsanPerfThreshold",
2068             "vim.version.version9",
2069             0 | F_OPTIONAL,
2070         ),
2071         ("name", "string", "vim.version.version9", 0 | F_OPTIONAL),
2072         ("description", "string", "vim.version.version9", 0 | F_OPTIONAL),
2073     ],
2074 )
2075 CreateDataType(
2076     "vim.cluster.VsanClusterHealthResultBase",
2077     "VsanClusterHealthResultBase",
2078     "vmodl.DynamicData",
2079     "vim.version.version9",
2080     [("label", "string", "vim.version.version9", 0 | F_OPTIONAL)],
2081 )
2082 CreateDataType(
2083     "vim.cluster.VsanPerfTopEntity",
2084     "VsanPerfTopEntity",
2085     "vmodl.DynamicData",
2086     "vim.version.version9",
2087     [
2088         ("entityRefId", "string", "vim.version.version9", 0),
2089         ("value", "string", "vim.version.version9", 0),
2090     ],
2091 )
2092 CreateDataType(
2093     "vim.cluster.VsanClusterBalancePerDiskInfo",
2094     "VsanClusterBalancePerDiskInfo",
2095     "vmodl.DynamicData",
2096     "vim.version.version9",
2097     [
2098         ("uuid"</b></font>, "string", "vim.version.version9", 0 | F_OPTIONAL),
2099         ("fullness", "long", "vim.version.version9", 0),
2100         ("variance", "long", "vim.version.version9", 0),
2101         ("fullnessAboveThreshold", "long", "vim.version.version9", 0),
2102         ("dataToMoveB", "long", "vim.version.version9", 0),
2103     ],
2104 )
2105 CreateDataType(
2106     "vim.cluster.VsanClusterHealthTest",
2107     "VsanClusterHealthTest",
2108     "vmodl.DynamicData",
2109     "vim.version.version9",
2110     [
2111         ("testName", "string", "vim.version.version9", 0 | F_OPTIONAL),
2112         ("testDescription", "string", "vim.version.version9", 0 | F_OPTIONAL),
2113         (<font color="#800517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"testShortDescription", "string", "vim.version.version9", 0 | F_OPTIONAL),
2114         ("testHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
2115         (
2116             "testDetails",
2117             "vim.cluster.VsanClusterHealthResultBase[]",
2118             "vim.version.version9",
2119             0 | F_OPTIONAL,
2120         ),
2121         (
2122             "testActions",
2123             "vim.cluster.VsanClusterHealthAction[]",
2124             "vim.version.version9",
2125             0 | F_OPTIONAL,
2126         ),
2127     ],
2128 )
2129 CreateDataType(
2130     "vim.cluster.StoragePolicyStatus",
2131     "VsanStoragePolicyStatus",
2132     "vmodl.DynamicData",
2133     "vim.version.version9",
2134     [
2135         ("id", "string", "vim.version.version9", 0 | F_OPTIONAL),
2136         ("expectedValue", "string", "vim.version.version9", 0 | F_OPTIONAL),
2137         ("currentValue", "string", "vim.version.version9", 0 | F_OPTIONAL),
2138     ],
2139 )
2140 CreateDataType(
2141     "vim.cluster.VsanPerfMemberInfo",
2142     "VsanPerfMemberInfo",
2143     "vmodl.DynamicData",
2144     "vim.version.version9",
2145     [("thumbprint", "string", "vim.version.version9", 0)],
2146 )
2147 CreateDataType(
2148     "vim.cluster.VsanPerfMetricId",
2149     "VsanPerfMetricId",
2150     "vmodl.DynamicData",
2151     "vim.version.version9",
2152     [
2153         ("label"</b></font>, "string", "vim.version.version9", 0),
2154         ("group", "string", "vim.version.version9", 0 | F_OPTIONAL),
2155         (
2156             "rollupType",
2157             "vim.cluster.VsanPerfSummaryType",
2158             "vim.version.version9",
2159             0 | F_OPTIONAL,
2160         ),
2161         (
2162             "statsType",
2163             "vim.cluster.VsanPerfStatsType",
2164             "vim.version.version9",
2165             0 | F_OPTIONAL,
2166         ),
2167         ("name", "string", "vim.version.version9", 0 | F_OPTIONAL),
2168         ("description", "string", "vim.version.version9", 0 | F_OPTIONAL),
2169         ("metricsCollectInterval", "int", "vim.version.version9", 0 | F_OPTIONAL),
2170     ],
2171 )
2172 CreateDataType(
2173     "vim.cluster.VSANWitnessHostInfo",
2174     "VimClusterVSANWitnessHostInfo",
2175     "vmodl.DynamicData",
2176     "vim.version.version10",
2177     [
2178         ("nodeUuid", "string", "vim.version.version10", 0),
2179         ("faultDomainName", "string", "vim.version.version10", 0 | F_OPTIONAL),
2180         ("preferredFdName", "string", "vim.version.version10", 0 | F_OPTIONAL),
2181         ("preferredFdUuid", "string", "vim.version.version10", 0 | F_OPTIONAL),
2182         ("unicastAgentAddr", "string", "vim.version.version10", 0 | F_OPTIONAL),
2183         ("host", "vim.HostSystem", "vim.version.version10", 0 | F_OPTIONAL),
2184     ],
2185 )
2186 CreateDataType(
2187     "vim.cluster.VsanHealthExtMgmtPreCheckResult",
2188     "VsanHealthExtMgmtPreCheckResult",
2189     "vim.version.version9",
2190     [
2191         (<font color="#e77471"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"overallResult", "boolean", "vim.version.version9", 0),
2192         ("esxVersionCheckPassed", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2193         ("drsCheckPassed", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2194         ("eamConnectionCheckPassed", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2195         ("installStateCheckPassed", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2196         ("results", "vim.cluster.VsanClusterHealthTest[]", "vim.version.version9", 0),
2197         ("vumRegistered", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2198     ],
2199 )
2200 CreateDataType(
2201     "vim.vsan.upgradesystem.HostWithHybridDiskgroupIssue",
2202     "VsanHostWithHybridDiskgroupIssue",
2203     "vim.VsanUpgradeSystem.PreflightCheckIssue",
2204     "vim.version.version10",
2205     [("hosts", "vim.HostSystem[]", "vim.version.version10", 0)],
2206 )
2207 CreateDataType(
2208     "vim.cluster.VsanPerfMetricSeriesCSV",
2209     "VsanPerfMetricSeriesCSV",
2210     "vmodl.DynamicData",
2211     "vim.version.version9",
2212     [
2213         ("metricId"</b></font>, "vim.cluster.VsanPerfMetricId", "vim.version.version9", 0),
2214         ("values", "string", "vim.version.version9", 0 | F_OPTIONAL),
2215     ],
2216 )
2217 CreateDataType(
2218     "vim.cluster.VsanPerfQuerySpec",
2219     "VsanPerfQuerySpec",
2220     "vim.version.version9",
2221     [
2222         <font color="#68818b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("entityRefId", "string", "vim.version.version9", 0),
2223         ("startTime", "vmodl.DateTime", "vim.version.version9", 0 | F_OPTIONAL),
2224         ("endTime", "vmodl.DateTime", "vim.version.version9", 0 | F_OPTIONAL),
2225         ("group", "string", "vim.version.version9", 0 | F_OPTIONAL),
2226         ("labels", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2227         ("interval", "int", "vim.version.version9", 0 | F_OPTIONAL),
2228     ],
2229 )
2230 CreateDataType(
2231     "vim.host.VsanRepairObjectsResult",
2232     "VsanRepairObjectsResult",
2233     "vmodl.DynamicData",
2234     "vim.version.version9",
2235     [
2236         ("inQueueObjects", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2237         (
2238             "failedRepairObjects",
2239             "vim.host.VsanFailedRepairObjectResult[]",
2240             "vim.version.version9",
2241             0 | F_OPTIONAL,
2242         ),
2243         ("notInQueueObjects", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2244     ],
2245 )
2246 CreateDataType(</b></font>
2247     "vim.cluster.VsanClusterNetworkPartitionInfo",
2248     "VsanClusterNetworkPartitionInfo",
2249     "vmodl.DynamicData",
2250     "vim.version.version9",
2251     [("hosts", "string[]", "vim.version.version9", 0 | F_OPTIONAL)],
2252 )
2253 CreateDataType(
2254     "vim.vsan.upgradesystem.MixedEsxVersionIssue",
2255     "VsanMixedEsxVersionIssue",
2256     "vim.VsanUpgradeSystem.PreflightCheckIssue",
2257     "vim.version.version10",
2258     [],
2259 )
2260 CreateDataType(
2261     "vim.cluster.VsanClusterClomdLivenessResult",
2262     "VsanClusterClomdLivenessResult",
2263     "vmodl.DynamicData",
2264     "vim.version.version9",
2265     [
2266         (
2267             "clomdLivenessResult",
2268             "vim.cluster.VsanHostClomdLivenessResult[]",
2269             "vim.version.version9",
2270             0 | F_OPTIONAL,
2271         ),
2272         ("issueFound", "boolean", "vim.version.version9", 0),
2273     ],
2274 )
2275 CreateDataType(
2276     "vim.cluster.VsanVsanClusterPcapResult",
2277     "VsanVsanClusterPcapResult",
2278     "vmodl.DynamicData",
2279     "vim.version.version9",
2280     [
2281         ("pkts", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2282         (
2283             "groups",
2284             "vim.cluster.VsanVsanClusterPcapGroup[]",
2285             "vim.version.version9",
2286             0 | F_OPTIONAL,
2287         ),
2288         ("issues", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2289         (
2290             "hostResults",
2291             "vim.host.VsanVsanPcapResult[]",
2292             "vim.version.version9",
2293             0 | F_OPTIONAL,
2294         ),
2295     ],
2296 )
2297 CreateDataType(
2298     "vim.cluster.VsanPerfMasterInformation",
2299     "VsanPerfMasterInformation",
2300     "vmodl.DynamicData",
2301     "vim.version.version9",
2302         ("secSinceLastStatsWrite", "long", "vim.version.version9", 0 | F_OPTIONAL),
2303         ("secSinceLastStatsCollect", "long", "vim.version.version9", 0 | F_OPTIONAL),
2304         (<font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"statsIntervalSec", "long", "vim.version.version9", 0),
2305         (
2306             "collectionFailureHostUuids",
2307             "string[]",
2308             "vim.version.version9",
2309             0 | F_OPTIONAL,
2310         ),
2311         ("renamedStatsDirectories", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2312         ("statsDirectoryPercentFree", "long", "vim.version.version9", 0 | F_OPTIONAL),
2313     ],
2314 )
2315 CreateDataType(
2316     "vim.cluster.VsanHostCreateVmHealthTestResult",
2317     "VsanHostCreateVmHealthTestResult",
2318     "vmodl.DynamicData",
2319     "vim.version.version9",
2320     [
2321         ("hostname", "string", "vim.version.version9", 0),
2322         ("state", "string", "vim.version.version9", 0),
2323         ("fault", "vmodl.MethodFault", "vim.version.version9", 0 | F_OPTIONAL),
2324     ],
2325 )
2326 CreateDataType(
2327     "vim.cluster.VsanDiskFormatConversionCheckResult",
2328     "VsanDiskFormatConversionCheckResult",
2329     "vim.VsanUpgradeSystem.PreflightCheckResult",
2330     "vim.version.version10",
2331     [
2332         ("isSupported", "boolean", "vim.version.version10", 0),
2333         ("targetVersion", "int", "vim.version.version10", 0 | F_OPTIONAL),
2334     ],
2335 )
2336 CreateDataType(
2337     "vim.cluster.VsanClusterHealthSystemObjectsRepairResult",
2338     "VsanClusterHealthSystemObjectsRepairResult",
2339     "vmodl.DynamicData",
2340     "vim.version.version9",
2341     [
2342         ("inRepairingQueueObjects", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2343         (
2344             "failedRepairObjects",
2345             "vim.host.VsanFailedRepairObjectResult[]",
2346             "vim.version.version9",
2347             0 | F_OPTIONAL,
2348         ),
2349         ("issueFound", "boolean", "vim.version.version9", 0),
2350     ],
2351 )
2352 CreateDataType(
2353     "vim.host.VsanHostHclInfo",
2354     "VsanHostHclInfo",
2355     "vmodl.DynamicData",
2356     "vim.version.version9",
2357     [
2358         ("hostname", "string", "vim.version.version9", 0),
2359         ("hclChecked", "boolean", "vim.version.version9", 0),
2360         ("error", "vmodl.MethodFault", "vim.version.version9", 0 | F_OPTIONAL),
2361         (
2362             <font color="#5eac10"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"controllers",
2363             "vim.host.VsanHclControllerInfo[]",
2364             "vim.version.version9",
2365             0 | F_OPTIONAL,
2366         ),
2367     ],
2368 )
2369 CreateDataType(
2370     "vim.cluster.VSANStretchedClusterCapability",
2371     "VimClusterVSANStretchedClusterCapability",
2372     "vmodl.DynamicData",
2373     "vim.version.version10",
2374     [
2375         ("hostMoId", "string", "vim.version.version10", 0),
2376         ("connStatus", "string", "vim.version.version10", 0 | F_OPTIONAL),
2377         ("isSupported", "boolean", "vim.version.version10", 0 | F_OPTIONAL),
2378         (
2379             "hostCapability",
2380             "vim.host.VSANStretchedClusterHostCapability",
2381             "vim.version.version10",
2382             0 | F_OPTIONAL,
2383         ),
2384     ],
2385 )
2386 CreateDataType(
2387     "vim.cluster.VsanDiskMappingsConfigSpec",
2388     "VimClusterVsanDiskMappingsConfigSpec",
2389     "vmodl.DynamicData",
2390     "vim.version.version10",
2391     [
2392         (
2393             "hostDiskMappings",
2394             "vim.cluster.VsanHostDiskMapping[]",
2395             "vim.version.version10",
2396             0,
2397         )
2398     ],
2399 )
2400 CreateDataType(
2401     "vim.host.VsanHostVmdkLoadTestResult",
2402     "VsanHostVmdkLoadTestResult",
2403     "vmodl.DynamicData",
2404     "vim.version.version9",
2405     [
2406         ("hostname"</b></font>, "string", "vim.version.version9", 0),
2407         ("issueFound", "boolean", "vim.version.version9", 0),
2408         ("faultMessage", "string", "vim.version.version9", 0 | F_OPTIONAL),
2409         (
2410             "vmdkResults",
2411             "vim.host.VsanVmdkLoadTestResult[]",
2412             "vim.version.version9",
2413             0 | F_OPTIONAL,
2414         ),
2415     ],
2416 )
2417 CreateDataType(
2418     "vim.vsan.ReconfigSpec",
2419     "VimVsanReconfigSpec",
2420     "vmodl.DynamicData",
2421     "vim.version.version10",
2422     [
2423         (
2424             "vsanClusterConfig",
2425             "vim.vsan.cluster.ConfigInfo",
2426             "vim.version.version10",
2427             0 | F_OPTIONAL,
2428         ),
2429         (
2430             "dataEfficiencyConfig",
2431             "vim.vsan.DataEfficiencyConfig",
2432             "vim.version.version10",
2433             0 | F_OPTIONAL,
2434         ),
2435         (
2436             "diskMappingSpec",
2437             "vim.cluster.VsanDiskMappingsConfigSpec",
2438             "vim.version.version10",
2439             0 | F_OPTIONAL,
2440         ),
2441         (
2442             "faultDomainsSpec",
2443             "vim.cluster.VsanFaultDomainsConfigSpec",
2444             "vim.version.version10",
2445             0 | F_OPTIONAL,
2446         ),
2447         ("modify", "boolean", "vim.version.version10", 0),
2448         ("allowReducedRedundancy", "boolean", "vim.version.version10", 0 | F_OPTIONAL),
2449     ],
2450 )
2451 CreateDataType(
2452     "vim.host.VsanNetworkPeerHealthResult",
2453     "VsanNetworkPeerHealthResult",
2454     "vmodl.DynamicData",
2455     "vim.version.version9",
2456     [
2457         ("peer", "string", "vim.version.version9", 0 | F_OPTIONAL),
2458         ("peerHostname", "string", "vim.version.version9", 0 | F_OPTIONAL),
2459         ("peerVmknicName", "string", "vim.version.version9", 0 | F_OPTIONAL),
2460         ("smallPingTestSuccessPct", "int", "vim.version.version9", 0 | F_OPTIONAL),
2461         ("maxLatencyUs", "long", "vim.version.version9", 0 | F_OPTIONAL),
2462         ("onSameIpSubnet", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2463         (<font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"sourceVmknicName", "string", "vim.version.version9", 0 | F_OPTIONAL),
2464     ],
2465 )
2466 CreateDataType(
2467     "vim.cluster.VsanWitnessSpec",
2468     "VimClusterVsanWitnessSpec",
2469     "vmodl.DynamicData",
2470     "vim.version.version10",
2471     [
2472         ("host", "vim.HostSystem", "vim.version.version10", 0),
2473         ("preferredFaultDomainName", "string", "vim.version.version10", 0),
2474         (
2475             "diskMapping",
2476             "vim.vsan.host.DiskMapping",
2477             "vim.version.version10",
2478             0 | F_OPTIONAL,
2479         ),
2480     ],
2481 )
2482 CreateDataType(
2483     "vim.vsan.host.DiskMappingCreationSpec",
2484     "VimVsanHostDiskMappingCreationSpec",
2485     "vmodl.DynamicData",
2486     "vim.version.version10",
2487     [
2488         ("host", "vim.HostSystem", "vim.version.version10", 0),
2489         ("cacheDisks", "vim.host.ScsiDisk[]", "vim.version.version10", 0 | F_OPTIONAL),
2490         ("capacityDisks", "vim.host.ScsiDisk[]", "vim.version.version10", 0),
2491         (
2492             "creationType",
2493             "vim.vsan.host.DiskMappingCreationType",
2494             "vim.version.version10",
2495             0,
2496         ),
2497     ],
2498 )
2499 CreateDataType(
2500     "vim.host.VsanLimitHealthResult",
2501     "VsanLimitHealthResult",
2502     "vmodl.DynamicData",
2503     "vim.version.version9",
2504     [
2505         ("hostname", "string", "vim.version.version9", 0 | F_OPTIONAL),
2506         ("issueFound", "boolean", "vim.version.version9", 0),
2507         ("maxComponents", "int", "vim.version.version9", 0),
2508         ("freeComponents", "int", "vim.version.version9", 0),
2509         ("componentLimitHealth", "string", "vim.version.version9", 0),
2510         ("lowestFreeDiskSpacePct", "int", "vim.version.version9", 0),
2511         ("totalDiskSpaceB", "long", "vim.version.version9", 0),
2512         ("diskFreeSpaceHealth", "string", "vim.version.version9", 0),
2513         (<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"reservedRcSizeB", "long", "vim.version.version9", 0),
2514         ("totalRcSizeB", "long", "vim.version.version9", 0),
2515         ("rcFreeReservationHealth", "string", "vim.version.version9", 0),
2516     ],
2517 )
2518 CreateDataType(
2519     "vim.cluster.VSANPreferredFaultDomainInfo",
2520     "VimClusterVSANPreferredFaultDomainInfo",
2521     "vmodl.DynamicData",
2522     "vim.version.version10",
2523     [
2524         ("preferredFaultDomainName", "string", "vim.version.version10", 0),
2525         ("preferredFaultDomainId", "string", "vim.version.version10", 0),
2526     ],
2527 )
2528 CreateDataType(
2529     "vim.host.VsanObjectOverallHealth",
2530     "VsanObjectOverallHealth",
2531     "vmodl.DynamicData",
2532     "vim.version.version9",
2533     [
2534         (
2535             "objectHealthDetail",
2536             "vim.host.VsanObjectHealth[]",
2537             "vim.version.version9",
2538             0 | F_OPTIONAL,
2539         ),
2540         ("objectVersionCompliance", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2541     ],
2542 )
2543 CreateDataType(
2544     "vim.cluster.VsanVsanClusterPcapGroup",
2545     "VsanVsanClusterPcapGroup",
2546     "vmodl.DynamicData",
2547     "vim.version.version9",
2548     [
2549         ("master", "string", "vim.version.version9", 0),
2550         ("members", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2551     ],
2552 )
2553 CreateDataType(
2554     "vim.cluster.VsanClusterHealthResultColumnInfo",
2555     "VsanClusterHealthResultColumnInfo",
2556     "vmodl.DynamicData",
2557     "vim.version.version9",
2558     [
2559         ("label", "string", "vim.version.version9", 0),
2560         ("type", "string", "vim.version.version9", 0),
2561     ],
2562 )
2563 CreateDataType(
2564     "vim.cluster.VsanClusterNetworkHealthResult",
2565     "VsanClusterNetworkHealthResult",
2566     "vmodl.DynamicData",
2567     "vim.version.version9",
2568     [
2569         (
2570             "hostResults",
2571             "vim.host.VsanNetworkHealthResult[]",
2572             "vim.version.version9",
2573             0 | F_OPTIONAL,
2574         ),
2575         ("issueFound"</b></font>, "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2576         ("vsanVmknicPresent", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2577         ("matchingMulticastConfig", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2578         ("matchingIpSubnets", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2579         ("pingTestSuccess", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2580         ("largePingTestSuccess", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2581         ("potentialMulticastIssue", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2582         ("otherHostsInVsanCluster", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2583         (
2584             "partitions",
2585             "vim.cluster.VsanClusterNetworkPartitionInfo[]",
2586             "vim.version.version9",
2587             0 | F_OPTIONAL,
2588         ),
2589         ("hostsWithVsanDisabled", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2590         ("hostsDisconnected", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2591         ("hostsCommFailure", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2592         (
2593             "hostsInEsxMaintenanceMode",
2594             "string[]",
2595             "vim.version.version9",
2596             0 | F_OPTIONAL,
2597         ),
2598         (
2599             "hostsInVsanMaintenanceMode",
2600             "string[]",
2601             "vim.version.version9",
2602             0 | F_OPTIONAL,
2603         ),
2604         (
2605             "infoAboutUnexpectedHosts",
2606             "vim.host.VsanQueryResultHostInfo[]",
2607             "vim.version.version9",
2608             0 | F_OPTIONAL,
2609         ),
2610     ],
2611 )
2612 CreateDataType(
2613     "vim.cluster.VsanPerfNodeInformation",
2614     "VsanPerfNodeInformation",
2615     "vmodl.DynamicData",
2616     "vim.version.version9",
2617     [
2618         ("version", "string", "vim.version.version9", 0),
2619         ("hostname", "string", "vim.version.version9", 0 | F_OPTIONAL),
2620         ("error", "vmodl.MethodFault", "vim.version.version9", 0 | F_OPTIONAL),
2621         ("isCmmdsMaster", "boolean", "vim.version.version9", 0),
2622         ("isStatsMaster", "boolean", "vim.version.version9", 0),
2623         ("vsanMasterUuid", "string", "vim.version.version9", 0 | F_OPTIONAL),
2624         ("vsanNodeUuid", "string", "vim.version.version9", 0 | F_OPTIONAL),
2625         (
2626             "masterInfo",
2627             "vim.cluster.VsanPerfMasterInformation",
2628             "vim.version.version9",
2629             0 | F_OPTIONAL,
2630         ),
2631     ],
2632 )
2633 CreateDataType(
2634     "vim.cluster.VsanPerfEntityMetricCSV",
2635     "VsanPerfEntityMetricCSV",
2636     "vmodl.DynamicData",
2637     [
2638         ("entityRefId", "string", "vim.version.version9", 0),
2639         (<font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"sampleInfo", "string", "vim.version.version9", 0 | F_OPTIONAL),
2640         (
2641             "value",
2642             "vim.cluster.VsanPerfMetricSeriesCSV[]",
2643             "vim.version.version9",
2644             0 | F_OPTIONAL,
2645         ),
2646     ],
2647 )
2648 CreateDataType(
2649     "vim.vsan.upgradesystem.DiskUnhealthIssue",
2650     "VsanDiskUnhealthIssue",
2651     "vim.VsanUpgradeSystem.PreflightCheckIssue",
2652     "vim.version.version10",
2653     [("uuids", "string[]", "vim.version.version10", 0)],
2654 )
2655 CreateDataType(
2656     "vim.cluster.VsanFaultDomainSpec",
2657     "VimClusterVsanFaultDomainSpec",
2658     "vmodl.DynamicData",
2659     "vim.version.version10",
2660     [
2661         ("hosts", "vim.HostSystem[]", "vim.version.version10", 0),
2662         ("name", "string", "vim.version.version10", 0),
2663     ],
2664 )
2665 CreateDataType(
2666     "vim.vsan.upgradesystem.ObjectInaccessibleIssue",
2667     "VsanObjectInaccessibleIssue",
2668     "vim.VsanUpgradeSystem.PreflightCheckIssue",
2669     "vim.version.version10",
2670     [("uuids", "string[]", "vim.version.version10", 0)],
2671 )
2672 CreateDataType(
2673     "vim.cluster.VsanDiskFormatConversionSpec",
2674     "VsanDiskFormatConversionSpec",
2675     "vmodl.DynamicData",
2676     "vim.version.version10",
2677     [
2678         (
2679             "dataEfficiencyConfig",
2680             "vim.vsan.DataEfficiencyConfig",
2681             "vim.version.version10",
2682             0 | F_OPTIONAL,
2683         )
2684     ],
2685 )
2686 CreateDataType(
2687     "vim.cluster.VsanClusterHealthAction",
2688     "VsanClusterHealthAction",
2689     "vmodl.DynamicData",
2690     "vim.version.version9",
2691     [
2692         (
2693             "actionId"</b></font>,
2694             "vim.cluster.VsanClusterHealthActionIdEnum",
2695             "vim.version.version9",
2696             0,
2697         ),
2698         ("actionLabel", "vmodl.LocalizableMessage", "vim.version.version9", 0),
2699         ("actionDescription", "vmodl.LocalizableMessage", "vim.version.version9", 0),
2700         ("enabled", "boolean", "vim.version.version9", 0),
2701     ],
2702 )
2703 CreateDataType(
2704     "vim.cluster.VsanClusterHealthSystemVersionResult",
2705     "VsanClusterHealthSystemVersionResult",
2706     "vmodl.DynamicData",
2707     "vim.version.version9",
2708     [
2709         (
2710             "hostResults",
2711             "vim.cluster.VsanHostHealthSystemVersionResult[]",
2712             "vim.version.version9",
2713         ),
2714         ("vcVersion", "string", "vim.version.version9", 0 | F_OPTIONAL),
2715         (<font color="#79764d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"issueFound", "boolean", "vim.version.version9", 0),
2716     ],
2717 )
2718 CreateDataType(
2719     "vim.cluster.VsanClusterHealthResultRow",
2720     "VsanClusterHealthResultRow",
2721     "vmodl.DynamicData",
2722     "vim.version.version9",
2723     [
2724         ("values", "string[]", "vim.version.version9", 0),
2725         (
2726             "nestedRows",
2727             "vim.cluster.VsanClusterHealthResultRow[]",
2728             "vim.version.version9",
2729             0 | F_OPTIONAL,
2730         ),
2731     ],
2732 )
2733 CreateDataType(
2734     "vim.cluster.VsanClusterHealthSystemStatusResult",
2735     "VsanClusterHealthSystemStatusResult",
2736     "vmodl.DynamicData",
2737     "vim.version.version9",
2738     [
2739         ("status", "string", "vim.version.version9", 0),
2740         ("goalState", "string", "vim.version.version9", 0),
2741         ("untrackedHosts", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2742         (
2743             "trackedHostsStatus",
2744             "vim.host.VsanHostHealthSystemStatusResult[]",
2745             "vim.version.version9",
2746             0 | F_OPTIONAL,
2747         ),
2748     ],
2749 )
2750 CreateDataType(
2751     "vim.cluster.VsanHostDiskMapping",
2752     "VimClusterVsanHostDiskMapping",
2753     "vmodl.DynamicData",
2754     "vim.version.version10",
2755     [
2756         (</b></font>"host", "vim.HostSystem", "vim.version.version10", 0),
2757         ("cacheDisks", "vim.host.ScsiDisk[]", "vim.version.version10", 0 | F_OPTIONAL),
2758         ("capacityDisks", "vim.host.ScsiDisk[]", "vim.version.version10", 0),
2759         ("type", "vim.cluster.VsanDiskGroupCreationType", "vim.version.version10", 0),
2760     ],
2761 )
2762 CreateDataType(
2763     "vim.cluster.VSANStretchedClusterFaultDomainConfig",
2764     "VimClusterVSANStretchedClusterFaultDomainConfig",
2765     "vmodl.DynamicData",
2766     "vim.version.version10",
2767     [
2768         ("firstFdName", "string", "vim.version.version10", 0),
2769         ("firstFdHosts", "vim.HostSystem[]", "vim.version.version10", 0),
2770         ("secondFdName", "string", "vim.version.version10", 0),
2771         ("secondFdHosts", "vim.HostSystem[]", "vim.version.version10", 0),
2772     ],
2773 )
2774 CreateDataType(
2775     "vim.host.VSANStretchedClusterHostInfo",
2776     "VimHostVSANStretchedClusterHostInfo",
2777     "vmodl.DynamicData",
2778     "vim.version.version10",
2779     [
2780         ("nodeInfo", "vim.host.VSANCmmdsNodeInfo", "vim.version.version10", 0),
2781         (
2782             "faultDomainInfo",
2783             "vim.host.VSANCmmdsFaultDomainInfo",
2784             "vim.version.version10",
2785         ),
2786         (
2787             <font color="#4e9258"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"preferredFaultDomainInfo",
2788             "vim.host.VSANCmmdsPreferredFaultDomainInfo",
2789             "vim.version.version10",
2790             0 | F_OPTIONAL,
2791         ),
2792     ],
2793 )
2794 CreateDataType(
2795     "vim.vsan.upgradesystem.HigherObjectsPresentDuringDowngradeIssue",
2796     "VsanHigherObjectsPresentDuringDowngradeIssue",
2797     "vim.VsanUpgradeSystem.PreflightCheckIssue",
2798     "vim.version.version10",
2799     [("uuids", "string[]", "vim.version.version10", 0)],
2800 )
2801 CreateDataType(
2802     "vim.host.VSANCmmdsFaultDomainInfo",
2803     "VimHostVSANCmmdsFaultDomainInfo",
2804     "vmodl.DynamicData",
2805     "vim.version.version10",
2806     [
2807         ("faultDomainId", "string", "vim.version.version10", 0),
2808         ("faultDomainName", "string", "vim.version.version10", 0),
2809     ],
2810 )
2811 CreateDataType(
2812     "vim.fault.VsanNodeNotMaster",
2813     "VsanNodeNotMaster",
2814     "vim.fault.VimFault",
2815     "vim.version.version9",
2816     [
2817         ("vsanMasterUuid", "string", "vim.version.version9", 0 | F_OPTIONAL),
2818         (
2819             "cmmdsMasterButNotStatsMaster",
2820             "boolean",
2821             "vim.version.version9",
2822             0 | F_OPTIONAL,
2823         ),
2824     ],
2825 )
2826 CreateDataType(
2827     "vim.cluster.VsanHostHealthSystemVersionResult",
2828     "VsanHostHealthSystemVersionResult",
2829     "vmodl.DynamicData",
2830     "vim.version.version9",
2831     [
2832         (</b></font>"hostname", "string", "vim.version.version9", 0),
2833         ("version", "string", "vim.version.version9", 0 | F_OPTIONAL),
2834         ("error", "vmodl.MethodFault", "vim.version.version9", 0 | F_OPTIONAL),
2835     ],
2836 )
2837 CreateDataType(
2838     "vim.cluster.VsanClusterHealthConfigs",
2839     "VsanClusterHealthConfigs",
2840     "vmodl.DynamicData",
2841     "vim.version.version9",
2842     [
2843         ("enableVsanTelemetry", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2844         ("vsanTelemetryInterval", "int", "vim.version.version9", 0 | F_OPTIONAL),
2845         (
2846             "vsanTelemetryProxy",
2847             "vim.cluster.VsanClusterTelemetryProxyConfig",
2848             "vim.version.version9",
2849             0 | F_OPTIONAL,
2850         ),
2851         (
2852             "configs",
2853             "vim.cluster.VsanClusterHealthResultKeyValuePair[]",
2854             "vim.version.version9",
2855             0 | F_OPTIONAL,
2856         ),
2857     ],
2858 )
2859 CreateDataType(
2860     "vim.cluster.VsanClusterWhatifHostFailuresResult",
2861     "VsanClusterWhatifHostFailuresResult",
2862     "vmodl.DynamicData",
2863     "vim.version.version9",
2864     [
2865         ("numFailures", "long", "vim.version.version9", 0),
2866         ("totalUsedCapacityB", "long", "vim.version.version9", 0),
2867         ("totalCapacityB", "long", "vim.version.version9", 0),
2868         ("totalRcReservationB", "long", "vim.version.version9", 0),
2869         ("totalRcSizeB", "long", "vim.version.version9", 0),
2870         ("usedComponents", "long", "vim.version.version9", 0),
2871         ("totalComponents", "long", "vim.version.version9", 0),
2872         ("componentLimitHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
2873         ("diskFreeSpaceHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
2874         ("rcFreeReservationHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
2875     ],
2876 )
2877 CreateDataType(
2878     "vim.cluster.VsanObjectIdentityAndHealth",
2879     "VsanObjectIdentityAndHealth",
2880     "vmodl.DynamicData",
2881     "vim.version.version9",
2882     [
2883         (
2884             "identities",
2885             "vim.cluster.VsanObjectIdentity[]",
2886             "vim.version.version9",
2887             0 | F_OPTIONAL,
2888         ),
2889         (
2890             "health",
2891             "vim.host.VsanObjectOverallHealth",
2892             "vim.version.version9",
2893             0 | F_OPTIONAL,
2894         ),
2895         (
2896             "spaceSummary",
2897             "vim.cluster.VsanObjectSpaceSummary[]",
2898             "vim.version.version9",
2899             0 | F_OPTIONAL,
2900         ),
2901         ("rawData", "string", "vim.version.version9", 0 | F_OPTIONAL),
2902     ],
2903 )
2904 CreateDataType(
2905     "vim.host.VsanHclControllerInfo",
2906     "VsanHclControllerInfo",
2907     "vmodl.DynamicData",
2908     "vim.version.version9",
2909     [
2910         ("deviceName", "string", "vim.version.version9", 0),
2911         ("deviceDisplayName", "string", "vim.version.version9", 0 | F_OPTIONAL),
2912         ("driverName", "string", "vim.version.version9", 0 | F_OPTIONAL),
2913         ("driverVersion", "string", "vim.version.version9", 0 | F_OPTIONAL),
2914         ("vendorId", "long", "vim.version.version9", 0 | F_OPTIONAL),
2915         ("deviceId", "long", "vim.version.version9", 0 | F_OPTIONAL),
2916         ("subVendorId", "long", "vim.version.version9", 0 | F_OPTIONAL),
2917         ("subDeviceId", "long", "vim.version.version9", 0 | F_OPTIONAL),
2918         ("extraInfo", "vim.KeyValue[]", "vim.version.version9", 0 | F_OPTIONAL),
2919         ("deviceOnHcl", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2920         ("releaseSupported", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2921         ("releasesOnHcl", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2922         ("driverVersionsOnHcl", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2923         ("driverVersionSupported", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2924         ("fwVersionSupported", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2925         ("fwVersionOnHcl", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2926         ("cacheConfigSupported", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2927         ("cacheConfigOnHcl", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2928         ("raidConfigSupported", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2929         ("raidConfigOnHcl", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
2930         ("fwVersion", "string", "vim.version.version9", 0 | F_OPTIONAL),
2931         ("raidConfig", "string", "vim.version.version9", 0 | F_OPTIONAL),
2932         ("cacheConfig", "string", "vim.version.version9", 0 | F_OPTIONAL),
2933         (
2934             "cimProviderInfo",
2935             "vim.host.VsanHostCimProviderInfo",
2936             "vim.version.version9",
2937             0 | F_OPTIONAL,
2938         ),
2939     ],
2940 )
2941 CreateDataType(
2942     "vim.cluster.VsanClusterHealthResultKeyValuePair",
2943     "VsanClusterHealthResultKeyValuePair",
2944     "vmodl.DynamicData",
2945     "vim.version.version9",
2946     [
2947         ("key", "string", "vim.version.version9", 0 | F_OPTIONAL),
2948         ("value", "string", "vim.version.version9", 0 | F_OPTIONAL),
2949     ],
2950 )
2951 CreateDataType(
2952     "vim.cluster.StorageOperationalStatus",
2953     "VsanStorageOperationalStatus",
2954     "vmodl.DynamicData",
2955     "vim.version.version9",
2956     [
2957         ("healthy", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2958         ("operationETA", "vmodl.DateTime", "vim.version.version9", 0 | F_OPTIONAL),
2959         ("operationProgress", "long", "vim.version.version9", 0 | F_OPTIONAL),
2960         ("transitional", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
2961     ],
2962 )
2963 CreateDataType(
2964     "vim.cluster.VsanSpaceUsage",
2965     "VsanSpaceUsage",
2966     "vmodl.DynamicData",
2967     [
2968         ("totalCapacityB", "long", "vim.version.version9", 0),
2969         (<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"freeCapacityB", "long", "vim.version.version9", 0 | F_OPTIONAL),
2970         (
2971             "spaceOverview",
2972             "vim.cluster.VsanObjectSpaceSummary",
2973             "vim.version.version9",
2974             0 | F_OPTIONAL,
2975         ),
2976         (
2977             "spaceDetail",
2978             "vim.cluster.VsanSpaceUsageDetailResult",
2979             "vim.version.version9",
2980             0 | F_OPTIONAL,
2981         ),
2982     ],
2983 )
2984 CreateDataType(
2985     "vim.cluster.VsanClusterHealthResultTable",
2986     "VsanClusterHealthResultTable",
2987     "vim.cluster.VsanClusterHealthResultBase",
2988     "vim.version.version9",
2989     [
2990         (
2991             "columns",
2992             "vim.cluster.VsanClusterHealthResultColumnInfo[]",
2993             "vim.version.version9",
2994             0 | F_OPTIONAL,
2995         ),
2996         (
2997             "rows",
2998             "vim.cluster.VsanClusterHealthResultRow[]",
2999             "vim.version.version9",
3000             0 | F_OPTIONAL,
3001         ),
3002     ],
3003 )
3004 CreateDataType(
3005     "vim.cluster.VsanClusterConfig",
3006     "VsanClusterConfig",
3007     "vmodl.DynamicData",
3008     "vim.version.version9",
3009     [
3010         ("config", "vim.vsan.cluster.ConfigInfo", "vim.version.version9", 0),
3011         ("name", "string", "vim.version.version9", 0),
3012         ("hosts", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
3013     ],
3014 )
3015 CreateDataType(
3016     "vim.vsan.host.VsanHostCapability",
3017     "VimVsanHostVsanHostCapability",
3018     "vmodl.DynamicData",
3019     "vim.version.version10",
3020     [
3021         ("host", "vim.HostSystem", "vim.version.version10", 0),
3022         ("isSupported", "boolean", "vim.version.version10", 0),
3023         ("isLicensed", "boolean", "vim.version.version10", 0),
3024     ],
3025 )
3026 CreateDataType(
3027     "vim.cluster.VsanPerfThreshold",
3028     "VsanPerfThreshold",
3029     "vmodl.DynamicData",
3030     "vim.version.version9",
3031     [
3032         (
3033             "direction",
3034             "vim.cluster.VsanPerfThresholdDirectionType",
3035             "vim.version.version9",
3036             0,
3037         ),
3038         ("yellow", "string", "vim.version.version9", 0 | F_OPTIONAL),
3039         ("red", "string", "vim.version.version9", 0 | F_OPTIONAL),
3040     ],
3041 )
3042 CreateDataType(
3043     "vim.host.VsanNetworkHealthResult",
3044     "VsanNetworkHealthResult",
3045     "vmodl.DynamicData",
3046     "vim.version.version9",
3047     [
3048         ("host", "vim.HostSystem", "vim.version.version9", 0 | F_OPTIONAL),
3049         ("hostname", "string", "vim.version.version9", 0 | F_OPTIONAL),
3050         ("vsanVmknicPresent"</b></font>, "boolean", "vim.version.version9", 0 | F_OPTIONAL),
3051         ("ipSubnets", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
3052         ("issueFound", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
3053         (
3054             "peerHealth",
3055             "vim.host.VsanNetworkPeerHealthResult[]",
3056             "vim.version.version9",
3057             0 | F_OPTIONAL,
3058         ),
3059         ("multicastConfig", "string", "vim.version.version9", 0 | F_OPTIONAL),
3060     ],
3061 )
3062 CreateDataType(
3063     "vim.vsan.ConfigInfoEx",
3064     "VsanConfigInfoEx",
3065     "vim.vsan.cluster.ConfigInfo",
3066     "vim.version.version10",
3067     [
3068         (
3069             "dataEfficiencyConfig",
3070             "vim.vsan.DataEfficiencyConfig",
3071             "vim.version.version10",
3072             0 | F_OPTIONAL,
3073         )
3074     ],
3075 )
3076 CreateDataType(
3077     "vim.host.VsanVmdkLoadTestResult",
3078     "VsanVmdkLoadTestResult",
3079     "vmodl.DynamicData",
3080     "vim.version.version9",
3081     [
3082         ("success", "boolean", "vim.version.version9", 0),
3083         ("faultMessage", "string", "vim.version.version9", 0 | F_OPTIONAL),
3084         ("spec", "vim.host.VsanVmdkLoadTestSpec", "vim.version.version9", 0),
3085         ("actualDurationSec", "int", "vim.version.version9", 0 | F_OPTIONAL),
3086         ("totalBytes", "long", "vim.version.version9", 0 | F_OPTIONAL),
3087         ("iops", "long", "vim.version.version9", 0 | F_OPTIONAL),
3088         ("tputBps", "long", "vim.version.version9", 0 | F_OPTIONAL),
3089         ("avgLatencyUs", "long", "vim.version.version9", 0 | F_OPTIONAL),
3090         ("maxLatencyUs", "long", "vim.version.version9", 0 | F_OPTIONAL),
3091         ("numIoAboveLatencyThreshold", "long", "vim.version.version9", 0 | F_OPTIONAL),
3092     ],
3093 )
3094 CreateDataType(
3095     "vim.cluster.VsanClusterVMsHealthOverallResult",
3096     "VsanClusterVMsHealthOverAllResult",
3097     "vim.version.version9",
3098     [
3099         <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(
3100             "healthStateList",
3101             "vim.cluster.VsanClusterVMsHealthSummaryResult[]",
3102             "vim.version.version9",
3103             0 | F_OPTIONAL,
3104         ),
3105         ("overallHealthState", "string", "vim.version.version9", 0 | F_OPTIONAL),
3106     ],
3107 )
3108 CreateDataType(
3109     "vim.host.VsanHostHealthSystemStatusResult",
3110     "VsanHostHealthSystemStatusResult",
3111     "vmodl.DynamicData",
3112     "vim.version.version9",
3113     [
3114         ("hostname", "string", "vim.version.version9", 0),
3115         ("status", "string", "vim.version.version9", 0),
3116         ("issues", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
3117     ],
3118 )
3119 CreateDataType(
3120     "vim.cluster.VsanClusterAdvCfgSyncResult",
3121     "VsanClusterAdvCfgSyncResult",
3122     "vmodl.DynamicData",
3123     "vim.version.version9",
3124     [
3125         ("inSync", "boolean", "vim.version.version9", 0),
3126         ("name", "string", "vim.version.version9", 0),
3127         (
3128             "hostValues",
3129             "vim.cluster.VsanClusterAdvCfgSyncHostResult[]",
3130             "vim.version.version9",
3131             0 | F_OPTIONAL,
3132         ),
3133     ],
3134 )
3135 CreateDataType(
3136     "vim.host.VsanQueryResultHostInfo",
3137     "VsanQueryResultHostInfo",
3138     "vmodl.DynamicData",
3139     "vim.version.version9",
3140     [
3141         ("uuid", "string", "vim.version.version9", 0 | F_OPTIONAL),
3142         ("hostnameInCmmds", "string", "vim.version.version9", 0 | F_OPTIONAL),
3143         ("vsanIpv4Addresses", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
3144     ],
3145 )
3146 CreateDataType(
3147     "vim.vsan.host.DiskMapInfoEx",
3148     "VimVsanHostDiskMapInfoEx",
3149     "vmodl.DynamicData",
3150     "vim.version.version10",
3151     [
3152         ("mapping", "vim.vsan.host.DiskMapping", "vim.version.version10", 0),
3153         ("isMounted", "boolean", "vim.version.version10", 0),
3154         ("isAllFlash"</b></font>, "boolean", "vim.version.version10", 0),
3155         ("isDataEfficiency", "boolean", "vim.version.version10", 0 | F_OPTIONAL),
3156     ],
3157 )
3158 CreateDataType(
3159     "vim.host.VsanVmdkLoadTestSpec",
3160     "VsanVmdkLoadTestSpec",
3161     "vmodl.DynamicData",
3162     "vim.version.version9",
3163     [
3164         (
3165             "vmdkCreateSpec",
3166             "vim.VirtualDiskManager.FileBackedVirtualDiskSpec",
3167             "vim.version.version9",
3168             0 | F_OPTIONAL,
3169         ),
3170         (
3171             "vmdkIOSpec",
3172             "vim.host.VsanVmdkIOLoadSpec",
3173             "vim.version.version9",
3174             0 | F_OPTIONAL,
3175         ),
3176         (
3177             "vmdkIOSpecSequence",
3178             "vim.host.VsanVmdkIOLoadSpec[]",
3179             "vim.version.version9",
3180             0 | F_OPTIONAL,
3181         ),
3182         ("stepDurationSec", "long", "vim.version.version9", 0 | F_OPTIONAL),
3183     ],
3184 )
3185 CreateDataType(
3186     "vim.cluster.VsanClusterHealthSummary",
3187     "VsanClusterHealthSummary",
3188     "vmodl.DynamicData",
3189     "vim.version.version9",
3190     [
3191         (
3192             "clusterStatus",
3193             "vim.cluster.VsanClusterHealthSystemStatusResult",
3194             "vim.version.version9",
3195             0 | F_OPTIONAL,
3196         ),
3197         ("timestamp", "vmodl.DateTime", "vim.version.version9", 0 | F_OPTIONAL),
3198         (
3199             "clusterVersions",
3200             "vim.cluster.VsanClusterHealthSystemVersionResult",
3201             "vim.version.version9",
3202             0 | F_OPTIONAL,
3203         ),
3204         (
3205             "objectHealth",
3206             "vim.host.VsanObjectOverallHealth",
3207             "vim.version.version9",
3208             0 | F_OPTIONAL,
3209         ),
3210         (
3211             "vmHealth",
3212             "vim.cluster.VsanClusterVMsHealthOverallResult",
3213             "vim.version.version9",
3214             0 | F_OPTIONAL,
3215         ),
3216         (
3217             "networkHealth",
3218             "vim.cluster.VsanClusterNetworkHealthResult",
3219             "vim.version.version9",
3220             0 | F_OPTIONAL,
3221         ),
3222         (
3223             "limitHealth",
3224             "vim.cluster.VsanClusterLimitHealthResult",
3225             "vim.version.version9",
3226             0 | F_OPTIONAL,
3227         ),
3228         (
3229             "advCfgSync",
3230             "vim.cluster.VsanClusterAdvCfgSyncResult[]",
3231             "vim.version.version9",
3232             0 | F_OPTIONAL,
3233         ),
3234         (
3235             "createVmHealth",
3236             "vim.cluster.VsanHostCreateVmHealthTestResult[]",
3237             "vim.version.version9",
3238             0 | F_OPTIONAL,
3239         ),
3240         (
3241             "physicalDisksHealth",
3242             "vim.host.VsanPhysicalDiskHealthSummary[]",
3243             "vim.version.version9",
3244             0 | F_OPTIONAL,
3245         ),
3246         (
3247             "hclInfo",
3248             "vim.cluster.VsanClusterHclInfo",
3249             "vim.version.version9",
3250             0 | F_OPTIONAL,
3251         ),
3252         (
3253             "groups",
3254             "vim.cluster.VsanClusterHealthGroup[]",
3255             "vim.version.version9",
3256             0 | F_OPTIONAL,
3257         ),
3258         ("overallHealth", "string", "vim.version.version9", 0),
3259         ("overallHealthDescription", "string", "vim.version.version9", 0),
3260         (
3261             "clomdLiveness",
3262             "vim.cluster.VsanClusterClomdLivenessResult",
3263             "vim.version.version9",
3264             0 | F_OPTIONAL,
3265         ),
3266         (
3267             "diskBalance",
3268             "vim.cluster.VsanClusterBalanceSummary",
3269             "vim.version.version9",
3270             0 | F_OPTIONAL,
3271         ),
3272     ],
3273 )
3274 CreateDataType(
3275     "vim.cluster.VsanPerfEntityType",
3276     "VsanPerfEntityType",
3277     "vmodl.DynamicData",
3278     "vim.version.version9",
3279     [
3280         ("name", "string", "vim.version.version9", 0),
3281         ("id", "string", "vim.version.version9", 0),
3282         ("graphs", "vim.cluster.VsanPerfGraph[]", "vim.version.version9", 0),
3283         ("description", "string", "vim.version.version9", 0 | F_OPTIONAL),
3284     ],
3285 )
3286 CreateDataType(
3287     "vim.host.VsanNetworkLoadTestResult",
3288     "VsanNetworkLoadTestResult",
3289     "vmodl.DynamicData",
3290     "vim.version.version9",
3291     [
3292         ("hostname", "string", "vim.version.version9", 0),
3293         ("status", "string", "vim.version.version9", 0 | F_OPTIONAL),
3294         ("client", "boolean", "vim.version.version9", 0),
3295         ("bandwidthBps", "long", "vim.version.version9", 0),
3296         ("totalBytes", "long", "vim.version.version9", 0),
3297         ("lostDatagrams", "long", "vim.version.version9", 0 | F_OPTIONAL),
3298         ("lossPct", "long", "vim.version.version9", 0 | F_OPTIONAL),
3299         ("sentDatagrams", "long", "vim.version.version9", 0 | F_OPTIONAL),
3300         ("jitterMs", "float", "vim.version.version9", 0 | F_OPTIONAL),
3301     ],
3302 )
3303 CreateDataType(
3304     "vim.host.VsanPhysicalDiskHealthSummary",
3305     "VsanPhysicalDiskHealthSummary",
3306     "vmodl.DynamicData",
3307     "vim.version.version9",
3308     [
3309         ("overallHealth", "string", "vim.version.version9", 0),
3310         (
3311             "heapsWithIssues",
3312             "vim.host.VsanResourceHealth[]",
3313             "vim.version.version9",
3314             0 | F_OPTIONAL,
3315         ),
3316         (
3317             "slabsWithIssues",
3318             "vim.host.VsanResourceHealth[]",
3319             "vim.version.version9",
3320             0 | F_OPTIONAL,
3321         ),
3322         (
3323             "disks",
3324             "vim.host.VsanPhysicalDiskHealth[]",
3325             "vim.version.version9",
3326             0 | F_OPTIONAL,
3327         ),
3328         (
3329             "componentsWithIssues",
3330             "vim.host.VsanResourceHealth[]",
3331             "vim.version.version9",
3332             0 | F_OPTIONAL,
3333         ),
3334         ("hostname", "string", "vim.version.version9", 0 | F_OPTIONAL),
3335         ("hostDedupScope", "int", "vim.version.version9", 0 | F_OPTIONAL),
3336         ("error", "vmodl.MethodFault", "vim.version.version9", 0 | F_OPTIONAL),
3337     ],
3338 )
3339 CreateDataType(
3340     "vim.vsan.host.VsanDiskManagementSystemCapability",
3341     "vmodl.DynamicData",
3342     "vim.version.version10",
3343     [(<font color="#f62817"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"version", "string", "vim.version.version10", 0)],
3344 )
3345 CreateDataType(
3346     "vim.host.VsanHostCimProviderInfo",
3347     "VsanHostCimProviderInfo",
3348     "vmodl.DynamicData",
3349     "vim.version.version9",
3350     [
3351         ("cimProviderSupported", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
3352         ("installedCIMProvider", "string", "vim.version.version9", 0 | F_OPTIONAL),
3353         ("cimProviderOnHcl", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
3354     ],
3355 )
3356 CreateDataType(
3357     "vim.cluster.VsanObjectInformation",
3358     "VsanObjectInformation",
3359     "vmodl.DynamicData",
3360     "vim.version.version9",
3361     [
3362         ("directoryName", "string", "vim.version.version9", 0 | F_OPTIONAL),
3363         ("vsanObjectUuid", "string", "vim.version.version9", 0 | F_OPTIONAL),
3364         ("vsanHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
3365         ("policyAttributes", "vim.KeyValue[]", "vim.version.version9", 0 | F_OPTIONAL),
3366         ("spbmProfileUuid", "string", "vim.version.version9", 0 | F_OPTIONAL),
3367         ("spbmProfileGenerationId"</b></font>, "string", "vim.version.version9", 0 | F_OPTIONAL),
3368         (
3369             "spbmComplianceResult",
3370             "vim.cluster.StorageComplianceResult",
3371             "vim.version.version9",
3372             0 | F_OPTIONAL,
3373         ),
3374     ],
3375 )
3376 CreateDataType(
3377     "vim.cluster.VsanObjectIdentity",
3378     "VsanObjectIdentity",
3379     "vim.version.version9",
3380     [
3381         <font color="#f660ab"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("uuid", "string", "vim.version.version9", 0),
3382         ("type", "string", "vim.version.version9", 0),
3383         ("vmInstanceUuid", "string", "vim.version.version9", 0 | F_OPTIONAL),
3384         ("vmNsObjectUuid", "string", "vim.version.version9", 0 | F_OPTIONAL),
3385         ("vm", "vim.VirtualMachine", "vim.version.version9", 0 | F_OPTIONAL),
3386         ("description", "string", "vim.version.version9", 0 | F_OPTIONAL),
3387     ],
3388 )
3389 CreateDataType(
3390     "vim.host.VsanResourceHealth",
3391     "VsanResourceHealth",
3392     "vmodl.DynamicData",
3393     "vim.version.version9",
3394     [
3395         ("resource", "string", "vim.version.version9", 0),
3396         ("health", "string", "vim.version.version9", 0),
3397         ("description", "string", "vim.version.version9", 0 | F_OPTIONAL),
3398     ],
3399 )
3400 CreateDataType(</b></font>
3401     "vim.cluster.VsanCapability",
3402     "VsanCapability",
3403     "vim.version.version10",
3404     [
3405         <font color="#3ea99f"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("target", "vmodl.ManagedObject", "vim.version.version10", 0 | F_OPTIONAL),
3406         ("capabilities", "string[]", "vim.version.version10", 0 | F_OPTIONAL),
3407     ],
3408 )
3409 CreateDataType(
3410     "vim.cluster.VsanHostClomdLivenessResult",
3411     "VsanHostClomdLivenessResult",
3412     "vmodl.DynamicData",
3413     "vim.version.version9",
3414     [
3415         ("hostname", "string", "vim.version.version9", 0),
3416         ("clomdStat", "string", "vim.version.version9", 0),
3417         ("error", "vmodl.MethodFault", "vim.version.version9", 0 | F_OPTIONAL),
3418     ],
3419 )
3420 CreateDataType(
3421     "vim.cluster.VsanObjectQuerySpec",
3422     "VsanObjectQuerySpec",
3423     "vmodl.DynamicData",
3424     "vim.version.version9",
3425     [
3426         ("uuid", "string", "vim.version.version9", 0),
3427         ("spbmProfileGenerationId"</b></font>, "string", "vim.version.version9", 0 | F_OPTIONAL),
3428     ],
3429 )
3430 CreateDataType(
3431     "vim.cluster.VsanClusterLimitHealthResult",
3432     "VsanClusterLimitHealthResult",
3433     "vmodl.DynamicData",
3434     "vim.version.version9",
3435     [
3436         ("issueFound", "boolean", "vim.version.version9", 0),
3437         ("componentLimitHealth", "string", "vim.version.version9", 0),
3438         ("diskFreeSpaceHealth", "string", "vim.version.version9", 0),
3439         ("rcFreeReservationHealth", "string", "vim.version.version9", 0),
3440         (
3441             "hostResults",
3442             "vim.host.VsanLimitHealthResult[]",
3443             "vim.version.version9",
3444             0 | F_OPTIONAL,
3445         ),
3446         (
3447             "whatifHostFailures",
3448             "vim.cluster.VsanClusterWhatifHostFailuresResult[]",
3449             "vim.version.version9",
3450             0 | F_OPTIONAL,
3451         ),
3452         ("hostsCommFailure", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
3453     ],
3454 )
3455 CreateDataType(
3456     "vim.cluster.VsanStorageWorkloadType",
3457     "VsanStorageWorkloadType",
3458     "vmodl.DynamicData",
3459     "vim.version.version9",
3460     [
3461         ("typeId", "string", "vim.version.version9", 0),
3462         ("name", "string", "vim.version.version9", 0),
3463         (<font color="#2981b2"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"description", "string", "vim.version.version9", 0),
3464     ],
3465 )
3466 CreateDataType(
3467     "vim.cluster.VsanClusterAdvCfgSyncHostResult",
3468     "VsanClusterAdvCfgSyncHostResult",
3469     "vmodl.DynamicData",
3470     "vim.version.version9",
3471     [
3472         ("hostname", "string", "vim.version.version9", 0),
3473         ("value", "string", "vim.version.version9", 0),
3474     ],
3475 )
3476 CreateDataType(
3477     "vim.vsan.upgradesystem.ObjectPolicyIssue",
3478     "VsanObjectPolicyIssue",
3479     "vim.VsanUpgradeSystem.PreflightCheckIssue",
3480     "vim.version.version10",
3481     [("uuids", "string[]", "vim.version.version10", 0)],
3482 )
3483 CreateDataType(
3484     "vim.cluster.VsanPerfTopEntities",
3485     "VsanPerfTopEntities",
3486     "vmodl.DynamicData",
3487     "vim.version.version9",
3488     [
3489         ("metricId", "vim.cluster.VsanPerfMetricId", "vim.version.version9", 0),
3490         ("entities", "vim.cluster.VsanPerfTopEntity[]", "vim.version.version9", 0),
3491     ],
3492 )
3493 CreateDataType(
3494     "vim.host.VsanProactiveRebalanceInfoEx",
3495     "VsanProactiveRebalanceInfoEx",
3496     "vmodl.DynamicData",
3497     "vim.version.version9",
3498     [
3499         ("running", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
3500         ("startTs"</b></font>, "vmodl.DateTime", "vim.version.version9", 0 | F_OPTIONAL),
3501         ("stopTs", "vmodl.DateTime", "vim.version.version9", 0 | F_OPTIONAL),
3502         ("varianceThreshold", "float", "vim.version.version9", 0 | F_OPTIONAL),
3503         ("timeThreshold", "int", "vim.version.version9", 0 | F_OPTIONAL),
3504         ("rateThreshold", "int", "vim.version.version9", 0 | F_OPTIONAL),
3505         ("hostname", "string", "vim.version.version9", 0 | F_OPTIONAL),
3506         ("error", "vmodl.MethodFault", "vim.version.version9", 0 | F_OPTIONAL),
3507     ],
3508 )
3509 CreateDataType(
3510     "vim.cluster.VsanClusterProactiveTestResult",
3511     "VsanClusterProactiveTestResult",
3512     "vim.version.version9",
3513     [
3514         <font color="#f52887"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("overallStatus", "string", "vim.version.version9", 0),
3515         ("overallStatusDescription", "string", "vim.version.version9", 0),
3516         ("timestamp", "vmodl.DateTime", "vim.version.version9", 0),
3517         (
3518             "healthTest",
3519             "vim.cluster.VsanClusterHealthTest",
3520             "vim.version.version9",
3521             0 | F_OPTIONAL,
3522         ),
3523     ],
3524 )
3525 CreateDataType(
3526     "vim.host.VSANCmmdsPreferredFaultDomainInfo",
3527     "VimHostVSANCmmdsPreferredFaultDomainInfo",
3528     "vmodl.DynamicData",
3529     "vim.version.version10",
3530     [
3531         ("preferredFaultDomainId", "string", "vim.version.version10", 0),
3532         ("preferredFaultDomainName", "string", "vim.version.version10", 0),
3533     ],
3534 )
3535 CreateDataType(
3536     "vim.cluster.VsanFaultDomainsConfigSpec",
3537     "VimClusterVsanFaultDomainsConfigSpec",
3538     "vmodl.DynamicData",
3539     "vim.version.version10",
3540     [
3541         (
3542             "faultDomains",
3543             "vim.cluster.VsanFaultDomainSpec[]",
3544             "vim.version.version10",
3545             0,
3546         ),
3547         (
3548             "witness",
3549             "vim.cluster.VsanWitnessSpec",
3550             "vim.version.version10",
3551             0 | F_OPTIONAL,
3552         ),
3553     ],
3554 )
3555 CreateDataType(
3556     "vim.cluster.VsanClusterHostVmknicMapping",
3557     "VsanClusterHostVmknicMapping",
3558     "vmodl.DynamicData",
3559     "vim.version.version9",
3560     [
3561         ("host"</b></font>, "string", "vim.version.version9", 0),
3562         ("vmknic", "string", "vim.version.version9", 0),
3563     ],
3564 )
3565 CreateDataType(
3566     "vim.cluster.VsanClusterVmdkLoadTestResult",
3567     "VsanClusterVmdkLoadTestResult",
3568     "vmodl.DynamicData",
3569     "vim.version.version9",
3570     [
3571         ("task", "vim.Task", "vim.version.version9", 0 | F_OPTIONAL),
3572         (
3573             "clusterResult",
3574             "vim.cluster.VsanClusterProactiveTestResult",
3575             "vim.version.version9",
3576         ),
3577         (
3578             <font color="#4cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"hostResults",
3579             "vim.host.VsanHostVmdkLoadTestResult[]",
3580             "vim.version.version9",
3581             0 | F_OPTIONAL,
3582         ),
3583     ],
3584 )
3585 CreateDataType(
3586     "vim.cluster.VsanClusterVMsHealthSummaryResult",
3587     "VsanClusterVMsHealthSummaryResult",
3588     "vmodl.DynamicData",
3589     "vim.version.version9",
3590     [
3591         ("numVMs", "int", "vim.version.version9", 0),
3592         ("state", "string", "vim.version.version9", 0 | F_OPTIONAL),
3593         ("health", "string", "vim.version.version9", 0),
3594         ("vmInstanceUuids", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
3595     ],
3596 )
3597 CreateDataType(
3598     "vim.host.VSANStretchedClusterHostCapability",
3599     "VimHostVSANStretchedClusterHostCapability",
3600     "vmodl.DynamicData",
3601     "vim.version.version10",
3602     [("featureVersion", "string", "vim.version.version10", 0)],
3603 )
3604 CreateDataType(
3605     "vim.host.VsanFailedRepairObjectResult",
3606     "VsanFailedRepairObjectResult",
3607     "vmodl.DynamicData",
3608     "vim.version.version9",
3609     [
3610         ("uuid"</b></font>, "string", "vim.version.version9", 0),
3611         ("errMessage", "string", "vim.version.version9", 0 | F_OPTIONAL),
3612     ],
3613 )
3614 CreateDataType(
3615     "vim.cluster.VsanClusterCreateVmHealthTestResult",
3616     "VsanClusterCreateVmHealthTestResult",
3617     "vim.version.version9",
3618     [
3619         <font color="#ae694a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(
3620             "clusterResult",
3621             "vim.cluster.VsanClusterProactiveTestResult",
3622             "vim.version.version9",
3623             0,
3624         ),
3625         (
3626             "hostResults",
3627             "vim.cluster.VsanHostCreateVmHealthTestResult[]",
3628             "vim.version.version9",
3629             0 | F_OPTIONAL,
3630         ),
3631     ],
3632 )
3633 CreateDataType(
3634     "vim.host.VsanObjectHealth",
3635     "VsanObjectHealth",
3636     "vmodl.DynamicData",
3637     "vim.version.version9",
3638     [
3639         ("numObjects", "int", "vim.version.version9", 0),
3640         ("health", "vim.host.VsanObjectHealthState", "vim.version.version9", 0),
3641         ("objUuids", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
3642     ],
3643 )
3644 CreateDataType(
3645     "vim.cluster.VsanClusterBalanceSummary",
3646     "VsanClusterBalanceSummary",
3647     "vmodl.DynamicData",
3648     "vim.version.version9",
3649     [
3650         ("varianceThreshold", "long", "vim.version.version9", 0),
3651         (
3652             "disks"</b></font>,
3653             "vim.cluster.VsanClusterBalancePerDiskInfo[]",
3654             "vim.version.version9",
3655             0 | F_OPTIONAL,
3656         ),
3657     ],
3658 )
3659 CreateDataType(
3660     "vim.cluster.VsanClusterTelemetryProxyConfig",
3661     "VsanClusterTelemetryProxyConfig",
3662     "vmodl.DynamicData",
3663     "vim.version.version9",
3664     [
3665         ("host", "string", "vim.version.version9", 0 | F_OPTIONAL),
3666         ("port", "int", "vim.version.version9", 0 | F_OPTIONAL),
3667         ("user", "string", "vim.version.version9", 0 | F_OPTIONAL),
3668         ("password", "string", "vim.version.version9", 0 | F_OPTIONAL),
3669         ("autoDiscovered", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
3670     ],
3671 )
3672 CreateDataType(
3673     "vim.host.VsanVmdkIOLoadSpec",
3674     "VsanVmdkIOLoadSpec",
3675     "vmodl.DynamicData",
3676     "vim.version.version9",
3677     [
3678         ("readPct", "int", "vim.version.version9", 0),
3679         ("oio", "int", "vim.version.version9", 0),
3680         ("iosizeB", "int", "vim.version.version9", 0),
3681         ("dataSizeMb", "long", "vim.version.version9", 0),
3682         ("random", "boolean", "vim.version.version9", 0),
3683         ("startOffsetB", "long", "vim.version.version9", 0 | F_OPTIONAL),
3684     ],
3685 )
3686 CreateDataType(
3687     "vim.host.VsanVsanPcapResult",
3688     "VsanVsanPcapResult",
3689     "vmodl.DynamicData",
3690     "vim.version.version9",
3691     [
3692         ("calltime", "float", "vim.version.version9", 0),
3693         ("vmknic", "string", "vim.version.version9", 0),
3694         ("tcpdumpFilter", "string", "vim.version.version9", 0),
3695         ("snaplen", "int", "vim.version.version9", 0),
3696         ("pkts", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
3697         ("pcap", "string", "vim.version.version9", 0 | F_OPTIONAL),
3698         ("error", "vmodl.MethodFault", "vim.version.version9", 0 | F_OPTIONAL),
3699         ("hostname", "string", "vim.version.version9", 0 | F_OPTIONAL),
3700     ],
3701 )
3702 CreateDataType(
3703     "vim.cluster.VsanClusterNetworkLoadTestResult",
3704     "VsanClusterNetworkLoadTestResult",
3705     "vmodl.DynamicData",
3706     "vim.version.version9",
3707     [
3708         (
3709             "clusterResult",
3710             "vim.cluster.VsanClusterProactiveTestResult",
3711             "vim.version.version9",
3712         ),
3713         (
3714             <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"hostResults",
3715             "vim.host.VsanNetworkLoadTestResult[]",
3716             "vim.version.version9",
3717             0 | F_OPTIONAL,
3718         ),
3719     ],
3720 )
3721 CreateDataType(
3722     "vim.vsan.upgradesystem.HostPropertyRetrieveIssue",
3723     "VsanHostPropertyRetrieveIssue",
3724     "vim.VsanUpgradeSystem.PreflightCheckIssue",
3725     "vim.version.version10",
3726     [("hosts", "vim.HostSystem[]", "vim.version.version10", 0)],
3727 )
3728 CreateEnumType(
3729     "vim.host.VsanObjectHealthState",
3730     "VsanObjectHealthState",
3731     "vim.version.version9",
3732     [
3733         "inaccessible",
3734         "reducedavailabilitywithnorebuild",
3735         "reducedavailabilitywithnorebuilddelaytimer",
3736         "reducedavailabilitywithactiverebuild",
3737         "datamove",
3738         "nonavailabilityrelatedreconfig",
3739         "nonavailabilityrelatedincompliance",
3740         "healthy",
3741     ],
3742 )
3743 CreateEnumType(
3744     "vim.cluster.VsanObjectTypeEnum",
3745     "VsanObjectTypeEnum",
3746     "vim.version.version9",
3747     [
3748         "vmswap",
3749         "vdisk",
3750         "namespace",
3751         "vmem",
3752         "statsdb",
3753         "iscsi",
3754         "other",
3755         "fileSystemOverhead",
3756         "dedupOverhead",
3757         "checksumOverhead",
3758     ],
3759 )
3760 CreateEnumType(
3761     "vim.cluster.VsanCapabilityType",
3762     "VsanCapabilityType",
3763     "vim.version.version10",
3764     [
3765         "capability",
3766         "allflash",
3767         "stretchedcluster",
3768         "dataefficiency",
3769         "clusterconfig",
3770         "upgrade",
3771         "objectidentities",
3772     ],
3773 )
3774 CreateEnumType(
3775     "vim.cluster.VsanHealthLogLevelEnum",
3776     "VsanHealthLogLevelEnum",
3777     "vim.version.version9",
3778     [
3779         "INFO",
3780         "WARNING",
3781         "ERROR",
3782         "DEBUG",
3783         "CRITICAL",
3784     ],
3785 )
3786 CreateEnumType(
3787     "vim.cluster.VsanPerfSummaryType",
3788     "VsanPerfSummaryType",
3789     "vim.version.version9",
3790     [
3791         "average",
3792         "maximum",
3793         "minimum",
3794         "latest",
3795         "summation",
3796         "none",
3797     ],
3798 )
3799 CreateEnumType(
3800     "vim.cluster.StorageComplianceStatus",
3801     "VsanStorageComplianceStatus",
3802     "vim.version.version9",
3803     [
3804         "compliant",
3805         "nonCompliant",
3806         "unknown",
3807         "notApplicable",
3808     ],
3809 )
3810 CreateEnumType(
3811     "vim.cluster.VsanPerfStatsUnitType",
3812     "VsanPerfStatsUnitType",
3813     "vim.version.version9",
3814     [
3815         "number",
3816         "time_ms",
3817         "percentage",
3818         "size_bytes",
3819         "rate_bytes",
3820     ],
3821 )
3822 CreateEnumType(
3823     "vim.cluster.VsanPerfThresholdDirectionType",
3824     "VsanPerfThresholdDirectionType",
3825     "vim.version.version9",
3826     [
3827         "upper",
3828         "lower",
3829     ],
3830 )
3831 CreateEnumType(
3832     "vim.cluster.VsanPerfStatsType",
3833     "VsanPerfStatsType",
3834     "vim.version.version9",
3835     [
3836         "absolute",
3837         "delta",
3838         "rate",
3839     ],
3840 )
3841 CreateEnumType(
3842     "vim.vsan.host.DiskMappingCreationType",
3843     "VimVsanHostDiskMappingCreationType",
3844     "vim.version.version10",
3845     [
3846         "hybrid",
3847         "allFlash",
3848     ],
3849 )
3850 CreateEnumType(
3851     "vim.cluster.VsanClusterHealthActionIdEnum",
3852     "VsanClusterHealthActionIdEnum",
3853     "vim.version.version9",
3854     [
3855         "RepairClusterObjectsAction",
3856         "UploadHclDb",
3857         "UpdateHclDbFromInternet",
3858         "EnableHealthService",
3859         "DiskBalance",
3860         "StopDiskBalance",
3861         "RemediateDedup",
3862         "UpgradeVsanDiskFormat",
3863     ],
3864 )
3865 CreateEnumType(
3866     "vim.cluster.VsanDiskGroupCreationType",
3867     "VimClusterVsanDiskGroupCreationType",
3868     "vim.version.version10",
3869     [
3870         "allflash"</b></font>,
3871         "hybrid",
3872     ],
3873 )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_virt_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import datetime
2 import os
3 import shutil
4 import tempfile
5 import xml.etree.ElementTree as ET
6 import salt.config
7 import salt.modules.config as config
8 import salt.modules.virt as virt
9 import salt.syspaths
10 import salt.utils.yaml
11 from salt.exceptions import CommandExecutionError, SaltInvocationError
12 from tests.support.helpers import dedent
13 from tests.support.mixins import LoaderModuleMockMixin
14 from tests.support.mock import MagicMock, patch
15 from tests.support.unit import TestCase
16 class LibvirtMock(MagicMock):  # pylint: disable=too-many-ancestors
17     class virDomain(MagicMock):
18     class libvirtError(Exception):
19         def __init__(self, msg):
20             super().__init__(msg)
21             self.msg = msg
22         def get_error_message(self):
23             return self.msg
24 class VirtTestCase(TestCase, LoaderModuleMockMixin):
25     def setup_loader_modules(self):
26         self.mock_libvirt = LibvirtMock()
27         self.mock_conn = MagicMock()
28         self.mock_conn.getStoragePoolCapabilities.return_value = (
29             "&lt;storagepoolCapabilities/&gt;"
30         )
31         self.mock_libvirt.openAuth.return_value = self.mock_conn
32         self.mock_popen = MagicMock()
33         self.addCleanup(delattr, self, "mock_libvirt")
34         self.addCleanup(delattr, self, "mock_conn")
35         self.addCleanup(delattr, self, "mock_popen")
36         self.mock_subprocess = MagicMock()
37         self.mock_subprocess.return_value = (
38             self.mock_subprocess
39         )  # pylint: disable=no-member
40         self.mock_subprocess.Popen.return_value = (
41             self.mock_popen
42         )  # pylint: disable=no-member
43         loader_globals = {
44             "__salt__": {"config.get": config.get, "config.option": config.option},
45             "libvirt": self.mock_libvirt,
46             "subprocess": self.mock_subprocess,
47         }
48         return {virt: loader_globals, config: loader_globals}
49     def set_mock_vm(self, name, xml):
50         self.mock_conn.listDefinedDomains.return_value = [
51             name
52         ]  # pylint: disable=no-member
53         mock_domain = self.mock_libvirt.virDomain()
54         self.mock_conn.lookupByName.return_value = (
55             mock_domain  # pylint: disable=no-member
56         )
57         mock_domain.XMLDesc.return_value = xml  # pylint: disable=no-member
58         mock_domain.info.return_value = [
59             4,
60             2048 * 1024,
61             1024 * 1024,
62             2,
63             1234,
64         ]  # pylint: disable=no-member
65         mock_domain.ID.return_value = 1
66         mock_domain.name.return_value = name
67         return mock_domain
68     def assert_equal_unit(self, actual, expected, unit="KiB"):
69         self.assertEqual(actual.get("unit"), unit)
70         self.assertEqual(actual.text, str(expected))
71     def test_disk_profile_merge(self):
72         root_dir = os.path.join(salt.syspaths.ROOT_DIR, "srv", "salt-images")
73         userdisks = [
74             {"name": "system", "image": "/path/to/image"},
75         ]
76         disks = virt<font color="#4e9258"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>._disk_profile(self.mock_conn, "default", "kvm", userdisks, "myvm")
77         self.assertEqual(
78             [
79                 {
80                     "name": "system",
81                     "device": "disk",
82                     "size": 8192,
83                     "format": "qcow2",
84                     "model": "virtio",
85                     "filename": "myvm_system.qcow2",
86                     "image": "/path/to/image",
87                     "source_file": "{}{}myvm_system.qcow2".format(root_dir, os.sep),
88                 },
89                 {
90                     "name": "data",
91                     "device": "disk",
92                     "size": 16384,
93                     "format": "raw",
94                     "model": "virtio",
95                     "filename": "myvm_data.raw",
96                     "source_file": "{}{}myvm_data.raw".format(root_dir, os.</b></font>sep),
97                 },
98             ],
99             disks,
100         )
101     def test_boot_default_dev(self):
102         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
103         nicp = virt._nic_profile("default", "kvm")
104         xml_data = virt._gen_xml(
105             self.mock_conn, "hello", 1, 512, diskp, nicp, "kvm", "hvm", "x86_64"
106         )
107         root = ET.fromstring(xml_data)
108         self.assertEqual(root.find("os/boot").attrib["dev"], "hd")
109         self.assertEqual(root.find("os/type").attrib["arch"], "x86_64")
110         self.assertEqual(root.find("os/type").text, "hvm")
111     def test_boot_custom_dev(self):
112         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
113         nicp = virt._nic_profile("default", "kvm")
114         xml_data = virt._gen_xml(
115             self.mock_conn,
116             "hello",
117             1,
118             512,
119             diskp,
120             nicp,
121             "kvm",
122             "hvm",
123             "x86_64",
124             boot_dev="cdrom",
125         )
126         root = ET.fromstring(xml_data)
127         self.assertEqual(root.find("os/boot").attrib["dev"], "cdrom")
128     def test_boot_multiple_devs(self):
129         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
130         nicp = virt._nic_profile("default", "kvm")
131         xml_data = virt._gen_xml(
132             self.mock_conn,
133             "hello",
134             1,
135             512,
136             diskp,
137             nicp,
138             "kvm",
139             "hvm",
140             "x86_64",
141             boot_dev="cdrom network",
142         )
143         root = ET.fromstring(xml_data)
144         devs = root.findall(".//boot")
145         self.assertTrue(len(devs) == 2)
146     def test_gen_xml_no_nic(self):
147         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
148         nicp = virt._nic_profile("default", "kvm")
149         xml_data = virt._gen_xml(
150             self.mock_conn,
151             "hello",
152             1,
153             512,
154             diskp,
155             nicp,
156             "kvm",
157             "hvm",
158             "x86_64",
159             serials=[{"type": "pty"}],
160         )
161         root = ET.fromstring(xml_data)
162         self.assertEqual(root.find("devices/serial").attrib["type"], "pty")
163     def test_gen_xml_for_telnet_serial(self):
164         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
165         nicp = virt._nic_profile("default", "kvm")
166         xml_data = virt._gen_xml(
167             self.mock_conn,
168             "hello",
169             1,
170             512,
171             diskp,
172             nicp,
173             "kvm",
174             "hvm",
175             "x86_64",
176             serials=[{"type": "tcp", "port": 22223, "protocol": "telnet"}],
177         )
178         root = ET.fromstring(xml_data)
179         self.assertEqual(root.find("devices/serial").attrib["type"], "tcp")
180         self.assertEqual(root.find("devices/serial/source").attrib["service"], "22223")
181         self.assertEqual(root.find("devices/serial/protocol").attrib["type"], "telnet")
182     def test_gen_xml_for_telnet_serial_unspecified_port(self):
183         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
184         nicp = virt._nic_profile("default", "kvm")
185         xml_data = virt._gen_xml(
186             self.mock_conn,
187             "hello",
188             1,
189             512,
190             diskp,
191             nicp,
192             "kvm",
193             "hvm",
194             "x86_64",
195             serials=[{"type": "tcp"}],
196         )
197         root = ET.fromstring(xml_data)
198         self.assertEqual(root.find("devices/serial").attrib["type"], "tcp")
199         self.assertEqual(root.find("devices/serial/source").attrib["service"], "23023")
200         self.assertFalse("tls" in root.find("devices/serial/source").keys())
201         self.assertEqual(root.find("devices/serial/protocol").attrib["type"], "telnet")
202     def test_gen_xml_for_chardev_types(self):
203         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
204         nicp = virt._nic_profile("default", "kvm")
205         xml_data = virt._gen_xml(
206             self.mock_conn,
207             "hello",
208             1,
209             512,
210             diskp,
211             nicp,
212             "kvm",
213             "hvm",
214             "x86_64",
215             consoles=[
216                 {"type": "pty", "path": "/dev/pts/2", "target_port": 2},
217                 {"type": "pty", "target_type": "usb-serial"},
218                 {"type": "stdio"},
219                 {"type": "file", "path": "/path/to/serial.log"},
220             ],
221             serials=[
222                 {"type": "pipe", "path": "/tmp/mypipe"},
223                 {"type": "udp", "host": "127.0.0.1", "port": 1234},
224                 {"type": "tcp", "port": 22223, "protocol": "raw", "tls": True},
225                 {"type": "unix", "path": "/path/to/socket"},
226             ],
227         )
228         root = ET.fromstring(xml_data)
229         self.assertEqual(root.find("devices/console[1]").attrib["type"], "pty")
230         self.assertEqual(
231             root.find("devices/console[1]/source").attrib["path"], "/dev/pts/2"
232         )
233         self.assertEqual(root.find("devices/console[1]/target").attrib["port"], "2")
234         self.assertEqual(root.find("devices/console[2]").attrib["type"], "pty")
235         self.assertIsNone(root.find("devices/console[2]/source"))
236         self.assertEqual(
237             root.find("devices/console[2]/target").attrib["type"], "usb-serial"
238         )
239         self.assertEqual(root.find("devices/console[3]").attrib["type"], "stdio")
240         self.assertIsNone(root.find("devices/console[3]/source"))
241         self.assertEqual(root.find("devices/console[4]").attrib["type"], "file")
242         self.assertEqual(
243             root.find("devices/console[4]/source").attrib["path"], "/path/to/serial.log"
244         )
245         self.assertEqual(root.find("devices/serial[1]").attrib["type"], "pipe")
246         self.assertEqual(
247             root.find("devices/serial[1]/source").attrib["path"], "/tmp/mypipe"
248         )
249         self.assertEqual(root.find("devices/serial[2]").attrib["type"], "udp")
250         self.assertEqual(root.find("devices/serial[2]/source").attrib["mode"], "bind")
251         self.assertEqual(
252             root.find("devices/serial[2]/source").attrib["service"], "1234"
253         )
254         self.assertEqual(
255             root.find("devices/serial[2]/source").attrib["host"], "127.0.0.1"
256         )
257         self.assertEqual(root.find("devices/serial[3]").attrib["type"], "tcp")
258         self.assertEqual(root.find("devices/serial[3]/source").attrib["mode"], "bind")
259         self.assertEqual(
260             root.find("devices/serial[3]/source").attrib["service"], "22223"
261         )
262         self.assertEqual(root.find("devices/serial[3]/source").attrib["tls"], "yes")
263         self.assertEqual(root.find("devices/serial[3]/protocol").attrib["type"], "raw")
264         self.assertEqual(root.find("devices/serial[4]").attrib["type"], "unix")
265         self.assertEqual(
266             root.find("devices/serial[4]/source").attrib["path"], "/path/to/socket"
267         )
268     def test_gen_xml_no_nic_console(self):
269         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
270         nicp = virt._nic_profile("default", "kvm")
271         xml_data = virt._gen_xml(
272             self.mock_conn,
273             "hello",
274             1,
275             512,
276             diskp,
277             nicp,
278             "kvm",
279             "hvm",
280             "x86_64",
281             consoles=[{"type": "pty"}],
282         )
283         root = ET.fromstring(xml_data)
284         self.assertEqual(root.find("devices/console").attrib["type"], "pty")
285     def test_gen_xml_for_telnet_console(self):
286         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
287         nicp = virt._nic_profile("default", "kvm")
288         xml_data = virt._gen_xml(
289             self.mock_conn,
290             "hello",
291             1,
292             512,
293             diskp,
294             nicp,
295             "kvm",
296             "hvm",
297             "x86_64",
298             consoles=[{"type": "tcp", "port": 22223, "protocol": "telnet"}],
299         )
300         root = ET.fromstring(xml_data)
301         self.assertEqual(root.find("devices/console").attrib["type"], "tcp")
302         self.assertEqual(root.find("devices/console/source").attrib["service"], "22223")
303         self.assertEqual(root.find("devices/console/protocol").attrib["type"], "telnet")
304     def test_gen_xml_for_telnet_console_unspecified_port(self):
305         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
306         nicp = virt._nic_profile("default", "kvm")
307         xml_data = virt._gen_xml(
308             self.mock_conn,
309             "hello",
310             1,
311             512,
312             diskp,
313             nicp,
314             "kvm",
315             "hvm",
316             "x86_64",
317             consoles=[{"type": "tcp"}],
318         )
319         root = ET.fromstring(xml_data)
320         self.assertEqual(root.find("devices/console").attrib["type"], "tcp")
321         self.assertEqual(root.find("devices/console/source").attrib["service"], "23023")
322         self.assertEqual(root.find("devices/console/protocol").attrib["type"], "telnet")
323     def test_gen_xml_for_serial_no_console(self):
324         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
325         nicp = virt._nic_profile("default", "kvm")
326         xml_data = virt._gen_xml(
327             self.mock_conn,
328             "hello",
329             1,
330             512,
331             diskp,
332             nicp,
333             "kvm",
334             "hvm",
335             "x86_64",
336             serials=[{"type": "pty"}],
337             consoles=[],
338         )
339         root = ET.fromstring(xml_data)
340         self.assertEqual(root.find("devices/serial").attrib["type"], "pty")
341         self.assertEqual(root.find("devices/console"), None)
342     def test_gen_xml_for_telnet_no_console(self):
343         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
344         nicp = virt._nic_profile("default", "kvm")
345         xml_data = virt._gen_xml(
346             self.mock_conn,
347             "hello",
348             1,
349             512,
350             diskp,
351             nicp,
352             "kvm",
353             "hvm",
354             "x86_64",
355             serials=[{"type": "tcp", "port": 22223, "protocol": "telnet"}],
356             consoles=[],
357         )
358         root = ET.fromstring(xml_data)
359         self.assertEqual(root.find("devices/serial").attrib["type"], "tcp")
360         self.assertEqual(root.find("devices/console"), None)
361     def test_gen_xml_nographics_default(self):
362         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
363         nicp = virt._nic_profile("default", "kvm")
364         xml_data = virt._gen_xml(
365             self.mock_conn, "hello", 1, 512, diskp, nicp, "kvm", "hvm", "x86_64"
366         )
367         root = ET.fromstring(xml_data)
368         self.assertIsNone(root.find("devices/graphics"))
369     def test_gen_xml_noloader_default(self):
370         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
371         nicp = virt._nic_profile("default", "kvm")
372         xml_data = virt._gen_xml(
373             self.mock_conn, "hello", 1, 512, diskp, nicp, "kvm", "hvm", "x86_64"
374         )
375         root = ET.fromstring(xml_data)
376         self.assertIsNone(root.find("os/loader"))
377     def test_gen_xml_vnc_default(self):
378         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
379         nicp = virt._nic_profile("default", "kvm")
380         xml_data = virt._gen_xml(
381             self.mock_conn,
382             "hello",
383             1,
384             512,
385             diskp,
386             nicp,
387             "kvm",
388             "hvm",
389             "x86_64",
390             graphics={
391                 "type": "vnc",
392                 "port": 1234,
393                 "tlsPort": 5678,
394                 "listen": {"type": "address", "address": "myhost"},
395             },
396         )
397         root = ET.fromstring(xml_data)
398         self.assertEqual(root.find("devices/graphics").attrib["type"], "vnc")
399         self.assertEqual(root.find("devices/graphics").attrib["autoport"], "no")
400         self.assertEqual(root.find("devices/graphics").attrib["port"], "1234")
401         self.assertFalse("tlsPort" in root.find("devices/graphics").attrib)
402         self.assertEqual(root.find("devices/graphics").attrib["listen"], "myhost")
403         self.assertEqual(root.find("devices/graphics/listen").attrib["type"], "address")
404         self.assertEqual(
405             root.find("devices/graphics/listen").attrib["address"], "myhost"
406         )
407     def test_gen_xml_memory(self):
408         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
409         nicp = virt._nic_profile("default", "kvm")
410         xml_data = virt._gen_xml(
411             self.mock_conn,
412             "hello",
413             1,
414             {
415                 "boot": "512m",
416                 "current": "256m",
417                 "max": "1g",
418                 "hard_limit": "1024",
419                 "soft_limit": "512m",
420                 "swap_hard_limit": "1g",
421                 "min_guarantee": "256m",
422                 "hugepages": [
423                     {"size": "128m"},
424                     {"nodeset": "0", "size": "256m"},
425                     {"nodeset": "1", "size": "512m"},
426                 ],
427                 "nosharepages": True,
428                 "locked": True,
429                 "source": "file",
430                 "access": "shared",
431                 "allocation": "immediate",
432                 "discard": True,
433             },
434             diskp,
435             nicp,
436             "kvm",
437             "hvm",
438             "x86_64",
439         )
440         root = ET.fromstring(xml_data)
441         self.assert_equal_unit(root.find("memory"), 512 * 1024)
442         self.assert_equal_unit(root.find("currentMemory"), 256 * 1024)
443         self.assert_equal_unit(root.find("maxMemory"), 1024 * 1024)
444         self.assertFalse("slots" in root.find("maxMemory").keys())
445         self.assert_equal_unit(root.find("memtune/hard_limit"), 1024 * 1024)
446         self.assert_equal_unit(root.find("memtune/soft_limit"), 512 * 1024)
447         self.assert_equal_unit(root.find("memtune/swap_hard_limit"), 1024 ** 2)
448         self.assert_equal_unit(root.find("memtune/min_guarantee"), 256 * 1024)
449             [
450                 {"nodeset": page.get("nodeset"), "size": page.get("size")}
451                 for page in root<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.findall("memoryBacking/hugepages/page")
452             ],
453             [
454                 {"nodeset": None, "size": str(128 * 1024)},
455                 {"nodeset": "0", "size": str(256 * 1024)},
456                 {"nodeset": "1", "size": str(512 * 1024)},
457             ],
458         )
459         self.assertIsNotNone(root.find("memoryBacking/nosharepages"))
460         self.assertIsNotNone(root.find("memoryBacking/locked"))
461         self.assertIsNotNone(root.find("memoryBacking/discard"))
462         self.assertEqual(root.find("memoryBacking/source").get("type"), "file")
463         self.</b></font>assertEqual(root.find("memoryBacking/access").get("mode"), "shared")
464         self.assertEqual(root.find("memoryBacking/allocation").get("mode"), "immediate")
465     def test_gen_xml_cpu(self):
466         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
467         nicp = virt._nic_profile("default", "kvm")
468         xml_data = virt._gen_xml(
469             self.mock_conn,
470             "hello",
471             {
472                 "maximum": 12,
473                 "placement": "static",
474                 "cpuset": "0-11",
475                 "current": 5,
476                 "mode": "custom",
477                 "match": "minimum",
478                 "check": "full",
479                 "vendor": "Intel",
480                 "model": {
481                     "name": "core2duo",
482                     "fallback": "allow",
483                     "vendor_id": "GenuineIntel",
484                 },
485                 "cache": {"level": 3, "mode": "emulate"},
486                 "features": {"lahf": "optional", "vmx": "require"},
487                 "vcpus": {
488                     0: {"enabled": True, "hotpluggable": True},
489                     1: {"enabled": False},
490                 },
491             },
492             512,
493             diskp,
494             nicp,
495             "kvm",
496             "hvm",
497             "x86_64",
498         )
499         root = ET.fromstring(xml_data)
500         self.assertEqual(root.find("vcpu").get("current"), "5")
501         self.assertEqual(root.find("vcpu").get("placement"), "static")
502         self.assertEqual(root.find("vcpu").get("cpuset"), "0-11")
503         self.assertEqual(root.find("vcpu").text, "12")
504         self.assertEqual(root.find("cpu").get("match"), "minimum")
505         self.assertEqual(root.find("cpu").get("mode"), "custom")
506         self.assertEqual(root.find("cpu").get("check"), "full")
507         self.assertEqual(root.find("cpu/vendor").text, "Intel")
508         self.assertEqual(root.find("cpu/model").text, "core2duo")
509         self.assertEqual(root.find("cpu/model").get("fallback"), "allow")
510         self.assertEqual(root.find("cpu/model").get("vendor_id"), "GenuineIntel")
511         self.assertEqual(root.find("cpu/cache").get("level"), "3")
512         self.assertEqual(root.find("cpu/cache").get("mode"), "emulate")
513         self.assertEqual(
514             {f.get("name"): f.get("policy") for f in root.findall("cpu/feature")},
515             {"lahf": "optional", "vmx": "require"},
516         )
517         self.assertEqual(
518             {
519                 v.get("id"): {
520                     "enabled": v.get("enabled"),
521                     "hotpluggable": v.get("hotpluggable"),
522                 }
523                 for v in root.findall("vcpus/vcpu")
524             },
525             {
526                 "0": {"enabled": "yes", "hotpluggable": "yes"},
527                 "1": {"enabled": "no", "hotpluggable": None},
528             },
529         )
530     def test_gen_xml_cpu_topology(self):
531         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
532         nicp = virt._nic_profile("default", "kvm")
533         xml_data = virt._gen_xml(
534             self.mock_conn,
535             "hello",
536             {"maximum": 1, "topology": {"sockets": 4, "cores": 16, "threads": 2}},
537             512,
538             diskp,
539             nicp,
540             "kvm",
541             "hvm",
542             "x86_64",
543         )
544         root = ET.fromstring(xml_data)
545         self.assertEqual(root.find("cpu/topology").get("sockets"), "4")
546         self.assertEqual(root.find("cpu/topology").get("cores"), "16")
547         self.assertEqual(root.find("cpu/topology").get("threads"), "2")
548     def test_gen_xml_cpu_numa(self):
549         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
550         nicp = virt._nic_profile("default", "kvm")
551         xml_data = virt._gen_xml(
552             self.mock_conn,
553             "hello",
554             {
555                 "maximum": 1,
556                 "numa": {
557                     0: {
558                         "cpus": "0-3",
559                         "memory": "1g",
560                         "discard": True,
561                         "distances": {0: 10, 1: 20},
562                     },
563                     1: {"cpus": "4-7", "memory": "2g", "distances": {0: 20, 1: 10}},
564                 },
565             },
566             512,
567             diskp,
568             nicp,
569             "kvm",
570             "hvm",
571             "x86_64",
572         )
573         root = ET.fromstring(xml_data)
574         cell0 = root.find("cpu/numa/cell[@id='0']")
575         self.assertEqual(cell0.get("cpus"), "0-3")
576         self.assertIsNone(cell0.get("unit"))
577         self.assertEqual(cell0.get("memory"), str(1024 ** 2))
578         self.assertEqual(cell0.get("discard"), "yes")
579         self.assertEqual(
580             {d.get("id"): d.get("value") for d in cell0.findall("distances/sibling")},
581             {"0": "10", "1": "20"},
582         )
583         cell1 = root.find("cpu/numa/cell[@id='1']")
584         self.assertEqual(cell1.get("cpus"), "4-7")
585         self.assertIsNone(cell0.get("unit"))
586         self.assertEqual(cell1.get("memory"), str(2 * 1024 ** 2))
587         self.assertFalse("discard" in cell1.keys())
588         self.assertEqual(
589             {d.get("id"): d.get("value") for d in cell1.findall("distances/sibling")},
590             {"0": "20", "1": "10"},
591         )
592     def test_gen_xml_cputune(self):
593         nicp = virt._nic_profile("default", "kvm")
594         cputune = {
595             <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"shares": 2048,
596             "period": 122000,
597             "quota": -1,
598             "global_period": 1000000,
599             "global_quota": -3,
600             "emulator_period": 1200000,
601             "emulator_quota": -10,
602             "iothread_period": 133000,
603             "iothread_quota": -1,
604             "vcpupin": {0: "1-4,^2", 1: "0,1", 2: "2,3", 3: "0,4"},
605             "emulatorpin": "1-3",
606             "iothreadpin": {1: "5-6", 2: "7-8"},
607             "vcpusched": [
608                 {"scheduler": "fifo", "priority": 1, "vcpus": "0"},
609                 {"scheduler": "fifo", "priority": 2, "vcpus": "1"},
610                 {"scheduler": "idle", "priority": 3, "vcpus": "2"},
611             ],
612             "iothreadsched": [
613                 {"scheduler": "idle"},
614                 {"scheduler": "batch", "iothreads": "5-7", "priority": 1},
615             ],
616             "emulatorsched": {"scheduler": "rr", "priority": 2},
617             "cachetune": {
618                 "0-3": {
619                     0: {"level": 3, "type": "both", "size": 3},
620                     1: {"level": 3, "type": "both", "size": 3},
621                     "monitor": {1: 3, "0-3": 3},
622                 },
623                 "4-5": {"monitor": {4: 3, 5: 2}},
624             },
625             "memorytune": {"0-2": {0: 60}, "3-4": {0</b></font>: 50, 1: 70}},
626         }
627         xml_data = virt._gen_xml(
628             self.mock_conn,
629             "hello",
630             {"maximum": 1, "tuning": cputune, "iothreads": 2},
631             512,
632             diskp,
633             nicp,
634             "kvm",
635             "hvm",
636             "x86_64",
637         )
638         root = ET.fromstring(xml_data)
639         self.assertEqual(root.find("cputune").find("shares").text, "2048")
640         self.assertEqual(root.find("cputune").find("period").text, "122000")
641         self.assertEqual(root.find("cputune").find("quota").text, "-1")
642         self.assertEqual(root.find("cputune").find("global_period").text, "1000000")
643         self.assertEqual(root.find("cputune").find("global_quota").text, "-3")
644         self.assertEqual(root.find("cputune").find("emulator_period").text, "1200000")
645         self.assertEqual(root.find("cputune").find("emulator_quota").text, "-10")
646         self.assertEqual(root.find("cputune").find("iothread_period").text, "133000")
647         self.assertEqual(root.find("cputune").find("iothread_quota").text, "-1")
648         self.assertEqual(
649             root.find("cputune").find("vcpupin[@vcpu='0']").attrib.get("cpuset"),
650             "1-4,^2",
651         )
652         self.assertEqual(
653             root.find("cputune").find("vcpupin[@vcpu='1']").attrib.get("cpuset"),
654             "0,1",
655         )
656         self.assertEqual(
657             root.find("cputune").find("vcpupin[@vcpu='2']").attrib.get("cpuset"),
658             "2,3",
659         )
660         self.assertEqual(
661             root.find("cputune").find("vcpupin[@vcpu='3']").attrib.get("cpuset"),
662             "0,4",
663         )
664         self.assertEqual(
665             root.find("cputune").find("emulatorpin").attrib.get("cpuset"), "1-3"
666         )
667         self.assertEqual(
668             root.find("cputune")
669             .find("iothreadpin[@iothread='1']")
670             .attrib.get("cpuset"),
671             "5-6",
672         )
673         self.assertEqual(
674             root.find("cputune")
675             .find("iothreadpin[@iothread='2']")
676             .attrib.get("cpuset"),
677             "7-8",
678         )
679         self.assertDictEqual(
680             {
681                 s.get("vcpus"): {
682                     "priority": s.get("priority"),
683                 }
684                 for s in root<font color="#5eac10"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.findall("cputune/vcpusched")
685             },
686             {
687                 "0": {"scheduler": "fifo", "priority": "1"},
688                 "1": {"scheduler": "fifo", "priority": "2"},
689                 "2": {"scheduler": "idle", "priority": "3"},
690             },
691         )
692         self.assertDictEqual(
693             {
694                 s.get("iothreads"): {
695                     "scheduler": s.</b></font>get("scheduler"),
696                     "priority": s.get("priority"),
697                 }
698                 for s in root.findall("cputune/iothreadsched")
699             },
700             {
701                 None: {"scheduler": "idle", "priority": None},
702                 "5-7": {"scheduler": "batch", "priority": "1"},
703             },
704         )
705         self.assertEqual(root.find("cputune/emulatorsched").get("scheduler"), "rr")
706         self.assertEqual(root.find("cputune/emulatorsched").get("priority"), "2")
707         self.assertEqual(
708             root.find("./cputune/cachetune[@vcpus='0-3']").attrib.get("vcpus"), "0-3"
709         )
710         self.assertEqual(
711             root.find("./cputune/cachetune[@vcpus='0-3']/cache[@id='0']").attrib.get(
712                 "level"
713             ),
714             "3",
715         )
716         self.assertEqual(
717             root.find("./cputune/cachetune[@vcpus='0-3']/cache[@id='0']").attrib.get(
718                 "type"
719             ),
720             "both",
721         )
722         self.assertEqual(
723             root.find(
724                 "./cputune/cachetune[@vcpus='0-3']/monitor[@vcpus='1']"
725             ).attrib.get("level"),
726             "3",
727         )
728         self.assertNotEqual(
729             root.find("./cputune/cachetune[@vcpus='0-3']/monitor[@vcpus='1']"), None
730         )
731         self.assertNotEqual(
732             root.find("./cputune/cachetune[@vcpus='4-5']").attrib.get("vcpus"), None
733         )
734         self.assertEqual(
735             root.find("./cputune/cachetune[@vcpus='4-5']/cache[@id='0']"), None
736         )
737         self.assertEqual(
738             root.find(
739                 "./cputune/cachetune[@vcpus='4-5']/monitor[@vcpus='4']"
740             ).attrib.get("level"),
741             "3",
742         )
743         self.assertEqual(
744             root.find(
745                 "./cputune/cachetune[@vcpus='4-5']/monitor[@vcpus='5']"
746             ).attrib.get("level"),
747             "2",
748         )
749         self.assertNotEqual(root.find("./cputune/memorytune[@vcpus='0-2']"), None)
750         self.assertEqual(
751             root.find("./cputune/memorytune[@vcpus='0-2']/node[@id='0']").attrib.get(
752                 "bandwidth"
753             ),
754             "60",
755         )
756         self.assertNotEqual(root.find("./cputune/memorytune[@vcpus='3-4']"), None)
757         self.assertEqual(
758             root.find("./cputune/memorytune[@vcpus='3-4']/node[@id='0']").attrib.get(
759                 "bandwidth"
760             ),
761             "50",
762         )
763         self.assertEqual(
764             root.find("./cputune/memorytune[@vcpus='3-4']/node[@id='1']").attrib.get(
765                 "bandwidth"
766             ),
767             "70",
768         )
769         self.assertEqual(root.find("iothreads").text, "2")
770     def test_default_disk_profile_hypervisor_esxi(self):
771         mock = MagicMock(return_value={})
772         with patch.dict(
773             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
774         ):
775             ret = virt._disk_profile(
776                 self.mock_conn, "nonexistent", "vmware", None, "test-vm"
777             )
778             self.assertTrue(len(ret) == 1)
779             found = [disk for disk in ret if disk["name"] == "system"]
780             self.assertTrue(bool(found))
781             system = found[0]
782             self.assertEqual(system["format"], "vmdk")
783             self.assertEqual(system["model"], "scsi")
784             self.assertTrue(int(system["size"]) &gt;= 1)
785     def test_default_disk_profile_hypervisor_kvm(self):
786         mock = MagicMock(side_effect=[{}, "/images/dir"])
787         with patch.dict(
788             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
789         ):
790             ret = virt._disk_profile(
791                 self.mock_conn, "nonexistent", "kvm", None, "test-vm"
792             )
793             self.assertTrue(len(ret) == 1)
794             found = [disk for disk in ret if disk["name"] == "system"]
795             self.assertTrue(bool(found))
796             system = found[0]
797             self.assertEqual(system["format"], "qcow2")
798             self.assertEqual(system["model"], "virtio")
799             self.assertTrue(int(system["size"]) &gt;= 1)
800     def test_default_disk_profile_hypervisor_xen(self):
801         mock = MagicMock(side_effect=[{}, "/images/dir"])
802         with patch.dict(
803             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
804         ):
805             ret = virt._disk_profile(
806                 self.mock_conn, "nonexistent", "xen", None, "test-vm"
807             )
808             self.assertTrue(len(ret) == 1)
809             found = [disk for disk in ret if disk["name"] == "system"]
810             self.assertTrue(bool(found))
811             system = found[0]
812             self.assertEqual(system["format"], "qcow2")
813             self.assertEqual(system["model"], "xen")
814             self.assertTrue(int(system["size"]) &gt;= 1)
815     def test_default_nic_profile_hypervisor_esxi(self):
816         mock = MagicMock(return_value={})
817         with patch.dict(
818             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
819         ):
820             ret = virt._nic_profile("nonexistent", "vmware")
821             self.assertTrue(len(ret) == 1)
822             eth0 = ret[0]
823             self.assertEqual(eth0["name"], "eth0")
824             self.assertEqual(eth0["type"], "bridge")
825             self.assertEqual(eth0["source"], "DEFAULT")
826             self.assertEqual(eth0["model"], "e1000")
827     def test_default_nic_profile_hypervisor_kvm(self):
828         mock = MagicMock(return_value={})
829         with patch.dict(
830             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
831         ):
832             ret = virt._nic_profile("nonexistent", "kvm")
833             self.assertTrue(len(ret) == 1)
834             eth0 = ret[0]
835             self.assertEqual(eth0["name"], "eth0")
836             self.assertEqual(eth0["type"], "bridge")
837             self.assertEqual(eth0["source"], "br0")
838             self.assertEqual(eth0["model"], "virtio")
839     def test_default_nic_profile_hypervisor_xen(self):
840         mock = MagicMock(return_value={})
841         with patch.dict(
842             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
843         ):
844             ret = virt._nic_profile("nonexistent", "xen")
845             self.assertTrue(len(ret) == 1)
846             eth0 = ret[0]
847             self.assertEqual(eth0["name"], "eth0")
848             self.assertEqual(eth0["type"], "bridge")
849             self.assertEqual(eth0["source"], "br0")
850             self.assertFalse(eth0["model"])
851     def test_gen_vol_xml_esx(self):
852         xml_data = virt._gen_vol_xml("vmname/system.vmdk", 8192, format="vmdk")
853         root = ET.fromstring(xml_data)
854         self.assertIsNone(root.get("type"))
855         self.assertEqual(root.find("name").text, "vmname/system.vmdk")
856         self.assertEqual(root.find("capacity").attrib["unit"], "KiB")
857         self.assertEqual(root.find("capacity").text, str(8192 * 1024))
858         self.assertEqual(root.find("allocation").text, str(0))
859         self.assertEqual(root.find("target/format").get("type"), "vmdk")
860         self.assertIsNone(root.find("target/permissions"))
861         self.assertIsNone(root.find("target/nocow"))
862         self.assertIsNone(root.find("backingStore"))
863     def test_gen_vol_xml_file(self):
864         xml_data = virt._gen_vol_xml(
865             "myvm_system.qcow2",
866             8192,
867             format="qcow2",
868             allocation=4096,
869             type="file",
870             permissions={
871                 "mode": "0775",
872                 "owner": "123",
873                 "group": "456",
874                 "label": "sec_label",
875             },
876             backing_store={"path": "/backing/image", "format": "raw"},
877             nocow=True,
878         )
879         root = ET.fromstring(xml_data)
880         self.assertEqual(root.get("type"), "file")
881         self.assertEqual(root.find("name").text, "myvm_system.qcow2")
882         self.assertIsNone(root.find("key"))
883         self.assertIsNone(root.find("target/path"))
884         self.assertEqual(root.find("target/format").get("type"), "qcow2")
885         self.assertEqual(root.find("capacity").attrib["unit"], "KiB")
886         self.assertEqual(root.find("capacity").text, str(8192 * 1024))
887         self.assertEqual(root.find("capacity").attrib["unit"], "KiB")
888         self.assertEqual(root.find("allocation").text, str(4096 * 1024))
889         self.assertEqual(root.find("target/permissions/mode").text, "0775")
890         self.assertEqual(root.find("target/permissions/owner").text, "123")
891         self.assertEqual(root.find("target/permissions/group").text, "456")
892         self.assertEqual(root.find("target/permissions/label").text, "sec_label")
893         self.assertIsNotNone(root.find("target/nocow"))
894         self.assertEqual(root.find("backingStore/path").text, "/backing/image")
895         self.assertEqual(root.find("backingStore/format").get("type"), "raw")
896     def test_gen_xml_for_kvm_default_profile(self):
897         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
898         nicp = virt._nic_profile("default", "kvm")
899         xml_data = virt._gen_xml(
900             self.mock_conn,
901             "hello",
902             1,
903             512,
904             diskp,
905             nicp,
906             "kvm",
907             "hvm",
908             "x86_64",
909         )
910         root = ET.fromstring(xml_data)
911         self.assertEqual(root.attrib["type"], "kvm")
912         self.assertEqual(root.find("vcpu").text, "1")
913         self.assertEqual(root.find("memory").text, str(512 * 1024))
914         self.assertEqual(root.find("memory").attrib["unit"], "KiB")
915         disks = root.findall(".//disk")
916         self.assertEqual(len(disks), 1)
917         disk = disks[0]
918         root_dir = salt.config.DEFAULT_MINION_OPTS.get("root_dir")
919         self.assertTrue(disk.find("source").attrib["file"].startswith(root_dir))
920         self.assertTrue("hello_system" in disk.find("source").attrib["file"])
921         self.assertEqual(disk.find("target").attrib["dev"], "vda")
922         self.assertEqual(disk.find("target").attrib["bus"], "virtio")
923         self.assertEqual(disk.find("driver").attrib["name"], "qemu")
924         self.assertEqual(disk.find("driver").attrib["type"], "qcow2")
925         interfaces = root.findall(".//interface")
926         self.assertEqual(len(interfaces), 1)
927         iface = interfaces[0]
928         self.assertEqual(iface.attrib["type"], "bridge")
929         self.assertEqual(iface.find("source").attrib["bridge"], "br0")
930         self.assertEqual(iface.find("model").attrib["type"], "virtio")
931     def test_gen_xml_for_esxi_default_profile(self):
932         diskp = virt._disk_profile(self.mock_conn, "default", "vmware", [], "hello")
933         nicp = virt._nic_profile("default", "vmware")
934         xml_data = virt._gen_xml(
935             self.mock_conn,
936             "hello",
937             1,
938             512,
939             diskp,
940             nicp,
941             "vmware",
942             "hvm",
943             "x86_64",
944         )
945         root = ET.fromstring(xml_data)
946         self.assertEqual(root.attrib["type"], "vmware")
947         self.assertEqual(root.find("vcpu").text, "1")
948         self.assertEqual(root.find("memory").text, str(512 * 1024))
949         self.assertEqual(root.find("memory").attrib["unit"], "KiB")
950         disks = root.findall(".//disk")
951         self.assertEqual(len(disks), 1)
952         disk = disks[0]
953         self.assertTrue("[0]" in disk.find("source").attrib["file"])
954         self.assertTrue("hello_system" in disk.find("source").attrib["file"])
955         self.assertEqual(disk.find("target").attrib["dev"], "sda")
956         self.assertEqual(disk.find("target").attrib["bus"], "scsi")
957         self.assertEqual(disk.find("address").attrib["unit"], "0")
958         interfaces = root.findall(".//interface")
959         self.assertEqual(len(interfaces), 1)
960         iface = interfaces[0]
961         self.assertEqual(iface.attrib["type"], "bridge")
962         self.assertEqual(iface.find("source").attrib["bridge"], "DEFAULT")
963         self.assertEqual(iface.find("model").attrib["type"], "e1000")
964     def test_gen_xml_for_esxi_custom_profile(self):
965         disks = {
966             "noeffect": [
967                 {"first": {"size": 8192, "pool": "datastore1"}},
968                 {"second": {"size": 4096, "pool": "datastore2"}},
969             ]
970         }
971         nics = {
972             "noeffect": [
973                 {"name": "eth1", "source": "ONENET"},
974                 {"name": "eth2", "source": "TWONET"},
975             ]
976         }
977         with patch.dict(
978             virt.__salt__,  # pylint: disable=no-member
979             {"config.get": MagicMock(side_effect=[disks, nics])},
980         ):
981             diskp = virt._disk_profile(
982                 self.mock_conn, "noeffect", "vmware", [], "hello"
983             )
984             nicp = virt._nic_profile("noeffect", "vmware")
985             xml_data = virt._gen_xml(
986                 self.mock_conn,
987                 "hello",
988                 1,
989                 512,
990                 diskp,
991                 nicp,
992                 "vmware",
993                 "hvm",
994                 "x86_64",
995             )
996             root = ET.fromstring(xml_data)
997             self.assertEqual(root.attrib["type"], "vmware")
998             self.assertEqual(root.find("vcpu").text, "1")
999             self.assertEqual(root.find("memory").text, str(512 * 1024))
1000             self.assertEqual(root.find("memory").attrib["unit"], "KiB")
1001             self.assertTrue(len(root.findall(".//disk")) == 2)
1002             self.assertTrue(len(root.findall(".//interface")) == 2)
1003     def test_gen_xml_for_kvm_custom_profile(self):
1004         disks = {
1005             "noeffect": [
1006                 {"first": {"size": 8192, "pool": "/var/lib/images"}},
1007                 {"second": {"size": 4096, "pool": "/var/lib/images"}},
1008             ]
1009         }
1010         nics = {
1011             "noeffect": [
1012                 {"name": "eth1", "source": "b2"},
1013                 {"name": "eth2", "source": "b2"},
1014             ]
1015         }
1016         with patch.dict(
1017             virt.__salt__,  # pylint: disable=no-member
1018             {"config.get": MagicMock(side_effect=[disks, nics])},
1019         ):
1020             diskp = virt._disk_profile(self.mock_conn, "noeffect", "kvm", [], "hello")
1021             nicp = virt._nic_profile("noeffect", "kvm")
1022             xml_data = virt._gen_xml(
1023                 self.mock_conn,
1024                 "hello",
1025                 1,
1026                 512,
1027                 diskp,
1028                 nicp,
1029                 "kvm",
1030                 "hvm",
1031                 "x86_64",
1032             )
1033             root = ET.fromstring(xml_data)
1034             self.assertEqual(root.attrib["type"], "kvm")
1035             self.assertEqual(root.find("vcpu").text, "1")
1036             self.assertEqual(root.find("memory").text, str(512 * 1024))
1037             self.assertEqual(root.find("memory").attrib["unit"], "KiB")
1038             disks = root.findall(".//disk")
1039             self.assertTrue(len(disks) == 2)
1040             self.assertEqual(disks[0].find("target").get("dev"), "vda")
1041             self.assertEqual(disks[1].find("target").get("dev"), "vdb")
1042             self.assertTrue(len(root.findall(".//interface")) == 2)
1043     def test_disk_profile_kvm_disk_pool(self):
1044         disks = {
1045             "noeffect": [
1046                 {"first": {"size": 8192, "pool": "mypool"}},
1047                 {"second": {"size": 4096}},
1048             ]
1049         }
1050         with patch.dict(
1051             virt.__salt__,
1052             {
1053                 "config.get": MagicMock(
1054                     side_effect=[
1055                         disks,
1056                         os.path.join(salt.syspaths.ROOT_DIR, "default", "path"),
1057                     ]
1058                 )
1059             },
1060         ):
1061             diskp = virt._disk_profile(self.mock_conn, "noeffect", "kvm", [], "hello")
1062             pools_path = (
1063                 os.path.join(salt.syspaths.ROOT_DIR, "pools", "mypool") + os.sep
1064             )
1065             default_path = (
1066                 os.path.join(salt.syspaths.ROOT_DIR, "default", "path") + os.sep
1067             )
1068             self.assertEqual(len(diskp), 2)
1069             self.assertTrue(diskp[1]["source_file"].startswith(default_path))
1070     def test_disk_profile_kvm_disk_external_image(self):
1071         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
1072             diskp = virt._disk_profile(
1073                 self.mock_conn,
1074                 None,
1075                 "kvm",
1076                 [{"name": "mydisk", "source_file": "/path/to/my/image.qcow2"}],
1077                 "hello",
1078             )
1079             self.assertEqual(len(diskp), 1)
1080             self.assertEqual(diskp[0]["source_file"], "/path/to/my/image.qcow2")
1081     def test_disk_profile_cdrom_default(self):
1082         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
1083             diskp = virt._disk_profile(
1084                 self.mock_conn,
1085                 None,
1086                 "kvm",
1087                 [
1088                     {
1089                         "name": "mydisk",
1090                         "device": "cdrom",
1091                         "source_file": "/path/to/my.iso",
1092                     }
1093                 ],
1094                 "hello",
1095             )
1096             self.assertEqual(len(diskp), 1)
1097             self.assertEqual(diskp[0]["model"], "ide")
1098             self.assertEqual(diskp[0]["format"], "raw")
1099     def test_disk_profile_pool_disk_type(self):
1100         self.mock_conn.listStoragePools.return_value = ["test-vdb"]
1101         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = """
1102             &lt;pool type="disk"&gt;
1103               &lt;name&gt;test-vdb&lt;/name&gt;
1104               &lt;source&gt;
1105                 &lt;device path='/dev/vdb'/&gt;
1106               &lt;/source&gt;
1107               &lt;target&gt;
1108                 &lt;path&gt;/dev&lt;/path&gt;
1109               &lt;/target&gt;
1110             &lt;/pool&gt;
1111         """
1112             []
1113         )
1114         diskp = virt<font color="#f62817"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>._disk_profile(
1115             self.mock_conn,
1116             None,
1117             "kvm",
1118             [{"name": "mydisk", "pool": "test-vdb"}],
1119             "hello",
1120         )
1121         self.assertEqual(diskp[0]["filename"], "vdb1")
1122         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.</b></font>return_value = [
1123             "vdb1",
1124         ]
1125         diskp = virt._disk_profile(
1126             self<font color="#736aff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.mock_conn,
1127             None,
1128             "kvm",
1129             [{"name": "mydisk", "pool": "test-vdb"}],
1130             "hello",
1131         )
1132         self.assertEqual(diskp[0]["filename"], "vdb3")
1133         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.</b></font>return_value = [
1134             "vdb1",
1135             "vdb3",
1136         ]
1137         diskp = virt._disk_profile(
1138             self.mock_conn,
1139             None,
1140             "kvm",
1141             [{"name": "mydisk", "pool": "test-vdb"}],
1142             "hello",
1143         )
1144         self.assertEqual(diskp[0]["filename"], "vdb2")
1145         diskp = virt._disk_profile(
1146             self.mock_conn,
1147             None,
1148             "kvm",
1149             [{"name": "mydisk", "pool": "test-vdb", "source_file": "vdb1"}],
1150             "hello",
1151         )
1152         self.assertEqual(diskp[0]["filename"], "vdb1")
1153     def test_gen_xml_volume(self):
1154         self.mock_conn.listStoragePools.return_value = ["default"]
1155         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
1156             "&lt;pool type='dir'/&gt;"
1157         )
1158         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = [
1159             "myvolume"
1160         ]
1161         diskp = virt._disk_profile(
1162             self.mock_conn,
1163             None,
1164             "kvm",
1165             [
1166                 {"name": "system", "pool": "default"},
1167                 {"name": "data", "pool": "default", "source_file": "myvolume"},
1168             ],
1169             "hello",
1170         )
1171         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
1172             "&lt;pool type='dir'/&gt;"
1173         )
1174         nicp = virt._nic_profile(None, "kvm")
1175         xml_data = virt._gen_xml(
1176             self.mock_conn,
1177             "hello",
1178             1,
1179             512,
1180             diskp,
1181             nicp,
1182             "kvm",
1183             "hvm",
1184             "x86_64",
1185         )
1186         root = ET.fromstring(xml_data)
1187         disk = root.findall(".//disk")[0]
1188         self.assertEqual(disk.attrib["device"], "disk")
1189         self.assertEqual(disk.attrib["type"], "volume")
1190         source = disk.find("source")
1191         self.assertEqual("default", source.attrib["pool"])
1192         self.assertEqual("hello_system", source.attrib["volume"])
1193         self.assertEqual("myvolume", root.find(".//disk[2]/source").get("volume"))
1194         self.mock_conn.listStoragePools.return_value = ["test-rbd"]
1195         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = """
1196             &lt;pool type='rbd'&gt;
1197               &lt;name&gt;test-rbd&lt;/name&gt;
1198               &lt;uuid&gt;ede33e0a-9df0-479f-8afd-55085a01b244&lt;/uuid&gt;
1199               &lt;capacity unit='bytes'&gt;526133493760&lt;/capacity&gt;
1200               &lt;allocation unit='bytes'&gt;589928&lt;/allocation&gt;
1201               &lt;available unit='bytes'&gt;515081306112&lt;/available&gt;
1202               &lt;source&gt;
1203                 &lt;host name='ses2.tf.local'/&gt;
1204                 &lt;host name='ses3.tf.local' port='1234'/&gt;
1205                 &lt;name&gt;libvirt-pool&lt;/name&gt;
1206                 &lt;auth type='ceph' username='libvirt'&gt;
1207                   &lt;secret usage='pool_test-rbd'/&gt;
1208                 &lt;/auth&gt;
1209               &lt;/source&gt;
1210             &lt;/pool&gt;
1211         """
1212         self.mock_conn.getStoragePoolCapabilities.return_value = """
1213             &lt;storagepoolCapabilities&gt;
1214               &lt;pool type='rbd' supported='yes'&gt;
1215                 &lt;volOptions&gt;
1216                   &lt;defaultFormat type='raw'/&gt;
1217                   &lt;enum name='targetFormatType'&gt;
1218                   &lt;/enum&gt;
1219                 &lt;/volOptions&gt;
1220               &lt;/pool&gt;
1221             &lt;/storagepoolCapabilities&gt;
1222         """
1223         diskp = virt._disk_profile(
1224             self.mock_conn,
1225             None,
1226             "kvm",
1227             [{"name": "system", "pool": "test-rbd"}],
1228             "test-vm",
1229         )
1230         xml_data = virt._gen_xml(
1231             self.mock_conn,
1232             "hello",
1233             1,
1234             512,
1235             diskp,
1236             nicp,
1237             "kvm",
1238             "hvm",
1239             "x86_64",
1240         )
1241         root = ET.fromstring(xml_data)
1242         self.assertDictEqual(
1243             {
1244                 <font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"type": "network",
1245                 "device": "disk",
1246                 "source": {
1247                     "protocol": "rbd",
1248                     "name": "libvirt-pool/test-vm_system",
1249                     "host": [
1250                         {"name": "ses2.tf.local"},
1251                         {"name": "ses3.tf.local", "port": "1234"},
1252                     ],
1253                     "auth": {
1254                         "username": "libvirt",
1255                         "secret": {"type": "ceph", "usage": "pool_test-rbd"},
1256                     },
1257                 },
1258                 "target": {"dev": "vda", "bus": "virtio"},
1259                 "driver": {
1260                     "name": "qemu",
1261                     "type": "raw",
1262                     "cache": "none",
1263                     "io": "native",
1264                 },
1265             },
1266             salt.utils.xmlutil.to_dict(disk, True),
1267         )
1268         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.</b></font>return_value = """
1269             &lt;pool type='rbd'&gt;
1270               &lt;name&gt;test-rbd&lt;/name&gt;
1271               &lt;uuid&gt;ede33e0a-9df0-479f-8afd-55085a01b244&lt;/uuid&gt;
1272               &lt;capacity unit='bytes'&gt;526133493760&lt;/capacity&gt;
1273               &lt;allocation unit='bytes'&gt;589928&lt;/allocation&gt;
1274               &lt;available unit='bytes'&gt;515081306112&lt;/available&gt;
1275               &lt;source&gt;
1276                 &lt;host name='ses2.tf.local'/&gt;
1277                 &lt;host name='ses3.tf.local' port='1234'/&gt;
1278                 &lt;name&gt;libvirt-pool&lt;/name&gt;
1279                 &lt;auth type='ceph' username='libvirt'&gt;
1280                   &lt;secret uuid='some-uuid'/&gt;
1281                 &lt;/auth&gt;
1282               &lt;/source&gt;
1283             &lt;/pool&gt;
1284         """
1285         self.mock_conn.secretLookupByUUIDString.return_value.usageID.return_value = (
1286             "pool_test-rbd"
1287         )
1288         diskp = virt._disk_profile(
1289             self.mock_conn,
1290             None,
1291             "kvm",
1292             [{"name": "system", "pool": "test-rbd"}],
1293             "test-vm",
1294         )
1295         xml_data = virt._gen_xml(
1296             self.mock_conn,
1297             "hello",
1298             1,
1299             512,
1300             diskp,
1301             nicp,
1302             "kvm",
1303             "hvm",
1304             "x86_64",
1305         )
1306         root = ET.fromstring(xml_data)
1307         self.assertDictEqual(
1308             {
1309                 "username": "libvirt",
1310                 "secret": {"type": "ceph", "usage": "pool_test-rbd"},
1311             },
1312             salt.utils.xmlutil.to_dict(root.find(".//disk/source/auth"), True),
1313         )
1314         self.mock_conn.secretLookupByUUIDString.assert_called_once_with("some-uuid")
1315         self.mock_conn.getStoragePoolCapabilities.return_value = """
1316             &lt;storagepoolCapabilities&gt;
1317               &lt;pool type='disk' supported='yes'&gt;
1318                 &lt;volOptions&gt;
1319                   &lt;defaultFormat type='none'/&gt;
1320                   &lt;enum name='targetFormatType'&gt;
1321                     &lt;value&gt;none&lt;/value&gt;
1322                     &lt;value&gt;linux&lt;/value&gt;
1323                     &lt;value&gt;fat16&lt;/value&gt;
1324                   &lt;/enum&gt;
1325                 &lt;/volOptions&gt;
1326               &lt;/pool&gt;
1327             &lt;/storagepoolCapabilities&gt;
1328         """
1329         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = """
1330             &lt;pool type='disk'&gt;
1331               &lt;name&gt;test-vdb&lt;/name&gt;
1332               &lt;source&gt;
1333                 &lt;device path='/dev/vdb'/&gt;
1334                 &lt;format type='gpt'/&gt;
1335               &lt;/source&gt;
1336             &lt;/pool&gt;
1337         """
1338         self.mock_conn.listStoragePools.return_value = ["test-vdb"]
1339         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = [
1340             "vdb1",
1341         ]
1342         diskp = virt._disk_profile(
1343             self.mock_conn,
1344             None,
1345             "kvm",
1346             [{"name": "system", "pool": "test-vdb"}],
1347             "test-vm",
1348         )
1349         xml_data = virt._gen_xml(
1350             self.mock_conn,
1351             "hello",
1352             1,
1353             512,
1354             diskp,
1355             nicp,
1356             "kvm",
1357             "hvm",
1358             "x86_64",
1359         )
1360         root = ET.fromstring(xml_data)
1361         disk = root.findall(".//disk")[0]
1362         self.assertEqual(disk.attrib["type"], "volume")
1363         source = disk.find("source")
1364         self.assertEqual("test-vdb", source.attrib["pool"])
1365         self.assertEqual("vdb2", source.attrib["volume"])
1366         self.assertEqual("raw", disk.find("driver").get("type"))
1367     def test_get_xml_volume_xen_dir(self):
1368         self.mock_conn.listStoragePools.return_value = ["default"]
1369         pool_mock = MagicMock()
1370         pool_mock.XMLDesc.return_value = (
1371             "&lt;pool type='dir'&gt;&lt;target&gt;&lt;path&gt;/path/to/images&lt;/path&gt;&lt;/target&gt;&lt;/pool&gt;"
1372         )
1373         volume_xml = "&lt;volume&gt;&lt;target&gt;&lt;path&gt;/path/to/images/hello_system&lt;/path&gt;&lt;/target&gt;&lt;/volume&gt;"
1374         pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = volume_xml
1375         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
1376         diskp = virt._disk_profile(
1377             self.mock_conn,
1378             None,
1379             "xen",
1380             [{"name": "system", "pool": "default"}],
1381             "hello",
1382         )
1383         xml_data = virt._gen_xml(
1384             self.mock_conn,
1385             "hello",
1386             1,
1387             512,
1388             diskp,
1389             [],
1390             "xen",
1391             "hvm",
1392             "x86_64",
1393         )
1394         root = ET.fromstring(xml_data)
1395         disk = root.findall(".//disk")[0]
1396         self.assertEqual(disk.attrib["type"], "file")
1397         self.assertEqual(
1398             "/path/to/images/hello_system", disk.find("source").attrib["file"]
1399         )
1400     def test_get_xml_volume_xen_block(self):
1401         self.mock_conn.listStoragePools.return_value = ["default"]
1402         pool_mock = MagicMock()
1403         pool_mock.listVolumes.return_value = ["vol01"]
1404         volume_xml = "&lt;volume&gt;&lt;target&gt;&lt;path&gt;/dev/to/vol01&lt;/path&gt;&lt;/target&gt;&lt;/volume&gt;"
1405         pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = volume_xml
1406         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
1407         for pool_type in ["logical", "disk", "iscsi", "scsi"]:
1408             pool_mock.XMLDesc.return_value = "&lt;pool type='{}'&gt;&lt;source&gt;&lt;device path='/dev/sda'/&gt;&lt;/source&gt;&lt;/pool&gt;".format(
1409                 pool_type
1410             )
1411             diskp = virt._disk_profile(
1412                 self.mock_conn,
1413                 None,
1414                 "xen",
1415                 [{"name": "system", "pool": "default", "source_file": "vol01"}],
1416                 "hello",
1417             )
1418             xml_data = virt._gen_xml(
1419                 self.mock_conn,
1420                 "hello",
1421                 1,
1422                 512,
1423                 diskp,
1424                 [],
1425                 "xen",
1426                 "hvm",
1427                 "x86_64",
1428             )
1429             root = ET.fromstring(xml_data)
1430             disk = root.findall(".//disk")[0]
1431             self.assertEqual(disk.attrib["type"], "block")
1432             self.assertEqual("/dev/to/vol01", disk.find("source").attrib["dev"])
1433     def test_gen_xml_cdrom(self):
1434         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
1435             "&lt;pool type='dir'/&gt;"
1436         )
1437         diskp = virt._disk_profile(
1438             self.mock_conn,
1439             None,
1440             "kvm",
1441             [
1442                 {"name": "system", "pool": "default"},
1443                 {
1444                     "name": "tested",
1445                     "device": "cdrom",
1446                     "source_file": None,
1447                     "model": "ide",
1448                 },
1449                 {
1450                     "name": "remote",
1451                     "device": "cdrom",
1452                     "source_file": (
1453                         "http://myhost:8080/url/to/image?query=foo&amp;filter=bar"
1454                     ),
1455                     "model": "ide",
1456                 },
1457             ],
1458             "hello",
1459         )
1460         nicp = virt._nic_profile(None, "kvm")
1461         xml_data = virt._gen_xml(
1462             self.mock_conn,
1463             "hello",
1464             1,
1465             512,
1466             diskp,
1467             nicp,
1468             "kvm",
1469             "hvm",
1470             "x86_64",
1471         )
1472         root = ET.fromstring(xml_data)
1473         disk = root.findall(".//disk")[1]
1474         self.assertEqual(disk.get("type"), "file")
1475         self.assertEqual(disk.attrib["device"], "cdrom")
1476         self.assertIsNone(disk.find("source"))
1477         self.assertEqual(disk.find("target").get("dev"), "hda")
1478         disk = root.findall(".//disk")[2]
1479         self.assertEqual(disk.get("type"), "network")
1480         self<font color="#79764d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertEqual(disk.attrib["device"], "cdrom")
1481         self.assertEqual(
1482             {
1483                 "protocol": "http",
1484                 "name": "/url/to/image",
1485                 "query": "query=foo&amp;filter=bar",
1486                 "host": {"name": "myhost", "port": "8080"},
1487             },
1488             salt.utils.xmlutil.to_dict(disk.</b></font>find("source"), True),
1489         )
1490     def test_controller_for_esxi(self):
1491         diskp = virt._disk_profile(self.mock_conn, "default", "vmware", [], "hello")
1492         nicp = virt._nic_profile("default", "vmware")
1493         xml_data = virt._gen_xml(
1494             self.mock_conn,
1495             "hello",
1496             1,
1497             512,
1498             diskp,
1499             nicp,
1500             "vmware",
1501             "hvm",
1502             "x86_64",
1503         )
1504         root = ET.fromstring(xml_data)
1505         controllers = root.findall(".//devices/controller")
1506         self.assertTrue(len(controllers) == 1)
1507         controller = controllers[0]
1508         self.assertEqual(controller.attrib["model"], "lsilogic")
1509     def test_controller_for_kvm(self):
1510         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
1511         nicp = virt._nic_profile("default", "kvm")
1512         xml_data = virt._gen_xml(
1513             self.mock_conn,
1514             "hello",
1515             1,
1516             512,
1517             diskp,
1518             nicp,
1519             "kvm",
1520             "hvm",
1521             "x86_64",
1522         )
1523         root = ET.fromstring(xml_data)
1524         controllers = root.findall(".//devices/controller")
1525         self.assertTrue(len(controllers) == 0)
1526     def test_diff_disks(self):
1527         old_disks = ET.fromstring(
1528         ).findall("disk")
1529         new_disks = ET.fromstring(
1530         ).findall("disk")
1531         ret = virt._diff_disk_lists(old_disks, new_disks)
1532         self.assertEqual(
1533             [
1534                 disk.find("source").get("file")
1535                 if disk.find("source") is not None
1536                 else None
1537                 for disk in ret["unchanged"]
1538             ],
1539             [],
1540         )
1541         self.assertEqual(
1542             [
1543                 disk.find("source").get("file")
1544                 if disk.find("source") is not None
1545                 else None
1546                 for disk in ret["new"]
1547             ],
1548             ["/path/to/img3.qcow2", "/path/to/img0.qcow2", "/path/to/img4.qcow2", None],
1549         )
1550         self.assertEqual(
1551             [disk.find("target").get("dev") for disk in ret["sorted"]],
1552             ["vda", "vdb", "vdc", "hda"],
1553         )
1554         self.assertEqual(
1555             [
1556                 disk.find("source").get("file")
1557                 if disk.find("source") is not None
1558                 else None
1559                 for disk in ret["sorted"]
1560             ],
1561             ["/path/to/img3.qcow2", "/path/to/img0.qcow2", "/path/to/img4.qcow2", None],
1562         )
1563         self.assertEqual(ret["new"][1].find("target").get("bus"), "virtio")
1564         self.assertEqual(
1565             [
1566                 disk.find("source").get("file")
1567                 if disk.find("source") is not None
1568                 else None
1569                 for disk in ret["deleted"]
1570             ],
1571             [
1572                 "/path/to/img0.qcow2",
1573                 "/path/to/img1.qcow2",
1574                 "/path/to/img2.qcow2",
1575                 "/path/to/img4.qcow2",
1576                 None,
1577             ],
1578         )
1579     def test_init(self):
1580         xml = """
1581 &lt;capabilities&gt;
1582   &lt;host&gt;
1583     &lt;uuid&gt;44454c4c-3400-105a-8033-b3c04f4b344a&lt;/uuid&gt;
1584     &lt;cpu&gt;
1585       &lt;arch&gt;x86_64&lt;/arch&gt;
1586       &lt;model&gt;Nehalem&lt;/model&gt;
1587       &lt;vendor&gt;Intel&lt;/vendor&gt;
1588       &lt;microcode version='25'/&gt;
1589       &lt;topology sockets='1' cores='4' threads='2'/&gt;
1590       &lt;feature name='vme'/&gt;
1591       &lt;feature name='ds'/&gt;
1592       &lt;feature name='acpi'/&gt;
1593       &lt;pages unit='KiB' size='4'/&gt;
1594       &lt;pages unit='KiB' size='2048'/&gt;
1595     &lt;/cpu&gt;
1596     &lt;power_management&gt;
1597       &lt;suspend_mem/&gt;
1598       &lt;suspend_disk/&gt;
1599       &lt;suspend_hybrid/&gt;
1600     &lt;/power_management&gt;
1601     &lt;migration_features&gt;
1602       &lt;live/&gt;
1603       &lt;uri_transports&gt;
1604         &lt;uri_transport&gt;tcp&lt;/uri_transport&gt;
1605         &lt;uri_transport&gt;rdma&lt;/uri_transport&gt;
1606       &lt;/uri_transports&gt;
1607     &lt;/migration_features&gt;
1608     &lt;topology&gt;
1609       &lt;cells num='1'&gt;
1610         &lt;cell id='0'&gt;
1611           &lt;memory unit='KiB'&gt;12367120&lt;/memory&gt;
1612           &lt;pages unit='KiB' size='4'&gt;3091780&lt;/pages&gt;
1613           &lt;pages unit='KiB' size='2048'&gt;0&lt;/pages&gt;
1614           &lt;distances&gt;
1615             &lt;sibling id='0' value='10'/&gt;
1616           &lt;/distances&gt;
1617           &lt;cpus num='8'&gt;
1618             &lt;cpu id='0' socket_id='0' core_id='0' siblings='0,4'/&gt;
1619             &lt;cpu id='1' socket_id='0' core_id='1' siblings='1,5'/&gt;
1620             &lt;cpu id='2' socket_id='0' core_id='2' siblings='2,6'/&gt;
1621             &lt;cpu id='3' socket_id='0' core_id='3' siblings='3,7'/&gt;
1622             &lt;cpu id='4' socket_id='0' core_id='0' siblings='0,4'/&gt;
1623             &lt;cpu id='5' socket_id='0' core_id='1' siblings='1,5'/&gt;
1624             &lt;cpu id='6' socket_id='0' core_id='2' siblings='2,6'/&gt;
1625             &lt;cpu id='7' socket_id='0' core_id='3' siblings='3,7'/&gt;
1626           &lt;/cpus&gt;
1627         &lt;/cell&gt;
1628       &lt;/cells&gt;
1629     &lt;/topology&gt;
1630     &lt;cache&gt;
1631       &lt;bank id='0' level='3' type='both' size='8' unit='MiB' cpus='0-7'/&gt;
1632     &lt;/cache&gt;
1633     &lt;secmodel&gt;
1634       &lt;model&gt;apparmor&lt;/model&gt;
1635       &lt;doi&gt;0&lt;/doi&gt;
1636     &lt;/secmodel&gt;
1637     &lt;secmodel&gt;
1638       &lt;model&gt;dac&lt;/model&gt;
1639       &lt;doi&gt;0&lt;/doi&gt;
1640       &lt;baselabel type='kvm'&gt;+487:+486&lt;/baselabel&gt;
1641       &lt;baselabel type='qemu'&gt;+487:+486&lt;/baselabel&gt;
1642     &lt;/secmodel&gt;
1643   &lt;/host&gt;
1644   &lt;guest&gt;
1645     &lt;os_type&gt;hvm&lt;/os_type&gt;
1646     &lt;arch name='i686'&gt;
1647       &lt;wordsize&gt;32&lt;/wordsize&gt;
1648       &lt;emulator&gt;/usr/bin/qemu-system-i386&lt;/emulator&gt;
1649       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
1650       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
1651       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
1652       &lt;domain type='qemu'/&gt;
1653       &lt;domain type='kvm'&gt;
1654         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
1655         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
1656         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
1657         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
1658       &lt;/domain&gt;
1659     &lt;/arch&gt;
1660     &lt;features&gt;
1661       &lt;cpuselection/&gt;
1662       &lt;deviceboot/&gt;
1663       &lt;disksnapshot default='on' toggle='no'/&gt;
1664       &lt;acpi default='on' toggle='yes'/&gt;
1665       &lt;apic default='on' toggle='no'/&gt;
1666       &lt;pae/&gt;
1667       &lt;nonpae/&gt;
1668     &lt;/features&gt;
1669   &lt;/guest&gt;
1670   &lt;guest&gt;
1671     &lt;os_type&gt;hvm&lt;/os_type&gt;
1672     &lt;arch name='x86_64'&gt;
1673       &lt;wordsize&gt;64&lt;/wordsize&gt;
1674       &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
1675       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
1676       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
1677       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
1678       &lt;domain type='qemu'/&gt;
1679       &lt;domain type='kvm'&gt;
1680         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
1681         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
1682         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
1683         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
1684       &lt;/domain&gt;
1685     &lt;/arch&gt;
1686     &lt;features&gt;
1687       &lt;cpuselection/&gt;
1688       &lt;deviceboot/&gt;
1689       &lt;disksnapshot default='on' toggle='no'/&gt;
1690       &lt;acpi default='on' toggle='yes'/&gt;
1691       &lt;apic default='on' toggle='no'/&gt;
1692     &lt;/features&gt;
1693   &lt;/guest&gt;
1694 &lt;/capabilities&gt;
1695         """
1696         self.mock_conn.getCapabilities.return_value = xml  # pylint: disable=no-member
1697         root_dir = os.path.join(salt.syspaths.ROOT_DIR, "srv", "salt-images")
1698         defineMock = MagicMock(return_value=1)
1699         self.mock_conn.defineXML = defineMock
1700         mock_chmod = MagicMock()
1701         mock_run = MagicMock()
1702         with patch.dict(
1703             os.__dict__, {"chmod": mock_chmod, "makedirs": MagicMock()}
1704         ):  # pylint: disable=no-member
1705             with patch.dict(
1706                 virt.__salt__, {"cmd.run": mock_run}
1707             ):  # pylint: disable=no-member
1708                 virt.init(
1709                     "test vm", 2, 1234, nic=None, disk=None, seed=False, start=False
1710                 )
1711                 definition = defineMock.call_args_list[0][0][0]
1712                 self.assertFalse("&lt;interface" in definition)
1713                 self.assertFalse("&lt;disk" in definition)
1714                 defineMock.reset_mock()
1715                 mock_run.reset_mock()
1716                 boot = {
1717                     "kernel": "/root/f8-i386-vmlinuz",
1718                     "initrd": "/root/f8-i386-initrd",
1719                     "cmdline": "console=ttyS0 ks=http://example.com/f8-i386/os/",
1720                 }
1721                 retval = virt.init(
1722                     "test vm boot params",
1723                     2,
1724                     1234,
1725                     nic=None,
1726                     disk=None,
1727                     seed=False,
1728                     start=False,
1729                     boot=boot,
1730                 )
1731                 definition = defineMock.call_args_list[0][0][0]
1732                 self.assertEqual("&lt;kernel" in definition, True)
1733                 self.assertEqual("&lt;initrd" in definition, True)
1734                 self.assertEqual("&lt;cmdline" in definition, True)
1735                 self.assertEqual(retval, True)
1736                 mock_response = MagicMock()
1737                 mock_response.read = MagicMock(return_value="filecontent")
1738                 cache_dir = tempfile.mkdtemp()
1739                 with patch.dict(virt.__dict__, {"CACHE_DIR": cache_dir}):
1740                     with patch(
1741                         "urllib.request.urlopen",
1742                         MagicMock(return_value=mock_response),
1743                     ):
1744                         with patch(
1745                             "salt.utils.files.fopen", return_value=mock_response
1746                         ):
1747                             defineMock.reset_mock()
1748                             mock_run.reset_mock()
1749                             boot = {
1750                                 "kernel": "https://www.example.com/download/vmlinuz",
1751                                 "initrd": "",
1752                                 "cmdline": (
1753                                     "console=ttyS0 ks=http://example.com/f8-i386/os/"
1754                                 ),
1755                             }
1756                             retval = virt.init(
1757                                 "test remote vm boot params",
1758                                 2,
1759                                 1234,
1760                                 nic=None,
1761                                 disk=None,
1762                                 seed=False,
1763                                 start=False,
1764                                 boot=boot,
1765                             )
1766                             definition = defineMock.call_args_list[0][0][0]
1767                             self.assertEqual(cache_dir in definition, True)
1768                     shutil.rmtree(cache_dir)
1769                 defineMock.reset_mock()
1770                 mock_run.reset_mock()
1771                 pool_mock = MagicMock()
1772                 pool_mock.XMLDesc.return_value = '&lt;pool type="dir"/&gt;'
1773                 self.mock_conn.storagePoolLookupByName.return_value = pool_mock
1774                 virt.init(
1775                     "test vm",
1776                     2,
1777                     1234,
1778                     nic=None,
1779                     disk=None,
1780                     disks=[
1781                         {"name": "system", "size": 10240},
1782                         {
1783                             "name": "cddrive",
1784                             "device": "cdrom",
1785                             "source_file": None,
1786                             "model": "ide",
1787                         },
1788                     ],
1789                     seed=False,
1790                     start=False,
1791                 )
1792                 definition = ET.fromstring(defineMock.call_args_list[0][0][0])
1793                 expected_disk_path = os.path.join(root_dir, "test vm_system.qcow2")
1794                 self.assertEqual(
1795                     expected_disk_path,
1796                     definition.find("./devices/disk[1]/source").get("file"),
1797                 )
1798                 self.assertIsNone(definition.find("./devices/disk[2]/source"))
1799                 self.assertEqual(
1800                     mock_run.call_args[0][0],
1801                     'qemu-img create -f qcow2 "{}" 10240M'.format(expected_disk_path),
1802                 )
1803                 self.assertEqual(mock_chmod.call_args[0][0], expected_disk_path)
1804                 defineMock.reset_mock()
1805                 mock_run.reset_mock()
1806                 vol_mock = MagicMock()
1807                 pool_mock.storageVolLookupByName.return_value = vol_mock
1808                 pool_mock.listVolumes.return_value = ["test vm_data"]
1809                 stream_mock = MagicMock()
1810                 self.mock_conn.newStream.return_value = stream_mock
1811                 self.mock_conn.listStoragePools.return_value = ["default", "test"]
1812                 with patch.dict(
1813                     os.__dict__, {"open": MagicMock(), "close": MagicMock()}
1814                 ):
1815                     cache_mock = MagicMock()
1816                     with patch.dict(virt.__salt__, {"cp.cache_file": cache_mock}):
1817                         virt.init(
1818                             "test vm",
1819                             2,
1820                             1234,
1821                             nic=None,
1822                             disk=None,
1823                             disks=[
1824                                 {
1825                                     "name": "system",
1826                                     "size": 10240,
1827                                     "image": "/path/to/image",
1828                                     "pool": "test",
1829                                 },
1830                                 {"name": "data", "size": 10240, "pool": "default"},
1831                                 {
1832                                     "name": "test",
1833                                     "size": 1024,
1834                                     "pool": "default",
1835                                     "format": "qcow2",
1836                                     "backing_store_path": "/backing/path",
1837                                     "backing_store_format": "raw",
1838                                 },
1839                             ],
1840                             seed=False,
1841                             start=False,
1842                         )
1843                         definition = ET.fromstring(defineMock.call_args_list[0][0][0])
1844                         self.assertTrue(
1845                             all(
1846                                 [
1847                                     disk.get("type") == "volume"
1848                                     for disk in definition.findall("./devices/disk")
1849                                 ]
1850                             )
1851                         )
1852                         self.assertEqual(
1853                             ["test", "default", "default"],
1854                             [
1855                                 src.get("pool")
1856                                 for src in definition.findall("./devices/disk/source")
1857                             ],
1858                         )
1859                         self.assertEqual(
1860                             ["test vm_system", "test vm_data", "test vm_test"],
1861                             [
1862                                 src.get("volume")
1863                                 for src in definition.findall("./devices/disk/source")
1864                             ],
1865                         )
1866                         create_calls = pool_mock.createXML.call_args_list
1867                         vol_names = [
1868                             ET.fromstring(call<font color="#717d7d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>[0][0]).find("name").text
1869                             for call in create_calls
1870                         ]
1871                         self.assertEqual(
1872                             ["test vm_system", "test vm_test"],
1873                             vol_names,
1874                         )
1875                         stream_mock.sendAll.assert_called_once()
1876                         stream_mock.finish.</b></font>assert_called_once()
1877                         vol_mock.upload.assert_called_once_with(stream_mock, 0, 0, 0)
1878     def test_update_backing_store(self):
1879         xml = """
1880             &lt;domain type='kvm' id='7'&gt;
1881               &lt;name&gt;my_vm&lt;/name&gt;
1882               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
1883               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
1884               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
1885               &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
1886               &lt;os&gt;
1887                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
1888               &lt;/os&gt;
1889               &lt;devices&gt;
1890                 &lt;disk type='volume' device='disk'&gt;
1891                   &lt;driver name='qemu' type='qcow2' cache='none' io='native'/&gt;
1892                   &lt;source pool='default' volume='my_vm_system' index='1'/&gt;
1893                   &lt;backingStore type='file' index='2'&gt;
1894                     &lt;format type='qcow2'/&gt;
1895                     &lt;source file='/path/to/base.qcow2'/&gt;
1896                     &lt;backingStore/&gt;
1897                   &lt;/backingStore&gt;
1898                   &lt;target dev='vda' bus='virtio'/&gt;
1899                   &lt;alias name='virtio-disk0'/&gt;
1900                   &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x04' function='0x0'/&gt;
1901                 &lt;/disk&gt;
1902               &lt;/devices&gt;
1903             &lt;/domain&gt;
1904         """
1905         domain_mock = self.set_mock_vm("my_vm", xml)
1906         domain_mock.OSType.return_value = "hvm"
1907         self.mock_conn.defineXML.return_value = True
1908         updatedev_mock = MagicMock(return_value=0)
1909         domain_mock.updateDeviceFlags = updatedev_mock
1910         self.mock_conn.listStoragePools.return_value = ["default"]
1911         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
1912             "&lt;pool type='dir'/&gt;"
1913         )
1914         ret = virt.update(
1915             "my_vm",
1916             disks=[
1917                 {
1918                     "name": "system",
1919                     "pool": "default",
1920                     "backing_store_path": "/path/to/base.qcow2",
1921                     "backing_store_format": "qcow2",
1922                 },
1923             ],
1924         )
1925         self.assertFalse(ret["definition"])
1926         self.assertFalse(ret["disk"]["attached"])
1927         self.assertFalse(ret["disk"]["detached"])
1928     def test_update_removables(self):
1929         xml = """
1930             &lt;domain type='kvm' id='7'&gt;
1931               &lt;name&gt;my_vm&lt;/name&gt;
1932               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
1933               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
1934               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
1935               &lt;os&gt;
1936                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
1937               &lt;/os&gt;
1938               &lt;devices&gt;
1939                 &lt;disk type='network' device='cdrom'&gt;
1940                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1941                   &lt;source protocol='https' name='/dvd-image-1.iso'&gt;
1942                     &lt;host name='test-srv.local' port='80'/&gt;
1943                   &lt;/source&gt;
1944                   &lt;backingStore/&gt;
1945                   &lt;target dev='hda' bus='ide'/&gt;
1946                   &lt;readonly/&gt;
1947                   &lt;alias name='ide0-0-0'/&gt;
1948                   &lt;address type='drive' controller='0' bus='0' target='0' unit='0'/&gt;
1949                 &lt;/disk&gt;
1950                 &lt;disk type='file' device='cdrom'&gt;
1951                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1952                   &lt;target dev='hdb' bus='ide'/&gt;
1953                   &lt;readonly/&gt;
1954                   &lt;alias name='ide0-0-1'/&gt;
1955                   &lt;address type='drive' controller='0' bus='0' target='0' unit='1'/&gt;
1956                 &lt;/disk&gt;
1957                 &lt;disk type='file' device='cdrom'&gt;
1958                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1959                   &lt;source file='/srv/dvd-image-2.iso'/&gt;
1960                   &lt;backingStore/&gt;
1961                   &lt;target dev='hdc' bus='ide'/&gt;
1962                   &lt;readonly/&gt;
1963                   &lt;alias name='ide0-0-2'/&gt;
1964                   &lt;address type='drive' controller='0' bus='0' target='0' unit='2'/&gt;
1965                 &lt;/disk&gt;
1966                 &lt;disk type='file' device='cdrom'&gt;
1967                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1968                   &lt;source file='/srv/dvd-image-3.iso'/&gt;
1969                   &lt;backingStore/&gt;
1970                   &lt;target dev='hdd' bus='ide'/&gt;
1971                   &lt;readonly/&gt;
1972                   &lt;alias name='ide0-0-3'/&gt;
1973                   &lt;address type='drive' controller='0' bus='0' target='0' unit='3'/&gt;
1974                 &lt;/disk&gt;
1975                 &lt;disk type='network' device='cdrom'&gt;
1976                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1977                   &lt;source protocol='https' name='/dvd-image-6.iso'&gt;
1978                     &lt;host name='test-srv.local' port='80'/&gt;
1979                   &lt;/source&gt;
1980                   &lt;backingStore/&gt;
1981                   &lt;target dev='hde' bus='ide'/&gt;
1982                   &lt;readonly/&gt;
1983                 &lt;/disk&gt;
1984               &lt;/devices&gt;
1985             &lt;/domain&gt;
1986         """
1987         domain_mock = self.set_mock_vm("my_vm", xml)
1988         domain_mock.OSType.return_value = "hvm"
1989         self.mock_conn.defineXML.return_value = True
1990         updatedev_mock = MagicMock(return_value=0)
1991         domain_mock.updateDeviceFlags = updatedev_mock
1992             "my_vm",
1993             disks=[
1994                 <font color="#e77471"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
1995                     "name": "dvd1",
1996                     "device": "cdrom",
1997                     "source_file": None,
1998                     "model": "ide",
1999                 },
2000                 {
2001                     "name": "dvd2",
2002                     "device": "cdrom",
2003                     "source_file": "/srv/dvd-image-4.iso",
2004                     "model": "ide",
2005                 },
2006                 {
2007                     "name": "dvd3",
2008                     "device": "cdrom",
2009                     "source_file": "/srv/dvd-image-2.iso",
2010                     "model": "ide",
2011                 },
2012                 {
2013                     "name": "dvd4",
2014                     "device": "cdrom",
2015                     "source_file": "/srv/dvd-image-5.iso",
2016                     "model": "ide",
2017                 },
2018                 {
2019                     "name": "dvd5",
2020                     "device": "cdrom",
2021                     "source_file": "/srv/dvd-image-6.iso",
2022                     "model": "ide",
2023                 },
2024             ],
2025         )
2026         self.assertTrue(ret["definition"])
2027         self.assertFalse(ret["disk"].</b></font>get("attached"))
2028         self<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertFalse(ret["disk"].get("detached"))
2029         self.assertEqual(
2030             [
2031                 {
2032                     "type": "file",
2033                     "device": "cdrom",
2034                     "driver": {
2035                         "name": "qemu",
2036                         "type": "raw",
2037                         "cache": "none",
2038                         "io": "native",
2039                     },
2040                     "backingStore": None,
2041                     "target": {"dev": "hda", "bus": "ide"},
2042                     "readonly": None,
2043                     "alias": {"name": "ide0-0-0"},
2044                     "address": {
2045                         "type": "drive",
2046                         "controller": "0",
2047                         "bus": "0",
2048                         "target": "0",
2049                         "unit": "0",
2050                     },
2051                 },
2052                 {
2053                     "type": "file",
2054                     "device": "cdrom",
2055                     "driver": {
2056                         "name": "qemu",
2057                         "type": "raw",
2058                         "cache": "none",
2059                         "io": "native",
2060                     },
2061                     "target": {"dev": "hdb", "bus": "ide"},
2062                     "readonly": None,
2063                     "alias": {"name": "ide0-0-1"},
2064                     "address": {
2065                         "type": "drive",
2066                         "controller": "0",
2067                         "bus": "0",
2068                         "target": "0",
2069                         "unit": "1",
2070                     },
2071                     "source": {"file": "/srv/dvd-image-4.iso"},
2072                 },
2073                 {
2074                     "type": "file",
2075                     "device": "cdrom",
2076                     "driver": {
2077                         "name": "qemu",
2078                         "type": "raw",
2079                         "cache": "none",
2080                         "io": "native",
2081                     },
2082                     "backingStore": None,
2083                     "target": {"dev": "hdd", "bus": "ide"},
2084                     "readonly": None,
2085                     "alias": {"name": "ide0-0-3"},
2086                     "address": {
2087                         "type": "drive",
2088                         "controller": "0",
2089                         "bus": "0",
2090                         "target": "0",
2091                         "unit": "3",
2092                     },
2093                     "source": {"file": "/srv/dvd-image-5.iso"},
2094                 },
2095                 {
2096                     "type": "file",
2097                     "device": "cdrom",
2098                     "driver": {
2099                         "name": "qemu",
2100                         "type": "raw",
2101                         "cache": "none",
2102                         "io": "native",
2103                     },
2104                     "backingStore": None,
2105                     "target": {"dev": "hde", "bus": "ide"},
2106                     "readonly": None,
2107                     "source": {"file": "/srv/dvd-image-6.iso"},
2108                 },
2109             ],
2110             [
2111                 salt.utils.</b></font>xmlutil.to_dict(ET.fromstring(disk), True)
2112                 for disk in ret["disk"]["updated"]
2113             ],
2114         )
2115     def test_update_xen_boot_params(self):
2116         root_dir = os.path.join(salt.syspaths.ROOT_DIR, "srv", "salt-images")
2117         xml_boot = """
2118             &lt;domain type='xen' id='8'&gt;
2119               &lt;name&gt;vm&lt;/name&gt;
2120               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
2121               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
2122               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
2123               &lt;os&gt;
2124                 &lt;type arch='x86_64' machine='xenfv'&gt;hvm&lt;/type&gt;
2125                 &lt;loader type='rom'&gt;/usr/lib/xen/boot/hvmloader&lt;/loader&gt;
2126               &lt;/os&gt;
2127             &lt;/domain&gt;
2128         """
2129         domain_mock_boot = self.set_mock_vm("vm", xml_boot)
2130         domain_mock_boot.OSType = MagicMock(return_value="hvm")
2131         define_mock_boot = MagicMock(return_value=True)
2132         define_mock_boot.setVcpusFlags = MagicMock(return_value=0)
2133         self.mock_conn.defineXML = define_mock_boot
2134         self.assertEqual(
2135             {
2136                 "cpu": False,
2137                 "definition": True,
2138                 "disk": {"attached": [], "detached": [], "updated": []},
2139                 "interface": {"attached": [], "detached": []},
2140             },
2141             virt.update("vm", cpu=2),
2142         )
2143         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2144         self.assertEqual(setxml.find("os").find("loader").attrib.get("type"), "rom")
2145         self.assertEqual(
2146             setxml.find("os").find("loader").text, "/usr/lib/xen/boot/hvmloader"
2147         )
2148     def test_update_existing_boot_params(self):
2149         xml_boot = """
2150             &lt;domain type='kvm' id='8'&gt;
2151               &lt;name&gt;vm_with_boot_param&lt;/name&gt;
2152               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
2153               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
2154               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
2155               &lt;os&gt;
2156                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
2157                 &lt;kernel&gt;/boot/oldkernel&lt;/kernel&gt;
2158                 &lt;initrd&gt;/boot/initrdold.img&lt;/initrd&gt;
2159                 &lt;cmdline&gt;console=ttyS0 ks=http://example.com/old/os/&lt;/cmdline&gt;
2160                 &lt;loader&gt;/usr/share/old/OVMF_CODE.fd&lt;/loader&gt;
2161                 &lt;nvram&gt;/usr/share/old/OVMF_VARS.ms.fd&lt;/nvram&gt;
2162               &lt;/os&gt;
2163             &lt;/domain&gt;
2164         """
2165         domain_mock_boot = self.set_mock_vm("vm_with_boot_param", xml_boot)
2166         domain_mock_boot.OSType = MagicMock(return_value="hvm")
2167         define_mock_boot = MagicMock(return_value=True)
2168         self.mock_conn.defineXML = define_mock_boot
2169         boot_new = {
2170             "kernel": "/root/new-vmlinuz",
2171             "initrd": "/root/new-initrd",
2172             "cmdline": "console=ttyS0 ks=http://example.com/new/os/",
2173         }
2174         uefi_boot_new = {
2175             "loader": "/usr/share/new/OVMF_CODE.fd",
2176             "nvram": "/usr/share/new/OVMF_VARS.ms.fd",
2177         }
2178         self.assertEqual(
2179             {
2180                 "definition": True,
2181                 "disk": {"attached": [], "detached": [], "updated": []},
2182                 "interface": {"attached": [], "detached": []},
2183             },
2184             virt.update("vm_with_boot_param", boot=boot_new),
2185         )
2186         setxml_boot = ET.fromstring(define_mock_boot.call_args[0][0])
2187         self.assertEqual(
2188             setxml_boot.find("os").find("kernel").text, "/root/new-vmlinuz"
2189         )
2190         self.assertEqual(setxml_boot.find("os").find("initrd").text, "/root/new-initrd")
2191         self.assertEqual(
2192             setxml_boot.find("os").find("cmdline").text,
2193             "console=ttyS0 ks=http://example.com/new/os/",
2194         )
2195         self.assertEqual(
2196             {
2197                 "definition": True,
2198                 "disk": {"attached": [], "detached": [], "updated": []},
2199                 "interface": {"attached": [], "detached": []},
2200             },
2201             virt.update("vm_with_boot_param", boot=uefi_boot_new),
2202         )
2203         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2204         self.assertEqual(
2205             setxml.find("os").find("loader").text, "/usr/share/new/OVMF_CODE.fd"
2206         )
2207         self.assertEqual(setxml.find("os").find("loader").attrib.get("readonly"), "yes")
2208         self.assertEqual(setxml.find("os").find("loader").attrib["type"], "pflash")
2209         self.assertEqual(
2210             setxml.find("os").find("nvram").attrib["template"],
2211             "/usr/share/new/OVMF_VARS.ms.fd",
2212         )
2213         kernel_none = {
2214             "kernel": None,
2215             "initrd": None,
2216             "cmdline": None,
2217         }
2218         uefi_none = {"loader": None, "nvram": None}
2219         self.assertEqual(
2220             {
2221                 "definition": True,
2222                 "disk": {"attached": [], "detached": [], "updated": []},
2223                 "interface": {"attached": [], "detached": []},
2224             },
2225             virt.update("vm_with_boot_param", boot=kernel_none),
2226         )
2227         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2228         self.assertEqual(setxml.find("os").find("kernel"), None)
2229         self.assertEqual(setxml.find("os").find("initrd"), None)
2230         self.assertEqual(setxml.find("os").find("cmdline"), None)
2231         self.assertEqual(
2232             {
2233                 "definition": True,
2234                 "disk": {"attached": [], "detached": [], "updated": []},
2235                 "interface": {"attached": [], "detached": []},
2236             },
2237             virt.update("vm_with_boot_param", boot={"efi": False}),
2238         )
2239         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2240         self.assertEqual(setxml.find("os").find("nvram"), None)
2241         self.assertEqual(setxml.find("os").find("loader"), None)
2242         self.assertEqual(
2243             {
2244                 "definition": True,
2245                 "disk": {"attached": [], "detached": [], "updated": []},
2246                 "interface": {"attached": [], "detached": []},
2247             },
2248             virt.update("vm_with_boot_param", boot=uefi_none),
2249         )
2250         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2251         self.assertEqual(setxml.find("os").find("loader"), None)
2252         self.assertEqual(setxml.find("os").find("nvram"), None)
2253     def test_update_existing_numatune_params(self):
2254         xml_numatune = """
2255             &lt;domain type='kvm' id='8'&gt;
2256               &lt;name&gt;vm_with_numatune_param&lt;/name&gt;
2257               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
2258               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
2259               &lt;maxMemory slots="12" unit="bytes"&gt;1048576&lt;/maxMemory&gt;
2260               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
2261               &lt;numatune&gt;
2262                 &lt;memory mode="strict" nodeset="0-11"/&gt;
2263                 &lt;memnode cellid="1" mode="strict" nodeset="3"/&gt;
2264                 &lt;memnode cellid="3" mode="preferred" nodeset="7"/&gt;
2265               &lt;/numatune&gt;
2266               &lt;os&gt;
2267                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
2268               &lt;/os&gt;
2269               &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
2270             &lt;/domain&gt;
2271         """
2272         domain_mock = self.set_mock_vm("vm_with_numatune_param", xml_numatune)
2273         domain_mock.OSType = MagicMock(return_value="hvm")
2274         define_mock = MagicMock(return_value=True)
2275         self.mock_conn.defineXML = define_mock
2276         numatune = {
2277             <font color="#68818b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"memory": {"mode": "preferred", "nodeset": "0-5"},
2278             "memnodes": {
2279                 0: {"mode": "strict", "nodeset": "4"},
2280                 3: {"mode": "preferred", "nodeset": "7"},
2281                 4: {"mode": "strict", "nodeset": "6"},
2282             },
2283         }
2284         self.assertEqual(
2285             {
2286                 "definition": True,
2287                 "disk": {"attached": [], "detached": [], "updated": []},
2288                 "interface": {"attached": [], "detached": []},
2289             },
2290             virt.update(</b></font>"vm_with_numatune_param", numatune=numatune),
2291         )
2292         setxml = ET.fromstring(define_mock.call_args[0][0])
2293         self.assertEqual(
2294             setxml.find("numatune").find("memory").attrib.get("mode"), "preferred"
2295         )
2296         self.assertEqual(
2297             setxml.find("numatune").find("memory").attrib.get("nodeset"),
2298             ",".join([str(i) for i in range(0, 6)]),
2299         )
2300         self.assertEqual(
2301             setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("mode"), "strict"
2302         )
2303         self.assertEqual(
2304             setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("nodeset"), "4"
2305         )
2306         self.assertEqual(setxml.find("./numatune/memnode/[@cellid='1']"), None)
2307         self.assertEqual(
2308             setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("mode"),
2309             "preferred",
2310         )
2311         self.assertEqual(
2312             setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("nodeset"), "7"
2313         )
2314         self.assertEqual(
2315             setxml.find("./numatune/memnode/[@cellid='4']").attrib.get("mode"), "strict"
2316         )
2317         self.assertEqual(
2318             setxml.find("./numatune/memnode/[@cellid='4']").attrib.get("nodeset"), "6"
2319         )
2320         self.assertEqual(setxml.find("./numatune/memnode/[@cellid='2']"), None)
2321         numatune_mem_none = {
2322             "memory": None,
2323             "memnodes": {
2324                 0: {"mode": "strict", "nodeset": "4"},
2325                 3: {"mode": "preferred", "nodeset": "7"},
2326                 4: {"mode": "strict", "nodeset": "6"},
2327             },
2328         }
2329         self.assertEqual(
2330             {
2331                 "definition": True,
2332                 "disk": {"attached": [], "detached": [], "updated": []},
2333                 "interface": {"attached": [], "detached": []},
2334             },
2335             virt.update("vm_with_numatune_param", numatune=numatune_mem_none),
2336         )
2337         setxml = ET.fromstring(define_mock.call_args[0][0])
2338         self.assertEqual(setxml.find("numatune").find("memory"), None)
2339         self.assertEqual(
2340             setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("mode"), "strict"
2341         )
2342         self.assertEqual(
2343             setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("nodeset"), "4"
2344         )
2345         self.assertEqual(
2346             setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("mode"),
2347             "preferred",
2348         )
2349         self.assertEqual(
2350             setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("nodeset"), "7"
2351         )
2352         self.assertEqual(setxml.find("./numatune/memnode/[@cellid='2']"), None)
2353         numatune_mnodes_none = {
2354             "memory": {"mode": "preferred", "nodeset": "0-5"},
2355             "memnodes": None,
2356         }
2357         self.assertEqual(
2358             {
2359                 "definition": True,
2360                 "disk": {"attached": [], "detached": [], "updated": []},
2361                 "interface": {"attached": [], "detached": []},
2362             },
2363             virt.update("vm_with_numatune_param", numatune=numatune_mnodes_none),
2364         )
2365         setxml = ET.fromstring(define_mock.call_args[0][0])
2366         self.assertEqual(
2367             setxml.find("numatune").find("memory").attrib.get("mode"), "preferred"
2368         )
2369         self.assertEqual(
2370             setxml.find("numatune").find("memory").attrib.get("nodeset"),
2371             ",".join([str(i) for i in range(0, 6)]),
2372         )
2373         self.assertEqual(setxml.find("./numatune/memnode"), None)
2374         numatune_without_change = {
2375             "memory": {"mode": "strict", "nodeset": "0-5,6,7-11"},
2376             "memnodes": {
2377                 1: {"mode": "strict", "nodeset": "3"},
2378                 3: {"mode": "preferred", "nodeset": "7"},
2379             },
2380         }
2381         self.assertEqual(
2382             {
2383                 "definition": False,
2384                 "disk": {"attached": [], "detached": [], "updated": []},
2385                 "interface": {"attached": [], "detached": []},
2386             },
2387             virt.update("vm_with_numatune_param", numatune=numatune_without_change),
2388         )
2389         self.assertEqual(
2390             {
2391                 "definition": True,
2392                 "disk": {"attached": [], "detached": [], "updated": []},
2393                 "interface": {"attached": [], "detached": []},
2394             },
2395             virt.update(
2396                 "vm_with_numatune_param", numatune={"memory": None, "memnodes": None}
2397             ),
2398         )
2399         setxml = ET.fromstring(define_mock.call_args[0][0])
2400         self.assertEqual(setxml.find("numatune"), None)
2401     def test_update_existing_cpu_params(self):
2402         xml_with_existing_params = """
2403             &lt;domain type='kvm' id='8'&gt;
2404               &lt;name&gt;vm_with_boot_param&lt;/name&gt;
2405               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
2406               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
2407               &lt;vcpu placement="static" cpuset="0-11" current="3"&gt;6&lt;/vcpu&gt;
2408               &lt;vcpus&gt;
2409                 &lt;vcpu id="0" enabled="yes" hotpluggable="no" order="1"/&gt;
2410                 &lt;vcpu id="1" enabled="no" hotpluggable="yes"/&gt;
2411                 &lt;vcpu id="2" enabled="no" hotpluggable="yes"/&gt;
2412                 &lt;vcpu id="3" enabled="no" hotpluggable="yes"/&gt;
2413                 &lt;vcpu id="4" enabled="no" hotpluggable="yes"/&gt;
2414                 &lt;vcpu id="5" enabled="no" hotpluggable="yes"/&gt;
2415                 &lt;vcpu id="6" enabled="no" hotpluggable="yes"/&gt;
2416                 &lt;vcpu id="7" enabled="no" hotpluggable="yes"/&gt;
2417                 &lt;vcpu id="8" enabled="no" hotpluggable="yes"/&gt;
2418                 &lt;vcpu id="9" enabled="no" hotpluggable="yes"/&gt;
2419                 &lt;vcpu id="10" enabled="no" hotpluggable="yes"/&gt;
2420                 &lt;vcpu id="11" enabled="no" hotpluggable="yes"/&gt;
2421               &lt;/vcpus&gt;
2422               &lt;cpu mode="custom" match="exact" check="full"&gt;
2423                  &lt;model fallback="allow" vendor_id="Genuine20201"&gt;core2duo&lt;/model&gt;
2424                  &lt;vendor&gt;Intel&lt;/vendor&gt;
2425                  &lt;topology sockets="2" cores="5" threads="2"/&gt;
2426                  &lt;cache level="3" mode="emulate"/&gt;
2427                  &lt;feature policy="optional" name="lahf_lm"/&gt;
2428                  &lt;feature policy="require" name="pcid"/&gt;
2429                  &lt;numa&gt;
2430                     &lt;cell id="0" cpus="0-3" memory="1073741824" unit="KiB" discard="no"&gt;
2431                         &lt;distances&gt;
2432                             &lt;sibling id="0" value="10"/&gt;
2433                             &lt;sibling id="1" value="21"/&gt;
2434                             &lt;sibling id="2" value="31"/&gt;
2435                             &lt;sibling id="3" value="41"/&gt;
2436                         &lt;/distances&gt;
2437                     &lt;/cell&gt;
2438                     &lt;cell id="1" cpus="4-6" memory="1073741824" unit="KiB" memAccess="private"&gt;
2439                         &lt;distances&gt;
2440                             &lt;sibling id="0" value="21"/&gt;
2441                             &lt;sibling id="1" value="10"/&gt;
2442                             &lt;sibling id="2" value="21"/&gt;
2443                             &lt;sibling id="3" value="31"/&gt;
2444                         &lt;/distances&gt;
2445                     &lt;/cell&gt;
2446                  &lt;/numa&gt;
2447               &lt;/cpu&gt;
2448               &lt;os&gt;
2449                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
2450               &lt;/os&gt;
2451               &lt;/domain&gt;
2452          """
2453         domain_mock = self.set_mock_vm(
2454             "vm_with_existing_param", xml_with_existing_params
2455         )
2456         domain_mock.OSType = MagicMock(return_value="hvm")
2457         define_mock = MagicMock(return_value=True)
2458         self.mock_conn.defineXML = define_mock
2459         setvcpus_mock = MagicMock(return_value=0)
2460         domain_mock.setVcpusFlags = setvcpus_mock
2461         cpu_attr = {"placement": "static", "cpuset": "0-5", "current": 3, "maximum": 5}
2462         self.assertEqual(
2463             {
2464                 "definition": True,
2465                 "cpu": True,
2466                 "disk": {"attached": [], "detached": [], "updated": []},
2467                 "interface": {"attached": [], "detached": []},
2468             },
2469             virt.update("vm_with_existing_param", cpu=cpu_attr),
2470         )
2471         setxml = ET.fromstring(define_mock.call_args[0][0])
2472         self.assertEqual(setxml.find("vcpu").text, "5")
2473         self.assertEqual(setxml.find("vcpu").attrib["placement"], "static")
2474         self.assertEqual(
2475             setxml.find("vcpu").attrib["cpuset"],
2476             ",".join([str(i) for i in range(0, 6)]),
2477         )
2478         self.assertEqual(setxml.find("vcpu").attrib["current"], "3")
2479         cpu_none = {"placement": "auto", "cpuset": None, "current": 2, "maximum": 5}
2480         self.assertEqual(
2481             {
2482                 "definition": True,
2483                 "cpu": True,
2484                 "disk": {"attached": [], "detached": [], "updated": []},
2485                 "interface": {"attached": [], "detached": []},
2486             },
2487             virt.update("vm_with_existing_param", cpu=cpu_none),
2488         )
2489         setxml = ET.fromstring(define_mock.call_args[0][0])
2490         self.assertEqual(setxml.find("vcpu").text, "5")
2491         self.assertEqual(setxml.find("vcpu").attrib["placement"], "auto")
2492         self.assertEqual(setxml.find("vcpu").attrib.get("cpuset"), None)
2493         self.assertEqual(setxml.find("vcpu").attrib.get("current"), "2")
2494         vcpus = {
2495             "vcpus": {
2496                 "0": {"enabled": False, "hotpluggable": True, "order": 5},
2497                 "3": {"enabled": True, "hotpluggable": False, "order": 3},
2498                 "7": {"enabled": True, "hotpluggable": False},
2499             }
2500         }
2501         self.assertEqual(
2502             {
2503                 "definition": True,
2504                 "disk": {"attached": [], "detached": [], "updated": []},
2505                 "interface": {"attached": [], "detached": []},
2506             },
2507             virt.update("vm_with_existing_param", cpu=vcpus),
2508         )
2509         setxml = ET.fromstring(define_mock.call_args[0][0])
2510         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']").attrib["id"], "0")
2511         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']").attrib["enabled"], "no")
2512         self.assertEqual(
2513             setxml.find("./vcpus/vcpu/[@id='0']").attrib["hotpluggable"], "yes"
2514         )
2515         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']").attrib["order"], "5")
2516         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["id"], "3")
2517         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["enabled"], "yes")
2518         self.assertEqual(
2519             setxml.find("./vcpus/vcpu/[@id='3']").attrib["hotpluggable"], "no"
2520         )
2521         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["order"], "3")
2522         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='7']").attrib["id"], "7")
2523         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='7']").attrib["enabled"], "yes")
2524         self.assertEqual(
2525             setxml.find("./vcpus/vcpu/[@id='7']").attrib["hotpluggable"], "no"
2526         )
2527         self.assertEqual(
2528             setxml.find("./vcpus/vcpu/[@id='7']").attrib.get("order"), None
2529         )
2530         ind_vcpu = {
2531             "vcpus": {"3": {"enabled": True, "hotpluggable": False, "order": None}}
2532         }
2533         self.assertEqual(
2534             {
2535                 "definition": True,
2536                 "disk": {"attached": [], "detached": [], "updated": []},
2537                 "interface": {"attached": [], "detached": []},
2538             },
2539             virt.update("vm_with_existing_param", cpu=ind_vcpu),
2540         )
2541         setxml = ET.fromstring(define_mock.call_args[0][0])
2542         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']"), None)
2543         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["enabled"], "yes")
2544         self.assertEqual(
2545             setxml.find("./vcpus/vcpu/[@id='3']").attrib["hotpluggable"], "no"
2546         )
2547         self.assertEqual(
2548             setxml.find("./vcpus/vcpu/[@id='3']").attrib.get("order"), None
2549         )
2550         vcpus_none = {"vcpus": None}
2551         self.assertEqual(
2552             {
2553                 "definition": True,
2554                 "disk": {"attached": [], "detached": [], "updated": []},
2555                 "interface": {"attached": [], "detached": []},
2556             },
2557             virt.update("vm_with_existing_param", cpu=vcpus_none),
2558         )
2559         setxml = ET.fromstring(define_mock.call_args[0][0])
2560         self.assertEqual(setxml.find("vcpus"), None)
2561         cpu_atr_none = {"match": None, "mode": None, "check": None}
2562         self.assertEqual(
2563             {
2564                 "definition": True,
2565                 "disk": {"attached": [], "detached": [], "updated": []},
2566                 "interface": {"attached": [], "detached": []},
2567             },
2568             virt.update("vm_with_existing_param", cpu=cpu_atr_none),
2569         )
2570         setxml = ET.fromstring(define_mock.call_args[0][0])
2571         self.assertEqual(setxml.find("cpu").attrib, {})
2572         cpu_atr_mn = {"match": None}
2573         self.assertEqual(
2574             {
2575                 "definition": True,
2576                 "disk": {"attached": [], "detached": [], "updated": []},
2577                 "interface": {"attached": [], "detached": []},
2578             },
2579             virt.update("vm_with_existing_param", cpu=cpu_atr_mn),
2580         )
2581         setxml = ET.fromstring(define_mock.call_args[0][0])
2582         self.assertEqual(setxml.find("cpu").attrib.get("match"), None)
2583         self.assertEqual(setxml.find("cpu").attrib.get("mode"), "custom")
2584         self.assertEqual(setxml.find("cpu").attrib.get("check"), "full")
2585         cpu_model_none = {"model": None}
2586         self.assertEqual(
2587             {
2588                 "definition": True,
2589                 "disk": {"attached": [], "detached": [], "updated": []},
2590                 "interface": {"attached": [], "detached": []},
2591             },
2592             virt.update("vm_with_existing_param", cpu=cpu_model_none),
2593         )
2594         setxml = ET.fromstring(define_mock.call_args[0][0])
2595         self.assertEqual(setxml.find("cpu").find("model"), None)
2596         cpu_model_atr_none = {
2597             "model": {"name": "coresolo", "fallback": "forbid", "vendor_id": None}
2598         }
2599         self.assertEqual(
2600             {
2601                 "definition": True,
2602                 "disk": {"attached": [], "detached": [], "updated": []},
2603                 "interface": {"attached": [], "detached": []},
2604             },
2605             virt.update("vm_with_existing_param", cpu=cpu_model_atr_none),
2606         )
2607         setxml = ET.fromstring(define_mock.call_args[0][0])
2608         self.assertEqual(setxml.find("cpu").find("model").attrib.get("vendor_id"), None)
2609         self.assertEqual(
2610             setxml.find("cpu").find("model").attrib.get("fallback"), "forbid"
2611         )
2612         self.assertEqual(setxml.find("cpu").find("model").text, "coresolo")
2613         cpu_model_atr = {
2614             "model": {
2615                 "name": "coresolo",
2616                 "fallback": "forbid",
2617                 "vendor_id": "AuthenticAMD",
2618             }
2619         }
2620         self.assertEqual(
2621             {
2622                 "definition": True,
2623                 "disk": {"attached": [], "detached": [], "updated": []},
2624                 "interface": {"attached": [], "detached": []},
2625             },
2626             virt.update("vm_with_existing_param", cpu=cpu_model_atr),
2627         )
2628         setxml = ET.fromstring(define_mock.call_args[0][0])
2629         self.assertEqual(
2630             setxml.find("cpu").find("model").attrib.get("fallback"), "forbid"
2631         )
2632         self.assertEqual(
2633             setxml.find("cpu").find("model").attrib.get("vendor_id"), "AuthenticAMD"
2634         )
2635         self.assertEqual(setxml.find("cpu").find("model").text, "coresolo")
2636         cpu_vendor = {"vendor": "AMD"}
2637         self.assertEqual(
2638             {
2639                 "definition": True,
2640                 "disk": {"attached": [], "detached": [], "updated": []},
2641                 "interface": {"attached": [], "detached": []},
2642             },
2643             virt.update("vm_with_existing_param", cpu=cpu_vendor),
2644         )
2645         setxml = ET.fromstring(define_mock.call_args[0][0])
2646         self.assertEqual(setxml.find("cpu").find("vendor").text, "AMD")
2647         cpu_vendor_none = {"vendor": None}
2648         self.assertEqual(
2649             {
2650                 "definition": True,
2651                 "disk": {"attached": [], "detached": [], "updated": []},
2652                 "interface": {"attached": [], "detached": []},
2653             },
2654             virt.update("vm_with_existing_param", cpu=cpu_vendor_none),
2655         )
2656         setxml = ET.fromstring(define_mock.call_args[0][0])
2657         self.assertEqual(setxml.find("cpu").find("vendor"), None)
2658         cpu_topology = {"topology": {"sockets": 1, "cores": 12, "threads": 1}}
2659         self.assertEqual(
2660             {
2661                 "definition": True,
2662                 "disk": {"attached": [], "detached": [], "updated": []},
2663                 "interface": {"attached": [], "detached": []},
2664             },
2665             virt.update("vm_with_existing_param", cpu=cpu_topology),
2666         )
2667         setxml = ET.fromstring(define_mock.call_args[0][0])
2668         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("sockets"), "1")
2669         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("cores"), "12")
2670         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("threads"), "1")
2671         cpu_topology_atr_none = {
2672             "topology": {"sockets": None, "cores": 12, "threads": 1}
2673         }
2674         self.assertEqual(
2675             {
2676                 "definition": True,
2677                 "disk": {"attached": [], "detached": [], "updated": []},
2678                 "interface": {"attached": [], "detached": []},
2679             },
2680             virt.update("vm_with_existing_param", cpu=cpu_topology_atr_none),
2681         )
2682         setxml = ET.fromstring(define_mock.call_args[0][0])
2683         self.assertEqual(
2684             setxml.find("cpu").find("topology").attrib.get("sockets"), None
2685         )
2686         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("cores"), "12")
2687         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("threads"), "1")
2688         cpu_topology_none = {"topology": None}
2689         self.assertEqual(
2690             {
2691                 "definition": True,
2692                 "disk": {"attached": [], "detached": [], "updated": []},
2693                 "interface": {"attached": [], "detached": []},
2694             },
2695             virt.update("vm_with_existing_param", cpu=cpu_topology_none),
2696         )
2697         setxml = ET.fromstring(define_mock.call_args[0][0])
2698         self.assertEqual(setxml.find("cpu").find("topology"), None)
2699         cpu_cache = {"cache": {"mode": "passthrough", "level": 2}}
2700         self.assertEqual(
2701             {
2702                 "definition": True,
2703                 "disk": {"attached": [], "detached": [], "updated": []},
2704                 "interface": {"attached": [], "detached": []},
2705             },
2706             virt.update("vm_with_existing_param", cpu=cpu_cache),
2707         )
2708         setxml = ET.fromstring(define_mock.call_args[0][0])
2709         self.assertEqual(setxml.find("cpu").find("cache").attrib.get("level"), "2")
2710         self.assertEqual(
2711             setxml.find("cpu").find("cache").attrib.get("mode"), "passthrough"
2712         )
2713         cpu_cache_atr_none = {"cache": {"mode": "passthrough", "level": None}}
2714         self.assertEqual(
2715             {
2716                 "definition": True,
2717                 "disk": {"attached": [], "detached": [], "updated": []},
2718                 "interface": {"attached": [], "detached": []},
2719             },
2720             virt.update("vm_with_existing_param", cpu=cpu_cache_atr_none),
2721         )
2722         setxml = ET.fromstring(define_mock.call_args[0][0])
2723         self.assertEqual(setxml.find("cpu").find("cache").attrib.get("level"), None)
2724         self.assertEqual(
2725             setxml.find("cpu").find("cache").attrib.get("mode"), "passthrough"
2726         )
2727         cpu_cache_none = {"cache": None}
2728         self.assertEqual(
2729             {
2730                 "definition": True,
2731                 "disk": {"attached": [], "detached": [], "updated": []},
2732                 "interface": {"attached": [], "detached": []},
2733             },
2734             virt.update("vm_with_existing_param", cpu=cpu_cache_none),
2735         )
2736         setxml = ET.fromstring(define_mock.call_args[0][0])
2737         self.assertEqual(setxml.find("cpu").find("cache"), None)
2738         cpu_feature = {"features": {"lahf_lm": "require", "pcid": "optional"}}
2739         self.assertEqual(
2740             {
2741                 "definition": True,
2742                 "disk": {"attached": [], "detached": [], "updated": []},
2743                 "interface": {"attached": [], "detached": []},
2744             },
2745             virt.update("vm_with_existing_param", cpu=cpu_feature),
2746         )
2747         setxml = ET.fromstring(define_mock.call_args[0][0])
2748         self.assertEqual(
2749             setxml.find("./cpu/feature[@name='pcid']").attrib.get("policy"), "optional"
2750         )
2751         self.assertEqual(
2752             setxml.find("./cpu/feature[@name='lahf_lm']").attrib.get("policy"),
2753             "require",
2754         )
2755         cpu_feature_atr_none = {"features": {"pcid": "optional", "lahf_lm": "disable"}}
2756         self.assertEqual(
2757             {
2758                 "definition": True,
2759                 "disk": {"attached": [], "detached": [], "updated": []},
2760                 "interface": {"attached": [], "detached": []},
2761             },
2762             virt.update("vm_with_existing_param", cpu=cpu_feature_atr_none),
2763         )
2764         setxml = ET.fromstring(define_mock.call_args[0][0])
2765         self.assertEqual(
2766             setxml.find("./cpu/feature[@name='lahf_lm']").attrib.get("policy"),
2767             "disable",
2768         )
2769         self.assertEqual(
2770             setxml.find("./cpu/feature[@name='pcid']").attrib.get("policy"), "optional"
2771         )
2772         cpu_feature_none = {"features": {"lahf_lm": None, "pcid": None}}
2773         self.assertEqual(
2774             {
2775                 "definition": True,
2776                 "disk": {"attached": [], "detached": [], "updated": []},
2777                 "interface": {"attached": [], "detached": []},
2778             },
2779             virt.update("vm_with_existing_param", cpu=cpu_feature_none),
2780         )
2781         setxml = ET.fromstring(define_mock.call_args[0][0])
2782         self.assertEqual(setxml.find("./cpu/feature"), None)
2783         numa_cell = {
2784             <font color="#f660ab"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"numa": {
2785                 0: {
2786                     "cpus": "0-6",
2787                     "memory": "512m",
2788                     "discard": True,
2789                     "distances": {0: 15, 1: 16, 2: 17, 3: 18},
2790                 },
2791                 1: {
2792                     "cpus": "7-12",
2793                     "memory": "2g",
2794                     "discard": True,
2795                     "memAccess": "shared",
2796                     "distances": {0: 23, 1: 24, 2: 25, 3: 26},
2797                 },
2798             }
2799         }
2800         self.assertEqual(
2801             {
2802                 "definition": True,
2803                 "disk": {"attached": [], "detached": [], "updated": []},
2804                 "interface": {"attached": [], "detached": []},
2805             },
2806             virt.update(</b></font>"vm_with_existing_param", cpu=numa_cell),
2807         )
2808         setxml = ET.fromstring(define_mock.call_args[0][0])
2809         self.assertEqual(
2810             setxml.find("./cpu/numa/cell/[@id='0']").attrib["cpus"],
2811             ",".join([str(i) for i in range(0, 7)]),
2812         )
2813         self.assertEqual(
2814             setxml.find("./cpu/numa/cell/[@id='0']").attrib["memory"],
2815             str(512 * 1024 ** 2),
2816         )
2817         self.assertEqual(
2818             setxml.find("./cpu/numa/cell/[@id='0']").get("unit"),
2819             "bytes",
2820         )
2821         self.assertEqual(
2822             setxml.find("./cpu/numa/cell/[@id='0']").attrib["discard"], "yes"
2823         )
2824         self.assertEqual(
2825             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='0']").attrib[
2826                 "value"
2827             ],
2828             "15",
2829         )
2830         self.assertEqual(
2831             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='1']").attrib[
2832                 "value"
2833             ],
2834             "16",
2835         )
2836         self.assertEqual(
2837             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='2']").attrib[
2838                 "value"
2839             ],
2840             "17",
2841         )
2842         self.assertEqual(
2843             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='3']").attrib[
2844                 "value"
2845             ],
2846             "18",
2847         )
2848         self.assertEqual(
2849             setxml.find("./cpu/numa/cell/[@id='1']").attrib["cpus"],
2850             ",".join([str(i) for i in range(7, 13)]),
2851         )
2852         self.assertEqual(
2853             setxml.find("./cpu/numa/cell/[@id='1']").attrib["memory"],
2854             str(int(2 * 1024 ** 3)),
2855         )
2856         self.assertEqual(
2857             setxml.find("./cpu/numa/cell/[@id='1']").get("unit"),
2858             "bytes",
2859         )
2860         self.assertEqual(
2861             setxml.find("./cpu/numa/cell/[@id='1']").attrib["discard"], "yes"
2862         )
2863         self.assertEqual(
2864             setxml.find("./cpu/numa/cell/[@id='1']").attrib["memAccess"], "shared"
2865         )
2866         self.assertEqual(
2867             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='0']").attrib[
2868                 "value"
2869             ],
2870             "23",
2871         )
2872         self.assertEqual(
2873             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='1']").attrib[
2874                 "value"
2875             ],
2876             "24",
2877         )
2878         self.assertEqual(
2879             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='2']").attrib[
2880                 "value"
2881             ],
2882             "25",
2883         )
2884         self.assertEqual(
2885             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='3']").attrib[
2886                 "value"
2887             ],
2888             "26",
2889         numa_cell_atr_none = {
2890             <font color="#827d6b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"numa": {
2891                 "0": {
2892                     "cpus": "0-6",
2893                     "memory": "512m",
2894                     "discard": False,
2895                     "distances": {0: 15, 2: 17, 3: 18},
2896                 },
2897                 "1": {
2898                     "cpus": "7-12",
2899                     "memory": "2g",
2900                     "discard": True,
2901                     "distances": {0: 23, 1: 24, 2: 25},
2902                 },
2903             }
2904         }
2905         self.assertEqual(
2906             {
2907                 "definition": True,
2908                 "disk": {"attached": [], "detached": [], "updated": []},
2909                 "interface": {"attached": [], "detached": []},
2910             },
2911             virt.</b></font>update("vm_with_existing_param", cpu=numa_cell_atr_none),
2912         )
2913         setxml = ET.fromstring(define_mock.call_args[0][0])
2914         self.assertEqual(
2915             setxml.find("./cpu/numa/cell/[@id='0']").attrib["cpus"],
2916             ",".join([str(i) for i in range(0, 7)]),
2917         )
2918         self.assertEqual(
2919             setxml.find("./cpu/numa/cell/[@id='0']").attrib["memory"],
2920             str(512 * 1024 ** 2),
2921         )
2922         self.assertEqual(
2923             setxml.find("./cpu/numa/cell/[@id='0']").get("unit"),
2924             "bytes",
2925         )
2926         self.assertEqual(
2927             setxml.find("./cpu/numa/cell/[@id='0']").attrib.get("discard"), "no"
2928         )
2929         self.assertEqual(
2930             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='0']").attrib[
2931                 "value"
2932             ],
2933             "15",
2934         )
2935         self.assertEqual(
2936             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='1']"), None
2937         )
2938         self.assertEqual(
2939             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='2']").attrib[
2940                 "value"
2941             ],
2942             "17",
2943         )
2944         self.assertEqual(
2945             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='3']").attrib[
2946                 "value"
2947             ],
2948             "18",
2949         )
2950         self.assertEqual(
2951             setxml.find("./cpu/numa/cell/[@id='1']").attrib["cpus"],
2952             ",".join([str(i) for i in range(7, 13)]),
2953         )
2954         self.assertEqual(
2955             setxml.find("./cpu/numa/cell/[@id='1']").attrib["memory"],
2956             str(int(2 * 1024 ** 3)),
2957         )
2958         self.assertEqual(
2959             setxml.find("./cpu/numa/cell/[@id='1']").attrib["discard"], "yes"
2960         )
2961         self.assertEqual(
2962             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='0']").attrib[
2963                 "value"
2964             ],
2965             "23",
2966         )
2967         self.assertEqual(
2968             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='1']").attrib[
2969                 "value"
2970             ],
2971             "24",
2972         )
2973         self.assertEqual(
2974             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='2']").attrib[
2975                 "value"
2976             ],
2977             "25",
2978         )
2979         self.assertEqual(
2980             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='3']"), None
2981         )
2982         self.assertEqual(
2983             setxml.find("./cpu/numa/cell/[@id='1']").attrib["cpus"],
2984             ",".join([str(i) for i in range(7, 13)]),
2985         )
2986         self.assertEqual(
2987             setxml.find("./cpu/numa/cell/[@id='1']").attrib["memory"],
2988             str(int(1024 ** 3 * 2)),
2989         )
2990         self.assertEqual(
2991             setxml.find("./cpu/numa/cell/[@id='1']").attrib["discard"], "yes"
2992         )
2993         self.assertEqual(
2994             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='0']").attrib[
2995                 "value"
2996             ],
2997             "23",
2998         )
2999         self.assertEqual(
3000             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='1']").attrib[
3001                 "value"
3002             ],
3003             "24",
3004         )
3005         self.assertEqual(
3006             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='2']").attrib[
3007                 "value"
3008             ],
3009             "25",
3010         )
3011         self.assertEqual(
3012             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='3']"),
3013             None,
3014         )
3015     def test_update_memtune_params(self):
3016         xml_with_memtune_params = """
3017             &lt;domain type='kvm' id='8'&gt;
3018               &lt;name&gt;vm_with_boot_param&lt;/name&gt;
3019               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
3020               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
3021               &lt;maxMemory slots="12" unit="bytes"&gt;1048576&lt;/maxMemory&gt;
3022               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
3023               &lt;memtune&gt;
3024                 &lt;hard_limit unit="KiB"&gt;1048576&lt;/hard_limit&gt;
3025                 &lt;soft_limit unit="KiB"&gt;2097152&lt;/soft_limit&gt;
3026                 &lt;swap_hard_limit unit="KiB"&gt;2621440&lt;/swap_hard_limit&gt;
3027                 &lt;min_guarantee unit='KiB'&gt;671088&lt;/min_guarantee&gt;
3028               &lt;/memtune&gt;
3029               &lt;os&gt;
3030                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
3031               &lt;/os&gt;
3032             &lt;/domain&gt;
3033         """
3034         domain_mock = self.set_mock_vm("vm_with_memtune_param", xml_with_memtune_params)
3035         domain_mock.OSType = MagicMock(return_value="hvm")
3036         define_mock = MagicMock(return_value=True)
3037         self.mock_conn.defineXML = define_mock
3038         memtune_new_val = {
3039             "boot": "0.7g",
3040             "current": "2.5g",
3041             "max": "3096m",
3042             "slots": "10",
3043             "soft_limit": "2048m",
3044             "hard_limit": "1024",
3045             "swap_hard_limit": "2.5g",
3046             "min_guarantee": "1 g",
3047         }
3048         domain_mock.setMemoryFlags.return_value = 0
3049         self.assertEqual(
3050             {
3051                 "definition": True,
3052                 "disk": {"attached": [], "detached": [], "updated": []},
3053                 "interface": {"attached": [], "detached": []},
3054                 "mem": True,
3055             },
3056             virt.update("vm_with_memtune_param", mem=memtune_new_val),
3057         )
3058         self.assertEqual(
3059             domain_mock.setMemoryFlags.call_args[0][0], int(2.5 * 1024 ** 2)
3060         )
3061         setxml = ET.fromstring(define_mock.call_args[0][0])
3062         self.assertEqual(
3063             setxml.find("memtune").find("soft_limit").text, str(2048 * 1024)
3064         )
3065         self.assertEqual(
3066             setxml.find("memtune").find("hard_limit").text, str(1024 * 1024)
3067         )
3068         self.assertEqual(
3069             setxml.find("memtune").find("swap_hard_limit").text,
3070             str(int(2.5 * 1024 ** 2)),
3071         )
3072         self.assertEqual(
3073             setxml.find("memtune").find("swap_hard_limit").get("unit"),
3074             "KiB",
3075         )
3076         self.assertEqual(
3077             setxml.find("memtune").find("min_guarantee").text, str(1 * 1024 ** 3)
3078         )
3079         self.assertEqual(
3080             setxml.find("memtune").find("min_guarantee").attrib.get("unit"), "bytes"
3081         )
3082         self.assertEqual(setxml.find("maxMemory").text, str(3096 * 1024 ** 2))
3083         self.assertEqual(setxml.find("maxMemory").attrib.get("slots"), "10")
3084         self.assertEqual(setxml.find("currentMemory").text, str(int(2.5 * 1024 ** 3)))
3085         self.assertEqual(setxml.find("memory").text, str(int(0.7 * 1024 ** 3)))
3086         max_slot_reverse = {
3087             "slots": "10",
3088             "max": "3096m",
3089         }
3090         self.assertEqual(
3091             {
3092                 "definition": True,
3093                 "disk": {"attached": [], "detached": [], "updated": []},
3094                 "interface": {"attached": [], "detached": []},
3095             },
3096             virt.update("vm_with_memtune_param", mem=max_slot_reverse),
3097         )
3098         setxml = ET.fromstring(define_mock.call_args[0][0])
3099         self.assertEqual(setxml.find("maxMemory").text, str(3096 * 1024 ** 2))
3100         self.assertEqual(setxml.find("maxMemory").get("unit"), "bytes")
3101         self.assertEqual(setxml.find("maxMemory").attrib.get("slots"), "10")
3102         max_swap_none = {
3103             "boot": "0.7g",
3104             "current": "2.5g",
3105             "max": None,
3106             "slots": "10",
3107             "soft_limit": "2048m",
3108             "hard_limit": "1024",
3109             "swap_hard_limit": None,
3110             "min_guarantee": "1 g",
3111         }
3112         domain_mock.setMemoryFlags.reset_mock()
3113         self.assertEqual(
3114             {
3115                 "definition": True,
3116                 "disk": {"attached": [], "detached": [], "updated": []},
3117                 "interface": {"attached": [], "detached": []},
3118                 "mem": True,
3119             },
3120             virt.update("vm_with_memtune_param", mem=max_swap_none),
3121         )
3122         self.assertEqual(
3123             domain_mock.setMemoryFlags.call_args[0][0], int(2.5 * 1024 ** 2)
3124         )
3125         setxml = ET.fromstring(define_mock.call_args[0][0])
3126         self.assertEqual(
3127             setxml.find("memtune").find("soft_limit").text, str(2048 * 1024)
3128         )
3129         self.assertEqual(
3130             setxml.find("memtune").find("hard_limit").text, str(1024 * 1024)
3131         )
3132         self.assertEqual(setxml.find("memtune").find("swap_hard_limit"), None)
3133         self.assertEqual(
3134             setxml.find("memtune").find("min_guarantee").text, str(1 * 1024 ** 3)
3135         )
3136         self.assertEqual(
3137             setxml.find("memtune").find("min_guarantee").attrib.get("unit"), "bytes"
3138         )
3139         self.assertEqual(setxml.find("maxMemory").text, None)
3140         self.assertEqual(setxml.find("currentMemory").text, str(int(2.5 * 1024 ** 3)))
3141         self.assertEqual(setxml.find("memory").text, str(int(0.7 * 1024 ** 3)))
3142         memtune_none = {
3143             "soft_limit": None,
3144             "hard_limit": None,
3145             "swap_hard_limit": None,
3146             "min_guarantee": None,
3147         }
3148         self.assertEqual(
3149             {
3150                 "definition": True,
3151                 "disk": {"attached": [], "detached": [], "updated": []},
3152                 "interface": {"attached": [], "detached": []},
3153             },
3154             virt.update("vm_with_memtune_param", mem=memtune_none),
3155         )
3156         setxml = ET.fromstring(define_mock.call_args[0][0])
3157         self.assertEqual(setxml.find("memtune").find("soft_limit"), None)
3158         self.assertEqual(setxml.find("memtune").find("hard_limit"), None)
3159         self.assertEqual(setxml.find("memtune").find("swap_hard_limit"), None)
3160         self.assertEqual(setxml.find("memtune").find("min_guarantee"), None)
3161         max_none = {
3162             "max": None,
3163         }
3164         self.assertEqual(
3165             {
3166                 "definition": True,
3167                 "disk": {"attached": [], "detached": [], "updated": []},
3168                 "interface": {"attached": [], "detached": []},
3169             },
3170             virt.update("vm_with_memtune_param", mem=max_none),
3171         )
3172         setxml = ET.fromstring(define_mock.call_args[0][0])
3173         self.assertEqual(setxml.find("maxMemory"), None)
3174         self.assertEqual(setxml.find("currentMemory").text, str(int(1 * 1024 ** 2)))
3175         self.assertEqual(setxml.find("memory").text, str(int(1 * 1024 ** 2)))
3176     def test_update_exist_memorybacking_params(self):
3177         xml_with_memback_params = """
3178             &lt;domain type='kvm' id='8'&gt;
3179               &lt;name&gt;vm_with_memback_param&lt;/name&gt;
3180               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
3181               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
3182               &lt;maxMemory slots="12" unit="KiB"&gt;1048576&lt;/maxMemory&gt;
3183               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
3184               &lt;memoryBacking&gt;
3185                 &lt;hugepages&gt;
3186                   &lt;page size="2048" unit="KiB"/&gt;
3187                   &lt;page size="3145728" nodeset="1-4,^3" unit="KiB"/&gt;
3188                   &lt;page size="1048576" nodeset="3" unit="KiB"/&gt;
3189                 &lt;/hugepages&gt;
3190                 &lt;nosharepages/&gt;
3191                 &lt;locked/&gt;
3192                 &lt;source type="file"/&gt;
3193                 &lt;access mode="shared"/&gt;
3194                 &lt;discard/&gt;
3195               &lt;/memoryBacking&gt;
3196               &lt;os&gt;
3197                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
3198               &lt;/os&gt;
3199               &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
3200             &lt;/domain&gt;
3201         """
3202         domain_mock = self.set_mock_vm("vm_with_memback_param", xml_with_memback_params)
3203         domain_mock.OSType = MagicMock(return_value="hvm")
3204         define_mock = MagicMock(return_value=True)
3205         self.mock_conn.defineXML = define_mock
3206         mem_back_param = {
3207             "hugepages": [
3208                 {"nodeset": "1-4,^3", "size": "1g"},
3209                 {"nodeset": "3", "size": "2g"},
3210             ],
3211             "nosharepages": None,
3212             "locked": None,
3213             "source": "anonymous",
3214             "access": "private",
3215             "allocation": "ondemand",
3216             "discard": None,
3217         }
3218         self.assertEqual(
3219             {
3220                 "definition": True,
3221                 "disk": {"attached": [], "detached": [], "updated": []},
3222                 "interface": {"attached": [], "detached": []},
3223             },
3224             virt.update("vm_with_memback_param", mem=mem_back_param),
3225         )
3226         setxml = ET.fromstring(define_mock.call_args[0][0])
3227         self.assertDictEqual(
3228             {
3229                 p.get("nodeset"): {"size": p.get("size"), "unit": p.get("unit")}
3230                 for p in setxml.findall("memoryBacking/hugepages/page")
3231             },
3232             {
3233                 "1,2,4": {"size": str(1024 ** 3), "unit": "bytes"},
3234                 "3": {"size": str(2 * 1024 ** 3), "unit": "bytes"},
3235             },
3236         )
3237         self.assertEqual(setxml.find("./memoryBacking/nosharepages"), None)
3238         self.assertEqual(setxml.find("./memoryBacking/locked"), None)
3239         self.assertEqual(
3240             setxml.find("./memoryBacking/source").attrib["type"], "anonymous"
3241         )
3242         self.assertEqual(
3243             setxml.find("./memoryBacking/access").attrib["mode"], "private"
3244         )
3245         self.assertEqual(
3246             setxml.find("./memoryBacking/allocation").attrib["mode"], "ondemand"
3247         )
3248         self.assertEqual(setxml.find("./memoryBacking/discard"), None)
3249         unchanged_page = {
3250             "hugepages": [
3251                 {"size": "2m"},
3252                 {"nodeset": "1-4,^3", "size": "3g"},
3253                 {"nodeset": "3", "size": "1g"},
3254             ],
3255         }
3256         self.assertEqual(
3257             {
3258                 "definition": False,
3259                 "disk": {"attached": [], "detached": [], "updated": []},
3260                 "interface": {"attached": [], "detached": []},
3261             },
3262             virt.update("vm_with_memback_param", mem=unchanged_page),
3263         )
3264     def test_update_iothreads_params(self):
3265         xml_with_iothreads_params = """
3266             &lt;domain type='kvm' id='8'&gt;
3267               &lt;name&gt;xml_with_iothreads_params&lt;/name&gt;
3268               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
3269               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
3270               &lt;maxMemory slots="12" unit="KiB"&gt;1048576&lt;/maxMemory&gt;
3271               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
3272               &lt;iothreads&gt;6&lt;/iothreads&gt;
3273               &lt;os&gt;
3274                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
3275               &lt;/os&gt;
3276             &lt;/domain&gt;
3277         """
3278         domain_mock = self.set_mock_vm(
3279             "xml_with_iothreads_params", xml_with_iothreads_params
3280         )
3281         domain_mock.OSType = MagicMock(return_value="hvm")
3282         define_mock = MagicMock(return_value=True)
3283         self.mock_conn.defineXML = define_mock
3284         self.assertEqual(
3285             {
3286                 "definition": True,
3287                 "disk": {"attached": [], "detached": [], "updated": []},
3288                 "interface": {"attached": [], "detached": []},
3289             },
3290             virt.update("xml_with_iothreads_params", cpu={"iothreads": 7}),
3291         )
3292         setxml = ET.fromstring(define_mock.call_args[0][0])
3293         self.assertEqual(setxml.find("iothreads").text, "7")
3294     def test_update_cputune_paramters(self):
3295         xml_with_cputune_params = """
3296                     &lt;domain type='kvm' id='8'&gt;
3297                       &lt;name&gt;xml_with_cputune_params&lt;/name&gt;
3298                       &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
3299                       &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
3300                       &lt;maxMemory slots="12" unit="KiB"&gt;1048576&lt;/maxMemory&gt;
3301                       &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
3302                       &lt;iothreads&gt;4&lt;/iothreads&gt;
3303                       &lt;cputune&gt;
3304                         &lt;shares&gt;2048&lt;/shares&gt;
3305                         &lt;period&gt;1000000&lt;/period&gt;
3306                         &lt;quota&gt;-1&lt;/quota&gt;
3307                         &lt;global_period&gt;1000000&lt;/global_period&gt;
3308                         &lt;global_quota&gt;-1&lt;/global_quota&gt;
3309                         &lt;emulator_period&gt;1000000&lt;/emulator_period&gt;
3310                         &lt;emulator_quota&gt;-1&lt;/emulator_quota&gt;
3311                         &lt;iothread_period&gt;1000000&lt;/iothread_period&gt;
3312                         &lt;iothread_quota&gt;-1&lt;/iothread_quota&gt;
3313                         &lt;vcpupin vcpu="0" cpuset="0-2"/&gt;
3314                         &lt;vcpupin vcpu="1" cpuset="3"/&gt;
3315                         &lt;vcpupin vcpu="2" cpuset="4"/&gt;
3316                         &lt;vcpupin vcpu="3" cpuset="5-7"/&gt;
3317                         &lt;emulatorpin cpuset="1-2"/&gt;
3318                         &lt;iothreadpin iothread="1" cpuset="1-5"/&gt;
3319                         &lt;iothreadpin iothread="2" cpuset="6-7"/&gt;
3320                         &lt;vcpusched vcpus="0" scheduler="idle" priority="3"/&gt;
3321                         &lt;vcpusched vcpus="1" scheduler="rr" priority="1"/&gt;
3322                         &lt;vcpusched vcpus="2" scheduler="fifo" priority="2"/&gt;
3323                         &lt;iothreadsched iothreads="4" scheduler="fifo"/&gt;
3324                         &lt;emulatorsched scheduler="idle"/&gt;
3325                         &lt;cachetune vcpus="0-4"&gt;
3326                           &lt;cache id="0" level="2" type="both" size="4" unit="KiB"/&gt;
3327                           &lt;cache id="1" level="2" type="both" size="4" unit="KiB"/&gt;
3328                           &lt;monitor level="5" vcpus="0-2"/&gt;
3329                           &lt;monitor level="6" vcpus="1-3"/&gt;
3330                         &lt;/cachetune&gt;
3331                         &lt;cachetune vcpus="5-8"&gt;
3332                           &lt;monitor level="5" vcpus="5-6"/&gt;
3333                           &lt;monitor level="3" vcpus="7-8"/&gt;
3334                         &lt;/cachetune&gt;
3335                         &lt;memorytune vcpus="0-6"&gt;
3336                           &lt;node id="0" bandwidth="45"/&gt;
3337                         &lt;/memorytune&gt;
3338                         &lt;memorytune vcpus="7-8"&gt;
3339                           &lt;node id="0" bandwidth="120"/&gt;
3340                         &lt;/memorytune&gt;
3341                       &lt;/cputune&gt;
3342                       &lt;os&gt;
3343                         &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
3344                       &lt;/os&gt;
3345                     &lt;/domain&gt;
3346                 """
3347         domain_mock = self.set_mock_vm(
3348             "xml_with_cputune_params", xml_with_cputune_params
3349         )
3350         domain_mock.OSType = MagicMock(return_value="hvm")
3351         define_mock = MagicMock(return_value=True)
3352         self.mock_conn.defineXML = define_mock
3353         cputune = {
3354             <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"shares": 1024,
3355             "period": 5000,
3356             "quota": -20,
3357             "global_period": 4000,
3358             "global_quota": -30,
3359             "emulator_period": 3000,
3360             "emulator_quota": -4,
3361             "iothread_period": 7000,
3362             "iothread_quota": -5,
3363             "vcpupin": {0: "1-4,^2", 1: "0,1", 2: "2,3", 3: "0,4"},
3364             "emulatorpin": "1-3",
3365             "iothreadpin": {1: "5-6", 2: "7-8"},
3366             "vcpusched": [
3367                 {"scheduler": "fifo", "priority": 1, "vcpus": "0"},
3368                 {"scheduler": "fifo", "priority": 2, "vcpus": "1"},
3369                 {"scheduler": "idle", "priority": 3, "vcpus": "2"},
3370             ],
3371             "iothreadsched": [
3372                 {"scheduler": "batch", "iothreads": "5-7", "priority": 1}
3373             ],
3374             "emulatorsched": {"scheduler": "rr", "priority": 2},
3375             "cachetune": {
3376                 "0-3": {
3377                     0: {"level": 3, "type": "both", "size": 3},
3378                     1: {"level": 3, "type": "both", "size": 3},
3379                     "monitor": {1: 3, "0-3": 3},
3380                 },
3381                 "4-5": {"monitor": {4: 3, 5: 2}},
3382             },
3383             "memorytune": {"0-2": {0: 60}, "3-4": {0: 50, 1: 70}},
3384         }
3385         self.assertEqual(
3386             {
3387                 "definition": True,
3388                 "disk": {"attached": [], "detached": [], "updated": []},
3389                 "interface": {"attached": [], "detached": []},
3390             },
3391             virt.</b></font>update("xml_with_cputune_params", cpu={"tuning": cputune}),
3392         )
3393         setxml = ET.fromstring(define_mock.call_args[0][0])
3394         self.assertEqual(setxml.find("cputune").find("shares").text, "1024")
3395         self.assertEqual(setxml.find("cputune").find("period").text, "5000")
3396         self.assertEqual(setxml.find("cputune").find("quota").text, "-20")
3397         self.assertEqual(setxml.find("cputune").find("global_period").text, "4000")
3398         self.assertEqual(setxml.find("cputune").find("global_quota").text, "-30")
3399         self.assertEqual(setxml.find("cputune").find("emulator_period").text, "3000")
3400         self.assertEqual(setxml.find("cputune").find("emulator_quota").text, "-4")
3401         self.assertEqual(setxml.find("cputune").find("iothread_period").text, "7000")
3402         self.assertEqual(setxml.find("cputune").find("iothread_quota").text, "-5")
3403         self.assertEqual(
3404             setxml.find("cputune").find("vcpupin[@vcpu='0']").attrib.get("cpuset"),
3405             "1,3,4",
3406         )
3407         self.assertEqual(
3408             setxml.find("cputune").find("vcpupin[@vcpu='1']").attrib.get("cpuset"),
3409             "0,1",
3410         )
3411         self.assertEqual(
3412             setxml.find("cputune").find("vcpupin[@vcpu='2']").attrib.get("cpuset"),
3413             "2,3",
3414         )
3415         self.assertEqual(
3416             setxml.find("cputune").find("vcpupin[@vcpu='3']").attrib.get("cpuset"),
3417             "0,4",
3418         )
3419         self.assertEqual(
3420             setxml.find("cputune").find("emulatorpin").attrib.get("cpuset"), "1,2,3"
3421         )
3422         self.assertEqual(
3423             setxml.find("cputune")
3424             .find("iothreadpin[@iothread='1']")
3425             .attrib.get("cpuset"),
3426             "5,6",
3427         )
3428         self.assertEqual(
3429             setxml.find("cputune")
3430             .find("iothreadpin[@iothread='2']")
3431             .attrib.get("cpuset"),
3432             "7,8",
3433         )
3434         self.assertDictEqual(
3435             {
3436                 s.get("vcpus"): {
3437                     "priority": s.get("priority"),
3438                 }
3439                 for s in setxml<font color="#4cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.findall("cputune/vcpusched")
3440             },
3441             {
3442                 "0": {"scheduler": "fifo", "priority": "1"},
3443                 "1": {"scheduler": "fifo", "priority": "2"},
3444                 "2": {"scheduler": "idle", "priority": "3"},
3445             },
3446         )
3447         self.assertDictEqual(
3448             {
3449                 s.get("iothreads"): {
3450                     "scheduler": s.</b></font>get("scheduler"),
3451                     "priority": s.get("priority"),
3452                 }
3453                 for s in setxml.findall("cputune/iothreadsched")
3454             },
3455             {"5,6,7": {"scheduler": "batch", "priority": "1"}},
3456         )
3457         self.assertEqual(setxml.find("cputune/emulatorsched").get("scheduler"), "rr")
3458         self.assertEqual(setxml.find("cputune/emulatorsched").get("priority"), "2")
3459         self.assertIsNotNone(setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']"))
3460         self.assertEqual(
3461             setxml.find(
3462                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3463             ).attrib.get("level"),
3464             "3",
3465         )
3466         self.assertEqual(
3467             setxml.find(
3468                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3469             ).attrib.get("type"),
3470             "both",
3471         )
3472         self.assertEqual(
3473             setxml.find(
3474                 "./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='1']"
3475             ).attrib.get("level"),
3476             "3",
3477         )
3478         self.assertNotEqual(
3479             setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='1']"),
3480             None,
3481         )
3482         self.assertNotEqual(
3483             setxml.find("./cputune/cachetune[@vcpus='4,5']").attrib.get("vcpus"), None
3484         )
3485         self.assertEqual(
3486             setxml.find("./cputune/cachetune[@vcpus='4,5']/cache[@id='0']"), None
3487         )
3488         self.assertEqual(
3489             setxml.find(
3490                 "./cputune/cachetune[@vcpus='4,5']/monitor[@vcpus='4']"
3491             ).attrib.get("level"),
3492             "3",
3493         )
3494         self.assertEqual(
3495             setxml.find(
3496                 "./cputune/cachetune[@vcpus='4,5']/monitor[@vcpus='5']"
3497             ).attrib.get("level"),
3498             "2",
3499         )
3500         self.assertNotEqual(setxml.find("./cputune/memorytune[@vcpus='0,1,2']"), None)
3501         self.assertEqual(
3502             setxml.find(
3503                 "./cputune/memorytune[@vcpus='0,1,2']/node[@id='0']"
3504             ).attrib.get("bandwidth"),
3505             "60",
3506         )
3507         self.assertNotEqual(setxml.find("./cputune/memorytune[@vcpus='3,4']"), None)
3508         self.assertEqual(
3509             setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='0']").attrib.get(
3510                 "bandwidth"
3511             ),
3512             "50",
3513         )
3514         self.assertEqual(
3515             setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='1']").attrib.get(
3516                 "bandwidth"
3517             ),
3518             "70",
3519         )
3520         cputune = {
3521             <font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"shares": None,
3522             "period": 20000,
3523             "quota": None,
3524             "global_period": 5000,
3525             "global_quota": None,
3526             "emulator_period": 2000,
3527             "emulator_quota": -4,
3528             "iothread_period": None,
3529             "iothread_quota": -5,
3530             "vcpupin": {0: "1-4,^2", 2: "2,4"},
3531             "emulatorpin": None,
3532             "iothreadpin": {1: "5-6"},
3533             "vcpusched": [{"scheduler": "idle", "priority": 5, "vcpus": "1"}],
3534             "iothreadsched": None,
3535             "cachetune": {
3536                 "0-3": {
3537                     0: {"level": 4, "type": "data", "size": 7},
3538                     "monitor": {"1-2": 11},
3539                 },
3540             },
3541             "memorytune": {"3-4": {0: 37, 1: 73}},
3542         }
3543         self.assertEqual(
3544             {
3545                 "definition": True,
3546                 "disk": {"attached": [], "detached": [], "updated": []},
3547                 "interface": {"attached": [], "detached": []},
3548             },
3549             virt.</b></font>update("xml_with_cputune_params", cpu={"tuning": cputune}),
3550         )
3551         setxml = ET.fromstring(define_mock.call_args[0][0])
3552         self.assertEqual(setxml.find("cputune").find("shares"), None)
3553         self.assertEqual(setxml.find("cputune").find("period").text, "20000")
3554         self.assertEqual(setxml.find("cputune").find("quota"), None)
3555         self.assertEqual(setxml.find("cputune").find("global_period").text, "5000")
3556         self.assertEqual(setxml.find("cputune").find("global_quota"), None)
3557         self.assertEqual(setxml.find("cputune").find("emulator_period").text, "2000")
3558         self.assertEqual(setxml.find("cputune").find("emulator_quota").text, "-4")
3559         self.assertEqual(setxml.find("cputune").find("iothread_period"), None)
3560         self.assertEqual(setxml.find("cputune").find("iothread_quota").text, "-5")
3561         self.assertEqual(
3562             setxml.find("cputune").find("vcpupin[@vcpu='0']").attrib.get("cpuset"),
3563             "1,3,4",
3564         )
3565         self.assertEqual(setxml.find("cputune").find("vcpupin[@vcpu='1']"), None)
3566         self.assertEqual(
3567             setxml.find("cputune").find("vcpupin[@vcpu='2']").attrib.get("cpuset"),
3568             "2,4",
3569         )
3570         self.assertEqual(setxml.find("cputune").find("vcpupin[@vcpu='3']"), None)
3571         self.assertEqual(setxml.find("cputune").find("emulatorpin"), None)
3572         self.assertEqual(
3573             setxml.find("cputune")
3574             .find("iothreadpin[@iothread='1']")
3575             .attrib.get("cpuset"),
3576             "5,6",
3577         )
3578         self.assertEqual(
3579             setxml.find("cputune").find("iothreadpin[@iothread='2']"), None
3580         )
3581         self.assertDictEqual(
3582             {
3583                 s.get("vcpus"): {
3584                     "scheduler": s.get("scheduler"),
3585                     "priority": s.get("priority"),
3586                 }
3587                 for s in setxml.findall("cputune/vcpusched")
3588             },
3589             {"1": {"scheduler": "idle", "priority": "5"}},
3590         )
3591         self.assertEqual(setxml.find("cputune").find("iothreadsched"), None)
3592         self.assertIsNotNone(setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']"))
3593         self.assertEqual(
3594             setxml.find(
3595                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3596             ).attrib.get("size"),
3597             "7",
3598         )
3599         self.assertEqual(
3600             setxml.find(
3601                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3602             ).attrib.get("level"),
3603             "4",
3604         )
3605         self.assertEqual(
3606             setxml.find(
3607                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3608             ).attrib.get("type"),
3609             "data",
3610         )
3611         self.assertEqual(
3612             setxml.find(
3613                 "./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='1,2']"
3614             ).attrib.get("level"),
3615             "11",
3616         )
3617         self.assertEqual(
3618             setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='3,4']"),
3619             None,
3620         )
3621         self.assertEqual(
3622             setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='1']"), None
3623         )
3624         self.assertEqual(setxml.find("./cputune/cachetune[@vcpus='4,5']"), None)
3625         self.assertEqual(setxml.find("./cputune/memorytune[@vcpus='0,1,2']"), None)
3626         self.assertEqual(
3627             setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='0']").attrib.get(
3628                 "bandwidth"
3629             ),
3630             "37",
3631         )
3632         self.assertEqual(
3633             setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='1']").attrib.get(
3634                 "bandwidth"
3635             ),
3636             "73",
3637         )
3638         cputune_subelement = {
3639             "vcpupin": None,
3640             "iothreadpin": None,
3641             "vcpusched": None,
3642             "iothreadsched": None,
3643             "cachetune": None,
3644             "memorytune": None,
3645         }
3646         self.assertEqual(
3647             {
3648                 "definition": True,
3649                 "disk": {"attached": [], "detached": [], "updated": []},
3650                 "interface": {"attached": [], "detached": []},
3651             },
3652             virt.update("xml_with_cputune_params", cpu={"tuning": cputune_subelement}),
3653         )
3654         setxml = ET.fromstring(define_mock.call_args[0][0])
3655         self.assertEqual(setxml.find("cputune").find("vcpupin"), None)
3656         self.assertEqual(setxml.find("cputune").find("iothreadpin"), None)
3657         self.assertEqual(setxml.find("cputune").find("vcpusched"), None)
3658         self.assertEqual(setxml.find("cputune").find("iothreadsched"), None)
3659         self.assertEqual(setxml.find("cputune").find("cachetune"), None)
3660         self.assertEqual(setxml.find("cputune").find("memorytune"), None)
3661     def test_handle_unit(self):
3662         valid_case = [
3663             ("2", 2097152),
3664             ("42", 44040192),
3665             ("5b", 5),
3666             ("2.3Kib", 2355),
3667             ("5.8Kb", 5800),
3668             ("16MiB", 16777216),
3669             ("20 GB", 20000000000),
3670             ("16KB", 16000),
3671             (".5k", 512),
3672             ("2.k", 2048),
3673         ]
3674         for key, val in valid_case:
3675             self.assertEqual(virt._handle_unit(key), val)
3676         invalid_case = [
3677             ("9ib", "invalid units"),
3678             ("8byte", "invalid units"),
3679             ("512bytes", "invalid units"),
3680             ("4 Kbytes", "invalid units"),
3681             ("3.4.MB", "invalid number"),
3682             ("", "invalid number"),
3683             ("bytes", "invalid number"),
3684             ("2HB", "invalid units"),
3685         ]
3686         for key, val in invalid_case:
3687             with self.assertRaises(SaltInvocationError):
3688                 virt._handle_unit(key)
3689     def test_mixed_dict_and_list_as_profile_objects(self):
3690         yaml_config = """
3691           virt:
3692              nic:
3693                 new-listonly-profile:
3694                    - bridge: br0
3695                      name: eth0
3696                    - model: virtio
3697                      name: eth1
3698                      source: test_network
3699                      type: network
3700                 new-list-with-legacy-names:
3701                    - eth0:
3702                         bridge: br0
3703                    - eth1:
3704                         bridge: br1
3705                         model: virtio
3706                 non-default-legacy-profile:
3707                    eth0:
3708                       bridge: br0
3709                    eth1:
3710                       bridge: br1
3711                       model: virtio
3712         Test virt.get_xml()
3713         domain = self.set_mock_vm("test-vm", xml)
3714         self.assertEqual(xml, virt.get_xml("test-vm"))
3715         self.assertEqual(xml, virt.get_xml(domain))
3716     def test_get_loader(self):
3717         xml = """&lt;domain type='kvm' id='7'&gt;
3718               &lt;name&gt;test-vm&lt;/name&gt;
3719               &lt;os&gt;
3720                 &lt;loader readonly='yes' type='pflash'&gt;/foo/bar&lt;/loader&gt;
3721               &lt;/os&gt;
3722             &lt;/domain&gt;
3723         """
3724         self.set_mock_vm("test-vm", xml)
3725         loader = virt.get_loader("test-vm")
3726         self.assertEqual("/foo/bar", loader["path"])
3727         self.assertEqual("yes", loader["readonly"])
3728     def test_cpu_baseline(self):
3729         capabilities_xml = dedent(
3730         Make sure that qemu-img info output is properly parsed
3731         Test virt.purge() with default parameters
3732         self.set_mock_vm("test-vm", xml)
3733         qemu_infos = """[{
3734             "virtual-size": 25769803776,
3735             "filename": "/disks/test.qcow2",
3736             "cluster-size": 65536,
3737             "format": "qcow2",
3738             "actual-size": 217088,
3739             "format-specific": {
3740                 "type": "qcow2",
3741                 "data": {
3742                     "compat": "1.1",
3743                     "lazy-refcounts": false,
3744                     "refcount-bits": 16,
3745                     "corrupt": false
3746                 }
3747             },
3748             "dirty-flag": false
3749         }]"""
3750         self.mock_popen.communicate.return_value = [qemu_infos, ""]
3751         self.mock_popen.returncode = 0
3752         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
3753             res = virt.purge("test-vm")
3754             self.assertTrue(res)
3755             mock_remove.assert_called_once()
3756             mock_remove.assert_any_call("/disks/test.qcow2")
3757     @patch("salt.modules.virt.stop", return_value=True)
3758     @patch("salt.modules.virt.undefine")
3759     def test_purge_volumes(self, mock_undefine, mock_stop):
3760         xml = """&lt;domain type='kvm' id='7'&gt;
3761               &lt;name&gt;test-vm&lt;/name&gt;
3762               &lt;devices&gt;
3763                 &lt;disk type='volume' device='disk'&gt;
3764                   &lt;driver name='qemu' type='qcow2' cache='none' io='native'/&gt;
3765                   &lt;source pool='default' volume='vm05_system'/&gt;
3766                   &lt;backingStore type='file' index='1'&gt;
3767                     &lt;format type='qcow2'/&gt;
3768                     &lt;source file='/var/lib/libvirt/images/vm04_system.qcow2'/&gt;
3769                     &lt;backingStore type='file' index='2'&gt;
3770                       &lt;format type='qcow2'/&gt;
3771                       &lt;source file='/var/testsuite-data/disk-image-template.qcow2'/&gt;
3772                       &lt;backingStore/&gt;
3773                     &lt;/backingStore&gt;
3774                   &lt;/backingStore&gt;
3775                   &lt;target dev='vda' bus='virtio'/&gt;
3776                   &lt;alias name='virtio-disk0'/&gt;
3777                   &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x04' function='0x0'/&gt;
3778                 &lt;/disk&gt;
3779               &lt;/devices&gt;
3780             &lt;/domain&gt;
3781         """
3782         self.set_mock_vm("test-vm", xml)
3783         pool_mock = MagicMock()
3784         pool_mock.storageVolLookupByName.return_value.info.return_value = [
3785             0,
3786             1234567,
3787             12345,
3788         ]
3789         pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = [
3790         ]
3791         pool_mock.listVolumes.return_value = ["vm05_system", "vm04_system.qcow2"]
3792         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
3793         self.mock_conn.listStoragePools.return_value = ["default"]
3794         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=False)}):
3795             res = virt.purge("test-vm")
3796             self.assertTrue(res)
3797             pool_mock.storageVolLookupByName.return_value.delete.assert_called_once()
3798     @patch("salt.modules.virt.stop", return_value=True)
3799     @patch("salt.modules.virt.undefine")
3800     def test_purge_rbd(self, mock_undefine, mock_stop):
3801         xml = """&lt;domain type='kvm' id='7'&gt;
3802               &lt;name&gt;test-vm&lt;/name&gt;
3803               &lt;devices&gt;
3804                 &lt;disk type="network" device="disk"&gt;
3805                   &lt;driver name='raw' type='qcow2'/&gt;
3806                   &lt;source protocol='rbd' name='libvirt-pool/my_vm_data2'&gt;
3807                     &lt;host name='ses2.tf.local'/&gt;
3808                     &lt;host name='ses3.tf.local' port='1234'/&gt;
3809                     &lt;auth username='libvirt'&gt;
3810                       &lt;secret type='ceph' usage='pool_test-rbd'/&gt;
3811                     &lt;/auth&gt;
3812                   &lt;/source&gt;
3813                   &lt;target dev='vdc' bus='virtio'/&gt;
3814                   &lt;alias name='virtio-disk2'/&gt;
3815                   &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x07' function='0x2'/&gt;
3816                 &lt;/disk&gt;
3817               &lt;/devices&gt;
3818             &lt;/domain&gt;
3819         """
3820         self.set_mock_vm("test-vm", xml)
3821         pool_mock = MagicMock()
3822         pool_mock.storageVolLookupByName.return_value.info.return_value = [
3823             0,
3824             1234567,
3825             12345,
3826         ]
3827         pool_mock.XMLDesc.return_value = """
3828         &lt;pool type='rbd'&gt;
3829           &lt;name&gt;test-ses&lt;/name&gt;
3830           &lt;source&gt;
3831             &lt;host name='ses2.tf.local'/&gt;
3832             &lt;name&gt;libvirt-pool&lt;/name&gt;
3833             &lt;auth type='ceph' username='libvirt'&gt;
3834               &lt;secret usage='pool_test-ses'/&gt;
3835             &lt;/auth&gt;
3836           &lt;/source&gt;
3837         &lt;/pool&gt;
3838         """
3839         pool_mock.name.return_value = "test-ses"
3840         pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = [
3841         ]
3842         pool_mock.listVolumes.return_value = ["my_vm_data2"]
3843         self.mock_conn.listAllStoragePools.return_value = [pool_mock]
3844         self.mock_conn.listStoragePools.return_value = ["test-ses"]
3845         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
3846         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=False)}):
3847             res = virt.purge("test-vm")
3848             self.assertTrue(res)
3849             pool_mock.storageVolLookupByName.return_value.delete.assert_called_once()
3850     @patch("salt.modules.virt.stop", return_value=True)
3851     @patch("salt.modules.virt.undefine")
3852     @patch("os.remove")
3853     def test_purge_removable(self, mock_remove, mock_undefine, mock_stop):
3854         xml = """&lt;domain type="kvm" id="7"&gt;
3855               &lt;name&gt;test-vm&lt;/name&gt;
3856               &lt;devices&gt;
3857                 &lt;disk type='file' device='disk'&gt;
3858                 &lt;driver name='qemu' type='qcow2'/&gt;
3859                 &lt;source file='/disks/test.qcow2'/&gt;
3860                 &lt;target dev='vda' bus='virtio'/&gt;
3861               &lt;/disk&gt;
3862               &lt;disk type='file' device='cdrom'&gt;
3863                 &lt;driver name='qemu' type='raw'/&gt;
3864                 &lt;source file='/disks/test-cdrom.iso'/&gt;
3865                 &lt;target dev='hda' bus='ide'/&gt;
3866                 &lt;readonly/&gt;
3867               &lt;/disk&gt;
3868               &lt;disk type='file' device='floppy'&gt;
3869                 &lt;driver name='qemu' type='raw'/&gt;
3870                 &lt;source file='/disks/test-floppy.iso'/&gt;
3871                 &lt;target dev='hdb' bus='ide'/&gt;
3872                 &lt;readonly/&gt;
3873               &lt;/disk&gt;
3874               &lt;/devices&gt;
3875             &lt;/domain&gt;
3876         """
3877         self.set_mock_vm("test-vm", xml)
3878         qemu_infos = """[{
3879             "virtual-size": 25769803776,
3880             "filename": "/disks/test.qcow2",
3881             "cluster-size": 65536,
3882             "format": "qcow2",
3883             "actual-size": 217088,
3884             "format-specific": {
3885                 "type": "qcow2",
3886                 "data": {
3887                     "compat": "1.1",
3888                     "lazy-refcounts": false,
3889                     "refcount-bits": 16,
3890                     "corrupt": false
3891                 }
3892             },
3893             "dirty-flag": false
3894         }]"""
3895         self.mock_popen.communicate.return_value = [qemu_infos, ""]
3896         self.mock_popen.returncode = 0
3897         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
3898             res = virt.purge("test-vm", removables=True)
3899             self.assertTrue(res)
3900             mock_remove.assert_any_call("/disks/test.qcow2")
3901             mock_remove.assert_any_call("/disks/test-cdrom.iso")
3902     def test_capabilities(self):
3903         xml = """
3904 &lt;capabilities&gt;
3905   &lt;host&gt;
3906     &lt;uuid&gt;44454c4c-3400-105a-8033-b3c04f4b344a&lt;/uuid&gt;
3907     &lt;cpu&gt;
3908       &lt;arch&gt;x86_64&lt;/arch&gt;
3909       &lt;model&gt;Nehalem&lt;/model&gt;
3910       &lt;vendor&gt;Intel&lt;/vendor&gt;
3911       &lt;microcode version='25'/&gt;
3912       &lt;topology sockets='1' cores='4' threads='2'/&gt;
3913       &lt;feature name='vme'/&gt;
3914       &lt;feature name='ds'/&gt;
3915       &lt;feature name='acpi'/&gt;
3916       &lt;pages unit='KiB' size='4'/&gt;
3917       &lt;pages unit='KiB' size='2048'/&gt;
3918     &lt;/cpu&gt;
3919     &lt;power_management&gt;
3920       &lt;suspend_mem/&gt;
3921       &lt;suspend_disk/&gt;
3922       &lt;suspend_hybrid/&gt;
3923     &lt;/power_management&gt;
3924     &lt;migration_features&gt;
3925       &lt;live/&gt;
3926       &lt;uri_transports&gt;
3927         &lt;uri_transport&gt;tcp&lt;/uri_transport&gt;
3928         &lt;uri_transport&gt;rdma&lt;/uri_transport&gt;
3929       &lt;/uri_transports&gt;
3930     &lt;/migration_features&gt;
3931     &lt;topology&gt;
3932       &lt;cells num='1'&gt;
3933         &lt;cell id='0'&gt;
3934           &lt;memory unit='KiB'&gt;12367120&lt;/memory&gt;
3935           &lt;pages unit='KiB' size='4'&gt;3091780&lt;/pages&gt;
3936           &lt;pages unit='KiB' size='2048'&gt;0&lt;/pages&gt;
3937           &lt;distances&gt;
3938             &lt;sibling id='0' value='10'/&gt;
3939           &lt;/distances&gt;
3940           &lt;cpus num='8'&gt;
3941             &lt;cpu id='0' socket_id='0' core_id='0' siblings='0,4'/&gt;
3942             &lt;cpu id='1' socket_id='0' core_id='1' siblings='1,5'/&gt;
3943             &lt;cpu id='2' socket_id='0' core_id='2' siblings='2,6'/&gt;
3944             &lt;cpu id='3' socket_id='0' core_id='3' siblings='3,7'/&gt;
3945             &lt;cpu id='4' socket_id='0' core_id='0' siblings='0,4'/&gt;
3946             &lt;cpu id='5' socket_id='0' core_id='1' siblings='1,5'/&gt;
3947             &lt;cpu id='6' socket_id='0' core_id='2' siblings='2,6'/&gt;
3948             &lt;cpu id='7' socket_id='0' core_id='3' siblings='3,7'/&gt;
3949           &lt;/cpus&gt;
3950         &lt;/cell&gt;
3951       &lt;/cells&gt;
3952     &lt;/topology&gt;
3953     &lt;cache&gt;
3954       &lt;bank id='0' level='3' type='both' size='8' unit='MiB' cpus='0-7'/&gt;
3955     &lt;/cache&gt;
3956     &lt;secmodel&gt;
3957       &lt;model&gt;apparmor&lt;/model&gt;
3958       &lt;doi&gt;0&lt;/doi&gt;
3959     &lt;/secmodel&gt;
3960     &lt;secmodel&gt;
3961       &lt;model&gt;dac&lt;/model&gt;
3962       &lt;doi&gt;0&lt;/doi&gt;
3963       &lt;baselabel type='kvm'&gt;+487:+486&lt;/baselabel&gt;
3964       &lt;baselabel type='qemu'&gt;+487:+486&lt;/baselabel&gt;
3965     &lt;/secmodel&gt;
3966   &lt;/host&gt;
3967   &lt;guest&gt;
3968     &lt;os_type&gt;hvm&lt;/os_type&gt;
3969     &lt;arch name='i686'&gt;
3970       &lt;wordsize&gt;32&lt;/wordsize&gt;
3971       &lt;emulator&gt;/usr/bin/qemu-system-i386&lt;/emulator&gt;
3972       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
3973       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
3974       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
3975       &lt;domain type='qemu'/&gt;
3976       &lt;domain type='kvm'&gt;
3977         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
3978         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
3979         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
3980         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
3981       &lt;/domain&gt;
3982     &lt;/arch&gt;
3983     &lt;features&gt;
3984       &lt;cpuselection/&gt;
3985       &lt;deviceboot/&gt;
3986       &lt;disksnapshot default='on' toggle='no'/&gt;
3987       &lt;acpi default='off' toggle='yes'/&gt;
3988       &lt;apic default='on' toggle='no'/&gt;
3989       &lt;pae/&gt;
3990       &lt;nonpae/&gt;
3991     &lt;/features&gt;
3992   &lt;/guest&gt;
3993   &lt;guest&gt;
3994     &lt;os_type&gt;hvm&lt;/os_type&gt;
3995     &lt;arch name='x86_64'&gt;
3996       &lt;wordsize&gt;64&lt;/wordsize&gt;
3997       &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
3998       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
3999       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
4000       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
4001       &lt;domain type='qemu'/&gt;
4002       &lt;domain type='kvm'&gt;
4003         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
4004         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
4005         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
4006         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
4007       &lt;/domain&gt;
4008     &lt;/arch&gt;
4009     &lt;features&gt;
4010       &lt;cpuselection/&gt;
4011       &lt;deviceboot/&gt;
4012       &lt;disksnapshot default='on' toggle='no'/&gt;
4013       &lt;acpi default='on' toggle='yes'/&gt;
4014       &lt;apic default='off' toggle='no'/&gt;
4015     &lt;/features&gt;
4016   &lt;/guest&gt;
4017   &lt;guest&gt;
4018     &lt;os_type&gt;xen&lt;/os_type&gt;
4019     &lt;arch name='x86_64'&gt;
4020       &lt;wordsize&gt;64&lt;/wordsize&gt;
4021       &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
4022       &lt;machine&gt;xenpv&lt;/machine&gt;
4023       &lt;domain type='xen'/&gt;
4024     &lt;/arch&gt;
4025   &lt;/guest&gt;
4026 &lt;/capabilities&gt;
4027         """
4028         self.mock_conn.getCapabilities.return_value = xml  # pylint: disable=no-member
4029         expected = {
4030             <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"host": {
4031                 "uuid": "44454c4c-3400-105a-8033-b3c04f4b344a",
4032                 "cpu": {
4033                     "arch": "x86_64",
4034                     "model": "Nehalem",
4035                     "vendor": "Intel",
4036                     "microcode": "25",
4037                     "sockets": 1,
4038                     "cores": 4,
4039                     "threads": 2,
4040                     "features": ["vme", "ds", "acpi"],
4041                     "pages": [{"size": "4 KiB"}, {"size": "2048 KiB"}],
4042                 },
4043                 "power_management": ["suspend_mem", "suspend_disk", "suspend_hybrid"],
4044                 "migration": {"live": True, "transports": ["tcp", "rdma"]},
4045                 "topology": {
4046                     "cells": [
4047                         {
4048                             "id": 0,
4049                             "memory": "12367120 KiB",
4050                             "pages": [
4051                                 {"size": "4 KiB", "available": 3091780},
4052                                 {"size": "2048 KiB", "available": 0},
4053                             ],
4054                             "distances": {0: 10},
4055                             "cpus": [
4056                                 {
4057                                     "id": 0,
4058                                     "socket_id": 0,
4059                                     "core_id": 0,
4060                                     "siblings": "0,4",
4061                                 },
4062                                 {
4063                                     "id": 1,
4064                                     "socket_id": 0,
4065                                     "core_id": 1,
4066                                     "siblings": "1,5",
4067                                 },
4068                                 {
4069                                     "id": 2,
4070                                     "socket_id": 0,
4071                                     "core_id": 2,
4072                                     "siblings": "2,6",
4073                                 },
4074                                 {
4075                                     "id": 3,
4076                                     "socket_id": 0,
4077                                     "core_id": 3,
4078                                     "siblings": "3,7",
4079                                 },
4080                                 {
4081                                     "id": 4,
4082                                     "socket_id": 0,
4083                                     "core_id": 0,
4084                                     "siblings": "0,4",
4085                                 },
4086                                 {
4087                                     "id": 5,
4088                                     "socket_id": 0,
4089                                     "core_id": 1,
4090                                     "siblings": "1,5",
4091                                 },
4092                                 {
4093                                     "id": 6,
4094                                     "socket_id": 0,
4095                                     "core_id": 2,
4096                                     "siblings": "2,6",
4097                                 },
4098                                 {
4099                                     "id": 7,
4100                                     "socket_id": 0,
4101                                     "core_id": 3,
4102                                     "siblings": "3,7",
4103                                 },
4104                             ],
4105                         }
4106                     ]
4107                 },
4108                 "cache": {
4109                     "banks": [
4110                         {
4111                             "id": 0,
4112                             "level": 3,
4113                             "type": "both",
4114                             "size": "8 MiB",
4115                             "cpus": "0-7",
4116                         }
4117                     ]
4118                 },
4119                 "security": [
4120                     {"model": "apparmor", "doi": "0", "baselabels": []},
4121                     {
4122                         "model": "dac",
4123                         "doi": "0",
4124                         "baselabels": [
4125                             {"type": "kvm", "label": "+487:+486"},
4126                             {"type": "qemu", "label": "+487:+486"},
4127                         ],
4128                     },
4129                 ],
4130             },
4131             "guests": [
4132                 {
4133                     "os_type": "hvm",
4134                     "arch": {
4135                         "name": "i686",
4136                         "wordsize": 32,
4137                         "emulator": "/usr/bin/qemu-system-i386",
4138                         "machines": {
4139                             "pc-i440fx-2.6": {
4140                                 "maxcpus": 255,
4141                                 "alternate_names": ["pc"],
4142                             },
4143                             "pc-0.12": {"maxcpus": 255, "alternate_names": []},
4144                         },
4145                         "domains": {
4146                             "qemu": {"emulator": None, "machines": {}},
4147                             "kvm": {
4148                                 "emulator": "/usr/bin/qemu-kvm",
4149                                 "machines": {
4150                                     "pc-i440fx-2.6": {
4151                                         "maxcpus": 255,
4152                                         "alternate_names": ["pc"],
4153                                     },
4154                                     "pc-0.12": {"maxcpus": 255, "alternate_names": []},
4155                                 },
4156                             },
4157                         },
4158                     },
4159                     "features": {
4160                         "cpuselection": {"default": True, "toggle": False},
4161                         "deviceboot": {"default": True, "toggle": False},
4162                         "disksnapshot": {"default": True, "toggle": False},
4163                         "acpi": {"default": False, "toggle": True},
4164                         "apic": {"default": True, "toggle": False},
4165                         "pae": {"default": True, "toggle": False},
4166                         "nonpae": {"default": True, "toggle": False},
4167                     },
4168                 },
4169                 {
4170                     "os_type": "hvm",
4171                     "arch": {
4172                         "name": "x86_64",
4173                         "wordsize": 64,
4174                         "emulator": "/usr/bin/qemu-system-x86_64",
4175                         "machines": {
4176                             "pc-i440fx-2.6": {
4177                                 "maxcpus": 255,
4178                                 "alternate_names": ["pc"],
4179                             },
4180                             "pc-0.12": {"maxcpus": 255, "alternate_names": []},
4181                         },
4182                         "domains": {
4183                             "qemu": {"emulator": None, "machines": {}},
4184                             "kvm": {
4185                                 "emulator": "/usr/bin/qemu-kvm",
4186                                 "machines": {
4187                                     "pc-i440fx-2.6": {
4188                                         "maxcpus": 255,
4189                                         "alternate_names": ["pc"],
4190                                     },
4191                                     "pc-0.12": {"maxcpus": 255, "alternate_names": []},
4192                                 },
4193                             },
4194                         },
4195                     },
4196                     "features": {
4197                         "cpuselection": {"default": True, "toggle": False},
4198                         "deviceboot": {"default": True, "toggle": False},
4199                         "disksnapshot": {"default": True, "toggle": False},
4200                         "acpi": {"default": True, "toggle": True},
4201                         "apic": {"default": False, "toggle": False},
4202                     },
4203                 },
4204                 {
4205                     "os_type": "xen",
4206                     "arch": {
4207                         "name": "x86_64",
4208                         "wordsize": 64,
4209                         "emulator": "/usr/bin/qemu-system-x86_64",
4210                         "machines": {"xenpv": {"alternate_names": []}},
4211                         "domains": {"xen": {"emulator": None, "machines": {}}},
4212                     },
4213                 },
4214             ],
4215         }
4216         self.assertEqual(</b></font>expected, caps)
4217     def test_domain_capabilities(self):
4218         xml = """
4219 &lt;domainCapabilities&gt;
4220   &lt;path&gt;/usr/bin/qemu-system-aarch64&lt;/path&gt;
4221   &lt;domain&gt;kvm&lt;/domain&gt;
4222   &lt;machine&gt;virt-2.12&lt;/machine&gt;
4223   &lt;arch&gt;aarch64&lt;/arch&gt;
4224   &lt;vcpu max='255'/&gt;
4225   &lt;iothreads supported='yes'/&gt;
4226   &lt;os supported='yes'&gt;
4227     &lt;loader supported='yes'&gt;
4228       &lt;value&gt;/usr/share/AAVMF/AAVMF_CODE.fd&lt;/value&gt;
4229       &lt;value&gt;/usr/share/AAVMF/AAVMF32_CODE.fd&lt;/value&gt;
4230       &lt;value&gt;/usr/share/OVMF/OVMF_CODE.fd&lt;/value&gt;
4231       &lt;enum name='type'&gt;
4232         &lt;value&gt;rom&lt;/value&gt;
4233         &lt;value&gt;pflash&lt;/value&gt;
4234       &lt;/enum&gt;
4235       &lt;enum name='readonly'&gt;
4236         &lt;value&gt;yes&lt;/value&gt;
4237         &lt;value&gt;no&lt;/value&gt;
4238       &lt;/enum&gt;
4239     &lt;/loader&gt;
4240   &lt;/os&gt;
4241   &lt;cpu&gt;
4242     &lt;mode name='host-passthrough' supported='yes'/&gt;
4243     &lt;mode name='host-model' supported='yes'&gt;
4244       &lt;model fallback='forbid'&gt;sample-cpu&lt;/model&gt;
4245       &lt;vendor&gt;ACME&lt;/vendor&gt;
4246       &lt;feature policy='require' name='vme'/&gt;
4247       &lt;feature policy='require' name='ss'/&gt;
4248     &lt;/mode&gt;
4249     &lt;mode name='custom' supported='yes'&gt;
4250       &lt;model usable='unknown'&gt;pxa262&lt;/model&gt;
4251       &lt;model usable='yes'&gt;pxa270-a0&lt;/model&gt;
4252       &lt;model usable='no'&gt;arm1136&lt;/model&gt;
4253     &lt;/mode&gt;
4254   &lt;/cpu&gt;
4255   &lt;devices&gt;
4256     &lt;disk supported='yes'&gt;
4257       &lt;enum name='diskDevice'&gt;
4258         &lt;value&gt;disk&lt;/value&gt;
4259         &lt;value&gt;cdrom&lt;/value&gt;
4260         &lt;value&gt;floppy&lt;/value&gt;
4261         &lt;value&gt;lun&lt;/value&gt;
4262       &lt;/enum&gt;
4263       &lt;enum name='bus'&gt;
4264         &lt;value&gt;fdc&lt;/value&gt;
4265         &lt;value&gt;scsi&lt;/value&gt;
4266         &lt;value&gt;virtio&lt;/value&gt;
4267         &lt;value&gt;usb&lt;/value&gt;
4268         &lt;value&gt;sata&lt;/value&gt;
4269       &lt;/enum&gt;
4270     &lt;/disk&gt;
4271     &lt;graphics supported='yes'&gt;
4272       &lt;enum name='type'&gt;
4273         &lt;value&gt;sdl&lt;/value&gt;
4274         &lt;value&gt;vnc&lt;/value&gt;
4275       &lt;/enum&gt;
4276     &lt;/graphics&gt;
4277     &lt;video supported='yes'&gt;
4278       &lt;enum name='modelType'&gt;
4279         &lt;value&gt;vga&lt;/value&gt;
4280         &lt;value&gt;virtio&lt;/value&gt;
4281       &lt;/enum&gt;
4282     &lt;/video&gt;
4283     &lt;hostdev supported='yes'&gt;
4284       &lt;enum name='mode'&gt;
4285         &lt;value&gt;subsystem&lt;/value&gt;
4286       &lt;/enum&gt;
4287       &lt;enum name='startupPolicy'&gt;
4288         &lt;value&gt;default&lt;/value&gt;
4289         &lt;value&gt;mandatory&lt;/value&gt;
4290         &lt;value&gt;requisite&lt;/value&gt;
4291         &lt;value&gt;optional&lt;/value&gt;
4292       &lt;/enum&gt;
4293       &lt;enum name='subsysType'&gt;
4294         &lt;value&gt;usb&lt;/value&gt;
4295         &lt;value&gt;pci&lt;/value&gt;
4296         &lt;value&gt;scsi&lt;/value&gt;
4297       &lt;/enum&gt;
4298       &lt;enum name='capsType'/&gt;
4299       &lt;enum name='pciBackend'&gt;
4300         &lt;value&gt;default&lt;/value&gt;
4301         &lt;value&gt;kvm&lt;/value&gt;
4302         &lt;value&gt;vfio&lt;/value&gt;
4303       &lt;/enum&gt;
4304     &lt;/hostdev&gt;
4305   &lt;/devices&gt;
4306   &lt;features&gt;
4307     &lt;gic supported='yes'&gt;
4308       &lt;enum name='version'&gt;
4309         &lt;value&gt;3&lt;/value&gt;
4310       &lt;/enum&gt;
4311     &lt;/gic&gt;
4312     &lt;vmcoreinfo supported='yes'/&gt;
4313   &lt;/features&gt;
4314 &lt;/domainCapabilities&gt;
4315         """
4316         self.mock_conn.getDomainCapabilities.return_value = (
4317             xml  # pylint: disable=no-member
4318         )
4319         expected = {
4320             <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"emulator": "/usr/bin/qemu-system-aarch64",
4321             "domain": "kvm",
4322             "machine": "virt-2.12",
4323             "arch": "aarch64",
4324             "max_vcpus": 255,
4325             "iothreads": True,
4326             "os": {
4327                 "loader": {
4328                     "type": ["rom", "pflash"],
4329                     "readonly": ["yes", "no"],
4330                     "values": [
4331                         "/usr/share/AAVMF/AAVMF_CODE.fd",
4332                         "/usr/share/AAVMF/AAVMF32_CODE.fd",
4333                         "/usr/share/OVMF/OVMF_CODE.fd",
4334                     ],
4335                 }
4336             },
4337             "cpu": {
4338                 "host-passthrough": True,
4339                 "host-model": {
4340                     "model": {"name": "sample-cpu", "fallback": "forbid"},
4341                     "vendor": "ACME",
4342                     "features": {"vme": "require", "ss": "require"},
4343                 },
4344                 "custom": {
4345                     "models": {"pxa262": "unknown", "pxa270-a0": "yes", "arm1136": "no"}
4346                 },
4347             },
4348             "devices": {
4349                 "disk": {
4350                     "diskDevice": ["disk", "cdrom", "floppy", "lun"],
4351                     "bus": ["fdc", "scsi", "virtio", "usb", "sata"],
4352                 },
4353                 "graphics": {"type": ["sdl", "vnc"]},
4354                 "video": {"modelType": ["vga", "virtio"]},
4355                 "hostdev": {
4356                     "mode": ["subsystem"],
4357                     "startupPolicy": ["default", "mandatory", "requisite", "optional"],
4358                     "subsysType": ["usb", "pci", "scsi"],
4359                     "capsType": [],
4360                     "pciBackend": ["default", "kvm", "vfio"],
4361                 },
4362             },
4363             "features": {"gic": {"version": ["3"]}, "vmcoreinfo": {}},
4364         }
4365         self.assertEqual(</b></font>expected, caps)
4366     def test_all_capabilities(self):
4367         domainXml = """
4368 &lt;domainCapabilities&gt;
4369   &lt;path&gt;/usr/bin/qemu-system-x86_64&lt;/path&gt;
4370   &lt;domain&gt;kvm&lt;/domain&gt;
4371   &lt;machine&gt;virt-2.12&lt;/machine&gt;
4372   &lt;arch&gt;x86_64&lt;/arch&gt;
4373   &lt;vcpu max='255'/&gt;
4374   &lt;iothreads supported='yes'/&gt;
4375 &lt;/domainCapabilities&gt;
4376         """
4377         hostXml = """
4378 &lt;capabilities&gt;
4379   &lt;host&gt;
4380     &lt;uuid&gt;44454c4c-3400-105a-8033-b3c04f4b344a&lt;/uuid&gt;
4381     &lt;cpu&gt;
4382       &lt;arch&gt;x86_64&lt;/arch&gt;
4383       &lt;model&gt;Nehalem&lt;/model&gt;
4384       &lt;vendor&gt;Intel&lt;/vendor&gt;
4385       &lt;microcode version='25'/&gt;
4386       &lt;topology sockets='1' cores='4' threads='2'/&gt;
4387     &lt;/cpu&gt;
4388   &lt;/host&gt;
4389   &lt;guest&gt;
4390     &lt;os_type&gt;hvm&lt;/os_type&gt;
4391     &lt;arch name='x86_64'&gt;
4392       &lt;wordsize&gt;64&lt;/wordsize&gt;
4393       &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
4394       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
4395       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
4396       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
4397       &lt;domain type='qemu'/&gt;
4398       &lt;domain type='kvm'&gt;
4399         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
4400         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
4401         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
4402         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
4403       &lt;/domain&gt;
4404     &lt;/arch&gt;
4405   &lt;/guest&gt;
4406 &lt;/capabilities&gt;
4407         """
4408         self.mock_conn.getCapabilities.return_value = hostXml
4409         self.mock_conn.getDomainCapabilities.side_effect = [
4410             domainXml,
4411             domainXml.replace("&lt;domain&gt;kvm", "&lt;domain&gt;qemu"),
4412         ]
4413         caps = virt.all_capabilities()
4414         self<font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertEqual(
4415             "44454c4c-3400-105a-8033-b3c04f4b344a", caps["host"]["host"]["uuid"]
4416         )
4417         self.assertEqual(
4418             {"qemu", "kvm"},
4419             {domainCaps["domain"] for domainCaps in caps["domains"]},
4420         )
4421         self.assertEqual(
4422             {call[0] for call in self.mock_conn.getDomainCapabilities.call_args_list},
4423             {
4424                 ("/usr/bin/qemu-system-x86_64", "x86_64", None, "kvm"),
4425                 ("/usr/bin/qemu-system-x86_64"</b></font>, "x86_64", None, "qemu"),
4426             },
4427         )
4428     def test_network_tag(self):
4429         xml_data = virt._gen_net_xml("network", "main", "bridge", "openvswitch", 1001)
4430         root = ET.fromstring(xml_data)
4431         self.assertEqual(root.find("name").text, "network")
4432         self.assertEqual(root.find("bridge").attrib["name"], "main")
4433         self.assertEqual(root.find("forward").attrib["mode"], "bridge")
4434         self.assertEqual(root.find("virtualport").attrib["type"], "openvswitch")
4435         self.assertEqual(root.find("vlan/tag").attrib["id"], "1001")
4436     def test_list_networks(self):
4437         names = ["net1", "default", "net2"]
4438         net_mocks = [MagicMock(), MagicMock(), MagicMock()]
4439         for i, value in enumerate(names):
4440             net_mocks[i].name.return_value = value
4441         self.mock_conn.listAllNetworks.return_value = (
4442             net_mocks  # pylint: disable=no-member
4443         )
4444         actual = virt.list_networks()
4445         self.assertEqual(names, actual)
4446     def test_network_info(self):
4447         self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV4 = 0
4448         self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV6 = 1
4449         net_mock = MagicMock()
4450         net_mock.name.return_value = "foo"
4451         net_mock.UUIDString.return_value = "some-uuid"
4452         net_mock.bridgeName.return_value = "br0"
4453         net_mock.autostart.return_value = True
4454         net_mock.isActive.return_value = False
4455         net_mock.isPersistent.return_value = True
4456         net_mock.DHCPLeases.return_value = [
4457             {
4458                 "iface": "virbr0",
4459                 "expirytime": 1527757552,
4460                 "type": 0,
4461                 "mac": "52:54:00:01:71:bd",
4462                 "ipaddr": "192.168.122.45",
4463                 "prefix": 24,
4464                 "hostname": "py3-test",
4465                 "clientid": "01:52:54:00:01:71:bd",
4466                 "iaid": None,
4467             }
4468         ]
4469         self.mock_conn.listAllNetworks.return_value = [net_mock]
4470         net = virt.network_info("foo")
4471         self.assertEqual(
4472             {
4473                 "foo": {
4474                     "uuid": "some-uuid",
4475                     "bridge": "br0",
4476                     "autostart": True,
4477                     "active": False,
4478                     "persistent": True,
4479                     "leases": [
4480                         {
4481                             "iface": "virbr0",
4482                             "expirytime": 1527757552,
4483                             "type": "ipv4",
4484                             "mac": "52:54:00:01:71:bd",
4485                             "ipaddr": "192.168.122.45",
4486                             "prefix": 24,
4487                             "hostname": "py3-test",
4488                             "clientid": "01:52:54:00:01:71:bd",
4489                             "iaid": None,
4490                         }
4491                     ],
4492                 }
4493             },
4494             net,
4495         )
4496     def test_network_info_all(self):
4497         self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV4 = 0
4498         self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV6 = 1
4499         net_mocks = []
4500         for i in range(2):
4501             net_mock = MagicMock()
4502             net_mock.name.return_value = "net{}".format(i)
4503             net_mock.UUIDString.return_value = "some-uuid"
4504             net_mock.bridgeName.return_value = "br{}".format(i)
4505             net_mock.autostart.return_value = True
4506             net_mock.isActive.return_value = False
4507             net_mock.isPersistent.return_value = True
4508             net_mock.DHCPLeases.return_value = []
4509             net_mocks.append(net_mock)
4510         self.mock_conn.listAllNetworks.return_value = net_mocks
4511         net = virt.network_info()
4512         self.assertEqual(
4513             {
4514                 "net0": {
4515                     "uuid": "some-uuid",
4516                     "bridge": "br0",
4517                     "autostart": True,
4518                     "active": False,
4519                     "persistent": True,
4520                     "leases": [],
4521                 },
4522                 "net1": {
4523                     "uuid": "some-uuid",
4524                     "bridge": "br1",
4525                     "autostart": True,
4526                     "active": False,
4527                     "persistent": True,
4528                     "leases": [],
4529                 },
4530             },
4531             net,
4532         )
4533     def test_network_info_notfound(self):
4534         self.mock_conn.listAllNetworks.return_value = []
4535         net = virt.network_info("foo")
4536         self.assertEqual({}, net)
4537     def test_network_get_xml(self):
4538         network_mock = MagicMock()
4539         network_mock.XMLDesc.return_value = "&lt;net&gt;Raw XML&lt;/net&gt;"
4540         self.mock_conn.networkLookupByName.return_value = network_mock
4541         self.assertEqual("&lt;net&gt;Raw XML&lt;/net&gt;", virt.network_get_xml("default"))
4542     def test_pool(self):
4543         xml_data = virt._gen_pool_xml("pool", "logical", "/dev/base")
4544         root = ET.fromstring(xml_data)
4545         self.assertEqual(root.find("name").text, "pool")
4546         self.assertEqual(root.attrib["type"], "logical")
4547         self.assertEqual(root.find("target/path").text, "/dev/base")
4548     def test_pool_with_source(self):
4549         xml_data = virt._gen_pool_xml(
4550             "pool", "logical", "/dev/base", source_devices=[{"path": "/dev/sda"}]
4551         )
4552         root = ET.fromstring(xml_data)
4553         self.assertEqual(root.find("name").text, "pool")
4554         self.assertEqual(root.attrib["type"], "logical")
4555         self.assertEqual(root.find("target/path").text, "/dev/base")
4556         self.assertEqual(root.find("source/device").attrib["path"], "/dev/sda")
4557     def test_pool_with_scsi(self):
4558         xml_data = virt._gen_pool_xml(
4559             "pool",
4560             "scsi",
4561             "/dev/disk/by-path",
4562             source_devices=[{"path": "/dev/sda"}],
4563             source_adapter={
4564                 "type": "scsi_host",
4565                 "parent_address": {
4566                     "unique_id": 5,
4567                     "address": {
4568                         "domain": "0x0000",
4569                         "bus": "0x00",
4570                         "slot": "0x1f",
4571                         "function": "0x2",
4572                     },
4573                 },
4574             },
4575             source_name="srcname",
4576         )
4577         root = ET.fromstring(xml_data)
4578         self.assertEqual(root.find("name").text, "pool")
4579         self.assertEqual(root.attrib["type"], "scsi")
4580         self.assertEqual(root.find("target/path").text, "/dev/disk/by-path")
4581         self.assertEqual(root.find("source/device"), None)
4582         self.assertEqual(root.find("source/name"), None)
4583         self.assertEqual(root.find("source/adapter").attrib["type"], "scsi_host")
4584         self.assertEqual(
4585             root.find("source/adapter/parentaddr").attrib["unique_id"], "5"
4586         )
4587         self.assertEqual(
4588             root.find("source/adapter/parentaddr/address").attrib["domain"], "0x0000"
4589         )
4590         self.assertEqual(
4591             root.find("source/adapter/parentaddr/address").attrib["bus"], "0x00"
4592         )
4593         self.assertEqual(
4594             root.find("source/adapter/parentaddr/address").attrib["slot"], "0x1f"
4595         )
4596         self.assertEqual(
4597             root.find("source/adapter/parentaddr/address").attrib["function"], "0x2"
4598         )
4599     def test_pool_with_rbd(self):
4600         xml_data = virt._gen_pool_xml(
4601             "pool",
4602             "rbd",
4603             source_devices=[{"path": "/dev/sda"}],
4604             source_hosts=["1.2.3.4", "my.ceph.monitor:69"],
4605             source_auth={
4606                 "type": "ceph",
4607                 "username": "admin",
4608                 "secret": {"type": "uuid", "value": "someuuid"},
4609             },
4610             source_name="srcname",
4611             source_adapter={"type": "scsi_host", "name": "host0"},
4612             source_dir="/some/dir",
4613             source_format="fmt",
4614         )
4615         root = ET.fromstring(xml_data)
4616         self.assertEqual(root.find("name").text, "pool")
4617         self.assertEqual(root.attrib["type"], "rbd")
4618         self.assertEqual(root.find("target"), None)
4619         self.assertEqual(root.find("source/device"), None)
4620         self.assertEqual(root.find("source/name").text, "srcname")
4621         self.assertEqual(root.find("source/adapter"), None)
4622         self.assertEqual(root.find("source/dir"), None)
4623         self.assertEqual(root.find("source/format"), None)
4624         self.assertEqual(root.findall("source/host")[0].attrib["name"], "1.2.3.4")
4625         self.assertTrue("port" not in root.findall("source/host")[0].attrib)
4626         self.assertEqual(
4627             root.findall("source/host")[1].attrib["name"], "my.ceph.monitor"
4628         )
4629         self.assertEqual(root.findall("source/host")[1].attrib["port"], "69")
4630         self.assertEqual(root.find("source/auth").attrib["type"], "ceph")
4631         self.assertEqual(root.find("source/auth").attrib["username"], "admin")
4632         self.assertEqual(root.find("source/auth/secret").attrib["uuid"], "someuuid")
4633     def test_pool_with_netfs(self):
4634         xml_data = virt._gen_pool_xml(
4635             "pool",
4636             "netfs",
4637             target="/path/to/target",
4638             permissions={
4639                 "mode": "0770",
4640                 "owner": 1000,
4641                 "group": 100,
4642                 "label": "seclabel",
4643             },
4644             source_devices=[{"path": "/dev/sda"}],
4645             source_hosts=["nfs.host"],
4646             source_name="srcname",
4647             source_adapter={"type": "scsi_host", "name": "host0"},
4648             source_dir="/some/dir",
4649             source_format="nfs",
4650         )
4651         root = ET.fromstring(xml_data)
4652         self.assertEqual(root.find("name").text, "pool")
4653         self.assertEqual(root.attrib["type"], "netfs")
4654         self.assertEqual(root.find("target/path").text, "/path/to/target")
4655         self.assertEqual(root.find("target/permissions/mode").text, "0770")
4656         self.assertEqual(root.find("target/permissions/owner").text, "1000")
4657         self.assertEqual(root.find("target/permissions/group").text, "100")
4658         self.assertEqual(root.find("target/permissions/label").text, "seclabel")
4659         self.assertEqual(root.find("source/device"), None)
4660         self.assertEqual(root.find("source/name"), None)
4661         self.assertEqual(root.find("source/adapter"), None)
4662         self.assertEqual(root.find("source/dir").attrib["path"], "/some/dir")
4663         self.assertEqual(root.find("source/format").attrib["type"], "nfs")
4664         self.assertEqual(root.find("source/host").attrib["name"], "nfs.host")
4665         self.assertEqual(root.find("source/auth"), None)
4666     def test_pool_with_iscsi_direct(self):
4667         xml_data = virt._gen_pool_xml(
4668             "pool",
4669             "iscsi-direct",
4670             source_hosts=["iscsi.example.com"],
4671             source_devices=[{"path": "iqn.2013-06.com.example:iscsi-pool"}],
4672             source_initiator="iqn.2013-06.com.example:iscsi-initiator",
4673         )
4674         root = ET.fromstring(xml_data)
4675         self.assertEqual(root.find("name").text, "pool")
4676         self.assertEqual(root.attrib["type"], "iscsi-direct")
4677         self.assertEqual(root.find("target"), None)
4678         self.assertEqual(
4679             root.find("source/device").attrib["path"],
4680             "iqn.2013-06.com.example:iscsi-pool",
4681         )
4682         self.assertEqual(
4683             root.findall("source/host")[0].attrib["name"], "iscsi.example.com"
4684         )
4685         self.assertEqual(
4686             root.find("source/initiator/iqn").attrib["name"],
4687             "iqn.2013-06.com.example:iscsi-initiator",
4688         )
4689     def test_pool_define(self):
4690         mock_pool = MagicMock()
4691         mock_secret = MagicMock()
4692         mock_secret_define = MagicMock(return_value=mock_secret)
4693         self.mock_conn.secretDefineXML = mock_secret_define
4694         self.mock_conn.storagePoolCreateXML = MagicMock(return_value=mock_pool)
4695         self.mock_conn.storagePoolDefineXML = MagicMock(return_value=mock_pool)
4696         mocks = [
4697             mock_pool,
4698             mock_secret,
4699             mock_secret_define,
4700             self.mock_conn.storagePoolCreateXML,
4701             self.mock_conn.secretDefineXML,
4702             self.mock_conn.storagePoolDefineXML,
4703         ]
4704         self.assertTrue(
4705             virt.pool_define(
4706                 "default",
4707                 "rbd",
4708                 source_name="rbdvol",
4709                 source_auth={
4710                     <font color="#5b8daf"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"type": "ceph",
4711                     "username": "admin",
4712                     "secret": {"type": "uuid", "value": "someuuid"},
4713                 },
4714             )
4715         )
4716         self.mock_conn.storagePoolDefineXML.assert_called_once()
4717         self.mock_conn.storagePoolCreateXML.assert_not_called()
4718         mock_pool.create.</b></font>assert_called_once()
4719         mock_secret_define.assert_not_called()
4720         for mock in mocks:
4721             mock.reset_mock()
4722         self.assertTrue(
4723             virt.pool_define(
4724                 "default",
4725                 "rbd",
4726                 transient=True,
4727                 source_hosts=["one.example.com", "two.example.com"],
4728                 source_name="rbdvol",
4729                 source_auth={"username": "admin", "password": "c2VjcmV0"},
4730             )
4731         )
4732         self.mock_conn.storagePoolDefineXML.assert_not_called()
4733         pool_xml = self.mock_conn.storagePoolCreateXML.call_args[0][0]
4734         root = ET.fromstring(pool_xml)
4735         self.assertEqual(root.find("source/auth").attrib["type"], "ceph")
4736         self.assertEqual(root.find("source/auth").attrib["username"], "admin")
4737         self.assertEqual(
4738             root.find("source/auth/secret").attrib["usage"], "pool_default"
4739         )
4740         mock_pool.create.assert_not_called()
4741         mock_secret.setValue.assert_called_once_with(b"secret")
4742         secret_xml = mock_secret_define.call_args[0][0]
4743         root = ET.fromstring(secret_xml)
4744         self.assertEqual(root.find("usage/name").text, "pool_default")
4745         self.assertEqual(root.find("usage").attrib["type"], "ceph")
4746         self.assertEqual(root.attrib["private"], "yes")
4747         self.assertEqual(
4748             root.find("description").text, "Passphrase for default pool created by Salt"
4749         )
4750         for mock in mocks:
4751             mock.reset_mock()
4752         self.assertTrue(
4753             virt.pool_define(
4754                 "default",
4755                 "iscsi",
4756                 target="/dev/disk/by-path",
4757                 source_hosts=["iscsi.example.com"],
4758                 source_devices=[{"path": "iqn.2013-06.com.example:iscsi-pool"}],
4759                 source_auth={"username": "admin", "password": "secret"},
4760                 start=False,
4761             )
4762         )
4763         self.mock_conn.storagePoolCreateXML.assert_not_called()
4764         pool_xml = self.mock_conn.storagePoolDefineXML.call_args[0][0]
4765         root = ET.fromstring(pool_xml)
4766         self.assertEqual(root.find("source/auth").attrib["type"], "chap")
4767         self.assertEqual(root.find("source/auth").attrib["username"], "admin")
4768         self.assertEqual(
4769             root.find("source/auth/secret").attrib["usage"], "pool_default"
4770         )
4771         mock_pool.create.assert_not_called()
4772         mock_secret.setValue.assert_called_once_with("secret")
4773         secret_xml = mock_secret_define.call_args[0][0]
4774         root = ET.fromstring(secret_xml)
4775         self.assertEqual(root.find("usage/target").text, "pool_default")
4776         self.assertEqual(root.find("usage").attrib["type"], "iscsi")
4777         self.assertEqual(root.attrib["private"], "yes")
4778         self.assertEqual(
4779             root.find("description").text, "Passphrase for default pool created by Salt"
4780         )
4781     def test_list_pools(self):
4782         names = ["pool1", "default", "pool2"]
4783         pool_mocks = [MagicMock(), MagicMock(), MagicMock()]
4784         for i, value in enumerate(names):
4785             pool_mocks[i].name.return_value = value
4786         self.mock_conn.listAllStoragePools.return_value = (
4787             pool_mocks  # pylint: disable=no-member
4788         )
4789         actual = virt.list_pools()
4790         self.assertEqual(names, actual)
4791     def test_pool_info(self):
4792         pool_mock = MagicMock()
4793         pool_mock.name.return_value = "foo"
4794         pool_mock.UUIDString.return_value = "some-uuid"
4795         pool_mock.info.return_value = [0, 1234, 5678, 123]
4796         pool_mock.autostart.return_value = True
4797         pool_mock.isPersistent.return_value = True
4798         pool_mock.XMLDesc.return_value = """&lt;pool type='dir'&gt;
4799   &lt;name&gt;default&lt;/name&gt;
4800   &lt;uuid&gt;d92682d0-33cf-4e10-9837-a216c463e158&lt;/uuid&gt;
4801   &lt;capacity unit='bytes'&gt;854374301696&lt;/capacity&gt;
4802   &lt;allocation unit='bytes'&gt;596275986432&lt;/allocation&gt;
4803   &lt;available unit='bytes'&gt;258098315264&lt;/available&gt;
4804   &lt;source&gt;
4805   &lt;/source&gt;
4806   &lt;target&gt;
4807     &lt;path&gt;/srv/vms&lt;/path&gt;
4808     &lt;permissions&gt;
4809       &lt;mode&gt;0755&lt;/mode&gt;
4810       &lt;owner&gt;0&lt;/owner&gt;
4811       &lt;group&gt;0&lt;/group&gt;
4812     &lt;/permissions&gt;
4813   &lt;/target&gt;
4814 &lt;/pool&gt;"""
4815         self.mock_conn.listAllStoragePools.return_value = [pool_mock]
4816         pool = virt.pool_info("foo")
4817         self.assertEqual(
4818             {
4819                 "foo": {
4820                     "uuid": "some-uuid",
4821                     "state": "inactive",
4822                     "capacity": 1234,
4823                     "allocation": 5678,
4824                     "free": 123,
4825                     "autostart": True,
4826                     "persistent": True,
4827                     "type": "dir",
4828                     "target_path": "/srv/vms",
4829                 }
4830             },
4831             pool,
4832         )
4833     def test_pool_info_notarget(self):
4834         pool_mock = MagicMock()
4835         pool_mock.name.return_value = "ceph"
4836         pool_mock.UUIDString.return_value = "some-uuid"
4837         pool_mock.info.return_value = [0, 0, 0, 0]
4838         pool_mock.autostart.return_value = True
4839         pool_mock.isPersistent.return_value = True
4840         pool_mock.XMLDesc.return_value = """&lt;pool type='rbd'&gt;
4841   &lt;name&gt;ceph&lt;/name&gt;
4842   &lt;uuid&gt;some-uuid&lt;/uuid&gt;
4843   &lt;capacity unit='bytes'&gt;0&lt;/capacity&gt;
4844   &lt;allocation unit='bytes'&gt;0&lt;/allocation&gt;
4845   &lt;available unit='bytes'&gt;0&lt;/available&gt;
4846   &lt;source&gt;
4847     &lt;host name='localhost' port='6789'/&gt;
4848     &lt;host name='localhost' port='6790'/&gt;
4849     &lt;name&gt;rbd&lt;/name&gt;
4850     &lt;auth type='ceph' username='admin'&gt;
4851       &lt;secret uuid='2ec115d7-3a88-3ceb-bc12-0ac909a6fd87'/&gt;
4852     &lt;/auth&gt;
4853   &lt;/source&gt;
4854 &lt;/pool&gt;"""
4855         self.mock_conn.listAllStoragePools.return_value = [pool_mock]
4856         pool = virt.pool_info("ceph")
4857         self.assertEqual(
4858             {
4859                 "ceph": {
4860                     "uuid": "some-uuid",
4861                     "state": "inactive",
4862                     "capacity": 0,
4863                     "allocation": 0,
4864                     "free": 0,
4865                     "autostart": True,
4866                     "persistent": True,
4867                     "type": "rbd",
4868                     "target_path": None,
4869                 }
4870             },
4871             pool,
4872         )
4873     def test_pool_info_notfound(self):
4874         self.mock_conn.listAllStoragePools.return_value = []
4875         pool = virt.pool_info("foo")
4876         self.assertEqual({}, pool)
4877     def test_pool_info_all(self):
4878         pool_mocks = []
4879         for i in range(2):
4880             pool_mock = MagicMock()
4881             pool_mock.name.return_value = "pool{}".format(i)
4882             pool_mock.UUIDString.return_value = "some-uuid-{}".format(i)
4883             pool_mock.info.return_value = [0, 1234, 5678, 123]
4884             pool_mock.autostart.return_value = True
4885             pool_mock.isPersistent.return_value = True
4886             pool_mock.XMLDesc.return_value = """&lt;pool type='dir'&gt;
4887   &lt;name&gt;default&lt;/name&gt;
4888   &lt;uuid&gt;d92682d0-33cf-4e10-9837-a216c463e158&lt;/uuid&gt;
4889   &lt;capacity unit='bytes'&gt;854374301696&lt;/capacity&gt;
4890   &lt;allocation unit='bytes'&gt;596275986432&lt;/allocation&gt;
4891   &lt;available unit='bytes'&gt;258098315264&lt;/available&gt;
4892   &lt;source&gt;
4893   &lt;/source&gt;
4894   &lt;target&gt;
4895     &lt;path&gt;/srv/vms&lt;/path&gt;
4896     &lt;permissions&gt;
4897       &lt;mode&gt;0755&lt;/mode&gt;
4898       &lt;owner&gt;0&lt;/owner&gt;
4899       &lt;group&gt;0&lt;/group&gt;
4900     &lt;/permissions&gt;
4901   &lt;/target&gt;
4902 &lt;/pool&gt;"""
4903             pool_mocks.append(pool_mock)
4904         self.mock_conn.listAllStoragePools.return_value = pool_mocks
4905         pool = virt.pool_info()
4906         self.assertEqual(
4907             {
4908                 "pool0": {
4909                     "uuid": "some-uuid-0",
4910                     "state": "inactive",
4911                     "capacity": 1234,
4912                     "allocation": 5678,
4913                     "free": 123,
4914                     "autostart": True,
4915                     "persistent": True,
4916                     "type": "dir",
4917                     "target_path": "/srv/vms",
4918                 },
4919                 "pool1": {
4920                     "uuid": "some-uuid-1",
4921                     "state": "inactive",
4922                     "capacity": 1234,
4923                     "allocation": 5678,
4924                     "free": 123,
4925                     "autostart": True,
4926                     "persistent": True,
4927                     "type": "dir",
4928                     "target_path": "/srv/vms",
4929                 },
4930             },
4931             pool,
4932         )
4933     def test_pool_get_xml(self):
4934         pool_mock = MagicMock()
4935         pool_mock.XMLDesc.return_value = "&lt;pool&gt;Raw XML&lt;/pool&gt;"
4936         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
4937         self.assertEqual("&lt;pool&gt;Raw XML&lt;/pool&gt;", virt.pool_get_xml("default"))
4938     def test_pool_list_volumes(self):
4939         names = ["volume1", "volume2"]
4940         mock_pool = MagicMock()
4941         mock_pool.listVolumes.return_value = names
4942         self.mock_conn.storagePoolLookupByName.return_value = mock_pool
4943         self.assertEqual(names, virt.pool_list_volumes("default"))
4944     @patch("salt.modules.virt._is_bhyve_hyper", return_value=False)
4945     @patch("salt.modules.virt._is_kvm_hyper", return_value=True)
4946     @patch("salt.modules.virt._is_xen_hyper", return_value=False)
4947     def test_get_hypervisor(self, isxen_mock, iskvm_mock, is_bhyve_mock):
4948         self.assertEqual("kvm", virt.get_hypervisor())
4949         iskvm_mock.return_value = False
4950         self.assertIsNone(virt.get_hypervisor())
4951         is_bhyve_mock.return_value = False
4952         self.assertIsNone(virt.get_hypervisor())
4953         isxen_mock.return_value = True
4954         self.assertEqual("xen", virt.get_hypervisor())
4955     def test_pool_delete(self):
4956         mock_pool = MagicMock()
4957         mock_pool.delete = MagicMock(return_value=0)
4958         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mock_pool)
4959         res = virt.pool_delete("test-pool")
4960         self.assertTrue(res)
4961         self.mock_conn.storagePoolLookupByName.assert_called_once_with("test-pool")
4962         mock_pool.delete.assert_called_once_with(
4963             self.mock_libvirt.VIR_STORAGE_POOL_DELETE_NORMAL
4964         )
4965     def test_pool_undefine_secret(self):
4966         mock_pool = MagicMock()
4967         mock_pool.undefine = MagicMock(return_value=0)
4968         mock_pool.XMLDesc.return_value = """
4969             &lt;pool type='rbd'&gt;
4970               &lt;name&gt;test-ses&lt;/name&gt;
4971               &lt;source&gt;
4972                 &lt;host name='myhost'/&gt;
4973                 &lt;name&gt;libvirt-pool&lt;/name&gt;
4974                 &lt;auth type='ceph' username='libvirt'&gt;
4975                   &lt;secret usage='pool_test-ses'/&gt;
4976                 &lt;/auth&gt;
4977               &lt;/source&gt;
4978             &lt;/pool&gt;
4979         """
4980         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mock_pool)
4981         mock_undefine = MagicMock(return_value=0)
4982         res = virt.pool_undefine("test-ses")
4983         self<font color="#2981b2"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertTrue(res)
4984         self.mock_conn.storagePoolLookupByName.assert_called_once_with("test-ses")
4985         mock_pool.undefine.assert_called_once_with()
4986         self.mock_conn.secretLookupByUsage.assert_called_once_with(
4987             self.mock_libvirt.VIR_SECRET_USAGE_TYPE_CEPH, "pool_test-ses"
4988         )
4989         mock_undefine.</b></font>assert_called_once()
4990     def test_full_info(self):
4991         xml = """&lt;domain type='kvm' id='7'&gt;
4992               &lt;uuid&gt;28deee33-4859-4f23-891c-ee239cffec94&lt;/uuid&gt;
4993               &lt;name&gt;test-vm&lt;/name&gt;
4994               &lt;on_poweroff&gt;destroy&lt;/on_poweroff&gt;
4995               &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
4996               &lt;on_crash&gt;destroy&lt;/on_crash&gt;
4997               &lt;devices&gt;
4998                 &lt;disk type='file' device='disk'&gt;
4999                 &lt;driver name='qemu' type='qcow2'/&gt;
5000                 &lt;source file='/disks/test.qcow2'/&gt;
5001                 &lt;target dev='vda' bus='virtio'/&gt;
5002               &lt;/disk&gt;
5003               &lt;disk type='file' device='cdrom'&gt;
5004                 &lt;driver name='qemu' type='raw'/&gt;
5005                 &lt;source file='/disks/test-cdrom.iso'/&gt;
5006                 &lt;target dev='hda' bus='ide'/&gt;
5007                 &lt;readonly/&gt;
5008               &lt;/disk&gt;
5009               &lt;interface type='bridge'&gt;
5010                 &lt;mac address='ac:de:48:b6:8b:59'/&gt;
5011                 &lt;source bridge='br0'/&gt;
5012                 &lt;model type='virtio'/&gt;
5013                 &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x03' function='0x0'/&gt;
5014               &lt;/interface&gt;
5015               &lt;graphics type='vnc' port='5900' autoport='yes' listen='0.0.0.0'&gt;
5016                 &lt;listen type='address' address='0.0.0.0'/&gt;
5017               &lt;/graphics&gt;
5018               &lt;/devices&gt;
5019             &lt;/domain&gt;
5020         """
5021         self.set_mock_vm("test-vm", xml)
5022         qemu_infos = """[{
5023             "virtual-size": 25769803776,
5024             "filename": "/disks/test.qcow2",
5025             "cluster-size": 65536,
5026             "format": "qcow2",
5027             "actual-size": 217088,
5028             "format-specific": {
5029                 "type": "qcow2",
5030                 "data": {
5031                     "compat": "1.1",
5032                     "lazy-refcounts": false,
5033                     "refcount-bits": 16,
5034                     "corrupt": false
5035                 }
5036             },
5037             "full-backing-filename": "/disks/mybacking.qcow2",
5038             "backing-filename": "mybacking.qcow2",
5039             "dirty-flag": false
5040         },
5041         {
5042             "virtual-size": 25769803776,
5043             "filename": "/disks/mybacking.qcow2",
5044             "cluster-size": 65536,
5045             "format": "qcow2",
5046             "actual-size": 393744384,
5047             "format-specific": {
5048                 "type": "qcow2",
5049                 "data": {
5050                     "compat": "1.1",
5051                     "lazy-refcounts": false,
5052                     "refcount-bits": 16,
5053                     "corrupt": false
5054                 }
5055             },
5056             "dirty-flag": false
5057         }]"""
5058         self.mock_popen.communicate.return_value = [qemu_infos, ""]
5059         self.mock_popen.returncode = 0
5060         self.mock_conn.getInfo = MagicMock(
5061             return_value=["x86_64", 4096, 8, 2712, 1, 2, 4, 2]
5062         )
5063         actual = virt.full_info()
5064         qemu_img_call = [
5065             call
5066             for call in self.mock_subprocess.Popen<font color="#f52887"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.call_args_list
5067             if "qemu-img" in call[0][0]
5068         ][0]
5069         self.assertIn("info", qemu_img_call[0][0])
5070         self.assertIn("-U", qemu_img_call[0][0])
5071         self.assertEqual(2816, actual["freemem"])
5072         self.</b></font>assertEqual(6, actual["freecpu"])
5073         self.assertEqual(4, actual<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["node_info"]["cpucores"])
5074         self.assertEqual(2712, actual["node_info"]["cpumhz"])
5075         self.assertEqual("x86_64", actual["node_info"]["cpumodel"])
5076         self.assertEqual(2, actual["node_info"]["cputhreads"])
5077         self.assertEqual(1, actual["node_info"]["numanodes"])
5078         self.</b></font>assertEqual(4096, actual<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["node_info"]["phymemory"])
5079         self.assertEqual(2, actual["node_info"]["sockets"])
5080         self.assertEqual(2, actual["vm_info"]["test-vm"]["cpu"])
5081         self.assertEqual(1024 * 1024, actual["vm_info"]["test-vm"]["mem"])
5082         self.assertEqual(2048 * 1024, actual["vm_info"]["test-vm"]["maxMem"])
5083         self.</b></font>assertEqual("shutdown", actual<font color="#947010"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["vm_info"]["test-vm"]["state"])
5084         self.assertEqual(
5085             "28deee33-4859-4f23-891c-ee239cffec94", actual["vm_info"]["test-vm"]["uuid"]
5086         )
5087         self.assertEqual("destroy", actual["vm_info"]["test-vm"]["on_crash"])
5088         self.</b></font>assertEqual("restart", actual["vm_info"]["test-vm"]["on_reboot"])
5089         self.assertEqual("destroy", actual["vm_info"]["test-vm"]["on_poweroff"])
5090         nic = actual["vm_info"]["test-vm"]["nics"]["ac:de:48:b6:8b:59"]
5091         self.assertEqual("bridge", nic["type"])
5092         self.assertEqual("ac:de:48:b6:8b:59", nic["mac"])
5093         disks = actual["vm_info"]["test-vm"]["disks"]
5094         disk = disks.get("vda")
5095         self.assertEqual("/disks/test.qcow2", disk["file"])
5096         self.assertEqual("disk", disk["type"])
5097         self.assertEqual("/disks/mybacking.qcow2", disk["backing file"]["file"])
5098         cdrom = disks.get("hda")
5099         self.assertEqual("/disks/test-cdrom.iso", cdrom["file"])
5100         self.assertEqual("cdrom", cdrom["type"])
5101         self.assertFalse("backing file" in cdrom.keys())
5102         graphics = actual["vm_info"]["test-vm"]["graphics"]
5103         self.assertEqual("vnc", graphics["type"])
5104         self.assertEqual("5900", graphics["port"])
5105         self.assertEqual("0.0.0.0", graphics["listen"])
5106     def test_pool_update(self):
5107         current_xml = """&lt;pool type='dir'&gt;
5108           &lt;name&gt;default&lt;/name&gt;
5109           &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
5110           &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
5111           &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
5112           &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
5113           &lt;source&gt;
5114           &lt;/source&gt;
5115           &lt;target&gt;
5116             &lt;path&gt;/path/to/pool&lt;/path&gt;
5117             &lt;permissions&gt;
5118               &lt;mode&gt;0775&lt;/mode&gt;
5119               &lt;owner&gt;0&lt;/owner&gt;
5120               &lt;group&gt;100&lt;/group&gt;
5121             &lt;/permissions&gt;
5122           &lt;/target&gt;
5123         &lt;/pool&gt;"""
5124         expected_xml = (
5125             '&lt;pool type="netfs"&gt;'
5126             "&lt;name&gt;default&lt;/name&gt;"
5127             "&lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;"
5128             '&lt;capacity unit="bytes"&gt;1999421108224&lt;/capacity&gt;'
5129             '&lt;allocation unit="bytes"&gt;713207042048&lt;/allocation&gt;'
5130             '&lt;available unit="bytes"&gt;1286214066176&lt;/available&gt;'
5131             "&lt;target&gt;"
5132             "&lt;path&gt;/mnt/cifs&lt;/path&gt;"
5133             "&lt;permissions&gt;"
5134             "&lt;mode&gt;0774&lt;/mode&gt;"
5135             "&lt;owner&gt;1234&lt;/owner&gt;"
5136             "&lt;group&gt;123&lt;/group&gt;"
5137             "&lt;/permissions&gt;"
5138             "&lt;/target&gt;"
5139             "&lt;source&gt;"
5140             '&lt;dir path="samba_share" /&gt;'
5141             '&lt;host name="one.example.com" /&gt;'
5142             '&lt;host name="two.example.com" /&gt;'
5143             '&lt;format type="cifs" /&gt;'
5144             "&lt;/source&gt;"
5145             "&lt;/pool&gt;"
5146         )
5147         mocked_pool = MagicMock()
5148         mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
5149         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
5150         self.mock_conn.storagePoolDefineXML = MagicMock()
5151         self.assertTrue(
5152             virt.pool_update(
5153                 "default",
5154                 "netfs",
5155                 target="/mnt/cifs",
5156                 permissions={"mode": "0774", "owner": "1234", "group": "123"},
5157                 source_format="cifs",
5158                 source_dir="samba_share",
5159                 source_hosts=["one.example.com", "two.example.com"],
5160             )
5161         )
5162         self.mock_conn.storagePoolDefineXML.assert_called_once_with(expected_xml)
5163     def test_pool_update_nochange(self):
5164         current_xml = """&lt;pool type='dir'&gt;
5165           &lt;name&gt;default&lt;/name&gt;
5166           &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
5167           &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
5168           &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
5169           &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
5170           &lt;source&gt;
5171           &lt;/source&gt;
5172           &lt;target&gt;
5173             &lt;path&gt;/path/to/pool&lt;/path&gt;
5174             &lt;permissions&gt;
5175               &lt;mode&gt;0775&lt;/mode&gt;
5176               &lt;owner&gt;0&lt;/owner&gt;
5177               &lt;group&gt;100&lt;/group&gt;
5178             &lt;/permissions&gt;
5179           &lt;/target&gt;
5180         &lt;/pool&gt;"""
5181         mocked_pool = MagicMock()
5182         mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
5183         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
5184         self.mock_conn.storagePoolDefineXML = MagicMock()
5185         self.assertFalse(
5186             virt.pool_update(
5187                 "default",
5188                 "dir",
5189                 target="/path/to/pool",
5190                 permissions={"mode": "0775", "owner": "0", "group": "100"},
5191                 test=True,
5192             )
5193         )
5194         self.mock_conn.storagePoolDefineXML.assert_not_called()
5195     def test_pool_update_password(self):
5196         current_xml = """&lt;pool type='rbd'&gt;
5197           &lt;name&gt;default&lt;/name&gt;
5198           &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
5199           &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
5200           &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
5201           &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
5202           &lt;source&gt;
5203             &lt;name&gt;iscsi-images&lt;/name&gt;
5204             &lt;host name='ses4.tf.local'/&gt;
5205             &lt;host name='ses5.tf.local'/&gt;
5206             &lt;auth username='libvirt' type='ceph'&gt;
5207               &lt;secret uuid='14e9a0f1-8fbf-4097-b816-5b094c182212'/&gt;
5208             &lt;/auth&gt;
5209           &lt;/source&gt;
5210         &lt;/pool&gt;"""
5211         mock_secret = MagicMock()
5212         self.mock_conn.secretLookupByUUIDString = MagicMock(return_value=mock_secret)
5213         mocked_pool = MagicMock()
5214         mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
5215         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
5216         self.mock_conn.storagePoolDefineXML = MagicMock()
5217         self.assertFalse(
5218             virt.pool_update(
5219                 "default",
5220                 "rbd",
5221                 source_name="iscsi-images",
5222                 source_hosts=["ses4.tf.local", "ses5.tf.local"],
5223                 source_auth={"username": "libvirt", "password": "c2VjcmV0"},
5224             )
5225         )
5226         self.mock_conn.storagePoolDefineXML.assert_not_called()
5227         mock_secret.setValue.assert_called_once_with(b"secret")
5228         self.mock_conn.secretLookupByUUIDString = MagicMock(
5229             side_effect=self.mock_libvirt.libvirtError("secret not found")
5230         )
5231         self.assertFalse(
5232             virt.pool_update(
5233                 "default",
5234                 "rbd",
5235                 source_name="iscsi-images",
5236                 source_hosts=["ses4.tf.local", "ses5.tf.local"],
5237                 source_auth={"username": "libvirt", "password": "c2VjcmV0"},
5238             )
5239         )
5240         self.mock_conn.storagePoolDefineXML.assert_not_called()
5241         self.mock_conn.secretDefineXML.assert_called_once()
5242         mock_secret.setValue.assert_called_once_with(b"secret")
5243     def test_pool_update_password_create(self):
5244         current_xml = """&lt;pool type='rbd'&gt;
5245           &lt;name&gt;default&lt;/name&gt;
5246           &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
5247           &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
5248           &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
5249           &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
5250           &lt;source&gt;
5251             &lt;name&gt;iscsi-images&lt;/name&gt;
5252             &lt;host name='ses4.tf.local'/&gt;
5253             &lt;host name='ses5.tf.local'/&gt;
5254           &lt;/source&gt;
5255         &lt;/pool&gt;"""
5256         expected_xml = (
5257             '&lt;pool type="rbd"&gt;'
5258             "&lt;name&gt;default&lt;/name&gt;"
5259             "&lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;"
5260             '&lt;capacity unit="bytes"&gt;1999421108224&lt;/capacity&gt;'
5261             '&lt;allocation unit="bytes"&gt;713207042048&lt;/allocation&gt;'
5262             '&lt;available unit="bytes"&gt;1286214066176&lt;/available&gt;'
5263             "&lt;source&gt;"
5264             '&lt;host name="ses4.tf.local" /&gt;'
5265             '&lt;host name="ses5.tf.local" /&gt;'
5266             '&lt;auth type="ceph" username="libvirt"&gt;'
5267             '&lt;secret usage="pool_default" /&gt;'
5268             "&lt;/auth&gt;"
5269             "&lt;name&gt;iscsi-images&lt;/name&gt;"
5270             "&lt;/source&gt;"
5271             "&lt;/pool&gt;"
5272         )
5273         mock_secret = MagicMock()
5274         self.mock_conn.secretDefineXML = MagicMock(return_value=mock_secret)
5275         mocked_pool = MagicMock()
5276         mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
5277         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
5278         self.mock_conn.storagePoolDefineXML = MagicMock()
5279         self.assertTrue(
5280             virt.pool_update(
5281                 "default",
5282                 "rbd",
5283                 source_name="iscsi-images",
5284                 source_hosts=["ses4.tf.local", "ses5.tf.local"],
5285                 source_auth={"username": "libvirt", "password": "c2VjcmV0"},
5286             )
5287         )
5288         self.mock_conn.storagePoolDefineXML.assert_called_once_with(expected_xml)
5289         mock_secret.setValue.assert_called_once_with(b"secret")
5290     def test_volume_infos(self):
5291         vms_disks = [
5292         ]
5293         mock_vms = []
5294         for idx, disk in enumerate(vms_disks):
5295             vm = MagicMock()
5296             vm.name.return_value = "vm{}".format(idx)
5297             vm.XMLDesc.return_value = """
5298                     &lt;domain type='kvm' id='1'&gt;
5299                       &lt;name&gt;vm{}&lt;/name&gt;
5300                       &lt;devices&gt;{}&lt;/devices&gt;
5301                     &lt;/domain&gt;
5302                 """.format(
5303                 idx, disk
5304             )
5305         mock_pool_data = [
5306             <font color="#3090c7"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
5307                 "name": "pool0",
5308                 "state": self.mock_libvirt.VIR_STORAGE_POOL_RUNNING,
5309                 "volumes": [
5310                     {
5311                         "key": "/key/of/vol0",
5312                         "name": "vol0",
5313                         "path": "/path/to/vol0.qcow2",
5314                         "info": [0, 123456789, 123456],
5315                         "backingStore": None,
5316                     }
5317                 ],
5318             },
5319             {
5320                 "name": "pool1",
5321                 "state": self.mock_libvirt.VIR_STORAGE_POOL_RUNNING,
5322                 "volumes": [
5323                     {
5324                         "key": "/key/of/vol0bad",
5325                         "name": "vol0bad",
5326                         "path": "/path/to/vol0bad.qcow2",
5327                         "info": None,
5328                         "backingStore": None,
5329                     },
5330                     {
5331                         "key": "/key/of/vol1",
5332                         "name": "vol1",
5333                         "path": "/path/to/vol1.qcow2",
5334                         "info": [0, 12345, 1234],
5335                         "backingStore": None,
5336                     },
5337                     {
5338                         "key": "/key/of/vol2",
5339                         "name": "vol2",
5340                         "path": "/path/to/vol2.qcow2",
5341                         "info": [0</b></font>, 12345, 1234],
5342                         "backingStore": "/path/to/vol0.qcow2",
5343                     },
5344                 ],
5345             },
5346         ]
5347         mock_pools = []
5348         for pool_data in mock_pool_data:
5349             mock_pool = MagicMock()
5350             mock_pool.name.return_value = pool_data["name"]  # pylint: disable=no-member
5351             mock_pool.info.return_value = [pool_data["state"]]
5352             mock_volumes = []
5353             for vol_data in pool_data["volumes"]:
5354                 mock_volume = MagicMock()
5355                 mock_volume.name.return_value = vol_data["name"]
5356                 mock_volume.key.return_value = vol_data["key"]
5357                 mock_volume.path.return_value = "/path/to/{}.qcow2".format(
5358                     vol_data["name"]
5359                 )
5360                 if vol_data["info"]:
5361                     mock_volume.info.return_value = vol_data["info"]
5362                     backing_store = (
5363                             vol_data["backingStore"]
5364                         )
5365                         if vol_data["backingStore"]
5366                         else "&lt;backingStore/&gt;"
5367                     )
5368                     mock_volume.XMLDesc.return_value = """
5369                         &lt;volume type='file'&gt;
5370                           &lt;name&gt;{0}&lt;/name&gt;
5371                           &lt;target&gt;
5372                             &lt;format type="qcow2"/&gt;
5373                             &lt;path&gt;/path/to/{0}.qcow2&lt;/path&gt;
5374                           &lt;/target&gt;
5375                           {1}
5376                         &lt;/volume&gt;
5377                     """.format(
5378                         vol_data["name"], backing_store
5379                     )
5380                 else:
5381                     mock_volume.info.side_effect = self.mock_libvirt.libvirtError(
5382                         "No such volume"
5383                     )
5384                     mock_volume.XMLDesc.side_effect = self.mock_libvirt.libvirtError(
5385                         "No such volume"
5386                     )
5387                 mock_volumes.append(mock_volume)
5388             mock_pool.listAllVolumes.return_value = (
5389                 mock_volumes  # pylint: disable=no-member
5390             )
5391             mock_pools.append(mock_pool)
5392         inactive_pool = MagicMock()
5393         inactive_pool.name.return_value = "pool2"
5394         inactive_pool.info.return_value = [self.mock_libvirt.VIR_STORAGE_POOL_INACTIVE]
5395         inactive_pool.listAllVolumes.side_effect = self.mock_libvirt.libvirtError(
5396             "pool is inactive"
5397         )
5398         mock_pools.append(inactive_pool)
5399         self.mock_conn.listAllStoragePools.return_value = (
5400             mock_pools  # pylint: disable=no-member
5401         )
5402         with patch("salt.modules.virt._get_domain", MagicMock(return_value=mock_vms)):
5403             self.assertEqual(1, len(actual.keys()))
5404             self.assertEqual(1, len(actual["pool0"].keys()))
5405             self.assertEqual(["vm0", "vm2"], sorted(actual["pool0"]<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["vol0"]["used_by"]))
5406             self.assertEqual("/path/to/vol0.qcow2", actual["pool0"]["vol0"]["path"])
5407             self.assertEqual("file", actual["pool0"]["vol0"]["type"])
5408             self.assertEqual("/key/of/vol0", actual["pool0"]["vol0"]["key"])
5409             self.assertEqual(123456789, actual["pool0"]["vol0"]["capacity"])
5410             self.</b></font>assertEqual(123456, actual["pool0"]["vol0"]["allocation"])
5411             self.assertEqual(
5412                 virt.volume_infos("pool1", None),
5413                 {
5414                     "pool1": {
5415                         "vol1": {
5416                             "type": "file",
5417                             "key": "/key/of/vol1",
5418                             "path": "/path/to/vol1.qcow2",
5419                             "capacity": 12345,
5420                             "allocation": 1234,
5421                             "used_by": [],
5422                             "backing_store": None,
5423                             "format": "qcow2",
5424                         },
5425                         "vol2": {
5426                             "type": "file",
5427                             "key": "/key/of/vol2",
5428                             "path": "/path/to/vol2.qcow2",
5429                             "capacity": 12345,
5430                             "allocation": 1234,
5431                             "used_by": ["vm2"],
5432                             "backing_store": {
5433                                 "path": "/path/to/vol0.qcow2",
5434                                 "format": "qcow2",
5435                             },
5436                             "format": "qcow2",
5437                         },
5438                     }
5439                 },
5440             )
5441             self.assertEqual(
5442                 virt.volume_infos(None, "vol2"),
5443                 {
5444                     "pool1": {
5445                         "vol2": {
5446                             "type": "file",
5447                             "key": "/key/of/vol2",
5448                             "path": "/path/to/vol2.qcow2",
5449                             "capacity": 12345,
5450                             "allocation": 1234,
5451                             "used_by": ["vm2"],
5452                             "backing_store": {
5453                                 "path": "/path/to/vol0.qcow2",
5454                                 "format": "qcow2",
5455                             },
5456                             "format": "qcow2",
5457                         }
5458                     }
5459                 },
5460             )
5461         with patch(
5462             "salt.modules.virt._get_domain", MagicMock(return_value=mock_vms[0])
5463         ):
5464             self.assertEqual(1, len(actual.keys()))
5465             self.assertEqual(1, len(actual["pool0"].keys()))
5466             self.assertEqual("/path/to/vol0.qcow2", actual["pool0"]["vol0"]["path"])
5467             self.assertEqual("file", actual["pool0"]["vol0"][</b></font>"type"])
5468             self.assertEqual("/key/of/vol0", actual["pool0"]<font color="#ae694a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["vol0"]["key"])
5469             self.assertEqual(123456789, actual["pool0"]["vol0"]["capacity"])
5470             self.assertEqual(123456, actual["pool0"]["vol0"][</b></font>"allocation"])
5471             self.assertEqual(
5472                 virt.volume_infos("pool1", None),
5473                 {
5474                     "pool1": {
5475                         "vol1": {
5476                             "type": "file",
5477                             "key": "/key/of/vol1",
5478                             "path": "/path/to/vol1.qcow2",
5479                             "capacity": 12345,
5480                             "allocation": 1234,
5481                             "used_by": [],
5482                             "backing_store": None,
5483                             "format": "qcow2",
5484                         },
5485                         "vol2": {
5486                             "type": "file",
5487                             "key": "/key/of/vol2",
5488                             "path": "/path/to/vol2.qcow2",
5489                             "capacity": 12345,
5490                             "allocation": 1234,
5491                             "used_by": [],
5492                             "backing_store": {
5493                                 "path": "/path/to/vol0.qcow2",
5494                                 "format": "qcow2",
5495                             },
5496                             "format": "qcow2",
5497                         },
5498                     }
5499                 },
5500             )
5501             self.assertEqual(
5502                 virt.volume_infos(None, "vol2"),
5503                 {
5504                     "pool1": {
5505                         "vol2": {
5506                             "type": "file",
5507                             "key": "/key/of/vol2",
5508                             "path": "/path/to/vol2.qcow2",
5509                             "capacity": 12345,
5510                             "allocation": 1234,
5511                             "used_by": [],
5512                             "backing_store": {
5513                                 "path": "/path/to/vol0.qcow2",
5514                                 "format": "qcow2",
5515                             },
5516                             "format": "qcow2",
5517                         }
5518                     }
5519                 },
5520             )
5521         with patch(
5522             "salt.modules.virt._get_domain",
5523             MagicMock(side_effect=CommandExecutionError("no VM")),
5524         ):
5525             actual = virt.volume_infos("pool0", "vol0")
5526             self.assertEqual(1, len(actual.keys()))
5527             self.assertEqual(1, len(actual["pool0"].keys()))
5528             self.assertEqual([], sorted(actual["pool0"]["vol0"]["used_by"]))
5529             self.assertEqual("/path/to/vol0.qcow2", actual["pool0"]["vol0"]["path"])
5530             self.assertEqual("file", actual["pool0"]["vol0"]["type"])
5531             self.assertEqual("/key/of/vol0", actual["pool0"]["vol0"]["key"])
5532             self.assertEqual(123456789, actual["pool0"]["vol0"]["capacity"])
5533             self.assertEqual(123456, actual["pool0"]["vol0"]["allocation"])
5534             self.assertEqual(
5535                 virt.volume_infos("pool1", None),
5536                 {
5537                     "pool1": {
5538                         "vol1": {
5539                             "type": "file",
5540                             "key": "/key/of/vol1",
5541                             "path": "/path/to/vol1.qcow2",
5542                             "capacity": 12345,
5543                             "allocation": 1234,
5544                             "used_by": [],
5545                             "backing_store": None,
5546                             "format": "qcow2",
5547                         },
5548                         "vol2": {
5549                             "type": "file",
5550                             "key": "/key/of/vol2",
5551                             "path": "/path/to/vol2.qcow2",
5552                             "capacity": 12345,
5553                             "allocation": 1234,
5554                             "used_by": [],
5555                             "backing_store": {
5556                                 "path": "/path/to/vol0.qcow2",
5557                                 "format": "qcow2",
5558                             },
5559                             "format": "qcow2",
5560                         },
5561                     }
5562                 },
5563             )
5564             self.assertEqual(
5565                 virt.volume_infos(None, "vol2"),
5566                 {
5567                     "pool1": {
5568                         "vol2": {
5569                             "type": "file",
5570                             "key": "/key/of/vol2",
5571                             "path": "/path/to/vol2.qcow2",
5572                             "capacity": 12345,
5573                             "allocation": 1234,
5574                             "used_by": [],
5575                             "backing_store": {
5576                                 "path": "/path/to/vol0.qcow2",
5577                                 "format": "qcow2",
5578                             },
5579                             "format": "qcow2",
5580                         }
5581                     }
5582                 },
5583             )
5584     def test_volume_delete(self):
5585         mock_delete = MagicMock(side_effect=[0, 1])
5586         mock_volume = MagicMock()
5587         mock_volume.delete = mock_delete  # pylint: disable=no-member
5588         mock_pool = MagicMock()
5589         mock_pool.storageVolLookupByName.side_effect = [
5590             mock_volume,
5591             mock_volume,
5592             self.mock_libvirt.libvirtError("Missing volume"),
5593             mock_volume,
5594         ]
5595         self.mock_conn.storagePoolLookupByName.side_effect = [
5596             mock_pool,
5597             mock_pool,
5598             mock_pool,
5599             self.mock_libvirt.libvirtError("Missing pool"),
5600         ]
5601         self.assertTrue(virt.volume_delete("default", "test_volume"))
5602         self.assertFalse(virt.volume_delete("default", "test_volume"))
5603         with self.assertRaises(self.mock_libvirt.libvirtError):
5604             virt.volume_delete("default", "missing")
5605             virt.volume_delete("missing", "test_volume")
5606         self.assertEqual(mock_delete.call_count, 2)
5607     def test_pool_capabilities(self):
5608         xml_caps = """
5609 &lt;storagepoolCapabilities&gt;
5610   &lt;pool type='disk' supported='yes'&gt;
5611     &lt;poolOptions&gt;
5612       &lt;defaultFormat type='unknown'/&gt;
5613       &lt;enum name='sourceFormatType'&gt;
5614         &lt;value&gt;unknown&lt;/value&gt;
5615         &lt;value&gt;dos&lt;/value&gt;
5616         &lt;value&gt;dvh&lt;/value&gt;
5617       &lt;/enum&gt;
5618     &lt;/poolOptions&gt;
5619     &lt;volOptions&gt;
5620       &lt;defaultFormat type='none'/&gt;
5621       &lt;enum name='targetFormatType'&gt;
5622         &lt;value&gt;none&lt;/value&gt;
5623         &lt;value&gt;linux&lt;/value&gt;
5624       &lt;/enum&gt;
5625     &lt;/volOptions&gt;
5626   &lt;/pool&gt;
5627   &lt;pool type='iscsi' supported='yes'&gt;
5628   &lt;/pool&gt;
5629   &lt;pool type='rbd' supported='yes'&gt;
5630     &lt;volOptions&gt;
5631       &lt;defaultFormat type='raw'/&gt;
5632       &lt;enum name='targetFormatType'&gt;
5633       &lt;/enum&gt;
5634     &lt;/volOptions&gt;
5635   &lt;/pool&gt;
5636   &lt;pool type='sheepdog' supported='no'&gt;
5637   &lt;/pool&gt;
5638 &lt;/storagepoolCapabilities&gt;
5639         self.mock_conn.getStoragePoolCapabilities = MagicMock(return_value=xml_caps)
5640         actual = virt<font color="#842dce"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.pool_capabilities()
5641         self.assertEqual(
5642             {
5643                 "computed": False,
5644                 "pool_types": [
5645                     {
5646                         "name": "disk",
5647                         "supported": True,
5648                         "options": {
5649                             "pool": {
5650                                 "default_format": "unknown",
5651                                 "sourceFormatType": ["unknown", "dos", "dvh"],
5652                             },
5653                             "volume": {
5654                                 "default_format": "none",
5655                                 "targetFormatType": ["none", "linux"],
5656                             },
5657                         },
5658                     },
5659                     {"name": "iscsi", "supported": True},
5660                     {
5661                         "name": "rbd",
5662                         "supported": True,
5663                         "options": {
5664                             "volume": {"default_format": "raw", "targetFormatType": []}
5665                         },
5666                     },
5667                     {"name"</b></font>: "sheepdog", "supported": False},
5668                 ],
5669             },
5670             actual,
5671         )
5672     @patch("salt.modules.virt.get_hypervisor", return_value="kvm")
5673     def test_pool_capabilities_computed(self, mock_get_hypervisor):
5674         self.mock_conn.getLibVersion = MagicMock(return_value=4006000)
5675         del self.mock_conn.getStoragePoolCapabilities
5676         actual = virt.pool_capabilities()
5677         self.assertTrue(actual["computed"])
5678         backends = actual["pool_types"]
5679         self.assertFalse(
5680             [backend for backend in backends if backend["name"] == "iscsi-direct"][0][
5681                 "supported"
5682             ]
5683         )
5684         self.assertTrue(
5685             [backend for backend in backends if backend["name"] == "gluster"][0][
5686                 "supported"
5687             ]
5688         )
5689         self.assertFalse(
5690             [backend for backend in backends if backend["name"] == "zfs"][0][
5691                 "supported"
5692             ]
5693         )
5694         mock_get_hypervisor.return_value = "xen"
5695         backends = virt.pool_capabilities()["pool_types"]
5696         self.assertFalse(
5697             [backend for backend in backends if backend["name"] == "gluster"][0][
5698                 "supported"
5699             ]
5700         )
5701         backends = virt.pool_capabilities()["pool_types"]
5702         self.assertFalse(
5703             [backend for backend in backends if backend<font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["name"] == "gluster"][0][
5704                 "supported"
5705             ]
5706         )
5707         self.assertTrue(
5708             [backend for backend in backends if backend["name"] == "zfs"][0][
5709                 "supported"
5710             ]
5711         )
5712         self.assertNotIn(
5713             "options",
5714             [backend for backend in backends if backend["name"] == "iscsi"][0],
5715         )
5716         self.assertNotIn(
5717             "pool",
5718             [backend for backend in backends if backend["name"] == "dir"][0]["options"],
5719         )
5720         self.assertNotIn(
5721             "volume",
5722             [backend for backend in backends if backend["name"] == "logical"][0][
5723                 "options"
5724             ],
5725         )
5726         self.</b></font>assertEqual(
5727             {
5728                 "pool": {
5729                     "default_format": "auto",
5730                     "sourceFormatType": ["auto", "nfs", "glusterfs", "cifs"],
5731                 },
5732                 "volume": {
5733                     "default_format": "raw",
5734                     "targetFormatType": [
5735                         "none",
5736                         "raw",
5737                         "dir",
5738                         "bochs",
5739                         "cloop",
5740                         "dmg",
5741                         "iso",
5742                         "vpc",
5743                         "vdi",
5744                         "fat",
5745                         "vhd",
5746                         "ploop",
5747                         "cow",
5748                         "qcow",
5749                         "qcow2",
5750                         "qed",
5751                         "vmdk",
5752                     ],
5753                 },
5754             },
5755             [backend for backend in backends if backend["name"] == "netfs"][0][
5756                 "options"
5757             ],
5758         )
5759     def test_get_domain(self):
5760         self.mock_conn.listDomainsID.return_value = []
5761         self.mock_conn.listDefinedDomains.return_value = []
5762         self.assertEqual([], virt._get_domain(self.mock_conn))
5763         self.assertRaisesRegex(
5764             CommandExecutionError,
5765             "No virtual machines found.",
5766             virt._get_domain,
5767             self.mock_conn,
5768             "vm2",
5769         )
5770         self.mock_conn.listDomainsID.return_value = [1]
5771         def create_mock_vm(idx):
5772             mock_vm = MagicMock()
5773             mock_vm.name.return_value = "vm{}".format(idx)
5774             return mock_vm
5775         mock_vms = [create_mock_vm(idx) for idx in range(3)]
5776         self.mock_conn.lookupByID.return_value = mock_vms[0]
5777         self.mock_conn.listDefinedDomains.return_value = ["vm1", "vm2"]
5778         self.mock_conn.lookupByName.side_effect = mock_vms
5779         self.assertEqual(mock_vms, virt._get_domain(self.mock_conn))
5780         self.mock_conn.lookupByName.side_effect = None
5781         self.mock_conn.lookupByName.return_value = mock_vms[0]
5782         self.assertEqual(mock_vms[0], virt._get_domain(self.mock_conn, inactive=False))
5783         self.mock_conn.lookupByName.return_value = None
5784         self.mock_conn.lookupByName.side_effect = [mock_vms[1], mock_vms[2]]
5785         self.assertEqual(
5786             [mock_vms[1], mock_vms[2]], virt._get_domain(self.mock_conn, active=False)
5787         )
5788         self.mock_conn.reset_mock()
5789         self.mock_conn.lookupByName.return_value = None
5790         self.mock_conn.lookupByName.side_effect = [<font color="#800517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>mock_vms[1], mock_vms[2]]
5791         self.assertEqual(
5792             [mock_vms[1], mock_vms[2]], virt._get_domain(self.mock_conn, "vm1", "vm2")
5793         )
5794         self.assertRaisesRegex(
5795             CommandExecutionError,
5796             'The VM "vm2" is not present',
5797             virt._get_domain,
5798             self.</b></font>mock_conn,
5799             "vm2",
5800             inactive=False,
5801         )
5802     def test_volume_define(self):
5803         pool_mock = MagicMock()
5804         pool_mock.XMLDesc.return_value = "&lt;pool type='dir'&gt;&lt;/pool&gt;"
5805         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
5806         self.assertTrue(
5807             virt.volume_define(
5808                 "testpool",
5809                 "myvm_system.qcow2",
5810                 8192,
5811                 allocation=4096,
5812                 format="qcow2",
5813                 type="file",
5814             )
5815         )
5816         expected_xml = (
5817             "&lt;volume type='file'&gt;\n"
5818             "  &lt;name&gt;myvm_system.qcow2&lt;/name&gt;\n"
5819             "  &lt;source&gt;\n"
5820             "  &lt;/source&gt;\n"
5821             "  &lt;capacity unit='KiB'&gt;8388608&lt;/capacity&gt;\n"
5822             "  &lt;allocation unit='KiB'&gt;4194304&lt;/allocation&gt;\n"
5823             "  &lt;target&gt;\n"
5824             "    &lt;format type='qcow2'/&gt;\n"
5825             "  &lt;/target&gt;\n"
5826             "&lt;/volume&gt;"
5827         )
5828         pool_mock.createXML.assert_called_once_with(expected_xml, 0)
5829         pool_mock.reset_mock()
5830         self.assertTrue(
5831             virt.volume_define(
5832                 "testpool",
5833                 "myvm_system.qcow2",
5834                 8192,
5835                 allocation=4096,
5836                 format="qcow2",
5837                 type="file",
5838                 backing_store={"path": "/path/to/base.raw", "format": "raw"},
5839             )
5840         )
5841         expected_xml = (
5842             "&lt;volume type='file'&gt;\n"
5843             "  &lt;name&gt;myvm_system.qcow2&lt;/name&gt;\n"
5844             "  &lt;source&gt;\n"
5845             "  &lt;/source&gt;\n"
5846             "  &lt;capacity unit='KiB'&gt;8388608&lt;/capacity&gt;\n"
5847             "  &lt;allocation unit='KiB'&gt;4194304&lt;/allocation&gt;\n"
5848             "  &lt;target&gt;\n"
5849             "    &lt;format type='qcow2'/&gt;\n"
5850             "  &lt;/target&gt;\n"
5851             "  &lt;backingStore&gt;\n"
5852             "    &lt;path&gt;/path/to/base.raw&lt;/path&gt;\n"
5853             "    &lt;format type='raw'/&gt;\n"
5854             "  &lt;/backingStore&gt;\n"
5855             "&lt;/volume&gt;"
5856         )
5857         pool_mock.createXML.assert_called_once_with(expected_xml, 0)
5858         pool_mock.reset_mock()
5859         pool_mock.XMLDesc.return_value = "&lt;pool type='logical'&gt;&lt;/pool&gt;"
5860         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
5861         self.assertTrue(
5862             virt.volume_define(
5863                 "testVG",
5864                 "myvm_system",
5865                 8192,
5866                 backing_store={"path": "/dev/testVG/base"},
5867             )
5868         )
5869         expected_xml = (
5870             "&lt;volume&gt;\n"
5871             "  &lt;name&gt;myvm_system&lt;/name&gt;\n"
5872             "  &lt;source&gt;\n"
5873             "  &lt;/source&gt;\n"
5874             "  &lt;capacity unit='KiB'&gt;8388608&lt;/capacity&gt;\n"
5875             "  &lt;allocation unit='KiB'&gt;8388608&lt;/allocation&gt;\n"
5876             "  &lt;target&gt;\n"
5877             "  &lt;/target&gt;\n"
5878             "  &lt;backingStore&gt;\n"
5879             "    &lt;path&gt;/dev/testVG/base&lt;/path&gt;\n"
5880             "  &lt;/backingStore&gt;\n"
5881             "&lt;/volume&gt;"
5882         )
5883         pool_mock.createXML.assert_called_once_with(expected_xml, 0)
5884     def test_volume_upload(self):
5885         pool_mock = MagicMock()
5886         vol_mock = MagicMock()
5887         pool_mock.storageVolLookupByName.return_value = vol_mock
5888         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
5889         stream_mock = MagicMock()
5890         self.mock_conn.newStream.return_value = stream_mock
5891         open_mock = MagicMock()
5892         close_mock = MagicMock()
5893         with patch.dict(
5894             os.__dict__, {"open": open_mock, "close": close_mock}
5895             self.assertTrue(virt.volume_upload("pool0", "vol1.qcow2", "/path/to/file"))
5896             stream_mock<font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.sendAll.assert_called_once()
5897             stream_mock.finish.assert_called_once()
5898             self.mock_conn.close.assert_called_once()
5899             vol_mock.upload.assert_called_once_with(stream_mock, 0, 0, 0)
5900             stream_mock.sendAll.reset_mock()
5901             vol_mock.upload.</b></font>reset_mock()
5902             self.assertTrue(
5903                 virt.volume_upload(
5904                     "pool0",
5905                     "vol1.qcow2",
5906                     "/path/to/file",
5907                     offset=123,
5908                     length=456,
5909                 )
5910             )
5911             stream_mock<font color="#af7a82"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.sendAll.assert_not_called()
5912             stream_mock.sparseSendAll.assert_called_once()
5913             vol_mock.upload.assert_called_once_with(
5914                 stream_mock,
5915                 123,
5916                 456,
5917                 self.mock_libvirt.VIR_STORAGE_VOL_UPLOAD_SPARSE_STREAM,
5918             )
5919             vol_mock.upload.</b></font>side_effect = self.mock_libvirt.libvirtError("Unsupported")
5920             self.assertRaisesRegex(
5921                 CommandExecutionError,
5922                 "Unsupported",
5923                 virt.volume_upload,
5924                 "pool0",
5925                 "vol1.qcow2",
5926                 "/path/to/file",
5927             )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
