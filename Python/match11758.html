<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for vsanmgmtObjects.py &amp; test_virt_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for vsanmgmtObjects.py &amp; test_virt_1.py
      </h3>
<h1 align="center">
        13.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>vsanmgmtObjects.py (54.909985%)<th>test_virt_1.py (7.989046%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1086-1424)<td><a href="#" name="0">(4790-4976)</a><td align="center"><font color="#ff0000">80</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(970-1080)<td><a href="#" name="1">(2373-2456)</a><td align="center"><font color="#660000">32</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(3751-3907)<td><a href="#" name="2">(570-582)</a><td align="center"><font color="#590000">28</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(62-193)<td><a href="#" name="3">(5087-5133)</a><td align="center"><font color="#590000">28</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(2997-3078)<td><a href="#" name="4">(6013-6021)</a><td align="center"><font color="#560000">27</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(800-883)<td><a href="#" name="5">(3836-3873)</a><td align="center"><font color="#520000">26</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(3128-3183)<td><a href="#" name="6">(6421-6426)</a><td align="center"><font color="#490000">23</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(2537-2599)<td><a href="#" name="7">(6007-6013)</a><td align="center"><font color="#490000">23</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(2325-2381)<td><a href="#" name="8">(6756-6781)</a><td align="center"><font color="#490000">23</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(2486-2534)<td><a href="#" name="9">(5190-5202)</a><td align="center"><font color="#420000">21</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(1511-1592)<td><a href="#" name="10">(732-762)</a><td align="center"><font color="#420000">21</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(2664-2718)<td><a href="#" name="11">(6988-6995)</a><td align="center"><font color="#390000">18</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(236-307)<td><a href="#" name="12">(1475-1501)</a><td align="center"><font color="#390000">18</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(1621-1693)<td><a href="#" name="13">(4006-4034)</a><td align="center"><font color="#360000">17</font>
<tr onclick='openModal("#842dce")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#842dce"><font color="#842dce">-</font><td><a href="#" name="14">(508-583)<td><a href="#" name="14">(6681-6708)</a><td align="center"><font color="#360000">17</font>
<tr onclick='openModal("#f52887")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f52887"><font color="#f52887">-</font><td><a href="#" name="15">(3548-3595)<td><a href="#" name="15">(5998-6006)</a><td align="center"><font color="#330000">16</font>
<tr onclick='openModal("#2981b2")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#2981b2"><font color="#2981b2">-</font><td><a href="#" name="16">(3496-3533)<td><a href="#" name="16">(5903-5911)</a><td align="center"><font color="#330000">16</font>
<tr onclick='openModal("#3090c7")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3090c7"><font color="#3090c7">-</font><td><a href="#" name="17">(406-448)<td><a href="#" name="17">(6310-6345)</a><td align="center"><font color="#330000">16</font>
<tr onclick='openModal("#800517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#800517"><font color="#800517">-</font><td><a href="#" name="18">(2131-2171)<td><a href="#" name="18">(6858-6866)</a><td align="center"><font color="#2f0000">15</font>
<tr onclick='openModal("#f62817")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f62817"><font color="#f62817">-</font><td><a href="#" name="19">(3373-3397)<td><a href="#" name="19">(1331-1341)</a><td align="center"><font color="#2c0000">14</font>
<tr onclick='openModal("#4e9258")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4e9258"><font color="#4e9258">-</font><td><a href="#" name="20">(2814-2859)<td><a href="#" name="20">(122-142)</a><td align="center"><font color="#2c0000">14</font>
<tr onclick='openModal("#947010")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#947010"><font color="#947010">-</font><td><a href="#" name="21">(2051-2081)<td><a href="#" name="21">(6021-6026)</a><td align="center"><font color="#2c0000">14</font>
<tr onclick='openModal("#4cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4cc417"><font color="#4cc417">-</font><td><a href="#" name="22">(3613-3645)<td><a href="#" name="22">(3922-3933)</a><td align="center"><font color="#290000">13</font>
<tr onclick='openModal("#f660ab")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f660ab"><font color="#f660ab">-</font><td><a href="#" name="23">(3412-3431)<td><a href="#" name="23">(3225-3247)</a><td align="center"><font color="#290000">13</font>
<tr onclick='openModal("#79764d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#79764d"><font color="#79764d">-</font><td><a href="#" name="24">(2741-2782)<td><a href="#" name="24">(1729-1737)</a><td align="center"><font color="#290000">13</font>
<tr onclick='openModal("#5eac10")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#5eac10"><font color="#5eac10">-</font><td><a href="#" name="25">(2384-2428)<td><a href="#" name="25">(822-833)</a><td align="center"><font color="#290000">13</font>
<tr onclick='openModal("#68818b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#68818b"><font color="#68818b">-</font><td><a href="#" name="26">(2242-2266)<td><a href="#" name="26">(2647-2661)</a><td align="center"><font color="#290000">13</font>
<tr onclick='openModal("#e77471")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#e77471"><font color="#e77471">-</font><td><a href="#" name="27">(2210-2232)<td><a href="#" name="27">(2338-2372)</a><td align="center"><font color="#290000">13</font>
<tr onclick='openModal("#717d7d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#717d7d"><font color="#717d7d">-</font><td><a href="#" name="28">(2083-2115)<td><a href="#" name="28">(2200-2209)</a><td align="center"><font color="#290000">13</font>
<tr onclick='openModal("#af7a82")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#af7a82"><font color="#af7a82">-</font><td><a href="#" name="29">(450-494)<td><a href="#" name="29">(7006-7016)</a><td align="center"><font color="#290000">13</font>
<tr onclick='openModal("#ae694a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ae694a"><font color="#ae694a">-</font><td><a href="#" name="30">(3655-3688)<td><a href="#" name="30">(6490-6492)</a><td align="center"><font color="#260000">12</font>
<tr onclick='openModal("#3ea99f")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3ea99f"><font color="#3ea99f">-</font><td><a href="#" name="31">(3437-3459)<td><a href="#" name="31">(6487-6489)</a><td align="center"><font color="#260000">12</font>
<tr onclick='openModal("#5b8daf")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#5b8daf"><font color="#5b8daf">-</font><td><a href="#" name="32">(1879-1912)<td><a href="#" name="32">(5557-5565)</a><td align="center"><font color="#260000">12</font>
<tr onclick='openModal("#736aff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#736aff"><font color="#736aff">-</font><td><a href="#" name="33">(665-704)<td><a href="#" name="33">(1346-1355)</a><td align="center"><font color="#260000">12</font>
<tr onclick='openModal("#827d6b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#827d6b"><font color="#827d6b">-</font><td><a href="#" name="34">(590-644)<td><a href="#" name="34">(3333-3354)</a><td align="center"><font color="#260000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>vsanmgmtObjects.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
# pylint: skip-file
from pyVmomi.VmomiSupport import (
    CreateDataType,
    CreateManagedType,
    CreateEnumType,
    AddVersion,
    AddVersionParent,
    F_LINK,
    F_LINKABLE,
    F_OPTIONAL,
)

CreateManagedType(
    "vim.cluster.VsanPerformanceManager",
    "VsanPerformanceManager",
    "vmodl.ManagedObject",
    "vim.version.version9",
    [],
    [
        (
            "setStatsObjectPolicy",
            "VsanPerfSetStatsObjectPolicy",
            "vim.version.version9",
            (
                (
                    "cluster",
                    "vim.ComputeResource",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
                (
                    "profile",
                    "vim.vm.ProfileSpec",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
            ),
            (0, "boolean", "boolean"),
            "System.Read",
            None,
        ),
        (
            "deleteStatsObject",
            "VsanPerfDeleteStatsObject",
            "vim.version.version9",
            (
                (
                    "cluster",
                    "vim.ComputeResource",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
            ),
            (0, "boolean", "boolean"),
            "System.Read",
<a name="3"></a>            None,
        ),
        (
            <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"createStatsObjectTask",
            "VsanPerfCreateStatsObjectTask",
            "vim.version.version9",
            (
                (
                    "cluster",
                    "vim.ComputeResource",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
                (
                    "profile",
                    "vim.vm.ProfileSpec",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
            ),
            (0, "vim.Task", "vim.Task"),
            "System.Read",
            None,
        ),
        (
            "deleteStatsObjectTask",
            "VsanPerfDeleteStatsObjectTask",
            "vim.version.version9",
            (
                (
                    "cluster",
                    "vim.ComputeResource",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
            ),
            (0, "vim.Task", "vim.Task"),
            "System.Read",
            None,
        ),
        (
            "queryClusterHealth",
            "VsanPerfQueryClusterHealth",
            "vim.version.version9",
            (
                (
                    "cluster",
                    "vim.ClusterComputeResource",
                    "vim.version.version9",
                    0,
                    None,
                ),
            ),
            (0, "vmodl.DynamicData[]", "vmodl.DynamicData[]"),
            "System.Read",
            None,
        ),
        (
            "queryStatsObjectInformation",
            "VsanPerfQueryStatsObjectInformation",
            "vim.version.version9",
            (
                (
                    "cluster",
                    "vim.ComputeResource",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
            ),
            (
                0,
                "vim.cluster.VsanObjectInformation",
                "vim.cluster.VsanObjectInformation",
            ),
            "System.Read",
            None,
        ),
        (
            "queryNodeInformation",
            "VsanPerfQueryNodeInformation",
            "vim.version.version9",
            (
                (
                    "cluster",
                    "vim.ComputeResource",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
            ),
            (
                0 | F_OPTIONAL,
                "vim.cluster.VsanPerfNodeInformation[]",
                "vim.cluster.VsanPerfNodeInformation[]",
            ),
            "System.Read",
            None,
        ),
        (
            "queryVsanPerf",
            "VsanPerfQueryPerf",
            "vim.version.version9",
            (
                (
                    "querySpecs",
                    "vim.cluster.VsanPerfQuerySpec[]",
                    "vim.version.version9",
                    0,
                    None,
                ),
                (
                    "cluster",
                    "vim.ComputeResource",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
            ),
            (
                0,
                "vim.cluster.VsanPerfEntityMetricCSV[]",
                "vim.cluster.VsanPerfEntityMetricCSV[]",
            ),
            "System.Read",
            None,
        ),
        (
            "getSupportedEntityTypes",
            "VsanPerfGetSupportedEntityTypes",
            "vim.version.version9",
            tuple(</b></font>),
            (
                0 | F_OPTIONAL,
                "vim.cluster.VsanPerfEntityType[]",
                "vim.cluster.VsanPerfEntityType[]",
            ),
            "System.Read",
            None,
        ),
        (
            "createStatsObject",
            "VsanPerfCreateStatsObject",
            "vim.version.version9",
            (
                (
                    "cluster",
                    "vim.ComputeResource",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
                (
                    "profile",
                    "vim.vm.ProfileSpec",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
            ),
            (0, "string", "string"),
            "System.Read",
            None,
        ),
    ],
)
CreateManagedType(
    "vim.cluster.VsanVcDiskManagementSystem",
    "VimClusterVsanVcDiskManagementSystem",
    "vmodl.ManagedObject",
    "vim.version.version10",
<a name="12"></a>    [],
    [
        (
            <font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"initializeDiskMappings",
            "InitializeDiskMappings",
            "vim.version.version10",
            (
                (
                    "spec",
                    "vim.vsan.host.DiskMappingCreationSpec",
                    "vim.version.version10",
                    0,
                    None,
                ),
            ),
            (0, "vim.Task", "vim.Task"),
            "System.Read",
            None,
        ),
        (
            "retrieveAllFlashCapabilities",
            "RetrieveAllFlashCapabilities",
            "vim.version.version10",
            (
                (
                    "cluster",
                    "vim.ClusterComputeResource",
                    "vim.version.version10",
                    0,
                    None,
                ),
            ),
            (
                0 | F_OPTIONAL,
                "vim.vsan.host.VsanHostCapability[]",
                "vim.vsan.host.VsanHostCapability[]",
            ),
            "System.Read",
            None,
        ),
        (
            "queryDiskMappings",
            "QueryDiskMappings",
            "vim.version.version10",
            (("host", "vim.HostSystem", "vim.version.version10", 0, None),),
            (
                0 | F_OPTIONAL,
                "vim.vsan.host.DiskMapInfoEx[]",
                "vim.vsan.host.DiskMapInfoEx[]",
            ),
            "System.Read",
            None,
        ),
    ],
)
CreateManagedType(
    "vim.cluster.VsanObjectSystem",
    "VsanObjectSystem",
    "vmodl.ManagedObject",
    "vim.version.version9",
    [],
    [
        (
            "setVsanObjectPolicy",
            "VosSetVsanObjectPolicy",
            "vim.version.version9",
            (
                (
                    "cluster",
                    "vim.ComputeResource",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
                ("vsanObjectUuid"</b></font>, "string", "vim.version.version9", 0, None),
                (
                    "profile",
                    "vim.vm.ProfileSpec",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
            ),
            (0, "boolean", "boolean"),
            "System.Read",
            None,
        ),
        (
            "queryObjectIdentities",
            "VsanQueryObjectIdentities",
            "vim.version.version9",
            (
                (
                    "cluster",
                    "vim.ComputeResource",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
                ("objUuids", "string[]", "vim.version.version9", 0 | F_OPTIONAL, None),
                (
                    "includeHealth",
                    "boolean",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
                (
                    "includeObjIdentity",
                    "boolean",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
                (
                    "includeSpaceSummary",
                    "boolean",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
            ),
            (
                0 | F_OPTIONAL,
                "vim.cluster.VsanObjectIdentityAndHealth",
                "vim.cluster.VsanObjectIdentityAndHealth",
            ),
            "System.Read",
            None,
        ),
        (
            "queryVsanObjectInformation",
            "VosQueryVsanObjectInformation",
            "vim.version.version9",
            (
                (
                    "cluster",
                    "vim.ComputeResource",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
                (
                    "vsanObjectQuerySpecs",
                    "vim.cluster.VsanObjectQuerySpec[]",
                    "vim.version.version9",
                    0,
                    None,
                ),
            ),
            (
                0,
                "vim.cluster.VsanObjectInformation[]",
                "vim.cluster.VsanObjectInformation[]",
            ),
            "System.Read",
            None,
        ),
    ],
)
CreateManagedType(
    "vim.host.VsanStretchedClusterSystem",
    "VimHostVsanStretchedClusterSystem",
    "vmodl.ManagedObject",
    "vim.version.version10",
    [],
    [
        (
            "getStretchedClusterInfoFromCmmds",
            "VSANHostGetStretchedClusterInfoFromCmmds",
<a name="17"></a>            "vim.version.version10",
            tuple(),
            (
                <font color="#3090c7"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>0 | F_OPTIONAL,
                "vim.host.VSANStretchedClusterHostInfo[]",
                "vim.host.VSANStretchedClusterHostInfo[]",
            ),
            "System.Read",
            None,
        ),
        (
            "witnessJoinVsanCluster",
            "VSANWitnessJoinVsanCluster",
            "vim.version.version10",
            (
                ("clusterUuid", "string", "vim.version.version10", 0, None),
                ("preferredFd", "string", "vim.version.version10", 0, None),
                (
                    "disableVsanAllowed",
                    "boolean",
                    "vim.version.version10",
                    0 | F_OPTIONAL,
                    None,
                ),
            ),
            (0, "void", "void"),
            "System.Read",
            None,
        ),
        (
            "witnessSetPreferredFaultDomain",
            "VSANWitnessSetPreferredFaultDomain",
            "vim.version.version10",
            (("preferredFd", "string", "vim.version.version10", 0, None),),
            (0, "void", "void"),
            "System.Read",
            None,
        ),
        (
            "addUnicastAgent",
            "VSANHostAddUnicastAgent",
            "vim.version.version10",
            (
                ("witnessAddress", "string", "vim.version.version10", 0, None),
<a name="29"></a>                ("witnessPort", "int", "vim.version.version10", 0 | F_OPTIONAL, None),
                ("overwrite"</b></font>, "boolean", "vim.version.version10", 0 | F_OPTIONAL, None),
            ),
            (<font color="#af7a82"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>0, "void", "void"),
            "System.Read",
            None,
        ),
        (
            "clusterGetPreferredFaultDomain",
            "VSANClusterGetPreferredFaultDomain",
            "vim.version.version10",
            tuple(),
            (
                0 | F_OPTIONAL,
                "vim.host.VSANCmmdsPreferredFaultDomainInfo",
                "vim.host.VSANCmmdsPreferredFaultDomainInfo",
            ),
            "System.Read",
            None,
        ),
        (
            "witnessLeaveVsanCluster",
            "VSANWitnessLeaveVsanCluster",
            "vim.version.version10",
            tuple(),
            (0, "void", "void"),
            "System.Read",
            None,
        ),
        (
            "getStretchedClusterCapability",
            "VSANHostGetStretchedClusterCapability",
            "vim.version.version10",
            tuple(),
            (
                0,
                "vim.host.VSANStretchedClusterHostCapability",
                "vim.host.VSANStretchedClusterHostCapability",
            ),
            "System.Read",
            None,
        ),
        (
            "removeUnicastAgent",
            "VSANHostRemoveUnicastAgent",
            "vim.version.version10",
            (
                ("witnessAddress"</b></font>, "string", "vim.version.version10", 0, None),
                (
                    "ignoreExistence",
                    "boolean",
                    "vim.version.version10",
                    0 | F_OPTIONAL,
                    None,
                ),
            ),
            (0, "void", "void"),
            "System.Read",
<a name="14"></a>            None,
        ),
        (
            <font color="#842dce"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"listUnicastAgent",
            "VSANHostListUnicastAgent",
            "vim.version.version10",
            tuple(),
            (0, "string", "string"),
            "System.Read",
            None,
        ),
    ],
)
CreateManagedType(
    "vim.VsanUpgradeSystemEx",
    "VsanUpgradeSystemEx",
    "vmodl.ManagedObject",
    "vim.version.version10",
    [],
    [
        (
            "performUpgrade",
            "PerformVsanUpgradeEx",
            "vim.version.version10",
            (
                (
                    "cluster",
                    "vim.ClusterComputeResource",
                    "vim.version.version10",
                    0,
                    None,
                ),
                (
                    "performObjectUpgrade",
                    "boolean",
                    "vim.version.version10",
                    0 | F_OPTIONAL,
                    None,
                ),
                (
                    "downgradeFormat",
                    "boolean",
                    "vim.version.version10",
                    0 | F_OPTIONAL,
                    None,
                ),
                (
                    "allowReducedRedundancy",
                    "boolean",
                    "vim.version.version10",
                    0 | F_OPTIONAL,
                    None,
                ),
                (
                    "excludeHosts",
                    "vim.HostSystem[]",
                    "vim.version.version10",
                    0 | F_OPTIONAL,
                    None,
                ),
                (
                    "spec",
                    "vim.cluster.VsanDiskFormatConversionSpec",
                    "vim.version.version10",
                    0 | F_OPTIONAL,
                    None,
                ),
            ),
            (0, "vim.Task", "vim.Task"),
            "System.Read",
            None,
        ),
        (
            "performUpgradePreflightCheck",
            "PerformVsanUpgradePreflightCheckEx",
            "vim.version.version10",
            (
                (
                    "cluster"</b></font>,
                    "vim.ClusterComputeResource",
                    "vim.version.version10",
                    0,
<a name="34"></a>                    None,
                ),
                (
                    <font color="#827d6b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"downgradeFormat",
                    "boolean",
                    "vim.version.version10",
                    0 | F_OPTIONAL,
                    None,
                ),
                (
                    "spec",
                    "vim.cluster.VsanDiskFormatConversionSpec",
                    "vim.version.version10",
                    0 | F_OPTIONAL,
                    None,
                ),
            ),
            (
                0,
                "vim.cluster.VsanDiskFormatConversionCheckResult",
                "vim.cluster.VsanDiskFormatConversionCheckResult",
            ),
            "System.Read",
            None,
        ),
        (
            "retrieveSupportedFormatVersion",
            "RetrieveSupportedVsanFormatVersion",
            "vim.version.version10",
            (
                (
                    "cluster",
                    "vim.ClusterComputeResource",
                    "vim.version.version10",
                    0,
                    None,
                ),
            ),
            (0, "int", "int"),
            "System.Read",
            None,
        ),
    ],
)
CreateManagedType(
    "vim.cluster.VsanCapabilitySystem",
    "VsanCapabilitySystem",
    "vmodl.ManagedObject",
    "vim.version.version10",
    [],
    [
        (
            "getCapabilities",
            "VsanGetCapabilities",
            "vim.version.version10",
            (
                (
                    "targets"</b></font>,
                    "vmodl.ManagedObject[]",
                    "vim.version.version10",
                    0 | F_OPTIONAL,
                    None,
                ),
            ),
            (0, "vim.cluster.VsanCapability[]", "vim.cluster.VsanCapability[]"),
            "System.Read",
            None,
        ),
    ],
)
CreateManagedType(
    "vim.cluster.VsanSpaceReportSystem",
    "VsanSpaceReportSystem",
    "vmodl.ManagedObject",
    "vim.version.version9",
<a name="33"></a>    [],
    [
        (
            <font color="#736aff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"querySpaceUsage",
            "VsanQuerySpaceUsage",
            "vim.version.version9",
            (("cluster", "vim.ComputeResource", "vim.version.version9", 0, None),),
            (0, "vim.cluster.VsanSpaceUsage", "vim.cluster.VsanSpaceUsage"),
            "System.Read",
            None,
        ),
    ],
)
CreateManagedType(
    "vim.cluster.VsanVcClusterConfigSystem",
    "VsanVcClusterConfigSystem",
    "vmodl.ManagedObject",
    "vim.version.version10",
    [],
    [
        (
            "getConfigInfoEx",
            "VsanClusterGetConfig",
            "vim.version.version10",
            (
                (
                    "cluster",
                    "vim.ClusterComputeResource",
                    "vim.version.version10",
                    0,
                    None,
                ),
            ),
            (0, "vim.vsan.ConfigInfoEx", "vim.vsan.ConfigInfoEx"),
            "System.Read",
            None,
        ),
        (
            "reconfigureEx",
            "VsanClusterReconfig",
            "vim.version.version10",
            (
                (</b></font>
                    "cluster",
                    "vim.ClusterComputeResource",
                    "vim.version.version10",
                    0,
                    None,
                ),
                (
                    "vsanReconfigSpec",
                    "vim.vsan.ReconfigSpec",
                    "vim.version.version10",
                    0,
                    None,
                ),
            ),
            (0, "vim.Task", "vim.Task"),
            "System.Read",
            None,
        ),
    ],
)
CreateManagedType(
    "vim.host.VsanHealthSystem",
    "HostVsanHealthSystem",
    "vmodl.ManagedObject",
    "vim.version.version9",
    [],
    [
        (
            "queryAdvCfg",
            "VsanHostQueryAdvCfg",
            "vim.version.version9",
            (("options", "string[]", "vim.version.version9", 0, None),),
            (0, "vim.option.OptionValue[]", "vim.option.OptionValue[]"),
            "System.Read",
            None,
        ),
        (
            "queryPhysicalDiskHealthSummary",
            "VsanHostQueryPhysicalDiskHealthSummary",
            "vim.version.version9",
            tuple(),
            (
                0,
                "vim.host.VsanPhysicalDiskHealthSummary",
                "vim.host.VsanPhysicalDiskHealthSummary",
            ),
            "System.Read",
            None,
        ),
        (
            "startProactiveRebalance",
            "VsanStartProactiveRebalance",
            "vim.version.version9",
            (
                ("timeSpan", "int", "vim.version.version9", 0 | F_OPTIONAL, None),
                (
                    "varianceThreshold",
                    "float",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
                ("timeThreshold", "int", "vim.version.version9", 0 | F_OPTIONAL, None),
                ("rateThreshold", "int", "vim.version.version9", 0 | F_OPTIONAL, None),
            ),
            (0, "boolean", "boolean"),
            "System.Read",
            None,
        ),
        (
            "queryHostInfoByUuids",
            "VsanHostQueryHostInfoByUuids",
            "vim.version.version9",
            (("uuids", "string[]", "vim.version.version9", 0, None),),
            (
                0,
                "vim.host.VsanQueryResultHostInfo[]",
                "vim.host.VsanQueryResultHostInfo[]",
            ),
            "System.Read",
            None,
        ),
        (
            "queryVersion",
            "VsanHostQueryHealthSystemVersion",
            "vim.version.version9",
            tuple(),
            (0, "string", "string"),
            "System.Read",
            None,
        ),
        (
<a name="5"></a>            "queryVerifyNetworkSettings",
            "VsanHostQueryVerifyNetworkSettings",
            "vim.version.version9",
            (<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("peers", "string[]", "vim.version.version9", 0 | F_OPTIONAL, None),),
            (0, "vim.host.VsanNetworkHealthResult", "vim.host.VsanNetworkHealthResult"),
            "System.Read",
            None,
        ),
        (
            "queryRunIperfClient",
            "VsanHostQueryRunIperfClient",
            "vim.version.version9",
            (
                ("multicast", "boolean", "vim.version.version9", 0, None),
                ("serverIp", "string", "vim.version.version9", 0, None),
            ),
            (
                0,
                "vim.host.VsanNetworkLoadTestResult",
                "vim.host.VsanNetworkLoadTestResult",
            ),
            "System.Read",
            None,
        ),
        (
            "runVmdkLoadTest",
            "VsanHostRunVmdkLoadTest",
            "vim.version.version9",
            (
                ("runname", "string", "vim.version.version9", 0, None),
                ("durationSec", "int", "vim.version.version9", 0, None),
                (
                    "specs",
                    "vim.host.VsanVmdkLoadTestSpec[]",
                    "vim.version.version9",
                    0,
                    None,
                ),
            ),
            (
                0,
                "vim.host.VsanVmdkLoadTestResult[]",
                "vim.host.VsanVmdkLoadTestResult[]",
            ),
            "System.Read",
            None,
        ),
        (
            "queryObjectHealthSummary",
            "VsanHostQueryObjectHealthSummary",
            "vim.version.version9",
            (
                ("objUuids", "string[]", "vim.version.version9", 0 | F_OPTIONAL, None),
                (
                    "includeObjUuids",
                    "boolean",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
                (
                    "localHostOnly",
                    "boolean",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
            ),
            (0, "vim.host.VsanObjectOverallHealth", "vim.host.VsanObjectOverallHealth"),
            "System.Read",
            None,
        ),
        (
            "getHclInfo",
            "VsanGetHclInfo",
            "vim.version.version9",
            tuple(),
            (0, "vim.host.VsanHostHclInfo", "vim.host.VsanHostHclInfo"),
            "System.Read",
            None,
        ),
        (
            "cleanupVmdkLoadTest",
            "VsanHostCleanupVmdkLoadTest",
            "vim.version.version9",
            (
                ("runname"</b></font>, "string", "vim.version.version9", 0, None),
                (
                    "specs",
                    "vim.host.VsanVmdkLoadTestSpec[]",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
            ),
            (0, "string", "string"),
            "System.Read",
            None,
        ),
        (
            "waitForVsanHealthGenerationIdChange",
            "VsanWaitForVsanHealthGenerationIdChange",
            "vim.version.version9",
            (("timeout", "int", "vim.version.version9", 0, None),),
            (0, "boolean", "boolean"),
            "System.Read",
            None,
        ),
        (
            "stopProactiveRebalance",
            "VsanStopProactiveRebalance",
            "vim.version.version9",
            tuple(),
            (0, "boolean", "boolean"),
            "System.Read",
            None,
        ),
        (
            "repairImmediateObjects",
            "VsanHostRepairImmediateObjects",
            "vim.version.version9",
            (
                ("uuids", "string[]", "vim.version.version9", 0 | F_OPTIONAL, None),
                ("repairType", "string", "vim.version.version9", 0 | F_OPTIONAL, None),
            ),
            (0, "vim.host.VsanRepairObjectsResult", "vim.host.VsanRepairObjectsResult"),
            "System.Read",
            None,
        ),
        (
            "prepareVmdkLoadTest",
            "VsanHostPrepareVmdkLoadTest",
            "vim.version.version9",
            (
                ("runname", "string", "vim.version.version9", 0, None),
                (
                    "specs",
                    "vim.host.VsanVmdkLoadTestSpec[]",
                    "vim.version.version9",
                    0,
                    None,
                ),
            ),
            (0, "string", "string"),
            "System.Read",
            None,
        ),
        (
            "queryRunIperfServer",
            "VsanHostQueryRunIperfServer",
            "vim.version.version9",
            (
                ("multicast", "boolean", "vim.version.version9", 0, None),
                ("serverIp", "string", "vim.version.version9", 0 | F_OPTIONAL, None),
            ),
            (
                0,
                "vim.host.VsanNetworkLoadTestResult",
                "vim.host.VsanNetworkLoadTestResult",
            ),
            "System.Read",
            None,
        ),
        (
            "queryCheckLimits",
            "VsanHostQueryCheckLimits",
            "vim.version.version9",
            tuple(),
            (0, "vim.host.VsanLimitHealthResult", "vim.host.VsanLimitHealthResult"),
            "System.Read",
<a name="1"></a>            None,
        ),
        (
            <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"getProactiveRebalanceInfo",
            "VsanGetProactiveRebalanceInfo",
            "vim.version.version9",
            tuple(),
            (
                0,
                "vim.host.VsanProactiveRebalanceInfoEx",
                "vim.host.VsanProactiveRebalanceInfoEx",
            ),
            "System.Read",
            None,
        ),
        (
            "checkClomdLiveness",
            "VsanHostClomdLiveness",
            "vim.version.version9",
            tuple(),
            (0, "boolean", "boolean"),
            "System.Read",
            None,
        ),
    ],
)
CreateManagedType(
    "vim.cluster.VsanVcClusterHealthSystem",
    "VsanVcClusterHealthSystem",
    "vmodl.ManagedObject",
    "vim.version.version9",
    [],
    [
        (
            "queryClusterCreateVmHealthHistoryTest",
            "VsanQueryVcClusterCreateVmHealthHistoryTest",
            "vim.version.version9",
            (
                (
                    "cluster",
                    "vim.ClusterComputeResource",
                    "vim.version.version9",
                    0,
                    None,
                ),
                ("count", "int", "vim.version.version9", 0 | F_OPTIONAL, None),
            ),
            (
                0 | F_OPTIONAL,
                "vim.cluster.VsanClusterCreateVmHealthTestResult[]",
                "vim.cluster.VsanClusterCreateVmHealthTestResult[]",
            ),
            "System.Read",
            None,
        ),
        (
            "setLogLevel",
            "VsanHealthSetLogLevel",
            "vim.version.version9",
            (
                (
                    "level",
                    "vim.cluster.VsanHealthLogLevelEnum",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
            ),
            (0, "void", "void"),
            "System.Read",
            None,
        ),
        (
            "testVsanClusterTelemetryProxy",
            "VsanHealthTestVsanClusterTelemetryProxy",
            "vim.version.version9",
            (
                (
                    "proxyConfig",
                    "vim.cluster.VsanClusterTelemetryProxyConfig",
                    "vim.version.version9",
                    0,
                    None,
                ),
            ),
            (0, "boolean", "boolean"),
            "System.Read",
            None,
        ),
        (
            "uploadHclDb",
            "VsanVcUploadHclDb",
            "vim.version.version9",
            (("db", "string", "vim.version.version9", 0, None),),
            (0, "boolean", "boolean"),
            "System.Read",
            None,
        ),
        (
            "updateHclDbFromWeb",
            "VsanVcUpdateHclDbFromWeb",
            "vim.version.version9",
            (("url", "string", "vim.version.version9", 0 | F_OPTIONAL, None),),
            (0, "boolean", "boolean"),
            "System.Read",
            None,
        ),
        (
            "repairClusterObjectsImmediate",
            "VsanHealthRepairClusterObjectsImmediate",
            "vim.version.version9",
            (
                (
                    "cluster"</b></font>,
                    "vim.ClusterComputeResource",
                    "vim.version.version9",
<a name="0"></a>                    0,
                    None,
                ),
                (<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"uuids", "string[]", "vim.version.version9", 0 | F_OPTIONAL, None),
            ),
            (0, "vim.Task", "vim.Task"),
            "System.Read",
            None,
        ),
        (
            "queryClusterNetworkPerfTest",
            "VsanQueryVcClusterNetworkPerfTest",
            "vim.version.version9",
            (
                (
                    "cluster",
                    "vim.ClusterComputeResource",
                    "vim.version.version9",
                    0,
                    None,
                ),
                ("multicast", "boolean", "vim.version.version9", 0, None),
            ),
            (
                0,
                "vim.cluster.VsanClusterNetworkLoadTestResult",
                "vim.cluster.VsanClusterNetworkLoadTestResult",
            ),
            "System.Read",
            None,
        ),
        (
            "queryClusterVmdkLoadHistoryTest",
            "VsanQueryVcClusterVmdkLoadHistoryTest",
            "vim.version.version9",
            (
                (
                    "cluster",
                    "vim.ClusterComputeResource",
                    "vim.version.version9",
                    0,
                    None,
                ),
                ("count", "int", "vim.version.version9", 0 | F_OPTIONAL, None),
                ("taskId", "string", "vim.version.version9", 0 | F_OPTIONAL, None),
            ),
            (
                0 | F_OPTIONAL,
                "vim.cluster.VsanClusterVmdkLoadTestResult[]",
                "vim.cluster.VsanClusterVmdkLoadTestResult[]",
            ),
            "System.Read",
            None,
        ),
        (
            "queryVsanClusterHealthCheckInterval",
            "VsanHealthQueryVsanClusterHealthCheckInterval",
            "vim.version.version9",
            (
                (
                    "cluster",
                    "vim.ClusterComputeResource",
                    "vim.version.version9",
                    0,
                    None,
                ),
            ),
            (0, "int", "int"),
            "System.Read",
            None,
        ),
        (
            "queryClusterCreateVmHealthTest",
            "VsanQueryVcClusterCreateVmHealthTest",
            "vim.version.version9",
            (
                (
                    "cluster",
                    "vim.ClusterComputeResource",
                    "vim.version.version9",
                    0,
                    None,
                ),
                ("timeout", "int", "vim.version.version9", 0, None),
            ),
            (
                0,
                "vim.cluster.VsanClusterCreateVmHealthTestResult",
                "vim.cluster.VsanClusterCreateVmHealthTestResult",
            ),
            "System.Read",
            None,
        ),
        (
            "getClusterHclInfo",
            "VsanVcClusterGetHclInfo",
            "vim.version.version9",
            (
                (
                    "cluster",
                    "vim.ClusterComputeResource",
                    "vim.version.version9",
                    0,
                    None,
                ),
                (
                    "includeHostsResult",
                    "boolean",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
            ),
            (0, "vim.cluster.VsanClusterHclInfo", "vim.cluster.VsanClusterHclInfo"),
            "System.Read",
            None,
        ),
        (
            "queryAttachToSrHistory",
            "VsanQueryAttachToSrHistory",
            "vim.version.version9",
            (
                (
                    "cluster",
                    "vim.ClusterComputeResource",
                    "vim.version.version9",
                    0,
                    None,
                ),
                ("count", "int", "vim.version.version9", 0 | F_OPTIONAL, None),
                ("taskId", "string", "vim.version.version9", 0 | F_OPTIONAL, None),
            ),
            (
                0 | F_OPTIONAL,
                "vim.cluster.VsanAttachToSrOperation[]",
                "vim.cluster.VsanAttachToSrOperation[]",
            ),
            "System.Read",
            None,
        ),
        (
            "rebalanceCluster",
            "VsanRebalanceCluster",
            "vim.version.version9",
            (
                (
                    "cluster",
                    "vim.ClusterComputeResource",
                    "vim.version.version9",
                    0,
                    None,
                ),
                (
                    "targetHosts",
                    "vim.HostSystem[]",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
            ),
            (0, "vim.Task", "vim.Task"),
            "System.Read",
            None,
        ),
        (
            "runVmdkLoadTest",
            "VsanVcClusterRunVmdkLoadTest",
            "vim.version.version9",
            (
                (
                    "cluster",
                    "vim.ClusterComputeResource",
                    "vim.version.version9",
                    0,
                    None,
                ),
                ("runname", "string", "vim.version.version9", 0, None),
                ("durationSec", "int", "vim.version.version9", 0 | F_OPTIONAL, None),
                (
                    "specs",
                    "vim.host.VsanVmdkLoadTestSpec[]",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
                ("action", "string", "vim.version.version9", 0 | F_OPTIONAL, None),
            ),
            (0, "vim.Task", "vim.Task"),
            "System.Read",
            None,
        ),
        (
            "sendVsanTelemetry",
            "VsanHealthSendVsanTelemetry",
            "vim.version.version9",
            (
                (
                    "cluster",
                    "vim.ClusterComputeResource",
                    "vim.version.version9",
                    0,
                    None,
                ),
            ),
            (0, "void", "void"),
            "System.Read",
            None,
        ),
        (
            "queryClusterNetworkPerfHistoryTest",
            "VsanQueryVcClusterNetworkPerfHistoryTest",
            "vim.version.version9",
            (
                (
                    "cluster",
                    "vim.ClusterComputeResource",
                    "vim.version.version9",
                    0,
                    None,
                ),
                ("count", "int", "vim.version.version9", 0 | F_OPTIONAL, None),
            ),
            (
                0 | F_OPTIONAL,
                "vim.cluster.VsanClusterNetworkLoadTestResult[]",
                "vim.cluster.VsanClusterNetworkLoadTestResult[]",
            ),
            "System.Read",
            None,
        ),
        (
            "queryClusterHealthSummary",
            "VsanQueryVcClusterHealthSummary",
            "vim.version.version9",
            (
                (
                    "cluster",
                    "vim.ClusterComputeResource",
                    "vim.version.version9",
                    0,
                    None,
                ),
                (
                    "vmCreateTimeout",
                    "int",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
                ("objUuids", "string[]", "vim.version.version9", 0 | F_OPTIONAL, None),
                (
                    "includeObjUuids",
                    "boolean",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
                ("fields", "string[]", "vim.version.version9", 0 | F_OPTIONAL, None),
                (
                    "fetchFromCache",
                    "boolean",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
            ),
            (
                0,
                "vim.cluster.VsanClusterHealthSummary",
                "vim.cluster.VsanClusterHealthSummary",
            ),
            "System.Read",
            None,
        ),
        (
            "stopRebalanceCluster",
            "VsanStopRebalanceCluster",
            "vim.version.version9",
            (
                (
                    "cluster",
                    "vim.ClusterComputeResource",
                    "vim.version.version9",
                    0,
                    None,
                ),
                (
                    "targetHosts",
                    "vim.HostSystem[]",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
            ),
            (0, "vim.Task", "vim.Task"),
            "System.Read",
            None,
        ),
        (
            "queryVsanClusterHealthConfig",
            "VsanHealthQueryVsanClusterHealthConfig",
            "vim.version.version9",
            (
                (
                    "cluster",
                    "vim.ClusterComputeResource",
                    "vim.version.version9",
                    0,
                    None,
                ),
            ),
            (
                0,
                "vim.cluster.VsanClusterHealthConfigs",
                "vim.cluster.VsanClusterHealthConfigs",
            ),
            "System.Read",
            None,
        ),
        (
            "attachVsanSupportBundleToSr",
            "VsanAttachVsanSupportBundleToSr",
            "vim.version.version9",
            (
                (
                    "cluster",
                    "vim.ClusterComputeResource",
                    "vim.version.version9",
                    0,
                    None,
                ),
                ("srNumber", "string", "vim.version.version9", 0, None),
            ),
            (0, "vim.Task", "vim.Task"),
            "System.Read",
            None,
        ),
        (
            "queryClusterVmdkWorkloadTypes",
            "VsanQueryVcClusterVmdkWorkloadTypes",
            "vim.version.version9",
            tuple(</b></font>),
            (
                0,
                "vim.cluster.VsanStorageWorkloadType[]",
                "vim.cluster.VsanStorageWorkloadType[]",
            ),
            "System.Read",
            None,
        ),
        (
            "queryVerifyClusterHealthSystemVersions",
            "VsanVcClusterQueryVerifyHealthSystemVersions",
            "vim.version.version9",
            (
                (
                    "cluster",
                    "vim.ClusterComputeResource",
                    "vim.version.version9",
                    0,
                    None,
                ),
            ),
            (
                0,
                "vim.cluster.VsanClusterHealthSystemVersionResult",
                "vim.cluster.VsanClusterHealthSystemVersionResult",
            ),
            "System.Read",
            None,
        ),
        (
            "isRebalanceRunning",
            "VsanHealthIsRebalanceRunning",
            "vim.version.version9",
            (
                (
                    "cluster",
                    "vim.ClusterComputeResource",
                    "vim.version.version9",
                    0,
                    None,
                ),
                (
                    "targetHosts",
                    "vim.HostSystem[]",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
            ),
            (0, "boolean", "boolean"),
            "System.Read",
            None,
        ),
        (
            "setVsanClusterHealthCheckInterval",
            "VsanHealthSetVsanClusterHealthCheckInterval",
            "vim.version.version9",
            (
                (
                    "cluster",
                    "vim.ClusterComputeResource",
                    "vim.version.version9",
                    0,
                    None,
                ),
                (
                    "vsanClusterHealthCheckInterval",
                    "int",
                    "vim.version.version9",
                    0,
                    None,
                ),
            ),
            (0, "void", "void"),
            "System.Read",
            None,
        ),
    ],
)
CreateManagedType(
    "vim.cluster.VsanVcStretchedClusterSystem",
    "VimClusterVsanVcStretchedClusterSystem",
    "vmodl.ManagedObject",
<a name="10"></a>    "vim.version.version10",
    [],
    [
        <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(
            "isWitnessHost",
            "VSANVcIsWitnessHost",
            "vim.version.version10",
            (("host", "vim.HostSystem", "vim.version.version10", 0, None),),
            (0, "boolean", "boolean"),
            "System.Read",
            None,
        ),
        (
            "setPreferredFaultDomain",
            "VSANVcSetPreferredFaultDomain",
            "vim.version.version10",
            (
                (
                    "cluster",
                    "vim.ClusterComputeResource",
                    "vim.version.version10",
                    0,
                    None,
                ),
                ("preferredFd", "string", "vim.version.version10", 0, None),
                (
                    "witnessHost",
                    "vim.HostSystem",
                    "vim.version.version10",
                    0 | F_OPTIONAL,
                    None,
                ),
            ),
            (0, "vim.Task", "vim.Task"),
            "System.Read",
            None,
        ),
        (
            "getPreferredFaultDomain",
            "VSANVcGetPreferredFaultDomain",
            "vim.version.version10",
            (
                (
                    "cluster",
                    "vim.ClusterComputeResource",
                    "vim.version.version10",
                    0,
                    None,
                ),
            ),
            (
                0 | F_OPTIONAL,
                "vim.cluster.VSANPreferredFaultDomainInfo",
                "vim.cluster.VSANPreferredFaultDomainInfo",
            ),
            "System.Read",
            None,
        ),
        (
            "getWitnessHosts",
            "VSANVcGetWitnessHosts",
            "vim.version.version10",
            (
                (
                    "cluster",
                    "vim.ClusterComputeResource",
                    "vim.version.version10",
                    0,
                    None,
                ),
            ),
            (
                0 | F_OPTIONAL,
                "vim.cluster.VSANWitnessHostInfo[]",
                "vim.cluster.VSANWitnessHostInfo[]",
            ),
            "System.Read",
            None,
        ),
        (
            "retrieveStretchedClusterVcCapability",
            "VSANVcRetrieveStretchedClusterVcCapability",
            "vim.version.version10",
            (
                (</b></font>
                    "cluster",
                    "vim.ClusterComputeResource",
                    "vim.version.version10",
                    0,
                    None,
                ),
                (
                    "verifyAllConnected",
                    "boolean",
                    "vim.version.version10",
                    0 | F_OPTIONAL,
                    None,
                ),
            ),
            (
                0 | F_OPTIONAL,
                "vim.cluster.VSANStretchedClusterCapability[]",
                "vim.cluster.VSANStretchedClusterCapability[]",
            ),
            "System.Read",
            None,
        ),
        (
            "convertToStretchedCluster",
            "VSANVcConvertToStretchedCluster",
<a name="13"></a>            "vim.version.version10",
            (
                (
                    <font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"cluster",
                    "vim.ClusterComputeResource",
                    "vim.version.version10",
                    0,
                    None,
                ),
                (
                    "faultDomainConfig",
                    "vim.cluster.VSANStretchedClusterFaultDomainConfig",
                    "vim.version.version10",
                    0,
                    None,
                ),
                ("witnessHost", "vim.HostSystem", "vim.version.version10", 0, None),
                ("preferredFd", "string", "vim.version.version10", 0, None),
                (
                    "diskMapping",
                    "vim.vsan.host.DiskMapping",
                    "vim.version.version10",
                    0 | F_OPTIONAL,
                    None,
                ),
            ),
            (0, "vim.Task", "vim.Task"),
            "System.Read",
            None,
        ),
        (
            "removeWitnessHost",
            "VSANVcRemoveWitnessHost",
            "vim.version.version10",
            (
                (
                    "cluster",
                    "vim.ClusterComputeResource",
                    "vim.version.version10",
                    0,
                    None,
                ),
                (
                    "witnessHost",
                    "vim.HostSystem",
                    "vim.version.version10",
                    0 | F_OPTIONAL,
                    None,
                ),
                (
                    "witnessAddress",
                    "string",
                    "vim.version.version10",
                    0 | F_OPTIONAL,
                    None,
                ),
            ),
            (0, "vim.Task", "vim.Task"),
            "System.Read",
            None,
        ),
    ],
)
CreateManagedType(
    "vim.cluster.VsanClusterHealthSystem",
    "VsanClusterHealthSystem",
    "vmodl.ManagedObject",
    "vim.version.version9",
    [],
    [
        (
            "queryPhysicalDiskHealthSummary",
            "VsanQueryClusterPhysicalDiskHealthSummary",
            "vim.version.version9",
            (
                ("hosts"</b></font>, "string[]", "vim.version.version9", 0, None),
                ("esxRootPassword", "string", "vim.version.version9", 0, None),
            ),
            (
                0,
                "vim.host.VsanPhysicalDiskHealthSummary[]",
                "vim.host.VsanPhysicalDiskHealthSummary[]",
            ),
            "System.Read",
            None,
        ),
        (
            "queryClusterNetworkPerfTest",
            "VsanQueryClusterNetworkPerfTest",
            "vim.version.version9",
            (
                ("hosts", "string[]", "vim.version.version9", 0, None),
                ("esxRootPassword", "string", "vim.version.version9", 0, None),
                ("multicast", "boolean", "vim.version.version9", 0, None),
            ),
            (
                0,
                "vim.cluster.VsanClusterNetworkLoadTestResult",
                "vim.cluster.VsanClusterNetworkLoadTestResult",
            ),
            "System.Read",
            None,
        ),
        (
            "queryAdvCfgSync",
            "VsanQueryClusterAdvCfgSync",
            "vim.version.version9",
            (
                ("hosts", "string[]", "vim.version.version9", 0, None),
                ("esxRootPassword", "string", "vim.version.version9", 0, None),
            ),
            (
                0,
                "vim.cluster.VsanClusterAdvCfgSyncResult[]",
                "vim.cluster.VsanClusterAdvCfgSyncResult[]",
            ),
            "System.Read",
            None,
        ),
        (
            "repairClusterImmediateObjects",
            "VsanRepairClusterImmediateObjects",
            "vim.version.version9",
            (
                ("hosts", "string[]", "vim.version.version9", 0, None),
                ("esxRootPassword", "string", "vim.version.version9", 0, None),
                ("uuids", "string[]", "vim.version.version9", 0 | F_OPTIONAL, None),
            ),
            (
                0,
                "vim.cluster.VsanClusterHealthSystemObjectsRepairResult",
                "vim.cluster.VsanClusterHealthSystemObjectsRepairResult",
            ),
            "System.Read",
            None,
        ),
        (
            "queryVerifyClusterNetworkSettings",
            "VsanQueryVerifyClusterNetworkSettings",
            "vim.version.version9",
            (
                ("hosts", "string[]", "vim.version.version9", 0, None),
                ("esxRootPassword", "string", "vim.version.version9", 0, None),
            ),
            (
                0,
                "vim.cluster.VsanClusterNetworkHealthResult",
                "vim.cluster.VsanClusterNetworkHealthResult",
            ),
            "System.Read",
            None,
        ),
        (
            "queryClusterCreateVmHealthTest",
            "VsanQueryClusterCreateVmHealthTest",
            "vim.version.version9",
            (
                ("hosts", "string[]", "vim.version.version9", 0, None),
                ("esxRootPassword", "string", "vim.version.version9", 0, None),
                ("timeout", "int", "vim.version.version9", 0, None),
            ),
            (
                0,
                "vim.cluster.VsanClusterCreateVmHealthTestResult",
                "vim.cluster.VsanClusterCreateVmHealthTestResult",
            ),
            "System.Read",
            None,
        ),
        (
            "queryClusterHealthSystemVersions",
            "VsanQueryClusterHealthSystemVersions",
            "vim.version.version9",
            (
                ("hosts", "string[]", "vim.version.version9", 0, None),
                ("esxRootPassword", "string", "vim.version.version9", 0, None),
            ),
            (
                0,
                "vim.cluster.VsanClusterHealthSystemVersionResult",
                "vim.cluster.VsanClusterHealthSystemVersionResult",
            ),
            "System.Read",
            None,
        ),
        (
            "getClusterHclInfo",
            "VsanClusterGetHclInfo",
            "vim.version.version9",
            (
                ("hosts", "string[]", "vim.version.version9", 0, None),
                ("esxRootPassword", "string", "vim.version.version9", 0, None),
            ),
            (0, "vim.cluster.VsanClusterHclInfo", "vim.cluster.VsanClusterHclInfo"),
            "System.Read",
            None,
        ),
        (
            "queryCheckLimits",
            "VsanQueryClusterCheckLimits",
            "vim.version.version9",
            (
                ("hosts", "string[]", "vim.version.version9", 0, None),
                ("esxRootPassword", "string", "vim.version.version9", 0, None),
            ),
            (
                0,
                "vim.cluster.VsanClusterLimitHealthResult",
                "vim.cluster.VsanClusterLimitHealthResult",
            ),
            "System.Read",
            None,
        ),
        (
            "queryCaptureVsanPcap",
            "VsanQueryClusterCaptureVsanPcap",
            "vim.version.version9",
            (
                ("hosts", "string[]", "vim.version.version9", 0, None),
                ("esxRootPassword", "string", "vim.version.version9", 0, None),
                ("duration", "int", "vim.version.version9", 0, None),
                (
                    "vmknic",
                    "vim.cluster.VsanClusterHostVmknicMapping[]",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
                (
                    "includeRawPcap",
                    "boolean",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
                (
                    "includeIgmp",
                    "boolean",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
                (
                    "cmmdsMsgTypeFilter",
                    "string[]",
                    "vim.version.version9",
                    0 | F_OPTIONAL,
                    None,
                ),
                ("cmmdsPorts", "int[]", "vim.version.version9", 0 | F_OPTIONAL, None),
                ("clusterUuid", "string", "vim.version.version9", 0 | F_OPTIONAL, None),
            ),
            (
                0,
                "vim.cluster.VsanVsanClusterPcapResult",
                "vim.cluster.VsanVsanClusterPcapResult",
            ),
            "System.Read",
<a name="32"></a>            None,
        ),
        (
            <font color="#5b8daf"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"checkClusterClomdLiveness",
            "VsanCheckClusterClomdLiveness",
            "vim.version.version9",
            (
                ("hosts", "string[]", "vim.version.version9", 0, None),
                ("esxRootPassword", "string", "vim.version.version9", 0, None),
            ),
            (
                0,
                "vim.cluster.VsanClusterClomdLivenessResult",
                "vim.cluster.VsanClusterClomdLivenessResult",
            ),
            "System.Read",
            None,
        ),
    ],
)
CreateDataType(
    "vim.host.VSANCmmdsNodeInfo",
    "VimHostVSANCmmdsNodeInfo",
    "vmodl.DynamicData",
    "vim.version.version10",
    [
        ("nodeUuid", "string", "vim.version.version10", 0),
        ("isWitness", "boolean", "vim.version.version10", 0),
    ],
)
CreateDataType(
    "vim.host.VsanPhysicalDiskHealth",
    "VsanPhysicalDiskHealth",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("name"</b></font>, "string", "vim.version.version9", 0),
        ("uuid", "string", "vim.version.version9", 0),
        ("inCmmds", "boolean", "vim.version.version9", 0),
        ("inVsi", "boolean", "vim.version.version9", 0),
        ("dedupScope", "long", "vim.version.version9", 0 | F_OPTIONAL),
        ("formatVersion", "int", "vim.version.version9", 0 | F_OPTIONAL),
        ("isAllFlash", "int", "vim.version.version9", 0 | F_OPTIONAL),
        ("congestionValue", "int", "vim.version.version9", 0 | F_OPTIONAL),
        ("congestionArea", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("congestionHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("metadataHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
        (
            "operationalHealthDescription",
            "string",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        ("operationalHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("dedupUsageHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("capacityHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("summaryHealth", "string", "vim.version.version9", 0),
        ("capacity", "long", "vim.version.version9", 0 | F_OPTIONAL),
        ("usedCapacity", "long", "vim.version.version9", 0 | F_OPTIONAL),
        ("reservedCapacity", "long", "vim.version.version9", 0 | F_OPTIONAL),
        ("totalBytes", "long", "vim.version.version9", 0 | F_OPTIONAL),
        ("freeBytes", "long", "vim.version.version9", 0 | F_OPTIONAL),
        ("hashedBytes", "long", "vim.version.version9", 0 | F_OPTIONAL),
        ("dedupedBytes", "long", "vim.version.version9", 0 | F_OPTIONAL),
        ("scsiDisk", "vim.host.ScsiDisk", "vim.version.version9", 0 | F_OPTIONAL),
        ("usedComponents", "long", "vim.version.version9", 0 | F_OPTIONAL),
        ("maxComponents", "long", "vim.version.version9", 0 | F_OPTIONAL),
        ("compLimitHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.vsan.DataEfficiencyConfig",
    "VsanDataEfficiencyConfig",
    "vmodl.DynamicData",
    "vim.version.version10",
    [
        ("dedupEnabled", "boolean", "vim.version.version10", 0),
        ("compressionEnabled", "boolean", "vim.version.version10", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.cluster.StorageComplianceResult",
    "VsanStorageComplianceResult",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("checkTime", "vmodl.DateTime", "vim.version.version9", 0 | F_OPTIONAL),
        ("profile", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("objectUUID", "string", "vim.version.version9", 0 | F_OPTIONAL),
        (
            "complianceStatus",
            "vim.cluster.StorageComplianceStatus",
            "vim.version.version9",
            0,
        ),
        ("mismatch", "boolean", "vim.version.version9", 0),
        (
            "violatedPolicies",
            "vim.cluster.StoragePolicyStatus[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        (
            "operationalStatus",
            "vim.cluster.StorageOperationalStatus",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
    ],
)
CreateDataType(
    "vim.cluster.VsanClusterHealthGroup",
    "VsanClusterHealthGroup",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("groupId", "string", "vim.version.version9", 0),
        ("groupName", "string", "vim.version.version9", 0),
        ("groupHealth", "string", "vim.version.version9", 0),
        (
            "groupTests",
            "vim.cluster.VsanClusterHealthTest[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        (
            "groupDetails",
            "vim.cluster.VsanClusterHealthResultBase[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
    ],
)
CreateDataType(
    "vim.cluster.VsanSpaceUsageDetailResult",
    "VsanSpaceUsageDetailResult",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        (
            "spaceUsageByObjectType",
            "vim.cluster.VsanObjectSpaceSummary[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        )
    ],
)
CreateDataType(
    "vim.cluster.VsanAttachToSrOperation",
    "VsanAttachToSrOperation",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("task", "vim.Task", "vim.version.version9", 0 | F_OPTIONAL),
        ("success", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
        ("timestamp", "vmodl.DateTime", "vim.version.version9", 0 | F_OPTIONAL),
        ("srNumber", "string", "vim.version.version9", 0),
    ],
)
CreateDataType(
    "vim.cluster.VsanObjectSpaceSummary",
    "VsanObjectSpaceSummary",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        (
            "objType",
            "vim.cluster.VsanObjectTypeEnum",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        ("overheadB", "long", "vim.version.version9", 0 | F_OPTIONAL),
<a name="21"></a>        ("temporaryOverheadB", "long", "vim.version.version9", 0 | F_OPTIONAL),
        ("primaryCapacityB", "long", "vim.version.version9", 0 | F_OPTIONAL),
        ("provisionCapacityB", "long", "vim.version.version9", 0 | F_OPTIONAL),
        (<font color="#947010"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"reservedCapacityB", "long", "vim.version.version9", 0 | F_OPTIONAL),
        ("overReservedB", "long", "vim.version.version9", 0 | F_OPTIONAL),
        ("physicalUsedB", "long", "vim.version.version9", 0 | F_OPTIONAL),
        ("usedB", "long", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.cluster.VsanClusterHclInfo",
    "VsanClusterHclInfo",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("hclDbLastUpdate", "vmodl.DateTime", "vim.version.version9", 0 | F_OPTIONAL),
        ("hclDbAgeHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
        (
            "hostResults",
            "vim.host.VsanHostHclInfo[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
    ],
)
CreateDataType(
    "vim.cluster.VsanPerfGraph",
    "VsanPerfGraph",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("id", "string", "vim.version.version9", 0),
<a name="28"></a>        ("metrics", "vim.cluster.VsanPerfMetricId[]", "vim.version.version9", 0),
        ("unit"</b></font>, "vim.cluster.VsanPerfStatsUnitType", "vim.version.version9", 0),
        (
            <font color="#717d7d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"threshold",
            "vim.cluster.VsanPerfThreshold",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        ("name", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("description", "string", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.cluster.VsanClusterHealthResultBase",
    "VsanClusterHealthResultBase",
    "vmodl.DynamicData",
    "vim.version.version9",
    [("label", "string", "vim.version.version9", 0 | F_OPTIONAL)],
)
CreateDataType(
    "vim.cluster.VsanPerfTopEntity",
    "VsanPerfTopEntity",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("entityRefId", "string", "vim.version.version9", 0),
        ("value", "string", "vim.version.version9", 0),
    ],
)
CreateDataType(
    "vim.cluster.VsanClusterBalancePerDiskInfo",
    "VsanClusterBalancePerDiskInfo",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("uuid"</b></font>, "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("fullness", "long", "vim.version.version9", 0),
        ("variance", "long", "vim.version.version9", 0),
        ("fullnessAboveThreshold", "long", "vim.version.version9", 0),
        ("dataToMoveB", "long", "vim.version.version9", 0),
    ],
)
CreateDataType(
    "vim.cluster.VsanClusterHealthTest",
    "VsanClusterHealthTest",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
<a name="18"></a>        ("testId", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("testName", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("testDescription", "string", "vim.version.version9", 0 | F_OPTIONAL),
        (<font color="#800517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"testShortDescription", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("testHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
        (
            "testDetails",
            "vim.cluster.VsanClusterHealthResultBase[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        (
            "testActions",
            "vim.cluster.VsanClusterHealthAction[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
    ],
)
CreateDataType(
    "vim.cluster.StoragePolicyStatus",
    "VsanStoragePolicyStatus",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("id", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("expectedValue", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("currentValue", "string", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.cluster.VsanPerfMemberInfo",
    "VsanPerfMemberInfo",
    "vmodl.DynamicData",
    "vim.version.version9",
    [("thumbprint", "string", "vim.version.version9", 0)],
)
CreateDataType(
    "vim.cluster.VsanPerfMetricId",
    "VsanPerfMetricId",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("label"</b></font>, "string", "vim.version.version9", 0),
        ("group", "string", "vim.version.version9", 0 | F_OPTIONAL),
        (
            "rollupType",
            "vim.cluster.VsanPerfSummaryType",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        (
            "statsType",
            "vim.cluster.VsanPerfStatsType",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        ("name", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("description", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("metricsCollectInterval", "int", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.cluster.VSANWitnessHostInfo",
    "VimClusterVSANWitnessHostInfo",
    "vmodl.DynamicData",
    "vim.version.version10",
    [
        ("nodeUuid", "string", "vim.version.version10", 0),
        ("faultDomainName", "string", "vim.version.version10", 0 | F_OPTIONAL),
        ("preferredFdName", "string", "vim.version.version10", 0 | F_OPTIONAL),
        ("preferredFdUuid", "string", "vim.version.version10", 0 | F_OPTIONAL),
        ("unicastAgentAddr", "string", "vim.version.version10", 0 | F_OPTIONAL),
        ("host", "vim.HostSystem", "vim.version.version10", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.cluster.VsanHealthExtMgmtPreCheckResult",
    "VsanHealthExtMgmtPreCheckResult",
<a name="27"></a>    "vmodl.DynamicData",
    "vim.version.version9",
    [
        (<font color="#e77471"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"overallResult", "boolean", "vim.version.version9", 0),
        ("esxVersionCheckPassed", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
        ("drsCheckPassed", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
        ("eamConnectionCheckPassed", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
        ("installStateCheckPassed", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
        ("results", "vim.cluster.VsanClusterHealthTest[]", "vim.version.version9", 0),
        ("vumRegistered", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.vsan.upgradesystem.HostWithHybridDiskgroupIssue",
    "VsanHostWithHybridDiskgroupIssue",
    "vim.VsanUpgradeSystem.PreflightCheckIssue",
    "vim.version.version10",
    [("hosts", "vim.HostSystem[]", "vim.version.version10", 0)],
)
CreateDataType(
    "vim.cluster.VsanPerfMetricSeriesCSV",
    "VsanPerfMetricSeriesCSV",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("metricId"</b></font>, "vim.cluster.VsanPerfMetricId", "vim.version.version9", 0),
        ("values", "string", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.cluster.VsanPerfQuerySpec",
    "VsanPerfQuerySpec",
<a name="26"></a>    "vmodl.DynamicData",
    "vim.version.version9",
    [
        <font color="#68818b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("entityRefId", "string", "vim.version.version9", 0),
        ("startTime", "vmodl.DateTime", "vim.version.version9", 0 | F_OPTIONAL),
        ("endTime", "vmodl.DateTime", "vim.version.version9", 0 | F_OPTIONAL),
        ("group", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("labels", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
        ("interval", "int", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.host.VsanRepairObjectsResult",
    "VsanRepairObjectsResult",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("inQueueObjects", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
        (
            "failedRepairObjects",
            "vim.host.VsanFailedRepairObjectResult[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        ("notInQueueObjects", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(</b></font>
    "vim.cluster.VsanClusterNetworkPartitionInfo",
    "VsanClusterNetworkPartitionInfo",
    "vmodl.DynamicData",
    "vim.version.version9",
    [("hosts", "string[]", "vim.version.version9", 0 | F_OPTIONAL)],
)
CreateDataType(
    "vim.vsan.upgradesystem.MixedEsxVersionIssue",
    "VsanMixedEsxVersionIssue",
    "vim.VsanUpgradeSystem.PreflightCheckIssue",
    "vim.version.version10",
    [],
)
CreateDataType(
    "vim.cluster.VsanClusterClomdLivenessResult",
    "VsanClusterClomdLivenessResult",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        (
            "clomdLivenessResult",
            "vim.cluster.VsanHostClomdLivenessResult[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        ("issueFound", "boolean", "vim.version.version9", 0),
    ],
)
CreateDataType(
    "vim.cluster.VsanVsanClusterPcapResult",
    "VsanVsanClusterPcapResult",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("pkts", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
        (
            "groups",
            "vim.cluster.VsanVsanClusterPcapGroup[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        ("issues", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
        (
            "hostResults",
            "vim.host.VsanVsanPcapResult[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
    ],
)
CreateDataType(
    "vim.cluster.VsanPerfMasterInformation",
    "VsanPerfMasterInformation",
    "vmodl.DynamicData",
    "vim.version.version9",
<a name="8"></a>    [
        ("secSinceLastStatsWrite", "long", "vim.version.version9", 0 | F_OPTIONAL),
        ("secSinceLastStatsCollect", "long", "vim.version.version9", 0 | F_OPTIONAL),
        (<font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"statsIntervalSec", "long", "vim.version.version9", 0),
        (
            "collectionFailureHostUuids",
            "string[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        ("renamedStatsDirectories", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
        ("statsDirectoryPercentFree", "long", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.cluster.VsanHostCreateVmHealthTestResult",
    "VsanHostCreateVmHealthTestResult",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("hostname", "string", "vim.version.version9", 0),
        ("state", "string", "vim.version.version9", 0),
        ("fault", "vmodl.MethodFault", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.cluster.VsanDiskFormatConversionCheckResult",
    "VsanDiskFormatConversionCheckResult",
    "vim.VsanUpgradeSystem.PreflightCheckResult",
    "vim.version.version10",
    [
        ("isSupported", "boolean", "vim.version.version10", 0),
        ("targetVersion", "int", "vim.version.version10", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.cluster.VsanClusterHealthSystemObjectsRepairResult",
    "VsanClusterHealthSystemObjectsRepairResult",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("inRepairingQueueObjects", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
        (
            "failedRepairObjects",
            "vim.host.VsanFailedRepairObjectResult[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        ("issueFound", "boolean", "vim.version.version9", 0),
    ],
)
CreateDataType(
    "vim.host.VsanHostHclInfo",
    "VsanHostHclInfo",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("hostname", "string", "vim.version.version9", 0),
        ("hclChecked", "boolean", "vim.version.version9", 0),
<a name="25"></a>        ("releaseName"</b></font>, "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("error", "vmodl.MethodFault", "vim.version.version9", 0 | F_OPTIONAL),
        (
            <font color="#5eac10"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"controllers",
            "vim.host.VsanHclControllerInfo[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
    ],
)
CreateDataType(
    "vim.cluster.VSANStretchedClusterCapability",
    "VimClusterVSANStretchedClusterCapability",
    "vmodl.DynamicData",
    "vim.version.version10",
    [
        ("hostMoId", "string", "vim.version.version10", 0),
        ("connStatus", "string", "vim.version.version10", 0 | F_OPTIONAL),
        ("isSupported", "boolean", "vim.version.version10", 0 | F_OPTIONAL),
        (
            "hostCapability",
            "vim.host.VSANStretchedClusterHostCapability",
            "vim.version.version10",
            0 | F_OPTIONAL,
        ),
    ],
)
CreateDataType(
    "vim.cluster.VsanDiskMappingsConfigSpec",
    "VimClusterVsanDiskMappingsConfigSpec",
    "vmodl.DynamicData",
    "vim.version.version10",
    [
        (
            "hostDiskMappings",
            "vim.cluster.VsanHostDiskMapping[]",
            "vim.version.version10",
            0,
        )
    ],
)
CreateDataType(
    "vim.host.VsanHostVmdkLoadTestResult",
    "VsanHostVmdkLoadTestResult",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("hostname"</b></font>, "string", "vim.version.version9", 0),
        ("issueFound", "boolean", "vim.version.version9", 0),
        ("faultMessage", "string", "vim.version.version9", 0 | F_OPTIONAL),
        (
            "vmdkResults",
            "vim.host.VsanVmdkLoadTestResult[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
    ],
)
CreateDataType(
    "vim.vsan.ReconfigSpec",
    "VimVsanReconfigSpec",
    "vmodl.DynamicData",
    "vim.version.version10",
    [
        (
            "vsanClusterConfig",
            "vim.vsan.cluster.ConfigInfo",
            "vim.version.version10",
            0 | F_OPTIONAL,
        ),
        (
            "dataEfficiencyConfig",
            "vim.vsan.DataEfficiencyConfig",
            "vim.version.version10",
            0 | F_OPTIONAL,
        ),
        (
            "diskMappingSpec",
            "vim.cluster.VsanDiskMappingsConfigSpec",
            "vim.version.version10",
            0 | F_OPTIONAL,
        ),
        (
            "faultDomainsSpec",
            "vim.cluster.VsanFaultDomainsConfigSpec",
            "vim.version.version10",
            0 | F_OPTIONAL,
        ),
        ("modify", "boolean", "vim.version.version10", 0),
        ("allowReducedRedundancy", "boolean", "vim.version.version10", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.host.VsanNetworkPeerHealthResult",
    "VsanNetworkPeerHealthResult",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("peer", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("peerHostname", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("peerVmknicName", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("smallPingTestSuccessPct", "int", "vim.version.version9", 0 | F_OPTIONAL),
<a name="9"></a>        ("largePingTestSuccessPct", "int", "vim.version.version9", 0 | F_OPTIONAL),
        ("maxLatencyUs", "long", "vim.version.version9", 0 | F_OPTIONAL),
        ("onSameIpSubnet", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
        (<font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"sourceVmknicName", "string", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.cluster.VsanWitnessSpec",
    "VimClusterVsanWitnessSpec",
    "vmodl.DynamicData",
    "vim.version.version10",
    [
        ("host", "vim.HostSystem", "vim.version.version10", 0),
        ("preferredFaultDomainName", "string", "vim.version.version10", 0),
        (
            "diskMapping",
            "vim.vsan.host.DiskMapping",
            "vim.version.version10",
            0 | F_OPTIONAL,
        ),
    ],
)
CreateDataType(
    "vim.vsan.host.DiskMappingCreationSpec",
    "VimVsanHostDiskMappingCreationSpec",
    "vmodl.DynamicData",
    "vim.version.version10",
    [
        ("host", "vim.HostSystem", "vim.version.version10", 0),
        ("cacheDisks", "vim.host.ScsiDisk[]", "vim.version.version10", 0 | F_OPTIONAL),
        ("capacityDisks", "vim.host.ScsiDisk[]", "vim.version.version10", 0),
        (
            "creationType",
            "vim.vsan.host.DiskMappingCreationType",
            "vim.version.version10",
            0,
        ),
    ],
)
CreateDataType(
    "vim.host.VsanLimitHealthResult",
    "VsanLimitHealthResult",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("hostname", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("issueFound", "boolean", "vim.version.version9", 0),
        ("maxComponents", "int", "vim.version.version9", 0),
        ("freeComponents", "int", "vim.version.version9", 0),
        ("componentLimitHealth", "string", "vim.version.version9", 0),
        ("lowestFreeDiskSpacePct", "int", "vim.version.version9", 0),
<a name="7"></a>        ("usedDiskSpaceB"</b></font>, "long", "vim.version.version9", 0),
        ("totalDiskSpaceB", "long", "vim.version.version9", 0),
        ("diskFreeSpaceHealth", "string", "vim.version.version9", 0),
        (<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"reservedRcSizeB", "long", "vim.version.version9", 0),
        ("totalRcSizeB", "long", "vim.version.version9", 0),
        ("rcFreeReservationHealth", "string", "vim.version.version9", 0),
    ],
)
CreateDataType(
    "vim.cluster.VSANPreferredFaultDomainInfo",
    "VimClusterVSANPreferredFaultDomainInfo",
    "vmodl.DynamicData",
    "vim.version.version10",
    [
        ("preferredFaultDomainName", "string", "vim.version.version10", 0),
        ("preferredFaultDomainId", "string", "vim.version.version10", 0),
    ],
)
CreateDataType(
    "vim.host.VsanObjectOverallHealth",
    "VsanObjectOverallHealth",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        (
            "objectHealthDetail",
            "vim.host.VsanObjectHealth[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        ("objectVersionCompliance", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.cluster.VsanVsanClusterPcapGroup",
    "VsanVsanClusterPcapGroup",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("master", "string", "vim.version.version9", 0),
        ("members", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.cluster.VsanClusterHealthResultColumnInfo",
    "VsanClusterHealthResultColumnInfo",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("label", "string", "vim.version.version9", 0),
        ("type", "string", "vim.version.version9", 0),
    ],
)
CreateDataType(
    "vim.cluster.VsanClusterNetworkHealthResult",
    "VsanClusterNetworkHealthResult",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        (
            "hostResults",
            "vim.host.VsanNetworkHealthResult[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        ("issueFound"</b></font>, "boolean", "vim.version.version9", 0 | F_OPTIONAL),
        ("vsanVmknicPresent", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
        ("matchingMulticastConfig", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
        ("matchingIpSubnets", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
        ("pingTestSuccess", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
        ("largePingTestSuccess", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
        ("potentialMulticastIssue", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
        ("otherHostsInVsanCluster", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
        (
            "partitions",
            "vim.cluster.VsanClusterNetworkPartitionInfo[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        ("hostsWithVsanDisabled", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
        ("hostsDisconnected", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
        ("hostsCommFailure", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
        (
            "hostsInEsxMaintenanceMode",
            "string[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        (
            "hostsInVsanMaintenanceMode",
            "string[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        (
            "infoAboutUnexpectedHosts",
            "vim.host.VsanQueryResultHostInfo[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
    ],
)
CreateDataType(
    "vim.cluster.VsanPerfNodeInformation",
    "VsanPerfNodeInformation",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("version", "string", "vim.version.version9", 0),
        ("hostname", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("error", "vmodl.MethodFault", "vim.version.version9", 0 | F_OPTIONAL),
        ("isCmmdsMaster", "boolean", "vim.version.version9", 0),
        ("isStatsMaster", "boolean", "vim.version.version9", 0),
        ("vsanMasterUuid", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("vsanNodeUuid", "string", "vim.version.version9", 0 | F_OPTIONAL),
        (
            "masterInfo",
            "vim.cluster.VsanPerfMasterInformation",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
    ],
)
CreateDataType(
    "vim.cluster.VsanPerfEntityMetricCSV",
    "VsanPerfEntityMetricCSV",
    "vmodl.DynamicData",
<a name="11"></a>    "vim.version.version9",
    [
        ("entityRefId", "string", "vim.version.version9", 0),
        (<font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"sampleInfo", "string", "vim.version.version9", 0 | F_OPTIONAL),
        (
            "value",
            "vim.cluster.VsanPerfMetricSeriesCSV[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
    ],
)
CreateDataType(
    "vim.vsan.upgradesystem.DiskUnhealthIssue",
    "VsanDiskUnhealthIssue",
    "vim.VsanUpgradeSystem.PreflightCheckIssue",
    "vim.version.version10",
    [("uuids", "string[]", "vim.version.version10", 0)],
)
CreateDataType(
    "vim.cluster.VsanFaultDomainSpec",
    "VimClusterVsanFaultDomainSpec",
    "vmodl.DynamicData",
    "vim.version.version10",
    [
        ("hosts", "vim.HostSystem[]", "vim.version.version10", 0),
        ("name", "string", "vim.version.version10", 0),
    ],
)
CreateDataType(
    "vim.vsan.upgradesystem.ObjectInaccessibleIssue",
    "VsanObjectInaccessibleIssue",
    "vim.VsanUpgradeSystem.PreflightCheckIssue",
    "vim.version.version10",
    [("uuids", "string[]", "vim.version.version10", 0)],
)
CreateDataType(
    "vim.cluster.VsanDiskFormatConversionSpec",
    "VsanDiskFormatConversionSpec",
    "vmodl.DynamicData",
    "vim.version.version10",
    [
        (
            "dataEfficiencyConfig",
            "vim.vsan.DataEfficiencyConfig",
            "vim.version.version10",
            0 | F_OPTIONAL,
        )
    ],
)
CreateDataType(
    "vim.cluster.VsanClusterHealthAction",
    "VsanClusterHealthAction",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        (
            "actionId"</b></font>,
            "vim.cluster.VsanClusterHealthActionIdEnum",
            "vim.version.version9",
            0,
        ),
        ("actionLabel", "vmodl.LocalizableMessage", "vim.version.version9", 0),
        ("actionDescription", "vmodl.LocalizableMessage", "vim.version.version9", 0),
        ("enabled", "boolean", "vim.version.version9", 0),
    ],
)
CreateDataType(
    "vim.cluster.VsanClusterHealthSystemVersionResult",
    "VsanClusterHealthSystemVersionResult",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        (
            "hostResults",
            "vim.cluster.VsanHostHealthSystemVersionResult[]",
            "vim.version.version9",
<a name="24"></a>            0 | F_OPTIONAL,
        ),
        ("vcVersion", "string", "vim.version.version9", 0 | F_OPTIONAL),
        (<font color="#79764d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"issueFound", "boolean", "vim.version.version9", 0),
    ],
)
CreateDataType(
    "vim.cluster.VsanClusterHealthResultRow",
    "VsanClusterHealthResultRow",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("values", "string[]", "vim.version.version9", 0),
        (
            "nestedRows",
            "vim.cluster.VsanClusterHealthResultRow[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
    ],
)
CreateDataType(
    "vim.cluster.VsanClusterHealthSystemStatusResult",
    "VsanClusterHealthSystemStatusResult",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("status", "string", "vim.version.version9", 0),
        ("goalState", "string", "vim.version.version9", 0),
        ("untrackedHosts", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
        (
            "trackedHostsStatus",
            "vim.host.VsanHostHealthSystemStatusResult[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
    ],
)
CreateDataType(
    "vim.cluster.VsanHostDiskMapping",
    "VimClusterVsanHostDiskMapping",
    "vmodl.DynamicData",
    "vim.version.version10",
    [
        (</b></font>"host", "vim.HostSystem", "vim.version.version10", 0),
        ("cacheDisks", "vim.host.ScsiDisk[]", "vim.version.version10", 0 | F_OPTIONAL),
        ("capacityDisks", "vim.host.ScsiDisk[]", "vim.version.version10", 0),
        ("type", "vim.cluster.VsanDiskGroupCreationType", "vim.version.version10", 0),
    ],
)
CreateDataType(
    "vim.cluster.VSANStretchedClusterFaultDomainConfig",
    "VimClusterVSANStretchedClusterFaultDomainConfig",
    "vmodl.DynamicData",
    "vim.version.version10",
    [
        ("firstFdName", "string", "vim.version.version10", 0),
        ("firstFdHosts", "vim.HostSystem[]", "vim.version.version10", 0),
        ("secondFdName", "string", "vim.version.version10", 0),
        ("secondFdHosts", "vim.HostSystem[]", "vim.version.version10", 0),
    ],
)
CreateDataType(
    "vim.host.VSANStretchedClusterHostInfo",
    "VimHostVSANStretchedClusterHostInfo",
    "vmodl.DynamicData",
    "vim.version.version10",
    [
        ("nodeInfo", "vim.host.VSANCmmdsNodeInfo", "vim.version.version10", 0),
        (
            "faultDomainInfo",
            "vim.host.VSANCmmdsFaultDomainInfo",
            "vim.version.version10",
<a name="20"></a>            0 | F_OPTIONAL,
        ),
        (
            <font color="#4e9258"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"preferredFaultDomainInfo",
            "vim.host.VSANCmmdsPreferredFaultDomainInfo",
            "vim.version.version10",
            0 | F_OPTIONAL,
        ),
    ],
)
CreateDataType(
    "vim.vsan.upgradesystem.HigherObjectsPresentDuringDowngradeIssue",
    "VsanHigherObjectsPresentDuringDowngradeIssue",
    "vim.VsanUpgradeSystem.PreflightCheckIssue",
    "vim.version.version10",
    [("uuids", "string[]", "vim.version.version10", 0)],
)
CreateDataType(
    "vim.host.VSANCmmdsFaultDomainInfo",
    "VimHostVSANCmmdsFaultDomainInfo",
    "vmodl.DynamicData",
    "vim.version.version10",
    [
        ("faultDomainId", "string", "vim.version.version10", 0),
        ("faultDomainName", "string", "vim.version.version10", 0),
    ],
)
CreateDataType(
    "vim.fault.VsanNodeNotMaster",
    "VsanNodeNotMaster",
    "vim.fault.VimFault",
    "vim.version.version9",
    [
        ("vsanMasterUuid", "string", "vim.version.version9", 0 | F_OPTIONAL),
        (
            "cmmdsMasterButNotStatsMaster",
            "boolean",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
    ],
)
CreateDataType(
    "vim.cluster.VsanHostHealthSystemVersionResult",
    "VsanHostHealthSystemVersionResult",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        (</b></font>"hostname", "string", "vim.version.version9", 0),
        ("version", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("error", "vmodl.MethodFault", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.cluster.VsanClusterHealthConfigs",
    "VsanClusterHealthConfigs",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("enableVsanTelemetry", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
        ("vsanTelemetryInterval", "int", "vim.version.version9", 0 | F_OPTIONAL),
        (
            "vsanTelemetryProxy",
            "vim.cluster.VsanClusterTelemetryProxyConfig",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        (
            "configs",
            "vim.cluster.VsanClusterHealthResultKeyValuePair[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
    ],
)
CreateDataType(
    "vim.cluster.VsanClusterWhatifHostFailuresResult",
    "VsanClusterWhatifHostFailuresResult",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("numFailures", "long", "vim.version.version9", 0),
        ("totalUsedCapacityB", "long", "vim.version.version9", 0),
        ("totalCapacityB", "long", "vim.version.version9", 0),
        ("totalRcReservationB", "long", "vim.version.version9", 0),
        ("totalRcSizeB", "long", "vim.version.version9", 0),
        ("usedComponents", "long", "vim.version.version9", 0),
        ("totalComponents", "long", "vim.version.version9", 0),
        ("componentLimitHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("diskFreeSpaceHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("rcFreeReservationHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.cluster.VsanObjectIdentityAndHealth",
    "VsanObjectIdentityAndHealth",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        (
            "identities",
            "vim.cluster.VsanObjectIdentity[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        (
            "health",
            "vim.host.VsanObjectOverallHealth",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        (
            "spaceSummary",
            "vim.cluster.VsanObjectSpaceSummary[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        ("rawData", "string", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.host.VsanHclControllerInfo",
    "VsanHclControllerInfo",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("deviceName", "string", "vim.version.version9", 0),
        ("deviceDisplayName", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("driverName", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("driverVersion", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("vendorId", "long", "vim.version.version9", 0 | F_OPTIONAL),
        ("deviceId", "long", "vim.version.version9", 0 | F_OPTIONAL),
        ("subVendorId", "long", "vim.version.version9", 0 | F_OPTIONAL),
        ("subDeviceId", "long", "vim.version.version9", 0 | F_OPTIONAL),
        ("extraInfo", "vim.KeyValue[]", "vim.version.version9", 0 | F_OPTIONAL),
        ("deviceOnHcl", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
        ("releaseSupported", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
        ("releasesOnHcl", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
        ("driverVersionsOnHcl", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
        ("driverVersionSupported", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
        ("fwVersionSupported", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
        ("fwVersionOnHcl", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
        ("cacheConfigSupported", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
        ("cacheConfigOnHcl", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
        ("raidConfigSupported", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
        ("raidConfigOnHcl", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
        ("fwVersion", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("raidConfig", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("cacheConfig", "string", "vim.version.version9", 0 | F_OPTIONAL),
        (
            "cimProviderInfo",
            "vim.host.VsanHostCimProviderInfo",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
    ],
)
CreateDataType(
    "vim.cluster.VsanClusterHealthResultKeyValuePair",
    "VsanClusterHealthResultKeyValuePair",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("key", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("value", "string", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.cluster.StorageOperationalStatus",
    "VsanStorageOperationalStatus",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("healthy", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
        ("operationETA", "vmodl.DateTime", "vim.version.version9", 0 | F_OPTIONAL),
        ("operationProgress", "long", "vim.version.version9", 0 | F_OPTIONAL),
        ("transitional", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.cluster.VsanSpaceUsage",
    "VsanSpaceUsage",
    "vmodl.DynamicData",
<a name="4"></a>    "vim.version.version9",
    [
        ("totalCapacityB", "long", "vim.version.version9", 0),
        (<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"freeCapacityB", "long", "vim.version.version9", 0 | F_OPTIONAL),
        (
            "spaceOverview",
            "vim.cluster.VsanObjectSpaceSummary",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        (
            "spaceDetail",
            "vim.cluster.VsanSpaceUsageDetailResult",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
    ],
)
CreateDataType(
    "vim.cluster.VsanClusterHealthResultTable",
    "VsanClusterHealthResultTable",
    "vim.cluster.VsanClusterHealthResultBase",
    "vim.version.version9",
    [
        (
            "columns",
            "vim.cluster.VsanClusterHealthResultColumnInfo[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        (
            "rows",
            "vim.cluster.VsanClusterHealthResultRow[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
    ],
)
CreateDataType(
    "vim.cluster.VsanClusterConfig",
    "VsanClusterConfig",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("config", "vim.vsan.cluster.ConfigInfo", "vim.version.version9", 0),
        ("name", "string", "vim.version.version9", 0),
        ("hosts", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.vsan.host.VsanHostCapability",
    "VimVsanHostVsanHostCapability",
    "vmodl.DynamicData",
    "vim.version.version10",
    [
        ("host", "vim.HostSystem", "vim.version.version10", 0),
        ("isSupported", "boolean", "vim.version.version10", 0),
        ("isLicensed", "boolean", "vim.version.version10", 0),
    ],
)
CreateDataType(
    "vim.cluster.VsanPerfThreshold",
    "VsanPerfThreshold",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        (
            "direction",
            "vim.cluster.VsanPerfThresholdDirectionType",
            "vim.version.version9",
            0,
        ),
        ("yellow", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("red", "string", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.host.VsanNetworkHealthResult",
    "VsanNetworkHealthResult",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("host", "vim.HostSystem", "vim.version.version9", 0 | F_OPTIONAL),
        ("hostname", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("vsanVmknicPresent"</b></font>, "boolean", "vim.version.version9", 0 | F_OPTIONAL),
        ("ipSubnets", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
        ("issueFound", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
        (
            "peerHealth",
            "vim.host.VsanNetworkPeerHealthResult[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        ("multicastConfig", "string", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.vsan.ConfigInfoEx",
    "VsanConfigInfoEx",
    "vim.vsan.cluster.ConfigInfo",
    "vim.version.version10",
    [
        (
            "dataEfficiencyConfig",
            "vim.vsan.DataEfficiencyConfig",
            "vim.version.version10",
            0 | F_OPTIONAL,
        )
    ],
)
CreateDataType(
    "vim.host.VsanVmdkLoadTestResult",
    "VsanVmdkLoadTestResult",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("success", "boolean", "vim.version.version9", 0),
        ("faultMessage", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("spec", "vim.host.VsanVmdkLoadTestSpec", "vim.version.version9", 0),
        ("actualDurationSec", "int", "vim.version.version9", 0 | F_OPTIONAL),
        ("totalBytes", "long", "vim.version.version9", 0 | F_OPTIONAL),
        ("iops", "long", "vim.version.version9", 0 | F_OPTIONAL),
        ("tputBps", "long", "vim.version.version9", 0 | F_OPTIONAL),
        ("avgLatencyUs", "long", "vim.version.version9", 0 | F_OPTIONAL),
        ("maxLatencyUs", "long", "vim.version.version9", 0 | F_OPTIONAL),
        ("numIoAboveLatencyThreshold", "long", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.cluster.VsanClusterVMsHealthOverallResult",
    "VsanClusterVMsHealthOverAllResult",
<a name="6"></a>    "vmodl.DynamicData",
    "vim.version.version9",
    [
        <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(
            "healthStateList",
            "vim.cluster.VsanClusterVMsHealthSummaryResult[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        ("overallHealthState", "string", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.host.VsanHostHealthSystemStatusResult",
    "VsanHostHealthSystemStatusResult",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("hostname", "string", "vim.version.version9", 0),
        ("status", "string", "vim.version.version9", 0),
        ("issues", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.cluster.VsanClusterAdvCfgSyncResult",
    "VsanClusterAdvCfgSyncResult",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("inSync", "boolean", "vim.version.version9", 0),
        ("name", "string", "vim.version.version9", 0),
        (
            "hostValues",
            "vim.cluster.VsanClusterAdvCfgSyncHostResult[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
    ],
)
CreateDataType(
    "vim.host.VsanQueryResultHostInfo",
    "VsanQueryResultHostInfo",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("uuid", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("hostnameInCmmds", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("vsanIpv4Addresses", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.vsan.host.DiskMapInfoEx",
    "VimVsanHostDiskMapInfoEx",
    "vmodl.DynamicData",
    "vim.version.version10",
    [
        ("mapping", "vim.vsan.host.DiskMapping", "vim.version.version10", 0),
        ("isMounted", "boolean", "vim.version.version10", 0),
        ("isAllFlash"</b></font>, "boolean", "vim.version.version10", 0),
        ("isDataEfficiency", "boolean", "vim.version.version10", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.host.VsanVmdkLoadTestSpec",
    "VsanVmdkLoadTestSpec",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        (
            "vmdkCreateSpec",
            "vim.VirtualDiskManager.FileBackedVirtualDiskSpec",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        (
            "vmdkIOSpec",
            "vim.host.VsanVmdkIOLoadSpec",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        (
            "vmdkIOSpecSequence",
            "vim.host.VsanVmdkIOLoadSpec[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        ("stepDurationSec", "long", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.cluster.VsanClusterHealthSummary",
    "VsanClusterHealthSummary",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        (
            "clusterStatus",
            "vim.cluster.VsanClusterHealthSystemStatusResult",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        ("timestamp", "vmodl.DateTime", "vim.version.version9", 0 | F_OPTIONAL),
        (
            "clusterVersions",
            "vim.cluster.VsanClusterHealthSystemVersionResult",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        (
            "objectHealth",
            "vim.host.VsanObjectOverallHealth",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        (
            "vmHealth",
            "vim.cluster.VsanClusterVMsHealthOverallResult",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        (
            "networkHealth",
            "vim.cluster.VsanClusterNetworkHealthResult",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        (
            "limitHealth",
            "vim.cluster.VsanClusterLimitHealthResult",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        (
            "advCfgSync",
            "vim.cluster.VsanClusterAdvCfgSyncResult[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        (
            "createVmHealth",
            "vim.cluster.VsanHostCreateVmHealthTestResult[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        (
            "physicalDisksHealth",
            "vim.host.VsanPhysicalDiskHealthSummary[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        (
            "hclInfo",
            "vim.cluster.VsanClusterHclInfo",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        (
            "groups",
            "vim.cluster.VsanClusterHealthGroup[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        ("overallHealth", "string", "vim.version.version9", 0),
        ("overallHealthDescription", "string", "vim.version.version9", 0),
        (
            "clomdLiveness",
            "vim.cluster.VsanClusterClomdLivenessResult",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        (
            "diskBalance",
            "vim.cluster.VsanClusterBalanceSummary",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
    ],
)
CreateDataType(
    "vim.cluster.VsanPerfEntityType",
    "VsanPerfEntityType",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("name", "string", "vim.version.version9", 0),
        ("id", "string", "vim.version.version9", 0),
        ("graphs", "vim.cluster.VsanPerfGraph[]", "vim.version.version9", 0),
        ("description", "string", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.host.VsanNetworkLoadTestResult",
    "VsanNetworkLoadTestResult",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("hostname", "string", "vim.version.version9", 0),
        ("status", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("client", "boolean", "vim.version.version9", 0),
        ("bandwidthBps", "long", "vim.version.version9", 0),
        ("totalBytes", "long", "vim.version.version9", 0),
        ("lostDatagrams", "long", "vim.version.version9", 0 | F_OPTIONAL),
        ("lossPct", "long", "vim.version.version9", 0 | F_OPTIONAL),
        ("sentDatagrams", "long", "vim.version.version9", 0 | F_OPTIONAL),
        ("jitterMs", "float", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.host.VsanPhysicalDiskHealthSummary",
    "VsanPhysicalDiskHealthSummary",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("overallHealth", "string", "vim.version.version9", 0),
        (
            "heapsWithIssues",
            "vim.host.VsanResourceHealth[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        (
            "slabsWithIssues",
            "vim.host.VsanResourceHealth[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        (
            "disks",
            "vim.host.VsanPhysicalDiskHealth[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        (
            "componentsWithIssues",
            "vim.host.VsanResourceHealth[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        ("hostname", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("hostDedupScope", "int", "vim.version.version9", 0 | F_OPTIONAL),
        ("error", "vmodl.MethodFault", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.vsan.host.VsanDiskManagementSystemCapability",
<a name="19"></a>    "VimVsanHostVsanDiskManagementSystemCapability",
    "vmodl.DynamicData",
    "vim.version.version10",
    [(<font color="#f62817"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"version", "string", "vim.version.version10", 0)],
)
CreateDataType(
    "vim.host.VsanHostCimProviderInfo",
    "VsanHostCimProviderInfo",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("cimProviderSupported", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
        ("installedCIMProvider", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("cimProviderOnHcl", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.cluster.VsanObjectInformation",
    "VsanObjectInformation",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("directoryName", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("vsanObjectUuid", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("vsanHealth", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("policyAttributes", "vim.KeyValue[]", "vim.version.version9", 0 | F_OPTIONAL),
        ("spbmProfileUuid", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("spbmProfileGenerationId"</b></font>, "string", "vim.version.version9", 0 | F_OPTIONAL),
        (
            "spbmComplianceResult",
            "vim.cluster.StorageComplianceResult",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
    ],
)
CreateDataType(
    "vim.cluster.VsanObjectIdentity",
    "VsanObjectIdentity",
<a name="23"></a>    "vmodl.DynamicData",
    "vim.version.version9",
    [
        <font color="#f660ab"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("uuid", "string", "vim.version.version9", 0),
        ("type", "string", "vim.version.version9", 0),
        ("vmInstanceUuid", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("vmNsObjectUuid", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("vm", "vim.VirtualMachine", "vim.version.version9", 0 | F_OPTIONAL),
        ("description", "string", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.host.VsanResourceHealth",
    "VsanResourceHealth",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("resource", "string", "vim.version.version9", 0),
        ("health", "string", "vim.version.version9", 0),
        ("description", "string", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(</b></font>
    "vim.cluster.VsanCapability",
    "VsanCapability",
<a name="31"></a>    "vmodl.DynamicData",
    "vim.version.version10",
    [
        <font color="#3ea99f"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("target", "vmodl.ManagedObject", "vim.version.version10", 0 | F_OPTIONAL),
        ("capabilities", "string[]", "vim.version.version10", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.cluster.VsanHostClomdLivenessResult",
    "VsanHostClomdLivenessResult",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("hostname", "string", "vim.version.version9", 0),
        ("clomdStat", "string", "vim.version.version9", 0),
        ("error", "vmodl.MethodFault", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.cluster.VsanObjectQuerySpec",
    "VsanObjectQuerySpec",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("uuid", "string", "vim.version.version9", 0),
        ("spbmProfileGenerationId"</b></font>, "string", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.cluster.VsanClusterLimitHealthResult",
    "VsanClusterLimitHealthResult",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("issueFound", "boolean", "vim.version.version9", 0),
        ("componentLimitHealth", "string", "vim.version.version9", 0),
        ("diskFreeSpaceHealth", "string", "vim.version.version9", 0),
        ("rcFreeReservationHealth", "string", "vim.version.version9", 0),
        (
            "hostResults",
            "vim.host.VsanLimitHealthResult[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        (
            "whatifHostFailures",
            "vim.cluster.VsanClusterWhatifHostFailuresResult[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
        ("hostsCommFailure", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.cluster.VsanStorageWorkloadType",
    "VsanStorageWorkloadType",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
<a name="16"></a>        ("specs", "vim.host.VsanVmdkLoadTestSpec[]", "vim.version.version9", 0),
        ("typeId", "string", "vim.version.version9", 0),
        ("name", "string", "vim.version.version9", 0),
        (<font color="#2981b2"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"description", "string", "vim.version.version9", 0),
    ],
)
CreateDataType(
    "vim.cluster.VsanClusterAdvCfgSyncHostResult",
    "VsanClusterAdvCfgSyncHostResult",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("hostname", "string", "vim.version.version9", 0),
        ("value", "string", "vim.version.version9", 0),
    ],
)
CreateDataType(
    "vim.vsan.upgradesystem.ObjectPolicyIssue",
    "VsanObjectPolicyIssue",
    "vim.VsanUpgradeSystem.PreflightCheckIssue",
    "vim.version.version10",
    [("uuids", "string[]", "vim.version.version10", 0)],
)
CreateDataType(
    "vim.cluster.VsanPerfTopEntities",
    "VsanPerfTopEntities",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("metricId", "vim.cluster.VsanPerfMetricId", "vim.version.version9", 0),
        ("entities", "vim.cluster.VsanPerfTopEntity[]", "vim.version.version9", 0),
    ],
)
CreateDataType(
    "vim.host.VsanProactiveRebalanceInfoEx",
    "VsanProactiveRebalanceInfoEx",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("running", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
        ("startTs"</b></font>, "vmodl.DateTime", "vim.version.version9", 0 | F_OPTIONAL),
        ("stopTs", "vmodl.DateTime", "vim.version.version9", 0 | F_OPTIONAL),
        ("varianceThreshold", "float", "vim.version.version9", 0 | F_OPTIONAL),
        ("timeThreshold", "int", "vim.version.version9", 0 | F_OPTIONAL),
        ("rateThreshold", "int", "vim.version.version9", 0 | F_OPTIONAL),
        ("hostname", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("error", "vmodl.MethodFault", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.cluster.VsanClusterProactiveTestResult",
    "VsanClusterProactiveTestResult",
<a name="15"></a>    "vmodl.DynamicData",
    "vim.version.version9",
    [
        <font color="#f52887"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("overallStatus", "string", "vim.version.version9", 0),
        ("overallStatusDescription", "string", "vim.version.version9", 0),
        ("timestamp", "vmodl.DateTime", "vim.version.version9", 0),
        (
            "healthTest",
            "vim.cluster.VsanClusterHealthTest",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
    ],
)
CreateDataType(
    "vim.host.VSANCmmdsPreferredFaultDomainInfo",
    "VimHostVSANCmmdsPreferredFaultDomainInfo",
    "vmodl.DynamicData",
    "vim.version.version10",
    [
        ("preferredFaultDomainId", "string", "vim.version.version10", 0),
        ("preferredFaultDomainName", "string", "vim.version.version10", 0),
    ],
)
CreateDataType(
    "vim.cluster.VsanFaultDomainsConfigSpec",
    "VimClusterVsanFaultDomainsConfigSpec",
    "vmodl.DynamicData",
    "vim.version.version10",
    [
        (
            "faultDomains",
            "vim.cluster.VsanFaultDomainSpec[]",
            "vim.version.version10",
            0,
        ),
        (
            "witness",
            "vim.cluster.VsanWitnessSpec",
            "vim.version.version10",
            0 | F_OPTIONAL,
        ),
    ],
)
CreateDataType(
    "vim.cluster.VsanClusterHostVmknicMapping",
    "VsanClusterHostVmknicMapping",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("host"</b></font>, "string", "vim.version.version9", 0),
        ("vmknic", "string", "vim.version.version9", 0),
    ],
)
CreateDataType(
    "vim.cluster.VsanClusterVmdkLoadTestResult",
    "VsanClusterVmdkLoadTestResult",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("task", "vim.Task", "vim.version.version9", 0 | F_OPTIONAL),
        (
            "clusterResult",
            "vim.cluster.VsanClusterProactiveTestResult",
            "vim.version.version9",
<a name="22"></a>            0 | F_OPTIONAL,
        ),
        (
            <font color="#4cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"hostResults",
            "vim.host.VsanHostVmdkLoadTestResult[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
    ],
)
CreateDataType(
    "vim.cluster.VsanClusterVMsHealthSummaryResult",
    "VsanClusterVMsHealthSummaryResult",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("numVMs", "int", "vim.version.version9", 0),
        ("state", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("health", "string", "vim.version.version9", 0),
        ("vmInstanceUuids", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.host.VSANStretchedClusterHostCapability",
    "VimHostVSANStretchedClusterHostCapability",
    "vmodl.DynamicData",
    "vim.version.version10",
    [("featureVersion", "string", "vim.version.version10", 0)],
)
CreateDataType(
    "vim.host.VsanFailedRepairObjectResult",
    "VsanFailedRepairObjectResult",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("uuid"</b></font>, "string", "vim.version.version9", 0),
        ("errMessage", "string", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.cluster.VsanClusterCreateVmHealthTestResult",
    "VsanClusterCreateVmHealthTestResult",
<a name="30"></a>    "vmodl.DynamicData",
    "vim.version.version9",
    [
        <font color="#ae694a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(
            "clusterResult",
            "vim.cluster.VsanClusterProactiveTestResult",
            "vim.version.version9",
            0,
        ),
        (
            "hostResults",
            "vim.cluster.VsanHostCreateVmHealthTestResult[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
    ],
)
CreateDataType(
    "vim.host.VsanObjectHealth",
    "VsanObjectHealth",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("numObjects", "int", "vim.version.version9", 0),
        ("health", "vim.host.VsanObjectHealthState", "vim.version.version9", 0),
        ("objUuids", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.cluster.VsanClusterBalanceSummary",
    "VsanClusterBalanceSummary",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("varianceThreshold", "long", "vim.version.version9", 0),
        (
            "disks"</b></font>,
            "vim.cluster.VsanClusterBalancePerDiskInfo[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
    ],
)
CreateDataType(
    "vim.cluster.VsanClusterTelemetryProxyConfig",
    "VsanClusterTelemetryProxyConfig",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("host", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("port", "int", "vim.version.version9", 0 | F_OPTIONAL),
        ("user", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("password", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("autoDiscovered", "boolean", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.host.VsanVmdkIOLoadSpec",
    "VsanVmdkIOLoadSpec",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("readPct", "int", "vim.version.version9", 0),
        ("oio", "int", "vim.version.version9", 0),
        ("iosizeB", "int", "vim.version.version9", 0),
        ("dataSizeMb", "long", "vim.version.version9", 0),
        ("random", "boolean", "vim.version.version9", 0),
        ("startOffsetB", "long", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.host.VsanVsanPcapResult",
    "VsanVsanPcapResult",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        ("calltime", "float", "vim.version.version9", 0),
        ("vmknic", "string", "vim.version.version9", 0),
        ("tcpdumpFilter", "string", "vim.version.version9", 0),
        ("snaplen", "int", "vim.version.version9", 0),
        ("pkts", "string[]", "vim.version.version9", 0 | F_OPTIONAL),
        ("pcap", "string", "vim.version.version9", 0 | F_OPTIONAL),
        ("error", "vmodl.MethodFault", "vim.version.version9", 0 | F_OPTIONAL),
        ("hostname", "string", "vim.version.version9", 0 | F_OPTIONAL),
    ],
)
CreateDataType(
    "vim.cluster.VsanClusterNetworkLoadTestResult",
    "VsanClusterNetworkLoadTestResult",
    "vmodl.DynamicData",
    "vim.version.version9",
    [
        (
            "clusterResult",
            "vim.cluster.VsanClusterProactiveTestResult",
            "vim.version.version9",
<a name="2"></a>            0,
        ),
        (
            <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"hostResults",
            "vim.host.VsanNetworkLoadTestResult[]",
            "vim.version.version9",
            0 | F_OPTIONAL,
        ),
    ],
)
CreateDataType(
    "vim.vsan.upgradesystem.HostPropertyRetrieveIssue",
    "VsanHostPropertyRetrieveIssue",
    "vim.VsanUpgradeSystem.PreflightCheckIssue",
    "vim.version.version10",
    [("hosts", "vim.HostSystem[]", "vim.version.version10", 0)],
)
CreateEnumType(
    "vim.host.VsanObjectHealthState",
    "VsanObjectHealthState",
    "vim.version.version9",
    [
        "inaccessible",
        "reducedavailabilitywithnorebuild",
        "reducedavailabilitywithnorebuilddelaytimer",
        "reducedavailabilitywithactiverebuild",
        "datamove",
        "nonavailabilityrelatedreconfig",
        "nonavailabilityrelatedincompliance",
        "healthy",
    ],
)
CreateEnumType(
    "vim.cluster.VsanObjectTypeEnum",
    "VsanObjectTypeEnum",
    "vim.version.version9",
    [
        "vmswap",
        "vdisk",
        "namespace",
        "vmem",
        "statsdb",
        "iscsi",
        "other",
        "fileSystemOverhead",
        "dedupOverhead",
        "checksumOverhead",
    ],
)
CreateEnumType(
    "vim.cluster.VsanCapabilityType",
    "VsanCapabilityType",
    "vim.version.version10",
    [
        "capability",
        "allflash",
        "stretchedcluster",
        "dataefficiency",
        "clusterconfig",
        "upgrade",
        "objectidentities",
    ],
)
CreateEnumType(
    "vim.cluster.VsanHealthLogLevelEnum",
    "VsanHealthLogLevelEnum",
    "vim.version.version9",
    [
        "INFO",
        "WARNING",
        "ERROR",
        "DEBUG",
        "CRITICAL",
    ],
)
CreateEnumType(
    "vim.cluster.VsanPerfSummaryType",
    "VsanPerfSummaryType",
    "vim.version.version9",
    [
        "average",
        "maximum",
        "minimum",
        "latest",
        "summation",
        "none",
    ],
)
CreateEnumType(
    "vim.cluster.StorageComplianceStatus",
    "VsanStorageComplianceStatus",
    "vim.version.version9",
    [
        "compliant",
        "nonCompliant",
        "unknown",
        "notApplicable",
    ],
)
CreateEnumType(
    "vim.cluster.VsanPerfStatsUnitType",
    "VsanPerfStatsUnitType",
    "vim.version.version9",
    [
        "number",
        "time_ms",
        "percentage",
        "size_bytes",
        "rate_bytes",
    ],
)
CreateEnumType(
    "vim.cluster.VsanPerfThresholdDirectionType",
    "VsanPerfThresholdDirectionType",
    "vim.version.version9",
    [
        "upper",
        "lower",
    ],
)
CreateEnumType(
    "vim.cluster.VsanPerfStatsType",
    "VsanPerfStatsType",
    "vim.version.version9",
    [
        "absolute",
        "delta",
        "rate",
    ],
)
CreateEnumType(
    "vim.vsan.host.DiskMappingCreationType",
    "VimVsanHostDiskMappingCreationType",
    "vim.version.version10",
    [
        "hybrid",
        "allFlash",
    ],
)
CreateEnumType(
    "vim.cluster.VsanClusterHealthActionIdEnum",
    "VsanClusterHealthActionIdEnum",
    "vim.version.version9",
    [
        "RepairClusterObjectsAction",
        "UploadHclDb",
        "UpdateHclDbFromInternet",
        "EnableHealthService",
        "DiskBalance",
        "StopDiskBalance",
        "RemediateDedup",
        "UpgradeVsanDiskFormat",
    ],
)
CreateEnumType(
    "vim.cluster.VsanDiskGroupCreationType",
    "VimClusterVsanDiskGroupCreationType",
    "vim.version.version10",
    [
        "allflash"</b></font>,
        "hybrid",
    ],
)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_virt_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
virt execution module unit tests
"""

# pylint: disable=3rd-party-module-not-gated


import datetime
import os
import shutil
import tempfile
import xml.etree.ElementTree as ET

import salt.config
import salt.modules.config as config
import salt.modules.virt as virt
import salt.syspaths
import salt.utils.yaml
from salt.exceptions import CommandExecutionError, SaltInvocationError

# pylint: disable=import-error
from tests.support.helpers import dedent
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import MagicMock, patch
from tests.support.unit import TestCase

# pylint: disable=invalid-name,protected-access,attribute-defined-outside-init,too-many-public-methods,unused-argument


class LibvirtMock(MagicMock):  # pylint: disable=too-many-ancestors
    """
    Libvirt library mock
    """

    class virDomain(MagicMock):
        """
        virDomain mock
        """

    class libvirtError(Exception):
        """
        libvirtError mock
        """

        def __init__(self, msg):
            super().__init__(msg)
            self.msg = msg

        def get_error_message(self):
            return self.msg


class VirtTestCase(TestCase, LoaderModuleMockMixin):
    """
    Test cases for salt.module.virt
    """

    def setup_loader_modules(self):
        self.mock_libvirt = LibvirtMock()
        self.mock_conn = MagicMock()
        self.mock_conn.getStoragePoolCapabilities.return_value = (
            "&lt;storagepoolCapabilities/&gt;"
        )
        self.mock_libvirt.openAuth.return_value = self.mock_conn
        self.mock_popen = MagicMock()
        self.addCleanup(delattr, self, "mock_libvirt")
        self.addCleanup(delattr, self, "mock_conn")
        self.addCleanup(delattr, self, "mock_popen")
        self.mock_subprocess = MagicMock()
        self.mock_subprocess.return_value = (
            self.mock_subprocess
        )  # pylint: disable=no-member
        self.mock_subprocess.Popen.return_value = (
            self.mock_popen
        )  # pylint: disable=no-member
        loader_globals = {
            "__salt__": {"config.get": config.get, "config.option": config.option},
            "libvirt": self.mock_libvirt,
            "subprocess": self.mock_subprocess,
        }
        return {virt: loader_globals, config: loader_globals}

    def set_mock_vm(self, name, xml):
        """
        Define VM to use in tests
        """
        self.mock_conn.listDefinedDomains.return_value = [
            name
        ]  # pylint: disable=no-member
        mock_domain = self.mock_libvirt.virDomain()
        self.mock_conn.lookupByName.return_value = (
            mock_domain  # pylint: disable=no-member
        )
        mock_domain.XMLDesc.return_value = xml  # pylint: disable=no-member

        # Return state as shutdown
        mock_domain.info.return_value = [
            4,
            2048 * 1024,
            1024 * 1024,
            2,
            1234,
        ]  # pylint: disable=no-member
        mock_domain.ID.return_value = 1
        mock_domain.name.return_value = name
        return mock_domain

    def assert_equal_unit(self, actual, expected, unit="KiB"):
        self.assertEqual(actual.get("unit"), unit)
        self.assertEqual(actual.text, str(expected))

    def test_disk_profile_merge(self):
        """
        Test virt._disk_profile() when merging with user-defined disks
        """
        root_dir = os.path.join(salt.syspaths.ROOT_DIR, "srv", "salt-images")
        userdisks = [
            {"name": "system", "image": "/path/to/image"},
<a name="20"></a>            {"name": "data", "size": 16384, "format": "raw"},
        ]

        disks = virt<font color="#4e9258"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>._disk_profile(self.mock_conn, "default", "kvm", userdisks, "myvm")
        self.assertEqual(
            [
                {
                    "name": "system",
                    "device": "disk",
                    "size": 8192,
                    "format": "qcow2",
                    "model": "virtio",
                    "filename": "myvm_system.qcow2",
                    "image": "/path/to/image",
                    "source_file": "{}{}myvm_system.qcow2".format(root_dir, os.sep),
                },
                {
                    "name": "data",
                    "device": "disk",
                    "size": 16384,
                    "format": "raw",
                    "model": "virtio",
                    "filename": "myvm_data.raw",
                    "source_file": "{}{}myvm_data.raw".format(root_dir, os.</b></font>sep),
                },
            ],
            disks,
        )

    def test_boot_default_dev(self):
        """
        Test virt._gen_xml() default boot device
        """
        diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
        nicp = virt._nic_profile("default", "kvm")
        xml_data = virt._gen_xml(
            self.mock_conn, "hello", 1, 512, diskp, nicp, "kvm", "hvm", "x86_64"
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find("os/boot").attrib["dev"], "hd")
        self.assertEqual(root.find("os/type").attrib["arch"], "x86_64")
        self.assertEqual(root.find("os/type").text, "hvm")

    def test_boot_custom_dev(self):
        """
        Test virt._gen_xml() custom boot device
        """
        diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
        nicp = virt._nic_profile("default", "kvm")
        xml_data = virt._gen_xml(
            self.mock_conn,
            "hello",
            1,
            512,
            diskp,
            nicp,
            "kvm",
            "hvm",
            "x86_64",
            boot_dev="cdrom",
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find("os/boot").attrib["dev"], "cdrom")

    def test_boot_multiple_devs(self):
        """
        Test virt._gen_xml() multiple boot devices
        """
        diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
        nicp = virt._nic_profile("default", "kvm")
        xml_data = virt._gen_xml(
            self.mock_conn,
            "hello",
            1,
            512,
            diskp,
            nicp,
            "kvm",
            "hvm",
            "x86_64",
            boot_dev="cdrom network",
        )
        root = ET.fromstring(xml_data)
        devs = root.findall(".//boot")
        self.assertTrue(len(devs) == 2)

    def test_gen_xml_no_nic(self):
        """
        Test virt._gen_xml() serial console
        """
        diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
        nicp = virt._nic_profile("default", "kvm")
        xml_data = virt._gen_xml(
            self.mock_conn,
            "hello",
            1,
            512,
            diskp,
            nicp,
            "kvm",
            "hvm",
            "x86_64",
            serials=[{"type": "pty"}],
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find("devices/serial").attrib["type"], "pty")

    def test_gen_xml_for_telnet_serial(self):
        """
        Test virt._gen_xml() telnet serial
        """
        diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
        nicp = virt._nic_profile("default", "kvm")
        xml_data = virt._gen_xml(
            self.mock_conn,
            "hello",
            1,
            512,
            diskp,
            nicp,
            "kvm",
            "hvm",
            "x86_64",
            serials=[{"type": "tcp", "port": 22223, "protocol": "telnet"}],
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find("devices/serial").attrib["type"], "tcp")
        self.assertEqual(root.find("devices/serial/source").attrib["service"], "22223")
        self.assertEqual(root.find("devices/serial/protocol").attrib["type"], "telnet")

    def test_gen_xml_for_telnet_serial_unspecified_port(self):
        """
        Test virt._gen_xml() telnet serial without any specified port
        """
        diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
        nicp = virt._nic_profile("default", "kvm")
        xml_data = virt._gen_xml(
            self.mock_conn,
            "hello",
            1,
            512,
            diskp,
            nicp,
            "kvm",
            "hvm",
            "x86_64",
            serials=[{"type": "tcp"}],
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find("devices/serial").attrib["type"], "tcp")
        self.assertEqual(root.find("devices/serial/source").attrib["service"], "23023")
        self.assertFalse("tls" in root.find("devices/serial/source").keys())
        self.assertEqual(root.find("devices/serial/protocol").attrib["type"], "telnet")

    def test_gen_xml_for_chardev_types(self):
        """
        Test virt._gen_xml() consoles and serials of various types
        """
        diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
        nicp = virt._nic_profile("default", "kvm")
        xml_data = virt._gen_xml(
            self.mock_conn,
            "hello",
            1,
            512,
            diskp,
            nicp,
            "kvm",
            "hvm",
            "x86_64",
            consoles=[
                {"type": "pty", "path": "/dev/pts/2", "target_port": 2},
                {"type": "pty", "target_type": "usb-serial"},
                {"type": "stdio"},
                {"type": "file", "path": "/path/to/serial.log"},
            ],
            serials=[
                {"type": "pipe", "path": "/tmp/mypipe"},
                {"type": "udp", "host": "127.0.0.1", "port": 1234},
                {"type": "tcp", "port": 22223, "protocol": "raw", "tls": True},
                {"type": "unix", "path": "/path/to/socket"},
            ],
        )
        root = ET.fromstring(xml_data)

        self.assertEqual(root.find("devices/console[1]").attrib["type"], "pty")
        self.assertEqual(
            root.find("devices/console[1]/source").attrib["path"], "/dev/pts/2"
        )
        self.assertEqual(root.find("devices/console[1]/target").attrib["port"], "2")

        self.assertEqual(root.find("devices/console[2]").attrib["type"], "pty")
        self.assertIsNone(root.find("devices/console[2]/source"))
        self.assertEqual(
            root.find("devices/console[2]/target").attrib["type"], "usb-serial"
        )

        self.assertEqual(root.find("devices/console[3]").attrib["type"], "stdio")
        self.assertIsNone(root.find("devices/console[3]/source"))

        self.assertEqual(root.find("devices/console[4]").attrib["type"], "file")
        self.assertEqual(
            root.find("devices/console[4]/source").attrib["path"], "/path/to/serial.log"
        )

        self.assertEqual(root.find("devices/serial[1]").attrib["type"], "pipe")
        self.assertEqual(
            root.find("devices/serial[1]/source").attrib["path"], "/tmp/mypipe"
        )

        self.assertEqual(root.find("devices/serial[2]").attrib["type"], "udp")
        self.assertEqual(root.find("devices/serial[2]/source").attrib["mode"], "bind")
        self.assertEqual(
            root.find("devices/serial[2]/source").attrib["service"], "1234"
        )
        self.assertEqual(
            root.find("devices/serial[2]/source").attrib["host"], "127.0.0.1"
        )

        self.assertEqual(root.find("devices/serial[3]").attrib["type"], "tcp")
        self.assertEqual(root.find("devices/serial[3]/source").attrib["mode"], "bind")
        self.assertEqual(
            root.find("devices/serial[3]/source").attrib["service"], "22223"
        )
        self.assertEqual(root.find("devices/serial[3]/source").attrib["tls"], "yes")
        self.assertEqual(root.find("devices/serial[3]/protocol").attrib["type"], "raw")

        self.assertEqual(root.find("devices/serial[4]").attrib["type"], "unix")
        self.assertEqual(
            root.find("devices/serial[4]/source").attrib["path"], "/path/to/socket"
        )

    def test_gen_xml_no_nic_console(self):
        """
        Test virt._gen_xml()  console
        """
        diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
        nicp = virt._nic_profile("default", "kvm")
        xml_data = virt._gen_xml(
            self.mock_conn,
            "hello",
            1,
            512,
            diskp,
            nicp,
            "kvm",
            "hvm",
            "x86_64",
            consoles=[{"type": "pty"}],
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find("devices/console").attrib["type"], "pty")

    def test_gen_xml_for_telnet_console(self):
        """
        Test virt._gen_xml() telnet console
        """
        diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
        nicp = virt._nic_profile("default", "kvm")
        xml_data = virt._gen_xml(
            self.mock_conn,
            "hello",
            1,
            512,
            diskp,
            nicp,
            "kvm",
            "hvm",
            "x86_64",
            consoles=[{"type": "tcp", "port": 22223, "protocol": "telnet"}],
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find("devices/console").attrib["type"], "tcp")
        self.assertEqual(root.find("devices/console/source").attrib["service"], "22223")
        self.assertEqual(root.find("devices/console/protocol").attrib["type"], "telnet")

    def test_gen_xml_for_telnet_console_unspecified_port(self):
        """
        Test virt._gen_xml() telnet console without any specified port
        """
        diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
        nicp = virt._nic_profile("default", "kvm")
        xml_data = virt._gen_xml(
            self.mock_conn,
            "hello",
            1,
            512,
            diskp,
            nicp,
            "kvm",
            "hvm",
            "x86_64",
            consoles=[{"type": "tcp"}],
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find("devices/console").attrib["type"], "tcp")
        self.assertEqual(root.find("devices/console/source").attrib["service"], "23023")
        self.assertEqual(root.find("devices/console/protocol").attrib["type"], "telnet")

    def test_gen_xml_for_serial_no_console(self):
        """
        Test virt._gen_xml() with no serial console
        """
        diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
        nicp = virt._nic_profile("default", "kvm")
        xml_data = virt._gen_xml(
            self.mock_conn,
            "hello",
            1,
            512,
            diskp,
            nicp,
            "kvm",
            "hvm",
            "x86_64",
            serials=[{"type": "pty"}],
            consoles=[],
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find("devices/serial").attrib["type"], "pty")
        self.assertEqual(root.find("devices/console"), None)

    def test_gen_xml_for_telnet_no_console(self):
        """
        Test virt._gen_xml() with no telnet console
        """
        diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
        nicp = virt._nic_profile("default", "kvm")
        xml_data = virt._gen_xml(
            self.mock_conn,
            "hello",
            1,
            512,
            diskp,
            nicp,
            "kvm",
            "hvm",
            "x86_64",
            serials=[{"type": "tcp", "port": 22223, "protocol": "telnet"}],
            consoles=[],
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find("devices/serial").attrib["type"], "tcp")
        self.assertEqual(root.find("devices/console"), None)

    def test_gen_xml_nographics_default(self):
        """
        Test virt._gen_xml() with default no graphics device
        """
        diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
        nicp = virt._nic_profile("default", "kvm")
        xml_data = virt._gen_xml(
            self.mock_conn, "hello", 1, 512, diskp, nicp, "kvm", "hvm", "x86_64"
        )
        root = ET.fromstring(xml_data)
        self.assertIsNone(root.find("devices/graphics"))

    def test_gen_xml_noloader_default(self):
        """
        Test virt._gen_xml() with default no loader
        """
        diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
        nicp = virt._nic_profile("default", "kvm")
        xml_data = virt._gen_xml(
            self.mock_conn, "hello", 1, 512, diskp, nicp, "kvm", "hvm", "x86_64"
        )
        root = ET.fromstring(xml_data)
        self.assertIsNone(root.find("os/loader"))

    def test_gen_xml_vnc_default(self):
        """
        Test virt._gen_xml() with default vnc graphics device
        """
        diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
        nicp = virt._nic_profile("default", "kvm")
        xml_data = virt._gen_xml(
            self.mock_conn,
            "hello",
            1,
            512,
            diskp,
            nicp,
            "kvm",
            "hvm",
            "x86_64",
            graphics={
                "type": "vnc",
                "port": 1234,
                "tlsPort": 5678,
                "listen": {"type": "address", "address": "myhost"},
            },
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find("devices/graphics").attrib["type"], "vnc")
        self.assertEqual(root.find("devices/graphics").attrib["autoport"], "no")
        self.assertEqual(root.find("devices/graphics").attrib["port"], "1234")
        self.assertFalse("tlsPort" in root.find("devices/graphics").attrib)
        self.assertEqual(root.find("devices/graphics").attrib["listen"], "myhost")
        self.assertEqual(root.find("devices/graphics/listen").attrib["type"], "address")
        self.assertEqual(
            root.find("devices/graphics/listen").attrib["address"], "myhost"
        )

    def test_gen_xml_memory(self):
        """
        Test virt._gen_xml() with advanced memory settings
        """
        diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
        nicp = virt._nic_profile("default", "kvm")
        xml_data = virt._gen_xml(
            self.mock_conn,
            "hello",
            1,
            {
                "boot": "512m",
                "current": "256m",
                "max": "1g",
                "hard_limit": "1024",
                "soft_limit": "512m",
                "swap_hard_limit": "1g",
                "min_guarantee": "256m",
                "hugepages": [
                    {"size": "128m"},
                    {"nodeset": "0", "size": "256m"},
                    {"nodeset": "1", "size": "512m"},
                ],
                "nosharepages": True,
                "locked": True,
                "source": "file",
                "access": "shared",
                "allocation": "immediate",
                "discard": True,
            },
            diskp,
            nicp,
            "kvm",
            "hvm",
            "x86_64",
        )
        root = ET.fromstring(xml_data)
        self.assert_equal_unit(root.find("memory"), 512 * 1024)
        self.assert_equal_unit(root.find("currentMemory"), 256 * 1024)
        self.assert_equal_unit(root.find("maxMemory"), 1024 * 1024)
        self.assertFalse("slots" in root.find("maxMemory").keys())
        self.assert_equal_unit(root.find("memtune/hard_limit"), 1024 * 1024)
        self.assert_equal_unit(root.find("memtune/soft_limit"), 512 * 1024)
        self.assert_equal_unit(root.find("memtune/swap_hard_limit"), 1024 ** 2)
        self.assert_equal_unit(root.find("memtune/min_guarantee"), 256 * 1024)
<a name="2"></a>        self.assertEqual(
            [
                {"nodeset": page.get("nodeset"), "size": page.get("size")}
                for page in root<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.findall("memoryBacking/hugepages/page")
            ],
            [
                {"nodeset": None, "size": str(128 * 1024)},
                {"nodeset": "0", "size": str(256 * 1024)},
                {"nodeset": "1", "size": str(512 * 1024)},
            ],
        )
        self.assertIsNotNone(root.find("memoryBacking/nosharepages"))
        self.assertIsNotNone(root.find("memoryBacking/locked"))
        self.assertIsNotNone(root.find("memoryBacking/discard"))
        self.assertEqual(root.find("memoryBacking/source").get("type"), "file")
        self.</b></font>assertEqual(root.find("memoryBacking/access").get("mode"), "shared")
        self.assertEqual(root.find("memoryBacking/allocation").get("mode"), "immediate")

    def test_gen_xml_cpu(self):
        """
        Test virt._gen_xml() with CPU advanced properties
        """
        diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
        nicp = virt._nic_profile("default", "kvm")
        xml_data = virt._gen_xml(
            self.mock_conn,
            "hello",
            {
                "maximum": 12,
                "placement": "static",
                "cpuset": "0-11",
                "current": 5,
                "mode": "custom",
                "match": "minimum",
                "check": "full",
                "vendor": "Intel",
                "model": {
                    "name": "core2duo",
                    "fallback": "allow",
                    "vendor_id": "GenuineIntel",
                },
                "cache": {"level": 3, "mode": "emulate"},
                "features": {"lahf": "optional", "vmx": "require"},
                "vcpus": {
                    0: {"enabled": True, "hotpluggable": True},
                    1: {"enabled": False},
                },
            },
            512,
            diskp,
            nicp,
            "kvm",
            "hvm",
            "x86_64",
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find("vcpu").get("current"), "5")
        self.assertEqual(root.find("vcpu").get("placement"), "static")
        self.assertEqual(root.find("vcpu").get("cpuset"), "0-11")
        self.assertEqual(root.find("vcpu").text, "12")
        self.assertEqual(root.find("cpu").get("match"), "minimum")
        self.assertEqual(root.find("cpu").get("mode"), "custom")
        self.assertEqual(root.find("cpu").get("check"), "full")
        self.assertEqual(root.find("cpu/vendor").text, "Intel")
        self.assertEqual(root.find("cpu/model").text, "core2duo")
        self.assertEqual(root.find("cpu/model").get("fallback"), "allow")
        self.assertEqual(root.find("cpu/model").get("vendor_id"), "GenuineIntel")
        self.assertEqual(root.find("cpu/cache").get("level"), "3")
        self.assertEqual(root.find("cpu/cache").get("mode"), "emulate")
        self.assertEqual(
            {f.get("name"): f.get("policy") for f in root.findall("cpu/feature")},
            {"lahf": "optional", "vmx": "require"},
        )
        self.assertEqual(
            {
                v.get("id"): {
                    "enabled": v.get("enabled"),
                    "hotpluggable": v.get("hotpluggable"),
                }
                for v in root.findall("vcpus/vcpu")
            },
            {
                "0": {"enabled": "yes", "hotpluggable": "yes"},
                "1": {"enabled": "no", "hotpluggable": None},
            },
        )

    def test_gen_xml_cpu_topology(self):
        """
        Test virt._gen_xml() with CPU topology
        """
        diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
        nicp = virt._nic_profile("default", "kvm")
        xml_data = virt._gen_xml(
            self.mock_conn,
            "hello",
            {"maximum": 1, "topology": {"sockets": 4, "cores": 16, "threads": 2}},
            512,
            diskp,
            nicp,
            "kvm",
            "hvm",
            "x86_64",
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find("cpu/topology").get("sockets"), "4")
        self.assertEqual(root.find("cpu/topology").get("cores"), "16")
        self.assertEqual(root.find("cpu/topology").get("threads"), "2")

    def test_gen_xml_cpu_numa(self):
        """
        Test virt._gen_xml() with CPU numa settings
        """
        diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
        nicp = virt._nic_profile("default", "kvm")
        xml_data = virt._gen_xml(
            self.mock_conn,
            "hello",
            {
                "maximum": 1,
                "numa": {
                    0: {
                        "cpus": "0-3",
                        "memory": "1g",
                        "discard": True,
                        "distances": {0: 10, 1: 20},
                    },
                    1: {"cpus": "4-7", "memory": "2g", "distances": {0: 20, 1: 10}},
                },
            },
            512,
            diskp,
            nicp,
            "kvm",
            "hvm",
            "x86_64",
        )
        root = ET.fromstring(xml_data)
        cell0 = root.find("cpu/numa/cell[@id='0']")
        self.assertEqual(cell0.get("cpus"), "0-3")
        self.assertIsNone(cell0.get("unit"))
        self.assertEqual(cell0.get("memory"), str(1024 ** 2))
        self.assertEqual(cell0.get("discard"), "yes")
        self.assertEqual(
            {d.get("id"): d.get("value") for d in cell0.findall("distances/sibling")},
            {"0": "10", "1": "20"},
        )

        cell1 = root.find("cpu/numa/cell[@id='1']")
        self.assertEqual(cell1.get("cpus"), "4-7")
        self.assertIsNone(cell0.get("unit"))
        self.assertEqual(cell1.get("memory"), str(2 * 1024 ** 2))
        self.assertFalse("discard" in cell1.keys())
        self.assertEqual(
            {d.get("id"): d.get("value") for d in cell1.findall("distances/sibling")},
            {"0": "20", "1": "10"},
        )

    def test_gen_xml_cputune(self):
        """
        Test virt._gen_xml() with CPU tuning
        """
<a name="10"></a>        diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
        nicp = virt._nic_profile("default", "kvm")
        cputune = {
            <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"shares": 2048,
            "period": 122000,
            "quota": -1,
            "global_period": 1000000,
            "global_quota": -3,
            "emulator_period": 1200000,
            "emulator_quota": -10,
            "iothread_period": 133000,
            "iothread_quota": -1,
            "vcpupin": {0: "1-4,^2", 1: "0,1", 2: "2,3", 3: "0,4"},
            "emulatorpin": "1-3",
            "iothreadpin": {1: "5-6", 2: "7-8"},
            "vcpusched": [
                {"scheduler": "fifo", "priority": 1, "vcpus": "0"},
                {"scheduler": "fifo", "priority": 2, "vcpus": "1"},
                {"scheduler": "idle", "priority": 3, "vcpus": "2"},
            ],
            "iothreadsched": [
                {"scheduler": "idle"},
                {"scheduler": "batch", "iothreads": "5-7", "priority": 1},
            ],
            "emulatorsched": {"scheduler": "rr", "priority": 2},
            "cachetune": {
                "0-3": {
                    0: {"level": 3, "type": "both", "size": 3},
                    1: {"level": 3, "type": "both", "size": 3},
                    "monitor": {1: 3, "0-3": 3},
                },
                "4-5": {"monitor": {4: 3, 5: 2}},
            },
            "memorytune": {"0-2": {0: 60}, "3-4": {0</b></font>: 50, 1: 70}},
        }
        xml_data = virt._gen_xml(
            self.mock_conn,
            "hello",
            {"maximum": 1, "tuning": cputune, "iothreads": 2},
            512,
            diskp,
            nicp,
            "kvm",
            "hvm",
            "x86_64",
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find("cputune").find("shares").text, "2048")
        self.assertEqual(root.find("cputune").find("period").text, "122000")
        self.assertEqual(root.find("cputune").find("quota").text, "-1")
        self.assertEqual(root.find("cputune").find("global_period").text, "1000000")
        self.assertEqual(root.find("cputune").find("global_quota").text, "-3")
        self.assertEqual(root.find("cputune").find("emulator_period").text, "1200000")
        self.assertEqual(root.find("cputune").find("emulator_quota").text, "-10")
        self.assertEqual(root.find("cputune").find("iothread_period").text, "133000")
        self.assertEqual(root.find("cputune").find("iothread_quota").text, "-1")
        self.assertEqual(
            root.find("cputune").find("vcpupin[@vcpu='0']").attrib.get("cpuset"),
            "1-4,^2",
        )
        self.assertEqual(
            root.find("cputune").find("vcpupin[@vcpu='1']").attrib.get("cpuset"),
            "0,1",
        )
        self.assertEqual(
            root.find("cputune").find("vcpupin[@vcpu='2']").attrib.get("cpuset"),
            "2,3",
        )
        self.assertEqual(
            root.find("cputune").find("vcpupin[@vcpu='3']").attrib.get("cpuset"),
            "0,4",
        )
        self.assertEqual(
            root.find("cputune").find("emulatorpin").attrib.get("cpuset"), "1-3"
        )
        self.assertEqual(
            root.find("cputune")
            .find("iothreadpin[@iothread='1']")
            .attrib.get("cpuset"),
            "5-6",
        )
        self.assertEqual(
            root.find("cputune")
            .find("iothreadpin[@iothread='2']")
            .attrib.get("cpuset"),
            "7-8",
        )
        self.assertDictEqual(
            {
                s.get("vcpus"): {
<a name="25"></a>                    "scheduler": s.get("scheduler"),
                    "priority": s.get("priority"),
                }
                for s in root<font color="#5eac10"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.findall("cputune/vcpusched")
            },
            {
                "0": {"scheduler": "fifo", "priority": "1"},
                "1": {"scheduler": "fifo", "priority": "2"},
                "2": {"scheduler": "idle", "priority": "3"},
            },
        )
        self.assertDictEqual(
            {
                s.get("iothreads"): {
                    "scheduler": s.</b></font>get("scheduler"),
                    "priority": s.get("priority"),
                }
                for s in root.findall("cputune/iothreadsched")
            },
            {
                None: {"scheduler": "idle", "priority": None},
                "5-7": {"scheduler": "batch", "priority": "1"},
            },
        )
        self.assertEqual(root.find("cputune/emulatorsched").get("scheduler"), "rr")
        self.assertEqual(root.find("cputune/emulatorsched").get("priority"), "2")
        self.assertEqual(
            root.find("./cputune/cachetune[@vcpus='0-3']").attrib.get("vcpus"), "0-3"
        )
        self.assertEqual(
            root.find("./cputune/cachetune[@vcpus='0-3']/cache[@id='0']").attrib.get(
                "level"
            ),
            "3",
        )
        self.assertEqual(
            root.find("./cputune/cachetune[@vcpus='0-3']/cache[@id='0']").attrib.get(
                "type"
            ),
            "both",
        )
        self.assertEqual(
            root.find(
                "./cputune/cachetune[@vcpus='0-3']/monitor[@vcpus='1']"
            ).attrib.get("level"),
            "3",
        )
        self.assertNotEqual(
            root.find("./cputune/cachetune[@vcpus='0-3']/monitor[@vcpus='1']"), None
        )
        self.assertNotEqual(
            root.find("./cputune/cachetune[@vcpus='4-5']").attrib.get("vcpus"), None
        )
        self.assertEqual(
            root.find("./cputune/cachetune[@vcpus='4-5']/cache[@id='0']"), None
        )
        self.assertEqual(
            root.find(
                "./cputune/cachetune[@vcpus='4-5']/monitor[@vcpus='4']"
            ).attrib.get("level"),
            "3",
        )
        self.assertEqual(
            root.find(
                "./cputune/cachetune[@vcpus='4-5']/monitor[@vcpus='5']"
            ).attrib.get("level"),
            "2",
        )
        self.assertNotEqual(root.find("./cputune/memorytune[@vcpus='0-2']"), None)
        self.assertEqual(
            root.find("./cputune/memorytune[@vcpus='0-2']/node[@id='0']").attrib.get(
                "bandwidth"
            ),
            "60",
        )
        self.assertNotEqual(root.find("./cputune/memorytune[@vcpus='3-4']"), None)
        self.assertEqual(
            root.find("./cputune/memorytune[@vcpus='3-4']/node[@id='0']").attrib.get(
                "bandwidth"
            ),
            "50",
        )
        self.assertEqual(
            root.find("./cputune/memorytune[@vcpus='3-4']/node[@id='1']").attrib.get(
                "bandwidth"
            ),
            "70",
        )
        self.assertEqual(root.find("iothreads").text, "2")

    def test_default_disk_profile_hypervisor_esxi(self):
        """
        Test virt._disk_profile() default ESXi profile
        """
        mock = MagicMock(return_value={})
        with patch.dict(
            virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
        ):
            ret = virt._disk_profile(
                self.mock_conn, "nonexistent", "vmware", None, "test-vm"
            )
            self.assertTrue(len(ret) == 1)
            found = [disk for disk in ret if disk["name"] == "system"]
            self.assertTrue(bool(found))
            system = found[0]
            self.assertEqual(system["format"], "vmdk")
            self.assertEqual(system["model"], "scsi")
            self.assertTrue(int(system["size"]) &gt;= 1)

    def test_default_disk_profile_hypervisor_kvm(self):
        """
        Test virt._disk_profile() default KVM profile
        """
        mock = MagicMock(side_effect=[{}, "/images/dir"])
        with patch.dict(
            virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
        ):
            ret = virt._disk_profile(
                self.mock_conn, "nonexistent", "kvm", None, "test-vm"
            )
            self.assertTrue(len(ret) == 1)
            found = [disk for disk in ret if disk["name"] == "system"]
            self.assertTrue(bool(found))
            system = found[0]
            self.assertEqual(system["format"], "qcow2")
            self.assertEqual(system["model"], "virtio")
            self.assertTrue(int(system["size"]) &gt;= 1)

    def test_default_disk_profile_hypervisor_xen(self):
        """
        Test virt._disk_profile() default XEN profile
        """
        mock = MagicMock(side_effect=[{}, "/images/dir"])
        with patch.dict(
            virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
        ):
            ret = virt._disk_profile(
                self.mock_conn, "nonexistent", "xen", None, "test-vm"
            )
            self.assertTrue(len(ret) == 1)
            found = [disk for disk in ret if disk["name"] == "system"]
            self.assertTrue(bool(found))
            system = found[0]
            self.assertEqual(system["format"], "qcow2")
            self.assertEqual(system["model"], "xen")
            self.assertTrue(int(system["size"]) &gt;= 1)

    def test_default_nic_profile_hypervisor_esxi(self):
        """
        Test virt._nic_profile() default ESXi profile
        """
        mock = MagicMock(return_value={})
        with patch.dict(
            virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
        ):
            ret = virt._nic_profile("nonexistent", "vmware")
            self.assertTrue(len(ret) == 1)
            eth0 = ret[0]
            self.assertEqual(eth0["name"], "eth0")
            self.assertEqual(eth0["type"], "bridge")
            self.assertEqual(eth0["source"], "DEFAULT")
            self.assertEqual(eth0["model"], "e1000")

    def test_default_nic_profile_hypervisor_kvm(self):
        """
        Test virt._nic_profile() default KVM profile
        """
        mock = MagicMock(return_value={})
        with patch.dict(
            virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
        ):
            ret = virt._nic_profile("nonexistent", "kvm")
            self.assertTrue(len(ret) == 1)
            eth0 = ret[0]
            self.assertEqual(eth0["name"], "eth0")
            self.assertEqual(eth0["type"], "bridge")
            self.assertEqual(eth0["source"], "br0")
            self.assertEqual(eth0["model"], "virtio")

    def test_default_nic_profile_hypervisor_xen(self):
        """
        Test virt._nic_profile() default XEN profile
        """
        mock = MagicMock(return_value={})
        with patch.dict(
            virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
        ):
            ret = virt._nic_profile("nonexistent", "xen")
            self.assertTrue(len(ret) == 1)
            eth0 = ret[0]
            self.assertEqual(eth0["name"], "eth0")
            self.assertEqual(eth0["type"], "bridge")
            self.assertEqual(eth0["source"], "br0")
            self.assertFalse(eth0["model"])

    def test_gen_vol_xml_esx(self):
        """
        Test virt._get_vol_xml() for the ESX case
        """
        xml_data = virt._gen_vol_xml("vmname/system.vmdk", 8192, format="vmdk")
        root = ET.fromstring(xml_data)
        self.assertIsNone(root.get("type"))
        self.assertEqual(root.find("name").text, "vmname/system.vmdk")
        self.assertEqual(root.find("capacity").attrib["unit"], "KiB")
        self.assertEqual(root.find("capacity").text, str(8192 * 1024))
        self.assertEqual(root.find("allocation").text, str(0))
        self.assertEqual(root.find("target/format").get("type"), "vmdk")
        self.assertIsNone(root.find("target/permissions"))
        self.assertIsNone(root.find("target/nocow"))
        self.assertIsNone(root.find("backingStore"))

    def test_gen_vol_xml_file(self):
        """
        Test virt._get_vol_xml() for a file volume
        """
        xml_data = virt._gen_vol_xml(
            "myvm_system.qcow2",
            8192,
            format="qcow2",
            allocation=4096,
            type="file",
            permissions={
                "mode": "0775",
                "owner": "123",
                "group": "456",
                "label": "sec_label",
            },
            backing_store={"path": "/backing/image", "format": "raw"},
            nocow=True,
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.get("type"), "file")
        self.assertEqual(root.find("name").text, "myvm_system.qcow2")
        self.assertIsNone(root.find("key"))
        self.assertIsNone(root.find("target/path"))
        self.assertEqual(root.find("target/format").get("type"), "qcow2")
        self.assertEqual(root.find("capacity").attrib["unit"], "KiB")
        self.assertEqual(root.find("capacity").text, str(8192 * 1024))
        self.assertEqual(root.find("capacity").attrib["unit"], "KiB")
        self.assertEqual(root.find("allocation").text, str(4096 * 1024))
        self.assertEqual(root.find("target/permissions/mode").text, "0775")
        self.assertEqual(root.find("target/permissions/owner").text, "123")
        self.assertEqual(root.find("target/permissions/group").text, "456")
        self.assertEqual(root.find("target/permissions/label").text, "sec_label")
        self.assertIsNotNone(root.find("target/nocow"))
        self.assertEqual(root.find("backingStore/path").text, "/backing/image")
        self.assertEqual(root.find("backingStore/format").get("type"), "raw")

    def test_gen_xml_for_kvm_default_profile(self):
        """
        Test virt._gen_xml(), KVM default profile case
        """
        diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
        nicp = virt._nic_profile("default", "kvm")
        xml_data = virt._gen_xml(
            self.mock_conn,
            "hello",
            1,
            512,
            diskp,
            nicp,
            "kvm",
            "hvm",
            "x86_64",
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.attrib["type"], "kvm")
        self.assertEqual(root.find("vcpu").text, "1")
        self.assertEqual(root.find("memory").text, str(512 * 1024))
        self.assertEqual(root.find("memory").attrib["unit"], "KiB")

        disks = root.findall(".//disk")
        self.assertEqual(len(disks), 1)
        disk = disks[0]
        root_dir = salt.config.DEFAULT_MINION_OPTS.get("root_dir")
        self.assertTrue(disk.find("source").attrib["file"].startswith(root_dir))
        self.assertTrue("hello_system" in disk.find("source").attrib["file"])
        self.assertEqual(disk.find("target").attrib["dev"], "vda")
        self.assertEqual(disk.find("target").attrib["bus"], "virtio")
        self.assertEqual(disk.find("driver").attrib["name"], "qemu")
        self.assertEqual(disk.find("driver").attrib["type"], "qcow2")

        interfaces = root.findall(".//interface")
        self.assertEqual(len(interfaces), 1)
        iface = interfaces[0]
        self.assertEqual(iface.attrib["type"], "bridge")
        self.assertEqual(iface.find("source").attrib["bridge"], "br0")
        self.assertEqual(iface.find("model").attrib["type"], "virtio")

    def test_gen_xml_for_esxi_default_profile(self):
        """
        Test virt._gen_xml(), ESXi/vmware default profile case
        """
        diskp = virt._disk_profile(self.mock_conn, "default", "vmware", [], "hello")
        nicp = virt._nic_profile("default", "vmware")
        xml_data = virt._gen_xml(
            self.mock_conn,
            "hello",
            1,
            512,
            diskp,
            nicp,
            "vmware",
            "hvm",
            "x86_64",
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.attrib["type"], "vmware")
        self.assertEqual(root.find("vcpu").text, "1")
        self.assertEqual(root.find("memory").text, str(512 * 1024))
        self.assertEqual(root.find("memory").attrib["unit"], "KiB")

        disks = root.findall(".//disk")
        self.assertEqual(len(disks), 1)
        disk = disks[0]
        self.assertTrue("[0]" in disk.find("source").attrib["file"])
        self.assertTrue("hello_system" in disk.find("source").attrib["file"])
        self.assertEqual(disk.find("target").attrib["dev"], "sda")
        self.assertEqual(disk.find("target").attrib["bus"], "scsi")
        self.assertEqual(disk.find("address").attrib["unit"], "0")

        interfaces = root.findall(".//interface")
        self.assertEqual(len(interfaces), 1)
        iface = interfaces[0]
        self.assertEqual(iface.attrib["type"], "bridge")
        self.assertEqual(iface.find("source").attrib["bridge"], "DEFAULT")
        self.assertEqual(iface.find("model").attrib["type"], "e1000")

    def test_gen_xml_for_esxi_custom_profile(self):
        """
        Test virt._gen_xml(), ESXi/vmware custom profile case
        """
        disks = {
            "noeffect": [
                {"first": {"size": 8192, "pool": "datastore1"}},
                {"second": {"size": 4096, "pool": "datastore2"}},
            ]
        }
        nics = {
            "noeffect": [
                {"name": "eth1", "source": "ONENET"},
                {"name": "eth2", "source": "TWONET"},
            ]
        }
        with patch.dict(
            virt.__salt__,  # pylint: disable=no-member
            {"config.get": MagicMock(side_effect=[disks, nics])},
        ):
            diskp = virt._disk_profile(
                self.mock_conn, "noeffect", "vmware", [], "hello"
            )
            nicp = virt._nic_profile("noeffect", "vmware")
            xml_data = virt._gen_xml(
                self.mock_conn,
                "hello",
                1,
                512,
                diskp,
                nicp,
                "vmware",
                "hvm",
                "x86_64",
            )
            root = ET.fromstring(xml_data)
            self.assertEqual(root.attrib["type"], "vmware")
            self.assertEqual(root.find("vcpu").text, "1")
            self.assertEqual(root.find("memory").text, str(512 * 1024))
            self.assertEqual(root.find("memory").attrib["unit"], "KiB")
            self.assertTrue(len(root.findall(".//disk")) == 2)
            self.assertTrue(len(root.findall(".//interface")) == 2)

    def test_gen_xml_for_kvm_custom_profile(self):
        """
        Test virt._gen_xml(), KVM custom profile case
        """
        disks = {
            "noeffect": [
                {"first": {"size": 8192, "pool": "/var/lib/images"}},
                {"second": {"size": 4096, "pool": "/var/lib/images"}},
            ]
        }
        nics = {
            "noeffect": [
                {"name": "eth1", "source": "b2"},
                {"name": "eth2", "source": "b2"},
            ]
        }
        with patch.dict(
            virt.__salt__,  # pylint: disable=no-member
            {"config.get": MagicMock(side_effect=[disks, nics])},
        ):
            diskp = virt._disk_profile(self.mock_conn, "noeffect", "kvm", [], "hello")
            nicp = virt._nic_profile("noeffect", "kvm")
            xml_data = virt._gen_xml(
                self.mock_conn,
                "hello",
                1,
                512,
                diskp,
                nicp,
                "kvm",
                "hvm",
                "x86_64",
            )
            root = ET.fromstring(xml_data)
            self.assertEqual(root.attrib["type"], "kvm")
            self.assertEqual(root.find("vcpu").text, "1")
            self.assertEqual(root.find("memory").text, str(512 * 1024))
            self.assertEqual(root.find("memory").attrib["unit"], "KiB")
            disks = root.findall(".//disk")
            self.assertTrue(len(disks) == 2)
            self.assertEqual(disks[0].find("target").get("dev"), "vda")
            self.assertEqual(disks[1].find("target").get("dev"), "vdb")
            self.assertTrue(len(root.findall(".//interface")) == 2)

    def test_disk_profile_kvm_disk_pool(self):
        """
        Test virt._disk_profile(), KVM case with pools defined.
        """
        disks = {
            "noeffect": [
                {"first": {"size": 8192, "pool": "mypool"}},
                {"second": {"size": 4096}},
            ]
        }

        # pylint: disable=no-member
        with patch.dict(
            virt.__salt__,
            {
                "config.get": MagicMock(
                    side_effect=[
                        disks,
                        os.path.join(salt.syspaths.ROOT_DIR, "default", "path"),
                    ]
                )
            },
        ):

            diskp = virt._disk_profile(self.mock_conn, "noeffect", "kvm", [], "hello")

            pools_path = (
                os.path.join(salt.syspaths.ROOT_DIR, "pools", "mypool") + os.sep
            )
            default_path = (
                os.path.join(salt.syspaths.ROOT_DIR, "default", "path") + os.sep
            )

            self.assertEqual(len(diskp), 2)
            self.assertTrue(diskp[1]["source_file"].startswith(default_path))
        # pylint: enable=no-member

    def test_disk_profile_kvm_disk_external_image(self):
        """
        Test virt._gen_xml(), KVM case with an external image.
        """
        with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
            diskp = virt._disk_profile(
                self.mock_conn,
                None,
                "kvm",
                [{"name": "mydisk", "source_file": "/path/to/my/image.qcow2"}],
                "hello",
            )

            self.assertEqual(len(diskp), 1)
            self.assertEqual(diskp[0]["source_file"], "/path/to/my/image.qcow2")

    def test_disk_profile_cdrom_default(self):
        """
        Test virt._gen_xml(), KVM case with cdrom.
        """
        with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
            diskp = virt._disk_profile(
                self.mock_conn,
                None,
                "kvm",
                [
                    {
                        "name": "mydisk",
                        "device": "cdrom",
                        "source_file": "/path/to/my.iso",
                    }
                ],
                "hello",
            )

            self.assertEqual(len(diskp), 1)
            self.assertEqual(diskp[0]["model"], "ide")
            self.assertEqual(diskp[0]["format"], "raw")

    def test_disk_profile_pool_disk_type(self):
        """
        Test virt._disk_profile(), with a disk pool of disk type
        """
        self.mock_conn.listStoragePools.return_value = ["test-vdb"]
        self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = """
            &lt;pool type="disk"&gt;
              &lt;name&gt;test-vdb&lt;/name&gt;
              &lt;source&gt;
                &lt;device path='/dev/vdb'/&gt;
              &lt;/source&gt;
              &lt;target&gt;
                &lt;path&gt;/dev&lt;/path&gt;
              &lt;/target&gt;
            &lt;/pool&gt;
        """

        # No existing disk case
<a name="19"></a>        self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = (
            []
        )
        diskp = virt<font color="#f62817"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>._disk_profile(
            self.mock_conn,
            None,
            "kvm",
            [{"name": "mydisk", "pool": "test-vdb"}],
            "hello",
        )
        self.assertEqual(diskp[0]["filename"], "vdb1")

        # Append to the end case
        self.mock_conn.storagePoolLookupByName.return_value.listVolumes.</b></font>return_value = [
            "vdb1",
<a name="33"></a>            "vdb2",
        ]
        diskp = virt._disk_profile(
            self<font color="#736aff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.mock_conn,
            None,
            "kvm",
            [{"name": "mydisk", "pool": "test-vdb"}],
            "hello",
        )
        self.assertEqual(diskp[0]["filename"], "vdb3")

        # Hole in the middle case
        self.mock_conn.storagePoolLookupByName.return_value.listVolumes.</b></font>return_value = [
            "vdb1",
            "vdb3",
        ]
        diskp = virt._disk_profile(
            self.mock_conn,
            None,
            "kvm",
            [{"name": "mydisk", "pool": "test-vdb"}],
            "hello",
        )
        self.assertEqual(diskp[0]["filename"], "vdb2")

        # Reuse existing volume case
        diskp = virt._disk_profile(
            self.mock_conn,
            None,
            "kvm",
            [{"name": "mydisk", "pool": "test-vdb", "source_file": "vdb1"}],
            "hello",
        )
        self.assertEqual(diskp[0]["filename"], "vdb1")

    def test_gen_xml_volume(self):
        """
        Test virt._gen_xml(), generating a disk of volume type
        """
        self.mock_conn.listStoragePools.return_value = ["default"]
        self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
            "&lt;pool type='dir'/&gt;"
        )
        self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = [
            "myvolume"
        ]
        diskp = virt._disk_profile(
            self.mock_conn,
            None,
            "kvm",
            [
                {"name": "system", "pool": "default"},
                {"name": "data", "pool": "default", "source_file": "myvolume"},
            ],
            "hello",
        )
        self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
            "&lt;pool type='dir'/&gt;"
        )
        nicp = virt._nic_profile(None, "kvm")
        xml_data = virt._gen_xml(
            self.mock_conn,
            "hello",
            1,
            512,
            diskp,
            nicp,
            "kvm",
            "hvm",
            "x86_64",
        )
        root = ET.fromstring(xml_data)
        disk = root.findall(".//disk")[0]
        self.assertEqual(disk.attrib["device"], "disk")
        self.assertEqual(disk.attrib["type"], "volume")
        source = disk.find("source")
        self.assertEqual("default", source.attrib["pool"])
        self.assertEqual("hello_system", source.attrib["volume"])
        self.assertEqual("myvolume", root.find(".//disk[2]/source").get("volume"))

        # RBD volume usage auth test case
        self.mock_conn.listStoragePools.return_value = ["test-rbd"]
        self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = """
            &lt;pool type='rbd'&gt;
              &lt;name&gt;test-rbd&lt;/name&gt;
              &lt;uuid&gt;ede33e0a-9df0-479f-8afd-55085a01b244&lt;/uuid&gt;
              &lt;capacity unit='bytes'&gt;526133493760&lt;/capacity&gt;
              &lt;allocation unit='bytes'&gt;589928&lt;/allocation&gt;
              &lt;available unit='bytes'&gt;515081306112&lt;/available&gt;
              &lt;source&gt;
                &lt;host name='ses2.tf.local'/&gt;
                &lt;host name='ses3.tf.local' port='1234'/&gt;
                &lt;name&gt;libvirt-pool&lt;/name&gt;
                &lt;auth type='ceph' username='libvirt'&gt;
                  &lt;secret usage='pool_test-rbd'/&gt;
                &lt;/auth&gt;
              &lt;/source&gt;
            &lt;/pool&gt;
        """
        self.mock_conn.getStoragePoolCapabilities.return_value = """
            &lt;storagepoolCapabilities&gt;
              &lt;pool type='rbd' supported='yes'&gt;
                &lt;volOptions&gt;
                  &lt;defaultFormat type='raw'/&gt;
                  &lt;enum name='targetFormatType'&gt;
                  &lt;/enum&gt;
                &lt;/volOptions&gt;
              &lt;/pool&gt;
            &lt;/storagepoolCapabilities&gt;
        """
        diskp = virt._disk_profile(
            self.mock_conn,
            None,
            "kvm",
            [{"name": "system", "pool": "test-rbd"}],
            "test-vm",
        )
        xml_data = virt._gen_xml(
            self.mock_conn,
            "hello",
            1,
            512,
            diskp,
            nicp,
            "kvm",
            "hvm",
            "x86_64",
        )
        root = ET.fromstring(xml_data)
<a name="12"></a>        disk = root.findall(".//disk")[0]
        self.assertDictEqual(
            {
                <font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"type": "network",
                "device": "disk",
                "source": {
                    "protocol": "rbd",
                    "name": "libvirt-pool/test-vm_system",
                    "host": [
                        {"name": "ses2.tf.local"},
                        {"name": "ses3.tf.local", "port": "1234"},
                    ],
                    "auth": {
                        "username": "libvirt",
                        "secret": {"type": "ceph", "usage": "pool_test-rbd"},
                    },
                },
                "target": {"dev": "vda", "bus": "virtio"},
                "driver": {
                    "name": "qemu",
                    "type": "raw",
                    "cache": "none",
                    "io": "native",
                },
            },
            salt.utils.xmlutil.to_dict(disk, True),
        )

        # RBD volume UUID auth test case
        self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.</b></font>return_value = """
            &lt;pool type='rbd'&gt;
              &lt;name&gt;test-rbd&lt;/name&gt;
              &lt;uuid&gt;ede33e0a-9df0-479f-8afd-55085a01b244&lt;/uuid&gt;
              &lt;capacity unit='bytes'&gt;526133493760&lt;/capacity&gt;
              &lt;allocation unit='bytes'&gt;589928&lt;/allocation&gt;
              &lt;available unit='bytes'&gt;515081306112&lt;/available&gt;
              &lt;source&gt;
                &lt;host name='ses2.tf.local'/&gt;
                &lt;host name='ses3.tf.local' port='1234'/&gt;
                &lt;name&gt;libvirt-pool&lt;/name&gt;
                &lt;auth type='ceph' username='libvirt'&gt;
                  &lt;secret uuid='some-uuid'/&gt;
                &lt;/auth&gt;
              &lt;/source&gt;
            &lt;/pool&gt;
        """
        self.mock_conn.secretLookupByUUIDString.return_value.usageID.return_value = (
            "pool_test-rbd"
        )
        diskp = virt._disk_profile(
            self.mock_conn,
            None,
            "kvm",
            [{"name": "system", "pool": "test-rbd"}],
            "test-vm",
        )
        xml_data = virt._gen_xml(
            self.mock_conn,
            "hello",
            1,
            512,
            diskp,
            nicp,
            "kvm",
            "hvm",
            "x86_64",
        )
        root = ET.fromstring(xml_data)
        self.assertDictEqual(
            {
                "username": "libvirt",
                "secret": {"type": "ceph", "usage": "pool_test-rbd"},
            },
            salt.utils.xmlutil.to_dict(root.find(".//disk/source/auth"), True),
        )
        self.mock_conn.secretLookupByUUIDString.assert_called_once_with("some-uuid")

        # Disk volume test case
        self.mock_conn.getStoragePoolCapabilities.return_value = """
            &lt;storagepoolCapabilities&gt;
              &lt;pool type='disk' supported='yes'&gt;
                &lt;volOptions&gt;
                  &lt;defaultFormat type='none'/&gt;
                  &lt;enum name='targetFormatType'&gt;
                    &lt;value&gt;none&lt;/value&gt;
                    &lt;value&gt;linux&lt;/value&gt;
                    &lt;value&gt;fat16&lt;/value&gt;
                  &lt;/enum&gt;
                &lt;/volOptions&gt;
              &lt;/pool&gt;
            &lt;/storagepoolCapabilities&gt;
        """
        self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = """
            &lt;pool type='disk'&gt;
              &lt;name&gt;test-vdb&lt;/name&gt;
              &lt;source&gt;
                &lt;device path='/dev/vdb'/&gt;
                &lt;format type='gpt'/&gt;
              &lt;/source&gt;
            &lt;/pool&gt;
        """
        self.mock_conn.listStoragePools.return_value = ["test-vdb"]
        self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = [
            "vdb1",
        ]
        diskp = virt._disk_profile(
            self.mock_conn,
            None,
            "kvm",
            [{"name": "system", "pool": "test-vdb"}],
            "test-vm",
        )
        xml_data = virt._gen_xml(
            self.mock_conn,
            "hello",
            1,
            512,
            diskp,
            nicp,
            "kvm",
            "hvm",
            "x86_64",
        )
        root = ET.fromstring(xml_data)
        disk = root.findall(".//disk")[0]
        self.assertEqual(disk.attrib["type"], "volume")
        source = disk.find("source")
        self.assertEqual("test-vdb", source.attrib["pool"])
        self.assertEqual("vdb2", source.attrib["volume"])
        self.assertEqual("raw", disk.find("driver").get("type"))

    def test_get_xml_volume_xen_dir(self):
        """
        Test virt._gen_xml generating disks for a Xen hypervisor
        """
        self.mock_conn.listStoragePools.return_value = ["default"]
        pool_mock = MagicMock()
        pool_mock.XMLDesc.return_value = (
            "&lt;pool type='dir'&gt;&lt;target&gt;&lt;path&gt;/path/to/images&lt;/path&gt;&lt;/target&gt;&lt;/pool&gt;"
        )
        volume_xml = "&lt;volume&gt;&lt;target&gt;&lt;path&gt;/path/to/images/hello_system&lt;/path&gt;&lt;/target&gt;&lt;/volume&gt;"
        pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = volume_xml
        self.mock_conn.storagePoolLookupByName.return_value = pool_mock
        diskp = virt._disk_profile(
            self.mock_conn,
            None,
            "xen",
            [{"name": "system", "pool": "default"}],
            "hello",
        )
        xml_data = virt._gen_xml(
            self.mock_conn,
            "hello",
            1,
            512,
            diskp,
            [],
            "xen",
            "hvm",
            "x86_64",
        )
        root = ET.fromstring(xml_data)
        disk = root.findall(".//disk")[0]
        self.assertEqual(disk.attrib["type"], "file")
        self.assertEqual(
            "/path/to/images/hello_system", disk.find("source").attrib["file"]
        )

    def test_get_xml_volume_xen_block(self):
        """
        Test virt._gen_xml generating disks for a Xen hypervisor
        """
        self.mock_conn.listStoragePools.return_value = ["default"]
        pool_mock = MagicMock()
        pool_mock.listVolumes.return_value = ["vol01"]
        volume_xml = "&lt;volume&gt;&lt;target&gt;&lt;path&gt;/dev/to/vol01&lt;/path&gt;&lt;/target&gt;&lt;/volume&gt;"
        pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = volume_xml
        self.mock_conn.storagePoolLookupByName.return_value = pool_mock

        for pool_type in ["logical", "disk", "iscsi", "scsi"]:
            pool_mock.XMLDesc.return_value = "&lt;pool type='{}'&gt;&lt;source&gt;&lt;device path='/dev/sda'/&gt;&lt;/source&gt;&lt;/pool&gt;".format(
                pool_type
            )
            diskp = virt._disk_profile(
                self.mock_conn,
                None,
                "xen",
                [{"name": "system", "pool": "default", "source_file": "vol01"}],
                "hello",
            )
            xml_data = virt._gen_xml(
                self.mock_conn,
                "hello",
                1,
                512,
                diskp,
                [],
                "xen",
                "hvm",
                "x86_64",
            )
            root = ET.fromstring(xml_data)
            disk = root.findall(".//disk")[0]
            self.assertEqual(disk.attrib["type"], "block")
            self.assertEqual("/dev/to/vol01", disk.find("source").attrib["dev"])

    def test_gen_xml_cdrom(self):
        """
        Test virt._gen_xml(), generating a cdrom device (different disk type, no source)
        """
        self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
            "&lt;pool type='dir'/&gt;"
        )
        diskp = virt._disk_profile(
            self.mock_conn,
            None,
            "kvm",
            [
                {"name": "system", "pool": "default"},
                {
                    "name": "tested",
                    "device": "cdrom",
                    "source_file": None,
                    "model": "ide",
                },
                {
                    "name": "remote",
                    "device": "cdrom",
                    "source_file": (
                        "http://myhost:8080/url/to/image?query=foo&amp;filter=bar"
                    ),
                    "model": "ide",
                },
            ],
            "hello",
        )
        nicp = virt._nic_profile(None, "kvm")
        xml_data = virt._gen_xml(
            self.mock_conn,
            "hello",
            1,
            512,
            diskp,
            nicp,
            "kvm",
            "hvm",
            "x86_64",
        )
        root = ET.fromstring(xml_data)
        disk = root.findall(".//disk")[1]
        self.assertEqual(disk.get("type"), "file")
        self.assertEqual(disk.attrib["device"], "cdrom")
        self.assertIsNone(disk.find("source"))
        self.assertEqual(disk.find("target").get("dev"), "hda")
<a name="24"></a>
        disk = root.findall(".//disk")[2]
        self.assertEqual(disk.get("type"), "network")
        self<font color="#79764d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertEqual(disk.attrib["device"], "cdrom")
        self.assertEqual(
            {
                "protocol": "http",
                "name": "/url/to/image",
                "query": "query=foo&amp;filter=bar",
                "host": {"name": "myhost", "port": "8080"},
            },
            salt.utils.xmlutil.to_dict(disk.</b></font>find("source"), True),
        )

    def test_controller_for_esxi(self):
        """
        Test virt._gen_xml() generated device controller for ESXi/vmware
        """
        diskp = virt._disk_profile(self.mock_conn, "default", "vmware", [], "hello")
        nicp = virt._nic_profile("default", "vmware")
        xml_data = virt._gen_xml(
            self.mock_conn,
            "hello",
            1,
            512,
            diskp,
            nicp,
            "vmware",
            "hvm",
            "x86_64",
        )
        root = ET.fromstring(xml_data)
        controllers = root.findall(".//devices/controller")
        self.assertTrue(len(controllers) == 1)
        controller = controllers[0]
        self.assertEqual(controller.attrib["model"], "lsilogic")

    def test_controller_for_kvm(self):
        """
        Test virt._gen_xml() generated device controller for KVM
        """
        diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
        nicp = virt._nic_profile("default", "kvm")
        xml_data = virt._gen_xml(
            self.mock_conn,
            "hello",
            1,
            512,
            diskp,
            nicp,
            "kvm",
            "hvm",
            "x86_64",
        )
        root = ET.fromstring(xml_data)
        controllers = root.findall(".//devices/controller")
        # There should be no controller
        self.assertTrue(len(controllers) == 0)

    def test_diff_disks(self):
        """
        Test virt._diff_disks()
        """
        old_disks = ET.fromstring(
            """
            &lt;devices&gt;
              &lt;disk type='file' device='disk'&gt;
                &lt;source file='/path/to/img0.qcow2'/&gt;
                &lt;target dev='vda' bus='virtio'/&gt;
              &lt;/disk&gt;
              &lt;disk type='file' device='disk'&gt;
                &lt;source file='/path/to/img1.qcow2'/&gt;
                &lt;target dev='vdb' bus='virtio'/&gt;
              &lt;/disk&gt;
              &lt;disk type='file' device='disk'&gt;
                &lt;source file='/path/to/img2.qcow2'/&gt;
                &lt;target dev='hda' bus='ide'/&gt;
              &lt;/disk&gt;
              &lt;disk type='file' device='disk'&gt;
                &lt;source file='/path/to/img4.qcow2'/&gt;
                &lt;target dev='hdb' bus='ide'/&gt;
              &lt;/disk&gt;
              &lt;disk type='file' device='cdrom'&gt;
                &lt;target dev='hdc' bus='ide'/&gt;
              &lt;/disk&gt;
            &lt;/devices&gt;
        """
        ).findall("disk")

        new_disks = ET.fromstring(
            """
            &lt;devices&gt;
              &lt;disk type='file' device='disk'&gt;
                &lt;source file='/path/to/img3.qcow2'/&gt;
                &lt;target dev='vda' bus='virtio'/&gt;
              &lt;/disk&gt;
              &lt;disk type='file' device='disk' cache='default'&gt;
                &lt;source file='/path/to/img0.qcow2'/&gt;
                &lt;target dev='vda' bus='virtio'/&gt;
              &lt;/disk&gt;
              &lt;disk type='file' device='disk'&gt;
                &lt;source file='/path/to/img4.qcow2'/&gt;
                &lt;target dev='vda' bus='virtio'/&gt;
              &lt;/disk&gt;
              &lt;disk type='file' device='cdrom'&gt;
                &lt;target dev='hda' bus='ide'/&gt;
              &lt;/disk&gt;
            &lt;/devices&gt;
        """
        ).findall("disk")
        ret = virt._diff_disk_lists(old_disks, new_disks)
        self.assertEqual(
            [
                disk.find("source").get("file")
                if disk.find("source") is not None
                else None
                for disk in ret["unchanged"]
            ],
            [],
        )
        self.assertEqual(
            [
                disk.find("source").get("file")
                if disk.find("source") is not None
                else None
                for disk in ret["new"]
            ],
            ["/path/to/img3.qcow2", "/path/to/img0.qcow2", "/path/to/img4.qcow2", None],
        )
        self.assertEqual(
            [disk.find("target").get("dev") for disk in ret["sorted"]],
            ["vda", "vdb", "vdc", "hda"],
        )
        self.assertEqual(
            [
                disk.find("source").get("file")
                if disk.find("source") is not None
                else None
                for disk in ret["sorted"]
            ],
            ["/path/to/img3.qcow2", "/path/to/img0.qcow2", "/path/to/img4.qcow2", None],
        )
        self.assertEqual(ret["new"][1].find("target").get("bus"), "virtio")
        self.assertEqual(
            [
                disk.find("source").get("file")
                if disk.find("source") is not None
                else None
                for disk in ret["deleted"]
            ],
            [
                "/path/to/img0.qcow2",
                "/path/to/img1.qcow2",
                "/path/to/img2.qcow2",
                "/path/to/img4.qcow2",
                None,
            ],
        )

    def test_init(self):
        """
        Test init() function
        """
        xml = """
&lt;capabilities&gt;
  &lt;host&gt;
    &lt;uuid&gt;44454c4c-3400-105a-8033-b3c04f4b344a&lt;/uuid&gt;
    &lt;cpu&gt;
      &lt;arch&gt;x86_64&lt;/arch&gt;
      &lt;model&gt;Nehalem&lt;/model&gt;
      &lt;vendor&gt;Intel&lt;/vendor&gt;
      &lt;microcode version='25'/&gt;
      &lt;topology sockets='1' cores='4' threads='2'/&gt;
      &lt;feature name='vme'/&gt;
      &lt;feature name='ds'/&gt;
      &lt;feature name='acpi'/&gt;
      &lt;pages unit='KiB' size='4'/&gt;
      &lt;pages unit='KiB' size='2048'/&gt;
    &lt;/cpu&gt;
    &lt;power_management&gt;
      &lt;suspend_mem/&gt;
      &lt;suspend_disk/&gt;
      &lt;suspend_hybrid/&gt;
    &lt;/power_management&gt;
    &lt;migration_features&gt;
      &lt;live/&gt;
      &lt;uri_transports&gt;
        &lt;uri_transport&gt;tcp&lt;/uri_transport&gt;
        &lt;uri_transport&gt;rdma&lt;/uri_transport&gt;
      &lt;/uri_transports&gt;
    &lt;/migration_features&gt;
    &lt;topology&gt;
      &lt;cells num='1'&gt;
        &lt;cell id='0'&gt;
          &lt;memory unit='KiB'&gt;12367120&lt;/memory&gt;
          &lt;pages unit='KiB' size='4'&gt;3091780&lt;/pages&gt;
          &lt;pages unit='KiB' size='2048'&gt;0&lt;/pages&gt;
          &lt;distances&gt;
            &lt;sibling id='0' value='10'/&gt;
          &lt;/distances&gt;
          &lt;cpus num='8'&gt;
            &lt;cpu id='0' socket_id='0' core_id='0' siblings='0,4'/&gt;
            &lt;cpu id='1' socket_id='0' core_id='1' siblings='1,5'/&gt;
            &lt;cpu id='2' socket_id='0' core_id='2' siblings='2,6'/&gt;
            &lt;cpu id='3' socket_id='0' core_id='3' siblings='3,7'/&gt;
            &lt;cpu id='4' socket_id='0' core_id='0' siblings='0,4'/&gt;
            &lt;cpu id='5' socket_id='0' core_id='1' siblings='1,5'/&gt;
            &lt;cpu id='6' socket_id='0' core_id='2' siblings='2,6'/&gt;
            &lt;cpu id='7' socket_id='0' core_id='3' siblings='3,7'/&gt;
          &lt;/cpus&gt;
        &lt;/cell&gt;
      &lt;/cells&gt;
    &lt;/topology&gt;
    &lt;cache&gt;
      &lt;bank id='0' level='3' type='both' size='8' unit='MiB' cpus='0-7'/&gt;
    &lt;/cache&gt;
    &lt;secmodel&gt;
      &lt;model&gt;apparmor&lt;/model&gt;
      &lt;doi&gt;0&lt;/doi&gt;
    &lt;/secmodel&gt;
    &lt;secmodel&gt;
      &lt;model&gt;dac&lt;/model&gt;
      &lt;doi&gt;0&lt;/doi&gt;
      &lt;baselabel type='kvm'&gt;+487:+486&lt;/baselabel&gt;
      &lt;baselabel type='qemu'&gt;+487:+486&lt;/baselabel&gt;
    &lt;/secmodel&gt;
  &lt;/host&gt;

  &lt;guest&gt;
    &lt;os_type&gt;hvm&lt;/os_type&gt;
    &lt;arch name='i686'&gt;
      &lt;wordsize&gt;32&lt;/wordsize&gt;
      &lt;emulator&gt;/usr/bin/qemu-system-i386&lt;/emulator&gt;
      &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
      &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
      &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
      &lt;domain type='qemu'/&gt;
      &lt;domain type='kvm'&gt;
        &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
        &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
        &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
        &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
      &lt;/domain&gt;
    &lt;/arch&gt;
    &lt;features&gt;
      &lt;cpuselection/&gt;
      &lt;deviceboot/&gt;
      &lt;disksnapshot default='on' toggle='no'/&gt;
      &lt;acpi default='on' toggle='yes'/&gt;
      &lt;apic default='on' toggle='no'/&gt;
      &lt;pae/&gt;
      &lt;nonpae/&gt;
    &lt;/features&gt;
  &lt;/guest&gt;

  &lt;guest&gt;
    &lt;os_type&gt;hvm&lt;/os_type&gt;
    &lt;arch name='x86_64'&gt;
      &lt;wordsize&gt;64&lt;/wordsize&gt;
      &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
      &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
      &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
      &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
      &lt;domain type='qemu'/&gt;
      &lt;domain type='kvm'&gt;
        &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
        &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
        &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
        &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
      &lt;/domain&gt;
    &lt;/arch&gt;
    &lt;features&gt;
      &lt;cpuselection/&gt;
      &lt;deviceboot/&gt;
      &lt;disksnapshot default='on' toggle='no'/&gt;
      &lt;acpi default='on' toggle='yes'/&gt;
      &lt;apic default='on' toggle='no'/&gt;
    &lt;/features&gt;
  &lt;/guest&gt;

&lt;/capabilities&gt;
        """
        self.mock_conn.getCapabilities.return_value = xml  # pylint: disable=no-member

        root_dir = os.path.join(salt.syspaths.ROOT_DIR, "srv", "salt-images")

        defineMock = MagicMock(return_value=1)
        self.mock_conn.defineXML = defineMock
        mock_chmod = MagicMock()
        mock_run = MagicMock()
        with patch.dict(
            os.__dict__, {"chmod": mock_chmod, "makedirs": MagicMock()}
        ):  # pylint: disable=no-member
            with patch.dict(
                virt.__salt__, {"cmd.run": mock_run}
            ):  # pylint: disable=no-member

                # Ensure the init() function allows creating VM without NIC and disk
                virt.init(
                    "test vm", 2, 1234, nic=None, disk=None, seed=False, start=False
                )
                definition = defineMock.call_args_list[0][0][0]
                self.assertFalse("&lt;interface" in definition)
                self.assertFalse("&lt;disk" in definition)

                # Ensure the init() function allows creating VM without NIC and
                # disk but with boot parameters.

                defineMock.reset_mock()
                mock_run.reset_mock()
                boot = {
                    "kernel": "/root/f8-i386-vmlinuz",
                    "initrd": "/root/f8-i386-initrd",
                    "cmdline": "console=ttyS0 ks=http://example.com/f8-i386/os/",
                }
                retval = virt.init(
                    "test vm boot params",
                    2,
                    1234,
                    nic=None,
                    disk=None,
                    seed=False,
                    start=False,
                    boot=boot,
                )
                definition = defineMock.call_args_list[0][0][0]
                self.assertEqual("&lt;kernel" in definition, True)
                self.assertEqual("&lt;initrd" in definition, True)
                self.assertEqual("&lt;cmdline" in definition, True)
                self.assertEqual(retval, True)

                # Verify that remote paths are downloaded and the xml has been
                # modified
                mock_response = MagicMock()
                mock_response.read = MagicMock(return_value="filecontent")
                cache_dir = tempfile.mkdtemp()

                with patch.dict(virt.__dict__, {"CACHE_DIR": cache_dir}):
                    with patch(
                        "urllib.request.urlopen",
                        MagicMock(return_value=mock_response),
                    ):
                        with patch(
                            "salt.utils.files.fopen", return_value=mock_response
                        ):

                            defineMock.reset_mock()
                            mock_run.reset_mock()
                            boot = {
                                "kernel": "https://www.example.com/download/vmlinuz",
                                "initrd": "",
                                "cmdline": (
                                    "console=ttyS0 ks=http://example.com/f8-i386/os/"
                                ),
                            }

                            retval = virt.init(
                                "test remote vm boot params",
                                2,
                                1234,
                                nic=None,
                                disk=None,
                                seed=False,
                                start=False,
                                boot=boot,
                            )
                            definition = defineMock.call_args_list[0][0][0]
                            self.assertEqual(cache_dir in definition, True)

                    shutil.rmtree(cache_dir)

                # Test case creating disks
                defineMock.reset_mock()
                mock_run.reset_mock()
                pool_mock = MagicMock()
                pool_mock.XMLDesc.return_value = '&lt;pool type="dir"/&gt;'
                self.mock_conn.storagePoolLookupByName.return_value = pool_mock
                virt.init(
                    "test vm",
                    2,
                    1234,
                    nic=None,
                    disk=None,
                    disks=[
                        {"name": "system", "size": 10240},
                        {
                            "name": "cddrive",
                            "device": "cdrom",
                            "source_file": None,
                            "model": "ide",
                        },
                    ],
                    seed=False,
                    start=False,
                )
                definition = ET.fromstring(defineMock.call_args_list[0][0][0])
                expected_disk_path = os.path.join(root_dir, "test vm_system.qcow2")
                self.assertEqual(
                    expected_disk_path,
                    definition.find("./devices/disk[1]/source").get("file"),
                )
                self.assertIsNone(definition.find("./devices/disk[2]/source"))
                self.assertEqual(
                    mock_run.call_args[0][0],
                    'qemu-img create -f qcow2 "{}" 10240M'.format(expected_disk_path),
                )
                self.assertEqual(mock_chmod.call_args[0][0], expected_disk_path)

                # Test case creating disks volumes
                defineMock.reset_mock()
                mock_run.reset_mock()
                vol_mock = MagicMock()
                pool_mock.storageVolLookupByName.return_value = vol_mock
                pool_mock.listVolumes.return_value = ["test vm_data"]
                stream_mock = MagicMock()
                self.mock_conn.newStream.return_value = stream_mock
                self.mock_conn.listStoragePools.return_value = ["default", "test"]
                with patch.dict(
                    os.__dict__, {"open": MagicMock(), "close": MagicMock()}
                ):
                    cache_mock = MagicMock()
                    with patch.dict(virt.__salt__, {"cp.cache_file": cache_mock}):
                        virt.init(
                            "test vm",
                            2,
                            1234,
                            nic=None,
                            disk=None,
                            disks=[
                                {
                                    "name": "system",
                                    "size": 10240,
                                    "image": "/path/to/image",
                                    "pool": "test",
                                },
                                {"name": "data", "size": 10240, "pool": "default"},
                                {
                                    "name": "test",
                                    "size": 1024,
                                    "pool": "default",
                                    "format": "qcow2",
                                    "backing_store_path": "/backing/path",
                                    "backing_store_format": "raw",
                                },
                            ],
                            seed=False,
                            start=False,
                        )
                        definition = ET.fromstring(defineMock.call_args_list[0][0][0])
                        self.assertTrue(
                            all(
                                [
                                    disk.get("type") == "volume"
                                    for disk in definition.findall("./devices/disk")
                                ]
                            )
                        )
                        self.assertEqual(
                            ["test", "default", "default"],
                            [
                                src.get("pool")
                                for src in definition.findall("./devices/disk/source")
                            ],
                        )
                        self.assertEqual(
                            ["test vm_system", "test vm_data", "test vm_test"],
                            [
                                src.get("volume")
                                for src in definition.findall("./devices/disk/source")
                            ],
                        )
<a name="28"></a>
                        create_calls = pool_mock.createXML.call_args_list
                        vol_names = [
                            ET.fromstring(call<font color="#717d7d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>[0][0]).find("name").text
                            for call in create_calls
                        ]
                        self.assertEqual(
                            ["test vm_system", "test vm_test"],
                            vol_names,
                        )

                        stream_mock.sendAll.assert_called_once()
                        stream_mock.finish.</b></font>assert_called_once()
                        vol_mock.upload.assert_called_once_with(stream_mock, 0, 0, 0)

    def test_update_backing_store(self):
        """
        Test updating a disk with a backing store
        """
        xml = """
            &lt;domain type='kvm' id='7'&gt;
              &lt;name&gt;my_vm&lt;/name&gt;
              &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
              &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
              &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
              &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
              &lt;os&gt;
                &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
              &lt;/os&gt;
              &lt;devices&gt;
                &lt;disk type='volume' device='disk'&gt;
                  &lt;driver name='qemu' type='qcow2' cache='none' io='native'/&gt;
                  &lt;source pool='default' volume='my_vm_system' index='1'/&gt;
                  &lt;backingStore type='file' index='2'&gt;
                    &lt;format type='qcow2'/&gt;
                    &lt;source file='/path/to/base.qcow2'/&gt;
                    &lt;backingStore/&gt;
                  &lt;/backingStore&gt;
                  &lt;target dev='vda' bus='virtio'/&gt;
                  &lt;alias name='virtio-disk0'/&gt;
                  &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x04' function='0x0'/&gt;
                &lt;/disk&gt;
              &lt;/devices&gt;
            &lt;/domain&gt;
        """
        domain_mock = self.set_mock_vm("my_vm", xml)
        domain_mock.OSType.return_value = "hvm"
        self.mock_conn.defineXML.return_value = True
        updatedev_mock = MagicMock(return_value=0)
        domain_mock.updateDeviceFlags = updatedev_mock
        self.mock_conn.listStoragePools.return_value = ["default"]
        self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
            "&lt;pool type='dir'/&gt;"
        )

        ret = virt.update(
            "my_vm",
            disks=[
                {
                    "name": "system",
                    "pool": "default",
                    "backing_store_path": "/path/to/base.qcow2",
                    "backing_store_format": "qcow2",
                },
            ],
        )
        self.assertFalse(ret["definition"])
        self.assertFalse(ret["disk"]["attached"])
        self.assertFalse(ret["disk"]["detached"])

    def test_update_removables(self):
        """
        Test attaching, detaching, changing removable devices
        """
        xml = """
            &lt;domain type='kvm' id='7'&gt;
              &lt;name&gt;my_vm&lt;/name&gt;
              &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
              &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
              &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
              &lt;os&gt;
                &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
              &lt;/os&gt;
              &lt;devices&gt;
                &lt;disk type='network' device='cdrom'&gt;
                  &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
                  &lt;source protocol='https' name='/dvd-image-1.iso'&gt;
                    &lt;host name='test-srv.local' port='80'/&gt;
                  &lt;/source&gt;
                  &lt;backingStore/&gt;
                  &lt;target dev='hda' bus='ide'/&gt;
                  &lt;readonly/&gt;
                  &lt;alias name='ide0-0-0'/&gt;
                  &lt;address type='drive' controller='0' bus='0' target='0' unit='0'/&gt;
                &lt;/disk&gt;
                &lt;disk type='file' device='cdrom'&gt;
                  &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
                  &lt;target dev='hdb' bus='ide'/&gt;
                  &lt;readonly/&gt;
                  &lt;alias name='ide0-0-1'/&gt;
                  &lt;address type='drive' controller='0' bus='0' target='0' unit='1'/&gt;
                &lt;/disk&gt;
                &lt;disk type='file' device='cdrom'&gt;
                  &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
                  &lt;source file='/srv/dvd-image-2.iso'/&gt;
                  &lt;backingStore/&gt;
                  &lt;target dev='hdc' bus='ide'/&gt;
                  &lt;readonly/&gt;
                  &lt;alias name='ide0-0-2'/&gt;
                  &lt;address type='drive' controller='0' bus='0' target='0' unit='2'/&gt;
                &lt;/disk&gt;
                &lt;disk type='file' device='cdrom'&gt;
                  &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
                  &lt;source file='/srv/dvd-image-3.iso'/&gt;
                  &lt;backingStore/&gt;
                  &lt;target dev='hdd' bus='ide'/&gt;
                  &lt;readonly/&gt;
                  &lt;alias name='ide0-0-3'/&gt;
                  &lt;address type='drive' controller='0' bus='0' target='0' unit='3'/&gt;
                &lt;/disk&gt;
                &lt;disk type='network' device='cdrom'&gt;
                  &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
                  &lt;source protocol='https' name='/dvd-image-6.iso'&gt;
                    &lt;host name='test-srv.local' port='80'/&gt;
                  &lt;/source&gt;
                  &lt;backingStore/&gt;
                  &lt;target dev='hde' bus='ide'/&gt;
                  &lt;readonly/&gt;
                &lt;/disk&gt;
              &lt;/devices&gt;
            &lt;/domain&gt;
        """
        domain_mock = self.set_mock_vm("my_vm", xml)
        domain_mock.OSType.return_value = "hvm"
        self.mock_conn.defineXML.return_value = True
        updatedev_mock = MagicMock(return_value=0)
        domain_mock.updateDeviceFlags = updatedev_mock

<a name="27"></a>        ret = virt.update(
            "my_vm",
            disks=[
                <font color="#e77471"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
                    "name": "dvd1",
                    "device": "cdrom",
                    "source_file": None,
                    "model": "ide",
                },
                {
                    "name": "dvd2",
                    "device": "cdrom",
                    "source_file": "/srv/dvd-image-4.iso",
                    "model": "ide",
                },
                {
                    "name": "dvd3",
                    "device": "cdrom",
                    "source_file": "/srv/dvd-image-2.iso",
                    "model": "ide",
                },
                {
                    "name": "dvd4",
                    "device": "cdrom",
                    "source_file": "/srv/dvd-image-5.iso",
                    "model": "ide",
                },
                {
                    "name": "dvd5",
                    "device": "cdrom",
                    "source_file": "/srv/dvd-image-6.iso",
                    "model": "ide",
                },
            ],
        )
<a name="1"></a>
        self.assertTrue(ret["definition"])
        self.assertFalse(ret["disk"].</b></font>get("attached"))
        self<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertFalse(ret["disk"].get("detached"))
        self.assertEqual(
            [
                {
                    "type": "file",
                    "device": "cdrom",
                    "driver": {
                        "name": "qemu",
                        "type": "raw",
                        "cache": "none",
                        "io": "native",
                    },
                    "backingStore": None,
                    "target": {"dev": "hda", "bus": "ide"},
                    "readonly": None,
                    "alias": {"name": "ide0-0-0"},
                    "address": {
                        "type": "drive",
                        "controller": "0",
                        "bus": "0",
                        "target": "0",
                        "unit": "0",
                    },
                },
                {
                    "type": "file",
                    "device": "cdrom",
                    "driver": {
                        "name": "qemu",
                        "type": "raw",
                        "cache": "none",
                        "io": "native",
                    },
                    "target": {"dev": "hdb", "bus": "ide"},
                    "readonly": None,
                    "alias": {"name": "ide0-0-1"},
                    "address": {
                        "type": "drive",
                        "controller": "0",
                        "bus": "0",
                        "target": "0",
                        "unit": "1",
                    },
                    "source": {"file": "/srv/dvd-image-4.iso"},
                },
                {
                    "type": "file",
                    "device": "cdrom",
                    "driver": {
                        "name": "qemu",
                        "type": "raw",
                        "cache": "none",
                        "io": "native",
                    },
                    "backingStore": None,
                    "target": {"dev": "hdd", "bus": "ide"},
                    "readonly": None,
                    "alias": {"name": "ide0-0-3"},
                    "address": {
                        "type": "drive",
                        "controller": "0",
                        "bus": "0",
                        "target": "0",
                        "unit": "3",
                    },
                    "source": {"file": "/srv/dvd-image-5.iso"},
                },
                {
                    "type": "file",
                    "device": "cdrom",
                    "driver": {
                        "name": "qemu",
                        "type": "raw",
                        "cache": "none",
                        "io": "native",
                    },
                    "backingStore": None,
                    "target": {"dev": "hde", "bus": "ide"},
                    "readonly": None,
                    "source": {"file": "/srv/dvd-image-6.iso"},
                },
            ],
            [
                salt.utils.</b></font>xmlutil.to_dict(ET.fromstring(disk), True)
                for disk in ret["disk"]["updated"]
            ],
        )

    def test_update_xen_boot_params(self):
        """
        Test virt.update() a Xen definition no boot parameter.
        """
        root_dir = os.path.join(salt.syspaths.ROOT_DIR, "srv", "salt-images")
        xml_boot = """
            &lt;domain type='xen' id='8'&gt;
              &lt;name&gt;vm&lt;/name&gt;
              &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
              &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
              &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
              &lt;os&gt;
                &lt;type arch='x86_64' machine='xenfv'&gt;hvm&lt;/type&gt;
                &lt;loader type='rom'&gt;/usr/lib/xen/boot/hvmloader&lt;/loader&gt;
              &lt;/os&gt;
            &lt;/domain&gt;
        """
        domain_mock_boot = self.set_mock_vm("vm", xml_boot)
        domain_mock_boot.OSType = MagicMock(return_value="hvm")
        define_mock_boot = MagicMock(return_value=True)
        define_mock_boot.setVcpusFlags = MagicMock(return_value=0)
        self.mock_conn.defineXML = define_mock_boot
        self.assertEqual(
            {
                "cpu": False,
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm", cpu=2),
        )
        setxml = ET.fromstring(define_mock_boot.call_args[0][0])
        self.assertEqual(setxml.find("os").find("loader").attrib.get("type"), "rom")
        self.assertEqual(
            setxml.find("os").find("loader").text, "/usr/lib/xen/boot/hvmloader"
        )

    def test_update_existing_boot_params(self):
        """
        Test virt.update() with existing boot parameters.
        """
        xml_boot = """
            &lt;domain type='kvm' id='8'&gt;
              &lt;name&gt;vm_with_boot_param&lt;/name&gt;
              &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
              &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
              &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
              &lt;os&gt;
                &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
                &lt;kernel&gt;/boot/oldkernel&lt;/kernel&gt;
                &lt;initrd&gt;/boot/initrdold.img&lt;/initrd&gt;
                &lt;cmdline&gt;console=ttyS0 ks=http://example.com/old/os/&lt;/cmdline&gt;
                &lt;loader&gt;/usr/share/old/OVMF_CODE.fd&lt;/loader&gt;
                &lt;nvram&gt;/usr/share/old/OVMF_VARS.ms.fd&lt;/nvram&gt;
              &lt;/os&gt;
            &lt;/domain&gt;
        """
        domain_mock_boot = self.set_mock_vm("vm_with_boot_param", xml_boot)
        domain_mock_boot.OSType = MagicMock(return_value="hvm")
        define_mock_boot = MagicMock(return_value=True)
        self.mock_conn.defineXML = define_mock_boot
        boot_new = {
            "kernel": "/root/new-vmlinuz",
            "initrd": "/root/new-initrd",
            "cmdline": "console=ttyS0 ks=http://example.com/new/os/",
        }

        uefi_boot_new = {
            "loader": "/usr/share/new/OVMF_CODE.fd",
            "nvram": "/usr/share/new/OVMF_VARS.ms.fd",
        }

        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm_with_boot_param", boot=boot_new),
        )
        setxml_boot = ET.fromstring(define_mock_boot.call_args[0][0])
        self.assertEqual(
            setxml_boot.find("os").find("kernel").text, "/root/new-vmlinuz"
        )
        self.assertEqual(setxml_boot.find("os").find("initrd").text, "/root/new-initrd")
        self.assertEqual(
            setxml_boot.find("os").find("cmdline").text,
            "console=ttyS0 ks=http://example.com/new/os/",
        )

        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm_with_boot_param", boot=uefi_boot_new),
        )

        setxml = ET.fromstring(define_mock_boot.call_args[0][0])
        self.assertEqual(
            setxml.find("os").find("loader").text, "/usr/share/new/OVMF_CODE.fd"
        )
        self.assertEqual(setxml.find("os").find("loader").attrib.get("readonly"), "yes")
        self.assertEqual(setxml.find("os").find("loader").attrib["type"], "pflash")
        self.assertEqual(
            setxml.find("os").find("nvram").attrib["template"],
            "/usr/share/new/OVMF_VARS.ms.fd",
        )

        kernel_none = {
            "kernel": None,
            "initrd": None,
            "cmdline": None,
        }

        uefi_none = {"loader": None, "nvram": None}

        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm_with_boot_param", boot=kernel_none),
        )

        setxml = ET.fromstring(define_mock_boot.call_args[0][0])
        self.assertEqual(setxml.find("os").find("kernel"), None)
        self.assertEqual(setxml.find("os").find("initrd"), None)
        self.assertEqual(setxml.find("os").find("cmdline"), None)

        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm_with_boot_param", boot={"efi": False}),
        )
        setxml = ET.fromstring(define_mock_boot.call_args[0][0])
        self.assertEqual(setxml.find("os").find("nvram"), None)
        self.assertEqual(setxml.find("os").find("loader"), None)

        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm_with_boot_param", boot=uefi_none),
        )

        setxml = ET.fromstring(define_mock_boot.call_args[0][0])
        self.assertEqual(setxml.find("os").find("loader"), None)
        self.assertEqual(setxml.find("os").find("nvram"), None)

    def test_update_existing_numatune_params(self):
        """
        Test virt.update() with existing numatune parameters.
        """
        xml_numatune = """
            &lt;domain type='kvm' id='8'&gt;
              &lt;name&gt;vm_with_numatune_param&lt;/name&gt;
              &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
              &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
              &lt;maxMemory slots="12" unit="bytes"&gt;1048576&lt;/maxMemory&gt;
              &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
              &lt;numatune&gt;
                &lt;memory mode="strict" nodeset="0-11"/&gt;
                &lt;memnode cellid="1" mode="strict" nodeset="3"/&gt;
                &lt;memnode cellid="3" mode="preferred" nodeset="7"/&gt;
              &lt;/numatune&gt;
              &lt;os&gt;
                &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
              &lt;/os&gt;
              &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
            &lt;/domain&gt;
        """
        domain_mock = self.set_mock_vm("vm_with_numatune_param", xml_numatune)
        domain_mock.OSType = MagicMock(return_value="hvm")
        define_mock = MagicMock(return_value=True)
        self.mock_conn.defineXML = define_mock
<a name="26"></a>
        # test update existing numatune node
        numatune = {
            <font color="#68818b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"memory": {"mode": "preferred", "nodeset": "0-5"},
            "memnodes": {
                0: {"mode": "strict", "nodeset": "4"},
                3: {"mode": "preferred", "nodeset": "7"},
                4: {"mode": "strict", "nodeset": "6"},
            },
        }

        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update(</b></font>"vm_with_numatune_param", numatune=numatune),
        )

        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(
            setxml.find("numatune").find("memory").attrib.get("mode"), "preferred"
        )

        self.assertEqual(
            setxml.find("numatune").find("memory").attrib.get("nodeset"),
            ",".join([str(i) for i in range(0, 6)]),
        )

        self.assertEqual(
            setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("mode"), "strict"
        )

        self.assertEqual(
            setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("nodeset"), "4"
        )

        self.assertEqual(setxml.find("./numatune/memnode/[@cellid='1']"), None)

        self.assertEqual(
            setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("mode"),
            "preferred",
        )

        self.assertEqual(
            setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("nodeset"), "7"
        )

        self.assertEqual(
            setxml.find("./numatune/memnode/[@cellid='4']").attrib.get("mode"), "strict"
        )

        self.assertEqual(
            setxml.find("./numatune/memnode/[@cellid='4']").attrib.get("nodeset"), "6"
        )

        self.assertEqual(setxml.find("./numatune/memnode/[@cellid='2']"), None)

        numatune_mem_none = {
            "memory": None,
            "memnodes": {
                0: {"mode": "strict", "nodeset": "4"},
                3: {"mode": "preferred", "nodeset": "7"},
                4: {"mode": "strict", "nodeset": "6"},
            },
        }

        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm_with_numatune_param", numatune=numatune_mem_none),
        )

        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find("numatune").find("memory"), None)

        self.assertEqual(
            setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("mode"), "strict"
        )

        self.assertEqual(
            setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("nodeset"), "4"
        )

        self.assertEqual(
            setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("mode"),
            "preferred",
        )

        self.assertEqual(
            setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("nodeset"), "7"
        )

        self.assertEqual(setxml.find("./numatune/memnode/[@cellid='2']"), None)

        numatune_mnodes_none = {
            "memory": {"mode": "preferred", "nodeset": "0-5"},
            "memnodes": None,
        }

        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm_with_numatune_param", numatune=numatune_mnodes_none),
        )

        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(
            setxml.find("numatune").find("memory").attrib.get("mode"), "preferred"
        )

        self.assertEqual(
            setxml.find("numatune").find("memory").attrib.get("nodeset"),
            ",".join([str(i) for i in range(0, 6)]),
        )

        self.assertEqual(setxml.find("./numatune/memnode"), None)

        numatune_without_change = {
            "memory": {"mode": "strict", "nodeset": "0-5,6,7-11"},
            "memnodes": {
                1: {"mode": "strict", "nodeset": "3"},
                3: {"mode": "preferred", "nodeset": "7"},
            },
        }

        self.assertEqual(
            {
                "definition": False,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm_with_numatune_param", numatune=numatune_without_change),
        )

        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update(
                "vm_with_numatune_param", numatune={"memory": None, "memnodes": None}
            ),
        )

        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find("numatune"), None)

    def test_update_existing_cpu_params(self):
        """
        Test virt.update() with existing cpu-related parameters.
        """
        xml_with_existing_params = """
            &lt;domain type='kvm' id='8'&gt;
              &lt;name&gt;vm_with_boot_param&lt;/name&gt;
              &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
              &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
              &lt;vcpu placement="static" cpuset="0-11" current="3"&gt;6&lt;/vcpu&gt;
              &lt;vcpus&gt;
                &lt;vcpu id="0" enabled="yes" hotpluggable="no" order="1"/&gt;
                &lt;vcpu id="1" enabled="no" hotpluggable="yes"/&gt;
                &lt;vcpu id="2" enabled="no" hotpluggable="yes"/&gt;
                &lt;vcpu id="3" enabled="no" hotpluggable="yes"/&gt;
                &lt;vcpu id="4" enabled="no" hotpluggable="yes"/&gt;
                &lt;vcpu id="5" enabled="no" hotpluggable="yes"/&gt;
                &lt;vcpu id="6" enabled="no" hotpluggable="yes"/&gt;
                &lt;vcpu id="7" enabled="no" hotpluggable="yes"/&gt;
                &lt;vcpu id="8" enabled="no" hotpluggable="yes"/&gt;
                &lt;vcpu id="9" enabled="no" hotpluggable="yes"/&gt;
                &lt;vcpu id="10" enabled="no" hotpluggable="yes"/&gt;
                &lt;vcpu id="11" enabled="no" hotpluggable="yes"/&gt;
              &lt;/vcpus&gt;
              &lt;cpu mode="custom" match="exact" check="full"&gt;
                 &lt;model fallback="allow" vendor_id="Genuine20201"&gt;core2duo&lt;/model&gt;
                 &lt;vendor&gt;Intel&lt;/vendor&gt;
                 &lt;topology sockets="2" cores="5" threads="2"/&gt;
                 &lt;cache level="3" mode="emulate"/&gt;
                 &lt;feature policy="optional" name="lahf_lm"/&gt;
                 &lt;feature policy="require" name="pcid"/&gt;
                 &lt;numa&gt;
                    &lt;cell id="0" cpus="0-3" memory="1073741824" unit="KiB" discard="no"&gt;
                        &lt;distances&gt;
                            &lt;sibling id="0" value="10"/&gt;
                            &lt;sibling id="1" value="21"/&gt;
                            &lt;sibling id="2" value="31"/&gt;
                            &lt;sibling id="3" value="41"/&gt;
                        &lt;/distances&gt;
                    &lt;/cell&gt;
                    &lt;cell id="1" cpus="4-6" memory="1073741824" unit="KiB" memAccess="private"&gt;
                        &lt;distances&gt;
                            &lt;sibling id="0" value="21"/&gt;
                            &lt;sibling id="1" value="10"/&gt;
                            &lt;sibling id="2" value="21"/&gt;
                            &lt;sibling id="3" value="31"/&gt;
                        &lt;/distances&gt;
                    &lt;/cell&gt;
                 &lt;/numa&gt;
              &lt;/cpu&gt;
              &lt;os&gt;
                &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
              &lt;/os&gt;
              &lt;/domain&gt;
         """
        domain_mock = self.set_mock_vm(
            "vm_with_existing_param", xml_with_existing_params
        )
        domain_mock.OSType = MagicMock(return_value="hvm")
        define_mock = MagicMock(return_value=True)
        self.mock_conn.defineXML = define_mock

        # test update vcpu with existing attributes case
        setvcpus_mock = MagicMock(return_value=0)
        domain_mock.setVcpusFlags = setvcpus_mock

        cpu_attr = {"placement": "static", "cpuset": "0-5", "current": 3, "maximum": 5}
        self.assertEqual(
            {
                "definition": True,
                "cpu": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm_with_existing_param", cpu=cpu_attr),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find("vcpu").text, "5")
        self.assertEqual(setxml.find("vcpu").attrib["placement"], "static")
        self.assertEqual(
            setxml.find("vcpu").attrib["cpuset"],
            ",".join([str(i) for i in range(0, 6)]),
        )
        self.assertEqual(setxml.find("vcpu").attrib["current"], "3")

        # test removing vcpu attribute
        cpu_none = {"placement": "auto", "cpuset": None, "current": 2, "maximum": 5}
        self.assertEqual(
            {
                "definition": True,
                "cpu": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm_with_existing_param", cpu=cpu_none),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find("vcpu").text, "5")
        self.assertEqual(setxml.find("vcpu").attrib["placement"], "auto")
        self.assertEqual(setxml.find("vcpu").attrib.get("cpuset"), None)
        self.assertEqual(setxml.find("vcpu").attrib.get("current"), "2")

        # test update individual vcpu with exisiting attributes
        vcpus = {
            "vcpus": {
                "0": {"enabled": False, "hotpluggable": True, "order": 5},
                "3": {"enabled": True, "hotpluggable": False, "order": 3},
                "7": {"enabled": True, "hotpluggable": False},
            }
        }
        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm_with_existing_param", cpu=vcpus),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']").attrib["id"], "0")
        self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']").attrib["enabled"], "no")
        self.assertEqual(
            setxml.find("./vcpus/vcpu/[@id='0']").attrib["hotpluggable"], "yes"
        )
        self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']").attrib["order"], "5")
        self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["id"], "3")
        self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["enabled"], "yes")
        self.assertEqual(
            setxml.find("./vcpus/vcpu/[@id='3']").attrib["hotpluggable"], "no"
        )
        self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["order"], "3")
        self.assertEqual(setxml.find("./vcpus/vcpu/[@id='7']").attrib["id"], "7")
        self.assertEqual(setxml.find("./vcpus/vcpu/[@id='7']").attrib["enabled"], "yes")
        self.assertEqual(
            setxml.find("./vcpus/vcpu/[@id='7']").attrib["hotpluggable"], "no"
        )
        self.assertEqual(
            setxml.find("./vcpus/vcpu/[@id='7']").attrib.get("order"), None
        )

        # test removing vcpu element
        ind_vcpu = {
            "vcpus": {"3": {"enabled": True, "hotpluggable": False, "order": None}}
        }
        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm_with_existing_param", cpu=ind_vcpu),
        )

        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']"), None)
        self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["enabled"], "yes")
        self.assertEqual(
            setxml.find("./vcpus/vcpu/[@id='3']").attrib["hotpluggable"], "no"
        )
        self.assertEqual(
            setxml.find("./vcpus/vcpu/[@id='3']").attrib.get("order"), None
        )

        # test removing vcpus element
        vcpus_none = {"vcpus": None}
        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm_with_existing_param", cpu=vcpus_none),
        )

        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find("vcpus"), None)

        # test removing cpu attrbutes
        cpu_atr_none = {"match": None, "mode": None, "check": None}
        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm_with_existing_param", cpu=cpu_atr_none),
        )

        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find("cpu").attrib, {})

        cpu_atr_mn = {"match": None}
        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm_with_existing_param", cpu=cpu_atr_mn),
        )

        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find("cpu").attrib.get("match"), None)
        self.assertEqual(setxml.find("cpu").attrib.get("mode"), "custom")
        self.assertEqual(setxml.find("cpu").attrib.get("check"), "full")

        # test update existing cpu model
        cpu_model_none = {"model": None}
        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm_with_existing_param", cpu=cpu_model_none),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find("cpu").find("model"), None)

        cpu_model_atr_none = {
            "model": {"name": "coresolo", "fallback": "forbid", "vendor_id": None}
        }
        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm_with_existing_param", cpu=cpu_model_atr_none),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find("cpu").find("model").attrib.get("vendor_id"), None)
        self.assertEqual(
            setxml.find("cpu").find("model").attrib.get("fallback"), "forbid"
        )
        self.assertEqual(setxml.find("cpu").find("model").text, "coresolo")

        cpu_model_atr = {
            "model": {
                "name": "coresolo",
                "fallback": "forbid",
                "vendor_id": "AuthenticAMD",
            }
        }
        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm_with_existing_param", cpu=cpu_model_atr),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(
            setxml.find("cpu").find("model").attrib.get("fallback"), "forbid"
        )
        self.assertEqual(
            setxml.find("cpu").find("model").attrib.get("vendor_id"), "AuthenticAMD"
        )
        self.assertEqual(setxml.find("cpu").find("model").text, "coresolo")

        # test update existing cpu vendor
        cpu_vendor = {"vendor": "AMD"}
        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm_with_existing_param", cpu=cpu_vendor),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find("cpu").find("vendor").text, "AMD")

        cpu_vendor_none = {"vendor": None}
        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm_with_existing_param", cpu=cpu_vendor_none),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find("cpu").find("vendor"), None)

        # test update exisiting cpu topology
        cpu_topology = {"topology": {"sockets": 1, "cores": 12, "threads": 1}}
        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm_with_existing_param", cpu=cpu_topology),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find("cpu").find("topology").attrib.get("sockets"), "1")
        self.assertEqual(setxml.find("cpu").find("topology").attrib.get("cores"), "12")
        self.assertEqual(setxml.find("cpu").find("topology").attrib.get("threads"), "1")

        cpu_topology_atr_none = {
            "topology": {"sockets": None, "cores": 12, "threads": 1}
        }
        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm_with_existing_param", cpu=cpu_topology_atr_none),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(
            setxml.find("cpu").find("topology").attrib.get("sockets"), None
        )
        self.assertEqual(setxml.find("cpu").find("topology").attrib.get("cores"), "12")
        self.assertEqual(setxml.find("cpu").find("topology").attrib.get("threads"), "1")

        cpu_topology_none = {"topology": None}
        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm_with_existing_param", cpu=cpu_topology_none),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find("cpu").find("topology"), None)

        # test update existing cache
        cpu_cache = {"cache": {"mode": "passthrough", "level": 2}}
        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm_with_existing_param", cpu=cpu_cache),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find("cpu").find("cache").attrib.get("level"), "2")
        self.assertEqual(
            setxml.find("cpu").find("cache").attrib.get("mode"), "passthrough"
        )

        cpu_cache_atr_none = {"cache": {"mode": "passthrough", "level": None}}
        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm_with_existing_param", cpu=cpu_cache_atr_none),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find("cpu").find("cache").attrib.get("level"), None)
        self.assertEqual(
            setxml.find("cpu").find("cache").attrib.get("mode"), "passthrough"
        )

        cpu_cache_none = {"cache": None}
        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm_with_existing_param", cpu=cpu_cache_none),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find("cpu").find("cache"), None)

        # test update existing feature
        cpu_feature = {"features": {"lahf_lm": "require", "pcid": "optional"}}
        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm_with_existing_param", cpu=cpu_feature),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(
            setxml.find("./cpu/feature[@name='pcid']").attrib.get("policy"), "optional"
        )
        self.assertEqual(
            setxml.find("./cpu/feature[@name='lahf_lm']").attrib.get("policy"),
            "require",
        )

        cpu_feature_atr_none = {"features": {"pcid": "optional", "lahf_lm": "disable"}}
        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm_with_existing_param", cpu=cpu_feature_atr_none),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(
            setxml.find("./cpu/feature[@name='lahf_lm']").attrib.get("policy"),
            "disable",
        )
        self.assertEqual(
            setxml.find("./cpu/feature[@name='pcid']").attrib.get("policy"), "optional"
        )

        cpu_feature_none = {"features": {"lahf_lm": None, "pcid": None}}
        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm_with_existing_param", cpu=cpu_feature_none),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find("./cpu/feature"), None)
<a name="23"></a>
        # test update existing numa cell
        numa_cell = {
            <font color="#f660ab"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"numa": {
                0: {
                    "cpus": "0-6",
                    "memory": "512m",
                    "discard": True,
                    "distances": {0: 15, 1: 16, 2: 17, 3: 18},
                },
                1: {
                    "cpus": "7-12",
                    "memory": "2g",
                    "discard": True,
                    "memAccess": "shared",
                    "distances": {0: 23, 1: 24, 2: 25, 3: 26},
                },
            }
        }
        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update(</b></font>"vm_with_existing_param", cpu=numa_cell),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='0']").attrib["cpus"],
            ",".join([str(i) for i in range(0, 7)]),
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='0']").attrib["memory"],
            str(512 * 1024 ** 2),
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='0']").get("unit"),
            "bytes",
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='0']").attrib["discard"], "yes"
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='0']").attrib[
                "value"
            ],
            "15",
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='1']").attrib[
                "value"
            ],
            "16",
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='2']").attrib[
                "value"
            ],
            "17",
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='3']").attrib[
                "value"
            ],
            "18",
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='1']").attrib["cpus"],
            ",".join([str(i) for i in range(7, 13)]),
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='1']").attrib["memory"],
            str(int(2 * 1024 ** 3)),
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='1']").get("unit"),
            "bytes",
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='1']").attrib["discard"], "yes"
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='1']").attrib["memAccess"], "shared"
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='0']").attrib[
                "value"
            ],
            "23",
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='1']").attrib[
                "value"
            ],
            "24",
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='2']").attrib[
                "value"
            ],
            "25",
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='3']").attrib[
                "value"
            ],
            "26",
<a name="34"></a>        )

        numa_cell_atr_none = {
            <font color="#827d6b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"numa": {
                "0": {
                    "cpus": "0-6",
                    "memory": "512m",
                    "discard": False,
                    "distances": {0: 15, 2: 17, 3: 18},
                },
                "1": {
                    "cpus": "7-12",
                    "memory": "2g",
                    "discard": True,
                    "distances": {0: 23, 1: 24, 2: 25},
                },
            }
        }
        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.</b></font>update("vm_with_existing_param", cpu=numa_cell_atr_none),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='0']").attrib["cpus"],
            ",".join([str(i) for i in range(0, 7)]),
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='0']").attrib["memory"],
            str(512 * 1024 ** 2),
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='0']").get("unit"),
            "bytes",
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='0']").attrib.get("discard"), "no"
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='0']").attrib[
                "value"
            ],
            "15",
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='1']"), None
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='2']").attrib[
                "value"
            ],
            "17",
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='3']").attrib[
                "value"
            ],
            "18",
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='1']").attrib["cpus"],
            ",".join([str(i) for i in range(7, 13)]),
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='1']").attrib["memory"],
            str(int(2 * 1024 ** 3)),
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='1']").attrib["discard"], "yes"
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='0']").attrib[
                "value"
            ],
            "23",
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='1']").attrib[
                "value"
            ],
            "24",
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='2']").attrib[
                "value"
            ],
            "25",
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='3']"), None
        )

        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='1']").attrib["cpus"],
            ",".join([str(i) for i in range(7, 13)]),
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='1']").attrib["memory"],
            str(int(1024 ** 3 * 2)),
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='1']").attrib["discard"], "yes"
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='0']").attrib[
                "value"
            ],
            "23",
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='1']").attrib[
                "value"
            ],
            "24",
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='2']").attrib[
                "value"
            ],
            "25",
        )
        self.assertEqual(
            setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='3']"),
            None,
        )

    def test_update_memtune_params(self):
        """
        Test virt.update() with memory tuning parameters.
        """
        xml_with_memtune_params = """
            &lt;domain type='kvm' id='8'&gt;
              &lt;name&gt;vm_with_boot_param&lt;/name&gt;
              &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
              &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
              &lt;maxMemory slots="12" unit="bytes"&gt;1048576&lt;/maxMemory&gt;
              &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
              &lt;memtune&gt;
                &lt;hard_limit unit="KiB"&gt;1048576&lt;/hard_limit&gt;
                &lt;soft_limit unit="KiB"&gt;2097152&lt;/soft_limit&gt;
                &lt;swap_hard_limit unit="KiB"&gt;2621440&lt;/swap_hard_limit&gt;
                &lt;min_guarantee unit='KiB'&gt;671088&lt;/min_guarantee&gt;
              &lt;/memtune&gt;
              &lt;os&gt;
                &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
              &lt;/os&gt;
            &lt;/domain&gt;
        """
        domain_mock = self.set_mock_vm("vm_with_memtune_param", xml_with_memtune_params)
        domain_mock.OSType = MagicMock(return_value="hvm")
        define_mock = MagicMock(return_value=True)
        self.mock_conn.defineXML = define_mock

        memtune_new_val = {
            "boot": "0.7g",
            "current": "2.5g",
            "max": "3096m",
            "slots": "10",
            "soft_limit": "2048m",
            "hard_limit": "1024",
            "swap_hard_limit": "2.5g",
            "min_guarantee": "1 g",
        }

        domain_mock.setMemoryFlags.return_value = 0
        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
                "mem": True,
            },
            virt.update("vm_with_memtune_param", mem=memtune_new_val),
        )
        self.assertEqual(
            domain_mock.setMemoryFlags.call_args[0][0], int(2.5 * 1024 ** 2)
        )

        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(
            setxml.find("memtune").find("soft_limit").text, str(2048 * 1024)
        )
        self.assertEqual(
            setxml.find("memtune").find("hard_limit").text, str(1024 * 1024)
        )
        self.assertEqual(
            setxml.find("memtune").find("swap_hard_limit").text,
            str(int(2.5 * 1024 ** 2)),
        )
        self.assertEqual(
            setxml.find("memtune").find("swap_hard_limit").get("unit"),
            "KiB",
        )
        self.assertEqual(
            setxml.find("memtune").find("min_guarantee").text, str(1 * 1024 ** 3)
        )
        self.assertEqual(
            setxml.find("memtune").find("min_guarantee").attrib.get("unit"), "bytes"
        )
        self.assertEqual(setxml.find("maxMemory").text, str(3096 * 1024 ** 2))
        self.assertEqual(setxml.find("maxMemory").attrib.get("slots"), "10")
        self.assertEqual(setxml.find("currentMemory").text, str(int(2.5 * 1024 ** 3)))
        self.assertEqual(setxml.find("memory").text, str(int(0.7 * 1024 ** 3)))

        max_slot_reverse = {
            "slots": "10",
            "max": "3096m",
        }
        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm_with_memtune_param", mem=max_slot_reverse),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find("maxMemory").text, str(3096 * 1024 ** 2))
        self.assertEqual(setxml.find("maxMemory").get("unit"), "bytes")
        self.assertEqual(setxml.find("maxMemory").attrib.get("slots"), "10")

        max_swap_none = {
            "boot": "0.7g",
            "current": "2.5g",
            "max": None,
            "slots": "10",
            "soft_limit": "2048m",
            "hard_limit": "1024",
            "swap_hard_limit": None,
            "min_guarantee": "1 g",
        }

        domain_mock.setMemoryFlags.reset_mock()
        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
                "mem": True,
            },
            virt.update("vm_with_memtune_param", mem=max_swap_none),
        )
        self.assertEqual(
            domain_mock.setMemoryFlags.call_args[0][0], int(2.5 * 1024 ** 2)
        )

        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(
            setxml.find("memtune").find("soft_limit").text, str(2048 * 1024)
        )
        self.assertEqual(
            setxml.find("memtune").find("hard_limit").text, str(1024 * 1024)
        )
        self.assertEqual(setxml.find("memtune").find("swap_hard_limit"), None)
        self.assertEqual(
            setxml.find("memtune").find("min_guarantee").text, str(1 * 1024 ** 3)
        )
        self.assertEqual(
            setxml.find("memtune").find("min_guarantee").attrib.get("unit"), "bytes"
        )
        self.assertEqual(setxml.find("maxMemory").text, None)
        self.assertEqual(setxml.find("currentMemory").text, str(int(2.5 * 1024 ** 3)))
        self.assertEqual(setxml.find("memory").text, str(int(0.7 * 1024 ** 3)))

        memtune_none = {
            "soft_limit": None,
            "hard_limit": None,
            "swap_hard_limit": None,
            "min_guarantee": None,
        }

        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm_with_memtune_param", mem=memtune_none),
        )

        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find("memtune").find("soft_limit"), None)
        self.assertEqual(setxml.find("memtune").find("hard_limit"), None)
        self.assertEqual(setxml.find("memtune").find("swap_hard_limit"), None)
        self.assertEqual(setxml.find("memtune").find("min_guarantee"), None)

        max_none = {
            "max": None,
        }

        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm_with_memtune_param", mem=max_none),
        )

        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find("maxMemory"), None)
        self.assertEqual(setxml.find("currentMemory").text, str(int(1 * 1024 ** 2)))
        self.assertEqual(setxml.find("memory").text, str(int(1 * 1024 ** 2)))

    def test_update_exist_memorybacking_params(self):
        """
        Test virt.update() with memory backing parameters.
        """
        xml_with_memback_params = """
            &lt;domain type='kvm' id='8'&gt;
              &lt;name&gt;vm_with_memback_param&lt;/name&gt;
              &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
              &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
              &lt;maxMemory slots="12" unit="KiB"&gt;1048576&lt;/maxMemory&gt;
              &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
              &lt;memoryBacking&gt;
                &lt;hugepages&gt;
                  &lt;page size="2048" unit="KiB"/&gt;
                  &lt;page size="3145728" nodeset="1-4,^3" unit="KiB"/&gt;
                  &lt;page size="1048576" nodeset="3" unit="KiB"/&gt;
                &lt;/hugepages&gt;
                &lt;nosharepages/&gt;
                &lt;locked/&gt;
                &lt;source type="file"/&gt;
                &lt;access mode="shared"/&gt;
                &lt;discard/&gt;
              &lt;/memoryBacking&gt;
              &lt;os&gt;
                &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
              &lt;/os&gt;
              &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
            &lt;/domain&gt;
        """
        domain_mock = self.set_mock_vm("vm_with_memback_param", xml_with_memback_params)
        domain_mock.OSType = MagicMock(return_value="hvm")
        define_mock = MagicMock(return_value=True)
        self.mock_conn.defineXML = define_mock

        # update memory backing case
        mem_back_param = {
            "hugepages": [
                {"nodeset": "1-4,^3", "size": "1g"},
                {"nodeset": "3", "size": "2g"},
            ],
            "nosharepages": None,
            "locked": None,
            "source": "anonymous",
            "access": "private",
            "allocation": "ondemand",
            "discard": None,
        }

        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm_with_memback_param", mem=mem_back_param),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertDictEqual(
            {
                p.get("nodeset"): {"size": p.get("size"), "unit": p.get("unit")}
                for p in setxml.findall("memoryBacking/hugepages/page")
            },
            {
                "1,2,4": {"size": str(1024 ** 3), "unit": "bytes"},
                "3": {"size": str(2 * 1024 ** 3), "unit": "bytes"},
            },
        )
        self.assertEqual(setxml.find("./memoryBacking/nosharepages"), None)
        self.assertEqual(setxml.find("./memoryBacking/locked"), None)
        self.assertEqual(
            setxml.find("./memoryBacking/source").attrib["type"], "anonymous"
        )
        self.assertEqual(
            setxml.find("./memoryBacking/access").attrib["mode"], "private"
        )
        self.assertEqual(
            setxml.find("./memoryBacking/allocation").attrib["mode"], "ondemand"
        )
        self.assertEqual(setxml.find("./memoryBacking/discard"), None)

        unchanged_page = {
            "hugepages": [
                {"size": "2m"},
                {"nodeset": "1-4,^3", "size": "3g"},
                {"nodeset": "3", "size": "1g"},
            ],
        }

        self.assertEqual(
            {
                "definition": False,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("vm_with_memback_param", mem=unchanged_page),
        )

    def test_update_iothreads_params(self):
        """
        Test virt.update() with iothreads parameters.
        """
        xml_with_iothreads_params = """
            &lt;domain type='kvm' id='8'&gt;
              &lt;name&gt;xml_with_iothreads_params&lt;/name&gt;
              &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
              &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
              &lt;maxMemory slots="12" unit="KiB"&gt;1048576&lt;/maxMemory&gt;
              &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
              &lt;iothreads&gt;6&lt;/iothreads&gt;
              &lt;os&gt;
                &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
              &lt;/os&gt;
            &lt;/domain&gt;
        """
        domain_mock = self.set_mock_vm(
            "xml_with_iothreads_params", xml_with_iothreads_params
        )
        domain_mock.OSType = MagicMock(return_value="hvm")
        define_mock = MagicMock(return_value=True)
        self.mock_conn.defineXML = define_mock

        # test updating existing iothreads
        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("xml_with_iothreads_params", cpu={"iothreads": 7}),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find("iothreads").text, "7")

    def test_update_cputune_paramters(self):
        """
        Test virt.update() with cputune parameters.
        """
        xml_with_cputune_params = """
                    &lt;domain type='kvm' id='8'&gt;
                      &lt;name&gt;xml_with_cputune_params&lt;/name&gt;
                      &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
                      &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
                      &lt;maxMemory slots="12" unit="KiB"&gt;1048576&lt;/maxMemory&gt;
                      &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
                      &lt;iothreads&gt;4&lt;/iothreads&gt;
                      &lt;cputune&gt;
                        &lt;shares&gt;2048&lt;/shares&gt;
                        &lt;period&gt;1000000&lt;/period&gt;
                        &lt;quota&gt;-1&lt;/quota&gt;
                        &lt;global_period&gt;1000000&lt;/global_period&gt;
                        &lt;global_quota&gt;-1&lt;/global_quota&gt;
                        &lt;emulator_period&gt;1000000&lt;/emulator_period&gt;
                        &lt;emulator_quota&gt;-1&lt;/emulator_quota&gt;
                        &lt;iothread_period&gt;1000000&lt;/iothread_period&gt;
                        &lt;iothread_quota&gt;-1&lt;/iothread_quota&gt;
                        &lt;vcpupin vcpu="0" cpuset="0-2"/&gt;
                        &lt;vcpupin vcpu="1" cpuset="3"/&gt;
                        &lt;vcpupin vcpu="2" cpuset="4"/&gt;
                        &lt;vcpupin vcpu="3" cpuset="5-7"/&gt;
                        &lt;emulatorpin cpuset="1-2"/&gt;
                        &lt;iothreadpin iothread="1" cpuset="1-5"/&gt;
                        &lt;iothreadpin iothread="2" cpuset="6-7"/&gt;
                        &lt;vcpusched vcpus="0" scheduler="idle" priority="3"/&gt;
                        &lt;vcpusched vcpus="1" scheduler="rr" priority="1"/&gt;
                        &lt;vcpusched vcpus="2" scheduler="fifo" priority="2"/&gt;
                        &lt;iothreadsched iothreads="4" scheduler="fifo"/&gt;
                        &lt;emulatorsched scheduler="idle"/&gt;
                        &lt;cachetune vcpus="0-4"&gt;
                          &lt;cache id="0" level="2" type="both" size="4" unit="KiB"/&gt;
                          &lt;cache id="1" level="2" type="both" size="4" unit="KiB"/&gt;
                          &lt;monitor level="5" vcpus="0-2"/&gt;
                          &lt;monitor level="6" vcpus="1-3"/&gt;
                        &lt;/cachetune&gt;
                        &lt;cachetune vcpus="5-8"&gt;
                          &lt;monitor level="5" vcpus="5-6"/&gt;
                          &lt;monitor level="3" vcpus="7-8"/&gt;
                        &lt;/cachetune&gt;
                        &lt;memorytune vcpus="0-6"&gt;
                          &lt;node id="0" bandwidth="45"/&gt;
                        &lt;/memorytune&gt;
                        &lt;memorytune vcpus="7-8"&gt;
                          &lt;node id="0" bandwidth="120"/&gt;
                        &lt;/memorytune&gt;
                      &lt;/cputune&gt;
                      &lt;os&gt;
                        &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
                      &lt;/os&gt;
                    &lt;/domain&gt;
                """
        domain_mock = self.set_mock_vm(
            "xml_with_cputune_params", xml_with_cputune_params
        )
        domain_mock.OSType = MagicMock(return_value="hvm")
        define_mock = MagicMock(return_value=True)
        self.mock_conn.defineXML = define_mock
<a name="5"></a>
        # test updating existing cputune parameters
        cputune = {
            <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"shares": 1024,
            "period": 5000,
            "quota": -20,
            "global_period": 4000,
            "global_quota": -30,
            "emulator_period": 3000,
            "emulator_quota": -4,
            "iothread_period": 7000,
            "iothread_quota": -5,
            "vcpupin": {0: "1-4,^2", 1: "0,1", 2: "2,3", 3: "0,4"},
            "emulatorpin": "1-3",
            "iothreadpin": {1: "5-6", 2: "7-8"},
            "vcpusched": [
                {"scheduler": "fifo", "priority": 1, "vcpus": "0"},
                {"scheduler": "fifo", "priority": 2, "vcpus": "1"},
                {"scheduler": "idle", "priority": 3, "vcpus": "2"},
            ],
            "iothreadsched": [
                {"scheduler": "batch", "iothreads": "5-7", "priority": 1}
            ],
            "emulatorsched": {"scheduler": "rr", "priority": 2},
            "cachetune": {
                "0-3": {
                    0: {"level": 3, "type": "both", "size": 3},
                    1: {"level": 3, "type": "both", "size": 3},
                    "monitor": {1: 3, "0-3": 3},
                },
                "4-5": {"monitor": {4: 3, 5: 2}},
            },
            "memorytune": {"0-2": {0: 60}, "3-4": {0: 50, 1: 70}},
        }
        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.</b></font>update("xml_with_cputune_params", cpu={"tuning": cputune}),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find("cputune").find("shares").text, "1024")
        self.assertEqual(setxml.find("cputune").find("period").text, "5000")
        self.assertEqual(setxml.find("cputune").find("quota").text, "-20")
        self.assertEqual(setxml.find("cputune").find("global_period").text, "4000")
        self.assertEqual(setxml.find("cputune").find("global_quota").text, "-30")
        self.assertEqual(setxml.find("cputune").find("emulator_period").text, "3000")
        self.assertEqual(setxml.find("cputune").find("emulator_quota").text, "-4")
        self.assertEqual(setxml.find("cputune").find("iothread_period").text, "7000")
        self.assertEqual(setxml.find("cputune").find("iothread_quota").text, "-5")
        self.assertEqual(
            setxml.find("cputune").find("vcpupin[@vcpu='0']").attrib.get("cpuset"),
            "1,3,4",
        )
        self.assertEqual(
            setxml.find("cputune").find("vcpupin[@vcpu='1']").attrib.get("cpuset"),
            "0,1",
        )
        self.assertEqual(
            setxml.find("cputune").find("vcpupin[@vcpu='2']").attrib.get("cpuset"),
            "2,3",
        )
        self.assertEqual(
            setxml.find("cputune").find("vcpupin[@vcpu='3']").attrib.get("cpuset"),
            "0,4",
        )
        self.assertEqual(
            setxml.find("cputune").find("emulatorpin").attrib.get("cpuset"), "1,2,3"
        )
        self.assertEqual(
            setxml.find("cputune")
            .find("iothreadpin[@iothread='1']")
            .attrib.get("cpuset"),
            "5,6",
        )
        self.assertEqual(
            setxml.find("cputune")
            .find("iothreadpin[@iothread='2']")
            .attrib.get("cpuset"),
            "7,8",
        )
        self.assertDictEqual(
            {
                s.get("vcpus"): {
<a name="22"></a>                    "scheduler": s.get("scheduler"),
                    "priority": s.get("priority"),
                }
                for s in setxml<font color="#4cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.findall("cputune/vcpusched")
            },
            {
                "0": {"scheduler": "fifo", "priority": "1"},
                "1": {"scheduler": "fifo", "priority": "2"},
                "2": {"scheduler": "idle", "priority": "3"},
            },
        )
        self.assertDictEqual(
            {
                s.get("iothreads"): {
                    "scheduler": s.</b></font>get("scheduler"),
                    "priority": s.get("priority"),
                }
                for s in setxml.findall("cputune/iothreadsched")
            },
            {"5,6,7": {"scheduler": "batch", "priority": "1"}},
        )
        self.assertEqual(setxml.find("cputune/emulatorsched").get("scheduler"), "rr")
        self.assertEqual(setxml.find("cputune/emulatorsched").get("priority"), "2")
        self.assertIsNotNone(setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']"))
        self.assertEqual(
            setxml.find(
                "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
            ).attrib.get("level"),
            "3",
        )
        self.assertEqual(
            setxml.find(
                "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
            ).attrib.get("type"),
            "both",
        )
        self.assertEqual(
            setxml.find(
                "./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='1']"
            ).attrib.get("level"),
            "3",
        )
        self.assertNotEqual(
            setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='1']"),
            None,
        )
        self.assertNotEqual(
            setxml.find("./cputune/cachetune[@vcpus='4,5']").attrib.get("vcpus"), None
        )
        self.assertEqual(
            setxml.find("./cputune/cachetune[@vcpus='4,5']/cache[@id='0']"), None
        )
        self.assertEqual(
            setxml.find(
                "./cputune/cachetune[@vcpus='4,5']/monitor[@vcpus='4']"
            ).attrib.get("level"),
            "3",
        )
        self.assertEqual(
            setxml.find(
                "./cputune/cachetune[@vcpus='4,5']/monitor[@vcpus='5']"
            ).attrib.get("level"),
            "2",
        )
        self.assertNotEqual(setxml.find("./cputune/memorytune[@vcpus='0,1,2']"), None)
        self.assertEqual(
            setxml.find(
                "./cputune/memorytune[@vcpus='0,1,2']/node[@id='0']"
            ).attrib.get("bandwidth"),
            "60",
        )
        self.assertNotEqual(setxml.find("./cputune/memorytune[@vcpus='3,4']"), None)
        self.assertEqual(
            setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='0']").attrib.get(
                "bandwidth"
            ),
            "50",
        )
        self.assertEqual(
            setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='1']").attrib.get(
                "bandwidth"
            ),
            "70",
        )
<a name="13"></a>
        # test removing cputune attributes and sub elements
        cputune = {
            <font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"shares": None,
            "period": 20000,
            "quota": None,
            "global_period": 5000,
            "global_quota": None,
            "emulator_period": 2000,
            "emulator_quota": -4,
            "iothread_period": None,
            "iothread_quota": -5,
            "vcpupin": {0: "1-4,^2", 2: "2,4"},
            "emulatorpin": None,
            "iothreadpin": {1: "5-6"},
            "vcpusched": [{"scheduler": "idle", "priority": 5, "vcpus": "1"}],
            "iothreadsched": None,
            "cachetune": {
                "0-3": {
                    0: {"level": 4, "type": "data", "size": 7},
                    "monitor": {"1-2": 11},
                },
            },
            "memorytune": {"3-4": {0: 37, 1: 73}},
        }
        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.</b></font>update("xml_with_cputune_params", cpu={"tuning": cputune}),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find("cputune").find("shares"), None)
        self.assertEqual(setxml.find("cputune").find("period").text, "20000")
        self.assertEqual(setxml.find("cputune").find("quota"), None)
        self.assertEqual(setxml.find("cputune").find("global_period").text, "5000")
        self.assertEqual(setxml.find("cputune").find("global_quota"), None)
        self.assertEqual(setxml.find("cputune").find("emulator_period").text, "2000")
        self.assertEqual(setxml.find("cputune").find("emulator_quota").text, "-4")
        self.assertEqual(setxml.find("cputune").find("iothread_period"), None)
        self.assertEqual(setxml.find("cputune").find("iothread_quota").text, "-5")
        self.assertEqual(
            setxml.find("cputune").find("vcpupin[@vcpu='0']").attrib.get("cpuset"),
            "1,3,4",
        )
        self.assertEqual(setxml.find("cputune").find("vcpupin[@vcpu='1']"), None)
        self.assertEqual(
            setxml.find("cputune").find("vcpupin[@vcpu='2']").attrib.get("cpuset"),
            "2,4",
        )
        self.assertEqual(setxml.find("cputune").find("vcpupin[@vcpu='3']"), None)
        self.assertEqual(setxml.find("cputune").find("emulatorpin"), None)
        self.assertEqual(
            setxml.find("cputune")
            .find("iothreadpin[@iothread='1']")
            .attrib.get("cpuset"),
            "5,6",
        )
        self.assertEqual(
            setxml.find("cputune").find("iothreadpin[@iothread='2']"), None
        )
        self.assertDictEqual(
            {
                s.get("vcpus"): {
                    "scheduler": s.get("scheduler"),
                    "priority": s.get("priority"),
                }
                for s in setxml.findall("cputune/vcpusched")
            },
            {"1": {"scheduler": "idle", "priority": "5"}},
        )
        self.assertEqual(setxml.find("cputune").find("iothreadsched"), None)
        self.assertIsNotNone(setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']"))
        self.assertEqual(
            setxml.find(
                "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
            ).attrib.get("size"),
            "7",
        )
        self.assertEqual(
            setxml.find(
                "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
            ).attrib.get("level"),
            "4",
        )
        self.assertEqual(
            setxml.find(
                "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
            ).attrib.get("type"),
            "data",
        )
        self.assertEqual(
            setxml.find(
                "./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='1,2']"
            ).attrib.get("level"),
            "11",
        )
        self.assertEqual(
            setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='3,4']"),
            None,
        )
        self.assertEqual(
            setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='1']"), None
        )
        self.assertEqual(setxml.find("./cputune/cachetune[@vcpus='4,5']"), None)
        self.assertEqual(setxml.find("./cputune/memorytune[@vcpus='0,1,2']"), None)
        self.assertEqual(
            setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='0']").attrib.get(
                "bandwidth"
            ),
            "37",
        )
        self.assertEqual(
            setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='1']").attrib.get(
                "bandwidth"
            ),
            "73",
        )

        cputune_subelement = {
            "vcpupin": None,
            "iothreadpin": None,
            "vcpusched": None,
            "iothreadsched": None,
            "cachetune": None,
            "memorytune": None,
        }

        self.assertEqual(
            {
                "definition": True,
                "disk": {"attached": [], "detached": [], "updated": []},
                "interface": {"attached": [], "detached": []},
            },
            virt.update("xml_with_cputune_params", cpu={"tuning": cputune_subelement}),
        )
        setxml = ET.fromstring(define_mock.call_args[0][0])
        self.assertEqual(setxml.find("cputune").find("vcpupin"), None)
        self.assertEqual(setxml.find("cputune").find("iothreadpin"), None)
        self.assertEqual(setxml.find("cputune").find("vcpusched"), None)
        self.assertEqual(setxml.find("cputune").find("iothreadsched"), None)
        self.assertEqual(setxml.find("cputune").find("cachetune"), None)
        self.assertEqual(setxml.find("cputune").find("memorytune"), None)

    def test_handle_unit(self):
        """
        Test regex function for handling units
        """
        valid_case = [
            ("2", 2097152),
            ("42", 44040192),
            ("5b", 5),
            ("2.3Kib", 2355),
            ("5.8Kb", 5800),
            ("16MiB", 16777216),
            ("20 GB", 20000000000),
            ("16KB", 16000),
            (".5k", 512),
            ("2.k", 2048),
        ]

        for key, val in valid_case:
            self.assertEqual(virt._handle_unit(key), val)

        invalid_case = [
            ("9ib", "invalid units"),
            ("8byte", "invalid units"),
            ("512bytes", "invalid units"),
            ("4 Kbytes", "invalid units"),
            ("3.4.MB", "invalid number"),
            ("", "invalid number"),
            ("bytes", "invalid number"),
            ("2HB", "invalid units"),
        ]

        for key, val in invalid_case:
            with self.assertRaises(SaltInvocationError):
                virt._handle_unit(key)

    def test_mixed_dict_and_list_as_profile_objects(self):
        """
        Test virt._nic_profile with mixed dictionaries and lists as input.
        """
        yaml_config = """
          virt:
             nic:
                new-listonly-profile:
                   - bridge: br0
                     name: eth0
                   - model: virtio
                     name: eth1
                     source: test_network
                     type: network
                new-list-with-legacy-names:
                   - eth0:
                        bridge: br0
                   - eth1:
                        bridge: br1
                        model: virtio
                non-default-legacy-profile:
                   eth0:
                      bridge: br0
                   eth1:
                      bridge: br1
                      model: virtio
        """
        mock_config = salt.utils.yaml.safe_load(yaml_config)
        with patch.dict(
            salt.modules.config.__opts__, mock_config  # pylint: disable=no-member
        ):

            for name in mock_config["virt"]["nic"].keys():
                profile = salt.modules.virt._nic_profile(name, "kvm")
                self.assertEqual(len(profile), 2)

                interface_attrs = profile[0]
                self.assertIn("source", interface_attrs)
                self.assertIn("type", interface_attrs)
                self.assertIn("name", interface_attrs)
                self.assertIn("model", interface_attrs)
                self.assertEqual(interface_attrs["model"], "virtio")

    def test_get_xml(self):
        """
        Test virt.get_xml()
        """
        xml = """&lt;domain type='kvm' id='7'&gt;
              &lt;name&gt;test-vm&lt;/name&gt;
              &lt;devices&gt;
                &lt;graphics type='vnc' port='5900' autoport='yes' listen='0.0.0.0'&gt;
                  &lt;listen type='address' address='0.0.0.0'/&gt;
                &lt;/graphics&gt;
              &lt;/devices&gt;
            &lt;/domain&gt;
        """
        domain = self.set_mock_vm("test-vm", xml)
        self.assertEqual(xml, virt.get_xml("test-vm"))
        self.assertEqual(xml, virt.get_xml(domain))

    def test_get_loader(self):
        """
        Test virt.get_loader()
        """
        xml = """&lt;domain type='kvm' id='7'&gt;
              &lt;name&gt;test-vm&lt;/name&gt;
              &lt;os&gt;
                &lt;loader readonly='yes' type='pflash'&gt;/foo/bar&lt;/loader&gt;
              &lt;/os&gt;
            &lt;/domain&gt;
        """
        self.set_mock_vm("test-vm", xml)

        loader = virt.get_loader("test-vm")
        self.assertEqual("/foo/bar", loader["path"])
        self.assertEqual("yes", loader["readonly"])

    def test_cpu_baseline(self):
        """
        Test virt.cpu_baseline()
        """
        capabilities_xml = dedent(
            """&lt;capabilities&gt;
                  &lt;host&gt;
                    &lt;uuid&gt;44454c4c-3400-105a-8033-b3c04f4b344a&lt;/uuid&gt;
                    &lt;cpu&gt;
                      &lt;arch&gt;x86_64&lt;/arch&gt;
                      &lt;vendor&gt;Intel&lt;/vendor&gt;
                    &lt;/cpu&gt;
                  &lt;/host&gt;
                &lt;/capabilities&gt;"""
        )

        baseline_cpu_xml = b"""&lt;cpu match="exact" mode="custom"&gt;
                                  &lt;vendor&gt;Intel&lt;/vendor&gt;
                                &lt;/cpu&gt;"""

        self.mock_conn.getCapabilities.return_value = capabilities_xml
        self.mock_conn.baselineCPU.return_value = baseline_cpu_xml
        self.assertMultiLineEqual(str(baseline_cpu_xml), str(virt.cpu_baseline()))

    def test_parse_qemu_img_info(self):
        """
        Make sure that qemu-img info output is properly parsed
        """
        qemu_infos = """[{
            "snapshots": [
                {
                    "vm-clock-nsec": 0,
                    "name": "first-snap",
                    "date-sec": 1528877587,
                    "date-nsec": 380589000,
                    "vm-clock-sec": 0,
                    "id": "1",
                    "vm-state-size": 1234
                },
                {
                    "vm-clock-nsec": 0,
                    "name": "second snap",
                    "date-sec": 1528877592,
                    "date-nsec": 933509000,
                    "vm-clock-sec": 0,
                    "id": "2",
                    "vm-state-size": 4567
                }
            ],
            "virtual-size": 25769803776,
            "filename": "/disks/test.qcow2",
            "cluster-size": 65536,
            "format": "qcow2",
            "actual-size": 217088,
            "format-specific": {
                "type": "qcow2",
                "data": {
                    "compat": "1.1",
                    "lazy-refcounts": false,
                    "refcount-bits": 16,
                    "corrupt": false
                }
            },
            "full-backing-filename": "/disks/mybacking.qcow2",
            "backing-filename": "mybacking.qcow2",
            "dirty-flag": false
        },
        {
            "virtual-size": 25769803776,
            "filename": "/disks/mybacking.qcow2",
            "cluster-size": 65536,
            "format": "qcow2",
            "actual-size": 393744384,
            "format-specific": {
                "type": "qcow2",
                "data": {
                    "compat": "1.1",
                    "lazy-refcounts": false,
                    "refcount-bits": 16,
                    "corrupt": false
                }
            },
            "full-backing-filename": "/disks/root.qcow2",
            "backing-filename": "root.qcow2",
            "dirty-flag": false
        },
        {
            "virtual-size": 25769803776,
            "filename": "/disks/root.qcow2",
            "cluster-size": 65536,
            "format": "qcow2",
            "actual-size": 196872192,
            "format-specific": {
                "type": "qcow2",
                "data": {
                    "compat": "1.1",
                    "lazy-refcounts": false,
                    "refcount-bits": 16,
                    "corrupt": false
                }
            },
            "dirty-flag": false
        }]"""

        self.assertEqual(
            {
                "file": "/disks/test.qcow2",
                "file format": "qcow2",
                "backing file": {
                    "file": "/disks/mybacking.qcow2",
                    "file format": "qcow2",
                    "disk size": 393744384,
                    "virtual size": 25769803776,
                    "cluster size": 65536,
                    "backing file": {
                        "file": "/disks/root.qcow2",
                        "file format": "qcow2",
                        "disk size": 196872192,
                        "virtual size": 25769803776,
                        "cluster size": 65536,
                    },
                },
                "disk size": 217088,
                "virtual size": 25769803776,
                "cluster size": 65536,
                "snapshots": [
                    {
                        "id": "1",
                        "tag": "first-snap",
                        "vmsize": 1234,
                        "date": datetime.datetime.fromtimestamp(
                            float("{}.{}".format(1528877587, 380589000))
                        ).isoformat(),
                        "vmclock": "00:00:00",
                    },
                    {
                        "id": "2",
                        "tag": "second snap",
                        "vmsize": 4567,
                        "date": datetime.datetime.fromtimestamp(
                            float("{}.{}".format(1528877592, 933509000))
                        ).isoformat(),
                        "vmclock": "00:00:00",
                    },
                ],
            },
            virt._parse_qemu_img_info(qemu_infos),
        )

    @patch("salt.modules.virt.stop", return_value=True)
    @patch("salt.modules.virt.undefine")
    @patch("os.remove")
    def test_purge_default(self, mock_remove, mock_undefine, mock_stop):
        """
        Test virt.purge() with default parameters
        """
        xml = """&lt;domain type='kvm' id='7'&gt;
              &lt;name&gt;test-vm&lt;/name&gt;
              &lt;devices&gt;
                &lt;disk type='file' device='disk'&gt;
                &lt;driver name='qemu' type='qcow2'/&gt;
                &lt;source file='/disks/test.qcow2'/&gt;
                &lt;target dev='vda' bus='virtio'/&gt;
              &lt;/disk&gt;
              &lt;disk type='file' device='cdrom'&gt;
                &lt;driver name='qemu' type='raw'/&gt;
                &lt;source file='/disks/test-cdrom.iso'/&gt;
                &lt;target dev='hda' bus='ide'/&gt;
                &lt;readonly/&gt;
              &lt;/disk&gt;
              &lt;/devices&gt;
            &lt;/domain&gt;
        """
        self.set_mock_vm("test-vm", xml)

        qemu_infos = """[{
            "virtual-size": 25769803776,
            "filename": "/disks/test.qcow2",
            "cluster-size": 65536,
            "format": "qcow2",
            "actual-size": 217088,
            "format-specific": {
                "type": "qcow2",
                "data": {
                    "compat": "1.1",
                    "lazy-refcounts": false,
                    "refcount-bits": 16,
                    "corrupt": false
                }
            },
            "dirty-flag": false
        }]"""

        self.mock_popen.communicate.return_value = [qemu_infos, ""]
        self.mock_popen.returncode = 0

        with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
            res = virt.purge("test-vm")
            self.assertTrue(res)
            mock_remove.assert_called_once()
            mock_remove.assert_any_call("/disks/test.qcow2")

    @patch("salt.modules.virt.stop", return_value=True)
    @patch("salt.modules.virt.undefine")
    def test_purge_volumes(self, mock_undefine, mock_stop):
        """
        Test virt.purge() with volume disks
        """
        xml = """&lt;domain type='kvm' id='7'&gt;
              &lt;name&gt;test-vm&lt;/name&gt;
              &lt;devices&gt;
                &lt;disk type='volume' device='disk'&gt;
                  &lt;driver name='qemu' type='qcow2' cache='none' io='native'/&gt;
                  &lt;source pool='default' volume='vm05_system'/&gt;
                  &lt;backingStore type='file' index='1'&gt;
                    &lt;format type='qcow2'/&gt;
                    &lt;source file='/var/lib/libvirt/images/vm04_system.qcow2'/&gt;
                    &lt;backingStore type='file' index='2'&gt;
                      &lt;format type='qcow2'/&gt;
                      &lt;source file='/var/testsuite-data/disk-image-template.qcow2'/&gt;
                      &lt;backingStore/&gt;
                    &lt;/backingStore&gt;
                  &lt;/backingStore&gt;
                  &lt;target dev='vda' bus='virtio'/&gt;
                  &lt;alias name='virtio-disk0'/&gt;
                  &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x04' function='0x0'/&gt;
                &lt;/disk&gt;
              &lt;/devices&gt;
            &lt;/domain&gt;
        """
        self.set_mock_vm("test-vm", xml)

        pool_mock = MagicMock()
        pool_mock.storageVolLookupByName.return_value.info.return_value = [
            0,
            1234567,
            12345,
        ]
        pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = [
            """
            &lt;volume type='file'&gt;
              &lt;name&gt;vm05_system&lt;/name&gt;
              &lt;target&gt;
                &lt;path&gt;/var/lib/libvirt/images/vm05_system&lt;/path&gt;
                &lt;format type='qcow2'/&gt;
              &lt;/target&gt;
              &lt;backingStore&gt;
                &lt;path&gt;/var/lib/libvirt/images/vm04_system.qcow2&lt;/path&gt;
                &lt;format type='qcow2'/&gt;
              &lt;/backingStore&gt;
            &lt;/volume&gt;
            """,
        ]
        pool_mock.listVolumes.return_value = ["vm05_system", "vm04_system.qcow2"]
        self.mock_conn.storagePoolLookupByName.return_value = pool_mock
        self.mock_conn.listStoragePools.return_value = ["default"]

        with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=False)}):
            res = virt.purge("test-vm")
            self.assertTrue(res)
            pool_mock.storageVolLookupByName.return_value.delete.assert_called_once()

    @patch("salt.modules.virt.stop", return_value=True)
    @patch("salt.modules.virt.undefine")
    def test_purge_rbd(self, mock_undefine, mock_stop):
        """
        Test virt.purge() with RBD disks
        """
        xml = """&lt;domain type='kvm' id='7'&gt;
              &lt;name&gt;test-vm&lt;/name&gt;
              &lt;devices&gt;
                &lt;disk type="network" device="disk"&gt;
                  &lt;driver name='raw' type='qcow2'/&gt;
                  &lt;source protocol='rbd' name='libvirt-pool/my_vm_data2'&gt;
                    &lt;host name='ses2.tf.local'/&gt;
                    &lt;host name='ses3.tf.local' port='1234'/&gt;
                    &lt;auth username='libvirt'&gt;
                      &lt;secret type='ceph' usage='pool_test-rbd'/&gt;
                    &lt;/auth&gt;
                  &lt;/source&gt;
                  &lt;target dev='vdc' bus='virtio'/&gt;
                  &lt;alias name='virtio-disk2'/&gt;
                  &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x07' function='0x2'/&gt;
                &lt;/disk&gt;
              &lt;/devices&gt;
            &lt;/domain&gt;
        """
        self.set_mock_vm("test-vm", xml)

        pool_mock = MagicMock()
        pool_mock.storageVolLookupByName.return_value.info.return_value = [
            0,
            1234567,
            12345,
        ]
        pool_mock.XMLDesc.return_value = """
        &lt;pool type='rbd'&gt;
          &lt;name&gt;test-ses&lt;/name&gt;
          &lt;source&gt;
            &lt;host name='ses2.tf.local'/&gt;
            &lt;name&gt;libvirt-pool&lt;/name&gt;
            &lt;auth type='ceph' username='libvirt'&gt;
              &lt;secret usage='pool_test-ses'/&gt;
            &lt;/auth&gt;
          &lt;/source&gt;
        &lt;/pool&gt;
        """
        pool_mock.name.return_value = "test-ses"
        pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = [
            """
            &lt;volume type='network'&gt;
              &lt;name&gt;my_vm_data2&lt;/name&gt;
              &lt;source&gt;
              &lt;/source&gt;
              &lt;capacity unit='bytes'&gt;536870912&lt;/capacity&gt;
              &lt;allocation unit='bytes'&gt;0&lt;/allocation&gt;
              &lt;target&gt;
                &lt;path&gt;libvirt-pool/my_vm_data2&lt;/path&gt;
                &lt;format type='raw'/&gt;
              &lt;/target&gt;
            &lt;/volume&gt;
            """,
        ]
        pool_mock.listVolumes.return_value = ["my_vm_data2"]
        self.mock_conn.listAllStoragePools.return_value = [pool_mock]
        self.mock_conn.listStoragePools.return_value = ["test-ses"]
        self.mock_conn.storagePoolLookupByName.return_value = pool_mock

        with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=False)}):
            res = virt.purge("test-vm")
            self.assertTrue(res)
            pool_mock.storageVolLookupByName.return_value.delete.assert_called_once()

    @patch("salt.modules.virt.stop", return_value=True)
    @patch("salt.modules.virt.undefine")
    @patch("os.remove")
    def test_purge_removable(self, mock_remove, mock_undefine, mock_stop):
        """
        Test virt.purge(removables=True)
        """
        xml = """&lt;domain type="kvm" id="7"&gt;
              &lt;name&gt;test-vm&lt;/name&gt;
              &lt;devices&gt;
                &lt;disk type='file' device='disk'&gt;
                &lt;driver name='qemu' type='qcow2'/&gt;
                &lt;source file='/disks/test.qcow2'/&gt;
                &lt;target dev='vda' bus='virtio'/&gt;
              &lt;/disk&gt;
              &lt;disk type='file' device='cdrom'&gt;
                &lt;driver name='qemu' type='raw'/&gt;
                &lt;source file='/disks/test-cdrom.iso'/&gt;
                &lt;target dev='hda' bus='ide'/&gt;
                &lt;readonly/&gt;
              &lt;/disk&gt;
              &lt;disk type='file' device='floppy'&gt;
                &lt;driver name='qemu' type='raw'/&gt;
                &lt;source file='/disks/test-floppy.iso'/&gt;
                &lt;target dev='hdb' bus='ide'/&gt;
                &lt;readonly/&gt;
              &lt;/disk&gt;
              &lt;/devices&gt;
            &lt;/domain&gt;
        """
        self.set_mock_vm("test-vm", xml)

        qemu_infos = """[{
            "virtual-size": 25769803776,
            "filename": "/disks/test.qcow2",
            "cluster-size": 65536,
            "format": "qcow2",
            "actual-size": 217088,
            "format-specific": {
                "type": "qcow2",
                "data": {
                    "compat": "1.1",
                    "lazy-refcounts": false,
                    "refcount-bits": 16,
                    "corrupt": false
                }
            },
            "dirty-flag": false
        }]"""

        self.mock_popen.communicate.return_value = [qemu_infos, ""]
        self.mock_popen.returncode = 0

        with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
            res = virt.purge("test-vm", removables=True)
            self.assertTrue(res)
            mock_remove.assert_any_call("/disks/test.qcow2")
            mock_remove.assert_any_call("/disks/test-cdrom.iso")

    def test_capabilities(self):
        """
        Test the virt.capabilities parsing
        """
        xml = """
&lt;capabilities&gt;
  &lt;host&gt;
    &lt;uuid&gt;44454c4c-3400-105a-8033-b3c04f4b344a&lt;/uuid&gt;
    &lt;cpu&gt;
      &lt;arch&gt;x86_64&lt;/arch&gt;
      &lt;model&gt;Nehalem&lt;/model&gt;
      &lt;vendor&gt;Intel&lt;/vendor&gt;
      &lt;microcode version='25'/&gt;
      &lt;topology sockets='1' cores='4' threads='2'/&gt;
      &lt;feature name='vme'/&gt;
      &lt;feature name='ds'/&gt;
      &lt;feature name='acpi'/&gt;
      &lt;pages unit='KiB' size='4'/&gt;
      &lt;pages unit='KiB' size='2048'/&gt;
    &lt;/cpu&gt;
    &lt;power_management&gt;
      &lt;suspend_mem/&gt;
      &lt;suspend_disk/&gt;
      &lt;suspend_hybrid/&gt;
    &lt;/power_management&gt;
    &lt;migration_features&gt;
      &lt;live/&gt;
      &lt;uri_transports&gt;
        &lt;uri_transport&gt;tcp&lt;/uri_transport&gt;
        &lt;uri_transport&gt;rdma&lt;/uri_transport&gt;
      &lt;/uri_transports&gt;
    &lt;/migration_features&gt;
    &lt;topology&gt;
      &lt;cells num='1'&gt;
        &lt;cell id='0'&gt;
          &lt;memory unit='KiB'&gt;12367120&lt;/memory&gt;
          &lt;pages unit='KiB' size='4'&gt;3091780&lt;/pages&gt;
          &lt;pages unit='KiB' size='2048'&gt;0&lt;/pages&gt;
          &lt;distances&gt;
            &lt;sibling id='0' value='10'/&gt;
          &lt;/distances&gt;
          &lt;cpus num='8'&gt;
            &lt;cpu id='0' socket_id='0' core_id='0' siblings='0,4'/&gt;
            &lt;cpu id='1' socket_id='0' core_id='1' siblings='1,5'/&gt;
            &lt;cpu id='2' socket_id='0' core_id='2' siblings='2,6'/&gt;
            &lt;cpu id='3' socket_id='0' core_id='3' siblings='3,7'/&gt;
            &lt;cpu id='4' socket_id='0' core_id='0' siblings='0,4'/&gt;
            &lt;cpu id='5' socket_id='0' core_id='1' siblings='1,5'/&gt;
            &lt;cpu id='6' socket_id='0' core_id='2' siblings='2,6'/&gt;
            &lt;cpu id='7' socket_id='0' core_id='3' siblings='3,7'/&gt;
          &lt;/cpus&gt;
        &lt;/cell&gt;
      &lt;/cells&gt;
    &lt;/topology&gt;
    &lt;cache&gt;
      &lt;bank id='0' level='3' type='both' size='8' unit='MiB' cpus='0-7'/&gt;
    &lt;/cache&gt;
    &lt;secmodel&gt;
      &lt;model&gt;apparmor&lt;/model&gt;
      &lt;doi&gt;0&lt;/doi&gt;
    &lt;/secmodel&gt;
    &lt;secmodel&gt;
      &lt;model&gt;dac&lt;/model&gt;
      &lt;doi&gt;0&lt;/doi&gt;
      &lt;baselabel type='kvm'&gt;+487:+486&lt;/baselabel&gt;
      &lt;baselabel type='qemu'&gt;+487:+486&lt;/baselabel&gt;
    &lt;/secmodel&gt;
  &lt;/host&gt;

  &lt;guest&gt;
    &lt;os_type&gt;hvm&lt;/os_type&gt;
    &lt;arch name='i686'&gt;
      &lt;wordsize&gt;32&lt;/wordsize&gt;
      &lt;emulator&gt;/usr/bin/qemu-system-i386&lt;/emulator&gt;
      &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
      &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
      &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
      &lt;domain type='qemu'/&gt;
      &lt;domain type='kvm'&gt;
        &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
        &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
        &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
        &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
      &lt;/domain&gt;
    &lt;/arch&gt;
    &lt;features&gt;
      &lt;cpuselection/&gt;
      &lt;deviceboot/&gt;
      &lt;disksnapshot default='on' toggle='no'/&gt;
      &lt;acpi default='off' toggle='yes'/&gt;
      &lt;apic default='on' toggle='no'/&gt;
      &lt;pae/&gt;
      &lt;nonpae/&gt;
    &lt;/features&gt;
  &lt;/guest&gt;

  &lt;guest&gt;
    &lt;os_type&gt;hvm&lt;/os_type&gt;
    &lt;arch name='x86_64'&gt;
      &lt;wordsize&gt;64&lt;/wordsize&gt;
      &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
      &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
      &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
      &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
      &lt;domain type='qemu'/&gt;
      &lt;domain type='kvm'&gt;
        &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
        &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
        &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
        &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
      &lt;/domain&gt;
    &lt;/arch&gt;
    &lt;features&gt;
      &lt;cpuselection/&gt;
      &lt;deviceboot/&gt;
      &lt;disksnapshot default='on' toggle='no'/&gt;
      &lt;acpi default='on' toggle='yes'/&gt;
      &lt;apic default='off' toggle='no'/&gt;
    &lt;/features&gt;
  &lt;/guest&gt;

  &lt;guest&gt;
    &lt;os_type&gt;xen&lt;/os_type&gt;
    &lt;arch name='x86_64'&gt;
      &lt;wordsize&gt;64&lt;/wordsize&gt;
      &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
      &lt;machine&gt;xenpv&lt;/machine&gt;
      &lt;domain type='xen'/&gt;
    &lt;/arch&gt;
  &lt;/guest&gt;

&lt;/capabilities&gt;
        """
        self.mock_conn.getCapabilities.return_value = xml  # pylint: disable=no-member
<a name="0"></a>        caps = virt.capabilities()

        expected = {
            <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"host": {
                "uuid": "44454c4c-3400-105a-8033-b3c04f4b344a",
                "cpu": {
                    "arch": "x86_64",
                    "model": "Nehalem",
                    "vendor": "Intel",
                    "microcode": "25",
                    "sockets": 1,
                    "cores": 4,
                    "threads": 2,
                    "features": ["vme", "ds", "acpi"],
                    "pages": [{"size": "4 KiB"}, {"size": "2048 KiB"}],
                },
                "power_management": ["suspend_mem", "suspend_disk", "suspend_hybrid"],
                "migration": {"live": True, "transports": ["tcp", "rdma"]},
                "topology": {
                    "cells": [
                        {
                            "id": 0,
                            "memory": "12367120 KiB",
                            "pages": [
                                {"size": "4 KiB", "available": 3091780},
                                {"size": "2048 KiB", "available": 0},
                            ],
                            "distances": {0: 10},
                            "cpus": [
                                {
                                    "id": 0,
                                    "socket_id": 0,
                                    "core_id": 0,
                                    "siblings": "0,4",
                                },
                                {
                                    "id": 1,
                                    "socket_id": 0,
                                    "core_id": 1,
                                    "siblings": "1,5",
                                },
                                {
                                    "id": 2,
                                    "socket_id": 0,
                                    "core_id": 2,
                                    "siblings": "2,6",
                                },
                                {
                                    "id": 3,
                                    "socket_id": 0,
                                    "core_id": 3,
                                    "siblings": "3,7",
                                },
                                {
                                    "id": 4,
                                    "socket_id": 0,
                                    "core_id": 0,
                                    "siblings": "0,4",
                                },
                                {
                                    "id": 5,
                                    "socket_id": 0,
                                    "core_id": 1,
                                    "siblings": "1,5",
                                },
                                {
                                    "id": 6,
                                    "socket_id": 0,
                                    "core_id": 2,
                                    "siblings": "2,6",
                                },
                                {
                                    "id": 7,
                                    "socket_id": 0,
                                    "core_id": 3,
                                    "siblings": "3,7",
                                },
                            ],
                        }
                    ]
                },
                "cache": {
                    "banks": [
                        {
                            "id": 0,
                            "level": 3,
                            "type": "both",
                            "size": "8 MiB",
                            "cpus": "0-7",
                        }
                    ]
                },
                "security": [
                    {"model": "apparmor", "doi": "0", "baselabels": []},
                    {
                        "model": "dac",
                        "doi": "0",
                        "baselabels": [
                            {"type": "kvm", "label": "+487:+486"},
                            {"type": "qemu", "label": "+487:+486"},
                        ],
                    },
                ],
            },
            "guests": [
                {
                    "os_type": "hvm",
                    "arch": {
                        "name": "i686",
                        "wordsize": 32,
                        "emulator": "/usr/bin/qemu-system-i386",
                        "machines": {
                            "pc-i440fx-2.6": {
                                "maxcpus": 255,
                                "alternate_names": ["pc"],
                            },
                            "pc-0.12": {"maxcpus": 255, "alternate_names": []},
                        },
                        "domains": {
                            "qemu": {"emulator": None, "machines": {}},
                            "kvm": {
                                "emulator": "/usr/bin/qemu-kvm",
                                "machines": {
                                    "pc-i440fx-2.6": {
                                        "maxcpus": 255,
                                        "alternate_names": ["pc"],
                                    },
                                    "pc-0.12": {"maxcpus": 255, "alternate_names": []},
                                },
                            },
                        },
                    },
                    "features": {
                        "cpuselection": {"default": True, "toggle": False},
                        "deviceboot": {"default": True, "toggle": False},
                        "disksnapshot": {"default": True, "toggle": False},
                        "acpi": {"default": False, "toggle": True},
                        "apic": {"default": True, "toggle": False},
                        "pae": {"default": True, "toggle": False},
                        "nonpae": {"default": True, "toggle": False},
                    },
                },
                {
                    "os_type": "hvm",
                    "arch": {
                        "name": "x86_64",
                        "wordsize": 64,
                        "emulator": "/usr/bin/qemu-system-x86_64",
                        "machines": {
                            "pc-i440fx-2.6": {
                                "maxcpus": 255,
                                "alternate_names": ["pc"],
                            },
                            "pc-0.12": {"maxcpus": 255, "alternate_names": []},
                        },
                        "domains": {
                            "qemu": {"emulator": None, "machines": {}},
                            "kvm": {
                                "emulator": "/usr/bin/qemu-kvm",
                                "machines": {
                                    "pc-i440fx-2.6": {
                                        "maxcpus": 255,
                                        "alternate_names": ["pc"],
                                    },
                                    "pc-0.12": {"maxcpus": 255, "alternate_names": []},
                                },
                            },
                        },
                    },
                    "features": {
                        "cpuselection": {"default": True, "toggle": False},
                        "deviceboot": {"default": True, "toggle": False},
                        "disksnapshot": {"default": True, "toggle": False},
                        "acpi": {"default": True, "toggle": True},
                        "apic": {"default": False, "toggle": False},
                    },
                },
                {
                    "os_type": "xen",
                    "arch": {
                        "name": "x86_64",
                        "wordsize": 64,
                        "emulator": "/usr/bin/qemu-system-x86_64",
                        "machines": {"xenpv": {"alternate_names": []}},
                        "domains": {"xen": {"emulator": None, "machines": {}}},
                    },
                },
            ],
        }
        self.assertEqual(</b></font>expected, caps)

    def test_domain_capabilities(self):
        """
        Test the virt.domain_capabilities parsing
        """
        xml = """
&lt;domainCapabilities&gt;
  &lt;path&gt;/usr/bin/qemu-system-aarch64&lt;/path&gt;
  &lt;domain&gt;kvm&lt;/domain&gt;
  &lt;machine&gt;virt-2.12&lt;/machine&gt;
  &lt;arch&gt;aarch64&lt;/arch&gt;
  &lt;vcpu max='255'/&gt;
  &lt;iothreads supported='yes'/&gt;
  &lt;os supported='yes'&gt;
    &lt;loader supported='yes'&gt;
      &lt;value&gt;/usr/share/AAVMF/AAVMF_CODE.fd&lt;/value&gt;
      &lt;value&gt;/usr/share/AAVMF/AAVMF32_CODE.fd&lt;/value&gt;
      &lt;value&gt;/usr/share/OVMF/OVMF_CODE.fd&lt;/value&gt;
      &lt;enum name='type'&gt;
        &lt;value&gt;rom&lt;/value&gt;
        &lt;value&gt;pflash&lt;/value&gt;
      &lt;/enum&gt;
      &lt;enum name='readonly'&gt;
        &lt;value&gt;yes&lt;/value&gt;
        &lt;value&gt;no&lt;/value&gt;
      &lt;/enum&gt;
    &lt;/loader&gt;
  &lt;/os&gt;
  &lt;cpu&gt;
    &lt;mode name='host-passthrough' supported='yes'/&gt;
    &lt;mode name='host-model' supported='yes'&gt;
      &lt;model fallback='forbid'&gt;sample-cpu&lt;/model&gt;
      &lt;vendor&gt;ACME&lt;/vendor&gt;
      &lt;feature policy='require' name='vme'/&gt;
      &lt;feature policy='require' name='ss'/&gt;
    &lt;/mode&gt;
    &lt;mode name='custom' supported='yes'&gt;
      &lt;model usable='unknown'&gt;pxa262&lt;/model&gt;
      &lt;model usable='yes'&gt;pxa270-a0&lt;/model&gt;
      &lt;model usable='no'&gt;arm1136&lt;/model&gt;
    &lt;/mode&gt;
  &lt;/cpu&gt;
  &lt;devices&gt;
    &lt;disk supported='yes'&gt;
      &lt;enum name='diskDevice'&gt;
        &lt;value&gt;disk&lt;/value&gt;
        &lt;value&gt;cdrom&lt;/value&gt;
        &lt;value&gt;floppy&lt;/value&gt;
        &lt;value&gt;lun&lt;/value&gt;
      &lt;/enum&gt;
      &lt;enum name='bus'&gt;
        &lt;value&gt;fdc&lt;/value&gt;
        &lt;value&gt;scsi&lt;/value&gt;
        &lt;value&gt;virtio&lt;/value&gt;
        &lt;value&gt;usb&lt;/value&gt;
        &lt;value&gt;sata&lt;/value&gt;
      &lt;/enum&gt;
    &lt;/disk&gt;
    &lt;graphics supported='yes'&gt;
      &lt;enum name='type'&gt;
        &lt;value&gt;sdl&lt;/value&gt;
        &lt;value&gt;vnc&lt;/value&gt;
      &lt;/enum&gt;
    &lt;/graphics&gt;
    &lt;video supported='yes'&gt;
      &lt;enum name='modelType'&gt;
        &lt;value&gt;vga&lt;/value&gt;
        &lt;value&gt;virtio&lt;/value&gt;
      &lt;/enum&gt;
    &lt;/video&gt;
    &lt;hostdev supported='yes'&gt;
      &lt;enum name='mode'&gt;
        &lt;value&gt;subsystem&lt;/value&gt;
      &lt;/enum&gt;
      &lt;enum name='startupPolicy'&gt;
        &lt;value&gt;default&lt;/value&gt;
        &lt;value&gt;mandatory&lt;/value&gt;
        &lt;value&gt;requisite&lt;/value&gt;
        &lt;value&gt;optional&lt;/value&gt;
      &lt;/enum&gt;
      &lt;enum name='subsysType'&gt;
        &lt;value&gt;usb&lt;/value&gt;
        &lt;value&gt;pci&lt;/value&gt;
        &lt;value&gt;scsi&lt;/value&gt;
      &lt;/enum&gt;
      &lt;enum name='capsType'/&gt;
      &lt;enum name='pciBackend'&gt;
        &lt;value&gt;default&lt;/value&gt;
        &lt;value&gt;kvm&lt;/value&gt;
        &lt;value&gt;vfio&lt;/value&gt;
      &lt;/enum&gt;
    &lt;/hostdev&gt;
  &lt;/devices&gt;
  &lt;features&gt;
    &lt;gic supported='yes'&gt;
      &lt;enum name='version'&gt;
        &lt;value&gt;3&lt;/value&gt;
      &lt;/enum&gt;
    &lt;/gic&gt;
    &lt;vmcoreinfo supported='yes'/&gt;
  &lt;/features&gt;
&lt;/domainCapabilities&gt;
        """

        self.mock_conn.getDomainCapabilities.return_value = (
            xml  # pylint: disable=no-member
        )
<a name="3"></a>        caps = virt.domain_capabilities()

        expected = {
            <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"emulator": "/usr/bin/qemu-system-aarch64",
            "domain": "kvm",
            "machine": "virt-2.12",
            "arch": "aarch64",
            "max_vcpus": 255,
            "iothreads": True,
            "os": {
                "loader": {
                    "type": ["rom", "pflash"],
                    "readonly": ["yes", "no"],
                    "values": [
                        "/usr/share/AAVMF/AAVMF_CODE.fd",
                        "/usr/share/AAVMF/AAVMF32_CODE.fd",
                        "/usr/share/OVMF/OVMF_CODE.fd",
                    ],
                }
            },
            "cpu": {
                "host-passthrough": True,
                "host-model": {
                    "model": {"name": "sample-cpu", "fallback": "forbid"},
                    "vendor": "ACME",
                    "features": {"vme": "require", "ss": "require"},
                },
                "custom": {
                    "models": {"pxa262": "unknown", "pxa270-a0": "yes", "arm1136": "no"}
                },
            },
            "devices": {
                "disk": {
                    "diskDevice": ["disk", "cdrom", "floppy", "lun"],
                    "bus": ["fdc", "scsi", "virtio", "usb", "sata"],
                },
                "graphics": {"type": ["sdl", "vnc"]},
                "video": {"modelType": ["vga", "virtio"]},
                "hostdev": {
                    "mode": ["subsystem"],
                    "startupPolicy": ["default", "mandatory", "requisite", "optional"],
                    "subsysType": ["usb", "pci", "scsi"],
                    "capsType": [],
                    "pciBackend": ["default", "kvm", "vfio"],
                },
            },
            "features": {"gic": {"version": ["3"]}, "vmcoreinfo": {}},
        }

        self.assertEqual(</b></font>expected, caps)

    def test_all_capabilities(self):
        """
        Test the virt.domain_capabilities default output
        """
        domainXml = """
&lt;domainCapabilities&gt;
  &lt;path&gt;/usr/bin/qemu-system-x86_64&lt;/path&gt;
  &lt;domain&gt;kvm&lt;/domain&gt;
  &lt;machine&gt;virt-2.12&lt;/machine&gt;
  &lt;arch&gt;x86_64&lt;/arch&gt;
  &lt;vcpu max='255'/&gt;
  &lt;iothreads supported='yes'/&gt;
&lt;/domainCapabilities&gt;
        """
        hostXml = """
&lt;capabilities&gt;
  &lt;host&gt;
    &lt;uuid&gt;44454c4c-3400-105a-8033-b3c04f4b344a&lt;/uuid&gt;
    &lt;cpu&gt;
      &lt;arch&gt;x86_64&lt;/arch&gt;
      &lt;model&gt;Nehalem&lt;/model&gt;
      &lt;vendor&gt;Intel&lt;/vendor&gt;
      &lt;microcode version='25'/&gt;
      &lt;topology sockets='1' cores='4' threads='2'/&gt;
    &lt;/cpu&gt;
  &lt;/host&gt;
  &lt;guest&gt;
    &lt;os_type&gt;hvm&lt;/os_type&gt;
    &lt;arch name='x86_64'&gt;
      &lt;wordsize&gt;64&lt;/wordsize&gt;
      &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
      &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
      &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
      &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
      &lt;domain type='qemu'/&gt;
      &lt;domain type='kvm'&gt;
        &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
        &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
        &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
        &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
      &lt;/domain&gt;
    &lt;/arch&gt;
  &lt;/guest&gt;
&lt;/capabilities&gt;
        """

        # pylint: disable=no-member
        self.mock_conn.getCapabilities.return_value = hostXml
        self.mock_conn.getDomainCapabilities.side_effect = [
            domainXml,
            domainXml.replace("&lt;domain&gt;kvm", "&lt;domain&gt;qemu"),
        ]
<a name="9"></a>        # pylint: enable=no-member

        caps = virt.all_capabilities()
        self<font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertEqual(
            "44454c4c-3400-105a-8033-b3c04f4b344a", caps["host"]["host"]["uuid"]
        )
        self.assertEqual(
            {"qemu", "kvm"},
            {domainCaps["domain"] for domainCaps in caps["domains"]},
        )

        self.assertEqual(
            {call[0] for call in self.mock_conn.getDomainCapabilities.call_args_list},
            {
                ("/usr/bin/qemu-system-x86_64", "x86_64", None, "kvm"),
                ("/usr/bin/qemu-system-x86_64"</b></font>, "x86_64", None, "qemu"),
            },
        )

    def test_network_tag(self):
        """
        Test virt._get_net_xml() with VLAN tag
        """
        xml_data = virt._gen_net_xml("network", "main", "bridge", "openvswitch", 1001)
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find("name").text, "network")
        self.assertEqual(root.find("bridge").attrib["name"], "main")
        self.assertEqual(root.find("forward").attrib["mode"], "bridge")
        self.assertEqual(root.find("virtualport").attrib["type"], "openvswitch")
        self.assertEqual(root.find("vlan/tag").attrib["id"], "1001")

    def test_list_networks(self):
        """
        Test virt.list_networks()
        """
        names = ["net1", "default", "net2"]
        net_mocks = [MagicMock(), MagicMock(), MagicMock()]
        for i, value in enumerate(names):
            net_mocks[i].name.return_value = value

        self.mock_conn.listAllNetworks.return_value = (
            net_mocks  # pylint: disable=no-member
        )
        actual = virt.list_networks()
        self.assertEqual(names, actual)

    def test_network_info(self):
        """
        Test virt.network_info()
        """
        self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV4 = 0
        self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV6 = 1

        net_mock = MagicMock()

        # pylint: disable=no-member
        net_mock.name.return_value = "foo"
        net_mock.UUIDString.return_value = "some-uuid"
        net_mock.bridgeName.return_value = "br0"
        net_mock.autostart.return_value = True
        net_mock.isActive.return_value = False
        net_mock.isPersistent.return_value = True
        net_mock.DHCPLeases.return_value = [
            {
                "iface": "virbr0",
                "expirytime": 1527757552,
                "type": 0,
                "mac": "52:54:00:01:71:bd",
                "ipaddr": "192.168.122.45",
                "prefix": 24,
                "hostname": "py3-test",
                "clientid": "01:52:54:00:01:71:bd",
                "iaid": None,
            }
        ]
        self.mock_conn.listAllNetworks.return_value = [net_mock]
        # pylint: enable=no-member

        net = virt.network_info("foo")
        self.assertEqual(
            {
                "foo": {
                    "uuid": "some-uuid",
                    "bridge": "br0",
                    "autostart": True,
                    "active": False,
                    "persistent": True,
                    "leases": [
                        {
                            "iface": "virbr0",
                            "expirytime": 1527757552,
                            "type": "ipv4",
                            "mac": "52:54:00:01:71:bd",
                            "ipaddr": "192.168.122.45",
                            "prefix": 24,
                            "hostname": "py3-test",
                            "clientid": "01:52:54:00:01:71:bd",
                            "iaid": None,
                        }
                    ],
                }
            },
            net,
        )

    def test_network_info_all(self):
        """
        Test virt.network_info()
        """
        self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV4 = 0
        self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV6 = 1

        net_mocks = []
        # pylint: disable=no-member
        for i in range(2):
            net_mock = MagicMock()

            net_mock.name.return_value = "net{}".format(i)
            net_mock.UUIDString.return_value = "some-uuid"
            net_mock.bridgeName.return_value = "br{}".format(i)
            net_mock.autostart.return_value = True
            net_mock.isActive.return_value = False
            net_mock.isPersistent.return_value = True
            net_mock.DHCPLeases.return_value = []
            net_mocks.append(net_mock)
        self.mock_conn.listAllNetworks.return_value = net_mocks
        # pylint: enable=no-member

        net = virt.network_info()
        self.assertEqual(
            {
                "net0": {
                    "uuid": "some-uuid",
                    "bridge": "br0",
                    "autostart": True,
                    "active": False,
                    "persistent": True,
                    "leases": [],
                },
                "net1": {
                    "uuid": "some-uuid",
                    "bridge": "br1",
                    "autostart": True,
                    "active": False,
                    "persistent": True,
                    "leases": [],
                },
            },
            net,
        )

    def test_network_info_notfound(self):
        """
        Test virt.network_info() when the network can't be found
        """
        # pylint: disable=no-member
        self.mock_conn.listAllNetworks.return_value = []
        # pylint: enable=no-member
        net = virt.network_info("foo")
        self.assertEqual({}, net)

    def test_network_get_xml(self):
        """
        Test virt.network_get_xml
        """
        network_mock = MagicMock()
        network_mock.XMLDesc.return_value = "&lt;net&gt;Raw XML&lt;/net&gt;"
        self.mock_conn.networkLookupByName.return_value = network_mock

        self.assertEqual("&lt;net&gt;Raw XML&lt;/net&gt;", virt.network_get_xml("default"))

    def test_pool(self):
        """
        Test virt._gen_pool_xml()
        """
        xml_data = virt._gen_pool_xml("pool", "logical", "/dev/base")
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find("name").text, "pool")
        self.assertEqual(root.attrib["type"], "logical")
        self.assertEqual(root.find("target/path").text, "/dev/base")

    def test_pool_with_source(self):
        """
        Test virt._gen_pool_xml() with a source device
        """
        xml_data = virt._gen_pool_xml(
            "pool", "logical", "/dev/base", source_devices=[{"path": "/dev/sda"}]
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find("name").text, "pool")
        self.assertEqual(root.attrib["type"], "logical")
        self.assertEqual(root.find("target/path").text, "/dev/base")
        self.assertEqual(root.find("source/device").attrib["path"], "/dev/sda")

    def test_pool_with_scsi(self):
        """
        Test virt._gen_pool_xml() with a SCSI source
        """
        xml_data = virt._gen_pool_xml(
            "pool",
            "scsi",
            "/dev/disk/by-path",
            source_devices=[{"path": "/dev/sda"}],
            source_adapter={
                "type": "scsi_host",
                "parent_address": {
                    "unique_id": 5,
                    "address": {
                        "domain": "0x0000",
                        "bus": "0x00",
                        "slot": "0x1f",
                        "function": "0x2",
                    },
                },
            },
            source_name="srcname",
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find("name").text, "pool")
        self.assertEqual(root.attrib["type"], "scsi")
        self.assertEqual(root.find("target/path").text, "/dev/disk/by-path")
        self.assertEqual(root.find("source/device"), None)
        self.assertEqual(root.find("source/name"), None)
        self.assertEqual(root.find("source/adapter").attrib["type"], "scsi_host")
        self.assertEqual(
            root.find("source/adapter/parentaddr").attrib["unique_id"], "5"
        )
        self.assertEqual(
            root.find("source/adapter/parentaddr/address").attrib["domain"], "0x0000"
        )
        self.assertEqual(
            root.find("source/adapter/parentaddr/address").attrib["bus"], "0x00"
        )
        self.assertEqual(
            root.find("source/adapter/parentaddr/address").attrib["slot"], "0x1f"
        )
        self.assertEqual(
            root.find("source/adapter/parentaddr/address").attrib["function"], "0x2"
        )

    def test_pool_with_rbd(self):
        """
        Test virt._gen_pool_xml() with an RBD source
        """
        xml_data = virt._gen_pool_xml(
            "pool",
            "rbd",
            source_devices=[{"path": "/dev/sda"}],
            source_hosts=["1.2.3.4", "my.ceph.monitor:69"],
            source_auth={
                "type": "ceph",
                "username": "admin",
                "secret": {"type": "uuid", "value": "someuuid"},
            },
            source_name="srcname",
            source_adapter={"type": "scsi_host", "name": "host0"},
            source_dir="/some/dir",
            source_format="fmt",
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find("name").text, "pool")
        self.assertEqual(root.attrib["type"], "rbd")
        self.assertEqual(root.find("target"), None)
        self.assertEqual(root.find("source/device"), None)
        self.assertEqual(root.find("source/name").text, "srcname")
        self.assertEqual(root.find("source/adapter"), None)
        self.assertEqual(root.find("source/dir"), None)
        self.assertEqual(root.find("source/format"), None)
        self.assertEqual(root.findall("source/host")[0].attrib["name"], "1.2.3.4")
        self.assertTrue("port" not in root.findall("source/host")[0].attrib)
        self.assertEqual(
            root.findall("source/host")[1].attrib["name"], "my.ceph.monitor"
        )
        self.assertEqual(root.findall("source/host")[1].attrib["port"], "69")
        self.assertEqual(root.find("source/auth").attrib["type"], "ceph")
        self.assertEqual(root.find("source/auth").attrib["username"], "admin")
        self.assertEqual(root.find("source/auth/secret").attrib["uuid"], "someuuid")

    def test_pool_with_netfs(self):
        """
        Test virt._gen_pool_xml() with a netfs source
        """
        xml_data = virt._gen_pool_xml(
            "pool",
            "netfs",
            target="/path/to/target",
            permissions={
                "mode": "0770",
                "owner": 1000,
                "group": 100,
                "label": "seclabel",
            },
            source_devices=[{"path": "/dev/sda"}],
            source_hosts=["nfs.host"],
            source_name="srcname",
            source_adapter={"type": "scsi_host", "name": "host0"},
            source_dir="/some/dir",
            source_format="nfs",
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find("name").text, "pool")
        self.assertEqual(root.attrib["type"], "netfs")
        self.assertEqual(root.find("target/path").text, "/path/to/target")
        self.assertEqual(root.find("target/permissions/mode").text, "0770")
        self.assertEqual(root.find("target/permissions/owner").text, "1000")
        self.assertEqual(root.find("target/permissions/group").text, "100")
        self.assertEqual(root.find("target/permissions/label").text, "seclabel")
        self.assertEqual(root.find("source/device"), None)
        self.assertEqual(root.find("source/name"), None)
        self.assertEqual(root.find("source/adapter"), None)
        self.assertEqual(root.find("source/dir").attrib["path"], "/some/dir")
        self.assertEqual(root.find("source/format").attrib["type"], "nfs")
        self.assertEqual(root.find("source/host").attrib["name"], "nfs.host")
        self.assertEqual(root.find("source/auth"), None)

    def test_pool_with_iscsi_direct(self):
        """
        Test virt._gen_pool_xml() with a iscsi-direct source
        """
        xml_data = virt._gen_pool_xml(
            "pool",
            "iscsi-direct",
            source_hosts=["iscsi.example.com"],
            source_devices=[{"path": "iqn.2013-06.com.example:iscsi-pool"}],
            source_initiator="iqn.2013-06.com.example:iscsi-initiator",
        )
        root = ET.fromstring(xml_data)
        self.assertEqual(root.find("name").text, "pool")
        self.assertEqual(root.attrib["type"], "iscsi-direct")
        self.assertEqual(root.find("target"), None)
        self.assertEqual(
            root.find("source/device").attrib["path"],
            "iqn.2013-06.com.example:iscsi-pool",
        )
        self.assertEqual(
            root.findall("source/host")[0].attrib["name"], "iscsi.example.com"
        )
        self.assertEqual(
            root.find("source/initiator/iqn").attrib["name"],
            "iqn.2013-06.com.example:iscsi-initiator",
        )

    def test_pool_define(self):
        """
        Test virt.pool_define()
        """
        mock_pool = MagicMock()
        mock_secret = MagicMock()
        mock_secret_define = MagicMock(return_value=mock_secret)
        self.mock_conn.secretDefineXML = mock_secret_define
        self.mock_conn.storagePoolCreateXML = MagicMock(return_value=mock_pool)
        self.mock_conn.storagePoolDefineXML = MagicMock(return_value=mock_pool)

        mocks = [
            mock_pool,
            mock_secret,
            mock_secret_define,
            self.mock_conn.storagePoolCreateXML,
            self.mock_conn.secretDefineXML,
            self.mock_conn.storagePoolDefineXML,
        ]

        # Test case with already defined secret and permanent pool
        self.assertTrue(
            virt.pool_define(
                "default",
                "rbd",
<a name="32"></a>                source_hosts=["one.example.com", "two.example.com"],
                source_name="rbdvol",
                source_auth={
                    <font color="#5b8daf"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"type": "ceph",
                    "username": "admin",
                    "secret": {"type": "uuid", "value": "someuuid"},
                },
            )
        )
        self.mock_conn.storagePoolDefineXML.assert_called_once()
        self.mock_conn.storagePoolCreateXML.assert_not_called()
        mock_pool.create.</b></font>assert_called_once()
        mock_secret_define.assert_not_called()

        # Test case with Ceph secret to be defined and transient pool
        for mock in mocks:
            mock.reset_mock()
        self.assertTrue(
            virt.pool_define(
                "default",
                "rbd",
                transient=True,
                source_hosts=["one.example.com", "two.example.com"],
                source_name="rbdvol",
                source_auth={"username": "admin", "password": "c2VjcmV0"},
            )
        )
        self.mock_conn.storagePoolDefineXML.assert_not_called()

        pool_xml = self.mock_conn.storagePoolCreateXML.call_args[0][0]
        root = ET.fromstring(pool_xml)
        self.assertEqual(root.find("source/auth").attrib["type"], "ceph")
        self.assertEqual(root.find("source/auth").attrib["username"], "admin")
        self.assertEqual(
            root.find("source/auth/secret").attrib["usage"], "pool_default"
        )
        mock_pool.create.assert_not_called()
        mock_secret.setValue.assert_called_once_with(b"secret")

        secret_xml = mock_secret_define.call_args[0][0]
        root = ET.fromstring(secret_xml)
        self.assertEqual(root.find("usage/name").text, "pool_default")
        self.assertEqual(root.find("usage").attrib["type"], "ceph")
        self.assertEqual(root.attrib["private"], "yes")
        self.assertEqual(
            root.find("description").text, "Passphrase for default pool created by Salt"
        )

        # Test case with iscsi secret not starting
        for mock in mocks:
            mock.reset_mock()
        self.assertTrue(
            virt.pool_define(
                "default",
                "iscsi",
                target="/dev/disk/by-path",
                source_hosts=["iscsi.example.com"],
                source_devices=[{"path": "iqn.2013-06.com.example:iscsi-pool"}],
                source_auth={"username": "admin", "password": "secret"},
                start=False,
            )
        )
        self.mock_conn.storagePoolCreateXML.assert_not_called()

        pool_xml = self.mock_conn.storagePoolDefineXML.call_args[0][0]
        root = ET.fromstring(pool_xml)
        self.assertEqual(root.find("source/auth").attrib["type"], "chap")
        self.assertEqual(root.find("source/auth").attrib["username"], "admin")
        self.assertEqual(
            root.find("source/auth/secret").attrib["usage"], "pool_default"
        )
        mock_pool.create.assert_not_called()
        mock_secret.setValue.assert_called_once_with("secret")

        secret_xml = mock_secret_define.call_args[0][0]
        root = ET.fromstring(secret_xml)
        self.assertEqual(root.find("usage/target").text, "pool_default")
        self.assertEqual(root.find("usage").attrib["type"], "iscsi")
        self.assertEqual(root.attrib["private"], "yes")
        self.assertEqual(
            root.find("description").text, "Passphrase for default pool created by Salt"
        )

    def test_list_pools(self):
        """
        Test virt.list_pools()
        """
        names = ["pool1", "default", "pool2"]
        pool_mocks = [MagicMock(), MagicMock(), MagicMock()]
        for i, value in enumerate(names):
            pool_mocks[i].name.return_value = value

        self.mock_conn.listAllStoragePools.return_value = (
            pool_mocks  # pylint: disable=no-member
        )
        actual = virt.list_pools()
        self.assertEqual(names, actual)

    def test_pool_info(self):
        """
        Test virt.pool_info()
        """
        # pylint: disable=no-member
        pool_mock = MagicMock()
        pool_mock.name.return_value = "foo"
        pool_mock.UUIDString.return_value = "some-uuid"
        pool_mock.info.return_value = [0, 1234, 5678, 123]
        pool_mock.autostart.return_value = True
        pool_mock.isPersistent.return_value = True
        pool_mock.XMLDesc.return_value = """&lt;pool type='dir'&gt;
  &lt;name&gt;default&lt;/name&gt;
  &lt;uuid&gt;d92682d0-33cf-4e10-9837-a216c463e158&lt;/uuid&gt;
  &lt;capacity unit='bytes'&gt;854374301696&lt;/capacity&gt;
  &lt;allocation unit='bytes'&gt;596275986432&lt;/allocation&gt;
  &lt;available unit='bytes'&gt;258098315264&lt;/available&gt;
  &lt;source&gt;
  &lt;/source&gt;
  &lt;target&gt;
    &lt;path&gt;/srv/vms&lt;/path&gt;
    &lt;permissions&gt;
      &lt;mode&gt;0755&lt;/mode&gt;
      &lt;owner&gt;0&lt;/owner&gt;
      &lt;group&gt;0&lt;/group&gt;
    &lt;/permissions&gt;
  &lt;/target&gt;
&lt;/pool&gt;"""
        self.mock_conn.listAllStoragePools.return_value = [pool_mock]
        # pylint: enable=no-member

        pool = virt.pool_info("foo")
        self.assertEqual(
            {
                "foo": {
                    "uuid": "some-uuid",
                    "state": "inactive",
                    "capacity": 1234,
                    "allocation": 5678,
                    "free": 123,
                    "autostart": True,
                    "persistent": True,
                    "type": "dir",
                    "target_path": "/srv/vms",
                }
            },
            pool,
        )

    def test_pool_info_notarget(self):
        """
        Test virt.pool_info()
        """
        # pylint: disable=no-member
        pool_mock = MagicMock()
        pool_mock.name.return_value = "ceph"
        pool_mock.UUIDString.return_value = "some-uuid"
        pool_mock.info.return_value = [0, 0, 0, 0]
        pool_mock.autostart.return_value = True
        pool_mock.isPersistent.return_value = True
        pool_mock.XMLDesc.return_value = """&lt;pool type='rbd'&gt;
  &lt;name&gt;ceph&lt;/name&gt;
  &lt;uuid&gt;some-uuid&lt;/uuid&gt;
  &lt;capacity unit='bytes'&gt;0&lt;/capacity&gt;
  &lt;allocation unit='bytes'&gt;0&lt;/allocation&gt;
  &lt;available unit='bytes'&gt;0&lt;/available&gt;
  &lt;source&gt;
    &lt;host name='localhost' port='6789'/&gt;
    &lt;host name='localhost' port='6790'/&gt;
    &lt;name&gt;rbd&lt;/name&gt;
    &lt;auth type='ceph' username='admin'&gt;
      &lt;secret uuid='2ec115d7-3a88-3ceb-bc12-0ac909a6fd87'/&gt;
    &lt;/auth&gt;
  &lt;/source&gt;
&lt;/pool&gt;"""
        self.mock_conn.listAllStoragePools.return_value = [pool_mock]
        # pylint: enable=no-member

        pool = virt.pool_info("ceph")
        self.assertEqual(
            {
                "ceph": {
                    "uuid": "some-uuid",
                    "state": "inactive",
                    "capacity": 0,
                    "allocation": 0,
                    "free": 0,
                    "autostart": True,
                    "persistent": True,
                    "type": "rbd",
                    "target_path": None,
                }
            },
            pool,
        )

    def test_pool_info_notfound(self):
        """
        Test virt.pool_info() when the pool can't be found
        """
        # pylint: disable=no-member
        self.mock_conn.listAllStoragePools.return_value = []
        # pylint: enable=no-member
        pool = virt.pool_info("foo")
        self.assertEqual({}, pool)

    def test_pool_info_all(self):
        """
        Test virt.pool_info()
        """
        # pylint: disable=no-member
        pool_mocks = []
        for i in range(2):
            pool_mock = MagicMock()
            pool_mock.name.return_value = "pool{}".format(i)
            pool_mock.UUIDString.return_value = "some-uuid-{}".format(i)
            pool_mock.info.return_value = [0, 1234, 5678, 123]
            pool_mock.autostart.return_value = True
            pool_mock.isPersistent.return_value = True
            pool_mock.XMLDesc.return_value = """&lt;pool type='dir'&gt;
  &lt;name&gt;default&lt;/name&gt;
  &lt;uuid&gt;d92682d0-33cf-4e10-9837-a216c463e158&lt;/uuid&gt;
  &lt;capacity unit='bytes'&gt;854374301696&lt;/capacity&gt;
  &lt;allocation unit='bytes'&gt;596275986432&lt;/allocation&gt;
  &lt;available unit='bytes'&gt;258098315264&lt;/available&gt;
  &lt;source&gt;
  &lt;/source&gt;
  &lt;target&gt;
    &lt;path&gt;/srv/vms&lt;/path&gt;
    &lt;permissions&gt;
      &lt;mode&gt;0755&lt;/mode&gt;
      &lt;owner&gt;0&lt;/owner&gt;
      &lt;group&gt;0&lt;/group&gt;
    &lt;/permissions&gt;
  &lt;/target&gt;
&lt;/pool&gt;"""
            pool_mocks.append(pool_mock)
        self.mock_conn.listAllStoragePools.return_value = pool_mocks
        # pylint: enable=no-member

        pool = virt.pool_info()
        self.assertEqual(
            {
                "pool0": {
                    "uuid": "some-uuid-0",
                    "state": "inactive",
                    "capacity": 1234,
                    "allocation": 5678,
                    "free": 123,
                    "autostart": True,
                    "persistent": True,
                    "type": "dir",
                    "target_path": "/srv/vms",
                },
                "pool1": {
                    "uuid": "some-uuid-1",
                    "state": "inactive",
                    "capacity": 1234,
                    "allocation": 5678,
                    "free": 123,
                    "autostart": True,
                    "persistent": True,
                    "type": "dir",
                    "target_path": "/srv/vms",
                },
            },
            pool,
        )

    def test_pool_get_xml(self):
        """
        Test virt.pool_get_xml
        """
        pool_mock = MagicMock()
        pool_mock.XMLDesc.return_value = "&lt;pool&gt;Raw XML&lt;/pool&gt;"
        self.mock_conn.storagePoolLookupByName.return_value = pool_mock

        self.assertEqual("&lt;pool&gt;Raw XML&lt;/pool&gt;", virt.pool_get_xml("default"))

    def test_pool_list_volumes(self):
        """
        Test virt.pool_list_volumes
        """
        names = ["volume1", "volume2"]
        mock_pool = MagicMock()
        # pylint: disable=no-member
        mock_pool.listVolumes.return_value = names
        self.mock_conn.storagePoolLookupByName.return_value = mock_pool
        # pylint: enable=no-member
        self.assertEqual(names, virt.pool_list_volumes("default"))

    @patch("salt.modules.virt._is_bhyve_hyper", return_value=False)
    @patch("salt.modules.virt._is_kvm_hyper", return_value=True)
    @patch("salt.modules.virt._is_xen_hyper", return_value=False)
    def test_get_hypervisor(self, isxen_mock, iskvm_mock, is_bhyve_mock):
        """
        test the virt.get_hypervisor() function
        """
        self.assertEqual("kvm", virt.get_hypervisor())

        iskvm_mock.return_value = False
        self.assertIsNone(virt.get_hypervisor())

        is_bhyve_mock.return_value = False
        self.assertIsNone(virt.get_hypervisor())

        isxen_mock.return_value = True
        self.assertEqual("xen", virt.get_hypervisor())

    def test_pool_delete(self):
        """
        Test virt.pool_delete function
        """
        mock_pool = MagicMock()
        mock_pool.delete = MagicMock(return_value=0)
        self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mock_pool)

        res = virt.pool_delete("test-pool")
        self.assertTrue(res)

        self.mock_conn.storagePoolLookupByName.assert_called_once_with("test-pool")

        # Shouldn't be called with another parameter so far since those are not implemented
        # and thus throwing exceptions.
        mock_pool.delete.assert_called_once_with(
            self.mock_libvirt.VIR_STORAGE_POOL_DELETE_NORMAL
        )

    def test_pool_undefine_secret(self):
        """
        Test virt.pool_undefine function where the pool has a secret
        """
        mock_pool = MagicMock()
        mock_pool.undefine = MagicMock(return_value=0)
        mock_pool.XMLDesc.return_value = """
            &lt;pool type='rbd'&gt;
              &lt;name&gt;test-ses&lt;/name&gt;
              &lt;source&gt;
                &lt;host name='myhost'/&gt;
                &lt;name&gt;libvirt-pool&lt;/name&gt;
                &lt;auth type='ceph' username='libvirt'&gt;
                  &lt;secret usage='pool_test-ses'/&gt;
                &lt;/auth&gt;
              &lt;/source&gt;
            &lt;/pool&gt;
        """
        self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mock_pool)
        mock_undefine = MagicMock(return_value=0)
<a name="16"></a>        self.mock_conn.secretLookupByUsage.return_value.undefine = mock_undefine

        res = virt.pool_undefine("test-ses")
        self<font color="#2981b2"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertTrue(res)

        self.mock_conn.storagePoolLookupByName.assert_called_once_with("test-ses")
        mock_pool.undefine.assert_called_once_with()

        self.mock_conn.secretLookupByUsage.assert_called_once_with(
            self.mock_libvirt.VIR_SECRET_USAGE_TYPE_CEPH, "pool_test-ses"
        )
        mock_undefine.</b></font>assert_called_once()

    def test_full_info(self):
        """
        Test virt.full_info
        """
        xml = """&lt;domain type='kvm' id='7'&gt;
              &lt;uuid&gt;28deee33-4859-4f23-891c-ee239cffec94&lt;/uuid&gt;
              &lt;name&gt;test-vm&lt;/name&gt;
              &lt;on_poweroff&gt;destroy&lt;/on_poweroff&gt;
              &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
              &lt;on_crash&gt;destroy&lt;/on_crash&gt;
              &lt;devices&gt;
                &lt;disk type='file' device='disk'&gt;
                &lt;driver name='qemu' type='qcow2'/&gt;
                &lt;source file='/disks/test.qcow2'/&gt;
                &lt;target dev='vda' bus='virtio'/&gt;
              &lt;/disk&gt;
              &lt;disk type='file' device='cdrom'&gt;
                &lt;driver name='qemu' type='raw'/&gt;
                &lt;source file='/disks/test-cdrom.iso'/&gt;
                &lt;target dev='hda' bus='ide'/&gt;
                &lt;readonly/&gt;
              &lt;/disk&gt;
              &lt;interface type='bridge'&gt;
                &lt;mac address='ac:de:48:b6:8b:59'/&gt;
                &lt;source bridge='br0'/&gt;
                &lt;model type='virtio'/&gt;
                &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x03' function='0x0'/&gt;
              &lt;/interface&gt;
              &lt;graphics type='vnc' port='5900' autoport='yes' listen='0.0.0.0'&gt;
                &lt;listen type='address' address='0.0.0.0'/&gt;
              &lt;/graphics&gt;
              &lt;/devices&gt;
            &lt;/domain&gt;
        """
        self.set_mock_vm("test-vm", xml)

        qemu_infos = """[{
            "virtual-size": 25769803776,
            "filename": "/disks/test.qcow2",
            "cluster-size": 65536,
            "format": "qcow2",
            "actual-size": 217088,
            "format-specific": {
                "type": "qcow2",
                "data": {
                    "compat": "1.1",
                    "lazy-refcounts": false,
                    "refcount-bits": 16,
                    "corrupt": false
                }
            },
            "full-backing-filename": "/disks/mybacking.qcow2",
            "backing-filename": "mybacking.qcow2",
            "dirty-flag": false
        },
        {
            "virtual-size": 25769803776,
            "filename": "/disks/mybacking.qcow2",
            "cluster-size": 65536,
            "format": "qcow2",
            "actual-size": 393744384,
            "format-specific": {
                "type": "qcow2",
                "data": {
                    "compat": "1.1",
                    "lazy-refcounts": false,
                    "refcount-bits": 16,
                    "corrupt": false
                }
            },
            "dirty-flag": false
        }]"""

        self.mock_popen.communicate.return_value = [qemu_infos, ""]
        self.mock_popen.returncode = 0

        self.mock_conn.getInfo = MagicMock(
            return_value=["x86_64", 4096, 8, 2712, 1, 2, 4, 2]
        )

        actual = virt.full_info()

<a name="15"></a>        # Check that qemu-img was called with the proper parameters
        qemu_img_call = [
            call
            for call in self.mock_subprocess.Popen<font color="#f52887"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.call_args_list
            if "qemu-img" in call[0][0]
        ][0]
        self.assertIn("info", qemu_img_call[0][0])
        self.assertIn("-U", qemu_img_call[0][0])

<a name="7"></a>        # Test the hypervisor infos
        self.assertEqual(2816, actual["freemem"])
        self.</b></font>assertEqual(6, actual["freecpu"])
        self.assertEqual(4, actual<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["node_info"]["cpucores"])
        self.assertEqual(2712, actual["node_info"]["cpumhz"])
        self.assertEqual("x86_64", actual["node_info"]["cpumodel"])
<a name="4"></a>        self.assertEqual(8, actual["node_info"]["cpus"])
        self.assertEqual(2, actual["node_info"]["cputhreads"])
        self.assertEqual(1, actual["node_info"]["numanodes"])
        self.</b></font>assertEqual(4096, actual<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["node_info"]["phymemory"])
        self.assertEqual(2, actual["node_info"]["sockets"])

        # Test the vm_info output:
        self.assertEqual(2, actual["vm_info"]["test-vm"]["cpu"])
<a name="21"></a>        self.assertEqual(1234, actual["vm_info"]["test-vm"]["cputime"])
        self.assertEqual(1024 * 1024, actual["vm_info"]["test-vm"]["mem"])
        self.assertEqual(2048 * 1024, actual["vm_info"]["test-vm"]["maxMem"])
        self.</b></font>assertEqual("shutdown", actual<font color="#947010"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["vm_info"]["test-vm"]["state"])
        self.assertEqual(
            "28deee33-4859-4f23-891c-ee239cffec94", actual["vm_info"]["test-vm"]["uuid"]
        )
        self.assertEqual("destroy", actual["vm_info"]["test-vm"]["on_crash"])
        self.</b></font>assertEqual("restart", actual["vm_info"]["test-vm"]["on_reboot"])
        self.assertEqual("destroy", actual["vm_info"]["test-vm"]["on_poweroff"])

        # Test the nics
        nic = actual["vm_info"]["test-vm"]["nics"]["ac:de:48:b6:8b:59"]
        self.assertEqual("bridge", nic["type"])
        self.assertEqual("ac:de:48:b6:8b:59", nic["mac"])

        # Test the disks
        disks = actual["vm_info"]["test-vm"]["disks"]
        disk = disks.get("vda")
        self.assertEqual("/disks/test.qcow2", disk["file"])
        self.assertEqual("disk", disk["type"])
        self.assertEqual("/disks/mybacking.qcow2", disk["backing file"]["file"])
        cdrom = disks.get("hda")
        self.assertEqual("/disks/test-cdrom.iso", cdrom["file"])
        self.assertEqual("cdrom", cdrom["type"])
        self.assertFalse("backing file" in cdrom.keys())

        # Test the graphics
        graphics = actual["vm_info"]["test-vm"]["graphics"]
        self.assertEqual("vnc", graphics["type"])
        self.assertEqual("5900", graphics["port"])
        self.assertEqual("0.0.0.0", graphics["listen"])

    def test_pool_update(self):
        """
        Test the pool_update function
        """
        current_xml = """&lt;pool type='dir'&gt;
          &lt;name&gt;default&lt;/name&gt;
          &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
          &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
          &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
          &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
          &lt;source&gt;
          &lt;/source&gt;
          &lt;target&gt;
            &lt;path&gt;/path/to/pool&lt;/path&gt;
            &lt;permissions&gt;
              &lt;mode&gt;0775&lt;/mode&gt;
              &lt;owner&gt;0&lt;/owner&gt;
              &lt;group&gt;100&lt;/group&gt;
            &lt;/permissions&gt;
          &lt;/target&gt;
        &lt;/pool&gt;"""

        expected_xml = (
            '&lt;pool type="netfs"&gt;'
            "&lt;name&gt;default&lt;/name&gt;"
            "&lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;"
            '&lt;capacity unit="bytes"&gt;1999421108224&lt;/capacity&gt;'
            '&lt;allocation unit="bytes"&gt;713207042048&lt;/allocation&gt;'
            '&lt;available unit="bytes"&gt;1286214066176&lt;/available&gt;'
            "&lt;target&gt;"
            "&lt;path&gt;/mnt/cifs&lt;/path&gt;"
            "&lt;permissions&gt;"
            "&lt;mode&gt;0774&lt;/mode&gt;"
            "&lt;owner&gt;1234&lt;/owner&gt;"
            "&lt;group&gt;123&lt;/group&gt;"
            "&lt;/permissions&gt;"
            "&lt;/target&gt;"
            "&lt;source&gt;"
            '&lt;dir path="samba_share" /&gt;'
            '&lt;host name="one.example.com" /&gt;'
            '&lt;host name="two.example.com" /&gt;'
            '&lt;format type="cifs" /&gt;'
            "&lt;/source&gt;"
            "&lt;/pool&gt;"
        )

        mocked_pool = MagicMock()
        mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
        self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
        self.mock_conn.storagePoolDefineXML = MagicMock()

        self.assertTrue(
            virt.pool_update(
                "default",
                "netfs",
                target="/mnt/cifs",
                permissions={"mode": "0774", "owner": "1234", "group": "123"},
                source_format="cifs",
                source_dir="samba_share",
                source_hosts=["one.example.com", "two.example.com"],
            )
        )
        self.mock_conn.storagePoolDefineXML.assert_called_once_with(expected_xml)

    def test_pool_update_nochange(self):
        """
        Test the pool_update function when no change is needed
        """

        current_xml = """&lt;pool type='dir'&gt;
          &lt;name&gt;default&lt;/name&gt;
          &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
          &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
          &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
          &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
          &lt;source&gt;
          &lt;/source&gt;
          &lt;target&gt;
            &lt;path&gt;/path/to/pool&lt;/path&gt;
            &lt;permissions&gt;
              &lt;mode&gt;0775&lt;/mode&gt;
              &lt;owner&gt;0&lt;/owner&gt;
              &lt;group&gt;100&lt;/group&gt;
            &lt;/permissions&gt;
          &lt;/target&gt;
        &lt;/pool&gt;"""

        mocked_pool = MagicMock()
        mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
        self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
        self.mock_conn.storagePoolDefineXML = MagicMock()

        self.assertFalse(
            virt.pool_update(
                "default",
                "dir",
                target="/path/to/pool",
                permissions={"mode": "0775", "owner": "0", "group": "100"},
                test=True,
            )
        )
        self.mock_conn.storagePoolDefineXML.assert_not_called()

    def test_pool_update_password(self):
        """
        Test the pool_update function, where the password only is changed
        """
        current_xml = """&lt;pool type='rbd'&gt;
          &lt;name&gt;default&lt;/name&gt;
          &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
          &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
          &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
          &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
          &lt;source&gt;
            &lt;name&gt;iscsi-images&lt;/name&gt;
            &lt;host name='ses4.tf.local'/&gt;
            &lt;host name='ses5.tf.local'/&gt;
            &lt;auth username='libvirt' type='ceph'&gt;
              &lt;secret uuid='14e9a0f1-8fbf-4097-b816-5b094c182212'/&gt;
            &lt;/auth&gt;
          &lt;/source&gt;
        &lt;/pool&gt;"""

        mock_secret = MagicMock()
        self.mock_conn.secretLookupByUUIDString = MagicMock(return_value=mock_secret)

        mocked_pool = MagicMock()
        mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
        self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
        self.mock_conn.storagePoolDefineXML = MagicMock()

        self.assertFalse(
            virt.pool_update(
                "default",
                "rbd",
                source_name="iscsi-images",
                source_hosts=["ses4.tf.local", "ses5.tf.local"],
                source_auth={"username": "libvirt", "password": "c2VjcmV0"},
            )
        )
        self.mock_conn.storagePoolDefineXML.assert_not_called()
        mock_secret.setValue.assert_called_once_with(b"secret")

        # Case where the secret can't be found
        self.mock_conn.secretLookupByUUIDString = MagicMock(
            side_effect=self.mock_libvirt.libvirtError("secret not found")
        )
        self.assertFalse(
            virt.pool_update(
                "default",
                "rbd",
                source_name="iscsi-images",
                source_hosts=["ses4.tf.local", "ses5.tf.local"],
                source_auth={"username": "libvirt", "password": "c2VjcmV0"},
            )
        )
        self.mock_conn.storagePoolDefineXML.assert_not_called()
        self.mock_conn.secretDefineXML.assert_called_once()
        mock_secret.setValue.assert_called_once_with(b"secret")

    def test_pool_update_password_create(self):
        """
        Test the pool_update function, where the password only is changed
        """
        current_xml = """&lt;pool type='rbd'&gt;
          &lt;name&gt;default&lt;/name&gt;
          &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
          &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
          &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
          &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
          &lt;source&gt;
            &lt;name&gt;iscsi-images&lt;/name&gt;
            &lt;host name='ses4.tf.local'/&gt;
            &lt;host name='ses5.tf.local'/&gt;
          &lt;/source&gt;
        &lt;/pool&gt;"""

        expected_xml = (
            '&lt;pool type="rbd"&gt;'
            "&lt;name&gt;default&lt;/name&gt;"
            "&lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;"
            '&lt;capacity unit="bytes"&gt;1999421108224&lt;/capacity&gt;'
            '&lt;allocation unit="bytes"&gt;713207042048&lt;/allocation&gt;'
            '&lt;available unit="bytes"&gt;1286214066176&lt;/available&gt;'
            "&lt;source&gt;"
            '&lt;host name="ses4.tf.local" /&gt;'
            '&lt;host name="ses5.tf.local" /&gt;'
            '&lt;auth type="ceph" username="libvirt"&gt;'
            '&lt;secret usage="pool_default" /&gt;'
            "&lt;/auth&gt;"
            "&lt;name&gt;iscsi-images&lt;/name&gt;"
            "&lt;/source&gt;"
            "&lt;/pool&gt;"
        )

        mock_secret = MagicMock()
        self.mock_conn.secretDefineXML = MagicMock(return_value=mock_secret)

        mocked_pool = MagicMock()
        mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
        self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
        self.mock_conn.storagePoolDefineXML = MagicMock()

        self.assertTrue(
            virt.pool_update(
                "default",
                "rbd",
                source_name="iscsi-images",
                source_hosts=["ses4.tf.local", "ses5.tf.local"],
                source_auth={"username": "libvirt", "password": "c2VjcmV0"},
            )
        )
        self.mock_conn.storagePoolDefineXML.assert_called_once_with(expected_xml)
        mock_secret.setValue.assert_called_once_with(b"secret")

    def test_volume_infos(self):
        """
        Test virt.volume_infos
        """
        vms_disks = [
            """
                &lt;disk type='file' device='disk'&gt;
                  &lt;driver name='qemu' type='qcow2'/&gt;
                  &lt;source file='/path/to/vol0.qcow2'/&gt;
                  &lt;target dev='vda' bus='virtio'/&gt;
                &lt;/disk&gt;
            """,
            """
                &lt;disk type='file' device='disk'&gt;
                  &lt;driver name='qemu' type='qcow2'/&gt;
                  &lt;source file='/path/to/vol3.qcow2'/&gt;
                  &lt;target dev='vda' bus='virtio'/&gt;
                &lt;/disk&gt;
            """,
            """
                &lt;disk type='file' device='disk'&gt;
                  &lt;driver name='qemu' type='qcow2'/&gt;
                  &lt;source file='/path/to/vol2.qcow2'/&gt;
                  &lt;target dev='vda' bus='virtio'/&gt;
                &lt;/disk&gt;
            """,
        ]
        mock_vms = []
        for idx, disk in enumerate(vms_disks):
            vm = MagicMock()
            # pylint: disable=no-member
            vm.name.return_value = "vm{}".format(idx)
            vm.XMLDesc.return_value = """
                    &lt;domain type='kvm' id='1'&gt;
                      &lt;name&gt;vm{}&lt;/name&gt;
                      &lt;devices&gt;{}&lt;/devices&gt;
                    &lt;/domain&gt;
                """.format(
                idx, disk
            )
            # pylint: enable=no-member
<a name="17"></a>            mock_vms.append(vm)

        mock_pool_data = [
            <font color="#3090c7"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
                "name": "pool0",
                "state": self.mock_libvirt.VIR_STORAGE_POOL_RUNNING,
                "volumes": [
                    {
                        "key": "/key/of/vol0",
                        "name": "vol0",
                        "path": "/path/to/vol0.qcow2",
                        "info": [0, 123456789, 123456],
                        "backingStore": None,
                    }
                ],
            },
            {
                "name": "pool1",
                "state": self.mock_libvirt.VIR_STORAGE_POOL_RUNNING,
                "volumes": [
                    {
                        "key": "/key/of/vol0bad",
                        "name": "vol0bad",
                        "path": "/path/to/vol0bad.qcow2",
                        "info": None,
                        "backingStore": None,
                    },
                    {
                        "key": "/key/of/vol1",
                        "name": "vol1",
                        "path": "/path/to/vol1.qcow2",
                        "info": [0, 12345, 1234],
                        "backingStore": None,
                    },
                    {
                        "key": "/key/of/vol2",
                        "name": "vol2",
                        "path": "/path/to/vol2.qcow2",
                        "info": [0</b></font>, 12345, 1234],
                        "backingStore": "/path/to/vol0.qcow2",
                    },
                ],
            },
        ]
        mock_pools = []
        for pool_data in mock_pool_data:
            mock_pool = MagicMock()
            mock_pool.name.return_value = pool_data["name"]  # pylint: disable=no-member
            mock_pool.info.return_value = [pool_data["state"]]
            mock_volumes = []
            for vol_data in pool_data["volumes"]:
                mock_volume = MagicMock()
                # pylint: disable=no-member
                mock_volume.name.return_value = vol_data["name"]
                mock_volume.key.return_value = vol_data["key"]
                mock_volume.path.return_value = "/path/to/{}.qcow2".format(
                    vol_data["name"]
                )
                if vol_data["info"]:
                    mock_volume.info.return_value = vol_data["info"]
                    backing_store = (
                        """
                        &lt;backingStore&gt;
                          &lt;format type="qcow2"/&gt;
                          &lt;path&gt;{}&lt;/path&gt;
                        &lt;/backingStore&gt;
                    """.format(
                            vol_data["backingStore"]
                        )
                        if vol_data["backingStore"]
                        else "&lt;backingStore/&gt;"
                    )
                    mock_volume.XMLDesc.return_value = """
                        &lt;volume type='file'&gt;
                          &lt;name&gt;{0}&lt;/name&gt;
                          &lt;target&gt;
                            &lt;format type="qcow2"/&gt;
                            &lt;path&gt;/path/to/{0}.qcow2&lt;/path&gt;
                          &lt;/target&gt;
                          {1}
                        &lt;/volume&gt;
                    """.format(
                        vol_data["name"], backing_store
                    )
                else:
                    mock_volume.info.side_effect = self.mock_libvirt.libvirtError(
                        "No such volume"
                    )
                    mock_volume.XMLDesc.side_effect = self.mock_libvirt.libvirtError(
                        "No such volume"
                    )
                mock_volumes.append(mock_volume)
                # pylint: enable=no-member
            mock_pool.listAllVolumes.return_value = (
                mock_volumes  # pylint: disable=no-member
            )
            mock_pools.append(mock_pool)

        inactive_pool = MagicMock()
        inactive_pool.name.return_value = "pool2"
        inactive_pool.info.return_value = [self.mock_libvirt.VIR_STORAGE_POOL_INACTIVE]
        inactive_pool.listAllVolumes.side_effect = self.mock_libvirt.libvirtError(
            "pool is inactive"
        )
        mock_pools.append(inactive_pool)

        self.mock_conn.listAllStoragePools.return_value = (
            mock_pools  # pylint: disable=no-member
        )

        with patch("salt.modules.virt._get_domain", MagicMock(return_value=mock_vms)):
<a name="6"></a>            actual = virt.volume_infos("pool0", "vol0")
            self.assertEqual(1, len(actual.keys()))
            self.assertEqual(1, len(actual["pool0"].keys()))
            self.assertEqual(["vm0", "vm2"], sorted(actual["pool0"]<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["vol0"]["used_by"]))
            self.assertEqual("/path/to/vol0.qcow2", actual["pool0"]["vol0"]["path"])
            self.assertEqual("file", actual["pool0"]["vol0"]["type"])
            self.assertEqual("/key/of/vol0", actual["pool0"]["vol0"]["key"])
            self.assertEqual(123456789, actual["pool0"]["vol0"]["capacity"])
            self.</b></font>assertEqual(123456, actual["pool0"]["vol0"]["allocation"])

            self.assertEqual(
                virt.volume_infos("pool1", None),
                {
                    "pool1": {
                        "vol1": {
                            "type": "file",
                            "key": "/key/of/vol1",
                            "path": "/path/to/vol1.qcow2",
                            "capacity": 12345,
                            "allocation": 1234,
                            "used_by": [],
                            "backing_store": None,
                            "format": "qcow2",
                        },
                        "vol2": {
                            "type": "file",
                            "key": "/key/of/vol2",
                            "path": "/path/to/vol2.qcow2",
                            "capacity": 12345,
                            "allocation": 1234,
                            "used_by": ["vm2"],
                            "backing_store": {
                                "path": "/path/to/vol0.qcow2",
                                "format": "qcow2",
                            },
                            "format": "qcow2",
                        },
                    }
                },
            )

            self.assertEqual(
                virt.volume_infos(None, "vol2"),
                {
                    "pool1": {
                        "vol2": {
                            "type": "file",
                            "key": "/key/of/vol2",
                            "path": "/path/to/vol2.qcow2",
                            "capacity": 12345,
                            "allocation": 1234,
                            "used_by": ["vm2"],
                            "backing_store": {
                                "path": "/path/to/vol0.qcow2",
                                "format": "qcow2",
                            },
                            "format": "qcow2",
                        }
                    }
                },
            )

        # Single VM test
        with patch(
            "salt.modules.virt._get_domain", MagicMock(return_value=mock_vms[0])
        ):
<a name="31"></a>            actual = virt.volume_infos("pool0", "vol0")
            self.assertEqual(1, len(actual.keys()))
            self.assertEqual(1, len(actual["pool0"].keys()))
<a name="30"></a>            self.assertEqual(["vm0"], sorted(actual["pool0"]<font color="#3ea99f"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["vol0"]["used_by"]))
            self.assertEqual("/path/to/vol0.qcow2", actual["pool0"]["vol0"]["path"])
            self.assertEqual("file", actual["pool0"]["vol0"][</b></font>"type"])
            self.assertEqual("/key/of/vol0", actual["pool0"]<font color="#ae694a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["vol0"]["key"])
            self.assertEqual(123456789, actual["pool0"]["vol0"]["capacity"])
            self.assertEqual(123456, actual["pool0"]["vol0"][</b></font>"allocation"])

            self.assertEqual(
                virt.volume_infos("pool1", None),
                {
                    "pool1": {
                        "vol1": {
                            "type": "file",
                            "key": "/key/of/vol1",
                            "path": "/path/to/vol1.qcow2",
                            "capacity": 12345,
                            "allocation": 1234,
                            "used_by": [],
                            "backing_store": None,
                            "format": "qcow2",
                        },
                        "vol2": {
                            "type": "file",
                            "key": "/key/of/vol2",
                            "path": "/path/to/vol2.qcow2",
                            "capacity": 12345,
                            "allocation": 1234,
                            "used_by": [],
                            "backing_store": {
                                "path": "/path/to/vol0.qcow2",
                                "format": "qcow2",
                            },
                            "format": "qcow2",
                        },
                    }
                },
            )

            self.assertEqual(
                virt.volume_infos(None, "vol2"),
                {
                    "pool1": {
                        "vol2": {
                            "type": "file",
                            "key": "/key/of/vol2",
                            "path": "/path/to/vol2.qcow2",
                            "capacity": 12345,
                            "allocation": 1234,
                            "used_by": [],
                            "backing_store": {
                                "path": "/path/to/vol0.qcow2",
                                "format": "qcow2",
                            },
                            "format": "qcow2",
                        }
                    }
                },
            )

        # No VM test
        with patch(
            "salt.modules.virt._get_domain",
            MagicMock(side_effect=CommandExecutionError("no VM")),
        ):
            actual = virt.volume_infos("pool0", "vol0")
            self.assertEqual(1, len(actual.keys()))
            self.assertEqual(1, len(actual["pool0"].keys()))
            self.assertEqual([], sorted(actual["pool0"]["vol0"]["used_by"]))
            self.assertEqual("/path/to/vol0.qcow2", actual["pool0"]["vol0"]["path"])
            self.assertEqual("file", actual["pool0"]["vol0"]["type"])
            self.assertEqual("/key/of/vol0", actual["pool0"]["vol0"]["key"])
            self.assertEqual(123456789, actual["pool0"]["vol0"]["capacity"])
            self.assertEqual(123456, actual["pool0"]["vol0"]["allocation"])

            self.assertEqual(
                virt.volume_infos("pool1", None),
                {
                    "pool1": {
                        "vol1": {
                            "type": "file",
                            "key": "/key/of/vol1",
                            "path": "/path/to/vol1.qcow2",
                            "capacity": 12345,
                            "allocation": 1234,
                            "used_by": [],
                            "backing_store": None,
                            "format": "qcow2",
                        },
                        "vol2": {
                            "type": "file",
                            "key": "/key/of/vol2",
                            "path": "/path/to/vol2.qcow2",
                            "capacity": 12345,
                            "allocation": 1234,
                            "used_by": [],
                            "backing_store": {
                                "path": "/path/to/vol0.qcow2",
                                "format": "qcow2",
                            },
                            "format": "qcow2",
                        },
                    }
                },
            )

            self.assertEqual(
                virt.volume_infos(None, "vol2"),
                {
                    "pool1": {
                        "vol2": {
                            "type": "file",
                            "key": "/key/of/vol2",
                            "path": "/path/to/vol2.qcow2",
                            "capacity": 12345,
                            "allocation": 1234,
                            "used_by": [],
                            "backing_store": {
                                "path": "/path/to/vol0.qcow2",
                                "format": "qcow2",
                            },
                            "format": "qcow2",
                        }
                    }
                },
            )

    def test_volume_delete(self):
        """
        Test virt.volume_delete
        """
        mock_delete = MagicMock(side_effect=[0, 1])
        mock_volume = MagicMock()
        mock_volume.delete = mock_delete  # pylint: disable=no-member
        mock_pool = MagicMock()
        # pylint: disable=no-member
        mock_pool.storageVolLookupByName.side_effect = [
            mock_volume,
            mock_volume,
            self.mock_libvirt.libvirtError("Missing volume"),
            mock_volume,
        ]
        self.mock_conn.storagePoolLookupByName.side_effect = [
            mock_pool,
            mock_pool,
            mock_pool,
            self.mock_libvirt.libvirtError("Missing pool"),
        ]

        # pylint: enable=no-member
        self.assertTrue(virt.volume_delete("default", "test_volume"))
        self.assertFalse(virt.volume_delete("default", "test_volume"))
        with self.assertRaises(self.mock_libvirt.libvirtError):
            virt.volume_delete("default", "missing")
            virt.volume_delete("missing", "test_volume")
        self.assertEqual(mock_delete.call_count, 2)

    def test_pool_capabilities(self):
        """
        Test virt.pool_capabilities where libvirt has the pool-capabilities feature
        """
        xml_caps = """
&lt;storagepoolCapabilities&gt;
  &lt;pool type='disk' supported='yes'&gt;
    &lt;poolOptions&gt;
      &lt;defaultFormat type='unknown'/&gt;
      &lt;enum name='sourceFormatType'&gt;
        &lt;value&gt;unknown&lt;/value&gt;
        &lt;value&gt;dos&lt;/value&gt;
        &lt;value&gt;dvh&lt;/value&gt;
      &lt;/enum&gt;
    &lt;/poolOptions&gt;
    &lt;volOptions&gt;
      &lt;defaultFormat type='none'/&gt;
      &lt;enum name='targetFormatType'&gt;
        &lt;value&gt;none&lt;/value&gt;
        &lt;value&gt;linux&lt;/value&gt;
      &lt;/enum&gt;
    &lt;/volOptions&gt;
  &lt;/pool&gt;
  &lt;pool type='iscsi' supported='yes'&gt;
  &lt;/pool&gt;
  &lt;pool type='rbd' supported='yes'&gt;
    &lt;volOptions&gt;
      &lt;defaultFormat type='raw'/&gt;
      &lt;enum name='targetFormatType'&gt;
      &lt;/enum&gt;
    &lt;/volOptions&gt;
  &lt;/pool&gt;
  &lt;pool type='sheepdog' supported='no'&gt;
  &lt;/pool&gt;
&lt;/storagepoolCapabilities&gt;
<a name="14"></a>        """
        self.mock_conn.getStoragePoolCapabilities = MagicMock(return_value=xml_caps)

        actual = virt<font color="#842dce"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.pool_capabilities()
        self.assertEqual(
            {
                "computed": False,
                "pool_types": [
                    {
                        "name": "disk",
                        "supported": True,
                        "options": {
                            "pool": {
                                "default_format": "unknown",
                                "sourceFormatType": ["unknown", "dos", "dvh"],
                            },
                            "volume": {
                                "default_format": "none",
                                "targetFormatType": ["none", "linux"],
                            },
                        },
                    },
                    {"name": "iscsi", "supported": True},
                    {
                        "name": "rbd",
                        "supported": True,
                        "options": {
                            "volume": {"default_format": "raw", "targetFormatType": []}
                        },
                    },
                    {"name"</b></font>: "sheepdog", "supported": False},
                ],
            },
            actual,
        )

    @patch("salt.modules.virt.get_hypervisor", return_value="kvm")
    def test_pool_capabilities_computed(self, mock_get_hypervisor):
        """
        Test virt.pool_capabilities where libvirt doesn't have the pool-capabilities feature
        """
        self.mock_conn.getLibVersion = MagicMock(return_value=4006000)
        del self.mock_conn.getStoragePoolCapabilities

        actual = virt.pool_capabilities()

        self.assertTrue(actual["computed"])
        backends = actual["pool_types"]

        # libvirt version matching check
        self.assertFalse(
            [backend for backend in backends if backend["name"] == "iscsi-direct"][0][
                "supported"
            ]
        )
        self.assertTrue(
            [backend for backend in backends if backend["name"] == "gluster"][0][
                "supported"
            ]
        )
        self.assertFalse(
            [backend for backend in backends if backend["name"] == "zfs"][0][
                "supported"
            ]
        )

        # test case matching other hypervisors
        mock_get_hypervisor.return_value = "xen"
        backends = virt.pool_capabilities()["pool_types"]
        self.assertFalse(
            [backend for backend in backends if backend["name"] == "gluster"][0][
                "supported"
            ]
        )

<a name="8"></a>        mock_get_hypervisor.return_value = "bhyve"
        backends = virt.pool_capabilities()["pool_types"]
        self.assertFalse(
            [backend for backend in backends if backend<font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["name"] == "gluster"][0][
                "supported"
            ]
        )
        self.assertTrue(
            [backend for backend in backends if backend["name"] == "zfs"][0][
                "supported"
            ]
        )

        # Test options output
        self.assertNotIn(
            "options",
            [backend for backend in backends if backend["name"] == "iscsi"][0],
        )
        self.assertNotIn(
            "pool",
            [backend for backend in backends if backend["name"] == "dir"][0]["options"],
        )
        self.assertNotIn(
            "volume",
            [backend for backend in backends if backend["name"] == "logical"][0][
                "options"
            ],
        )
        self.</b></font>assertEqual(
            {
                "pool": {
                    "default_format": "auto",
                    "sourceFormatType": ["auto", "nfs", "glusterfs", "cifs"],
                },
                "volume": {
                    "default_format": "raw",
                    "targetFormatType": [
                        "none",
                        "raw",
                        "dir",
                        "bochs",
                        "cloop",
                        "dmg",
                        "iso",
                        "vpc",
                        "vdi",
                        "fat",
                        "vhd",
                        "ploop",
                        "cow",
                        "qcow",
                        "qcow2",
                        "qed",
                        "vmdk",
                    ],
                },
            },
            [backend for backend in backends if backend["name"] == "netfs"][0][
                "options"
            ],
        )

    def test_get_domain(self):
        """
        Test the virt._get_domain function
        """
        # Tests with no VM
        self.mock_conn.listDomainsID.return_value = []
        self.mock_conn.listDefinedDomains.return_value = []
        self.assertEqual([], virt._get_domain(self.mock_conn))
        self.assertRaisesRegex(
            CommandExecutionError,
            "No virtual machines found.",
            virt._get_domain,
            self.mock_conn,
            "vm2",
        )

        # Test with active and inactive VMs
        self.mock_conn.listDomainsID.return_value = [1]

        def create_mock_vm(idx):
            mock_vm = MagicMock()
            mock_vm.name.return_value = "vm{}".format(idx)
            return mock_vm

        mock_vms = [create_mock_vm(idx) for idx in range(3)]
        self.mock_conn.lookupByID.return_value = mock_vms[0]
        self.mock_conn.listDefinedDomains.return_value = ["vm1", "vm2"]

        self.mock_conn.lookupByName.side_effect = mock_vms
        self.assertEqual(mock_vms, virt._get_domain(self.mock_conn))

        self.mock_conn.lookupByName.side_effect = None
        self.mock_conn.lookupByName.return_value = mock_vms[0]
        self.assertEqual(mock_vms[0], virt._get_domain(self.mock_conn, inactive=False))

        self.mock_conn.lookupByName.return_value = None
        self.mock_conn.lookupByName.side_effect = [mock_vms[1], mock_vms[2]]
        self.assertEqual(
            [mock_vms[1], mock_vms[2]], virt._get_domain(self.mock_conn, active=False)
        )
<a name="18"></a>
        self.mock_conn.reset_mock()
        self.mock_conn.lookupByName.return_value = None
        self.mock_conn.lookupByName.side_effect = [<font color="#800517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>mock_vms[1], mock_vms[2]]
        self.assertEqual(
            [mock_vms[1], mock_vms[2]], virt._get_domain(self.mock_conn, "vm1", "vm2")
        )
        self.assertRaisesRegex(
            CommandExecutionError,
            'The VM "vm2" is not present',
            virt._get_domain,
            self.</b></font>mock_conn,
            "vm2",
            inactive=False,
        )

    def test_volume_define(self):
        """
        Test virt.volume_define function
        """
        # Normal test case
        pool_mock = MagicMock()
        pool_mock.XMLDesc.return_value = "&lt;pool type='dir'&gt;&lt;/pool&gt;"
        self.mock_conn.storagePoolLookupByName.return_value = pool_mock

        self.assertTrue(
            virt.volume_define(
                "testpool",
                "myvm_system.qcow2",
                8192,
                allocation=4096,
                format="qcow2",
                type="file",
            )
        )

        expected_xml = (
            "&lt;volume type='file'&gt;\n"
            "  &lt;name&gt;myvm_system.qcow2&lt;/name&gt;\n"
            "  &lt;source&gt;\n"
            "  &lt;/source&gt;\n"
            "  &lt;capacity unit='KiB'&gt;8388608&lt;/capacity&gt;\n"
            "  &lt;allocation unit='KiB'&gt;4194304&lt;/allocation&gt;\n"
            "  &lt;target&gt;\n"
            "    &lt;format type='qcow2'/&gt;\n"
            "  &lt;/target&gt;\n"
            "&lt;/volume&gt;"
        )

        pool_mock.createXML.assert_called_once_with(expected_xml, 0)

        # backing store test case
        pool_mock.reset_mock()
        self.assertTrue(
            virt.volume_define(
                "testpool",
                "myvm_system.qcow2",
                8192,
                allocation=4096,
                format="qcow2",
                type="file",
                backing_store={"path": "/path/to/base.raw", "format": "raw"},
            )
        )

        expected_xml = (
            "&lt;volume type='file'&gt;\n"
            "  &lt;name&gt;myvm_system.qcow2&lt;/name&gt;\n"
            "  &lt;source&gt;\n"
            "  &lt;/source&gt;\n"
            "  &lt;capacity unit='KiB'&gt;8388608&lt;/capacity&gt;\n"
            "  &lt;allocation unit='KiB'&gt;4194304&lt;/allocation&gt;\n"
            "  &lt;target&gt;\n"
            "    &lt;format type='qcow2'/&gt;\n"
            "  &lt;/target&gt;\n"
            "  &lt;backingStore&gt;\n"
            "    &lt;path&gt;/path/to/base.raw&lt;/path&gt;\n"
            "    &lt;format type='raw'/&gt;\n"
            "  &lt;/backingStore&gt;\n"
            "&lt;/volume&gt;"
        )

        pool_mock.createXML.assert_called_once_with(expected_xml, 0)

        # logical pool test case
        pool_mock.reset_mock()
        pool_mock.XMLDesc.return_value = "&lt;pool type='logical'&gt;&lt;/pool&gt;"
        self.mock_conn.storagePoolLookupByName.return_value = pool_mock

        self.assertTrue(
            virt.volume_define(
                "testVG",
                "myvm_system",
                8192,
                backing_store={"path": "/dev/testVG/base"},
            )
        )

        expected_xml = (
            "&lt;volume&gt;\n"
            "  &lt;name&gt;myvm_system&lt;/name&gt;\n"
            "  &lt;source&gt;\n"
            "  &lt;/source&gt;\n"
            "  &lt;capacity unit='KiB'&gt;8388608&lt;/capacity&gt;\n"
            "  &lt;allocation unit='KiB'&gt;8388608&lt;/allocation&gt;\n"
            "  &lt;target&gt;\n"
            "  &lt;/target&gt;\n"
            "  &lt;backingStore&gt;\n"
            "    &lt;path&gt;/dev/testVG/base&lt;/path&gt;\n"
            "  &lt;/backingStore&gt;\n"
            "&lt;/volume&gt;"
        )

        pool_mock.createXML.assert_called_once_with(expected_xml, 0)

    def test_volume_upload(self):
        """
        Test virt.volume_upload function
        """
        pool_mock = MagicMock()
        vol_mock = MagicMock()
        pool_mock.storageVolLookupByName.return_value = vol_mock
        self.mock_conn.storagePoolLookupByName.return_value = pool_mock
        stream_mock = MagicMock()
        self.mock_conn.newStream.return_value = stream_mock

        open_mock = MagicMock()
        close_mock = MagicMock()
        with patch.dict(
            os.__dict__, {"open": open_mock, "close": close_mock}
<a name="11"></a>        ):  # pylint: disable=no-member
            # Normal case
            self.assertTrue(virt.volume_upload("pool0", "vol1.qcow2", "/path/to/file"))
            stream_mock<font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.sendAll.assert_called_once()
            stream_mock.finish.assert_called_once()
            self.mock_conn.close.assert_called_once()
            vol_mock.upload.assert_called_once_with(stream_mock, 0, 0, 0)

            # Sparse upload case
            stream_mock.sendAll.reset_mock()
            vol_mock.upload.</b></font>reset_mock()
            self.assertTrue(
                virt.volume_upload(
                    "pool0",
                    "vol1.qcow2",
                    "/path/to/file",
                    offset=123,
                    length=456,
<a name="29"></a>                    sparse=True,
                )
            )
            stream_mock<font color="#af7a82"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.sendAll.assert_not_called()
            stream_mock.sparseSendAll.assert_called_once()
            vol_mock.upload.assert_called_once_with(
                stream_mock,
                123,
                456,
                self.mock_libvirt.VIR_STORAGE_VOL_UPLOAD_SPARSE_STREAM,
            )

            # Upload unsupported case
            vol_mock.upload.</b></font>side_effect = self.mock_libvirt.libvirtError("Unsupported")
            self.assertRaisesRegex(
                CommandExecutionError,
                "Unsupported",
                virt.volume_upload,
                "pool0",
                "vol1.qcow2",
                "/path/to/file",
            )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
