<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for qingcloud.py &amp; http.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for qingcloud.py &amp; http.py
      </h3>
<h1 align="center">
        1.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>qingcloud.py (1.9675926%)<th>http.py (1.0793651%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(28-51)<td><a href="#" name="0">(32-49)</a><td align="center"><font color="#ff0000">17</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>qingcloud.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import base64
2 import hmac
3 import logging
4 import pprint
5 import time
6 import urllib.parse
7 from hashlib import sha256
8 import salt.config as config
9 import salt.utils.cloud
10 import salt.utils.data
11 import salt.utils.json
12 from salt.exceptions import (
13     SaltCloudExecutionFailure,
14     SaltCloudExecutionTimeout,
15     SaltCloudNotFound,
16     SaltCloudSystemExit,
17 )
18 try:
19     import requests
20     HAS_REQUESTS = True
21 e</b></font>xcept ImportError:
22     HAS_REQUESTS = False
23 log = logging.getLogger(__name__)
24 __virtualname__ = "qingcloud"
25 DEFAULT_QINGCLOUD_API_VERSION = 1
26 DEFAULT_QINGCLOUD_SIGNATURE_VERSION = 1
27 def __virtual__():
28     if get_configured_provider() is False:
29         return False
30     if get_dependencies() is False:
31         return False
32     return __virtualname__
33 def _get_active_provider_name():
34     try:
35         return __active_provider_name__.value()
36     except AttributeError:
37         return __active_provider_name__
38 def get_configured_provider():
39     return config.is_provider_configured(
40         __opts__,
41         _get_active_provider_name() or __virtualname__,
42         ("access_key_id", "secret_access_key", "zone", "key_filename"),
43     )
44 def get_dependencies():
45     return config.check_driver_dependencies(__virtualname__, {"requests": HAS_REQUESTS})
46 def _compute_signature(parameters, access_key_secret, method, path):
47     parameters["signature_method"] = "HmacSHA256"
48     string_to_sign = "{}\n{}\n".format(method.upper(), path)
49     keys = sorted(parameters.keys())
50     pairs = []
51     for key in keys:
52         val = str(parameters[key]).encode("utf-8")
53         pairs.append(
54             urllib.parse.quote(key, safe="") + "=" + urllib.parse.quote(val, safe="-_~")
55         )
56     qs = "&amp;".join(pairs)
57     string_to_sign += qs
58     h = hmac.new(access_key_secret, digestmod=sha256)
59     h.update(string_to_sign)
60     signature = base64.b64encode(h.digest()).strip()
61     return signature
62 def query(params=None):
63     path = "https://api.qingcloud.com/iaas/"
64     access_key_id = config.get_cloud_config_value(
65         "access_key_id", get_configured_provider(), __opts__, search_global=False
66     )
67     access_key_secret = config.get_cloud_config_value(
68         "secret_access_key", get_configured_provider(), __opts__, search_global=False
69     )
70     verify_ssl = config.get_cloud_config_value(
71         "verify_ssl",
72         get_configured_provider(),
73         __opts__,
74         default=True,
75         search_global=False,
76     )
77     real_parameters = {
78         "access_key_id": access_key_id,
79         "signature_version": DEFAULT_QINGCLOUD_SIGNATURE_VERSION,
80         "time_stamp": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
81         "version": DEFAULT_QINGCLOUD_API_VERSION,
82     }
83     if params:
84         for key, value in params.items():
85             if isinstance(value, list):
86                 for i in range(1, len(value) + 1):
87                     if isinstance(value[i - 1], dict):
88                         for sk, sv in value[i - 1].items():
89                             if isinstance(sv, dict) or isinstance(sv, list):
90                                 sv = salt.utils.json.dumps(sv, separators=(",", ":"))
91                             real_parameters["{}.{}.{}".format(key, i, sk)] = sv
92                     else:
93                         real_parameters["{}.{}".format(key, i)] = value[i - 1]
94             else:
95                 real_parameters[key] = value
96     signature = _compute_signature(real_parameters, access_key_secret, "GET", "/iaas/")
97     real_parameters["signature"] = signature
98     request = requests.get(path, params=real_parameters, verify=verify_ssl)
99     if request.status_code != 200:
100         raise SaltCloudSystemExit(
101             "An error occurred while querying QingCloud. HTTP Code: {}  "
102             "Error: '{}'".format(request.status_code, request.text)
103         )
104     log.debug(request.url)
105     content = request.text
106     result = salt.utils.json.loads(content)
107     if result["ret_code"] != 0:
108         raise SaltCloudSystemExit(pprint.pformat(result.get("message", {})))
109     return result
110 def avail_locations(call=None):
111     if call == "action":
112         raise SaltCloudSystemExit(
113             "The avail_locations function must be called with "
114             "-f or --function, or with the --list-locations option"
115         )
116     params = {
117         "action": "DescribeZones",
118     }
119     items = query(params=params)
120     result = {}
121     for region in items["zone_set"]:
122         result[region["zone_id"]] = {}
123         for key in region:
124             result[region["zone_id"]][key] = str(region[key])
125     return result
126 def _get_location(vm_=None):
127     locations = avail_locations()
128     vm_location = str(
129         config.get_cloud_config_value("zone", vm_, __opts__, search_global=False)
130     )
131     if not vm_location:
132         raise SaltCloudNotFound("No location specified for this VM.")
133     if vm_location in locations:
134         return vm_location
135     raise SaltCloudNotFound(
136         "The specified location, '{}', could not be found.".format(vm_location)
137     )
138 def _get_specified_zone(kwargs=None, provider=None):
139     if provider is None:
140         provider = get_configured_provider()
141     if isinstance(kwargs, dict):
142         zone = kwargs.get("zone", None)
143         if zone is not None:
144             return zone
145     zone = provider["zone"]
146     return zone
147 def avail_images(kwargs=None, call=None):
148     if call == "action":
149         raise SaltCloudSystemExit(
150             "The avail_images function must be called with "
151             "-f or --function, or with the --list-images option"
152         )
153     if not isinstance(kwargs, dict):
154         kwargs = {}
155     params = {
156         "action": "DescribeImages",
157         "provider": "system",
158         "zone": _get_specified_zone(kwargs, get_configured_provider()),
159     }
160     items = query(params=params)
161     result = {}
162     for image in items["image_set"]:
163         result[image["image_id"]] = {}
164         for key in image:
165             result[image["image_id"]][key] = image[key]
166     return result
167 def _get_image(vm_):
168     images = avail_images()
169     vm_image = str(
170         config.get_cloud_config_value("image", vm_, __opts__, search_global=False)
171     )
172     if not vm_image:
173         raise SaltCloudNotFound("No image specified for this VM.")
174     if vm_image in images:
175         return vm_image
176     raise SaltCloudNotFound(
177         "The specified image, '{}', could not be found.".format(vm_image)
178     )
179 def show_image(kwargs, call=None):
180     if call != "function":
181         raise SaltCloudSystemExit(
182             "The show_images function must be called with -f or --function"
183         )
184     if not isinstance(kwargs, dict):
185         kwargs = {}
186     images = kwargs["image"]
187     images = images.split(",")
188     params = {
189         "action": "DescribeImages",
190         "images": images,
191         "zone": _get_specified_zone(kwargs, get_configured_provider()),
192     }
193     items = query(params=params)
194     if not items["image_set"]:
195         raise SaltCloudNotFound("The specified image could not be found.")
196     result = {}
197     for image in items["image_set"]:
198         result[image["image_id"]] = {}
199         for key in image:
200             result[image["image_id"]][key] = image[key]
201     return result
202 QINGCLOUD_SIZES = {
203     "pek2": {
204         "c1m1": {"cpu": 1, "memory": "1G"},
205         "c1m2": {"cpu": 1, "memory": "2G"},
206         "c1m4": {"cpu": 1, "memory": "4G"},
207         "c2m2": {"cpu": 2, "memory": "2G"},
208         "c2m4": {"cpu": 2, "memory": "4G"},
209         "c2m8": {"cpu": 2, "memory": "8G"},
210         "c4m4": {"cpu": 4, "memory": "4G"},
211         "c4m8": {"cpu": 4, "memory": "8G"},
212         "c4m16": {"cpu": 4, "memory": "16G"},
213     },
214     "pek1": {
215         "small_b": {"cpu": 1, "memory": "1G"},
216         "small_c": {"cpu": 1, "memory": "2G"},
217         "medium_a": {"cpu": 2, "memory": "2G"},
218         "medium_b": {"cpu": 2, "memory": "4G"},
219         "medium_c": {"cpu": 2, "memory": "8G"},
220         "large_a": {"cpu": 4, "memory": "4G"},
221         "large_b": {"cpu": 4, "memory": "8G"},
222         "large_c": {"cpu": 4, "memory": "16G"},
223     },
224 }
225 QINGCLOUD_SIZES["ap1"] = QINGCLOUD_SIZES["pek2"]
226 QINGCLOUD_SIZES["gd1"] = QINGCLOUD_SIZES["pek2"]
227 def avail_sizes(kwargs=None, call=None):
228     if call == "action":
229         raise SaltCloudSystemExit(
230             "The avail_sizes function must be called with "
231             "-f or --function, or with the --list-sizes option"
232         )
233     zone = _get_specified_zone(kwargs, get_configured_provider())
234     result = {}
235     for size_key in QINGCLOUD_SIZES[zone]:
236         result[size_key] = {}
237         for attribute_key in QINGCLOUD_SIZES[zone][size_key]:
238             result[size_key][attribute_key] = QINGCLOUD_SIZES[zone][size_key][
239                 attribute_key
240             ]
241     return result
242 def _get_size(vm_):
243     sizes = avail_sizes()
244     vm_size = str(
245         config.get_cloud_config_value("size", vm_, __opts__, search_global=False)
246     )
247     if not vm_size:
248         raise SaltCloudNotFound("No size specified for this instance.")
249     if vm_size in sizes.keys():
250         return vm_size
251     raise SaltCloudNotFound(
252         "The specified size, '{}', could not be found.".format(vm_size)
253     )
254 def _show_normalized_node(full_node):
255     public_ips = full_node.get("eip", [])
256     if public_ips:
257         public_ip = public_ips["eip_addr"]
258         public_ips = [
259             public_ip,
260         ]
261     private_ips = []
262     for vxnet in full_node.get("vxnets", []):
263         private_ip = vxnet.get("private_ip", None)
264         if private_ip:
265             private_ips.append(private_ip)
266     normalized_node = {
267         "id": full_node["instance_id"],
268         "image": full_node["image"]["image_id"],
269         "size": full_node["instance_type"],
270         "state": full_node["status"],
271         "private_ips": private_ips,
272         "public_ips": public_ips,
273     }
274     return normalized_node
275 def list_nodes_full(call=None):
276     if call == "action":
277         raise SaltCloudSystemExit(
278             "The list_nodes_full function must be called with -f or --function."
279         )
280     zone = _get_specified_zone()
281     params = {
282         "action": "DescribeInstances",
283         "zone": zone,
284         "status": ["pending", "running", "stopped", "suspended"],
285     }
286     items = query(params=params)
287     log.debug("Total %s instances found in zone %s", items["total_count"], zone)
288     result = {}
289     if items["total_count"] == 0:
290         return result
291     for node in items["instance_set"]:
292         normalized_node = _show_normalized_node(node)
293         node.update(normalized_node)
294         result[node["instance_id"]] = node
295     provider = _get_active_provider_name() or "qingcloud"
296     if ":" in provider:
297         comps = provider.split(":")
298         provider = comps[0]
299     __opts__["update_cachedir"] = True
300     __utils__["cloud.cache_node_list"](result, provider, __opts__)
301     return result
302 def list_nodes(call=None):
303     if call == "action":
304         raise SaltCloudSystemExit(
305             "The list_nodes function must be called with -f or --function."
306         )
307     nodes = list_nodes_full()
308     ret = {}
309     for instance_id, full_node in nodes.items():
310         ret[instance_id] = {
311             "id": full_node["id"],
312             "image": full_node["image"],
313             "size": full_node["size"],
314             "state": full_node["state"],
315             "public_ips": full_node["public_ips"],
316             "private_ips": full_node["private_ips"],
317         }
318     return ret
319 def list_nodes_min(call=None):
320     if call != "function":
321         raise SaltCloudSystemExit(
322             "The list_nodes_min function must be called with -f or --function."
323         )
324     nodes = list_nodes_full()
325     result = {}
326     for instance_id, full_node in nodes.items():
327         result[instance_id] = {
328             "name": full_node["instance_name"],
329             "status": full_node["status"],
330         }
331     return result
332 def list_nodes_select(call=None):
333     return salt.utils.cloud.list_nodes_select(
334         list_nodes_full("function"),
335         __opts__["query.selection"],
336         call,
337     )
338 def show_instance(instance_id, call=None, kwargs=None):
339     if call != "action":
340         raise SaltCloudSystemExit(
341             "The show_instance action must be called with -a or --action."
342         )
343     params = {
344         "action": "DescribeInstances",
345         "instances.1": instance_id,
346         "zone": _get_specified_zone(kwargs=None, provider=get_configured_provider()),
347     }
348     items = query(params=params)
349     if items["total_count"] == 0:
350         raise SaltCloudNotFound(
351             "The specified instance, '{}', could not be found.".format(instance_id)
352         )
353     full_node = items["instance_set"][0]
354     normalized_node = _show_normalized_node(full_node)
355     full_node.update(normalized_node)
356     result = full_node
357     return result
358 def _query_node_data(instance_id):
359     data = show_instance(instance_id, call="action")
360     if not data:
361         return False
362     if data.get("private_ips", []):
363         return data
364 def create(vm_):
365     try:
366         if (
367             vm_["profile"]
368             and config.is_profile_configured(
369                 __opts__,
370                 _get_active_provider_name() or "qingcloud",
371                 vm_["profile"],
372                 vm_=vm_,
373             )
374             is False
375         ):
376             return False
377     except AttributeError:
378         pass
379     __utils__["cloud.fire_event"](
380         "event",
381         "starting create",
382         "salt/cloud/{}/creating".format(vm_["name"]),
383         args=__utils__["cloud.filter_event"](
384             "creating", vm_, ["name", "profile", "provider", "driver"]
385         ),
386         sock_dir=__opts__["sock_dir"],
387         transport=__opts__["transport"],
388     )
389     log.info("Creating Cloud VM %s", vm_["name"])
390     params = {
391         "action": "RunInstances",
392         "instance_name": vm_["name"],
393         "zone": _get_location(vm_),
394         "instance_type": _get_size(vm_),
395         "image_id": _get_image(vm_),
396         "vxnets.1": vm_["vxnets"],
397         "login_mode": vm_["login_mode"],
398         "login_keypair": vm_["login_keypair"],
399     }
400     __utils__["cloud.fire_event"](
401         "event",
402         "requesting instance",
403         "salt/cloud/{}/requesting".format(vm_["name"]),
404         args={
405             "kwargs": __utils__["cloud.filter_event"](
406                 "requesting", params, list(params)
407             ),
408         },
409         sock_dir=__opts__["sock_dir"],
410         transport=__opts__["transport"],
411     )
412     result = query(params)
413     new_instance_id = result["instances"][0]
414     try:
415         data = salt.utils.cloud.wait_for_ip(
416             _query_node_data,
417             update_args=(new_instance_id,),
418             timeout=config.get_cloud_config_value(
419                 "wait_for_ip_timeout", vm_, __opts__, default=10 * 60
420             ),
421             interval=config.get_cloud_config_value(
422                 "wait_for_ip_interval", vm_, __opts__, default=10
423             ),
424         )
425     except (SaltCloudExecutionTimeout, SaltCloudExecutionFailure) as exc:
426         try:
427             destroy(vm_["name"])
428         except SaltCloudSystemExit:
429             pass
430         finally:
431             raise SaltCloudSystemExit(str(exc))
432     private_ip = data["private_ips"][0]
433     log.debug("VM %s is now running", private_ip)
434     vm_["ssh_host"] = private_ip
435     __utils__["cloud.bootstrap"](vm_, __opts__)
436     log.info("Created Cloud VM '%s'", vm_["name"])
437     log.debug("'%s' VM creation details:\n%s", vm_["name"], pprint.pformat(data))
438     __utils__["cloud.fire_event"](
439         "event",
440         "created instance",
441         "salt/cloud/{}/created".format(vm_["name"]),
442         args=__utils__["cloud.filter_event"](
443             "created", vm_, ["name", "profile", "provider", "driver"]
444         ),
445         sock_dir=__opts__["sock_dir"],
446         transport=__opts__["transport"],
447     )
448     return data
449 def script(vm_):
450     deploy_script = salt.utils.cloud.os_script(
451         config.get_cloud_config_value("script", vm_, __opts__),
452         vm_,
453         __opts__,
454         salt.utils.cloud.salt_config_to_yaml(
455             salt.utils.cloud.minion_config(__opts__, vm_)
456         ),
457     )
458     return deploy_script
459 def start(instance_id, call=None):
460     if call != "action":
461         raise SaltCloudSystemExit("The stop action must be called with -a or --action.")
462     log.info("Starting instance %s", instance_id)
463     params = {
464         "action": "StartInstances",
465         "zone": _get_specified_zone(provider=get_configured_provider()),
466         "instances.1": instance_id,
467     }
468     result = query(params)
469     return result
470 def stop(instance_id, force=False, call=None):
471     if call != "action":
472         raise SaltCloudSystemExit("The stop action must be called with -a or --action.")
473     log.info("Stopping instance %s", instance_id)
474     params = {
475         "action": "StopInstances",
476         "zone": _get_specified_zone(provider=get_configured_provider()),
477         "instances.1": instance_id,
478         "force": int(force),
479     }
480     result = query(params)
481     return result
482 def reboot(instance_id, call=None):
483     if call != "action":
484         raise SaltCloudSystemExit("The stop action must be called with -a or --action.")
485     log.info("Rebooting instance %s", instance_id)
486     params = {
487         "action": "RestartInstances",
488         "zone": _get_specified_zone(provider=get_configured_provider()),
489         "instances.1": instance_id,
490     }
491     result = query(params)
492     return result
493 def destroy(instance_id, call=None):
494     if call == "function":
495         raise SaltCloudSystemExit(
496             "The destroy action must be called with -d, --destroy, -a or --action."
497         )
498     instance_data = show_instance(instance_id, call="action")
499     name = instance_data["instance_name"]
500     __utils__["cloud.fire_event"](
501         "event",
502         "destroying instance",
503         "salt/cloud/{}/destroying".format(name),
504         args={"name": name},
505         sock_dir=__opts__["sock_dir"],
506         transport=__opts__["transport"],
507     )
508     params = {
509         "action": "TerminateInstances",
510         "zone": _get_specified_zone(provider=get_configured_provider()),
511         "instances.1": instance_id,
512     }
513     result = query(params)
514     __utils__["cloud.fire_event"](
515         "event",
516         "destroyed instance",
517         "salt/cloud/{}/destroyed".format(name),
518         args={"name": name},
519         sock_dir=__opts__["sock_dir"],
520         transport=__opts__["transport"],
521     )
522     return result
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>http.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import cgi
2 import gzip
3 import http.client
4 import http.cookiejar
5 import io
6 import logging
7 import os
8 import pprint
9 import re
10 import socket
11 import ssl
12 import urllib.error
13 import urllib.parse
14 import urllib.request
15 import xml.etree.ElementTree as ET
16 import zlib
17 import salt.config
18 import salt.ext.tornado.httputil
19 import salt.ext.tornado.simple_httpclient
20 import salt.loader
21 <a name="0"></a>import salt.syspaths
22 import salt.utils.args
23 import salt.utils.data
24 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import salt.utils.files
25 import salt.utils.json
26 import salt.utils.msgpack
27 import salt.utils.network
28 import salt.utils.platform
29 import salt.utils.stringutils
30 import salt.utils.xmlutil as xml
31 import salt.utils.yaml
32 import salt.version
33 from salt.ext.tornado.httpclient import HTTPClient
34 from salt.template import compile_template
35 from salt.utils.decorators.jinja import jinja_filter
36 try:
37     from ssl import CertificateError, match_hostname
38     HAS_MATCHHOSTNAME = True
39 e</b></font>xcept ImportError:
40     try:
41         from backports.ssl_match_hostname import CertificateError, match_hostname
42         HAS_MATCHHOSTNAME = True
43     except ImportError:
44         try:
45             from salt.ext.ssl_match_hostname import CertificateError, match_hostname
46             HAS_MATCHHOSTNAME = True
47         except ImportError:
48             HAS_MATCHHOSTNAME = False
49 try:
50     import salt.ext.tornado.curl_httpclient
51     HAS_CURL_HTTPCLIENT = True
52 except ImportError:
53     HAS_CURL_HTTPCLIENT = False
54 try:
55     import requests
56     HAS_REQUESTS = True
57 except ImportError:
58     HAS_REQUESTS = False
59 try:
60     import certifi
61     HAS_CERTIFI = True
62 except ImportError:
63     HAS_CERTIFI = False
64 log = logging.getLogger(__name__)
65 USERAGENT = "Salt/{}".format(salt.version.__version__)
66 def __decompressContent(coding, pgctnt):
67     if not pgctnt:
68         return pgctnt
69     log.trace(
70         "Decompressing %s byte content with compression type: %s", len(pgctnt), coding
71     )
72     if coding == "deflate":
73         pgctnt = zlib.decompress(pgctnt, -zlib.MAX_WBITS)
74     elif coding == "gzip":
75         buf = io.BytesIO(pgctnt)
76         f = gzip.GzipFile(fileobj=buf)
77         pgctnt = f.read()
78     elif coding == "sdch":
79         raise ValueError("SDCH compression is not currently supported")
80     elif coding == "br":
81         raise ValueError("Brotli compression is not currently supported")
82     elif coding == "compress":
83         raise ValueError("LZW compression is not currently supported")
84     log.trace("Content size after decompression: %s", len(pgctnt))
85     return pgctnt
86 @jinja_filter("http_query")
87 def query(
88     url,
89     method="GET",
90     params=None,
91     data=None,
92     data_file=None,
93     header_dict=None,
94     header_list=None,
95     header_file=None,
96     username=None,
97     password=None,
98     auth=None,
99     decode=False,
100     decode_type="auto",
101     status=False,
102     headers=False,
103     text=False,
104     cookies=None,
105     cookie_jar=None,
106     cookie_format="lwp",
107     persist_session=False,
108     session_cookie_jar=None,
109     data_render=False,
110     data_renderer=None,
111     header_render=False,
112     header_renderer=None,
113     template_dict=None,
114     test=False,
115     test_url=None,
116     node="minion",
117     port=80,
118     opts=None,
119     backend=None,
120     ca_bundle=None,
121     verify_ssl=None,
122     cert=None,
123     text_out=None,
124     headers_out=None,
125     decode_out=None,
126     stream=False,
127     streaming_callback=None,
128     header_callback=None,
129     handle=False,
130     agent=USERAGENT,
131     hide_fields=None,
132     raise_error=True,
133     formdata=False,
134     formdata_fieldname=None,
135     formdata_filename=None,
136     decode_body=True,
137     **kwargs
138 ):
139     ret = {}
140     if opts is None:
141         if node == "master":
142             opts = salt.config.master_config(
143                 os.path.join(salt.syspaths.CONFIG_DIR, "master")
144             )
145         elif node == "minion":
146             opts = salt.config.minion_config(
147                 os.path.join(salt.syspaths.CONFIG_DIR, "minion")
148             )
149         else:
150             opts = {}
151     if not backend:
152         backend = opts.get("backend", "tornado")
153     match = re.match(
154         r"https?://((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)($|/)",
155         url,
156     )
157     if not match:
158         salt.utils.network.refresh_dns()
159     if backend == "requests":
160         if HAS_REQUESTS is False:
161             ret["error"] = (
162                 "http.query has been set to use requests, but the "
163                 "requests library does not seem to be installed"
164             )
165             log.error(ret["error"])
166             return ret
167         else:
168             requests_log = logging.getLogger("requests")
169             requests_log.setLevel(logging.WARNING)
170     url_full = salt.ext.tornado.httputil.url_concat(url, params) if params else url
171     if ca_bundle is None:
172         ca_bundle = get_ca_bundle(opts)
173     if verify_ssl is None:
174         verify_ssl = opts.get("verify_ssl", True)
175     if cert is None:
176         cert = opts.get("cert", None)
177     if data_file is not None:
178         data = _render(data_file, data_render, data_renderer, template_dict, opts)
179     log_url = sanitize_url(url_full, hide_fields)
180     log.debug("Requesting URL %s using %s method", log_url, method)
181     log.debug("Using backend: %s", backend)
182     if method == "POST" and log.isEnabledFor(logging.TRACE):
183         if isinstance(data, dict):
184             log_data = data.copy()
185             if isinstance(hide_fields, list):
186                 for item in data:
187                     for field in hide_fields:
188                         if item == field:
189                             log_data[item] = "XXXXXXXXXX"
190             log.trace("Request POST Data: %s", pprint.pformat(log_data))
191         else:
192             log.trace("Request POST Data: %s", pprint.pformat(data))
193     if header_file is not None:
194         header_tpl = _render(
195             header_file, header_render, header_renderer, template_dict, opts
196         )
197         if isinstance(header_tpl, dict):
198             header_dict = header_tpl
199         else:
200             header_list = header_tpl.splitlines()
201     if header_dict is None:
202         header_dict = {}
203     if header_list is None:
204         header_list = []
205     if cookie_jar is None:
206         cookie_jar = os.path.join(
207             opts.get("cachedir", salt.syspaths.CACHE_DIR), "cookies.txt"
208         )
209     if session_cookie_jar is None:
210         session_cookie_jar = os.path.join(
211             opts.get("cachedir", salt.syspaths.CACHE_DIR), "cookies.session.p"
212         )
213     if persist_session is True and salt.utils.msgpack.HAS_MSGPACK:
214         if os.path.isfile(session_cookie_jar):
215             with salt.utils.files.fopen(session_cookie_jar, "rb") as fh_:
216                 session_cookies = salt.utils.msgpack.load(fh_)
217             if isinstance(session_cookies, dict):
218                 header_dict.update(session_cookies)
219         else:
220             with salt.utils.files.fopen(session_cookie_jar, "wb") as fh_:
221                 salt.utils.msgpack.dump("", fh_)
222     for header in header_list:
223         comps = header.split(":")
224         if len(comps) &lt; 2:
225             continue
226         header_dict[comps[0].strip()] = comps[1].strip()
227     if not auth:
228         if username and password:
229             auth = (username, password)
230     if agent == USERAGENT:
231         agent = "{} http.query()".format(agent)
232     header_dict["User-agent"] = agent
233     if backend == "requests":
234         sess = requests.Session()
235         sess.auth = auth
236         sess.headers.update(header_dict)
237         log.trace("Request Headers: %s", sess.headers)
238         sess_cookies = sess.cookies
239         sess.verify = verify_ssl
240     elif backend == "urllib2":
241         sess_cookies = None
242     else:
243         sess_cookies = None
244     if cookies is not None:
245         if cookie_format == "mozilla":
246             sess_cookies = http.cookiejar.MozillaCookieJar(cookie_jar)
247         else:
248             sess_cookies = http.cookiejar.LWPCookieJar(cookie_jar)
249         if not os.path.isfile(cookie_jar):
250             sess_cookies.save()
251         sess_cookies.load()
252     if test is True:
253         if test_url is None:
254             return {}
255         else:
256             url = test_url
257             ret["test"] = True
258     if backend == "requests":
259         req_kwargs = {}
260         if stream is True:
261             if requests.__version__[0] == "0":
262                 req_kwargs["prefetch"] = False
263             else:
264                 req_kwargs["stream"] = True
265         if cert is not None:
266             if isinstance(cert, str):
267                 if os.path.exists(cert):
268                     req_kwargs["cert"] = cert
269             elif isinstance(cert, list):
270                 if os.path.exists(cert[0]) and os.path.exists(cert[1]):
271                     req_kwargs["cert"] = cert
272             else:
273                 log.error(
274                     "The client-side certificate path that was passed is not valid: %s",
275                     cert,
276                 )
277         if formdata:
278             if not formdata_fieldname:
279                 ret["error"] = "formdata_fieldname is required when formdata=True"
280                 log.error(ret["error"])
281                 return ret
282             result = sess.request(
283                 method,
284                 url,
285                 params=params,
286                 files={formdata_fieldname: (formdata_filename, io.StringIO(data))},
287                 **req_kwargs
288             )
289         else:
290             result = sess.request(method, url, params=params, data=data, **req_kwargs)
291         result.raise_for_status()
292         if stream is True:
293             header_callback("HTTP/1.0 {} MESSAGE".format(result.status_code))
294             streaming_callback(result.content)
295             return {
296                 "handle": result,
297             }
298         if handle is True:
299             return {
300                 "handle": result,
301                 "body": result.content,
302             }
303         log.debug(
304             "Final URL location of Response: %s", sanitize_url(result.url, hide_fields)
305         )
306         result_status_code = result.status_code
307         result_headers = result.headers
308         result_text = result.content
309         result_cookies = result.cookies
310         body = result.content
311         if not isinstance(body, str) and decode_body:
312             body = body.decode(result.encoding or "utf-8")
313         ret["body"] = body
314     elif backend == "urllib2":
315         request = urllib.request.Request(url_full, data)
316         handlers = [
317             urllib.request.HTTPHandler,
318             urllib.request.HTTPCookieProcessor(sess_cookies),
319         ]
320         if url.startswith("https"):
321             hostname = request.get_host()
322             handlers[0] = urllib.request.HTTPSHandler(1)
323             if not HAS_MATCHHOSTNAME:
324                 log.warning(
325                     "match_hostname() not available, SSL hostname checking "
326                     "not available. THIS CONNECTION MAY NOT BE SECURE!"
327                 )
328             elif verify_ssl is False:
329                 log.warning(
330                     "SSL certificate verification has been explicitly "
331                     "disabled. THIS CONNECTION MAY NOT BE SECURE!"
332                 )
333             else:
334                 if ":" in hostname:
335                     hostname, port = hostname.split(":")
336                 else:
337                     port = 443
338                 sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
339                 sock.connect((hostname, int(port)))
340                 sockwrap = ssl.wrap_socket(
341                     sock, ca_certs=ca_bundle, cert_reqs=ssl.CERT_REQUIRED
342                 )
343                 try:
344                     match_hostname(sockwrap.getpeercert(), hostname)
345                 except CertificateError as exc:
346                     ret[
347                         "error"
348                     ] = "The certificate was invalid. Error returned was: {}".format(
349                         pprint.pformat(exc)
350                     )
351                     return ret
352                 if cert is not None:
353                     cert_chain = None
354                     if isinstance(cert, str):
355                         if os.path.exists(cert):
356                             cert_chain = cert
357                     elif isinstance(cert, list):
358                         if os.path.exists(cert[0]) and os.path.exists(cert[1]):
359                             cert_chain = cert
360                     else:
361                         log.error(
362                             "The client-side certificate path that was "
363                             "passed is not valid: %s",
364                             cert,
365                         )
366                         return
367                     if hasattr(ssl, "SSLContext"):
368                         context = ssl.SSLContext.load_cert_chain(*cert_chain)
369                         handlers.append(
370                             urllib.request.HTTPSHandler(context=context)
371                         )  # pylint: disable=E1123
372                     else:
373                         cert_kwargs = {
374                             "host": request.get_host(),
375                             "port": port,
376                             "cert_file": cert_chain[0],
377                         }
378                         if len(cert_chain) &gt; 1:
379                             cert_kwargs["key_file"] = cert_chain[1]
380                         handlers[0] = http.client.HTTPSConnection(**cert_kwargs)
381         opener = urllib.request.build_opener(*handlers)
382         for header in header_dict:
383             request.add_header(header, header_dict[header])
384         request.get_method = lambda: method
385         try:
386             result = opener.open(request)
387         except urllib.error.URLError as exc:
388             return {"Error": str(exc)}
389         if stream is True or handle is True:
390             return {
391                 "handle": result,
392                 "body": result.content,
393             }
394         result_status_code = result.code
395         result_headers = dict(result.info())
396         result_text = result.read()
397         if "Content-Type" in result_headers:
398             res_content_type, res_params = cgi.parse_header(
399                 result_headers["Content-Type"]
400             )
401             if (
402                 res_content_type.startswith("text/")
403                 and "charset" in res_params
404                 and not isinstance(result_text, str)
405             ):
406                 result_text = result_text.decode(res_params["charset"])
407         if isinstance(result_text, bytes) and decode_body:
408             result_text = result_text.decode("utf-8")
409         ret["body"] = result_text
410     else:
411         req_kwargs = {}
412         if cert is not None:
413             if isinstance(cert, str):
414                 if os.path.exists(cert):
415                     req_kwargs["client_cert"] = cert
416             elif isinstance(cert, list):
417                 if os.path.exists(cert[0]) and os.path.exists(cert[1]):
418                     req_kwargs["client_cert"] = cert[0]
419                     req_kwargs["client_key"] = cert[1]
420             else:
421                 log.error(
422                     "The client-side certificate path that was passed is not valid: %s",
423                     cert,
424                 )
425         if isinstance(data, dict):
426             data = urllib.parse.urlencode(data)
427         if verify_ssl:
428             req_kwargs["ca_certs"] = ca_bundle
429         max_body = opts.get(
430             "http_max_body", salt.config.DEFAULT_MINION_OPTS["http_max_body"]
431         )
432         connect_timeout = opts.get(
433             "http_connect_timeout",
434             salt.config.DEFAULT_MINION_OPTS["http_connect_timeout"],
435         )
436         timeout = opts.get(
437             "http_request_timeout",
438             salt.config.DEFAULT_MINION_OPTS["http_request_timeout"],
439         )
440         client_argspec = None
441         proxy_host = opts.get("proxy_host", None)
442         if proxy_host:
443             proxy_host = salt.utils.stringutils.to_str(proxy_host)
444         proxy_port = opts.get("proxy_port", None)
445         proxy_username = opts.get("proxy_username", None)
446         if proxy_username:
447             proxy_username = salt.utils.stringutils.to_str(proxy_username)
448         proxy_password = opts.get("proxy_password", None)
449         if proxy_password:
450             proxy_password = salt.utils.stringutils.to_str(proxy_password)
451         no_proxy = opts.get("no_proxy", [])
452         if urllib.parse.urlparse(url_full).hostname in no_proxy:
453             proxy_host = None
454             proxy_port = None
455             proxy_username = None
456             proxy_password = None
457         if proxy_host and proxy_port:
458             if HAS_CURL_HTTPCLIENT is False:
459                 ret["error"] = (
460                     "proxy_host and proxy_port has been set. This requires pycurl and"
461                     " tornado, but the libraries does not seem to be installed"
462                 )
463                 log.error(ret["error"])
464                 return ret
465             salt.ext.tornado.httpclient.AsyncHTTPClient.configure(
466                 "tornado.curl_httpclient.CurlAsyncHTTPClient"
467             )
468             client_argspec = salt.utils.args.get_function_argspec(
469                 salt.ext.tornado.curl_httpclient.CurlAsyncHTTPClient.initialize
470             )
471         else:
472             salt.ext.tornado.httpclient.AsyncHTTPClient.configure(None)
473             client_argspec = salt.utils.args.get_function_argspec(
474                 salt.ext.tornado.simple_httpclient.SimpleAsyncHTTPClient.initialize
475             )
476         supports_max_body_size = "max_body_size" in client_argspec.args
477         req_kwargs.update(
478             {
479                 "method": method,
480                 "headers": header_dict,
481                 "auth_username": username,
482                 "auth_password": password,
483                 "body": data,
484                 "validate_cert": verify_ssl,
485                 "allow_nonstandard_methods": True,
486                 "streaming_callback": streaming_callback,
487                 "header_callback": header_callback,
488                 "connect_timeout": connect_timeout,
489                 "request_timeout": timeout,
490                 "proxy_host": proxy_host,
491                 "proxy_port": proxy_port,
492                 "proxy_username": proxy_username,
493                 "proxy_password": proxy_password,
494                 "raise_error": raise_error,
495                 "decompress_response": False,
496             }
497         )
498         req_kwargs = salt.utils.data.decode(req_kwargs, to_str=True)
499         try:
500             download_client = (
501                 HTTPClient(max_body_size=max_body)
502                 if supports_max_body_size
503                 else HTTPClient()
504             )
505             result = download_client.fetch(url_full, **req_kwargs)
506         except salt.ext.tornado.httpclient.HTTPError as exc:
507             ret["status"] = exc.code
508             ret["error"] = str(exc)
509             return ret
510         except (socket.herror, OSError, socket.timeout, socket.gaierror) as exc:
511             if status is True:
512                 ret["status"] = 0
513             ret["error"] = str(exc)
514             log.debug("Cannot perform 'http.query': %s - %s", url_full, ret["error"])
515             return ret
516         if stream is True or handle is True:
517             return {
518                 "handle": result,
519                 "body": result.body,
520             }
521         result_status_code = result.code
522         result_headers = result.headers
523         result_text = result.body
524         if "Content-Type" in result_headers:
525             res_content_type, res_params = cgi.parse_header(
526                 result_headers["Content-Type"]
527             )
528             if (
529                 res_content_type.startswith("text/")
530                 and "charset" in res_params
531                 and not isinstance(result_text, str)
532             ):
533                 result_text = result_text.decode(res_params["charset"])
534         if isinstance(result_text, bytes) and decode_body:
535             result_text = result_text.decode("utf-8")
536         ret["body"] = result_text
537         if "Set-Cookie" in result_headers and cookies is not None:
538             result_cookies = parse_cookie_header(result_headers["Set-Cookie"])
539             for item in result_cookies:
540                 sess_cookies.set_cookie(item)
541         else:
542             result_cookies = None
543     if isinstance(result_headers, list):
544         result_headers_dict = {}
545         for header in result_headers:
546             comps = header.split(":")
547             result_headers_dict[comps[0].strip()] = ":".join(comps[1:]).strip()
548         result_headers = result_headers_dict
549     log.debug("Response Status Code: %s", result_status_code)
550     log.trace("Response Headers: %s", result_headers)
551     log.trace("Response Cookies: %s", sess_cookies)
552     coding = result_headers.get("Content-Encoding", "identity")
553     if backend != "requests":
554         result_text = __decompressContent(coding, result_text)
555     try:
556         log.trace("Response Text: %s", result_text)
557     except UnicodeEncodeError as exc:
558         log.trace(
559             "Cannot Trace Log Response Text: %s. This may be due to "
560             "incompatibilities between requests and logging.",
561             exc,
562         )
563     if text_out is not None:
564         with salt.utils.files.fopen(text_out, "w") as tof:
565             tof.write(result_text)
566     if headers_out is not None and os.path.exists(headers_out):
567         with salt.utils.files.fopen(headers_out, "w") as hof:
568             hof.write(result_headers)
569     if cookies is not None:
570         sess_cookies.save()
571     if persist_session is True and salt.utils.msgpack.HAS_MSGPACK:
572         if "set-cookie" in result_headers:
573             with salt.utils.files.fopen(session_cookie_jar, "wb") as fh_:
574                 session_cookies = result_headers.get("set-cookie", None)
575                 if session_cookies is not None:
576                     salt.utils.msgpack.dump({"Cookie": session_cookies}, fh_)
577                 else:
578                     salt.utils.msgpack.dump("", fh_)
579     if status is True:
580         ret["status"] = result_status_code
581     if headers is True:
582         ret["headers"] = result_headers
583     if decode is True:
584         if decode_type == "auto":
585             content_type = result_headers.get("content-type", "application/json")
586             if "xml" in content_type:
587                 decode_type = "xml"
588             elif "json" in content_type:
589                 decode_type = "json"
590             elif "yaml" in content_type:
591                 decode_type = "yaml"
592             else:
593                 decode_type = "plain"
594         valid_decodes = ("json", "xml", "yaml", "plain")
595         if decode_type not in valid_decodes:
596             ret[
597                 "error"
598             ] = "Invalid decode_type specified. Valid decode types are: {}".format(
599                 pprint.pformat(valid_decodes)
600             )
601             log.error(ret["error"])
602             return ret
603         if decode_type == "json":
604             ret["dict"] = salt.utils.json.loads(result_text)
605         elif decode_type == "xml":
606             ret["dict"] = []
607             items = ET.fromstring(result_text)
608             for item in items:
609                 ret["dict"].append(xml.to_dict(item))
610         elif decode_type == "yaml":
611             ret["dict"] = salt.utils.data.decode(salt.utils.yaml.safe_load(result_text))
612         else:
613             text = True
614         if decode_out:
615             with salt.utils.files.fopen(decode_out, "w") as dof:
616                 dof.write(result_text)
617     if text is True:
618         ret["text"] = result_text
619     return ret
620 def get_ca_bundle(opts=None):
621     if hasattr(get_ca_bundle, "__return_value__"):
622         return get_ca_bundle.__return_value__
623     if opts is None:
624         opts = {}
625     opts_bundle = opts.get("ca_bundle", None)
626     if opts_bundle is not None and os.path.exists(opts_bundle):
627         return opts_bundle
628     file_roots = opts.get("file_roots", {"base": [salt.syspaths.SRV_ROOT_DIR]})
629     for salt_root in file_roots.get("base", []):
630         for path in ("cacert.pem", "ca-bundle.crt"):
631             cert_path = os.path.join(salt_root, path)
632             if os.path.exists(cert_path):
633                 return cert_path
634     locations = (
635         "/etc/ssl/certs/ca-certificates.crt",
636         "/etc/pki/tls/certs/ca-bundle.crt",
637         "/etc/pki/tls/certs/ca-bundle.trust.crt",
638         "/etc/ssl/certs/ca-bundle.crt",
639         "/var/lib/ca-certificates/ca-bundle.pem",
640         "/etc/ssl/cert.pem",
641     )
642     for path in locations:
643         if os.path.exists(path):
644             return path
645     if salt.utils.platform.is_windows() and HAS_CERTIFI:
646         return certifi.where()
647     return None
648 def update_ca_bundle(
649     target=None,
650     source=None,
651     opts=None,
652     merge_files=None,
653 ):
654     if opts is None:
655         opts = {}
656     if target is None:
657         target = get_ca_bundle(opts)
658     if target is None:
659         log.error("Unable to detect location to write CA bundle to")
660         return
661     if source is None:
662         source = opts.get("ca_bundle_url", "http://curl.haxx.se/ca/cacert.pem")
663     log.debug("Attempting to download %s to %s", source, target)
664     query(source, text=True, decode=False, headers=False, status=False, text_out=target)
665     if merge_files is not None:
666         if isinstance(merge_files, str):
667             merge_files = [merge_files]
668         if not isinstance(merge_files, list):
669             log.error(
670                 "A value was passed as merge_files which was not either "
671                 "a string or a list"
672             )
673             return
674         merge_content = ""
675         for cert_file in merge_files:
676             if os.path.exists(cert_file):
677                 log.debug("Queueing up %s to be appended to %s", cert_file, target)
678                 try:
679                     with salt.utils.files.fopen(cert_file, "r") as fcf:
680                         merge_content = "\n".join((merge_content, fcf.read()))
681                 except OSError as exc:
682                     log.error(
683                         "Reading from %s caused the following error: %s", cert_file, exc
684                     )
685         if merge_content:
686             log.debug("Appending merge_files to %s", target)
687             try:
688                 with salt.utils.files.fopen(target, "a") as tfp:
689                     tfp.write("\n")
690                     tfp.write(merge_content)
691             except OSError as exc:
692                 log.error("Writing to %s caused the following error: %s", target, exc)
693 def _render(template, render, renderer, template_dict, opts):
694     if render:
695         if template_dict is None:
696             template_dict = {}
697         if not renderer:
698             renderer = opts.get("renderer", "jinja|yaml")
699         rend = salt.loader.render(opts, {})
700         blacklist = opts.get("renderer_blacklist")
701         whitelist = opts.get("renderer_whitelist")
702         ret = compile_template(
703             template, rend, renderer, blacklist, whitelist, **template_dict
704         )
705         if salt.utils.stringio.is_readable(ret):
706             ret = ret.read()
707         if str(ret).startswith("#!") and not str(ret).startswith("#!/"):
708             ret = str(ret).split("\n", 1)[1]
709         return ret
710     with salt.utils.files.fopen(template, "r") as fh_:
711         return fh_.read()
712 def parse_cookie_header(header):
713     attribs = (
714         "expires",
715         "path",
716         "domain",
717         "version",
718         "httponly",
719         "secure",
720         "comment",
721         "max-age",
722         "samesite",
723     )
724     morsels = []
725     for item in header.split(";"):
726         item = item.strip()
727         if "," in item and "expires" not in item:
728             for part in item.split(","):
729                 morsels.append(part)
730         else:
731             morsels.append(item)
732     cookies = []
733     cookie = {}
734     value_set = False
735     for morsel in morsels:
736         parts = morsel.split("=")
737         parts[0] = parts[0].lower()
738         if parts[0] in attribs:
739             if parts[0] in cookie:
740                 cookies.append(cookie)
741                 cookie = {}
742             if len(parts) &gt; 1:
743                 cookie[parts[0]] = "=".join(parts[1:])
744             else:
745                 cookie[parts[0]] = True
746         else:
747             if value_set is True:
748                 cookies.append(cookie)
749                 cookie = {}
750                 value_set = False
751             cookie[parts[0]] = "=".join(parts[1:])
752             value_set = True
753     if cookie:
754         cookies.append(cookie)
755     reqd = (
756         "version",
757         "port",
758         "port_specified",
759         "domain",
760         "domain_specified",
761         "domain_initial_dot",
762         "path",
763         "path_specified",
764         "secure",
765         "expires",
766         "discard",
767         "comment",
768         "comment_url",
769         "rest",
770     )
771     ret = []
772     for cookie in cookies:
773         name = None
774         value = None
775         for item in list(cookie):
776             if item in attribs:
777                 continue
778             name = item
779             value = cookie.pop(item)
780         if "expires" in cookie:
781             cookie["expires"] = http.cookiejar.http2time(cookie["expires"])
782         for req in reqd:
783             if req not in cookie:
784                 cookie[req] = ""
785         if cookie["version"] == "":
786             cookie["version"] = 0
787         if cookie["rest"] == "":
788             cookie["rest"] = {}
789         if cookie["expires"] == "":
790             cookie["expires"] = 0
791         cookie.pop("httponly", None)
792         cookie.pop("samesite", None)
793         ret.append(http.cookiejar.Cookie(name=name, value=value, **cookie))
794     return ret
795 def sanitize_url(url, hide_fields):
796     if isinstance(hide_fields, list):
797         url_comps = urllib.parse.splitquery(url)
798         log_url = url_comps[0]
799         if len(url_comps) &gt; 1:
800             log_url += "?"
801         for pair in url_comps[1:]:
802             url_tmp = None
803             for field in hide_fields:
804                 comps_list = pair.split("&amp;")
805                 if url_tmp:
806                     url_tmp = url_tmp.split("&amp;")
807                     url_tmp = _sanitize_url_components(url_tmp, field)
808                 else:
809                     url_tmp = _sanitize_url_components(comps_list, field)
810             log_url += url_tmp
811         return log_url.rstrip("&amp;")
812     else:
813         return str(url)
814 def _sanitize_url_components(comp_list, field):
815     if not comp_list:
816         return ""
817     elif comp_list[0].startswith("{}=".format(field)):
818         ret = "{}=XXXXXXXXXX&amp;".format(field)
819         comp_list.remove(comp_list[0])
820         return ret + _sanitize_url_components(comp_list, field)
821     else:
822         ret = "{}&amp;".format(comp_list[0])
823         comp_list.remove(comp_list[0])
824         return ret + _sanitize_url_components(comp_list, field)
825 def session(user=None, password=None, verify_ssl=True, ca_bundle=None, headers=None):
826     session = requests.session()
827     if user and password:
828         session.auth = (user, password)
829     if ca_bundle and not verify_ssl:
830         log.error("You cannot use both ca_bundle and verify_ssl False together")
831         return False
832     if ca_bundle:
833         opts = {"ca_bundle": ca_bundle}
834         session.verify = get_ca_bundle(opts)
835     if not verify_ssl:
836         session.verify = False
837     if headers:
838         session.headers.update(headers)
839     return session
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
