<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for qingcloud.py &amp; http.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for qingcloud.py &amp; http.py
      </h3>
<h1 align="center">
        1.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>qingcloud.py (1.9675926%)<th>http.py (1.0793651%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(28-51)<td><a href="#" name="0">(32-49)</a><td align="center"><font color="#ff0000">17</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>qingcloud.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import base64
2 import hmac
3 import logging
4 import pprint
5 import time
6 import urllib.parse
7 from hashlib import sha256
8 import salt.config as config
9 import salt.utils.cloud
10 import salt.utils.data
11 import salt.utils.json
12 from salt.exceptions import (
13     SaltCloudExecutionFailure,
14     SaltCloudExecutionTimeout,
15     SaltCloudNotFound,
16     SaltCloudSystemExit,
17 )
18 try:
19     import requests
20     HAS_REQUESTS = True
21 e</b></font>xcept ImportError:
22     HAS_REQUESTS = False
23 log = logging.getLogger(__name__)
24 __virtualname__ = "qingcloud"
25 DEFAULT_QINGCLOUD_API_VERSION = 1
26 DEFAULT_QINGCLOUD_SIGNATURE_VERSION = 1
27 def __virtual__():
28     if get_configured_provider() is False:
29         return False
30     if get_dependencies() is False:
31         return False
32     return __virtualname__
33 def _get_active_provider_name():
34     try:
35         return __active_provider_name__.value()
36     except AttributeError:
37         return __active_provider_name__
38 def get_configured_provider():
39     return config.is_provider_configured(
40         __opts__,
41         _get_active_provider_name() or __virtualname__,
42         ("access_key_id", "secret_access_key", "zone", "key_filename"),
43     )
44 def get_dependencies():
45     return config.check_driver_dependencies(__virtualname__, {"requests": HAS_REQUESTS})
46 def _compute_signature(parameters, access_key_secret, method, path):
47     parameters["signature_method"] = "HmacSHA256"
48     string_to_sign = "{}\n{}\n".format(method.upper(), path)
49     keys = sorted(parameters.keys())
50     pairs = []
51     for key in keys:
52         val = str(parameters[key]).encode("utf-8")
53         pairs.append(
54             urllib.parse.quote(key, safe="") + "=" + urllib.parse.quote(val, safe="-_~")
55         )
56     qs = "&amp;".join(pairs)
57     string_to_sign += qs
58     h = hmac.new(access_key_secret, digestmod=sha256)
59     h.update(string_to_sign)
60     signature = base64.b64encode(h.digest()).strip()
61     return signature
62 def query(params=None):
63     path = "https://api.qingcloud.com/iaas/"
64     access_key_id = config.get_cloud_config_value(
65         "access_key_id", get_configured_provider(), __opts__, search_global=False
66     )
67     access_key_secret = config.get_cloud_config_value(
68         "secret_access_key", get_configured_provider(), __opts__, search_global=False
69     )
70     verify_ssl = config.get_cloud_config_value(
71         "verify_ssl",
72         get_configured_provider(),
73         __opts__,
74         default=True,
75         search_global=False,
76     )
77     real_parameters = {
78         "access_key_id": access_key_id,
79         "signature_version": DEFAULT_QINGCLOUD_SIGNATURE_VERSION,
80         "time_stamp": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
81         "version": DEFAULT_QINGCLOUD_API_VERSION,
82     }
83     if params:
84         for key, value in params.items():
85             if isinstance(value, list):
86                 for i in range(1, len(value) + 1):
87                     if isinstance(value[i - 1], dict):
88                         for sk, sv in value[i - 1].items():
89                             if isinstance(sv, dict) or isinstance(sv, list):
90                                 sv = salt.utils.json.dumps(sv, separators=(",", ":"))
91                             real_parameters["{}.{}.{}".format(key, i, sk)] = sv
92                     else:
93                         real_parameters["{}.{}".format(key, i)] = value[i - 1]
94             else:
95                 real_parameters[key] = value
96     signature = _compute_signature(real_parameters, access_key_secret, "GET", "/iaas/")
97     real_parameters["signature"] = signature
98     request = requests.get(path, params=real_parameters, verify=verify_ssl)
99     if request.status_code != 200:
100         raise SaltCloudSystemExit(
101             "An error occurred while querying QingCloud. HTTP Code: {}  "
102             "Error: '{}'".format(request.status_code, request.text)
103         )
104     log.debug(request.url)
105     content = request.text
106     result = salt.utils.json.loads(content)
107     if result["ret_code"] != 0:
108         raise SaltCloudSystemExit(pprint.pformat(result.get("message", {})))
109     return result
110 def avail_locations(call=None):
111     if call == "action":
112         raise SaltCloudSystemExit(
113             "The avail_locations function must be called with "
114             "-f or --function, or with the --list-locations option"
115         )
116     params = {
117         "action": "DescribeZones",
118     }
119     items = query(params=params)
120     result = {}
121     for region in items["zone_set"]:
122         result[region["zone_id"]] = {}
123         for key in region:
124             result[region["zone_id"]][key] = str(region[key])
125     return result
126 def _get_location(vm_=None):
127     locations = avail_locations()
128     vm_location = str(
129         config.get_cloud_config_value("zone", vm_, __opts__, search_global=False)
130     )
131     if not vm_location:
132         raise SaltCloudNotFound("No location specified for this VM.")
133     if vm_location in locations:
134         return vm_location
135     raise SaltCloudNotFound(
136         "The specified location, '{}', could not be found.".format(vm_location)
137     )
138 def _get_specified_zone(kwargs=None, provider=None):
139     if provider is None:
140         provider = get_configured_provider()
141     if isinstance(kwargs, dict):
142         zone = kwargs.get("zone", None)
143         if zone is not None:
144             return zone
145     zone = provider["zone"]
146     return zone
147 def avail_images(kwargs=None, call=None):
148     if call == "action":
149         raise SaltCloudSystemExit(
150             "The avail_images function must be called with "
151             "-f or --function, or with the --list-images option"
152         )
153     if not isinstance(kwargs, dict):
154         kwargs = {}
155     params = {
156         "action": "DescribeImages",
157         "provider": "system",
158         "zone": _get_specified_zone(kwargs, get_configured_provider()),
159     }
160     items = query(params=params)
161     result = {}
162     for image in items["image_set"]:
163         result[image["image_id"]] = {}
164         for key in image:
165             result[image["image_id"]][key] = image[key]
166     return result
167 def _get_image(vm_):
168     images = avail_images()
169     vm_image = str(
170         config.get_cloud_config_value("image", vm_, __opts__, search_global=False)
171     )
172     if not vm_image:
173         raise SaltCloudNotFound("No image specified for this VM.")
174     if vm_image in images:
175         return vm_image
176     raise SaltCloudNotFound(
177         "The specified image, '{}', could not be found.".format(vm_image)
178     )
179 def show_image(kwargs, call=None):
180     if call != "function":
181         raise SaltCloudSystemExit(
182             "The show_images function must be called with -f or --function"
183         )
184     if not isinstance(kwargs, dict):
185         kwargs = {}
186     images = kwargs["image"]
187     images = images.split(",")
188     params = {
189         "action": "DescribeImages",
190         "images": images,
191         "zone": _get_specified_zone(kwargs, get_configured_provider()),
192     }
193     items = query(params=params)
194     if not items["image_set"]:
195         raise SaltCloudNotFound("The specified image could not be found.")
196     result = {}
197     for image in items["image_set"]:
198         result[image["image_id"]] = {}
199         for key in image:
200             result[image["image_id"]][key] = image[key]
201     return result
202 QINGCLOUD_SIZES = {
203     "pek2": {
204         "c1m1": {"cpu": 1, "memory": "1G"},
205         "c1m2": {"cpu": 1, "memory": "2G"},
206         "c1m4": {"cpu": 1, "memory": "4G"},
207         "c2m2": {"cpu": 2, "memory": "2G"},
208         "c2m4": {"cpu": 2, "memory": "4G"},
209         "c2m8": {"cpu": 2, "memory": "8G"},
210         "c4m4": {"cpu": 4, "memory": "4G"},
211         "c4m8": {"cpu": 4, "memory": "8G"},
212         "c4m16": {"cpu": 4, "memory": "16G"},
213     },
214     "pek1": {
215         "small_b": {"cpu": 1, "memory": "1G"},
216         "small_c": {"cpu": 1, "memory": "2G"},
217         "medium_a": {"cpu": 2, "memory": "2G"},
218         "medium_b": {"cpu": 2, "memory": "4G"},
219         "medium_c": {"cpu": 2, "memory": "8G"},
220         "large_a": {"cpu": 4, "memory": "4G"},
221         "large_b": {"cpu": 4, "memory": "8G"},
222         "large_c": {"cpu": 4, "memory": "16G"},
223     },
224 }
225 QINGCLOUD_SIZES["ap1"] = QINGCLOUD_SIZES["pek2"]
226 QINGCLOUD_SIZES["gd1"] = QINGCLOUD_SIZES["pek2"]
227 def avail_sizes(kwargs=None, call=None):
228     if call == "action":
229         raise SaltCloudSystemExit(
230             "The avail_sizes function must be called with "
231             "-f or --function, or with the --list-sizes option"
232         )
233     zone = _get_specified_zone(kwargs, get_configured_provider())
234     result = {}
235     for size_key in QINGCLOUD_SIZES[zone]:
236         result[size_key] = {}
237         for attribute_key in QINGCLOUD_SIZES[zone][size_key]:
238             result[size_key][attribute_key] = QINGCLOUD_SIZES[zone][size_key][
239                 attribute_key
240             ]
241     return result
242 def _get_size(vm_):
243     sizes = avail_sizes()
244     vm_size = str(
245         config.get_cloud_config_value("size", vm_, __opts__, search_global=False)
246     )
247     if not vm_size:
248         raise SaltCloudNotFound("No size specified for this instance.")
249     if vm_size in sizes.keys():
250         return vm_size
251     raise SaltCloudNotFound(
252         "The specified size, '{}', could not be found.".format(vm_size)
253     )
254 def _show_normalized_node(full_node):
255     public_ips = full_node.get("eip", [])
256     if public_ips:
257         public_ip = public_ips["eip_addr"]
258         public_ips = [
259             public_ip,
260         ]
261     private_ips = []
262     for vxnet in full_node.get("vxnets", []):
263         private_ip = vxnet.get("private_ip", None)
264         if private_ip:
265             private_ips.append(private_ip)
266     normalized_node = {
267         "id": full_node["instance_id"],
268         "image": full_node["image"]["image_id"],
269         "size": full_node["instance_type"],
270         "state": full_node["status"],
271         "private_ips": private_ips,
272         "public_ips": public_ips,
273     }
274     return normalized_node
275 def list_nodes_full(call=None):
276     if call == "action":
277         raise SaltCloudSystemExit(
278             "The list_nodes_full function must be called with -f or --function."
279         )
280     zone = _get_specified_zone()
281     params = {
282         "action": "DescribeInstances",
283         "zone": zone,
284         "status": ["pending", "running", "stopped", "suspended"],
285     }
286     items = query(params=params)
287     log.debug("Total %s instances found in zone %s", items["total_count"], zone)
288     result = {}
289     if items["total_count"] == 0:
290         return result
291     for node in items["instance_set"]:
292         normalized_node = _show_normalized_node(node)
293         node.update(normalized_node)
294         result[node["instance_id"]] = node
295     provider = _get_active_provider_name() or "qingcloud"
296     if ":" in provider:
297         comps = provider.split(":")
298         provider = comps[0]
299     __opts__["update_cachedir"] = True
300     __utils__["cloud.cache_node_list"](result, provider, __opts__)
301     return result
302 def list_nodes(call=None):
303     if call == "action":
304         raise SaltCloudSystemExit(
305             "The list_nodes function must be called with -f or --function."
306         )
307     nodes = list_nodes_full()
308     ret = {}
309     for instance_id, full_node in nodes.items():
310         ret[instance_id] = {
311             "id": full_node["id"],
312             "image": full_node["image"],
313             "size": full_node["size"],
314             "state": full_node["state"],
315             "public_ips": full_node["public_ips"],
316             "private_ips": full_node["private_ips"],
317         }
318     return ret
319 def list_nodes_min(call=None):
320     if call != "function":
321         raise SaltCloudSystemExit(
322             "The list_nodes_min function must be called with -f or --function."
323         )
324     nodes = list_nodes_full()
325     result = {}
326     for instance_id, full_node in nodes.items():
327         result[instance_id] = {
328             "name": full_node["instance_name"],
329             "status": full_node["status"],
330         }
331     return result
332 def list_nodes_select(call=None):
333     return salt.utils.cloud.list_nodes_select(
334         list_nodes_full("function"),
335         __opts__["query.selection"],
336         call,
337     )
338 def show_instance(instance_id, call=None, kwargs=None):
339     if call != "action":
340         raise SaltCloudSystemExit(
341             "The show_instance action must be called with -a or --action."
342         )
343     params = {
344         "action": "DescribeInstances",
345         "instances.1": instance_id,
346         "zone": _get_specified_zone(kwargs=None, provider=get_configured_provider()),
347     }
348     items = query(params=params)
349     if items["total_count"] == 0:
350         raise SaltCloudNotFound(
351             "The specified instance, '{}', could not be found.".format(instance_id)
352         )
353     full_node = items["instance_set"][0]
354     normalized_node = _show_normalized_node(full_node)
355     full_node.update(normalized_node)
356     result = full_node
357     return result
358 def _query_node_data(instance_id):
359     data = show_instance(instance_id, call="action")
360     if not data:
361         return False
362     if data.get("private_ips", []):
363         return data
364 def create(vm_):
365     try:
366         if (
367             vm_["profile"]
368             and config.is_profile_configured(
369                 __opts__,
370                 _get_active_provider_name() or "qingcloud",
371                 vm_["profile"],
372                 vm_=vm_,
373             )
374             is False
375         ):
376             return False
377     except AttributeError:
378         pass
379     __utils__["cloud.fire_event"](
380         "event",
381         "starting create",
382         "salt/cloud/{}/creating".format(vm_["name"]),
383         args=__utils__["cloud.filter_event"](
384             "creating", vm_, ["name", "profile", "provider", "driver"]
385         ),
386         sock_dir=__opts__["sock_dir"],
387         transport=__opts__["transport"],
388     )
389     log.info("Creating Cloud VM %s", vm_["name"])
390     params = {
391         "action": "RunInstances",
392         "instance_name": vm_["name"],
393         "zone": _get_location(vm_),
394         "instance_type": _get_size(vm_),
395         "image_id": _get_image(vm_),
396         "vxnets.1": vm_["vxnets"],
397         "login_mode": vm_["login_mode"],
398         "login_keypair": vm_["login_keypair"],
399     }
400     __utils__["cloud.fire_event"](
401         "event",
402         "requesting instance",
403         "salt/cloud/{}/requesting".format(vm_["name"]),
404         args={
405             "kwargs": __utils__["cloud.filter_event"](
406                 "requesting", params, list(params)
407             ),
408         },
409         sock_dir=__opts__["sock_dir"],
410         transport=__opts__["transport"],
411     )
412     result = query(params)
413     new_instance_id = result["instances"][0]
414     try:
415         data = salt.utils.cloud.wait_for_ip(
416             _query_node_data,
417             update_args=(new_instance_id,),
418             timeout=config.get_cloud_config_value(
419                 "wait_for_ip_timeout", vm_, __opts__, default=10 * 60
420             ),
421             interval=config.get_cloud_config_value(
422                 "wait_for_ip_interval", vm_, __opts__, default=10
423             ),
424         )
425     except (SaltCloudExecutionTimeout, SaltCloudExecutionFailure) as exc:
426         try:
427             destroy(vm_["name"])
428         except SaltCloudSystemExit:
429             pass
430         finally:
431             raise SaltCloudSystemExit(str(exc))
432     private_ip = data["private_ips"][0]
433     log.debug("VM %s is now running", private_ip)
434     vm_["ssh_host"] = private_ip
435     __utils__["cloud.bootstrap"](vm_, __opts__)
436     log.info("Created Cloud VM '%s'", vm_["name"])
437     log.debug("'%s' VM creation details:\n%s", vm_["name"], pprint.pformat(data))
438     __utils__["cloud.fire_event"](
439         "event",
440         "created instance",
441         "salt/cloud/{}/created".format(vm_["name"]),
442         args=__utils__["cloud.filter_event"](
443             "created", vm_, ["name", "profile", "provider", "driver"]
444         ),
445         sock_dir=__opts__["sock_dir"],
446         transport=__opts__["transport"],
447     )
448     return data
449 def script(vm_):
450     deploy_script = salt.utils.cloud.os_script(
451         config.get_cloud_config_value("script", vm_, __opts__),
452         vm_,
453         __opts__,
454         salt.utils.cloud.salt_config_to_yaml(
455             salt.utils.cloud.minion_config(__opts__, vm_)
456         ),
457     )
458     return deploy_script
459 def start(instance_id, call=None):
460     if call != "action":
461         raise SaltCloudSystemExit("The stop action must be called with -a or --action.")
462     log.info("Starting instance %s", instance_id)
463     params = {
464         "action": "StartInstances",
465         "zone": _get_specified_zone(provider=get_configured_provider()),
466         "instances.1": instance_id,
467     }
468     result = query(params)
469     return result
470 def stop(instance_id, force=False, call=None):
471     if call != "action":
472         raise SaltCloudSystemExit("The stop action must be called with -a or --action.")
473     log.info("Stopping instance %s", instance_id)
474     params = {
475         "action": "StopInstances",
476         "zone": _get_specified_zone(provider=get_configured_provider()),
477         "instances.1": instance_id,
478         "force": int(force),
479     }
480     result = query(params)
481     return result
482 def reboot(instance_id, call=None):
483     if call != "action":
484         raise SaltCloudSystemExit("The stop action must be called with -a or --action.")
485     log.info("Rebooting instance %s", instance_id)
486     params = {
487         "action": "RestartInstances",
488         "zone": _get_specified_zone(provider=get_configured_provider()),
489         "instances.1": instance_id,
490     }
491     result = query(params)
492     return result
493 def destroy(instance_id, call=None):
494     if call == "function":
495         raise SaltCloudSystemExit(
496             "The destroy action must be called with -d, --destroy, -a or --action."
497         )
498     instance_data = show_instance(instance_id, call="action")
499     name = instance_data["instance_name"]
500     __utils__["cloud.fire_event"](
501         "event",
502         "destroying instance",
503         "salt/cloud/{}/destroying".format(name),
504         args={"name": name},
505         sock_dir=__opts__["sock_dir"],
506         transport=__opts__["transport"],
507     )
508     params = {
509         "action": "TerminateInstances",
510         "zone": _get_specified_zone(provider=get_configured_provider()),
511         "instances.1": instance_id,
512     }
513     result = query(params)
514     __utils__["cloud.fire_event"](
515         "event",
516         "destroyed instance",
517         "salt/cloud/{}/destroyed".format(name),
518         args={"name": name},
519         sock_dir=__opts__["sock_dir"],
520         transport=__opts__["transport"],
521     )
522     return result
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>http.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import cgi
2 import gzip
3 import http.client
4 import http.cookiejar
5 import io
6 import logging
7 import os
8 import pprint
9 import re
10 import socket
11 import ssl
12 import urllib.error
13 import urllib.parse
14 import urllib.request
15 import xml.etree.ElementTree as ET
16 import zlib
17 import salt.config
18 import salt.ext.tornado.httputil
19 import salt.ext.tornado.simple_httpclient
20 import salt.loader
21 import salt.utils.args
22 import salt.utils.data
23 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import salt.utils.files
24 import salt.utils.json
25 import salt.utils.msgpack
26 import salt.utils.network
27 import salt.utils.platform
28 import salt.utils.stringutils
29 import salt.utils.xmlutil as xml
30 import salt.utils.yaml
31 import salt.version
32 from salt.ext.tornado.httpclient import HTTPClient
33 from salt.template import compile_template
34 from salt.utils.decorators.jinja import jinja_filter
35 try:
36     from ssl import CertificateError, match_hostname
37     HAS_MATCHHOSTNAME = True
38 e</b></font>xcept ImportError:
39     try:
40         from backports.ssl_match_hostname import CertificateError, match_hostname
41         HAS_MATCHHOSTNAME = True
42     except ImportError:
43         try:
44             from salt.ext.ssl_match_hostname import CertificateError, match_hostname
45             HAS_MATCHHOSTNAME = True
46         except ImportError:
47             HAS_MATCHHOSTNAME = False
48 try:
49     import salt.ext.tornado.curl_httpclient
50     HAS_CURL_HTTPCLIENT = True
51 except ImportError:
52     HAS_CURL_HTTPCLIENT = False
53 try:
54     import requests
55     HAS_REQUESTS = True
56 except ImportError:
57     HAS_REQUESTS = False
58 try:
59     import certifi
60     HAS_CERTIFI = True
61 except ImportError:
62     HAS_CERTIFI = False
63 log = logging.getLogger(__name__)
64 USERAGENT = "Salt/{}".format(salt.version.__version__)
65 def __decompressContent(coding, pgctnt):
66     if not pgctnt:
67         return pgctnt
68     log.trace(
69         "Decompressing %s byte content with compression type: %s", len(pgctnt), coding
70     )
71     if coding == "deflate":
72         pgctnt = zlib.decompress(pgctnt, -zlib.MAX_WBITS)
73     elif coding == "gzip":
74         buf = io.BytesIO(pgctnt)
75         f = gzip.GzipFile(fileobj=buf)
76         pgctnt = f.read()
77     elif coding == "sdch":
78         raise ValueError("SDCH compression is not currently supported")
79     elif coding == "br":
80         raise ValueError("Brotli compression is not currently supported")
81     elif coding == "compress":
82         raise ValueError("LZW compression is not currently supported")
83     log.trace("Content size after decompression: %s", len(pgctnt))
84     return pgctnt
85 @jinja_filter("http_query")
86 def query(
87     url,
88     method="GET",
89     params=None,
90     data=None,
91     data_file=None,
92     header_dict=None,
93     header_list=None,
94     header_file=None,
95     username=None,
96     password=None,
97     auth=None,
98     decode=False,
99     decode_type="auto",
100     status=False,
101     headers=False,
102     text=False,
103     cookies=None,
104     cookie_jar=None,
105     cookie_format="lwp",
106     persist_session=False,
107     session_cookie_jar=None,
108     data_render=False,
109     data_renderer=None,
110     header_render=False,
111     header_renderer=None,
112     template_dict=None,
113     test=False,
114     test_url=None,
115     node="minion",
116     port=80,
117     opts=None,
118     backend=None,
119     ca_bundle=None,
120     verify_ssl=None,
121     cert=None,
122     text_out=None,
123     headers_out=None,
124     decode_out=None,
125     stream=False,
126     streaming_callback=None,
127     header_callback=None,
128     handle=False,
129     agent=USERAGENT,
130     hide_fields=None,
131     raise_error=True,
132     formdata=False,
133     formdata_fieldname=None,
134     formdata_filename=None,
135     decode_body=True,
136     **kwargs
137 ):
138     ret = {}
139     if opts is None:
140         if node == "master":
141             opts = salt.config.master_config(
142                 os.path.join(salt.syspaths.CONFIG_DIR, "master")
143             )
144         elif node == "minion":
145             opts = salt.config.minion_config(
146                 os.path.join(salt.syspaths.CONFIG_DIR, "minion")
147             )
148         else:
149             opts = {}
150     if not backend:
151         backend = opts.get("backend", "tornado")
152     match = re.match(
153         r"https?://((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)($|/)",
154         url,
155     )
156     if not match:
157         salt.utils.network.refresh_dns()
158     if backend == "requests":
159         if HAS_REQUESTS is False:
160             ret["error"] = (
161                 "http.query has been set to use requests, but the "
162                 "requests library does not seem to be installed"
163             )
164             log.error(ret["error"])
165             return ret
166         else:
167             requests_log = logging.getLogger("requests")
168             requests_log.setLevel(logging.WARNING)
169     url_full = salt.ext.tornado.httputil.url_concat(url, params) if params else url
170     if ca_bundle is None:
171         ca_bundle = get_ca_bundle(opts)
172     if verify_ssl is None:
173         verify_ssl = opts.get("verify_ssl", True)
174     if cert is None:
175         cert = opts.get("cert", None)
176     if data_file is not None:
177         data = _render(data_file, data_render, data_renderer, template_dict, opts)
178     log_url = sanitize_url(url_full, hide_fields)
179     log.debug("Requesting URL %s using %s method", log_url, method)
180     log.debug("Using backend: %s", backend)
181     if method == "POST" and log.isEnabledFor(logging.TRACE):
182         if isinstance(data, dict):
183             log_data = data.copy()
184             if isinstance(hide_fields, list):
185                 for item in data:
186                     for field in hide_fields:
187                         if item == field:
188                             log_data[item] = "XXXXXXXXXX"
189             log.trace("Request POST Data: %s", pprint.pformat(log_data))
190         else:
191             log.trace("Request POST Data: %s", pprint.pformat(data))
192     if header_file is not None:
193         header_tpl = _render(
194             header_file, header_render, header_renderer, template_dict, opts
195         )
196         if isinstance(header_tpl, dict):
197             header_dict = header_tpl
198         else:
199             header_list = header_tpl.splitlines()
200     if header_dict is None:
201         header_dict = {}
202     if header_list is None:
203         header_list = []
204     if cookie_jar is None:
205         cookie_jar = os.path.join(
206             opts.get("cachedir", salt.syspaths.CACHE_DIR), "cookies.txt"
207         )
208     if session_cookie_jar is None:
209         session_cookie_jar = os.path.join(
210             opts.get("cachedir", salt.syspaths.CACHE_DIR), "cookies.session.p"
211         )
212     if persist_session is True and salt.utils.msgpack.HAS_MSGPACK:
213         if os.path.isfile(session_cookie_jar):
214             with salt.utils.files.fopen(session_cookie_jar, "rb") as fh_:
215                 session_cookies = salt.utils.msgpack.load(fh_)
216             if isinstance(session_cookies, dict):
217                 header_dict.update(session_cookies)
218         else:
219             with salt.utils.files.fopen(session_cookie_jar, "wb") as fh_:
220                 salt.utils.msgpack.dump("", fh_)
221     for header in header_list:
222         comps = header.split(":")
223         if len(comps) &lt; 2:
224             continue
225         header_dict[comps[0].strip()] = comps[1].strip()
226     if not auth:
227         if username and password:
228             auth = (username, password)
229     if agent == USERAGENT:
230         agent = "{} http.query()".format(agent)
231     header_dict["User-agent"] = agent
232     if backend == "requests":
233         sess = requests.Session()
234         sess.auth = auth
235         sess.headers.update(header_dict)
236         log.trace("Request Headers: %s", sess.headers)
237         sess_cookies = sess.cookies
238         sess.verify = verify_ssl
239     elif backend == "urllib2":
240         sess_cookies = None
241     else:
242         sess_cookies = None
243     if cookies is not None:
244         if cookie_format == "mozilla":
245             sess_cookies = http.cookiejar.MozillaCookieJar(cookie_jar)
246         else:
247             sess_cookies = http.cookiejar.LWPCookieJar(cookie_jar)
248         if not os.path.isfile(cookie_jar):
249             sess_cookies.save()
250         sess_cookies.load()
251     if test is True:
252         if test_url is None:
253             return {}
254         else:
255             url = test_url
256             ret["test"] = True
257     if backend == "requests":
258         req_kwargs = {}
259         if stream is True:
260             if requests.__version__[0] == "0":
261                 req_kwargs["prefetch"] = False
262             else:
263                 req_kwargs["stream"] = True
264         if cert is not None:
265             if isinstance(cert, str):
266                 if os.path.exists(cert):
267                     req_kwargs["cert"] = cert
268             elif isinstance(cert, list):
269                 if os.path.exists(cert[0]) and os.path.exists(cert[1]):
270                     req_kwargs["cert"] = cert
271             else:
272                 log.error(
273                     "The client-side certificate path that was passed is not valid: %s",
274                     cert,
275                 )
276         if formdata:
277             if not formdata_fieldname:
278                 ret["error"] = "formdata_fieldname is required when formdata=True"
279                 log.error(ret["error"])
280                 return ret
281             result = sess.request(
282                 method,
283                 url,
284                 params=params,
285                 files={formdata_fieldname: (formdata_filename, io.StringIO(data))},
286                 **req_kwargs
287             )
288         else:
289             result = sess.request(method, url, params=params, data=data, **req_kwargs)
290         result.raise_for_status()
291         if stream is True:
292             header_callback("HTTP/1.0 {} MESSAGE".format(result.status_code))
293             streaming_callback(result.content)
294             return {
295                 "handle": result,
296             }
297         if handle is True:
298             return {
299                 "handle": result,
300                 "body": result.content,
301             }
302         log.debug(
303             "Final URL location of Response: %s", sanitize_url(result.url, hide_fields)
304         )
305         result_status_code = result.status_code
306         result_headers = result.headers
307         result_text = result.content
308         result_cookies = result.cookies
309         body = result.content
310         if not isinstance(body, str) and decode_body:
311             body = body.decode(result.encoding or "utf-8")
312         ret["body"] = body
313     elif backend == "urllib2":
314         request = urllib.request.Request(url_full, data)
315         handlers = [
316             urllib.request.HTTPHandler,
317             urllib.request.HTTPCookieProcessor(sess_cookies),
318         ]
319         if url.startswith("https"):
320             hostname = request.get_host()
321             handlers[0] = urllib.request.HTTPSHandler(1)
322             if not HAS_MATCHHOSTNAME:
323                 log.warning(
324                     "match_hostname() not available, SSL hostname checking "
325                     "not available. THIS CONNECTION MAY NOT BE SECURE!"
326                 )
327             elif verify_ssl is False:
328                 log.warning(
329                     "SSL certificate verification has been explicitly "
330                     "disabled. THIS CONNECTION MAY NOT BE SECURE!"
331                 )
332             else:
333                 if ":" in hostname:
334                     hostname, port = hostname.split(":")
335                 else:
336                     port = 443
337                 sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
338                 sock.connect((hostname, int(port)))
339                 sockwrap = ssl.wrap_socket(
340                     sock, ca_certs=ca_bundle, cert_reqs=ssl.CERT_REQUIRED
341                 )
342                 try:
343                     match_hostname(sockwrap.getpeercert(), hostname)
344                 except CertificateError as exc:
345                     ret[
346                         "error"
347                     ] = "The certificate was invalid. Error returned was: {}".format(
348                         pprint.pformat(exc)
349                     )
350                     return ret
351                 if cert is not None:
352                     cert_chain = None
353                     if isinstance(cert, str):
354                         if os.path.exists(cert):
355                             cert_chain = cert
356                     elif isinstance(cert, list):
357                         if os.path.exists(cert[0]) and os.path.exists(cert[1]):
358                             cert_chain = cert
359                     else:
360                         log.error(
361                             "The client-side certificate path that was "
362                             "passed is not valid: %s",
363                             cert,
364                         )
365                         return
366                     if hasattr(ssl, "SSLContext"):
367                         context = ssl.SSLContext.load_cert_chain(*cert_chain)
368                         handlers.append(
369                             urllib.request.HTTPSHandler(context=context)
370                         )  # pylint: disable=E1123
371                     else:
372                         cert_kwargs = {
373                             "host": request.get_host(),
374                             "port": port,
375                             "cert_file": cert_chain[0],
376                         }
377                         if len(cert_chain) &gt; 1:
378                             cert_kwargs["key_file"] = cert_chain[1]
379                         handlers[0] = http.client.HTTPSConnection(**cert_kwargs)
380         opener = urllib.request.build_opener(*handlers)
381         for header in header_dict:
382             request.add_header(header, header_dict[header])
383         request.get_method = lambda: method
384         try:
385             result = opener.open(request)
386         except urllib.error.URLError as exc:
387             return {"Error": str(exc)}
388         if stream is True or handle is True:
389             return {
390                 "handle": result,
391                 "body": result.content,
392             }
393         result_status_code = result.code
394         result_headers = dict(result.info())
395         result_text = result.read()
396         if "Content-Type" in result_headers:
397             res_content_type, res_params = cgi.parse_header(
398                 result_headers["Content-Type"]
399             )
400             if (
401                 res_content_type.startswith("text/")
402                 and "charset" in res_params
403                 and not isinstance(result_text, str)
404             ):
405                 result_text = result_text.decode(res_params["charset"])
406         if isinstance(result_text, bytes) and decode_body:
407             result_text = result_text.decode("utf-8")
408         ret["body"] = result_text
409     else:
410         req_kwargs = {}
411         if cert is not None:
412             if isinstance(cert, str):
413                 if os.path.exists(cert):
414                     req_kwargs["client_cert"] = cert
415             elif isinstance(cert, list):
416                 if os.path.exists(cert[0]) and os.path.exists(cert[1]):
417                     req_kwargs["client_cert"] = cert[0]
418                     req_kwargs["client_key"] = cert[1]
419             else:
420                 log.error(
421                     "The client-side certificate path that was passed is not valid: %s",
422                     cert,
423                 )
424         if isinstance(data, dict):
425             data = urllib.parse.urlencode(data)
426         if verify_ssl:
427             req_kwargs["ca_certs"] = ca_bundle
428         max_body = opts.get(
429             "http_max_body", salt.config.DEFAULT_MINION_OPTS["http_max_body"]
430         )
431         connect_timeout = opts.get(
432             "http_connect_timeout",
433             salt.config.DEFAULT_MINION_OPTS["http_connect_timeout"],
434         )
435         timeout = opts.get(
436             "http_request_timeout",
437             salt.config.DEFAULT_MINION_OPTS["http_request_timeout"],
438         )
439         client_argspec = None
440         proxy_host = opts.get("proxy_host", None)
441         if proxy_host:
442             proxy_host = salt.utils.stringutils.to_str(proxy_host)
443         proxy_port = opts.get("proxy_port", None)
444         proxy_username = opts.get("proxy_username", None)
445         if proxy_username:
446             proxy_username = salt.utils.stringutils.to_str(proxy_username)
447         proxy_password = opts.get("proxy_password", None)
448         if proxy_password:
449             proxy_password = salt.utils.stringutils.to_str(proxy_password)
450         no_proxy = opts.get("no_proxy", [])
451         if urllib.parse.urlparse(url_full).hostname in no_proxy:
452             proxy_host = None
453             proxy_port = None
454             proxy_username = None
455             proxy_password = None
456         if proxy_host and proxy_port:
457             if HAS_CURL_HTTPCLIENT is False:
458                 ret["error"] = (
459                     "proxy_host and proxy_port has been set. This requires pycurl and"
460                     " tornado, but the libraries does not seem to be installed"
461                 )
462                 log.error(ret["error"])
463                 return ret
464             salt.ext.tornado.httpclient.AsyncHTTPClient.configure(
465                 "tornado.curl_httpclient.CurlAsyncHTTPClient"
466             )
467             client_argspec = salt.utils.args.get_function_argspec(
468                 salt.ext.tornado.curl_httpclient.CurlAsyncHTTPClient.initialize
469             )
470         else:
471             salt.ext.tornado.httpclient.AsyncHTTPClient.configure(None)
472             client_argspec = salt.utils.args.get_function_argspec(
473                 salt.ext.tornado.simple_httpclient.SimpleAsyncHTTPClient.initialize
474             )
475         supports_max_body_size = "max_body_size" in client_argspec.args
476         req_kwargs.update(
477             {
478                 "method": method,
479                 "headers": header_dict,
480                 "auth_username": username,
481                 "auth_password": password,
482                 "body": data,
483                 "validate_cert": verify_ssl,
484                 "allow_nonstandard_methods": True,
485                 "streaming_callback": streaming_callback,
486                 "header_callback": header_callback,
487                 "connect_timeout": connect_timeout,
488                 "request_timeout": timeout,
489                 "proxy_host": proxy_host,
490                 "proxy_port": proxy_port,
491                 "proxy_username": proxy_username,
492                 "proxy_password": proxy_password,
493                 "raise_error": raise_error,
494                 "decompress_response": False,
495             }
496         )
497         req_kwargs = salt.utils.data.decode(req_kwargs, to_str=True)
498         try:
499             download_client = (
500                 HTTPClient(max_body_size=max_body)
501                 if supports_max_body_size
502                 else HTTPClient()
503             )
504             result = download_client.fetch(url_full, **req_kwargs)
505         except salt.ext.tornado.httpclient.HTTPError as exc:
506             ret["status"] = exc.code
507             ret["error"] = str(exc)
508             return ret
509         except (socket.herror, OSError, socket.timeout, socket.gaierror) as exc:
510             if status is True:
511                 ret["status"] = 0
512             ret["error"] = str(exc)
513             log.debug("Cannot perform 'http.query': %s - %s", url_full, ret["error"])
514             return ret
515         if stream is True or handle is True:
516             return {
517                 "handle": result,
518                 "body": result.body,
519             }
520         result_status_code = result.code
521         result_headers = result.headers
522         result_text = result.body
523         if "Content-Type" in result_headers:
524             res_content_type, res_params = cgi.parse_header(
525                 result_headers["Content-Type"]
526             )
527             if (
528                 res_content_type.startswith("text/")
529                 and "charset" in res_params
530                 and not isinstance(result_text, str)
531             ):
532                 result_text = result_text.decode(res_params["charset"])
533         if isinstance(result_text, bytes) and decode_body:
534             result_text = result_text.decode("utf-8")
535         ret["body"] = result_text
536         if "Set-Cookie" in result_headers and cookies is not None:
537             result_cookies = parse_cookie_header(result_headers["Set-Cookie"])
538             for item in result_cookies:
539                 sess_cookies.set_cookie(item)
540         else:
541             result_cookies = None
542     if isinstance(result_headers, list):
543         result_headers_dict = {}
544         for header in result_headers:
545             comps = header.split(":")
546             result_headers_dict[comps[0].strip()] = ":".join(comps[1:]).strip()
547         result_headers = result_headers_dict
548     log.debug("Response Status Code: %s", result_status_code)
549     log.trace("Response Headers: %s", result_headers)
550     log.trace("Response Cookies: %s", sess_cookies)
551     coding = result_headers.get("Content-Encoding", "identity")
552     if backend != "requests":
553         result_text = __decompressContent(coding, result_text)
554     try:
555         log.trace("Response Text: %s", result_text)
556     except UnicodeEncodeError as exc:
557         log.trace(
558             "Cannot Trace Log Response Text: %s. This may be due to "
559             "incompatibilities between requests and logging.",
560             exc,
561         )
562     if text_out is not None:
563         with salt.utils.files.fopen(text_out, "w") as tof:
564             tof.write(result_text)
565     if headers_out is not None and os.path.exists(headers_out):
566         with salt.utils.files.fopen(headers_out, "w") as hof:
567             hof.write(result_headers)
568     if cookies is not None:
569         sess_cookies.save()
570     if persist_session is True and salt.utils.msgpack.HAS_MSGPACK:
571         if "set-cookie" in result_headers:
572             with salt.utils.files.fopen(session_cookie_jar, "wb") as fh_:
573                 session_cookies = result_headers.get("set-cookie", None)
574                 if session_cookies is not None:
575                     salt.utils.msgpack.dump({"Cookie": session_cookies}, fh_)
576                 else:
577                     salt.utils.msgpack.dump("", fh_)
578     if status is True:
579         ret["status"] = result_status_code
580     if headers is True:
581         ret["headers"] = result_headers
582     if decode is True:
583         if decode_type == "auto":
584             content_type = result_headers.get("content-type", "application/json")
585             if "xml" in content_type:
586                 decode_type = "xml"
587             elif "json" in content_type:
588                 decode_type = "json"
589             elif "yaml" in content_type:
590                 decode_type = "yaml"
591             else:
592                 decode_type = "plain"
593         valid_decodes = ("json", "xml", "yaml", "plain")
594         if decode_type not in valid_decodes:
595             ret[
596                 "error"
597             ] = "Invalid decode_type specified. Valid decode types are: {}".format(
598                 pprint.pformat(valid_decodes)
599             )
600             log.error(ret["error"])
601             return ret
602         if decode_type == "json":
603             ret["dict"] = salt.utils.json.loads(result_text)
604         elif decode_type == "xml":
605             ret["dict"] = []
606             items = ET.fromstring(result_text)
607             for item in items:
608                 ret["dict"].append(xml.to_dict(item))
609         elif decode_type == "yaml":
610             ret["dict"] = salt.utils.data.decode(salt.utils.yaml.safe_load(result_text))
611         else:
612             text = True
613         if decode_out:
614             with salt.utils.files.fopen(decode_out, "w") as dof:
615                 dof.write(result_text)
616     if text is True:
617         ret["text"] = result_text
618     return ret
619 def get_ca_bundle(opts=None):
620     if hasattr(get_ca_bundle, "__return_value__"):
621         return get_ca_bundle.__return_value__
622     if opts is None:
623         opts = {}
624     opts_bundle = opts.get("ca_bundle", None)
625     if opts_bundle is not None and os.path.exists(opts_bundle):
626         return opts_bundle
627     file_roots = opts.get("file_roots", {"base": [salt.syspaths.SRV_ROOT_DIR]})
628     for salt_root in file_roots.get("base", []):
629         for path in ("cacert.pem", "ca-bundle.crt"):
630             cert_path = os.path.join(salt_root, path)
631             if os.path.exists(cert_path):
632                 return cert_path
633     locations = (
634         "/etc/ssl/certs/ca-certificates.crt",
635         "/etc/pki/tls/certs/ca-bundle.crt",
636         "/etc/pki/tls/certs/ca-bundle.trust.crt",
637         "/etc/ssl/certs/ca-bundle.crt",
638         "/var/lib/ca-certificates/ca-bundle.pem",
639         "/etc/ssl/cert.pem",
640     )
641     for path in locations:
642         if os.path.exists(path):
643             return path
644     if salt.utils.platform.is_windows() and HAS_CERTIFI:
645         return certifi.where()
646     return None
647 def update_ca_bundle(
648     target=None,
649     source=None,
650     opts=None,
651     merge_files=None,
652 ):
653     if opts is None:
654         opts = {}
655     if target is None:
656         target = get_ca_bundle(opts)
657     if target is None:
658         log.error("Unable to detect location to write CA bundle to")
659         return
660     if source is None:
661         source = opts.get("ca_bundle_url", "http://curl.haxx.se/ca/cacert.pem")
662     log.debug("Attempting to download %s to %s", source, target)
663     query(source, text=True, decode=False, headers=False, status=False, text_out=target)
664     if merge_files is not None:
665         if isinstance(merge_files, str):
666             merge_files = [merge_files]
667         if not isinstance(merge_files, list):
668             log.error(
669                 "A value was passed as merge_files which was not either "
670                 "a string or a list"
671             )
672             return
673         merge_content = ""
674         for cert_file in merge_files:
675             if os.path.exists(cert_file):
676                 log.debug("Queueing up %s to be appended to %s", cert_file, target)
677                 try:
678                     with salt.utils.files.fopen(cert_file, "r") as fcf:
679                         merge_content = "\n".join((merge_content, fcf.read()))
680                 except OSError as exc:
681                     log.error(
682                         "Reading from %s caused the following error: %s", cert_file, exc
683                     )
684         if merge_content:
685             log.debug("Appending merge_files to %s", target)
686             try:
687                 with salt.utils.files.fopen(target, "a") as tfp:
688                     tfp.write("\n")
689                     tfp.write(merge_content)
690             except OSError as exc:
691                 log.error("Writing to %s caused the following error: %s", target, exc)
692 def _render(template, render, renderer, template_dict, opts):
693     if render:
694         if template_dict is None:
695             template_dict = {}
696         if not renderer:
697             renderer = opts.get("renderer", "jinja|yaml")
698         rend = salt.loader.render(opts, {})
699         blacklist = opts.get("renderer_blacklist")
700         whitelist = opts.get("renderer_whitelist")
701         ret = compile_template(
702             template, rend, renderer, blacklist, whitelist, **template_dict
703         )
704         if salt.utils.stringio.is_readable(ret):
705             ret = ret.read()
706         if str(ret).startswith("#!") and not str(ret).startswith("#!/"):
707             ret = str(ret).split("\n", 1)[1]
708         return ret
709     with salt.utils.files.fopen(template, "r") as fh_:
710         return fh_.read()
711 def parse_cookie_header(header):
712     attribs = (
713         "expires",
714         "path",
715         "domain",
716         "version",
717         "httponly",
718         "secure",
719         "comment",
720         "max-age",
721         "samesite",
722     )
723     morsels = []
724     for item in header.split(";"):
725         item = item.strip()
726         if "," in item and "expires" not in item:
727             for part in item.split(","):
728                 morsels.append(part)
729         else:
730             morsels.append(item)
731     cookies = []
732     cookie = {}
733     value_set = False
734     for morsel in morsels:
735         parts = morsel.split("=")
736         parts[0] = parts[0].lower()
737         if parts[0] in attribs:
738             if parts[0] in cookie:
739                 cookies.append(cookie)
740                 cookie = {}
741             if len(parts) &gt; 1:
742                 cookie[parts[0]] = "=".join(parts[1:])
743             else:
744                 cookie[parts[0]] = True
745         else:
746             if value_set is True:
747                 cookies.append(cookie)
748                 cookie = {}
749                 value_set = False
750             cookie[parts[0]] = "=".join(parts[1:])
751             value_set = True
752     if cookie:
753         cookies.append(cookie)
754     reqd = (
755         "version",
756         "port",
757         "port_specified",
758         "domain",
759         "domain_specified",
760         "domain_initial_dot",
761         "path",
762         "path_specified",
763         "secure",
764         "expires",
765         "discard",
766         "comment",
767         "comment_url",
768         "rest",
769     )
770     ret = []
771     for cookie in cookies:
772         name = None
773         value = None
774         for item in list(cookie):
775             if item in attribs:
776                 continue
777             name = item
778             value = cookie.pop(item)
779         if "expires" in cookie:
780             cookie["expires"] = http.cookiejar.http2time(cookie["expires"])
781         for req in reqd:
782             if req not in cookie:
783                 cookie[req] = ""
784         if cookie["version"] == "":
785             cookie["version"] = 0
786         if cookie["rest"] == "":
787             cookie["rest"] = {}
788         if cookie["expires"] == "":
789             cookie["expires"] = 0
790         cookie.pop("httponly", None)
791         cookie.pop("samesite", None)
792         ret.append(http.cookiejar.Cookie(name=name, value=value, **cookie))
793     return ret
794 def sanitize_url(url, hide_fields):
795     if isinstance(hide_fields, list):
796         url_comps = urllib.parse.splitquery(url)
797         log_url = url_comps[0]
798         if len(url_comps) &gt; 1:
799             log_url += "?"
800         for pair in url_comps[1:]:
801             url_tmp = None
802             for field in hide_fields:
803                 comps_list = pair.split("&amp;")
804                 if url_tmp:
805                     url_tmp = url_tmp.split("&amp;")
806                     url_tmp = _sanitize_url_components(url_tmp, field)
807                 else:
808                     url_tmp = _sanitize_url_components(comps_list, field)
809             log_url += url_tmp
810         return log_url.rstrip("&amp;")
811     else:
812         return str(url)
813 def _sanitize_url_components(comp_list, field):
814     if not comp_list:
815         return ""
816     elif comp_list[0].startswith("{}=".format(field)):
817         ret = "{}=XXXXXXXXXX&amp;".format(field)
818         comp_list.remove(comp_list[0])
819         return ret + _sanitize_url_components(comp_list, field)
820     else:
821         ret = "{}&amp;".format(comp_list[0])
822         comp_list.remove(comp_list[0])
823         return ret + _sanitize_url_components(comp_list, field)
824 def session(user=None, password=None, verify_ssl=True, ca_bundle=None, headers=None):
825     session = requests.session()
826     if user and password:
827         session.auth = (user, password)
828     if ca_bundle and not verify_ssl:
829         log.error("You cannot use both ca_bundle and verify_ssl False together")
830         return False
831     if ca_bundle:
832         opts = {"ca_bundle": ca_bundle}
833         session.verify = get_ca_bundle(opts)
834     if not verify_ssl:
835         session.verify = False
836     if headers:
837         session.headers.update(headers)
838     return session
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
