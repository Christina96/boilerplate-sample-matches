<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for qingcloud.py &amp; http.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for qingcloud.py &amp; http.py
      </h3>
<h1 align="center">
        1.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>qingcloud.py (1.9675926%)<th>http.py (1.0793651%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(28-51)<td><a href="#" name="0">(32-49)</a><td align="center"><font color="#ff0000">17</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>qingcloud.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import base64
import hmac
import logging
import pprint
import time
import urllib.parse
from hashlib import sha256
import salt.config as config
import salt.utils.cloud
import salt.utils.data
import salt.utils.json
from salt.exceptions import (
    SaltCloudExecutionFailure,
    SaltCloudExecutionTimeout,
    SaltCloudNotFound,
    SaltCloudSystemExit,
)
try:
    import requests
    HAS_REQUESTS = True
e</b></font>xcept ImportError:
    HAS_REQUESTS = False
log = logging.getLogger(__name__)
__virtualname__ = "qingcloud"
DEFAULT_QINGCLOUD_API_VERSION = 1
DEFAULT_QINGCLOUD_SIGNATURE_VERSION = 1
def __virtual__():
    if get_configured_provider() is False:
        return False
    if get_dependencies() is False:
        return False
    return __virtualname__
def _get_active_provider_name():
    try:
        return __active_provider_name__.value()
    except AttributeError:
        return __active_provider_name__
def get_configured_provider():
    return config.is_provider_configured(
        __opts__,
        _get_active_provider_name() or __virtualname__,
        ("access_key_id", "secret_access_key", "zone", "key_filename"),
    )
def get_dependencies():
    return config.check_driver_dependencies(__virtualname__, {"requests": HAS_REQUESTS})
def _compute_signature(parameters, access_key_secret, method, path):
    parameters["signature_method"] = "HmacSHA256"
    string_to_sign = "{}\n{}\n".format(method.upper(), path)
    keys = sorted(parameters.keys())
    pairs = []
    for key in keys:
        val = str(parameters[key]).encode("utf-8")
        pairs.append(
            urllib.parse.quote(key, safe="") + "=" + urllib.parse.quote(val, safe="-_~")
        )
    qs = "&amp;".join(pairs)
    string_to_sign += qs
    h = hmac.new(access_key_secret, digestmod=sha256)
    h.update(string_to_sign)
    signature = base64.b64encode(h.digest()).strip()
    return signature
def query(params=None):
    path = "https://api.qingcloud.com/iaas/"
    access_key_id = config.get_cloud_config_value(
        "access_key_id", get_configured_provider(), __opts__, search_global=False
    )
    access_key_secret = config.get_cloud_config_value(
        "secret_access_key", get_configured_provider(), __opts__, search_global=False
    )
    verify_ssl = config.get_cloud_config_value(
        "verify_ssl",
        get_configured_provider(),
        __opts__,
        default=True,
        search_global=False,
    )
    real_parameters = {
        "access_key_id": access_key_id,
        "signature_version": DEFAULT_QINGCLOUD_SIGNATURE_VERSION,
        "time_stamp": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
        "version": DEFAULT_QINGCLOUD_API_VERSION,
    }
    if params:
        for key, value in params.items():
            if isinstance(value, list):
                for i in range(1, len(value) + 1):
                    if isinstance(value[i - 1], dict):
                        for sk, sv in value[i - 1].items():
                            if isinstance(sv, dict) or isinstance(sv, list):
                                sv = salt.utils.json.dumps(sv, separators=(",", ":"))
                            real_parameters["{}.{}.{}".format(key, i, sk)] = sv
                    else:
                        real_parameters["{}.{}".format(key, i)] = value[i - 1]
            else:
                real_parameters[key] = value
    signature = _compute_signature(real_parameters, access_key_secret, "GET", "/iaas/")
    real_parameters["signature"] = signature
    request = requests.get(path, params=real_parameters, verify=verify_ssl)
    if request.status_code != 200:
        raise SaltCloudSystemExit(
            "An error occurred while querying QingCloud. HTTP Code: {}  "
            "Error: '{}'".format(request.status_code, request.text)
        )
    log.debug(request.url)
    content = request.text
    result = salt.utils.json.loads(content)
    if result["ret_code"] != 0:
        raise SaltCloudSystemExit(pprint.pformat(result.get("message", {})))
    return result
def avail_locations(call=None):
    if call == "action":
        raise SaltCloudSystemExit(
            "The avail_locations function must be called with "
            "-f or --function, or with the --list-locations option"
        )
    params = {
        "action": "DescribeZones",
    }
    items = query(params=params)
    result = {}
    for region in items["zone_set"]:
        result[region["zone_id"]] = {}
        for key in region:
            result[region["zone_id"]][key] = str(region[key])
    return result
def _get_location(vm_=None):
    locations = avail_locations()
    vm_location = str(
        config.get_cloud_config_value("zone", vm_, __opts__, search_global=False)
    )
    if not vm_location:
        raise SaltCloudNotFound("No location specified for this VM.")
    if vm_location in locations:
        return vm_location
    raise SaltCloudNotFound(
        "The specified location, '{}', could not be found.".format(vm_location)
    )
def _get_specified_zone(kwargs=None, provider=None):
    if provider is None:
        provider = get_configured_provider()
    if isinstance(kwargs, dict):
        zone = kwargs.get("zone", None)
        if zone is not None:
            return zone
    zone = provider["zone"]
    return zone
def avail_images(kwargs=None, call=None):
    if call == "action":
        raise SaltCloudSystemExit(
            "The avail_images function must be called with "
            "-f or --function, or with the --list-images option"
        )
    if not isinstance(kwargs, dict):
        kwargs = {}
    params = {
        "action": "DescribeImages",
        "provider": "system",
        "zone": _get_specified_zone(kwargs, get_configured_provider()),
    }
    items = query(params=params)
    result = {}
    for image in items["image_set"]:
        result[image["image_id"]] = {}
        for key in image:
            result[image["image_id"]][key] = image[key]
    return result
def _get_image(vm_):
    images = avail_images()
    vm_image = str(
        config.get_cloud_config_value("image", vm_, __opts__, search_global=False)
    )
    if not vm_image:
        raise SaltCloudNotFound("No image specified for this VM.")
    if vm_image in images:
        return vm_image
    raise SaltCloudNotFound(
        "The specified image, '{}', could not be found.".format(vm_image)
    )
def show_image(kwargs, call=None):
    if call != "function":
        raise SaltCloudSystemExit(
            "The show_images function must be called with -f or --function"
        )
    if not isinstance(kwargs, dict):
        kwargs = {}
    images = kwargs["image"]
    images = images.split(",")
    params = {
        "action": "DescribeImages",
        "images": images,
        "zone": _get_specified_zone(kwargs, get_configured_provider()),
    }
    items = query(params=params)
    if not items["image_set"]:
        raise SaltCloudNotFound("The specified image could not be found.")
    result = {}
    for image in items["image_set"]:
        result[image["image_id"]] = {}
        for key in image:
            result[image["image_id"]][key] = image[key]
    return result
QINGCLOUD_SIZES = {
    "pek2": {
        "c1m1": {"cpu": 1, "memory": "1G"},
        "c1m2": {"cpu": 1, "memory": "2G"},
        "c1m4": {"cpu": 1, "memory": "4G"},
        "c2m2": {"cpu": 2, "memory": "2G"},
        "c2m4": {"cpu": 2, "memory": "4G"},
        "c2m8": {"cpu": 2, "memory": "8G"},
        "c4m4": {"cpu": 4, "memory": "4G"},
        "c4m8": {"cpu": 4, "memory": "8G"},
        "c4m16": {"cpu": 4, "memory": "16G"},
    },
    "pek1": {
        "small_b": {"cpu": 1, "memory": "1G"},
        "small_c": {"cpu": 1, "memory": "2G"},
        "medium_a": {"cpu": 2, "memory": "2G"},
        "medium_b": {"cpu": 2, "memory": "4G"},
        "medium_c": {"cpu": 2, "memory": "8G"},
        "large_a": {"cpu": 4, "memory": "4G"},
        "large_b": {"cpu": 4, "memory": "8G"},
        "large_c": {"cpu": 4, "memory": "16G"},
    },
}
QINGCLOUD_SIZES["ap1"] = QINGCLOUD_SIZES["pek2"]
QINGCLOUD_SIZES["gd1"] = QINGCLOUD_SIZES["pek2"]
def avail_sizes(kwargs=None, call=None):
    if call == "action":
        raise SaltCloudSystemExit(
            "The avail_sizes function must be called with "
            "-f or --function, or with the --list-sizes option"
        )
    zone = _get_specified_zone(kwargs, get_configured_provider())
    result = {}
    for size_key in QINGCLOUD_SIZES[zone]:
        result[size_key] = {}
        for attribute_key in QINGCLOUD_SIZES[zone][size_key]:
            result[size_key][attribute_key] = QINGCLOUD_SIZES[zone][size_key][
                attribute_key
            ]
    return result
def _get_size(vm_):
    sizes = avail_sizes()
    vm_size = str(
        config.get_cloud_config_value("size", vm_, __opts__, search_global=False)
    )
    if not vm_size:
        raise SaltCloudNotFound("No size specified for this instance.")
    if vm_size in sizes.keys():
        return vm_size
    raise SaltCloudNotFound(
        "The specified size, '{}', could not be found.".format(vm_size)
    )
def _show_normalized_node(full_node):
    public_ips = full_node.get("eip", [])
    if public_ips:
        public_ip = public_ips["eip_addr"]
        public_ips = [
            public_ip,
        ]
    private_ips = []
    for vxnet in full_node.get("vxnets", []):
        private_ip = vxnet.get("private_ip", None)
        if private_ip:
            private_ips.append(private_ip)
    normalized_node = {
        "id": full_node["instance_id"],
        "image": full_node["image"]["image_id"],
        "size": full_node["instance_type"],
        "state": full_node["status"],
        "private_ips": private_ips,
        "public_ips": public_ips,
    }
    return normalized_node
def list_nodes_full(call=None):
    if call == "action":
        raise SaltCloudSystemExit(
            "The list_nodes_full function must be called with -f or --function."
        )
    zone = _get_specified_zone()
    params = {
        "action": "DescribeInstances",
        "zone": zone,
        "status": ["pending", "running", "stopped", "suspended"],
    }
    items = query(params=params)
    log.debug("Total %s instances found in zone %s", items["total_count"], zone)
    result = {}
    if items["total_count"] == 0:
        return result
    for node in items["instance_set"]:
        normalized_node = _show_normalized_node(node)
        node.update(normalized_node)
        result[node["instance_id"]] = node
    provider = _get_active_provider_name() or "qingcloud"
    if ":" in provider:
        comps = provider.split(":")
        provider = comps[0]
    __opts__["update_cachedir"] = True
    __utils__["cloud.cache_node_list"](result, provider, __opts__)
    return result
def list_nodes(call=None):
    if call == "action":
        raise SaltCloudSystemExit(
            "The list_nodes function must be called with -f or --function."
        )
    nodes = list_nodes_full()
    ret = {}
    for instance_id, full_node in nodes.items():
        ret[instance_id] = {
            "id": full_node["id"],
            "image": full_node["image"],
            "size": full_node["size"],
            "state": full_node["state"],
            "public_ips": full_node["public_ips"],
            "private_ips": full_node["private_ips"],
        }
    return ret
def list_nodes_min(call=None):
    if call != "function":
        raise SaltCloudSystemExit(
            "The list_nodes_min function must be called with -f or --function."
        )
    nodes = list_nodes_full()
    result = {}
    for instance_id, full_node in nodes.items():
        result[instance_id] = {
            "name": full_node["instance_name"],
            "status": full_node["status"],
        }
    return result
def list_nodes_select(call=None):
    return salt.utils.cloud.list_nodes_select(
        list_nodes_full("function"),
        __opts__["query.selection"],
        call,
    )
def show_instance(instance_id, call=None, kwargs=None):
    if call != "action":
        raise SaltCloudSystemExit(
            "The show_instance action must be called with -a or --action."
        )
    params = {
        "action": "DescribeInstances",
        "instances.1": instance_id,
        "zone": _get_specified_zone(kwargs=None, provider=get_configured_provider()),
    }
    items = query(params=params)
    if items["total_count"] == 0:
        raise SaltCloudNotFound(
            "The specified instance, '{}', could not be found.".format(instance_id)
        )
    full_node = items["instance_set"][0]
    normalized_node = _show_normalized_node(full_node)
    full_node.update(normalized_node)
    result = full_node
    return result
def _query_node_data(instance_id):
    data = show_instance(instance_id, call="action")
    if not data:
        return False
    if data.get("private_ips", []):
        return data
def create(vm_):
    try:
        if (
            vm_["profile"]
            and config.is_profile_configured(
                __opts__,
                _get_active_provider_name() or "qingcloud",
                vm_["profile"],
                vm_=vm_,
            )
            is False
        ):
            return False
    except AttributeError:
        pass
    __utils__["cloud.fire_event"](
        "event",
        "starting create",
        "salt/cloud/{}/creating".format(vm_["name"]),
        args=__utils__["cloud.filter_event"](
            "creating", vm_, ["name", "profile", "provider", "driver"]
        ),
        sock_dir=__opts__["sock_dir"],
        transport=__opts__["transport"],
    )
    log.info("Creating Cloud VM %s", vm_["name"])
    params = {
        "action": "RunInstances",
        "instance_name": vm_["name"],
        "zone": _get_location(vm_),
        "instance_type": _get_size(vm_),
        "image_id": _get_image(vm_),
        "vxnets.1": vm_["vxnets"],
        "login_mode": vm_["login_mode"],
        "login_keypair": vm_["login_keypair"],
    }
    __utils__["cloud.fire_event"](
        "event",
        "requesting instance",
        "salt/cloud/{}/requesting".format(vm_["name"]),
        args={
            "kwargs": __utils__["cloud.filter_event"](
                "requesting", params, list(params)
            ),
        },
        sock_dir=__opts__["sock_dir"],
        transport=__opts__["transport"],
    )
    result = query(params)
    new_instance_id = result["instances"][0]
    try:
        data = salt.utils.cloud.wait_for_ip(
            _query_node_data,
            update_args=(new_instance_id,),
            timeout=config.get_cloud_config_value(
                "wait_for_ip_timeout", vm_, __opts__, default=10 * 60
            ),
            interval=config.get_cloud_config_value(
                "wait_for_ip_interval", vm_, __opts__, default=10
            ),
        )
    except (SaltCloudExecutionTimeout, SaltCloudExecutionFailure) as exc:
        try:
            destroy(vm_["name"])
        except SaltCloudSystemExit:
            pass
        finally:
            raise SaltCloudSystemExit(str(exc))
    private_ip = data["private_ips"][0]
    log.debug("VM %s is now running", private_ip)
    vm_["ssh_host"] = private_ip
    __utils__["cloud.bootstrap"](vm_, __opts__)
    log.info("Created Cloud VM '%s'", vm_["name"])
    log.debug("'%s' VM creation details:\n%s", vm_["name"], pprint.pformat(data))
    __utils__["cloud.fire_event"](
        "event",
        "created instance",
        "salt/cloud/{}/created".format(vm_["name"]),
        args=__utils__["cloud.filter_event"](
            "created", vm_, ["name", "profile", "provider", "driver"]
        ),
        sock_dir=__opts__["sock_dir"],
        transport=__opts__["transport"],
    )
    return data
def script(vm_):
    deploy_script = salt.utils.cloud.os_script(
        config.get_cloud_config_value("script", vm_, __opts__),
        vm_,
        __opts__,
        salt.utils.cloud.salt_config_to_yaml(
            salt.utils.cloud.minion_config(__opts__, vm_)
        ),
    )
    return deploy_script
def start(instance_id, call=None):
    if call != "action":
        raise SaltCloudSystemExit("The stop action must be called with -a or --action.")
    log.info("Starting instance %s", instance_id)
    params = {
        "action": "StartInstances",
        "zone": _get_specified_zone(provider=get_configured_provider()),
        "instances.1": instance_id,
    }
    result = query(params)
    return result
def stop(instance_id, force=False, call=None):
    if call != "action":
        raise SaltCloudSystemExit("The stop action must be called with -a or --action.")
    log.info("Stopping instance %s", instance_id)
    params = {
        "action": "StopInstances",
        "zone": _get_specified_zone(provider=get_configured_provider()),
        "instances.1": instance_id,
        "force": int(force),
    }
    result = query(params)
    return result
def reboot(instance_id, call=None):
    if call != "action":
        raise SaltCloudSystemExit("The stop action must be called with -a or --action.")
    log.info("Rebooting instance %s", instance_id)
    params = {
        "action": "RestartInstances",
        "zone": _get_specified_zone(provider=get_configured_provider()),
        "instances.1": instance_id,
    }
    result = query(params)
    return result
def destroy(instance_id, call=None):
    if call == "function":
        raise SaltCloudSystemExit(
            "The destroy action must be called with -d, --destroy, -a or --action."
        )
    instance_data = show_instance(instance_id, call="action")
    name = instance_data["instance_name"]
    __utils__["cloud.fire_event"](
        "event",
        "destroying instance",
        "salt/cloud/{}/destroying".format(name),
        args={"name": name},
        sock_dir=__opts__["sock_dir"],
        transport=__opts__["transport"],
    )
    params = {
        "action": "TerminateInstances",
        "zone": _get_specified_zone(provider=get_configured_provider()),
        "instances.1": instance_id,
    }
    result = query(params)
    __utils__["cloud.fire_event"](
        "event",
        "destroyed instance",
        "salt/cloud/{}/destroyed".format(name),
        args={"name": name},
        sock_dir=__opts__["sock_dir"],
        transport=__opts__["transport"],
    )
    return result
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>http.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import cgi
import gzip
import http.client
import http.cookiejar
import io
import logging
import os
import pprint
import re
import socket
import ssl
import urllib.error
import urllib.parse
import urllib.request
import xml.etree.ElementTree as ET
import zlib
import salt.config
import salt.ext.tornado.httputil
import salt.ext.tornado.simple_httpclient
import salt.loader
<a name="0"></a>import salt.syspaths
import salt.utils.args
import salt.utils.data
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import salt.utils.files
import salt.utils.json
import salt.utils.msgpack
import salt.utils.network
import salt.utils.platform
import salt.utils.stringutils
import salt.utils.xmlutil as xml
import salt.utils.yaml
import salt.version
from salt.ext.tornado.httpclient import HTTPClient
from salt.template import compile_template
from salt.utils.decorators.jinja import jinja_filter
try:
    from ssl import CertificateError, match_hostname
    HAS_MATCHHOSTNAME = True
e</b></font>xcept ImportError:
    try:
        from backports.ssl_match_hostname import CertificateError, match_hostname
        HAS_MATCHHOSTNAME = True
    except ImportError:
        try:
            from salt.ext.ssl_match_hostname import CertificateError, match_hostname
            HAS_MATCHHOSTNAME = True
        except ImportError:
            HAS_MATCHHOSTNAME = False
try:
    import salt.ext.tornado.curl_httpclient
    HAS_CURL_HTTPCLIENT = True
except ImportError:
    HAS_CURL_HTTPCLIENT = False
try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False
try:
    import certifi
    HAS_CERTIFI = True
except ImportError:
    HAS_CERTIFI = False
log = logging.getLogger(__name__)
USERAGENT = "Salt/{}".format(salt.version.__version__)
def __decompressContent(coding, pgctnt):
    if not pgctnt:
        return pgctnt
    log.trace(
        "Decompressing %s byte content with compression type: %s", len(pgctnt), coding
    )
    if coding == "deflate":
        pgctnt = zlib.decompress(pgctnt, -zlib.MAX_WBITS)
    elif coding == "gzip":
        buf = io.BytesIO(pgctnt)
        f = gzip.GzipFile(fileobj=buf)
        pgctnt = f.read()
    elif coding == "sdch":
        raise ValueError("SDCH compression is not currently supported")
    elif coding == "br":
        raise ValueError("Brotli compression is not currently supported")
    elif coding == "compress":
        raise ValueError("LZW compression is not currently supported")
    log.trace("Content size after decompression: %s", len(pgctnt))
    return pgctnt
@jinja_filter("http_query")
def query(
    url,
    method="GET",
    params=None,
    data=None,
    data_file=None,
    header_dict=None,
    header_list=None,
    header_file=None,
    username=None,
    password=None,
    auth=None,
    decode=False,
    decode_type="auto",
    status=False,
    headers=False,
    text=False,
    cookies=None,
    cookie_jar=None,
    cookie_format="lwp",
    persist_session=False,
    session_cookie_jar=None,
    data_render=False,
    data_renderer=None,
    header_render=False,
    header_renderer=None,
    template_dict=None,
    test=False,
    test_url=None,
    node="minion",
    port=80,
    opts=None,
    backend=None,
    ca_bundle=None,
    verify_ssl=None,
    cert=None,
    text_out=None,
    headers_out=None,
    decode_out=None,
    stream=False,
    streaming_callback=None,
    header_callback=None,
    handle=False,
    agent=USERAGENT,
    hide_fields=None,
    raise_error=True,
    formdata=False,
    formdata_fieldname=None,
    formdata_filename=None,
    decode_body=True,
    **kwargs
):
    ret = {}
    if opts is None:
        if node == "master":
            opts = salt.config.master_config(
                os.path.join(salt.syspaths.CONFIG_DIR, "master")
            )
        elif node == "minion":
            opts = salt.config.minion_config(
                os.path.join(salt.syspaths.CONFIG_DIR, "minion")
            )
        else:
            opts = {}
    if not backend:
        backend = opts.get("backend", "tornado")
    match = re.match(
        r"https?://((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)($|/)",
        url,
    )
    if not match:
        salt.utils.network.refresh_dns()
    if backend == "requests":
        if HAS_REQUESTS is False:
            ret["error"] = (
                "http.query has been set to use requests, but the "
                "requests library does not seem to be installed"
            )
            log.error(ret["error"])
            return ret
        else:
            requests_log = logging.getLogger("requests")
            requests_log.setLevel(logging.WARNING)
    url_full = salt.ext.tornado.httputil.url_concat(url, params) if params else url
    if ca_bundle is None:
        ca_bundle = get_ca_bundle(opts)
    if verify_ssl is None:
        verify_ssl = opts.get("verify_ssl", True)
    if cert is None:
        cert = opts.get("cert", None)
    if data_file is not None:
        data = _render(data_file, data_render, data_renderer, template_dict, opts)
    log_url = sanitize_url(url_full, hide_fields)
    log.debug("Requesting URL %s using %s method", log_url, method)
    log.debug("Using backend: %s", backend)
    if method == "POST" and log.isEnabledFor(logging.TRACE):
        if isinstance(data, dict):
            log_data = data.copy()
            if isinstance(hide_fields, list):
                for item in data:
                    for field in hide_fields:
                        if item == field:
                            log_data[item] = "XXXXXXXXXX"
            log.trace("Request POST Data: %s", pprint.pformat(log_data))
        else:
            log.trace("Request POST Data: %s", pprint.pformat(data))
    if header_file is not None:
        header_tpl = _render(
            header_file, header_render, header_renderer, template_dict, opts
        )
        if isinstance(header_tpl, dict):
            header_dict = header_tpl
        else:
            header_list = header_tpl.splitlines()
    if header_dict is None:
        header_dict = {}
    if header_list is None:
        header_list = []
    if cookie_jar is None:
        cookie_jar = os.path.join(
            opts.get("cachedir", salt.syspaths.CACHE_DIR), "cookies.txt"
        )
    if session_cookie_jar is None:
        session_cookie_jar = os.path.join(
            opts.get("cachedir", salt.syspaths.CACHE_DIR), "cookies.session.p"
        )
    if persist_session is True and salt.utils.msgpack.HAS_MSGPACK:
        if os.path.isfile(session_cookie_jar):
            with salt.utils.files.fopen(session_cookie_jar, "rb") as fh_:
                session_cookies = salt.utils.msgpack.load(fh_)
            if isinstance(session_cookies, dict):
                header_dict.update(session_cookies)
        else:
            with salt.utils.files.fopen(session_cookie_jar, "wb") as fh_:
                salt.utils.msgpack.dump("", fh_)
    for header in header_list:
        comps = header.split(":")
        if len(comps) &lt; 2:
            continue
        header_dict[comps[0].strip()] = comps[1].strip()
    if not auth:
        if username and password:
            auth = (username, password)
    if agent == USERAGENT:
        agent = "{} http.query()".format(agent)
    header_dict["User-agent"] = agent
    if backend == "requests":
        sess = requests.Session()
        sess.auth = auth
        sess.headers.update(header_dict)
        log.trace("Request Headers: %s", sess.headers)
        sess_cookies = sess.cookies
        sess.verify = verify_ssl
    elif backend == "urllib2":
        sess_cookies = None
    else:
        sess_cookies = None
    if cookies is not None:
        if cookie_format == "mozilla":
            sess_cookies = http.cookiejar.MozillaCookieJar(cookie_jar)
        else:
            sess_cookies = http.cookiejar.LWPCookieJar(cookie_jar)
        if not os.path.isfile(cookie_jar):
            sess_cookies.save()
        sess_cookies.load()
    if test is True:
        if test_url is None:
            return {}
        else:
            url = test_url
            ret["test"] = True
    if backend == "requests":
        req_kwargs = {}
        if stream is True:
            if requests.__version__[0] == "0":
                req_kwargs["prefetch"] = False
            else:
                req_kwargs["stream"] = True
        if cert is not None:
            if isinstance(cert, str):
                if os.path.exists(cert):
                    req_kwargs["cert"] = cert
            elif isinstance(cert, list):
                if os.path.exists(cert[0]) and os.path.exists(cert[1]):
                    req_kwargs["cert"] = cert
            else:
                log.error(
                    "The client-side certificate path that was passed is not valid: %s",
                    cert,
                )
        if formdata:
            if not formdata_fieldname:
                ret["error"] = "formdata_fieldname is required when formdata=True"
                log.error(ret["error"])
                return ret
            result = sess.request(
                method,
                url,
                params=params,
                files={formdata_fieldname: (formdata_filename, io.StringIO(data))},
                **req_kwargs
            )
        else:
            result = sess.request(method, url, params=params, data=data, **req_kwargs)
        result.raise_for_status()
        if stream is True:
            header_callback("HTTP/1.0 {} MESSAGE".format(result.status_code))
            streaming_callback(result.content)
            return {
                "handle": result,
            }
        if handle is True:
            return {
                "handle": result,
                "body": result.content,
            }
        log.debug(
            "Final URL location of Response: %s", sanitize_url(result.url, hide_fields)
        )
        result_status_code = result.status_code
        result_headers = result.headers
        result_text = result.content
        result_cookies = result.cookies
        body = result.content
        if not isinstance(body, str) and decode_body:
            body = body.decode(result.encoding or "utf-8")
        ret["body"] = body
    elif backend == "urllib2":
        request = urllib.request.Request(url_full, data)
        handlers = [
            urllib.request.HTTPHandler,
            urllib.request.HTTPCookieProcessor(sess_cookies),
        ]
        if url.startswith("https"):
            hostname = request.get_host()
            handlers[0] = urllib.request.HTTPSHandler(1)
            if not HAS_MATCHHOSTNAME:
                log.warning(
                    "match_hostname() not available, SSL hostname checking "
                    "not available. THIS CONNECTION MAY NOT BE SECURE!"
                )
            elif verify_ssl is False:
                log.warning(
                    "SSL certificate verification has been explicitly "
                    "disabled. THIS CONNECTION MAY NOT BE SECURE!"
                )
            else:
                if ":" in hostname:
                    hostname, port = hostname.split(":")
                else:
                    port = 443
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.connect((hostname, int(port)))
                sockwrap = ssl.wrap_socket(
                    sock, ca_certs=ca_bundle, cert_reqs=ssl.CERT_REQUIRED
                )
                try:
                    match_hostname(sockwrap.getpeercert(), hostname)
                except CertificateError as exc:
                    ret[
                        "error"
                    ] = "The certificate was invalid. Error returned was: {}".format(
                        pprint.pformat(exc)
                    )
                    return ret
                if cert is not None:
                    cert_chain = None
                    if isinstance(cert, str):
                        if os.path.exists(cert):
                            cert_chain = cert
                    elif isinstance(cert, list):
                        if os.path.exists(cert[0]) and os.path.exists(cert[1]):
                            cert_chain = cert
                    else:
                        log.error(
                            "The client-side certificate path that was "
                            "passed is not valid: %s",
                            cert,
                        )
                        return
                    if hasattr(ssl, "SSLContext"):
                        context = ssl.SSLContext.load_cert_chain(*cert_chain)
                        handlers.append(
                            urllib.request.HTTPSHandler(context=context)
                        )  # pylint: disable=E1123
                    else:
                        cert_kwargs = {
                            "host": request.get_host(),
                            "port": port,
                            "cert_file": cert_chain[0],
                        }
                        if len(cert_chain) &gt; 1:
                            cert_kwargs["key_file"] = cert_chain[1]
                        handlers[0] = http.client.HTTPSConnection(**cert_kwargs)
        opener = urllib.request.build_opener(*handlers)
        for header in header_dict:
            request.add_header(header, header_dict[header])
        request.get_method = lambda: method
        try:
            result = opener.open(request)
        except urllib.error.URLError as exc:
            return {"Error": str(exc)}
        if stream is True or handle is True:
            return {
                "handle": result,
                "body": result.content,
            }
        result_status_code = result.code
        result_headers = dict(result.info())
        result_text = result.read()
        if "Content-Type" in result_headers:
            res_content_type, res_params = cgi.parse_header(
                result_headers["Content-Type"]
            )
            if (
                res_content_type.startswith("text/")
                and "charset" in res_params
                and not isinstance(result_text, str)
            ):
                result_text = result_text.decode(res_params["charset"])
        if isinstance(result_text, bytes) and decode_body:
            result_text = result_text.decode("utf-8")
        ret["body"] = result_text
    else:
        req_kwargs = {}
        if cert is not None:
            if isinstance(cert, str):
                if os.path.exists(cert):
                    req_kwargs["client_cert"] = cert
            elif isinstance(cert, list):
                if os.path.exists(cert[0]) and os.path.exists(cert[1]):
                    req_kwargs["client_cert"] = cert[0]
                    req_kwargs["client_key"] = cert[1]
            else:
                log.error(
                    "The client-side certificate path that was passed is not valid: %s",
                    cert,
                )
        if isinstance(data, dict):
            data = urllib.parse.urlencode(data)
        if verify_ssl:
            req_kwargs["ca_certs"] = ca_bundle
        max_body = opts.get(
            "http_max_body", salt.config.DEFAULT_MINION_OPTS["http_max_body"]
        )
        connect_timeout = opts.get(
            "http_connect_timeout",
            salt.config.DEFAULT_MINION_OPTS["http_connect_timeout"],
        )
        timeout = opts.get(
            "http_request_timeout",
            salt.config.DEFAULT_MINION_OPTS["http_request_timeout"],
        )
        client_argspec = None
        proxy_host = opts.get("proxy_host", None)
        if proxy_host:
            proxy_host = salt.utils.stringutils.to_str(proxy_host)
        proxy_port = opts.get("proxy_port", None)
        proxy_username = opts.get("proxy_username", None)
        if proxy_username:
            proxy_username = salt.utils.stringutils.to_str(proxy_username)
        proxy_password = opts.get("proxy_password", None)
        if proxy_password:
            proxy_password = salt.utils.stringutils.to_str(proxy_password)
        no_proxy = opts.get("no_proxy", [])
        if urllib.parse.urlparse(url_full).hostname in no_proxy:
            proxy_host = None
            proxy_port = None
            proxy_username = None
            proxy_password = None
        if proxy_host and proxy_port:
            if HAS_CURL_HTTPCLIENT is False:
                ret["error"] = (
                    "proxy_host and proxy_port has been set. This requires pycurl and"
                    " tornado, but the libraries does not seem to be installed"
                )
                log.error(ret["error"])
                return ret
            salt.ext.tornado.httpclient.AsyncHTTPClient.configure(
                "tornado.curl_httpclient.CurlAsyncHTTPClient"
            )
            client_argspec = salt.utils.args.get_function_argspec(
                salt.ext.tornado.curl_httpclient.CurlAsyncHTTPClient.initialize
            )
        else:
            salt.ext.tornado.httpclient.AsyncHTTPClient.configure(None)
            client_argspec = salt.utils.args.get_function_argspec(
                salt.ext.tornado.simple_httpclient.SimpleAsyncHTTPClient.initialize
            )
        supports_max_body_size = "max_body_size" in client_argspec.args
        req_kwargs.update(
            {
                "method": method,
                "headers": header_dict,
                "auth_username": username,
                "auth_password": password,
                "body": data,
                "validate_cert": verify_ssl,
                "allow_nonstandard_methods": True,
                "streaming_callback": streaming_callback,
                "header_callback": header_callback,
                "connect_timeout": connect_timeout,
                "request_timeout": timeout,
                "proxy_host": proxy_host,
                "proxy_port": proxy_port,
                "proxy_username": proxy_username,
                "proxy_password": proxy_password,
                "raise_error": raise_error,
                "decompress_response": False,
            }
        )
        req_kwargs = salt.utils.data.decode(req_kwargs, to_str=True)
        try:
            download_client = (
                HTTPClient(max_body_size=max_body)
                if supports_max_body_size
                else HTTPClient()
            )
            result = download_client.fetch(url_full, **req_kwargs)
        except salt.ext.tornado.httpclient.HTTPError as exc:
            ret["status"] = exc.code
            ret["error"] = str(exc)
            return ret
        except (socket.herror, OSError, socket.timeout, socket.gaierror) as exc:
            if status is True:
                ret["status"] = 0
            ret["error"] = str(exc)
            log.debug("Cannot perform 'http.query': %s - %s", url_full, ret["error"])
            return ret
        if stream is True or handle is True:
            return {
                "handle": result,
                "body": result.body,
            }
        result_status_code = result.code
        result_headers = result.headers
        result_text = result.body
        if "Content-Type" in result_headers:
            res_content_type, res_params = cgi.parse_header(
                result_headers["Content-Type"]
            )
            if (
                res_content_type.startswith("text/")
                and "charset" in res_params
                and not isinstance(result_text, str)
            ):
                result_text = result_text.decode(res_params["charset"])
        if isinstance(result_text, bytes) and decode_body:
            result_text = result_text.decode("utf-8")
        ret["body"] = result_text
        if "Set-Cookie" in result_headers and cookies is not None:
            result_cookies = parse_cookie_header(result_headers["Set-Cookie"])
            for item in result_cookies:
                sess_cookies.set_cookie(item)
        else:
            result_cookies = None
    if isinstance(result_headers, list):
        result_headers_dict = {}
        for header in result_headers:
            comps = header.split(":")
            result_headers_dict[comps[0].strip()] = ":".join(comps[1:]).strip()
        result_headers = result_headers_dict
    log.debug("Response Status Code: %s", result_status_code)
    log.trace("Response Headers: %s", result_headers)
    log.trace("Response Cookies: %s", sess_cookies)
    coding = result_headers.get("Content-Encoding", "identity")
    if backend != "requests":
        result_text = __decompressContent(coding, result_text)
    try:
        log.trace("Response Text: %s", result_text)
    except UnicodeEncodeError as exc:
        log.trace(
            "Cannot Trace Log Response Text: %s. This may be due to "
            "incompatibilities between requests and logging.",
            exc,
        )
    if text_out is not None:
        with salt.utils.files.fopen(text_out, "w") as tof:
            tof.write(result_text)
    if headers_out is not None and os.path.exists(headers_out):
        with salt.utils.files.fopen(headers_out, "w") as hof:
            hof.write(result_headers)
    if cookies is not None:
        sess_cookies.save()
    if persist_session is True and salt.utils.msgpack.HAS_MSGPACK:
        if "set-cookie" in result_headers:
            with salt.utils.files.fopen(session_cookie_jar, "wb") as fh_:
                session_cookies = result_headers.get("set-cookie", None)
                if session_cookies is not None:
                    salt.utils.msgpack.dump({"Cookie": session_cookies}, fh_)
                else:
                    salt.utils.msgpack.dump("", fh_)
    if status is True:
        ret["status"] = result_status_code
    if headers is True:
        ret["headers"] = result_headers
    if decode is True:
        if decode_type == "auto":
            content_type = result_headers.get("content-type", "application/json")
            if "xml" in content_type:
                decode_type = "xml"
            elif "json" in content_type:
                decode_type = "json"
            elif "yaml" in content_type:
                decode_type = "yaml"
            else:
                decode_type = "plain"
        valid_decodes = ("json", "xml", "yaml", "plain")
        if decode_type not in valid_decodes:
            ret[
                "error"
            ] = "Invalid decode_type specified. Valid decode types are: {}".format(
                pprint.pformat(valid_decodes)
            )
            log.error(ret["error"])
            return ret
        if decode_type == "json":
            ret["dict"] = salt.utils.json.loads(result_text)
        elif decode_type == "xml":
            ret["dict"] = []
            items = ET.fromstring(result_text)
            for item in items:
                ret["dict"].append(xml.to_dict(item))
        elif decode_type == "yaml":
            ret["dict"] = salt.utils.data.decode(salt.utils.yaml.safe_load(result_text))
        else:
            text = True
        if decode_out:
            with salt.utils.files.fopen(decode_out, "w") as dof:
                dof.write(result_text)
    if text is True:
        ret["text"] = result_text
    return ret
def get_ca_bundle(opts=None):
    if hasattr(get_ca_bundle, "__return_value__"):
        return get_ca_bundle.__return_value__
    if opts is None:
        opts = {}
    opts_bundle = opts.get("ca_bundle", None)
    if opts_bundle is not None and os.path.exists(opts_bundle):
        return opts_bundle
    file_roots = opts.get("file_roots", {"base": [salt.syspaths.SRV_ROOT_DIR]})
    for salt_root in file_roots.get("base", []):
        for path in ("cacert.pem", "ca-bundle.crt"):
            cert_path = os.path.join(salt_root, path)
            if os.path.exists(cert_path):
                return cert_path
    locations = (
        "/etc/ssl/certs/ca-certificates.crt",
        "/etc/pki/tls/certs/ca-bundle.crt",
        "/etc/pki/tls/certs/ca-bundle.trust.crt",
        "/etc/ssl/certs/ca-bundle.crt",
        "/var/lib/ca-certificates/ca-bundle.pem",
        "/etc/ssl/cert.pem",
    )
    for path in locations:
        if os.path.exists(path):
            return path
    if salt.utils.platform.is_windows() and HAS_CERTIFI:
        return certifi.where()
    return None
def update_ca_bundle(
    target=None,
    source=None,
    opts=None,
    merge_files=None,
):
    if opts is None:
        opts = {}
    if target is None:
        target = get_ca_bundle(opts)
    if target is None:
        log.error("Unable to detect location to write CA bundle to")
        return
    if source is None:
        source = opts.get("ca_bundle_url", "http://curl.haxx.se/ca/cacert.pem")
    log.debug("Attempting to download %s to %s", source, target)
    query(source, text=True, decode=False, headers=False, status=False, text_out=target)
    if merge_files is not None:
        if isinstance(merge_files, str):
            merge_files = [merge_files]
        if not isinstance(merge_files, list):
            log.error(
                "A value was passed as merge_files which was not either "
                "a string or a list"
            )
            return
        merge_content = ""
        for cert_file in merge_files:
            if os.path.exists(cert_file):
                log.debug("Queueing up %s to be appended to %s", cert_file, target)
                try:
                    with salt.utils.files.fopen(cert_file, "r") as fcf:
                        merge_content = "\n".join((merge_content, fcf.read()))
                except OSError as exc:
                    log.error(
                        "Reading from %s caused the following error: %s", cert_file, exc
                    )
        if merge_content:
            log.debug("Appending merge_files to %s", target)
            try:
                with salt.utils.files.fopen(target, "a") as tfp:
                    tfp.write("\n")
                    tfp.write(merge_content)
            except OSError as exc:
                log.error("Writing to %s caused the following error: %s", target, exc)
def _render(template, render, renderer, template_dict, opts):
    if render:
        if template_dict is None:
            template_dict = {}
        if not renderer:
            renderer = opts.get("renderer", "jinja|yaml")
        rend = salt.loader.render(opts, {})
        blacklist = opts.get("renderer_blacklist")
        whitelist = opts.get("renderer_whitelist")
        ret = compile_template(
            template, rend, renderer, blacklist, whitelist, **template_dict
        )
        if salt.utils.stringio.is_readable(ret):
            ret = ret.read()
        if str(ret).startswith("#!") and not str(ret).startswith("#!/"):
            ret = str(ret).split("\n", 1)[1]
        return ret
    with salt.utils.files.fopen(template, "r") as fh_:
        return fh_.read()
def parse_cookie_header(header):
    attribs = (
        "expires",
        "path",
        "domain",
        "version",
        "httponly",
        "secure",
        "comment",
        "max-age",
        "samesite",
    )
    morsels = []
    for item in header.split(";"):
        item = item.strip()
        if "," in item and "expires" not in item:
            for part in item.split(","):
                morsels.append(part)
        else:
            morsels.append(item)
    cookies = []
    cookie = {}
    value_set = False
    for morsel in morsels:
        parts = morsel.split("=")
        parts[0] = parts[0].lower()
        if parts[0] in attribs:
            if parts[0] in cookie:
                cookies.append(cookie)
                cookie = {}
            if len(parts) &gt; 1:
                cookie[parts[0]] = "=".join(parts[1:])
            else:
                cookie[parts[0]] = True
        else:
            if value_set is True:
                cookies.append(cookie)
                cookie = {}
                value_set = False
            cookie[parts[0]] = "=".join(parts[1:])
            value_set = True
    if cookie:
        cookies.append(cookie)
    reqd = (
        "version",
        "port",
        "port_specified",
        "domain",
        "domain_specified",
        "domain_initial_dot",
        "path",
        "path_specified",
        "secure",
        "expires",
        "discard",
        "comment",
        "comment_url",
        "rest",
    )
    ret = []
    for cookie in cookies:
        name = None
        value = None
        for item in list(cookie):
            if item in attribs:
                continue
            name = item
            value = cookie.pop(item)
        if "expires" in cookie:
            cookie["expires"] = http.cookiejar.http2time(cookie["expires"])
        for req in reqd:
            if req not in cookie:
                cookie[req] = ""
        if cookie["version"] == "":
            cookie["version"] = 0
        if cookie["rest"] == "":
            cookie["rest"] = {}
        if cookie["expires"] == "":
            cookie["expires"] = 0
        cookie.pop("httponly", None)
        cookie.pop("samesite", None)
        ret.append(http.cookiejar.Cookie(name=name, value=value, **cookie))
    return ret
def sanitize_url(url, hide_fields):
    if isinstance(hide_fields, list):
        url_comps = urllib.parse.splitquery(url)
        log_url = url_comps[0]
        if len(url_comps) &gt; 1:
            log_url += "?"
        for pair in url_comps[1:]:
            url_tmp = None
            for field in hide_fields:
                comps_list = pair.split("&amp;")
                if url_tmp:
                    url_tmp = url_tmp.split("&amp;")
                    url_tmp = _sanitize_url_components(url_tmp, field)
                else:
                    url_tmp = _sanitize_url_components(comps_list, field)
            log_url += url_tmp
        return log_url.rstrip("&amp;")
    else:
        return str(url)
def _sanitize_url_components(comp_list, field):
    if not comp_list:
        return ""
    elif comp_list[0].startswith("{}=".format(field)):
        ret = "{}=XXXXXXXXXX&amp;".format(field)
        comp_list.remove(comp_list[0])
        return ret + _sanitize_url_components(comp_list, field)
    else:
        ret = "{}&amp;".format(comp_list[0])
        comp_list.remove(comp_list[0])
        return ret + _sanitize_url_components(comp_list, field)
def session(user=None, password=None, verify_ssl=True, ca_bundle=None, headers=None):
    session = requests.session()
    if user and password:
        session.auth = (user, password)
    if ca_bundle and not verify_ssl:
        log.error("You cannot use both ca_bundle and verify_ssl False together")
        return False
    if ca_bundle:
        opts = {"ca_bundle": ca_bundle}
        session.verify = get_ca_bundle(opts)
    if not verify_ssl:
        session.verify = False
    if headers:
        session.headers.update(headers)
    return session
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
