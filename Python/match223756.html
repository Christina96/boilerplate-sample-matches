<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for qingcloud.py & http.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for qingcloud.py & http.py
      </h3>
      <h1 align="center">
        1.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>qingcloud.py (1.9675926%)<TH>http.py (1.0793651%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match223756-0.html#0',2,'match223756-1.html#0',3)" NAME="0">(28-51)<TD><A HREF="javascript:ZweiFrames('match223756-0.html#0',2,'match223756-1.html#0',3)" NAME="0">(32-49)</A><TD ALIGN=center><FONT COLOR="#ff0000">17</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>qingcloud.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
QingCloud Cloud Module
======================

.. versionadded:: 2015.8.0

The QingCloud cloud module is used to control access to the QingCloud.
http://www.qingcloud.com/

Use of this module requires the ``access_key_id``, ``secret_access_key``,
``zone`` and ``key_filename`` parameter to be set.

Set up the cloud configuration at ``/etc/salt/cloud.providers`` or
``/etc/salt/cloud.providers.d/qingcloud.conf``:

.. code-block:: yaml

    my-qingcloud:
      driver: qingcloud
      access_key_id: AKIDMRTGYONNLTFFRBQJ
      secret_access_key: clYwH21U5UOmcov4aNV2V2XocaHCG3JZGcxEczFu
      zone: pek2
      key_filename: /path/to/your.pem

<A NAME="0"></A>:depends: requests
&quot;&quot;&quot;

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match223756-1.html#0',3,'match223756-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import base64
import hmac
import logging
import pprint
import time
import urllib.parse
from hashlib import sha256

import salt.config as config
import salt.utils.cloud
import salt.utils.data
import salt.utils.json
from salt.exceptions import (
    SaltCloudExecutionFailure,
    SaltCloudExecutionTimeout,
    SaltCloudNotFound,
    SaltCloudSystemExit,
)

try:
    import requests

    HAS_REQUESTS = True
e</B></FONT>xcept ImportError:
    HAS_REQUESTS = False


# Get logging started
log = logging.getLogger(__name__)

__virtualname__ = &quot;qingcloud&quot;

DEFAULT_QINGCLOUD_API_VERSION = 1
DEFAULT_QINGCLOUD_SIGNATURE_VERSION = 1


# Only load in this module if the qingcloud configurations are in place
def __virtual__():
    &quot;&quot;&quot;
    Check for QingCloud configurations.
    &quot;&quot;&quot;
    if get_configured_provider() is False:
        return False

    if get_dependencies() is False:
        return False

    return __virtualname__


def _get_active_provider_name():
    try:
        return __active_provider_name__.value()
    except AttributeError:
        return __active_provider_name__


def get_configured_provider():
    &quot;&quot;&quot;
    Return the first configured instance.
    &quot;&quot;&quot;
    return config.is_provider_configured(
        __opts__,
        _get_active_provider_name() or __virtualname__,
        (&quot;access_key_id&quot;, &quot;secret_access_key&quot;, &quot;zone&quot;, &quot;key_filename&quot;),
    )


def get_dependencies():
    &quot;&quot;&quot;
    Warn if dependencies aren't met.
    &quot;&quot;&quot;
    return config.check_driver_dependencies(__virtualname__, {&quot;requests&quot;: HAS_REQUESTS})


def _compute_signature(parameters, access_key_secret, method, path):
    &quot;&quot;&quot;
    Generate an API request signature. Detailed document can be found at:

    https://docs.qingcloud.com/api/common/signature.html
    &quot;&quot;&quot;
    parameters[&quot;signature_method&quot;] = &quot;HmacSHA256&quot;

    string_to_sign = &quot;{}\n{}\n&quot;.format(method.upper(), path)

    keys = sorted(parameters.keys())
    pairs = []
    for key in keys:
        val = str(parameters[key]).encode(&quot;utf-8&quot;)
        pairs.append(
            urllib.parse.quote(key, safe=&quot;&quot;) + &quot;=&quot; + urllib.parse.quote(val, safe=&quot;-_~&quot;)
        )
    qs = &quot;&amp;&quot;.join(pairs)
    string_to_sign += qs

    h = hmac.new(access_key_secret, digestmod=sha256)
    h.update(string_to_sign)

    signature = base64.b64encode(h.digest()).strip()

    return signature


def query(params=None):
    &quot;&quot;&quot;
    Make a web call to QingCloud IaaS API.
    &quot;&quot;&quot;
    path = &quot;https://api.qingcloud.com/iaas/&quot;

    access_key_id = config.get_cloud_config_value(
        &quot;access_key_id&quot;, get_configured_provider(), __opts__, search_global=False
    )
    access_key_secret = config.get_cloud_config_value(
        &quot;secret_access_key&quot;, get_configured_provider(), __opts__, search_global=False
    )

    verify_ssl = config.get_cloud_config_value(
        &quot;verify_ssl&quot;,
        get_configured_provider(),
        __opts__,
        default=True,
        search_global=False,
    )

    # public interface parameters
    real_parameters = {
        &quot;access_key_id&quot;: access_key_id,
        &quot;signature_version&quot;: DEFAULT_QINGCLOUD_SIGNATURE_VERSION,
        &quot;time_stamp&quot;: time.strftime(&quot;%Y-%m-%dT%H:%M:%SZ&quot;, time.gmtime()),
        &quot;version&quot;: DEFAULT_QINGCLOUD_API_VERSION,
    }

    # include action or function parameters
    if params:
        for key, value in params.items():
            if isinstance(value, list):
                for i in range(1, len(value) + 1):
                    if isinstance(value[i - 1], dict):
                        for sk, sv in value[i - 1].items():
                            if isinstance(sv, dict) or isinstance(sv, list):
                                sv = salt.utils.json.dumps(sv, separators=(&quot;,&quot;, &quot;:&quot;))
                            real_parameters[&quot;{}.{}.{}&quot;.format(key, i, sk)] = sv
                    else:
                        real_parameters[&quot;{}.{}&quot;.format(key, i)] = value[i - 1]
            else:
                real_parameters[key] = value

    # Calculate the string for Signature
    signature = _compute_signature(real_parameters, access_key_secret, &quot;GET&quot;, &quot;/iaas/&quot;)
    real_parameters[&quot;signature&quot;] = signature

    # print('parameters:')
    # pprint.pprint(real_parameters)

    request = requests.get(path, params=real_parameters, verify=verify_ssl)

    # print('url:')
    # print(request.url)

    if request.status_code != 200:
        raise SaltCloudSystemExit(
            &quot;An error occurred while querying QingCloud. HTTP Code: {}  &quot;
            &quot;Error: '{}'&quot;.format(request.status_code, request.text)
        )

    log.debug(request.url)

    content = request.text
    result = salt.utils.json.loads(content)

    # print('response:')
    # pprint.pprint(result)

    if result[&quot;ret_code&quot;] != 0:
        raise SaltCloudSystemExit(pprint.pformat(result.get(&quot;message&quot;, {})))

    return result


def avail_locations(call=None):
    &quot;&quot;&quot;
    Return a dict of all available locations on the provider with
    relevant data.

    CLI Examples:

    .. code-block:: bash

        salt-cloud --list-locations my-qingcloud
    &quot;&quot;&quot;
    if call == &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The avail_locations function must be called with &quot;
            &quot;-f or --function, or with the --list-locations option&quot;
        )

    params = {
        &quot;action&quot;: &quot;DescribeZones&quot;,
    }
    items = query(params=params)

    result = {}
    for region in items[&quot;zone_set&quot;]:
        result[region[&quot;zone_id&quot;]] = {}
        for key in region:
            result[region[&quot;zone_id&quot;]][key] = str(region[key])

    return result


def _get_location(vm_=None):
    &quot;&quot;&quot;
    Return the VM's location. Used by create().
    &quot;&quot;&quot;
    locations = avail_locations()

    vm_location = str(
        config.get_cloud_config_value(&quot;zone&quot;, vm_, __opts__, search_global=False)
    )

    if not vm_location:
        raise SaltCloudNotFound(&quot;No location specified for this VM.&quot;)

    if vm_location in locations:
        return vm_location

    raise SaltCloudNotFound(
        &quot;The specified location, '{}', could not be found.&quot;.format(vm_location)
    )


def _get_specified_zone(kwargs=None, provider=None):
    if provider is None:
        provider = get_configured_provider()

    if isinstance(kwargs, dict):
        zone = kwargs.get(&quot;zone&quot;, None)
        if zone is not None:
            return zone

    zone = provider[&quot;zone&quot;]
    return zone


def avail_images(kwargs=None, call=None):
    &quot;&quot;&quot;
    Return a list of the images that are on the provider.

    CLI Examples:

    .. code-block:: bash

        salt-cloud --list-images my-qingcloud
        salt-cloud -f avail_images my-qingcloud zone=gd1
    &quot;&quot;&quot;
    if call == &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The avail_images function must be called with &quot;
            &quot;-f or --function, or with the --list-images option&quot;
        )

    if not isinstance(kwargs, dict):
        kwargs = {}

    params = {
        &quot;action&quot;: &quot;DescribeImages&quot;,
        &quot;provider&quot;: &quot;system&quot;,
        &quot;zone&quot;: _get_specified_zone(kwargs, get_configured_provider()),
    }
    items = query(params=params)

    result = {}
    for image in items[&quot;image_set&quot;]:
        result[image[&quot;image_id&quot;]] = {}
        for key in image:
            result[image[&quot;image_id&quot;]][key] = image[key]

    return result


def _get_image(vm_):
    &quot;&quot;&quot;
    Return the VM's image. Used by create().
    &quot;&quot;&quot;
    images = avail_images()
    vm_image = str(
        config.get_cloud_config_value(&quot;image&quot;, vm_, __opts__, search_global=False)
    )

    if not vm_image:
        raise SaltCloudNotFound(&quot;No image specified for this VM.&quot;)

    if vm_image in images:
        return vm_image

    raise SaltCloudNotFound(
        &quot;The specified image, '{}', could not be found.&quot;.format(vm_image)
    )


def show_image(kwargs, call=None):
    &quot;&quot;&quot;
    Show the details from QingCloud concerning an image.

    CLI Examples:

    .. code-block:: bash

        salt-cloud -f show_image my-qingcloud image=trustysrvx64c
        salt-cloud -f show_image my-qingcloud image=trustysrvx64c,coreos4
        salt-cloud -f show_image my-qingcloud image=trustysrvx64c zone=ap1
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The show_images function must be called with -f or --function&quot;
        )

    if not isinstance(kwargs, dict):
        kwargs = {}

    images = kwargs[&quot;image&quot;]
    images = images.split(&quot;,&quot;)

    params = {
        &quot;action&quot;: &quot;DescribeImages&quot;,
        &quot;images&quot;: images,
        &quot;zone&quot;: _get_specified_zone(kwargs, get_configured_provider()),
    }

    items = query(params=params)

    if not items[&quot;image_set&quot;]:
        raise SaltCloudNotFound(&quot;The specified image could not be found.&quot;)

    result = {}
    for image in items[&quot;image_set&quot;]:
        result[image[&quot;image_id&quot;]] = {}
        for key in image:
            result[image[&quot;image_id&quot;]][key] = image[key]

    return result


# QingCloud doesn't provide an API of geting instance sizes
QINGCLOUD_SIZES = {
    &quot;pek2&quot;: {
        &quot;c1m1&quot;: {&quot;cpu&quot;: 1, &quot;memory&quot;: &quot;1G&quot;},
        &quot;c1m2&quot;: {&quot;cpu&quot;: 1, &quot;memory&quot;: &quot;2G&quot;},
        &quot;c1m4&quot;: {&quot;cpu&quot;: 1, &quot;memory&quot;: &quot;4G&quot;},
        &quot;c2m2&quot;: {&quot;cpu&quot;: 2, &quot;memory&quot;: &quot;2G&quot;},
        &quot;c2m4&quot;: {&quot;cpu&quot;: 2, &quot;memory&quot;: &quot;4G&quot;},
        &quot;c2m8&quot;: {&quot;cpu&quot;: 2, &quot;memory&quot;: &quot;8G&quot;},
        &quot;c4m4&quot;: {&quot;cpu&quot;: 4, &quot;memory&quot;: &quot;4G&quot;},
        &quot;c4m8&quot;: {&quot;cpu&quot;: 4, &quot;memory&quot;: &quot;8G&quot;},
        &quot;c4m16&quot;: {&quot;cpu&quot;: 4, &quot;memory&quot;: &quot;16G&quot;},
    },
    &quot;pek1&quot;: {
        &quot;small_b&quot;: {&quot;cpu&quot;: 1, &quot;memory&quot;: &quot;1G&quot;},
        &quot;small_c&quot;: {&quot;cpu&quot;: 1, &quot;memory&quot;: &quot;2G&quot;},
        &quot;medium_a&quot;: {&quot;cpu&quot;: 2, &quot;memory&quot;: &quot;2G&quot;},
        &quot;medium_b&quot;: {&quot;cpu&quot;: 2, &quot;memory&quot;: &quot;4G&quot;},
        &quot;medium_c&quot;: {&quot;cpu&quot;: 2, &quot;memory&quot;: &quot;8G&quot;},
        &quot;large_a&quot;: {&quot;cpu&quot;: 4, &quot;memory&quot;: &quot;4G&quot;},
        &quot;large_b&quot;: {&quot;cpu&quot;: 4, &quot;memory&quot;: &quot;8G&quot;},
        &quot;large_c&quot;: {&quot;cpu&quot;: 4, &quot;memory&quot;: &quot;16G&quot;},
    },
}
QINGCLOUD_SIZES[&quot;ap1&quot;] = QINGCLOUD_SIZES[&quot;pek2&quot;]
QINGCLOUD_SIZES[&quot;gd1&quot;] = QINGCLOUD_SIZES[&quot;pek2&quot;]


def avail_sizes(kwargs=None, call=None):
    &quot;&quot;&quot;
    Return a list of the instance sizes that are on the provider.

    CLI Examples:

    .. code-block:: bash

        salt-cloud --list-sizes my-qingcloud
        salt-cloud -f avail_sizes my-qingcloud zone=pek2
    &quot;&quot;&quot;
    if call == &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The avail_sizes function must be called with &quot;
            &quot;-f or --function, or with the --list-sizes option&quot;
        )

    zone = _get_specified_zone(kwargs, get_configured_provider())

    result = {}
    for size_key in QINGCLOUD_SIZES[zone]:
        result[size_key] = {}
        for attribute_key in QINGCLOUD_SIZES[zone][size_key]:
            result[size_key][attribute_key] = QINGCLOUD_SIZES[zone][size_key][
                attribute_key
            ]

    return result


def _get_size(vm_):
    &quot;&quot;&quot;
    Return the VM's size. Used by create().
    &quot;&quot;&quot;
    sizes = avail_sizes()

    vm_size = str(
        config.get_cloud_config_value(&quot;size&quot;, vm_, __opts__, search_global=False)
    )

    if not vm_size:
        raise SaltCloudNotFound(&quot;No size specified for this instance.&quot;)

    if vm_size in sizes.keys():
        return vm_size

    raise SaltCloudNotFound(
        &quot;The specified size, '{}', could not be found.&quot;.format(vm_size)
    )


def _show_normalized_node(full_node):
    &quot;&quot;&quot;
    Normalize the QingCloud instance data. Used by list_nodes()-related
    functions.
    &quot;&quot;&quot;
    public_ips = full_node.get(&quot;eip&quot;, [])
    if public_ips:
        public_ip = public_ips[&quot;eip_addr&quot;]
        public_ips = [
            public_ip,
        ]

    private_ips = []
    for vxnet in full_node.get(&quot;vxnets&quot;, []):
        private_ip = vxnet.get(&quot;private_ip&quot;, None)
        if private_ip:
            private_ips.append(private_ip)

    normalized_node = {
        &quot;id&quot;: full_node[&quot;instance_id&quot;],
        &quot;image&quot;: full_node[&quot;image&quot;][&quot;image_id&quot;],
        &quot;size&quot;: full_node[&quot;instance_type&quot;],
        &quot;state&quot;: full_node[&quot;status&quot;],
        &quot;private_ips&quot;: private_ips,
        &quot;public_ips&quot;: public_ips,
    }

    return normalized_node


def list_nodes_full(call=None):
    &quot;&quot;&quot;
    Return a list of the instances that are on the provider.

    CLI Examples:

    .. code-block:: bash

        salt-cloud -F my-qingcloud
    &quot;&quot;&quot;
    if call == &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The list_nodes_full function must be called with -f or --function.&quot;
        )

    zone = _get_specified_zone()

    params = {
        &quot;action&quot;: &quot;DescribeInstances&quot;,
        &quot;zone&quot;: zone,
        &quot;status&quot;: [&quot;pending&quot;, &quot;running&quot;, &quot;stopped&quot;, &quot;suspended&quot;],
    }
    items = query(params=params)

    log.debug(&quot;Total %s instances found in zone %s&quot;, items[&quot;total_count&quot;], zone)

    result = {}

    if items[&quot;total_count&quot;] == 0:
        return result

    for node in items[&quot;instance_set&quot;]:
        normalized_node = _show_normalized_node(node)
        node.update(normalized_node)

        result[node[&quot;instance_id&quot;]] = node

    provider = _get_active_provider_name() or &quot;qingcloud&quot;
    if &quot;:&quot; in provider:
        comps = provider.split(&quot;:&quot;)
        provider = comps[0]

    __opts__[&quot;update_cachedir&quot;] = True
    __utils__[&quot;cloud.cache_node_list&quot;](result, provider, __opts__)

    return result


def list_nodes(call=None):
    &quot;&quot;&quot;
    Return a list of the instances that are on the provider.

    CLI Examples:

    .. code-block:: bash

        salt-cloud -Q my-qingcloud
    &quot;&quot;&quot;
    if call == &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The list_nodes function must be called with -f or --function.&quot;
        )

    nodes = list_nodes_full()

    ret = {}
    for instance_id, full_node in nodes.items():
        ret[instance_id] = {
            &quot;id&quot;: full_node[&quot;id&quot;],
            &quot;image&quot;: full_node[&quot;image&quot;],
            &quot;size&quot;: full_node[&quot;size&quot;],
            &quot;state&quot;: full_node[&quot;state&quot;],
            &quot;public_ips&quot;: full_node[&quot;public_ips&quot;],
            &quot;private_ips&quot;: full_node[&quot;private_ips&quot;],
        }

    return ret


def list_nodes_min(call=None):
    &quot;&quot;&quot;
    Return a list of the instances that are on the provider. Only a list of
    instances names, and their state, is returned.

    CLI Examples:

    .. code-block:: bash

        salt-cloud -f list_nodes_min my-qingcloud
    &quot;&quot;&quot;
    if call != &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The list_nodes_min function must be called with -f or --function.&quot;
        )

    nodes = list_nodes_full()

    result = {}
    for instance_id, full_node in nodes.items():
        result[instance_id] = {
            &quot;name&quot;: full_node[&quot;instance_name&quot;],
            &quot;status&quot;: full_node[&quot;status&quot;],
        }

    return result


def list_nodes_select(call=None):
    &quot;&quot;&quot;
    Return a list of the instances that are on the provider, with selected
    fields.

    CLI Examples:

    .. code-block:: bash

        salt-cloud -S my-qingcloud
    &quot;&quot;&quot;
    return salt.utils.cloud.list_nodes_select(
        list_nodes_full(&quot;function&quot;),
        __opts__[&quot;query.selection&quot;],
        call,
    )


def show_instance(instance_id, call=None, kwargs=None):
    &quot;&quot;&quot;
    Show the details from QingCloud concerning an instance.

    CLI Examples:

    .. code-block:: bash

        salt-cloud -a show_instance i-2f733r5n
    &quot;&quot;&quot;
    if call != &quot;action&quot;:
        raise SaltCloudSystemExit(
            &quot;The show_instance action must be called with -a or --action.&quot;
        )

    params = {
        &quot;action&quot;: &quot;DescribeInstances&quot;,
        &quot;instances.1&quot;: instance_id,
        &quot;zone&quot;: _get_specified_zone(kwargs=None, provider=get_configured_provider()),
    }
    items = query(params=params)

    if items[&quot;total_count&quot;] == 0:
        raise SaltCloudNotFound(
            &quot;The specified instance, '{}', could not be found.&quot;.format(instance_id)
        )

    full_node = items[&quot;instance_set&quot;][0]
    normalized_node = _show_normalized_node(full_node)
    full_node.update(normalized_node)

    result = full_node

    return result


def _query_node_data(instance_id):
    data = show_instance(instance_id, call=&quot;action&quot;)

    if not data:
        return False

    if data.get(&quot;private_ips&quot;, []):
        return data


def create(vm_):
    &quot;&quot;&quot;
    Create a single instance from a data dict.

    CLI Examples:

    .. code-block:: bash

        salt-cloud -p qingcloud-ubuntu-c1m1 hostname1
        salt-cloud -m /path/to/mymap.sls -P
    &quot;&quot;&quot;
    try:
        # Check for required profile parameters before sending any API calls.
        if (
            vm_[&quot;profile&quot;]
            and config.is_profile_configured(
                __opts__,
                _get_active_provider_name() or &quot;qingcloud&quot;,
                vm_[&quot;profile&quot;],
                vm_=vm_,
            )
            is False
        ):
            return False
    except AttributeError:
        pass

    __utils__[&quot;cloud.fire_event&quot;](
        &quot;event&quot;,
        &quot;starting create&quot;,
        &quot;salt/cloud/{}/creating&quot;.format(vm_[&quot;name&quot;]),
        args=__utils__[&quot;cloud.filter_event&quot;](
            &quot;creating&quot;, vm_, [&quot;name&quot;, &quot;profile&quot;, &quot;provider&quot;, &quot;driver&quot;]
        ),
        sock_dir=__opts__[&quot;sock_dir&quot;],
        transport=__opts__[&quot;transport&quot;],
    )

    log.info(&quot;Creating Cloud VM %s&quot;, vm_[&quot;name&quot;])

    # params
    params = {
        &quot;action&quot;: &quot;RunInstances&quot;,
        &quot;instance_name&quot;: vm_[&quot;name&quot;],
        &quot;zone&quot;: _get_location(vm_),
        &quot;instance_type&quot;: _get_size(vm_),
        &quot;image_id&quot;: _get_image(vm_),
        &quot;vxnets.1&quot;: vm_[&quot;vxnets&quot;],
        &quot;login_mode&quot;: vm_[&quot;login_mode&quot;],
        &quot;login_keypair&quot;: vm_[&quot;login_keypair&quot;],
    }

    __utils__[&quot;cloud.fire_event&quot;](
        &quot;event&quot;,
        &quot;requesting instance&quot;,
        &quot;salt/cloud/{}/requesting&quot;.format(vm_[&quot;name&quot;]),
        args={
            &quot;kwargs&quot;: __utils__[&quot;cloud.filter_event&quot;](
                &quot;requesting&quot;, params, list(params)
            ),
        },
        sock_dir=__opts__[&quot;sock_dir&quot;],
        transport=__opts__[&quot;transport&quot;],
    )

    result = query(params)
    new_instance_id = result[&quot;instances&quot;][0]

    try:
        data = salt.utils.cloud.wait_for_ip(
            _query_node_data,
            update_args=(new_instance_id,),
            timeout=config.get_cloud_config_value(
                &quot;wait_for_ip_timeout&quot;, vm_, __opts__, default=10 * 60
            ),
            interval=config.get_cloud_config_value(
                &quot;wait_for_ip_interval&quot;, vm_, __opts__, default=10
            ),
        )
    except (SaltCloudExecutionTimeout, SaltCloudExecutionFailure) as exc:
        try:
            # It might be already up, let's destroy it!
            destroy(vm_[&quot;name&quot;])
        except SaltCloudSystemExit:
            pass
        finally:
            raise SaltCloudSystemExit(str(exc))

    private_ip = data[&quot;private_ips&quot;][0]

    log.debug(&quot;VM %s is now running&quot;, private_ip)

    vm_[&quot;ssh_host&quot;] = private_ip

    # The instance is booted and accessible, let's Salt it!
    __utils__[&quot;cloud.bootstrap&quot;](vm_, __opts__)

    log.info(&quot;Created Cloud VM '%s'&quot;, vm_[&quot;name&quot;])

    log.debug(&quot;'%s' VM creation details:\n%s&quot;, vm_[&quot;name&quot;], pprint.pformat(data))

    __utils__[&quot;cloud.fire_event&quot;](
        &quot;event&quot;,
        &quot;created instance&quot;,
        &quot;salt/cloud/{}/created&quot;.format(vm_[&quot;name&quot;]),
        args=__utils__[&quot;cloud.filter_event&quot;](
            &quot;created&quot;, vm_, [&quot;name&quot;, &quot;profile&quot;, &quot;provider&quot;, &quot;driver&quot;]
        ),
        sock_dir=__opts__[&quot;sock_dir&quot;],
        transport=__opts__[&quot;transport&quot;],
    )

    return data


def script(vm_):
    &quot;&quot;&quot;
    Return the script deployment object.
    &quot;&quot;&quot;
    deploy_script = salt.utils.cloud.os_script(
        config.get_cloud_config_value(&quot;script&quot;, vm_, __opts__),
        vm_,
        __opts__,
        salt.utils.cloud.salt_config_to_yaml(
            salt.utils.cloud.minion_config(__opts__, vm_)
        ),
    )

    return deploy_script


def start(instance_id, call=None):
    &quot;&quot;&quot;
    Start an instance.

    CLI Examples:

    .. code-block:: bash

        salt-cloud -a start i-2f733r5n
    &quot;&quot;&quot;
    if call != &quot;action&quot;:
        raise SaltCloudSystemExit(&quot;The stop action must be called with -a or --action.&quot;)

    log.info(&quot;Starting instance %s&quot;, instance_id)

    params = {
        &quot;action&quot;: &quot;StartInstances&quot;,
        &quot;zone&quot;: _get_specified_zone(provider=get_configured_provider()),
        &quot;instances.1&quot;: instance_id,
    }
    result = query(params)

    return result


def stop(instance_id, force=False, call=None):
    &quot;&quot;&quot;
    Stop an instance.

    CLI Examples:

    .. code-block:: bash

        salt-cloud -a stop i-2f733r5n
        salt-cloud -a stop i-2f733r5n force=True
    &quot;&quot;&quot;
    if call != &quot;action&quot;:
        raise SaltCloudSystemExit(&quot;The stop action must be called with -a or --action.&quot;)

    log.info(&quot;Stopping instance %s&quot;, instance_id)

    params = {
        &quot;action&quot;: &quot;StopInstances&quot;,
        &quot;zone&quot;: _get_specified_zone(provider=get_configured_provider()),
        &quot;instances.1&quot;: instance_id,
        &quot;force&quot;: int(force),
    }
    result = query(params)

    return result


def reboot(instance_id, call=None):
    &quot;&quot;&quot;
    Reboot an instance.

    CLI Examples:

    .. code-block:: bash

        salt-cloud -a reboot i-2f733r5n
    &quot;&quot;&quot;
    if call != &quot;action&quot;:
        raise SaltCloudSystemExit(&quot;The stop action must be called with -a or --action.&quot;)

    log.info(&quot;Rebooting instance %s&quot;, instance_id)

    params = {
        &quot;action&quot;: &quot;RestartInstances&quot;,
        &quot;zone&quot;: _get_specified_zone(provider=get_configured_provider()),
        &quot;instances.1&quot;: instance_id,
    }
    result = query(params)

    return result


def destroy(instance_id, call=None):
    &quot;&quot;&quot;
    Destroy an instance.

    CLI Example:

    .. code-block:: bash

        salt-cloud -a destroy i-2f733r5n
        salt-cloud -d i-2f733r5n
    &quot;&quot;&quot;
    if call == &quot;function&quot;:
        raise SaltCloudSystemExit(
            &quot;The destroy action must be called with -d, --destroy, -a or --action.&quot;
        )

    instance_data = show_instance(instance_id, call=&quot;action&quot;)
    name = instance_data[&quot;instance_name&quot;]

    __utils__[&quot;cloud.fire_event&quot;](
        &quot;event&quot;,
        &quot;destroying instance&quot;,
        &quot;salt/cloud/{}/destroying&quot;.format(name),
        args={&quot;name&quot;: name},
        sock_dir=__opts__[&quot;sock_dir&quot;],
        transport=__opts__[&quot;transport&quot;],
    )

    params = {
        &quot;action&quot;: &quot;TerminateInstances&quot;,
        &quot;zone&quot;: _get_specified_zone(provider=get_configured_provider()),
        &quot;instances.1&quot;: instance_id,
    }
    result = query(params)

    __utils__[&quot;cloud.fire_event&quot;](
        &quot;event&quot;,
        &quot;destroyed instance&quot;,
        &quot;salt/cloud/{}/destroyed&quot;.format(name),
        args={&quot;name&quot;: name},
        sock_dir=__opts__[&quot;sock_dir&quot;],
        transport=__opts__[&quot;transport&quot;],
    )

    return result
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>http.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Utils for making various web calls. Primarily designed for REST, SOAP, webhooks
and the like, but also useful for basic HTTP testing.

.. versionadded:: 2015.5.0
&quot;&quot;&quot;

import cgi
import gzip
import http.client
import http.cookiejar
import io
import logging
import os
import pprint
import re
import socket
import ssl
import urllib.error
import urllib.parse
import urllib.request
import xml.etree.ElementTree as ET
import zlib

import salt.config
import salt.ext.tornado.httputil
import salt.ext.tornado.simple_httpclient
import salt.loader
<A NAME="0"></A>import salt.syspaths
import salt.utils.args
import salt.utils.data
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match223756-0.html#0',2,'match223756-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import salt.utils.files
import salt.utils.json
import salt.utils.msgpack
import salt.utils.network
import salt.utils.platform
import salt.utils.stringutils
import salt.utils.xmlutil as xml
import salt.utils.yaml
import salt.version
from salt.ext.tornado.httpclient import HTTPClient
from salt.template import compile_template
from salt.utils.decorators.jinja import jinja_filter

try:
    from ssl import CertificateError, match_hostname

    HAS_MATCHHOSTNAME = True
e</B></FONT>xcept ImportError:
    # pylint: disable=no-name-in-module
    try:
        from backports.ssl_match_hostname import CertificateError, match_hostname

        HAS_MATCHHOSTNAME = True
    except ImportError:
        try:
            from salt.ext.ssl_match_hostname import CertificateError, match_hostname

            HAS_MATCHHOSTNAME = True
        except ImportError:
            HAS_MATCHHOSTNAME = False
    # pylint: enable=no-name-in-module


try:
    import salt.ext.tornado.curl_httpclient

    HAS_CURL_HTTPCLIENT = True
except ImportError:
    HAS_CURL_HTTPCLIENT = False

try:
    import requests

    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False

try:
    import certifi

    HAS_CERTIFI = True
except ImportError:
    HAS_CERTIFI = False

log = logging.getLogger(__name__)
USERAGENT = &quot;Salt/{}&quot;.format(salt.version.__version__)


def __decompressContent(coding, pgctnt):
    &quot;&quot;&quot;
    Decompress returned HTTP content depending on the specified encoding.
    Currently supports identity/none, deflate, and gzip, which should
    cover 99%+ of the content on the internet.
    &quot;&quot;&quot;
    if not pgctnt:
        return pgctnt

    log.trace(
        &quot;Decompressing %s byte content with compression type: %s&quot;, len(pgctnt), coding
    )

    if coding == &quot;deflate&quot;:
        pgctnt = zlib.decompress(pgctnt, -zlib.MAX_WBITS)

    elif coding == &quot;gzip&quot;:
        buf = io.BytesIO(pgctnt)
        f = gzip.GzipFile(fileobj=buf)
        pgctnt = f.read()

    elif coding == &quot;sdch&quot;:
        raise ValueError(&quot;SDCH compression is not currently supported&quot;)
    elif coding == &quot;br&quot;:
        raise ValueError(&quot;Brotli compression is not currently supported&quot;)
    elif coding == &quot;compress&quot;:
        raise ValueError(&quot;LZW compression is not currently supported&quot;)

    log.trace(&quot;Content size after decompression: %s&quot;, len(pgctnt))
    return pgctnt


@jinja_filter(&quot;http_query&quot;)
def query(
    url,
    method=&quot;GET&quot;,
    params=None,
    data=None,
    data_file=None,
    header_dict=None,
    header_list=None,
    header_file=None,
    username=None,
    password=None,
    auth=None,
    decode=False,
    decode_type=&quot;auto&quot;,
    status=False,
    headers=False,
    text=False,
    cookies=None,
    cookie_jar=None,
    cookie_format=&quot;lwp&quot;,
    persist_session=False,
    session_cookie_jar=None,
    data_render=False,
    data_renderer=None,
    header_render=False,
    header_renderer=None,
    template_dict=None,
    test=False,
    test_url=None,
    node=&quot;minion&quot;,
    port=80,
    opts=None,
    backend=None,
    ca_bundle=None,
    verify_ssl=None,
    cert=None,
    text_out=None,
    headers_out=None,
    decode_out=None,
    stream=False,
    streaming_callback=None,
    header_callback=None,
    handle=False,
    agent=USERAGENT,
    hide_fields=None,
    raise_error=True,
    formdata=False,
    formdata_fieldname=None,
    formdata_filename=None,
    decode_body=True,
    **kwargs
):
    &quot;&quot;&quot;
    Query a resource, and decode the return data
    &quot;&quot;&quot;
    ret = {}

    if opts is None:
        if node == &quot;master&quot;:
            opts = salt.config.master_config(
                os.path.join(salt.syspaths.CONFIG_DIR, &quot;master&quot;)
            )
        elif node == &quot;minion&quot;:
            opts = salt.config.minion_config(
                os.path.join(salt.syspaths.CONFIG_DIR, &quot;minion&quot;)
            )
        else:
            opts = {}

    if not backend:
        backend = opts.get(&quot;backend&quot;, &quot;tornado&quot;)

    match = re.match(
        r&quot;https?://((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)($|/)&quot;,
        url,
    )
    if not match:
        salt.utils.network.refresh_dns()

    if backend == &quot;requests&quot;:
        if HAS_REQUESTS is False:
            ret[&quot;error&quot;] = (
                &quot;http.query has been set to use requests, but the &quot;
                &quot;requests library does not seem to be installed&quot;
            )
            log.error(ret[&quot;error&quot;])
            return ret
        else:
            requests_log = logging.getLogger(&quot;requests&quot;)
            requests_log.setLevel(logging.WARNING)

    # Some libraries don't support separation of url and GET parameters
    # Don't need a try/except block, since Salt depends on tornado
    url_full = salt.ext.tornado.httputil.url_concat(url, params) if params else url

    if ca_bundle is None:
        ca_bundle = get_ca_bundle(opts)

    if verify_ssl is None:
        verify_ssl = opts.get(&quot;verify_ssl&quot;, True)

    if cert is None:
        cert = opts.get(&quot;cert&quot;, None)

    if data_file is not None:
        data = _render(data_file, data_render, data_renderer, template_dict, opts)

    # Make sure no secret fields show up in logs
    log_url = sanitize_url(url_full, hide_fields)

    log.debug(&quot;Requesting URL %s using %s method&quot;, log_url, method)
    log.debug(&quot;Using backend: %s&quot;, backend)

    if method == &quot;POST&quot; and log.isEnabledFor(logging.TRACE):
        # Make sure no secret fields show up in logs
        if isinstance(data, dict):
            log_data = data.copy()
            if isinstance(hide_fields, list):
                for item in data:
                    for field in hide_fields:
                        if item == field:
                            log_data[item] = &quot;XXXXXXXXXX&quot;
            log.trace(&quot;Request POST Data: %s&quot;, pprint.pformat(log_data))
        else:
            log.trace(&quot;Request POST Data: %s&quot;, pprint.pformat(data))

    if header_file is not None:
        header_tpl = _render(
            header_file, header_render, header_renderer, template_dict, opts
        )
        if isinstance(header_tpl, dict):
            header_dict = header_tpl
        else:
            header_list = header_tpl.splitlines()

    if header_dict is None:
        header_dict = {}

    if header_list is None:
        header_list = []

    if cookie_jar is None:
        cookie_jar = os.path.join(
            opts.get(&quot;cachedir&quot;, salt.syspaths.CACHE_DIR), &quot;cookies.txt&quot;
        )
    if session_cookie_jar is None:
        session_cookie_jar = os.path.join(
            opts.get(&quot;cachedir&quot;, salt.syspaths.CACHE_DIR), &quot;cookies.session.p&quot;
        )

    if persist_session is True and salt.utils.msgpack.HAS_MSGPACK:
        # TODO: This is hackish; it will overwrite the session cookie jar with
        # all cookies from this one connection, rather than behaving like a
        # proper cookie jar. Unfortunately, since session cookies do not
        # contain expirations, they can't be stored in a proper cookie jar.
        if os.path.isfile(session_cookie_jar):
            with salt.utils.files.fopen(session_cookie_jar, &quot;rb&quot;) as fh_:
                session_cookies = salt.utils.msgpack.load(fh_)
            if isinstance(session_cookies, dict):
                header_dict.update(session_cookies)
        else:
            with salt.utils.files.fopen(session_cookie_jar, &quot;wb&quot;) as fh_:
                salt.utils.msgpack.dump(&quot;&quot;, fh_)

    for header in header_list:
        comps = header.split(&quot;:&quot;)
        if len(comps) &lt; 2:
            continue
        header_dict[comps[0].strip()] = comps[1].strip()

    if not auth:
        if username and password:
            auth = (username, password)

    if agent == USERAGENT:
        agent = &quot;{} http.query()&quot;.format(agent)
    header_dict[&quot;User-agent&quot;] = agent

    if backend == &quot;requests&quot;:
        sess = requests.Session()
        sess.auth = auth
        sess.headers.update(header_dict)
        log.trace(&quot;Request Headers: %s&quot;, sess.headers)
        sess_cookies = sess.cookies
        sess.verify = verify_ssl
    elif backend == &quot;urllib2&quot;:
        sess_cookies = None
    else:
        # Tornado
        sess_cookies = None

    if cookies is not None:
        if cookie_format == &quot;mozilla&quot;:
            sess_cookies = http.cookiejar.MozillaCookieJar(cookie_jar)
        else:
            sess_cookies = http.cookiejar.LWPCookieJar(cookie_jar)
        if not os.path.isfile(cookie_jar):
            sess_cookies.save()
        sess_cookies.load()

    if test is True:
        if test_url is None:
            return {}
        else:
            url = test_url
            ret[&quot;test&quot;] = True

    if backend == &quot;requests&quot;:
        req_kwargs = {}
        if stream is True:
            if requests.__version__[0] == &quot;0&quot;:
                # 'stream' was called 'prefetch' before 1.0, with flipped meaning
                req_kwargs[&quot;prefetch&quot;] = False
            else:
                req_kwargs[&quot;stream&quot;] = True

        # Client-side cert handling
        if cert is not None:
            if isinstance(cert, str):
                if os.path.exists(cert):
                    req_kwargs[&quot;cert&quot;] = cert
            elif isinstance(cert, list):
                if os.path.exists(cert[0]) and os.path.exists(cert[1]):
                    req_kwargs[&quot;cert&quot;] = cert
            else:
                log.error(
                    &quot;The client-side certificate path that was passed is not valid: %s&quot;,
                    cert,
                )

        if formdata:
            if not formdata_fieldname:
                ret[&quot;error&quot;] = &quot;formdata_fieldname is required when formdata=True&quot;
                log.error(ret[&quot;error&quot;])
                return ret
            result = sess.request(
                method,
                url,
                params=params,
                files={formdata_fieldname: (formdata_filename, io.StringIO(data))},
                **req_kwargs
            )
        else:
            result = sess.request(method, url, params=params, data=data, **req_kwargs)
        result.raise_for_status()
        if stream is True:
            # fake a HTTP response header
            header_callback(&quot;HTTP/1.0 {} MESSAGE&quot;.format(result.status_code))
            # fake streaming the content
            streaming_callback(result.content)
            return {
                &quot;handle&quot;: result,
            }

        if handle is True:
            return {
                &quot;handle&quot;: result,
                &quot;body&quot;: result.content,
            }

        log.debug(
            &quot;Final URL location of Response: %s&quot;, sanitize_url(result.url, hide_fields)
        )

        result_status_code = result.status_code
        result_headers = result.headers
        result_text = result.content
        result_cookies = result.cookies
        body = result.content
        if not isinstance(body, str) and decode_body:
            body = body.decode(result.encoding or &quot;utf-8&quot;)
        ret[&quot;body&quot;] = body
    elif backend == &quot;urllib2&quot;:
        request = urllib.request.Request(url_full, data)
        handlers = [
            urllib.request.HTTPHandler,
            urllib.request.HTTPCookieProcessor(sess_cookies),
        ]

        if url.startswith(&quot;https&quot;):
            hostname = request.get_host()
            handlers[0] = urllib.request.HTTPSHandler(1)
            if not HAS_MATCHHOSTNAME:
                log.warning(
                    &quot;match_hostname() not available, SSL hostname checking &quot;
                    &quot;not available. THIS CONNECTION MAY NOT BE SECURE!&quot;
                )
            elif verify_ssl is False:
                log.warning(
                    &quot;SSL certificate verification has been explicitly &quot;
                    &quot;disabled. THIS CONNECTION MAY NOT BE SECURE!&quot;
                )
            else:
                if &quot;:&quot; in hostname:
                    hostname, port = hostname.split(&quot;:&quot;)
                else:
                    port = 443
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.connect((hostname, int(port)))
                sockwrap = ssl.wrap_socket(
                    sock, ca_certs=ca_bundle, cert_reqs=ssl.CERT_REQUIRED
                )
                try:
                    match_hostname(sockwrap.getpeercert(), hostname)
                except CertificateError as exc:
                    ret[
                        &quot;error&quot;
                    ] = &quot;The certificate was invalid. Error returned was: {}&quot;.format(
                        pprint.pformat(exc)
                    )
                    return ret

                # Client-side cert handling
                if cert is not None:
                    cert_chain = None
                    if isinstance(cert, str):
                        if os.path.exists(cert):
                            cert_chain = cert
                    elif isinstance(cert, list):
                        if os.path.exists(cert[0]) and os.path.exists(cert[1]):
                            cert_chain = cert
                    else:
                        log.error(
                            &quot;The client-side certificate path that was &quot;
                            &quot;passed is not valid: %s&quot;,
                            cert,
                        )
                        return
                    if hasattr(ssl, &quot;SSLContext&quot;):
                        # Python &gt;= 2.7.9
                        context = ssl.SSLContext.load_cert_chain(*cert_chain)
                        handlers.append(
                            urllib.request.HTTPSHandler(context=context)
                        )  # pylint: disable=E1123
                    else:
                        # Python &lt; 2.7.9
                        cert_kwargs = {
                            &quot;host&quot;: request.get_host(),
                            &quot;port&quot;: port,
                            &quot;cert_file&quot;: cert_chain[0],
                        }
                        if len(cert_chain) &gt; 1:
                            cert_kwargs[&quot;key_file&quot;] = cert_chain[1]
                        handlers[0] = http.client.HTTPSConnection(**cert_kwargs)

        opener = urllib.request.build_opener(*handlers)
        for header in header_dict:
            request.add_header(header, header_dict[header])
        request.get_method = lambda: method
        try:
            result = opener.open(request)
        except urllib.error.URLError as exc:
            return {&quot;Error&quot;: str(exc)}
        if stream is True or handle is True:
            return {
                &quot;handle&quot;: result,
                &quot;body&quot;: result.content,
            }

        result_status_code = result.code
        result_headers = dict(result.info())
        result_text = result.read()
        if &quot;Content-Type&quot; in result_headers:
            res_content_type, res_params = cgi.parse_header(
                result_headers[&quot;Content-Type&quot;]
            )
            if (
                res_content_type.startswith(&quot;text/&quot;)
                and &quot;charset&quot; in res_params
                and not isinstance(result_text, str)
            ):
                result_text = result_text.decode(res_params[&quot;charset&quot;])
        if isinstance(result_text, bytes) and decode_body:
            result_text = result_text.decode(&quot;utf-8&quot;)
        ret[&quot;body&quot;] = result_text
    else:
        # Tornado
        req_kwargs = {}

        # Client-side cert handling
        if cert is not None:
            if isinstance(cert, str):
                if os.path.exists(cert):
                    req_kwargs[&quot;client_cert&quot;] = cert
            elif isinstance(cert, list):
                if os.path.exists(cert[0]) and os.path.exists(cert[1]):
                    req_kwargs[&quot;client_cert&quot;] = cert[0]
                    req_kwargs[&quot;client_key&quot;] = cert[1]
            else:
                log.error(
                    &quot;The client-side certificate path that was passed is not valid: %s&quot;,
                    cert,
                )

        if isinstance(data, dict):
            data = urllib.parse.urlencode(data)

        if verify_ssl:
            req_kwargs[&quot;ca_certs&quot;] = ca_bundle

        max_body = opts.get(
            &quot;http_max_body&quot;, salt.config.DEFAULT_MINION_OPTS[&quot;http_max_body&quot;]
        )
        connect_timeout = opts.get(
            &quot;http_connect_timeout&quot;,
            salt.config.DEFAULT_MINION_OPTS[&quot;http_connect_timeout&quot;],
        )
        timeout = opts.get(
            &quot;http_request_timeout&quot;,
            salt.config.DEFAULT_MINION_OPTS[&quot;http_request_timeout&quot;],
        )

        client_argspec = None

        proxy_host = opts.get(&quot;proxy_host&quot;, None)
        if proxy_host:
            # tornado requires a str for proxy_host, cannot be a unicode str in py2
            proxy_host = salt.utils.stringutils.to_str(proxy_host)
        proxy_port = opts.get(&quot;proxy_port&quot;, None)
        proxy_username = opts.get(&quot;proxy_username&quot;, None)
        if proxy_username:
            # tornado requires a str, cannot be unicode str in py2
            proxy_username = salt.utils.stringutils.to_str(proxy_username)
        proxy_password = opts.get(&quot;proxy_password&quot;, None)
        if proxy_password:
            # tornado requires a str, cannot be unicode str in py2
            proxy_password = salt.utils.stringutils.to_str(proxy_password)
        no_proxy = opts.get(&quot;no_proxy&quot;, [])

        # Since tornado doesnt support no_proxy, we'll always hand it empty proxies or valid ones
        # except we remove the valid ones if a url has a no_proxy hostname in it
        if urllib.parse.urlparse(url_full).hostname in no_proxy:
            proxy_host = None
            proxy_port = None
            proxy_username = None
            proxy_password = None

        # We want to use curl_http if we have a proxy defined
        if proxy_host and proxy_port:
            if HAS_CURL_HTTPCLIENT is False:
                ret[&quot;error&quot;] = (
                    &quot;proxy_host and proxy_port has been set. This requires pycurl and&quot;
                    &quot; tornado, but the libraries does not seem to be installed&quot;
                )
                log.error(ret[&quot;error&quot;])
                return ret

            salt.ext.tornado.httpclient.AsyncHTTPClient.configure(
                &quot;tornado.curl_httpclient.CurlAsyncHTTPClient&quot;
            )
            client_argspec = salt.utils.args.get_function_argspec(
                salt.ext.tornado.curl_httpclient.CurlAsyncHTTPClient.initialize
            )
        else:
            salt.ext.tornado.httpclient.AsyncHTTPClient.configure(None)
            client_argspec = salt.utils.args.get_function_argspec(
                salt.ext.tornado.simple_httpclient.SimpleAsyncHTTPClient.initialize
            )

        supports_max_body_size = &quot;max_body_size&quot; in client_argspec.args

        req_kwargs.update(
            {
                &quot;method&quot;: method,
                &quot;headers&quot;: header_dict,
                &quot;auth_username&quot;: username,
                &quot;auth_password&quot;: password,
                &quot;body&quot;: data,
                &quot;validate_cert&quot;: verify_ssl,
                &quot;allow_nonstandard_methods&quot;: True,
                &quot;streaming_callback&quot;: streaming_callback,
                &quot;header_callback&quot;: header_callback,
                &quot;connect_timeout&quot;: connect_timeout,
                &quot;request_timeout&quot;: timeout,
                &quot;proxy_host&quot;: proxy_host,
                &quot;proxy_port&quot;: proxy_port,
                &quot;proxy_username&quot;: proxy_username,
                &quot;proxy_password&quot;: proxy_password,
                &quot;raise_error&quot;: raise_error,
                &quot;decompress_response&quot;: False,
            }
        )

        # Unicode types will cause a TypeError when Tornado's curl HTTPClient
        # invokes setopt. Therefore, make sure all arguments we pass which
        # contain strings are str types.
        req_kwargs = salt.utils.data.decode(req_kwargs, to_str=True)

        try:
            download_client = (
                HTTPClient(max_body_size=max_body)
                if supports_max_body_size
                else HTTPClient()
            )
            result = download_client.fetch(url_full, **req_kwargs)
        except salt.ext.tornado.httpclient.HTTPError as exc:
            ret[&quot;status&quot;] = exc.code
            ret[&quot;error&quot;] = str(exc)
            return ret
        except (socket.herror, OSError, socket.timeout, socket.gaierror) as exc:
            if status is True:
                ret[&quot;status&quot;] = 0
            ret[&quot;error&quot;] = str(exc)
            log.debug(&quot;Cannot perform 'http.query': %s - %s&quot;, url_full, ret[&quot;error&quot;])
            return ret

        if stream is True or handle is True:
            return {
                &quot;handle&quot;: result,
                &quot;body&quot;: result.body,
            }

        result_status_code = result.code
        result_headers = result.headers
        result_text = result.body
        if &quot;Content-Type&quot; in result_headers:
            res_content_type, res_params = cgi.parse_header(
                result_headers[&quot;Content-Type&quot;]
            )
            if (
                res_content_type.startswith(&quot;text/&quot;)
                and &quot;charset&quot; in res_params
                and not isinstance(result_text, str)
            ):
                result_text = result_text.decode(res_params[&quot;charset&quot;])
        if isinstance(result_text, bytes) and decode_body:
            result_text = result_text.decode(&quot;utf-8&quot;)
        ret[&quot;body&quot;] = result_text
        if &quot;Set-Cookie&quot; in result_headers and cookies is not None:
            result_cookies = parse_cookie_header(result_headers[&quot;Set-Cookie&quot;])
            for item in result_cookies:
                sess_cookies.set_cookie(item)
        else:
            result_cookies = None

    if isinstance(result_headers, list):
        result_headers_dict = {}
        for header in result_headers:
            comps = header.split(&quot;:&quot;)
            result_headers_dict[comps[0].strip()] = &quot;:&quot;.join(comps[1:]).strip()
        result_headers = result_headers_dict

    log.debug(&quot;Response Status Code: %s&quot;, result_status_code)
    log.trace(&quot;Response Headers: %s&quot;, result_headers)
    log.trace(&quot;Response Cookies: %s&quot;, sess_cookies)
    # log.trace(&quot;Content: %s&quot;, result_text)

    coding = result_headers.get(&quot;Content-Encoding&quot;, &quot;identity&quot;)

    # Requests will always decompress the content, and working around that is annoying.
    if backend != &quot;requests&quot;:
        result_text = __decompressContent(coding, result_text)

    try:
        log.trace(&quot;Response Text: %s&quot;, result_text)
    except UnicodeEncodeError as exc:
        log.trace(
            &quot;Cannot Trace Log Response Text: %s. This may be due to &quot;
            &quot;incompatibilities between requests and logging.&quot;,
            exc,
        )

    if text_out is not None:
        with salt.utils.files.fopen(text_out, &quot;w&quot;) as tof:
            tof.write(result_text)

    if headers_out is not None and os.path.exists(headers_out):
        with salt.utils.files.fopen(headers_out, &quot;w&quot;) as hof:
            hof.write(result_headers)

    if cookies is not None:
        sess_cookies.save()

    if persist_session is True and salt.utils.msgpack.HAS_MSGPACK:
        # TODO: See persist_session above
        if &quot;set-cookie&quot; in result_headers:
            with salt.utils.files.fopen(session_cookie_jar, &quot;wb&quot;) as fh_:
                session_cookies = result_headers.get(&quot;set-cookie&quot;, None)
                if session_cookies is not None:
                    salt.utils.msgpack.dump({&quot;Cookie&quot;: session_cookies}, fh_)
                else:
                    salt.utils.msgpack.dump(&quot;&quot;, fh_)

    if status is True:
        ret[&quot;status&quot;] = result_status_code

    if headers is True:
        ret[&quot;headers&quot;] = result_headers

    if decode is True:
        if decode_type == &quot;auto&quot;:
            content_type = result_headers.get(&quot;content-type&quot;, &quot;application/json&quot;)
            if &quot;xml&quot; in content_type:
                decode_type = &quot;xml&quot;
            elif &quot;json&quot; in content_type:
                decode_type = &quot;json&quot;
            elif &quot;yaml&quot; in content_type:
                decode_type = &quot;yaml&quot;
            else:
                decode_type = &quot;plain&quot;

        valid_decodes = (&quot;json&quot;, &quot;xml&quot;, &quot;yaml&quot;, &quot;plain&quot;)
        if decode_type not in valid_decodes:
            ret[
                &quot;error&quot;
            ] = &quot;Invalid decode_type specified. Valid decode types are: {}&quot;.format(
                pprint.pformat(valid_decodes)
            )
            log.error(ret[&quot;error&quot;])
            return ret

        if decode_type == &quot;json&quot;:
            ret[&quot;dict&quot;] = salt.utils.json.loads(result_text)
        elif decode_type == &quot;xml&quot;:
            ret[&quot;dict&quot;] = []
            items = ET.fromstring(result_text)
            for item in items:
                ret[&quot;dict&quot;].append(xml.to_dict(item))
        elif decode_type == &quot;yaml&quot;:
            ret[&quot;dict&quot;] = salt.utils.data.decode(salt.utils.yaml.safe_load(result_text))
        else:
            text = True

        if decode_out:
            with salt.utils.files.fopen(decode_out, &quot;w&quot;) as dof:
                dof.write(result_text)

    if text is True:
        ret[&quot;text&quot;] = result_text

    return ret


def get_ca_bundle(opts=None):
    &quot;&quot;&quot;
    Return the location of the ca bundle file. See the following article:

        http://tinyurl.com/k7rx42a
    &quot;&quot;&quot;
    if hasattr(get_ca_bundle, &quot;__return_value__&quot;):
        return get_ca_bundle.__return_value__

    if opts is None:
        opts = {}

    opts_bundle = opts.get(&quot;ca_bundle&quot;, None)
    if opts_bundle is not None and os.path.exists(opts_bundle):
        return opts_bundle

    file_roots = opts.get(&quot;file_roots&quot;, {&quot;base&quot;: [salt.syspaths.SRV_ROOT_DIR]})

    # Please do not change the order without good reason

    # Check Salt first
    for salt_root in file_roots.get(&quot;base&quot;, []):
        for path in (&quot;cacert.pem&quot;, &quot;ca-bundle.crt&quot;):
            cert_path = os.path.join(salt_root, path)
            if os.path.exists(cert_path):
                return cert_path

    locations = (
        # Debian has paths that often exist on other distros
        &quot;/etc/ssl/certs/ca-certificates.crt&quot;,
        # RedHat is also very common
        &quot;/etc/pki/tls/certs/ca-bundle.crt&quot;,
        &quot;/etc/pki/tls/certs/ca-bundle.trust.crt&quot;,
        # RedHat's link for Debian compatibility
        &quot;/etc/ssl/certs/ca-bundle.crt&quot;,
        # SUSE has an unusual path
        &quot;/var/lib/ca-certificates/ca-bundle.pem&quot;,
        # OpenBSD has an unusual path
        &quot;/etc/ssl/cert.pem&quot;,
    )
    for path in locations:
        if os.path.exists(path):
            return path

    if salt.utils.platform.is_windows() and HAS_CERTIFI:
        return certifi.where()

    return None


def update_ca_bundle(
    target=None,
    source=None,
    opts=None,
    merge_files=None,
):
    &quot;&quot;&quot;
    Attempt to update the CA bundle file from a URL

    If not specified, the local location on disk (``target``) will be
    auto-detected, if possible. If it is not found, then a new location on disk
    will be created and updated.

    The default ``source`` is:

        http://curl.haxx.se/ca/cacert.pem

    This is based on the information at:

        http://curl.haxx.se/docs/caextract.html

    A string or list of strings representing files to be appended to the end of
    the CA bundle file may also be passed through as ``merge_files``.
    &quot;&quot;&quot;
    if opts is None:
        opts = {}

    if target is None:
        target = get_ca_bundle(opts)

    if target is None:
        log.error(&quot;Unable to detect location to write CA bundle to&quot;)
        return

    if source is None:
        source = opts.get(&quot;ca_bundle_url&quot;, &quot;http://curl.haxx.se/ca/cacert.pem&quot;)

    log.debug(&quot;Attempting to download %s to %s&quot;, source, target)
    query(source, text=True, decode=False, headers=False, status=False, text_out=target)

    if merge_files is not None:
        if isinstance(merge_files, str):
            merge_files = [merge_files]

        if not isinstance(merge_files, list):
            log.error(
                &quot;A value was passed as merge_files which was not either &quot;
                &quot;a string or a list&quot;
            )
            return

        merge_content = &quot;&quot;

        for cert_file in merge_files:
            if os.path.exists(cert_file):
                log.debug(&quot;Queueing up %s to be appended to %s&quot;, cert_file, target)
                try:
                    with salt.utils.files.fopen(cert_file, &quot;r&quot;) as fcf:
                        merge_content = &quot;\n&quot;.join((merge_content, fcf.read()))
                except OSError as exc:
                    log.error(
                        &quot;Reading from %s caused the following error: %s&quot;, cert_file, exc
                    )

        if merge_content:
            log.debug(&quot;Appending merge_files to %s&quot;, target)
            try:
                with salt.utils.files.fopen(target, &quot;a&quot;) as tfp:
                    tfp.write(&quot;\n&quot;)
                    tfp.write(merge_content)
            except OSError as exc:
                log.error(&quot;Writing to %s caused the following error: %s&quot;, target, exc)


def _render(template, render, renderer, template_dict, opts):
    &quot;&quot;&quot;
    Render a template
    &quot;&quot;&quot;
    if render:
        if template_dict is None:
            template_dict = {}
        if not renderer:
            renderer = opts.get(&quot;renderer&quot;, &quot;jinja|yaml&quot;)
        rend = salt.loader.render(opts, {})
        blacklist = opts.get(&quot;renderer_blacklist&quot;)
        whitelist = opts.get(&quot;renderer_whitelist&quot;)
        ret = compile_template(
            template, rend, renderer, blacklist, whitelist, **template_dict
        )
        if salt.utils.stringio.is_readable(ret):
            ret = ret.read()
        if str(ret).startswith(&quot;#!&quot;) and not str(ret).startswith(&quot;#!/&quot;):
            ret = str(ret).split(&quot;\n&quot;, 1)[1]
        return ret
    with salt.utils.files.fopen(template, &quot;r&quot;) as fh_:
        return fh_.read()


def parse_cookie_header(header):
    &quot;&quot;&quot;
    Parse the &quot;Set-cookie&quot; header, and return a list of cookies.

    This function is here because Tornado's HTTPClient doesn't handle cookies.
    &quot;&quot;&quot;
    attribs = (
        &quot;expires&quot;,
        &quot;path&quot;,
        &quot;domain&quot;,
        &quot;version&quot;,
        &quot;httponly&quot;,
        &quot;secure&quot;,
        &quot;comment&quot;,
        &quot;max-age&quot;,
        &quot;samesite&quot;,
    )

    # Split into cookie(s); handles headers with multiple cookies defined
    morsels = []
    for item in header.split(&quot;;&quot;):
        item = item.strip()
        if &quot;,&quot; in item and &quot;expires&quot; not in item:
            for part in item.split(&quot;,&quot;):
                morsels.append(part)
        else:
            morsels.append(item)

    # Break down morsels into actual cookies
    cookies = []
    cookie = {}
    value_set = False
    for morsel in morsels:
        parts = morsel.split(&quot;=&quot;)
        parts[0] = parts[0].lower()
        if parts[0] in attribs:
            if parts[0] in cookie:
                cookies.append(cookie)
                cookie = {}
            if len(parts) &gt; 1:
                cookie[parts[0]] = &quot;=&quot;.join(parts[1:])
            else:
                cookie[parts[0]] = True
        else:
            if value_set is True:
                # This is a new cookie; save the old one and clear for this one
                cookies.append(cookie)
                cookie = {}
                value_set = False
            cookie[parts[0]] = &quot;=&quot;.join(parts[1:])
            value_set = True

    if cookie:
        # Set the last cookie that was processed
        cookies.append(cookie)

    # These arguments are required by cookielib.Cookie()
    reqd = (
        &quot;version&quot;,
        &quot;port&quot;,
        &quot;port_specified&quot;,
        &quot;domain&quot;,
        &quot;domain_specified&quot;,
        &quot;domain_initial_dot&quot;,
        &quot;path&quot;,
        &quot;path_specified&quot;,
        &quot;secure&quot;,
        &quot;expires&quot;,
        &quot;discard&quot;,
        &quot;comment&quot;,
        &quot;comment_url&quot;,
        &quot;rest&quot;,
    )

    ret = []
    for cookie in cookies:
        name = None
        value = None
        for item in list(cookie):
            if item in attribs:
                continue
            name = item
            value = cookie.pop(item)

        # cookielib.Cookie() requires an epoch
        if &quot;expires&quot; in cookie:
            cookie[&quot;expires&quot;] = http.cookiejar.http2time(cookie[&quot;expires&quot;])

        # Fill in missing required fields
        for req in reqd:
            if req not in cookie:
                cookie[req] = &quot;&quot;
        if cookie[&quot;version&quot;] == &quot;&quot;:
            cookie[&quot;version&quot;] = 0
        if cookie[&quot;rest&quot;] == &quot;&quot;:
            cookie[&quot;rest&quot;] = {}
        if cookie[&quot;expires&quot;] == &quot;&quot;:
            cookie[&quot;expires&quot;] = 0

        # Remove attribs that don't apply to Cookie objects
        cookie.pop(&quot;httponly&quot;, None)
        cookie.pop(&quot;samesite&quot;, None)
        ret.append(http.cookiejar.Cookie(name=name, value=value, **cookie))

    return ret


def sanitize_url(url, hide_fields):
    &quot;&quot;&quot;
    Make sure no secret fields show up in logs
    &quot;&quot;&quot;
    if isinstance(hide_fields, list):
        url_comps = urllib.parse.splitquery(url)
        log_url = url_comps[0]
        if len(url_comps) &gt; 1:
            log_url += &quot;?&quot;
        for pair in url_comps[1:]:
            url_tmp = None
            for field in hide_fields:
                comps_list = pair.split(&quot;&amp;&quot;)
                if url_tmp:
                    url_tmp = url_tmp.split(&quot;&amp;&quot;)
                    url_tmp = _sanitize_url_components(url_tmp, field)
                else:
                    url_tmp = _sanitize_url_components(comps_list, field)
            log_url += url_tmp
        return log_url.rstrip(&quot;&amp;&quot;)
    else:
        return str(url)


def _sanitize_url_components(comp_list, field):
    &quot;&quot;&quot;
    Recursive function to sanitize each component of the url.
    &quot;&quot;&quot;
    if not comp_list:
        return &quot;&quot;
    elif comp_list[0].startswith(&quot;{}=&quot;.format(field)):
        ret = &quot;{}=XXXXXXXXXX&amp;&quot;.format(field)
        comp_list.remove(comp_list[0])
        return ret + _sanitize_url_components(comp_list, field)
    else:
        ret = &quot;{}&amp;&quot;.format(comp_list[0])
        comp_list.remove(comp_list[0])
        return ret + _sanitize_url_components(comp_list, field)


def session(user=None, password=None, verify_ssl=True, ca_bundle=None, headers=None):
    &quot;&quot;&quot;
    create a requests session
    &quot;&quot;&quot;
    session = requests.session()
    if user and password:
        session.auth = (user, password)
    if ca_bundle and not verify_ssl:
        log.error(&quot;You cannot use both ca_bundle and verify_ssl False together&quot;)
        return False
    if ca_bundle:
        opts = {&quot;ca_bundle&quot;: ca_bundle}
        session.verify = get_ca_bundle(opts)
    if not verify_ssl:
        session.verify = False
    if headers:
        session.headers.update(headers)
    return session
</PRE>
</div>
  </div>
</body>
</html>
