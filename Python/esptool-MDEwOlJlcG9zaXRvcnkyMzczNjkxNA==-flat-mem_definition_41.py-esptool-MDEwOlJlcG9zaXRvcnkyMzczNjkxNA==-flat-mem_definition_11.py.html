
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-mem_definition_41.py</h3>
            <pre><code>1  import os
2  import yaml
3  from ..mem_definition_base import (
4      EfuseBlocksBase,
5      EfuseFieldsBase,
6      EfuseRegistersBase,
7      Field,
8  )
9  class EfuseDefineRegisters(EfuseRegistersBase):
10      EFUSE_ADDR_MASK = 0x00000FFF
11      EFUSE_MEM_SIZE = 0x01FC + 4
12      DR_REG_EFUSE_BASE = 0x6001A000
13      EFUSE_PGM_DATA0_REG = DR_REG_EFUSE_BASE
14      EFUSE_CHECK_VALUE0_REG = DR_REG_EFUSE_BASE + 0x020
15      EFUSE_CLK_REG = DR_REG_EFUSE_BASE + 0x1C8
16      EFUSE_CONF_REG = DR_REG_EFUSE_BASE + 0x1CC
17      EFUSE_STATUS_REG = DR_REG_EFUSE_BASE + 0x1D0
18      EFUSE_CMD_REG = DR_REG_EFUSE_BASE + 0x1D4
19      EFUSE_RD_RS_ERR0_REG = DR_REG_EFUSE_BASE + 0x1C0
20      EFUSE_RD_RS_ERR1_REG = DR_REG_EFUSE_BASE + 0x1C4
21      EFUSE_RD_REPEAT_ERR0_REG = DR_REG_EFUSE_BASE + 0x17C
22      EFUSE_RD_REPEAT_ERR1_REG = DR_REG_EFUSE_BASE + 0x180
23      EFUSE_RD_REPEAT_ERR2_REG = DR_REG_EFUSE_BASE + 0x184
24      EFUSE_RD_REPEAT_ERR3_REG = DR_REG_EFUSE_BASE + 0x188
25      EFUSE_RD_REPEAT_ERR4_REG = DR_REG_EFUSE_BASE + 0x18C
26      EFUSE_DAC_CONF_REG = DR_REG_EFUSE_BASE + 0x1E8
27      EFUSE_RD_TIM_CONF_REG = DR_REG_EFUSE_BASE + 0x1EC
28      EFUSE_WR_TIM_CONF1_REG = DR_REG_EFUSE_BASE + 0x1F4
29      EFUSE_WR_TIM_CONF2_REG = DR_REG_EFUSE_BASE + 0x1F8
30      EFUSE_DATE_REG = DR_REG_EFUSE_BASE + 0x1FC
31      EFUSE_WRITE_OP_CODE = 0x5A5A
32      EFUSE_READ_OP_CODE = 0x5AA5
33      EFUSE_PGM_CMD_MASK = 0x3
34      EFUSE_PGM_CMD = 0x2
35      EFUSE_READ_CMD = 0x1
36      BLOCK_ERRORS = [
37          (EFUSE_RD_REPEAT_ERR0_REG, None, None, None),  # BLOCK0
38          (EFUSE_RD_RS_ERR0_REG, 0x7, 0, 3),  # MAC_SPI_8M_0
39          (EFUSE_RD_RS_ERR0_REG, 0x7, 4, 7),  # BLOCK_SYS_DATA
40          (EFUSE_RD_RS_ERR0_REG, 0x7, 8, 11),  # BLOCK_USR_DATA
41          (EFUSE_RD_RS_ERR0_REG, 0x7, 12, 15),  # BLOCK_KEY0
42          (EFUSE_RD_RS_ERR0_REG, 0x7, 16, 19),  # BLOCK_KEY1
43          (EFUSE_RD_RS_ERR0_REG, 0x7, 20, 23),  # BLOCK_KEY2
44          (EFUSE_RD_RS_ERR0_REG, 0x7, 24, 27),  # BLOCK_KEY3
45          (EFUSE_RD_RS_ERR0_REG, 0x7, 28, 31),  # BLOCK_KEY4
46          (EFUSE_RD_RS_ERR1_REG, 0x7, 0, 3),  # BLOCK_KEY5
47          (EFUSE_RD_RS_ERR1_REG, 0x7, 4, 7),  # BLOCK_SYS_DATA2
48      ]
49      EFUSE_PWR_OFF_NUM_S = 0
50      EFUSE_PWR_OFF_NUM_M = 0xFFFF << EFUSE_PWR_OFF_NUM_S
51      EFUSE_PWR_ON_NUM_S = 8
52      EFUSE_PWR_ON_NUM_M = 0x0000FFFF << EFUSE_PWR_ON_NUM_S
53      EFUSE_DAC_CLK_DIV_S = 0
54      EFUSE_DAC_CLK_DIV_M = 0xFF << EFUSE_DAC_CLK_DIV_S
55      EFUSE_DAC_NUM_S = 9
56      EFUSE_DAC_NUM_M = 0xFF << EFUSE_DAC_NUM_S
57  class EfuseDefineBlocks(EfuseBlocksBase):
58      __base_rd_regs = EfuseDefineRegisters.DR_REG_EFUSE_BASE
59      __base_wr_regs = EfuseDefineRegisters.EFUSE_PGM_DATA0_REG
60      BLOCKS = [
61          ("BLOCK0",          [],          0,  __base_rd_regs + 0x02C, __base_wr_regs, None, None, 6, None),
62          ("MAC_SPI_8M_0",    ["BLOCK1"],  1,  __base_rd_regs + 0x044, __base_wr_regs, 20,   None, 6, None),
63          ("BLOCK_SYS_DATA",  ["BLOCK2"],  2,  __base_rd_regs + 0x05C, __base_wr_regs, 21,   None, 8, None),
64          ("BLOCK_USR_DATA",  ["BLOCK3"],  3,  __base_rd_regs + 0x07C, __base_wr_regs, 22,   None, 8, None),
65          ("BLOCK_KEY0",      ["BLOCK4"],  4,  __base_rd_regs + 0x09C, __base_wr_regs, 23,   0,    8, "KEY_PURPOSE_0"),
66          ("BLOCK_KEY1",      ["BLOCK5"],  5,  __base_rd_regs + 0x0BC, __base_wr_regs, 24,   1,    8, "KEY_PURPOSE_1"),
67          ("BLOCK_KEY2",      ["BLOCK6"],  6,  __base_rd_regs + 0x0DC, __base_wr_regs, 25,   2,    8, "KEY_PURPOSE_2"),
68          ("BLOCK_KEY3",      ["BLOCK7"],  7,  __base_rd_regs + 0x0FC, __base_wr_regs, 26,   3,    8, "KEY_PURPOSE_3"),
69          ("BLOCK_KEY4",      ["BLOCK8"],  8,  __base_rd_regs + 0x11C, __base_wr_regs, 27,   4,    8, "KEY_PURPOSE_4"),
70          ("BLOCK_KEY5",      ["BLOCK9"],  9,  __base_rd_regs + 0x13C, __base_wr_regs, 28,   5,    8, "KEY_PURPOSE_5"),
71          ("BLOCK_SYS_DATA2", ["BLOCK10"], 10, __base_rd_regs + 0x15C, __base_wr_regs, 29,   6,    8, None),
72      ]
73      def get_burn_block_data_names(self):
74          list_of_names = []
75          for block in self.BLOCKS:
76              blk = self.get(block)
77              if blk.name:
78                  list_of_names.append(blk.name)
79              if blk.alias:
80                  for alias in blk.alias:
81                      list_of_names.append(alias)
82          return list_of_names
83  class EfuseDefineFields(EfuseFieldsBase):
84      def __init__(self) -> None:
85          self.EFUSES = []
86          self.KEYBLOCKS = []
87          self.BLOCK2_CALIBRATION_EFUSES = []
88          self.CALC = []
89          dir_name = os.path.dirname(os.path.abspath(__file__))
90          dir_name, file_name = os.path.split(dir_name)
91          file_name = file_name + ".yaml"
92          dir_name, _ = os.path.split(dir_name)
93          efuse_file = os.path.join(dir_name, "efuse_defs", file_name)
94          efuse_file = efuse_file.replace("esp32s3beta2", "esp32s3")
95          with open(f"{efuse_file}", "r") as r_file:
96              e_desc = yaml.safe_load(r_file)
97          super().__init__(e_desc)
98          for i, efuse in enumerate(self.ALL_EFUSES):
99              if efuse.name in [
100                  "BLOCK_USR_DATA",
101                  "BLOCK_KEY0",
102                  "BLOCK_KEY1",
103                  "BLOCK_KEY2",
104                  "BLOCK_KEY3",
105                  "BLOCK_KEY4",
106                  "BLOCK_KEY5",
107                  "BLOCK_SYS_DATA2",
108              ]:
109                  if efuse.name == "BLOCK_USR_DATA":
110                      efuse.bit_len = 256
111                      efuse.type = "bytes:32"
112                  self.KEYBLOCKS.append(efuse)
113                  self.ALL_EFUSES[i] = None
114              elif efuse.category == "calibration":
115                  self.BLOCK2_CALIBRATION_EFUSES.append(efuse)
116                  self.ALL_EFUSES[i] = None
117          f = Field()
<span onclick='openModal()' class='match'>118          f.name = "WAFER_VERSION_MINOR"
119          f.block = 0
120          f.bit_len = 4
121          f.type = f"uint:{f.bit_len}"
</span>122          f.category = "identity"
123          f.class_type = "wafer"
124          f.description = "calc WAFER VERSION MINOR = WAFER_VERSION_MINOR_HI << 3 + WAFER_VERSION_MINOR_LO (read only)"
125          self.CALC.append(f)
126          for efuse in self.ALL_EFUSES:
127              if efuse is not None:
128                  self.EFUSES.append(efuse)
129          self.ALL_EFUSES = []
</code></pre>
        </div>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-mem_definition_11.py</h3>
            <pre><code>1  import os
2  import yaml
3  from ..mem_definition_base import (
4      EfuseBlocksBase,
5      EfuseFieldsBase,
6      EfuseRegistersBase,
7      Field,
8  )
9  class EfuseDefineRegisters(EfuseRegistersBase):
10      EFUSE_MEM_SIZE = 0x01FC + 4
11      DR_REG_EFUSE_BASE = 0x3F41A000
12      EFUSE_PGM_DATA0_REG = DR_REG_EFUSE_BASE
13      EFUSE_CHECK_VALUE0_REG = DR_REG_EFUSE_BASE + 0x020
14      EFUSE_CLK_REG = DR_REG_EFUSE_BASE + 0x1C8
15      EFUSE_CONF_REG = DR_REG_EFUSE_BASE + 0x1CC
16      EFUSE_STATUS_REG = DR_REG_EFUSE_BASE + 0x1D0
17      EFUSE_CMD_REG = DR_REG_EFUSE_BASE + 0x1D4
18      EFUSE_RD_RS_ERR0_REG = DR_REG_EFUSE_BASE + 0x194
19      EFUSE_RD_RS_ERR1_REG = DR_REG_EFUSE_BASE + 0x198
20      EFUSE_RD_REPEAT_ERR0_REG = DR_REG_EFUSE_BASE + 0x17C
21      EFUSE_RD_REPEAT_ERR1_REG = DR_REG_EFUSE_BASE + 0x180
22      EFUSE_RD_REPEAT_ERR2_REG = DR_REG_EFUSE_BASE + 0x184
23      EFUSE_RD_REPEAT_ERR3_REG = DR_REG_EFUSE_BASE + 0x188
24      EFUSE_RD_REPEAT_ERR4_REG = DR_REG_EFUSE_BASE + 0x18C
25      EFUSE_DAC_CONF_REG = DR_REG_EFUSE_BASE + 0x1E8
26      EFUSE_RD_TIM_CONF_REG = DR_REG_EFUSE_BASE + 0x1EC
27      EFUSE_WR_TIM_CONF1_REG = DR_REG_EFUSE_BASE + 0x1F4
28      EFUSE_WR_TIM_CONF2_REG = DR_REG_EFUSE_BASE + 0x1F8
29      EFUSE_DATE_REG = DR_REG_EFUSE_BASE + 0x1FC
30      EFUSE_WRITE_OP_CODE = 0x5A5A
31      EFUSE_READ_OP_CODE = 0x5AA5
32      EFUSE_PGM_CMD_MASK = 0x3
33      EFUSE_PGM_CMD = 0x2
34      EFUSE_READ_CMD = 0x1
35      BLOCK_ERRORS = [
36          (EFUSE_RD_REPEAT_ERR0_REG, None, None, None),  # BLOCK0
37          (EFUSE_RD_RS_ERR0_REG, 0x7, 0, 3),  # MAC_SPI_8M_0
38          (EFUSE_RD_RS_ERR0_REG, 0x7, 4, 7),  # BLOCK_SYS_DATA
39          (EFUSE_RD_RS_ERR0_REG, 0x7, 8, 11),  # BLOCK_USR_DATA
40          (EFUSE_RD_RS_ERR0_REG, 0x7, 12, 15),  # BLOCK_KEY0
41          (EFUSE_RD_RS_ERR0_REG, 0x7, 16, 19),  # BLOCK_KEY1
42          (EFUSE_RD_RS_ERR0_REG, 0x7, 20, 23),  # BLOCK_KEY2
43          (EFUSE_RD_RS_ERR0_REG, 0x7, 24, 27),  # BLOCK_KEY3
44          (EFUSE_RD_RS_ERR0_REG, 0x7, 28, 31),  # BLOCK_KEY4
45          (EFUSE_RD_RS_ERR1_REG, 0x7, 0, 3),  # BLOCK_KEY5
46          (EFUSE_RD_RS_ERR1_REG, 0x7, 4, 7),  # BLOCK_SYS_DATA2
47      ]
48      EFUSE_DAC_CONF_REG = DR_REG_EFUSE_BASE + 0x1E8
49      EFUSE_DAC_CLK_DIV_S = 0
50      EFUSE_DAC_CLK_DIV_M = 0xFF << EFUSE_DAC_CLK_DIV_S
51      EFUSE_RD_TIM_CONF_REG = DR_REG_EFUSE_BASE + 0x1EC
52      EFUSE_TSUR_A_S = 16
53      EFUSE_TSUR_A_M = 0xFF << EFUSE_TSUR_A_S
54      EFUSE_TRD_S = 8
55      EFUSE_TRD_M = 0xFF << EFUSE_TRD_S
56      EFUSE_THR_A_S = 0
57      EFUSE_THR_A_M = 0xFF << EFUSE_THR_A_S
58      EFUSE_WR_TIM_CONF0_REG = DR_REG_EFUSE_BASE + 0x1F0
59      EFUSE_TPGM_S = 16
60      EFUSE_TPGM_M = 0xFFFF << EFUSE_TPGM_S
61      EFUSE_TPGM_INACTIVE_S = 8
62      EFUSE_TPGM_INACTIVE_M = 0xFF << EFUSE_TPGM_INACTIVE_S
63      EFUSE_THP_A_S = 0
64      EFUSE_THP_A_M = 0xFF << EFUSE_THP_A_S
65      EFUSE_PWR_ON_NUM_S = 8
66      EFUSE_PWR_ON_NUM_M = 0xFFFF << EFUSE_PWR_ON_NUM_S
67      EFUSE_TSUP_A_S = 0
68      EFUSE_TSUP_A_M = 0xFF << EFUSE_TSUP_A_S
69      EFUSE_PWR_OFF_NUM_S = 0
70      EFUSE_PWR_OFF_NUM_M = 0xFFFF << EFUSE_PWR_OFF_NUM_S
71      EFUSE_PROGRAMMING_TIMING_PARAMETERS = {
72          80: (0x2, 0x320, 0x2, 0x4),
73          40: (0x1, 0x190, 0x1, 0x2),
74          20: (0x1, 0xC8, 0x1, 0x1),
75      }
76      VDDQ_TIMING_PARAMETERS = {
77          80: (0xA0, 0xA200, 0x100),
78          40: (0x50, 0x5100, 0x80),
79          20: (0x28, 0x2880, 0x40),
80      }
81      EFUSE_READING_PARAMETERS = {
82          80: (0x2, 0x4, 0x2),
83          40: (0x1, 0x2, 0x1),
84          20: (0x1, 0x1, 0x1),
85      }
86  class EfuseDefineBlocks(EfuseBlocksBase):
87      __base_rd_regs = EfuseDefineRegisters.DR_REG_EFUSE_BASE
88      __base_wr_regs = EfuseDefineRegisters.EFUSE_PGM_DATA0_REG
89      BLOCKS = [
90          ("BLOCK0",          [],          0,  __base_rd_regs + 0x02C, __base_wr_regs, None, None, 6, None),
91          ("MAC_SPI_8M_0",    ["BLOCK1"],  1,  __base_rd_regs + 0x044, __base_wr_regs, 20,   None, 6, None),
92          ("BLOCK_SYS_DATA",  ["BLOCK2"],  2,  __base_rd_regs + 0x05C, __base_wr_regs, 21,   None, 8, None),
93          ("BLOCK_USR_DATA",  ["BLOCK3"],  3,  __base_rd_regs + 0x07C, __base_wr_regs, 22,   None, 8, None),
94          ("BLOCK_KEY0",      ["BLOCK4"],  4,  __base_rd_regs + 0x09C, __base_wr_regs, 23,   0,    8, "KEY_PURPOSE_0"),
95          ("BLOCK_KEY1",      ["BLOCK5"],  5,  __base_rd_regs + 0x0BC, __base_wr_regs, 24,   1,    8, "KEY_PURPOSE_1"),
96          ("BLOCK_KEY2",      ["BLOCK6"],  6,  __base_rd_regs + 0x0DC, __base_wr_regs, 25,   2,    8, "KEY_PURPOSE_2"),
97          ("BLOCK_KEY3",      ["BLOCK7"],  7,  __base_rd_regs + 0x0FC, __base_wr_regs, 26,   3,    8, "KEY_PURPOSE_3"),
98          ("BLOCK_KEY4",      ["BLOCK8"],  8,  __base_rd_regs + 0x11C, __base_wr_regs, 27,   4,    8, "KEY_PURPOSE_4"),
99          ("BLOCK_KEY5",      ["BLOCK9"],  9,  __base_rd_regs + 0x13C, __base_wr_regs, 28,   5,    8, "KEY_PURPOSE_5"),
100          ("BLOCK_SYS_DATA2", ["BLOCK10"], 10, __base_rd_regs + 0x15C, __base_wr_regs, 29,   6,    8, None),
101      ]
102      def get_burn_block_data_names(self):
103          list_of_names = []
104          for block in self.BLOCKS:
105              blk = self.get(block)
106              if blk.name:
107                  list_of_names.append(blk.name)
108              if blk.alias:
109                  for alias in blk.alias:
110                      list_of_names.append(alias)
111          return list_of_names
112  class EfuseDefineFields(EfuseFieldsBase):
113      def __init__(self) -> None:
114          self.EFUSES = []
115          self.KEYBLOCKS = []
116          self.BLOCK2_CALIBRATION_EFUSES = []
117          self.CALC = []
118          dir_name = os.path.dirname(os.path.abspath(__file__))
119          dir_name, file_name = os.path.split(dir_name)
120          file_name = file_name + ".yaml"
121          dir_name, _ = os.path.split(dir_name)
122          efuse_file = os.path.join(dir_name, "efuse_defs", file_name)
123          with open(f"{efuse_file}", "r") as r_file:
124              e_desc = yaml.safe_load(r_file)
125          super().__init__(e_desc)
126          for i, efuse in enumerate(self.ALL_EFUSES):
127              if efuse.name in [
128                  "BLOCK_USR_DATA",
129                  "BLOCK_KEY0",
130                  "BLOCK_KEY1",
131                  "BLOCK_KEY2",
132                  "BLOCK_KEY3",
133                  "BLOCK_KEY4",
134                  "BLOCK_KEY5",
135                  "BLOCK_SYS_DATA2",
136              ]:
137                  if efuse.name == "BLOCK_USR_DATA":
138                      efuse.bit_len = 256
139                      efuse.type = "bytes:32"
140                  self.KEYBLOCKS.append(efuse)
141                  self.ALL_EFUSES[i] = None
142              elif efuse.category == "calibration":
143                  self.BLOCK2_CALIBRATION_EFUSES.append(efuse)
144                  self.ALL_EFUSES[i] = None
145          f = Field()
<span onclick='openModal()' class='match'>146          f.name = "WAFER_VERSION_MINOR"
147          f.block = 0
148          f.bit_len = 4
149          f.type = f"uint:{f.bit_len}"
</span>150          f.category = "identity"
151          f.class_type = "wafer"
152          f.description = "calc WAFER VERSION MINOR = WAFER_VERSION_MINOR_HI << 3 + WAFER_VERSION_MINOR_LO (read only)"
153          self.CALC.append(f)
154          for efuse in self.ALL_EFUSES:
155              if efuse is not None:
156                  self.EFUSES.append(efuse)
157          self.ALL_EFUSES = []
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-mem_definition_41.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-mem_definition_11.py</div>
                </div>
                <div class="column column_space"><pre><code>118          f.name = "WAFER_VERSION_MINOR"
119          f.block = 0
120          f.bit_len = 4
121          f.type = f"uint:{f.bit_len}"
</pre></code></div>
                <div class="column column_space"><pre><code>146          f.name = "WAFER_VERSION_MINOR"
147          f.block = 0
148          f.bit_len = 4
149          f.type = f"uint:{f.bit_len}"
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    