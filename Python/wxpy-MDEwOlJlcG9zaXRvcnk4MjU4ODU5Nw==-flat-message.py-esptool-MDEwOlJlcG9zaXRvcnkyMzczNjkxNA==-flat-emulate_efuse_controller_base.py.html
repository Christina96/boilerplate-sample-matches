
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>wxpy-MDEwOlJlcG9zaXRvcnk4MjU4ODU5Nw==-flat-message.py</h3>
            <pre><code>1  from __future__ import unicode_literals
2  import logging
3  import os
4  import tempfile
5  import weakref
6  from datetime import datetime
7  from xml.etree import ElementTree as ETree
8  try:
9      import html
10  except ImportError:
11      from HTMLParser import HTMLParser
12      html = HTMLParser()
13  from wxpy.api.chats import Chat, Group, Member, User
14  from wxpy.compatible.utils import force_encoded_string_output
15  from wxpy.utils import wrap_user_name, repr_message
16  from .article import Article
17  from ..consts import ATTACHMENT, CARD, FRIENDS, MAP, PICTURE, RECORDING, SHARING, TEXT, VIDEO
18  from ...compatible import *
19  logger = logging.getLogger(__name__)
20  class Message(object):
21      def __init__(self, raw, bot):
22          self.raw = raw
23          self.bot = weakref.proxy(bot)
24          self._receive_time = datetime.now()
25          for method in '', '_image', '_file', '_video', '_msg', '_raw_msg':
26              setattr(self, 'reply' + method, getattr(self.chat, 'send' + method))
27      def __hash__(self):
28          return hash((Message, self.id))
29      @force_encoded_string_output
30      def __repr__(self):
31          return repr_message(self)
32      def __unicode__(self):
33          return repr_message(self)
34      @property
35      def type(self):
36          return self.raw.get('Type')
37      @property
38      def id(self):
39          return self.raw.get('NewMsgId')
40      @property
41      def text(self):
42          _type = self.type
43          _card = self.card
44          if _type == MAP:
45              location = self.location
46              if location:
47                  return location.get('label')
48          elif _card:
49              if _type == CARD:
50                  return _card.name
51              elif _type == FRIENDS:
52                  return _card.raw.get('Content')
53          ret = self.raw.get('Text')
54          if isinstance(ret, str):
55              return ret
56      def get_file(self, save_path=None):
57          _text = self.raw.get('Text')
58          if callable(_text) and self.type in (PICTURE, RECORDING, ATTACHMENT, VIDEO):
59              return _text(save_path)
60          else:
61              raise ValueError('download method not found, or invalid message type')
62      @property
63      def file_name(self):
64          return self.raw.get('FileName')
65      @property
66      def file_size(self):
67          return self.raw.get('FileSize')
68      @property
69      def media_id(self):
70          return self.raw.get('MediaId')
71      @property
72      def is_at(self):
73          return self.raw.get('IsAt') or self.raw.get('isAt')
74      @property
75      def img_height(self):
76          return self.raw.get('ImgHeight')
77      @property
78      def img_width(self):
79          return self.raw.get('ImgWidth')
80      @property
81      def play_length(self):
82          return self.raw.get('PlayLength')
83      @property
84      def voice_length(self):
85          return self.raw.get('VoiceLength')
86      @property
87      def url(self):
88          _url = self.raw.get('Url')
89          if isinstance(_url, str):
90              _url = html.unescape(_url)
91          return _url
92      @property
93      def articles(self):
94          from wxpy import MP
95          if self.type == SHARING and isinstance(self.sender, MP):
96              tree = ETree.fromstring(self.raw['Content'])
97              items = tree.findall('.//mmreader/category/item')
98              article_list = list()
99              for item in items:
100                  def find_text(tag):
101                      found = item.find(tag)
102                      if found is not None:
103                          return found.text
104                  article = Article()
105                  article.title = find_text('title')
106                  article.summary = find_text('digest')
107                  article.url = find_text('url')
108                  article.cover = find_text('cover')
109                  article_list.append(article)
110              return article_list
111      @property
112      def card(self):
113          if self.type in (CARD, FRIENDS):
114              return User(self.raw.get('RecommendInfo'), self.bot)
115      @property
116      def create_time(self):
117          try:
118              return datetime.fromtimestamp(self.raw.get('CreateTime'))
119          except:
120              pass
121      @property
122      def receive_time(self):
123          return self._receive_time
124      @property
125      def latency(self):
126          create_time = self.create_time
127          if create_time:
128              return (self.receive_time - create_time).total_seconds()
129      @property
130      def location(self):
131          try:
132              ret = ETree.fromstring(self.raw['OriContent']).find('location').attrib
133              try:
134                  ret['x'] = float(ret['x'])
135                  ret['y'] = float(ret['y'])
136                  ret['scale'] = int(ret['scale'])
137                  ret['maptype'] = int(ret['maptype'])
138              except (KeyError, ValueError):
139                  pass
140              return ret
141          except (TypeError, KeyError, ValueError, ETree.ParseError):
142              pass
143      @property
144      def chat(self):
145          if self.raw.get('FromUserName') == self.bot.self.user_name:
146              return self.receiver
147          else:
148              return self.sender
149      @property
150      def sender(self):
151          return self._get_chat_by_user_name(self.raw.get('FromUserName'))
152      @property
153      def receiver(self):
154          return self._get_chat_by_user_name(self.raw.get('ToUserName'))
155      @property
156      def member(self):
157          if isinstance(self.chat, Group):
158              if self.sender == self.bot.self:
159                  return self.chat.self
160              else:
161                  actual_user_name = self.raw.get('ActualUserName')
<span onclick='openModal()' class='match'>162                  for _member in self.chat.members:
163                      if _member.user_name == actual_user_name:
164                          return _member
</span>165                  return Member(dict(
166                      UserName=actual_user_name,
167                      NickName=self.raw.get('ActualNickName')
168                  ), self.chat)
169      def _get_chat_by_user_name(self, user_name):
170          def match_in_chats(_chats):
171              for c in _chats:
172                  if c.user_name == user_name:
173                      return c
174          _chat = None
175          if user_name.startswith('@@'):
176              _chat = match_in_chats(self.bot.groups())
177          elif user_name:
178              _chat = match_in_chats(self.bot.friends())
179              if not _chat:
180                  _chat = match_in_chats(self.bot.mps())
181          if not _chat:
182              _chat = Chat(wrap_user_name(user_name), self.bot)
183          return _chat
184      def forward(self, chat, prefix=None, suffix=None, raise_for_unsupported=False):
185          logger.info('{}: forwarding to {}: {}'.format(self.bot, chat, self))
186          def wrapped_send(send_type, *args, **kwargs):
187              if send_type == 'msg':
188                  if args:
189                      text = args[0]
190                  elif kwargs:
191                      text = kwargs['msg']
192                  else:
193                      text = self.text
194                  ret = chat.send_msg('{}{}{}'.format(
195                      str(prefix) + '\n' if prefix else '',
196                      text,
197                      '\n' + str(suffix) if suffix else '',
198                  ))
199              else:
200                  if prefix:
201                      chat.send_msg(prefix)
202                  ret = getattr(chat, 'send_{}'.format(send_type))(*args, **kwargs)
203                  if suffix:
204                      chat.send_msg(suffix)
205              return ret
206          def download_and_send():
207              fd, path = tempfile.mkstemp(
208                  suffix='_{}'.format(self.file_name),
209                  dir=self.bot.temp_dir.name
210              )
211              try:
212                  self.get_file(path)
213                  if self.type == PICTURE:
214                      return wrapped_send('image', path)
215                  elif self.type == VIDEO:
216                      return wrapped_send('video', path)
217                  else:
218                      return wrapped_send('file', path)
219              finally:
220                  os.close(fd)
221          def raise_properly(text):
222              logger.warning(text)
223              if raise_for_unsupported:
224                  raise NotImplementedError(text)
225          if self.type == TEXT:
226              return wrapped_send('msg')
227          elif self.type == SHARING:
228              return wrapped_send('msg', '{}\n{}'.format(self.text, self.url))
229          elif self.type == MAP:
230              return wrapped_send('msg', '{}: {}\n{}'.format(
231                  self.location['poiname'], self.location['label'], self.url
232              ))
233          elif self.type == ATTACHMENT:
234              content = \
235                  "<appmsg appid='wxeb7ec651dd0aefa9' sdkver=''>" \
236                  "<title>{file_name}</title><des></des><action></action>" \
237                  "<type>6</type><content></content><url></url><lowurl></lowurl>" \
238                  "<appattach><totallen>{file_size}</totallen><attachid>{media_id}</attachid>" \
239                  "<fileext>{file_ext}</fileext></appattach><extinfo></extinfo></appmsg>"
240              content = content.format(
241                  file_name=self.file_name,
242                  file_size=self.file_size,
243                  media_id=self.media_id,
244                  file_ext=os.path.splitext(self.file_name)[1].replace('.', '')
245              )
246              return wrapped_send(
247                  send_type='raw_msg',
248                  raw_type=self.raw['MsgType'],
249                  raw_content=content,
250                  uri='/webwxsendappmsg?fun=async&f=json'
251              )
252          elif self.type == CARD:
253              if self.card.raw.get('AttrStatus') and self.sender != self.bot.self:
254                  raise_properly('Personal cards sent from others are unsupported:\n{}'.format(self))
255              else:
256                  return wrapped_send(
257                      send_type='raw_msg',
258                      raw_type=self.raw['MsgType'],
259                      raw_content=self.raw['Content'],
260                      uri='/webwxsendmsg'
261                  )
262          elif self.type == PICTURE:
263              if self.raw.get('HasProductId'):
264                  raise_properly('Stickers from store are unsupported:\n{}'.format(self))
265              else:
266                  return download_and_send()
267          elif self.type == VIDEO:
268              return download_and_send()
269          elif self.type == RECORDING:
270              return download_and_send()
271          else:
272              raise_properly('Unsupported message type:\n{}'.format(self))
</code></pre>
        </div>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-emulate_efuse_controller_base.py</h3>
            <pre><code>1  import re
2  from bitstring import BitStream
3  class EmulateEfuseControllerBase(object):
4      CHIP_NAME = ""
5      mem = None
6      debug = False
7      Blocks = None
8      Fields = None
9      REGS = None
10      def __init__(self, efuse_file=None, debug=False):
11          self.debug = debug
12          self.efuse_file = efuse_file
13          if self.efuse_file:
14              try:
15                  self.mem = BitStream(
16                      bytes=open(self.efuse_file, "rb").read(),
17                      length=self.REGS.EFUSE_MEM_SIZE * 8,
18                  )
19              except (ValueError, FileNotFoundError):
20                  self.mem = BitStream(length=self.REGS.EFUSE_MEM_SIZE * 8)
21                  self.mem.set(0)
22                  self.mem.tofile(open(self.efuse_file, "a+b"))
23          else:
24              self.mem = BitStream(self.REGS.EFUSE_MEM_SIZE * 8)
25              self.mem.set(0)
26      def get_chip_description(self):
27          major_rev = self.get_major_chip_version()
28          minor_rev = self.get_minor_chip_version()
29          return f"{self.CHIP_NAME} (revision v{major_rev}.{minor_rev})"
30      def get_chip_revision(self):
31          return self.get_major_chip_version() * 100 + self.get_minor_chip_version()
32      def read_efuse(self, n, block=0):
33          blk = self.Blocks.get(self.Blocks.BLOCKS[block])
34          return self.read_reg(blk.rd_addr + (4 * n))
35      def read_reg(self, addr):
36          self.mem.pos = self.mem.length - ((addr - self.REGS.DR_REG_EFUSE_BASE) * 8 + 32)
37          return self.mem.read("uint:32")
38      def write_reg(self, addr, value, mask=0xFFFFFFFF, delay_us=0, delay_after_us=0):
39          self.mem.pos = self.mem.length - ((addr - self.REGS.DR_REG_EFUSE_BASE) * 8 + 32)
40          self.mem.overwrite("uint:32={}".format(value & mask))
41          self.handle_writing_event(addr, value)
42      def update_reg(self, addr, mask, new_val):
43          position = self.mem.length - ((addr - self.REGS.DR_REG_EFUSE_BASE) * 8 + 32)
44          self.mem.pos = position
45          cur_val = self.mem.read("uint:32")
46          self.mem.pos = position
47          self.mem.overwrite("uint:32={}".format(cur_val | (new_val & mask)))
48      def write_efuse(self, n, value, block=0):
49          blk = self.Blocks.get(self.Blocks.BLOCKS[block])
50          self.write_reg(blk.wr_addr + (4 * n), value)
51      def handle_writing_event(self, addr, value):
52          self.save_to_file()
53      def save_to_file(self):
54          if self.efuse_file:
55              with open(self.efuse_file, "wb") as f:
56                  self.mem.tofile(f)
57      def handle_coding_scheme(self, blk, data):
58          return data
59      def copy_blocks_wr_regs_to_rd_regs(self, updated_block=None):
60          for b in reversed(self.Blocks.BLOCKS):
61              blk = self.Blocks.get(b)
62              if updated_block is not None:
63                  if blk.id != updated_block:
64                      continue
65              data = self.read_block(blk.id, wr_regs=True)
66              if self.debug:
67                  print(blk.name, data.hex)
68              plain_data = self.handle_coding_scheme(blk, data)
69              plain_data = self.check_wr_protection_area(blk.id, plain_data)
70              self.update_block(blk, plain_data)
71      def clean_blocks_wr_regs(self):
72          for b in self.Blocks.BLOCKS:
73              blk = self.Blocks.get(b)
74              for offset in range(0, blk.len * 4, 4):
75                  wr_addr = blk.wr_addr + offset
76                  self.write_reg(wr_addr, 0)
77      def read_field(self, name, bitstring=True):
<span onclick='openModal()' class='match'>78          for field in self.Fields.EFUSES:
79              if field.name == name:
80                  self.read_block(field.block)
</span>81                  block = self.read_block(field.block)
82                  if field.type.startswith("bool"):
83                      field_len = 1
84                  else:
85                      field_len = int(re.search(r"\d+", field.type).group())
86                      if field.type.startswith("bytes"):
87                          field_len *= 8
88                  block.pos = block.length - (field.word * 32 + field.pos + field_len)
89                  if bitstring:
90                      return block.read(field_len)
91                  else:
92                      return block.read(field.type)
93          return None
94      def get_bitlen_of_block(self, blk, wr=False):
95          return 32 * blk.len
96      def read_block(self, idx, wr_regs=False):
97          block = None
98          for b in self.Blocks.BLOCKS:
99              blk = self.Blocks.get(b)
100              if blk.id == idx:
101                  blk_len_bits = self.get_bitlen_of_block(blk, wr=wr_regs)
102                  addr = blk.wr_addr if wr_regs else blk.rd_addr
103                  self.mem.pos = self.mem.length - (
104                      (addr - self.REGS.DR_REG_EFUSE_BASE) * 8 + blk_len_bits
105                  )
106                  block = self.mem.read(blk_len_bits)
107                  break
108          return block
109      def update_block(self, blk, wr_data):
110          wr_data = self.read_block(blk.id) | wr_data
111          self.overwrite_mem_from_block(blk, wr_data)
112      def overwrite_mem_from_block(self, blk, wr_data):
113          self.mem.pos = self.mem.length - (
114              (blk.rd_addr - self.REGS.DR_REG_EFUSE_BASE) * 8 + wr_data.len
115          )
116          self.mem.overwrite(wr_data)
117      def check_wr_protection_area(self, num_blk, wr_data):
118          write_disable_bit = self.read_field("WR_DIS", bitstring=False)
119          mask_wr_data = BitStream(len(wr_data))
120          mask_wr_data.set(0)
121          blk = self.Blocks.get(self.Blocks.BLOCKS[num_blk])
122          if blk.write_disable_bit is not None and write_disable_bit & (
123              1 << blk.write_disable_bit
124          ):
125              mask_wr_data.set(1)
126          else:
127              for field in self.Fields.EFUSES:
128                  if blk.id == field.block and field.block == num_blk:
129                      if field.write_disable_bit is not None and write_disable_bit & (
130                          1 << field.write_disable_bit
131                      ):
132                          data = self.read_field(field.name)
133                          data.set(1)
134                          mask_wr_data.pos = mask_wr_data.length - (
135                              field.word * 32 + field.pos + data.len
136                          )
137                          mask_wr_data.overwrite(data)
138          mask_wr_data.invert()
139          return wr_data & mask_wr_data
140      def check_rd_protection_area(self):
141          read_disable_bit = self.read_field("RD_DIS", bitstring=False)
142          for b in self.Blocks.BLOCKS:
143              blk = self.Blocks.get(b)
144              block = self.read_block(blk.id)
145              if blk.read_disable_bit is not None and read_disable_bit & (
146                  1 << blk.read_disable_bit
147              ):
148                  block.set(0)
149              else:
150                  for field in self.Fields.EFUSES:
151                      if (
152                          blk.id == field.block
153                          and field.read_disable_bit is not None
154                          and read_disable_bit & (1 << field.read_disable_bit)
155                      ):
156                          raw_data = self.read_field(field.name)
157                          raw_data.set(0)
158                          block.pos = block.length - (
159                              field.word * 32 + field.pos + raw_data.length
160                          )
161                          block.overwrite(BitStream(raw_data.length))
162              self.overwrite_mem_from_block(blk, block)
163      def clean_mem(self):
164          self.mem.set(0)
165          if self.efuse_file:
166              with open(self.efuse_file, "wb") as f:
167                  self.mem.tofile(f)
168  class FatalError(RuntimeError):
169      def __init__(self, message):
170          RuntimeError.__init__(self, message)
171      @staticmethod
172      def WithResult(message, result):
173          return FatalError(result)
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from wxpy-MDEwOlJlcG9zaXRvcnk4MjU4ODU5Nw==-flat-message.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-emulate_efuse_controller_base.py</div>
                </div>
                <div class="column column_space"><pre><code>162                  for _member in self.chat.members:
163                      if _member.user_name == actual_user_name:
164                          return _member
</pre></code></div>
                <div class="column column_space"><pre><code>78          for field in self.Fields.EFUSES:
79              if field.name == name:
80                  self.read_block(field.block)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    