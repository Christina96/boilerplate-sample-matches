<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for client.py & version.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for client.py & version.py
      </h3>
      <h1 align="center">
        2.6%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>client.py (8.695652%)<TH>version.py (1.5414258%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match134580-0.html#0',2,'match134580-1.html#0',3)" NAME="0">(45-67)<TD><A HREF="javascript:ZweiFrames('match134580-0.html#0',2,'match134580-1.html#0',3)" NAME="0">(680-703)</A><TD ALIGN=center><FONT COLOR="#ff0000">24</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>client.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
import copy
import logging
import os
import random

import salt.client.ssh
import salt.config
import salt.syspaths
import salt.utils.args
from salt.exceptions import SaltClientError

log = logging.getLogger(__name__)


class SSHClient:
    &quot;&quot;&quot;
    Create a client object for executing routines via the salt-ssh backend

    .. versionadded:: 2015.5.0
    &quot;&quot;&quot;

    def __init__(
        self,
        c_path=os.path.join(salt.syspaths.CONFIG_DIR, &quot;master&quot;),
        mopts=None,
        disable_custom_roster=False,
    ):
        if mopts:
            self.opts = mopts
        else:
            if os.path.isdir(c_path):
                log.warning(
                    &quot;%s expects a file path not a directory path(%s) to &quot;
                    &quot;its 'c_path' keyword argument&quot;,
                    self.__class__.__name__,
                    c_path,
                )
            self.opts = salt.config.client_config(c_path)

        # Salt API should never offer a custom roster!
        self.opts[&quot;__disable_custom_roster&quot;] = disable_custom_roster
<A NAME="0"></A>
    def sanitize_kwargs(self, kwargs):
        roster_vals = [
            <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match134580-1.html#0',3,'match134580-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>(&quot;host&quot;, str),
            (&quot;ssh_user&quot;, str),
            (&quot;ssh_passwd&quot;, str),
            (&quot;ssh_port&quot;, int),
            (&quot;ssh_sudo&quot;, bool),
            (&quot;ssh_sudo_user&quot;, str),
            (&quot;ssh_priv&quot;, str),
            (&quot;ssh_priv_passwd&quot;, str),
            (&quot;ssh_identities_only&quot;, bool),
            (&quot;ssh_remote_port_forwards&quot;, str),
            (&quot;ssh_options&quot;, list),
            (&quot;ssh_max_procs&quot;, int),
            (&quot;ssh_askpass&quot;, bool),
            (&quot;ssh_key_deploy&quot;, bool),
            (&quot;ssh_update_roster&quot;, bool),
            (&quot;ssh_scan_ports&quot;, str),
            (&quot;ssh_scan_timeout&quot;, int),
            (&quot;ssh_timeout&quot;, int),
            (&quot;ssh_log_file&quot;, str),
            (&quot;raw_shell&quot;, bool),
            (&quot;refresh_cache&quot;, bool),
            (&quot;roster&quot;, str),
            (&quot;roster_file&quot;</B></FONT>, str),
            (&quot;rosters&quot;, list),
            (&quot;ignore_host_keys&quot;, bool),
            (&quot;raw_shell&quot;, bool),
            (&quot;extra_filerefs&quot;, str),
            (&quot;min_extra_mods&quot;, str),
            (&quot;thin_extra_mods&quot;, str),
            (&quot;verbose&quot;, bool),
            (&quot;static&quot;, bool),
            (&quot;ssh_wipe&quot;, bool),
            (&quot;rand_thin_dir&quot;, bool),
            (&quot;regen_thin&quot;, bool),
            (&quot;ssh_run_pre_flight&quot;, bool),
            (&quot;no_host_keys&quot;, bool),
            (&quot;saltfile&quot;, str),
        ]
        sane_kwargs = {}
        for name, kind in roster_vals:
            if name not in kwargs:
                continue
            try:
                val = kind(kwargs[name])
            except ValueError:
                log.warning(&quot;Unable to cast kwarg %s&quot;, name)
                continue
            if kind is bool or kind is int:
                sane_kwargs[name] = val
            elif kind is str:
                if val.find(&quot;ProxyCommand&quot;) != -1:
                    log.warning(&quot;Filter unsafe value for kwarg %s&quot;, name)
                    continue
                sane_kwargs[name] = val
            elif kind is list:
                sane_val = []
                for item in val:
                    # This assumes the values are strings
                    if item.find(&quot;ProxyCommand&quot;) != -1:
                        log.warning(&quot;Filter unsafe value for kwarg %s&quot;, name)
                        continue
                    sane_val.append(item)
                sane_kwargs[name] = sane_val
        return sane_kwargs

    def _prep_ssh(
        self, tgt, fun, arg=(), timeout=None, tgt_type=&quot;glob&quot;, kwarg=None, **kwargs
    ):
        &quot;&quot;&quot;
        Prepare the arguments
        &quot;&quot;&quot;
        kwargs = self.sanitize_kwargs(kwargs)
        opts = copy.deepcopy(self.opts)
        opts.update(kwargs)
        if timeout:
            opts[&quot;timeout&quot;] = timeout
        arg = salt.utils.args.condition_input(arg, kwarg)
        opts[&quot;argv&quot;] = [fun] + arg
        opts[&quot;selected_target_option&quot;] = tgt_type
        opts[&quot;tgt&quot;] = tgt
        opts[&quot;arg&quot;] = arg
        return salt.client.ssh.SSH(opts)

    def cmd_iter(
        self,
        tgt,
        fun,
        arg=(),
        timeout=None,
        tgt_type=&quot;glob&quot;,
        ret=&quot;&quot;,
        kwarg=None,
        **kwargs
    ):
        &quot;&quot;&quot;
        Execute a single command via the salt-ssh subsystem and return a
        generator

        .. versionadded:: 2015.5.0
        &quot;&quot;&quot;
        ssh = self._prep_ssh(tgt, fun, arg, timeout, tgt_type, kwarg, **kwargs)
        yield from ssh.run_iter(jid=kwargs.get(&quot;jid&quot;, None))

    def cmd(
        self, tgt, fun, arg=(), timeout=None, tgt_type=&quot;glob&quot;, kwarg=None, **kwargs
    ):
        &quot;&quot;&quot;
        Execute a single command via the salt-ssh subsystem and return all
        routines at once

        .. versionadded:: 2015.5.0
        &quot;&quot;&quot;
        ssh = self._prep_ssh(tgt, fun, arg, timeout, tgt_type, kwarg, **kwargs)
        final = {}
        for ret in ssh.run_iter(jid=kwargs.get(&quot;jid&quot;, None)):
            final.update(ret)
        return final

    def cmd_sync(self, low):
        &quot;&quot;&quot;
        Execute a salt-ssh call synchronously.

        .. versionadded:: 2015.5.0

        WARNING: Eauth is **NOT** respected

        .. code-block:: python

            client.cmd_sync({
                'tgt': 'silver',
                'fun': 'test.ping',
                'arg': (),
                'tgt_type'='glob',
                'kwarg'={}
                })
            {'silver': {'fun_args': [], 'jid': '20141202152721523072', 'return': True, 'retcode': 0, 'success': True, 'fun': 'test.ping', 'id': 'silver'}}
        &quot;&quot;&quot;

        kwargs = copy.deepcopy(low)

        for ignore in [&quot;tgt&quot;, &quot;fun&quot;, &quot;arg&quot;, &quot;timeout&quot;, &quot;tgt_type&quot;, &quot;kwarg&quot;]:
            if ignore in kwargs:
                del kwargs[ignore]

        return self.cmd(
            low[&quot;tgt&quot;],
            low[&quot;fun&quot;],
            low.get(&quot;arg&quot;, []),
            low.get(&quot;timeout&quot;),
            low.get(&quot;tgt_type&quot;),
            low.get(&quot;kwarg&quot;),
            **kwargs
        )

    def cmd_async(self, low, timeout=None):
        &quot;&quot;&quot;
        Execute aa salt-ssh asynchronously

        WARNING: Eauth is **NOT** respected

        .. code-block:: python

            client.cmd_sync({
                'tgt': 'silver',
                'fun': 'test.ping',
                'arg': (),
                'tgt_type'='glob',
                'kwarg'={}
                })
            {'silver': {'fun_args': [], 'jid': '20141202152721523072', 'return': True, 'retcode': 0, 'success': True, 'fun': 'test.ping', 'id': 'silver'}}
        &quot;&quot;&quot;
        # TODO Not implemented
        raise SaltClientError

    def cmd_subset(
        self,
        tgt,
        fun,
        arg=(),
        timeout=None,
        tgt_type=&quot;glob&quot;,
        ret=&quot;&quot;,
        kwarg=None,
        subset=3,
        **kwargs
    ):
        &quot;&quot;&quot;
        Execute a command on a random subset of the targeted systems

        The function signature is the same as :py:meth:`cmd` with the
        following exceptions.

        :param subset: The number of systems to execute on

        .. code-block:: python

            &gt;&gt;&gt; import salt.client.ssh.client
            &gt;&gt;&gt; sshclient= salt.client.ssh.client.SSHClient()
            &gt;&gt;&gt; sshclient.cmd_subset('*', 'test.ping', subset=1)
            {'jerry': True}

        .. versionadded:: 2017.7.0
        &quot;&quot;&quot;
        minion_ret = self.cmd(tgt, &quot;sys.list_functions&quot;, tgt_type=tgt_type, **kwargs)
        minions = list(minion_ret)
        random.shuffle(minions)
        f_tgt = []
        for minion in minions:
            if fun in minion_ret[minion][&quot;return&quot;]:
                f_tgt.append(minion)
            if len(f_tgt) &gt;= subset:
                break
        return self.cmd_iter(
            f_tgt, fun, arg, timeout, tgt_type=&quot;list&quot;, ret=ret, kwarg=kwarg, **kwargs
        )

    def destroy(self):
        &quot;&quot;&quot;
        API compatibility method with salt.client.LocalClient
        &quot;&quot;&quot;

    def __enter__(self):
        &quot;&quot;&quot;
        API compatibility method with salt.client.LocalClient
        &quot;&quot;&quot;
        return self

    def __exit__(self, *args):
        &quot;&quot;&quot;
        API compatibility method with salt.client.LocalClient
        &quot;&quot;&quot;
        self.destroy()
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>version.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Set up the version of Salt
&quot;&quot;&quot;

import operator
import platform
import re
import sys
from collections import namedtuple
from functools import total_ordering

MAX_SIZE = sys.maxsize
VERSION_LIMIT = MAX_SIZE - 200

# ----- ATTENTION ---------------------------------------------------------------------------------------------------&gt;
#
# ALL major version bumps, new release codenames, MUST be defined in the SaltStackVersion.NAMES dictionary, i.e.:
#
#    class SaltStackVersion:
#
#        NAMES = {
#            'Hydrogen': (2014, 1),   # &lt;- This is the tuple to bump versions
#            ( ... )
#        }
#
#
# ONLY UPDATE CODENAMES AFTER BRANCHING
#
# As an example, The Helium codename must only be properly defined with &quot;(2014, 7)&quot; after Hydrogen, &quot;(2014, 1)&quot;, has
# been branched out into its own branch.
#
# ALL OTHER VERSION INFORMATION IS EXTRACTED FROM THE GIT TAGS
#
# &lt;---- ATTENTION ----------------------------------------------------------------------------------------------------


@total_ordering
class SaltVersion(namedtuple(&quot;SaltVersion&quot;, &quot;name, info, released&quot;)):
    __slots__ = ()

    def __new__(cls, name, info, released=False):
        if isinstance(info, int):
            info = (info,)
        return super().__new__(cls, name, info, released)

    def __eq__(self, other):
        return self.info == other.info

    def __gt__(self, other):
        return self.info &gt; other.info


class SaltVersionsInfo(type):

    _sorted_versions = ()
    _current_release = None
    _previous_release = None
    _next_release = None

    # pylint: disable=bad-whitespace,multiple-spaces-before-operator
    # ----- Please refrain from fixing whitespace ----------------------------------&gt;
    # The idea is to keep this readable.
    # -------------------------------------------------------------------------------
    # fmt: off
    HYDROGEN      = SaltVersion(&quot;Hydrogen&quot;     , info=(2014, 1),  released=True)
    HELIUM        = SaltVersion(&quot;Helium&quot;       , info=(2014, 7),  released=True)
    LITHIUM       = SaltVersion(&quot;Lithium&quot;      , info=(2015, 5),  released=True)
    BERYLLIUM     = SaltVersion(&quot;Beryllium&quot;    , info=(2015, 8),  released=True)
    BORON         = SaltVersion(&quot;Boron&quot;        , info=(2016, 3),  released=True)
    CARBON        = SaltVersion(&quot;Carbon&quot;       , info=(2016, 11), released=True)
    NITROGEN      = SaltVersion(&quot;Nitrogen&quot;     , info=(2017, 7),  released=True)
    OXYGEN        = SaltVersion(&quot;Oxygen&quot;       , info=(2018, 3),  released=True)
    FLUORINE      = SaltVersion(&quot;Fluorine&quot;     , info=(2019, 2),  released=True)
    NEON          = SaltVersion(&quot;Neon&quot;         , info=3000,       released=True)
    SODIUM        = SaltVersion(&quot;Sodium&quot;       , info=3001,       released=True)
    MAGNESIUM     = SaltVersion(&quot;Magnesium&quot;    , info=3002,       released=True)
    ALUMINIUM     = SaltVersion(&quot;Aluminium&quot;    , info=3003,       released=True)
    SILICON       = SaltVersion(&quot;Silicon&quot;      , info=3004,       released=True)
    PHOSPHORUS    = SaltVersion(&quot;Phosphorus&quot;   , info=3005)
    SULFUR        = SaltVersion(&quot;Sulfur&quot;       , info=3006)
    CHLORINE      = SaltVersion(&quot;Chlorine&quot;     , info=3007)
    ARGON         = SaltVersion(&quot;Argon&quot;        , info=3008)
    POTASSIUM     = SaltVersion(&quot;Potassium&quot;    , info=3009)
    CALCIUM       = SaltVersion(&quot;Calcium&quot;      , info=3010)
    SCANDIUM      = SaltVersion(&quot;Scandium&quot;     , info=3011)
    TITANIUM      = SaltVersion(&quot;Titanium&quot;     , info=3012)
    VANADIUM      = SaltVersion(&quot;Vanadium&quot;     , info=3013)
    CHROMIUM      = SaltVersion(&quot;Chromium&quot;     , info=3014)
    MANGANESE     = SaltVersion(&quot;Manganese&quot;    , info=3015)
    IRON          = SaltVersion(&quot;Iron&quot;         , info=3016)
    COBALT        = SaltVersion(&quot;Cobalt&quot;       , info=3017)
    NICKEL        = SaltVersion(&quot;Nickel&quot;       , info=3018)
    COPPER        = SaltVersion(&quot;Copper&quot;       , info=3019)
    ZINC          = SaltVersion(&quot;Zinc&quot;         , info=3020)
    GALLIUM       = SaltVersion(&quot;Gallium&quot;      , info=3021)
    GERMANIUM     = SaltVersion(&quot;Germanium&quot;    , info=3022)
    ARSENIC       = SaltVersion(&quot;Arsenic&quot;      , info=3023)
    SELENIUM      = SaltVersion(&quot;Selenium&quot;     , info=3024)
    BROMINE       = SaltVersion(&quot;Bromine&quot;      , info=3025)
    KRYPTON       = SaltVersion(&quot;Krypton&quot;      , info=3026)
    RUBIDIUM      = SaltVersion(&quot;Rubidium&quot;     , info=3027)
    STRONTIUM     = SaltVersion(&quot;Strontium&quot;    , info=3028)
    YTTRIUM       = SaltVersion(&quot;Yttrium&quot;      , info=3029)
    ZIRCONIUM     = SaltVersion(&quot;Zirconium&quot;    , info=3030)
    NIOBIUM       = SaltVersion(&quot;Niobium&quot;      , info=3031)
    MOLYBDENUM    = SaltVersion(&quot;Molybdenum&quot;   , info=3032)
    TECHNETIUM    = SaltVersion(&quot;Technetium&quot;   , info=3033)
    RUTHENIUM     = SaltVersion(&quot;Ruthenium&quot;    , info=3034)
    RHODIUM       = SaltVersion(&quot;Rhodium&quot;      , info=3035)
    PALLADIUM     = SaltVersion(&quot;Palladium&quot;    , info=3036)
    SILVER        = SaltVersion(&quot;Silver&quot;       , info=3037)
    CADMIUM       = SaltVersion(&quot;Cadmium&quot;      , info=3038)
    INDIUM        = SaltVersion(&quot;Indium&quot;       , info=3039)
    TIN           = SaltVersion(&quot;Tin&quot;          , info=3040)
    ANTIMONY      = SaltVersion(&quot;Antimony&quot;     , info=3041)
    TELLURIUM     = SaltVersion(&quot;Tellurium&quot;    , info=3042)
    IODINE        = SaltVersion(&quot;Iodine&quot;       , info=3043)
    XENON         = SaltVersion(&quot;Xenon&quot;        , info=3044)
    CESIUM        = SaltVersion(&quot;Cesium&quot;       , info=3045)
    BARIUM        = SaltVersion(&quot;Barium&quot;       , info=3046)
    LANTHANUM     = SaltVersion(&quot;Lanthanum&quot;    , info=3047)
    CERIUM        = SaltVersion(&quot;Cerium&quot;       , info=3048)
    PRASEODYMIUM  = SaltVersion(&quot;Praseodymium&quot; , info=3049)
    NEODYMIUM     = SaltVersion(&quot;Neodymium&quot;    , info=3050)
    PROMETHIUM    = SaltVersion(&quot;Promethium&quot;   , info=3051)
    SAMARIUM      = SaltVersion(&quot;Samarium&quot;     , info=3052)
    EUROPIUM      = SaltVersion(&quot;Europium&quot;     , info=3053)
    GADOLINIUM    = SaltVersion(&quot;Gadolinium&quot;   , info=3054)
    TERBIUM       = SaltVersion(&quot;Terbium&quot;      , info=3055)
    DYSPROSIUM    = SaltVersion(&quot;Dysprosium&quot;   , info=3056)
    HOLMIUM       = SaltVersion(&quot;Holmium&quot;      , info=3057)
    ERBIUM        = SaltVersion(&quot;Erbium&quot;       , info=3058)
    THULIUM       = SaltVersion(&quot;Thulium&quot;      , info=3059)
    YTTERBIUM     = SaltVersion(&quot;Ytterbium&quot;    , info=3060)
    LUTETIUM      = SaltVersion(&quot;Lutetium&quot;     , info=3061)
    HAFNIUM       = SaltVersion(&quot;Hafnium&quot;      , info=3062)
    TANTALUM      = SaltVersion(&quot;Tantalum&quot;     , info=3063)
    TUNGSTEN      = SaltVersion(&quot;Tungsten&quot;     , info=3064)
    RHENIUM       = SaltVersion(&quot;Rhenium&quot;      , info=3065)
    OSMIUM        = SaltVersion(&quot;Osmium&quot;       , info=3066)
    IRIDIUM       = SaltVersion(&quot;Iridium&quot;      , info=3067)
    PLATINUM      = SaltVersion(&quot;Platinum&quot;     , info=3068)
    GOLD          = SaltVersion(&quot;Gold&quot;         , info=3069)
    MERCURY       = SaltVersion(&quot;Mercury&quot;      , info=3070)
    THALLIUM      = SaltVersion(&quot;Thallium&quot;     , info=3071)
    LEAD          = SaltVersion(&quot;Lead&quot;         , info=3072)
    BISMUTH       = SaltVersion(&quot;Bismuth&quot;      , info=3073)
    POLONIUM      = SaltVersion(&quot;Polonium&quot;     , info=3074)
    ASTATINE      = SaltVersion(&quot;Astatine&quot;     , info=3075)
    RADON         = SaltVersion(&quot;Radon&quot;        , info=3076)
    FRANCIUM      = SaltVersion(&quot;Francium&quot;     , info=3077)
    RADIUM        = SaltVersion(&quot;Radium&quot;       , info=3078)
    ACTINIUM      = SaltVersion(&quot;Actinium&quot;     , info=3079)
    THORIUM       = SaltVersion(&quot;Thorium&quot;      , info=3080)
    PROTACTINIUM  = SaltVersion(&quot;Protactinium&quot; , info=3081)
    URANIUM       = SaltVersion(&quot;Uranium&quot;      , info=3082)
    NEPTUNIUM     = SaltVersion(&quot;Neptunium&quot;    , info=3083)
    PLUTONIUM     = SaltVersion(&quot;Plutonium&quot;    , info=3084)
    AMERICIUM     = SaltVersion(&quot;Americium&quot;    , info=3085)
    CURIUM        = SaltVersion(&quot;Curium&quot;       , info=3086)
    BERKELIUM     = SaltVersion(&quot;Berkelium&quot;    , info=3087)
    CALIFORNIUM   = SaltVersion(&quot;Californium&quot;  , info=3088)
    EINSTEINIUM   = SaltVersion(&quot;Einsteinium&quot;  , info=3089)
    FERMIUM       = SaltVersion(&quot;Fermium&quot;      , info=3090)
    MENDELEVIUM   = SaltVersion(&quot;Mendelevium&quot;  , info=3091)
    NOBELIUM      = SaltVersion(&quot;Nobelium&quot;     , info=3092)
    LAWRENCIUM    = SaltVersion(&quot;Lawrencium&quot;   , info=3093)
    RUTHERFORDIUM = SaltVersion(&quot;Rutherfordium&quot;, info=3094)
    DUBNIUM       = SaltVersion(&quot;Dubnium&quot;      , info=3095)
    SEABORGIUM    = SaltVersion(&quot;Seaborgium&quot;   , info=3096)
    BOHRIUM       = SaltVersion(&quot;Bohrium&quot;      , info=3097)
    HASSIUM       = SaltVersion(&quot;Hassium&quot;      , info=3098)
    MEITNERIUM    = SaltVersion(&quot;Meitnerium&quot;   , info=3099)
    DARMSTADTIUM  = SaltVersion(&quot;Darmstadtium&quot; , info=3100)
    ROENTGENIUM   = SaltVersion(&quot;Roentgenium&quot;  , info=3101)
    COPERNICIUM   = SaltVersion(&quot;Copernicium&quot;  , info=3102)
    NIHONIUM      = SaltVersion(&quot;Nihonium&quot;     , info=3103)
    FLEROVIUM     = SaltVersion(&quot;Flerovium&quot;    , info=3104)
    MOSCOVIUM     = SaltVersion(&quot;Moscovium&quot;    , info=3105)
    LIVERMORIUM   = SaltVersion(&quot;Livermorium&quot;  , info=3106)
    TENNESSINE    = SaltVersion(&quot;Tennessine&quot;   , info=3107)
    OGANESSON     = SaltVersion(&quot;Oganesson&quot;    , info=3108)
    # &lt;---- Please refrain from fixing whitespace -----------------------------------
    # The idea is to keep this readable.
    # -------------------------------------------------------------------------------
    # pylint: enable=bad-whitespace,multiple-spaces-before-operator
    # fmt: on

    @classmethod
    def versions(cls):
        if not cls._sorted_versions:
            cls._sorted_versions = sorted(
                (getattr(cls, name) for name in dir(cls) if name.isupper()),
                key=operator.attrgetter(&quot;info&quot;),
            )
        return cls._sorted_versions

    @classmethod
    def current_release(cls):
        if cls._current_release is None:
            for version in cls.versions():
                if version.released is False:
                    cls._current_release = version
                    break
        return cls._current_release

    @classmethod
    def next_release(cls):
        if cls._next_release is None:
            next_release_ahead = False
            for version in cls.versions():
                if next_release_ahead:
                    cls._next_release = version
                    break
                if version == cls.current_release():
                    next_release_ahead = True
        return cls._next_release

    @classmethod
    def previous_release(cls):
        if cls._previous_release is None:
            previous = None
            for version in cls.versions():
                if version == cls.current_release():
                    break
                previous = version
            cls._previous_release = previous
        return cls._previous_release


class SaltStackVersion:
    &quot;&quot;&quot;
    Handle SaltStack versions class.

    Knows how to parse ``git describe`` output, knows about release candidates
    and also supports version comparison.
    &quot;&quot;&quot;

    __slots__ = (
        &quot;name&quot;,
        &quot;major&quot;,
        &quot;minor&quot;,
        &quot;bugfix&quot;,
        &quot;mbugfix&quot;,
        &quot;pre_type&quot;,
        &quot;pre_num&quot;,
        &quot;noc&quot;,
        &quot;sha&quot;,
    )

    git_sha_regex = r&quot;(?P&lt;sha&gt;g?[a-f0-9]{7,40})&quot;

    git_describe_regex = re.compile(
        r&quot;(?:[^\d]+)?(?P&lt;major&gt;[\d]{1,4})&quot;
        r&quot;(?:\.(?P&lt;minor&gt;[\d]{1,2}))?&quot;
        r&quot;(?:\.(?P&lt;bugfix&gt;[\d]{0,2}))?&quot;
        r&quot;(?:\.(?P&lt;mbugfix&gt;[\d]{0,2}))?&quot;
        r&quot;(?:(?P&lt;pre_type&gt;rc|a|b|alpha|beta|nb)(?P&lt;pre_num&gt;[\d]+))?&quot;
        r&quot;(?:(?:.*)(?:\+|-)(?P&lt;noc&gt;(?:0na|[\d]+|n/a))(?:-|\.)&quot; + git_sha_regex + r&quot;)?&quot;
    )
    git_sha_regex = r&quot;^&quot; + git_sha_regex

    git_sha_regex = re.compile(git_sha_regex)

    NAMES = {v.name: v.info for v in SaltVersionsInfo.versions()}
    LNAMES = {k.lower(): v for (k, v) in iter(NAMES.items())}
    VNAMES = {v: k for (k, v) in iter(NAMES.items())}
    RMATCH = {v[:2]: k for (k, v) in iter(NAMES.items())}

    def __init__(
        self,  # pylint: disable=C0103
        major,
        minor=None,
        bugfix=None,
        mbugfix=0,
        pre_type=None,
        pre_num=None,
        noc=0,
        sha=None,
    ):

        if isinstance(major, str):
            major = int(major)

        if isinstance(minor, str):
            if not minor:
                # Empty string
                minor = None
            else:
                minor = int(minor)

        if bugfix is None and not self.new_version(major=major):
            bugfix = 0
        elif isinstance(bugfix, str):
            if not bugfix:
                bugfix = None
            else:
                bugfix = int(bugfix)

        if mbugfix is None:
            mbugfix = 0
        elif isinstance(mbugfix, str):
            mbugfix = int(mbugfix)

        if pre_type is None:
            pre_type = &quot;&quot;
        if pre_num is None:
            pre_num = 0
        elif isinstance(pre_num, str):
            pre_num = int(pre_num)

        if noc is None:
            noc = 0
        elif isinstance(noc, str) and noc in (&quot;0na&quot;, &quot;n/a&quot;):
            noc = -1
        elif isinstance(noc, str):
            noc = int(noc)

        self.major = major
        self.minor = minor
        self.bugfix = bugfix
        self.mbugfix = mbugfix
        self.pre_type = pre_type
        self.pre_num = pre_num
        if self.new_version(major):
            vnames_key = (major,)
        else:
            vnames_key = (major, minor)
        self.name = self.VNAMES.get(vnames_key)
        self.noc = noc
        self.sha = sha

    def new_version(self, major):
        &quot;&quot;&quot;
        determine if using new versioning scheme
        &quot;&quot;&quot;
        return bool(int(major) &gt;= 3000 and int(major) &lt; VERSION_LIMIT)

    @classmethod
    def parse(cls, version_string):
        if version_string.lower() in cls.LNAMES:
            return cls.from_name(version_string)
        vstr = (
            version_string.decode()
            if isinstance(version_string, bytes)
            else version_string
        )
        match = cls.git_describe_regex.match(vstr)
        if not match:
            raise ValueError(
                &quot;Unable to parse version string: '{}'&quot;.format(version_string)
            )
        return cls(*match.groups())

    @classmethod
    def from_name(cls, name):
        if name.lower() not in cls.LNAMES:
            raise ValueError(&quot;Named version '{}' is not known&quot;.format(name))
        return cls(*cls.LNAMES[name.lower()])

    @classmethod
    def from_last_named_version(cls):
        import salt.utils.versions

        salt.utils.versions.warn_until(
            SaltVersionsInfo.SULFUR,
            &quot;The use of SaltStackVersion.from_last_named_version() is &quot;
            &quot;deprecated and set to be removed in {version}. Please use &quot;
            &quot;SaltStackVersion.current_release() instead.&quot;,
        )
        return cls.current_release()

    @classmethod
    def current_release(cls):
        return cls(*SaltVersionsInfo.current_release().info)

    @classmethod
    def next_release(cls):
        return cls(*SaltVersionsInfo.next_release().info)

    @property
    def sse(self):
        # Higher than 0.17, lower than first date based
        return 0 &lt; self.major &lt; 2014

    def min_info(self):
        info = [self.major]
        if self.new_version(self.major):
            if self.minor:
                info.append(self.minor)
        else:
            info.extend([self.minor, self.bugfix, self.mbugfix])
        return info

    @property
    def info(self):
        return tuple(self.min_info())

    @property
    def pre_info(self):
        info = self.min_info()
        info.extend([self.pre_type, self.pre_num])
        return tuple(info)

    @property
    def noc_info(self):
        info = self.min_info()
        info.extend([self.pre_type, self.pre_num, self.noc])
        return tuple(info)

    @property
    def full_info(self):
        info = self.min_info()
        info.extend([self.pre_type, self.pre_num, self.noc, self.sha])
        return tuple(info)

    @property
    def full_info_all_versions(self):
        &quot;&quot;&quot;
        Return the full info regardless
        of which versioning scheme we
        are using.
        &quot;&quot;&quot;
        info = [
            self.major,
            self.minor,
            self.bugfix,
            self.mbugfix,
            self.pre_type,
            self.pre_num,
            self.noc,
            self.sha,
        ]
        return tuple(info)

    @property
    def string(self):
        if self.new_version(self.major):
            version_string = &quot;{}&quot;.format(self.major)
            if self.minor:
                version_string = &quot;{}.{}&quot;.format(self.major, self.minor)
        else:
            version_string = &quot;{}.{}.{}&quot;.format(self.major, self.minor, self.bugfix)
        if self.mbugfix:
            version_string += &quot;.{}&quot;.format(self.mbugfix)
        if self.pre_type:
            version_string += &quot;{}{}&quot;.format(self.pre_type, self.pre_num)
        if self.noc and self.sha:
            noc = self.noc
            if noc &lt; 0:
                noc = &quot;0na&quot;
            version_string += &quot;+{}.{}&quot;.format(noc, self.sha)
        return version_string

    @property
    def formatted_version(self):
        if self.name and self.major &gt; 10000:
            version_string = self.name
            if self.sse:
                version_string += &quot; Enterprise&quot;
            version_string += &quot; (Unreleased)&quot;
            return version_string
        version_string = self.string
        if self.sse:
            version_string += &quot; Enterprise&quot;
        if (self.major, self.minor) in self.RMATCH:
            version_string += &quot; ({})&quot;.format(self.RMATCH[(self.major, self.minor)])
        return version_string

    @property
    def pre_index(self):
        if self.new_version(self.major):
            pre_type = 2
            if not isinstance(self.minor, int):
                pre_type = 1
        else:
            pre_type = 4
        return pre_type

    def __str__(self):
        return self.string

    def __compare__(self, other, method):
        if not isinstance(other, SaltStackVersion):
            if isinstance(other, str):
                other = SaltStackVersion.parse(other)
            elif isinstance(other, (list, tuple)):
                other = SaltStackVersion(*other)
            else:
                raise ValueError(
                    &quot;Cannot instantiate Version from type '{}'&quot;.format(type(other))
                )

        pre_type = self.pre_index
        other_pre_type = other.pre_index
        other_noc_info = list(other.noc_info)
        noc_info = list(self.noc_info)

        if self.new_version(self.major):
            if self.minor and not other.minor:
                # We have minor information, the other side does not
                if self.minor &gt; 0:
                    other_noc_info[1] = 0

            if not self.minor and other.minor:
                # The other side has minor information, we don't
                if other.minor &gt; 0:
                    noc_info[1] = 0

        if self.pre_type and not other.pre_type:
            # We have pre-release information, the other side doesn't
            other_noc_info[other_pre_type] = &quot;zzzzz&quot;

        if not self.pre_type and other.pre_type:
            # The other side has pre-release information, we don't
            noc_info[pre_type] = &quot;zzzzz&quot;

        return method(tuple(noc_info), tuple(other_noc_info))

    def __lt__(self, other):
        return self.__compare__(other, lambda _self, _other: _self &lt; _other)

    def __le__(self, other):
        return self.__compare__(other, lambda _self, _other: _self &lt;= _other)

    def __eq__(self, other):
        return self.__compare__(other, lambda _self, _other: _self == _other)

    def __ne__(self, other):
        return self.__compare__(other, lambda _self, _other: _self != _other)

    def __ge__(self, other):
        return self.__compare__(other, lambda _self, _other: _self &gt;= _other)

    def __gt__(self, other):
        return self.__compare__(other, lambda _self, _other: _self &gt; _other)

    def __repr__(self):
        parts = []
        if self.name:
            parts.append(&quot;name='{}'&quot;.format(self.name))
        parts.extend([&quot;major={}&quot;.format(self.major), &quot;minor={}&quot;.format(self.minor)])

        if self.new_version(self.major):
            if not self.minor:
                parts.remove(&quot;&quot;.join([x for x in parts if re.search(&quot;^minor*&quot;, x)]))
        else:
            parts.extend([&quot;bugfix={}&quot;.format(self.bugfix)])

        if self.mbugfix:
            parts.append(&quot;minor-bugfix={}&quot;.format(self.mbugfix))
        if self.pre_type:
            parts.append(&quot;{}={}&quot;.format(self.pre_type, self.pre_num))
        noc = self.noc
        if noc == -1:
            noc = &quot;0na&quot;
        if noc and self.sha:
            parts.extend([&quot;noc={}&quot;.format(noc), &quot;sha={}&quot;.format(self.sha)])
        return &quot;&lt;{} {}&gt;&quot;.format(self.__class__.__name__, &quot; &quot;.join(parts))


# ----- Hardcoded Salt Codename Version Information -----------------------------------------------------------------&gt;
#
#   There's no need to do anything here. The last released codename will be picked up
# --------------------------------------------------------------------------------------------------------------------
__saltstack_version__ = SaltStackVersion.current_release()
# &lt;---- Hardcoded Salt Version Information ---------------------------------------------------------------------------


# ----- Dynamic/Runtime Salt Version Information --------------------------------------------------------------------&gt;
def __discover_version(saltstack_version):
    # This might be a 'python setup.py develop' installation type. Let's
    # discover the version information at runtime.
    import os
    import subprocess

    if &quot;SETUP_DIRNAME&quot; in globals():
        # This is from the exec() call in Salt's setup.py
        cwd = SETUP_DIRNAME  # pylint: disable=E0602
        if not os.path.exists(os.path.join(cwd, &quot;.git&quot;)):
            # This is not a Salt git checkout!!! Don't even try to parse...
            return saltstack_version
    else:
        cwd = os.path.abspath(os.path.dirname(__file__))
        if not os.path.exists(os.path.join(os.path.dirname(cwd), &quot;.git&quot;)):
            # This is not a Salt git checkout!!! Don't even try to parse...
            return saltstack_version

    try:
        kwargs = dict(stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=cwd)

        if not sys.platform.startswith(&quot;win&quot;):
            # Let's not import `salt.utils` for the above check
            kwargs[&quot;close_fds&quot;] = True

        process = subprocess.Popen(
            [
                &quot;git&quot;,
                &quot;describe&quot;,
                &quot;--tags&quot;,
                &quot;--long&quot;,
                &quot;--match&quot;,
                &quot;v[0-9]*&quot;,
                &quot;--always&quot;,
            ],
            **kwargs
        )

        out, err = process.communicate()

        out = out.decode().strip()
        err = err.decode().strip()

        if not out or err:
            return saltstack_version

        if SaltStackVersion.git_sha_regex.match(out):
            # We only define the parsed SHA and set NOC as ??? (unknown)
            saltstack_version.sha = out.strip()
            saltstack_version.noc = -1
            return saltstack_version

        return SaltStackVersion.parse(out)

    except OSError as os_err:
        if os_err.errno != 2:
            # If the errno is not 2(The system cannot find the file
            # specified), raise the exception so it can be catch by the
            # developers
            raise
    return saltstack_version


def __get_version(saltstack_version):
    &quot;&quot;&quot;
    If we can get a version provided at installation time or from Git, use
    that instead, otherwise we carry on.
    &quot;&quot;&quot;
    try:
        # Try to import the version information provided at install time
        from salt._version import __saltstack_version__  # pylint: disable=E0611,F0401

        return __saltstack_version__
    except ImportError:
        return __discover_version(saltstack_version)


# Get additional version information if available
__saltstack_version__ = __get_version(__saltstack_version__)
if __saltstack_version__.name:
    # Set SaltVersionsInfo._current_release to avoid lookups when finding previous and next releases
    SaltVersionsInfo._current_release = getattr(
        SaltVersionsInfo, __saltstack_version__.name.upper()
    )

# This function has executed once, we're done with it. Delete it!
del __get_version
# &lt;---- Dynamic/Runtime Salt Version Information ---------------------------------------------------------------------


# ----- Common version related attributes - NO NEED TO CHANGE -------------------------------------------------------&gt;
__version_info__ = __saltstack_version__.info
__version__ = __saltstack_version__.string
# &lt;---- Common version related attributes - NO NEED TO CHANGE --------------------------------------------------------


def salt_information():
    &quot;&quot;&quot;
    Report version of salt.
    &quot;&quot;&quot;
    yield &quot;Salt&quot;, __version__


def dependency_information(include_salt_cloud=False):
    &quot;&quot;&quot;
    Report versions of library dependencies.
<A NAME="0"></A>    &quot;&quot;&quot;
    libs = [
        (&quot;Python&quot;, None, sys.version.rsplit(&quot;\n&quot;)[0].strip()),
        (<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match134580-0.html#0',2,'match134580-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>&quot;Jinja2&quot;, &quot;jinja2&quot;, &quot;__version__&quot;),
        (&quot;M2Crypto&quot;, &quot;M2Crypto&quot;, &quot;version&quot;),
        (&quot;msgpack&quot;, &quot;msgpack&quot;, &quot;version&quot;),
        (&quot;msgpack-pure&quot;, &quot;msgpack_pure&quot;, &quot;version&quot;),
        (&quot;pycrypto&quot;, &quot;Crypto&quot;, &quot;__version__&quot;),
        (&quot;pycryptodome&quot;, &quot;Cryptodome&quot;, &quot;version_info&quot;),
        (&quot;PyYAML&quot;, &quot;yaml&quot;, &quot;__version__&quot;),
        (&quot;PyZMQ&quot;, &quot;zmq&quot;, &quot;__version__&quot;),
        (&quot;ZMQ&quot;, &quot;zmq&quot;, &quot;zmq_version&quot;),
        (&quot;Mako&quot;, &quot;mako&quot;, &quot;__version__&quot;),
        (&quot;Tornado&quot;, &quot;tornado&quot;, &quot;version&quot;),
        (&quot;timelib&quot;, &quot;timelib&quot;, &quot;version&quot;),
        (&quot;dateutil&quot;, &quot;dateutil&quot;, &quot;__version__&quot;),
        (&quot;pygit2&quot;, &quot;pygit2&quot;, &quot;__version__&quot;),
        (&quot;libgit2&quot;, &quot;pygit2&quot;, &quot;LIBGIT2_VERSION&quot;),
        (&quot;smmap&quot;, &quot;smmap&quot;, &quot;__version__&quot;),
        (&quot;cffi&quot;, &quot;cffi&quot;, &quot;__version__&quot;),
        (&quot;pycparser&quot;, &quot;pycparser&quot;, &quot;__version__&quot;),
        (&quot;gitdb&quot;, &quot;gitdb&quot;, &quot;__version__&quot;),
        (&quot;gitpython&quot;, &quot;git&quot;, &quot;__version__&quot;),
        (&quot;python-gnupg&quot;, &quot;gnupg&quot;, &quot;__version__&quot;),
        (&quot;mysql-python&quot;, &quot;MySQLdb&quot;, &quot;__version__&quot;),
        (&quot;cherrypy&quot;, &quot;cherrypy&quot;, &quot;__version__&quot;),
        (&quot;docker-py&quot;</B></FONT>, &quot;docker&quot;, &quot;__version__&quot;),
    ]

    if include_salt_cloud:
        libs.append(
            (&quot;Apache Libcloud&quot;, &quot;libcloud&quot;, &quot;__version__&quot;),
        )

    for name, imp, attr in libs:
        if imp is None:
            yield name, attr
            continue
        try:
            imp = __import__(imp)
            version = getattr(imp, attr)
            if callable(version):
                version = version()
            if isinstance(version, (tuple, list)):
                version = &quot;.&quot;.join(map(str, version))
            yield name, version
        except Exception:  # pylint: disable=broad-except
            yield name, None


def system_information():
    &quot;&quot;&quot;
    Report system versions.
    &quot;&quot;&quot;
    # Late import so that when getting called from setup.py does not break
    from distro import linux_distribution

    def system_version():
        &quot;&quot;&quot;
        Return host system version.
        &quot;&quot;&quot;

        lin_ver = linux_distribution()
        mac_ver = platform.mac_ver()
        win_ver = platform.win32_ver()

        # linux_distribution() will return a
        # distribution on OS X and Windows.
        # Check mac_ver and win_ver first,
        # then lin_ver.
        if mac_ver[0]:
            if isinstance(mac_ver[1], (tuple, list)) and &quot;&quot;.join(mac_ver[1]):
                return &quot; &quot;.join([mac_ver[0], &quot;.&quot;.join(mac_ver[1]), mac_ver[2]])
            else:
                return &quot; &quot;.join([mac_ver[0], mac_ver[2]])
        elif win_ver[0]:
            return &quot; &quot;.join(win_ver)
        elif lin_ver[0]:
            return &quot; &quot;.join(lin_ver)
        else:
            return &quot;&quot;

    if platform.win32_ver()[0]:
        # Get the version and release info based on the Windows Operating
        # System Product Name. As long as Microsoft maintains a similar format
        # this should be future proof
        import win32api  # pylint: disable=3rd-party-module-not-gated
        import win32con  # pylint: disable=3rd-party-module-not-gated

        # Get the product name from the registry
        hkey = win32con.HKEY_LOCAL_MACHINE
        key = &quot;SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion&quot;
        value_name = &quot;ProductName&quot;
        reg_handle = win32api.RegOpenKey(hkey, key)

        # Returns a tuple of (product_name, value_type)
        product_name, _ = win32api.RegQueryValueEx(reg_handle, value_name)

        version = &quot;Unknown&quot;
        release = &quot;&quot;
        if &quot;Server&quot; in product_name:
            for item in product_name.split(&quot; &quot;):
                # If it's all digits, then it's version
                if re.match(r&quot;\d+&quot;, item):
                    version = item
                # If it starts with R and then numbers, it's the release
                # ie: R2
                if re.match(r&quot;^R\d+$&quot;, item):
                    release = item
            release = &quot;{}Server{}&quot;.format(version, release)
        else:
            for item in product_name.split(&quot; &quot;):
                # If it's a number, decimal number, Thin or Vista, then it's the
                # version
                if re.match(r&quot;^(\d+(\.\d+)?)|Thin|Vista$&quot;, item):
                    version = item
            release = version

        _, ver, service_pack, extra = platform.win32_ver()
        version = &quot; &quot;.join([release, ver, service_pack, extra])
    else:
        version = system_version()
        release = platform.release()

    system = [
        (&quot;system&quot;, platform.system()),
        (&quot;dist&quot;, &quot; &quot;.join(linux_distribution(full_distribution_name=False))),
        (&quot;release&quot;, release),
        (&quot;machine&quot;, platform.machine()),
        (&quot;version&quot;, version),
        (&quot;locale&quot;, __salt_system_encoding__),
    ]

    for name, attr in system:
        yield name, attr
        continue


def extensions_information():
    &quot;&quot;&quot;
    Gather infomation about any installed salt extensions
    &quot;&quot;&quot;
    # Late import
    import salt.utils.entrypoints

    extensions = {}
    for entry_point in salt.utils.entrypoints.iter_entry_points(&quot;salt.loader&quot;):
        dist_nv = salt.utils.entrypoints.name_and_version_from_entry_point(entry_point)
        if not dist_nv:
            continue
        if dist_nv.name in extensions:
            continue
        extensions[dist_nv.name] = dist_nv.version
    return extensions


def versions_information(include_salt_cloud=False, include_extensions=True):
    &quot;&quot;&quot;
    Report the versions of dependent software.
    &quot;&quot;&quot;
    salt_info = list(salt_information())
    lib_info = list(dependency_information(include_salt_cloud))
    sys_info = list(system_information())

    info = {
        &quot;Salt Version&quot;: dict(salt_info),
        &quot;Dependency Versions&quot;: dict(lib_info),
        &quot;System Versions&quot;: dict(sys_info),
    }
    if include_extensions:
        extensions_info = extensions_information()
        if extensions_info:
            info[&quot;Salt Extensions&quot;] = extensions_info
    return info


def versions_report(include_salt_cloud=False, include_extensions=True):
    &quot;&quot;&quot;
    Yield each version properly formatted for console output.
    &quot;&quot;&quot;
    ver_info = versions_information(
        include_salt_cloud=include_salt_cloud, include_extensions=include_extensions
    )
    not_installed = &quot;Not Installed&quot;
    ns_pad = len(not_installed)
    lib_pad = max(len(name) for name in ver_info[&quot;Dependency Versions&quot;])
    sys_pad = max(len(name) for name in ver_info[&quot;System Versions&quot;])
    if include_extensions and &quot;Salt Extensions&quot; in ver_info:
        ext_pad = max(len(name) for name in ver_info[&quot;Salt Extensions&quot;])
    else:
        ext_pad = 1
    padding = max(lib_pad, sys_pad, ns_pad, ext_pad) + 1

    fmt = &quot;{0:&gt;{pad}}: {1}&quot;
    info = []
    for ver_type in (
        &quot;Salt Version&quot;,
        &quot;Dependency Versions&quot;,
        &quot;Salt Extensions&quot;,
        &quot;System Versions&quot;,
    ):
        if ver_type == &quot;Salt Extensions&quot; and ver_type not in ver_info:
            # No salt Extensions to report
            continue
        info.append(&quot;{}:&quot;.format(ver_type))
        # List dependencies in alphabetical, case insensitive order
        for name in sorted(ver_info[ver_type], key=lambda x: x.lower()):
            ver = fmt.format(
                name, ver_info[ver_type][name] or not_installed, pad=padding
            )
            info.append(ver)
        info.append(&quot; &quot;)

    yield from info


if __name__ == &quot;__main__&quot;:
    print(__version__)
</PRE>
</div>
  </div>
</body>
</html>
