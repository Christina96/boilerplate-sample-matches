<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for aws.py &amp; jinja_3.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for aws.py &amp; jinja_3.py
      </h3>
<h1 align="center">
        2.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>aws.py (3.3377838%)<th>jinja_3.py (2.1349275%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(11-24)<td><a href="#" name="0">(6-18)</a><td align="center"><font color="#ff0000">13</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(166-172)<td><a href="#" name="1">(1138-1142)</a><td align="center"><font color="#eb0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>aws.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import binascii
import hashlib
import hmac
import logging
import random
import re
import time
import urllib.parse
import xml.etree.ElementTree as ET
from datetime import datetime
import salt.config
import salt.utils.hashutils
import</b></font> salt.utils.xmlutil as xml
try:
    import requests
    HAS_REQUESTS = True  # pylint: disable=W0612
except ImportError:
    HAS_REQUESTS = False  # pylint: disable=W0612
log = logging.getLogger(__name__)
DEFAULT_LOCATION = "us-east-1"
DEFAULT_AWS_API_VERSION = "2016-11-15"
AWS_RETRY_CODES = [
    "RequestLimitExceeded",
    "InsufficientInstanceCapacity",
    "InternalError",
    "Unavailable",
    "InsufficientAddressCapacity",
    "InsufficientReservedInstanceCapacity",
]
AWS_METADATA_TIMEOUT = 3.05
AWS_MAX_RETRIES = 7
IROLE_CODE = "use-instance-role-credentials"
__AccessKeyId__ = ""
__SecretAccessKey__ = ""
__Token__ = ""
__Expiration__ = ""
__Location__ = ""
__AssumeCache__ = {}
def sleep_exponential_backoff(attempts):
    time.sleep(random.uniform(1, 2 ** attempts))
def creds(provider):
    global __AccessKeyId__, __SecretAccessKey__, __Token__, __Expiration__
    ret_credentials = ()
    if provider["id"] == IROLE_CODE or provider["key"] == IROLE_CODE:
        if __Expiration__ != "":
            timenow = datetime.utcnow()
            timestamp = timenow.strftime("%Y-%m-%dT%H:%M:%SZ")
            if timestamp &lt; __Expiration__:
                return __AccessKeyId__, __SecretAccessKey__, __Token__
        try:
            result = requests.get(
                "http://169.254.169.254/latest/meta-data/iam/security-credentials/",
                proxies={"http": ""},
                timeout=AWS_METADATA_TIMEOUT,
            )
            result.raise_for_status()
            role = result.text
        except (requests.exceptions.HTTPError, requests.exceptions.ConnectionError):
            return provider["id"], provider["key"], ""
        try:
            result = requests.get(
                "http://169.254.169.254/latest/meta-data/iam/security-credentials/{}".format(
                    role
                ),
                proxies={"http": ""},
                timeout=AWS_METADATA_TIMEOUT,
            )
            result.raise_for_status()
        except (requests.exceptions.HTTPError, requests.exceptions.ConnectionError):
            return provider["id"], provider["key"], ""
        data = result.json()
        __AccessKeyId__ = data["AccessKeyId"]
        __SecretAccessKey__ = data["SecretAccessKey"]
        __Token__ = data["Token"]
        __Expiration__ = data["Expiration"]
        ret_credentials = __AccessKeyId__, __SecretAccessKey__, __Token__
    else:
        ret_credentials = provider["id"], provider["key"], ""
    if provider.get("role_arn") is not None:
        provider_shadow = provider.copy()
        provider_shadow.pop("role_arn", None)
        log.info("Assuming the role: %s", provider.get("role_arn"))
        ret_credentials = assumed_creds(
            provider_shadow, role_arn=provider.get("role_arn"), location="us-east-1"
        )
    return ret_credentials
def sig2(method, endpoint, params, provider, aws_api_version):
    timenow = datetime.utcnow()
    timestamp = timenow.strftime("%Y-%m-%dT%H:%M:%SZ")
    access_key_id, secret_access_key, token = creds(provider)
    params_with_headers = params.copy()
    params_with_headers["AWSAccessKeyId"] = access_key_id
    params_with_headers["SignatureVersion"] = "2"
    params_with_headers["SignatureMethod"] = "HmacSHA256"
    params_with_headers["Timestamp"] = "{}".format(timestamp)
    params_with_headers["Version"] = aws_api_version
    keys = sorted(params_with_headers.keys())
<a name="1"></a>    values = list(list(map(params_with_headers.get, keys)))
    querystring = urllib.parse.urlencode(list(zip(keys, values)))
    canonical = "{}\n{}\n/\n{}"<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.format(
        method.encode("utf-8"),
        endpoint.encode("utf-8"),
        querystring.encode("utf-8"),
    )
    hashed = hmac.new(secret_access_key, canonical, hashlib.</b></font>sha256)
    sig = binascii.b2a_base64(hashed.digest())
    params_with_headers["Signature"] = sig.strip()
    if token != "":
        params_with_headers["SecurityToken"] = token
    return params_with_headers
def assumed_creds(prov_dict, role_arn, location=None):
    valid_session_name_re = re.compile("[^a-z0-9A-Z+=,.@-]")
    now = time.mktime(datetime.utcnow().timetuple())
    for key, creds in __AssumeCache__.items():
        if (creds["Expiration"] - now) &lt;= 120:
            __AssumeCache__.delete(key)
    if role_arn in __AssumeCache__:
        c = __AssumeCache__[role_arn]
        return c["AccessKeyId"], c["SecretAccessKey"], c["SessionToken"]
    version = "2011-06-15"
    session_name = valid_session_name_re.sub(
        "", salt.config.get_id({"root_dir": None})[0]
    )[0:63]
    headers, requesturl = sig4(
        "GET",
        "sts.amazonaws.com",
        params={
            "Version": version,
            "Action": "AssumeRole",
            "RoleSessionName": session_name,
            "RoleArn": role_arn,
            "Policy": (
                '{"Version":"2012-10-17","Statement":[{"Sid":"Stmt1",'
                ' "Effect":"Allow","Action":"*","Resource":"*"}]}'
            ),
            "DurationSeconds": "3600",
        },
        aws_api_version=version,
        data="",
        uri="/",
        prov_dict=prov_dict,
        product="sts",
        location=location,
        requesturl="https://sts.amazonaws.com/",
    )
    headers["Accept"] = "application/json"
    result = requests.request("GET", requesturl, headers=headers, data="", verify=True)
    if result.status_code &gt;= 400:
        log.info("AssumeRole response: %s", result.content)
    result.raise_for_status()
    resp = result.json()
    data = resp["AssumeRoleResponse"]["AssumeRoleResult"]["Credentials"]
    __AssumeCache__[role_arn] = data
    return data["AccessKeyId"], data["SecretAccessKey"], data["SessionToken"]
def sig4(
    method,
    endpoint,
    params,
    prov_dict,
    aws_api_version=DEFAULT_AWS_API_VERSION,
    location=None,
    product="ec2",
    uri="/",
    requesturl=None,
    data="",
    headers=None,
    role_arn=None,
    payload_hash=None,
):
    timenow = datetime.utcnow()
    if role_arn is None:
        access_key_id, secret_access_key, token = creds(prov_dict)
    else:
        access_key_id, secret_access_key, token = assumed_creds(
            prov_dict, role_arn, location=location
        )
    if location is None:
        location = get_region_from_metadata()
    if location is None:
        location = DEFAULT_LOCATION
    params_with_headers = params.copy()
    if product not in ("s3", "ssm"):
        params_with_headers["Version"] = aws_api_version
    keys = sorted(params_with_headers.keys())
    values = list(map(params_with_headers.get, keys))
    querystring = urllib.parse.urlencode(list(zip(keys, values))).replace("+", "%20")
    amzdate = timenow.strftime("%Y%m%dT%H%M%SZ")
    datestamp = timenow.strftime("%Y%m%d")
    new_headers = {}
    if isinstance(headers, dict):
        new_headers = headers.copy()
    if not payload_hash:
        payload_hash = salt.utils.hashutils.sha256_digest(data)
    new_headers["X-Amz-date"] = amzdate
    new_headers["host"] = endpoint
    new_headers["x-amz-content-sha256"] = payload_hash
    a_canonical_headers = []
    a_signed_headers = []
    if token != "":
        new_headers["X-Amz-security-token"] = token
    for header in sorted(new_headers.keys(), key=str.lower):
        lower_header = header.lower()
        a_canonical_headers.append(
            "{}:{}".format(lower_header, new_headers[header].strip())
        )
        a_signed_headers.append(lower_header)
    canonical_headers = "\n".join(a_canonical_headers) + "\n"
    signed_headers = ";".join(a_signed_headers)
    algorithm = "AWS4-HMAC-SHA256"
    canonical_request = "\n".join(
        (method, uri, querystring, canonical_headers, signed_headers, payload_hash)
    )
    credential_scope = "/".join((datestamp, location, product, "aws4_request"))
    string_to_sign = "\n".join(
        (
            algorithm,
            amzdate,
            credential_scope,
            salt.utils.hashutils.sha256_digest(canonical_request),
        )
    )
    signing_key = _sig_key(secret_access_key, datestamp, location, product)
    signature = hmac.new(
        signing_key, string_to_sign.encode("utf-8"), hashlib.sha256
    ).hexdigest()
    authorization_header = "{} Credential={}/{}, SignedHeaders={}, Signature={}".format(
        algorithm,
        access_key_id,
        credential_scope,
        signed_headers,
        signature,
    )
    new_headers["Authorization"] = authorization_header
    requesturl = "{}?{}".format(requesturl, querystring)
    return new_headers, requesturl
def _sign(key, msg):
    return hmac.new(key, msg.encode("utf-8"), hashlib.sha256).digest()
def _sig_key(key, date_stamp, regionName, serviceName):
    kDate = _sign(("AWS4" + key).encode("utf-8"), date_stamp)
    if regionName:
        kRegion = _sign(kDate, regionName)
        kService = _sign(kRegion, serviceName)
    else:
        kService = _sign(kDate, serviceName)
    kSigning = _sign(kService, "aws4_request")
    return kSigning
def query(
    params=None,
    setname=None,
    requesturl=None,
    location=None,
    return_url=False,
    return_root=False,
    opts=None,
    provider=None,
    endpoint=None,
    product="ec2",
    sigver="2",
):
    if params is None:
        params = {}
    if opts is None:
        opts = {}
    function = opts.get("function", (None, product))
    providers = opts.get("providers", {})
    if provider is None:
        prov_dict = providers.get(function[1], {}).get(product, {})
        if prov_dict:
            driver = list(list(prov_dict.keys()))[0]
            provider = providers.get(driver, product)
    else:
        prov_dict = providers.get(provider, {}).get(product, {})
    service_url = prov_dict.get("service_url", "amazonaws.com")
    if not location:
        location = get_location(opts, prov_dict)
    if endpoint is None:
        if not requesturl:
            endpoint = prov_dict.get(
                "endpoint", "{}.{}.{}".format(product, location, service_url)
            )
            requesturl = "https://{}/".format(endpoint)
        else:
            endpoint = urllib.parse.urlparse(requesturl).netloc
            if endpoint == "":
                endpoint_err = (
                    "Could not find a valid endpoint in the "
                    "requesturl: {}. Looking for something "
                    "like https://some.aws.endpoint/?args".format(requesturl)
                )
                log.error(endpoint_err)
                if return_url is True:
                    return {"error": endpoint_err}, requesturl
                return {"error": endpoint_err}
    log.debug("Using AWS endpoint: %s", endpoint)
    method = "GET"
    aws_api_version = prov_dict.get(
        "aws_api_version",
        prov_dict.get("{}_api_version".format(product), DEFAULT_AWS_API_VERSION),
    )
    if not prov_dict.get("id", None):
        prov_dict["id"] = providers.get(provider, {}).get("ec2", {}).get("id", {})
        prov_dict["key"] = providers.get(provider, {}).get("ec2", {}).get("key", {})
    if sigver == "4":
        headers, requesturl = sig4(
            method,
            endpoint,
            params,
            prov_dict,
            aws_api_version,
            location,
            product,
            requesturl=requesturl,
        )
        params_with_headers = {}
    else:
        params_with_headers = sig2(method, endpoint, params, prov_dict, aws_api_version)
        headers = {}
    attempts = 0
    while attempts &lt; AWS_MAX_RETRIES:
        log.debug("AWS Request: %s", requesturl)
        log.trace("AWS Request Parameters: %s", params_with_headers)
        try:
            result = requests.get(
                requesturl, headers=headers, params=params_with_headers
            )
            log.debug("AWS Response Status Code: %s", result.status_code)
            log.trace("AWS Response Text: %s", result.text)
            result.raise_for_status()
            break
        except requests.exceptions.HTTPError as exc:
            root = ET.fromstring(exc.response.content)
            data = xml.to_dict(root)
            err_code = data.get("Errors", {}).get("Error", {}).get("Code", "")
            if attempts &lt; AWS_MAX_RETRIES and err_code and err_code in AWS_RETRY_CODES:
                attempts += 1
                log.error(
                    "AWS Response Status Code and Error: [%s %s] %s; "
                    "Attempts remaining: %s",
                    exc.response.status_code,
                    exc,
                    data,
                    attempts,
                )
                sleep_exponential_backoff(attempts)
                continue
            log.error(
                "AWS Response Status Code and Error: [%s %s] %s",
                exc.response.status_code,
                exc,
                data,
            )
            if return_url is True:
                return {"error": data}, requesturl
            return {"error": data}
    else:
        log.error(
            "AWS Response Status Code and Error: [%s %s] %s",
            exc.response.status_code,
            exc,
            data,
        )
        if return_url is True:
            return {"error": data}, requesturl
        return {"error": data}
    root = ET.fromstring(result.text)
    items = root[1]
    if return_root is True:
        items = root
    if setname:
        for idx, item in enumerate(root):
            comps = item.tag.split("}")
            if comps[1] == setname:
                items = root[idx]
    ret = []
    for item in items:
        ret.append(xml.to_dict(item))
    if return_url is True:
        return ret, requesturl
    return ret
def get_region_from_metadata():
    global __Location__
    if __Location__ == "do-not-get-from-metadata":
        log.debug(
            "Previously failed to get AWS region from metadata. Not trying again."
        )
        return None
    if __Location__ != "":
        return __Location__
    try:
        result = requests.get(
            "http://169.254.169.254/latest/dynamic/instance-identity/document",
            proxies={"http": ""},
            timeout=AWS_METADATA_TIMEOUT,
        )
    except requests.exceptions.RequestException:
        log.warning("Failed to get AWS region from instance metadata.", exc_info=True)
        __Location__ = "do-not-get-from-metadata"
        return None
    try:
        region = result.json()["region"]
        __Location__ = region
        return __Location__
    except (ValueError, KeyError):
        log.warning("Failed to decode JSON from instance metadata.")
        return None
    return None
def get_location(opts=None, provider=None):
    if opts is None:
        opts = {}
    ret = opts.get("location")
    if ret is None and provider is not None:
        ret = provider.get("location")
    if ret is None:
        ret = get_region_from_metadata()
    if ret is None:
        ret = DEFAULT_LOCATION
    return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>jinja_3.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import atexit
import itertools
import logging
import os.path
import pipes
import pprint
import re
import time
import uuid
import warnings
from collections.abc import Hashable
from functools import wraps
from</b></font> xml.dom import minidom
from xml.etree.ElementTree import Element, SubElement, tostring
import jinja2
import salt.fileclient
import salt.utils.data
import salt.utils.files
import salt.utils.json
import salt.utils.stringutils
import salt.utils.url
import salt.utils.yaml
from jinja2 import BaseLoader, Markup, TemplateNotFound, nodes
from jinja2.environment import TemplateModule
from jinja2.exceptions import TemplateRuntimeError
from jinja2.ext import Extension
from salt.exceptions import TemplateError
from salt.utils.decorators.jinja import jinja_filter, jinja_global, jinja_test
from salt.utils.odict import OrderedDict
from salt.utils.versions import LooseVersion
log = logging.getLogger(__name__)
__all__ = ["SaltCacheLoader", "SerializerExtension"]
GLOBAL_UUID = uuid.UUID("91633EBF-1C86-5E33-935A-28061F4B480E")
JINJA_VERSION = LooseVersion(jinja2.__version__)
class SaltCacheLoader(BaseLoader):
    _cached_pillar_client = None
    _cached_client = None
    @classmethod
    def shutdown(cls):
        for attr in ("_cached_client", "_cached_pillar_client"):
            client = getattr(cls, attr, None)
            if client is not None:
                if hasattr(client, "destroy"):
                    client.destroy()
                setattr(cls, attr, None)
    def __init__(
        self,
        opts,
        saltenv="base",
        encoding="utf-8",
        pillar_rend=False,
        _file_client=None,
    ):
        self.opts = opts
        self.saltenv = saltenv
        self.encoding = encoding
        self.pillar_rend = pillar_rend
        if self.pillar_rend:
            if saltenv not in self.opts["pillar_roots"]:
                self.searchpath = []
            else:
                self.searchpath = opts["pillar_roots"][saltenv]
        else:
            self.searchpath = [os.path.join(opts["cachedir"], "files", saltenv)]
        log.debug("Jinja search path: %s", self.searchpath)
        self.cached = []
        self._file_client = _file_client
        self.file_client()
    def file_client(self):
        if self._file_client is None:
            attr = "_cached_pillar_client" if self.pillar_rend else "_cached_client"
            cached_client = getattr(self, attr, None)
            if cached_client is None:
                cached_client = salt.fileclient.get_file_client(
                    self.opts, self.pillar_rend
                )
                setattr(SaltCacheLoader, attr, cached_client)
            self._file_client = cached_client
        return self._file_client
    def cache_file(self, template):
        saltpath = salt.utils.url.create(template)
        self.file_client().get_file(saltpath, "", True, self.saltenv)
    def check_cache(self, template):
        if template not in self.cached:
            self.cache_file(template)
            self.cached.append(template)
    def get_source(self, environment, template):
        _template = template
        if template.split("/", 1)[0] in ("..", "."):
            is_relative = True
        else:
            is_relative = False
        if is_relative:
            if not environment or "tpldir" not in environment.globals:
                log.warning(
                    'Relative path "%s" cannot be resolved without an environment',
                    template,
                )
                raise TemplateNotFound(template)
            base_path = environment.globals["tpldir"]
            _template = os.path.normpath("/".join((base_path, _template)))
            if _template.split("/", 1)[0] == "..":
                log.warning(
                    'Discarded template path "%s": attempts to'
                    " ascend outside of salt://",
                    template,
                )
                raise TemplateNotFound(template)
        self.check_cache(_template)
        if environment and template:
            tpldir = os.path.dirname(_template).replace("\\", "/")
            tplfile = _template
            if is_relative:
                tpldir = environment.globals.get("tpldir", tpldir)
                tplfile = template
            tpldata = {
                "tplfile": tplfile,
                "tpldir": "." if tpldir == "" else tpldir,
                "tpldot": tpldir.replace("/", "."),
            }
            environment.globals.update(tpldata)
        for spath in self.searchpath:
            filepath = os.path.join(spath, _template)
            try:
                with salt.utils.files.fopen(filepath, "rb") as ifile:
                    contents = ifile.read().decode(self.encoding)
                    mtime = os.path.getmtime(filepath)
                    def uptodate():
                        try:
                            return os.path.getmtime(filepath) == mtime
                        except OSError:
                            return False
                    return contents, filepath, uptodate
            except OSError:
                continue
        raise TemplateNotFound(template)
atexit.register(SaltCacheLoader.shutdown)
class PrintableDict(OrderedDict):
    def __str__(self):
        output = []
        for key, value in self.items():
            if isinstance(value, str):
                output.append("{!r}: {!r}".format(key, value))
            else:
                output.append("{!r}: {!s}".format(key, value))
        return "{" + ", ".join(output) + "}"
    def __repr__(self):  # pylint: disable=W0221
        output = []
        for key, value in self.items():
            output.append("{!r}: {!r}".format(key, value))
        return "{" + ", ".join(output) + "}"
@jinja_global("raise")
def jinja_raise(msg):
    raise TemplateError(msg)
@jinja_test("match")
def test_match(txt, rgx, ignorecase=False, multiline=False):
    flag = 0
    if ignorecase:
        flag |= re.I
    if multiline:
        flag |= re.M
    compiled_rgx = re.compile(rgx, flag)
    return True if compiled_rgx.match(txt) else False
@jinja_test("equalto")
def test_equalto(value, other):
    return value == other
@jinja_filter("skip")
def skip_filter(data):
    return ""
@jinja_filter("sequence")
def ensure_sequence_filter(data):
    if not isinstance(data, (list, tuple, set, dict)):
        return [data]
    return data
@jinja_filter("to_bool")
def to_bool(val):
    if val is None:
        return False
    if isinstance(val, bool):
        return val
    if isinstance(val, (str, (str,))):
        return val.lower() in ("yes", "1", "true")
    if isinstance(val, int):
        return val &gt; 0
    if not isinstance(val, Hashable):
        return len(val) &gt; 0
    return False
@jinja_filter("indent")
def indent(s, width=4, first=False, blank=False, indentfirst=None):
    if indentfirst is not None:
        warnings.warn(
            "The 'indentfirst' argument is renamed to 'first' and will"
            " be removed in Jinja 3.0.",
            DeprecationWarning,
            stacklevel=2,
        )
        first = indentfirst
    indention = " " * width
    newline = "\n"
    if isinstance(s, Markup):
        indention = Markup(indention)
        newline = Markup(newline)
    s += newline  # this quirk is necessary for splitlines method
    if blank:
        rv = (newline + indention).join(s.splitlines())
    else:
        lines = s.splitlines()
        rv = lines.pop(0)
        if lines:
            rv += newline + newline.join(
                indention + line if line else line for line in lines
            )
    if first:
        rv = indention + rv
    return rv
@jinja_filter("tojson")
def tojson(val, indent=None, **options):
    options.setdefault("ensure_ascii", True)
    if indent is not None:
        options["indent"] = indent
    return (
        salt.utils.json.dumps(val, **options)
        .replace("&lt;", "\\u003c")
        .replace("&gt;", "\\u003e")
        .replace("&amp;", "\\u0026")
        .replace("'", "\\u0027")
    )
@jinja_filter("quote")
def quote(txt):
    return pipes.quote(txt)
@jinja_filter()
def regex_escape(value):
    return re.escape(value)
@jinja_filter("regex_search")
def regex_search(txt, rgx, ignorecase=False, multiline=False):
    flag = 0
    if ignorecase:
        flag |= re.I
    if multiline:
        flag |= re.M
    obj = re.search(rgx, txt, flag)
    if not obj:
        return
    return obj.groups()
@jinja_filter("regex_match")
def regex_match(txt, rgx, ignorecase=False, multiline=False):
    flag = 0
    if ignorecase:
        flag |= re.I
    if multiline:
        flag |= re.M
    obj = re.match(rgx, txt, flag)
    if not obj:
        return
    return obj.groups()
@jinja_filter("regex_replace")
def regex_replace(txt, rgx, val, ignorecase=False, multiline=False):
    r"""
    Searches for a pattern and replaces with a sequence of characters.
    .. code-block:: jinja
        {% set my_text = 'lets replace spaces' %}
        {{ my_text | regex_replace('\s+', '__') }}
    will be rendered as:
    .. code-block:: text
        lets__replace__spaces
    Returns a UUID corresponding to the value passed as argument.
    .. code-block:: jinja
        {{ 'example' | uuid }}
    will be rendered as:
    .. code-block:: text
        f4efeff8-c219-578a-bad7-3dc280612ec8
    Removes duplicates from a list.
    .. code-block:: jinja
        {% set my_list = ['a', 'b', 'c', 'a', 'b'] -%}
        {{ my_list | unique }}
    will be rendered as:
    .. code-block:: text
        ['a', 'b', 'c']
    Returns the min value.
    .. code-block:: jinja
        {% set my_list = [1,2,3,4] -%}
        {{ my_list | min }}
    will be rendered as:
    .. code-block:: text
        1
    Returns the max value.
    .. code-block:: jinja
        {% my_list = [1,2,3,4] -%}
        {{ set my_list | max }}
    will be rendered as:
    .. code-block:: text
        4
    Returns the average value of a list.
    .. code-block:: jinja
        {% my_list = [1,2,3,4] -%}
        {{ set my_list | avg }}
    will be rendered as:
    .. code-block:: yaml
        2.5
    Returns the union of two lists.
    .. code-block:: jinja
        {% my_list = [1,2,3,4] -%}
        {{ set my_list | union([2, 4, 6]) }}
    will be rendered as:
    .. code-block:: text
        [1, 2, 3, 4, 6]
    Returns the intersection of two lists.
    .. code-block:: jinja
        {% my_list = [1,2,3,4] -%}
        {{ set my_list | intersect([2, 4, 6]) }}
    will be rendered as:
    .. code-block:: text
        [2, 4]
    Returns the difference of two lists.
    .. code-block:: jinja
        {% my_list = [1,2,3,4] -%}
        {{ set my_list | difference([2, 4, 6]) }}
    will be rendered as:
    .. code-block:: text
        [1, 3, 6]
    Returns the symmetric difference of two lists.
    .. code-block:: jinja
        {% my_list = [1,2,3,4] -%}
        {{ set my_list | symmetric_difference([2, 4, 6]) }}
    will be rendered as:
    .. code-block:: text
        [1, 3]
        Ensure that printed mappings are YAML friendly.
        data structure. Supports tag attributes and nested dicts/lists.
        :param value: Complex data structure representing XML contents
        :returns: Formatted XML string rendered with newlines and indentation
        :rtype: str
                nodes<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.Assign(
                    nodes.Name(profile_id, "store").set_lineno(lineno),
                    self.call_method(
                        "_profile_start",
                        dyn_args=nodes.List([label</b></font>, nodes.Const(source)]).set_lineno(
                            lineno
                        ),
                    ).set_lineno(lineno),
                ).set_lineno(lineno),
            ]
            + body
            + [
                nodes.ExprStmt(
                    self.call_method(
                        "_profile_end", dyn_args=nodes.Name(profile_id, "load")
                    ),
                ).set_lineno(lineno),
            ]
        )
        return ret
    def parse_load(self, parser):
        filter_name = parser.stream.current.value
        lineno = next(parser.stream).lineno
        if filter_name not in self.environment.filters:
            parser.fail("Unable to parse {}".format(filter_name), lineno)
        parser.stream.expect("name:as")
        target = parser.parse_assign_target()
        macro_name = "_" + parser.free_identifier().name
        macro_body = parser.parse_statements(("name:endload",), drop_needle=True)
        return [
            nodes.Macro(macro_name, [], [], macro_body).set_lineno(lineno),
            nodes.Assign(
                target,
                nodes.Filter(
                    nodes.Call(
                        nodes.Name(macro_name, "load").set_lineno(lineno),
                        [],
                        [],
                        None,
                        None,
                    ).set_lineno(lineno),
                    filter_name,
                    [],
                    [],
                    None,
                    None,
                ).set_lineno(lineno),
            ).set_lineno(lineno),
        ]
    def parse_import(self, parser, converter):
        import_node = parser.parse_import()
        target = import_node.target
        lineno = import_node.lineno
        body = [
            import_node,
            nodes.Assign(
                nodes.Name(target, "store").set_lineno(lineno),
                nodes.Filter(
                    nodes.Name(target, "load").set_lineno(lineno),
                    "load_{}".format(converter),
                    [],
                    [],
                    None,
                    None,
                ).set_lineno(lineno),
            ).set_lineno(lineno),
        ]
        return self._parse_profile_block(
            parser, import_node.template, "import_{}".format(converter), body, lineno
        )
    def dict_to_sls_yaml_params(self, value, flow_style=False):
        return self.format_yaml(
            [{key: val} for key, val in value.items()], flow_style=flow_style
        )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
