<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for aws.py &amp; jinja_3.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for aws.py &amp; jinja_3.py
      </h3>
<h1 align="center">
        2.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>aws.py (3.3377838%)<th>jinja_3.py (2.1349275%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(11-24)<td><a href="#" name="0">(6-18)</a><td align="center"><font color="#ff0000">13</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(166-172)<td><a href="#" name="1">(1138-1142)</a><td align="center"><font color="#eb0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>aws.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import binascii
2 import hashlib
3 import hmac
4 import logging
5 import random
6 import re
7 import time
8 import urllib.parse
9 import xml.etree.ElementTree as ET
10 from datetime import datetime
11 import salt.config
12 import salt.utils.hashutils
13 import</b></font> salt.utils.xmlutil as xml
14 try:
15     import requests
16     HAS_REQUESTS = True  # pylint: disable=W0612
17 except ImportError:
18     HAS_REQUESTS = False  # pylint: disable=W0612
19 log = logging.getLogger(__name__)
20 DEFAULT_LOCATION = "us-east-1"
21 DEFAULT_AWS_API_VERSION = "2016-11-15"
22 AWS_RETRY_CODES = [
23     "RequestLimitExceeded",
24     "InsufficientInstanceCapacity",
25     "InternalError",
26     "Unavailable",
27     "InsufficientAddressCapacity",
28     "InsufficientReservedInstanceCapacity",
29 ]
30 AWS_METADATA_TIMEOUT = 3.05
31 AWS_MAX_RETRIES = 7
32 IROLE_CODE = "use-instance-role-credentials"
33 __AccessKeyId__ = ""
34 __SecretAccessKey__ = ""
35 __Token__ = ""
36 __Expiration__ = ""
37 __Location__ = ""
38 __AssumeCache__ = {}
39 def sleep_exponential_backoff(attempts):
40     time.sleep(random.uniform(1, 2 ** attempts))
41 def creds(provider):
42     global __AccessKeyId__, __SecretAccessKey__, __Token__, __Expiration__
43     ret_credentials = ()
44     if provider["id"] == IROLE_CODE or provider["key"] == IROLE_CODE:
45         if __Expiration__ != "":
46             timenow = datetime.utcnow()
47             timestamp = timenow.strftime("%Y-%m-%dT%H:%M:%SZ")
48             if timestamp &lt; __Expiration__:
49                 return __AccessKeyId__, __SecretAccessKey__, __Token__
50         try:
51             result = requests.get(
52                 "http://169.254.169.254/latest/meta-data/iam/security-credentials/",
53                 proxies={"http": ""},
54                 timeout=AWS_METADATA_TIMEOUT,
55             )
56             result.raise_for_status()
57             role = result.text
58         except (requests.exceptions.HTTPError, requests.exceptions.ConnectionError):
59             return provider["id"], provider["key"], ""
60         try:
61             result = requests.get(
62                 "http://169.254.169.254/latest/meta-data/iam/security-credentials/{}".format(
63                     role
64                 ),
65                 proxies={"http": ""},
66                 timeout=AWS_METADATA_TIMEOUT,
67             )
68             result.raise_for_status()
69         except (requests.exceptions.HTTPError, requests.exceptions.ConnectionError):
70             return provider["id"], provider["key"], ""
71         data = result.json()
72         __AccessKeyId__ = data["AccessKeyId"]
73         __SecretAccessKey__ = data["SecretAccessKey"]
74         __Token__ = data["Token"]
75         __Expiration__ = data["Expiration"]
76         ret_credentials = __AccessKeyId__, __SecretAccessKey__, __Token__
77     else:
78         ret_credentials = provider["id"], provider["key"], ""
79     if provider.get("role_arn") is not None:
80         provider_shadow = provider.copy()
81         provider_shadow.pop("role_arn", None)
82         log.info("Assuming the role: %s", provider.get("role_arn"))
83         ret_credentials = assumed_creds(
84             provider_shadow, role_arn=provider.get("role_arn"), location="us-east-1"
85         )
86     return ret_credentials
87 def sig2(method, endpoint, params, provider, aws_api_version):
88     timenow = datetime.utcnow()
89     timestamp = timenow.strftime("%Y-%m-%dT%H:%M:%SZ")
90     access_key_id, secret_access_key, token = creds(provider)
91     params_with_headers = params.copy()
92     params_with_headers["AWSAccessKeyId"] = access_key_id
93     params_with_headers["SignatureVersion"] = "2"
94     params_with_headers["SignatureMethod"] = "HmacSHA256"
95     params_with_headers["Timestamp"] = "{}".format(timestamp)
96     params_with_headers["Version"] = aws_api_version
97     keys = sorted(params_with_headers.keys())
98 <a name="1"></a>    values = list(list(map(params_with_headers.get, keys)))
99     querystring = urllib.parse.urlencode(list(zip(keys, values)))
100     canonical = "{}\n{}\n/\n{}"<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.format(
101         method.encode("utf-8"),
102         endpoint.encode("utf-8"),
103         querystring.encode("utf-8"),
104     )
105     hashed = hmac.new(secret_access_key, canonical, hashlib.</b></font>sha256)
106     sig = binascii.b2a_base64(hashed.digest())
107     params_with_headers["Signature"] = sig.strip()
108     if token != "":
109         params_with_headers["SecurityToken"] = token
110     return params_with_headers
111 def assumed_creds(prov_dict, role_arn, location=None):
112     valid_session_name_re = re.compile("[^a-z0-9A-Z+=,.@-]")
113     now = time.mktime(datetime.utcnow().timetuple())
114     for key, creds in __AssumeCache__.items():
115         if (creds["Expiration"] - now) &lt;= 120:
116             __AssumeCache__.delete(key)
117     if role_arn in __AssumeCache__:
118         c = __AssumeCache__[role_arn]
119         return c["AccessKeyId"], c["SecretAccessKey"], c["SessionToken"]
120     version = "2011-06-15"
121     session_name = valid_session_name_re.sub(
122         "", salt.config.get_id({"root_dir": None})[0]
123     )[0:63]
124     headers, requesturl = sig4(
125         "GET",
126         "sts.amazonaws.com",
127         params={
128             "Version": version,
129             "Action": "AssumeRole",
130             "RoleSessionName": session_name,
131             "RoleArn": role_arn,
132             "Policy": (
133                 '{"Version":"2012-10-17","Statement":[{"Sid":"Stmt1",'
134                 ' "Effect":"Allow","Action":"*","Resource":"*"}]}'
135             ),
136             "DurationSeconds": "3600",
137         },
138         aws_api_version=version,
139         data="",
140         uri="/",
141         prov_dict=prov_dict,
142         product="sts",
143         location=location,
144         requesturl="https://sts.amazonaws.com/",
145     )
146     headers["Accept"] = "application/json"
147     result = requests.request("GET", requesturl, headers=headers, data="", verify=True)
148     if result.status_code &gt;= 400:
149         log.info("AssumeRole response: %s", result.content)
150     result.raise_for_status()
151     resp = result.json()
152     data = resp["AssumeRoleResponse"]["AssumeRoleResult"]["Credentials"]
153     __AssumeCache__[role_arn] = data
154     return data["AccessKeyId"], data["SecretAccessKey"], data["SessionToken"]
155 def sig4(
156     method,
157     endpoint,
158     params,
159     prov_dict,
160     aws_api_version=DEFAULT_AWS_API_VERSION,
161     location=None,
162     product="ec2",
163     uri="/",
164     requesturl=None,
165     data="",
166     headers=None,
167     role_arn=None,
168     payload_hash=None,
169 ):
170     timenow = datetime.utcnow()
171     if role_arn is None:
172         access_key_id, secret_access_key, token = creds(prov_dict)
173     else:
174         access_key_id, secret_access_key, token = assumed_creds(
175             prov_dict, role_arn, location=location
176         )
177     if location is None:
178         location = get_region_from_metadata()
179     if location is None:
180         location = DEFAULT_LOCATION
181     params_with_headers = params.copy()
182     if product not in ("s3", "ssm"):
183         params_with_headers["Version"] = aws_api_version
184     keys = sorted(params_with_headers.keys())
185     values = list(map(params_with_headers.get, keys))
186     querystring = urllib.parse.urlencode(list(zip(keys, values))).replace("+", "%20")
187     amzdate = timenow.strftime("%Y%m%dT%H%M%SZ")
188     datestamp = timenow.strftime("%Y%m%d")
189     new_headers = {}
190     if isinstance(headers, dict):
191         new_headers = headers.copy()
192     if not payload_hash:
193         payload_hash = salt.utils.hashutils.sha256_digest(data)
194     new_headers["X-Amz-date"] = amzdate
195     new_headers["host"] = endpoint
196     new_headers["x-amz-content-sha256"] = payload_hash
197     a_canonical_headers = []
198     a_signed_headers = []
199     if token != "":
200         new_headers["X-Amz-security-token"] = token
201     for header in sorted(new_headers.keys(), key=str.lower):
202         lower_header = header.lower()
203         a_canonical_headers.append(
204             "{}:{}".format(lower_header, new_headers[header].strip())
205         )
206         a_signed_headers.append(lower_header)
207     canonical_headers = "\n".join(a_canonical_headers) + "\n"
208     signed_headers = ";".join(a_signed_headers)
209     algorithm = "AWS4-HMAC-SHA256"
210     canonical_request = "\n".join(
211         (method, uri, querystring, canonical_headers, signed_headers, payload_hash)
212     )
213     credential_scope = "/".join((datestamp, location, product, "aws4_request"))
214     string_to_sign = "\n".join(
215         (
216             algorithm,
217             amzdate,
218             credential_scope,
219             salt.utils.hashutils.sha256_digest(canonical_request),
220         )
221     )
222     signing_key = _sig_key(secret_access_key, datestamp, location, product)
223     signature = hmac.new(
224         signing_key, string_to_sign.encode("utf-8"), hashlib.sha256
225     ).hexdigest()
226     authorization_header = "{} Credential={}/{}, SignedHeaders={}, Signature={}".format(
227         algorithm,
228         access_key_id,
229         credential_scope,
230         signed_headers,
231         signature,
232     )
233     new_headers["Authorization"] = authorization_header
234     requesturl = "{}?{}".format(requesturl, querystring)
235     return new_headers, requesturl
236 def _sign(key, msg):
237     return hmac.new(key, msg.encode("utf-8"), hashlib.sha256).digest()
238 def _sig_key(key, date_stamp, regionName, serviceName):
239     kDate = _sign(("AWS4" + key).encode("utf-8"), date_stamp)
240     if regionName:
241         kRegion = _sign(kDate, regionName)
242         kService = _sign(kRegion, serviceName)
243     else:
244         kService = _sign(kDate, serviceName)
245     kSigning = _sign(kService, "aws4_request")
246     return kSigning
247 def query(
248     params=None,
249     setname=None,
250     requesturl=None,
251     location=None,
252     return_url=False,
253     return_root=False,
254     opts=None,
255     provider=None,
256     endpoint=None,
257     product="ec2",
258     sigver="2",
259 ):
260     if params is None:
261         params = {}
262     if opts is None:
263         opts = {}
264     function = opts.get("function", (None, product))
265     providers = opts.get("providers", {})
266     if provider is None:
267         prov_dict = providers.get(function[1], {}).get(product, {})
268         if prov_dict:
269             driver = list(list(prov_dict.keys()))[0]
270             provider = providers.get(driver, product)
271     else:
272         prov_dict = providers.get(provider, {}).get(product, {})
273     service_url = prov_dict.get("service_url", "amazonaws.com")
274     if not location:
275         location = get_location(opts, prov_dict)
276     if endpoint is None:
277         if not requesturl:
278             endpoint = prov_dict.get(
279                 "endpoint", "{}.{}.{}".format(product, location, service_url)
280             )
281             requesturl = "https://{}/".format(endpoint)
282         else:
283             endpoint = urllib.parse.urlparse(requesturl).netloc
284             if endpoint == "":
285                 endpoint_err = (
286                     "Could not find a valid endpoint in the "
287                     "requesturl: {}. Looking for something "
288                     "like https://some.aws.endpoint/?args".format(requesturl)
289                 )
290                 log.error(endpoint_err)
291                 if return_url is True:
292                     return {"error": endpoint_err}, requesturl
293                 return {"error": endpoint_err}
294     log.debug("Using AWS endpoint: %s", endpoint)
295     method = "GET"
296     aws_api_version = prov_dict.get(
297         "aws_api_version",
298         prov_dict.get("{}_api_version".format(product), DEFAULT_AWS_API_VERSION),
299     )
300     if not prov_dict.get("id", None):
301         prov_dict["id"] = providers.get(provider, {}).get("ec2", {}).get("id", {})
302         prov_dict["key"] = providers.get(provider, {}).get("ec2", {}).get("key", {})
303     if sigver == "4":
304         headers, requesturl = sig4(
305             method,
306             endpoint,
307             params,
308             prov_dict,
309             aws_api_version,
310             location,
311             product,
312             requesturl=requesturl,
313         )
314         params_with_headers = {}
315     else:
316         params_with_headers = sig2(method, endpoint, params, prov_dict, aws_api_version)
317         headers = {}
318     attempts = 0
319     while attempts &lt; AWS_MAX_RETRIES:
320         log.debug("AWS Request: %s", requesturl)
321         log.trace("AWS Request Parameters: %s", params_with_headers)
322         try:
323             result = requests.get(
324                 requesturl, headers=headers, params=params_with_headers
325             )
326             log.debug("AWS Response Status Code: %s", result.status_code)
327             log.trace("AWS Response Text: %s", result.text)
328             result.raise_for_status()
329             break
330         except requests.exceptions.HTTPError as exc:
331             root = ET.fromstring(exc.response.content)
332             data = xml.to_dict(root)
333             err_code = data.get("Errors", {}).get("Error", {}).get("Code", "")
334             if attempts &lt; AWS_MAX_RETRIES and err_code and err_code in AWS_RETRY_CODES:
335                 attempts += 1
336                 log.error(
337                     "AWS Response Status Code and Error: [%s %s] %s; "
338                     "Attempts remaining: %s",
339                     exc.response.status_code,
340                     exc,
341                     data,
342                     attempts,
343                 )
344                 sleep_exponential_backoff(attempts)
345                 continue
346             log.error(
347                 "AWS Response Status Code and Error: [%s %s] %s",
348                 exc.response.status_code,
349                 exc,
350                 data,
351             )
352             if return_url is True:
353                 return {"error": data}, requesturl
354             return {"error": data}
355     else:
356         log.error(
357             "AWS Response Status Code and Error: [%s %s] %s",
358             exc.response.status_code,
359             exc,
360             data,
361         )
362         if return_url is True:
363             return {"error": data}, requesturl
364         return {"error": data}
365     root = ET.fromstring(result.text)
366     items = root[1]
367     if return_root is True:
368         items = root
369     if setname:
370         for idx, item in enumerate(root):
371             comps = item.tag.split("}")
372             if comps[1] == setname:
373                 items = root[idx]
374     ret = []
375     for item in items:
376         ret.append(xml.to_dict(item))
377     if return_url is True:
378         return ret, requesturl
379     return ret
380 def get_region_from_metadata():
381     global __Location__
382     if __Location__ == "do-not-get-from-metadata":
383         log.debug(
384             "Previously failed to get AWS region from metadata. Not trying again."
385         )
386         return None
387     if __Location__ != "":
388         return __Location__
389     try:
390         result = requests.get(
391             "http://169.254.169.254/latest/dynamic/instance-identity/document",
392             proxies={"http": ""},
393             timeout=AWS_METADATA_TIMEOUT,
394         )
395     except requests.exceptions.RequestException:
396         log.warning("Failed to get AWS region from instance metadata.", exc_info=True)
397         __Location__ = "do-not-get-from-metadata"
398         return None
399     try:
400         region = result.json()["region"]
401         __Location__ = region
402         return __Location__
403     except (ValueError, KeyError):
404         log.warning("Failed to decode JSON from instance metadata.")
405         return None
406     return None
407 def get_location(opts=None, provider=None):
408     if opts is None:
409         opts = {}
410     ret = opts.get("location")
411     if ret is None and provider is not None:
412         ret = provider.get("location")
413     if ret is None:
414         ret = get_region_from_metadata()
415     if ret is None:
416         ret = DEFAULT_LOCATION
417     return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>jinja_3.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import atexit
2 import itertools
3 import logging
4 import os.path
5 import pipes
6 import pprint
7 import re
8 import time
9 import uuid
10 import warnings
11 from collections.abc import Hashable
12 from functools import wraps
13 from</b></font> xml.dom import minidom
14 from xml.etree.ElementTree import Element, SubElement, tostring
15 import jinja2
16 import salt.fileclient
17 import salt.utils.data
18 import salt.utils.files
19 import salt.utils.json
20 import salt.utils.stringutils
21 import salt.utils.url
22 import salt.utils.yaml
23 from jinja2 import BaseLoader, Markup, TemplateNotFound, nodes
24 from jinja2.environment import TemplateModule
25 from jinja2.exceptions import TemplateRuntimeError
26 from jinja2.ext import Extension
27 from salt.exceptions import TemplateError
28 from salt.utils.decorators.jinja import jinja_filter, jinja_global, jinja_test
29 from salt.utils.odict import OrderedDict
30 from salt.utils.versions import LooseVersion
31 log = logging.getLogger(__name__)
32 __all__ = ["SaltCacheLoader", "SerializerExtension"]
33 GLOBAL_UUID = uuid.UUID("91633EBF-1C86-5E33-935A-28061F4B480E")
34 JINJA_VERSION = LooseVersion(jinja2.__version__)
35 class SaltCacheLoader(BaseLoader):
36     _cached_pillar_client = None
37     _cached_client = None
38     @classmethod
39     def shutdown(cls):
40         for attr in ("_cached_client", "_cached_pillar_client"):
41             client = getattr(cls, attr, None)
42             if client is not None:
43                 if hasattr(client, "destroy"):
44                     client.destroy()
45                 setattr(cls, attr, None)
46     def __init__(
47         self,
48         opts,
49         saltenv="base",
50         encoding="utf-8",
51         pillar_rend=False,
52         _file_client=None,
53     ):
54         self.opts = opts
55         self.saltenv = saltenv
56         self.encoding = encoding
57         self.pillar_rend = pillar_rend
58         if self.pillar_rend:
59             if saltenv not in self.opts["pillar_roots"]:
60                 self.searchpath = []
61             else:
62                 self.searchpath = opts["pillar_roots"][saltenv]
63         else:
64             self.searchpath = [os.path.join(opts["cachedir"], "files", saltenv)]
65         log.debug("Jinja search path: %s", self.searchpath)
66         self.cached = []
67         self._file_client = _file_client
68         self.file_client()
69     def file_client(self):
70         if self._file_client is None:
71             attr = "_cached_pillar_client" if self.pillar_rend else "_cached_client"
72             cached_client = getattr(self, attr, None)
73             if cached_client is None:
74                 cached_client = salt.fileclient.get_file_client(
75                     self.opts, self.pillar_rend
76                 )
77                 setattr(SaltCacheLoader, attr, cached_client)
78             self._file_client = cached_client
79         return self._file_client
80     def cache_file(self, template):
81         saltpath = salt.utils.url.create(template)
82         self.file_client().get_file(saltpath, "", True, self.saltenv)
83     def check_cache(self, template):
84         if template not in self.cached:
85             self.cache_file(template)
86             self.cached.append(template)
87     def get_source(self, environment, template):
88         _template = template
89         if template.split("/", 1)[0] in ("..", "."):
90             is_relative = True
91         else:
92             is_relative = False
93         if is_relative:
94             if not environment or "tpldir" not in environment.globals:
95                 log.warning(
96                     'Relative path "%s" cannot be resolved without an environment',
97                     template,
98                 )
99                 raise TemplateNotFound(template)
100             base_path = environment.globals["tpldir"]
101             _template = os.path.normpath("/".join((base_path, _template)))
102             if _template.split("/", 1)[0] == "..":
103                 log.warning(
104                     'Discarded template path "%s": attempts to'
105                     " ascend outside of salt://",
106                     template,
107                 )
108                 raise TemplateNotFound(template)
109         self.check_cache(_template)
110         if environment and template:
111             tpldir = os.path.dirname(_template).replace("\\", "/")
112             tplfile = _template
113             if is_relative:
114                 tpldir = environment.globals.get("tpldir", tpldir)
115                 tplfile = template
116             tpldata = {
117                 "tplfile": tplfile,
118                 "tpldir": "." if tpldir == "" else tpldir,
119                 "tpldot": tpldir.replace("/", "."),
120             }
121             environment.globals.update(tpldata)
122         for spath in self.searchpath:
123             filepath = os.path.join(spath, _template)
124             try:
125                 with salt.utils.files.fopen(filepath, "rb") as ifile:
126                     contents = ifile.read().decode(self.encoding)
127                     mtime = os.path.getmtime(filepath)
128                     def uptodate():
129                         try:
130                             return os.path.getmtime(filepath) == mtime
131                         except OSError:
132                             return False
133                     return contents, filepath, uptodate
134             except OSError:
135                 continue
136         raise TemplateNotFound(template)
137 atexit.register(SaltCacheLoader.shutdown)
138 class PrintableDict(OrderedDict):
139     def __str__(self):
140         output = []
141         for key, value in self.items():
142             if isinstance(value, str):
143                 output.append("{!r}: {!r}".format(key, value))
144             else:
145                 output.append("{!r}: {!s}".format(key, value))
146         return "{" + ", ".join(output) + "}"
147     def __repr__(self):  # pylint: disable=W0221
148         output = []
149         for key, value in self.items():
150             output.append("{!r}: {!r}".format(key, value))
151         return "{" + ", ".join(output) + "}"
152 @jinja_global("raise")
153 def jinja_raise(msg):
154     raise TemplateError(msg)
155 @jinja_test("match")
156 def test_match(txt, rgx, ignorecase=False, multiline=False):
157     flag = 0
158     if ignorecase:
159         flag |= re.I
160     if multiline:
161         flag |= re.M
162     compiled_rgx = re.compile(rgx, flag)
163     return True if compiled_rgx.match(txt) else False
164 @jinja_test("equalto")
165 def test_equalto(value, other):
166     return value == other
167 @jinja_filter("skip")
168 def skip_filter(data):
169     return ""
170 @jinja_filter("sequence")
171 def ensure_sequence_filter(data):
172     if not isinstance(data, (list, tuple, set, dict)):
173         return [data]
174     return data
175 @jinja_filter("to_bool")
176 def to_bool(val):
177     if val is None:
178         return False
179     if isinstance(val, bool):
180         return val
181     if isinstance(val, (str, (str,))):
182         return val.lower() in ("yes", "1", "true")
183     if isinstance(val, int):
184         return val &gt; 0
185     if not isinstance(val, Hashable):
186         return len(val) &gt; 0
187     return False
188 @jinja_filter("indent")
189 def indent(s, width=4, first=False, blank=False, indentfirst=None):
190     if indentfirst is not None:
191         warnings.warn(
192             "The 'indentfirst' argument is renamed to 'first' and will"
193             " be removed in Jinja 3.0.",
194             DeprecationWarning,
195             stacklevel=2,
196         )
197         first = indentfirst
198     indention = " " * width
199     newline = "\n"
200     if isinstance(s, Markup):
201         indention = Markup(indention)
202         newline = Markup(newline)
203     s += newline  # this quirk is necessary for splitlines method
204     if blank:
205         rv = (newline + indention).join(s.splitlines())
206     else:
207         lines = s.splitlines()
208         rv = lines.pop(0)
209         if lines:
210             rv += newline + newline.join(
211                 indention + line if line else line for line in lines
212             )
213     if first:
214         rv = indention + rv
215     return rv
216 @jinja_filter("tojson")
217 def tojson(val, indent=None, **options):
218     options.setdefault("ensure_ascii", True)
219     if indent is not None:
220         options["indent"] = indent
221     return (
222         salt.utils.json.dumps(val, **options)
223         .replace("&lt;", "\\u003c")
224         .replace("&gt;", "\\u003e")
225         .replace("&amp;", "\\u0026")
226         .replace("'", "\\u0027")
227     )
228 @jinja_filter("quote")
229 def quote(txt):
230     return pipes.quote(txt)
231 @jinja_filter()
232 def regex_escape(value):
233     return re.escape(value)
234 @jinja_filter("regex_search")
235 def regex_search(txt, rgx, ignorecase=False, multiline=False):
236     flag = 0
237     if ignorecase:
238         flag |= re.I
239     if multiline:
240         flag |= re.M
241     obj = re.search(rgx, txt, flag)
242     if not obj:
243         return
244     return obj.groups()
245 @jinja_filter("regex_match")
246 def regex_match(txt, rgx, ignorecase=False, multiline=False):
247     flag = 0
248     if ignorecase:
249         flag |= re.I
250     if multiline:
251         flag |= re.M
252     obj = re.match(rgx, txt, flag)
253     if not obj:
254         return
255     return obj.groups()
256 @jinja_filter("regex_replace")
257 def regex_replace(txt, rgx, val, ignorecase=False, multiline=False):
258     r"""
259     Searches for a pattern and replaces with a sequence of characters.
260     .. code-block:: jinja
261         {% set my_text = 'lets replace spaces' %}
262         {{ my_text | regex_replace('\s+', '__') }}
263     will be rendered as:
264     .. code-block:: text
265         lets__replace__spaces
266     Returns a UUID corresponding to the value passed as argument.
267     .. code-block:: jinja
268         {{ 'example' | uuid }}
269     will be rendered as:
270     .. code-block:: text
271         f4efeff8-c219-578a-bad7-3dc280612ec8
272     Removes duplicates from a list.
273     .. code-block:: jinja
274         {% set my_list = ['a', 'b', 'c', 'a', 'b'] -%}
275         {{ my_list | unique }}
276     will be rendered as:
277     .. code-block:: text
278         ['a', 'b', 'c']
279     Returns the min value.
280     .. code-block:: jinja
281         {% set my_list = [1,2,3,4] -%}
282         {{ my_list | min }}
283     will be rendered as:
284     .. code-block:: text
285         1
286     Returns the max value.
287     .. code-block:: jinja
288         {% my_list = [1,2,3,4] -%}
289         {{ set my_list | max }}
290     will be rendered as:
291     .. code-block:: text
292         4
293     Returns the average value of a list.
294     .. code-block:: jinja
295         {% my_list = [1,2,3,4] -%}
296         {{ set my_list | avg }}
297     will be rendered as:
298     .. code-block:: yaml
299         2.5
300     Returns the union of two lists.
301     .. code-block:: jinja
302         {% my_list = [1,2,3,4] -%}
303         {{ set my_list | union([2, 4, 6]) }}
304     will be rendered as:
305     .. code-block:: text
306         [1, 2, 3, 4, 6]
307     Returns the intersection of two lists.
308     .. code-block:: jinja
309         {% my_list = [1,2,3,4] -%}
310         {{ set my_list | intersect([2, 4, 6]) }}
311     will be rendered as:
312     .. code-block:: text
313         [2, 4]
314     Returns the difference of two lists.
315     .. code-block:: jinja
316         {% my_list = [1,2,3,4] -%}
317         {{ set my_list | difference([2, 4, 6]) }}
318     will be rendered as:
319     .. code-block:: text
320         [1, 3, 6]
321     Returns the symmetric difference of two lists.
322     .. code-block:: jinja
323         {% my_list = [1,2,3,4] -%}
324         {{ set my_list | symmetric_difference([2, 4, 6]) }}
325     will be rendered as:
326     .. code-block:: text
327         [1, 3]
328         Ensure that printed mappings are YAML friendly.
329         data structure. Supports tag attributes and nested dicts/lists.
330         :param value: Complex data structure representing XML contents
331         :returns: Formatted XML string rendered with newlines and indentation
332         :rtype: str
333                 nodes<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.Assign(
334                     nodes.Name(profile_id, "store").set_lineno(lineno),
335                     self.call_method(
336                         "_profile_start",
337                         dyn_args=nodes.List([label</b></font>, nodes.Const(source)]).set_lineno(
338                             lineno
339                         ),
340                     ).set_lineno(lineno),
341                 ).set_lineno(lineno),
342             ]
343             + body
344             + [
345                 nodes.ExprStmt(
346                     self.call_method(
347                         "_profile_end", dyn_args=nodes.Name(profile_id, "load")
348                     ),
349                 ).set_lineno(lineno),
350             ]
351         )
352         return ret
353     def parse_load(self, parser):
354         filter_name = parser.stream.current.value
355         lineno = next(parser.stream).lineno
356         if filter_name not in self.environment.filters:
357             parser.fail("Unable to parse {}".format(filter_name), lineno)
358         parser.stream.expect("name:as")
359         target = parser.parse_assign_target()
360         macro_name = "_" + parser.free_identifier().name
361         macro_body = parser.parse_statements(("name:endload",), drop_needle=True)
362         return [
363             nodes.Macro(macro_name, [], [], macro_body).set_lineno(lineno),
364             nodes.Assign(
365                 target,
366                 nodes.Filter(
367                     nodes.Call(
368                         nodes.Name(macro_name, "load").set_lineno(lineno),
369                         [],
370                         [],
371                         None,
372                         None,
373                     ).set_lineno(lineno),
374                     filter_name,
375                     [],
376                     [],
377                     None,
378                     None,
379                 ).set_lineno(lineno),
380             ).set_lineno(lineno),
381         ]
382     def parse_import(self, parser, converter):
383         import_node = parser.parse_import()
384         target = import_node.target
385         lineno = import_node.lineno
386         body = [
387             import_node,
388             nodes.Assign(
389                 nodes.Name(target, "store").set_lineno(lineno),
390                 nodes.Filter(
391                     nodes.Name(target, "load").set_lineno(lineno),
392                     "load_{}".format(converter),
393                     [],
394                     [],
395                     None,
396                     None,
397                 ).set_lineno(lineno),
398             ).set_lineno(lineno),
399         ]
400         return self._parse_profile_block(
401             parser, import_node.template, "import_{}".format(converter), body, lineno
402         )
403     def dict_to_sls_yaml_params(self, value, flow_style=False):
404         return self.format_yaml(
405             [{key: val} for key, val in value.items()], flow_style=flow_style
406         )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
