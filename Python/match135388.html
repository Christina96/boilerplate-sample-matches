<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for aws.py &amp; jinja_3.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for aws.py &amp; jinja_3.py
      </h3>
<h1 align="center">
        2.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>aws.py (3.3377838%)<th>jinja_3.py (2.1349275%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(11-24)<td><a href="#" name="0">(6-18)</a><td align="center"><font color="#ff0000">13</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(166-172)<td><a href="#" name="1">(1138-1142)</a><td align="center"><font color="#eb0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>aws.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import binascii
2 import hashlib
3 import hmac
4 import logging
5 import random
6 import re
7 import time
8 import urllib.parse
9 import xml.etree.ElementTree as ET
10 from datetime import datetime
11 import salt.config
12 import salt.utils.hashutils
13 import</b></font> salt.utils.xmlutil as xml
14 try:
15     import requests
16     HAS_REQUESTS = True  # pylint: disable=W0612
17 except ImportError:
18     HAS_REQUESTS = False  # pylint: disable=W0612
19 log = logging.getLogger(__name__)
20 DEFAULT_LOCATION = "us-east-1"
21 DEFAULT_AWS_API_VERSION = "2016-11-15"
22 AWS_RETRY_CODES = [
23     "RequestLimitExceeded",
24     "InsufficientInstanceCapacity",
25     "InternalError",
26     "Unavailable",
27     "InsufficientAddressCapacity",
28     "InsufficientReservedInstanceCapacity",
29 ]
30 AWS_METADATA_TIMEOUT = 3.05
31 AWS_MAX_RETRIES = 7
32 IROLE_CODE = "use-instance-role-credentials"
33 __AccessKeyId__ = ""
34 __SecretAccessKey__ = ""
35 __Token__ = ""
36 __Expiration__ = ""
37 __Location__ = ""
38 __AssumeCache__ = {}
39 def sleep_exponential_backoff(attempts):
40     time.sleep(random.uniform(1, 2 ** attempts))
41 def creds(provider):
42     global __AccessKeyId__, __SecretAccessKey__, __Token__, __Expiration__
43     ret_credentials = ()
44     if provider["id"] == IROLE_CODE or provider["key"] == IROLE_CODE:
45         if __Expiration__ != "":
46             timenow = datetime.utcnow()
47             timestamp = timenow.strftime("%Y-%m-%dT%H:%M:%SZ")
48             if timestamp &lt; __Expiration__:
49                 return __AccessKeyId__, __SecretAccessKey__, __Token__
50         try:
51             result = requests.get(
52                 "http://169.254.169.254/latest/meta-data/iam/security-credentials/",
53                 proxies={"http": ""},
54                 timeout=AWS_METADATA_TIMEOUT,
55             )
56             result.raise_for_status()
57             role = result.text
58         except (requests.exceptions.HTTPError, requests.exceptions.ConnectionError):
59             return provider["id"], provider["key"], ""
60         try:
61             result = requests.get(
62                 "http://169.254.169.254/latest/meta-data/iam/security-credentials/{}".format(
63                     role
64                 ),
65                 proxies={"http": ""},
66                 timeout=AWS_METADATA_TIMEOUT,
67             )
68             result.raise_for_status()
69         except (requests.exceptions.HTTPError, requests.exceptions.ConnectionError):
70             return provider["id"], provider["key"], ""
71         data = result.json()
72         __AccessKeyId__ = data["AccessKeyId"]
73         __SecretAccessKey__ = data["SecretAccessKey"]
74         __Token__ = data["Token"]
75         __Expiration__ = data["Expiration"]
76         ret_credentials = __AccessKeyId__, __SecretAccessKey__, __Token__
77     else:
78         ret_credentials = provider["id"], provider["key"], ""
79     if provider.get("role_arn") is not None:
80         provider_shadow = provider.copy()
81         provider_shadow.pop("role_arn", None)
82         log.info("Assuming the role: %s", provider.get("role_arn"))
83         ret_credentials = assumed_creds(
84             provider_shadow, role_arn=provider.get("role_arn"), location="us-east-1"
85         )
86     return ret_credentials
87 def sig2(method, endpoint, params, provider, aws_api_version):
88     timenow = datetime.utcnow()
89     timestamp = timenow.strftime("%Y-%m-%dT%H:%M:%SZ")
90     access_key_id, secret_access_key, token = creds(provider)
91     params_with_headers = params.copy()
92     params_with_headers["AWSAccessKeyId"] = access_key_id
93     params_with_headers["SignatureVersion"] = "2"
94     params_with_headers["SignatureMethod"] = "HmacSHA256"
95     params_with_headers["Timestamp"] = "{}".format(timestamp)
96     params_with_headers["Version"] = aws_api_version
97     keys = sorted(params_with_headers.keys())
98     querystring = urllib.parse.urlencode(list(zip(keys, values)))
99     canonical = "{}\n{}\n/\n{}"<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.format(
100         method.encode("utf-8"),
101         endpoint.encode("utf-8"),
102         querystring.encode("utf-8"),
103     )
104     hashed = hmac.new(secret_access_key, canonical, hashlib.</b></font>sha256)
105     sig = binascii.b2a_base64(hashed.digest())
106     params_with_headers["Signature"] = sig.strip()
107     if token != "":
108         params_with_headers["SecurityToken"] = token
109     return params_with_headers
110 def assumed_creds(prov_dict, role_arn, location=None):
111     valid_session_name_re = re.compile("[^a-z0-9A-Z+=,.@-]")
112     now = time.mktime(datetime.utcnow().timetuple())
113     for key, creds in __AssumeCache__.items():
114         if (creds["Expiration"] - now) &lt;= 120:
115             __AssumeCache__.delete(key)
116     if role_arn in __AssumeCache__:
117         c = __AssumeCache__[role_arn]
118         return c["AccessKeyId"], c["SecretAccessKey"], c["SessionToken"]
119     version = "2011-06-15"
120     session_name = valid_session_name_re.sub(
121         "", salt.config.get_id({"root_dir": None})[0]
122     )[0:63]
123     headers, requesturl = sig4(
124         "GET",
125         "sts.amazonaws.com",
126         params={
127             "Version": version,
128             "Action": "AssumeRole",
129             "RoleSessionName": session_name,
130             "RoleArn": role_arn,
131             "Policy": (
132                 '{"Version":"2012-10-17","Statement":[{"Sid":"Stmt1",'
133                 ' "Effect":"Allow","Action":"*","Resource":"*"}]}'
134             ),
135             "DurationSeconds": "3600",
136         },
137         aws_api_version=version,
138         data="",
139         uri="/",
140         prov_dict=prov_dict,
141         product="sts",
142         location=location,
143         requesturl="https://sts.amazonaws.com/",
144     )
145     headers["Accept"] = "application/json"
146     result = requests.request("GET", requesturl, headers=headers, data="", verify=True)
147     if result.status_code &gt;= 400:
148         log.info("AssumeRole response: %s", result.content)
149     result.raise_for_status()
150     resp = result.json()
151     data = resp["AssumeRoleResponse"]["AssumeRoleResult"]["Credentials"]
152     __AssumeCache__[role_arn] = data
153     return data["AccessKeyId"], data["SecretAccessKey"], data["SessionToken"]
154 def sig4(
155     method,
156     endpoint,
157     params,
158     prov_dict,
159     aws_api_version=DEFAULT_AWS_API_VERSION,
160     location=None,
161     product="ec2",
162     uri="/",
163     requesturl=None,
164     data="",
165     headers=None,
166     role_arn=None,
167     payload_hash=None,
168 ):
169     timenow = datetime.utcnow()
170     if role_arn is None:
171         access_key_id, secret_access_key, token = creds(prov_dict)
172     else:
173         access_key_id, secret_access_key, token = assumed_creds(
174             prov_dict, role_arn, location=location
175         )
176     if location is None:
177         location = get_region_from_metadata()
178     if location is None:
179         location = DEFAULT_LOCATION
180     params_with_headers = params.copy()
181     if product not in ("s3", "ssm"):
182         params_with_headers["Version"] = aws_api_version
183     keys = sorted(params_with_headers.keys())
184     values = list(map(params_with_headers.get, keys))
185     querystring = urllib.parse.urlencode(list(zip(keys, values))).replace("+", "%20")
186     amzdate = timenow.strftime("%Y%m%dT%H%M%SZ")
187     datestamp = timenow.strftime("%Y%m%d")
188     new_headers = {}
189     if isinstance(headers, dict):
190         new_headers = headers.copy()
191     if not payload_hash:
192         payload_hash = salt.utils.hashutils.sha256_digest(data)
193     new_headers["X-Amz-date"] = amzdate
194     new_headers["host"] = endpoint
195     new_headers["x-amz-content-sha256"] = payload_hash
196     a_canonical_headers = []
197     a_signed_headers = []
198     if token != "":
199         new_headers["X-Amz-security-token"] = token
200     for header in sorted(new_headers.keys(), key=str.lower):
201         lower_header = header.lower()
202         a_canonical_headers.append(
203             "{}:{}".format(lower_header, new_headers[header].strip())
204         )
205         a_signed_headers.append(lower_header)
206     canonical_headers = "\n".join(a_canonical_headers) + "\n"
207     signed_headers = ";".join(a_signed_headers)
208     algorithm = "AWS4-HMAC-SHA256"
209     canonical_request = "\n".join(
210         (method, uri, querystring, canonical_headers, signed_headers, payload_hash)
211     )
212     credential_scope = "/".join((datestamp, location, product, "aws4_request"))
213     string_to_sign = "\n".join(
214         (
215             algorithm,
216             amzdate,
217             credential_scope,
218             salt.utils.hashutils.sha256_digest(canonical_request),
219         )
220     )
221     signing_key = _sig_key(secret_access_key, datestamp, location, product)
222     signature = hmac.new(
223         signing_key, string_to_sign.encode("utf-8"), hashlib.sha256
224     ).hexdigest()
225     authorization_header = "{} Credential={}/{}, SignedHeaders={}, Signature={}".format(
226         algorithm,
227         access_key_id,
228         credential_scope,
229         signed_headers,
230         signature,
231     )
232     new_headers["Authorization"] = authorization_header
233     requesturl = "{}?{}".format(requesturl, querystring)
234     return new_headers, requesturl
235 def _sign(key, msg):
236     return hmac.new(key, msg.encode("utf-8"), hashlib.sha256).digest()
237 def _sig_key(key, date_stamp, regionName, serviceName):
238     kDate = _sign(("AWS4" + key).encode("utf-8"), date_stamp)
239     if regionName:
240         kRegion = _sign(kDate, regionName)
241         kService = _sign(kRegion, serviceName)
242     else:
243         kService = _sign(kDate, serviceName)
244     kSigning = _sign(kService, "aws4_request")
245     return kSigning
246 def query(
247     params=None,
248     setname=None,
249     requesturl=None,
250     location=None,
251     return_url=False,
252     return_root=False,
253     opts=None,
254     provider=None,
255     endpoint=None,
256     product="ec2",
257     sigver="2",
258 ):
259     if params is None:
260         params = {}
261     if opts is None:
262         opts = {}
263     function = opts.get("function", (None, product))
264     providers = opts.get("providers", {})
265     if provider is None:
266         prov_dict = providers.get(function[1], {}).get(product, {})
267         if prov_dict:
268             driver = list(list(prov_dict.keys()))[0]
269             provider = providers.get(driver, product)
270     else:
271         prov_dict = providers.get(provider, {}).get(product, {})
272     service_url = prov_dict.get("service_url", "amazonaws.com")
273     if not location:
274         location = get_location(opts, prov_dict)
275     if endpoint is None:
276         if not requesturl:
277             endpoint = prov_dict.get(
278                 "endpoint", "{}.{}.{}".format(product, location, service_url)
279             )
280             requesturl = "https://{}/".format(endpoint)
281         else:
282             endpoint = urllib.parse.urlparse(requesturl).netloc
283             if endpoint == "":
284                 endpoint_err = (
285                     "Could not find a valid endpoint in the "
286                     "requesturl: {}. Looking for something "
287                     "like https://some.aws.endpoint/?args".format(requesturl)
288                 )
289                 log.error(endpoint_err)
290                 if return_url is True:
291                     return {"error": endpoint_err}, requesturl
292                 return {"error": endpoint_err}
293     log.debug("Using AWS endpoint: %s", endpoint)
294     method = "GET"
295     aws_api_version = prov_dict.get(
296         "aws_api_version",
297         prov_dict.get("{}_api_version".format(product), DEFAULT_AWS_API_VERSION),
298     )
299     if not prov_dict.get("id", None):
300         prov_dict["id"] = providers.get(provider, {}).get("ec2", {}).get("id", {})
301         prov_dict["key"] = providers.get(provider, {}).get("ec2", {}).get("key", {})
302     if sigver == "4":
303         headers, requesturl = sig4(
304             method,
305             endpoint,
306             params,
307             prov_dict,
308             aws_api_version,
309             location,
310             product,
311             requesturl=requesturl,
312         )
313         params_with_headers = {}
314     else:
315         params_with_headers = sig2(method, endpoint, params, prov_dict, aws_api_version)
316         headers = {}
317     attempts = 0
318     while attempts &lt; AWS_MAX_RETRIES:
319         log.debug("AWS Request: %s", requesturl)
320         log.trace("AWS Request Parameters: %s", params_with_headers)
321         try:
322             result = requests.get(
323                 requesturl, headers=headers, params=params_with_headers
324             )
325             log.debug("AWS Response Status Code: %s", result.status_code)
326             log.trace("AWS Response Text: %s", result.text)
327             result.raise_for_status()
328             break
329         except requests.exceptions.HTTPError as exc:
330             root = ET.fromstring(exc.response.content)
331             data = xml.to_dict(root)
332             err_code = data.get("Errors", {}).get("Error", {}).get("Code", "")
333             if attempts &lt; AWS_MAX_RETRIES and err_code and err_code in AWS_RETRY_CODES:
334                 attempts += 1
335                 log.error(
336                     "AWS Response Status Code and Error: [%s %s] %s; "
337                     "Attempts remaining: %s",
338                     exc.response.status_code,
339                     exc,
340                     data,
341                     attempts,
342                 )
343                 sleep_exponential_backoff(attempts)
344                 continue
345             log.error(
346                 "AWS Response Status Code and Error: [%s %s] %s",
347                 exc.response.status_code,
348                 exc,
349                 data,
350             )
351             if return_url is True:
352                 return {"error": data}, requesturl
353             return {"error": data}
354     else:
355         log.error(
356             "AWS Response Status Code and Error: [%s %s] %s",
357             exc.response.status_code,
358             exc,
359             data,
360         )
361         if return_url is True:
362             return {"error": data}, requesturl
363         return {"error": data}
364     root = ET.fromstring(result.text)
365     items = root[1]
366     if return_root is True:
367         items = root
368     if setname:
369         for idx, item in enumerate(root):
370             comps = item.tag.split("}")
371             if comps[1] == setname:
372                 items = root[idx]
373     ret = []
374     for item in items:
375         ret.append(xml.to_dict(item))
376     if return_url is True:
377         return ret, requesturl
378     return ret
379 def get_region_from_metadata():
380     global __Location__
381     if __Location__ == "do-not-get-from-metadata":
382         log.debug(
383             "Previously failed to get AWS region from metadata. Not trying again."
384         )
385         return None
386     if __Location__ != "":
387         return __Location__
388     try:
389         result = requests.get(
390             "http://169.254.169.254/latest/dynamic/instance-identity/document",
391             proxies={"http": ""},
392             timeout=AWS_METADATA_TIMEOUT,
393         )
394     except requests.exceptions.RequestException:
395         log.warning("Failed to get AWS region from instance metadata.", exc_info=True)
396         __Location__ = "do-not-get-from-metadata"
397         return None
398     try:
399         region = result.json()["region"]
400         __Location__ = region
401         return __Location__
402     except (ValueError, KeyError):
403         log.warning("Failed to decode JSON from instance metadata.")
404         return None
405     return None
406 def get_location(opts=None, provider=None):
407     if opts is None:
408         opts = {}
409     ret = opts.get("location")
410     if ret is None and provider is not None:
411         ret = provider.get("location")
412     if ret is None:
413         ret = get_region_from_metadata()
414     if ret is None:
415         ret = DEFAULT_LOCATION
416     return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>jinja_3.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import atexit
3 import itertools
4 import logging
5 import os.path
6 import pipes
7 import pprint
8 import re
9 import time
10 import uuid
11 import warnings
12 from collections.abc import Hashable
13 from functools import wraps
14 from</b></font> xml.dom import minidom
15 from xml.etree.ElementTree import Element, SubElement, tostring
16 import jinja2
17 import salt.fileclient
18 import salt.utils.data
19 import salt.utils.files
20 import salt.utils.json
21 import salt.utils.stringutils
22 import salt.utils.url
23 import salt.utils.yaml
24 from jinja2 import BaseLoader, Markup, TemplateNotFound, nodes
25 from jinja2.environment import TemplateModule
26 from jinja2.exceptions import TemplateRuntimeError
27 from jinja2.ext import Extension
28 from salt.exceptions import TemplateError
29 from salt.utils.decorators.jinja import jinja_filter, jinja_global, jinja_test
30 from salt.utils.odict import OrderedDict
31 from salt.utils.versions import LooseVersion
32 log = logging.getLogger(__name__)
33 __all__ = ["SaltCacheLoader", "SerializerExtension"]
34 GLOBAL_UUID = uuid.UUID("91633EBF-1C86-5E33-935A-28061F4B480E")
35 JINJA_VERSION = LooseVersion(jinja2.__version__)
36 class SaltCacheLoader(BaseLoader):
37     """
38     A special jinja Template Loader for salt.
39     Requested templates are always fetched from the server
40     to guarantee that the file is up to date.
41     Templates are cached like regular salt states
42     and only loaded once per loader instance.
43     """
44     _cached_pillar_client = None
45     _cached_client = None
46     @classmethod
47     def shutdown(cls):
48         for attr in ("_cached_client", "_cached_pillar_client"):
49             client = getattr(cls, attr, None)
50             if client is not None:
51                 if hasattr(client, "destroy"):
52                     client.destroy()
53                 setattr(cls, attr, None)
54     def __init__(
55         self,
56         opts,
57         saltenv="base",
58         encoding="utf-8",
59         pillar_rend=False,
60         _file_client=None,
61     ):
62         self.opts = opts
63         self.saltenv = saltenv
64         self.encoding = encoding
65         self.pillar_rend = pillar_rend
66         if self.pillar_rend:
67             if saltenv not in self.opts["pillar_roots"]:
68                 self.searchpath = []
69             else:
70                 self.searchpath = opts["pillar_roots"][saltenv]
71         else:
72             self.searchpath = [os.path.join(opts["cachedir"], "files", saltenv)]
73         log.debug("Jinja search path: %s", self.searchpath)
74         self.cached = []
75         self._file_client = _file_client
76         self.file_client()
77     def file_client(self):
78         """
79         Return a file client. Instantiates on first call.
80         """
81         if self._file_client is None:
82             attr = "_cached_pillar_client" if self.pillar_rend else "_cached_client"
83             cached_client = getattr(self, attr, None)
84             if cached_client is None:
85                 cached_client = salt.fileclient.get_file_client(
86                     self.opts, self.pillar_rend
87                 )
88                 setattr(SaltCacheLoader, attr, cached_client)
89             self._file_client = cached_client
90         return self._file_client
91     def cache_file(self, template):
92         """
93         Cache a file from the salt master
94         """
95         saltpath = salt.utils.url.create(template)
96         self.file_client().get_file(saltpath, "", True, self.saltenv)
97     def check_cache(self, template):
98         """
99         Cache a file only once
100         """
101         if template not in self.cached:
102             self.cache_file(template)
103             self.cached.append(template)
104     def get_source(self, environment, template):
105         """
106         Salt-specific loader to find imported jinja files.
107         Jinja imports will be interpreted as originating from the top
108         of each of the directories in the searchpath when the template
109         name does not begin with './' or '../'.  When a template name
110         begins with './' or '../' then the import will be relative to
111         the importing file.
112         """
113         _template = template
114         if template.split("/", 1)[0] in ("..", "."):
115             is_relative = True
116         else:
117             is_relative = False
118         if is_relative:
119             if not environment or "tpldir" not in environment.globals:
120                 log.warning(
121                     'Relative path "%s" cannot be resolved without an environment',
122                     template,
123                 )
124                 raise TemplateNotFound(template)
125             base_path = environment.globals["tpldir"]
126             _template = os.path.normpath("/".join((base_path, _template)))
127             if _template.split("/", 1)[0] == "..":
128                 log.warning(
129                     'Discarded template path "%s": attempts to'
130                     " ascend outside of salt://",
131                     template,
132                 )
133                 raise TemplateNotFound(template)
134         self.check_cache(_template)
135         if environment and template:
136             tpldir = os.path.dirname(_template).replace("\\", "/")
137             tplfile = _template
138             if is_relative:
139                 tpldir = environment.globals.get("tpldir", tpldir)
140                 tplfile = template
141             tpldata = {
142                 "tplfile": tplfile,
143                 "tpldir": "." if tpldir == "" else tpldir,
144                 "tpldot": tpldir.replace("/", "."),
145             }
146             environment.globals.update(tpldata)
147         for spath in self.searchpath:
148             filepath = os.path.join(spath, _template)
149             try:
150                 with salt.utils.files.fopen(filepath, "rb") as ifile:
151                     contents = ifile.read().decode(self.encoding)
152                     mtime = os.path.getmtime(filepath)
153                     def uptodate():
154                         try:
155                             return os.path.getmtime(filepath) == mtime
156                         except OSError:
157                             return False
158                     return contents, filepath, uptodate
159             except OSError:
160                 continue
161         raise TemplateNotFound(template)
162 atexit.register(SaltCacheLoader.shutdown)
163 class PrintableDict(OrderedDict):
164     """
165     Ensures that dict str() and repr() are YAML friendly.
166     .. code-block:: python
167         mapping = OrderedDict([('a', 'b'), ('c', None)])
168         print mapping
169         decorated = PrintableDict(mapping)
170         print decorated
171     """
172     def __str__(self):
173         output = []
174         for key, value in self.items():
175             if isinstance(value, str):
176                 output.append("{!r}: {!r}".format(key, value))
177             else:
178                 output.append("{!r}: {!s}".format(key, value))
179         return "{" + ", ".join(output) + "}"
180     def __repr__(self):  # pylint: disable=W0221
181         output = []
182         for key, value in self.items():
183             output.append("{!r}: {!r}".format(key, value))
184         return "{" + ", ".join(output) + "}"
185 @jinja_global("raise")
186 def jinja_raise(msg):
187     raise TemplateError(msg)
188 @jinja_test("match")
189 def test_match(txt, rgx, ignorecase=False, multiline=False):
190     flag = 0
191     if ignorecase:
192         flag |= re.I
193     if multiline:
194         flag |= re.M
195     compiled_rgx = re.compile(rgx, flag)
196     return True if compiled_rgx.match(txt) else False
197 @jinja_test("equalto")
198 def test_equalto(value, other):
199     return value == other
200 @jinja_filter("skip")
201 def skip_filter(data):
202     """
203     Suppress data output
204     .. code-block:: yaml
205         {% my_string = "foo" %}
206         {{ my_string|skip }}
207     will be rendered as empty string,
208     """
209     return ""
210 @jinja_filter("sequence")
211 def ensure_sequence_filter(data):
212     """
213     Ensure sequenced data.
214     **sequence**
215         ensure that parsed data is a sequence
216     .. code-block:: jinja
217         {% set my_string = "foo" %}
218         {% set my_list = ["bar", ] %}
219         {% set my_dict = {"baz": "qux"} %}
220         {{ my_string|sequence|first }}
221         {{ my_list|sequence|first }}
222         {{ my_dict|sequence|first }}
223     will be rendered as:
224     .. code-block:: yaml
225         foo
226         bar
227         baz
228     """
229     if not isinstance(data, (list, tuple, set, dict)):
230         return [data]
231     return data
232 @jinja_filter("to_bool")
233 def to_bool(val):
234     """
235     Returns the logical value.
236     .. code-block:: jinja
237         {{ 'yes' | to_bool }}
238     will be rendered as:
239     .. code-block:: text
240         True
241     """
242     if val is None:
243         return False
244     if isinstance(val, bool):
245         return val
246     if isinstance(val, (str, (str,))):
247         return val.lower() in ("yes", "1", "true")
248     if isinstance(val, int):
249         return val &gt; 0
250     if not isinstance(val, Hashable):
251         return len(val) &gt; 0
252     return False
253 @jinja_filter("indent")
254 def indent(s, width=4, first=False, blank=False, indentfirst=None):
255     """
256     A ported version of the "indent" filter containing a fix for indenting Markup
257     objects. If the minion has Jinja version 2.11 or newer, the "indent" filter
258     from upstream will be used, and this one will be ignored.
259     """
260     if indentfirst is not None:
261         warnings.warn(
262             "The 'indentfirst' argument is renamed to 'first' and will"
263             " be removed in Jinja 3.0.",
264             DeprecationWarning,
265             stacklevel=2,
266         )
267         first = indentfirst
268     indention = " " * width
269     newline = "\n"
270     if isinstance(s, Markup):
271         indention = Markup(indention)
272         newline = Markup(newline)
273     s += newline  # this quirk is necessary for splitlines method
274     if blank:
275         rv = (newline + indention).join(s.splitlines())
276     else:
277         lines = s.splitlines()
278         rv = lines.pop(0)
279         if lines:
280             rv += newline + newline.join(
281                 indention + line if line else line for line in lines
282             )
283     if first:
284         rv = indention + rv
285     return rv
286 @jinja_filter("tojson")
287 def tojson(val, indent=None, **options):
288     """
289     Implementation of tojson filter (only present in Jinja 2.9 and later).
290     Unlike the Jinja built-in filter, this allows arbitrary options to be
291     passed in to the underlying JSON library.
292     """
293     options.setdefault("ensure_ascii", True)
294     if indent is not None:
295         options["indent"] = indent
296     return (
297         salt.utils.json.dumps(val, **options)
298         .replace("&lt;", "\\u003c")
299         .replace("&gt;", "\\u003e")
300         .replace("&amp;", "\\u0026")
301         .replace("'", "\\u0027")
302     )
303 @jinja_filter("quote")
304 def quote(txt):
305     """
306     Wraps a text around quotes.
307     .. code-block:: jinja
308         {% set my_text = 'my_text' %}
309         {{ my_text | quote }}
310     will be rendered as:
311     .. code-block:: text
312         'my_text'
313     """
314     return pipes.quote(txt)
315 @jinja_filter()
316 def regex_escape(value):
317     return re.escape(value)
318 @jinja_filter("regex_search")
319 def regex_search(txt, rgx, ignorecase=False, multiline=False):
320     """
321     Searches for a pattern in the text.
322     .. code-block:: jinja
323         {% set my_text = 'abcd' %}
324         {{ my_text | regex_search('^(.*)BC(.*)$', ignorecase=True) }}
325     will be rendered as:
326     .. code-block:: text
327         ('a', 'd')
328     """
329     flag = 0
330     if ignorecase:
331         flag |= re.I
332     if multiline:
333         flag |= re.M
334     obj = re.search(rgx, txt, flag)
335     if not obj:
336         return
337     return obj.groups()
338 @jinja_filter("regex_match")
339 def regex_match(txt, rgx, ignorecase=False, multiline=False):
340     """
341     Searches for a pattern in the text.
342     .. code-block:: jinja
343         {% set my_text = 'abcd' %}
344         {{ my_text | regex_match('^(.*)BC(.*)$', ignorecase=True) }}
345     will be rendered as:
346     .. code-block:: text
347         ('a', 'd')
348     """
349     flag = 0
350     if ignorecase:
351         flag |= re.I
352     if multiline:
353         flag |= re.M
354     obj = re.match(rgx, txt, flag)
355     if not obj:
356         return
357     return obj.groups()
358 @jinja_filter("regex_replace")
359 def regex_replace(txt, rgx, val, ignorecase=False, multiline=False):
360     r"""
361     Searches for a pattern and replaces with a sequence of characters.
362     .. code-block:: jinja
363         {% set my_text = 'lets replace spaces' %}
364         {{ my_text | regex_replace('\s+', '__') }}
365     will be rendered as:
366     .. code-block:: text
367         lets__replace__spaces
368     """
369     flag = 0
370     if ignorecase:
371         flag |= re.I
372     if multiline:
373         flag |= re.M
374     compiled_rgx = re.compile(rgx, flag)
375     return compiled_rgx.sub(val, txt)
376 @jinja_filter("uuid")
377 def uuid_(val):
378     """
379     Returns a UUID corresponding to the value passed as argument.
380     .. code-block:: jinja
381         {{ 'example' | uuid }}
382     will be rendered as:
383     .. code-block:: text
384         f4efeff8-c219-578a-bad7-3dc280612ec8
385     """
386     return str(uuid.uuid5(GLOBAL_UUID, salt.utils.stringutils.to_str(val)))
387 @jinja_filter()
388 def unique(values):
389     """
390     Removes duplicates from a list.
391     .. code-block:: jinja
392         {% set my_list = ['a', 'b', 'c', 'a', 'b'] -%}
393         {{ my_list | unique }}
394     will be rendered as:
395     .. code-block:: text
396         ['a', 'b', 'c']
397     """
398     ret = None
399     if isinstance(values, Hashable):
400         ret = set(values)
401     else:
402         ret = []
403         for value in values:
404             if value not in ret:
405                 ret.append(value)
406     return ret
407 @jinja_filter("min")
408 def lst_min(obj):
409     """
410     Returns the min value.
411     .. code-block:: jinja
412         {% set my_list = [1,2,3,4] -%}
413         {{ my_list | min }}
414     will be rendered as:
415     .. code-block:: text
416         1
417     """
418     return min(obj)
419 @jinja_filter("max")
420 def lst_max(obj):
421     """
422     Returns the max value.
423     .. code-block:: jinja
424         {% my_list = [1,2,3,4] -%}
425         {{ set my_list | max }}
426     will be rendered as:
427     .. code-block:: text
428         4
429     """
430     return max(obj)
431 @jinja_filter("avg")
432 def lst_avg(lst):
433     """
434     Returns the average value of a list.
435     .. code-block:: jinja
436         {% my_list = [1,2,3,4] -%}
437         {{ set my_list | avg }}
438     will be rendered as:
439     .. code-block:: yaml
440         2.5
441     """
442     if not isinstance(lst, Hashable):
443         return float(sum(lst) / len(lst))
444     return float(lst)
445 @jinja_filter("union")
446 def union(lst1, lst2):
447     """
448     Returns the union of two lists.
449     .. code-block:: jinja
450         {% my_list = [1,2,3,4] -%}
451         {{ set my_list | union([2, 4, 6]) }}
452     will be rendered as:
453     .. code-block:: text
454         [1, 2, 3, 4, 6]
455     """
456     if isinstance(lst1, Hashable) and isinstance(lst2, Hashable):
457         return set(lst1) | set(lst2)
458     return unique(lst1 + lst2)
459 @jinja_filter("intersect")
460 def intersect(lst1, lst2):
461     """
462     Returns the intersection of two lists.
463     .. code-block:: jinja
464         {% my_list = [1,2,3,4] -%}
465         {{ set my_list | intersect([2, 4, 6]) }}
466     will be rendered as:
467     .. code-block:: text
468         [2, 4]
469     """
470     if isinstance(lst1, Hashable) and isinstance(lst2, Hashable):
471         return set(lst1) &amp; set(lst2)
472     return unique([ele for ele in lst1 if ele in lst2])
473 @jinja_filter("difference")
474 def difference(lst1, lst2):
475     """
476     Returns the difference of two lists.
477     .. code-block:: jinja
478         {% my_list = [1,2,3,4] -%}
479         {{ set my_list | difference([2, 4, 6]) }}
480     will be rendered as:
481     .. code-block:: text
482         [1, 3, 6]
483     """
484     if isinstance(lst1, Hashable) and isinstance(lst2, Hashable):
485         return set(lst1) - set(lst2)
486     return unique([ele for ele in lst1 if ele not in lst2])
487 @jinja_filter("symmetric_difference")
488 def symmetric_difference(lst1, lst2):
489     """
490     Returns the symmetric difference of two lists.
491     .. code-block:: jinja
492         {% my_list = [1,2,3,4] -%}
493         {{ set my_list | symmetric_difference([2, 4, 6]) }}
494     will be rendered as:
495     .. code-block:: text
496         [1, 3]
497     """
498     if isinstance(lst1, Hashable) and isinstance(lst2, Hashable):
499         return set(lst1) ^ set(lst2)
500     return unique(
501         [ele for ele in union(lst1, lst2) if ele not in intersect(lst1, lst2)]
502     )
503 @jinja_filter("method_call")
504 def method_call(obj, f_name, *f_args, **f_kwargs):
505     return getattr(obj, f_name, lambda *args, **kwargs: None)(*f_args, **f_kwargs)
506 @jinja2.contextfunction
507 def show_full_context(ctx):
508     return salt.utils.data.simple_types_filter(
509         {key: value for key, value in ctx.items()}
510     )
511 class SerializerExtension(Extension):
512     '''
513     Yaml and Json manipulation.
514     **Format filters**
515     Allows jsonifying or yamlifying any data structure. For example, this dataset:
516     .. code-block:: python
517         data = {
518             'foo': True,
519             'bar': 42,
520             'baz': [1, 2, 3],
521             'qux': 2.0
522         }
523     .. code-block:: jinja
524         yaml = {{ data|yaml }}
525         json = {{ data|json }}
526         python = {{ data|python }}
527         xml  = {{ {'root_node': data}|xml }}
528     will be rendered as::
529         yaml = {bar: 42, baz: [1, 2, 3], foo: true, qux: 2.0}
530         json = {"baz": [1, 2, 3], "foo": true, "bar": 42, "qux": 2.0}
531         python = {'bar': 42, 'baz': [1, 2, 3], 'foo': True, 'qux': 2.0}
532         xml = """&lt;&lt;?xml version="1.0" ?&gt;
533                  &lt;root_node bar="42" foo="True" qux="2.0"&gt;
534                   &lt;baz&gt;1&lt;/baz&gt;
535                   &lt;baz&gt;2&lt;/baz&gt;
536                   &lt;baz&gt;3&lt;/baz&gt;
537                  &lt;/root_node&gt;"""
538     The yaml filter takes an optional flow_style parameter to control the
539     default-flow-style parameter of the YAML dumper.
540     .. code-block:: jinja
541         {{ data|yaml(False) }}
542     will be rendered as:
543     .. code-block:: yaml
544         bar: 42
545         baz:
546           - 1
547           - 2
548           - 3
549         foo: true
550         qux: 2.0
551     **Load filters**
552     Strings and variables can be deserialized with **load_yaml** and
553     **load_json** tags and filters. It allows one to manipulate data directly
554     in templates, easily:
555     .. code-block:: jinja
556         {%- set yaml_src = "{foo: it works}"|load_yaml %}
557         {%- set json_src = "{'bar': 'for real'}"|load_json %}
558         Dude, {{ yaml_src.foo }} {{ json_src.bar }}!
559     will be rendered as::
560         Dude, it works for real!
561     **Load tags**
562     Salt implements ``load_yaml`` and ``load_json`` tags. They work like
563     the `import tag`_, except that the document is also deserialized.
564     Syntaxes are ``{% load_yaml as [VARIABLE] %}[YOUR DATA]{% endload %}``
565     and ``{% load_json as [VARIABLE] %}[YOUR DATA]{% endload %}``
566     For example:
567     .. code-block:: jinja
568         {% load_yaml as yaml_src %}
569             foo: it works
570         {% endload %}
571         {% load_json as json_src %}
572             {
573                 "bar": "for real"
574             }
575         {% endload %}
576         Dude, {{ yaml_src.foo }} {{ json_src.bar }}!
577     will be rendered as::
578         Dude, it works for real!
579     **Import tags**
580     External files can be imported and made available as a Jinja variable.
581     .. code-block:: jinja
582         {% import_yaml "myfile.yml" as myfile %}
583         {% import_json "defaults.json" as defaults %}
584         {% import_text "completeworksofshakespeare.txt" as poems %}
585     **Catalog**
586     ``import_*`` and ``load_*`` tags will automatically expose their
587     target variable to import. This feature makes catalog of data to
588     handle.
589     for example:
590     .. code-block:: jinja
591         {% load_yaml as var1 %}
592             foo: it works
593         {% endload %}
594         {% load_yaml as var2 %}
595             bar: for real
596         {% endload %}
597     .. code-block:: jinja
598         {% from "doc1.sls" import var1, var2 as local2 %}
599         {{ var1.foo }} {{ local2.bar }}
600     ** Escape Filters **
601     .. versionadded:: 2017.7.0
602     Allows escaping of strings so they can be interpreted literally by another
603     function.
604     For example:
605     .. code-block:: jinja
606         regex_escape = {{ 'https://example.com?foo=bar%20baz' | regex_escape }}
607     will be rendered as::
608         regex_escape = https\\:\\/\\/example\\.com\\?foo\\=bar\\%20baz
609     ** Set Theory Filters **
610     .. versionadded:: 2017.7.0
611     Performs set math using Jinja filters.
612     For example:
613     .. code-block:: jinja
614         unique = {{ ['foo', 'foo', 'bar'] | unique }}
615     will be rendered as::
616         unique = ['foo', 'bar']
617     ** Salt State Parameter Format Filters **
618     .. versionadded:: 3005
619     Renders a formatted multi-line YAML string from a Python dictionary. Each
620     key/value pair in the dictionary will be added as a single-key dictionary
621     to a list that will then be sent to the YAML formatter.
622     For example:
623     .. code-block:: jinja
624         {% set thing_params = {
625             "name": "thing",
626             "changes": True,
627             "warnings": "OMG! Stuff is happening!"
628            }
629         %}
630         thing:
631           test.configurable_test_state:
632             {{ thing_params | dict_to_sls_yaml_params | indent }}
633     will be rendered as::
634     .. code-block:: yaml
635         thing:
636           test.configurable_test_state:
637             - name: thing
638             - changes: true
639             - warnings: OMG! Stuff is happening!
640     .. _`import tag`: https://jinja.palletsprojects.com/en/2.11.x/templates/#import
641     '''
642     tags = {
643         "load_yaml",
644         "load_json",
645         "import_yaml",
646         "import_json",
647         "load_text",
648         "import_text",
649         "profile",
650     }
651     def __init__(self, environment):
652         super().__init__(environment)
653         self.environment.filters.update(
654             {
655                 "yaml": self.format_yaml,
656                 "json": self.format_json,
657                 "xml": self.format_xml,
658                 "python": self.format_python,
659                 "load_yaml": self.load_yaml,
660                 "load_json": self.load_json,
661                 "load_text": self.load_text,
662                 "dict_to_sls_yaml_params": self.dict_to_sls_yaml_params,
663                 "combinations": itertools.combinations,
664                 "combinations_with_replacement": itertools.combinations_with_replacement,
665                 "compress": itertools.compress,
666                 "permutations": itertools.permutations,
667                 "product": itertools.product,
668                 "zip": zip,
669                 "zip_longest": itertools.zip_longest,
670             }
671         )
672         if self.environment.finalize is None:
673             self.environment.finalize = self.finalizer
674         else:
675             finalizer = self.environment.finalize
676             @wraps(finalizer)
677             def wrapper(self, data):
678                 return finalizer(self.finalizer(data))
679             self.environment.finalize = wrapper
680     def finalizer(self, data):
681         """
682         Ensure that printed mappings are YAML friendly.
683         """
684         def explore(data):
685             if isinstance(data, (dict, OrderedDict)):
686                 return PrintableDict(
687                     [(key, explore(value)) for key, value in data.items()]
688                 )
689             elif isinstance(data, (list, tuple, set)):
690                 return data.__class__([explore(value) for value in data])
691             return data
692         return explore(data)
693     def format_json(self, value, sort_keys=True, indent=None):
694         json_txt = salt.utils.json.dumps(
695             value, sort_keys=sort_keys, indent=indent
696         ).strip()
697         try:
698             return Markup(json_txt)
699         except UnicodeDecodeError:
700             return Markup(salt.utils.stringutils.to_unicode(json_txt))
701     def format_yaml(self, value, flow_style=True):
702         yaml_txt = salt.utils.yaml.safe_dump(
703             value, default_flow_style=flow_style
704         ).strip()
705         if yaml_txt.endswith("\n..."):
706             yaml_txt = yaml_txt[: len(yaml_txt) - 4]
707         try:
708             return Markup(yaml_txt)
709         except UnicodeDecodeError:
710             return Markup(salt.utils.stringutils.to_unicode(yaml_txt))
711     def format_xml(self, value):
712         """Render a formatted multi-line XML string from a complex Python
713         data structure. Supports tag attributes and nested dicts/lists.
714         :param value: Complex data structure representing XML contents
715         :returns: Formatted XML string rendered with newlines and indentation
716         :rtype: str
717         """
718         def normalize_iter(value):
719             if isinstance(value, (list, tuple)):
720                 if isinstance(value[0], str):
721                     xmlval = value
722                 else:
723                     xmlval = []
724             elif isinstance(value, dict):
725                 xmlval = list(value.items())
726             else:
727                 raise TemplateRuntimeError(
728                     "Value is not a dict or list. Cannot render as XML"
729                 )
730             return xmlval
731         def recurse_tree(xmliter, element=None):
732             sub = None
733             for tag, attrs in xmliter:
734                 if isinstance(attrs, list):
735                     for attr in attrs:
736                         recurse_tree(((tag, attr),), element)
737                 elif element is not None:
738                     sub = SubElement(element, tag)
739                 else:
740                     sub = Element(tag)
741                 if isinstance(attrs, (str, int, bool, float)):
742                     sub.text = str(attrs)
743                     continue
744                 if isinstance(attrs, dict):
745                     sub.attrib = {
746                         attr: str(val)
747                         for attr, val in attrs.items()
748                         if not isinstance(val, (dict, list))
749                     }
750                 for tag, val in [
751                     item
752                     for item in normalize_iter(attrs)
753                     if isinstance(item[1], (dict, list))
754                 ]:
755                     recurse_tree(((tag, val),), sub)
756             return sub
757         return Markup(
758             minidom.parseString(
759                 tostring(recurse_tree(normalize_iter(value)))
760             ).toprettyxml(indent=" ")
761         )
762     def format_python(self, value):
763         return Markup(pprint.pformat(value).strip())
764     def load_yaml(self, value):
765         if isinstance(value, TemplateModule):
766             value = str(value)
767         try:
768             return salt.utils.data.decode(salt.utils.yaml.safe_load(value))
769         except salt.utils.yaml.YAMLError as exc:
770             msg = "Encountered error loading yaml: "
771             try:
772                 line = exc.problem_mark.line + 1
773                 buf = exc.problem_mark.buffer
774                 problem = exc.problem
775             except AttributeError:
776                 msg += str(exc)
777             else:
778                 msg += "{}\n".format(problem)
779                 msg += salt.utils.stringutils.get_context(
780                     buf, line, marker="    &lt;======================"
781                 )
782             raise TemplateRuntimeError(msg)
783         except AttributeError:
784             raise TemplateRuntimeError("Unable to load yaml from {}".format(value))
785     def load_json(self, value):
786         if isinstance(value, TemplateModule):
787             value = str(value)
788         try:
789             return salt.utils.json.loads(value)
790         except (ValueError, TypeError, AttributeError):
791             raise TemplateRuntimeError("Unable to load json from {}".format(value))
792     def load_text(self, value):
793         if isinstance(value, TemplateModule):
794             value = str(value)
795         return value
796     _load_parsers = {"load_yaml", "load_json", "load_text"}
797     _import_parsers = {"import_yaml", "import_json", "import_text"}
798     def parse(self, parser):
799         if parser.stream.current.value in self._load_parsers:
800             return self.parse_load(parser)
801         elif parser.stream.current.value in self._import_parsers:
802             return self.parse_import(
803                 parser, parser.stream.current.value.split("_", 1)[1]
804             )
805         elif parser.stream.current.value == "profile":
806             return self.parse_profile(parser)
807         parser.fail(
808             "Unknown format " + parser.stream.current.value,
809             parser.stream.current.lineno,
810         )
811     def parse_profile(self, parser):
812         lineno = next(parser.stream).lineno
813         parser.stream.expect("name:as")
814         label = parser.parse_expression()
815         body = parser.parse_statements(["name:endprofile"], drop_needle=True)
816         return self._parse_profile_block(parser, label, "profile block", body, lineno)
817     def _create_profile_id(self, parser):
818         return "_salt_profile_{}".format(parser.free_identifier().name)
819     def _profile_start(self, label, source):
820         return (label, source, time.time())
821     def _profile_end(self, label, source, previous_time):
822         log.profile(
823             "Time (in seconds) to render %s '%s': %s",
824             source,
825             label,
826             time.time() - previous_time,
827         )
828     def _parse_profile_block(self, parser, label, source, body, lineno):
829         ret = (
830             [
831                 nodes<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.Assign(
832                     nodes.Name(profile_id, "store").set_lineno(lineno),
833                     self.call_method(
834                         "_profile_start",
835                         dyn_args=nodes.List([label</b></font>, nodes.Const(source)]).set_lineno(
836                             lineno
837                         ),
838                     ).set_lineno(lineno),
839                 ).set_lineno(lineno),
840             ]
841             + body
842             + [
843                 nodes.ExprStmt(
844                     self.call_method(
845                         "_profile_end", dyn_args=nodes.Name(profile_id, "load")
846                     ),
847                 ).set_lineno(lineno),
848             ]
849         )
850         return ret
851     def parse_load(self, parser):
852         filter_name = parser.stream.current.value
853         lineno = next(parser.stream).lineno
854         if filter_name not in self.environment.filters:
855             parser.fail("Unable to parse {}".format(filter_name), lineno)
856         parser.stream.expect("name:as")
857         target = parser.parse_assign_target()
858         macro_name = "_" + parser.free_identifier().name
859         macro_body = parser.parse_statements(("name:endload",), drop_needle=True)
860         return [
861             nodes.Macro(macro_name, [], [], macro_body).set_lineno(lineno),
862             nodes.Assign(
863                 target,
864                 nodes.Filter(
865                     nodes.Call(
866                         nodes.Name(macro_name, "load").set_lineno(lineno),
867                         [],
868                         [],
869                         None,
870                         None,
871                     ).set_lineno(lineno),
872                     filter_name,
873                     [],
874                     [],
875                     None,
876                     None,
877                 ).set_lineno(lineno),
878             ).set_lineno(lineno),
879         ]
880     def parse_import(self, parser, converter):
881         import_node = parser.parse_import()
882         target = import_node.target
883         lineno = import_node.lineno
884         body = [
885             import_node,
886             nodes.Assign(
887                 nodes.Name(target, "store").set_lineno(lineno),
888                 nodes.Filter(
889                     nodes.Name(target, "load").set_lineno(lineno),
890                     "load_{}".format(converter),
891                     [],
892                     [],
893                     None,
894                     None,
895                 ).set_lineno(lineno),
896             ).set_lineno(lineno),
897         ]
898         return self._parse_profile_block(
899             parser, import_node.template, "import_{}".format(converter), body, lineno
900         )
901     def dict_to_sls_yaml_params(self, value, flow_style=False):
902         """
903         .. versionadded:: 3005
904         Render a formatted multi-line YAML string from a Python dictionary. Each
905         key/value pair in the dictionary will be added as a single-key dictionary
906         to a list that will then be sent to the YAML formatter.
907         :param value: Python dictionary representing Salt state parameters
908         :param flow_style: Setting flow_style to False will enforce indentation
909                            mode
910         :returns: Formatted SLS YAML string rendered with newlines and
911                   indentation
912         """
913         return self.format_yaml(
914             [{key: val} for key, val in value.items()], flow_style=flow_style
915         )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
