<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for aws.py & jinja_3.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for aws.py & jinja_3.py
      </h3>
      <h1 align="center">
        2.6%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>aws.py (3.3377838%)<TH>jinja_3.py (2.1349275%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match135388-0.html#0',2,'match135388-1.html#0',3)" NAME="0">(11-24)<TD><A HREF="javascript:ZweiFrames('match135388-0.html#0',2,'match135388-1.html#0',3)" NAME="0">(6-18)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match135388-0.html#1',2,'match135388-1.html#1',3)" NAME="1">(166-172)<TD><A HREF="javascript:ZweiFrames('match135388-0.html#1',2,'match135388-1.html#1',3)" NAME="1">(1138-1142)</A><TD ALIGN=center><FONT COLOR="#eb0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>aws.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Connection library for AWS

.. versionadded:: 2015.5.0

This is a base library used by a number of AWS services.

<A NAME="0"></A>:depends: requests
&quot;&quot;&quot;

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match135388-1.html#0',3,'match135388-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import binascii
import hashlib
import hmac
import logging
import random
import re
import time
import urllib.parse
import xml.etree.ElementTree as ET
from datetime import datetime

import salt.config
import salt.utils.hashutils
import</B></FONT> salt.utils.xmlutil as xml

try:
    import requests

    HAS_REQUESTS = True  # pylint: disable=W0612
except ImportError:
    HAS_REQUESTS = False  # pylint: disable=W0612

# pylint: enable=import-error,redefined-builtin,no-name-in-module

log = logging.getLogger(__name__)
DEFAULT_LOCATION = &quot;us-east-1&quot;
DEFAULT_AWS_API_VERSION = &quot;2016-11-15&quot;
AWS_RETRY_CODES = [
    &quot;RequestLimitExceeded&quot;,
    &quot;InsufficientInstanceCapacity&quot;,
    &quot;InternalError&quot;,
    &quot;Unavailable&quot;,
    &quot;InsufficientAddressCapacity&quot;,
    &quot;InsufficientReservedInstanceCapacity&quot;,
]
AWS_METADATA_TIMEOUT = 3.05

AWS_MAX_RETRIES = 7

IROLE_CODE = &quot;use-instance-role-credentials&quot;
__AccessKeyId__ = &quot;&quot;
__SecretAccessKey__ = &quot;&quot;
__Token__ = &quot;&quot;
__Expiration__ = &quot;&quot;
__Location__ = &quot;&quot;
__AssumeCache__ = {}


def sleep_exponential_backoff(attempts):
    &quot;&quot;&quot;
    backoff an exponential amount of time to throttle requests
    during &quot;API Rate Exceeded&quot; failures as suggested by the AWS documentation here:
    https://docs.aws.amazon.com/AWSEC2/latest/APIReference/query-api-troubleshooting.html
    and also here:
    https://docs.aws.amazon.com/general/latest/gr/api-retries.html
    Failure to implement this approach results in a failure rate of &gt;30% when using salt-cloud with
    &quot;--parallel&quot; when creating 50 or more instances with a fixed delay of 2 seconds.
    A failure rate of &gt;10% is observed when using the salt-api with an asynchronous client
    specified (runner_async).
    &quot;&quot;&quot;
    time.sleep(random.uniform(1, 2 ** attempts))


def creds(provider):
    &quot;&quot;&quot;
    Return the credentials for AWS signing.  This could be just the id and key
    specified in the provider configuration, or if the id or key is set to the
    literal string 'use-instance-role-credentials' creds will pull the instance
    role credentials from the meta data, cache them, and provide them instead.
    &quot;&quot;&quot;
    # Declare globals
    global __AccessKeyId__, __SecretAccessKey__, __Token__, __Expiration__

    ret_credentials = ()

    # if id or key is 'use-instance-role-credentials', pull them from meta-data
    ## if needed
    if provider[&quot;id&quot;] == IROLE_CODE or provider[&quot;key&quot;] == IROLE_CODE:
        # Check to see if we have cache credentials that are still good
        if __Expiration__ != &quot;&quot;:
            timenow = datetime.utcnow()
            timestamp = timenow.strftime(&quot;%Y-%m-%dT%H:%M:%SZ&quot;)
            if timestamp &lt; __Expiration__:
                # Current timestamp less than expiration fo cached credentials
                return __AccessKeyId__, __SecretAccessKey__, __Token__
        # We don't have any cached credentials, or they are expired, get them

        # Connections to instance meta-data must fail fast and never be proxied
        try:
            result = requests.get(
                &quot;http://169.254.169.254/latest/meta-data/iam/security-credentials/&quot;,
                proxies={&quot;http&quot;: &quot;&quot;},
                timeout=AWS_METADATA_TIMEOUT,
            )
            result.raise_for_status()
            role = result.text
        except (requests.exceptions.HTTPError, requests.exceptions.ConnectionError):
            return provider[&quot;id&quot;], provider[&quot;key&quot;], &quot;&quot;

        try:
            result = requests.get(
                &quot;http://169.254.169.254/latest/meta-data/iam/security-credentials/{}&quot;.format(
                    role
                ),
                proxies={&quot;http&quot;: &quot;&quot;},
                timeout=AWS_METADATA_TIMEOUT,
            )
            result.raise_for_status()
        except (requests.exceptions.HTTPError, requests.exceptions.ConnectionError):
            return provider[&quot;id&quot;], provider[&quot;key&quot;], &quot;&quot;

        data = result.json()
        __AccessKeyId__ = data[&quot;AccessKeyId&quot;]
        __SecretAccessKey__ = data[&quot;SecretAccessKey&quot;]
        __Token__ = data[&quot;Token&quot;]
        __Expiration__ = data[&quot;Expiration&quot;]

        ret_credentials = __AccessKeyId__, __SecretAccessKey__, __Token__
    else:
        ret_credentials = provider[&quot;id&quot;], provider[&quot;key&quot;], &quot;&quot;

    if provider.get(&quot;role_arn&quot;) is not None:
        provider_shadow = provider.copy()
        provider_shadow.pop(&quot;role_arn&quot;, None)
        log.info(&quot;Assuming the role: %s&quot;, provider.get(&quot;role_arn&quot;))
        ret_credentials = assumed_creds(
            provider_shadow, role_arn=provider.get(&quot;role_arn&quot;), location=&quot;us-east-1&quot;
        )

    return ret_credentials


def sig2(method, endpoint, params, provider, aws_api_version):
    &quot;&quot;&quot;
    Sign a query against AWS services using Signature Version 2 Signing
    Process. This is documented at:

    http://docs.aws.amazon.com/general/latest/gr/signature-version-2.html
    &quot;&quot;&quot;
    timenow = datetime.utcnow()
    timestamp = timenow.strftime(&quot;%Y-%m-%dT%H:%M:%SZ&quot;)

    # Retrieve access credentials from meta-data, or use provided
    access_key_id, secret_access_key, token = creds(provider)

    params_with_headers = params.copy()
    params_with_headers[&quot;AWSAccessKeyId&quot;] = access_key_id
    params_with_headers[&quot;SignatureVersion&quot;] = &quot;2&quot;
    params_with_headers[&quot;SignatureMethod&quot;] = &quot;HmacSHA256&quot;
    params_with_headers[&quot;Timestamp&quot;] = &quot;{}&quot;.format(timestamp)
    params_with_headers[&quot;Version&quot;] = aws_api_version
    keys = sorted(params_with_headers.keys())
<A NAME="1"></A>    values = list(list(map(params_with_headers.get, keys)))
    querystring = urllib.parse.urlencode(list(zip(keys, values)))

    canonical = &quot;{}\n{}\n/\n{}&quot;<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match135388-1.html#1',3,'match135388-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.format(
        method.encode(&quot;utf-8&quot;),
        endpoint.encode(&quot;utf-8&quot;),
        querystring.encode(&quot;utf-8&quot;),
    )

    hashed = hmac.new(secret_access_key, canonical, hashlib.</B></FONT>sha256)
    sig = binascii.b2a_base64(hashed.digest())
    params_with_headers[&quot;Signature&quot;] = sig.strip()

    # Add in security token if we have one
    if token != &quot;&quot;:
        params_with_headers[&quot;SecurityToken&quot;] = token

    return params_with_headers


def assumed_creds(prov_dict, role_arn, location=None):
    valid_session_name_re = re.compile(&quot;[^a-z0-9A-Z+=,.@-]&quot;)

    # current time in epoch seconds
    now = time.mktime(datetime.utcnow().timetuple())

    for key, creds in __AssumeCache__.items():
        if (creds[&quot;Expiration&quot;] - now) &lt;= 120:
            __AssumeCache__.delete(key)

    if role_arn in __AssumeCache__:
        c = __AssumeCache__[role_arn]
        return c[&quot;AccessKeyId&quot;], c[&quot;SecretAccessKey&quot;], c[&quot;SessionToken&quot;]

    version = &quot;2011-06-15&quot;
    session_name = valid_session_name_re.sub(
        &quot;&quot;, salt.config.get_id({&quot;root_dir&quot;: None})[0]
    )[0:63]

    headers, requesturl = sig4(
        &quot;GET&quot;,
        &quot;sts.amazonaws.com&quot;,
        params={
            &quot;Version&quot;: version,
            &quot;Action&quot;: &quot;AssumeRole&quot;,
            &quot;RoleSessionName&quot;: session_name,
            &quot;RoleArn&quot;: role_arn,
            &quot;Policy&quot;: (
                '{&quot;Version&quot;:&quot;2012-10-17&quot;,&quot;Statement&quot;:[{&quot;Sid&quot;:&quot;Stmt1&quot;,'
                ' &quot;Effect&quot;:&quot;Allow&quot;,&quot;Action&quot;:&quot;*&quot;,&quot;Resource&quot;:&quot;*&quot;}]}'
            ),
            &quot;DurationSeconds&quot;: &quot;3600&quot;,
        },
        aws_api_version=version,
        data=&quot;&quot;,
        uri=&quot;/&quot;,
        prov_dict=prov_dict,
        product=&quot;sts&quot;,
        location=location,
        requesturl=&quot;https://sts.amazonaws.com/&quot;,
    )
    headers[&quot;Accept&quot;] = &quot;application/json&quot;
    result = requests.request(&quot;GET&quot;, requesturl, headers=headers, data=&quot;&quot;, verify=True)

    if result.status_code &gt;= 400:
        log.info(&quot;AssumeRole response: %s&quot;, result.content)
    result.raise_for_status()
    resp = result.json()

    data = resp[&quot;AssumeRoleResponse&quot;][&quot;AssumeRoleResult&quot;][&quot;Credentials&quot;]
    __AssumeCache__[role_arn] = data
    return data[&quot;AccessKeyId&quot;], data[&quot;SecretAccessKey&quot;], data[&quot;SessionToken&quot;]


def sig4(
    method,
    endpoint,
    params,
    prov_dict,
    aws_api_version=DEFAULT_AWS_API_VERSION,
    location=None,
    product=&quot;ec2&quot;,
    uri=&quot;/&quot;,
    requesturl=None,
    data=&quot;&quot;,
    headers=None,
    role_arn=None,
    payload_hash=None,
):
    &quot;&quot;&quot;
    Sign a query against AWS services using Signature Version 4 Signing
    Process. This is documented at:

    http://docs.aws.amazon.com/general/latest/gr/sigv4_signing.html
    http://docs.aws.amazon.com/general/latest/gr/sigv4-signed-request-examples.html
    http://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html
    &quot;&quot;&quot;
    timenow = datetime.utcnow()

    # Retrieve access credentials from meta-data, or use provided
    if role_arn is None:
        access_key_id, secret_access_key, token = creds(prov_dict)
    else:
        access_key_id, secret_access_key, token = assumed_creds(
            prov_dict, role_arn, location=location
        )

    if location is None:
        location = get_region_from_metadata()
    if location is None:
        location = DEFAULT_LOCATION

    params_with_headers = params.copy()
    if product not in (&quot;s3&quot;, &quot;ssm&quot;):
        params_with_headers[&quot;Version&quot;] = aws_api_version
    keys = sorted(params_with_headers.keys())
    values = list(map(params_with_headers.get, keys))
    querystring = urllib.parse.urlencode(list(zip(keys, values))).replace(&quot;+&quot;, &quot;%20&quot;)

    amzdate = timenow.strftime(&quot;%Y%m%dT%H%M%SZ&quot;)
    datestamp = timenow.strftime(&quot;%Y%m%d&quot;)
    new_headers = {}
    if isinstance(headers, dict):
        new_headers = headers.copy()

    # Create payload hash (hash of the request body content). For GET
    # requests, the payload is an empty string ('').
    if not payload_hash:
        payload_hash = salt.utils.hashutils.sha256_digest(data)

    new_headers[&quot;X-Amz-date&quot;] = amzdate
    new_headers[&quot;host&quot;] = endpoint
    new_headers[&quot;x-amz-content-sha256&quot;] = payload_hash
    a_canonical_headers = []
    a_signed_headers = []

    if token != &quot;&quot;:
        new_headers[&quot;X-Amz-security-token&quot;] = token

    for header in sorted(new_headers.keys(), key=str.lower):
        lower_header = header.lower()
        a_canonical_headers.append(
            &quot;{}:{}&quot;.format(lower_header, new_headers[header].strip())
        )
        a_signed_headers.append(lower_header)
    canonical_headers = &quot;\n&quot;.join(a_canonical_headers) + &quot;\n&quot;
    signed_headers = &quot;;&quot;.join(a_signed_headers)

    algorithm = &quot;AWS4-HMAC-SHA256&quot;

    # Combine elements to create create canonical request
    canonical_request = &quot;\n&quot;.join(
        (method, uri, querystring, canonical_headers, signed_headers, payload_hash)
    )

    # Create the string to sign
    credential_scope = &quot;/&quot;.join((datestamp, location, product, &quot;aws4_request&quot;))
    string_to_sign = &quot;\n&quot;.join(
        (
            algorithm,
            amzdate,
            credential_scope,
            salt.utils.hashutils.sha256_digest(canonical_request),
        )
    )

    # Create the signing key using the function defined above.
    signing_key = _sig_key(secret_access_key, datestamp, location, product)

    # Sign the string_to_sign using the signing_key
    signature = hmac.new(
        signing_key, string_to_sign.encode(&quot;utf-8&quot;), hashlib.sha256
    ).hexdigest()

    # Add signing information to the request
    authorization_header = &quot;{} Credential={}/{}, SignedHeaders={}, Signature={}&quot;.format(
        algorithm,
        access_key_id,
        credential_scope,
        signed_headers,
        signature,
    )

    new_headers[&quot;Authorization&quot;] = authorization_header

    requesturl = &quot;{}?{}&quot;.format(requesturl, querystring)
    return new_headers, requesturl


def _sign(key, msg):
    &quot;&quot;&quot;
    Key derivation functions. See:

    http://docs.aws.amazon.com/general/latest/gr/signature-v4-examples.html#signature-v4-examples-python
    &quot;&quot;&quot;
    return hmac.new(key, msg.encode(&quot;utf-8&quot;), hashlib.sha256).digest()


def _sig_key(key, date_stamp, regionName, serviceName):
    &quot;&quot;&quot;
    Get a signature key. See:

    http://docs.aws.amazon.com/general/latest/gr/signature-v4-examples.html#signature-v4-examples-python
    &quot;&quot;&quot;
    kDate = _sign((&quot;AWS4&quot; + key).encode(&quot;utf-8&quot;), date_stamp)
    if regionName:
        kRegion = _sign(kDate, regionName)
        kService = _sign(kRegion, serviceName)
    else:
        kService = _sign(kDate, serviceName)
    kSigning = _sign(kService, &quot;aws4_request&quot;)
    return kSigning


def query(
    params=None,
    setname=None,
    requesturl=None,
    location=None,
    return_url=False,
    return_root=False,
    opts=None,
    provider=None,
    endpoint=None,
    product=&quot;ec2&quot;,
    sigver=&quot;2&quot;,
):
    &quot;&quot;&quot;
    Perform a query against AWS services using Signature Version 2 Signing
    Process. This is documented at:

    http://docs.aws.amazon.com/general/latest/gr/signature-version-2.html

    Regions and endpoints are documented at:

    http://docs.aws.amazon.com/general/latest/gr/rande.html

    Default ``product`` is ``ec2``. Valid ``product`` names are:

    .. code-block:: yaml

        - autoscaling (Auto Scaling)
        - cloudformation (CloudFormation)
        - ec2 (Elastic Compute Cloud)
        - elasticache (ElastiCache)
        - elasticbeanstalk (Elastic BeanStalk)
        - elasticloadbalancing (Elastic Load Balancing)
        - elasticmapreduce (Elastic MapReduce)
        - iam (Identity and Access Management)
        - importexport (Import/Export)
        - monitoring (CloudWatch)
        - rds (Relational Database Service)
        - simpledb (SimpleDB)
        - sns (Simple Notification Service)
        - sqs (Simple Queue Service)
    &quot;&quot;&quot;
    if params is None:
        params = {}

    if opts is None:
        opts = {}

    function = opts.get(&quot;function&quot;, (None, product))
    providers = opts.get(&quot;providers&quot;, {})

    if provider is None:
        prov_dict = providers.get(function[1], {}).get(product, {})
        if prov_dict:
            driver = list(list(prov_dict.keys()))[0]
            provider = providers.get(driver, product)
    else:
        prov_dict = providers.get(provider, {}).get(product, {})

    service_url = prov_dict.get(&quot;service_url&quot;, &quot;amazonaws.com&quot;)

    if not location:
        location = get_location(opts, prov_dict)

    if endpoint is None:
        if not requesturl:
            endpoint = prov_dict.get(
                &quot;endpoint&quot;, &quot;{}.{}.{}&quot;.format(product, location, service_url)
            )

            requesturl = &quot;https://{}/&quot;.format(endpoint)
        else:
            endpoint = urllib.parse.urlparse(requesturl).netloc
            if endpoint == &quot;&quot;:
                endpoint_err = (
                    &quot;Could not find a valid endpoint in the &quot;
                    &quot;requesturl: {}. Looking for something &quot;
                    &quot;like https://some.aws.endpoint/?args&quot;.format(requesturl)
                )
                log.error(endpoint_err)
                if return_url is True:
                    return {&quot;error&quot;: endpoint_err}, requesturl
                return {&quot;error&quot;: endpoint_err}

    log.debug(&quot;Using AWS endpoint: %s&quot;, endpoint)
    method = &quot;GET&quot;

    aws_api_version = prov_dict.get(
        &quot;aws_api_version&quot;,
        prov_dict.get(&quot;{}_api_version&quot;.format(product), DEFAULT_AWS_API_VERSION),
    )

    # Fallback to ec2's id &amp; key if none is found, for this component
    if not prov_dict.get(&quot;id&quot;, None):
        prov_dict[&quot;id&quot;] = providers.get(provider, {}).get(&quot;ec2&quot;, {}).get(&quot;id&quot;, {})
        prov_dict[&quot;key&quot;] = providers.get(provider, {}).get(&quot;ec2&quot;, {}).get(&quot;key&quot;, {})

    if sigver == &quot;4&quot;:
        headers, requesturl = sig4(
            method,
            endpoint,
            params,
            prov_dict,
            aws_api_version,
            location,
            product,
            requesturl=requesturl,
        )
        params_with_headers = {}
    else:
        params_with_headers = sig2(method, endpoint, params, prov_dict, aws_api_version)
        headers = {}

    attempts = 0
    while attempts &lt; AWS_MAX_RETRIES:
        log.debug(&quot;AWS Request: %s&quot;, requesturl)
        log.trace(&quot;AWS Request Parameters: %s&quot;, params_with_headers)
        try:
            result = requests.get(
                requesturl, headers=headers, params=params_with_headers
            )
            log.debug(&quot;AWS Response Status Code: %s&quot;, result.status_code)
            log.trace(&quot;AWS Response Text: %s&quot;, result.text)
            result.raise_for_status()
            break
        except requests.exceptions.HTTPError as exc:
            root = ET.fromstring(exc.response.content)
            data = xml.to_dict(root)

            # check to see if we should retry the query
            err_code = data.get(&quot;Errors&quot;, {}).get(&quot;Error&quot;, {}).get(&quot;Code&quot;, &quot;&quot;)
            if attempts &lt; AWS_MAX_RETRIES and err_code and err_code in AWS_RETRY_CODES:
                attempts += 1
                log.error(
                    &quot;AWS Response Status Code and Error: [%s %s] %s; &quot;
                    &quot;Attempts remaining: %s&quot;,
                    exc.response.status_code,
                    exc,
                    data,
                    attempts,
                )
                sleep_exponential_backoff(attempts)
                continue

            log.error(
                &quot;AWS Response Status Code and Error: [%s %s] %s&quot;,
                exc.response.status_code,
                exc,
                data,
            )
            if return_url is True:
                return {&quot;error&quot;: data}, requesturl
            return {&quot;error&quot;: data}
    else:
        log.error(
            &quot;AWS Response Status Code and Error: [%s %s] %s&quot;,
            exc.response.status_code,
            exc,
            data,
        )
        if return_url is True:
            return {&quot;error&quot;: data}, requesturl
        return {&quot;error&quot;: data}

    root = ET.fromstring(result.text)
    items = root[1]
    if return_root is True:
        items = root

    if setname:
        for idx, item in enumerate(root):
            comps = item.tag.split(&quot;}&quot;)
            if comps[1] == setname:
                items = root[idx]

    ret = []
    for item in items:
        ret.append(xml.to_dict(item))

    if return_url is True:
        return ret, requesturl

    return ret


def get_region_from_metadata():
    &quot;&quot;&quot;
    Try to get region from instance identity document and cache it

    .. versionadded:: 2015.5.6
    &quot;&quot;&quot;
    global __Location__

    if __Location__ == &quot;do-not-get-from-metadata&quot;:
        log.debug(
            &quot;Previously failed to get AWS region from metadata. Not trying again.&quot;
        )
        return None

    # Cached region
    if __Location__ != &quot;&quot;:
        return __Location__

    try:
        # Connections to instance meta-data must fail fast and never be proxied
        result = requests.get(
            &quot;http://169.254.169.254/latest/dynamic/instance-identity/document&quot;,
            proxies={&quot;http&quot;: &quot;&quot;},
            timeout=AWS_METADATA_TIMEOUT,
        )
    except requests.exceptions.RequestException:
        log.warning(&quot;Failed to get AWS region from instance metadata.&quot;, exc_info=True)
        # Do not try again
        __Location__ = &quot;do-not-get-from-metadata&quot;
        return None

    try:
        region = result.json()[&quot;region&quot;]
        __Location__ = region
        return __Location__
    except (ValueError, KeyError):
        log.warning(&quot;Failed to decode JSON from instance metadata.&quot;)
        return None

    return None


def get_location(opts=None, provider=None):
    &quot;&quot;&quot;
    Return the region to use, in this order:
        opts['location']
        provider['location']
        get_region_from_metadata()
        DEFAULT_LOCATION
    &quot;&quot;&quot;
    if opts is None:
        opts = {}
    ret = opts.get(&quot;location&quot;)
    if ret is None and provider is not None:
        ret = provider.get(&quot;location&quot;)
    if ret is None:
        ret = get_region_from_metadata()
    if ret is None:
        ret = DEFAULT_LOCATION
    return ret
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>jinja_3.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Jinja loading utils to enable a more powerful backend for jinja templates
<A NAME="0"></A>&quot;&quot;&quot;


<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match135388-0.html#0',2,'match135388-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import atexit
import itertools
import logging
import os.path
import pipes
import pprint
import re
import time
import uuid
import warnings
from collections.abc import Hashable
from functools import wraps
from</B></FONT> xml.dom import minidom
from xml.etree.ElementTree import Element, SubElement, tostring

import jinja2
import salt.fileclient
import salt.utils.data
import salt.utils.files
import salt.utils.json
import salt.utils.stringutils
import salt.utils.url
import salt.utils.yaml
from jinja2 import BaseLoader, Markup, TemplateNotFound, nodes
from jinja2.environment import TemplateModule
from jinja2.exceptions import TemplateRuntimeError
from jinja2.ext import Extension
from salt.exceptions import TemplateError
from salt.utils.decorators.jinja import jinja_filter, jinja_global, jinja_test
from salt.utils.odict import OrderedDict
from salt.utils.versions import LooseVersion

log = logging.getLogger(__name__)

__all__ = [&quot;SaltCacheLoader&quot;, &quot;SerializerExtension&quot;]

GLOBAL_UUID = uuid.UUID(&quot;91633EBF-1C86-5E33-935A-28061F4B480E&quot;)
JINJA_VERSION = LooseVersion(jinja2.__version__)


class SaltCacheLoader(BaseLoader):
    &quot;&quot;&quot;
    A special jinja Template Loader for salt.
    Requested templates are always fetched from the server
    to guarantee that the file is up to date.
    Templates are cached like regular salt states
    and only loaded once per loader instance.
    &quot;&quot;&quot;

    _cached_pillar_client = None
    _cached_client = None

    @classmethod
    def shutdown(cls):
        for attr in (&quot;_cached_client&quot;, &quot;_cached_pillar_client&quot;):
            client = getattr(cls, attr, None)
            if client is not None:
                # PillarClient and LocalClient objects do not have a destroy method
                if hasattr(client, &quot;destroy&quot;):
                    client.destroy()
                setattr(cls, attr, None)

    def __init__(
        self,
        opts,
        saltenv=&quot;base&quot;,
        encoding=&quot;utf-8&quot;,
        pillar_rend=False,
        _file_client=None,
    ):
        self.opts = opts
        self.saltenv = saltenv
        self.encoding = encoding
        self.pillar_rend = pillar_rend
        if self.pillar_rend:
            if saltenv not in self.opts[&quot;pillar_roots&quot;]:
                self.searchpath = []
            else:
                self.searchpath = opts[&quot;pillar_roots&quot;][saltenv]
        else:
            self.searchpath = [os.path.join(opts[&quot;cachedir&quot;], &quot;files&quot;, saltenv)]
        log.debug(&quot;Jinja search path: %s&quot;, self.searchpath)
        self.cached = []
        self._file_client = _file_client
        # Instantiate the fileclient
        self.file_client()

    def file_client(self):
        &quot;&quot;&quot;
        Return a file client. Instantiates on first call.
        &quot;&quot;&quot;
        # If there was no file_client passed to the class, create a cache_client
        # and use that. This avoids opening a new file_client every time this
        # class is instantiated
        if self._file_client is None:
            attr = &quot;_cached_pillar_client&quot; if self.pillar_rend else &quot;_cached_client&quot;
            cached_client = getattr(self, attr, None)
            if cached_client is None:
                cached_client = salt.fileclient.get_file_client(
                    self.opts, self.pillar_rend
                )
                setattr(SaltCacheLoader, attr, cached_client)
            self._file_client = cached_client
        return self._file_client

    def cache_file(self, template):
        &quot;&quot;&quot;
        Cache a file from the salt master
        &quot;&quot;&quot;
        saltpath = salt.utils.url.create(template)
        self.file_client().get_file(saltpath, &quot;&quot;, True, self.saltenv)

    def check_cache(self, template):
        &quot;&quot;&quot;
        Cache a file only once
        &quot;&quot;&quot;
        if template not in self.cached:
            self.cache_file(template)
            self.cached.append(template)

    def get_source(self, environment, template):
        &quot;&quot;&quot;
        Salt-specific loader to find imported jinja files.

        Jinja imports will be interpreted as originating from the top
        of each of the directories in the searchpath when the template
        name does not begin with './' or '../'.  When a template name
        begins with './' or '../' then the import will be relative to
        the importing file.

        &quot;&quot;&quot;
        # FIXME: somewhere do seprataor replacement: '\\' =&gt; '/'
        _template = template
        if template.split(&quot;/&quot;, 1)[0] in (&quot;..&quot;, &quot;.&quot;):
            is_relative = True
        else:
            is_relative = False
        # checks for relative '..' paths that step-out of file_roots
        if is_relative:
            # Starts with a relative path indicator

            if not environment or &quot;tpldir&quot; not in environment.globals:
                log.warning(
                    'Relative path &quot;%s&quot; cannot be resolved without an environment',
                    template,
                )
                raise TemplateNotFound(template)
            base_path = environment.globals[&quot;tpldir&quot;]
            _template = os.path.normpath(&quot;/&quot;.join((base_path, _template)))
            if _template.split(&quot;/&quot;, 1)[0] == &quot;..&quot;:
                log.warning(
                    'Discarded template path &quot;%s&quot;: attempts to'
                    &quot; ascend outside of salt://&quot;,
                    template,
                )
                raise TemplateNotFound(template)

        self.check_cache(_template)

        if environment and template:
            tpldir = os.path.dirname(_template).replace(&quot;\\&quot;, &quot;/&quot;)
            tplfile = _template
            if is_relative:
                tpldir = environment.globals.get(&quot;tpldir&quot;, tpldir)
                tplfile = template
            tpldata = {
                &quot;tplfile&quot;: tplfile,
                &quot;tpldir&quot;: &quot;.&quot; if tpldir == &quot;&quot; else tpldir,
                &quot;tpldot&quot;: tpldir.replace(&quot;/&quot;, &quot;.&quot;),
            }
            environment.globals.update(tpldata)

        # pylint: disable=cell-var-from-loop
        for spath in self.searchpath:
            filepath = os.path.join(spath, _template)
            try:
                with salt.utils.files.fopen(filepath, &quot;rb&quot;) as ifile:
                    contents = ifile.read().decode(self.encoding)
                    mtime = os.path.getmtime(filepath)

                    def uptodate():
                        try:
                            return os.path.getmtime(filepath) == mtime
                        except OSError:
                            return False

                    return contents, filepath, uptodate
            except OSError:
                # there is no file under current path
                continue
        # pylint: enable=cell-var-from-loop

        # there is no template file within searchpaths
        raise TemplateNotFound(template)


atexit.register(SaltCacheLoader.shutdown)


class PrintableDict(OrderedDict):
    &quot;&quot;&quot;
    Ensures that dict str() and repr() are YAML friendly.

    .. code-block:: python

        mapping = OrderedDict([('a', 'b'), ('c', None)])
        print mapping
        # OrderedDict([('a', 'b'), ('c', None)])

        decorated = PrintableDict(mapping)
        print decorated
        # {'a': 'b', 'c': None}
    &quot;&quot;&quot;

    def __str__(self):
        output = []
        for key, value in self.items():
            if isinstance(value, str):
                # keeps quotes around strings
                # pylint: disable=repr-flag-used-in-string
                output.append(&quot;{!r}: {!r}&quot;.format(key, value))
                # pylint: enable=repr-flag-used-in-string
            else:
                # let default output
                output.append(&quot;{!r}: {!s}&quot;.format(key, value))
        return &quot;{&quot; + &quot;, &quot;.join(output) + &quot;}&quot;

    def __repr__(self):  # pylint: disable=W0221
        output = []
        for key, value in self.items():
            # Raw string formatter required here because this is a repr
            # function.
            # pylint: disable=repr-flag-used-in-string
            output.append(&quot;{!r}: {!r}&quot;.format(key, value))
            # pylint: enable=repr-flag-used-in-string
        return &quot;{&quot; + &quot;, &quot;.join(output) + &quot;}&quot;


# Additional globals
@jinja_global(&quot;raise&quot;)
def jinja_raise(msg):
    raise TemplateError(msg)


# Additional tests
@jinja_test(&quot;match&quot;)
def test_match(txt, rgx, ignorecase=False, multiline=False):
    &quot;&quot;&quot;Returns true if a sequence of chars matches a pattern.&quot;&quot;&quot;
    flag = 0
    if ignorecase:
        flag |= re.I
    if multiline:
        flag |= re.M
    compiled_rgx = re.compile(rgx, flag)
    return True if compiled_rgx.match(txt) else False


@jinja_test(&quot;equalto&quot;)
def test_equalto(value, other):
    &quot;&quot;&quot;Returns true if two values are equal.&quot;&quot;&quot;
    return value == other


# Additional filters
@jinja_filter(&quot;skip&quot;)
def skip_filter(data):
    &quot;&quot;&quot;
    Suppress data output

    .. code-block:: yaml

        {% my_string = &quot;foo&quot; %}

        {{ my_string|skip }}

    will be rendered as empty string,

    &quot;&quot;&quot;
    return &quot;&quot;


@jinja_filter(&quot;sequence&quot;)
def ensure_sequence_filter(data):
    &quot;&quot;&quot;
    Ensure sequenced data.

    **sequence**

        ensure that parsed data is a sequence

    .. code-block:: jinja

        {% set my_string = &quot;foo&quot; %}
        {% set my_list = [&quot;bar&quot;, ] %}
        {% set my_dict = {&quot;baz&quot;: &quot;qux&quot;} %}

        {{ my_string|sequence|first }}
        {{ my_list|sequence|first }}
        {{ my_dict|sequence|first }}


    will be rendered as:

    .. code-block:: yaml

        foo
        bar
        baz
    &quot;&quot;&quot;
    if not isinstance(data, (list, tuple, set, dict)):
        return [data]
    return data


@jinja_filter(&quot;to_bool&quot;)
def to_bool(val):
    &quot;&quot;&quot;
    Returns the logical value.

    .. code-block:: jinja

        {{ 'yes' | to_bool }}

    will be rendered as:

    .. code-block:: text

        True
    &quot;&quot;&quot;
    if val is None:
        return False
    if isinstance(val, bool):
        return val
    if isinstance(val, (str, (str,))):
        return val.lower() in (&quot;yes&quot;, &quot;1&quot;, &quot;true&quot;)
    if isinstance(val, int):
        return val &gt; 0
    if not isinstance(val, Hashable):
        return len(val) &gt; 0
    return False


@jinja_filter(&quot;indent&quot;)
def indent(s, width=4, first=False, blank=False, indentfirst=None):
    &quot;&quot;&quot;
    A ported version of the &quot;indent&quot; filter containing a fix for indenting Markup
    objects. If the minion has Jinja version 2.11 or newer, the &quot;indent&quot; filter
    from upstream will be used, and this one will be ignored.
    &quot;&quot;&quot;
    if indentfirst is not None:
        warnings.warn(
            &quot;The 'indentfirst' argument is renamed to 'first' and will&quot;
            &quot; be removed in Jinja 3.0.&quot;,
            DeprecationWarning,
            stacklevel=2,
        )
        first = indentfirst

    indention = &quot; &quot; * width
    newline = &quot;\n&quot;

    if isinstance(s, Markup):
        indention = Markup(indention)
        newline = Markup(newline)

    s += newline  # this quirk is necessary for splitlines method

    if blank:
        rv = (newline + indention).join(s.splitlines())
    else:
        lines = s.splitlines()
        rv = lines.pop(0)

        if lines:
            rv += newline + newline.join(
                indention + line if line else line for line in lines
            )

    if first:
        rv = indention + rv

    return rv


@jinja_filter(&quot;tojson&quot;)
def tojson(val, indent=None, **options):
    &quot;&quot;&quot;
    Implementation of tojson filter (only present in Jinja 2.9 and later).
    Unlike the Jinja built-in filter, this allows arbitrary options to be
    passed in to the underlying JSON library.
    &quot;&quot;&quot;
    options.setdefault(&quot;ensure_ascii&quot;, True)
    if indent is not None:
        options[&quot;indent&quot;] = indent
    return (
        salt.utils.json.dumps(val, **options)
        .replace(&quot;&lt;&quot;, &quot;\\u003c&quot;)
        .replace(&quot;&gt;&quot;, &quot;\\u003e&quot;)
        .replace(&quot;&amp;&quot;, &quot;\\u0026&quot;)
        .replace(&quot;'&quot;, &quot;\\u0027&quot;)
    )


@jinja_filter(&quot;quote&quot;)
def quote(txt):
    &quot;&quot;&quot;
    Wraps a text around quotes.

    .. code-block:: jinja

        {% set my_text = 'my_text' %}
        {{ my_text | quote }}

    will be rendered as:

    .. code-block:: text

        'my_text'
    &quot;&quot;&quot;
    return pipes.quote(txt)


@jinja_filter()
def regex_escape(value):
    return re.escape(value)


@jinja_filter(&quot;regex_search&quot;)
def regex_search(txt, rgx, ignorecase=False, multiline=False):
    &quot;&quot;&quot;
    Searches for a pattern in the text.

    .. code-block:: jinja

        {% set my_text = 'abcd' %}
        {{ my_text | regex_search('^(.*)BC(.*)$', ignorecase=True) }}

    will be rendered as:

    .. code-block:: text

        ('a', 'd')
    &quot;&quot;&quot;
    flag = 0
    if ignorecase:
        flag |= re.I
    if multiline:
        flag |= re.M
    obj = re.search(rgx, txt, flag)
    if not obj:
        return
    return obj.groups()


@jinja_filter(&quot;regex_match&quot;)
def regex_match(txt, rgx, ignorecase=False, multiline=False):
    &quot;&quot;&quot;
    Searches for a pattern in the text.

    .. code-block:: jinja

        {% set my_text = 'abcd' %}
        {{ my_text | regex_match('^(.*)BC(.*)$', ignorecase=True) }}

    will be rendered as:

    .. code-block:: text

        ('a', 'd')
    &quot;&quot;&quot;
    flag = 0
    if ignorecase:
        flag |= re.I
    if multiline:
        flag |= re.M
    obj = re.match(rgx, txt, flag)
    if not obj:
        return
    return obj.groups()


@jinja_filter(&quot;regex_replace&quot;)
def regex_replace(txt, rgx, val, ignorecase=False, multiline=False):
    r&quot;&quot;&quot;
    Searches for a pattern and replaces with a sequence of characters.

    .. code-block:: jinja

        {% set my_text = 'lets replace spaces' %}
        {{ my_text | regex_replace('\s+', '__') }}

    will be rendered as:

    .. code-block:: text

        lets__replace__spaces
    &quot;&quot;&quot;
    flag = 0
    if ignorecase:
        flag |= re.I
    if multiline:
        flag |= re.M
    compiled_rgx = re.compile(rgx, flag)
    return compiled_rgx.sub(val, txt)


@jinja_filter(&quot;uuid&quot;)
def uuid_(val):
    &quot;&quot;&quot;
    Returns a UUID corresponding to the value passed as argument.

    .. code-block:: jinja

        {{ 'example' | uuid }}

    will be rendered as:

    .. code-block:: text

        f4efeff8-c219-578a-bad7-3dc280612ec8
    &quot;&quot;&quot;
    return str(uuid.uuid5(GLOBAL_UUID, salt.utils.stringutils.to_str(val)))


### List-related filters


@jinja_filter()
def unique(values):
    &quot;&quot;&quot;
    Removes duplicates from a list.

    .. code-block:: jinja

        {% set my_list = ['a', 'b', 'c', 'a', 'b'] -%}
        {{ my_list | unique }}

    will be rendered as:

    .. code-block:: text

        ['a', 'b', 'c']
    &quot;&quot;&quot;
    ret = None
    if isinstance(values, Hashable):
        ret = set(values)
    else:
        ret = []
        for value in values:
            if value not in ret:
                ret.append(value)
    return ret


@jinja_filter(&quot;min&quot;)
def lst_min(obj):
    &quot;&quot;&quot;
    Returns the min value.

    .. code-block:: jinja

        {% set my_list = [1,2,3,4] -%}
        {{ my_list | min }}

    will be rendered as:

    .. code-block:: text

        1
    &quot;&quot;&quot;
    return min(obj)


@jinja_filter(&quot;max&quot;)
def lst_max(obj):
    &quot;&quot;&quot;
    Returns the max value.

    .. code-block:: jinja

        {% my_list = [1,2,3,4] -%}
        {{ set my_list | max }}

    will be rendered as:

    .. code-block:: text

        4
    &quot;&quot;&quot;
    return max(obj)


@jinja_filter(&quot;avg&quot;)
def lst_avg(lst):
    &quot;&quot;&quot;
    Returns the average value of a list.

    .. code-block:: jinja

        {% my_list = [1,2,3,4] -%}
        {{ set my_list | avg }}

    will be rendered as:

    .. code-block:: yaml

        2.5
    &quot;&quot;&quot;
    if not isinstance(lst, Hashable):
        return float(sum(lst) / len(lst))
    return float(lst)


@jinja_filter(&quot;union&quot;)
def union(lst1, lst2):
    &quot;&quot;&quot;
    Returns the union of two lists.

    .. code-block:: jinja

        {% my_list = [1,2,3,4] -%}
        {{ set my_list | union([2, 4, 6]) }}

    will be rendered as:

    .. code-block:: text

        [1, 2, 3, 4, 6]
    &quot;&quot;&quot;
    if isinstance(lst1, Hashable) and isinstance(lst2, Hashable):
        return set(lst1) | set(lst2)
    return unique(lst1 + lst2)


@jinja_filter(&quot;intersect&quot;)
def intersect(lst1, lst2):
    &quot;&quot;&quot;
    Returns the intersection of two lists.

    .. code-block:: jinja

        {% my_list = [1,2,3,4] -%}
        {{ set my_list | intersect([2, 4, 6]) }}

    will be rendered as:

    .. code-block:: text

        [2, 4]
    &quot;&quot;&quot;
    if isinstance(lst1, Hashable) and isinstance(lst2, Hashable):
        return set(lst1) &amp; set(lst2)
    return unique([ele for ele in lst1 if ele in lst2])


@jinja_filter(&quot;difference&quot;)
def difference(lst1, lst2):
    &quot;&quot;&quot;
    Returns the difference of two lists.

    .. code-block:: jinja

        {% my_list = [1,2,3,4] -%}
        {{ set my_list | difference([2, 4, 6]) }}

    will be rendered as:

    .. code-block:: text

        [1, 3, 6]
    &quot;&quot;&quot;
    if isinstance(lst1, Hashable) and isinstance(lst2, Hashable):
        return set(lst1) - set(lst2)
    return unique([ele for ele in lst1 if ele not in lst2])


@jinja_filter(&quot;symmetric_difference&quot;)
def symmetric_difference(lst1, lst2):
    &quot;&quot;&quot;
    Returns the symmetric difference of two lists.

    .. code-block:: jinja

        {% my_list = [1,2,3,4] -%}
        {{ set my_list | symmetric_difference([2, 4, 6]) }}

    will be rendered as:

    .. code-block:: text

        [1, 3]
    &quot;&quot;&quot;
    if isinstance(lst1, Hashable) and isinstance(lst2, Hashable):
        return set(lst1) ^ set(lst2)
    return unique(
        [ele for ele in union(lst1, lst2) if ele not in intersect(lst1, lst2)]
    )


@jinja_filter(&quot;method_call&quot;)
def method_call(obj, f_name, *f_args, **f_kwargs):
    return getattr(obj, f_name, lambda *args, **kwargs: None)(*f_args, **f_kwargs)


@jinja2.contextfunction
def show_full_context(ctx):
    return salt.utils.data.simple_types_filter(
        {key: value for key, value in ctx.items()}
    )


class SerializerExtension(Extension):
    '''
    Yaml and Json manipulation.

    **Format filters**

    Allows jsonifying or yamlifying any data structure. For example, this dataset:

    .. code-block:: python

        data = {
            'foo': True,
            'bar': 42,
            'baz': [1, 2, 3],
            'qux': 2.0
        }

    .. code-block:: jinja

        yaml = {{ data|yaml }}
        json = {{ data|json }}
        python = {{ data|python }}
        xml  = {{ {'root_node': data}|xml }}

    will be rendered as::

        yaml = {bar: 42, baz: [1, 2, 3], foo: true, qux: 2.0}
        json = {&quot;baz&quot;: [1, 2, 3], &quot;foo&quot;: true, &quot;bar&quot;: 42, &quot;qux&quot;: 2.0}
        python = {'bar': 42, 'baz': [1, 2, 3], 'foo': True, 'qux': 2.0}
        xml = &quot;&quot;&quot;&lt;&lt;?xml version=&quot;1.0&quot; ?&gt;
                 &lt;root_node bar=&quot;42&quot; foo=&quot;True&quot; qux=&quot;2.0&quot;&gt;
                  &lt;baz&gt;1&lt;/baz&gt;
                  &lt;baz&gt;2&lt;/baz&gt;
                  &lt;baz&gt;3&lt;/baz&gt;
                 &lt;/root_node&gt;&quot;&quot;&quot;

    The yaml filter takes an optional flow_style parameter to control the
    default-flow-style parameter of the YAML dumper.

    .. code-block:: jinja

        {{ data|yaml(False) }}

    will be rendered as:

    .. code-block:: yaml

        bar: 42
        baz:
          - 1
          - 2
          - 3
        foo: true
        qux: 2.0

    **Load filters**

    Strings and variables can be deserialized with **load_yaml** and
    **load_json** tags and filters. It allows one to manipulate data directly
    in templates, easily:

    .. code-block:: jinja

        {%- set yaml_src = &quot;{foo: it works}&quot;|load_yaml %}
        {%- set json_src = &quot;{'bar': 'for real'}&quot;|load_json %}
        Dude, {{ yaml_src.foo }} {{ json_src.bar }}!

    will be rendered as::

        Dude, it works for real!

    **Load tags**

    Salt implements ``load_yaml`` and ``load_json`` tags. They work like
    the `import tag`_, except that the document is also deserialized.

    Syntaxes are ``{% load_yaml as [VARIABLE] %}[YOUR DATA]{% endload %}``
    and ``{% load_json as [VARIABLE] %}[YOUR DATA]{% endload %}``

    For example:

    .. code-block:: jinja

        {% load_yaml as yaml_src %}
            foo: it works
        {% endload %}
        {% load_json as json_src %}
            {
                &quot;bar&quot;: &quot;for real&quot;
            }
        {% endload %}
        Dude, {{ yaml_src.foo }} {{ json_src.bar }}!

    will be rendered as::

        Dude, it works for real!

    **Import tags**

    External files can be imported and made available as a Jinja variable.

    .. code-block:: jinja

        {% import_yaml &quot;myfile.yml&quot; as myfile %}
        {% import_json &quot;defaults.json&quot; as defaults %}
        {% import_text &quot;completeworksofshakespeare.txt&quot; as poems %}

    **Catalog**

    ``import_*`` and ``load_*`` tags will automatically expose their
    target variable to import. This feature makes catalog of data to
    handle.

    for example:

    .. code-block:: jinja

        # doc1.sls
        {% load_yaml as var1 %}
            foo: it works
        {% endload %}
        {% load_yaml as var2 %}
            bar: for real
        {% endload %}

    .. code-block:: jinja

        # doc2.sls
        {% from &quot;doc1.sls&quot; import var1, var2 as local2 %}
        {{ var1.foo }} {{ local2.bar }}

    ** Escape Filters **

    .. versionadded:: 2017.7.0

    Allows escaping of strings so they can be interpreted literally by another
    function.

    For example:

    .. code-block:: jinja

        regex_escape = {{ 'https://example.com?foo=bar%20baz' | regex_escape }}

    will be rendered as::

        regex_escape = https\\:\\/\\/example\\.com\\?foo\\=bar\\%20baz

    ** Set Theory Filters **

    .. versionadded:: 2017.7.0

    Performs set math using Jinja filters.

    For example:

    .. code-block:: jinja

        unique = {{ ['foo', 'foo', 'bar'] | unique }}

    will be rendered as::

        unique = ['foo', 'bar']

    ** Salt State Parameter Format Filters **

    .. versionadded:: 3005

    Renders a formatted multi-line YAML string from a Python dictionary. Each
    key/value pair in the dictionary will be added as a single-key dictionary
    to a list that will then be sent to the YAML formatter.

    For example:

    .. code-block:: jinja

        {% set thing_params = {
            &quot;name&quot;: &quot;thing&quot;,
            &quot;changes&quot;: True,
            &quot;warnings&quot;: &quot;OMG! Stuff is happening!&quot;
           }
        %}

        thing:
          test.configurable_test_state:
            {{ thing_params | dict_to_sls_yaml_params | indent }}

    will be rendered as::

    .. code-block:: yaml

        thing:
          test.configurable_test_state:
            - name: thing
            - changes: true
            - warnings: OMG! Stuff is happening!

    .. _`import tag`: https://jinja.palletsprojects.com/en/2.11.x/templates/#import
    '''

    tags = {
        &quot;load_yaml&quot;,
        &quot;load_json&quot;,
        &quot;import_yaml&quot;,
        &quot;import_json&quot;,
        &quot;load_text&quot;,
        &quot;import_text&quot;,
        &quot;profile&quot;,
    }

    def __init__(self, environment):
        super().__init__(environment)
        self.environment.filters.update(
            {
                &quot;yaml&quot;: self.format_yaml,
                &quot;json&quot;: self.format_json,
                &quot;xml&quot;: self.format_xml,
                &quot;python&quot;: self.format_python,
                &quot;load_yaml&quot;: self.load_yaml,
                &quot;load_json&quot;: self.load_json,
                &quot;load_text&quot;: self.load_text,
                &quot;dict_to_sls_yaml_params&quot;: self.dict_to_sls_yaml_params,
                &quot;combinations&quot;: itertools.combinations,
                &quot;combinations_with_replacement&quot;: itertools.combinations_with_replacement,
                &quot;compress&quot;: itertools.compress,
                &quot;permutations&quot;: itertools.permutations,
                &quot;product&quot;: itertools.product,
                &quot;zip&quot;: zip,
                &quot;zip_longest&quot;: itertools.zip_longest,
            }
        )

        if self.environment.finalize is None:
            self.environment.finalize = self.finalizer
        else:
            finalizer = self.environment.finalize

            @wraps(finalizer)
            def wrapper(self, data):
                return finalizer(self.finalizer(data))

            self.environment.finalize = wrapper

    def finalizer(self, data):
        &quot;&quot;&quot;
        Ensure that printed mappings are YAML friendly.
        &quot;&quot;&quot;

        def explore(data):
            if isinstance(data, (dict, OrderedDict)):
                return PrintableDict(
                    [(key, explore(value)) for key, value in data.items()]
                )
            elif isinstance(data, (list, tuple, set)):
                return data.__class__([explore(value) for value in data])
            return data

        return explore(data)

    def format_json(self, value, sort_keys=True, indent=None):
        json_txt = salt.utils.json.dumps(
            value, sort_keys=sort_keys, indent=indent
        ).strip()
        try:
            return Markup(json_txt)
        except UnicodeDecodeError:
            return Markup(salt.utils.stringutils.to_unicode(json_txt))

    def format_yaml(self, value, flow_style=True):
        yaml_txt = salt.utils.yaml.safe_dump(
            value, default_flow_style=flow_style
        ).strip()
        if yaml_txt.endswith(&quot;\n...&quot;):
            yaml_txt = yaml_txt[: len(yaml_txt) - 4]
        try:
            return Markup(yaml_txt)
        except UnicodeDecodeError:
            return Markup(salt.utils.stringutils.to_unicode(yaml_txt))

    def format_xml(self, value):
        &quot;&quot;&quot;Render a formatted multi-line XML string from a complex Python
        data structure. Supports tag attributes and nested dicts/lists.

        :param value: Complex data structure representing XML contents
        :returns: Formatted XML string rendered with newlines and indentation
        :rtype: str
        &quot;&quot;&quot;

        def normalize_iter(value):
            if isinstance(value, (list, tuple)):
                if isinstance(value[0], str):
                    xmlval = value
                else:
                    xmlval = []
            elif isinstance(value, dict):
                xmlval = list(value.items())
            else:
                raise TemplateRuntimeError(
                    &quot;Value is not a dict or list. Cannot render as XML&quot;
                )
            return xmlval

        def recurse_tree(xmliter, element=None):
            sub = None
            for tag, attrs in xmliter:
                if isinstance(attrs, list):
                    for attr in attrs:
                        recurse_tree(((tag, attr),), element)
                elif element is not None:
                    sub = SubElement(element, tag)
                else:
                    sub = Element(tag)
                if isinstance(attrs, (str, int, bool, float)):
                    sub.text = str(attrs)
                    continue
                if isinstance(attrs, dict):
                    sub.attrib = {
                        attr: str(val)
                        for attr, val in attrs.items()
                        if not isinstance(val, (dict, list))
                    }
                for tag, val in [
                    item
                    for item in normalize_iter(attrs)
                    if isinstance(item[1], (dict, list))
                ]:
                    recurse_tree(((tag, val),), sub)
            return sub

        return Markup(
            minidom.parseString(
                tostring(recurse_tree(normalize_iter(value)))
            ).toprettyxml(indent=&quot; &quot;)
        )

    def format_python(self, value):
        return Markup(pprint.pformat(value).strip())

    def load_yaml(self, value):
        if isinstance(value, TemplateModule):
            value = str(value)
        try:
            return salt.utils.data.decode(salt.utils.yaml.safe_load(value))
        except salt.utils.yaml.YAMLError as exc:
            msg = &quot;Encountered error loading yaml: &quot;
            try:
                # Reported line is off by one, add 1 to correct it
                line = exc.problem_mark.line + 1
                buf = exc.problem_mark.buffer
                problem = exc.problem
            except AttributeError:
                # No context information available in the exception, fall back
                # to the stringified version of the exception.
                msg += str(exc)
            else:
                msg += &quot;{}\n&quot;.format(problem)
                msg += salt.utils.stringutils.get_context(
                    buf, line, marker=&quot;    &lt;======================&quot;
                )
            raise TemplateRuntimeError(msg)
        except AttributeError:
            raise TemplateRuntimeError(&quot;Unable to load yaml from {}&quot;.format(value))

    def load_json(self, value):
        if isinstance(value, TemplateModule):
            value = str(value)
        try:
            return salt.utils.json.loads(value)
        except (ValueError, TypeError, AttributeError):
            raise TemplateRuntimeError(&quot;Unable to load json from {}&quot;.format(value))

    def load_text(self, value):
        if isinstance(value, TemplateModule):
            value = str(value)

        return value

    _load_parsers = {&quot;load_yaml&quot;, &quot;load_json&quot;, &quot;load_text&quot;}
    _import_parsers = {&quot;import_yaml&quot;, &quot;import_json&quot;, &quot;import_text&quot;}

    def parse(self, parser):
        if parser.stream.current.value in self._load_parsers:
            return self.parse_load(parser)
        elif parser.stream.current.value in self._import_parsers:
            return self.parse_import(
                parser, parser.stream.current.value.split(&quot;_&quot;, 1)[1]
            )
        elif parser.stream.current.value == &quot;profile&quot;:
            return self.parse_profile(parser)

        parser.fail(
            &quot;Unknown format &quot; + parser.stream.current.value,
            parser.stream.current.lineno,
        )

    # pylint: disable=E1120,E1121
    def parse_profile(self, parser):
        lineno = next(parser.stream).lineno
        parser.stream.expect(&quot;name:as&quot;)
        label = parser.parse_expression()
        body = parser.parse_statements([&quot;name:endprofile&quot;], drop_needle=True)
        return self._parse_profile_block(parser, label, &quot;profile block&quot;, body, lineno)

    def _create_profile_id(self, parser):
        return &quot;_salt_profile_{}&quot;.format(parser.free_identifier().name)

    def _profile_start(self, label, source):
        return (label, source, time.time())

    def _profile_end(self, label, source, previous_time):
        log.profile(
            &quot;Time (in seconds) to render %s '%s': %s&quot;,
            source,
            label,
            time.time() - previous_time,
        )

    def _parse_profile_block(self, parser, label, source, body, lineno):
<A NAME="1"></A>        profile_id = self._create_profile_id(parser)
        ret = (
            [
                nodes<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match135388-0.html#1',2,'match135388-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.Assign(
                    nodes.Name(profile_id, &quot;store&quot;).set_lineno(lineno),
                    self.call_method(
                        &quot;_profile_start&quot;,
                        dyn_args=nodes.List([label</B></FONT>, nodes.Const(source)]).set_lineno(
                            lineno
                        ),
                    ).set_lineno(lineno),
                ).set_lineno(lineno),
            ]
            + body
            + [
                nodes.ExprStmt(
                    self.call_method(
                        &quot;_profile_end&quot;, dyn_args=nodes.Name(profile_id, &quot;load&quot;)
                    ),
                ).set_lineno(lineno),
            ]
        )
        return ret

    def parse_load(self, parser):
        filter_name = parser.stream.current.value
        lineno = next(parser.stream).lineno
        if filter_name not in self.environment.filters:
            parser.fail(&quot;Unable to parse {}&quot;.format(filter_name), lineno)

        parser.stream.expect(&quot;name:as&quot;)
        target = parser.parse_assign_target()
        macro_name = &quot;_&quot; + parser.free_identifier().name
        macro_body = parser.parse_statements((&quot;name:endload&quot;,), drop_needle=True)

        return [
            nodes.Macro(macro_name, [], [], macro_body).set_lineno(lineno),
            nodes.Assign(
                target,
                nodes.Filter(
                    nodes.Call(
                        nodes.Name(macro_name, &quot;load&quot;).set_lineno(lineno),
                        [],
                        [],
                        None,
                        None,
                    ).set_lineno(lineno),
                    filter_name,
                    [],
                    [],
                    None,
                    None,
                ).set_lineno(lineno),
            ).set_lineno(lineno),
        ]

    def parse_import(self, parser, converter):
        import_node = parser.parse_import()
        target = import_node.target
        lineno = import_node.lineno

        body = [
            import_node,
            nodes.Assign(
                nodes.Name(target, &quot;store&quot;).set_lineno(lineno),
                nodes.Filter(
                    nodes.Name(target, &quot;load&quot;).set_lineno(lineno),
                    &quot;load_{}&quot;.format(converter),
                    [],
                    [],
                    None,
                    None,
                ).set_lineno(lineno),
            ).set_lineno(lineno),
        ]
        return self._parse_profile_block(
            parser, import_node.template, &quot;import_{}&quot;.format(converter), body, lineno
        )

    def dict_to_sls_yaml_params(self, value, flow_style=False):
        &quot;&quot;&quot;
        .. versionadded:: 3005

        Render a formatted multi-line YAML string from a Python dictionary. Each
        key/value pair in the dictionary will be added as a single-key dictionary
        to a list that will then be sent to the YAML formatter.

        :param value: Python dictionary representing Salt state parameters

        :param flow_style: Setting flow_style to False will enforce indentation
                           mode

        :returns: Formatted SLS YAML string rendered with newlines and
                  indentation
        &quot;&quot;&quot;
        return self.format_yaml(
            [{key: val} for key, val in value.items()], flow_style=flow_style
        )
</PRE>
</div>
  </div>
</body>
</html>
