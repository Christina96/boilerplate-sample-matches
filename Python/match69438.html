<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for tism.py &amp; highstate_return.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for tism.py &amp; highstate_return.py
      </h3>
<h1 align="center">
        4.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>tism.py (26.0%)<th>highstate_return.py (2.504817%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(31-49)<td><a href="#" name="0">(87-108)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>tism.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import logging
3 import salt.utils.http as http
4 import salt.utils.json
5 from salt.exceptions import SaltConfigurationError
6 log = logging.getLogger(__name__)
7 __virtualname__ = "tism"
8 def __virtual__():
9     """
10     This module has no other system dependencies
11     """
12     return __virtualname__
13 def get(key, service=</b></font>None, profile=None):  # pylint: disable=W0613
14     """
15     Get a decrypted secret from the tISMd API
16     """
17     if not profile.get("url") or not profile.get("token"):
18         raise SaltConfigurationError(
19             "url and/or token missing from the tism sdb profile"
20         )
21     request = {"token": profile["token"], "encsecret": key}
22     result = http.query(
23         profile["url"],
24         method="POST",
25         data=salt.utils.json.dumps(request),
26     )
27     decrypted = result.get("body")
28     if not decrypted:
29         log.warning(
30             "tism.get sdb decryption request failed with error %s",
31             result.get("error", "unknown"),
32         )
33         return "ERROR" + str(result.get("status", "unknown"))
34     return decrypted
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>highstate_return.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 Return the results of a highstate (or any other state function that returns
3 data in a compatible format) via an HTML email or HTML file.
4 .. versionadded:: 2017.7.0
5 Similar results can be achieved by using the smtp returner with a custom template,
6 except an attempt at writing such a template for the complex data structure
7 returned by highstate function had proven to be a challenge, not to mention
8 that the smtp module doesn't support sending HTML mail at the moment.
9 The main goal of this returner was to produce an easy to read email similar
10 to the output of highstate outputter used by the CLI.
11 This returner could be very useful during scheduled executions,
12 but could also be useful for communicating the results of a manual execution.
13 Returner configuration is controlled in a standard fashion either via
14 highstate group or an alternatively named group.
15 .. code-block:: bash
16     salt '*' state.highstate --return highstate
17 To use the alternative configuration, append '--return_config config-name'
18 .. code-block:: bash
19     salt '*' state.highstate --return highstate --return_config simple
20 Here is an example of what the configuration might look like:
21 .. code-block:: yaml
22     simple.highstate:
23       report_failures: True
24       report_changes: True
25       report_everything: False
26       failure_function: pillar.items
27       success_function: pillar.items
28       report_format: html
29       report_delivery: smtp
30       smtp_success_subject: 'success minion {id} on host {host}'
31       smtp_failure_subject: 'failure minion {id} on host {host}'
32       smtp_server: smtp.example.com
33       smtp_recipients: saltusers@example.com, devops@example.com
34       smtp_sender: salt@example.com
35 The *report_failures*, *report_changes*, and *report_everything* flags provide
36 filtering of the results. If you want an email to be sent every time, then
37 *report_everything* is your choice. If you want to be notified only when
38 changes were successfully made use *report_changes*. And *report_failures* will
39 generate an email if there were failures.
40 The configuration allows you to run a salt module function in case of
41 success (*success_function*) or failure (*failure_function*).
42 Any salt function, including ones defined in the _module folder of your salt
43 repo, could be used here and its output will be displayed under the 'extra'
44 heading of the email.
45 Supported values for *report_format* are html, json, and yaml. The latter two
46 are typically used for debugging purposes, but could be used for applying
47 a template at some later stage.
48 The values for *report_delivery* are smtp or file. In case of file delivery
49 the only other applicable option is *file_output*.
50 In case of smtp delivery, smtp_* options demonstrated by the example above
51 could be used to customize the email.
52 As you might have noticed, the success and failure subjects contain {id} and {host}
53 values. Any other grain name could be used. As opposed to using
54 {{grains['id']}}, which will be rendered by the master and contain master's
55 values at the time of pillar generation, these will contain minion values at
56 the time of execution.
57 """
58 import html
59 import io
60 import logging
61 import smtplib
62 import salt.returners
63 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import salt.utils.files
64 import salt.utils.json
65 import salt.utils.stringutils
66 import salt.utils.yaml
67 log = logging.getLogger(__name__)
68 __virtualname__ = "highstate"
69 def __virtual__():
70     """
71     Return our name
72     """
73     return __virtualname__
74 def _get_options(ret):
75     """
76     Return options
77     """
78     attrs =</b></font> {
79         "report_everything": "report_everything",
80         "report_changes": "report_changes",
81         "report_failures": "report_failures",
82         "failure_function": "failure_function",
83         "success_function": "success_function",
84         "report_format": "report_format",
85         "report_delivery": "report_delivery",
86         "file_output": "file_output",
87         "smtp_sender": "smtp_sender",
88         "smtp_recipients": "smtp_recipients",
89         "smtp_failure_subject": "smtp_failure_subject",
90         "smtp_success_subject": "smtp_success_subject",
91         "smtp_server": "smtp_server",
92     }
93     _options = salt.returners.get_returner_options(
94         __virtualname__, ret, attrs, __salt__=__salt__, __opts__=__opts__
95     )
96     return _options
97 _STYLES = {
98     "_table": "border-collapse:collapse;width:100%;",
99     "_td": "vertical-align:top;font-family:Helvetica,Arial,sans-serif;font-size:9pt;",
100     "unchanged": "color:blue;",
101     "changed": "color:green",
102     "failed": "color:red;",
103     "first": "border-top:0;border-left:1px solid #9e9e9e;",
104     "first_first": "border-top:0;border-left:0;",
105     "notfirst_first": "border-left:0;border-top:1px solid #9e9e9e;",
106     "other": "border-top:1px solid #9e9e9e;border-left:1px solid #9e9e9e;",
107     "name": "width:70pt;",
108     "container": "padding:0;",
109 }
110 def _lookup_style(element, names):
111     """
112     Lookup style by either element name or the list of classes
113     """
114     return _STYLES.get("_" + element, "") + "".join(
115         [_STYLES.get(name, "") for name in names]
116     )
117 def _generate_html_table(data, out, level=0, extra_style=""):
118     """
119     Generate a single table of data
120     """
121     print(
122         '&lt;table style="{}"&gt;'.format(_lookup_style("table", ["table" + str(level)])),
123         file=out,
124     )
125     firstone = True
126     row_style = "row" + str(level)
127     cell_style = "cell" + str(level)
128     for subdata in data:
129         first_style = "first_first" if firstone else "notfirst_first"
130         second_style = "first" if firstone else "other"
131         if isinstance(subdata, dict):
132             if "__style__" in subdata:
133                 new_extra_style = subdata["__style__"]
134                 del subdata["__style__"]
135             else:
136                 new_extra_style = extra_style
137             if len(subdata) == 1:
138                 name, value = next(iter(subdata.items()))
139                 print(
140                     '&lt;tr style="{}"&gt;'.format(_lookup_style("tr", [row_style])),
141                     file=out,
142                 )
143                 print(
144                     '&lt;td style="{}"&gt;{}&lt;/td&gt;'.format(
145                         _lookup_style(
146                             "td", [cell_style, first_style, "name", new_extra_style]
147                         ),
148                         name,
149                     ),
150                     file=out,
151                 )
152                 if isinstance(value, list):
153                     print(
154                         '&lt;td style="{}"&gt;'.format(
155                             _lookup_style(
156                                 "td",
157                                 [
158                                     cell_style,
159                                     second_style,
160                                     "container",
161                                     new_extra_style,
162                                 ],
163                             )
164                         ),
165                         file=out,
166                     )
167                     _generate_html_table(value, out, level + 1, new_extra_style)
168                     print("&lt;/td&gt;", file=out)
169                 else:
170                     print(
171                         '&lt;td style="{}"&gt;{}&lt;/td&gt;'.format(
172                             _lookup_style(
173                                 "td",
174                                 [cell_style, second_style, "value", new_extra_style],
175                             ),
176                             html.escape(str(value)),
177                         ),
178                         file=out,
179                     )
180                 print("&lt;/tr&gt;", file=out)
181         elif isinstance(subdata, list):
182             print('&lt;tr style="{}"&gt;'.format(_lookup_style("tr", [row_style])), file=out)
183             print(
184                 '&lt;td style="{}"&gt;'.format(
185                     _lookup_style(
186                         "td", [cell_style, first_style, "container", extra_style]
187                     )
188                 ),
189                 file=out,
190             )
191             _generate_html_table(subdata, out, level + 1, extra_style)
192             print("&lt;/td&gt;", file=out)
193             print("&lt;/tr&gt;", file=out)
194         else:
195             print('&lt;tr style="{}"&gt;'.format(_lookup_style("tr", [row_style])), file=out)
196             print(
197                 '&lt;td style="{}"&gt;{}&lt;/td&gt;'.format(
198                     _lookup_style(
199                         "td", [cell_style, first_style, "value", extra_style]
200                     ),
201                     html.escape(str(subdata)),
202                 ),
203                 file=out,
204             )
205             print("&lt;/tr&gt;", file=out)
206         firstone = False
207     print("&lt;/table&gt;", file=out)
208 def _generate_html(data, out):
209     """
210     Generate report data as HTML
211     """
212     print("&lt;html&gt;", file=out)
213     print("&lt;body&gt;", file=out)
214     _generate_html_table(data, out, 0)
215     print("&lt;/body&gt;", file=out)
216     print("&lt;/html&gt;", file=out)
217 def _dict_to_name_value(data):
218     """
219     Convert a dictionary to a list of dictionaries to facilitate ordering
220     """
221     if isinstance(data, dict):
222         sorted_data = sorted(data.items(), key=lambda s: s[0])
223         result = []
224         for name, value in sorted_data:
225             if isinstance(value, dict):
226                 result.append({name: _dict_to_name_value(value)})
227             else:
228                 result.append({name: value})
229     else:
230         result = data
231     return result
232 def _generate_states_report(sorted_data):
233     """
234     Generate states report
235     """
236     states = []
237     for state, data in sorted_data:
238         module, stateid, name, function = state.split("_|-")
239         module_function = ".".join((module, function))
240         result = data.get("result", "")
241         single = [
242             {"function": module_function},
243             {"name": name},
244             {"result": result},
245             {"duration": data.get("duration", 0.0)},
246             {"comment": data.get("comment", "")},
247         ]
248         if not result:
249             style = "failed"
250         else:
251             changes = data.get("changes", {})
252             if changes and isinstance(changes, dict):
253                 single.append({"changes": _dict_to_name_value(changes)})
254                 style = "changed"
255             else:
256                 style = "unchanged"
257         started = data.get("start_time", "")
258         if started:
259             single.append({"started": started})
260         states.append({stateid: single, "__style__": style})
261     return states
262 def _generate_report(ret, setup):
263     """
264     Generate report dictionary
265     """
266     retdata = ret.get("return", {})
267     sorted_data = sorted(retdata.items(), key=lambda s: s[1].get("__run_num__", 0))
268     total = 0
269     failed = 0
270     changed = 0
271     duration = 0.0
272     for _, data in sorted_data:
273         if not data.get("result", True):
274             failed += 1
275         total += 1
276         try:
277             duration += float(data.get("duration", 0.0))
278         except ValueError:
279             pass
280         if data.get("changes", {}):
281             changed += 1
282     unchanged = total - failed - changed
283     log.debug("highstate total: %s", total)
284     log.debug("highstate failed: %s", failed)
285     log.debug("highstate unchanged: %s", unchanged)
286     log.debug("highstate changed: %s", changed)
287     if (
288         setup.get("report_everything", False)
289         or (setup.get("report_changes", True) and changed != 0)
290         or (setup.get("report_failures", True) and failed != 0)
291     ):
292         report = [
293             {
294                 "stats": [
295                     {"total": total},
296                     {"failed": failed, "__style__": "failed"},
297                     {"unchanged": unchanged, "__style__": "unchanged"},
298                     {"changed": changed, "__style__": "changed"},
299                     {"duration": duration},
300                 ]
301             },
302             {
303                 "job": [
304                     {"function": ret.get("fun", "")},
305                     {"arguments": ret.get("fun_args", "")},
306                     {"jid": ret.get("jid", "")},
307                     {"success": ret.get("success", True)},
308                     {"retcode": ret.get("retcode", 0)},
309                 ]
310             },
311             {"states": _generate_states_report(sorted_data)},
312         ]
313         if failed:
314             function = setup.get("failure_function", None)
315         else:
316             function = setup.get("success_function", None)
317         if function:
318             func_result = __salt__[function]()
319             report.insert(0, {"extra": [{function: _dict_to_name_value(func_result)}]})
320     else:
321         report = []
322     return report, failed
323 def _sprinkle(config_str):
324     """
325     Sprinkle with grains of salt, that is
326     convert 'test {id} test {host} ' types of strings
327     """
328     parts = [x for sub in config_str.split("{") for x in sub.split("}")]
329     for i in range(1, len(parts), 2):
330         parts[i] = str(__grains__.get(parts[i], ""))
331     return "".join(parts)
332 def _produce_output(report, failed, setup):
333     """
334     Produce output from the report dictionary generated by _generate_report
335     """
336     report_format = setup.get("report_format", "yaml")
337     log.debug("highstate output format: %s", report_format)
338     if report_format == "json":
339         report_text = salt.utils.json.dumps(report)
340     elif report_format == "yaml":
341         string_file = io.StringIO()
342         salt.utils.yaml.safe_dump(report, string_file, default_flow_style=False)
343         string_file.seek(0)
344         report_text = string_file.read()
345     else:
346         string_file = io.StringIO()
347         _generate_html(report, string_file)
348         string_file.seek(0)
349         report_text = string_file.read()
350     report_delivery = setup.get("report_delivery", "file")
351     log.debug("highstate report_delivery: %s", report_delivery)
352     if report_delivery == "file":
353         output_file = _sprinkle(setup.get("file_output", "/tmp/test.rpt"))
354         with salt.utils.files.fopen(output_file, "w") as out:
355             out.write(salt.utils.stringutils.to_str(report_text))
356     else:
357         msg = MIMEText(report_text, report_format)
358         sender = setup.get("smtp_sender", "")
359         recipients = setup.get("smtp_recipients", "")
360         if failed:
361             subject = setup.get("smtp_failure_subject", "Installation failure")
362         else:
363             subject = setup.get("smtp_success_subject", "Installation success")
364         subject = _sprinkle(subject)
365         msg["Subject"] = subject
366         msg["From"] = sender
367         msg["To"] = recipients
368         smtp = smtplib.SMTP(host=setup.get("smtp_server", ""))
369         smtp.sendmail(
370             sender, [x.strip() for x in recipients.split(",")], msg.as_string()
371         )
372         smtp.quit()
373 def returner(ret):
374     """
375     Check highstate return information and possibly fire off an email
376     or save a file.
377     """
378     setup = _get_options(ret)
379     log.debug("highstate setup %s", setup)
380     report, failed = _generate_report(ret, setup)
381     if report:
382         _produce_output(report, failed, setup)
383 def __test_html():
384     """
385     HTML generation test only used when called from the command line:
386         python ./highstate.py
387     Typical options for generating the report file:
388     highstate:
389         report_format: yaml
390         report_delivery: file
391         file_output: '/srv/salt/_returners/test.rpt'
392     """
393     with salt.utils.files.fopen("test.rpt", "r") as input_file:
394         data_text = salt.utils.stringutils.to_unicode(input_file.read())
395     data = salt.utils.yaml.safe_load(data_text)
396     string_file = io.StringIO()
397     _generate_html(data, string_file)
398     string_file.seek(0)
399     result = string_file.read()
400     with salt.utils.files.fopen("test.html", "w") as output:
401         output.write(salt.utils.stringutils.to_str(result))
402 if __name__ == "__main__":
403     __test_html()
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
