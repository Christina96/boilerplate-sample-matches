<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for tism.py &amp; highstate_return.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for tism.py &amp; highstate_return.py
      </h3>
<h1 align="center">
        4.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>tism.py (26.0%)<th>highstate_return.py (2.504817%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(31-49)<td><a href="#" name="0">(87-108)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>tism.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
tISM - the Immutable Secrets Manager SDB Module

:maintainer:    tISM
:maturity:      New
:platform:      all

.. versionadded:: 2017.7.0

This module will decrypt PGP encrypted secrets against a tISM server.

.. code::

  sdb://&lt;profile&gt;/&lt;encrypted secret&gt;

  sdb://tism/hQEMAzJ+GfdAB3KqAQf9E3cyvrPEWR1sf1tMvH0nrJ0bZa9kDFLPxvtwAOqlRiNp0F7IpiiVRF+h+sW5Mb4ffB1TElMzQ+/G5ptd6CjmgBfBsuGeajWmvLEi4lC6/9v1rYGjjLeOCCcN4Dl5AHlxUUaSrxB8akTDvSAnPvGhtRTZqDlltl5UEHsyYXM8RaeCrBw5Or1yvC9Ctx2saVp3xmALQvyhzkUv5pTb1mH0I9Z7E0ian07ZUOD+pVacDAf1oQcPpqkeNVTQQ15EP0fDuvnW+a0vxeLhkbFLfnwqhqEsvFxVFLHVLcs2ffE5cceeOMtVo7DS9fCtkdZr5hR7a+86n4hdKfwDMFXiBwSIPMkmY980N/H30L/r50+CBkuI/u4M2pXDcMYsvvt4ajCbJn91qaQ7BDI=

A profile must be setup in the minion configuration or pillar. If you want to
use sdb in a runner or pillar you must also place a profile in the master
configuration.

.. code-block:: yaml

    tism:
      driver: tism
      url: https://my.tismd:8080/decrypt
      token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6MSwiZXhwIjoxNTg1MTExNDYwLCJqdGkiOiI3NnA5cWNiMWdtdmw4Iiwia2V5cyI6WyJBTEwiXX0.RtAhG6Uorf5xnSf4Ya_GwJnoHkCsql4r1_hiOeDSLzo
<a name="0"></a>"""


<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import logging

import salt.utils.http as http
import salt.utils.json
from salt.exceptions import SaltConfigurationError

log = logging.getLogger(__name__)

__virtualname__ = "tism"


def __virtual__():
    """
    This module has no other system dependencies
    """
    return __virtualname__


def get(key, service=</b></font>None, profile=None):  # pylint: disable=W0613
    """
    Get a decrypted secret from the tISMd API
    """

    if not profile.get("url") or not profile.get("token"):
        raise SaltConfigurationError(
            "url and/or token missing from the tism sdb profile"
        )

    request = {"token": profile["token"], "encsecret": key}

    result = http.query(
        profile["url"],
        method="POST",
        data=salt.utils.json.dumps(request),
    )

    decrypted = result.get("body")

    if not decrypted:
        log.warning(
            "tism.get sdb decryption request failed with error %s",
            result.get("error", "unknown"),
        )
        return "ERROR" + str(result.get("status", "unknown"))

    return decrypted
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>highstate_return.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
Return the results of a highstate (or any other state function that returns
data in a compatible format) via an HTML email or HTML file.

.. versionadded:: 2017.7.0

Similar results can be achieved by using the smtp returner with a custom template,
except an attempt at writing such a template for the complex data structure
returned by highstate function had proven to be a challenge, not to mention
that the smtp module doesn't support sending HTML mail at the moment.

The main goal of this returner was to produce an easy to read email similar
to the output of highstate outputter used by the CLI.

This returner could be very useful during scheduled executions,
but could also be useful for communicating the results of a manual execution.

Returner configuration is controlled in a standard fashion either via
highstate group or an alternatively named group.

.. code-block:: bash

    salt '*' state.highstate --return highstate

To use the alternative configuration, append '--return_config config-name'

.. code-block:: bash

    salt '*' state.highstate --return highstate --return_config simple

Here is an example of what the configuration might look like:

.. code-block:: yaml

    simple.highstate:
      report_failures: True
      report_changes: True
      report_everything: False
      failure_function: pillar.items
      success_function: pillar.items
      report_format: html
      report_delivery: smtp
      smtp_success_subject: 'success minion {id} on host {host}'
      smtp_failure_subject: 'failure minion {id} on host {host}'
      smtp_server: smtp.example.com
      smtp_recipients: saltusers@example.com, devops@example.com
      smtp_sender: salt@example.com

The *report_failures*, *report_changes*, and *report_everything* flags provide
filtering of the results. If you want an email to be sent every time, then
*report_everything* is your choice. If you want to be notified only when
changes were successfully made use *report_changes*. And *report_failures* will
generate an email if there were failures.

The configuration allows you to run a salt module function in case of
success (*success_function*) or failure (*failure_function*).

Any salt function, including ones defined in the _module folder of your salt
repo, could be used here and its output will be displayed under the 'extra'
heading of the email.

Supported values for *report_format* are html, json, and yaml. The latter two
are typically used for debugging purposes, but could be used for applying
a template at some later stage.

The values for *report_delivery* are smtp or file. In case of file delivery
the only other applicable option is *file_output*.

In case of smtp delivery, smtp_* options demonstrated by the example above
could be used to customize the email.

As you might have noticed, the success and failure subjects contain {id} and {host}
values. Any other grain name could be used. As opposed to using
{{grains['id']}}, which will be rendered by the master and contain master's
values at the time of pillar generation, these will contain minion values at
the time of execution.

"""

import html
import io
import logging
import smtplib
<a name="0"></a>from email.mime.text import MIMEText

import salt.returners
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import salt.utils.files
import salt.utils.json
import salt.utils.stringutils
import salt.utils.yaml

log = logging.getLogger(__name__)

__virtualname__ = "highstate"


def __virtual__():
    """
    Return our name
    """
    return __virtualname__


def _get_options(ret):
    """
    Return options
    """
    attrs =</b></font> {
        "report_everything": "report_everything",
        "report_changes": "report_changes",
        "report_failures": "report_failures",
        "failure_function": "failure_function",
        "success_function": "success_function",
        "report_format": "report_format",
        "report_delivery": "report_delivery",
        "file_output": "file_output",
        "smtp_sender": "smtp_sender",
        "smtp_recipients": "smtp_recipients",
        "smtp_failure_subject": "smtp_failure_subject",
        "smtp_success_subject": "smtp_success_subject",
        "smtp_server": "smtp_server",
    }

    _options = salt.returners.get_returner_options(
        __virtualname__, ret, attrs, __salt__=__salt__, __opts__=__opts__
    )

    return _options


#
# Most email readers to not support &lt;style&gt; tag.
# The following dict and a function provide a primitive styler
# sufficient for our needs.
#
_STYLES = {
    "_table": "border-collapse:collapse;width:100%;",
    "_td": "vertical-align:top;font-family:Helvetica,Arial,sans-serif;font-size:9pt;",
    "unchanged": "color:blue;",
    "changed": "color:green",
    "failed": "color:red;",
    "first": "border-top:0;border-left:1px solid #9e9e9e;",
    "first_first": "border-top:0;border-left:0;",
    "notfirst_first": "border-left:0;border-top:1px solid #9e9e9e;",
    "other": "border-top:1px solid #9e9e9e;border-left:1px solid #9e9e9e;",
    "name": "width:70pt;",
    "container": "padding:0;",
}


def _lookup_style(element, names):
    """
    Lookup style by either element name or the list of classes
    """
    return _STYLES.get("_" + element, "") + "".join(
        [_STYLES.get(name, "") for name in names]
    )


def _generate_html_table(data, out, level=0, extra_style=""):
    """
    Generate a single table of data
    """
    print(
        '&lt;table style="{}"&gt;'.format(_lookup_style("table", ["table" + str(level)])),
        file=out,
    )

    firstone = True

    row_style = "row" + str(level)
    cell_style = "cell" + str(level)

    for subdata in data:
        first_style = "first_first" if firstone else "notfirst_first"
        second_style = "first" if firstone else "other"

        if isinstance(subdata, dict):
            if "__style__" in subdata:
                new_extra_style = subdata["__style__"]
                del subdata["__style__"]
            else:
                new_extra_style = extra_style
            if len(subdata) == 1:
                name, value = next(iter(subdata.items()))
                print(
                    '&lt;tr style="{}"&gt;'.format(_lookup_style("tr", [row_style])),
                    file=out,
                )
                print(
                    '&lt;td style="{}"&gt;{}&lt;/td&gt;'.format(
                        _lookup_style(
                            "td", [cell_style, first_style, "name", new_extra_style]
                        ),
                        name,
                    ),
                    file=out,
                )
                if isinstance(value, list):
                    print(
                        '&lt;td style="{}"&gt;'.format(
                            _lookup_style(
                                "td",
                                [
                                    cell_style,
                                    second_style,
                                    "container",
                                    new_extra_style,
                                ],
                            )
                        ),
                        file=out,
                    )
                    _generate_html_table(value, out, level + 1, new_extra_style)
                    print("&lt;/td&gt;", file=out)
                else:
                    print(
                        '&lt;td style="{}"&gt;{}&lt;/td&gt;'.format(
                            _lookup_style(
                                "td",
                                [cell_style, second_style, "value", new_extra_style],
                            ),
                            html.escape(str(value)),
                        ),
                        file=out,
                    )
                print("&lt;/tr&gt;", file=out)
        elif isinstance(subdata, list):
            print('&lt;tr style="{}"&gt;'.format(_lookup_style("tr", [row_style])), file=out)
            print(
                '&lt;td style="{}"&gt;'.format(
                    _lookup_style(
                        "td", [cell_style, first_style, "container", extra_style]
                    )
                ),
                file=out,
            )
            _generate_html_table(subdata, out, level + 1, extra_style)
            print("&lt;/td&gt;", file=out)
            print("&lt;/tr&gt;", file=out)
        else:
            print('&lt;tr style="{}"&gt;'.format(_lookup_style("tr", [row_style])), file=out)
            print(
                '&lt;td style="{}"&gt;{}&lt;/td&gt;'.format(
                    _lookup_style(
                        "td", [cell_style, first_style, "value", extra_style]
                    ),
                    html.escape(str(subdata)),
                ),
                file=out,
            )
            print("&lt;/tr&gt;", file=out)
        firstone = False
    print("&lt;/table&gt;", file=out)


def _generate_html(data, out):
    """
    Generate report data as HTML
    """
    print("&lt;html&gt;", file=out)
    print("&lt;body&gt;", file=out)
    _generate_html_table(data, out, 0)
    print("&lt;/body&gt;", file=out)
    print("&lt;/html&gt;", file=out)


def _dict_to_name_value(data):
    """
    Convert a dictionary to a list of dictionaries to facilitate ordering
    """
    if isinstance(data, dict):
        sorted_data = sorted(data.items(), key=lambda s: s[0])
        result = []
        for name, value in sorted_data:
            if isinstance(value, dict):
                result.append({name: _dict_to_name_value(value)})
            else:
                result.append({name: value})
    else:
        result = data
    return result


def _generate_states_report(sorted_data):
    """
    Generate states report
    """
    states = []
    for state, data in sorted_data:
        module, stateid, name, function = state.split("_|-")
        module_function = ".".join((module, function))
        result = data.get("result", "")
        single = [
            {"function": module_function},
            {"name": name},
            {"result": result},
            {"duration": data.get("duration", 0.0)},
            {"comment": data.get("comment", "")},
        ]

        if not result:
            style = "failed"
        else:
            changes = data.get("changes", {})
            if changes and isinstance(changes, dict):
                single.append({"changes": _dict_to_name_value(changes)})
                style = "changed"
            else:
                style = "unchanged"

        started = data.get("start_time", "")
        if started:
            single.append({"started": started})

        states.append({stateid: single, "__style__": style})
    return states


def _generate_report(ret, setup):
    """
    Generate report dictionary
    """

    retdata = ret.get("return", {})

    sorted_data = sorted(retdata.items(), key=lambda s: s[1].get("__run_num__", 0))

    total = 0
    failed = 0
    changed = 0
    duration = 0.0

    # gather stats
    for _, data in sorted_data:
        if not data.get("result", True):
            failed += 1
        total += 1

        try:
            duration += float(data.get("duration", 0.0))
        except ValueError:
            pass

        if data.get("changes", {}):
            changed += 1

    unchanged = total - failed - changed

    log.debug("highstate total: %s", total)
    log.debug("highstate failed: %s", failed)
    log.debug("highstate unchanged: %s", unchanged)
    log.debug("highstate changed: %s", changed)

    # generate report if required
    if (
        setup.get("report_everything", False)
        or (setup.get("report_changes", True) and changed != 0)
        or (setup.get("report_failures", True) and failed != 0)
    ):

        report = [
            {
                "stats": [
                    {"total": total},
                    {"failed": failed, "__style__": "failed"},
                    {"unchanged": unchanged, "__style__": "unchanged"},
                    {"changed": changed, "__style__": "changed"},
                    {"duration": duration},
                ]
            },
            {
                "job": [
                    {"function": ret.get("fun", "")},
                    {"arguments": ret.get("fun_args", "")},
                    {"jid": ret.get("jid", "")},
                    {"success": ret.get("success", True)},
                    {"retcode": ret.get("retcode", 0)},
                ]
            },
            {"states": _generate_states_report(sorted_data)},
        ]

        if failed:
            function = setup.get("failure_function", None)
        else:
            function = setup.get("success_function", None)

        if function:
            func_result = __salt__[function]()
            report.insert(0, {"extra": [{function: _dict_to_name_value(func_result)}]})

    else:
        report = []

    return report, failed


def _sprinkle(config_str):
    """
    Sprinkle with grains of salt, that is
    convert 'test {id} test {host} ' types of strings
    """
    parts = [x for sub in config_str.split("{") for x in sub.split("}")]
    for i in range(1, len(parts), 2):
        parts[i] = str(__grains__.get(parts[i], ""))
    return "".join(parts)


def _produce_output(report, failed, setup):
    """
    Produce output from the report dictionary generated by _generate_report
    """
    report_format = setup.get("report_format", "yaml")

    log.debug("highstate output format: %s", report_format)

    if report_format == "json":
        report_text = salt.utils.json.dumps(report)
    elif report_format == "yaml":
        string_file = io.StringIO()
        salt.utils.yaml.safe_dump(report, string_file, default_flow_style=False)
        string_file.seek(0)
        report_text = string_file.read()
    else:
        string_file = io.StringIO()
        _generate_html(report, string_file)
        string_file.seek(0)
        report_text = string_file.read()

    report_delivery = setup.get("report_delivery", "file")

    log.debug("highstate report_delivery: %s", report_delivery)

    if report_delivery == "file":
        output_file = _sprinkle(setup.get("file_output", "/tmp/test.rpt"))
        with salt.utils.files.fopen(output_file, "w") as out:
            out.write(salt.utils.stringutils.to_str(report_text))
    else:
        msg = MIMEText(report_text, report_format)

        sender = setup.get("smtp_sender", "")
        recipients = setup.get("smtp_recipients", "")

        if failed:
            subject = setup.get("smtp_failure_subject", "Installation failure")
        else:
            subject = setup.get("smtp_success_subject", "Installation success")

        subject = _sprinkle(subject)

        msg["Subject"] = subject
        msg["From"] = sender
        msg["To"] = recipients

        smtp = smtplib.SMTP(host=setup.get("smtp_server", ""))
        smtp.sendmail(
            sender, [x.strip() for x in recipients.split(",")], msg.as_string()
        )
        smtp.quit()


def returner(ret):
    """
    Check highstate return information and possibly fire off an email
    or save a file.
    """
    setup = _get_options(ret)

    log.debug("highstate setup %s", setup)

    report, failed = _generate_report(ret, setup)
    if report:
        _produce_output(report, failed, setup)


def __test_html():
    """
    HTML generation test only used when called from the command line:
        python ./highstate.py
    Typical options for generating the report file:
    highstate:
        report_format: yaml
        report_delivery: file
        file_output: '/srv/salt/_returners/test.rpt'
    """
    with salt.utils.files.fopen("test.rpt", "r") as input_file:
        data_text = salt.utils.stringutils.to_unicode(input_file.read())
    data = salt.utils.yaml.safe_load(data_text)

    string_file = io.StringIO()
    _generate_html(data, string_file)
    string_file.seek(0)
    result = string_file.read()

    with salt.utils.files.fopen("test.html", "w") as output:
        output.write(salt.utils.stringutils.to_str(result))


if __name__ == "__main__":
    __test_html()
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
