
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 13, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-test_esptool.py</h3>
            <pre><code>1  import os
2  import os.path
3  import random
4  import re
5  import struct
6  import subprocess
7  import sys
8  import tempfile
9  import time
10  from socket import AF_INET, SOCK_STREAM, socket
11  from time import sleep
12  from conftest import (
13      arg_baud,
14      arg_chip,
15      arg_port,
16      arg_preload_port,
17      arg_trace,
18      need_to_install_package_err,
19  )
20  import pytest
21  try:
22      import esptool
23      import espefuse
24  except ImportError:
25      need_to_install_package_err()
26  import serial
27  TEST_DIR = os.path.abspath(os.path.dirname(__file__))
28  os.environ[&quot;ESPTOOL_TESTING&quot;] = &quot;1&quot;
29  print(&quot;Running esptool.py tests...&quot;)
30  class ESPRFC2217Server(object):
31      def __init__(self, rfc2217_port=None):
32          self.port = rfc2217_port or self.get_free_port()
33          self.cmd = [
34              sys.executable,
35              os.path.join(TEST_DIR, &quot;..&quot;, &quot;esp_rfc2217_server.py&quot;),
36              &quot;-p&quot;,
37              str(self.port),
38              arg_port,
39          ]
40          self.server_output_file = open(f&quot;{TEST_DIR}/{str(arg_chip)}_server.out&quot;, &quot;a&quot;)
41          self.server_output_file.write(&quot;************************************&quot;)
42          self.p = None
43          self.wait_for_server_starts(attempts_count=5)
44      @staticmethod
45      def get_free_port():
46          s = socket(AF_INET, SOCK_STREAM)
47          s.bind((&quot;&quot;, 0))
48          port = s.getsockname()[1]
49          s.close()
50          return port
51      def wait_for_server_starts(self, attempts_count):
52          for attempt in range(attempts_count):
53              try:
54                  self.p = subprocess.Popen(
55                      self.cmd,
56                      cwd=TEST_DIR,
57                      stdout=self.server_output_file,
58                      stderr=subprocess.STDOUT,
59                      close_fds=True,
60                  )
61                  sleep(2)
62                  s = socket(AF_INET, SOCK_STREAM)
63                  result = s.connect_ex((&quot;localhost&quot;, self.port))
64                  s.close()
65                  if result == 0:
66                      print(&quot;Server started successfully.&quot;)
67                      return
68              except Exception as e:
69                  print(e)
70              print(
71                  &quot;Server start failed.&quot;
72                  + (&quot; Retrying . . .&quot; if attempt &lt; attempts_count - 1 else &quot;&quot;)
73              )
74              self.p.terminate()
75          raise Exception(&quot;Server not started successfully!&quot;)
76      def __enter__(self):
77          return self
78      def __exit__(self, type, value, traceback):
79          self.server_output_file.close()
80          self.p.terminate()
81  @pytest.mark.flaky(reruns=1, condition=arg_preload_port is not False)
82  class EsptoolTestCase:
83      def run_espsecure(self, args):
84          cmd = [sys.executable, &quot;-m&quot;, &quot;espsecure&quot;] + args.split(&quot; &quot;)
85          print(&quot;\nExecuting {}...&quot;.format(&quot; &quot;.join(cmd)))
86          try:
87              output = subprocess.check_output(
88                  [str(s) for s in cmd], cwd=TEST_DIR, stderr=subprocess.STDOUT
89              )
90              output = output.decode(&quot;utf-8&quot;)
91              print(output)  # for more complete stdout logs on failure
92              return output
93          except subprocess.CalledProcessError as e:
94              print(e.output)
95              raise e
96      def run_esptool(self, args, baud=None, chip=None, port=None, preload=True):
97          def run_esptool_process(cmd):
98              print(&quot;Executing {}...&quot;.format(&quot; &quot;.join(cmd)))
99              try:
100                  output = subprocess.check_output(
101                      [str(s) for s in cmd],
102                      cwd=TEST_DIR,
103                      stderr=subprocess.STDOUT,
104                  )
105                  return output.decode(&quot;utf-8&quot;)
106              except subprocess.CalledProcessError as e:
107                  print(e.output.decode(&quot;utf-8&quot;))
108                  raise e
109          try:
110              esptool = [os.environ[&quot;ESPTOOL_PY&quot;]]
111          except KeyError:
112              esptool = [&quot;-m&quot;, &quot;esptool&quot;]
113          trace_arg = [&quot;--trace&quot;] if arg_trace else []
114          base_cmd = [sys.executable] + esptool + trace_arg
115          if chip or arg_chip is not None and chip != &quot;auto&quot;:
116              base_cmd += [&quot;--chip&quot;, chip or arg_chip]
117          if port or arg_port is not None:
118              base_cmd += [&quot;--port&quot;, port or arg_port]
119          if baud or arg_baud is not None:
120              base_cmd += [&quot;--baud&quot;, str(baud or arg_baud)]
121          usb_jtag_serial_reset = [&quot;--before&quot;, &quot;usb_reset&quot;] if arg_preload_port else []
122          full_cmd = base_cmd + usb_jtag_serial_reset + args.split(&quot; &quot;)
123          if (
124              preload
125              and arg_preload_port
126              and arg_chip
127              in [&quot;esp32c3&quot;, &quot;esp32s3&quot;, &quot;esp32c6&quot;, &quot;esp32h2&quot;]  # With USB-JTAG/Serial
128          ):
129              port_index = base_cmd.index(&quot;--port&quot;) + 1
130              base_cmd[port_index] = arg_preload_port  # Set the port to the preload one
131              preload_cmd = base_cmd + [
132                  &quot;--no-stub&quot;,
133                  &quot;load_ram&quot;,
134                  f&quot;{TEST_DIR}/images/ram_helloworld/helloworld-{arg_chip}.bin&quot;,
135              ]
136              print(&quot;\nPreloading dummy binary to disable RTC watchdog...&quot;)
137              run_esptool_process(preload_cmd)
138              print(&quot;Dummy binary preloaded successfully.&quot;)
139              time.sleep(0.3)  # Wait for the app to run and port to appear
140          print(f&#x27;\nRunning the &quot;{args}&quot; command...&#x27;)
141          output = run_esptool_process(full_cmd)
142          print(output)  # for more complete stdout logs on failure
143          return output
144      def run_esptool_error(self, args, baud=None):
145          with pytest.raises(subprocess.CalledProcessError) as fail:
146              self.run_esptool(args, baud)
147          failure = fail.value
148          assert failure.returncode == 2  # esptool.FatalError return code
149          return failure.output.decode(&quot;utf-8&quot;)
150      @classmethod
151      def setup_class(self):
152          print()
153          print(50 * &quot;*&quot;)
154          self.stored_dir = os.getcwd()
155          os.chdir(TEST_DIR)
156      @classmethod
157      def teardown_class(self):
158          os.chdir(self.stored_dir)
159      def readback(self, offset, length):
160          dump_file = tempfile.NamedTemporaryFile(delete=False)  # a file we can read into
161          try:
162              self.run_esptool(
163                  f&quot;--before default_reset read_flash {offset} {length} {dump_file.name}&quot;
164              )
165              with open(dump_file.name, &quot;rb&quot;) as f:
166                  rb = f.read()
167              assert length == len(
168                  rb
169              ), f&quot;read_flash length {length} offset {offset:#x} yielded {len(rb)} bytes!&quot;
170              return rb
171          finally:
172              dump_file.close()
173              os.unlink(dump_file.name)
174      def verify_readback(self, offset, length, compare_to, is_bootloader=False):
175          rb = self.readback(offset, length)
176          with open(compare_to, &quot;rb&quot;) as f:
177              ct = f.read()
178          if len(rb) != len(ct):
179              print(
180                  f&quot;WARNING: Expected length {len(ct)} doesn&#x27;t match comparison {len(rb)}&quot;
181              )
182          print(f&quot;Readback {len(rb)} bytes&quot;)
183          if is_bootloader:
184              assert ct[0] == rb[0], &quot;First bytes should be identical&quot;
185              rb = rb[8:]
186              ct = ct[8:]
187          for rb_b, ct_b, offs in zip(rb, ct, range(len(rb))):
188              assert (
189                  rb_b == ct_b
190              ), f&quot;First difference at offset {offs:#x} Expected {ct_b} got {rb_b}&quot;
191  @pytest.mark.skipif(arg_chip != &quot;esp32&quot;, reason=&quot;ESP32 only&quot;)
192  class TestFlashEncryption(EsptoolTestCase):
193      def valid_key_present(self):
194          try:
195              esp = esptool.ESP32ROM(arg_port)
196              esp.connect()
197              efuses, _ = espefuse.get_efuses(esp=esp)
198              blk1_rd_en = efuses[&quot;BLOCK1&quot;].is_readable()
199              return not blk1_rd_en
200          finally:
201              esp._port.close()
202      def test_blank_efuse_encrypt_write_abort(self):
203          if self.valid_key_present() is True:
204              pytest.skip(&quot;Valid encryption key already programmed, aborting the test&quot;)
205          self.run_esptool(
206              &quot;write_flash 0x1000 images/bootloader_esp32.bin &quot;
207              &quot;0x8000 images/partitions_singleapp.bin &quot;
208              &quot;0x10000 images/ram_helloworld/helloworld-esp32.bin&quot;
209          )
210          output = self.run_esptool_error(
211              &quot;write_flash --encrypt 0x10000 images/ram_helloworld/helloworld-esp32.bin&quot;
212          )
213          assert &quot;Flash encryption key is not programmed&quot;.lower() in output.lower()
214      def test_blank_efuse_encrypt_write_continue1(self):
215          if self.valid_key_present() is True:
216              pytest.skip(&quot;Valid encryption key already programmed, aborting the test&quot;)
217          self.run_esptool(
218              &quot;write_flash --encrypt --ignore-flash-encryption-efuse-setting &quot;
219              &quot;0x10000 images/ram_helloworld/helloworld-esp32.bin&quot;
220          )
221          self.run_esptool(&quot;read_flash 0x10000 192 images/read_encrypted_flash.bin&quot;)
222          self.run_espsecure(
223              &quot;encrypt_flash_data --address 0x10000 --keyfile images/aes_key.bin &quot;
224              &quot;--flash_crypt_conf 0 --output images/local_enc.bin &quot;
225              &quot;images/ram_helloworld/helloworld-esp32.bin&quot;
226          )
227          try:
228              with open(&quot;images/read_encrypted_flash.bin&quot;, &quot;rb&quot;) as file1:
229                  read_file1 = file1.read()
230              with open(&quot;images/local_enc.bin&quot;, &quot;rb&quot;) as file2:
231                  read_file2 = file2.read()
232              for rf1, rf2, i in zip(read_file1, read_file2, range(len(read_file2))):
233                  assert (
234                      rf1 == rf2
235                  ), f&quot;Encrypted write failed: file mismatch at byte position {i}&quot;
236              print(&quot;Encrypted write success&quot;)
237          finally:
238              os.remove(&quot;images/read_encrypted_flash.bin&quot;)
239              os.remove(&quot;images/local_enc.bin&quot;)
240      def test_blank_efuse_encrypt_write_continue2(self):
241          if self.valid_key_present() is True:
242              pytest.skip(&quot;Valid encryption key already programmed, aborting the test&quot;)
<span onclick='openModal()' class='match'>243          self.run_esptool(
244              &quot;write_flash --encrypt --ignore-flash-encryption-efuse-setting &quot;
245              &quot;0x10000 images/ram_helloworld/helloworld-esp32_edit.bin&quot;
246          )
247          self.run_esptool(&quot;read_flash 0x10000 192 images/read_encrypted_flash.bin&quot;)
248          self.run_espsecure(
</span>249              &quot;encrypt_flash_data --address 0x10000 --keyfile images/aes_key.bin &quot;
250              &quot;--flash_crypt_conf 0 --output images/local_enc.bin &quot;
251              &quot;images/ram_helloworld/helloworld-esp32.bin&quot;
252          )
253          try:
254              with open(&quot;images/read_encrypted_flash.bin&quot;, &quot;rb&quot;) as file1:
255                  read_file1 = file1.read()
256              with open(&quot;images/local_enc.bin&quot;, &quot;rb&quot;) as file2:
257                  read_file2 = file2.read()
258              mismatch = any(rf1 != rf2 for rf1, rf2 in zip(read_file1, read_file2))
259              assert mismatch, &quot;Files should mismatch&quot;
260          finally:
261              os.remove(&quot;images/read_encrypted_flash.bin&quot;)
262              os.remove(&quot;images/local_enc.bin&quot;)
263  class TestFlashing(EsptoolTestCase):
264      @pytest.mark.quick_test
265      def test_short_flash(self):
266          self.run_esptool(&quot;write_flash 0x0 images/one_kb.bin&quot;)
267          self.verify_readback(0, 1024, &quot;images/one_kb.bin&quot;)
268      @pytest.mark.quick_test
269      def test_highspeed_flash(self):
270          self.run_esptool(&quot;write_flash 0x0 images/fifty_kb.bin&quot;, baud=921600)
271          self.verify_readback(0, 50 * 1024, &quot;images/fifty_kb.bin&quot;)
272      def test_adjacent_flash(self):
273          self.run_esptool(&quot;write_flash 0x0 images/sector.bin 0x1000 images/fifty_kb.bin&quot;)
274          self.verify_readback(0, 4096, &quot;images/sector.bin&quot;)
275          self.verify_readback(4096, 50 * 1024, &quot;images/fifty_kb.bin&quot;)
276      def test_adjacent_independent_flash(self):
277          self.run_esptool(&quot;write_flash 0x0 images/sector.bin&quot;)
278          self.verify_readback(0, 4096, &quot;images/sector.bin&quot;)
279          self.run_esptool(&quot;write_flash 0x1000 images/fifty_kb.bin&quot;)
280          self.verify_readback(4096, 50 * 1024, &quot;images/fifty_kb.bin&quot;)
281          self.verify_readback(0, 4096, &quot;images/sector.bin&quot;)
282      @pytest.mark.skipif(
283          int(os.getenv(&quot;ESPTOOL_TEST_FLASH_SIZE&quot;, &quot;0&quot;)) &lt; 32, reason=&quot;needs 32MB flash&quot;
284      )
285      def test_last_bytes_of_32M_flash(self):
286          flash_size = 32 * 1024 * 1024
287          image_size = 1024
288          offset = flash_size - image_size
289          self.run_esptool(&quot;write_flash {} images/one_kb.bin&quot;.format(hex(offset)))
290          offset2 = offset &amp; 0xFFFFFF
291          self.run_esptool(&quot;write_flash {} images/one_kb_all_ef.bin&quot;.format(hex(offset2)))
292          self.verify_readback(offset, image_size, &quot;images/one_kb.bin&quot;)
293      @pytest.mark.skipif(
294          int(os.getenv(&quot;ESPTOOL_TEST_FLASH_SIZE&quot;, &quot;0&quot;)) &lt; 32, reason=&quot;needs 32MB flash&quot;
295      )
296      def test_write_larger_area_to_32M_flash(self):
297          offset = 18 * 1024 * 1024
298          self.run_esptool(&quot;write_flash {} images/one_mb.bin&quot;.format(hex(offset)))
299          offset2 = offset &amp; 0xFFFFFF
300          self.run_esptool(&quot;write_flash {} images/one_kb_all_ef.bin&quot;.format(hex(offset2)))
301          self.verify_readback(offset, 1 * 1024 * 1024, &quot;images/one_mb.bin&quot;)
302      def test_correct_offset(self):
303          self.run_esptool(&quot;write_flash 0x2000 images/sector.bin&quot;)
304          time.sleep(0.1)
305          three_sectors = self.readback(0, 0x3000)
306          last_sector = three_sectors[0x2000:]
307          with open(&quot;images/sector.bin&quot;, &quot;rb&quot;) as f:
308              ct = f.read()
309          assert last_sector == ct
310      @pytest.mark.quick_test
311      def test_no_compression_flash(self):
312          self.run_esptool(
313              &quot;write_flash -u 0x0 images/sector.bin 0x1000 images/fifty_kb.bin&quot;
314          )
315          self.verify_readback(0, 4096, &quot;images/sector.bin&quot;)
316          self.verify_readback(4096, 50 * 1024, &quot;images/fifty_kb.bin&quot;)
317      @pytest.mark.quick_test
318      @pytest.mark.skipif(arg_chip == &quot;esp8266&quot;, reason=&quot;Added in ESP32&quot;)
319      def test_compressed_nostub_flash(self):
320          self.run_esptool(
321              &quot;--no-stub write_flash -z 0x0 images/sector.bin 0x1000 images/fifty_kb.bin&quot;
322          )
323          self.verify_readback(0, 4096, &quot;images/sector.bin&quot;)
324          self.verify_readback(4096, 50 * 1024, &quot;images/fifty_kb.bin&quot;)
325      def _test_partition_table_then_bootloader(self, args):
326          self.run_esptool(args + &quot; 0x4000 images/partitions_singleapp.bin&quot;)
327          self.verify_readback(0x4000, 96, &quot;images/partitions_singleapp.bin&quot;)
328          self.run_esptool(args + &quot; 0x1000 images/bootloader_esp32.bin&quot;)
329          self.verify_readback(0x1000, 7888, &quot;images/bootloader_esp32.bin&quot;, True)
330          self.verify_readback(0x4000, 96, &quot;images/partitions_singleapp.bin&quot;)
331      def test_partition_table_then_bootloader(self):
332          self._test_partition_table_then_bootloader(&quot;write_flash --force&quot;)
333      def test_partition_table_then_bootloader_no_compression(self):
334          self._test_partition_table_then_bootloader(&quot;write_flash --force -u&quot;)
335      def test_partition_table_then_bootloader_nostub(self):
336          self._test_partition_table_then_bootloader(&quot;--no-stub write_flash --force&quot;)
337      def test_length_not_aligned_4bytes(self):
338          self.run_esptool(&quot;write_flash 0x0 images/not_4_byte_aligned.bin&quot;)
339      def test_length_not_aligned_4bytes_no_compression(self):
340          self.run_esptool(&quot;write_flash -u 0x0 images/not_4_byte_aligned.bin&quot;)
341      @pytest.mark.quick_test
342      @pytest.mark.host_test
343      def test_write_overlap(self):
344          output = self.run_esptool_error(
345              &quot;write_flash 0x0 images/bootloader_esp32.bin 0x1000 images/one_kb.bin&quot;
346          )
347          assert &quot;Detected overlap at address: 0x1000 &quot; in output
348      @pytest.mark.quick_test
349      @pytest.mark.host_test
350      def test_repeated_address(self):
351          output = self.run_esptool_error(
352              &quot;write_flash 0x0 images/one_kb.bin 0x0 images/one_kb.bin&quot;
353          )
354          assert &quot;Detected overlap at address: 0x0 &quot; in output
355      @pytest.mark.quick_test
356      @pytest.mark.host_test
357      def test_write_sector_overlap(self):
358          output = self.run_esptool_error(
359              &quot;write_flash 0xd00 images/one_kb.bin 0x1d00 images/one_kb.bin&quot;
360          )
361          assert &quot;Detected overlap at address: 0x1d00&quot; in output
362      def test_write_no_overlap(self):
363          output = self.run_esptool(
364              &quot;write_flash 0x0 images/one_kb.bin 0x2000 images/one_kb.bin&quot;
365          )
366          assert &quot;Detected overlap at address&quot; not in output
367      def test_compressible_file(self):
368          try:
369              input_file = tempfile.NamedTemporaryFile(delete=False)
370              file_size = 1024 * 1024
371              input_file.write(b&quot;\x00&quot; * file_size)
372              input_file.close()
373              self.run_esptool(f&quot;write_flash 0x10000 {input_file.name}&quot;)
374          finally:
375              os.unlink(input_file.name)
376      def test_compressible_non_trivial_file(self):
377          try:
378              input_file = tempfile.NamedTemporaryFile(delete=False)
379              file_size = 1000 * 1000
380              same_bytes = 8000
381              for _ in range(file_size // same_bytes):
382                  input_file.write(
383                      struct.pack(&quot;B&quot;, random.randrange(0, 1 &lt;&lt; 8)) * same_bytes
384                  )
385              input_file.close()
386              self.run_esptool(f&quot;write_flash 0x10000 {input_file.name}&quot;)
387          finally:
388              os.unlink(input_file.name)
389      @pytest.mark.quick_test
390      def test_zero_length(self):
391          output = self.run_esptool(
392              &quot;write_flash 0x10000 images/one_kb.bin 0x11000 images/zerolength.bin&quot;
393          )
394          self.verify_readback(0x10000, 1024, &quot;images/one_kb.bin&quot;)
395          assert &quot;zerolength.bin is empty&quot; in output
396      @pytest.mark.quick_test
397      def test_single_byte(self):
398          self.run_esptool(&quot;write_flash 0x0 images/onebyte.bin&quot;)
399          self.verify_readback(0x0, 1, &quot;images/onebyte.bin&quot;)
400      def test_erase_range_messages(self):
401          output = self.run_esptool(
402              &quot;write_flash 0x1000 images/sector.bin 0x0FC00 images/one_kb.bin&quot;
403          )
404          assert &quot;Flash will be erased from 0x00001000 to 0x00001fff...&quot; in output
405          assert (
406              &quot;WARNING: Flash address 0x0000fc00 is not aligned to a 0x1000 &quot;
407              &quot;byte flash sector. 0xc00 bytes before this address will be erased.&quot;
408              in output
409          )
410          assert &quot;Flash will be erased from 0x0000f000 to 0x0000ffff...&quot; in output
411      @pytest.mark.skipif(
412          arg_chip == &quot;esp8266&quot;, reason=&quot;chip_id field exist in ESP32 and later images&quot;
413      )
414      @pytest.mark.skipif(
415          arg_chip == &quot;esp32s3&quot;, reason=&quot;This is a valid ESP32-S3 image, would pass&quot;
416      )
417      def test_write_image_for_another_target(self):
418          output = self.run_esptool_error(
419              &quot;write_flash 0x0 images/esp32s3_header.bin 0x1000 images/one_kb.bin&quot;
420          )
421          assert &quot;Unexpected chip id in image.&quot; in output
422          assert &quot;value was 9. Is this image for a different chip model?&quot; in output
423          assert &quot;images/esp32s3_header.bin is not an &quot; in output
424          assert &quot;image. Use --force to flash anyway.&quot; in output
425      @pytest.mark.skipif(
426          arg_chip == &quot;esp8266&quot;, reason=&quot;chip_id field exist in ESP32 and later images&quot;
427      )
428      @pytest.mark.skipif(
429          arg_chip != &quot;esp32s3&quot;, reason=&quot;This check happens only on a valid image&quot;
430      )
431      def test_write_image_for_another_revision(self):
432          output = self.run_esptool_error(
433              &quot;write_flash 0x0 images/one_kb.bin 0x1000 images/esp32s3_header.bin&quot;
434          )
435          assert &quot;images/esp32s3_header.bin requires chip revision 10&quot; in output
436          assert &quot;or higher (this chip is revision&quot; in output
437          assert &quot;Use --force to flash anyway.&quot; in output
438      @pytest.mark.skipif(
439          arg_chip != &quot;esp32c3&quot;, reason=&quot;This check happens only on a valid image&quot;
440      )
441      def test_flash_with_min_max_rev(self):
442          output = self.run_esptool_error(
443              &quot;write_flash 0x0 images/one_kb.bin 0x1000 images/esp32c3_header_min_rev.bin&quot;
444          )
445          assert (
446              &quot;images/esp32c3_header_min_rev.bin &quot;
447              &quot;requires chip revision in range [v0.10 - max rev not set]&quot; in output
448          )
449          assert &quot;Use --force to flash anyway.&quot; in output
450      @pytest.mark.quick_test
451      def test_erase_before_write(self):
452          output = self.run_esptool(&quot;write_flash --erase-all 0x0 images/one_kb.bin&quot;)
453          assert &quot;Chip erase completed successfully&quot; in output
454          assert &quot;Hash of data verified&quot; in output
455  @pytest.mark.skipif(
456      arg_chip in [&quot;esp8266&quot;, &quot;esp32&quot;],
457      reason=&quot;get_security_info command is supported on ESP32S2 and later&quot;,
458  )
459  class TestSecurityInfo(EsptoolTestCase):
460      def test_show_security_info(self):
461          res = self.run_esptool(&quot;get_security_info&quot;)
462          assert &quot;Flags&quot; in res
463          assert &quot;Flash_Crypt_Cnt&quot; in res
464          assert &quot;Key_Purposes&quot; in res
465          if arg_chip != &quot;esp32s2&quot;:
466              esp = esptool.get_default_connected_device(
467                  [arg_port], arg_port, 10, 115200, arg_chip
468              )
469              assert f&quot;Chip_ID: {esp.IMAGE_CHIP_ID}&quot; in res
470              assert &quot;Api_Version&quot; in res
471  class TestFlashSizes(EsptoolTestCase):
472      def test_high_offset(self):
473          self.run_esptool(&quot;write_flash -fs 4MB 0x300000 images/one_kb.bin&quot;)
474          self.verify_readback(0x300000, 1024, &quot;images/one_kb.bin&quot;)
475      def test_high_offset_no_compression(self):
476          self.run_esptool(&quot;write_flash -u -fs 4MB 0x300000 images/one_kb.bin&quot;)
477          self.verify_readback(0x300000, 1024, &quot;images/one_kb.bin&quot;)
478      def test_large_image(self):
479          self.run_esptool(&quot;write_flash -fs 4MB 0x280000 images/one_mb.bin&quot;)
480          self.verify_readback(0x280000, 0x100000, &quot;images/one_mb.bin&quot;)
481      def test_large_no_compression(self):
482          self.run_esptool(&quot;write_flash -u -fs 4MB 0x280000 images/one_mb.bin&quot;)
483          self.verify_readback(0x280000, 0x100000, &quot;images/one_mb.bin&quot;)
484      @pytest.mark.quick_test
485      @pytest.mark.host_test
486      def test_invalid_size_arg(self):
487          self.run_esptool_error(&quot;write_flash -fs 10MB 0x6000 images/one_kb.bin&quot;)
488      def test_write_past_end_fails(self):
489          output = self.run_esptool_error(
490              &quot;write_flash -fs 1MB 0x280000 images/one_kb.bin&quot;
491          )
492          assert &quot;File images/one_kb.bin&quot; in output
493          assert &quot;will not fit&quot; in output
494      def test_write_no_compression_past_end_fails(self):
495          output = self.run_esptool_error(
496              &quot;write_flash -u -fs 1MB 0x280000 images/one_kb.bin&quot;
497          )
498          assert &quot;File images/one_kb.bin&quot; in output
499          assert &quot;will not fit&quot; in output
500      @pytest.mark.skipif(
501          arg_chip not in [&quot;esp8266&quot;, &quot;esp32&quot;, &quot;esp32c3&quot;],
502          reason=&quot;Don&#x27;t run on every chip, so other bootloader images are not needed&quot;,
503      )
504      def test_flash_size_keep(self):
505          offset = 0x1000 if arg_chip in [&quot;esp32&quot;, &quot;esp32s2&quot;] else 0x0
506          image = f&quot;images/bootloader_{arg_chip}.bin&quot;
507          with open(image, &quot;rb&quot;) as f:
508              f.seek(0, 2)
509              image_len = f.tell()
510          self.run_esptool(f&quot;write_flash -fs keep {offset} {image}&quot;)
511          self.verify_readback(offset, image_len, image)
512  class TestFlashDetection(EsptoolTestCase):
513      @pytest.mark.quick_test
514      def test_flash_id(self):
515          res = self.run_esptool(&quot;flash_id&quot;)
516          assert &quot;Manufacturer:&quot; in res
517          assert &quot;Device:&quot; in res
518      @pytest.mark.quick_test
519      def test_flash_id_expand_args(self):
520          try:
521              arg_file = tempfile.NamedTemporaryFile(delete=False)
522              arg_file.write(b&quot;flash_id\n&quot;)
523              arg_file.close()
524              res = self.run_esptool(f&quot;@{arg_file.name}&quot;)
525              assert &quot;Manufacturer:&quot; in res
526              assert &quot;Device:&quot; in res
527          finally:
528              os.unlink(arg_file.name)
529      @pytest.mark.quick_test
530      def test_flash_id_trace(self):
531          res = self.run_esptool(&quot;--trace flash_id&quot;)
532          assert re.search(r&quot;TRACE \+\d.\d{3} command op=0x0a .*&quot;, res) is not None
533          assert re.search(r&quot;TRACE \+\d.\d{3} command op=0x09 .*&quot;, res) is not None
534          assert re.search(r&quot;TRACE \+\d.\d{3} Read \d* bytes: .*&quot;, res) is not None
535          assert re.search(r&quot;TRACE \+\d.\d{3} Write \d* bytes: .*&quot;, res) is not None
536          assert re.search(r&quot;TRACE \+\d.\d{3} Received full packet: .*&quot;, res) is not None
537          assert (
538              re.search(r&quot;TRACE \+\d.\d{3} Received full packet: 4f484149&quot;, res)
539              is not None
540          )
541          assert &quot;Manufacturer:&quot; in res
542          assert &quot;Device:&quot; in res
543  @pytest.mark.skipif(
544      os.name == &quot;nt&quot;, reason=&quot;Temporarily disabled on windows&quot;
545  )  # TODO: ESPTOOL-673
546  class TestStubReuse(EsptoolTestCase):
547      def test_stub_reuse_with_synchronization(self):
548          res = self.run_esptool(
549              &quot;--after no_reset_stub flash_id&quot;
550          )  # flasher stub keeps running after this
551          assert &quot;Manufacturer:&quot; in res
552          res = self.run_esptool(
553              &quot;--before no_reset flash_id&quot;,
554              preload=False,
555          )  # do sync before (without reset it talks to the flasher stub)
556          assert &quot;Manufacturer:&quot; in res
557      @pytest.mark.skipif(arg_chip != &quot;esp8266&quot;, reason=&quot;ESP8266 only&quot;)
558      def test_stub_reuse_without_synchronization(self):
559          res = self.run_esptool(&quot;--after no_reset_stub flash_id&quot;)
560          assert &quot;Manufacturer:&quot; in res
561          res = self.run_esptool(&quot;--before no_reset_no_sync flash_id&quot;)
562          assert &quot;Manufacturer:&quot; in res
563  class TestErase(EsptoolTestCase):
564      @pytest.mark.quick_test
565      def test_chip_erase(self):
566          self.run_esptool(&quot;write_flash 0x10000 images/one_kb.bin&quot;)
567          self.verify_readback(0x10000, 0x400, &quot;images/one_kb.bin&quot;)
568          self.run_esptool(&quot;erase_flash&quot;)
569          empty = self.readback(0x10000, 0x400)
570          assert empty == b&quot;\xFF&quot; * 0x400
571      def test_region_erase(self):
572          self.run_esptool(&quot;write_flash 0x10000 images/one_kb.bin&quot;)
573          self.run_esptool(&quot;write_flash 0x11000 images/sector.bin&quot;)
574          self.verify_readback(0x10000, 0x400, &quot;images/one_kb.bin&quot;)
575          self.verify_readback(0x11000, 0x1000, &quot;images/sector.bin&quot;)
576          self.run_esptool(&quot;erase_region 0x10000 0x1000&quot;)
577          self.verify_readback(0x11000, 0x1000, &quot;images/sector.bin&quot;)
578          empty = self.readback(0x10000, 0x1000)
579          assert empty == b&quot;\xFF&quot; * 0x1000
580      def test_region_erase_all(self):
581          res = self.run_esptool(&quot;erase_region 0x0 ALL&quot;)
582          assert re.search(r&quot;Detected flash size: \d+[KM]B&quot;, res) is not None
583      def test_large_region_erase(self):
584          self.run_esptool(&quot;erase_region 0x0 0x100000&quot;)
585  class TestSectorBoundaries(EsptoolTestCase):
586      def test_end_sector(self):
587          self.run_esptool(&quot;write_flash 0x10000 images/sector.bin&quot;)
588          self.run_esptool(&quot;write_flash 0x0FC00 images/one_kb.bin&quot;)
589          self.verify_readback(0x0FC00, 0x400, &quot;images/one_kb.bin&quot;)
590          self.verify_readback(0x10000, 0x1000, &quot;images/sector.bin&quot;)
591      def test_end_sector_uncompressed(self):
592          self.run_esptool(&quot;write_flash -u 0x10000 images/sector.bin&quot;)
593          self.run_esptool(&quot;write_flash -u 0x0FC00 images/one_kb.bin&quot;)
594          self.verify_readback(0x0FC00, 0x400, &quot;images/one_kb.bin&quot;)
595          self.verify_readback(0x10000, 0x1000, &quot;images/sector.bin&quot;)
596      def test_overlap(self):
597          self.run_esptool(&quot;write_flash 0x20800 images/sector.bin&quot;)
598          self.verify_readback(0x20800, 0x1000, &quot;images/sector.bin&quot;)
599  class TestVerifyCommand(EsptoolTestCase):
600      @pytest.mark.quick_test
601      def test_verify_success(self):
602          self.run_esptool(&quot;write_flash 0x5000 images/one_kb.bin&quot;)
603          self.run_esptool(&quot;verify_flash 0x5000 images/one_kb.bin&quot;)
604      def test_verify_failure(self):
605          self.run_esptool(&quot;write_flash 0x6000 images/sector.bin&quot;)
606          output = self.run_esptool_error(
607              &quot;verify_flash --diff=yes 0x6000 images/one_kb.bin&quot;
608          )
609          assert &quot;verify FAILED&quot; in output
610          assert &quot;first @ 0x00006000&quot; in output
611      def test_verify_unaligned_length(self):
612          self.run_esptool(&quot;write_flash 0x0 images/not_4_byte_aligned.bin&quot;)
613          self.run_esptool(&quot;verify_flash 0x0 images/not_4_byte_aligned.bin&quot;)
614  class TestReadIdentityValues(EsptoolTestCase):
615      @pytest.mark.quick_test
616      def test_read_mac(self):
617          output = self.run_esptool(&quot;read_mac&quot;)
618          mac = re.search(r&quot;[0-9a-f:]{17}&quot;, output)
619          assert mac is not None
620          mac = mac.group(0)
621          assert mac != &quot;00:00:00:00:00:00&quot;
622          assert mac != &quot;ff:ff:ff:ff:ff:ff&quot;
623      @pytest.mark.skipif(arg_chip != &quot;esp8266&quot;, reason=&quot;ESP8266 only&quot;)
624      def test_read_chip_id(self):
625          output = self.run_esptool(&quot;chip_id&quot;)
626          idstr = re.search(&quot;Chip ID: 0x([0-9a-f]+)&quot;, output)
627          assert idstr is not None
628          idstr = idstr.group(1)
629          assert idstr != &quot;0&quot; * 8
630          assert idstr != &quot;f&quot; * 8
631  class TestMemoryOperations(EsptoolTestCase):
632      @pytest.mark.quick_test
633      def test_memory_dump(self):
634          output = self.run_esptool(&quot;dump_mem 0x50000000 128 memout.bin&quot;)
635          assert &quot;Read 128 bytes&quot; in output
636          os.remove(&quot;memout.bin&quot;)
637      def test_memory_write(self):
638          output = self.run_esptool(&quot;write_mem 0x400C0000 0xabad1dea 0x0000ffff&quot;)
639          assert &quot;Wrote abad1dea&quot; in output
640          assert &quot;mask 0000ffff&quot; in output
641          assert &quot;to 400c0000&quot; in output
642      def test_memory_read(self):
643          output = self.run_esptool(&quot;read_mem 0x400C0000&quot;)
644          assert &quot;0x400c0000 =&quot; in output
645  class TestKeepImageSettings(EsptoolTestCase):
646      @classmethod
647      def setup_class(self):
648          super(TestKeepImageSettings, self).setup_class()
649          self.BL_IMAGE = f&quot;images/bootloader_{arg_chip}.bin&quot;
650          self.flash_offset = (
651              0x1000 if arg_chip in (&quot;esp32&quot;, &quot;esp32s2&quot;) else 0
652          )  # bootloader offset
653          with open(self.BL_IMAGE, &quot;rb&quot;) as f:
654              self.header = f.read(8)
655      @pytest.mark.skipif(
656          arg_chip not in [&quot;esp8266&quot;, &quot;esp32&quot;, &quot;esp32c3&quot;],
657          reason=&quot;Don&#x27;t run on every chip, so other bootloader images are not needed&quot;,
658      )
659      def test_keep_does_not_change_settings(self):
660          self.run_esptool(f&quot;write_flash -fs keep {self.flash_offset:#x} {self.BL_IMAGE}&quot;)
661          self.verify_readback(self.flash_offset, 8, self.BL_IMAGE, False)
662          self.run_esptool(
663              f&quot;write_flash -fm keep -ff keep -fs keep &quot;
664              f&quot;{self.flash_offset:#x} {self.BL_IMAGE}&quot;
665          )
666          self.verify_readback(self.flash_offset, 8, self.BL_IMAGE, False)
667          self.run_esptool(
668              f&quot;verify_flash -fs keep {self.flash_offset:#x} {self.BL_IMAGE}&quot;
669          )
670      @pytest.mark.skipif(
671          arg_chip not in [&quot;esp8266&quot;, &quot;esp32&quot;, &quot;esp32c3&quot;],
672          reason=&quot;Don&#x27;t run for every chip, so other bootloader images are not needed&quot;,
673      )
674      @pytest.mark.quick_test
675      def test_detect_size_changes_size(self):
676          self.run_esptool(
677              f&quot;write_flash -fs detect {self.flash_offset:#x} {self.BL_IMAGE}&quot;
678          )
679          readback = self.readback(self.flash_offset, 8)
680          assert self.header[:3] == readback[:3]  # first 3 bytes unchanged
681          if arg_chip in [&quot;esp8266&quot;, &quot;esp32&quot;]:
682              assert self.header[3] != readback[3]  # size_freq byte changed
683          else:
684              assert self.header[3] == readback[3]  # size_freq byte unchanged
685          assert self.header[4:] == readback[4:]  # rest unchanged
686      @pytest.mark.skipif(
687          arg_chip not in [&quot;esp8266&quot;, &quot;esp32&quot;],
688          reason=&quot;Bootloader header needs to be modifiable - without sha256&quot;,
689      )
690      def test_explicit_set_size_freq_mode(self):
691          self.run_esptool(
692              f&quot;write_flash -fs 2MB -fm dout -ff 80m &quot;
693              f&quot;{self.flash_offset:#x} {self.BL_IMAGE}&quot;
694          )
695          readback = self.readback(self.flash_offset, 8)
696          assert self.header[0] == readback[0]
697          assert self.header[1] == readback[1]
698          assert (0x3F if arg_chip == &quot;esp8266&quot; else 0x1F) == readback[3]  # size_freq
699          assert 3 != self.header[2]  # original image not dout mode
700          assert 3 == readback[2]  # value in flash is dout mode
701          assert self.header[3] != readback[3]  # size/freq values have changed
702          assert self.header[4:] == readback[4:]  # entrypoint address hasn&#x27;t changed
703          self.run_esptool(
704              f&quot;verify_flash -fs 2MB -fm dout -ff 80m &quot;
705              f&quot;{self.flash_offset:#x} {self.BL_IMAGE}&quot;
706          )
707          self.run_esptool_error(f&quot;verify_flash {self.flash_offset:#x} {self.BL_IMAGE}&quot;)
708  @pytest.mark.skipif(
709      arg_chip in [&quot;esp32s2&quot;, &quot;esp32s3&quot;],
710      reason=&quot;Not supported on targets with USB-CDC.&quot;,
711  )
712  class TestLoadRAM(EsptoolTestCase):
713      @pytest.mark.quick_test
714      def test_load_ram(self):
715          self.run_esptool(f&quot;load_ram images/ram_helloworld/helloworld-{arg_chip}.bin&quot;)
716          try:
717              p = serial.serial_for_url(arg_port, arg_baud)
718              p.timeout = 5
719              output = p.read(100)
720              print(f&quot;Output: {output}&quot;)
721              assert (
722                  b&quot;Hello world!&quot; in output  # xtensa
723                  or b&#x27;\xce?\x13\x05\x04\xd0\x97A\x11&quot;\xc4\x06\xc67\x04&#x27; in output  # C3
724              )
725          finally:
726              p.close()
727  class TestDeepSleepFlash(EsptoolTestCase):
728      @pytest.mark.skipif(arg_chip != &quot;esp8266&quot;, reason=&quot;ESP8266 only&quot;)
729      def test_deep_sleep_flash(self):
730          self.run_esptool(&quot;write_flash 0x0 images/esp8266_deepsleep.bin&quot;, baud=230400)
731          time.sleep(0.25)  # give ESP8266 time to enter deep sleep
732          self.run_esptool(&quot;write_flash 0x0 images/fifty_kb.bin&quot;, baud=230400)
733          self.verify_readback(0, 50 * 1024, &quot;images/fifty_kb.bin&quot;)
734  class TestBootloaderHeaderRewriteCases(EsptoolTestCase):
735      @pytest.mark.skipif(
736          arg_chip not in [&quot;esp8266&quot;, &quot;esp32&quot;, &quot;esp32c3&quot;],
737          reason=&quot;Don&#x27;t run on every chip, so other bootloader images are not needed&quot;,
738      )
739      @pytest.mark.quick_test
740      def test_flash_header_rewrite(self):
741          bl_offset = 0x1000 if arg_chip in (&quot;esp32&quot;, &quot;esp32s2&quot;) else 0
742          bl_image = f&quot;images/bootloader_{arg_chip}.bin&quot;
743          output = self.run_esptool(
744              f&quot;write_flash -fm dout -ff 20m {bl_offset:#x} {bl_image}&quot;
745          )
746          if arg_chip in [&quot;esp8266&quot;, &quot;esp32&quot;]:
747              &quot;Flash params set to&quot; in output
748          else:
749              assert &quot;Flash params set to&quot; not in output
750              &quot;not changing the flash mode setting&quot; in output
751              &quot;not changing the flash frequency setting&quot; in output
752      def test_flash_header_no_magic_no_rewrite(self):
753          bl_offset = 0x1000 if arg_chip in (&quot;esp32&quot;, &quot;esp32s2&quot;) else 0
754          for image in [&quot;images/one_kb.bin&quot;, &quot;images/one_kb_all_ef.bin&quot;]:
755              output = self.run_esptool(
756                  f&quot;write_flash -fm dout -ff 20m {bl_offset:#x} {image}&quot;
757              )
758              &quot;not changing any flash settings&quot; in output
759              self.verify_readback(bl_offset, 1024, image)
760  class TestAutoDetect(EsptoolTestCase):
761      def _check_output(self, output):
762          expected_chip_name = esptool.util.expand_chip_name(arg_chip)
763          if arg_chip not in [&quot;esp8266&quot;, &quot;esp32&quot;, &quot;esp32s2&quot;]:
764              assert &quot;Unsupported detection protocol&quot; not in output
765          assert f&quot;Detecting chip type... {expected_chip_name}&quot; in output
766          assert f&quot;Chip is {expected_chip_name}&quot; in output
767      @pytest.mark.quick_test
768      def test_auto_detect(self):
769          output = self.run_esptool(&quot;chip_id&quot;, chip=&quot;auto&quot;)
770          self._check_output(output)
771  @pytest.mark.flaky(reruns=5)
772  @pytest.mark.skipif(arg_preload_port is not False, reason=&quot;USB-to-UART bridge only&quot;)
773  @pytest.mark.skipif(os.name == &quot;nt&quot;, reason=&quot;Linux/MacOS only&quot;)
774  class TestVirtualPort(TestAutoDetect):
775      def test_auto_detect_virtual_port(self):
776          with ESPRFC2217Server() as server:
777              output = self.run_esptool(
778                  &quot;chip_id&quot;,
779                  chip=&quot;auto&quot;,
780                  port=f&quot;rfc2217://localhost:{str(server.port)}?ign_set_control&quot;,
781              )
782              self._check_output(output)
783      def test_highspeed_flash_virtual_port(self):
784          with ESPRFC2217Server() as server:
785              rfc2217_port = f&quot;rfc2217://localhost:{str(server.port)}?ign_set_control&quot;
786              self.run_esptool(
787                  &quot;write_flash 0x0 images/fifty_kb.bin&quot;,
788                  baud=921600,
789                  port=rfc2217_port,
790              )
791          self.verify_readback(0, 50 * 1024, &quot;images/fifty_kb.bin&quot;)
792  @pytest.mark.quick_test
793  class TestReadWriteMemory(EsptoolTestCase):
794      def _test_read_write(self, esp):
795          test_addr = None
796          for test_region in [
797              &quot;RTC_DRAM&quot;,
798              &quot;RTC_DATA&quot;,
799              &quot;DRAM&quot;,
800          ]:  # find a probably-unused memory type
801              region = esp.get_memory_region(test_region)
802              if region:
803                  test_addr = region[1] - 8 if arg_chip == &quot;esp32c2&quot; else region[0]
804                  break
805          print(f&quot;Using test address {test_addr:#x}&quot;)
806          val = esp.read_reg(test_addr)  # verify we can read this word at all
807          try:
808              esp.write_reg(test_addr, 0x1234567)
809              assert esp.read_reg(test_addr) == 0x1234567
810              esp.write_reg(test_addr, 0, delay_us=100)
811              assert esp.read_reg(test_addr) == 0
812              esp.write_reg(test_addr, 0x555, delay_after_us=100)
813              assert esp.read_reg(test_addr) == 0x555
814          finally:
815              esp.write_reg(test_addr, val)  # write the original value, non-destructive
816              esp._port.close()
817      def test_read_write_memory_rom(self):
818          try:
819              esp = esptool.get_default_connected_device(
820                  [arg_port], arg_port, 10, 115200, arg_chip
821              )
822              self._test_read_write(esp)
823          finally:
824              esp._port.close()
825      def test_read_write_memory_stub(self):
826          try:
827              esp = esptool.get_default_connected_device(
828                  [arg_port], arg_port, 10, 115200, arg_chip
829              )
830              esp = esp.run_stub()
831              self._test_read_write(esp)
832          finally:
833              esp._port.close()
834      @pytest.mark.skipif(
835          arg_chip != &quot;esp32&quot;, reason=&quot;Could be unsupported by different flash&quot;
836      )
837      def test_read_write_flash_status(self):
838          res = self.run_esptool(&quot;read_flash_status&quot;)
839          match = re.search(r&quot;Status value: (0x[\d|a-f]*)&quot;, res)
840          assert match is not None
841          res = self.run_esptool(f&quot;write_flash_status {match.group(1)}&quot;)
842          assert f&quot;Initial flash status: {match.group(1)}&quot; in res
843          assert f&quot;Setting flash status: {match.group(1)}&quot; in res
844          assert f&quot;After flash status:   {match.group(1)}&quot; in res
845      def test_read_chip_description(self):
846          try:
847              esp = esptool.get_default_connected_device(
848                  [arg_port], arg_port, 10, 115200, arg_chip
849              )
850              chip = esp.get_chip_description()
851              assert &quot;unknown&quot; not in chip.lower()
852          finally:
853              esp._port.close()
854  @pytest.mark.skipif(
855      arg_chip != &quot;esp8266&quot;, reason=&quot;Make image option is supported only on ESP8266&quot;
856  )
857  class TestMakeImage(EsptoolTestCase):
858      def verify_image(self, offset, length, image, compare_to):
859          with open(image, &quot;rb&quot;) as f:
860              f.seek(offset)
861              rb = f.read(length)
862          with open(compare_to, &quot;rb&quot;) as f:
863              ct = f.read()
864          if len(rb) != len(ct):
865              print(
866                  f&quot;WARNING: Expected length {len(ct)} doesn&#x27;t match comparison {len(rb)}&quot;
867              )
868          print(f&quot;Readback {len(rb)} bytes&quot;)
869          for rb_b, ct_b, offs in zip(rb, ct, range(len(rb))):
870              assert (
871                  rb_b == ct_b
872              ), f&quot;First difference at offset {offs:#x} Expected {ct_b} got {rb_b}&quot;
873      def test_make_image(self):
874          output = self.run_esptool(
875              &quot;make_image test&quot;
876              &quot; -a 0x0 -f images/sector.bin -a 0x1000 -f images/fifty_kb.bin&quot;
877          )
878          try:
879              assert &quot;Successfully created esp8266 image.&quot; in output
880              assert os.path.exists(&quot;test0x00000.bin&quot;)
881              self.verify_image(16, 4096, &quot;test0x00000.bin&quot;, &quot;images/sector.bin&quot;)
882              self.verify_image(
883                  4096 + 24, 50 * 1024, &quot;test0x00000.bin&quot;, &quot;images/fifty_kb.bin&quot;
884              )
885          finally:
886              os.remove(&quot;test0x00000.bin&quot;)
887  @pytest.mark.skipif(arg_chip != &quot;esp32&quot;, reason=&quot;Don&#x27;t need to test multiple times&quot;)
888  @pytest.mark.quick_test
889  class TestConfigFile(EsptoolTestCase):
890      class ConfigFile:
891          def __init__(self, file_path, file_content):
892              self.file_path = file_path
893              self.file_content = file_content
894          def __enter__(self):
895              with open(self.file_path, &quot;w&quot;) as cfg_file:
896                  cfg_file.write(self.file_content)
897                  return cfg_file
898          def __exit__(self, exc_type, exc_value, exc_tb):
899              os.unlink(self.file_path)
900              assert not os.path.exists(self.file_path)
901      dummy_config = (
902          &quot;[esptool]\n&quot;
903          &quot;connect_attempts = 5\n&quot;
904          &quot;reset_delay = 1\n&quot;
905          &quot;serial_write_timeout = 12&quot;
906      )
907      @pytest.mark.host_test
908      def test_load_config_file(self):
909          config_file_path = os.path.join(os.getcwd(), &quot;esptool.cfg&quot;)
910          with self.ConfigFile(config_file_path, self.dummy_config):
911              output = self.run_esptool(&quot;version&quot;)
912              assert f&quot;Loaded custom configuration from {config_file_path}&quot; in output
913              assert &quot;Ignoring unknown config file option&quot; not in output
914              assert &quot;Ignoring invalid config file&quot; not in output
915          with self.ConfigFile(config_file_path, &quot;[wrong section name]&quot;):
916              output = self.run_esptool(&quot;version&quot;)
917              assert f&quot;Loaded custom configuration from {config_file_path}&quot; not in output
918          faulty_config = &quot;[esptool]\n&quot; &quot;connect_attempts = 5\n&quot; &quot;connect_attempts = 9\n&quot;
919          with self.ConfigFile(config_file_path, faulty_config):
920              output = self.run_esptool(&quot;version&quot;)
921              assert f&quot;Ignoring invalid config file {config_file_path}&quot; in output
922              assert (
923                  &quot;option &#x27;connect_attempts&#x27; in section &#x27;esptool&#x27; already exists&quot;
924                  in output
925              )
926          faulty_config = &quot;[esptool]\n&quot; &quot;connect_attempts = 9\n&quot; &quot;timout = 2\n&quot; &quot;bits = 2&quot;
927          with self.ConfigFile(config_file_path, faulty_config):
928              output = self.run_esptool(&quot;version&quot;)
929              assert &quot;Ignoring unknown config file options: bits, timout&quot; in output
930          config_file_path = os.path.join(os.getcwd(), &quot;tox.ini&quot;)
931          with self.ConfigFile(config_file_path, self.dummy_config):
932              output = self.run_esptool(&quot;version&quot;)
933              assert f&quot;Loaded custom configuration from {config_file_path}&quot; in output
934      @pytest.mark.host_test
935      def test_load_config_file_with_env_var(self):
936          config_file_path = os.path.join(TEST_DIR, &quot;custom_file.ini&quot;)
937          with self.ConfigFile(config_file_path, self.dummy_config):
938              output = self.run_esptool(&quot;version&quot;)
939              assert f&quot;Loaded custom configuration from {config_file_path}&quot; not in output
940              tmp = os.environ.get(&quot;ESPTOOL_CFGFILE&quot;)  # Save the env var if it is set
941              os.environ[&quot;ESPTOOL_CFGFILE&quot;] = config_file_path
942              output = self.run_esptool(&quot;version&quot;)
943              assert f&quot;Loaded custom configuration from {config_file_path}&quot; in output
944              assert &quot;(set with ESPTOOL_CFGFILE)&quot; in output
945              if tmp is not None:  # Restore the env var or unset it
946                  os.environ[&quot;ESPTOOL_CFGFILE&quot;] = tmp
947              else:
948                  os.environ.pop(&quot;ESPTOOL_CFGFILE&quot;, None)
949      def test_custom_reset_sequence(self):
950          reset_seq_config = (
951              &quot;[esptool]\n&quot;
952              &quot;custom_reset_sequence = D0|W0.1|R1|R0|W0.1|R1|R0\n&quot;
953              &quot;connect_attempts = 1\n&quot;
954          )
955          config_file_path = os.path.join(os.getcwd(), &quot;esptool.cfg&quot;)
956          with self.ConfigFile(config_file_path, reset_seq_config):
957              output = self.run_esptool_error(&quot;flash_id&quot;)
958              assert f&quot;Loaded custom configuration from {config_file_path}&quot; in output
959              assert &quot;A fatal error occurred: Failed to connect to&quot; in output
960              assert &quot;Connecting.............&quot; not in output
961          invalid_reset_seq_config = &quot;[esptool]\n&quot; &quot;custom_reset_sequence = F0|R1|C0|A5\n&quot;
962          with self.ConfigFile(config_file_path, invalid_reset_seq_config):
963              output = self.run_esptool_error(&quot;flash_id&quot;)
964              assert f&quot;Loaded custom configuration from {config_file_path}&quot; in output
965              assert &#x27;Invalid &quot;custom_reset_sequence&quot; option format:&#x27; in output
</code></pre>
        </div>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-test_esptool.py</h3>
            <pre><code>1  import os
2  import os.path
3  import random
4  import re
5  import struct
6  import subprocess
7  import sys
8  import tempfile
9  import time
10  from socket import AF_INET, SOCK_STREAM, socket
11  from time import sleep
12  from conftest import (
13      arg_baud,
14      arg_chip,
15      arg_port,
16      arg_preload_port,
17      arg_trace,
18      need_to_install_package_err,
19  )
20  import pytest
21  try:
22      import esptool
23      import espefuse
24  except ImportError:
25      need_to_install_package_err()
26  import serial
27  TEST_DIR = os.path.abspath(os.path.dirname(__file__))
28  os.environ[&quot;ESPTOOL_TESTING&quot;] = &quot;1&quot;
29  print(&quot;Running esptool.py tests...&quot;)
30  class ESPRFC2217Server(object):
31      def __init__(self, rfc2217_port=None):
32          self.port = rfc2217_port or self.get_free_port()
33          self.cmd = [
34              sys.executable,
35              os.path.join(TEST_DIR, &quot;..&quot;, &quot;esp_rfc2217_server.py&quot;),
36              &quot;-p&quot;,
37              str(self.port),
38              arg_port,
39          ]
40          self.server_output_file = open(f&quot;{TEST_DIR}/{str(arg_chip)}_server.out&quot;, &quot;a&quot;)
41          self.server_output_file.write(&quot;************************************&quot;)
42          self.p = None
43          self.wait_for_server_starts(attempts_count=5)
44      @staticmethod
45      def get_free_port():
46          s = socket(AF_INET, SOCK_STREAM)
47          s.bind((&quot;&quot;, 0))
48          port = s.getsockname()[1]
49          s.close()
50          return port
51      def wait_for_server_starts(self, attempts_count):
52          for attempt in range(attempts_count):
53              try:
54                  self.p = subprocess.Popen(
55                      self.cmd,
56                      cwd=TEST_DIR,
57                      stdout=self.server_output_file,
58                      stderr=subprocess.STDOUT,
59                      close_fds=True,
60                  )
61                  sleep(2)
62                  s = socket(AF_INET, SOCK_STREAM)
63                  result = s.connect_ex((&quot;localhost&quot;, self.port))
64                  s.close()
65                  if result == 0:
66                      print(&quot;Server started successfully.&quot;)
67                      return
68              except Exception as e:
69                  print(e)
70              print(
71                  &quot;Server start failed.&quot;
72                  + (&quot; Retrying . . .&quot; if attempt &lt; attempts_count - 1 else &quot;&quot;)
73              )
74              self.p.terminate()
75          raise Exception(&quot;Server not started successfully!&quot;)
76      def __enter__(self):
77          return self
78      def __exit__(self, type, value, traceback):
79          self.server_output_file.close()
80          self.p.terminate()
81  @pytest.mark.flaky(reruns=1, condition=arg_preload_port is not False)
82  class EsptoolTestCase:
83      def run_espsecure(self, args):
84          cmd = [sys.executable, &quot;-m&quot;, &quot;espsecure&quot;] + args.split(&quot; &quot;)
85          print(&quot;\nExecuting {}...&quot;.format(&quot; &quot;.join(cmd)))
86          try:
87              output = subprocess.check_output(
88                  [str(s) for s in cmd], cwd=TEST_DIR, stderr=subprocess.STDOUT
89              )
90              output = output.decode(&quot;utf-8&quot;)
91              print(output)  # for more complete stdout logs on failure
92              return output
93          except subprocess.CalledProcessError as e:
94              print(e.output)
95              raise e
96      def run_esptool(self, args, baud=None, chip=None, port=None, preload=True):
97          def run_esptool_process(cmd):
98              print(&quot;Executing {}...&quot;.format(&quot; &quot;.join(cmd)))
99              try:
100                  output = subprocess.check_output(
101                      [str(s) for s in cmd],
102                      cwd=TEST_DIR,
103                      stderr=subprocess.STDOUT,
104                  )
105                  return output.decode(&quot;utf-8&quot;)
106              except subprocess.CalledProcessError as e:
107                  print(e.output.decode(&quot;utf-8&quot;))
108                  raise e
109          try:
110              esptool = [os.environ[&quot;ESPTOOL_PY&quot;]]
111          except KeyError:
112              esptool = [&quot;-m&quot;, &quot;esptool&quot;]
113          trace_arg = [&quot;--trace&quot;] if arg_trace else []
114          base_cmd = [sys.executable] + esptool + trace_arg
115          if chip or arg_chip is not None and chip != &quot;auto&quot;:
116              base_cmd += [&quot;--chip&quot;, chip or arg_chip]
117          if port or arg_port is not None:
118              base_cmd += [&quot;--port&quot;, port or arg_port]
119          if baud or arg_baud is not None:
120              base_cmd += [&quot;--baud&quot;, str(baud or arg_baud)]
121          usb_jtag_serial_reset = [&quot;--before&quot;, &quot;usb_reset&quot;] if arg_preload_port else []
122          full_cmd = base_cmd + usb_jtag_serial_reset + args.split(&quot; &quot;)
123          if (
124              preload
125              and arg_preload_port
126              and arg_chip
127              in [&quot;esp32c3&quot;, &quot;esp32s3&quot;, &quot;esp32c6&quot;, &quot;esp32h2&quot;]  # With USB-JTAG/Serial
128          ):
129              port_index = base_cmd.index(&quot;--port&quot;) + 1
130              base_cmd[port_index] = arg_preload_port  # Set the port to the preload one
131              preload_cmd = base_cmd + [
132                  &quot;--no-stub&quot;,
133                  &quot;load_ram&quot;,
134                  f&quot;{TEST_DIR}/images/ram_helloworld/helloworld-{arg_chip}.bin&quot;,
135              ]
136              print(&quot;\nPreloading dummy binary to disable RTC watchdog...&quot;)
137              run_esptool_process(preload_cmd)
138              print(&quot;Dummy binary preloaded successfully.&quot;)
139              time.sleep(0.3)  # Wait for the app to run and port to appear
140          print(f&#x27;\nRunning the &quot;{args}&quot; command...&#x27;)
141          output = run_esptool_process(full_cmd)
142          print(output)  # for more complete stdout logs on failure
143          return output
144      def run_esptool_error(self, args, baud=None):
145          with pytest.raises(subprocess.CalledProcessError) as fail:
146              self.run_esptool(args, baud)
147          failure = fail.value
148          assert failure.returncode == 2  # esptool.FatalError return code
149          return failure.output.decode(&quot;utf-8&quot;)
150      @classmethod
151      def setup_class(self):
152          print()
153          print(50 * &quot;*&quot;)
154          self.stored_dir = os.getcwd()
155          os.chdir(TEST_DIR)
156      @classmethod
157      def teardown_class(self):
158          os.chdir(self.stored_dir)
159      def readback(self, offset, length):
160          dump_file = tempfile.NamedTemporaryFile(delete=False)  # a file we can read into
161          try:
162              self.run_esptool(
163                  f&quot;--before default_reset read_flash {offset} {length} {dump_file.name}&quot;
164              )
165              with open(dump_file.name, &quot;rb&quot;) as f:
166                  rb = f.read()
167              assert length == len(
168                  rb
169              ), f&quot;read_flash length {length} offset {offset:#x} yielded {len(rb)} bytes!&quot;
170              return rb
171          finally:
172              dump_file.close()
173              os.unlink(dump_file.name)
174      def verify_readback(self, offset, length, compare_to, is_bootloader=False):
175          rb = self.readback(offset, length)
176          with open(compare_to, &quot;rb&quot;) as f:
177              ct = f.read()
178          if len(rb) != len(ct):
179              print(
180                  f&quot;WARNING: Expected length {len(ct)} doesn&#x27;t match comparison {len(rb)}&quot;
181              )
182          print(f&quot;Readback {len(rb)} bytes&quot;)
183          if is_bootloader:
184              assert ct[0] == rb[0], &quot;First bytes should be identical&quot;
185              rb = rb[8:]
186              ct = ct[8:]
187          for rb_b, ct_b, offs in zip(rb, ct, range(len(rb))):
188              assert (
189                  rb_b == ct_b
190              ), f&quot;First difference at offset {offs:#x} Expected {ct_b} got {rb_b}&quot;
191  @pytest.mark.skipif(arg_chip != &quot;esp32&quot;, reason=&quot;ESP32 only&quot;)
192  class TestFlashEncryption(EsptoolTestCase):
193      def valid_key_present(self):
194          try:
195              esp = esptool.ESP32ROM(arg_port)
196              esp.connect()
197              efuses, _ = espefuse.get_efuses(esp=esp)
198              blk1_rd_en = efuses[&quot;BLOCK1&quot;].is_readable()
199              return not blk1_rd_en
200          finally:
201              esp._port.close()
202      def test_blank_efuse_encrypt_write_abort(self):
203          if self.valid_key_present() is True:
204              pytest.skip(&quot;Valid encryption key already programmed, aborting the test&quot;)
205          self.run_esptool(
206              &quot;write_flash 0x1000 images/bootloader_esp32.bin &quot;
207              &quot;0x8000 images/partitions_singleapp.bin &quot;
208              &quot;0x10000 images/ram_helloworld/helloworld-esp32.bin&quot;
209          )
210          output = self.run_esptool_error(
211              &quot;write_flash --encrypt 0x10000 images/ram_helloworld/helloworld-esp32.bin&quot;
212          )
213          assert &quot;Flash encryption key is not programmed&quot;.lower() in output.lower()
214      def test_blank_efuse_encrypt_write_continue1(self):
215          if self.valid_key_present() is True:
216              pytest.skip(&quot;Valid encryption key already programmed, aborting the test&quot;)
<span onclick='openModal()' class='match'>217          self.run_esptool(
218              &quot;write_flash --encrypt --ignore-flash-encryption-efuse-setting &quot;
219              &quot;0x10000 images/ram_helloworld/helloworld-esp32.bin&quot;
220          )
221          self.run_esptool(&quot;read_flash 0x10000 192 images/read_encrypted_flash.bin&quot;)
222          self.run_espsecure(
</span>223              &quot;encrypt_flash_data --address 0x10000 --keyfile images/aes_key.bin &quot;
224              &quot;--flash_crypt_conf 0 --output images/local_enc.bin &quot;
225              &quot;images/ram_helloworld/helloworld-esp32.bin&quot;
226          )
227          try:
228              with open(&quot;images/read_encrypted_flash.bin&quot;, &quot;rb&quot;) as file1:
229                  read_file1 = file1.read()
230              with open(&quot;images/local_enc.bin&quot;, &quot;rb&quot;) as file2:
231                  read_file2 = file2.read()
232              for rf1, rf2, i in zip(read_file1, read_file2, range(len(read_file2))):
233                  assert (
234                      rf1 == rf2
235                  ), f&quot;Encrypted write failed: file mismatch at byte position {i}&quot;
236              print(&quot;Encrypted write success&quot;)
237          finally:
238              os.remove(&quot;images/read_encrypted_flash.bin&quot;)
239              os.remove(&quot;images/local_enc.bin&quot;)
240      def test_blank_efuse_encrypt_write_continue2(self):
241          if self.valid_key_present() is True:
242              pytest.skip(&quot;Valid encryption key already programmed, aborting the test&quot;)
243          self.run_esptool(
244              &quot;write_flash --encrypt --ignore-flash-encryption-efuse-setting &quot;
245              &quot;0x10000 images/ram_helloworld/helloworld-esp32_edit.bin&quot;
246          )
247          self.run_esptool(&quot;read_flash 0x10000 192 images/read_encrypted_flash.bin&quot;)
248          self.run_espsecure(
249              &quot;encrypt_flash_data --address 0x10000 --keyfile images/aes_key.bin &quot;
250              &quot;--flash_crypt_conf 0 --output images/local_enc.bin &quot;
251              &quot;images/ram_helloworld/helloworld-esp32.bin&quot;
252          )
253          try:
254              with open(&quot;images/read_encrypted_flash.bin&quot;, &quot;rb&quot;) as file1:
255                  read_file1 = file1.read()
256              with open(&quot;images/local_enc.bin&quot;, &quot;rb&quot;) as file2:
257                  read_file2 = file2.read()
258              mismatch = any(rf1 != rf2 for rf1, rf2 in zip(read_file1, read_file2))
259              assert mismatch, &quot;Files should mismatch&quot;
260          finally:
261              os.remove(&quot;images/read_encrypted_flash.bin&quot;)
262              os.remove(&quot;images/local_enc.bin&quot;)
263  class TestFlashing(EsptoolTestCase):
264      @pytest.mark.quick_test
265      def test_short_flash(self):
266          self.run_esptool(&quot;write_flash 0x0 images/one_kb.bin&quot;)
267          self.verify_readback(0, 1024, &quot;images/one_kb.bin&quot;)
268      @pytest.mark.quick_test
269      def test_highspeed_flash(self):
270          self.run_esptool(&quot;write_flash 0x0 images/fifty_kb.bin&quot;, baud=921600)
271          self.verify_readback(0, 50 * 1024, &quot;images/fifty_kb.bin&quot;)
272      def test_adjacent_flash(self):
273          self.run_esptool(&quot;write_flash 0x0 images/sector.bin 0x1000 images/fifty_kb.bin&quot;)
274          self.verify_readback(0, 4096, &quot;images/sector.bin&quot;)
275          self.verify_readback(4096, 50 * 1024, &quot;images/fifty_kb.bin&quot;)
276      def test_adjacent_independent_flash(self):
277          self.run_esptool(&quot;write_flash 0x0 images/sector.bin&quot;)
278          self.verify_readback(0, 4096, &quot;images/sector.bin&quot;)
279          self.run_esptool(&quot;write_flash 0x1000 images/fifty_kb.bin&quot;)
280          self.verify_readback(4096, 50 * 1024, &quot;images/fifty_kb.bin&quot;)
281          self.verify_readback(0, 4096, &quot;images/sector.bin&quot;)
282      @pytest.mark.skipif(
283          int(os.getenv(&quot;ESPTOOL_TEST_FLASH_SIZE&quot;, &quot;0&quot;)) &lt; 32, reason=&quot;needs 32MB flash&quot;
284      )
285      def test_last_bytes_of_32M_flash(self):
286          flash_size = 32 * 1024 * 1024
287          image_size = 1024
288          offset = flash_size - image_size
289          self.run_esptool(&quot;write_flash {} images/one_kb.bin&quot;.format(hex(offset)))
290          offset2 = offset &amp; 0xFFFFFF
291          self.run_esptool(&quot;write_flash {} images/one_kb_all_ef.bin&quot;.format(hex(offset2)))
292          self.verify_readback(offset, image_size, &quot;images/one_kb.bin&quot;)
293      @pytest.mark.skipif(
294          int(os.getenv(&quot;ESPTOOL_TEST_FLASH_SIZE&quot;, &quot;0&quot;)) &lt; 32, reason=&quot;needs 32MB flash&quot;
295      )
296      def test_write_larger_area_to_32M_flash(self):
297          offset = 18 * 1024 * 1024
298          self.run_esptool(&quot;write_flash {} images/one_mb.bin&quot;.format(hex(offset)))
299          offset2 = offset &amp; 0xFFFFFF
300          self.run_esptool(&quot;write_flash {} images/one_kb_all_ef.bin&quot;.format(hex(offset2)))
301          self.verify_readback(offset, 1 * 1024 * 1024, &quot;images/one_mb.bin&quot;)
302      def test_correct_offset(self):
303          self.run_esptool(&quot;write_flash 0x2000 images/sector.bin&quot;)
304          time.sleep(0.1)
305          three_sectors = self.readback(0, 0x3000)
306          last_sector = three_sectors[0x2000:]
307          with open(&quot;images/sector.bin&quot;, &quot;rb&quot;) as f:
308              ct = f.read()
309          assert last_sector == ct
310      @pytest.mark.quick_test
311      def test_no_compression_flash(self):
312          self.run_esptool(
313              &quot;write_flash -u 0x0 images/sector.bin 0x1000 images/fifty_kb.bin&quot;
314          )
315          self.verify_readback(0, 4096, &quot;images/sector.bin&quot;)
316          self.verify_readback(4096, 50 * 1024, &quot;images/fifty_kb.bin&quot;)
317      @pytest.mark.quick_test
318      @pytest.mark.skipif(arg_chip == &quot;esp8266&quot;, reason=&quot;Added in ESP32&quot;)
319      def test_compressed_nostub_flash(self):
320          self.run_esptool(
321              &quot;--no-stub write_flash -z 0x0 images/sector.bin 0x1000 images/fifty_kb.bin&quot;
322          )
323          self.verify_readback(0, 4096, &quot;images/sector.bin&quot;)
324          self.verify_readback(4096, 50 * 1024, &quot;images/fifty_kb.bin&quot;)
325      def _test_partition_table_then_bootloader(self, args):
326          self.run_esptool(args + &quot; 0x4000 images/partitions_singleapp.bin&quot;)
327          self.verify_readback(0x4000, 96, &quot;images/partitions_singleapp.bin&quot;)
328          self.run_esptool(args + &quot; 0x1000 images/bootloader_esp32.bin&quot;)
329          self.verify_readback(0x1000, 7888, &quot;images/bootloader_esp32.bin&quot;, True)
330          self.verify_readback(0x4000, 96, &quot;images/partitions_singleapp.bin&quot;)
331      def test_partition_table_then_bootloader(self):
332          self._test_partition_table_then_bootloader(&quot;write_flash --force&quot;)
333      def test_partition_table_then_bootloader_no_compression(self):
334          self._test_partition_table_then_bootloader(&quot;write_flash --force -u&quot;)
335      def test_partition_table_then_bootloader_nostub(self):
336          self._test_partition_table_then_bootloader(&quot;--no-stub write_flash --force&quot;)
337      def test_length_not_aligned_4bytes(self):
338          self.run_esptool(&quot;write_flash 0x0 images/not_4_byte_aligned.bin&quot;)
339      def test_length_not_aligned_4bytes_no_compression(self):
340          self.run_esptool(&quot;write_flash -u 0x0 images/not_4_byte_aligned.bin&quot;)
341      @pytest.mark.quick_test
342      @pytest.mark.host_test
343      def test_write_overlap(self):
344          output = self.run_esptool_error(
345              &quot;write_flash 0x0 images/bootloader_esp32.bin 0x1000 images/one_kb.bin&quot;
346          )
347          assert &quot;Detected overlap at address: 0x1000 &quot; in output
348      @pytest.mark.quick_test
349      @pytest.mark.host_test
350      def test_repeated_address(self):
351          output = self.run_esptool_error(
352              &quot;write_flash 0x0 images/one_kb.bin 0x0 images/one_kb.bin&quot;
353          )
354          assert &quot;Detected overlap at address: 0x0 &quot; in output
355      @pytest.mark.quick_test
356      @pytest.mark.host_test
357      def test_write_sector_overlap(self):
358          output = self.run_esptool_error(
359              &quot;write_flash 0xd00 images/one_kb.bin 0x1d00 images/one_kb.bin&quot;
360          )
361          assert &quot;Detected overlap at address: 0x1d00&quot; in output
362      def test_write_no_overlap(self):
363          output = self.run_esptool(
364              &quot;write_flash 0x0 images/one_kb.bin 0x2000 images/one_kb.bin&quot;
365          )
366          assert &quot;Detected overlap at address&quot; not in output
367      def test_compressible_file(self):
368          try:
369              input_file = tempfile.NamedTemporaryFile(delete=False)
370              file_size = 1024 * 1024
371              input_file.write(b&quot;\x00&quot; * file_size)
372              input_file.close()
373              self.run_esptool(f&quot;write_flash 0x10000 {input_file.name}&quot;)
374          finally:
375              os.unlink(input_file.name)
376      def test_compressible_non_trivial_file(self):
377          try:
378              input_file = tempfile.NamedTemporaryFile(delete=False)
379              file_size = 1000 * 1000
380              same_bytes = 8000
381              for _ in range(file_size // same_bytes):
382                  input_file.write(
383                      struct.pack(&quot;B&quot;, random.randrange(0, 1 &lt;&lt; 8)) * same_bytes
384                  )
385              input_file.close()
386              self.run_esptool(f&quot;write_flash 0x10000 {input_file.name}&quot;)
387          finally:
388              os.unlink(input_file.name)
389      @pytest.mark.quick_test
390      def test_zero_length(self):
391          output = self.run_esptool(
392              &quot;write_flash 0x10000 images/one_kb.bin 0x11000 images/zerolength.bin&quot;
393          )
394          self.verify_readback(0x10000, 1024, &quot;images/one_kb.bin&quot;)
395          assert &quot;zerolength.bin is empty&quot; in output
396      @pytest.mark.quick_test
397      def test_single_byte(self):
398          self.run_esptool(&quot;write_flash 0x0 images/onebyte.bin&quot;)
399          self.verify_readback(0x0, 1, &quot;images/onebyte.bin&quot;)
400      def test_erase_range_messages(self):
401          output = self.run_esptool(
402              &quot;write_flash 0x1000 images/sector.bin 0x0FC00 images/one_kb.bin&quot;
403          )
404          assert &quot;Flash will be erased from 0x00001000 to 0x00001fff...&quot; in output
405          assert (
406              &quot;WARNING: Flash address 0x0000fc00 is not aligned to a 0x1000 &quot;
407              &quot;byte flash sector. 0xc00 bytes before this address will be erased.&quot;
408              in output
409          )
410          assert &quot;Flash will be erased from 0x0000f000 to 0x0000ffff...&quot; in output
411      @pytest.mark.skipif(
412          arg_chip == &quot;esp8266&quot;, reason=&quot;chip_id field exist in ESP32 and later images&quot;
413      )
414      @pytest.mark.skipif(
415          arg_chip == &quot;esp32s3&quot;, reason=&quot;This is a valid ESP32-S3 image, would pass&quot;
416      )
417      def test_write_image_for_another_target(self):
418          output = self.run_esptool_error(
419              &quot;write_flash 0x0 images/esp32s3_header.bin 0x1000 images/one_kb.bin&quot;
420          )
421          assert &quot;Unexpected chip id in image.&quot; in output
422          assert &quot;value was 9. Is this image for a different chip model?&quot; in output
423          assert &quot;images/esp32s3_header.bin is not an &quot; in output
424          assert &quot;image. Use --force to flash anyway.&quot; in output
425      @pytest.mark.skipif(
426          arg_chip == &quot;esp8266&quot;, reason=&quot;chip_id field exist in ESP32 and later images&quot;
427      )
428      @pytest.mark.skipif(
429          arg_chip != &quot;esp32s3&quot;, reason=&quot;This check happens only on a valid image&quot;
430      )
431      def test_write_image_for_another_revision(self):
432          output = self.run_esptool_error(
433              &quot;write_flash 0x0 images/one_kb.bin 0x1000 images/esp32s3_header.bin&quot;
434          )
435          assert &quot;images/esp32s3_header.bin requires chip revision 10&quot; in output
436          assert &quot;or higher (this chip is revision&quot; in output
437          assert &quot;Use --force to flash anyway.&quot; in output
438      @pytest.mark.skipif(
439          arg_chip != &quot;esp32c3&quot;, reason=&quot;This check happens only on a valid image&quot;
440      )
441      def test_flash_with_min_max_rev(self):
442          output = self.run_esptool_error(
443              &quot;write_flash 0x0 images/one_kb.bin 0x1000 images/esp32c3_header_min_rev.bin&quot;
444          )
445          assert (
446              &quot;images/esp32c3_header_min_rev.bin &quot;
447              &quot;requires chip revision in range [v0.10 - max rev not set]&quot; in output
448          )
449          assert &quot;Use --force to flash anyway.&quot; in output
450      @pytest.mark.quick_test
451      def test_erase_before_write(self):
452          output = self.run_esptool(&quot;write_flash --erase-all 0x0 images/one_kb.bin&quot;)
453          assert &quot;Chip erase completed successfully&quot; in output
454          assert &quot;Hash of data verified&quot; in output
455  @pytest.mark.skipif(
456      arg_chip in [&quot;esp8266&quot;, &quot;esp32&quot;],
457      reason=&quot;get_security_info command is supported on ESP32S2 and later&quot;,
458  )
459  class TestSecurityInfo(EsptoolTestCase):
460      def test_show_security_info(self):
461          res = self.run_esptool(&quot;get_security_info&quot;)
462          assert &quot;Flags&quot; in res
463          assert &quot;Flash_Crypt_Cnt&quot; in res
464          assert &quot;Key_Purposes&quot; in res
465          if arg_chip != &quot;esp32s2&quot;:
466              esp = esptool.get_default_connected_device(
467                  [arg_port], arg_port, 10, 115200, arg_chip
468              )
469              assert f&quot;Chip_ID: {esp.IMAGE_CHIP_ID}&quot; in res
470              assert &quot;Api_Version&quot; in res
471  class TestFlashSizes(EsptoolTestCase):
472      def test_high_offset(self):
473          self.run_esptool(&quot;write_flash -fs 4MB 0x300000 images/one_kb.bin&quot;)
474          self.verify_readback(0x300000, 1024, &quot;images/one_kb.bin&quot;)
475      def test_high_offset_no_compression(self):
476          self.run_esptool(&quot;write_flash -u -fs 4MB 0x300000 images/one_kb.bin&quot;)
477          self.verify_readback(0x300000, 1024, &quot;images/one_kb.bin&quot;)
478      def test_large_image(self):
479          self.run_esptool(&quot;write_flash -fs 4MB 0x280000 images/one_mb.bin&quot;)
480          self.verify_readback(0x280000, 0x100000, &quot;images/one_mb.bin&quot;)
481      def test_large_no_compression(self):
482          self.run_esptool(&quot;write_flash -u -fs 4MB 0x280000 images/one_mb.bin&quot;)
483          self.verify_readback(0x280000, 0x100000, &quot;images/one_mb.bin&quot;)
484      @pytest.mark.quick_test
485      @pytest.mark.host_test
486      def test_invalid_size_arg(self):
487          self.run_esptool_error(&quot;write_flash -fs 10MB 0x6000 images/one_kb.bin&quot;)
488      def test_write_past_end_fails(self):
489          output = self.run_esptool_error(
490              &quot;write_flash -fs 1MB 0x280000 images/one_kb.bin&quot;
491          )
492          assert &quot;File images/one_kb.bin&quot; in output
493          assert &quot;will not fit&quot; in output
494      def test_write_no_compression_past_end_fails(self):
495          output = self.run_esptool_error(
496              &quot;write_flash -u -fs 1MB 0x280000 images/one_kb.bin&quot;
497          )
498          assert &quot;File images/one_kb.bin&quot; in output
499          assert &quot;will not fit&quot; in output
500      @pytest.mark.skipif(
501          arg_chip not in [&quot;esp8266&quot;, &quot;esp32&quot;, &quot;esp32c3&quot;],
502          reason=&quot;Don&#x27;t run on every chip, so other bootloader images are not needed&quot;,
503      )
504      def test_flash_size_keep(self):
505          offset = 0x1000 if arg_chip in [&quot;esp32&quot;, &quot;esp32s2&quot;] else 0x0
506          image = f&quot;images/bootloader_{arg_chip}.bin&quot;
507          with open(image, &quot;rb&quot;) as f:
508              f.seek(0, 2)
509              image_len = f.tell()
510          self.run_esptool(f&quot;write_flash -fs keep {offset} {image}&quot;)
511          self.verify_readback(offset, image_len, image)
512  class TestFlashDetection(EsptoolTestCase):
513      @pytest.mark.quick_test
514      def test_flash_id(self):
515          res = self.run_esptool(&quot;flash_id&quot;)
516          assert &quot;Manufacturer:&quot; in res
517          assert &quot;Device:&quot; in res
518      @pytest.mark.quick_test
519      def test_flash_id_expand_args(self):
520          try:
521              arg_file = tempfile.NamedTemporaryFile(delete=False)
522              arg_file.write(b&quot;flash_id\n&quot;)
523              arg_file.close()
524              res = self.run_esptool(f&quot;@{arg_file.name}&quot;)
525              assert &quot;Manufacturer:&quot; in res
526              assert &quot;Device:&quot; in res
527          finally:
528              os.unlink(arg_file.name)
529      @pytest.mark.quick_test
530      def test_flash_id_trace(self):
531          res = self.run_esptool(&quot;--trace flash_id&quot;)
532          assert re.search(r&quot;TRACE \+\d.\d{3} command op=0x0a .*&quot;, res) is not None
533          assert re.search(r&quot;TRACE \+\d.\d{3} command op=0x09 .*&quot;, res) is not None
534          assert re.search(r&quot;TRACE \+\d.\d{3} Read \d* bytes: .*&quot;, res) is not None
535          assert re.search(r&quot;TRACE \+\d.\d{3} Write \d* bytes: .*&quot;, res) is not None
536          assert re.search(r&quot;TRACE \+\d.\d{3} Received full packet: .*&quot;, res) is not None
537          assert (
538              re.search(r&quot;TRACE \+\d.\d{3} Received full packet: 4f484149&quot;, res)
539              is not None
540          )
541          assert &quot;Manufacturer:&quot; in res
542          assert &quot;Device:&quot; in res
543  @pytest.mark.skipif(
544      os.name == &quot;nt&quot;, reason=&quot;Temporarily disabled on windows&quot;
545  )  # TODO: ESPTOOL-673
546  class TestStubReuse(EsptoolTestCase):
547      def test_stub_reuse_with_synchronization(self):
548          res = self.run_esptool(
549              &quot;--after no_reset_stub flash_id&quot;
550          )  # flasher stub keeps running after this
551          assert &quot;Manufacturer:&quot; in res
552          res = self.run_esptool(
553              &quot;--before no_reset flash_id&quot;,
554              preload=False,
555          )  # do sync before (without reset it talks to the flasher stub)
556          assert &quot;Manufacturer:&quot; in res
557      @pytest.mark.skipif(arg_chip != &quot;esp8266&quot;, reason=&quot;ESP8266 only&quot;)
558      def test_stub_reuse_without_synchronization(self):
559          res = self.run_esptool(&quot;--after no_reset_stub flash_id&quot;)
560          assert &quot;Manufacturer:&quot; in res
561          res = self.run_esptool(&quot;--before no_reset_no_sync flash_id&quot;)
562          assert &quot;Manufacturer:&quot; in res
563  class TestErase(EsptoolTestCase):
564      @pytest.mark.quick_test
565      def test_chip_erase(self):
566          self.run_esptool(&quot;write_flash 0x10000 images/one_kb.bin&quot;)
567          self.verify_readback(0x10000, 0x400, &quot;images/one_kb.bin&quot;)
568          self.run_esptool(&quot;erase_flash&quot;)
569          empty = self.readback(0x10000, 0x400)
570          assert empty == b&quot;\xFF&quot; * 0x400
571      def test_region_erase(self):
572          self.run_esptool(&quot;write_flash 0x10000 images/one_kb.bin&quot;)
573          self.run_esptool(&quot;write_flash 0x11000 images/sector.bin&quot;)
574          self.verify_readback(0x10000, 0x400, &quot;images/one_kb.bin&quot;)
575          self.verify_readback(0x11000, 0x1000, &quot;images/sector.bin&quot;)
576          self.run_esptool(&quot;erase_region 0x10000 0x1000&quot;)
577          self.verify_readback(0x11000, 0x1000, &quot;images/sector.bin&quot;)
578          empty = self.readback(0x10000, 0x1000)
579          assert empty == b&quot;\xFF&quot; * 0x1000
580      def test_region_erase_all(self):
581          res = self.run_esptool(&quot;erase_region 0x0 ALL&quot;)
582          assert re.search(r&quot;Detected flash size: \d+[KM]B&quot;, res) is not None
583      def test_large_region_erase(self):
584          self.run_esptool(&quot;erase_region 0x0 0x100000&quot;)
585  class TestSectorBoundaries(EsptoolTestCase):
586      def test_end_sector(self):
587          self.run_esptool(&quot;write_flash 0x10000 images/sector.bin&quot;)
588          self.run_esptool(&quot;write_flash 0x0FC00 images/one_kb.bin&quot;)
589          self.verify_readback(0x0FC00, 0x400, &quot;images/one_kb.bin&quot;)
590          self.verify_readback(0x10000, 0x1000, &quot;images/sector.bin&quot;)
591      def test_end_sector_uncompressed(self):
592          self.run_esptool(&quot;write_flash -u 0x10000 images/sector.bin&quot;)
593          self.run_esptool(&quot;write_flash -u 0x0FC00 images/one_kb.bin&quot;)
594          self.verify_readback(0x0FC00, 0x400, &quot;images/one_kb.bin&quot;)
595          self.verify_readback(0x10000, 0x1000, &quot;images/sector.bin&quot;)
596      def test_overlap(self):
597          self.run_esptool(&quot;write_flash 0x20800 images/sector.bin&quot;)
598          self.verify_readback(0x20800, 0x1000, &quot;images/sector.bin&quot;)
599  class TestVerifyCommand(EsptoolTestCase):
600      @pytest.mark.quick_test
601      def test_verify_success(self):
602          self.run_esptool(&quot;write_flash 0x5000 images/one_kb.bin&quot;)
603          self.run_esptool(&quot;verify_flash 0x5000 images/one_kb.bin&quot;)
604      def test_verify_failure(self):
605          self.run_esptool(&quot;write_flash 0x6000 images/sector.bin&quot;)
606          output = self.run_esptool_error(
607              &quot;verify_flash --diff=yes 0x6000 images/one_kb.bin&quot;
608          )
609          assert &quot;verify FAILED&quot; in output
610          assert &quot;first @ 0x00006000&quot; in output
611      def test_verify_unaligned_length(self):
612          self.run_esptool(&quot;write_flash 0x0 images/not_4_byte_aligned.bin&quot;)
613          self.run_esptool(&quot;verify_flash 0x0 images/not_4_byte_aligned.bin&quot;)
614  class TestReadIdentityValues(EsptoolTestCase):
615      @pytest.mark.quick_test
616      def test_read_mac(self):
617          output = self.run_esptool(&quot;read_mac&quot;)
618          mac = re.search(r&quot;[0-9a-f:]{17}&quot;, output)
619          assert mac is not None
620          mac = mac.group(0)
621          assert mac != &quot;00:00:00:00:00:00&quot;
622          assert mac != &quot;ff:ff:ff:ff:ff:ff&quot;
623      @pytest.mark.skipif(arg_chip != &quot;esp8266&quot;, reason=&quot;ESP8266 only&quot;)
624      def test_read_chip_id(self):
625          output = self.run_esptool(&quot;chip_id&quot;)
626          idstr = re.search(&quot;Chip ID: 0x([0-9a-f]+)&quot;, output)
627          assert idstr is not None
628          idstr = idstr.group(1)
629          assert idstr != &quot;0&quot; * 8
630          assert idstr != &quot;f&quot; * 8
631  class TestMemoryOperations(EsptoolTestCase):
632      @pytest.mark.quick_test
633      def test_memory_dump(self):
634          output = self.run_esptool(&quot;dump_mem 0x50000000 128 memout.bin&quot;)
635          assert &quot;Read 128 bytes&quot; in output
636          os.remove(&quot;memout.bin&quot;)
637      def test_memory_write(self):
638          output = self.run_esptool(&quot;write_mem 0x400C0000 0xabad1dea 0x0000ffff&quot;)
639          assert &quot;Wrote abad1dea&quot; in output
640          assert &quot;mask 0000ffff&quot; in output
641          assert &quot;to 400c0000&quot; in output
642      def test_memory_read(self):
643          output = self.run_esptool(&quot;read_mem 0x400C0000&quot;)
644          assert &quot;0x400c0000 =&quot; in output
645  class TestKeepImageSettings(EsptoolTestCase):
646      @classmethod
647      def setup_class(self):
648          super(TestKeepImageSettings, self).setup_class()
649          self.BL_IMAGE = f&quot;images/bootloader_{arg_chip}.bin&quot;
650          self.flash_offset = (
651              0x1000 if arg_chip in (&quot;esp32&quot;, &quot;esp32s2&quot;) else 0
652          )  # bootloader offset
653          with open(self.BL_IMAGE, &quot;rb&quot;) as f:
654              self.header = f.read(8)
655      @pytest.mark.skipif(
656          arg_chip not in [&quot;esp8266&quot;, &quot;esp32&quot;, &quot;esp32c3&quot;],
657          reason=&quot;Don&#x27;t run on every chip, so other bootloader images are not needed&quot;,
658      )
659      def test_keep_does_not_change_settings(self):
660          self.run_esptool(f&quot;write_flash -fs keep {self.flash_offset:#x} {self.BL_IMAGE}&quot;)
661          self.verify_readback(self.flash_offset, 8, self.BL_IMAGE, False)
662          self.run_esptool(
663              f&quot;write_flash -fm keep -ff keep -fs keep &quot;
664              f&quot;{self.flash_offset:#x} {self.BL_IMAGE}&quot;
665          )
666          self.verify_readback(self.flash_offset, 8, self.BL_IMAGE, False)
667          self.run_esptool(
668              f&quot;verify_flash -fs keep {self.flash_offset:#x} {self.BL_IMAGE}&quot;
669          )
670      @pytest.mark.skipif(
671          arg_chip not in [&quot;esp8266&quot;, &quot;esp32&quot;, &quot;esp32c3&quot;],
672          reason=&quot;Don&#x27;t run for every chip, so other bootloader images are not needed&quot;,
673      )
674      @pytest.mark.quick_test
675      def test_detect_size_changes_size(self):
676          self.run_esptool(
677              f&quot;write_flash -fs detect {self.flash_offset:#x} {self.BL_IMAGE}&quot;
678          )
679          readback = self.readback(self.flash_offset, 8)
680          assert self.header[:3] == readback[:3]  # first 3 bytes unchanged
681          if arg_chip in [&quot;esp8266&quot;, &quot;esp32&quot;]:
682              assert self.header[3] != readback[3]  # size_freq byte changed
683          else:
684              assert self.header[3] == readback[3]  # size_freq byte unchanged
685          assert self.header[4:] == readback[4:]  # rest unchanged
686      @pytest.mark.skipif(
687          arg_chip not in [&quot;esp8266&quot;, &quot;esp32&quot;],
688          reason=&quot;Bootloader header needs to be modifiable - without sha256&quot;,
689      )
690      def test_explicit_set_size_freq_mode(self):
691          self.run_esptool(
692              f&quot;write_flash -fs 2MB -fm dout -ff 80m &quot;
693              f&quot;{self.flash_offset:#x} {self.BL_IMAGE}&quot;
694          )
695          readback = self.readback(self.flash_offset, 8)
696          assert self.header[0] == readback[0]
697          assert self.header[1] == readback[1]
698          assert (0x3F if arg_chip == &quot;esp8266&quot; else 0x1F) == readback[3]  # size_freq
699          assert 3 != self.header[2]  # original image not dout mode
700          assert 3 == readback[2]  # value in flash is dout mode
701          assert self.header[3] != readback[3]  # size/freq values have changed
702          assert self.header[4:] == readback[4:]  # entrypoint address hasn&#x27;t changed
703          self.run_esptool(
704              f&quot;verify_flash -fs 2MB -fm dout -ff 80m &quot;
705              f&quot;{self.flash_offset:#x} {self.BL_IMAGE}&quot;
706          )
707          self.run_esptool_error(f&quot;verify_flash {self.flash_offset:#x} {self.BL_IMAGE}&quot;)
708  @pytest.mark.skipif(
709      arg_chip in [&quot;esp32s2&quot;, &quot;esp32s3&quot;],
710      reason=&quot;Not supported on targets with USB-CDC.&quot;,
711  )
712  class TestLoadRAM(EsptoolTestCase):
713      @pytest.mark.quick_test
714      def test_load_ram(self):
715          self.run_esptool(f&quot;load_ram images/ram_helloworld/helloworld-{arg_chip}.bin&quot;)
716          try:
717              p = serial.serial_for_url(arg_port, arg_baud)
718              p.timeout = 5
719              output = p.read(100)
720              print(f&quot;Output: {output}&quot;)
721              assert (
722                  b&quot;Hello world!&quot; in output  # xtensa
723                  or b&#x27;\xce?\x13\x05\x04\xd0\x97A\x11&quot;\xc4\x06\xc67\x04&#x27; in output  # C3
724              )
725          finally:
726              p.close()
727  class TestDeepSleepFlash(EsptoolTestCase):
728      @pytest.mark.skipif(arg_chip != &quot;esp8266&quot;, reason=&quot;ESP8266 only&quot;)
729      def test_deep_sleep_flash(self):
730          self.run_esptool(&quot;write_flash 0x0 images/esp8266_deepsleep.bin&quot;, baud=230400)
731          time.sleep(0.25)  # give ESP8266 time to enter deep sleep
732          self.run_esptool(&quot;write_flash 0x0 images/fifty_kb.bin&quot;, baud=230400)
733          self.verify_readback(0, 50 * 1024, &quot;images/fifty_kb.bin&quot;)
734  class TestBootloaderHeaderRewriteCases(EsptoolTestCase):
735      @pytest.mark.skipif(
736          arg_chip not in [&quot;esp8266&quot;, &quot;esp32&quot;, &quot;esp32c3&quot;],
737          reason=&quot;Don&#x27;t run on every chip, so other bootloader images are not needed&quot;,
738      )
739      @pytest.mark.quick_test
740      def test_flash_header_rewrite(self):
741          bl_offset = 0x1000 if arg_chip in (&quot;esp32&quot;, &quot;esp32s2&quot;) else 0
742          bl_image = f&quot;images/bootloader_{arg_chip}.bin&quot;
743          output = self.run_esptool(
744              f&quot;write_flash -fm dout -ff 20m {bl_offset:#x} {bl_image}&quot;
745          )
746          if arg_chip in [&quot;esp8266&quot;, &quot;esp32&quot;]:
747              &quot;Flash params set to&quot; in output
748          else:
749              assert &quot;Flash params set to&quot; not in output
750              &quot;not changing the flash mode setting&quot; in output
751              &quot;not changing the flash frequency setting&quot; in output
752      def test_flash_header_no_magic_no_rewrite(self):
753          bl_offset = 0x1000 if arg_chip in (&quot;esp32&quot;, &quot;esp32s2&quot;) else 0
754          for image in [&quot;images/one_kb.bin&quot;, &quot;images/one_kb_all_ef.bin&quot;]:
755              output = self.run_esptool(
756                  f&quot;write_flash -fm dout -ff 20m {bl_offset:#x} {image}&quot;
757              )
758              &quot;not changing any flash settings&quot; in output
759              self.verify_readback(bl_offset, 1024, image)
760  class TestAutoDetect(EsptoolTestCase):
761      def _check_output(self, output):
762          expected_chip_name = esptool.util.expand_chip_name(arg_chip)
763          if arg_chip not in [&quot;esp8266&quot;, &quot;esp32&quot;, &quot;esp32s2&quot;]:
764              assert &quot;Unsupported detection protocol&quot; not in output
765          assert f&quot;Detecting chip type... {expected_chip_name}&quot; in output
766          assert f&quot;Chip is {expected_chip_name}&quot; in output
767      @pytest.mark.quick_test
768      def test_auto_detect(self):
769          output = self.run_esptool(&quot;chip_id&quot;, chip=&quot;auto&quot;)
770          self._check_output(output)
771  @pytest.mark.flaky(reruns=5)
772  @pytest.mark.skipif(arg_preload_port is not False, reason=&quot;USB-to-UART bridge only&quot;)
773  @pytest.mark.skipif(os.name == &quot;nt&quot;, reason=&quot;Linux/MacOS only&quot;)
774  class TestVirtualPort(TestAutoDetect):
775      def test_auto_detect_virtual_port(self):
776          with ESPRFC2217Server() as server:
777              output = self.run_esptool(
778                  &quot;chip_id&quot;,
779                  chip=&quot;auto&quot;,
780                  port=f&quot;rfc2217://localhost:{str(server.port)}?ign_set_control&quot;,
781              )
782              self._check_output(output)
783      def test_highspeed_flash_virtual_port(self):
784          with ESPRFC2217Server() as server:
785              rfc2217_port = f&quot;rfc2217://localhost:{str(server.port)}?ign_set_control&quot;
786              self.run_esptool(
787                  &quot;write_flash 0x0 images/fifty_kb.bin&quot;,
788                  baud=921600,
789                  port=rfc2217_port,
790              )
791          self.verify_readback(0, 50 * 1024, &quot;images/fifty_kb.bin&quot;)
792  @pytest.mark.quick_test
793  class TestReadWriteMemory(EsptoolTestCase):
794      def _test_read_write(self, esp):
795          test_addr = None
796          for test_region in [
797              &quot;RTC_DRAM&quot;,
798              &quot;RTC_DATA&quot;,
799              &quot;DRAM&quot;,
800          ]:  # find a probably-unused memory type
801              region = esp.get_memory_region(test_region)
802              if region:
803                  test_addr = region[1] - 8 if arg_chip == &quot;esp32c2&quot; else region[0]
804                  break
805          print(f&quot;Using test address {test_addr:#x}&quot;)
806          val = esp.read_reg(test_addr)  # verify we can read this word at all
807          try:
808              esp.write_reg(test_addr, 0x1234567)
809              assert esp.read_reg(test_addr) == 0x1234567
810              esp.write_reg(test_addr, 0, delay_us=100)
811              assert esp.read_reg(test_addr) == 0
812              esp.write_reg(test_addr, 0x555, delay_after_us=100)
813              assert esp.read_reg(test_addr) == 0x555
814          finally:
815              esp.write_reg(test_addr, val)  # write the original value, non-destructive
816              esp._port.close()
817      def test_read_write_memory_rom(self):
818          try:
819              esp = esptool.get_default_connected_device(
820                  [arg_port], arg_port, 10, 115200, arg_chip
821              )
822              self._test_read_write(esp)
823          finally:
824              esp._port.close()
825      def test_read_write_memory_stub(self):
826          try:
827              esp = esptool.get_default_connected_device(
828                  [arg_port], arg_port, 10, 115200, arg_chip
829              )
830              esp = esp.run_stub()
831              self._test_read_write(esp)
832          finally:
833              esp._port.close()
834      @pytest.mark.skipif(
835          arg_chip != &quot;esp32&quot;, reason=&quot;Could be unsupported by different flash&quot;
836      )
837      def test_read_write_flash_status(self):
838          res = self.run_esptool(&quot;read_flash_status&quot;)
839          match = re.search(r&quot;Status value: (0x[\d|a-f]*)&quot;, res)
840          assert match is not None
841          res = self.run_esptool(f&quot;write_flash_status {match.group(1)}&quot;)
842          assert f&quot;Initial flash status: {match.group(1)}&quot; in res
843          assert f&quot;Setting flash status: {match.group(1)}&quot; in res
844          assert f&quot;After flash status:   {match.group(1)}&quot; in res
845      def test_read_chip_description(self):
846          try:
847              esp = esptool.get_default_connected_device(
848                  [arg_port], arg_port, 10, 115200, arg_chip
849              )
850              chip = esp.get_chip_description()
851              assert &quot;unknown&quot; not in chip.lower()
852          finally:
853              esp._port.close()
854  @pytest.mark.skipif(
855      arg_chip != &quot;esp8266&quot;, reason=&quot;Make image option is supported only on ESP8266&quot;
856  )
857  class TestMakeImage(EsptoolTestCase):
858      def verify_image(self, offset, length, image, compare_to):
859          with open(image, &quot;rb&quot;) as f:
860              f.seek(offset)
861              rb = f.read(length)
862          with open(compare_to, &quot;rb&quot;) as f:
863              ct = f.read()
864          if len(rb) != len(ct):
865              print(
866                  f&quot;WARNING: Expected length {len(ct)} doesn&#x27;t match comparison {len(rb)}&quot;
867              )
868          print(f&quot;Readback {len(rb)} bytes&quot;)
869          for rb_b, ct_b, offs in zip(rb, ct, range(len(rb))):
870              assert (
871                  rb_b == ct_b
872              ), f&quot;First difference at offset {offs:#x} Expected {ct_b} got {rb_b}&quot;
873      def test_make_image(self):
874          output = self.run_esptool(
875              &quot;make_image test&quot;
876              &quot; -a 0x0 -f images/sector.bin -a 0x1000 -f images/fifty_kb.bin&quot;
877          )
878          try:
879              assert &quot;Successfully created esp8266 image.&quot; in output
880              assert os.path.exists(&quot;test0x00000.bin&quot;)
881              self.verify_image(16, 4096, &quot;test0x00000.bin&quot;, &quot;images/sector.bin&quot;)
882              self.verify_image(
883                  4096 + 24, 50 * 1024, &quot;test0x00000.bin&quot;, &quot;images/fifty_kb.bin&quot;
884              )
885          finally:
886              os.remove(&quot;test0x00000.bin&quot;)
887  @pytest.mark.skipif(arg_chip != &quot;esp32&quot;, reason=&quot;Don&#x27;t need to test multiple times&quot;)
888  @pytest.mark.quick_test
889  class TestConfigFile(EsptoolTestCase):
890      class ConfigFile:
891          def __init__(self, file_path, file_content):
892              self.file_path = file_path
893              self.file_content = file_content
894          def __enter__(self):
895              with open(self.file_path, &quot;w&quot;) as cfg_file:
896                  cfg_file.write(self.file_content)
897                  return cfg_file
898          def __exit__(self, exc_type, exc_value, exc_tb):
899              os.unlink(self.file_path)
900              assert not os.path.exists(self.file_path)
901      dummy_config = (
902          &quot;[esptool]\n&quot;
903          &quot;connect_attempts = 5\n&quot;
904          &quot;reset_delay = 1\n&quot;
905          &quot;serial_write_timeout = 12&quot;
906      )
907      @pytest.mark.host_test
908      def test_load_config_file(self):
909          config_file_path = os.path.join(os.getcwd(), &quot;esptool.cfg&quot;)
910          with self.ConfigFile(config_file_path, self.dummy_config):
911              output = self.run_esptool(&quot;version&quot;)
912              assert f&quot;Loaded custom configuration from {config_file_path}&quot; in output
913              assert &quot;Ignoring unknown config file option&quot; not in output
914              assert &quot;Ignoring invalid config file&quot; not in output
915          with self.ConfigFile(config_file_path, &quot;[wrong section name]&quot;):
916              output = self.run_esptool(&quot;version&quot;)
917              assert f&quot;Loaded custom configuration from {config_file_path}&quot; not in output
918          faulty_config = &quot;[esptool]\n&quot; &quot;connect_attempts = 5\n&quot; &quot;connect_attempts = 9\n&quot;
919          with self.ConfigFile(config_file_path, faulty_config):
920              output = self.run_esptool(&quot;version&quot;)
921              assert f&quot;Ignoring invalid config file {config_file_path}&quot; in output
922              assert (
923                  &quot;option &#x27;connect_attempts&#x27; in section &#x27;esptool&#x27; already exists&quot;
924                  in output
925              )
926          faulty_config = &quot;[esptool]\n&quot; &quot;connect_attempts = 9\n&quot; &quot;timout = 2\n&quot; &quot;bits = 2&quot;
927          with self.ConfigFile(config_file_path, faulty_config):
928              output = self.run_esptool(&quot;version&quot;)
929              assert &quot;Ignoring unknown config file options: bits, timout&quot; in output
930          config_file_path = os.path.join(os.getcwd(), &quot;tox.ini&quot;)
931          with self.ConfigFile(config_file_path, self.dummy_config):
932              output = self.run_esptool(&quot;version&quot;)
933              assert f&quot;Loaded custom configuration from {config_file_path}&quot; in output
934      @pytest.mark.host_test
935      def test_load_config_file_with_env_var(self):
936          config_file_path = os.path.join(TEST_DIR, &quot;custom_file.ini&quot;)
937          with self.ConfigFile(config_file_path, self.dummy_config):
938              output = self.run_esptool(&quot;version&quot;)
939              assert f&quot;Loaded custom configuration from {config_file_path}&quot; not in output
940              tmp = os.environ.get(&quot;ESPTOOL_CFGFILE&quot;)  # Save the env var if it is set
941              os.environ[&quot;ESPTOOL_CFGFILE&quot;] = config_file_path
942              output = self.run_esptool(&quot;version&quot;)
943              assert f&quot;Loaded custom configuration from {config_file_path}&quot; in output
944              assert &quot;(set with ESPTOOL_CFGFILE)&quot; in output
945              if tmp is not None:  # Restore the env var or unset it
946                  os.environ[&quot;ESPTOOL_CFGFILE&quot;] = tmp
947              else:
948                  os.environ.pop(&quot;ESPTOOL_CFGFILE&quot;, None)
949      def test_custom_reset_sequence(self):
950          reset_seq_config = (
951              &quot;[esptool]\n&quot;
952              &quot;custom_reset_sequence = D0|W0.1|R1|R0|W0.1|R1|R0\n&quot;
953              &quot;connect_attempts = 1\n&quot;
954          )
955          config_file_path = os.path.join(os.getcwd(), &quot;esptool.cfg&quot;)
956          with self.ConfigFile(config_file_path, reset_seq_config):
957              output = self.run_esptool_error(&quot;flash_id&quot;)
958              assert f&quot;Loaded custom configuration from {config_file_path}&quot; in output
959              assert &quot;A fatal error occurred: Failed to connect to&quot; in output
960              assert &quot;Connecting.............&quot; not in output
961          invalid_reset_seq_config = &quot;[esptool]\n&quot; &quot;custom_reset_sequence = F0|R1|C0|A5\n&quot;
962          with self.ConfigFile(config_file_path, invalid_reset_seq_config):
963              output = self.run_esptool_error(&quot;flash_id&quot;)
964              assert f&quot;Loaded custom configuration from {config_file_path}&quot; in output
965              assert &#x27;Invalid &quot;custom_reset_sequence&quot; option format:&#x27; in output
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-test_esptool.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-test_esptool.py</div>
                </div>
                <div class="column column_space"><pre><code>243          self.run_esptool(
244              &quot;write_flash --encrypt --ignore-flash-encryption-efuse-setting &quot;
245              &quot;0x10000 images/ram_helloworld/helloworld-esp32_edit.bin&quot;
246          )
247          self.run_esptool(&quot;read_flash 0x10000 192 images/read_encrypted_flash.bin&quot;)
248          self.run_espsecure(
</pre></code></div>
                <div class="column column_space"><pre><code>217          self.run_esptool(
218              &quot;write_flash --encrypt --ignore-flash-encryption-efuse-setting &quot;
219              &quot;0x10000 images/ram_helloworld/helloworld-esp32.bin&quot;
220          )
221          self.run_esptool(&quot;read_flash 0x10000 192 images/read_encrypted_flash.bin&quot;)
222          self.run_espsecure(
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    