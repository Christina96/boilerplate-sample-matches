<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for journald.py & log_beacon.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for journald.py & log_beacon.py
      </h3>
      <h1 align="center">
        7.7%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>journald.py (9.6%)<TH>log_beacon.py (6.521739%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match31533-0.html#0',2,'match31533-1.html#0',3)" NAME="0">(24-35)<TD><A HREF="javascript:ZweiFrames('match31533-0.html#0',2,'match31533-1.html#0',3)" NAME="0">(35-46)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>journald.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
A simple beacon to watch journald for specific entries
&quot;&quot;&quot;
import logging

import salt.utils.beacons
import salt.utils.data

try:
    import systemd.journal  # pylint: disable=no-name-in-module

    HAS_SYSTEMD = True
except ImportError:
    HAS_SYSTEMD = False


log = logging.getLogger(__name__)

__virtualname__ = &quot;journald&quot;

<A NAME="0"></A>
def __virtual__():
    if HAS_SYSTEMD:
        <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match31533-1.html#0',3,'match31533-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>return __virtualname__
    err_msg = &quot;systemd library is missing.&quot;
    log.error(&quot;Unable to load %s beacon: %s&quot;, __virtualname__, err_msg)
    return False, err_msg


def _get_journal():
    &quot;&quot;&quot;
    Return the active running journal object
    &quot;&quot;&quot;
    if &quot;systemd.journald&quot; in __context__:
        return __context__[</B></FONT>&quot;systemd.journald&quot;]
    __context__[&quot;systemd.journald&quot;] = systemd.journal.Reader()
    # get to the end of the journal
    __context__[&quot;systemd.journald&quot;].seek_tail()
    __context__[&quot;systemd.journald&quot;].get_previous()
    return __context__[&quot;systemd.journald&quot;]


def validate(config):
    &quot;&quot;&quot;
    Validate the beacon configuration
    &quot;&quot;&quot;
    # Configuration for journald beacon should be a list of dicts
    if not isinstance(config, list):
        return (False, &quot;Configuration for journald beacon must be a list.&quot;)
    else:
        config = salt.utils.beacons.list_to_dict(config)

        for name in config.get(&quot;services&quot;, {}):
            if not isinstance(config[&quot;services&quot;][name], dict):
                return (
                    False,
                    &quot;Services configuration for journald beacon must be a list of&quot;
                    &quot; dictionaries.&quot;,
                )
    return True, &quot;Valid beacon configuration&quot;


def beacon(config):
    &quot;&quot;&quot;
    The journald beacon allows for the systemd journal to be parsed and linked
    objects to be turned into events.

    This beacons config will return all sshd jornal entries

    .. code-block:: yaml

        beacons:
          journald:
            - services:
                sshd:
                  SYSLOG_IDENTIFIER: sshd
                  PRIORITY: 6
    &quot;&quot;&quot;
    ret = []
    journal = _get_journal()

    config = salt.utils.beacons.list_to_dict(config)

    while True:
        cur = journal.get_next()
        if not cur:
            break

        for name in config.get(&quot;services&quot;, {}):
            n_flag = 0
            for key in config[&quot;services&quot;][name]:
                if isinstance(key, str):
                    key = salt.utils.data.decode(key)
                if key in cur:
                    if config[&quot;services&quot;][name][key] == cur[key]:
                        n_flag += 1
            if n_flag == len(config[&quot;services&quot;][name]):
                # Match!
                sub = salt.utils.data.simple_types_filter(cur)
                sub.update({&quot;tag&quot;: name})
                ret.append(sub)
    return ret
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>log_beacon.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Beacon to fire events at specific log messages.

.. versionadded:: 2017.7.0

&quot;&quot;&quot;
import logging

import salt.utils.beacons
import salt.utils.files
import salt.utils.platform

try:
    import re

    HAS_REGEX = True
except ImportError:
    HAS_REGEX = False

__virtualname__ = &quot;log&quot;
LOC_KEY = &quot;log.loc&quot;

SKEL = {}
SKEL[&quot;tag&quot;] = &quot;&quot;
SKEL[&quot;match&quot;] = &quot;no&quot;
SKEL[&quot;raw&quot;] = &quot;&quot;
SKEL[&quot;error&quot;] = &quot;&quot;


log = logging.getLogger(__name__)

<A NAME="0"></A>
def __virtual__():
    if not salt.utils.platform.is_windows() and HAS_REGEX:
        <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31533-0.html#0',2,'match31533-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>return __virtualname__
    err_msg = &quot;Not available for Windows systems or when regex library is missing.&quot;
    log.error(&quot;Unable to load %s beacon: %s&quot;, __virtualname__, err_msg)
    return False, err_msg


def _get_loc():
    &quot;&quot;&quot;
    return the active file location
    &quot;&quot;&quot;
    if LOC_KEY in __context__:
        return __context__[</B></FONT>LOC_KEY]


def validate(config):
    &quot;&quot;&quot;
    Validate the beacon configuration
    &quot;&quot;&quot;
    # Configuration for log beacon should be a list of dicts
    if not isinstance(config, list):
        return False, &quot;Configuration for log beacon must be a list.&quot;

    config = salt.utils.beacons.list_to_dict(config)

    if &quot;file&quot; not in config:
        return False, &quot;Configuration for log beacon must contain file option.&quot;
    return True, &quot;Valid beacon configuration&quot;


# TODO: match values should be returned in the event
def beacon(config):
    &quot;&quot;&quot;
    Read the log file and return match whole string

    .. code-block:: yaml

        beacons:
          log:
            - file: &lt;path&gt;
            - tags:
                &lt;tag&gt;:
                  regex: &lt;pattern&gt;

    .. note::

        regex matching is based on the `re`_ module

    .. _re: https://docs.python.org/3.6/library/re.html#regular-expression-syntax

    The defined tag is added to the beacon event tag.
    This is not the tag in the log.

    .. code-block:: yaml

        beacons:
          log:
            - file: /var/log/messages #path to log.
            - tags:
                goodbye/world: # tag added to beacon event tag.
                  regex: .*good-bye.* # match good-bye string anywhere in the log entry.
    &quot;&quot;&quot;
    config = salt.utils.beacons.list_to_dict(config)

    ret = []

    if &quot;file&quot; not in config:
        event = SKEL.copy()
        event[&quot;tag&quot;] = &quot;global&quot;
        event[&quot;error&quot;] = &quot;file not defined in config&quot;
        ret.append(event)
        return ret

    with salt.utils.files.fopen(config[&quot;file&quot;], &quot;r&quot;) as fp_:
        loc = __context__.get(LOC_KEY, 0)
        if loc == 0:
            fp_.seek(0, 2)
            __context__[LOC_KEY] = fp_.tell()
            return ret

        fp_.seek(0, 2)
        __context__[LOC_KEY] = fp_.tell()
        fp_.seek(loc)

        txt = fp_.read()
        log.info(&quot;txt %s&quot;, txt)

        d = {}
        for tag in config.get(&quot;tags&quot;, {}):
            if &quot;regex&quot; not in config[&quot;tags&quot;][tag]:
                continue
            if not config[&quot;tags&quot;][tag][&quot;regex&quot;]:
                continue
            try:
                d[tag] = re.compile(r&quot;{}&quot;.format(config[&quot;tags&quot;][tag][&quot;regex&quot;]))
            except Exception as e:  # pylint: disable=broad-except
                event = SKEL.copy()
                event[&quot;tag&quot;] = tag
                event[&quot;error&quot;] = &quot;bad regex&quot;
                ret.append(event)

        for line in txt.splitlines():
            for tag, reg in d.items():
                try:
                    m = reg.match(line)
                    if m:
                        event = SKEL.copy()
                        event[&quot;tag&quot;] = tag
                        event[&quot;raw&quot;] = line
                        event[&quot;match&quot;] = &quot;yes&quot;
                        ret.append(event)
                except Exception:  # pylint: disable=broad-except
                    event = SKEL.copy()
                    event[&quot;tag&quot;] = tag
                    event[&quot;error&quot;] = &quot;bad match&quot;
                    ret.append(event)
    return ret
</PRE>
</div>
  </div>
</body>
</html>
