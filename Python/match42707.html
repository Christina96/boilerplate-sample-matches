<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for boto_kms.py &amp; boto_lc.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for boto_kms.py &amp; boto_lc.py
      </h3>
<h1 align="center">
        6.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>boto_kms.py (4.2505593%)<th>boto_lc.py (13.103448%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(60-84)<td><a href="#" name="0">(101-125)</a><td align="center"><font color="#ff0000">19</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_kms.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>from salt.exceptions import SaltInvocationError
3 def __virtual__():
4     """
5     Only load if boto is available.
6     """
7     if "boto_kms.describe_key" in __salt__:
8         return "boto_kms"
9     return (False, "boto_kms module could not be loaded")
10 def key_present(
11     name,
12     policy,
13     description=None,
14     key_usage=None,
15     grants=None,
16     manage_grants=False,
17     key_rotation=False,
18     enabled=True,
19     region=None,
20     key=None,
21     keyid=None,
22     profile=</b></font>None,
23 ):
24     """
25     Ensure the KMS key exists. KMS keys can not be deleted, so this function
26     must be used to ensure the key is enabled or disabled.
27     name
28         Name of the key.
29     policy
30         Key usage policy.
31     description
32         Description of the key.
33     key_usage
34         Specifies the intended use of the key. Can only be set on creation,
35         defaults to ENCRYPT_DECRYPT, which is also the only supported option.
36     grants
37         A list of grants to apply to the key. Not currently implemented.
38     manage_grants
39         Whether or not to manage grants. False by default, which will not
40         manage any grants.
41     key_rotation
42         Whether or not key rotation is enabled for the key. False by default.
43     enabled
44         Whether or not the key is enabled. True by default.
45     region
46         Region to connect to.
47     key
48         Secret key to be used.
49     keyid
50         Access key to be used.
51     profile
52         A dict with region, key and keyid, or a pillar key (string)
53         that contains a dict with region, key and keyid.
54     """
55     if not policy:
56         raise SaltInvocationError("policy is a required argument.")
57     if grants and not isinstance(grants, list):
58         raise SaltInvocationError("manage_grants must be a list.")
59     if not isinstance(manage_grants, bool):
60         raise SaltInvocationError("manage_grants must be true or false.")
61     if not isinstance(key_rotation, bool):
62         raise SaltInvocationError("key_rotation must be true or false.")
63     if not isinstance(enabled, bool):
64         raise SaltInvocationError("enabled must be true or false.")
65     ret = {"name": name, "result": True, "comment": "", "changes": {}}
66     _ret = _key_present(
67         name,
68         policy,
69         description,
70         key_usage,
71         key_rotation,
72         enabled,
73         region,
74         key,
75         keyid,
76         profile,
77     )
78     ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
79     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
80     if not _ret["result"]:
81         ret["result"] = _ret["result"]
82         if ret["result"] is False:
83             return ret
84     return ret
85 def _key_present(
86     name,
87     policy,
88     description,
89     key_usage,
90     key_rotation,
91     enabled,
92     region,
93     key,
94     keyid,
95     profile,
96 ):
97     ret = {"result": True, "comment": "", "changes": {}}
98     alias = "alias/{}".format(name)
99     r = __salt__["boto_kms.key_exists"](alias, region, key, keyid, profile)
100     if "error" in r:
101         ret["result"] = False
102         ret["comment"] = "Error when attempting to find key: {}.".format(
103             r["error"]["message"]
104         )
105         return ret
106     if not r["result"]:
107         if __opts__["test"]:
108             ret["comment"] = "Key is set to be created."
109             ret["result"] = None
110             return ret
111         rc = __salt__["boto_kms.create_key"](
112             policy, description, key_usage, region, key, keyid, profile
113         )
114         if "error" in rc:
115             ret["result"] = False
116             ret["comment"] = "Failed to create key: {}".format(rc["error"]["message"])
117             return ret
118         key_metadata = rc["key_metadata"]
119         kms_key_id = key_metadata["KeyId"]
120         rn = __salt__["boto_kms.create_alias"](
121             alias, kms_key_id, region, key, keyid, profile
122         )
123         if "error" in rn:
124             ret["result"] = False
125             ret["comment"] = (
126                 "Failed to create key alias for key_id {}. This resource "
127                 "will be left dangling. Please clean manually. "
128                 "Error: {}".format(kms_key_id, rn["error"]["message"])
129             )
130             return ret
131         ret["changes"]["old"] = {"key": None}
132         ret["changes"]["new"] = {"key": name}
133         ret["comment"] = "Key {} created.".format(name)
134     else:
135         rd = __salt__["boto_kms.describe_key"](alias, region, key, keyid, profile)
136         if "error" in rd:
137             ret["result"] = False
138             ret["comment"] = "Failed to update key: {}.".format(rd["error"]["message"])
139             return ret
140         key_metadata = rd["key_metadata"]
141         _ret = _key_description(key_metadata, description, region, key, keyid, profile)
142         ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
143         ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
144         if not _ret["result"]:
145             ret["result"] = _ret["result"]
146             if ret["result"] is False:
147                 return ret
148         _ret = _key_policy(key_metadata, policy, region, key, keyid, profile)
149         ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
150         ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
151         if not _ret["result"]:
152             ret["result"] = _ret["result"]
153             if ret["result"] is False:
154                 return ret
155     _ret = _key_enabled(key_metadata, enabled, region, key, keyid, profile)
156     ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
157     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
158     if not _ret["result"]:
159         ret["result"] = _ret["result"]
160         if ret["result"] is False:
161             return ret
162     _ret = _key_rotation(key_metadata, key_rotation, region, key, keyid, profile)
163     ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
164     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
165     if not _ret["result"]:
166         ret["result"] = _ret["result"]
167     return ret
168 def _key_enabled(key_metadata, enabled, region, key, keyid, profile):
169     ret = {"result": True, "comment": "", "changes": {}}
170     kms_key_id = key_metadata["KeyId"]
171     if key_metadata["Enabled"] == enabled:
172         return ret
173     if __opts__["test"]:
174         ret["comment"] = "Key set to have enabled status updated."
175         ret["result"] = None
176         return ret
177     if enabled:
178         re = __salt__["boto_kms.enable_key"](kms_key_id, region, key, keyid, profile)
179         event = "Enabled"
180     else:
181         re = __salt__["boto_kms.disable_key"](kms_key_id, region, key, keyid, profile)
182         event = "Disabled"
183     if "error" in re:
184         ret["result"] = False
185         ret["comment"] = "Failed to update key enabled status: {}.".format(
186             re["error"]["message"]
187         )
188     else:
189         ret["comment"] = "{} key.".format(event)
190     return ret
191 def _key_description(key_metadata, description, region, key, keyid, profile):
192     ret = {"result": True, "comment": "", "changes": {}}
193     if key_metadata["Description"] == description:
194         return ret
195     if __opts__["test"]:
196         ret["comment"] = "Key set to have description updated."
197         ret["result"] = None
198         return ret
199     rdu = __salt__["boto_kms.update_key_description"](
200         key_metadata["KeyId"], description, region, key, keyid, profile
201     )
202     if "error" in rdu:
203         ret["result"] = False
204         ret["comment"] = "Failed to update key description: {}.".format(
205             rdu["error"]["message"]
206         )
207     else:
208         ret["comment"] = "Updated key description."
209     return ret
210 def _key_rotation(key_metadata, key_rotation, region, key, keyid, profile):
211     ret = {"result": True, "comment": "", "changes": {}}
212     kms_key_id = key_metadata["KeyId"]
213     rke = __salt__["boto_kms.get_key_rotation_status"](
214         kms_key_id, region, key, keyid, profile
215     )
216     if rke["result"] == key_rotation:
217         return ret
218     if __opts__["test"]:
219         ret["comment"] = "Key set to have key rotation policy updated."
220         ret["result"] = None
221         return ret
222     if not key_metadata["Enabled"]:
223         ret["comment"] = "Key is disabled, not changing key rotation policy."
224         ret["result"] = None
225         return ret
226     if key_rotation:
227         rk = __salt__["boto_kms.enable_key_rotation"](
228             kms_key_id, region, key, keyid, profile
229         )
230     else:
231         rk = __salt__["boto_kms.enable_key_rotation"](
232             kms_key_id, region, key, keyid, profile
233         )
234     if "error" in rk:
235         if "is disabled" in rk["error"]["message"]:
236             msg = "Key is disabled, not changing key rotation policy."
237             ret["result"] = None
238             ret["comment"] = msg
239             return ret
240         ret["result"] = False
241         ret["comment"] = "Failed to set key rotation: {}.".format(
242             rk["error"]["message"]
243         )
244     else:
245         ret["changes"] = {
246             "old": {"key_rotation": not key_rotation},
247             "new": {"key_rotation": key_rotation},
248         }
249         ret["comment"] = "Set key rotation policy to {}.".format(key_rotation)
250     return ret
251 def _key_policy(key_metadata, policy, region, key, keyid, profile):
252     ret = {"result": True, "comment": "", "changes": {}}
253     kms_key_id = key_metadata["KeyId"]
254     rkp = __salt__["boto_kms.get_key_policy"](
255         kms_key_id, "default", region, key, keyid, profile
256     )
257     if rkp["key_policy"] == policy:
258         return ret
259     if __opts__["test"]:
260         ret["comment"] = "{} Key set to have key policy updated.".format(ret["comment"])
261         ret["result"] = None
262         return ret
263     rpkp = __salt__["boto_kms.put_key_policy"](
264         kms_key_id, "default", policy, region, key, keyid, profile
265     )
266     if "error" in rpkp:
267         ret["result"] = False
268         ret["comment"] = "{} Failed to update key policy: {}".format(
269             ret["comment"], rpkp["error"]["message"]
270         )
271     else:
272         ret["comment"] = "Updated key policy."
273     return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_lc.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 Manage Launch Configurations
3 .. versionadded:: 2014.7.0
4 Create and destroy Launch Configurations. Be aware that this interacts with
5 Amazon's services, and so may incur charges.
6 A limitation of this module is that you can not modify launch configurations
7 once they have been created. If a launch configuration with the specified name
8 exists, this module will always report success, even if the specified
9 configuration doesn't match. This is due to a limitation in Amazon's launch
10 configuration API, as it only allows launch configurations to be created and
11 deleted.
12 Also note that a launch configuration that's in use by an autoscale group can
13 not be deleted until the autoscale group is no longer using it. This may affect
14 the way in which you want to order your states.
15 This module uses ``boto``, which can be installed via package, or pip.
16 This module accepts explicit autoscale credentials but can also utilize
17 IAM roles assigned to the instance through Instance Profiles. Dynamic
18 credentials are then automatically obtained from AWS API and no further
19 configuration is necessary. More information available `here
20 &lt;http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html&gt;`_.
21 If IAM roles are not used you need to specify them either in a pillar file or
22 in the minion's config file:
23 .. code-block:: yaml
24     asg.keyid: GKTADJGHEIQSXMKKRBJ08H
25     asg.key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs
26 It's also possible to specify ``key``, ``keyid`` and ``region`` via a profile, either
27 passed in as a dict, or as a string to pull from pillars or minion config:
28 .. code-block:: yaml
29     myprofile:
30         keyid: GKTADJGHEIQSXMKKRBJ08H
31         key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs
32         region: us-east-1
33 Credential information is shared with autoscale groups as launch configurations
34 and autoscale groups are completely dependent on each other.
35 .. code-block:: yaml
36     Ensure mylc exists:
37       boto_lc.present:
38         - name: mylc
39         - image_id: ami-0b9c9f62
40         - key_name: mykey
41         - security_groups:
42             - mygroup
43         - instance_type: m1.small
44         - instance_monitoring: true
45         - block_device_mappings:
46             - '/dev/sda1':
47                 size: 20
48                 volume_type: 'io1'
49                 iops: 220
50                 delete_on_termination: true
51         - cloud_init:
52             boothooks:
53               'disable-master.sh': |
54                 echo "manual" &gt; /etc/init/salt-master.override
55             scripts:
56               'run_salt.sh': |
57                 add-apt-repository -y ppa:saltstack/salt
58                 apt-get update
59                 apt-get install -y salt-minion
60                 salt-call state.highstate
61         - region: us-east-1
62         - keyid: GKTADJGHEIQSXMKKRBJ08H
63         - key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs
64     Ensure mylc exists:
65       boto_lc.present:
66         - name: mylc
67         - image_id: ami-0b9c9f62
68         - profile: myprofile
69     Ensure mylc exists:
70       boto_lc.present:
71         - name: mylc
72         - image_id: ami-0b9c9f62
73         - profile:
74             keyid: GKTADJGHEIQSXMKKRBJ08H
75             key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs
76 """
77 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>from salt.exceptions import SaltInvocationError
78 def __virtual__():
79     """
80     Only load if boto is available.
81     """
82     if "boto_asg.exists" in __salt__:
83         return "boto_lc"
84     return (False, "boto_asg module could not be loaded")
85 def present(
86     name,
87     image_id,
88     key_name=None,
89     vpc_id=None,
90     vpc_name=None,
91     security_groups=None,
92     user_data=None,
93     cloud_init=None,
94     instance_type="m1.small",
95     kernel_id=None,
96     ramdisk_id=None,
97     block_device_mappings=</b></font>None,
98     delete_on_termination=None,
99     instance_monitoring=False,
100     spot_price=None,
101     instance_profile_name=None,
102     ebs_optimized=False,
103     associate_public_ip_address=None,
104     region=None,
105     key=None,
106     keyid=None,
107     profile=None,
108 ):
109     """
110     Ensure the launch configuration exists.
111     name
112         Name of the launch configuration.
113     image_id
114         AMI to use for instances. AMI must exist or creation of the launch
115         configuration will fail.
116     key_name
117         Name of the EC2 key pair to use for instances. Key must exist or
118         creation of the launch configuration will fail.
119     vpc_id
120         The VPC id where the security groups are defined. Only necessary when
121         using named security groups that exist outside of the default VPC.
122         Mutually exclusive with vpc_name.
123     vpc_name
124         Name of the VPC where the security groups are defined. Only Necessary
125         when using named security groups that exist outside of the default VPC.
126         Mutually exclusive with vpc_id.
127     security_groups
128         List of Names or security group id’s of the security groups with which
129         to associate the EC2 instances or VPC instances, respectively. Security
130         groups must exist, or creation of the launch configuration will fail.
131     user_data
132         The user data available to launched EC2 instances.
133     cloud_init
134         A dict of cloud_init configuration. Currently supported keys:
135         boothooks, scripts and cloud-config.
136         Mutually exclusive with user_data.
137     instance_type
138         The instance type. ex: m1.small.
139     kernel_id
140         The kernel id for the instance.
141     ramdisk_id
142         The RAM disk ID for the instance.
143     block_device_mappings
144         A dict of block device mappings that contains a dict
145         with volume_type, delete_on_termination, iops, size, encrypted,
146         snapshot_id.
147         volume_type
148             Indicates what volume type to use. Valid values are standard, io1, gp2.
149             Default is standard.
150         delete_on_termination
151             Whether the volume should be explicitly marked for deletion when its instance is
152             terminated (True), or left around (False).  If not provided, or None is explicitly passed,
153             the default AWS behaviour is used, which is True for ROOT volumes of instances, and
154             False for all others.
155         iops
156             For Provisioned IOPS (SSD) volumes only. The number of I/O operations per
157             second (IOPS) to provision for the volume.
158         size
159             Desired volume size (in GiB).
160         encrypted
161             Indicates whether the volume should be encrypted. Encrypted EBS volumes must
162             be attached to instances that support Amazon EBS encryption. Volumes that are
163             created from encrypted snapshots are automatically encrypted. There is no way
164             to create an encrypted volume from an unencrypted snapshot or an unencrypted
165             volume from an encrypted snapshot.
166     instance_monitoring
167         Whether instances in group are launched with detailed monitoring.
168     spot_price
169         The spot price you are bidding. Only applies if you are building an
170         autoscaling group with spot instances.
171     instance_profile_name
172         The name or the Amazon Resource Name (ARN) of the instance profile
173         associated with the IAM role for the instance. Instance profile must
174         exist or the creation of the launch configuration will fail.
175     ebs_optimized
176         Specifies whether the instance is optimized for EBS I/O (true) or not
177         (false).
178     associate_public_ip_address
179         Used for Auto Scaling groups that launch instances into an Amazon
180         Virtual Private Cloud. Specifies whether to assign a public IP address
181         to each instance launched in a Amazon VPC.
182     region
183         The region to connect to.
184     key
185         Secret key to be used.
186     keyid
187         Access key to be used.
188     profile
189         A dict with region, key and keyid, or a pillar key (string)
190         that contains a dict with region, key and keyid.
191     """
192     if user_data and cloud_init:
193         raise SaltInvocationError(
194             "user_data and cloud_init are mutually exclusive options."
195         )
196     ret = {"name": name, "result": True, "comment": "", "changes": {}}
197     exists = __salt__["boto_asg.launch_configuration_exists"](
198         name, region=region, key=key, keyid=keyid, profile=profile
199     )
200     if not exists:
201         if __opts__["test"]:
202             msg = "Launch configuration set to be created."
203             ret["comment"] = msg
204             ret["result"] = None
205             return ret
206         if cloud_init:
207             user_data = __salt__["boto_asg.get_cloud_init_mime"](cloud_init)
208         created = __salt__["boto_asg.create_launch_configuration"](
209             name,
210             image_id,
211             key_name=key_name,
212             vpc_id=vpc_id,
213             vpc_name=vpc_name,
214             security_groups=security_groups,
215             user_data=user_data,
216             instance_type=instance_type,
217             kernel_id=kernel_id,
218             ramdisk_id=ramdisk_id,
219             block_device_mappings=block_device_mappings,
220             delete_on_termination=delete_on_termination,
221             instance_monitoring=instance_monitoring,
222             spot_price=spot_price,
223             instance_profile_name=instance_profile_name,
224             ebs_optimized=ebs_optimized,
225             associate_public_ip_address=associate_public_ip_address,
226             region=region,
227             key=key,
228             keyid=keyid,
229             profile=profile,
230         )
231         if created:
232             ret["changes"]["old"] = None
233             ret["changes"]["new"] = name
234         else:
235             ret["result"] = False
236             ret["comment"] = "Failed to create launch configuration."
237     else:
238         ret["comment"] = "Launch configuration present."
239     return ret
240 def absent(name, region=None, key=None, keyid=None, profile=None):
241     """
242     Ensure the named launch configuration is deleted.
243     name
244         Name of the launch configuration.
245     region
246         The region to connect to.
247     key
248         Secret key to be used.
249     keyid
250         Access key to be used.
251     profile
252         A dict with region, key and keyid, or a pillar key (string)
253         that contains a dict with region, key and keyid.
254     """
255     ret = {"name": name, "result": True, "comment": "", "changes": {}}
256     exists = __salt__["boto_asg.launch_configuration_exists"](
257         name, region=region, key=key, keyid=keyid, profile=profile
258     )
259     if exists:
260         if __opts__["test"]:
261             ret["comment"] = "Launch configuration set to be deleted."
262             ret["result"] = None
263             return ret
264         deleted = __salt__["boto_asg.delete_launch_configuration"](
265             name, region=region, key=key, keyid=keyid, profile=profile
266         )
267         if deleted:
268             ret["changes"]["old"] = name
269             ret["changes"]["new"] = None
270             ret["comment"] = "Deleted launch configuration."
271         else:
272             ret["result"] = False
273             ret["comment"] = "Failed to delete launch configuration."
274     else:
275         ret["comment"] = "Launch configuration does not exist."
276     return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
