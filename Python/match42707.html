<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for boto_kms.py & boto_lc.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for boto_kms.py & boto_lc.py
      </h3>
      <h1 align="center">
        6.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>boto_kms.py (4.2505593%)<TH>boto_lc.py (13.103448%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match42707-0.html#0',2,'match42707-1.html#0',3)" NAME="0">(60-84)<TD><A HREF="javascript:ZweiFrames('match42707-0.html#0',2,'match42707-1.html#0',3)" NAME="0">(101-125)</A><TD ALIGN=center><FONT COLOR="#ff0000">19</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_kms.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Manage KMS keys, key policies and grants.

.. versionadded:: 2015.8.0

Be aware that this interacts with Amazon's services, and so may incur charges.

This module uses ``boto``, which can be installed via package, or pip.

This module accepts explicit kms credentials but can also utilize
IAM roles assigned to the instance through Instance Profiles. Dynamic
credentials are then automatically obtained from AWS API and no further
configuration is necessary. More information available `here
&lt;http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html&gt;`_.

If IAM roles are not used you need to specify them either in a pillar file or
in the minion's config file:

.. code-block:: yaml

    elb.keyid: GKTADJGHEIQSXMKKRBJ08H
    elb.key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs

It's also possible to specify ``key``, ``keyid`` and ``region`` via a profile,
either passed in as a dict, or as a string to pull from pillars or minion
config:

.. code-block:: yaml

    myprofile:
        keyid: GKTADJGHEIQSXMKKRBJ08H
        key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs
        region: us-east-1

.. code-block:: yaml

    Ensure mykey key exists:
      boto_kms.key_present:
        - name: mykey
        - region: us-east-1

    # Using a profile from pillars
    Ensure mykey key exists:
      boto_kms.key_present:
        - name: mykey
        - region: us-east-1
        - profile: myprofile

    # Passing in a profile
    Ensure mykey key exists:
      boto_key.key_present:
        - name: mykey
        - region: us-east-1
        - profile:
            keyid: GKTADJGHEIQSXMKKRBJ08H
            key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs
<A NAME="0"></A>&quot;&quot;&quot;

import salt.utils.dictupdate as dictupdate
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match42707-1.html#0',3,'match42707-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>from salt.exceptions import SaltInvocationError


def __virtual__():
    &quot;&quot;&quot;
    Only load if boto is available.
    &quot;&quot;&quot;
    if &quot;boto_kms.describe_key&quot; in __salt__:
        return &quot;boto_kms&quot;
    return (False, &quot;boto_kms module could not be loaded&quot;)


def key_present(
    name,
    policy,
    description=None,
    key_usage=None,
    grants=None,
    manage_grants=False,
    key_rotation=False,
    enabled=True,
    region=None,
    key=None,
    keyid=None,
    profile=</B></FONT>None,
):
    &quot;&quot;&quot;
    Ensure the KMS key exists. KMS keys can not be deleted, so this function
    must be used to ensure the key is enabled or disabled.

    name
        Name of the key.

    policy
        Key usage policy.

    description
        Description of the key.

    key_usage
        Specifies the intended use of the key. Can only be set on creation,
        defaults to ENCRYPT_DECRYPT, which is also the only supported option.

    grants
        A list of grants to apply to the key. Not currently implemented.

    manage_grants
        Whether or not to manage grants. False by default, which will not
        manage any grants.

    key_rotation
        Whether or not key rotation is enabled for the key. False by default.

    enabled
        Whether or not the key is enabled. True by default.

    region
        Region to connect to.

    key
        Secret key to be used.

    keyid
        Access key to be used.

    profile
        A dict with region, key and keyid, or a pillar key (string)
        that contains a dict with region, key and keyid.
    &quot;&quot;&quot;
    if not policy:
        raise SaltInvocationError(&quot;policy is a required argument.&quot;)
    if grants and not isinstance(grants, list):
        raise SaltInvocationError(&quot;manage_grants must be a list.&quot;)
    if not isinstance(manage_grants, bool):
        raise SaltInvocationError(&quot;manage_grants must be true or false.&quot;)
    if not isinstance(key_rotation, bool):
        raise SaltInvocationError(&quot;key_rotation must be true or false.&quot;)
    if not isinstance(enabled, bool):
        raise SaltInvocationError(&quot;enabled must be true or false.&quot;)
    # TODO: support grant from pillars.
    # TODO: support key policy from pillars.
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    _ret = _key_present(
        name,
        policy,
        description,
        key_usage,
        key_rotation,
        enabled,
        region,
        key,
        keyid,
        profile,
    )
    ret[&quot;changes&quot;] = dictupdate.update(ret[&quot;changes&quot;], _ret[&quot;changes&quot;])
    ret[&quot;comment&quot;] = &quot; &quot;.join([ret[&quot;comment&quot;], _ret[&quot;comment&quot;]])
    if not _ret[&quot;result&quot;]:
        ret[&quot;result&quot;] = _ret[&quot;result&quot;]
        if ret[&quot;result&quot;] is False:
            return ret
    # TODO: add grants_present function
    return ret


def _key_present(
    name,
    policy,
    description,
    key_usage,
    key_rotation,
    enabled,
    region,
    key,
    keyid,
    profile,
):
    ret = {&quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    alias = &quot;alias/{}&quot;.format(name)
    r = __salt__[&quot;boto_kms.key_exists&quot;](alias, region, key, keyid, profile)
    if &quot;error&quot; in r:
        ret[&quot;result&quot;] = False
        ret[&quot;comment&quot;] = &quot;Error when attempting to find key: {}.&quot;.format(
            r[&quot;error&quot;][&quot;message&quot;]
        )
        return ret
    if not r[&quot;result&quot;]:
        if __opts__[&quot;test&quot;]:
            ret[&quot;comment&quot;] = &quot;Key is set to be created.&quot;
            ret[&quot;result&quot;] = None
            return ret
        rc = __salt__[&quot;boto_kms.create_key&quot;](
            policy, description, key_usage, region, key, keyid, profile
        )
        if &quot;error&quot; in rc:
            ret[&quot;result&quot;] = False
            ret[&quot;comment&quot;] = &quot;Failed to create key: {}&quot;.format(rc[&quot;error&quot;][&quot;message&quot;])
            return ret
        key_metadata = rc[&quot;key_metadata&quot;]
        kms_key_id = key_metadata[&quot;KeyId&quot;]
        rn = __salt__[&quot;boto_kms.create_alias&quot;](
            alias, kms_key_id, region, key, keyid, profile
        )
        if &quot;error&quot; in rn:
            # We can't recover from this. KMS only exposes enable/disable
            # and disable is not necessarily a great action here. AWS sucks
            # for not including alias in the create_key call.
            ret[&quot;result&quot;] = False
            ret[&quot;comment&quot;] = (
                &quot;Failed to create key alias for key_id {}. This resource &quot;
                &quot;will be left dangling. Please clean manually. &quot;
                &quot;Error: {}&quot;.format(kms_key_id, rn[&quot;error&quot;][&quot;message&quot;])
            )
            return ret
        ret[&quot;changes&quot;][&quot;old&quot;] = {&quot;key&quot;: None}
        ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;key&quot;: name}
        ret[&quot;comment&quot;] = &quot;Key {} created.&quot;.format(name)
    else:
        rd = __salt__[&quot;boto_kms.describe_key&quot;](alias, region, key, keyid, profile)
        if &quot;error&quot; in rd:
            ret[&quot;result&quot;] = False
            ret[&quot;comment&quot;] = &quot;Failed to update key: {}.&quot;.format(rd[&quot;error&quot;][&quot;message&quot;])
            return ret
        key_metadata = rd[&quot;key_metadata&quot;]
        _ret = _key_description(key_metadata, description, region, key, keyid, profile)
        ret[&quot;changes&quot;] = dictupdate.update(ret[&quot;changes&quot;], _ret[&quot;changes&quot;])
        ret[&quot;comment&quot;] = &quot; &quot;.join([ret[&quot;comment&quot;], _ret[&quot;comment&quot;]])
        if not _ret[&quot;result&quot;]:
            ret[&quot;result&quot;] = _ret[&quot;result&quot;]
            if ret[&quot;result&quot;] is False:
                return ret
        _ret = _key_policy(key_metadata, policy, region, key, keyid, profile)
        ret[&quot;changes&quot;] = dictupdate.update(ret[&quot;changes&quot;], _ret[&quot;changes&quot;])
        ret[&quot;comment&quot;] = &quot; &quot;.join([ret[&quot;comment&quot;], _ret[&quot;comment&quot;]])
        if not _ret[&quot;result&quot;]:
            ret[&quot;result&quot;] = _ret[&quot;result&quot;]
            if ret[&quot;result&quot;] is False:
                return ret
    # Actions that need to occur whether creating or updating
    _ret = _key_enabled(key_metadata, enabled, region, key, keyid, profile)
    ret[&quot;changes&quot;] = dictupdate.update(ret[&quot;changes&quot;], _ret[&quot;changes&quot;])
    ret[&quot;comment&quot;] = &quot; &quot;.join([ret[&quot;comment&quot;], _ret[&quot;comment&quot;]])
    if not _ret[&quot;result&quot;]:
        ret[&quot;result&quot;] = _ret[&quot;result&quot;]
        if ret[&quot;result&quot;] is False:
            return ret
    _ret = _key_rotation(key_metadata, key_rotation, region, key, keyid, profile)
    ret[&quot;changes&quot;] = dictupdate.update(ret[&quot;changes&quot;], _ret[&quot;changes&quot;])
    ret[&quot;comment&quot;] = &quot; &quot;.join([ret[&quot;comment&quot;], _ret[&quot;comment&quot;]])
    if not _ret[&quot;result&quot;]:
        ret[&quot;result&quot;] = _ret[&quot;result&quot;]
    return ret


def _key_enabled(key_metadata, enabled, region, key, keyid, profile):
    ret = {&quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    kms_key_id = key_metadata[&quot;KeyId&quot;]
    if key_metadata[&quot;Enabled&quot;] == enabled:
        return ret
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot;Key set to have enabled status updated.&quot;
        ret[&quot;result&quot;] = None
        return ret
    if enabled:
        re = __salt__[&quot;boto_kms.enable_key&quot;](kms_key_id, region, key, keyid, profile)
        event = &quot;Enabled&quot;
    else:
        re = __salt__[&quot;boto_kms.disable_key&quot;](kms_key_id, region, key, keyid, profile)
        event = &quot;Disabled&quot;
    if &quot;error&quot; in re:
        ret[&quot;result&quot;] = False
        ret[&quot;comment&quot;] = &quot;Failed to update key enabled status: {}.&quot;.format(
            re[&quot;error&quot;][&quot;message&quot;]
        )
    else:
        ret[&quot;comment&quot;] = &quot;{} key.&quot;.format(event)
    return ret


def _key_description(key_metadata, description, region, key, keyid, profile):
    ret = {&quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    if key_metadata[&quot;Description&quot;] == description:
        return ret
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot;Key set to have description updated.&quot;
        ret[&quot;result&quot;] = None
        return ret
    rdu = __salt__[&quot;boto_kms.update_key_description&quot;](
        key_metadata[&quot;KeyId&quot;], description, region, key, keyid, profile
    )
    if &quot;error&quot; in rdu:
        ret[&quot;result&quot;] = False
        ret[&quot;comment&quot;] = &quot;Failed to update key description: {}.&quot;.format(
            rdu[&quot;error&quot;][&quot;message&quot;]
        )
    else:
        ret[&quot;comment&quot;] = &quot;Updated key description.&quot;
    return ret


def _key_rotation(key_metadata, key_rotation, region, key, keyid, profile):
    ret = {&quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    kms_key_id = key_metadata[&quot;KeyId&quot;]
    rke = __salt__[&quot;boto_kms.get_key_rotation_status&quot;](
        kms_key_id, region, key, keyid, profile
    )
    if rke[&quot;result&quot;] == key_rotation:
        return ret
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot;Key set to have key rotation policy updated.&quot;
        ret[&quot;result&quot;] = None
        return ret
    if not key_metadata[&quot;Enabled&quot;]:
        ret[&quot;comment&quot;] = &quot;Key is disabled, not changing key rotation policy.&quot;
        ret[&quot;result&quot;] = None
        return ret
    if key_rotation:
        rk = __salt__[&quot;boto_kms.enable_key_rotation&quot;](
            kms_key_id, region, key, keyid, profile
        )
    else:
        rk = __salt__[&quot;boto_kms.enable_key_rotation&quot;](
            kms_key_id, region, key, keyid, profile
        )
    if &quot;error&quot; in rk:
        # Just checking for the key being disabled isn't enough, since key
        # disabling is very eventually consistent, so we have a long race
        # condition to handle. We check the error message to see if the failure
        # was due to a key being disabled.
        if &quot;is disabled&quot; in rk[&quot;error&quot;][&quot;message&quot;]:
            msg = &quot;Key is disabled, not changing key rotation policy.&quot;
            ret[&quot;result&quot;] = None
            ret[&quot;comment&quot;] = msg
            return ret
        ret[&quot;result&quot;] = False
        ret[&quot;comment&quot;] = &quot;Failed to set key rotation: {}.&quot;.format(
            rk[&quot;error&quot;][&quot;message&quot;]
        )
    else:
        ret[&quot;changes&quot;] = {
            &quot;old&quot;: {&quot;key_rotation&quot;: not key_rotation},
            &quot;new&quot;: {&quot;key_rotation&quot;: key_rotation},
        }
        ret[&quot;comment&quot;] = &quot;Set key rotation policy to {}.&quot;.format(key_rotation)
    return ret


def _key_policy(key_metadata, policy, region, key, keyid, profile):
    ret = {&quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    kms_key_id = key_metadata[&quot;KeyId&quot;]
    rkp = __salt__[&quot;boto_kms.get_key_policy&quot;](
        kms_key_id, &quot;default&quot;, region, key, keyid, profile
    )
    if rkp[&quot;key_policy&quot;] == policy:
        return ret
    if __opts__[&quot;test&quot;]:
        ret[&quot;comment&quot;] = &quot;{} Key set to have key policy updated.&quot;.format(ret[&quot;comment&quot;])
        ret[&quot;result&quot;] = None
        return ret
    rpkp = __salt__[&quot;boto_kms.put_key_policy&quot;](
        kms_key_id, &quot;default&quot;, policy, region, key, keyid, profile
    )
    if &quot;error&quot; in rpkp:
        ret[&quot;result&quot;] = False
        ret[&quot;comment&quot;] = &quot;{} Failed to update key policy: {}&quot;.format(
            ret[&quot;comment&quot;], rpkp[&quot;error&quot;][&quot;message&quot;]
        )
    else:
        ret[&quot;comment&quot;] = &quot;Updated key policy.&quot;
    return ret
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_lc.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Manage Launch Configurations

.. versionadded:: 2014.7.0

Create and destroy Launch Configurations. Be aware that this interacts with
Amazon's services, and so may incur charges.

A limitation of this module is that you can not modify launch configurations
once they have been created. If a launch configuration with the specified name
exists, this module will always report success, even if the specified
configuration doesn't match. This is due to a limitation in Amazon's launch
configuration API, as it only allows launch configurations to be created and
deleted.

Also note that a launch configuration that's in use by an autoscale group can
not be deleted until the autoscale group is no longer using it. This may affect
the way in which you want to order your states.

This module uses ``boto``, which can be installed via package, or pip.

This module accepts explicit autoscale credentials but can also utilize
IAM roles assigned to the instance through Instance Profiles. Dynamic
credentials are then automatically obtained from AWS API and no further
configuration is necessary. More information available `here
&lt;http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html&gt;`_.

If IAM roles are not used you need to specify them either in a pillar file or
in the minion's config file:

.. code-block:: yaml

    asg.keyid: GKTADJGHEIQSXMKKRBJ08H
    asg.key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs

It's also possible to specify ``key``, ``keyid`` and ``region`` via a profile, either
passed in as a dict, or as a string to pull from pillars or minion config:

.. code-block:: yaml

    myprofile:
        keyid: GKTADJGHEIQSXMKKRBJ08H
        key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs
        region: us-east-1

Credential information is shared with autoscale groups as launch configurations
and autoscale groups are completely dependent on each other.

.. code-block:: yaml

    Ensure mylc exists:
      boto_lc.present:
        - name: mylc
        - image_id: ami-0b9c9f62
        - key_name: mykey
        - security_groups:
            - mygroup
        - instance_type: m1.small
        - instance_monitoring: true
        - block_device_mappings:
            - '/dev/sda1':
                size: 20
                volume_type: 'io1'
                iops: 220
                delete_on_termination: true
        - cloud_init:
            boothooks:
              'disable-master.sh': |
                #!/bin/bash
                echo &quot;manual&quot; &gt; /etc/init/salt-master.override
            scripts:
              'run_salt.sh': |
                #!/bin/bash

                add-apt-repository -y ppa:saltstack/salt
                apt-get update
                apt-get install -y salt-minion
                salt-call state.highstate
        - region: us-east-1
        - keyid: GKTADJGHEIQSXMKKRBJ08H
        - key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs

    # Using a profile from pillars.
    Ensure mylc exists:
      boto_lc.present:
        - name: mylc
        - image_id: ami-0b9c9f62
        - profile: myprofile

    # Passing in a profile.
    Ensure mylc exists:
      boto_lc.present:
        - name: mylc
        - image_id: ami-0b9c9f62
        - profile:
            keyid: GKTADJGHEIQSXMKKRBJ08H
            key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs
<A NAME="0"></A>            region: us-east-1
&quot;&quot;&quot;

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match42707-0.html#0',2,'match42707-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>from salt.exceptions import SaltInvocationError


def __virtual__():
    &quot;&quot;&quot;
    Only load if boto is available.
    &quot;&quot;&quot;
    if &quot;boto_asg.exists&quot; in __salt__:
        return &quot;boto_lc&quot;
    return (False, &quot;boto_asg module could not be loaded&quot;)


def present(
    name,
    image_id,
    key_name=None,
    vpc_id=None,
    vpc_name=None,
    security_groups=None,
    user_data=None,
    cloud_init=None,
    instance_type=&quot;m1.small&quot;,
    kernel_id=None,
    ramdisk_id=None,
    block_device_mappings=</B></FONT>None,
    delete_on_termination=None,
    instance_monitoring=False,
    spot_price=None,
    instance_profile_name=None,
    ebs_optimized=False,
    associate_public_ip_address=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;
    Ensure the launch configuration exists.

    name
        Name of the launch configuration.

    image_id
        AMI to use for instances. AMI must exist or creation of the launch
        configuration will fail.

    key_name
        Name of the EC2 key pair to use for instances. Key must exist or
        creation of the launch configuration will fail.

    vpc_id
        The VPC id where the security groups are defined. Only necessary when
        using named security groups that exist outside of the default VPC.
        Mutually exclusive with vpc_name.

    vpc_name
        Name of the VPC where the security groups are defined. Only Necessary
        when using named security groups that exist outside of the default VPC.
        Mutually exclusive with vpc_id.

    security_groups
        List of Names or security group idâ€™s of the security groups with which
        to associate the EC2 instances or VPC instances, respectively. Security
        groups must exist, or creation of the launch configuration will fail.

    user_data
        The user data available to launched EC2 instances.

    cloud_init
        A dict of cloud_init configuration. Currently supported keys:
        boothooks, scripts and cloud-config.
        Mutually exclusive with user_data.

    instance_type
        The instance type. ex: m1.small.

    kernel_id
        The kernel id for the instance.

    ramdisk_id
        The RAM disk ID for the instance.

    block_device_mappings
        A dict of block device mappings that contains a dict
        with volume_type, delete_on_termination, iops, size, encrypted,
        snapshot_id.

        volume_type
            Indicates what volume type to use. Valid values are standard, io1, gp2.
            Default is standard.

        delete_on_termination
            Whether the volume should be explicitly marked for deletion when its instance is
            terminated (True), or left around (False).  If not provided, or None is explicitly passed,
            the default AWS behaviour is used, which is True for ROOT volumes of instances, and
            False for all others.

        iops
            For Provisioned IOPS (SSD) volumes only. The number of I/O operations per
            second (IOPS) to provision for the volume.

        size
            Desired volume size (in GiB).

        encrypted
            Indicates whether the volume should be encrypted. Encrypted EBS volumes must
            be attached to instances that support Amazon EBS encryption. Volumes that are
            created from encrypted snapshots are automatically encrypted. There is no way
            to create an encrypted volume from an unencrypted snapshot or an unencrypted
            volume from an encrypted snapshot.

    instance_monitoring
        Whether instances in group are launched with detailed monitoring.

    spot_price
        The spot price you are bidding. Only applies if you are building an
        autoscaling group with spot instances.

    instance_profile_name
        The name or the Amazon Resource Name (ARN) of the instance profile
        associated with the IAM role for the instance. Instance profile must
        exist or the creation of the launch configuration will fail.

    ebs_optimized
        Specifies whether the instance is optimized for EBS I/O (true) or not
        (false).

    associate_public_ip_address
        Used for Auto Scaling groups that launch instances into an Amazon
        Virtual Private Cloud. Specifies whether to assign a public IP address
        to each instance launched in a Amazon VPC.

    region
        The region to connect to.

    key
        Secret key to be used.

    keyid
        Access key to be used.

    profile
        A dict with region, key and keyid, or a pillar key (string)
        that contains a dict with region, key and keyid.
    &quot;&quot;&quot;
    if user_data and cloud_init:
        raise SaltInvocationError(
            &quot;user_data and cloud_init are mutually exclusive options.&quot;
        )
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    exists = __salt__[&quot;boto_asg.launch_configuration_exists&quot;](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    if not exists:
        if __opts__[&quot;test&quot;]:
            msg = &quot;Launch configuration set to be created.&quot;
            ret[&quot;comment&quot;] = msg
            ret[&quot;result&quot;] = None
            return ret
        if cloud_init:
            user_data = __salt__[&quot;boto_asg.get_cloud_init_mime&quot;](cloud_init)
        # TODO: Ensure image_id, key_name, security_groups and instance_profile
        # exist, or throw an invocation error.
        created = __salt__[&quot;boto_asg.create_launch_configuration&quot;](
            name,
            image_id,
            key_name=key_name,
            vpc_id=vpc_id,
            vpc_name=vpc_name,
            security_groups=security_groups,
            user_data=user_data,
            instance_type=instance_type,
            kernel_id=kernel_id,
            ramdisk_id=ramdisk_id,
            block_device_mappings=block_device_mappings,
            delete_on_termination=delete_on_termination,
            instance_monitoring=instance_monitoring,
            spot_price=spot_price,
            instance_profile_name=instance_profile_name,
            ebs_optimized=ebs_optimized,
            associate_public_ip_address=associate_public_ip_address,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
        if created:
            ret[&quot;changes&quot;][&quot;old&quot;] = None
            ret[&quot;changes&quot;][&quot;new&quot;] = name
        else:
            ret[&quot;result&quot;] = False
            ret[&quot;comment&quot;] = &quot;Failed to create launch configuration.&quot;
    else:
        ret[&quot;comment&quot;] = &quot;Launch configuration present.&quot;
    return ret


def absent(name, region=None, key=None, keyid=None, profile=None):
    &quot;&quot;&quot;
    Ensure the named launch configuration is deleted.

    name
        Name of the launch configuration.

    region
        The region to connect to.

    key
        Secret key to be used.

    keyid
        Access key to be used.

    profile
        A dict with region, key and keyid, or a pillar key (string)
        that contains a dict with region, key and keyid.
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    exists = __salt__[&quot;boto_asg.launch_configuration_exists&quot;](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    if exists:
        if __opts__[&quot;test&quot;]:
            ret[&quot;comment&quot;] = &quot;Launch configuration set to be deleted.&quot;
            ret[&quot;result&quot;] = None
            return ret
        deleted = __salt__[&quot;boto_asg.delete_launch_configuration&quot;](
            name, region=region, key=key, keyid=keyid, profile=profile
        )
        if deleted:
            ret[&quot;changes&quot;][&quot;old&quot;] = name
            ret[&quot;changes&quot;][&quot;new&quot;] = None
            ret[&quot;comment&quot;] = &quot;Deleted launch configuration.&quot;
        else:
            ret[&quot;result&quot;] = False
            ret[&quot;comment&quot;] = &quot;Failed to delete launch configuration.&quot;
    else:
        ret[&quot;comment&quot;] = &quot;Launch configuration does not exist.&quot;
    return ret
</PRE>
</div>
  </div>
</body>
</html>
