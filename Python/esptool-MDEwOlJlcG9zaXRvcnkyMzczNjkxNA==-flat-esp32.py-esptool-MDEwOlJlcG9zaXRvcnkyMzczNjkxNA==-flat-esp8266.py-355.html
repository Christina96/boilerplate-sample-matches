
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 22, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-esp32.py</h3>
            <pre><code>1  import struct
2  import time
3  from ..loader import ESPLoader
4  from ..util import FatalError, NotSupportedError
5  class ESP32ROM(ESPLoader):
6      CHIP_NAME = &quot;ESP32&quot;
7      IMAGE_CHIP_ID = 0
8      IS_STUB = False
9      FPGA_SLOW_BOOT = True
10      CHIP_DETECT_MAGIC_VALUE = [0x00F01D83]
11      IROM_MAP_START = 0x400D0000
12      IROM_MAP_END = 0x40400000
13      DROM_MAP_START = 0x3F400000
14      DROM_MAP_END = 0x3F800000
15      STATUS_BYTES_LENGTH = 4
16      SPI_REG_BASE = 0x3FF42000
17      SPI_USR_OFFS = 0x1C
18      SPI_USR1_OFFS = 0x20
19      SPI_USR2_OFFS = 0x24
20      SPI_MOSI_DLEN_OFFS = 0x28
21      SPI_MISO_DLEN_OFFS = 0x2C
22      EFUSE_RD_REG_BASE = 0x3FF5A000
23      EFUSE_DIS_DOWNLOAD_MANUAL_ENCRYPT_REG = EFUSE_RD_REG_BASE + 0x18
24      EFUSE_DIS_DOWNLOAD_MANUAL_ENCRYPT = 1 &lt;&lt; 7  # EFUSE_RD_DISABLE_DL_ENCRYPT
25      EFUSE_SPI_BOOT_CRYPT_CNT_REG = EFUSE_RD_REG_BASE  # EFUSE_BLK0_WDATA0_REG
26      EFUSE_SPI_BOOT_CRYPT_CNT_MASK = 0x7F &lt;&lt; 20  # EFUSE_FLASH_CRYPT_CNT
27      EFUSE_RD_ABS_DONE_REG = EFUSE_RD_REG_BASE + 0x018
28      EFUSE_RD_ABS_DONE_0_MASK = 1 &lt;&lt; 4
29      EFUSE_RD_ABS_DONE_1_MASK = 1 &lt;&lt; 5
30      DR_REG_SYSCON_BASE = 0x3FF66000
31      APB_CTL_DATE_ADDR = DR_REG_SYSCON_BASE + 0x7C
32      APB_CTL_DATE_V = 0x1
33      APB_CTL_DATE_S = 31
34      SPI_W0_OFFS = 0x80
35      UART_CLKDIV_REG = 0x3FF40014
36      XTAL_CLK_DIVIDER = 1
37      RTCCALICFG1 = 0x3FF5F06C
38      TIMERS_RTC_CALI_VALUE = 0x01FFFFFF
<span onclick='openModal()' class='match'>39      TIMERS_RTC_CALI_VALUE_S = 7
40      FLASH_SIZES = {
41          &quot;1MB&quot;: 0x00,
42          &quot;2MB&quot;: 0x10,
43          &quot;4MB&quot;: 0x20,
44          &quot;8MB&quot;: 0x30,
45          &quot;16MB&quot;: 0x40,
</span>46          &quot;32MB&quot;: 0x50,
47          &quot;64MB&quot;: 0x60,
48          &quot;128MB&quot;: 0x70,
49      }
50      FLASH_FREQUENCY = {
51          &quot;80m&quot;: 0xF,
52          &quot;40m&quot;: 0x0,
53          &quot;26m&quot;: 0x1,
54          &quot;20m&quot;: 0x2,
55      }
56      BOOTLOADER_FLASH_OFFSET = 0x1000
57      OVERRIDE_VDDSDIO_CHOICES = [&quot;1.8V&quot;, &quot;1.9V&quot;, &quot;OFF&quot;]
58      MEMORY_MAP = [
59          [0x00000000, 0x00010000, &quot;PADDING&quot;],
60          [0x3F400000, 0x3F800000, &quot;DROM&quot;],
61          [0x3F800000, 0x3FC00000, &quot;EXTRAM_DATA&quot;],
62          [0x3FF80000, 0x3FF82000, &quot;RTC_DRAM&quot;],
63          [0x3FF90000, 0x40000000, &quot;BYTE_ACCESSIBLE&quot;],
64          [0x3FFAE000, 0x40000000, &quot;DRAM&quot;],
65          [0x3FFE0000, 0x3FFFFFFC, &quot;DIRAM_DRAM&quot;],
66          [0x40000000, 0x40070000, &quot;IROM&quot;],
67          [0x40070000, 0x40078000, &quot;CACHE_PRO&quot;],
68          [0x40078000, 0x40080000, &quot;CACHE_APP&quot;],
69          [0x40080000, 0x400A0000, &quot;IRAM&quot;],
70          [0x400A0000, 0x400BFFFC, &quot;DIRAM_IRAM&quot;],
71          [0x400C0000, 0x400C2000, &quot;RTC_IRAM&quot;],
72          [0x400D0000, 0x40400000, &quot;IROM&quot;],
73          [0x50000000, 0x50002000, &quot;RTC_DATA&quot;],
74      ]
75      FLASH_ENCRYPTED_WRITE_ALIGN = 32
76      def is_flash_encryption_key_valid(self):
77          word0 = self.read_efuse(0)
78          rd_disable = (word0 &gt;&gt; 16) &amp; 0x1
79          if rd_disable:
80              return True
81          else:
82              key_word = [0] * 7
83              for i in range(len(key_word)):
84                  key_word[i] = self.read_efuse(14 + i)
85                  if key_word[i] != 0:
86                      return True
87              return False
88      def get_flash_crypt_config(self):
89          word0 = self.read_efuse(0)
90          rd_disable = (word0 &gt;&gt; 19) &amp; 0x1
91          if rd_disable == 0:
92              word5 = self.read_efuse(5)
93              word5 = (word5 &gt;&gt; 28) &amp; 0xF
94              return word5
95          else:
96              return 0xF
97      def get_encrypted_download_disabled(self):
98          return (
99              self.read_reg(self.EFUSE_DIS_DOWNLOAD_MANUAL_ENCRYPT_REG)
100              &amp; self.EFUSE_DIS_DOWNLOAD_MANUAL_ENCRYPT
101          )
102      def get_flash_encryption_enabled(self):
103          flash_crypt_cnt = (
104              self.read_reg(self.EFUSE_SPI_BOOT_CRYPT_CNT_REG)
105              &amp; self.EFUSE_SPI_BOOT_CRYPT_CNT_MASK
106          )
107          return bin(flash_crypt_cnt).count(&quot;1&quot;) &amp; 1 != 0
108      def get_secure_boot_enabled(self):
109          efuses = self.read_reg(self.EFUSE_RD_ABS_DONE_REG)
110          rev = self.get_chip_revision()
111          return efuses &amp; self.EFUSE_RD_ABS_DONE_0_MASK or (
112              rev &gt;= 300 and efuses &amp; self.EFUSE_RD_ABS_DONE_1_MASK
113          )
114      def get_pkg_version(self):
115          word3 = self.read_efuse(3)
116          pkg_version = (word3 &gt;&gt; 9) &amp; 0x07
117          pkg_version += ((word3 &gt;&gt; 2) &amp; 0x1) &lt;&lt; 3
118          return pkg_version
119      def get_chip_revision(self):
120          return self.get_major_chip_version() * 100 + self.get_minor_chip_version()
121      def get_minor_chip_version(self):
122          return (self.read_efuse(5) &gt;&gt; 24) &amp; 0x3
123      def get_major_chip_version(self):
124          rev_bit0 = (self.read_efuse(3) &gt;&gt; 15) &amp; 0x1
125          rev_bit1 = (self.read_efuse(5) &gt;&gt; 20) &amp; 0x1
126          apb_ctl_date = self.read_reg(self.APB_CTL_DATE_ADDR)
127          rev_bit2 = (apb_ctl_date &gt;&gt; self.APB_CTL_DATE_S) &amp; self.APB_CTL_DATE_V
128          combine_value = (rev_bit2 &lt;&lt; 2) | (rev_bit1 &lt;&lt; 1) | rev_bit0
129          revision = {
130              0: 0,
131              1: 1,
132              3: 2,
133              7: 3,
134          }.get(combine_value, 0)
135          return revision
136      def get_chip_description(self):
137          pkg_version = self.get_pkg_version()
138          major_rev = self.get_major_chip_version()
139          minor_rev = self.get_minor_chip_version()
140          rev3 = major_rev == 3
141          single_core = self.read_efuse(3) &amp; (1 &lt;&lt; 0)  # CHIP_VER DIS_APP_CPU
142          chip_name = {
143              0: &quot;ESP32-S0WDQ6&quot; if single_core else &quot;ESP32-D0WDQ6&quot;,
144              1: &quot;ESP32-S0WD&quot; if single_core else &quot;ESP32-D0WD&quot;,
145              2: &quot;ESP32-D2WD&quot;,
146              4: &quot;ESP32-U4WDH&quot;,
147              5: &quot;ESP32-PICO-V3&quot; if rev3 else &quot;ESP32-PICO-D4&quot;,
148              6: &quot;ESP32-PICO-V3-02&quot;,
149              7: &quot;ESP32-D0WDR2-V3&quot;,
150          }.get(pkg_version, &quot;unknown ESP32&quot;)
151          if chip_name.startswith(&quot;ESP32-D0WD&quot;) and rev3:
152              chip_name += &quot;-V3&quot;
153          return f&quot;{chip_name} (revision v{major_rev}.{minor_rev})&quot;
154      def get_chip_features(self):
155          features = [&quot;WiFi&quot;]
156          word3 = self.read_efuse(3)
157          chip_ver_dis_bt = word3 &amp; (1 &lt;&lt; 1)
158          if chip_ver_dis_bt == 0:
159              features += [&quot;BT&quot;]
160          chip_ver_dis_app_cpu = word3 &amp; (1 &lt;&lt; 0)
161          if chip_ver_dis_app_cpu:
162              features += [&quot;Single Core&quot;]
163          else:
164              features += [&quot;Dual Core&quot;]
165          chip_cpu_freq_rated = word3 &amp; (1 &lt;&lt; 13)
166          if chip_cpu_freq_rated:
167              chip_cpu_freq_low = word3 &amp; (1 &lt;&lt; 12)
168              if chip_cpu_freq_low:
169                  features += [&quot;160MHz&quot;]
170              else:
171                  features += [&quot;240MHz&quot;]
172          pkg_version = self.get_pkg_version()
173          if pkg_version in [2, 4, 5, 6]:
174              features += [&quot;Embedded Flash&quot;]
175          if pkg_version == 6:
176              features += [&quot;Embedded PSRAM&quot;]
177          word4 = self.read_efuse(4)
178          adc_vref = (word4 &gt;&gt; 8) &amp; 0x1F
179          if adc_vref:
180              features += [&quot;VRef calibration in efuse&quot;]
181          blk3_part_res = word3 &gt;&gt; 14 &amp; 0x1
182          if blk3_part_res:
183              features += [&quot;BLK3 partially reserved&quot;]
184          word6 = self.read_efuse(6)
185          coding_scheme = word6 &amp; 0x3
186          features += [
187              &quot;Coding Scheme %s&quot;
188              % {0: &quot;None&quot;, 1: &quot;3/4&quot;, 2: &quot;Repeat (UNSUPPORTED)&quot;, 3: &quot;Invalid&quot;}[
189                  coding_scheme
190              ]
191          ]
192          return features
193      def read_efuse(self, n):
194          return self.read_reg(self.EFUSE_RD_REG_BASE + (4 * n))
195      def chip_id(self):
196          raise NotSupportedError(self, &quot;chip_id&quot;)
197      def read_mac(self, mac_type=&quot;BASE_MAC&quot;):
198          if mac_type != &quot;BASE_MAC&quot;:
199              return None
200          words = [self.read_efuse(2), self.read_efuse(1)]
201          bitstring = struct.pack(&quot;&gt;II&quot;, *words)
202          bitstring = bitstring[2:8]  # trim the 2 byte CRC
203          return tuple(bitstring)
204      def get_erase_size(self, offset, size):
205          return size
206      def override_vddsdio(self, new_voltage):
207          new_voltage = new_voltage.upper()
208          if new_voltage not in self.OVERRIDE_VDDSDIO_CHOICES:
209              raise FatalError(
210                  &quot;The only accepted VDDSDIO overrides are &#x27;1.8V&#x27;, &#x27;1.9V&#x27; and &#x27;OFF&#x27;&quot;
211              )
212          RTC_CNTL_SDIO_CONF_REG = 0x3FF48074
213          RTC_CNTL_XPD_SDIO_REG = 1 &lt;&lt; 31
214          RTC_CNTL_DREFH_SDIO_M = 3 &lt;&lt; 29
215          RTC_CNTL_DREFM_SDIO_M = 3 &lt;&lt; 27
216          RTC_CNTL_DREFL_SDIO_M = 3 &lt;&lt; 25
217          RTC_CNTL_SDIO_FORCE = 1 &lt;&lt; 22
218          RTC_CNTL_SDIO_PD_EN = 1 &lt;&lt; 21
219          reg_val = RTC_CNTL_SDIO_FORCE  # override efuse setting
220          reg_val |= RTC_CNTL_SDIO_PD_EN
221          if new_voltage != &quot;OFF&quot;:
222              reg_val |= RTC_CNTL_XPD_SDIO_REG  # enable internal LDO
223          if new_voltage == &quot;1.9V&quot;:
224              reg_val |= (
225                  RTC_CNTL_DREFH_SDIO_M | RTC_CNTL_DREFM_SDIO_M | RTC_CNTL_DREFL_SDIO_M
226              )  # boost voltage
227          self.write_reg(RTC_CNTL_SDIO_CONF_REG, reg_val)
228          print(&quot;VDDSDIO regulator set to %s&quot; % new_voltage)
229      def read_flash_slow(self, offset, length, progress_fn):
230          BLOCK_LEN = 64  # ROM read limit per command (this limit is why it&#x27;s so slow)
231          data = b&quot;&quot;
232          while len(data) &lt; length:
233              block_len = min(BLOCK_LEN, length - len(data))
234              r = self.check_command(
235                  &quot;read flash block&quot;,
236                  self.ESP_READ_FLASH_SLOW,
237                  struct.pack(&quot;&lt;II&quot;, offset + len(data), block_len),
238              )
239              if len(r) &lt; block_len:
240                  raise FatalError(
241                      &quot;Expected %d byte block, got %d bytes. Serial errors?&quot;
242                      % (block_len, len(r))
243                  )
244              data += r[:block_len]
245              if progress_fn and (len(data) % 1024 == 0 or len(data) == length):
246                  progress_fn(len(data), length)
247          return data
248      def get_rom_cal_crystal_freq(self):
249          cali_val = (
250              self.read_reg(self.RTCCALICFG1) &gt;&gt; self.TIMERS_RTC_CALI_VALUE_S
251          ) &amp; self.TIMERS_RTC_CALI_VALUE
252          clk_8M_freq = self.read_efuse(4) &amp; (0xFF)  # EFUSE_RD_CK8M_FREQ
253          rom_calculated_freq = cali_val * 15625 * clk_8M_freq / 40
254          return rom_calculated_freq
255      def change_baud(self, baud):
256          rom_calculated_freq = self.get_rom_cal_crystal_freq()
257          valid_freq = 40000000 if rom_calculated_freq &gt; 33000000 else 26000000
258          false_rom_baud = int(baud * rom_calculated_freq // valid_freq)
259          print(f&quot;Changing baud rate to {baud}&quot;)
260          self.command(self.ESP_CHANGE_BAUDRATE, struct.pack(&quot;&lt;II&quot;, false_rom_baud, 0))
261          print(&quot;Changed.&quot;)
262          self._set_port_baudrate(baud)
263          time.sleep(0.05)  # get rid of garbage sent during baud rate change
264          self.flush_input()
265  class ESP32StubLoader(ESP32ROM):
266      FLASH_WRITE_SIZE = 0x4000  # matches MAX_WRITE_BLOCK in stub_loader.c
267      STATUS_BYTES_LENGTH = 2  # same as ESP8266, different to ESP32 ROM
268      IS_STUB = True
269      def __init__(self, rom_loader):
270          self.secure_download_mode = rom_loader.secure_download_mode
271          self._port = rom_loader._port
272          self._trace_enabled = rom_loader._trace_enabled
273          self.cache = rom_loader.cache
274          self.flush_input()  # resets _slip_reader
275      def change_baud(self, baud):
276          ESPLoader.change_baud(self, baud)
277  ESP32ROM.STUB_CLASS = ESP32StubLoader
</code></pre>
        </div>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-esp8266.py</h3>
            <pre><code>1  from ..loader import ESPLoader
2  from ..util import FatalError, NotImplementedInROMError
3  class ESP8266ROM(ESPLoader):
4      CHIP_NAME = &quot;ESP8266&quot;
5      IS_STUB = False
6      CHIP_DETECT_MAGIC_VALUE = [0xFFF0C101]
7      ESP_OTP_MAC0 = 0x3FF00050
8      ESP_OTP_MAC1 = 0x3FF00054
9      ESP_OTP_MAC3 = 0x3FF0005C
10      SPI_REG_BASE = 0x60000200
11      SPI_USR_OFFS = 0x1C
12      SPI_USR1_OFFS = 0x20
13      SPI_USR2_OFFS = 0x24
14      SPI_MOSI_DLEN_OFFS = None
15      SPI_MISO_DLEN_OFFS = None
16      SPI_W0_OFFS = 0x40
17      UART_CLKDIV_REG = 0x60000014
<span onclick='openModal()' class='match'>18      XTAL_CLK_DIVIDER = 2
19      FLASH_SIZES = {
20          &quot;512KB&quot;: 0x00,
21          &quot;256KB&quot;: 0x10,
22          &quot;1MB&quot;: 0x20,
23          &quot;2MB&quot;: 0x30,
24          &quot;4MB&quot;: 0x40,
</span>25          &quot;2MB-c1&quot;: 0x50,
26          &quot;4MB-c1&quot;: 0x60,
27          &quot;8MB&quot;: 0x80,
28          &quot;16MB&quot;: 0x90,
29      }
30      FLASH_FREQUENCY = {
31          &quot;80m&quot;: 0xF,
32          &quot;40m&quot;: 0x0,
33          &quot;26m&quot;: 0x1,
34          &quot;20m&quot;: 0x2,
35      }
36      BOOTLOADER_FLASH_OFFSET = 0
37      MEMORY_MAP = [
38          [0x3FF00000, 0x3FF00010, &quot;DPORT&quot;],
39          [0x3FFE8000, 0x40000000, &quot;DRAM&quot;],
40          [0x40100000, 0x40108000, &quot;IRAM&quot;],
41          [0x40201010, 0x402E1010, &quot;IROM&quot;],
42      ]
43      def get_efuses(self):
44          result = self.read_reg(0x3FF0005C) &lt;&lt; 96
45          result |= self.read_reg(0x3FF00058) &lt;&lt; 64
46          result |= self.read_reg(0x3FF00054) &lt;&lt; 32
47          result |= self.read_reg(0x3FF00050)
48          return result
49      def _get_flash_size(self, efuses):
50          r0_4 = (efuses &amp; (1 &lt;&lt; 4)) != 0
51          r3_25 = (efuses &amp; (1 &lt;&lt; 121)) != 0
52          r3_26 = (efuses &amp; (1 &lt;&lt; 122)) != 0
53          r3_27 = (efuses &amp; (1 &lt;&lt; 123)) != 0
54          if r0_4 and not r3_25:
55              if not r3_27 and not r3_26:
56                  return 1
57              elif not r3_27 and r3_26:
58                  return 2
59          if not r0_4 and r3_25:
60              if not r3_27 and not r3_26:
61                  return 2
62              elif not r3_27 and r3_26:
63                  return 4
64          return -1
65      def get_chip_description(self):
66          efuses = self.get_efuses()
67          is_8285 = (
68              efuses &amp; ((1 &lt;&lt; 4) | 1 &lt;&lt; 80)
69          ) != 0  # One or the other efuse bit is set for ESP8285
70          if is_8285:
71              flash_size = self._get_flash_size(efuses)
72              max_temp = (
73                  efuses &amp; (1 &lt;&lt; 5)
74              ) != 0  # This efuse bit identifies the max flash temperature
75              chip_name = {
76                  1: &quot;ESP8285H08&quot; if max_temp else &quot;ESP8285N08&quot;,
77                  2: &quot;ESP8285H16&quot; if max_temp else &quot;ESP8285N16&quot;,
78              }.get(flash_size, &quot;ESP8285&quot;)
79              return chip_name
80          return &quot;ESP8266EX&quot;
81      def get_chip_features(self):
82          features = [&quot;WiFi&quot;]
83          if &quot;ESP8285&quot; in self.get_chip_description():
84              features += [&quot;Embedded Flash&quot;]
85          return features
86      def flash_spi_attach(self, hspi_arg):
87          if self.IS_STUB:
88              super(ESP8266ROM, self).flash_spi_attach(hspi_arg)
89          else:
90              self.flash_begin(0, 0)
91      def flash_set_parameters(self, size):
92          if self.IS_STUB:
93              super(ESP8266ROM, self).flash_set_parameters(size)
94      def chip_id(self):
95          id0 = self.read_reg(self.ESP_OTP_MAC0)
96          id1 = self.read_reg(self.ESP_OTP_MAC1)
97          return (id0 &gt;&gt; 24) | ((id1 &amp; 0xFFFFFF) &lt;&lt; 8)
98      def read_mac(self, mac_type=&quot;BASE_MAC&quot;):
99          if mac_type != &quot;BASE_MAC&quot;:
100              return None
101          mac0 = self.read_reg(self.ESP_OTP_MAC0)
102          mac1 = self.read_reg(self.ESP_OTP_MAC1)
103          mac3 = self.read_reg(self.ESP_OTP_MAC3)
104          if mac3 != 0:
105              oui = ((mac3 &gt;&gt; 16) &amp; 0xFF, (mac3 &gt;&gt; 8) &amp; 0xFF, mac3 &amp; 0xFF)
106          elif ((mac1 &gt;&gt; 16) &amp; 0xFF) == 0:
107              oui = (0x18, 0xFE, 0x34)
108          elif ((mac1 &gt;&gt; 16) &amp; 0xFF) == 1:
109              oui = (0xAC, 0xD0, 0x74)
110          else:
111              raise FatalError(&quot;Unknown OUI&quot;)
112          return oui + ((mac1 &gt;&gt; 8) &amp; 0xFF, mac1 &amp; 0xFF, (mac0 &gt;&gt; 24) &amp; 0xFF)
113      def get_erase_size(self, offset, size):
114          sectors_per_block = 16
115          sector_size = self.FLASH_SECTOR_SIZE
116          num_sectors = (size + sector_size - 1) // sector_size
117          start_sector = offset // sector_size
118          head_sectors = sectors_per_block - (start_sector % sectors_per_block)
119          if num_sectors &lt; head_sectors:
120              head_sectors = num_sectors
121          if num_sectors &lt; 2 * head_sectors:
122              return (num_sectors + 1) // 2 * sector_size
123          else:
124              return (num_sectors - head_sectors) * sector_size
125      def override_vddsdio(self, new_voltage):
126          raise NotImplementedInROMError(
127              &quot;Overriding VDDSDIO setting only applies to ESP32&quot;
128          )
129  class ESP8266StubLoader(ESP8266ROM):
130      FLASH_WRITE_SIZE = 0x4000  # matches MAX_WRITE_BLOCK in stub_loader.c
131      IS_STUB = True
132      def __init__(self, rom_loader):
133          self.secure_download_mode = rom_loader.secure_download_mode
134          self._port = rom_loader._port
135          self._trace_enabled = rom_loader._trace_enabled
136          self.cache = rom_loader.cache
137          self.flush_input()  # resets _slip_reader
138      def get_erase_size(self, offset, size):
139          return size  # stub doesn&#x27;t have same size bug as ROM loader
140  ESP8266ROM.STUB_CLASS = ESP8266StubLoader
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-esp32.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-esp8266.py</div>
                </div>
                <div class="column column_space"><pre><code>39      TIMERS_RTC_CALI_VALUE_S = 7
40      FLASH_SIZES = {
41          &quot;1MB&quot;: 0x00,
42          &quot;2MB&quot;: 0x10,
43          &quot;4MB&quot;: 0x20,
44          &quot;8MB&quot;: 0x30,
45          &quot;16MB&quot;: 0x40,
</pre></code></div>
                <div class="column column_space"><pre><code>18      XTAL_CLK_DIVIDER = 2
19      FLASH_SIZES = {
20          &quot;512KB&quot;: 0x00,
21          &quot;256KB&quot;: 0x10,
22          &quot;1MB&quot;: 0x20,
23          &quot;2MB&quot;: 0x30,
24          &quot;4MB&quot;: 0x40,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    