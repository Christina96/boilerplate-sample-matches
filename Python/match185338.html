<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_selinux_2.py & test_aptpkg_1.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_selinux_2.py & test_aptpkg_1.py
      </h3>
      <h1 align="center">
        1.8%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_selinux_2.py (7.7777777%)<TH>test_aptpkg_1.py (1.0424423%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match185338-0.html#0',2,'match185338-1.html#0',3)" NAME="0">(97-103)<TD><A HREF="javascript:ZweiFrames('match185338-0.html#0',2,'match185338-1.html#0',3)" NAME="0">(267-271)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_selinux_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
    :codeauthor: Jayesh Kariya &lt;jayeshk@saltstack.com&gt;
&quot;&quot;&quot;

import pytest
import salt.states.selinux as selinux
from tests.support.mock import MagicMock, patch


@pytest.fixture
def configure_loader_modules():
    return {selinux: {}}


def test_mode():
    &quot;&quot;&quot;
    Test to verifies the mode SELinux is running in,
    can be set to enforcing or permissive.
    &quot;&quot;&quot;
    ret = {
        &quot;name&quot;: &quot;unknown&quot;,
        &quot;changes&quot;: {},
        &quot;result&quot;: False,
        &quot;comment&quot;: &quot;unknown is not an accepted mode&quot;,
    }
    assert selinux.mode(&quot;unknown&quot;) == ret

    mock_en = MagicMock(return_value=&quot;Enforcing&quot;)
    mock_pr = MagicMock(side_effect=[&quot;Permissive&quot;, &quot;Enforcing&quot;])
    with patch.dict(
        selinux.__salt__,
        {
            &quot;selinux.getenforce&quot;: mock_en,
            &quot;selinux.getconfig&quot;: mock_en,
            &quot;selinux.setenforce&quot;: mock_pr,
        },
    ):
        comt = &quot;SELinux is already in Enforcing mode&quot;
        ret = {&quot;name&quot;: &quot;Enforcing&quot;, &quot;comment&quot;: comt, &quot;result&quot;: True, &quot;changes&quot;: {}}
        assert selinux.mode(&quot;Enforcing&quot;) == ret

        with patch.dict(selinux.__opts__, {&quot;test&quot;: True}):
            comt = &quot;SELinux mode is set to be changed to Permissive&quot;
            ret = {
                &quot;name&quot;: &quot;Permissive&quot;,
                &quot;comment&quot;: comt,
                &quot;result&quot;: None,
                &quot;changes&quot;: {&quot;new&quot;: &quot;Permissive&quot;, &quot;old&quot;: &quot;Enforcing&quot;},
            }
            assert selinux.mode(&quot;Permissive&quot;) == ret

        with patch.dict(selinux.__opts__, {&quot;test&quot;: False}):
            comt = &quot;SELinux has been set to Permissive mode&quot;
            ret = {
                &quot;name&quot;: &quot;Permissive&quot;,
                &quot;comment&quot;: comt,
                &quot;result&quot;: True,
                &quot;changes&quot;: {&quot;new&quot;: &quot;Permissive&quot;, &quot;old&quot;: &quot;Enforcing&quot;},
            }
            assert selinux.mode(&quot;Permissive&quot;) == ret

            comt = &quot;Failed to set SELinux to Permissive mode&quot;
            ret.update(
                {&quot;name&quot;: &quot;Permissive&quot;, &quot;comment&quot;: comt, &quot;result&quot;: False, &quot;changes&quot;: {}}
            )
            assert selinux.mode(&quot;Permissive&quot;) == ret


def test_boolean():
    &quot;&quot;&quot;
    Test to set up an SELinux boolean.
    &quot;&quot;&quot;
    name = &quot;samba_create_home_dirs&quot;
    value = True
    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    mock_en = MagicMock(return_value=[])
    with patch.dict(selinux.__salt__, {&quot;selinux.list_sebool&quot;: mock_en}):
        comt = &quot;Boolean {} is not available&quot;.format(name)
        ret.update({&quot;comment&quot;: comt})
        assert selinux.boolean(name, value) == ret

    mock_bools = MagicMock(return_value={name: {&quot;State&quot;: &quot;on&quot;, &quot;Default&quot;: &quot;on&quot;}})
    with patch.dict(selinux.__salt__, {&quot;selinux.list_sebool&quot;: mock_bools}):
        comt = &quot;None is not a valid value for the boolean&quot;
        ret.update({&quot;comment&quot;: comt})
        assert selinux.boolean(name, None) == ret

        comt = &quot;Boolean is in the correct state&quot;
        ret.update({&quot;comment&quot;: comt, &quot;result&quot;: True})
        assert selinux.boolean(name, value, True) == ret

        comt = &quot;Boolean is in the correct state&quot;
<A NAME="0"></A>        ret.update({&quot;comment&quot;: comt, &quot;result&quot;: True})
        assert selinux.boolean(name, value) == ret

    mock_bools = MagicMock(return_value={name: {<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match185338-1.html#0',3,'match185338-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>&quot;State&quot;: &quot;off&quot;, &quot;Default&quot;: &quot;on&quot;}})
    mock = MagicMock(side_effect=[True, False])
    with patch.dict(
        selinux.__salt__,
        {&quot;selinux.list_sebool&quot;: mock_bools, &quot;selinux.setsebool&quot;: mock},
    ):
        with patch.dict(selinux.</B></FONT>__opts__, {&quot;test&quot;: True}):
            comt = &quot;Boolean samba_create_home_dirs is set to be changed to on&quot;
            ret.update({&quot;comment&quot;: comt, &quot;result&quot;: None})
            assert selinux.boolean(name, value) == ret

        with patch.dict(selinux.__opts__, {&quot;test&quot;: False}):
            comt = &quot;Boolean samba_create_home_dirs has been set to on&quot;
            ret.update({&quot;comment&quot;: comt, &quot;result&quot;: True})
            ret.update({&quot;changes&quot;: {&quot;State&quot;: {&quot;old&quot;: &quot;off&quot;, &quot;new&quot;: &quot;on&quot;}}})
            assert selinux.boolean(name, value) == ret

            comt = &quot;Failed to set the boolean samba_create_home_dirs to on&quot;
            ret.update({&quot;comment&quot;: comt, &quot;result&quot;: False})
            ret.update({&quot;changes&quot;: {}})
            assert selinux.boolean(name, value) == ret
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_aptpkg_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
    :synopsis: Unit Tests for Advanced Packaging Tool module 'module.aptpkg'
    :platform: Linux
    :maturity: develop
    versionadded:: 2017.7.0
&quot;&quot;&quot;


import copy
import logging
import os
import pathlib
import textwrap

import pytest
import salt.modules.aptpkg as aptpkg
import salt.modules.pkg_resource as pkg_resource
from salt.exceptions import (
    CommandExecutionError,
    CommandNotFoundError,
    SaltInvocationError,
)
from tests.support.mock import MagicMock, Mock, call, mock_open, patch

try:
    from aptsources import sourceslist  # pylint: disable=unused-import

    HAS_APTSOURCES = True
except ImportError:
    HAS_APTSOURCES = False

log = logging.getLogger(__name__)


@pytest.fixture(scope=&quot;module&quot;)
def repo_keys_var():
    return {
        &quot;46181433FBB75451&quot;: {
            &quot;algorithm&quot;: 17,
            &quot;bits&quot;: 1024,
            &quot;capability&quot;: &quot;scSC&quot;,
            &quot;date_creation&quot;: 1104433784,
            &quot;date_expiration&quot;: None,
            &quot;fingerprint&quot;: &quot;C5986B4F1257FFA86632CBA746181433FBB75451&quot;,
            &quot;keyid&quot;: &quot;46181433FBB75451&quot;,
            &quot;uid&quot;: &quot;Ubuntu CD Image Automatic Signing Key &lt;cdimage@ubuntu.com&gt;&quot;,
            &quot;uid_hash&quot;: &quot;B4D41942D4B35FF44182C7F9D00C99AF27B93AD0&quot;,
            &quot;validity&quot;: &quot;-&quot;,
        }
    }


@pytest.fixture(scope=&quot;module&quot;)
def packages_var():
    return {&quot;wget&quot;: &quot;1.15-1ubuntu1.14.04.2&quot;}


@pytest.fixture(scope=&quot;module&quot;)
def lowpkg_files_var():
    return {
        &quot;errors&quot;: {},
        &quot;packages&quot;: {
            &quot;wget&quot;: [
                &quot;/.&quot;,
                &quot;/etc&quot;,
                &quot;/etc/wgetrc&quot;,
                &quot;/usr&quot;,
                &quot;/usr/bin&quot;,
                &quot;/usr/bin/wget&quot;,
                &quot;/usr/share&quot;,
                &quot;/usr/share/info&quot;,
                &quot;/usr/share/info/wget.info.gz&quot;,
                &quot;/usr/share/doc&quot;,
                &quot;/usr/share/doc/wget&quot;,
                &quot;/usr/share/doc/wget/MAILING-LIST&quot;,
                &quot;/usr/share/doc/wget/NEWS.gz&quot;,
                &quot;/usr/share/doc/wget/AUTHORS&quot;,
                &quot;/usr/share/doc/wget/copyright&quot;,
                &quot;/usr/share/doc/wget/changelog.Debian.gz&quot;,
                &quot;/usr/share/doc/wget/README&quot;,
                &quot;/usr/share/man&quot;,
                &quot;/usr/share/man/man1&quot;,
                &quot;/usr/share/man/man1/wget.1.gz&quot;,
            ]
        },
    }


@pytest.fixture(scope=&quot;module&quot;)
def lowpkg_info_var():
    return {
        &quot;wget&quot;: {
            &quot;architecture&quot;: &quot;amd64&quot;,
            &quot;description&quot;: &quot;retrieves files from the web&quot;,
            &quot;homepage&quot;: &quot;http://www.gnu.org/software/wget/&quot;,
            &quot;install_date&quot;: &quot;2016-08-30T22:20:15Z&quot;,
            &quot;maintainer&quot;: &quot;Ubuntu Developers &lt;ubuntu-devel-discuss@lists.ubuntu.com&gt;&quot;,
            &quot;name&quot;: &quot;wget&quot;,
            &quot;section&quot;: &quot;web&quot;,
            &quot;source&quot;: &quot;wget&quot;,
            &quot;version&quot;: &quot;1.15-1ubuntu1.14.04.2&quot;,
            &quot;status&quot;: &quot;ii&quot;,
        },
        &quot;apache2&quot;: {
            &quot;architecture&quot;: &quot;amd64&quot;,
            &quot;description&quot;: &quot;&quot;&quot;Apache HTTP Server
     The Apache HTTP Server Project's goal is to build a secure, efficient and
     extensible HTTP server as standards-compliant open source software. The
     result has long been the number one web server on the Internet.
     .
     Installing this package results in a full installation, including the
     configuration files, init scripts and support scripts.&quot;&quot;&quot;,
            &quot;homepage&quot;: &quot;http://httpd.apache.org/&quot;,
            &quot;install_date&quot;: &quot;2016-08-30T22:20:15Z&quot;,
            &quot;maintainer&quot;: &quot;Ubuntu Developers &lt;ubuntu-devel-discuss@lists.ubuntu.com&gt;&quot;,
            &quot;name&quot;: &quot;apache2&quot;,
            &quot;section&quot;: &quot;httpd&quot;,
            &quot;source&quot;: &quot;apache2&quot;,
            &quot;version&quot;: &quot;2.4.18-2ubuntu3.9&quot;,
            &quot;status&quot;: &quot;rc&quot;,
        },
    }


@pytest.fixture(scope=&quot;module&quot;)
def apt_q_update_var():
    return &quot;&quot;&quot;
    Get:1 http://security.ubuntu.com trusty-security InRelease [65 kB]
    Get:2 http://security.ubuntu.com trusty-security/main Sources [120 kB]
    Get:3 http://security.ubuntu.com trusty-security/main amd64 Packages [548 kB]
    Get:4 http://security.ubuntu.com trusty-security/main i386 Packages [507 kB]
    Hit http://security.ubuntu.com trusty-security/main Translation-en
    Fetched 1240 kB in 10s (124 kB/s)
    Reading package lists...
    &quot;&quot;&quot;


@pytest.fixture(scope=&quot;module&quot;)
def apt_q_update_error_var():
    return &quot;&quot;&quot;
    Err http://security.ubuntu.com trusty InRelease

    Err http://security.ubuntu.com trusty Release.gpg
    Unable to connect to security.ubuntu.com:http:
    Reading package lists...
    W: Failed to fetch http://security.ubuntu.com/ubuntu/dists/trusty/InRelease

    W: Failed to fetch http://security.ubuntu.com/ubuntu/dists/trusty/Release.gpg  Unable to connect to security.ubuntu.com:http:

    W: Some index files failed to download. They have been ignored, or old ones used instead.
    &quot;&quot;&quot;


@pytest.fixture(scope=&quot;module&quot;)
def autoremove_var():
    return &quot;&quot;&quot;
    Reading package lists... Done
    Building dependency tree
    Reading state information... Done
    0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
    &quot;&quot;&quot;


@pytest.fixture(scope=&quot;module&quot;)
def upgrade_var():
    return &quot;&quot;&quot;
    Reading package lists...
    Building dependency tree...
    Reading state information...
    0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
    &quot;&quot;&quot;


@pytest.fixture(scope=&quot;module&quot;)
def uninstall_var():
    return {&quot;tmux&quot;: {&quot;new&quot;: &quot;&quot;, &quot;old&quot;: &quot;1.8-5&quot;}}


@pytest.fixture(scope=&quot;module&quot;)
def install_var():
    return {&quot;tmux&quot;: {&quot;new&quot;: &quot;1.8-5&quot;, &quot;old&quot;: &quot;&quot;}}


def _get_uri(repo):
    &quot;&quot;&quot;
    Get the URI portion of the a string
    &quot;&quot;&quot;
    splits = repo.split()
    for val in splits:
        if any(val.startswith(x) for x in (&quot;http://&quot;, &quot;https://&quot;, &quot;ftp://&quot;)):
            return val


class MockSourceEntry:
    def __init__(self, uri, source_type, line, invalid, dist=&quot;&quot;, file=None):
        self.uri = uri
        self.type = source_type
        self.line = line
        self.invalid = invalid
        self.file = file
        self.disabled = False
        self.dist = dist
        self.comps = []
        self.architectures = []

    def mysplit(self, line):
        return line.split()


class MockSourceList:
    def __init__(self):
        self.list = []

    def __iter__(self):
        yield from self.list

    def save(self):
        pass


@pytest.fixture
def configure_loader_modules():
    return {aptpkg: {&quot;__grains__&quot;: {}}}


def test_version(lowpkg_info_var):
    &quot;&quot;&quot;
    Test - Returns a string representing the package version or an empty string if
    not installed.
    &quot;&quot;&quot;
    version = lowpkg_info_var[&quot;wget&quot;][&quot;version&quot;]
    mock = MagicMock(return_value=version)
    with patch.dict(aptpkg.__salt__, {&quot;pkg_resource.version&quot;: mock}):
        assert aptpkg.version(*[&quot;wget&quot;]) == version


def test_upgrade_available():
    &quot;&quot;&quot;
    Test - Check whether or not an upgrade is available for a given package.
    &quot;&quot;&quot;
    with patch(&quot;salt.modules.aptpkg.latest_version&quot;, MagicMock(return_value=&quot;&quot;)):
        assert aptpkg.upgrade_available(&quot;wget&quot;) is False


def test_add_repo_key(repo_keys_var):
    &quot;&quot;&quot;
    Test - Add a repo key.
    &quot;&quot;&quot;
    with patch(
        &quot;salt.modules.aptpkg.get_repo_keys&quot;, MagicMock(return_value=repo_keys_var)
    ):
        mock = MagicMock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: &quot;OK&quot;})
        with patch.dict(aptpkg.__salt__, {&quot;cmd.run_all&quot;: mock}):
            assert (
                aptpkg.add_repo_key(keyserver=&quot;keyserver.ubuntu.com&quot;, keyid=&quot;FBB75451&quot;)
                is True
            )


def test_add_repo_key_failed(repo_keys_var):
    &quot;&quot;&quot;
    Test - Add a repo key using incomplete input data.
    &quot;&quot;&quot;
<A NAME="0"></A>    with patch(
        &quot;salt.modules.aptpkg.get_repo_keys&quot;, MagicMock(return_value=repo_keys_var)
    ):
        kwargs = {<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match185338-0.html#0',2,'match185338-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>&quot;keyserver&quot;: &quot;keyserver.ubuntu.com&quot;}
        mock = MagicMock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: &quot;OK&quot;})
        with patch.dict(aptpkg.__salt__, {&quot;cmd.run_all&quot;: mock}):
            with pytest.raises(SaltInvocationError):
                aptpkg.</B></FONT>add_repo_key(**kwargs)


def test_get_repo_keys(repo_keys_var):
    &quot;&quot;&quot;
    Test - List known repo key details.
    &quot;&quot;&quot;
    APT_KEY_LIST = r&quot;&quot;&quot;
    pub:-:1024:17:46181433FBB75451:1104433784:::-:::scSC:
    fpr:::::::::C5986B4F1257FFA86632CBA746181433FBB75451:
    uid:-::::1104433784::B4D41942D4B35FF44182C7F9D00C99AF27B93AD0::Ubuntu CD Image Automatic Signing Key &lt;cdimage@ubuntu.com&gt;:
    &quot;&quot;&quot;

    mock = MagicMock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: APT_KEY_LIST})
    with patch.dict(aptpkg.__salt__, {&quot;cmd.run_all&quot;: mock}):
        assert aptpkg.get_repo_keys() == repo_keys_var


def test_file_dict(lowpkg_files_var):
    &quot;&quot;&quot;
    Test - List the files that belong to a package, grouped by package.
    &quot;&quot;&quot;
    mock = MagicMock(return_value=lowpkg_files_var)
    with patch.dict(aptpkg.__salt__, {&quot;lowpkg.file_dict&quot;: mock}):
        assert aptpkg.file_dict(&quot;wget&quot;) == lowpkg_files_var


def test_file_list(lowpkg_files_var):
    &quot;&quot;&quot;
    Test - List the files that belong to a package.
    &quot;&quot;&quot;
    files = {
        &quot;errors&quot;: lowpkg_files_var[&quot;errors&quot;],
        &quot;files&quot;: lowpkg_files_var[&quot;packages&quot;][&quot;wget&quot;],
    }
    mock = MagicMock(return_value=files)
    with patch.dict(aptpkg.__salt__, {&quot;lowpkg.file_list&quot;: mock}):
        assert aptpkg.file_list(&quot;wget&quot;) == files


def test_get_selections():
    &quot;&quot;&quot;
    Test - View package state from the dpkg database.
    &quot;&quot;&quot;
    selections = {&quot;install&quot;: [&quot;wget&quot;]}
    mock = MagicMock(return_value=&quot;wget\t\t\t\t\t\tinstall&quot;)
    with patch.dict(aptpkg.__salt__, {&quot;cmd.run_stdout&quot;: mock}):
        assert aptpkg.get_selections(&quot;wget&quot;) == selections


def test_info_installed(lowpkg_info_var):
    &quot;&quot;&quot;
    Test - Return the information of the named package(s) installed on the system.
    &quot;&quot;&quot;
    names = {&quot;group&quot;: &quot;section&quot;, &quot;packager&quot;: &quot;maintainer&quot;, &quot;url&quot;: &quot;homepage&quot;}

    installed = copy.deepcopy({&quot;wget&quot;: lowpkg_info_var[&quot;wget&quot;]})
    for name in names:
        if installed[&quot;wget&quot;].get(names[name], False):
            installed[&quot;wget&quot;][name] = installed[&quot;wget&quot;].pop(names[name])

    mock = MagicMock(return_value=lowpkg_info_var)
    with patch.dict(aptpkg.__salt__, {&quot;lowpkg.info&quot;: mock}):
        del installed[&quot;wget&quot;][&quot;status&quot;]
        assert aptpkg.info_installed(&quot;wget&quot;) == installed
        assert len(aptpkg.info_installed()) == 1


def test_owner():
    &quot;&quot;&quot;
    Test - Return the name of the package that owns the file.
    &quot;&quot;&quot;
    paths = [&quot;/usr/bin/wget&quot;]
    mock = MagicMock(return_value=&quot;wget: /usr/bin/wget&quot;)
    with patch.dict(aptpkg.__salt__, {&quot;cmd.run_stdout&quot;: mock}):
        assert aptpkg.owner(*paths) == &quot;wget&quot;


def test_refresh_db(apt_q_update_var):
    &quot;&quot;&quot;
    Test - Updates the APT database to latest packages based upon repositories.
    &quot;&quot;&quot;
    refresh_db = {
        &quot;http://security.ubuntu.com trusty-security InRelease&quot;: True,
        &quot;http://security.ubuntu.com trusty-security/main Sources&quot;: True,
        &quot;http://security.ubuntu.com trusty-security/main Translation-en&quot;: None,
        &quot;http://security.ubuntu.com trusty-security/main amd64 Packages&quot;: True,
        &quot;http://security.ubuntu.com trusty-security/main i386 Packages&quot;: True,
    }
    mock = MagicMock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: apt_q_update_var})
    with patch(&quot;salt.utils.pkg.clear_rtag&quot;, MagicMock()):
        with patch.dict(
            aptpkg.__salt__,
            {&quot;cmd.run_all&quot;: mock, &quot;config.get&quot;: MagicMock(return_value=False)},
        ):
            assert aptpkg.refresh_db() == refresh_db


def test_refresh_db_failed(apt_q_update_error_var):
    &quot;&quot;&quot;
    Test - Update the APT database using unreachable repositories.
    &quot;&quot;&quot;
    kwargs = {&quot;failhard&quot;: True}
    mock = MagicMock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: apt_q_update_error_var})
    with patch(&quot;salt.utils.pkg.clear_rtag&quot;, MagicMock()):
        with patch.dict(
            aptpkg.__salt__,
            {&quot;cmd.run_all&quot;: mock, &quot;config.get&quot;: MagicMock(return_value=False)},
        ):
            with pytest.raises(CommandExecutionError):
                aptpkg.refresh_db(**kwargs)


def test_autoremove(packages_var, autoremove_var):
    &quot;&quot;&quot;
    Test - Remove packages not required by another package.
    &quot;&quot;&quot;
    with patch(&quot;salt.modules.aptpkg.list_pkgs&quot;, MagicMock(return_value=packages_var)):
        patch_kwargs = {
            &quot;__salt__&quot;: {
                &quot;config.get&quot;: MagicMock(return_value=True),
                &quot;cmd.run_all&quot;: MagicMock(
                    return_value=MagicMock(return_value=autoremove_var)
                ),
            }
        }
        with patch.multiple(aptpkg, **patch_kwargs):
            assert aptpkg.autoremove() == {}
            assert aptpkg.autoremove(purge=True) == {}
            assert aptpkg.autoremove(list_only=True) == []
            assert aptpkg.autoremove(list_only=True, purge=True) == []


def test_install(install_var):
    &quot;&quot;&quot;
    Test - Install packages.
    &quot;&quot;&quot;
    with patch(&quot;salt.modules.aptpkg.install&quot;, MagicMock(return_value=install_var)):
        assert aptpkg.install(name=&quot;tmux&quot;) == install_var
        kwargs = {&quot;force_conf_new&quot;: True}
        assert aptpkg.install(name=&quot;tmux&quot;, **kwargs) == install_var


def test_remove(uninstall_var):
    &quot;&quot;&quot;
    Test - Remove packages.
    &quot;&quot;&quot;
    with patch(&quot;salt.modules.aptpkg._uninstall&quot;, MagicMock(return_value=uninstall_var)):
        assert aptpkg.remove(name=&quot;tmux&quot;) == uninstall_var


def test_purge(uninstall_var):
    &quot;&quot;&quot;
    Test - Remove packages along with all configuration files.
    &quot;&quot;&quot;
    with patch(&quot;salt.modules.aptpkg._uninstall&quot;, MagicMock(return_value=uninstall_var)):
        assert aptpkg.purge(name=&quot;tmux&quot;) == uninstall_var


def test_upgrade(uninstall_var, upgrade_var):
    &quot;&quot;&quot;
    Test - Upgrades all packages.
    &quot;&quot;&quot;
    with patch(&quot;salt.utils.pkg.clear_rtag&quot;, MagicMock()):
        with patch(
            &quot;salt.modules.aptpkg.list_pkgs&quot;, MagicMock(return_value=uninstall_var)
        ):
            mock_cmd = MagicMock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: upgrade_var})
            patch_kwargs = {
                &quot;__salt__&quot;: {
                    &quot;config.get&quot;: MagicMock(return_value=True),
                    &quot;cmd.run_all&quot;: mock_cmd,
                }
            }
            with patch.multiple(aptpkg, **patch_kwargs):
                assert aptpkg.upgrade() == dict()
                kwargs = {&quot;force_conf_new&quot;: True}
                assert aptpkg.upgrade(**kwargs) == dict()


def test_upgrade_downloadonly(uninstall_var, upgrade_var):
    &quot;&quot;&quot;
    Tests the download-only options for upgrade.
    &quot;&quot;&quot;
    with patch(&quot;salt.utils.pkg.clear_rtag&quot;, MagicMock()):
        with patch(
            &quot;salt.modules.aptpkg.list_pkgs&quot;, MagicMock(return_value=uninstall_var)
        ):
            mock_cmd = MagicMock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: upgrade_var})
            patch_kwargs = {
                &quot;__salt__&quot;: {
                    &quot;config.get&quot;: MagicMock(return_value=True),
                    &quot;cmd.run_all&quot;: mock_cmd,
                },
            }
            with patch.multiple(aptpkg, **patch_kwargs):
                aptpkg.upgrade()
                args_matching = [
                    True
                    for args in patch_kwargs[&quot;__salt__&quot;][&quot;cmd.run_all&quot;].call_args[0]
                    if &quot;--download-only&quot; in args
                ]
                # Here we shouldn't see the parameter and args_matching should be empty.
                assert any(args_matching) is False

                aptpkg.upgrade(downloadonly=True)
                args_matching = [
                    True
                    for args in patch_kwargs[&quot;__salt__&quot;][&quot;cmd.run_all&quot;].call_args[0]
                    if &quot;--download-only&quot; in args
                ]
                # --download-only should be in the args list and we should have at least on True in the list.
                assert any(args_matching) is True

                aptpkg.upgrade(download_only=True)
                args_matching = [
                    True
                    for args in patch_kwargs[&quot;__salt__&quot;][&quot;cmd.run_all&quot;].call_args[0]
                    if &quot;--download-only&quot; in args
                ]
                # --download-only should be in the args list and we should have at least on True in the list.
                assert any(args_matching) is True


def test_upgrade_allow_downgrades(uninstall_var, upgrade_var):
    &quot;&quot;&quot;
    Tests the allow_downgrades option for upgrade.
    &quot;&quot;&quot;
    with patch(&quot;salt.utils.pkg.clear_rtag&quot;, MagicMock()):
        with patch(
            &quot;salt.modules.aptpkg.list_pkgs&quot;, MagicMock(return_value=uninstall_var)
        ):
            mock_cmd = MagicMock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: upgrade_var})
            patch_kwargs = {
                &quot;__salt__&quot;: {
                    &quot;config.get&quot;: MagicMock(return_value=True),
                    &quot;cmd.run_all&quot;: mock_cmd,
                },
            }
            with patch.multiple(aptpkg, **patch_kwargs):
                aptpkg.upgrade()
                args_matching = [
                    True
                    for args in patch_kwargs[&quot;__salt__&quot;][&quot;cmd.run_all&quot;].call_args[0]
                    if &quot;--allow-downgrades&quot; in args
                ]
                # Here we shouldn't see the parameter and args_matching should be empty.
                assert any(args_matching) is False

                aptpkg.upgrade(allow_downgrades=True)
                args_matching = [
                    True
                    for args in patch_kwargs[&quot;__salt__&quot;][&quot;cmd.run_all&quot;].call_args[0]
                    if &quot;--allow-downgrades&quot; in args
                ]
                # --allow-downgrades should be in the args list and we should have at least on True in the list.
                assert any(args_matching) is True


def test_show():
    &quot;&quot;&quot;
    Test that the pkg.show function properly parses apt-cache show output.
    This test uses an abridged output per package, for simplicity.
    &quot;&quot;&quot;
    show_mock_success = MagicMock(
        return_value={
            &quot;retcode&quot;: 0,
            &quot;pid&quot;: 12345,
            &quot;stderr&quot;: &quot;&quot;,
            &quot;stdout&quot;: textwrap.dedent(
                &quot;&quot;&quot;\
            Package: foo1.0
            Architecture: amd64
            Version: 1.0.5-3ubuntu4
            Description: A silly package (1.0 release cycle)
            Provides: foo
            Suggests: foo-doc

            Package: foo1.0
            Architecture: amd64
            Version: 1.0.4-2ubuntu1
            Description: A silly package (1.0 release cycle)
            Provides: foo
            Suggests: foo-doc

            Package: foo-doc
            Architecture: all
            Version: 1.0.5-3ubuntu4
            Description: Silly documentation for a silly package (1.0 release cycle)

            Package: foo-doc
            Architecture: all
            Version: 1.0.4-2ubuntu1
            Description: Silly documentation for a silly package (1.0 release cycle)

            &quot;&quot;&quot;
            ),
        }
    )

    show_mock_failure = MagicMock(
        return_value={
            &quot;retcode&quot;: 1,
            &quot;pid&quot;: 12345,
            &quot;stderr&quot;: textwrap.dedent(
                &quot;&quot;&quot;\
            N: Unable to locate package foo*
            N: Couldn't find any package by glob 'foo*'
            N: Couldn't find any package by regex 'foo*'
            E: No packages found
            &quot;&quot;&quot;
            ),
            &quot;stdout&quot;: &quot;&quot;,
        }
    )

    refresh_mock = Mock()

    expected = {
        &quot;foo1.0&quot;: {
            &quot;1.0.5-3ubuntu4&quot;: {
                &quot;Architecture&quot;: &quot;amd64&quot;,
                &quot;Description&quot;: &quot;A silly package (1.0 release cycle)&quot;,
                &quot;Provides&quot;: &quot;foo&quot;,
                &quot;Suggests&quot;: &quot;foo-doc&quot;,
            },
            &quot;1.0.4-2ubuntu1&quot;: {
                &quot;Architecture&quot;: &quot;amd64&quot;,
                &quot;Description&quot;: &quot;A silly package (1.0 release cycle)&quot;,
                &quot;Provides&quot;: &quot;foo&quot;,
                &quot;Suggests&quot;: &quot;foo-doc&quot;,
            },
        },
        &quot;foo-doc&quot;: {
            &quot;1.0.5-3ubuntu4&quot;: {
                &quot;Architecture&quot;: &quot;all&quot;,
                &quot;Description&quot;: (
                    &quot;Silly documentation for a silly package (1.0 release cycle)&quot;
                ),
            },
            &quot;1.0.4-2ubuntu1&quot;: {
                &quot;Architecture&quot;: &quot;all&quot;,
                &quot;Description&quot;: (
                    &quot;Silly documentation for a silly package (1.0 release cycle)&quot;
                ),
            },
        },
    }

    # Make a copy of the above dict and strip out some keys to produce the
    # expected filtered result.
    filtered = copy.deepcopy(expected)
    for k1 in filtered:
        for k2 in filtered[k1]:
            # Using list() because we will modify the dict during iteration
            for k3 in list(filtered[k1][k2]):
                if k3 not in (&quot;Description&quot;, &quot;Provides&quot;):
                    filtered[k1][k2].pop(k3)

    with patch.dict(aptpkg.__salt__, {&quot;cmd.run_all&quot;: show_mock_success}), patch.object(
        aptpkg, &quot;refresh_db&quot;, refresh_mock
    ):

        # Test success (no refresh)
        assert aptpkg.show(&quot;foo*&quot;) == expected
        refresh_mock.assert_not_called()
        refresh_mock.reset_mock()

        # Test success (with refresh)
        assert aptpkg.show(&quot;foo*&quot;, refresh=True) == expected
        refresh_mock.assert_called_once()
        refresh_mock.reset_mock()

        # Test filtered return
        assert aptpkg.show(&quot;foo*&quot;, filter=&quot;description,provides&quot;) == filtered
        refresh_mock.assert_not_called()
        refresh_mock.reset_mock()

    with patch.dict(aptpkg.__salt__, {&quot;cmd.run_all&quot;: show_mock_failure}), patch.object(
        aptpkg, &quot;refresh_db&quot;, refresh_mock
    ):

        # Test failure (no refresh)
        assert aptpkg.show(&quot;foo*&quot;) == {}
        refresh_mock.assert_not_called()
        refresh_mock.reset_mock()

        # Test failure (with refresh)
        assert aptpkg.show(&quot;foo*&quot;, refresh=True) == {}
        refresh_mock.assert_called_once()
        refresh_mock.reset_mock()


@pytest.mark.skipif(
    not (pathlib.Path(&quot;/etc&quot;) / &quot;apt&quot; / &quot;sources.list&quot;).is_file(),
    reason=&quot;Requires sources.list file&quot;,
)
def test_mod_repo_enabled():
    &quot;&quot;&quot;
    Checks if a repo is enabled or disabled depending on the passed kwargs.
    &quot;&quot;&quot;
    with patch.dict(
        aptpkg.__salt__,
        {&quot;config.option&quot;: MagicMock(), &quot;no_proxy&quot;: MagicMock(return_value=False)},
    ):
        with patch(&quot;salt.modules.aptpkg.refresh_db&quot;, MagicMock(return_value={})):
            with patch(
                &quot;salt.utils.data.is_true&quot;, MagicMock(return_value=True)
            ) as data_is_true:
                with patch(&quot;salt.modules.aptpkg.SourcesList&quot;, MagicMock(), create=True):
                    with patch(
                        &quot;salt.modules.aptpkg.SourceEntry&quot;, MagicMock(), create=True
                    ):
                        repo = aptpkg.mod_repo(&quot;foo&quot;, enabled=False)
                        data_is_true.assert_called_with(False)
                        # with disabled=True; should call salt.utils.data.is_true True
                        data_is_true.reset_mock()
                        repo = aptpkg.mod_repo(&quot;foo&quot;, disabled=True)
                        data_is_true.assert_called_with(True)
                        # with enabled=True; should call salt.utils.data.is_true with False
                        data_is_true.reset_mock()
                        repo = aptpkg.mod_repo(&quot;foo&quot;, enabled=True)
                        data_is_true.assert_called_with(True)
                        # with disabled=True; should call salt.utils.data.is_true False
                        data_is_true.reset_mock()
                        repo = aptpkg.mod_repo(&quot;foo&quot;, disabled=False)
                        data_is_true.assert_called_with(False)


def test_mod_repo_match():
    &quot;&quot;&quot;
    Checks if a repo is matched without taking into account any ending &quot;/&quot; in the uri.
    &quot;&quot;&quot;
    source_type = &quot;deb&quot;
    source_uri = &quot;http://cdn-aws.deb.debian.org/debian/&quot;
    source_line = &quot;deb http://cdn-aws.deb.debian.org/debian/ stretch main\n&quot;

    mock_source = MockSourceEntry(
        source_uri, source_type, source_line, False, &quot;stretch&quot;
    )
    mock_source_list = MockSourceList()
    mock_source_list.list = [mock_source]

    with patch.dict(
        aptpkg.__salt__,
        {&quot;config.option&quot;: MagicMock(), &quot;no_proxy&quot;: MagicMock(return_value=False)},
    ):
        with patch(&quot;salt.modules.aptpkg.refresh_db&quot;, MagicMock(return_value={})):
            with patch(&quot;salt.utils.data.is_true&quot;, MagicMock(return_value=True)):
                with patch(&quot;salt.modules.aptpkg.SourceEntry&quot;, MagicMock(), create=True):
                    with patch(
                        &quot;salt.modules.aptpkg.SourcesList&quot;,
                        MagicMock(return_value=mock_source_list),
                        create=True,
                    ):
                        with patch(
                            &quot;salt.modules.aptpkg._split_repo_str&quot;,
                            MagicMock(
                                return_value=(
                                    &quot;deb&quot;,
                                    [],
                                    &quot;http://cdn-aws.deb.debian.org/debian/&quot;,
                                    &quot;stretch&quot;,
                                    [&quot;main&quot;],
                                )
                            ),
                        ):
                            source_line_no_slash = (
                                &quot;deb http://cdn-aws.deb.debian.org/debian&quot;
                                &quot; stretch main&quot;
                            )
                            repo = aptpkg.mod_repo(source_line_no_slash, enabled=False)
                            assert repo[source_line_no_slash][&quot;uri&quot;] == source_uri


@patch(&quot;salt.utils.path.os_walk&quot;, MagicMock(return_value=[(&quot;test&quot;, &quot;test&quot;, &quot;test&quot;)]))
@patch(&quot;os.path.getsize&quot;, MagicMock(return_value=123456))
@patch(&quot;os.path.getctime&quot;, MagicMock(return_value=1234567890.123456))
@patch(
    &quot;fnmatch.filter&quot;,
    MagicMock(return_value=[&quot;/var/cache/apt/archive/test_package.rpm&quot;]),
)
def test_list_downloaded():
    &quot;&quot;&quot;
    Test downloaded packages listing.
    :return:
    &quot;&quot;&quot;
    DOWNLOADED_RET = {
        &quot;test-package&quot;: {
            &quot;1.0&quot;: {
                &quot;path&quot;: &quot;/var/cache/apt/archive/test_package.rpm&quot;,
                &quot;size&quot;: 123456,
                &quot;creation_date_time_t&quot;: 1234567890,
                &quot;creation_date_time&quot;: &quot;2009-02-13T23:31:30&quot;,
            }
        }
    }

    with patch.dict(
        aptpkg.__salt__,
        {
            &quot;lowpkg.bin_pkg_info&quot;: MagicMock(
                return_value={&quot;name&quot;: &quot;test-package&quot;, &quot;version&quot;: &quot;1.0&quot;}
            )
        },
    ):
        list_downloaded = aptpkg.list_downloaded()
        assert len(list_downloaded) == 1
        assert list_downloaded == DOWNLOADED_RET


def test__skip_source():
    &quot;&quot;&quot;
    Test __skip_source.
    :return:
    &quot;&quot;&quot;
    # Valid source
    source_type = &quot;deb&quot;
    source_uri = &quot;http://cdn-aws.deb.debian.org/debian&quot;
    source_line = &quot;deb http://cdn-aws.deb.debian.org/debian stretch main\n&quot;

    mock_source = MockSourceEntry(source_uri, source_type, source_line, False)

    ret = aptpkg._skip_source(mock_source)
    assert ret is False

    # Invalid source type
    source_type = &quot;ded&quot;
    source_uri = &quot;http://cdn-aws.deb.debian.org/debian&quot;
    source_line = &quot;deb http://cdn-aws.deb.debian.org/debian stretch main\n&quot;

    mock_source = MockSourceEntry(source_uri, source_type, source_line, True)

    ret = aptpkg._skip_source(mock_source)
    assert ret is True

    # Invalid source type , not skipped
    source_type = &quot;deb&quot;
    source_uri = &quot;http://cdn-aws.deb.debian.org/debian&quot;
    source_line = &quot;deb [http://cdn-aws.deb.debian.org/debian] stretch main\n&quot;

    mock_source = MockSourceEntry(source_uri, source_type, source_line, True)

    ret = aptpkg._skip_source(mock_source)
    assert ret is False


def test_normalize_name():
    &quot;&quot;&quot;
    Test that package is normalized only when it should be
    &quot;&quot;&quot;
    with patch.dict(aptpkg.__grains__, {&quot;osarch&quot;: &quot;amd64&quot;}):
        result = aptpkg.normalize_name(&quot;foo&quot;)
        assert result == &quot;foo&quot;, result
        result = aptpkg.normalize_name(&quot;foo:amd64&quot;)
        assert result == &quot;foo&quot;, result
        result = aptpkg.normalize_name(&quot;foo:any&quot;)
        assert result == &quot;foo&quot;, result
        result = aptpkg.normalize_name(&quot;foo:all&quot;)
        assert result == &quot;foo&quot;, result
        result = aptpkg.normalize_name(&quot;foo:i386&quot;)
        assert result == &quot;foo:i386&quot;, result


def test_list_repos():
    &quot;&quot;&quot;
    Checks results from list_repos
    &quot;&quot;&quot;
    # Valid source
    source_type = &quot;deb&quot;
    source_uri = &quot;http://cdn-aws.deb.debian.org/debian/&quot;
    source_line = &quot;deb http://cdn-aws.deb.debian.org/debian/ stretch main\n&quot;

    mock_source = MockSourceEntry(source_uri, source_type, source_line, False)
    mock_source_list = MockSourceList()
    mock_source_list.list = [mock_source]

    with patch(&quot;salt.modules.aptpkg.SourcesList&quot;, MagicMock(), create=True):
        with patch(&quot;salt.modules.aptpkg.SourceEntry&quot;, MagicMock(), create=True):
            with patch(
                &quot;salt.modules.aptpkg.SourcesList&quot;,
                MagicMock(return_value=mock_source_list),
                create=True,
            ):
                repos = aptpkg.list_repos()
                assert source_uri in repos

                assert isinstance(repos[source_uri], list)
                assert len(repos[source_uri]) == 1

                # Make sure last character in of the URI in line is still a /
                assert &quot;line&quot; in repos[source_uri][0]
                _uri = _get_uri(repos[source_uri][0][&quot;line&quot;])
                assert _uri[-1] == &quot;/&quot;

                # Make sure last character in URI is still a /
                assert &quot;uri&quot; in repos[source_uri][0]
                assert repos[source_uri][0][&quot;uri&quot;][-1] == &quot;/&quot;


@pytest.mark.skipif(
    HAS_APTSOURCES is False, reason=&quot;The 'aptsources' library is missing.&quot;
)
def test_expand_repo_def():
    &quot;&quot;&quot;
    Checks results from expand_repo_def
    &quot;&quot;&quot;
    source_type = &quot;deb&quot;
    source_uri = &quot;http://cdn-aws.deb.debian.org/debian/&quot;
    source_line = &quot;deb http://cdn-aws.deb.debian.org/debian/ stretch main\n&quot;
    source_file = &quot;/etc/apt/sources.list&quot;

    # Valid source
    repo = &quot;deb http://cdn-aws.deb.debian.org/debian/ stretch main\n&quot;
    sanitized = aptpkg.expand_repo_def(repo=repo, file=source_file)

    assert isinstance(sanitized, dict)
    assert &quot;uri&quot; in sanitized

    # Make sure last character in of the URI is still a /
    assert sanitized[&quot;uri&quot;][-1] == &quot;/&quot;

    # Pass the architecture and make sure it is added the the line attribute
    repo = &quot;deb http://cdn-aws.deb.debian.org/debian/ stretch main\n&quot;
    sanitized = aptpkg.expand_repo_def(
        repo=repo, file=source_file, architectures=&quot;amd64&quot;
    )

    # Make sure line is in the dict
    assert isinstance(sanitized, dict)
    assert &quot;line&quot; in sanitized

    # Make sure the architecture is in line
    assert (
        sanitized[&quot;line&quot;]
        == &quot;deb [arch=amd64] http://cdn-aws.deb.debian.org/debian/ stretch main&quot;
    )


def test_list_pkgs():
    &quot;&quot;&quot;
    Test packages listing.

    :return:
    &quot;&quot;&quot;

    def _add_data(data, key, value):
        data.setdefault(key, []).append(value)

    apt_out = [
        &quot;install ok installed accountsservice 0.6.55-0ubuntu12~20.04.1 amd64&quot;,
        &quot;install ok installed acpid 1:2.0.32-1ubuntu1 amd64&quot;,
        &quot;install ok installed adduser 3.118ubuntu2 all&quot;,
        &quot;install ok installed alsa-topology-conf 1.2.2-1 all&quot;,
        &quot;install ok installed alsa-ucm-conf 1.2.2-1ubuntu0.4 all&quot;,
        &quot;install ok installed apparmor 2.13.3-7ubuntu5.1 amd64&quot;,
        &quot;install ok installed apport 2.20.11-0ubuntu27.9 all&quot;,
        &quot;install ok installed apport-symptoms 0.23 all&quot;,
        &quot;install ok installed apt 2.0.2ubuntu0.1 amd64&quot;,
        &quot;install ok installed apt-utils 2.0.2ubuntu0.1 amd64&quot;,
        &quot;install ok installed at 3.1.23-1ubuntu1 amd64&quot;,
    ]
    with patch.dict(aptpkg.__grains__, {&quot;osarch&quot;: &quot;x86_64&quot;}), patch.dict(
        aptpkg.__salt__,
        {&quot;cmd.run_stdout&quot;: MagicMock(return_value=os.linesep.join(apt_out))},
    ), patch.dict(aptpkg.__salt__, {&quot;pkg_resource.add_pkg&quot;: _add_data}), patch.dict(
        aptpkg.__salt__,
        {&quot;pkg_resource.format_pkg_list&quot;: pkg_resource.format_pkg_list},
    ), patch.dict(
        aptpkg.__salt__, {&quot;pkg_resource.sort_pkglist&quot;: pkg_resource.sort_pkglist}
    ):
        pkgs = aptpkg.list_pkgs(versions_as_list=True)
        for pkg_name, pkg_version in {
            &quot;accountsservice&quot;: &quot;0.6.55-0ubuntu12~20.04.1&quot;,
            &quot;acpid&quot;: &quot;1:2.0.32-1ubuntu1&quot;,
            &quot;adduser&quot;: &quot;3.118ubuntu2&quot;,
            &quot;alsa-topology-conf&quot;: &quot;1.2.2-1&quot;,
            &quot;alsa-ucm-conf&quot;: &quot;1.2.2-1ubuntu0.4&quot;,
            &quot;apparmor&quot;: &quot;2.13.3-7ubuntu5.1&quot;,
            &quot;apport&quot;: &quot;2.20.11-0ubuntu27.9&quot;,
            &quot;apport-symptoms&quot;: &quot;0.23&quot;,
            &quot;apt&quot;: &quot;2.0.2ubuntu0.1&quot;,
            &quot;apt-utils&quot;: &quot;2.0.2ubuntu0.1&quot;,
            &quot;at&quot;: &quot;3.1.23-1ubuntu1&quot;,
        }.items():
            assert pkgs[pkg_name] == [pkg_version]


def test_list_pkgs_no_context():
    &quot;&quot;&quot;
    Test packages listing and ensure __context__ for pkg.list_pkgs is absent.

    :return:
    &quot;&quot;&quot;

    def _add_data(data, key, value):
        data.setdefault(key, []).append(value)

    apt_out = [
        &quot;install ok installed accountsservice 0.6.55-0ubuntu12~20.04.1 amd64&quot;,
        &quot;install ok installed acpid 1:2.0.32-1ubuntu1 amd64&quot;,
        &quot;install ok installed adduser 3.118ubuntu2 all&quot;,
        &quot;install ok installed alsa-topology-conf 1.2.2-1 all&quot;,
        &quot;install ok installed alsa-ucm-conf 1.2.2-1ubuntu0.4 all&quot;,
        &quot;install ok installed apparmor 2.13.3-7ubuntu5.1 amd64&quot;,
        &quot;install ok installed apport 2.20.11-0ubuntu27.9 all&quot;,
        &quot;install ok installed apport-symptoms 0.23 all&quot;,
        &quot;install ok installed apt 2.0.2ubuntu0.1 amd64&quot;,
        &quot;install ok installed apt-utils 2.0.2ubuntu0.1 amd64&quot;,
        &quot;install ok installed at 3.1.23-1ubuntu1 amd64&quot;,
    ]
    with patch.dict(aptpkg.__grains__, {&quot;osarch&quot;: &quot;x86_64&quot;}), patch.dict(
        aptpkg.__salt__,
        {&quot;cmd.run_stdout&quot;: MagicMock(return_value=os.linesep.join(apt_out))},
    ), patch.dict(aptpkg.__salt__, {&quot;pkg_resource.add_pkg&quot;: _add_data}), patch.dict(
        aptpkg.__salt__,
        {&quot;pkg_resource.format_pkg_list&quot;: pkg_resource.format_pkg_list},
    ), patch.dict(
        aptpkg.__salt__, {&quot;pkg_resource.sort_pkglist&quot;: pkg_resource.sort_pkglist}
    ), patch.object(
        aptpkg, &quot;_list_pkgs_from_context&quot;
    ) as list_pkgs_context_mock:
        pkgs = aptpkg.list_pkgs(versions_as_list=True, use_context=False)
        list_pkgs_context_mock.assert_not_called()
        list_pkgs_context_mock.reset_mock()

        pkgs = aptpkg.list_pkgs(versions_as_list=True, use_context=False)
        list_pkgs_context_mock.assert_not_called()
        list_pkgs_context_mock.reset_mock()


def test_call_apt_default():
    &quot;&quot;&quot;
    Call default apt.
    :return:
    &quot;&quot;&quot;
    with patch.dict(
        aptpkg.__salt__,
        {&quot;cmd.run_all&quot;: MagicMock(), &quot;config.get&quot;: MagicMock(return_value=False)},
    ):
        aptpkg._call_apt([&quot;apt-get&quot;, &quot;install&quot;, &quot;emacs&quot;])  # pylint: disable=W0106
        aptpkg.__salt__[&quot;cmd.run_all&quot;].assert_called_once_with(
            [&quot;apt-get&quot;, &quot;install&quot;, &quot;emacs&quot;],
            env={},
            output_loglevel=&quot;trace&quot;,
            python_shell=False,
        )


@patch(&quot;salt.utils.systemd.has_scope&quot;, MagicMock(return_value=True))
def test_call_apt_in_scope():
    &quot;&quot;&quot;
    Call apt within the scope.
    :return:
    &quot;&quot;&quot;
    with patch.dict(
        aptpkg.__salt__,
        {&quot;cmd.run_all&quot;: MagicMock(), &quot;config.get&quot;: MagicMock(return_value=True)},
    ):
        aptpkg._call_apt([&quot;apt-get&quot;, &quot;purge&quot;, &quot;vim&quot;])  # pylint: disable=W0106
        aptpkg.__salt__[&quot;cmd.run_all&quot;].assert_called_once_with(
            [
                &quot;systemd-run&quot;,
                &quot;--scope&quot;,
                &quot;--description&quot;,
                '&quot;salt.modules.aptpkg&quot;',
                &quot;apt-get&quot;,
                &quot;purge&quot;,
                &quot;vim&quot;,
            ],
            env={},
            output_loglevel=&quot;trace&quot;,
            python_shell=False,
        )


def test_call_apt_with_kwargs():
    &quot;&quot;&quot;
    Call apt with the optinal keyword arguments.
    :return:
    &quot;&quot;&quot;
    with patch.dict(
        aptpkg.__salt__,
        {&quot;cmd.run_all&quot;: MagicMock(), &quot;config.get&quot;: MagicMock(return_value=False)},
    ):
        aptpkg._call_apt(
            [&quot;dpkg&quot;, &quot;-l&quot;, &quot;python&quot;],
            python_shell=True,
            output_loglevel=&quot;quiet&quot;,
            ignore_retcode=False,
            username=&quot;Darth Vader&quot;,
        )  # pylint: disable=W0106
        aptpkg.__salt__[&quot;cmd.run_all&quot;].assert_called_once_with(
            [&quot;dpkg&quot;, &quot;-l&quot;, &quot;python&quot;],
            env={},
            ignore_retcode=False,
            output_loglevel=&quot;quiet&quot;,
            python_shell=True,
            username=&quot;Darth Vader&quot;,
        )


def test_call_apt_dpkg_lock():
    &quot;&quot;&quot;
    Call apt and ensure the dpkg locking is handled
    :return:
    &quot;&quot;&quot;
    cmd_side_effect = [
        {&quot;stderr&quot;: &quot;Could not get lock&quot;},
        {&quot;stderr&quot;: &quot;Could not get lock&quot;},
        {&quot;stderr&quot;: &quot;Could not get lock&quot;},
        {&quot;stderr&quot;: &quot;Could not get lock&quot;},
        {&quot;stderr&quot;: &quot;&quot;, &quot;stdout&quot;: &quot;&quot;},
    ]

    cmd_mock = MagicMock(side_effect=cmd_side_effect)
    cmd_call = (
        call(
            [&quot;dpkg&quot;, &quot;-l&quot;, &quot;python&quot;],
            env={},
            ignore_retcode=False,
            output_loglevel=&quot;quiet&quot;,
            python_shell=True,
            username=&quot;Darth Vader&quot;,
        ),
    )
    expected_calls = [cmd_call * 5]

    with patch.dict(
        aptpkg.__salt__,
        {&quot;cmd.run_all&quot;: cmd_mock, &quot;config.get&quot;: MagicMock(return_value=False)},
    ):
        with patch(&quot;salt.modules.aptpkg.time.sleep&quot;, MagicMock()) as sleep_mock:
            aptpkg._call_apt(
                [&quot;dpkg&quot;, &quot;-l&quot;, &quot;python&quot;],
                python_shell=True,
                output_loglevel=&quot;quiet&quot;,
                ignore_retcode=False,
                username=&quot;Darth Vader&quot;,
            )  # pylint: disable=W0106

            # We should have sleept at least 4 times
            assert sleep_mock.call_count &gt;= 4

            # We should attempt to call the cmd 5 times
            assert cmd_mock.call_count == 5
            cmd_mock.has_calls(expected_calls)


def test_services_need_restart_checkrestart_missing():
    &quot;&quot;&quot;Test that the user is informed about the required dependency.&quot;&quot;&quot;

    with patch(&quot;salt.utils.path.which_bin&quot;, Mock(return_value=None)):
        with pytest.raises(CommandNotFoundError):
            aptpkg.services_need_restart()


@patch(&quot;salt.utils.path.which_bin&quot;, Mock(return_value=&quot;/usr/sbin/checkrestart&quot;))
def test_services_need_restart():
    &quot;&quot;&quot;
    Test that checkrestart output is parsed correctly
    &quot;&quot;&quot;
    cr_output = &quot;&quot;&quot;
PROCESSES: 24
PROGRAMS: 17
PACKAGES: 8
SERVICE:rsyslog,385,/usr/sbin/rsyslogd
SERVICE:cups-daemon,390,/usr/sbin/cupsd
    &quot;&quot;&quot;

    with patch.dict(aptpkg.__salt__, {&quot;cmd.run_stdout&quot;: Mock(return_value=cr_output)}):
        assert sorted(aptpkg.services_need_restart()) == [
            &quot;cups-daemon&quot;,
            &quot;rsyslog&quot;,
        ]


@pytest.mark.skipif(
    HAS_APTSOURCES is True, reason=&quot;Only run test with python3-apt library is missing.&quot;
)
def test_sourceslist_multiple_comps():
    &quot;&quot;&quot;
    Test SourcesList when repo has multiple comps
    &quot;&quot;&quot;
    repo_line = &quot;deb http://archive.ubuntu.com/ubuntu/ focal-updates main restricted&quot;
    with patch.object(aptpkg, &quot;HAS_APT&quot;, return_value=True):
        with patch(&quot;salt.utils.files.fopen&quot;, mock_open(read_data=repo_line)):
            with patch(&quot;pathlib.Path.is_file&quot;, side_effect=[True, False]):
                sources = aptpkg.SourcesList()
                for source in sources:
                    assert source.type == &quot;deb&quot;
                    assert source.uri == &quot;http://archive.ubuntu.com/ubuntu/&quot;
                    assert source.comps == [&quot;main&quot;, &quot;restricted&quot;]
                    assert source.dist == &quot;focal-updates&quot;


@pytest.mark.skipif(
    HAS_APTSOURCES is True, reason=&quot;Only run test with python3-apt library is missing.&quot;
)
@pytest.mark.parametrize(
    &quot;repo_line&quot;,
    [
        &quot;deb [ arch=amd64 ] http://archive.ubuntu.com/ubuntu/ focal-updates main restricted&quot;,
        &quot;deb [arch=amd64 ] http://archive.ubuntu.com/ubuntu/ focal-updates main restricted&quot;,
        &quot;deb [arch=amd64 test=one ] http://archive.ubuntu.com/ubuntu/ focal-updates main restricted&quot;,
        &quot;deb [arch=amd64,armel test=one ] http://archive.ubuntu.com/ubuntu/ focal-updates main restricted&quot;,
        &quot;deb [ arch=amd64,armel test=one ] http://archive.ubuntu.com/ubuntu/ focal-updates main restricted&quot;,
        &quot;deb [ arch=amd64,armel test=one] http://archive.ubuntu.com/ubuntu/ focal-updates main restricted&quot;,
        &quot;deb [arch=amd64] http://archive.ubuntu.com/ubuntu/ focal-updates main restricted&quot;,
    ],
)
def test_sourceslist_architectures(repo_line):
    &quot;&quot;&quot;
    Test SourcesList when architectures is in repo
    &quot;&quot;&quot;
    with patch(&quot;salt.utils.files.fopen&quot;, mock_open(read_data=repo_line)):
        with patch(&quot;pathlib.Path.is_file&quot;, side_effect=[True, False]):
            sources = aptpkg.SourcesList()
            for source in sources:
                assert source.type == &quot;deb&quot;
                assert source.uri == &quot;http://archive.ubuntu.com/ubuntu/&quot;
                assert source.comps == [&quot;main&quot;, &quot;restricted&quot;]
                assert source.dist == &quot;focal-updates&quot;
                if &quot;,&quot; in repo_line:
                    assert source.architectures == [&quot;amd64&quot;, &quot;armel&quot;]
                else:
                    assert source.architectures == [&quot;amd64&quot;]
</PRE>
</div>
  </div>
</body>
</html>
