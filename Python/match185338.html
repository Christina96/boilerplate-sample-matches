<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_selinux_2.py &amp; test_aptpkg_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_selinux_2.py &amp; test_aptpkg_1.py
      </h3>
<h1 align="center">
        1.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_selinux_2.py (7.7777777%)<th>test_aptpkg_1.py (1.0424423%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(97-103)<td><a href="#" name="0">(267-271)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_selinux_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import pytest
2 import salt.states.selinux as selinux
3 from tests.support.mock import MagicMock, patch
4 @pytest.fixture
5 def configure_loader_modules():
6     return {selinux: {}}
7 def test_mode():
8     ret = {
9         "name": "unknown",
10         "changes": {},
11         "result": False,
12         "comment": "unknown is not an accepted mode",
13     }
14     assert selinux.mode("unknown") == ret
15     mock_en = MagicMock(return_value="Enforcing")
16     mock_pr = MagicMock(side_effect=["Permissive", "Enforcing"])
17     with patch.dict(
18         selinux.__salt__,
19         {
20             "selinux.getenforce": mock_en,
21             "selinux.getconfig": mock_en,
22             "selinux.setenforce": mock_pr,
23         },
24     ):
25         comt = "SELinux is already in Enforcing mode"
26         ret = {"name": "Enforcing", "comment": comt, "result": True, "changes": {}}
27         assert selinux.mode("Enforcing") == ret
28         with patch.dict(selinux.__opts__, {"test": True}):
29             comt = "SELinux mode is set to be changed to Permissive"
30             ret = {
31                 "name": "Permissive",
32                 "comment": comt,
33                 "result": None,
34                 "changes": {"new": "Permissive", "old": "Enforcing"},
35             }
36             assert selinux.mode("Permissive") == ret
37         with patch.dict(selinux.__opts__, {"test": False}):
38             comt = "SELinux has been set to Permissive mode"
39             ret = {
40                 "name": "Permissive",
41                 "comment": comt,
42                 "result": True,
43                 "changes": {"new": "Permissive", "old": "Enforcing"},
44             }
45             assert selinux.mode("Permissive") == ret
46             comt = "Failed to set SELinux to Permissive mode"
47             ret.update(
48                 {"name": "Permissive", "comment": comt, "result": False, "changes": {}}
49             )
50             assert selinux.mode("Permissive") == ret
51 def test_boolean():
52     name = "samba_create_home_dirs"
53     value = True
54     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
55     mock_en = MagicMock(return_value=[])
56     with patch.dict(selinux.__salt__, {"selinux.list_sebool": mock_en}):
57         comt = "Boolean {} is not available".format(name)
58         ret.update({"comment": comt})
59         assert selinux.boolean(name, value) == ret
60     mock_bools = MagicMock(return_value={name: {"State": "on", "Default": "on"}})
61     with patch.dict(selinux.__salt__, {"selinux.list_sebool": mock_bools}):
62         comt = "None is not a valid value for the boolean"
63         ret.update({"comment": comt})
64         assert selinux.boolean(name, None) == ret
65         comt = "Boolean is in the correct state"
66         ret.update({"comment": comt, "result": True})
67         assert selinux.boolean(name, value, True) == ret
68         comt = "Boolean is in the correct state"
69         assert selinux.boolean(name, value) == ret
70     mock_bools = MagicMock(return_value={name: {<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"State": "off", "Default": "on"}})
71     mock = MagicMock(side_effect=[True, False])
72     with patch.dict(
73         selinux.__salt__,
74         {"selinux.list_sebool": mock_bools, "selinux.setsebool": mock},
75     ):
76         with patch.dict(selinux.</b></font>__opts__, {"test": True}):
77             comt = "Boolean samba_create_home_dirs is set to be changed to on"
78             ret.update({"comment": comt, "result": None})
79             assert selinux.boolean(name, value) == ret
80         with patch.dict(selinux.__opts__, {"test": False}):
81             comt = "Boolean samba_create_home_dirs has been set to on"
82             ret.update({"comment": comt, "result": True})
83             ret.update({"changes": {"State": {"old": "off", "new": "on"}}})
84             assert selinux.boolean(name, value) == ret
85             comt = "Failed to set the boolean samba_create_home_dirs to on"
86             ret.update({"comment": comt, "result": False})
87             ret.update({"changes": {}})
88             assert selinux.boolean(name, value) == ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_aptpkg_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import logging
3 import os
4 import pathlib
5 import textwrap
6 import pytest
7 import salt.modules.aptpkg as aptpkg
8 import salt.modules.pkg_resource as pkg_resource
9 from salt.exceptions import (
10     CommandExecutionError,
11     CommandNotFoundError,
12     SaltInvocationError,
13 )
14 from tests.support.mock import MagicMock, Mock, call, mock_open, patch
15 try:
16     from aptsources import sourceslist  # pylint: disable=unused-import
17     HAS_APTSOURCES = True
18 except ImportError:
19     HAS_APTSOURCES = False
20 log = logging.getLogger(__name__)
21 @pytest.fixture(scope="module")
22 def repo_keys_var():
23     return {
24         "46181433FBB75451": {
25             "algorithm": 17,
26             "bits": 1024,
27             "capability": "scSC",
28             "date_creation": 1104433784,
29             "date_expiration": None,
30             "fingerprint": "C5986B4F1257FFA86632CBA746181433FBB75451",
31             "keyid": "46181433FBB75451",
32             "uid": "Ubuntu CD Image Automatic Signing Key &lt;cdimage@ubuntu.com&gt;",
33             "uid_hash": "B4D41942D4B35FF44182C7F9D00C99AF27B93AD0",
34             "validity": "-",
35         }
36     }
37 @pytest.fixture(scope="module")
38 def packages_var():
39     return {"wget": "1.15-1ubuntu1.14.04.2"}
40 @pytest.fixture(scope="module")
41 def lowpkg_files_var():
42     return {
43         "errors": {},
44         "packages": {
45             "wget": [
46                 "/.",
47                 "/etc",
48                 "/etc/wgetrc",
49                 "/usr",
50                 "/usr/bin",
51                 "/usr/bin/wget",
52                 "/usr/share",
53                 "/usr/share/info",
54                 "/usr/share/info/wget.info.gz",
55                 "/usr/share/doc",
56                 "/usr/share/doc/wget",
57                 "/usr/share/doc/wget/MAILING-LIST",
58                 "/usr/share/doc/wget/NEWS.gz",
59                 "/usr/share/doc/wget/AUTHORS",
60                 "/usr/share/doc/wget/copyright",
61                 "/usr/share/doc/wget/changelog.Debian.gz",
62                 "/usr/share/doc/wget/README",
63                 "/usr/share/man",
64                 "/usr/share/man/man1",
65                 "/usr/share/man/man1/wget.1.gz",
66             ]
67         },
68     }
69 @pytest.fixture(scope="module")
70 def lowpkg_info_var():
71     return {
72         "wget": {
73             "architecture": "amd64",
74             "description": "retrieves files from the web",
75             "homepage": "http://www.gnu.org/software/wget/",
76             "install_date": "2016-08-30T22:20:15Z",
77             "maintainer": "Ubuntu Developers &lt;ubuntu-devel-discuss@lists.ubuntu.com&gt;",
78             "name": "wget",
79             "section": "web",
80             "source": "wget",
81             "version": "1.15-1ubuntu1.14.04.2",
82             "status": "ii",
83         },
84         "apache2": {
85             "architecture": "amd64",
86             "description": """Apache HTTP Server
87      The Apache HTTP Server Project's goal is to build a secure, efficient and
88      extensible HTTP server as standards-compliant open source software. The
89      result has long been the number one web server on the Internet.
90      .
91      Installing this package results in a full installation, including the
92      configuration files, init scripts and support scripts.""",
93             "homepage": "http://httpd.apache.org/",
94             "install_date": "2016-08-30T22:20:15Z",
95             "maintainer": "Ubuntu Developers &lt;ubuntu-devel-discuss@lists.ubuntu.com&gt;",
96             "name": "apache2",
97             "section": "httpd",
98             "source": "apache2",
99             "version": "2.4.18-2ubuntu3.9",
100             "status": "rc",
101         },
102     }
103 @pytest.fixture(scope="module")
104 def apt_q_update_var():
105     return """
106     Get:1 http://security.ubuntu.com trusty-security InRelease [65 kB]
107     Get:2 http://security.ubuntu.com trusty-security/main Sources [120 kB]
108     Get:3 http://security.ubuntu.com trusty-security/main amd64 Packages [548 kB]
109     Get:4 http://security.ubuntu.com trusty-security/main i386 Packages [507 kB]
110     Hit http://security.ubuntu.com trusty-security/main Translation-en
111     Fetched 1240 kB in 10s (124 kB/s)
112     Reading package lists...
113 @pytest.fixture(scope="module")
114 def autoremove_var():
115     return """
116     Reading package lists... Done
117     Building dependency tree
118     Reading state information... Done
119     0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
120 @pytest.fixture(scope="module")
121 def uninstall_var():
122     return {"tmux": {"new": "", "old": "1.8-5"}}
123 @pytest.fixture(scope="module")
124 def install_var():
125     return {"tmux": {"new": "1.8-5", "old": ""}}
126 def _get_uri(repo):
127     splits = repo.split()
128     for val in splits:
129         if any(val.startswith(x) for x in ("http://", "https://", "ftp://")):
130             return val
131 class MockSourceEntry:
132     def __init__(self, uri, source_type, line, invalid, dist="", file=None):
133         self.uri = uri
134         self.type = source_type
135         self.line = line
136         self.invalid = invalid
137         self.file = file
138         self.disabled = False
139         self.dist = dist
140         self.comps = []
141         self.architectures = []
142     def mysplit(self, line):
143         return line.split()
144 class MockSourceList:
145     def __init__(self):
146         self.list = []
147     def __iter__(self):
148         yield from self.list
149     def save(self):
150         pass
151 @pytest.fixture
152 def configure_loader_modules():
153     return {aptpkg: {"__grains__": {}}}
154 def test_version(lowpkg_info_var):
155     version = lowpkg_info_var["wget"]["version"]
156     mock = MagicMock(return_value=version)
157     with patch.dict(aptpkg.__salt__, {"pkg_resource.version": mock}):
158         assert aptpkg.version(*["wget"]) == version
159 def test_upgrade_available():
160     with patch("salt.modules.aptpkg.latest_version", MagicMock(return_value="")):
161         assert aptpkg.upgrade_available("wget") is False
162 def test_add_repo_key(repo_keys_var):
163     with patch(
164         "salt.modules.aptpkg.get_repo_keys", MagicMock(return_value=repo_keys_var)
165     ):
166         mock = MagicMock(return_value={"retcode": 0, "stdout": "OK"})
167         with patch.dict(aptpkg.__salt__, {"cmd.run_all": mock}):
168             assert (
169                 aptpkg.add_repo_key(keyserver="keyserver.ubuntu.com", keyid="FBB75451")
170                 is True
171             )
172 def test_add_repo_key_failed(repo_keys_var):
173         "salt.modules.aptpkg.get_repo_keys", MagicMock(return_value=repo_keys_var)
174     ):
175         kwargs = {<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"keyserver": "keyserver.ubuntu.com"}
176         mock = MagicMock(return_value={"retcode": 0, "stdout": "OK"})
177         with patch.dict(aptpkg.__salt__, {"cmd.run_all": mock}):
178             with pytest.raises(SaltInvocationError):
179                 aptpkg.</b></font>add_repo_key(**kwargs)
180 def test_get_repo_keys(repo_keys_var):
181     APT_KEY_LIST = r"""
182     pub:-:1024:17:46181433FBB75451:1104433784:::-:::scSC:
183     fpr:::::::::C5986B4F1257FFA86632CBA746181433FBB75451:
184     uid:-::::1104433784::B4D41942D4B35FF44182C7F9D00C99AF27B93AD0::Ubuntu CD Image Automatic Signing Key &lt;cdimage@ubuntu.com&gt;:
185     """
186     mock = MagicMock(return_value={"retcode": 0, "stdout": APT_KEY_LIST})
187     with patch.dict(aptpkg.__salt__, {"cmd.run_all": mock}):
188         assert aptpkg.get_repo_keys() == repo_keys_var
189 def test_file_dict(lowpkg_files_var):
190     mock = MagicMock(return_value=lowpkg_files_var)
191     with patch.dict(aptpkg.__salt__, {"lowpkg.file_dict": mock}):
192         assert aptpkg.file_dict("wget") == lowpkg_files_var
193 def test_file_list(lowpkg_files_var):
194     files = {
195         "errors": lowpkg_files_var["errors"],
196         "files": lowpkg_files_var["packages"]["wget"],
197     }
198     mock = MagicMock(return_value=files)
199     with patch.dict(aptpkg.__salt__, {"lowpkg.file_list": mock}):
200         assert aptpkg.file_list("wget") == files
201 def test_get_selections():
202     selections = {"install": ["wget"]}
203     mock = MagicMock(return_value="wget\t\t\t\t\t\tinstall")
204     with patch.dict(aptpkg.__salt__, {"cmd.run_stdout": mock}):
205         assert aptpkg.get_selections("wget") == selections
206 def test_info_installed(lowpkg_info_var):
207     names = {"group": "section", "packager": "maintainer", "url": "homepage"}
208     installed = copy.deepcopy({"wget": lowpkg_info_var["wget"]})
209     for name in names:
210         if installed["wget"].get(names[name], False):
211             installed["wget"][name] = installed["wget"].pop(names[name])
212     mock = MagicMock(return_value=lowpkg_info_var)
213     with patch.dict(aptpkg.__salt__, {"lowpkg.info": mock}):
214         del installed["wget"]["status"]
215         assert aptpkg.info_installed("wget") == installed
216         assert len(aptpkg.info_installed()) == 1
217 def test_owner():
218     paths = ["/usr/bin/wget"]
219     mock = MagicMock(return_value="wget: /usr/bin/wget")
220     with patch.dict(aptpkg.__salt__, {"cmd.run_stdout": mock}):
221         assert aptpkg.owner(*paths) == "wget"
222 def test_refresh_db(apt_q_update_var):
223     refresh_db = {
224         "http://security.ubuntu.com trusty-security InRelease": True,
225         "http://security.ubuntu.com trusty-security/main Sources": True,
226         "http://security.ubuntu.com trusty-security/main Translation-en": None,
227         "http://security.ubuntu.com trusty-security/main amd64 Packages": True,
228         "http://security.ubuntu.com trusty-security/main i386 Packages": True,
229     }
230     mock = MagicMock(return_value={"retcode": 0, "stdout": apt_q_update_var})
231     with patch("salt.utils.pkg.clear_rtag", MagicMock()):
232         with patch.dict(
233             aptpkg.__salt__,
234             {"cmd.run_all": mock, "config.get": MagicMock(return_value=False)},
235         ):
236             assert aptpkg.refresh_db() == refresh_db
237 def test_refresh_db_failed(apt_q_update_error_var):
238     kwargs = {"failhard": True}
239     mock = MagicMock(return_value={"retcode": 0, "stdout": apt_q_update_error_var})
240     with patch("salt.utils.pkg.clear_rtag", MagicMock()):
241         with patch.dict(
242             aptpkg.__salt__,
243             {"cmd.run_all": mock, "config.get": MagicMock(return_value=False)},
244         ):
245             with pytest.raises(CommandExecutionError):
246                 aptpkg.refresh_db(**kwargs)
247 def test_autoremove(packages_var, autoremove_var):
248     with patch("salt.modules.aptpkg.list_pkgs", MagicMock(return_value=packages_var)):
249         patch_kwargs = {
250             "__salt__": {
251                 "config.get": MagicMock(return_value=True),
252                 "cmd.run_all": MagicMock(
253                     return_value=MagicMock(return_value=autoremove_var)
254                 ),
255             }
256         }
257         with patch.multiple(aptpkg, **patch_kwargs):
258             assert aptpkg.autoremove() == {}
259             assert aptpkg.autoremove(purge=True) == {}
260             assert aptpkg.autoremove(list_only=True) == []
261             assert aptpkg.autoremove(list_only=True, purge=True) == []
262 def test_install(install_var):
263     with patch("salt.modules.aptpkg.install", MagicMock(return_value=install_var)):
264         assert aptpkg.install(name="tmux") == install_var
265         kwargs = {"force_conf_new": True}
266         assert aptpkg.install(name="tmux", **kwargs) == install_var
267 def test_remove(uninstall_var):
268     with patch("salt.modules.aptpkg._uninstall", MagicMock(return_value=uninstall_var)):
269         assert aptpkg.remove(name="tmux") == uninstall_var
270 def test_purge(uninstall_var):
271     with patch("salt.modules.aptpkg._uninstall", MagicMock(return_value=uninstall_var)):
272         assert aptpkg.purge(name="tmux") == uninstall_var
273 def test_upgrade(uninstall_var, upgrade_var):
274     with patch("salt.utils.pkg.clear_rtag", MagicMock()):
275         with patch(
276             "salt.modules.aptpkg.list_pkgs", MagicMock(return_value=uninstall_var)
277         ):
278             mock_cmd = MagicMock(return_value={"retcode": 0, "stdout": upgrade_var})
279             patch_kwargs = {
280                 "__salt__": {
281                     "config.get": MagicMock(return_value=True),
282                     "cmd.run_all": mock_cmd,
283                 }
284             }
285             with patch.multiple(aptpkg, **patch_kwargs):
286                 assert aptpkg.upgrade() == dict()
287                 kwargs = {"force_conf_new": True}
288                 assert aptpkg.upgrade(**kwargs) == dict()
289 def test_upgrade_downloadonly(uninstall_var, upgrade_var):
290     with patch("salt.utils.pkg.clear_rtag", MagicMock()):
291         with patch(
292             "salt.modules.aptpkg.list_pkgs", MagicMock(return_value=uninstall_var)
293         ):
294             mock_cmd = MagicMock(return_value={"retcode": 0, "stdout": upgrade_var})
295             patch_kwargs = {
296                 "__salt__": {
297                     "config.get": MagicMock(return_value=True),
298                     "cmd.run_all": mock_cmd,
299                 },
300             }
301             with patch.multiple(aptpkg, **patch_kwargs):
302                 aptpkg.upgrade()
303                 args_matching = [
304                     True
305                     for args in patch_kwargs["__salt__"]["cmd.run_all"].call_args[0]
306                     if "--download-only" in args
307                 ]
308                 assert any(args_matching) is False
309                 aptpkg.upgrade(downloadonly=True)
310                 args_matching = [
311                     True
312                     for args in patch_kwargs["__salt__"]["cmd.run_all"].call_args[0]
313                     if "--download-only" in args
314                 ]
315                 assert any(args_matching) is True
316                 aptpkg.upgrade(download_only=True)
317                 args_matching = [
318                     True
319                     for args in patch_kwargs["__salt__"]["cmd.run_all"].call_args[0]
320                     if "--download-only" in args
321                 ]
322                 assert any(args_matching) is True
323 def test_upgrade_allow_downgrades(uninstall_var, upgrade_var):
324     with patch("salt.utils.pkg.clear_rtag", MagicMock()):
325         with patch(
326             "salt.modules.aptpkg.list_pkgs", MagicMock(return_value=uninstall_var)
327         ):
328             mock_cmd = MagicMock(return_value={"retcode": 0, "stdout": upgrade_var})
329             patch_kwargs = {
330                 "__salt__": {
331                     "config.get": MagicMock(return_value=True),
332                     "cmd.run_all": mock_cmd,
333                 },
334             }
335             with patch.multiple(aptpkg, **patch_kwargs):
336                 aptpkg.upgrade()
337                 args_matching = [
338                     True
339                     for args in patch_kwargs["__salt__"]["cmd.run_all"].call_args[0]
340                     if "--allow-downgrades" in args
341                 ]
342                 assert any(args_matching) is False
343                 aptpkg.upgrade(allow_downgrades=True)
344                 args_matching = [
345                     True
346                     for args in patch_kwargs["__salt__"]["cmd.run_all"].call_args[0]
347                     if "--allow-downgrades" in args
348                 ]
349                 assert any(args_matching) is True
350 def test_show():
351     show_mock_success = MagicMock(
352         return_value={
353             "retcode": 0,
354             "pid": 12345,
355             "stderr": "",
356             "stdout": textwrap.dedent(
357             ),
358         }
359     )
360     show_mock_failure = MagicMock(
361         return_value={
362             "retcode": 1,
363             "pid": 12345,
364             "stderr": textwrap.dedent(
365             ),
366             "stdout": "",
367         }
368     )
369     refresh_mock = Mock()
370     expected = {
371         "foo1.0": {
372             "1.0.5-3ubuntu4": {
373                 "Architecture": "amd64",
374                 "Description": "A silly package (1.0 release cycle)",
375                 "Provides": "foo",
376                 "Suggests": "foo-doc",
377             },
378             "1.0.4-2ubuntu1": {
379                 "Architecture": "amd64",
380                 "Description": "A silly package (1.0 release cycle)",
381                 "Provides": "foo",
382                 "Suggests": "foo-doc",
383             },
384         },
385         "foo-doc": {
386             "1.0.5-3ubuntu4": {
387                 "Architecture": "all",
388                 "Description": (
389                     "Silly documentation for a silly package (1.0 release cycle)"
390                 ),
391             },
392             "1.0.4-2ubuntu1": {
393                 "Architecture": "all",
394                 "Description": (
395                     "Silly documentation for a silly package (1.0 release cycle)"
396                 ),
397             },
398         },
399     }
400     filtered = copy.deepcopy(expected)
401     for k1 in filtered:
402         for k2 in filtered[k1]:
403             for k3 in list(filtered[k1][k2]):
404                 if k3 not in ("Description", "Provides"):
405                     filtered[k1][k2].pop(k3)
406     with patch.dict(aptpkg.__salt__, {"cmd.run_all": show_mock_success}), patch.object(
407         aptpkg, "refresh_db", refresh_mock
408     ):
409         assert aptpkg.show("foo*") == expected
410         refresh_mock.assert_not_called()
411         refresh_mock.reset_mock()
412         assert aptpkg.show("foo*", refresh=True) == expected
413         refresh_mock.assert_called_once()
414         refresh_mock.reset_mock()
415         assert aptpkg.show("foo*", filter="description,provides") == filtered
416         refresh_mock.assert_not_called()
417         refresh_mock.reset_mock()
418     with patch.dict(aptpkg.__salt__, {"cmd.run_all": show_mock_failure}), patch.object(
419         aptpkg, "refresh_db", refresh_mock
420     ):
421         assert aptpkg.show("foo*") == {}
422         refresh_mock.assert_not_called()
423         refresh_mock.reset_mock()
424         assert aptpkg.show("foo*", refresh=True) == {}
425         refresh_mock.assert_called_once()
426         refresh_mock.reset_mock()
427 @pytest.mark.skipif(
428     not (pathlib.Path("/etc") / "apt" / "sources.list").is_file(),
429     reason="Requires sources.list file",
430 )
431 def test_mod_repo_enabled():
432     with patch.dict(
433         aptpkg.__salt__,
434         {"config.option": MagicMock(), "no_proxy": MagicMock(return_value=False)},
435     ):
436         with patch("salt.modules.aptpkg.refresh_db", MagicMock(return_value={})):
437             with patch(
438                 "salt.utils.data.is_true", MagicMock(return_value=True)
439             ) as data_is_true:
440                 with patch("salt.modules.aptpkg.SourcesList", MagicMock(), create=True):
441                     with patch(
442                         "salt.modules.aptpkg.SourceEntry", MagicMock(), create=True
443                     ):
444                         repo = aptpkg.mod_repo("foo", enabled=False)
445                         data_is_true.assert_called_with(False)
446                         data_is_true.reset_mock()
447                         repo = aptpkg.mod_repo("foo", disabled=True)
448                         data_is_true.assert_called_with(True)
449                         data_is_true.reset_mock()
450                         repo = aptpkg.mod_repo("foo", enabled=True)
451                         data_is_true.assert_called_with(True)
452                         data_is_true.reset_mock()
453                         repo = aptpkg.mod_repo("foo", disabled=False)
454                         data_is_true.assert_called_with(False)
455 def test_mod_repo_match():
456     source_type = "deb"
457     source_uri = "http://cdn-aws.deb.debian.org/debian/"
458     source_line = "deb http://cdn-aws.deb.debian.org/debian/ stretch main\n"
459     mock_source = MockSourceEntry(
460         source_uri, source_type, source_line, False, "stretch"
461     )
462     mock_source_list = MockSourceList()
463     mock_source_list.list = [mock_source]
464     with patch.dict(
465         aptpkg.__salt__,
466         {"config.option": MagicMock(), "no_proxy": MagicMock(return_value=False)},
467     ):
468         with patch("salt.modules.aptpkg.refresh_db", MagicMock(return_value={})):
469             with patch("salt.utils.data.is_true", MagicMock(return_value=True)):
470                 with patch("salt.modules.aptpkg.SourceEntry", MagicMock(), create=True):
471                     with patch(
472                         "salt.modules.aptpkg.SourcesList",
473                         MagicMock(return_value=mock_source_list),
474                         create=True,
475                     ):
476                         with patch(
477                             "salt.modules.aptpkg._split_repo_str",
478                             MagicMock(
479                                 return_value=(
480                                     "deb",
481                                     [],
482                                     "http://cdn-aws.deb.debian.org/debian/",
483                                     "stretch",
484                                     ["main"],
485                                 )
486                             ),
487                         ):
488                             source_line_no_slash = (
489                                 "deb http://cdn-aws.deb.debian.org/debian"
490                                 " stretch main"
491                             )
492                             repo = aptpkg.mod_repo(source_line_no_slash, enabled=False)
493                             assert repo[source_line_no_slash]["uri"] == source_uri
494 @patch("salt.utils.path.os_walk", MagicMock(return_value=[("test", "test", "test")]))
495 @patch("os.path.getsize", MagicMock(return_value=123456))
496 @patch("os.path.getctime", MagicMock(return_value=1234567890.123456))
497 @patch(
498     "fnmatch.filter",
499     MagicMock(return_value=["/var/cache/apt/archive/test_package.rpm"]),
500 )
501 def test_list_downloaded():
502     DOWNLOADED_RET = {
503         "test-package": {
504             "1.0": {
505                 "path": "/var/cache/apt/archive/test_package.rpm",
506                 "size": 123456,
507                 "creation_date_time_t": 1234567890,
508                 "creation_date_time": "2009-02-13T23:31:30",
509             }
510         }
511     }
512     with patch.dict(
513         aptpkg.__salt__,
514         {
515             "lowpkg.bin_pkg_info": MagicMock(
516                 return_value={"name": "test-package", "version": "1.0"}
517             )
518         },
519     ):
520         list_downloaded = aptpkg.list_downloaded()
521         assert len(list_downloaded) == 1
522         assert list_downloaded == DOWNLOADED_RET
523 def test__skip_source():
524     source_type = "deb"
525     source_uri = "http://cdn-aws.deb.debian.org/debian"
526     source_line = "deb http://cdn-aws.deb.debian.org/debian stretch main\n"
527     mock_source = MockSourceEntry(source_uri, source_type, source_line, False)
528     ret = aptpkg._skip_source(mock_source)
529     assert ret is False
530     source_type = "ded"
531     source_uri = "http://cdn-aws.deb.debian.org/debian"
532     source_line = "deb http://cdn-aws.deb.debian.org/debian stretch main\n"
533     mock_source = MockSourceEntry(source_uri, source_type, source_line, True)
534     ret = aptpkg._skip_source(mock_source)
535     assert ret is True
536     source_type = "deb"
537     source_uri = "http://cdn-aws.deb.debian.org/debian"
538     source_line = "deb [http://cdn-aws.deb.debian.org/debian] stretch main\n"
539     mock_source = MockSourceEntry(source_uri, source_type, source_line, True)
540     ret = aptpkg._skip_source(mock_source)
541     assert ret is False
542 def test_normalize_name():
543     with patch.dict(aptpkg.__grains__, {"osarch": "amd64"}):
544         result = aptpkg.normalize_name("foo")
545         assert result == "foo", result
546         result = aptpkg.normalize_name("foo:amd64")
547         assert result == "foo", result
548         result = aptpkg.normalize_name("foo:any")
549         assert result == "foo", result
550         result = aptpkg.normalize_name("foo:all")
551         assert result == "foo", result
552         result = aptpkg.normalize_name("foo:i386")
553         assert result == "foo:i386", result
554 def test_list_repos():
555     source_type = "deb"
556     source_uri = "http://cdn-aws.deb.debian.org/debian/"
557     source_line = "deb http://cdn-aws.deb.debian.org/debian/ stretch main\n"
558     mock_source = MockSourceEntry(source_uri, source_type, source_line, False)
559     mock_source_list = MockSourceList()
560     mock_source_list.list = [mock_source]
561     with patch("salt.modules.aptpkg.SourcesList", MagicMock(), create=True):
562         with patch("salt.modules.aptpkg.SourceEntry", MagicMock(), create=True):
563             with patch(
564                 "salt.modules.aptpkg.SourcesList",
565                 MagicMock(return_value=mock_source_list),
566                 create=True,
567             ):
568                 repos = aptpkg.list_repos()
569                 assert source_uri in repos
570                 assert isinstance(repos[source_uri], list)
571                 assert len(repos[source_uri]) == 1
572                 assert "line" in repos[source_uri][0]
573                 _uri = _get_uri(repos[source_uri][0]["line"])
574                 assert _uri[-1] == "/"
575                 assert "uri" in repos[source_uri][0]
576                 assert repos[source_uri][0]["uri"][-1] == "/"
577 @pytest.mark.skipif(
578     HAS_APTSOURCES is False, reason="The 'aptsources' library is missing."
579 )
580 def test_expand_repo_def():
581     source_type = "deb"
582     source_uri = "http://cdn-aws.deb.debian.org/debian/"
583     source_line = "deb http://cdn-aws.deb.debian.org/debian/ stretch main\n"
584     source_file = "/etc/apt/sources.list"
585     repo = "deb http://cdn-aws.deb.debian.org/debian/ stretch main\n"
586     sanitized = aptpkg.expand_repo_def(repo=repo, file=source_file)
587     assert isinstance(sanitized, dict)
588     assert "uri" in sanitized
589     assert sanitized["uri"][-1] == "/"
590     repo = "deb http://cdn-aws.deb.debian.org/debian/ stretch main\n"
591     sanitized = aptpkg.expand_repo_def(
592         repo=repo, file=source_file, architectures="amd64"
593     )
594     assert isinstance(sanitized, dict)
595     assert "line" in sanitized
596     assert (
597         sanitized["line"]
598         == "deb [arch=amd64] http://cdn-aws.deb.debian.org/debian/ stretch main"
599     )
600 def test_list_pkgs():
601     def _add_data(data, key, value):
602         data.setdefault(key, []).append(value)
603     apt_out = [
604         "install ok installed accountsservice 0.6.55-0ubuntu12~20.04.1 amd64",
605         "install ok installed acpid 1:2.0.32-1ubuntu1 amd64",
606         "install ok installed adduser 3.118ubuntu2 all",
607         "install ok installed alsa-topology-conf 1.2.2-1 all",
608         "install ok installed alsa-ucm-conf 1.2.2-1ubuntu0.4 all",
609         "install ok installed apparmor 2.13.3-7ubuntu5.1 amd64",
610         "install ok installed apport 2.20.11-0ubuntu27.9 all",
611         "install ok installed apport-symptoms 0.23 all",
612         "install ok installed apt 2.0.2ubuntu0.1 amd64",
613         "install ok installed apt-utils 2.0.2ubuntu0.1 amd64",
614         "install ok installed at 3.1.23-1ubuntu1 amd64",
615     ]
616     with patch.dict(aptpkg.__grains__, {"osarch": "x86_64"}), patch.dict(
617         aptpkg.__salt__,
618         {"cmd.run_stdout": MagicMock(return_value=os.linesep.join(apt_out))},
619     ), patch.dict(aptpkg.__salt__, {"pkg_resource.add_pkg": _add_data}), patch.dict(
620         aptpkg.__salt__,
621         {"pkg_resource.format_pkg_list": pkg_resource.format_pkg_list},
622     ), patch.dict(
623         aptpkg.__salt__, {"pkg_resource.sort_pkglist": pkg_resource.sort_pkglist}
624     ):
625         pkgs = aptpkg.list_pkgs(versions_as_list=True)
626         for pkg_name, pkg_version in {
627             "accountsservice": "0.6.55-0ubuntu12~20.04.1",
628             "acpid": "1:2.0.32-1ubuntu1",
629             "adduser": "3.118ubuntu2",
630             "alsa-topology-conf": "1.2.2-1",
631             "alsa-ucm-conf": "1.2.2-1ubuntu0.4",
632             "apparmor": "2.13.3-7ubuntu5.1",
633             "apport": "2.20.11-0ubuntu27.9",
634             "apport-symptoms": "0.23",
635             "apt": "2.0.2ubuntu0.1",
636             "apt-utils": "2.0.2ubuntu0.1",
637             "at": "3.1.23-1ubuntu1",
638         }.items():
639             assert pkgs[pkg_name] == [pkg_version]
640 def test_list_pkgs_no_context():
641     def _add_data(data, key, value):
642         data.setdefault(key, []).append(value)
643     apt_out = [
644         "install ok installed accountsservice 0.6.55-0ubuntu12~20.04.1 amd64",
645         "install ok installed acpid 1:2.0.32-1ubuntu1 amd64",
646         "install ok installed adduser 3.118ubuntu2 all",
647         "install ok installed alsa-topology-conf 1.2.2-1 all",
648         "install ok installed alsa-ucm-conf 1.2.2-1ubuntu0.4 all",
649         "install ok installed apparmor 2.13.3-7ubuntu5.1 amd64",
650         "install ok installed apport 2.20.11-0ubuntu27.9 all",
651         "install ok installed apport-symptoms 0.23 all",
652         "install ok installed apt 2.0.2ubuntu0.1 amd64",
653         "install ok installed apt-utils 2.0.2ubuntu0.1 amd64",
654         "install ok installed at 3.1.23-1ubuntu1 amd64",
655     ]
656     with patch.dict(aptpkg.__grains__, {"osarch": "x86_64"}), patch.dict(
657         aptpkg.__salt__,
658         {"cmd.run_stdout": MagicMock(return_value=os.linesep.join(apt_out))},
659     ), patch.dict(aptpkg.__salt__, {"pkg_resource.add_pkg": _add_data}), patch.dict(
660         aptpkg.__salt__,
661         {"pkg_resource.format_pkg_list": pkg_resource.format_pkg_list},
662     ), patch.dict(
663         aptpkg.__salt__, {"pkg_resource.sort_pkglist": pkg_resource.sort_pkglist}
664     ), patch.object(
665         aptpkg, "_list_pkgs_from_context"
666     ) as list_pkgs_context_mock:
667         pkgs = aptpkg.list_pkgs(versions_as_list=True, use_context=False)
668         list_pkgs_context_mock.assert_not_called()
669         list_pkgs_context_mock.reset_mock()
670         pkgs = aptpkg.list_pkgs(versions_as_list=True, use_context=False)
671         list_pkgs_context_mock.assert_not_called()
672         list_pkgs_context_mock.reset_mock()
673 def test_call_apt_default():
674     with patch.dict(
675         aptpkg.__salt__,
676         {"cmd.run_all": MagicMock(), "config.get": MagicMock(return_value=False)},
677     ):
678         aptpkg._call_apt(["apt-get", "install", "emacs"])  # pylint: disable=W0106
679         aptpkg.__salt__["cmd.run_all"].assert_called_once_with(
680             ["apt-get", "install", "emacs"],
681             env={},
682             output_loglevel="trace",
683             python_shell=False,
684         )
685 @patch("salt.utils.systemd.has_scope", MagicMock(return_value=True))
686 def test_call_apt_in_scope():
687     with patch.dict(
688         aptpkg.__salt__,
689         {"cmd.run_all": MagicMock(), "config.get": MagicMock(return_value=True)},
690     ):
691         aptpkg._call_apt(["apt-get", "purge", "vim"])  # pylint: disable=W0106
692         aptpkg.__salt__["cmd.run_all"].assert_called_once_with(
693             [
694                 "systemd-run",
695                 "--scope",
696                 "--description",
697                 '"salt.modules.aptpkg"',
698                 "apt-get",
699                 "purge",
700                 "vim",
701             ],
702             env={},
703             output_loglevel="trace",
704             python_shell=False,
705         )
706 def test_call_apt_with_kwargs():
707     with patch.dict(
708         aptpkg.__salt__,
709         {"cmd.run_all": MagicMock(), "config.get": MagicMock(return_value=False)},
710     ):
711         aptpkg._call_apt(
712             ["dpkg", "-l", "python"],
713             python_shell=True,
714             output_loglevel="quiet",
715             ignore_retcode=False,
716             username="Darth Vader",
717         )  # pylint: disable=W0106
718         aptpkg.__salt__["cmd.run_all"].assert_called_once_with(
719             ["dpkg", "-l", "python"],
720             env={},
721             ignore_retcode=False,
722             output_loglevel="quiet",
723             python_shell=True,
724             username="Darth Vader",
725         )
726 def test_call_apt_dpkg_lock():
727     cmd_side_effect = [
728         {"stderr": "Could not get lock"},
729         {"stderr": "Could not get lock"},
730         {"stderr": "Could not get lock"},
731         {"stderr": "Could not get lock"},
732         {"stderr": "", "stdout": ""},
733     ]
734     cmd_mock = MagicMock(side_effect=cmd_side_effect)
735     cmd_call = (
736         call(
737             ["dpkg", "-l", "python"],
738             env={},
739             ignore_retcode=False,
740             output_loglevel="quiet",
741             python_shell=True,
742             username="Darth Vader",
743         ),
744     )
745     expected_calls = [cmd_call * 5]
746     with patch.dict(
747         aptpkg.__salt__,
748         {"cmd.run_all": cmd_mock, "config.get": MagicMock(return_value=False)},
749     ):
750         with patch("salt.modules.aptpkg.time.sleep", MagicMock()) as sleep_mock:
751             aptpkg._call_apt(
752                 ["dpkg", "-l", "python"],
753                 python_shell=True,
754                 output_loglevel="quiet",
755                 ignore_retcode=False,
756                 username="Darth Vader",
757             )  # pylint: disable=W0106
758             assert sleep_mock.call_count &gt;= 4
759             assert cmd_mock.call_count == 5
760             cmd_mock.has_calls(expected_calls)
761 def test_services_need_restart_checkrestart_missing():
762     with patch("salt.utils.path.which_bin", Mock(return_value=None)):
763         with pytest.raises(CommandNotFoundError):
764             aptpkg.services_need_restart()
765 @patch("salt.utils.path.which_bin", Mock(return_value="/usr/sbin/checkrestart"))
766 def test_services_need_restart():
767     cr_output = """
768 PROCESSES: 24
769 PROGRAMS: 17
770 PACKAGES: 8
771 SERVICE:rsyslog,385,/usr/sbin/rsyslogd
772 SERVICE:cups-daemon,390,/usr/sbin/cupsd
773     Test SourcesList when repo has multiple comps
774     Test SourcesList when architectures is in repo
775     """
776     with patch("salt.utils.files.fopen", mock_open(read_data=repo_line)):
777         with patch("pathlib.Path.is_file", side_effect=[True, False]):
778             sources = aptpkg.SourcesList()
779             for source in sources:
780                 assert source.type == "deb"
781                 assert source.uri == "http://archive.ubuntu.com/ubuntu/"
782                 assert source.comps == ["main", "restricted"]
783                 assert source.dist == "focal-updates"
784                 if "," in repo_line:
785                     assert source.architectures == ["amd64", "armel"]
786                 else:
787                     assert source.architectures == ["amd64"]
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
