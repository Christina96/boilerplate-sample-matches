<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for lxd_container.py &amp; bigip.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for lxd_container.py &amp; bigip.py
      </h3>
<h1 align="center">
        1.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>lxd_container.py (2.1840873%)<th>bigip.py (0.6698565%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(49-65)<td><a href="#" name="0">(627-646)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>lxd_container.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
Manage LXD containers.
.. versionadded:: 2019.2.0
.. note:
    - :ref:`pylxd` version 2 is required to let this work,
      currently only available via pip.
        To install on Ubuntu:
        $ apt-get install libssl-dev python-pip
        $ pip install -U pylxd
    - you need lxd installed on the minion
      for the init() and version() methods.
    - for the config_get() and config_get() methods
      you need to have lxd-client installed.
.. _pylxd: https://github.com/lxc/pylxd/blob/master/doc/source/installation.rst
:maintainer: Ren√© Jochum &lt;rene@jochums.at&gt;
:maturity: new
:depends: python-pylxd
:platform: Linux
"""
from salt.exceptions import CommandExecutionError, SaltInvocationError
__docformat__ = "restructuredtext en"
__virtualname__ = "lxd_container"
CONTAINER_STATUS_RUNNING = 103
CONTAINER_STATUS_FROZEN = 110
CONTAINER_STATUS_STOPPED = 102
def __virtual__():
    """
    Only load if the lxd module is available in __salt__
    if "lxd.version" in __salt__:
        return __virtualname__
    return (F<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>alse, "lxd module could not be loaded")
def present(
    name,
    running=None,
    source=None,
    profiles=None,
    config=None,
    devices=None,
    architecture="x86_64",
    ephemeral=False,
    restart_on_change=False,
    remote_addr=None,
    cert=None,
    key=None,
    verify_cert=</b></font>True,
):
    """
    Create the named container if it does not exist
    name
        The name of the container to be created
    running : None
        * If ``True``, ensure that the container is running
        * If ``False``, ensure that the container is stopped
        * If ``None``, do nothing with regards to the running state of the
          container
    source : None
        Can be either a string containing an image alias:
        .. code-block:: none
             "xenial/amd64"
        or an dict with type "image" with alias:
        .. code-block:: python
            {"type": "image",
             "alias": "xenial/amd64"}
        or image with "fingerprint":
        .. code-block:: python
            {"type": "image",
             "fingerprint": "SHA-256"}
        or image with "properties":
        .. code-block:: python
            {"type": "image",
             "properties": {
                "os": "ubuntu",
                "release": "14.04",
                "architecture": "x86_64"
             }}
        or none:
        .. code-block:: python
            {"type": "none"}
        or copy:
        .. code-block:: python
            {"type": "copy",
             "source": "my-old-container"}
    profiles : ['default']
        List of profiles to apply on this container
    config :
        A config dict or None (None = unset).
        Can also be a list:
        .. code-block:: python
            [{'key': 'boot.autostart', 'value': 1},
             {'key': 'security.privileged', 'value': '1'}]
    devices :
        A device dict or None (None = unset).
    architecture : 'x86_64'
        Can be one of the following:
        * unknown
        * i686
        * x86_64
        * armv7l
        * aarch64
        * ppc
        * ppc64
        * ppc64le
        * s390x
    ephemeral : False
        Destroy this container after stop?
    restart_on_change : False
        Restart the container when we detect changes on the config or
        its devices?
    remote_addr :
        An URL to a remote Server, you also have to give cert and key if you
        provide remote_addr!
        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock
    cert :
        PEM Formatted SSL Zertifikate.
        Examples:
            ~/.config/lxc/client.crt
    key :
        PEM Formatted SSL Key.
        Examples:
            ~/.config/lxc/client.key
    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.
    """
    if profiles is None:
        profiles = ["default"]
    if source is None:
        source = {}
    ret = {
        "name": name,
        "running": running,
        "profiles": profiles,
        "source": source,
        "config": config,
        "devices": devices,
        "architecture": architecture,
        "ephemeral": ephemeral,
        "restart_on_change": restart_on_change,
        "remote_addr": remote_addr,
        "cert": cert,
        "key": key,
        "verify_cert": verify_cert,
        "changes": {},
    }
    container = None
    try:
        container = __salt__["lxd.container_get"](
            name, remote_addr, cert, key, verify_cert, _raw=True
        )
    except CommandExecutionError as e:
        return _error(ret, str(e))
    except SaltInvocationError as e:
        pass
    if container is None:
        if __opts__["test"]:
            msg = 'Would create the container "{}"'.format(name)
            ret["changes"] = {"created": msg}
            if running is True:
                msg = msg + " and start it."
                ret["changes"]["started"] = 'Would start the container "{}"'.format(
                    name
                )
            ret["changes"] = {"created": msg}
            return _unchanged(ret, msg)
        try:
            __salt__["lxd.container_create"](
                name,
                source,
                profiles,
                config,
                devices,
                architecture,
                ephemeral,
                True,  # Wait
                remote_addr,
                cert,
                key,
                verify_cert,
            )
        except CommandExecutionError as e:
            return _error(ret, str(e))
        msg = 'Created the container "{}"'.format(name)
        ret["changes"] = {"created": msg}
        if running is True:
            try:
                __salt__["lxd.container_start"](
                    name, remote_addr, cert, key, verify_cert
                )
            except CommandExecutionError as e:
                return _error(ret, str(e))
            msg = msg + " and started it."
            ret["changes"] = {"started": 'Started the container "{}"'.format(name)}
        return _success(ret, msg)
    new_profiles = set(map(str, profiles))
    old_profiles = set(map(str, container.profiles))
    container_changed = False
    profile_changes = []
    for k in old_profiles.difference(new_profiles):
        if not __opts__["test"]:
            profile_changes.append('Removed profile "{}"'.format(k))
            old_profiles.discard(k)
        else:
            profile_changes.append('Would remove profile "{}"'.format(k))
    for k in new_profiles.difference(old_profiles):
        if not __opts__["test"]:
            profile_changes.append('Added profile "{}"'.format(k))
            old_profiles.add(k)
        else:
            profile_changes.append('Would add profile "{}"'.format(k))
    if profile_changes:
        container_changed = True
        ret["changes"]["profiles"] = profile_changes
        container.profiles = list(old_profiles)
    config, devices = __salt__["lxd.normalize_input_values"](config, devices)
    changes = __salt__["lxd.sync_config_devices"](
        container, config, devices, __opts__["test"]
    )
    if changes:
        container_changed = True
        ret["changes"].update(changes)
    is_running = container.status_code == CONTAINER_STATUS_RUNNING
    if not __opts__["test"]:
        try:
            __salt__["lxd.pylxd_save_object"](container)
        except CommandExecutionError as e:
            return _error(ret, str(e))
    if running != is_running:
        if running is True:
            if __opts__["test"]:
                changes["running"] = "Would start the container"
                return _unchanged(
                    ret,
                    'Container "{}" would get changed and started.'.format(name),
                )
            else:
                container.start(wait=True)
                changes["running"] = "Started the container"
        elif running is False:
            if __opts__["test"]:
                changes["stopped"] = "Would stopped the container"
                return _unchanged(
                    ret,
                    'Container "{}" would get changed and stopped.'.format(name),
                )
            else:
                container.stop(wait=True)
                changes["stopped"] = "Stopped the container"
    if (
        (running is True or running is None)
        and is_running
        and restart_on_change
        and container_changed
    ):
        if __opts__["test"]:
            changes["restarted"] = "Would restart the container"
            return _unchanged(ret, 'Would restart the container "{}"'.format(name))
        else:
            container.restart(wait=True)
            changes["restarted"] = 'Container "{}" has been restarted'.format(name)
            return _success(ret, 'Container "{}" has been restarted'.format(name))
    if not container_changed:
        return _success(ret, "No changes")
    if __opts__["test"]:
        return _unchanged(ret, 'Container "{}" would get changed.'.format(name))
    return _success(ret, "{} changes".format(len(ret["changes"].keys())))
def absent(name, stop=False, remote_addr=None, cert=None, key=None, verify_cert=True):
    """
    Ensure a LXD container is not present, destroying it if present
    name :
        The name of the container to destroy
    stop :
        stop before destroying
        default: false
    remote_addr :
        An URL to a remote Server, you also have to give cert and key if you
        provide remote_addr!
        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock
    cert :
        PEM Formatted SSL Zertifikate.
        Examples:
            ~/.config/lxc/client.crt
    key :
        PEM Formatted SSL Key.
        Examples:
            ~/.config/lxc/client.key
    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.
    """
    ret = {
        "name": name,
        "stop": stop,
        "remote_addr": remote_addr,
        "cert": cert,
        "key": key,
        "verify_cert": verify_cert,
        "changes": {},
    }
    try:
        container = __salt__["lxd.container_get"](
            name, remote_addr, cert, key, verify_cert, _raw=True
        )
    except CommandExecutionError as e:
        return _error(ret, str(e))
    except SaltInvocationError as e:
        return _success(ret, 'Container "{}" not found.'.format(name))
    if __opts__["test"]:
        ret["changes"] = {"removed": 'Container "{}" would get deleted.'.format(name)}
        return _unchanged(ret, ret["changes"]["removed"])
    if stop and container.status_code == CONTAINER_STATUS_RUNNING:
        container.stop(wait=True)
    container.delete(wait=True)
    ret["changes"]["deleted"] = 'Container "{}" has been deleted.'.format(name)
    return _success(ret, ret["changes"]["deleted"])
def running(
    name, restart=False, remote_addr=None, cert=None, key=None, verify_cert=True
):
    """
    Ensure a LXD container is running and restart it if restart is True
    name :
        The name of the container to start/restart.
    restart :
        restart the container if it is already started.
    remote_addr :
        An URL to a remote Server, you also have to give cert and key if you
        provide remote_addr!
        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock
    cert :
        PEM Formatted SSL Zertifikate.
        Examples:
            ~/.config/lxc/client.crt
    key :
        PEM Formatted SSL Key.
        Examples:
            ~/.config/lxc/client.key
    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.
    """
    ret = {
        "name": name,
        "restart": restart,
        "remote_addr": remote_addr,
        "cert": cert,
        "key": key,
        "verify_cert": verify_cert,
        "changes": {},
    }
    try:
        container = __salt__["lxd.container_get"](
            name, remote_addr, cert, key, verify_cert, _raw=True
        )
    except CommandExecutionError as e:
        return _error(ret, str(e))
    except SaltInvocationError as e:
        return _error(ret, 'Container "{}" not found'.format(name))
    is_running = container.status_code == CONTAINER_STATUS_RUNNING
    if is_running:
        if not restart:
            return _success(ret, 'The container "{}" is already running'.format(name))
        else:
            if __opts__["test"]:
                ret["changes"]["restarted"] = 'Would restart the container "{}"'.format(
                    name
                )
                return _unchanged(ret, ret["changes"]["restarted"])
            else:
                container.restart(wait=True)
                ret["changes"]["restarted"] = 'Restarted the container "{}"'.format(
                    name
                )
                return _success(ret, ret["changes"]["restarted"])
    if __opts__["test"]:
        ret["changes"]["started"] = 'Would start the container "{}"'.format(name)
        return _unchanged(ret, ret["changes"]["started"])
    container.start(wait=True)
    ret["changes"]["started"] = 'Started the container "{}"'.format(name)
    return _success(ret, ret["changes"]["started"])
def frozen(name, start=True, remote_addr=None, cert=None, key=None, verify_cert=True):
    """
    Ensure a LXD container is frozen, start and freeze it if start is true
    name :
        The name of the container to freeze
    start :
        start and freeze it
    remote_addr :
        An URL to a remote Server, you also have to give cert and key if you
        provide remote_addr!
        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock
    cert :
        PEM Formatted SSL Zertifikate.
        Examples:
            ~/.config/lxc/client.crt
    key :
        PEM Formatted SSL Key.
        Examples:
            ~/.config/lxc/client.key
    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.
    """
    ret = {
        "name": name,
        "start": start,
        "remote_addr": remote_addr,
        "cert": cert,
        "key": key,
        "verify_cert": verify_cert,
        "changes": {},
    }
    try:
        container = __salt__["lxd.container_get"](
            name, remote_addr, cert, key, verify_cert, _raw=True
        )
    except CommandExecutionError as e:
        return _error(ret, str(e))
    except SaltInvocationError as e:
        return _error(ret, 'Container "{}" not found'.format(name))
    if container.status_code == CONTAINER_STATUS_FROZEN:
        return _success(ret, 'Container "{}" is alredy frozen'.format(name))
    is_running = container.status_code == CONTAINER_STATUS_RUNNING
    if not is_running and not start:
        return _error(
            ret,
            'Container "{}" is not running and start is False, cannot freeze it'.format(
                name
            ),
        )
    elif not is_running and start:
        if __opts__["test"]:
            ret["changes"][
                "started"
            ] = 'Would start the container "{}" and freeze it after'.format(name)
            return _unchanged(ret, ret["changes"]["started"])
        else:
            container.start(wait=True)
            ret["changes"]["started"] = 'Start the container "{}"'.format(name)
    if __opts__["test"]:
        ret["changes"]["frozen"] = 'Would freeze the container "{}"'.format(name)
        return _unchanged(ret, ret["changes"]["frozen"])
    container.freeze(wait=True)
    ret["changes"]["frozen"] = 'Froze the container "{}"'.format(name)
    return _success(ret, ret["changes"]["frozen"])
def stopped(name, kill=False, remote_addr=None, cert=None, key=None, verify_cert=True):
    """
    Ensure a LXD container is stopped, kill it if kill is true else stop it
    name :
        The name of the container to stop
    kill :
        kill if true
    remote_addr :
        An URL to a remote Server, you also have to give cert and key if you
        provide remote_addr!
        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock
    cert :
        PEM Formatted SSL Zertifikate.
        Examples:
            ~/.config/lxc/client.crt
    key :
        PEM Formatted SSL Key.
        Examples:
            ~/.config/lxc/client.key
    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.
    """
    ret = {
        "name": name,
        "kill": kill,
        "remote_addr": remote_addr,
        "cert": cert,
        "key": key,
        "verify_cert": verify_cert,
        "changes": {},
    }
    try:
        container = __salt__["lxd.container_get"](
            name, remote_addr, cert, key, verify_cert, _raw=True
        )
    except CommandExecutionError as e:
        return _error(ret, str(e))
    except SaltInvocationError as e:
        return _error(ret, 'Container "{}" not found'.format(name))
    if container.status_code == CONTAINER_STATUS_STOPPED:
        return _success(ret, 'Container "{}" is already stopped'.format(name))
    if __opts__["test"]:
        ret["changes"]["stopped"] = 'Would stop the container "{}"'.format(name)
        return _unchanged(ret, ret["changes"]["stopped"])
    container.stop(force=kill, wait=True)
    ret["changes"]["stopped"] = 'Stopped the container "{}"'.format(name)
    return _success(ret, ret["changes"]["stopped"])
def migrated(
    name,
    remote_addr,
    cert,
    key,
    verify_cert,
    src_remote_addr,
    stop_and_start=False,
    src_cert=None,
    src_key=None,
    src_verify_cert=None,
):
    """Ensure a container is migrated to another host
    If the container is running, it either must be shut down
    first (use stop_and_start=True) or criu must be installed
    on the source and destination machines.
    For this operation both certs need to be authenticated,
    use :mod:`lxd.authenticate &lt;salt.states.lxd.authenticate`
    to authenticate your cert(s).
    name :
        The container to migrate
    remote_addr :
        An URL to the destination remote Server
        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock
    cert :
        PEM Formatted SSL Zertifikate.
        Examples:
            ~/.config/lxc/client.crt
    key :
        PEM Formatted SSL Key.
        Examples:
            ~/.config/lxc/client.key
    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.
    src_remote_addr :
        An URL to the source remote Server
        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock
    stop_and_start:
        Stop before migrating and start after
    src_cert :
        PEM Formatted SSL Zertifikate, if None we copy "cert"
        Examples:
            ~/.config/lxc/client.crt
    src_key :
        PEM Formatted SSL Key, if None we copy "key"
        Examples:
            ~/.config/lxc/client.key
    src_verify_cert :
        Wherever to verify the cert, if None we copy "verify_cert"
    """
    ret = {
        "name": name,
        "remote_addr": remote_addr,
        "cert": cert,
        "key": key,
        "verify_cert": verify_cert,
        "src_remote_addr": src_remote_addr,
        "src_and_start": stop_and_start,
        "src_cert": src_cert,
        "src_key": src_key,
        "changes": {},
    }
    dest_container = None
    try:
        dest_container = __salt__["lxd.container_get"](
            name, remote_addr, cert, key, verify_cert, _raw=True
        )
    except CommandExecutionError as e:
        return _error(ret, str(e))
    except SaltInvocationError as e:
        pass
    if dest_container is not None:
        return _success(ret, 'Container "{}" exists on the destination'.format(name))
    if src_verify_cert is None:
        src_verify_cert = verify_cert
    try:
        __salt__["lxd.container_get"](
            name, src_remote_addr, src_cert, src_key, src_verify_cert, _raw=True
        )
    except CommandExecutionError as e:
        return _error(ret, str(e))
    except SaltInvocationError as e:
        return _error(ret, 'Source Container "{}" not found'.format(name))
    if __opts__["test"]:
        ret["changes"][
            "migrated"
        ] = 'Would migrate the container "{}" from "{}" to "{}"'.format(
            name, src_remote_addr, remote_addr
        )
        return _unchanged(ret, ret["changes"]["migrated"])
    try:
        __salt__["lxd.container_migrate"](
            name,
            stop_and_start,
            remote_addr,
            cert,
            key,
            verify_cert,
            src_remote_addr,
            src_cert,
            src_key,
            src_verify_cert,
        )
    except CommandExecutionError as e:
        return _error(ret, str(e))
    ret["changes"]["migrated"] = 'Migrated the container "{}" from "{}" to "{}"'.format(
        name, src_remote_addr, remote_addr
    )
    return _success(ret, ret["changes"]["migrated"])
def _success(ret, success_msg):
    ret["result"] = True
    ret["comment"] = success_msg
    if "changes" not in ret:
        ret["changes"] = {}
    return ret
def _unchanged(ret, msg):
    ret["result"] = None
    ret["comment"] = msg
    if "changes" not in ret:
        ret["changes"] = {}
    return ret
def _error(ret, err_msg):
    ret["result"] = False
    ret["comment"] = err_msg
    if "changes" not in ret:
        ret["changes"] = {}
    return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>bigip.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
A state module designed to enforce load-balancing configurations for F5 Big-IP entities.
    :maturity:      develop
    :platform:      f5_bigip_11.6
"""
import salt.utils.json
def __virtual__():
    """
    Only load if the bigip exec module is available in __salt__
    """
    if "bigip.list_transaction" in __salt__:
        return "bigip"
    return (False, "bigip module could not be loaded")
def _load_result(response, ret):
    """
    format the results of listing functions
    """
    if response["code"] is None:
        ret["comment"] = response["content"]
    elif response["code"] == 401:
        ret["comment"] = "401 Forbidden: Authentication required!"
    elif response["code"] == 404:
        ret["comment"] = response["content"]["message"]
    elif response["code"] == 200:
        ret["result"] = True
        ret["comment"] = (
            "Listing Current Configuration Only.  "
            "Not action or changes occurred during the execution of this state."
        )
        ret["changes"] = response["content"]
    else:
        ret["comment"] = response["content"]["message"]
    return ret
def _strip_key(dictionary, keyword):
    """
    look for a certain key within a dictionary and nullify ti's contents, check within nested
    dictionaries and lists as well.  Certain attributes such as "generation" will change even
    when there were no changes made to the entity.
    """
    for key, value in dictionary.items():
        if key == keyword:
            dictionary[key] = None
        elif isinstance(value, dict):
            _strip_key(value, keyword)
        elif isinstance(value, list):
            for item in value:
                if isinstance(item, dict):
                    _strip_key(item, keyword)
    return dictionary
def _check_for_changes(entity_type, ret, existing, modified):
    """
    take an existing entity and a modified entity and check for changes.
    """
    ret["result"] = True
    if isinstance(existing, dict) and isinstance(modified, dict):
        if "generation" in modified["content"].keys():
            del modified["content"]["generation"]
        if "generation" in existing["content"].keys():
            del existing["content"]["generation"]
        if modified["content"] == existing["content"]:
            ret["comment"] = (
                "{entity_type} is currently enforced to the desired state.  No changes"
                " made.".format(entity_type=entity_type)
            )
        else:
            ret["comment"] = (
                "{entity_type} was enforced to the desired state.  Note: Only"
                " parameters specified were enforced. See changes for details.".format(
                    entity_type=entity_type
                )
            )
            ret["changes"]["old"] = existing["content"]
            ret["changes"]["new"] = modified["content"]
    else:
        if modified == existing:
            ret["comment"] = (
                "{entity_type} is currently enforced to the desired state.  No changes"
                " made.".format(entity_type=entity_type)
            )
        else:
            ret["comment"] = (
                "{entity_type} was enforced to the desired state.  Note: Only"
                " parameters specified were enforced. See changes for details.".format(
                    entity_type=entity_type
                )
            )
            ret["changes"]["old"] = existing
            ret["changes"]["new"] = modified
    return ret
def _test_output(ret, action, params):
    """
    For testing just output what the state will attempt to do without actually doing it.
    """
    if action == "list":
        ret[
            "comment"
        ] += "The list action will just list an entity and will make no changes.\n"
    elif action == "create" or action == "add":
        ret["comment"] += (
            "The create action will attempt to create an entity if it does not already"
            " exist.\n"
        )
    elif action == "delete":
        ret["comment"] += (
            "The delete action will attempt to delete an existing entity if it"
            " exists.\n"
        )
    elif action == "manage":
        ret["comment"] += (
            "The manage action will create a new entity if it does not exist.  If it"
            " does exist, it will be enforcedto the desired state.\n"
        )
    elif action == "modify":
        ret["comment"] += (
            "The modify action will attempt to modify an existing entity only if it"
            " exists.\n"
        )
    ret["comment"] += "An iControl REST Request will be made using the parameters:\n"
    ret["comment"] += salt.utils.json.dumps(params, indent=4)
    ret["changes"] = {}
    ret["result"] = None
    return ret
def list_node(hostname, username, password, name):
    """
    A function to connect to a bigip device and list a specific node.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the node to list.
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "list",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
            },
        )
    response = __salt__["bigip.list_node"](hostname, username, password, name)
    return _load_result(response, ret)
def create_node(hostname, username, password, name, address):
    """
    Create a new node if it does not already exist.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the node to create
    address
        The address of the node
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "create",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
                "address": address,
            },
        )
    existing = __salt__["bigip.list_node"](hostname, username, password, name)
    if existing["code"] == 200:
        ret["result"] = True
        ret["comment"] = "A node by this name currently exists.  No change made."
    elif existing["code"] == 404:
        response = __salt__["bigip.create_node"](
            hostname, username, password, name, address
        )
        ret["result"] = True
        ret["changes"]["old"] = {}
        ret["changes"]["new"] = response["content"]
        ret["comment"] = "Node was successfully created."
    else:
        ret = _load_result(existing, ret)
    return ret
def manage_node(
    hostname,
    username,
    password,
    name,
    address,
    connection_limit=None,
    description=None,
    dynamic_ratio=None,
    logging=None,
    monitor=None,
    rate_limit=None,
    ratio=None,
    session=None,
    node_state=None,
):
    """
    Manages a node of a given bigip device.  If the node does not exist it will be created, otherwise,
    only the properties which are different than the existing will be updated.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the node to manage.
    address
        The address of the node
    connection_limit
        [integer]
    description
        [string]
    dynam
        c_ratio:        [integer]
    logging
        [enabled | disabled]
    monitor
        [[name] | none | default]
    rate_limit
        [integer]
    ratio
        [integer]
    session
        [user-enabled | user-disabled]
    node_state (state)
        [user-down | user-up ]
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "manage",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
                "address": address,
                "connection_limit": connection_limit,
                "description": description,
                "dynamic_ratio": dynamic_ratio,
                "logging": logging,
                "monitor": monitor,
                "rate_limit": rate_limit,
                "ratio": ratio,
                "session": session,
                "state:": node_state,
            },
        )
    existing = __salt__["bigip.list_node"](hostname, username, password, name)
    if existing["code"] == 200:
        if existing["content"]["address"] != address:
            ret["result"] = False
            ret[
                "comment"
            ] = "A node with this name exists but the address does not match."
        modified = __salt__["bigip.modify_node"](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            connection_limit=connection_limit,
            description=description,
            dynamic_ratio=dynamic_ratio,
            logging=logging,
            monitor=monitor,
            rate_limit=rate_limit,
            ratio=ratio,
            session=session,
            state=node_state,
        )
        if modified["code"] == 200:
            ret = _check_for_changes("Node", ret, existing, modified)
        else:
            ret = _load_result(modified, ret)
    elif existing["code"] == 404:
        new = __salt__["bigip.create_node"](hostname, username, password, name, address)
        if new["code"] == 200:
            modified = __salt__["bigip.modify_node"](
                hostname=hostname,
                username=username,
                password=password,
                name=name,
                connection_limit=connection_limit,
                description=description,
                dynamic_ratio=dynamic_ratio,
                logging=logging,
                monitor=monitor,
                rate_limit=rate_limit,
                ratio=ratio,
                session=session,
                state=node_state,
            )
            if modified["code"] == 200:
                ret["result"] = True
                ret["comment"] = (
                    "Node was created and enforced to the desired state.  Note: Only"
                    " parameters specified were enforced.  See changes for details."
                )
                ret["changes"]["old"] = {}
                ret["changes"]["new"] = modified["content"]
            else:
                deleted = __salt__["bigip.delete_node"](
                    hostname, username, password, name
                )
                if deleted["code"] == 200:
                    ret["comment"] = (
                        "Node was successfully created but an error occurred during"
                        " modification. The creation of the node has been rolled back."
                        " Message is as follows:\n{message}".format(
                            message=modified["content"]["message"]
                        )
                    )
                else:
                    ret["comment"] = (
                        "Node was successfully created but an error occurred during"
                        " modification. The creation of the node was not able to be"
                        " rolled back. Message is as follows:\n"
                        " {message}\n{message_two}".format(
                            message=modified["content"]["message"],
                            message_two=deleted["content"]["message"],
                        )
                    )
        else:
            ret = _load_result(new, ret)
    else:
        ret = _load_result(existing, ret)
    return ret
def modify_node(
    hostname,
    username,
    password,
    name,
    connection_limit=None,
    description=None,
    dynamic_ratio=None,
    logging=None,
    monitor=None,
    rate_limit=None,
    ratio=None,
    session=None,
    node_state=None,
):
    """
    Modify an existing node. Only a node which already exists will be modified and
    only the parameters specified will be enforced.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the node to modify
    connection_limit
        [integer]
    description
        [string]
    dynamic_ratio
        [integer]
    logging
        [enabled | disabled]
    monitor
        [[name] | none | default]
    rate_limit
        [integer]
    ratio
        [integer]
    session
        [user-enabled | user-disabled]
    node_state (state)
        [user-down | user-up ]
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "modify",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
                "connection_limit": connection_limit,
                "description": description,
                "dynamic_ratio": dynamic_ratio,
                "logging": logging,
                "monitor": monitor,
                "rate_limit": rate_limit,
                "ratio": ratio,
                "session": session,
                "state:": node_state,
            },
        )
    existing = __salt__["bigip.list_node"](hostname, username, password, name)
    if existing["code"] == 200:
        modified = __salt__["bigip.modify_node"](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            connection_limit=connection_limit,
            description=description,
            dynamic_ratio=dynamic_ratio,
            logging=logging,
            monitor=monitor,
            rate_limit=rate_limit,
            ratio=ratio,
            session=session,
            state=node_state,
        )
        if modified["code"] == 200:
            ret = _check_for_changes("Node", ret, existing, modified)
        else:
            ret = _load_result(modified, ret)
    elif existing["code"] == 404:
        ret["comment"] = "A node with this name was not found."
    else:
        ret = _load_result(existing, ret)
    return ret
def delete_node(hostname, username, password, name):
    """
    Delete an existing node.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the node which will be deleted.
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "delete",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
            },
        )
    existing = __salt__["bigip.list_node"](hostname, username, password, name)
    if existing["code"] == 200:
        deleted = __salt__["bigip.delete_node"](hostname, username, password, name)
        if deleted["code"] == 200:
            ret["result"] = True
            ret["comment"] = "Node was successfully deleted."
            ret["changes"]["old"] = existing["content"]
            ret["changes"]["new"] = {}
        else:
            ret = _load_result(existing, ret)
    elif existing["code"] == 404:
        ret["result"] = True
        ret["comment"] = "This node already does not exist. No changes made."
        ret["changes"]["old"] = {}
        ret["changes"]["new"] = {}
    else:
        ret = _load_result(existing, ret)
    return ret
def list_pool(hostname, username, password, name):
    """
    A function to connect to a bigip device and list a specific pool.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool to list.
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "list",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
            },
    response = __salt__["bigip.list_pool"](hostname, username, password, name)
    return _load_result(<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>response, ret)
def create_pool(
    hostname,
    username,
    password,
    name,
    members=None,
    allow_nat=None,
    allow_snat=None,
    description=None,
    gateway_failsafe_device=None,
    ignore_persisted_weight=None,
    ip_tos_to_client=None,
    ip_tos_to_server=None,
    link_qos_to_client=None,
    link_qos_to_server=None,
    load_balancing_mode=None,
    min_active_members=</b></font>None,
    min_up_members=None,
    min_up_members_action=None,
    min_up_members_checking=None,
    monitor=None,
    profiles=None,
    queue_depth_limit=None,
    queue_on_connection_limit=None,
    queue_time_limit=None,
    reselect_tries=None,
    service_down_action=None,
    slow_ramp_time=None,
):
    """
    Create a new node if it does not already exist.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool to create
    members
        List of members to be added to the pool
    allow_nat
        [yes | no]
    allow_snat
        [yes | no]
    description
        [string]
    gateway_failsafe_device
        [string]
    ignore_persisted_weight
        [enabled | disabled]
    ip_tos_to_client
        [pass-through | [integer]]
    ip_tos_to_server
        [pass-through | [integer]]
    link_qos_to_client
        [pass-through | [integer]]
    link_qos_to_server
        [pass-through | [integer]]
    load_balancing_mode
        [dynamic-ratio-member | dynamic-ratio-node |
        fastest-app-response | fastest-node |
        least-connections-members |
        least-connections-node |
        least-sessions |
        observed-member | observed-node |
        predictive-member | predictive-node |
        ratio-least-connections-member |
        ratio-least-connections-node |
        ratio-member | ratio-node | ratio-session |
        round-robin | weighted-least-connections-member |
        weighted-least-connections-node]
    min_active_members
        [integer]
    min_up_members
        [integer]
    min_up_members_action
        [failover | reboot | restart-all]
    min_up_members_checking
        [enabled | disabled]
    monitor
        [name]
    profiles
        [none | profile_name]
    queue_depth_limit
        [integer]
    queue_on_connection_limit
        [enabled | disabled]
    queue_time_limit
        [integer]
    reselect_tries
        [integer]
    service_down_action
        [drop | none | reselect | reset]
    slow_ramp_time
        [integer]
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "create",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
                "members": members,
                "allow_nat": allow_nat,
                "allow_snat": allow_snat,
                "description": description,
                "gateway_failsafe_device": gateway_failsafe_device,
                "ignore_persisted_weight": ignore_persisted_weight,
                "ip_tos_client:": ip_tos_to_client,
                "ip_tos_server": ip_tos_to_server,
                "link_qos_to_client": link_qos_to_client,
                "link_qos_to_server": link_qos_to_server,
                "load_balancing_mode": load_balancing_mode,
                "min_active_members": min_active_members,
                "min_up_members": min_up_members,
                "min_up_members_checking": min_up_members_checking,
                "monitor": monitor,
                "profiles": profiles,
                "queue_depth_limit": queue_depth_limit,
                "queue_on_connection_limit": queue_on_connection_limit,
                "queue_time_limit": queue_time_limit,
                "reselect_tries": reselect_tries,
                "service_down_action": service_down_action,
                "slow_ramp_time": slow_ramp_time,
            },
        )
    existing = __salt__["bigip.list_pool"](hostname, username, password, name)
    if existing["code"] == 200:
        ret["result"] = True
        ret["comment"] = "A pool by this name currently exists.  No change made."
    elif existing["code"] == 404:
        response = __salt__["bigip.create_pool"](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            members=members,
            allow_nat=allow_nat,
            allow_snat=allow_snat,
            description=description,
            gateway_failsafe_device=gateway_failsafe_device,
            ignore_persisted_weight=ignore_persisted_weight,
            ip_tos_to_client=ip_tos_to_client,
            ip_tos_to_server=ip_tos_to_server,
            link_qos_to_client=link_qos_to_client,
            link_qos_to_server=link_qos_to_server,
            load_balancing_mode=load_balancing_mode,
            min_active_members=min_active_members,
            min_up_members=min_up_members,
            min_up_members_action=min_up_members_action,
            min_up_members_checking=min_up_members_checking,
            monitor=monitor,
            profiles=profiles,
            queue_depth_limit=queue_depth_limit,
            queue_on_connection_limit=queue_on_connection_limit,
            queue_time_limit=queue_time_limit,
            reselect_tries=reselect_tries,
            service_down_action=service_down_action,
            slow_ramp_time=slow_ramp_time,
        )
        if response["code"] == 200:
            ret["result"] = True
            ret["changes"]["old"] = {}
            ret["changes"]["new"] = response["content"]
            ret["comment"] = "Pool was successfully created."
        else:
            ret = _load_result(existing, ret)
    else:
        ret = _load_result(existing, ret)
    return ret
def manage_pool(
    hostname,
    username,
    password,
    name,
    allow_nat=None,
    allow_snat=None,
    description=None,
    gateway_failsafe_device=None,
    ignore_persisted_weight=None,
    ip_tos_to_client=None,
    ip_tos_to_server=None,
    link_qos_to_client=None,
    link_qos_to_server=None,
    load_balancing_mode=None,
    min_active_members=None,
    min_up_members=None,
    min_up_members_action=None,
    min_up_members_checking=None,
    monitor=None,
    profiles=None,
    queue_depth_limit=None,
    queue_on_connection_limit=None,
    queue_time_limit=None,
    reselect_tries=None,
    service_down_action=None,
    slow_ramp_time=None,
):
    """
    Create a new pool if it does not already exist. Pool members are managed separately. Only the
    parameters specified are enforced.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool to create
    allow_nat
        [yes | no]
    allow_snat
        [yes | no]
    description
        [string]
    gateway_failsafe_device
        [string]
    ignore_persisted_weight
        [enabled | disabled]
    ip_tos_to_client
        [pass-through | [integer]]
    ip_tos_to_server
        [pass-through | [integer]]
    link_qos_to_client
        [pass-through | [integer]]
    link_qos_to_server
        [pass-through | [integer]]
    load_balancing_mode
        [dynamic-ratio-member | dynamic-ratio-node |
        fastest-app-response | fastest-node |
        least-connections-members |
        least-connections-node |
        least-sessions |
        observed-member | observed-node |
        predictive-member | predictive-node |
        ratio-least-connections-member |
        ratio-least-connections-node |
        ratio-member | ratio-node | ratio-session |
        round-robin | weighted-least-connections-member |
        weighted-least-connections-node]
    min_active_members
        [integer]
    min_up_members
        [integer]
    min_up_members_action
        [failover | reboot | restart-all]
    min_up_members_checking
        [enabled | disabled]
    monitor
        [name]
    profiles
        [none | profile_name]
    queue_depth_limit
        [integer]
    queue_on_connection_limit
        [enabled | disabled]
    queue_time_limit
        [integer]
    reselect_tries
        [integer]
    service_down_action
        [drop | none | reselect | reset]
    slow_ramp_time
        [integer]
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "manage",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
                "allow_nat": allow_nat,
                "allow_snat": allow_snat,
                "description": description,
                "gateway_failsafe_device": gateway_failsafe_device,
                "ignore_persisted_weight": ignore_persisted_weight,
                "ip_tos_client:": ip_tos_to_client,
                "ip_tos_server": ip_tos_to_server,
                "link_qos_to_client": link_qos_to_client,
                "link_qos_to_server": link_qos_to_server,
                "load_balancing_mode": load_balancing_mode,
                "min_active_members": min_active_members,
                "min_up_members": min_up_members,
                "min_up_members_checking": min_up_members_checking,
                "monitor": monitor,
                "profiles": profiles,
                "queue_depth_limit": queue_depth_limit,
                "queue_on_connection_limit": queue_on_connection_limit,
                "queue_time_limit": queue_time_limit,
                "reselect_tries": reselect_tries,
                "service_down_action": service_down_action,
                "slow_ramp_time": slow_ramp_time,
            },
        )
    existing = __salt__["bigip.list_pool"](hostname, username, password, name)
    if existing["code"] == 200:
        modified = __salt__["bigip.modify_pool"](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            allow_nat=allow_nat,
            allow_snat=allow_snat,
            description=description,
            gateway_failsafe_device=gateway_failsafe_device,
            ignore_persisted_weight=ignore_persisted_weight,
            ip_tos_to_client=ip_tos_to_client,
            ip_tos_to_server=ip_tos_to_server,
            link_qos_to_client=link_qos_to_client,
            link_qos_to_server=link_qos_to_server,
            load_balancing_mode=load_balancing_mode,
            min_active_members=min_active_members,
            min_up_members=min_up_members,
            min_up_members_action=min_up_members_action,
            min_up_members_checking=min_up_members_checking,
            monitor=monitor,
            profiles=profiles,
            queue_depth_limit=queue_depth_limit,
            queue_on_connection_limit=queue_on_connection_limit,
            queue_time_limit=queue_time_limit,
            reselect_tries=reselect_tries,
            service_down_action=service_down_action,
            slow_ramp_time=slow_ramp_time,
        )
        if modified["code"] == 200:
            del existing["content"]["membersReference"]
            del modified["content"]["membersReference"]
            del existing["content"]["selfLink"]
            del modified["content"]["selfLink"]
            ret = _check_for_changes("Pool", ret, existing, modified)
        else:
            ret = _load_result(modified, ret)
    elif existing["code"] == 404:
        new = __salt__["bigip.create_pool"](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            allow_nat=allow_nat,
            allow_snat=allow_snat,
            description=description,
            gateway_failsafe_device=gateway_failsafe_device,
            ignore_persisted_weight=ignore_persisted_weight,
            ip_tos_to_client=ip_tos_to_client,
            ip_tos_to_server=ip_tos_to_server,
            link_qos_to_client=link_qos_to_client,
            link_qos_to_server=link_qos_to_server,
            load_balancing_mode=load_balancing_mode,
            min_active_members=min_active_members,
            min_up_members=min_up_members,
            min_up_members_action=min_up_members_action,
            min_up_members_checking=min_up_members_checking,
            monitor=monitor,
            profiles=profiles,
            queue_depth_limit=queue_depth_limit,
            queue_on_connection_limit=queue_on_connection_limit,
            queue_time_limit=queue_time_limit,
            reselect_tries=reselect_tries,
            service_down_action=service_down_action,
            slow_ramp_time=slow_ramp_time,
        )
        if new["code"] == 200:
            ret["result"] = True
            ret["comment"] = (
                "Pool was created and enforced to the desired state.  Note: Only"
                " parameters specified were enforced.  See changes for details."
            )
            ret["changes"]["old"] = {}
            ret["changes"]["new"] = new["content"]
        else:
            ret = _load_result(new, ret)
    else:
        ret = _load_result(existing, ret)
    return ret
def modify_pool(
    hostname,
    username,
    password,
    name,
    allow_nat=None,
    allow_snat=None,
    description=None,
    gateway_failsafe_device=None,
    ignore_persisted_weight=None,
    ip_tos_to_client=None,
    ip_tos_to_server=None,
    link_qos_to_client=None,
    link_qos_to_server=None,
    load_balancing_mode=None,
    min_active_members=None,
    min_up_members=None,
    min_up_members_action=None,
    min_up_members_checking=None,
    monitor=None,
    profiles=None,
    queue_depth_limit=None,
    queue_on_connection_limit=None,
    queue_time_limit=None,
    reselect_tries=None,
    service_down_action=None,
    slow_ramp_time=None,
):
    """
    Modify an existing pool. Pool members are managed separately. Only the
    parameters specified are enforced.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool to create
    allow_nat
        [yes | no]
    allow_snat
        [yes | no]
    description
        [string]
    gateway_failsafe_device
        [string]
    ignore_persisted_weight
        [enabled | disabled]
    ip_tos_to_client
        [pass-through | [integer]]
    ip_tos_to_server
        [pass-through | [integer]]
    link_qos_to_client
        [pass-through | [integer]]
    link_qos_to_server
        [pass-through | [integer]]
    load_balancing_mode
        [dynamic-ratio-member | dynamic-ratio-node |
        fastest-app-response | fastest-node |
        least-connections-members |
        least-connections-node |
        least-sessions |
        observed-member | observed-node |
        predictive-member | predictive-node |
        ratio-least-connections-member |
        ratio-least-connections-node |
        ratio-member | ratio-node | ratio-session |
        round-robin | weighted-least-connections-member |
        weighted-least-connections-node]
    min_active_members
        [integer]
    min_up_members
        [integer]
    min_up_members_action
        [failover | reboot | restart-all]
    min_up_members_checking
        [enabled | disabled]
    monitor
        [name]
    profiles
        [none | profile_name]
    queue_depth_limit
        [integer]
    queue_on_connection_limit
        [enabled | disabled]
    queue_time_limit
        [integer]
    reselect_tries
        [integer]
    service_down_action
        [drop | none | reselect | reset]
    slow_ramp_time
        [integer]
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "modify",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
                "allow_nat": allow_nat,
                "allow_snat": allow_snat,
                "description": description,
                "gateway_failsafe_device": gateway_failsafe_device,
                "ignore_persisted_weight": ignore_persisted_weight,
                "ip_tos_client:": ip_tos_to_client,
                "ip_tos_server": ip_tos_to_server,
                "link_qos_to_client": link_qos_to_client,
                "link_qos_to_server": link_qos_to_server,
                "load_balancing_mode": load_balancing_mode,
                "min_active_members": min_active_members,
                "min_up_members": min_up_members,
                "min_up_members_checking": min_up_members_checking,
                "monitor": monitor,
                "profiles": profiles,
                "queue_depth_limit": queue_depth_limit,
                "queue_on_connection_limit": queue_on_connection_limit,
                "queue_time_limit": queue_time_limit,
                "reselect_tries": reselect_tries,
                "service_down_action": service_down_action,
                "slow_ramp_time": slow_ramp_time,
            },
        )
    existing = __salt__["bigip.list_pool"](hostname, username, password, name)
    if existing["code"] == 200:
        modified = __salt__["bigip.modify_pool"](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            allow_nat=allow_nat,
            allow_snat=allow_snat,
            description=description,
            gateway_failsafe_device=gateway_failsafe_device,
            ignore_persisted_weight=ignore_persisted_weight,
            ip_tos_to_client=ip_tos_to_client,
            ip_tos_to_server=ip_tos_to_server,
            link_qos_to_client=link_qos_to_client,
            link_qos_to_server=link_qos_to_server,
            load_balancing_mode=load_balancing_mode,
            min_active_members=min_active_members,
            min_up_members=min_up_members,
            min_up_members_action=min_up_members_action,
            min_up_members_checking=min_up_members_checking,
            monitor=monitor,
            profiles=profiles,
            queue_depth_limit=queue_depth_limit,
            queue_on_connection_limit=queue_on_connection_limit,
            queue_time_limit=queue_time_limit,
            reselect_tries=reselect_tries,
            service_down_action=service_down_action,
            slow_ramp_time=slow_ramp_time,
        )
        if modified["code"] == 200:
            del existing["content"]["membersReference"]
            del modified["content"]["membersReference"]
            del existing["content"]["selfLink"]
            del modified["content"]["selfLink"]
            ret = _check_for_changes("Pool", ret, existing, modified)
        else:
            ret = _load_result(modified, ret)
    elif existing["code"] == 404:
        ret["comment"] = "A pool with this name was not found."
    else:
        ret = _load_result(existing, ret)
    return ret
def delete_pool(hostname, username, password, name):
    """
    Delete an existing pool.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool which will be deleted
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "delete",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
            },
        )
    existing = __salt__["bigip.list_pool"](hostname, username, password, name)
    if existing["code"] == 200:
        deleted = __salt__["bigip.delete_pool"](hostname, username, password, name)
        if deleted["code"] == 200:
            ret["result"] = True
            ret["comment"] = "Pool was successfully deleted."
            ret["changes"]["old"] = existing["content"]
            ret["changes"]["new"] = {}
        else:
            ret = _load_result(deleted, ret)
    elif existing["code"] == 404:
        ret["result"] = True
        ret["comment"] = "This pool already does not exist. No changes made."
        ret["changes"]["old"] = {}
        ret["changes"]["new"] = {}
    else:
        ret = _load_result(existing, ret)
    return ret
def manage_pool_members(hostname, username, password, name, members):
    """
    Manage the members of an existing pool.  This function replaces all current pool members.
    Only the parameters specified are enforced.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool to modify
    members
        list of pool members to manage.
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "manage",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
                "members": members,
            },
        )
    existing = __salt__["bigip.list_pool"](hostname, username, password, name)
    if existing["code"] == 200:
        current_members = existing["content"]["membersReference"]["items"]
        modified = __salt__["bigip.replace_pool_members"](
            hostname, username, password, name, members
        )
        if modified["code"] == 200:
            new_listing = __salt__["bigip.list_pool"](
                hostname, username, password, name
            )
            if new_listing["code"] != 200:
                ret = _load_result(new_listing, ret)
                ret["comment"] = (
                    "modification of the pool was successful but an error occurred upon"
                    " retrieving new listing."
                )
                return ret
            new_members = new_listing["content"]["membersReference"]["items"]
            for current_member in current_members:
                del current_member["generation"]
            for new_member in new_members:
                del new_member["generation"]
            ret = _check_for_changes(
                "Pool Membership", ret, current_members, new_members
            )
        else:
            ret = _load_result(modified, ret)
    elif existing["code"] == 404:
        ret["comment"] = "A pool with this name was not found."
    else:
        ret = _load_result(existing, ret)
    return ret
def add_pool_member(hostname, username, password, name, member):
    """
    A function to connect to a bigip device and add a new member to an existing pool.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool to modify
    member
        The member to add to the pool
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "add",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
                "members": member,
            },
        )
    existing_pool = __salt__["bigip.list_pool"](hostname, username, password, name)
    if existing_pool["code"] == 200:
        current_members = existing_pool["content"]["membersReference"]["items"]
        exists = False
        for current_member in current_members:
            if current_member["name"] == member["name"]:
                exists = True
                break
        if exists:
            ret["result"] = True
            ret[
                "comment"
            ] = "Member: {name} already exists within this pool.  No changes made.".format(
                name=member["name"]
            )
            ret["changes"]["old"] = {}
            ret["changes"]["new"] = {}
        else:
            new_member = __salt__["bigip.add_pool_member"](
                hostname, username, password, name, member
            )
            if new_member["code"] == 200:
                ret["result"] = True
                ret[
                    "comment"
                ] = "Member: {name} has been successfully added to the pool.".format(
                    name=member["name"]
                )
                ret["changes"]["old"] = {}
                pool_listing = __salt__["bigip.list_pool"](
                    hostname, username, password, name
                )
                if pool_listing["code"] != 200:
                    ret = _load_result(new_member, ret)
                    return ret
                members = pool_listing["content"]["membersReference"]["items"]
                for current_member in members:
                    if current_member["name"] == member["name"]:
                        added_member = current_member
                        break
                ret["changes"]["new"] = added_member
            else:
                ret = _load_result(new_member, ret)
    elif existing_pool["code"] == 404:
        ret["comment"] = "A pool with this name was not found."
    else:
        ret = _load_result(existing_pool, ret)
    return ret
def modify_pool_member(
    hostname,
    username,
    password,
    name,
    member,
    connection_limit=None,
    description=None,
    dynamic_ratio=None,
    inherit_profile=None,
    logging=None,
    monitor=None,
    priority_group=None,
    profiles=None,
    rate_limit=None,
    ratio=None,
    session=None,
    member_state=None,
):
    """
    A function to connect to a bigip device and modify a member of an existing pool.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool to modify
    member
        The member modify
    connection_limit
        [integer]
    description
        [string]
    dynamic_ratio
        [integer]
    inherit_profile
        [enabled | disabled]
    logging
        [enabled | disabled]
    monitor
        [name]
    priority_group
        [integer]
    profiles
        [none | profile_name]
    rate_limit
        [integer]
    ratio
        [integer]
    session
        [user-enabled | user-disabled]
    member_state (state)
        [ user-up | user-down ]
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "modify",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
                "members": member,
            },
        )
    existing_pool = __salt__["bigip.list_pool"](hostname, username, password, name)
    if existing_pool["code"] == 200:
        current_members = existing_pool["content"]["membersReference"]["items"]
        exists = False
        for current_member in current_members:
            if current_member["name"] == member:
                exists = True
                existing_member = current_member
                break
        if exists:
            modified = __salt__["bigip.modify_pool_member"](
                hostname=hostname,
                username=username,
                password=password,
                name=name,
                member=member,
                connection_limit=connection_limit,
                description=description,
                dynamic_ratio=dynamic_ratio,
                inherit_profile=inherit_profile,
                logging=logging,
                monitor=monitor,
                priority_group=priority_group,
                profiles=profiles,
                rate_limit=rate_limit,
                ratio=ratio,
                session=session,
                state=member_state,
            )
            new_pool = __salt__["bigip.list_pool"](hostname, username, password, name)
            if modified["code"] == 200 and modified["code"] == 200:
                new_members = new_pool["content"]["membersReference"]["items"]
                for new_member in new_members:
                    if new_member["name"] == member:
                        modified_member = new_member
                        break
                old = {"content": existing_member}
                new = {"content": modified_member}
                ret = _check_for_changes(
                    "Pool Member: {member}".format(member=member), ret, old, new
                )
            else:
                ret = _load_result(modified, ret)
        else:
            ret[
                "comment"
            ] = "Member: {name} does not exists within this pool.  No changes made.".format(
                name=member["name"]
            )
    elif existing_pool["code"] == 404:
        ret["comment"] = "A pool with this name was not found."
    else:
        ret = _load_result(existing_pool, ret)
    return ret
def delete_pool_member(hostname, username, password, name, member):
    """
    Delete an existing pool member.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool to be modified
    member
        The name of the member to delete from the pool
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "delete",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
                "members": member,
            },
        )
    existing = __salt__["bigip.list_pool"](hostname, username, password, name)
    if existing["code"] == 200:
        current_members = existing["content"]["membersReference"]["items"]
        exists = False
        for current_member in current_members:
            if current_member["name"] == member:
                exists = True
                existing_member = current_member
                break
        if exists:
            deleted = __salt__["bigip.delete_pool_member"](
                hostname, username, password, name, member
            )
            if deleted["code"] == 200:
                ret["result"] = True
                ret[
                    "comment"
                ] = "Pool Member: {member} was successfully deleted.".format(
                    member=member
                )
                ret["changes"]["old"] = existing_member
                ret["changes"]["new"] = {}
        else:
            ret["result"] = True
            ret["comment"] = "This pool member already does not exist. No changes made."
            ret["changes"]["old"] = {}
            ret["changes"]["new"] = {}
    else:
        ret = _load_result(existing, ret)
    return ret
def list_virtual(hostname, username, password, name):
    """
    A function to list a specific virtual.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the virtual to list
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "list",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
            },
        )
    response = __salt__["bigip.list_virtual"](hostname, username, password, name)
    return _load_result(response, ret)
def create_virtual(
    hostname,
    username,
    password,
    name,
    destination,
    pool=None,
    address_status=None,
    auto_lasthop=None,
    bwc_policy=None,
    cmp_enabled=None,
    connection_limit=None,
    dhcp_relay=None,
    description=None,
    fallback_persistence=None,
    flow_eviction_policy=None,
    gtm_score=None,
    ip_forward=None,
    ip_protocol=None,
    internal=None,
    twelve_forward=None,
    last_hop_pool=None,
    mask=None,
    mirror=None,
    nat64=None,
    persist=None,
    profiles=None,
    policies=None,
    rate_class=None,
    rate_limit=None,
    rate_limit_mode=None,
    rate_limit_dst=None,
    rate_limit_src=None,
    rules=None,
    related_rules=None,
    reject=None,
    source=None,
    source_address_translation=None,
    source_port=None,
    virtual_state=None,
    traffic_classes=None,
    translate_address=None,
    translate_port=None,
    vlans=None,
):
    """
    A function to connect to a bigip device and create a virtual server if it does not already exists.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the virtual to create
    destination
        [ [virtual_address_name:port] | [ipv4:port] | [ipv6.port] ]
    pool
        [ [pool_name] | none]
    address_status
        [yes | no]
    auto_lasthop
        [default | enabled | disabled ]
    bwc_policy
        [none] | string]
    cmp_enabled
        [yes | no]
    dhcp_relay
        [yes | no}
    connection_limit
        [integer]
    description
        [string]
    state
        [disabled | enabled]
    fallback_persistence
        [none | [profile name] ]
    flow_eviction_policy
        [none | [eviction policy name] ]
    gtm_score
        [integer]
    ip_forward
        [yes | no]
    ip_protocol
        [any | protocol]
    internal
        [yes | no]
    twelve_forward(12-forward)
        [yes | no]
    last_hop-pool
        [ [pool_name] | none]
    mask
        { [ipv4] | [ipv6] }
    mirror
        { [disabled | enabled | none] }
    nat64
        [enabled | disabled]
    persist
        [list]
    profiles
        [none | default | list ]
    policies
        [none | default | list ]
    rate_class
        [name]
    rate_limit
        [integer]
    rate_limit-mode
        [destination | object | object-destination |
        object-source | object-source-destination |
        source | source-destination]
    rate_limit-dst
        [integer]
    rate_limit-src
        [integer]
    rules
        [none | list ]
    related_rules
        [none | list ]
    reject
        [yes | no]
    source
        { [ipv4[/prefixlen]] | [ipv6[/prefixlen]] }
    source_address_translation
        [none | snat:pool_name | lsn | automap | dictionary ]
    source_port
        [change | preserve | preserve-strict]
    state
        [enabled | disabled]
    traffic_classes
        [none | default | list ]
    translate_address
        [enabled | disabled]
    translate_port
        [enabled | disabled]
    vlans
        [none | default | dictionary]
        vlan_ids
            [ list]
        enabled
            [ true | false ]
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "create",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
                "destination": destination,
                "pool": pool,
                "address_status": address_status,
                "auto_lasthop": auto_lasthop,
                "bwc_policy": bwc_policy,
                "cmp_enabled": cmp_enabled,
                "connection_limit": connection_limit,
                "dhcp_relay": dhcp_relay,
                "description": description,
                "fallback_persistence": fallback_persistence,
                "flow_eviction_policy": flow_eviction_policy,
                "gtm_score": gtm_score,
                "ip_forward": ip_forward,
                "ip_protocol": ip_protocol,
                "internal": internal,
                "twelve_forward": twelve_forward,
                "last_hop_pool": last_hop_pool,
                "mask": mask,
                "mirror": mirror,
                "nat64": nat64,
                "persist": persist,
                "profiles": profiles,
                "policies": policies,
                "rate_class": rate_class,
                "rate_limit": rate_limit,
                "rate_limit_mode": rate_limit_mode,
                "rate_limit_dst": rate_limit_dst,
                "rate_limit_src": rate_limit_src,
                "rules": rules,
                "related_rules": related_rules,
                "reject": reject,
                "source": source,
                "source_address_translation": source_address_translation,
                "source_port": source_port,
                "virtual_state": virtual_state,
                "traffic_classes": traffic_classes,
                "translate_address": translate_address,
                "translate_port": translate_port,
                "vlans": vlans,
            },
        )
    existing = __salt__["bigip.list_virtual"](hostname, username, password, name)
    if existing["code"] == 200:
        ret["result"] = True
        ret["comment"] = "A virtual by this name currently exists.  No change made."
    elif existing["code"] == 404:
        virtual = __salt__["bigip.create_virtual"](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            destination=destination,
            description=description,
            pool=pool,
            address_status=address_status,
            auto_lasthop=auto_lasthop,
            bwc_policy=bwc_policy,
            cmp_enabled=cmp_enabled,
            connection_limit=connection_limit,
            dhcp_relay=dhcp_relay,
            fallback_persistence=fallback_persistence,
            flow_eviction_policy=flow_eviction_policy,
            gtm_score=gtm_score,
            ip_forward=ip_forward,
            ip_protocol=ip_protocol,
            internal=internal,
            twelve_forward=twelve_forward,
            last_hop_pool=last_hop_pool,
            mask=mask,
            mirror=mirror,
            nat64=nat64,
            persist=persist,
            profiles=profiles,
            policies=policies,
            rate_class=rate_class,
            rate_limit=rate_limit,
            rate_limit_mode=rate_limit_mode,
            rate_limit_dst=rate_limit_dst,
            rate_limit_src=rate_limit_src,
            rules=rules,
            related_rules=related_rules,
            reject=reject,
            source=source,
            source_address_translation=source_address_translation,
            source_port=source_port,
            state=virtual_state,
            traffic_classes=traffic_classes,
            translate_address=translate_address,
            translate_port=translate_port,
            vlans=vlans,
        )
        if virtual["code"] == 200:
            ret["result"] = True
            ret["changes"]["old"] = {}
            ret["changes"]["new"] = virtual["content"]
            ret["comment"] = "Virtual was successfully created."
        else:
            ret = _load_result(existing, ret)
    else:
        ret = _load_result(existing, ret)
    return ret
def manage_virtual(
    hostname,
    username,
    password,
    name,
    destination,
    pool=None,
    address_status=None,
    auto_lasthop=None,
    bwc_policy=None,
    cmp_enabled=None,
    connection_limit=None,
    dhcp_relay=None,
    description=None,
    fallback_persistence=None,
    flow_eviction_policy=None,
    gtm_score=None,
    ip_forward=None,
    ip_protocol=None,
    internal=None,
    twelve_forward=None,
    last_hop_pool=None,
    mask=None,
    mirror=None,
    nat64=None,
    persist=None,
    profiles=None,
    policies=None,
    rate_class=None,
    rate_limit=None,
    rate_limit_mode=None,
    rate_limit_dst=None,
    rate_limit_src=None,
    rules=None,
    related_rules=None,
    reject=None,
    source=None,
    source_address_translation=None,
    source_port=None,
    virtual_state=None,
    traffic_classes=None,
    translate_address=None,
    translate_port=None,
    vlans=None,
):
    """
    Manage a virtual server.  If a virtual does not exists it will be created, otherwise only the
    parameters specified will be enforced.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the virtual to create
    destination
        [ [virtual_address_name:port] | [ipv4:port] | [ipv6.port] ]
    pool
        [ [pool_name] | none]
    address_status
        [yes | no]
    auto_lasthop
        [default | enabled | disabled ]
    bwc_policy
        [none] | string]
    cmp_enabled
        [yes | no]
    dhcp_relay
        [yes | no}
    connection_limit
        [integer]
    description
        [string]
    state
        [disabled | enabled]
    fallback_persistence
        [none | [profile name] ]
    flow_eviction_policy
        [none | [eviction policy name] ]
    gtm_score
        [integer]
    ip_forward
        [yes | no]
    ip_protocol
        [any | protocol]
    internal
        [yes | no]
    twelve_forward(12-forward)
        [yes | no]
    last_hop-pool
        [ [pool_name] | none]
    mask
        { [ipv4] | [ipv6] }
    mirror
        { [disabled | enabled | none] }
    nat64
        [enabled | disabled]
    persist
        [list]
    profiles
        [none | default | list ]
    policies
        [none | default | list ]
    rate_class
        [name]
    rate_limit
        [integer]
    rate_limit-mode
        [destination | object | object-destination |
        object-source | object-source-destination |
        source | source-destination]
    rate_limit-dst
        [integer]
    rate_limit-src
        [integer]
    rules
        [none | list ]
    related_rules
        [none | list ]
    reject
        [yes | no]
    source
        { [ipv4[/prefixlen]] | [ipv6[/prefixlen]] }
    source_address_translation
        [none | snat:pool_name | lsn | automap | dictionary ]
    source_port
        [change | preserve | preserve-strict]
    state
        [enabled | disabled]
    traffic_classes
        [none | default | list ]
    translate_address
        [enabled | disabled]
    translate_port
        [enabled | disabled]
    vlans
        [none | default | dictionary]
        vlan_ids
            [ list]
        enabled
            [ true | false ]
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "manage",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
                "destination": destination,
                "pool": pool,
                "address_status": address_status,
                "auto_lasthop": auto_lasthop,
                "bwc_policy": bwc_policy,
                "cmp_enabled": cmp_enabled,
                "connection_limit": connection_limit,
                "dhcp_relay": dhcp_relay,
                "description": description,
                "fallback_persistence": fallback_persistence,
                "flow_eviction_policy": flow_eviction_policy,
                "gtm_score": gtm_score,
                "ip_forward": ip_forward,
                "ip_protocol": ip_protocol,
                "internal": internal,
                "twelve_forward": twelve_forward,
                "last_hop_pool": last_hop_pool,
                "mask": mask,
                "mirror": mirror,
                "nat64": nat64,
                "persist": persist,
                "profiles": profiles,
                "policies": policies,
                "rate_class": rate_class,
                "rate_limit": rate_limit,
                "rate_limit_mode": rate_limit_mode,
                "rate_limit_dst": rate_limit_dst,
                "rate_limit_src": rate_limit_src,
                "rules": rules,
                "related_rules": related_rules,
                "reject": reject,
                "source": source,
                "source_address_translation": source_address_translation,
                "source_port": source_port,
                "virtual_state": virtual_state,
                "traffic_classes": traffic_classes,
                "translate_address": translate_address,
                "translate_port": translate_port,
                "vlans": vlans,
            },
        )
    existing = __salt__["bigip.list_virtual"](hostname, username, password, name)
    if existing["code"] == 200:
        modified = __salt__["bigip.modify_virtual"](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            destination=destination,
            description=description,
            pool=pool,
            address_status=address_status,
            auto_lasthop=auto_lasthop,
            bwc_policy=bwc_policy,
            cmp_enabled=cmp_enabled,
            connection_limit=connection_limit,
            dhcp_relay=dhcp_relay,
            fallback_persistence=fallback_persistence,
            flow_eviction_policy=flow_eviction_policy,
            gtm_score=gtm_score,
            ip_forward=ip_forward,
            ip_protocol=ip_protocol,
            internal=internal,
            twelve_forward=twelve_forward,
            last_hop_pool=last_hop_pool,
            mask=mask,
            mirror=mirror,
            nat64=nat64,
            persist=persist,
            profiles=profiles,
            policies=policies,
            rate_class=rate_class,
            rate_limit=rate_limit,
            rate_limit_mode=rate_limit_mode,
            rate_limit_dst=rate_limit_dst,
            rate_limit_src=rate_limit_src,
            rules=rules,
            related_rules=related_rules,
            reject=reject,
            source=source,
            source_address_translation=source_address_translation,
            source_port=source_port,
            state=virtual_state,
            traffic_classes=traffic_classes,
            translate_address=translate_address,
            translate_port=translate_port,
            vlans=vlans,
        )
        if modified["code"] == 200:
            relisting = __salt__["bigip.list_virtual"](
                hostname, username, password, name
            )
            if relisting["code"] == 200:
                relisting = _strip_key(relisting, "generation")
                existing = _strip_key(existing, "generation")
                ret = _check_for_changes("Virtual", ret, existing, relisting)
            else:
                ret = _load_result(relisting, ret)
        else:
            ret = _load_result(modified, ret)
    elif existing["code"] == 404:
        virtual = __salt__["bigip.create_virtual"](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            destination=destination,
            description=description,
            pool=pool,
            address_status=address_status,
            auto_lasthop=auto_lasthop,
            bwc_policy=bwc_policy,
            cmp_enabled=cmp_enabled,
            connection_limit=connection_limit,
            dhcp_relay=dhcp_relay,
            fallback_persistence=fallback_persistence,
            flow_eviction_policy=flow_eviction_policy,
            gtm_score=gtm_score,
            ip_forward=ip_forward,
            ip_protocol=ip_protocol,
            internal=internal,
            twelve_forward=twelve_forward,
            last_hop_pool=last_hop_pool,
            mask=mask,
            mirror=mirror,
            nat64=nat64,
            persist=persist,
            profiles=profiles,
            policies=policies,
            rate_class=rate_class,
            rate_limit=rate_limit,
            rate_limit_mode=rate_limit_mode,
            rate_limit_dst=rate_limit_dst,
            rate_limit_src=rate_limit_src,
            rules=rules,
            related_rules=related_rules,
            reject=reject,
            source=source,
            source_address_translation=source_address_translation,
            source_port=source_port,
            state=virtual_state,
            traffic_classes=traffic_classes,
            translate_address=translate_address,
            translate_port=translate_port,
            vlans=vlans,
        )
        if virtual["code"] == 200:
            ret["result"] = True
            ret["changes"]["old"] = {}
            ret["changes"]["new"] = virtual["content"]
            ret[
                "comment"
            ] = "Virtual was successfully created and enforced to the desired state."
        else:
            ret = _load_result(virtual, ret)
    else:
        ret = _load_result(existing, ret)
    return ret
def modify_virtual(
    hostname,
    username,
    password,
    name,
    destination,
    pool=None,
    address_status=None,
    auto_lasthop=None,
    bwc_policy=None,
    cmp_enabled=None,
    connection_limit=None,
    dhcp_relay=None,
    description=None,
    fallback_persistence=None,
    flow_eviction_policy=None,
    gtm_score=None,
    ip_forward=None,
    ip_protocol=None,
    internal=None,
    twelve_forward=None,
    last_hop_pool=None,
    mask=None,
    mirror=None,
    nat64=None,
    persist=None,
    profiles=None,
    policies=None,
    rate_class=None,
    rate_limit=None,
    rate_limit_mode=None,
    rate_limit_dst=None,
    rate_limit_src=None,
    rules=None,
    related_rules=None,
    reject=None,
    source=None,
    source_address_translation=None,
    source_port=None,
    virtual_state=None,
    traffic_classes=None,
    translate_address=None,
    translate_port=None,
    vlans=None,
):
    """
    Modify an virtual server.  modify an existing virtual.  Only parameters specified will be enforced.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the virtual to create
    destination
        [ [virtual_address_name:port] | [ipv4:port] | [ipv6.port] ]
    pool
        [ [pool_name] | none]
    address_status
        [yes | no]
    auto_lasthop
        [default | enabled | disabled ]
    bwc_policy
        [none] | string]
    cmp_enabled
        [yes | no]
    dhcp_relay
        [yes | no}
    connection_limit
        [integer]
    description
        [string]
    state
        [disabled | enabled]
    fallback_persistence
        [none | [profile name] ]
    flow_eviction_policy
        [none | [eviction policy name] ]
    gtm_score
        [integer]
    ip_forward
        [yes | no]
    ip_protocol
        [any | protocol]
    internal
        [yes | no]
    twelve_forward(12-forward)
        [yes | no]
    last_hop-pool
        [ [pool_name] | none]
    mask
        { [ipv4] | [ipv6] }
    mirror
        { [disabled | enabled | none] }
    nat64
        [enabled | disabled]
    persist
        [list]
    profiles
        [none | default | list ]
    policies
        [none | default | list ]
    rate_class
        [name]
    rate_limit
        [integer]
    rate_limit-mode
        [destination | object | object-destination |
        object-source | object-source-destination |
        source | source-destination]
    rate_limit_dst
        [integer]
    rate_limit_src
        [integer]
    rules
        [none | list ]
    related_rules
        [none | list ]
    reject
        [yes | no]
    source
        { [ipv4[/prefixlen]] | [ipv6[/prefixlen]] }
    source_address_translation
        [none | snat:pool_name | lsn | automap | dictionary ]
    source_port
        [change | preserve | preserve-strict]
    state
        [enabled | disabled]
    traffic_classes
        [none | default | list ]
    translate_address
        [enabled | disabled]
    translate_port
        [enabled | disabled]
    vlans
        [none | default | dictionary ]
        vlan_ids
            [ list]
        enabled
            [ true | false ]
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "modify",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
                "destination": destination,
                "pool": pool,
                "address_status": address_status,
                "auto_lasthop": auto_lasthop,
                "bwc_policy": bwc_policy,
                "cmp_enabled": cmp_enabled,
                "connection_limit": connection_limit,
                "dhcp_relay": dhcp_relay,
                "description": description,
                "fallback_persistence": fallback_persistence,
                "flow_eviction_policy": flow_eviction_policy,
                "gtm_score": gtm_score,
                "ip_forward": ip_forward,
                "ip_protocol": ip_protocol,
                "internal": internal,
                "twelve_forward": twelve_forward,
                "last_hop_pool": last_hop_pool,
                "mask": mask,
                "mirror": mirror,
                "nat64": nat64,
                "persist": persist,
                "profiles": profiles,
                "policies": policies,
                "rate_class": rate_class,
                "rate_limit": rate_limit,
                "rate_limit_mode": rate_limit_mode,
                "rate_limit_dst": rate_limit_dst,
                "rate_limit_src": rate_limit_src,
                "rules": rules,
                "related_rules": related_rules,
                "reject": reject,
                "source": source,
                "source_address_translation": source_address_translation,
                "source_port": source_port,
                "virtual_state": virtual_state,
                "traffic_classes": traffic_classes,
                "translate_address": translate_address,
                "translate_port": translate_port,
                "vlans": vlans,
            },
        )
    existing = __salt__["bigip.list_virtual"](hostname, username, password, name)
    if existing["code"] == 200:
        modified = __salt__["bigip.modify_virtual"](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            destination=destination,
            description=description,
            pool=pool,
            address_status=address_status,
            auto_lasthop=auto_lasthop,
            bwc_policy=bwc_policy,
            cmp_enabled=cmp_enabled,
            connection_limit=connection_limit,
            dhcp_relay=dhcp_relay,
            fallback_persistence=fallback_persistence,
            flow_eviction_policy=flow_eviction_policy,
            gtm_score=gtm_score,
            ip_forward=ip_forward,
            ip_protocol=ip_protocol,
            internal=internal,
            twelve_forward=twelve_forward,
            last_hop_pool=last_hop_pool,
            mask=mask,
            mirror=mirror,
            nat64=nat64,
            persist=persist,
            profiles=profiles,
            policies=policies,
            rate_class=rate_class,
            rate_limit=rate_limit,
            rate_limit_mode=rate_limit_mode,
            rate_limit_dst=rate_limit_dst,
            rate_limit_src=rate_limit_src,
            rules=rules,
            related_rules=related_rules,
            reject=reject,
            source=source,
            source_address_translation=source_address_translation,
            source_port=source_port,
            state=virtual_state,
            traffic_classes=traffic_classes,
            translate_address=translate_address,
            translate_port=translate_port,
            vlans=vlans,
        )
        if modified["code"] == 200:
            relisting = __salt__["bigip.list_virtual"](
                hostname, username, password, name
            )
            if relisting["code"] == 200:
                relisting = _strip_key(relisting, "generation")
                existing = _strip_key(existing, "generation")
                ret = _check_for_changes("Virtual", ret, existing, relisting)
            else:
                ret = _load_result(relisting, ret)
        else:
            ret = _load_result(modified, ret)
    elif existing["code"] == 404:
        ret["comment"] = "A Virtual with this name was not found."
    else:
        ret = _load_result(existing, ret)
    return ret
def delete_virtual(hostname, username, password, name):
    """
    Delete an existing virtual.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the virtual which will be deleted
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "delete",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
            },
        )
    existing = __salt__["bigip.list_virtual"](hostname, username, password, name)
    if existing["code"] == 200:
        deleted = __salt__["bigip.delete_virtual"](hostname, username, password, name)
        if deleted["code"] == 200:
            ret["result"] = True
            ret["comment"] = "Virtual was successfully deleted."
            ret["changes"]["old"] = existing["content"]
            ret["changes"]["new"] = {}
        else:
            ret = _load_result(deleted, ret)
    elif existing["code"] == 404:
        ret["result"] = True
        ret["comment"] = "This virtual already does not exist. No changes made."
        ret["changes"]["old"] = {}
        ret["changes"]["new"] = {}
    else:
        ret = _load_result(existing, ret)
    return ret
def list_monitor(hostname, username, password, monitor_type, name):
    """
    A function to list an existing monitor.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    monitor_type
        The type of monitor to list
    name
        The name of the monitor to list
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "list",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "monitor_type": monitor_type,
                "name": name,
            },
        )
    response = __salt__["bigip.list_monitor"](
        hostname, username, password, monitor_type, name
    )
    return _load_result(response, ret)
def create_monitor(hostname, username, password, monitor_type, name, **kwargs):
    """
    A function to connect to a bigip device and create a monitor.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    monitor_type
        The type of monitor to create
    name
        The name of the monitor to create
    kwargs
        [ arg=val ] ...
        Consult F5 BIGIP user guide for specific options for each monitor type.
        Typically, tmsh arg names are used.
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        params = {
            "hostname": hostname,
            "username": username,
            "password": password,
            "monitor_type": monitor_type,
            "name": name,
        }
        for key, value in kwargs.items():
            params[key] = value
        return _test_output(ret, "create", params)
    existing = __salt__["bigip.list_monitor"](
        hostname, username, password, monitor_type, name
    )
    if existing["code"] == 200:
        ret["result"] = True
        ret["comment"] = "A monitor by this name currently exists.  No change made."
    elif existing["code"] == 404:
        response = __salt__["bigip.create_monitor"](
            hostname, username, password, monitor_type, name, **kwargs
        )
        if response["code"] == 200:
            ret["result"] = True
            ret["changes"]["old"] = {}
            ret["changes"]["new"] = response["content"]
            ret["comment"] = "Monitor was successfully created."
        else:
            ret = _load_result(response, ret)
    else:
        ret = _load_result(existing, ret)
    return ret
def manage_monitor(hostname, username, password, monitor_type, name, **kwargs):
    """
    Create a new monitor if a monitor of this type and name does not already exists.  If it does exists, only
    the parameters specified will be enforced.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    monitor_type
        The type of monitor to create
    name
        The name of the monitor to create
    kwargs
        [ arg=val ] ...
        Consult F5 BIGIP user guide for specific options for each monitor type.
        Typically, tmsh arg names are used.
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        params = {
            "hostname": hostname,
            "username": username,
            "password": password,
            "monitor_type": monitor_type,
            "name": name,
        }
        for key, value in kwargs.items():
            params[key] = value
        return _test_output(ret, "manage", params)
    existing = __salt__["bigip.list_monitor"](
        hostname, username, password, monitor_type, name
    )
    if existing["code"] == 200:
        modified = __salt__["bigip.modify_monitor"](
            hostname, username, password, monitor_type, name, **kwargs
        )
        if modified["code"] == 200:
            del existing["content"]["selfLink"]
            del modified["content"]["selfLink"]
            ret = _check_for_changes("Monitor", ret, existing, modified)
        else:
            ret = _load_result(modified, ret)
    elif existing["code"] == 404:
        response = __salt__["bigip.create_monitor"](
            hostname, username, password, monitor_type, name, **kwargs
        )
        if response["code"] == 200:
            ret["result"] = True
            ret["changes"]["old"] = {}
            ret["changes"]["new"] = response["content"]
            ret["comment"] = "Monitor was successfully created."
        else:
            ret = _load_result(response, ret)
    else:
        ret = _load_result(existing, ret)
    return ret
def modify_monitor(hostname, username, password, monitor_type, name, **kwargs):
    """
    Modify an existing monitor.  If it does exists, only
    the parameters specified will be enforced.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    monitor_type
        The type of monitor to create
    name
        The name of the monitor to create
    kwargs
        [ arg=val ] ...
        Consult F5 BIGIP user guide for specific options for each monitor type.
        Typically, tmsh arg names are used.
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        params = {
            "hostname": hostname,
            "username": username,
            "password": password,
            "monitor_type": monitor_type,
            "name": name,
        }
        for key, value in kwargs.items():
            params[key] = value
        return _test_output(ret, "modify", params)
    existing = __salt__["bigip.list_monitor"](
        hostname, username, password, monitor_type, name
    )
    if existing["code"] == 200:
        modified = __salt__["bigip.modify_monitor"](
            hostname, username, password, monitor_type, name, **kwargs
        )
        if modified["code"] == 200:
            del existing["content"]["selfLink"]
            del modified["content"]["selfLink"]
            ret = _check_for_changes("Monitor", ret, existing, modified)
        else:
            ret = _load_result(modified, ret)
    elif existing["code"] == 404:
        ret["comment"] = "A Monitor with this name was not found."
    else:
        ret = _load_result(existing, ret)
    return ret
def delete_monitor(hostname, username, password, monitor_type, name):
    """
    Modify an existing monitor.  If it does exists, only
    the parameters specified will be enforced.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    monitor_type
        The type of monitor to create
    name
        The name of the monitor to create
    kwargs
        [ arg=val ] ...
        Consult F5 BIGIP user guide for specific options for each monitor type.
        Typically, tmsh arg names are used.
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "delete",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "monitor_type": monitor_type,
                "name": name,
            },
        )
    existing = __salt__["bigip.list_monitor"](
        hostname, username, password, monitor_type, name
    )
    if existing["code"] == 200:
        deleted = __salt__["bigip.delete_monitor"](
            hostname, username, password, monitor_type, name
        )
        if deleted["code"] == 200:
            ret["result"] = True
            ret["comment"] = "Monitor was successfully deleted."
            ret["changes"]["old"] = existing["content"]
            ret["changes"]["new"] = {}
        else:
            ret = _load_result(deleted, ret)
    elif existing["code"] == 404:
        ret["result"] = True
        ret["comment"] = "This Monitor already does not exist. No changes made."
        ret["changes"]["old"] = {}
        ret["changes"]["new"] = {}
    else:
        ret = _load_result(existing, ret)
    return ret
def list_profile(hostname, username, password, profile_type, name):
    """
    A function to list an existing profile.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    profile_type
        The type of profile to list
    name
        The name of the profile to list
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "list",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "profile_type": profile_type,
                "name": name,
            },
        )
    response = __salt__["bigip.list_profile"](
        hostname, username, password, profile_type, name
    )
    return _load_result(response, ret)
def create_profile(hostname, username, password, profile_type, name, **kwargs):
    r"""
    A function to connect to a bigip device and create a profile.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    profile_type
        The type of profile to create
    name
        The name of the profile to create
    kwargs
        [ arg=val ] ...
        Consult F5 BIGIP user guide for specific options for each profile type.
        Typically, tmsh arg names are used.
    Special Characters ``|``, ``,`` and ``:`` must be escaped using ``\`` when
    used within strings.
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "create",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "profile_type": profile_type,
                "name": name,
            },
        )
    existing = __salt__["bigip.list_profile"](
        hostname, username, password, profile_type, name
    )
    if existing["code"] == 200:
        ret["result"] = True
        ret["comment"] = "A profile by this name currently exists.  No change made."
    elif existing["code"] == 404:
        response = __salt__["bigip.create_profile"](
            hostname, username, password, profile_type, name, **kwargs
        )
        if response["code"] == 200:
            ret["result"] = True
            ret["changes"]["old"] = {}
            ret["changes"]["new"] = response["content"]
            ret["comment"] = "Profile was successfully created."
        else:
            ret = _load_result(response, ret)
    else:
        ret = _load_result(existing, ret)
    return ret
def manage_profile(hostname, username, password, profile_type, name, **kwargs):
    """
    Create a new profile if a monitor of this type and name does not already exists.  If it does exists, only
    the parameters specified will be enforced.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    profile_type
        The type of profile to create
    name
        The name of the profile to create
    kwargs
        [ arg=val ] ...
        Consult F5 BIGIP user guide for specific options for each profile type.
        Typically, tmsh arg names are used.
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        params = {
            "hostname": hostname,
            "username": username,
            "password": password,
            "profile_type": profile_type,
            "name": name,
        }
        for key, value in kwargs.items():
            params[key] = value
        return _test_output(ret, "manage", params)
    existing = __salt__["bigip.list_profile"](
        hostname, username, password, profile_type, name
    )
    if existing["code"] == 200:
        modified = __salt__["bigip.modify_profile"](
            hostname, username, password, profile_type, name, **kwargs
        )
        if modified["code"] == 200:
            del existing["content"]["selfLink"]
            del modified["content"]["selfLink"]
            ret = _check_for_changes("Profile", ret, existing, modified)
        else:
            ret = _load_result(modified, ret)
    elif existing["code"] == 404:
        response = __salt__["bigip.create_profile"](
            hostname, username, password, profile_type, name, **kwargs
        )
        if response["code"] == 200:
            ret["result"] = True
            ret["changes"]["old"] = {}
            ret["changes"]["new"] = response["content"]
            ret["comment"] = "Profile was successfully created."
        else:
            ret = _load_result(existing, ret)
    else:
        ret = _load_result(existing, ret)
    return ret
def modify_profile(hostname, username, password, profile_type, name, **kwargs):
    """
    Modify an existing profile.  If it does exists, only
    the parameters specified will be enforced.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    profile_type
        The type of profile to create
    name
        The name of the profile to create
    kwargs
        [ arg=val ] ...
        Consult F5 BIGIP user guide for specific options for each monitor type.
        Typically, tmsh arg names are used.
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        params = {
            "hostname": hostname,
            "username": username,
            "password": password,
            "profile_type": profile_type,
            "name": name,
        }
        for key, value in kwargs.items():
            params[key] = value
        return _test_output(ret, "modify", params)
    existing = __salt__["bigip.list_profile"](
        hostname, username, password, profile_type, name
    )
    if existing["code"] == 200:
        modified = __salt__["bigip.modify_profile"](
            hostname, username, password, profile_type, name, **kwargs
        )
        if modified["code"] == 200:
            del existing["content"]["selfLink"]
            del modified["content"]["selfLink"]
            ret = _check_for_changes("Profile", ret, existing, modified)
        else:
            ret = _load_result(modified, ret)
    elif existing["code"] == 404:
        ret["comment"] = "A Profile with this name was not found."
    else:
        ret = _load_result(existing, ret)
    return ret
def delete_profile(hostname, username, password, profile_type, name):
    """
    Modify an existing profile.  If it does exists, only
    the parameters specified will be enforced.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    profile_type
        The type of profile to create
    name
        The name of the profile to create
    kwargs
        [ arg=val ] ...
        Consult F5 BIGIP user guide for specific options for each profile type.
        Typically, tmsh arg names are used.
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "delete",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "profile_type": profile_type,
                "name": name,
            },
        )
    existing = __salt__["bigip.list_profile"](
        hostname, username, password, profile_type, name
    )
    if existing["code"] == 200:
        deleted = __salt__["bigip.delete_profile"](
            hostname, username, password, profile_type, name
        )
        if deleted["code"] == 200:
            ret["result"] = True
            ret["comment"] = "Profile was successfully deleted."
            ret["changes"]["old"] = existing["content"]
            ret["changes"]["new"] = {}
        else:
            ret = _load_result(deleted, ret)
    elif existing["code"] == 404:
        ret["result"] = True
        ret["comment"] = "This Profile already does not exist. No changes made."
        ret["changes"]["old"] = {}
        ret["changes"]["new"] = {}
    else:
        ret = _load_result(existing, ret)
    return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
