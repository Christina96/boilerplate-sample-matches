<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for lxd_container.py & bigip.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for lxd_container.py & bigip.py
      </h3>
      <h1 align="center">
        1.0%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>lxd_container.py (2.1840873%)<TH>bigip.py (0.6698565%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match256248-0.html#0',2,'match256248-1.html#0',3)" NAME="0">(49-65)<TD><A HREF="javascript:ZweiFrames('match256248-0.html#0',2,'match256248-1.html#0',3)" NAME="0">(627-646)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>lxd_container.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Manage LXD containers.

.. versionadded:: 2019.2.0

.. note:

    - :ref:`pylxd` version 2 is required to let this work,
      currently only available via pip.

        To install on Ubuntu:

        $ apt-get install libssl-dev python-pip
        $ pip install -U pylxd

    - you need lxd installed on the minion
      for the init() and version() methods.

    - for the config_get() and config_get() methods
      you need to have lxd-client installed.

.. _pylxd: https://github.com/lxc/pylxd/blob/master/doc/source/installation.rst

:maintainer: Ren√© Jochum &lt;rene@jochums.at&gt;
:maturity: new
:depends: python-pylxd
:platform: Linux
&quot;&quot;&quot;


from salt.exceptions import CommandExecutionError, SaltInvocationError

__docformat__ = &quot;restructuredtext en&quot;

__virtualname__ = &quot;lxd_container&quot;

# Keep in sync with: https://github.com/lxc/lxd/blob/master/shared/status.go
CONTAINER_STATUS_RUNNING = 103
CONTAINER_STATUS_FROZEN = 110
CONTAINER_STATUS_STOPPED = 102


def __virtual__():
    &quot;&quot;&quot;
    Only load if the lxd module is available in __salt__
<A NAME="0"></A>    &quot;&quot;&quot;
    if &quot;lxd.version&quot; in __salt__:
        return __virtualname__
    return (F<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match256248-1.html#0',3,'match256248-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>alse, &quot;lxd module could not be loaded&quot;)


def present(
    name,
    running=None,
    source=None,
    profiles=None,
    config=None,
    devices=None,
    architecture=&quot;x86_64&quot;,
    ephemeral=False,
    restart_on_change=False,
    remote_addr=None,
    cert=None,
    key=None,
    verify_cert=</B></FONT>True,
):
    &quot;&quot;&quot;
    Create the named container if it does not exist

    name
        The name of the container to be created

    running : None
        * If ``True``, ensure that the container is running
        * If ``False``, ensure that the container is stopped
        * If ``None``, do nothing with regards to the running state of the
          container

    source : None
        Can be either a string containing an image alias:

        .. code-block:: none

             &quot;xenial/amd64&quot;

        or an dict with type &quot;image&quot; with alias:

        .. code-block:: python

            {&quot;type&quot;: &quot;image&quot;,
             &quot;alias&quot;: &quot;xenial/amd64&quot;}

        or image with &quot;fingerprint&quot;:

        .. code-block:: python

            {&quot;type&quot;: &quot;image&quot;,
             &quot;fingerprint&quot;: &quot;SHA-256&quot;}

        or image with &quot;properties&quot;:

        .. code-block:: python

            {&quot;type&quot;: &quot;image&quot;,
             &quot;properties&quot;: {
                &quot;os&quot;: &quot;ubuntu&quot;,
                &quot;release&quot;: &quot;14.04&quot;,
                &quot;architecture&quot;: &quot;x86_64&quot;
             }}

        or none:

        .. code-block:: python

            {&quot;type&quot;: &quot;none&quot;}

        or copy:

        .. code-block:: python

            {&quot;type&quot;: &quot;copy&quot;,
             &quot;source&quot;: &quot;my-old-container&quot;}

    profiles : ['default']
        List of profiles to apply on this container

    config :
        A config dict or None (None = unset).

        Can also be a list:

        .. code-block:: python

            [{'key': 'boot.autostart', 'value': 1},
             {'key': 'security.privileged', 'value': '1'}]

    devices :
        A device dict or None (None = unset).

    architecture : 'x86_64'
        Can be one of the following:

        * unknown
        * i686
        * x86_64
        * armv7l
        * aarch64
        * ppc
        * ppc64
        * ppc64le
        * s390x

    ephemeral : False
        Destroy this container after stop?

    restart_on_change : False
        Restart the container when we detect changes on the config or
        its devices?

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if you
        provide remote_addr!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Zertifikate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.
    &quot;&quot;&quot;
    if profiles is None:
        profiles = [&quot;default&quot;]

    if source is None:
        source = {}

    ret = {
        &quot;name&quot;: name,
        &quot;running&quot;: running,
        &quot;profiles&quot;: profiles,
        &quot;source&quot;: source,
        &quot;config&quot;: config,
        &quot;devices&quot;: devices,
        &quot;architecture&quot;: architecture,
        &quot;ephemeral&quot;: ephemeral,
        &quot;restart_on_change&quot;: restart_on_change,
        &quot;remote_addr&quot;: remote_addr,
        &quot;cert&quot;: cert,
        &quot;key&quot;: key,
        &quot;verify_cert&quot;: verify_cert,
        &quot;changes&quot;: {},
    }

    container = None
    try:
        container = __salt__[&quot;lxd.container_get&quot;](
            name, remote_addr, cert, key, verify_cert, _raw=True
        )
    except CommandExecutionError as e:
        return _error(ret, str(e))
    except SaltInvocationError as e:
        # Profile not found
        pass

    if container is None:
        if __opts__[&quot;test&quot;]:
            # Test is on, just return that we would create the container
            msg = 'Would create the container &quot;{}&quot;'.format(name)
            ret[&quot;changes&quot;] = {&quot;created&quot;: msg}
            if running is True:
                msg = msg + &quot; and start it.&quot;
                ret[&quot;changes&quot;][&quot;started&quot;] = 'Would start the container &quot;{}&quot;'.format(
                    name
                )

            ret[&quot;changes&quot;] = {&quot;created&quot;: msg}
            return _unchanged(ret, msg)

        # create the container
        try:
            __salt__[&quot;lxd.container_create&quot;](
                name,
                source,
                profiles,
                config,
                devices,
                architecture,
                ephemeral,
                True,  # Wait
                remote_addr,
                cert,
                key,
                verify_cert,
            )
        except CommandExecutionError as e:
            return _error(ret, str(e))

        msg = 'Created the container &quot;{}&quot;'.format(name)
        ret[&quot;changes&quot;] = {&quot;created&quot;: msg}

        if running is True:
            try:
                __salt__[&quot;lxd.container_start&quot;](
                    name, remote_addr, cert, key, verify_cert
                )
            except CommandExecutionError as e:
                return _error(ret, str(e))

            msg = msg + &quot; and started it.&quot;
            ret[&quot;changes&quot;] = {&quot;started&quot;: 'Started the container &quot;{}&quot;'.format(name)}

        return _success(ret, msg)

    # Container exists, lets check for differences
    new_profiles = set(map(str, profiles))
    old_profiles = set(map(str, container.profiles))

    container_changed = False

    profile_changes = []
    # Removed profiles
    for k in old_profiles.difference(new_profiles):
        if not __opts__[&quot;test&quot;]:
            profile_changes.append('Removed profile &quot;{}&quot;'.format(k))
            old_profiles.discard(k)
        else:
            profile_changes.append('Would remove profile &quot;{}&quot;'.format(k))

    # Added profiles
    for k in new_profiles.difference(old_profiles):
        if not __opts__[&quot;test&quot;]:
            profile_changes.append('Added profile &quot;{}&quot;'.format(k))
            old_profiles.add(k)
        else:
            profile_changes.append('Would add profile &quot;{}&quot;'.format(k))

    if profile_changes:
        container_changed = True
        ret[&quot;changes&quot;][&quot;profiles&quot;] = profile_changes
        container.profiles = list(old_profiles)

    # Config and devices changes
    config, devices = __salt__[&quot;lxd.normalize_input_values&quot;](config, devices)
    changes = __salt__[&quot;lxd.sync_config_devices&quot;](
        container, config, devices, __opts__[&quot;test&quot;]
    )
    if changes:
        container_changed = True
        ret[&quot;changes&quot;].update(changes)

    is_running = container.status_code == CONTAINER_STATUS_RUNNING

    if not __opts__[&quot;test&quot;]:
        try:
            __salt__[&quot;lxd.pylxd_save_object&quot;](container)
        except CommandExecutionError as e:
            return _error(ret, str(e))

    if running != is_running:
        if running is True:
            if __opts__[&quot;test&quot;]:
                changes[&quot;running&quot;] = &quot;Would start the container&quot;
                return _unchanged(
                    ret,
                    'Container &quot;{}&quot; would get changed and started.'.format(name),
                )
            else:
                container.start(wait=True)
                changes[&quot;running&quot;] = &quot;Started the container&quot;

        elif running is False:
            if __opts__[&quot;test&quot;]:
                changes[&quot;stopped&quot;] = &quot;Would stopped the container&quot;
                return _unchanged(
                    ret,
                    'Container &quot;{}&quot; would get changed and stopped.'.format(name),
                )
            else:
                container.stop(wait=True)
                changes[&quot;stopped&quot;] = &quot;Stopped the container&quot;

    if (
        (running is True or running is None)
        and is_running
        and restart_on_change
        and container_changed
    ):

        if __opts__[&quot;test&quot;]:
            changes[&quot;restarted&quot;] = &quot;Would restart the container&quot;
            return _unchanged(ret, 'Would restart the container &quot;{}&quot;'.format(name))
        else:
            container.restart(wait=True)
            changes[&quot;restarted&quot;] = 'Container &quot;{}&quot; has been restarted'.format(name)
            return _success(ret, 'Container &quot;{}&quot; has been restarted'.format(name))

    if not container_changed:
        return _success(ret, &quot;No changes&quot;)

    if __opts__[&quot;test&quot;]:
        return _unchanged(ret, 'Container &quot;{}&quot; would get changed.'.format(name))

    return _success(ret, &quot;{} changes&quot;.format(len(ret[&quot;changes&quot;].keys())))


def absent(name, stop=False, remote_addr=None, cert=None, key=None, verify_cert=True):
    &quot;&quot;&quot;
    Ensure a LXD container is not present, destroying it if present

    name :
        The name of the container to destroy

    stop :
        stop before destroying
        default: false

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if you
        provide remote_addr!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Zertifikate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.
    &quot;&quot;&quot;
    ret = {
        &quot;name&quot;: name,
        &quot;stop&quot;: stop,
        &quot;remote_addr&quot;: remote_addr,
        &quot;cert&quot;: cert,
        &quot;key&quot;: key,
        &quot;verify_cert&quot;: verify_cert,
        &quot;changes&quot;: {},
    }

    try:
        container = __salt__[&quot;lxd.container_get&quot;](
            name, remote_addr, cert, key, verify_cert, _raw=True
        )
    except CommandExecutionError as e:
        return _error(ret, str(e))
    except SaltInvocationError as e:
        # Container not found
        return _success(ret, 'Container &quot;{}&quot; not found.'.format(name))

    if __opts__[&quot;test&quot;]:
        ret[&quot;changes&quot;] = {&quot;removed&quot;: 'Container &quot;{}&quot; would get deleted.'.format(name)}
        return _unchanged(ret, ret[&quot;changes&quot;][&quot;removed&quot;])

    if stop and container.status_code == CONTAINER_STATUS_RUNNING:
        container.stop(wait=True)

    container.delete(wait=True)

    ret[&quot;changes&quot;][&quot;deleted&quot;] = 'Container &quot;{}&quot; has been deleted.'.format(name)
    return _success(ret, ret[&quot;changes&quot;][&quot;deleted&quot;])


def running(
    name, restart=False, remote_addr=None, cert=None, key=None, verify_cert=True
):
    &quot;&quot;&quot;
    Ensure a LXD container is running and restart it if restart is True

    name :
        The name of the container to start/restart.

    restart :
        restart the container if it is already started.

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if you
        provide remote_addr!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Zertifikate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.
    &quot;&quot;&quot;
    ret = {
        &quot;name&quot;: name,
        &quot;restart&quot;: restart,
        &quot;remote_addr&quot;: remote_addr,
        &quot;cert&quot;: cert,
        &quot;key&quot;: key,
        &quot;verify_cert&quot;: verify_cert,
        &quot;changes&quot;: {},
    }

    try:
        container = __salt__[&quot;lxd.container_get&quot;](
            name, remote_addr, cert, key, verify_cert, _raw=True
        )
    except CommandExecutionError as e:
        return _error(ret, str(e))
    except SaltInvocationError as e:
        # Container not found
        return _error(ret, 'Container &quot;{}&quot; not found'.format(name))

    is_running = container.status_code == CONTAINER_STATUS_RUNNING

    if is_running:
        if not restart:
            return _success(ret, 'The container &quot;{}&quot; is already running'.format(name))
        else:
            if __opts__[&quot;test&quot;]:
                ret[&quot;changes&quot;][&quot;restarted&quot;] = 'Would restart the container &quot;{}&quot;'.format(
                    name
                )
                return _unchanged(ret, ret[&quot;changes&quot;][&quot;restarted&quot;])
            else:
                container.restart(wait=True)
                ret[&quot;changes&quot;][&quot;restarted&quot;] = 'Restarted the container &quot;{}&quot;'.format(
                    name
                )
                return _success(ret, ret[&quot;changes&quot;][&quot;restarted&quot;])

    if __opts__[&quot;test&quot;]:
        ret[&quot;changes&quot;][&quot;started&quot;] = 'Would start the container &quot;{}&quot;'.format(name)
        return _unchanged(ret, ret[&quot;changes&quot;][&quot;started&quot;])

    container.start(wait=True)
    ret[&quot;changes&quot;][&quot;started&quot;] = 'Started the container &quot;{}&quot;'.format(name)
    return _success(ret, ret[&quot;changes&quot;][&quot;started&quot;])


def frozen(name, start=True, remote_addr=None, cert=None, key=None, verify_cert=True):
    &quot;&quot;&quot;
    Ensure a LXD container is frozen, start and freeze it if start is true

    name :
        The name of the container to freeze

    start :
        start and freeze it

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if you
        provide remote_addr!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Zertifikate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.
    &quot;&quot;&quot;
    ret = {
        &quot;name&quot;: name,
        &quot;start&quot;: start,
        &quot;remote_addr&quot;: remote_addr,
        &quot;cert&quot;: cert,
        &quot;key&quot;: key,
        &quot;verify_cert&quot;: verify_cert,
        &quot;changes&quot;: {},
    }

    try:
        container = __salt__[&quot;lxd.container_get&quot;](
            name, remote_addr, cert, key, verify_cert, _raw=True
        )
    except CommandExecutionError as e:
        return _error(ret, str(e))
    except SaltInvocationError as e:
        # Container not found
        return _error(ret, 'Container &quot;{}&quot; not found'.format(name))

    if container.status_code == CONTAINER_STATUS_FROZEN:
        return _success(ret, 'Container &quot;{}&quot; is alredy frozen'.format(name))

    is_running = container.status_code == CONTAINER_STATUS_RUNNING

    if not is_running and not start:
        return _error(
            ret,
            'Container &quot;{}&quot; is not running and start is False, cannot freeze it'.format(
                name
            ),
        )

    elif not is_running and start:
        if __opts__[&quot;test&quot;]:
            ret[&quot;changes&quot;][
                &quot;started&quot;
            ] = 'Would start the container &quot;{}&quot; and freeze it after'.format(name)
            return _unchanged(ret, ret[&quot;changes&quot;][&quot;started&quot;])
        else:
            container.start(wait=True)
            ret[&quot;changes&quot;][&quot;started&quot;] = 'Start the container &quot;{}&quot;'.format(name)

    if __opts__[&quot;test&quot;]:
        ret[&quot;changes&quot;][&quot;frozen&quot;] = 'Would freeze the container &quot;{}&quot;'.format(name)
        return _unchanged(ret, ret[&quot;changes&quot;][&quot;frozen&quot;])

    container.freeze(wait=True)
    ret[&quot;changes&quot;][&quot;frozen&quot;] = 'Froze the container &quot;{}&quot;'.format(name)

    return _success(ret, ret[&quot;changes&quot;][&quot;frozen&quot;])


def stopped(name, kill=False, remote_addr=None, cert=None, key=None, verify_cert=True):
    &quot;&quot;&quot;
    Ensure a LXD container is stopped, kill it if kill is true else stop it

    name :
        The name of the container to stop

    kill :
        kill if true

    remote_addr :
        An URL to a remote Server, you also have to give cert and key if you
        provide remote_addr!

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Zertifikate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.
    &quot;&quot;&quot;
    ret = {
        &quot;name&quot;: name,
        &quot;kill&quot;: kill,
        &quot;remote_addr&quot;: remote_addr,
        &quot;cert&quot;: cert,
        &quot;key&quot;: key,
        &quot;verify_cert&quot;: verify_cert,
        &quot;changes&quot;: {},
    }

    try:
        container = __salt__[&quot;lxd.container_get&quot;](
            name, remote_addr, cert, key, verify_cert, _raw=True
        )
    except CommandExecutionError as e:
        return _error(ret, str(e))
    except SaltInvocationError as e:
        # Container not found
        return _error(ret, 'Container &quot;{}&quot; not found'.format(name))

    if container.status_code == CONTAINER_STATUS_STOPPED:
        return _success(ret, 'Container &quot;{}&quot; is already stopped'.format(name))

    if __opts__[&quot;test&quot;]:
        ret[&quot;changes&quot;][&quot;stopped&quot;] = 'Would stop the container &quot;{}&quot;'.format(name)
        return _unchanged(ret, ret[&quot;changes&quot;][&quot;stopped&quot;])

    container.stop(force=kill, wait=True)
    ret[&quot;changes&quot;][&quot;stopped&quot;] = 'Stopped the container &quot;{}&quot;'.format(name)
    return _success(ret, ret[&quot;changes&quot;][&quot;stopped&quot;])


def migrated(
    name,
    remote_addr,
    cert,
    key,
    verify_cert,
    src_remote_addr,
    stop_and_start=False,
    src_cert=None,
    src_key=None,
    src_verify_cert=None,
):
    &quot;&quot;&quot;Ensure a container is migrated to another host

    If the container is running, it either must be shut down
    first (use stop_and_start=True) or criu must be installed
    on the source and destination machines.

    For this operation both certs need to be authenticated,
    use :mod:`lxd.authenticate &lt;salt.states.lxd.authenticate`
    to authenticate your cert(s).

    name :
        The container to migrate

    remote_addr :
        An URL to the destination remote Server

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    cert :
        PEM Formatted SSL Zertifikate.

        Examples:
            ~/.config/lxc/client.crt

    key :
        PEM Formatted SSL Key.

        Examples:
            ~/.config/lxc/client.key

    verify_cert : True
        Wherever to verify the cert, this is by default True
        but in the most cases you want to set it off as LXD
        normally uses self-signed certificates.

    src_remote_addr :
        An URL to the source remote Server

        Examples:
            https://myserver.lan:8443
            /var/lib/mysocket.sock

    stop_and_start:
        Stop before migrating and start after

    src_cert :
        PEM Formatted SSL Zertifikate, if None we copy &quot;cert&quot;

        Examples:
            ~/.config/lxc/client.crt

    src_key :
        PEM Formatted SSL Key, if None we copy &quot;key&quot;

        Examples:
            ~/.config/lxc/client.key

    src_verify_cert :
        Wherever to verify the cert, if None we copy &quot;verify_cert&quot;
    &quot;&quot;&quot;
    ret = {
        &quot;name&quot;: name,
        &quot;remote_addr&quot;: remote_addr,
        &quot;cert&quot;: cert,
        &quot;key&quot;: key,
        &quot;verify_cert&quot;: verify_cert,
        &quot;src_remote_addr&quot;: src_remote_addr,
        &quot;src_and_start&quot;: stop_and_start,
        &quot;src_cert&quot;: src_cert,
        &quot;src_key&quot;: src_key,
        &quot;changes&quot;: {},
    }

    dest_container = None
    try:
        dest_container = __salt__[&quot;lxd.container_get&quot;](
            name, remote_addr, cert, key, verify_cert, _raw=True
        )
    except CommandExecutionError as e:
        return _error(ret, str(e))
    except SaltInvocationError as e:
        # Destination container not found
        pass

    if dest_container is not None:
        return _success(ret, 'Container &quot;{}&quot; exists on the destination'.format(name))

    if src_verify_cert is None:
        src_verify_cert = verify_cert

    try:
        __salt__[&quot;lxd.container_get&quot;](
            name, src_remote_addr, src_cert, src_key, src_verify_cert, _raw=True
        )
    except CommandExecutionError as e:
        return _error(ret, str(e))
    except SaltInvocationError as e:
        # Container not found
        return _error(ret, 'Source Container &quot;{}&quot; not found'.format(name))

    if __opts__[&quot;test&quot;]:
        ret[&quot;changes&quot;][
            &quot;migrated&quot;
        ] = 'Would migrate the container &quot;{}&quot; from &quot;{}&quot; to &quot;{}&quot;'.format(
            name, src_remote_addr, remote_addr
        )
        return _unchanged(ret, ret[&quot;changes&quot;][&quot;migrated&quot;])

    try:
        __salt__[&quot;lxd.container_migrate&quot;](
            name,
            stop_and_start,
            remote_addr,
            cert,
            key,
            verify_cert,
            src_remote_addr,
            src_cert,
            src_key,
            src_verify_cert,
        )
    except CommandExecutionError as e:
        return _error(ret, str(e))

    ret[&quot;changes&quot;][&quot;migrated&quot;] = 'Migrated the container &quot;{}&quot; from &quot;{}&quot; to &quot;{}&quot;'.format(
        name, src_remote_addr, remote_addr
    )
    return _success(ret, ret[&quot;changes&quot;][&quot;migrated&quot;])


def _success(ret, success_msg):
    ret[&quot;result&quot;] = True
    ret[&quot;comment&quot;] = success_msg
    if &quot;changes&quot; not in ret:
        ret[&quot;changes&quot;] = {}
    return ret


def _unchanged(ret, msg):
    ret[&quot;result&quot;] = None
    ret[&quot;comment&quot;] = msg
    if &quot;changes&quot; not in ret:
        ret[&quot;changes&quot;] = {}
    return ret


def _error(ret, err_msg):
    ret[&quot;result&quot;] = False
    ret[&quot;comment&quot;] = err_msg
    if &quot;changes&quot; not in ret:
        ret[&quot;changes&quot;] = {}
    return ret
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>bigip.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
A state module designed to enforce load-balancing configurations for F5 Big-IP entities.
    :maturity:      develop
    :platform:      f5_bigip_11.6
&quot;&quot;&quot;


import salt.utils.json


# set up virtual function
def __virtual__():
    &quot;&quot;&quot;
    Only load if the bigip exec module is available in __salt__
    &quot;&quot;&quot;
    if &quot;bigip.list_transaction&quot; in __salt__:
        return &quot;bigip&quot;
    return (False, &quot;bigip module could not be loaded&quot;)


def _load_result(response, ret):
    &quot;&quot;&quot;
    format the results of listing functions
    &quot;&quot;&quot;

    # were we able to connect?
    if response[&quot;code&quot;] is None:
        ret[&quot;comment&quot;] = response[&quot;content&quot;]
    # forbidden?
    elif response[&quot;code&quot;] == 401:
        ret[&quot;comment&quot;] = &quot;401 Forbidden: Authentication required!&quot;
    # Not found?
    elif response[&quot;code&quot;] == 404:
        ret[&quot;comment&quot;] = response[&quot;content&quot;][&quot;message&quot;]
    # 200?
    elif response[&quot;code&quot;] == 200:
        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = (
            &quot;Listing Current Configuration Only.  &quot;
            &quot;Not action or changes occurred during the execution of this state.&quot;
        )
        ret[&quot;changes&quot;] = response[&quot;content&quot;]
    # something bad
    else:
        ret[&quot;comment&quot;] = response[&quot;content&quot;][&quot;message&quot;]

    return ret


def _strip_key(dictionary, keyword):
    &quot;&quot;&quot;
    look for a certain key within a dictionary and nullify ti's contents, check within nested
    dictionaries and lists as well.  Certain attributes such as &quot;generation&quot; will change even
    when there were no changes made to the entity.
    &quot;&quot;&quot;

    for key, value in dictionary.items():
        if key == keyword:
            dictionary[key] = None
        elif isinstance(value, dict):
            _strip_key(value, keyword)
        elif isinstance(value, list):
            for item in value:
                if isinstance(item, dict):
                    _strip_key(item, keyword)

    return dictionary


def _check_for_changes(entity_type, ret, existing, modified):
    &quot;&quot;&quot;
    take an existing entity and a modified entity and check for changes.
    &quot;&quot;&quot;

    ret[&quot;result&quot;] = True

    # were there any changes? generation always changes, remove it.

    if isinstance(existing, dict) and isinstance(modified, dict):
        if &quot;generation&quot; in modified[&quot;content&quot;].keys():
            del modified[&quot;content&quot;][&quot;generation&quot;]

        if &quot;generation&quot; in existing[&quot;content&quot;].keys():
            del existing[&quot;content&quot;][&quot;generation&quot;]

        if modified[&quot;content&quot;] == existing[&quot;content&quot;]:
            ret[&quot;comment&quot;] = (
                &quot;{entity_type} is currently enforced to the desired state.  No changes&quot;
                &quot; made.&quot;.format(entity_type=entity_type)
            )
        else:
            ret[&quot;comment&quot;] = (
                &quot;{entity_type} was enforced to the desired state.  Note: Only&quot;
                &quot; parameters specified were enforced. See changes for details.&quot;.format(
                    entity_type=entity_type
                )
            )
            ret[&quot;changes&quot;][&quot;old&quot;] = existing[&quot;content&quot;]
            ret[&quot;changes&quot;][&quot;new&quot;] = modified[&quot;content&quot;]

    else:
        if modified == existing:
            ret[&quot;comment&quot;] = (
                &quot;{entity_type} is currently enforced to the desired state.  No changes&quot;
                &quot; made.&quot;.format(entity_type=entity_type)
            )
        else:
            ret[&quot;comment&quot;] = (
                &quot;{entity_type} was enforced to the desired state.  Note: Only&quot;
                &quot; parameters specified were enforced. See changes for details.&quot;.format(
                    entity_type=entity_type
                )
            )
            ret[&quot;changes&quot;][&quot;old&quot;] = existing
            ret[&quot;changes&quot;][&quot;new&quot;] = modified

    return ret


def _test_output(ret, action, params):
    &quot;&quot;&quot;
    For testing just output what the state will attempt to do without actually doing it.
    &quot;&quot;&quot;

    if action == &quot;list&quot;:
        ret[
            &quot;comment&quot;
        ] += &quot;The list action will just list an entity and will make no changes.\n&quot;
    elif action == &quot;create&quot; or action == &quot;add&quot;:
        ret[&quot;comment&quot;] += (
            &quot;The create action will attempt to create an entity if it does not already&quot;
            &quot; exist.\n&quot;
        )
    elif action == &quot;delete&quot;:
        ret[&quot;comment&quot;] += (
            &quot;The delete action will attempt to delete an existing entity if it&quot;
            &quot; exists.\n&quot;
        )
    elif action == &quot;manage&quot;:
        ret[&quot;comment&quot;] += (
            &quot;The manage action will create a new entity if it does not exist.  If it&quot;
            &quot; does exist, it will be enforcedto the desired state.\n&quot;
        )
    elif action == &quot;modify&quot;:
        ret[&quot;comment&quot;] += (
            &quot;The modify action will attempt to modify an existing entity only if it&quot;
            &quot; exists.\n&quot;
        )

    ret[&quot;comment&quot;] += &quot;An iControl REST Request will be made using the parameters:\n&quot;
    ret[&quot;comment&quot;] += salt.utils.json.dumps(params, indent=4)

    ret[&quot;changes&quot;] = {}
    # Return ``None`` when running with ``test=true``.
    ret[&quot;result&quot;] = None

    return ret


def list_node(hostname, username, password, name):
    &quot;&quot;&quot;
    A function to connect to a bigip device and list a specific node.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the node to list.
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;list&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
            },
        )

    response = __salt__[&quot;bigip.list_node&quot;](hostname, username, password, name)
    return _load_result(response, ret)


def create_node(hostname, username, password, name, address):
    &quot;&quot;&quot;
    Create a new node if it does not already exist.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the node to create
    address
        The address of the node
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;create&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
                &quot;address&quot;: address,
            },
        )

    # is this node currently configured?
    existing = __salt__[&quot;bigip.list_node&quot;](hostname, username, password, name)

    # if it exists
    if existing[&quot;code&quot;] == 200:

        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;A node by this name currently exists.  No change made.&quot;

    # if it doesn't exist
    elif existing[&quot;code&quot;] == 404:
        response = __salt__[&quot;bigip.create_node&quot;](
            hostname, username, password, name, address
        )

        ret[&quot;result&quot;] = True
        ret[&quot;changes&quot;][&quot;old&quot;] = {}
        ret[&quot;changes&quot;][&quot;new&quot;] = response[&quot;content&quot;]
        ret[&quot;comment&quot;] = &quot;Node was successfully created.&quot;

    # else something else was returned
    else:
        ret = _load_result(existing, ret)

    return ret


def manage_node(
    hostname,
    username,
    password,
    name,
    address,
    connection_limit=None,
    description=None,
    dynamic_ratio=None,
    logging=None,
    monitor=None,
    rate_limit=None,
    ratio=None,
    session=None,
    node_state=None,
):
    &quot;&quot;&quot;
    Manages a node of a given bigip device.  If the node does not exist it will be created, otherwise,
    only the properties which are different than the existing will be updated.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the node to manage.
    address
        The address of the node
    connection_limit
        [integer]
    description
        [string]
    dynam
        c_ratio:        [integer]
    logging
        [enabled | disabled]
    monitor
        [[name] | none | default]
    rate_limit
        [integer]
    ratio
        [integer]
    session
        [user-enabled | user-disabled]
    node_state (state)
        [user-down | user-up ]
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;manage&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
                &quot;address&quot;: address,
                &quot;connection_limit&quot;: connection_limit,
                &quot;description&quot;: description,
                &quot;dynamic_ratio&quot;: dynamic_ratio,
                &quot;logging&quot;: logging,
                &quot;monitor&quot;: monitor,
                &quot;rate_limit&quot;: rate_limit,
                &quot;ratio&quot;: ratio,
                &quot;session&quot;: session,
                &quot;state:&quot;: node_state,
            },
        )

    # is this node currently configured?
    existing = __salt__[&quot;bigip.list_node&quot;](hostname, username, password, name)

    # if it exists by name
    if existing[&quot;code&quot;] == 200:

        # ensure the address is the same, we don't want to modify a different node than what
        # we think we are managing
        if existing[&quot;content&quot;][&quot;address&quot;] != address:
            ret[&quot;result&quot;] = False
            ret[
                &quot;comment&quot;
            ] = &quot;A node with this name exists but the address does not match.&quot;

        modified = __salt__[&quot;bigip.modify_node&quot;](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            connection_limit=connection_limit,
            description=description,
            dynamic_ratio=dynamic_ratio,
            logging=logging,
            monitor=monitor,
            rate_limit=rate_limit,
            ratio=ratio,
            session=session,
            state=node_state,
        )

        # was the modification successful?
        if modified[&quot;code&quot;] == 200:
            ret = _check_for_changes(&quot;Node&quot;, ret, existing, modified)
        else:
            ret = _load_result(modified, ret)

    # not found, attempt to create it
    elif existing[&quot;code&quot;] == 404:

        new = __salt__[&quot;bigip.create_node&quot;](hostname, username, password, name, address)

        # were we able to create it?
        if new[&quot;code&quot;] == 200:
            # try modification

            modified = __salt__[&quot;bigip.modify_node&quot;](
                hostname=hostname,
                username=username,
                password=password,
                name=name,
                connection_limit=connection_limit,
                description=description,
                dynamic_ratio=dynamic_ratio,
                logging=logging,
                monitor=monitor,
                rate_limit=rate_limit,
                ratio=ratio,
                session=session,
                state=node_state,
            )
            # was the modification successful?
            if modified[&quot;code&quot;] == 200:

                ret[&quot;result&quot;] = True
                ret[&quot;comment&quot;] = (
                    &quot;Node was created and enforced to the desired state.  Note: Only&quot;
                    &quot; parameters specified were enforced.  See changes for details.&quot;
                )
                ret[&quot;changes&quot;][&quot;old&quot;] = {}
                ret[&quot;changes&quot;][&quot;new&quot;] = modified[&quot;content&quot;]

            # roll it back
            else:

                deleted = __salt__[&quot;bigip.delete_node&quot;](
                    hostname, username, password, name
                )
                # did we get rid of it?
                if deleted[&quot;code&quot;] == 200:
                    ret[&quot;comment&quot;] = (
                        &quot;Node was successfully created but an error occurred during&quot;
                        &quot; modification. The creation of the node has been rolled back.&quot;
                        &quot; Message is as follows:\n{message}&quot;.format(
                            message=modified[&quot;content&quot;][&quot;message&quot;]
                        )
                    )
                # something bad happened
                else:
                    ret[&quot;comment&quot;] = (
                        &quot;Node was successfully created but an error occurred during&quot;
                        &quot; modification. The creation of the node was not able to be&quot;
                        &quot; rolled back. Message is as follows:\n&quot;
                        &quot; {message}\n{message_two}&quot;.format(
                            message=modified[&quot;content&quot;][&quot;message&quot;],
                            message_two=deleted[&quot;content&quot;][&quot;message&quot;],
                        )
                    )

        # unable to create it
        else:
            ret = _load_result(new, ret)
    # an error occurred
    else:
        ret = _load_result(existing, ret)

    return ret


def modify_node(
    hostname,
    username,
    password,
    name,
    connection_limit=None,
    description=None,
    dynamic_ratio=None,
    logging=None,
    monitor=None,
    rate_limit=None,
    ratio=None,
    session=None,
    node_state=None,
):
    &quot;&quot;&quot;
    Modify an existing node. Only a node which already exists will be modified and
    only the parameters specified will be enforced.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the node to modify
    connection_limit
        [integer]
    description
        [string]
    dynamic_ratio
        [integer]
    logging
        [enabled | disabled]
    monitor
        [[name] | none | default]
    rate_limit
        [integer]
    ratio
        [integer]
    session
        [user-enabled | user-disabled]
    node_state (state)
        [user-down | user-up ]
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;modify&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
                &quot;connection_limit&quot;: connection_limit,
                &quot;description&quot;: description,
                &quot;dynamic_ratio&quot;: dynamic_ratio,
                &quot;logging&quot;: logging,
                &quot;monitor&quot;: monitor,
                &quot;rate_limit&quot;: rate_limit,
                &quot;ratio&quot;: ratio,
                &quot;session&quot;: session,
                &quot;state:&quot;: node_state,
            },
        )

    # is this node currently configured?
    existing = __salt__[&quot;bigip.list_node&quot;](hostname, username, password, name)

    # if it exists by name
    if existing[&quot;code&quot;] == 200:

        modified = __salt__[&quot;bigip.modify_node&quot;](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            connection_limit=connection_limit,
            description=description,
            dynamic_ratio=dynamic_ratio,
            logging=logging,
            monitor=monitor,
            rate_limit=rate_limit,
            ratio=ratio,
            session=session,
            state=node_state,
        )

        # was the modification successful?
        if modified[&quot;code&quot;] == 200:
            ret = _check_for_changes(&quot;Node&quot;, ret, existing, modified)
        else:
            ret = _load_result(modified, ret)

    # not found, attempt to create it
    elif existing[&quot;code&quot;] == 404:
        ret[&quot;comment&quot;] = &quot;A node with this name was not found.&quot;
    # an error occurred
    else:
        ret = _load_result(existing, ret)

    return ret


def delete_node(hostname, username, password, name):
    &quot;&quot;&quot;
    Delete an existing node.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the node which will be deleted.
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;delete&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
            },
        )

    # is this node currently configured?
    existing = __salt__[&quot;bigip.list_node&quot;](hostname, username, password, name)
    # if it exists by name
    if existing[&quot;code&quot;] == 200:

        deleted = __salt__[&quot;bigip.delete_node&quot;](hostname, username, password, name)
        # did we get rid of it?
        if deleted[&quot;code&quot;] == 200:
            ret[&quot;result&quot;] = True
            ret[&quot;comment&quot;] = &quot;Node was successfully deleted.&quot;
            ret[&quot;changes&quot;][&quot;old&quot;] = existing[&quot;content&quot;]
            ret[&quot;changes&quot;][&quot;new&quot;] = {}

        # something bad happened
        else:
            ret = _load_result(existing, ret)

    # not found
    elif existing[&quot;code&quot;] == 404:
        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;This node already does not exist. No changes made.&quot;
        ret[&quot;changes&quot;][&quot;old&quot;] = {}
        ret[&quot;changes&quot;][&quot;new&quot;] = {}

    else:
        ret = _load_result(existing, ret)

    return ret


def list_pool(hostname, username, password, name):
    &quot;&quot;&quot;
    A function to connect to a bigip device and list a specific pool.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool to list.
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;list&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
            },
<A NAME="0"></A>        )

    response = __salt__[&quot;bigip.list_pool&quot;](hostname, username, password, name)
    return _load_result(<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match256248-0.html#0',2,'match256248-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>response, ret)


def create_pool(
    hostname,
    username,
    password,
    name,
    members=None,
    allow_nat=None,
    allow_snat=None,
    description=None,
    gateway_failsafe_device=None,
    ignore_persisted_weight=None,
    ip_tos_to_client=None,
    ip_tos_to_server=None,
    link_qos_to_client=None,
    link_qos_to_server=None,
    load_balancing_mode=None,
    min_active_members=</B></FONT>None,
    min_up_members=None,
    min_up_members_action=None,
    min_up_members_checking=None,
    monitor=None,
    profiles=None,
    queue_depth_limit=None,
    queue_on_connection_limit=None,
    queue_time_limit=None,
    reselect_tries=None,
    service_down_action=None,
    slow_ramp_time=None,
):
    &quot;&quot;&quot;
    Create a new node if it does not already exist.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool to create
    members
        List of members to be added to the pool
    allow_nat
        [yes | no]
    allow_snat
        [yes | no]
    description
        [string]
    gateway_failsafe_device
        [string]
    ignore_persisted_weight
        [enabled | disabled]
    ip_tos_to_client
        [pass-through | [integer]]
    ip_tos_to_server
        [pass-through | [integer]]
    link_qos_to_client
        [pass-through | [integer]]
    link_qos_to_server
        [pass-through | [integer]]
    load_balancing_mode
        [dynamic-ratio-member | dynamic-ratio-node |
        fastest-app-response | fastest-node |
        least-connections-members |
        least-connections-node |
        least-sessions |
        observed-member | observed-node |
        predictive-member | predictive-node |
        ratio-least-connections-member |
        ratio-least-connections-node |
        ratio-member | ratio-node | ratio-session |
        round-robin | weighted-least-connections-member |
        weighted-least-connections-node]
    min_active_members
        [integer]
    min_up_members
        [integer]
    min_up_members_action
        [failover | reboot | restart-all]
    min_up_members_checking
        [enabled | disabled]
    monitor
        [name]
    profiles
        [none | profile_name]
    queue_depth_limit
        [integer]
    queue_on_connection_limit
        [enabled | disabled]
    queue_time_limit
        [integer]
    reselect_tries
        [integer]
    service_down_action
        [drop | none | reselect | reset]
    slow_ramp_time
        [integer]
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;create&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
                &quot;members&quot;: members,
                &quot;allow_nat&quot;: allow_nat,
                &quot;allow_snat&quot;: allow_snat,
                &quot;description&quot;: description,
                &quot;gateway_failsafe_device&quot;: gateway_failsafe_device,
                &quot;ignore_persisted_weight&quot;: ignore_persisted_weight,
                &quot;ip_tos_client:&quot;: ip_tos_to_client,
                &quot;ip_tos_server&quot;: ip_tos_to_server,
                &quot;link_qos_to_client&quot;: link_qos_to_client,
                &quot;link_qos_to_server&quot;: link_qos_to_server,
                &quot;load_balancing_mode&quot;: load_balancing_mode,
                &quot;min_active_members&quot;: min_active_members,
                &quot;min_up_members&quot;: min_up_members,
                &quot;min_up_members_checking&quot;: min_up_members_checking,
                &quot;monitor&quot;: monitor,
                &quot;profiles&quot;: profiles,
                &quot;queue_depth_limit&quot;: queue_depth_limit,
                &quot;queue_on_connection_limit&quot;: queue_on_connection_limit,
                &quot;queue_time_limit&quot;: queue_time_limit,
                &quot;reselect_tries&quot;: reselect_tries,
                &quot;service_down_action&quot;: service_down_action,
                &quot;slow_ramp_time&quot;: slow_ramp_time,
            },
        )

    # is this pool currently configured?
    existing = __salt__[&quot;bigip.list_pool&quot;](hostname, username, password, name)

    # if it exists
    if existing[&quot;code&quot;] == 200:

        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;A pool by this name currently exists.  No change made.&quot;

    # if it doesn't exist
    elif existing[&quot;code&quot;] == 404:

        response = __salt__[&quot;bigip.create_pool&quot;](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            members=members,
            allow_nat=allow_nat,
            allow_snat=allow_snat,
            description=description,
            gateway_failsafe_device=gateway_failsafe_device,
            ignore_persisted_weight=ignore_persisted_weight,
            ip_tos_to_client=ip_tos_to_client,
            ip_tos_to_server=ip_tos_to_server,
            link_qos_to_client=link_qos_to_client,
            link_qos_to_server=link_qos_to_server,
            load_balancing_mode=load_balancing_mode,
            min_active_members=min_active_members,
            min_up_members=min_up_members,
            min_up_members_action=min_up_members_action,
            min_up_members_checking=min_up_members_checking,
            monitor=monitor,
            profiles=profiles,
            queue_depth_limit=queue_depth_limit,
            queue_on_connection_limit=queue_on_connection_limit,
            queue_time_limit=queue_time_limit,
            reselect_tries=reselect_tries,
            service_down_action=service_down_action,
            slow_ramp_time=slow_ramp_time,
        )
        if response[&quot;code&quot;] == 200:
            ret[&quot;result&quot;] = True
            ret[&quot;changes&quot;][&quot;old&quot;] = {}
            ret[&quot;changes&quot;][&quot;new&quot;] = response[&quot;content&quot;]
            ret[&quot;comment&quot;] = &quot;Pool was successfully created.&quot;
        else:
            ret = _load_result(existing, ret)

    # else something else was returned
    else:
        ret = _load_result(existing, ret)

    return ret


def manage_pool(
    hostname,
    username,
    password,
    name,
    allow_nat=None,
    allow_snat=None,
    description=None,
    gateway_failsafe_device=None,
    ignore_persisted_weight=None,
    ip_tos_to_client=None,
    ip_tos_to_server=None,
    link_qos_to_client=None,
    link_qos_to_server=None,
    load_balancing_mode=None,
    min_active_members=None,
    min_up_members=None,
    min_up_members_action=None,
    min_up_members_checking=None,
    monitor=None,
    profiles=None,
    queue_depth_limit=None,
    queue_on_connection_limit=None,
    queue_time_limit=None,
    reselect_tries=None,
    service_down_action=None,
    slow_ramp_time=None,
):
    &quot;&quot;&quot;
    Create a new pool if it does not already exist. Pool members are managed separately. Only the
    parameters specified are enforced.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool to create
    allow_nat
        [yes | no]
    allow_snat
        [yes | no]
    description
        [string]
    gateway_failsafe_device
        [string]
    ignore_persisted_weight
        [enabled | disabled]
    ip_tos_to_client
        [pass-through | [integer]]
    ip_tos_to_server
        [pass-through | [integer]]
    link_qos_to_client
        [pass-through | [integer]]
    link_qos_to_server
        [pass-through | [integer]]
    load_balancing_mode
        [dynamic-ratio-member | dynamic-ratio-node |
        fastest-app-response | fastest-node |
        least-connections-members |
        least-connections-node |
        least-sessions |
        observed-member | observed-node |
        predictive-member | predictive-node |
        ratio-least-connections-member |
        ratio-least-connections-node |
        ratio-member | ratio-node | ratio-session |
        round-robin | weighted-least-connections-member |
        weighted-least-connections-node]
    min_active_members
        [integer]
    min_up_members
        [integer]
    min_up_members_action
        [failover | reboot | restart-all]
    min_up_members_checking
        [enabled | disabled]
    monitor
        [name]
    profiles
        [none | profile_name]
    queue_depth_limit
        [integer]
    queue_on_connection_limit
        [enabled | disabled]
    queue_time_limit
        [integer]
    reselect_tries
        [integer]
    service_down_action
        [drop | none | reselect | reset]
    slow_ramp_time
        [integer]

    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;manage&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
                &quot;allow_nat&quot;: allow_nat,
                &quot;allow_snat&quot;: allow_snat,
                &quot;description&quot;: description,
                &quot;gateway_failsafe_device&quot;: gateway_failsafe_device,
                &quot;ignore_persisted_weight&quot;: ignore_persisted_weight,
                &quot;ip_tos_client:&quot;: ip_tos_to_client,
                &quot;ip_tos_server&quot;: ip_tos_to_server,
                &quot;link_qos_to_client&quot;: link_qos_to_client,
                &quot;link_qos_to_server&quot;: link_qos_to_server,
                &quot;load_balancing_mode&quot;: load_balancing_mode,
                &quot;min_active_members&quot;: min_active_members,
                &quot;min_up_members&quot;: min_up_members,
                &quot;min_up_members_checking&quot;: min_up_members_checking,
                &quot;monitor&quot;: monitor,
                &quot;profiles&quot;: profiles,
                &quot;queue_depth_limit&quot;: queue_depth_limit,
                &quot;queue_on_connection_limit&quot;: queue_on_connection_limit,
                &quot;queue_time_limit&quot;: queue_time_limit,
                &quot;reselect_tries&quot;: reselect_tries,
                &quot;service_down_action&quot;: service_down_action,
                &quot;slow_ramp_time&quot;: slow_ramp_time,
            },
        )

    # is this pool currently configured?
    existing = __salt__[&quot;bigip.list_pool&quot;](hostname, username, password, name)

    # if it exists
    if existing[&quot;code&quot;] == 200:

        modified = __salt__[&quot;bigip.modify_pool&quot;](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            allow_nat=allow_nat,
            allow_snat=allow_snat,
            description=description,
            gateway_failsafe_device=gateway_failsafe_device,
            ignore_persisted_weight=ignore_persisted_weight,
            ip_tos_to_client=ip_tos_to_client,
            ip_tos_to_server=ip_tos_to_server,
            link_qos_to_client=link_qos_to_client,
            link_qos_to_server=link_qos_to_server,
            load_balancing_mode=load_balancing_mode,
            min_active_members=min_active_members,
            min_up_members=min_up_members,
            min_up_members_action=min_up_members_action,
            min_up_members_checking=min_up_members_checking,
            monitor=monitor,
            profiles=profiles,
            queue_depth_limit=queue_depth_limit,
            queue_on_connection_limit=queue_on_connection_limit,
            queue_time_limit=queue_time_limit,
            reselect_tries=reselect_tries,
            service_down_action=service_down_action,
            slow_ramp_time=slow_ramp_time,
        )

        # was the modification successful?
        if modified[&quot;code&quot;] == 200:

            # remove member listings and self-links
            del existing[&quot;content&quot;][&quot;membersReference&quot;]
            del modified[&quot;content&quot;][&quot;membersReference&quot;]
            del existing[&quot;content&quot;][&quot;selfLink&quot;]
            del modified[&quot;content&quot;][&quot;selfLink&quot;]

            ret = _check_for_changes(&quot;Pool&quot;, ret, existing, modified)
        else:
            ret = _load_result(modified, ret)

    # if it doesn't exist
    elif existing[&quot;code&quot;] == 404:

        new = __salt__[&quot;bigip.create_pool&quot;](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            allow_nat=allow_nat,
            allow_snat=allow_snat,
            description=description,
            gateway_failsafe_device=gateway_failsafe_device,
            ignore_persisted_weight=ignore_persisted_weight,
            ip_tos_to_client=ip_tos_to_client,
            ip_tos_to_server=ip_tos_to_server,
            link_qos_to_client=link_qos_to_client,
            link_qos_to_server=link_qos_to_server,
            load_balancing_mode=load_balancing_mode,
            min_active_members=min_active_members,
            min_up_members=min_up_members,
            min_up_members_action=min_up_members_action,
            min_up_members_checking=min_up_members_checking,
            monitor=monitor,
            profiles=profiles,
            queue_depth_limit=queue_depth_limit,
            queue_on_connection_limit=queue_on_connection_limit,
            queue_time_limit=queue_time_limit,
            reselect_tries=reselect_tries,
            service_down_action=service_down_action,
            slow_ramp_time=slow_ramp_time,
        )

        # were we able to create it?
        if new[&quot;code&quot;] == 200:
            ret[&quot;result&quot;] = True
            ret[&quot;comment&quot;] = (
                &quot;Pool was created and enforced to the desired state.  Note: Only&quot;
                &quot; parameters specified were enforced.  See changes for details.&quot;
            )
            ret[&quot;changes&quot;][&quot;old&quot;] = {}
            ret[&quot;changes&quot;][&quot;new&quot;] = new[&quot;content&quot;]

        # unable to create it
        else:
            ret = _load_result(new, ret)

    # else something else was returned
    else:
        ret = _load_result(existing, ret)

    return ret


def modify_pool(
    hostname,
    username,
    password,
    name,
    allow_nat=None,
    allow_snat=None,
    description=None,
    gateway_failsafe_device=None,
    ignore_persisted_weight=None,
    ip_tos_to_client=None,
    ip_tos_to_server=None,
    link_qos_to_client=None,
    link_qos_to_server=None,
    load_balancing_mode=None,
    min_active_members=None,
    min_up_members=None,
    min_up_members_action=None,
    min_up_members_checking=None,
    monitor=None,
    profiles=None,
    queue_depth_limit=None,
    queue_on_connection_limit=None,
    queue_time_limit=None,
    reselect_tries=None,
    service_down_action=None,
    slow_ramp_time=None,
):
    &quot;&quot;&quot;
    Modify an existing pool. Pool members are managed separately. Only the
    parameters specified are enforced.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool to create
    allow_nat
        [yes | no]
    allow_snat
        [yes | no]
    description
        [string]
    gateway_failsafe_device
        [string]
    ignore_persisted_weight
        [enabled | disabled]
    ip_tos_to_client
        [pass-through | [integer]]
    ip_tos_to_server
        [pass-through | [integer]]
    link_qos_to_client
        [pass-through | [integer]]
    link_qos_to_server
        [pass-through | [integer]]
    load_balancing_mode
        [dynamic-ratio-member | dynamic-ratio-node |
        fastest-app-response | fastest-node |
        least-connections-members |
        least-connections-node |
        least-sessions |
        observed-member | observed-node |
        predictive-member | predictive-node |
        ratio-least-connections-member |
        ratio-least-connections-node |
        ratio-member | ratio-node | ratio-session |
        round-robin | weighted-least-connections-member |
        weighted-least-connections-node]
    min_active_members
        [integer]
    min_up_members
        [integer]
    min_up_members_action
        [failover | reboot | restart-all]
    min_up_members_checking
        [enabled | disabled]
    monitor
        [name]
    profiles
        [none | profile_name]
    queue_depth_limit
        [integer]
    queue_on_connection_limit
        [enabled | disabled]
    queue_time_limit
        [integer]
    reselect_tries
        [integer]
    service_down_action
        [drop | none | reselect | reset]
    slow_ramp_time
        [integer]

    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;modify&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
                &quot;allow_nat&quot;: allow_nat,
                &quot;allow_snat&quot;: allow_snat,
                &quot;description&quot;: description,
                &quot;gateway_failsafe_device&quot;: gateway_failsafe_device,
                &quot;ignore_persisted_weight&quot;: ignore_persisted_weight,
                &quot;ip_tos_client:&quot;: ip_tos_to_client,
                &quot;ip_tos_server&quot;: ip_tos_to_server,
                &quot;link_qos_to_client&quot;: link_qos_to_client,
                &quot;link_qos_to_server&quot;: link_qos_to_server,
                &quot;load_balancing_mode&quot;: load_balancing_mode,
                &quot;min_active_members&quot;: min_active_members,
                &quot;min_up_members&quot;: min_up_members,
                &quot;min_up_members_checking&quot;: min_up_members_checking,
                &quot;monitor&quot;: monitor,
                &quot;profiles&quot;: profiles,
                &quot;queue_depth_limit&quot;: queue_depth_limit,
                &quot;queue_on_connection_limit&quot;: queue_on_connection_limit,
                &quot;queue_time_limit&quot;: queue_time_limit,
                &quot;reselect_tries&quot;: reselect_tries,
                &quot;service_down_action&quot;: service_down_action,
                &quot;slow_ramp_time&quot;: slow_ramp_time,
            },
        )

    # is this pool currently configured?
    existing = __salt__[&quot;bigip.list_pool&quot;](hostname, username, password, name)

    # if it exists
    if existing[&quot;code&quot;] == 200:

        modified = __salt__[&quot;bigip.modify_pool&quot;](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            allow_nat=allow_nat,
            allow_snat=allow_snat,
            description=description,
            gateway_failsafe_device=gateway_failsafe_device,
            ignore_persisted_weight=ignore_persisted_weight,
            ip_tos_to_client=ip_tos_to_client,
            ip_tos_to_server=ip_tos_to_server,
            link_qos_to_client=link_qos_to_client,
            link_qos_to_server=link_qos_to_server,
            load_balancing_mode=load_balancing_mode,
            min_active_members=min_active_members,
            min_up_members=min_up_members,
            min_up_members_action=min_up_members_action,
            min_up_members_checking=min_up_members_checking,
            monitor=monitor,
            profiles=profiles,
            queue_depth_limit=queue_depth_limit,
            queue_on_connection_limit=queue_on_connection_limit,
            queue_time_limit=queue_time_limit,
            reselect_tries=reselect_tries,
            service_down_action=service_down_action,
            slow_ramp_time=slow_ramp_time,
        )

        # was the modification successful?
        if modified[&quot;code&quot;] == 200:

            # remove member listings and self-links
            del existing[&quot;content&quot;][&quot;membersReference&quot;]
            del modified[&quot;content&quot;][&quot;membersReference&quot;]
            del existing[&quot;content&quot;][&quot;selfLink&quot;]
            del modified[&quot;content&quot;][&quot;selfLink&quot;]

            ret = _check_for_changes(&quot;Pool&quot;, ret, existing, modified)
        else:
            ret = _load_result(modified, ret)

    # if it doesn't exist
    elif existing[&quot;code&quot;] == 404:
        ret[&quot;comment&quot;] = &quot;A pool with this name was not found.&quot;
    # else something else was returned
    else:
        ret = _load_result(existing, ret)

    return ret


def delete_pool(hostname, username, password, name):
    &quot;&quot;&quot;
    Delete an existing pool.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool which will be deleted
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;delete&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
            },
        )

    # is this pool currently configured?
    existing = __salt__[&quot;bigip.list_pool&quot;](hostname, username, password, name)
    # if it exists by name
    if existing[&quot;code&quot;] == 200:

        deleted = __salt__[&quot;bigip.delete_pool&quot;](hostname, username, password, name)
        # did we get rid of it?
        if deleted[&quot;code&quot;] == 200:
            ret[&quot;result&quot;] = True
            ret[&quot;comment&quot;] = &quot;Pool was successfully deleted.&quot;
            ret[&quot;changes&quot;][&quot;old&quot;] = existing[&quot;content&quot;]
            ret[&quot;changes&quot;][&quot;new&quot;] = {}

        # something bad happened
        else:
            ret = _load_result(deleted, ret)

    # not found
    elif existing[&quot;code&quot;] == 404:
        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;This pool already does not exist. No changes made.&quot;
        ret[&quot;changes&quot;][&quot;old&quot;] = {}
        ret[&quot;changes&quot;][&quot;new&quot;] = {}

    else:
        ret = _load_result(existing, ret)

    return ret


def manage_pool_members(hostname, username, password, name, members):
    &quot;&quot;&quot;
    Manage the members of an existing pool.  This function replaces all current pool members.
    Only the parameters specified are enforced.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool to modify
    members
        list of pool members to manage.

    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;manage&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
                &quot;members&quot;: members,
            },
        )

    # is this pool currently configured?
    existing = __salt__[&quot;bigip.list_pool&quot;](hostname, username, password, name)

    # if it exists
    if existing[&quot;code&quot;] == 200:

        # what are the current members?
        current_members = existing[&quot;content&quot;][&quot;membersReference&quot;][&quot;items&quot;]

        modified = __salt__[&quot;bigip.replace_pool_members&quot;](
            hostname, username, password, name, members
        )

        # was the modification successful?
        if modified[&quot;code&quot;] == 200:

            # re-list the pool with new membership
            new_listing = __salt__[&quot;bigip.list_pool&quot;](
                hostname, username, password, name
            )

            # just in case something happened...
            if new_listing[&quot;code&quot;] != 200:
                ret = _load_result(new_listing, ret)
                ret[&quot;comment&quot;] = (
                    &quot;modification of the pool was successful but an error occurred upon&quot;
                    &quot; retrieving new listing.&quot;
                )
                return ret

            new_members = new_listing[&quot;content&quot;][&quot;membersReference&quot;][&quot;items&quot;]

            # remove generation keys and create new lists indexed by integers
            for current_member in current_members:
                del current_member[&quot;generation&quot;]

            for new_member in new_members:
                del new_member[&quot;generation&quot;]

            # anything changed?
            ret = _check_for_changes(
                &quot;Pool Membership&quot;, ret, current_members, new_members
            )

        else:
            ret = _load_result(modified, ret)

    # pool does not exists
    elif existing[&quot;code&quot;] == 404:
        ret[&quot;comment&quot;] = &quot;A pool with this name was not found.&quot;

    else:
        ret = _load_result(existing, ret)

    return ret


def add_pool_member(hostname, username, password, name, member):
    &quot;&quot;&quot;
    A function to connect to a bigip device and add a new member to an existing pool.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool to modify
    member
        The member to add to the pool
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;add&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
                &quot;members&quot;: member,
            },
        )

    # is this pool member currently configured?
    existing_pool = __salt__[&quot;bigip.list_pool&quot;](hostname, username, password, name)

    if existing_pool[&quot;code&quot;] == 200:

        # for some reason iControl REST doesn't support listing a single pool member.
        # the response from GET for listing a member will return 200 even if it doesn't exists.
        # because of this we have to do some rather &quot;unnecessary&quot; searching within a pool.

        # what are the current members?
        current_members = existing_pool[&quot;content&quot;][&quot;membersReference&quot;][&quot;items&quot;]

        # loop through them
        exists = False
        for current_member in current_members:
            if current_member[&quot;name&quot;] == member[&quot;name&quot;]:
                exists = True
                break

        if exists:
            ret[&quot;result&quot;] = True
            ret[
                &quot;comment&quot;
            ] = &quot;Member: {name} already exists within this pool.  No changes made.&quot;.format(
                name=member[&quot;name&quot;]
            )
            ret[&quot;changes&quot;][&quot;old&quot;] = {}
            ret[&quot;changes&quot;][&quot;new&quot;] = {}
        else:
            new_member = __salt__[&quot;bigip.add_pool_member&quot;](
                hostname, username, password, name, member
            )

            if new_member[&quot;code&quot;] == 200:
                ret[&quot;result&quot;] = True
                ret[
                    &quot;comment&quot;
                ] = &quot;Member: {name} has been successfully added to the pool.&quot;.format(
                    name=member[&quot;name&quot;]
                )
                ret[&quot;changes&quot;][&quot;old&quot;] = {}

                # look up the member again...
                pool_listing = __salt__[&quot;bigip.list_pool&quot;](
                    hostname, username, password, name
                )

                if pool_listing[&quot;code&quot;] != 200:
                    ret = _load_result(new_member, ret)
                    return ret

                members = pool_listing[&quot;content&quot;][&quot;membersReference&quot;][&quot;items&quot;]
                # loop through them
                for current_member in members:
                    if current_member[&quot;name&quot;] == member[&quot;name&quot;]:
                        added_member = current_member
                        break

                ret[&quot;changes&quot;][&quot;new&quot;] = added_member

            # member wasn't added
            else:
                ret = _load_result(new_member, ret)

    # pool does not exists
    elif existing_pool[&quot;code&quot;] == 404:
        ret[&quot;comment&quot;] = &quot;A pool with this name was not found.&quot;
    else:
        ret = _load_result(existing_pool, ret)

    return ret


def modify_pool_member(
    hostname,
    username,
    password,
    name,
    member,
    connection_limit=None,
    description=None,
    dynamic_ratio=None,
    inherit_profile=None,
    logging=None,
    monitor=None,
    priority_group=None,
    profiles=None,
    rate_limit=None,
    ratio=None,
    session=None,
    member_state=None,
):
    &quot;&quot;&quot;
    A function to connect to a bigip device and modify a member of an existing pool.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool to modify
    member
        The member modify
    connection_limit
        [integer]
    description
        [string]
    dynamic_ratio
        [integer]
    inherit_profile
        [enabled | disabled]
    logging
        [enabled | disabled]
    monitor
        [name]
    priority_group
        [integer]
    profiles
        [none | profile_name]
    rate_limit
        [integer]
    ratio
        [integer]
    session
        [user-enabled | user-disabled]
    member_state (state)
        [ user-up | user-down ]

    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;modify&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
                &quot;members&quot;: member,
            },
        )

    # is this pool member currently configured?
    existing_pool = __salt__[&quot;bigip.list_pool&quot;](hostname, username, password, name)

    if existing_pool[&quot;code&quot;] == 200:

        # for some reason iControl REST doesn't support listing a single pool member.
        # the response from GET for listing a member will return 200 even if it doesn't exists.
        # because of this we have to do some rather &quot;unnecessary&quot; searching within a pool.

        # what are the current members?
        current_members = existing_pool[&quot;content&quot;][&quot;membersReference&quot;][&quot;items&quot;]

        # loop through them
        exists = False
        for current_member in current_members:
            if current_member[&quot;name&quot;] == member:
                exists = True
                existing_member = current_member
                break

        if exists:

            # modify the pool member
            modified = __salt__[&quot;bigip.modify_pool_member&quot;](
                hostname=hostname,
                username=username,
                password=password,
                name=name,
                member=member,
                connection_limit=connection_limit,
                description=description,
                dynamic_ratio=dynamic_ratio,
                inherit_profile=inherit_profile,
                logging=logging,
                monitor=monitor,
                priority_group=priority_group,
                profiles=profiles,
                rate_limit=rate_limit,
                ratio=ratio,
                session=session,
                state=member_state,
            )

            # re-list the pool
            new_pool = __salt__[&quot;bigip.list_pool&quot;](hostname, username, password, name)

            if modified[&quot;code&quot;] == 200 and modified[&quot;code&quot;] == 200:

                # what are the new members?
                new_members = new_pool[&quot;content&quot;][&quot;membersReference&quot;][&quot;items&quot;]

                # loop through them
                for new_member in new_members:
                    if new_member[&quot;name&quot;] == member:
                        modified_member = new_member
                        break

                # check for changes
                old = {&quot;content&quot;: existing_member}
                new = {&quot;content&quot;: modified_member}
                ret = _check_for_changes(
                    &quot;Pool Member: {member}&quot;.format(member=member), ret, old, new
                )

            else:
                ret = _load_result(modified, ret)
        else:
            ret[
                &quot;comment&quot;
            ] = &quot;Member: {name} does not exists within this pool.  No changes made.&quot;.format(
                name=member[&quot;name&quot;]
            )

    # pool does not exists
    elif existing_pool[&quot;code&quot;] == 404:
        ret[&quot;comment&quot;] = &quot;A pool with this name was not found.&quot;
    else:
        ret = _load_result(existing_pool, ret)

    return ret


def delete_pool_member(hostname, username, password, name, member):
    &quot;&quot;&quot;
    Delete an existing pool member.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool to be modified
    member
        The name of the member to delete from the pool
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;delete&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
                &quot;members&quot;: member,
            },
        )

    # is this pool currently configured?
    existing = __salt__[&quot;bigip.list_pool&quot;](hostname, username, password, name)

    # if it exists by name
    if existing[&quot;code&quot;] == 200:

        # what are the current members?
        current_members = existing[&quot;content&quot;][&quot;membersReference&quot;][&quot;items&quot;]

        # loop through them
        exists = False
        for current_member in current_members:
            if current_member[&quot;name&quot;] == member:
                exists = True
                existing_member = current_member
                break

        if exists:
            deleted = __salt__[&quot;bigip.delete_pool_member&quot;](
                hostname, username, password, name, member
            )
            # did we get rid of it?
            if deleted[&quot;code&quot;] == 200:
                ret[&quot;result&quot;] = True
                ret[
                    &quot;comment&quot;
                ] = &quot;Pool Member: {member} was successfully deleted.&quot;.format(
                    member=member
                )
                ret[&quot;changes&quot;][&quot;old&quot;] = existing_member
                ret[&quot;changes&quot;][&quot;new&quot;] = {}

        # something bad happened
        else:
            ret[&quot;result&quot;] = True
            ret[&quot;comment&quot;] = &quot;This pool member already does not exist. No changes made.&quot;
            ret[&quot;changes&quot;][&quot;old&quot;] = {}
            ret[&quot;changes&quot;][&quot;new&quot;] = {}

    else:
        ret = _load_result(existing, ret)

    return ret


def list_virtual(hostname, username, password, name):
    &quot;&quot;&quot;
    A function to list a specific virtual.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the virtual to list
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;list&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
            },
        )

    response = __salt__[&quot;bigip.list_virtual&quot;](hostname, username, password, name)
    return _load_result(response, ret)


def create_virtual(
    hostname,
    username,
    password,
    name,
    destination,
    pool=None,
    address_status=None,
    auto_lasthop=None,
    bwc_policy=None,
    cmp_enabled=None,
    connection_limit=None,
    dhcp_relay=None,
    description=None,
    fallback_persistence=None,
    flow_eviction_policy=None,
    gtm_score=None,
    ip_forward=None,
    ip_protocol=None,
    internal=None,
    twelve_forward=None,
    last_hop_pool=None,
    mask=None,
    mirror=None,
    nat64=None,
    persist=None,
    profiles=None,
    policies=None,
    rate_class=None,
    rate_limit=None,
    rate_limit_mode=None,
    rate_limit_dst=None,
    rate_limit_src=None,
    rules=None,
    related_rules=None,
    reject=None,
    source=None,
    source_address_translation=None,
    source_port=None,
    virtual_state=None,
    traffic_classes=None,
    translate_address=None,
    translate_port=None,
    vlans=None,
):
    &quot;&quot;&quot;
    A function to connect to a bigip device and create a virtual server if it does not already exists.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the virtual to create
    destination
        [ [virtual_address_name:port] | [ipv4:port] | [ipv6.port] ]
    pool
        [ [pool_name] | none]
    address_status
        [yes | no]
    auto_lasthop
        [default | enabled | disabled ]
    bwc_policy
        [none] | string]
    cmp_enabled
        [yes | no]
    dhcp_relay
        [yes | no}
    connection_limit
        [integer]
    description
        [string]
    state
        [disabled | enabled]
    fallback_persistence
        [none | [profile name] ]
    flow_eviction_policy
        [none | [eviction policy name] ]
    gtm_score
        [integer]
    ip_forward
        [yes | no]
    ip_protocol
        [any | protocol]
    internal
        [yes | no]
    twelve_forward(12-forward)
        [yes | no]
    last_hop-pool
        [ [pool_name] | none]
    mask
        { [ipv4] | [ipv6] }
    mirror
        { [disabled | enabled | none] }
    nat64
        [enabled | disabled]
    persist
        [list]
    profiles
        [none | default | list ]
    policies
        [none | default | list ]
    rate_class
        [name]
    rate_limit
        [integer]
    rate_limit-mode
        [destination | object | object-destination |
        object-source | object-source-destination |
        source | source-destination]
    rate_limit-dst
        [integer]
    rate_limit-src
        [integer]
    rules
        [none | list ]
    related_rules
        [none | list ]
    reject
        [yes | no]
    source
        { [ipv4[/prefixlen]] | [ipv6[/prefixlen]] }
    source_address_translation
        [none | snat:pool_name | lsn | automap | dictionary ]
    source_port
        [change | preserve | preserve-strict]
    state
        [enabled | disabled]
    traffic_classes
        [none | default | list ]
    translate_address
        [enabled | disabled]
    translate_port
        [enabled | disabled]
    vlans
        [none | default | dictionary]

        vlan_ids
            [ list]
        enabled
            [ true | false ]
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;create&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
                &quot;destination&quot;: destination,
                &quot;pool&quot;: pool,
                &quot;address_status&quot;: address_status,
                &quot;auto_lasthop&quot;: auto_lasthop,
                &quot;bwc_policy&quot;: bwc_policy,
                &quot;cmp_enabled&quot;: cmp_enabled,
                &quot;connection_limit&quot;: connection_limit,
                &quot;dhcp_relay&quot;: dhcp_relay,
                &quot;description&quot;: description,
                &quot;fallback_persistence&quot;: fallback_persistence,
                &quot;flow_eviction_policy&quot;: flow_eviction_policy,
                &quot;gtm_score&quot;: gtm_score,
                &quot;ip_forward&quot;: ip_forward,
                &quot;ip_protocol&quot;: ip_protocol,
                &quot;internal&quot;: internal,
                &quot;twelve_forward&quot;: twelve_forward,
                &quot;last_hop_pool&quot;: last_hop_pool,
                &quot;mask&quot;: mask,
                &quot;mirror&quot;: mirror,
                &quot;nat64&quot;: nat64,
                &quot;persist&quot;: persist,
                &quot;profiles&quot;: profiles,
                &quot;policies&quot;: policies,
                &quot;rate_class&quot;: rate_class,
                &quot;rate_limit&quot;: rate_limit,
                &quot;rate_limit_mode&quot;: rate_limit_mode,
                &quot;rate_limit_dst&quot;: rate_limit_dst,
                &quot;rate_limit_src&quot;: rate_limit_src,
                &quot;rules&quot;: rules,
                &quot;related_rules&quot;: related_rules,
                &quot;reject&quot;: reject,
                &quot;source&quot;: source,
                &quot;source_address_translation&quot;: source_address_translation,
                &quot;source_port&quot;: source_port,
                &quot;virtual_state&quot;: virtual_state,
                &quot;traffic_classes&quot;: traffic_classes,
                &quot;translate_address&quot;: translate_address,
                &quot;translate_port&quot;: translate_port,
                &quot;vlans&quot;: vlans,
            },
        )

    existing = __salt__[&quot;bigip.list_virtual&quot;](hostname, username, password, name)

    # does this virtual exist?
    if existing[&quot;code&quot;] == 200:

        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;A virtual by this name currently exists.  No change made.&quot;

    elif existing[&quot;code&quot;] == 404:

        # create it
        virtual = __salt__[&quot;bigip.create_virtual&quot;](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            destination=destination,
            description=description,
            pool=pool,
            address_status=address_status,
            auto_lasthop=auto_lasthop,
            bwc_policy=bwc_policy,
            cmp_enabled=cmp_enabled,
            connection_limit=connection_limit,
            dhcp_relay=dhcp_relay,
            fallback_persistence=fallback_persistence,
            flow_eviction_policy=flow_eviction_policy,
            gtm_score=gtm_score,
            ip_forward=ip_forward,
            ip_protocol=ip_protocol,
            internal=internal,
            twelve_forward=twelve_forward,
            last_hop_pool=last_hop_pool,
            mask=mask,
            mirror=mirror,
            nat64=nat64,
            persist=persist,
            profiles=profiles,
            policies=policies,
            rate_class=rate_class,
            rate_limit=rate_limit,
            rate_limit_mode=rate_limit_mode,
            rate_limit_dst=rate_limit_dst,
            rate_limit_src=rate_limit_src,
            rules=rules,
            related_rules=related_rules,
            reject=reject,
            source=source,
            source_address_translation=source_address_translation,
            source_port=source_port,
            state=virtual_state,
            traffic_classes=traffic_classes,
            translate_address=translate_address,
            translate_port=translate_port,
            vlans=vlans,
        )
        if virtual[&quot;code&quot;] == 200:
            ret[&quot;result&quot;] = True
            ret[&quot;changes&quot;][&quot;old&quot;] = {}
            ret[&quot;changes&quot;][&quot;new&quot;] = virtual[&quot;content&quot;]
            ret[&quot;comment&quot;] = &quot;Virtual was successfully created.&quot;
        else:
            ret = _load_result(existing, ret)

    # else something else was returned
    else:
        ret = _load_result(existing, ret)

    return ret


def manage_virtual(
    hostname,
    username,
    password,
    name,
    destination,
    pool=None,
    address_status=None,
    auto_lasthop=None,
    bwc_policy=None,
    cmp_enabled=None,
    connection_limit=None,
    dhcp_relay=None,
    description=None,
    fallback_persistence=None,
    flow_eviction_policy=None,
    gtm_score=None,
    ip_forward=None,
    ip_protocol=None,
    internal=None,
    twelve_forward=None,
    last_hop_pool=None,
    mask=None,
    mirror=None,
    nat64=None,
    persist=None,
    profiles=None,
    policies=None,
    rate_class=None,
    rate_limit=None,
    rate_limit_mode=None,
    rate_limit_dst=None,
    rate_limit_src=None,
    rules=None,
    related_rules=None,
    reject=None,
    source=None,
    source_address_translation=None,
    source_port=None,
    virtual_state=None,
    traffic_classes=None,
    translate_address=None,
    translate_port=None,
    vlans=None,
):
    &quot;&quot;&quot;
    Manage a virtual server.  If a virtual does not exists it will be created, otherwise only the
    parameters specified will be enforced.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the virtual to create
    destination
        [ [virtual_address_name:port] | [ipv4:port] | [ipv6.port] ]
    pool
        [ [pool_name] | none]
    address_status
        [yes | no]
    auto_lasthop
        [default | enabled | disabled ]
    bwc_policy
        [none] | string]
    cmp_enabled
        [yes | no]
    dhcp_relay
        [yes | no}
    connection_limit
        [integer]
    description
        [string]
    state
        [disabled | enabled]
    fallback_persistence
        [none | [profile name] ]
    flow_eviction_policy
        [none | [eviction policy name] ]
    gtm_score
        [integer]
    ip_forward
        [yes | no]
    ip_protocol
        [any | protocol]
    internal
        [yes | no]
    twelve_forward(12-forward)
        [yes | no]
    last_hop-pool
        [ [pool_name] | none]
    mask
        { [ipv4] | [ipv6] }
    mirror
        { [disabled | enabled | none] }
    nat64
        [enabled | disabled]
    persist
        [list]
    profiles
        [none | default | list ]
    policies
        [none | default | list ]
    rate_class
        [name]
    rate_limit
        [integer]
    rate_limit-mode
        [destination | object | object-destination |
        object-source | object-source-destination |
        source | source-destination]
    rate_limit-dst
        [integer]
    rate_limit-src
        [integer]
    rules
        [none | list ]
    related_rules
        [none | list ]
    reject
        [yes | no]
    source
        { [ipv4[/prefixlen]] | [ipv6[/prefixlen]] }
    source_address_translation
        [none | snat:pool_name | lsn | automap | dictionary ]
    source_port
        [change | preserve | preserve-strict]
    state
        [enabled | disabled]
    traffic_classes
        [none | default | list ]
    translate_address
        [enabled | disabled]
    translate_port
        [enabled | disabled]
    vlans
        [none | default | dictionary]

        vlan_ids
            [ list]
        enabled
            [ true | false ]
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;manage&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
                &quot;destination&quot;: destination,
                &quot;pool&quot;: pool,
                &quot;address_status&quot;: address_status,
                &quot;auto_lasthop&quot;: auto_lasthop,
                &quot;bwc_policy&quot;: bwc_policy,
                &quot;cmp_enabled&quot;: cmp_enabled,
                &quot;connection_limit&quot;: connection_limit,
                &quot;dhcp_relay&quot;: dhcp_relay,
                &quot;description&quot;: description,
                &quot;fallback_persistence&quot;: fallback_persistence,
                &quot;flow_eviction_policy&quot;: flow_eviction_policy,
                &quot;gtm_score&quot;: gtm_score,
                &quot;ip_forward&quot;: ip_forward,
                &quot;ip_protocol&quot;: ip_protocol,
                &quot;internal&quot;: internal,
                &quot;twelve_forward&quot;: twelve_forward,
                &quot;last_hop_pool&quot;: last_hop_pool,
                &quot;mask&quot;: mask,
                &quot;mirror&quot;: mirror,
                &quot;nat64&quot;: nat64,
                &quot;persist&quot;: persist,
                &quot;profiles&quot;: profiles,
                &quot;policies&quot;: policies,
                &quot;rate_class&quot;: rate_class,
                &quot;rate_limit&quot;: rate_limit,
                &quot;rate_limit_mode&quot;: rate_limit_mode,
                &quot;rate_limit_dst&quot;: rate_limit_dst,
                &quot;rate_limit_src&quot;: rate_limit_src,
                &quot;rules&quot;: rules,
                &quot;related_rules&quot;: related_rules,
                &quot;reject&quot;: reject,
                &quot;source&quot;: source,
                &quot;source_address_translation&quot;: source_address_translation,
                &quot;source_port&quot;: source_port,
                &quot;virtual_state&quot;: virtual_state,
                &quot;traffic_classes&quot;: traffic_classes,
                &quot;translate_address&quot;: translate_address,
                &quot;translate_port&quot;: translate_port,
                &quot;vlans&quot;: vlans,
            },
        )

    existing = __salt__[&quot;bigip.list_virtual&quot;](hostname, username, password, name)

    # does this virtual exist?
    if existing[&quot;code&quot;] == 200:

        # modify
        modified = __salt__[&quot;bigip.modify_virtual&quot;](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            destination=destination,
            description=description,
            pool=pool,
            address_status=address_status,
            auto_lasthop=auto_lasthop,
            bwc_policy=bwc_policy,
            cmp_enabled=cmp_enabled,
            connection_limit=connection_limit,
            dhcp_relay=dhcp_relay,
            fallback_persistence=fallback_persistence,
            flow_eviction_policy=flow_eviction_policy,
            gtm_score=gtm_score,
            ip_forward=ip_forward,
            ip_protocol=ip_protocol,
            internal=internal,
            twelve_forward=twelve_forward,
            last_hop_pool=last_hop_pool,
            mask=mask,
            mirror=mirror,
            nat64=nat64,
            persist=persist,
            profiles=profiles,
            policies=policies,
            rate_class=rate_class,
            rate_limit=rate_limit,
            rate_limit_mode=rate_limit_mode,
            rate_limit_dst=rate_limit_dst,
            rate_limit_src=rate_limit_src,
            rules=rules,
            related_rules=related_rules,
            reject=reject,
            source=source,
            source_address_translation=source_address_translation,
            source_port=source_port,
            state=virtual_state,
            traffic_classes=traffic_classes,
            translate_address=translate_address,
            translate_port=translate_port,
            vlans=vlans,
        )

        # was the modification successful?
        if modified[&quot;code&quot;] == 200:

            # relist it to compare
            relisting = __salt__[&quot;bigip.list_virtual&quot;](
                hostname, username, password, name
            )

            if relisting[&quot;code&quot;] == 200:

                relisting = _strip_key(relisting, &quot;generation&quot;)
                existing = _strip_key(existing, &quot;generation&quot;)

                ret = _check_for_changes(&quot;Virtual&quot;, ret, existing, relisting)
            else:
                ret = _load_result(relisting, ret)

        else:
            ret = _load_result(modified, ret)

    elif existing[&quot;code&quot;] == 404:

        # create it
        virtual = __salt__[&quot;bigip.create_virtual&quot;](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            destination=destination,
            description=description,
            pool=pool,
            address_status=address_status,
            auto_lasthop=auto_lasthop,
            bwc_policy=bwc_policy,
            cmp_enabled=cmp_enabled,
            connection_limit=connection_limit,
            dhcp_relay=dhcp_relay,
            fallback_persistence=fallback_persistence,
            flow_eviction_policy=flow_eviction_policy,
            gtm_score=gtm_score,
            ip_forward=ip_forward,
            ip_protocol=ip_protocol,
            internal=internal,
            twelve_forward=twelve_forward,
            last_hop_pool=last_hop_pool,
            mask=mask,
            mirror=mirror,
            nat64=nat64,
            persist=persist,
            profiles=profiles,
            policies=policies,
            rate_class=rate_class,
            rate_limit=rate_limit,
            rate_limit_mode=rate_limit_mode,
            rate_limit_dst=rate_limit_dst,
            rate_limit_src=rate_limit_src,
            rules=rules,
            related_rules=related_rules,
            reject=reject,
            source=source,
            source_address_translation=source_address_translation,
            source_port=source_port,
            state=virtual_state,
            traffic_classes=traffic_classes,
            translate_address=translate_address,
            translate_port=translate_port,
            vlans=vlans,
        )

        # were we able to create it?
        if virtual[&quot;code&quot;] == 200:
            ret[&quot;result&quot;] = True
            ret[&quot;changes&quot;][&quot;old&quot;] = {}
            ret[&quot;changes&quot;][&quot;new&quot;] = virtual[&quot;content&quot;]
            ret[
                &quot;comment&quot;
            ] = &quot;Virtual was successfully created and enforced to the desired state.&quot;

        else:
            ret = _load_result(virtual, ret)

    else:
        ret = _load_result(existing, ret)

    return ret


def modify_virtual(
    hostname,
    username,
    password,
    name,
    destination,
    pool=None,
    address_status=None,
    auto_lasthop=None,
    bwc_policy=None,
    cmp_enabled=None,
    connection_limit=None,
    dhcp_relay=None,
    description=None,
    fallback_persistence=None,
    flow_eviction_policy=None,
    gtm_score=None,
    ip_forward=None,
    ip_protocol=None,
    internal=None,
    twelve_forward=None,
    last_hop_pool=None,
    mask=None,
    mirror=None,
    nat64=None,
    persist=None,
    profiles=None,
    policies=None,
    rate_class=None,
    rate_limit=None,
    rate_limit_mode=None,
    rate_limit_dst=None,
    rate_limit_src=None,
    rules=None,
    related_rules=None,
    reject=None,
    source=None,
    source_address_translation=None,
    source_port=None,
    virtual_state=None,
    traffic_classes=None,
    translate_address=None,
    translate_port=None,
    vlans=None,
):
    &quot;&quot;&quot;
    Modify an virtual server.  modify an existing virtual.  Only parameters specified will be enforced.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the virtual to create
    destination
        [ [virtual_address_name:port] | [ipv4:port] | [ipv6.port] ]
    pool
        [ [pool_name] | none]
    address_status
        [yes | no]
    auto_lasthop
        [default | enabled | disabled ]
    bwc_policy
        [none] | string]
    cmp_enabled
        [yes | no]
    dhcp_relay
        [yes | no}
    connection_limit
        [integer]
    description
        [string]
    state
        [disabled | enabled]
    fallback_persistence
        [none | [profile name] ]
    flow_eviction_policy
        [none | [eviction policy name] ]
    gtm_score
        [integer]
    ip_forward
        [yes | no]
    ip_protocol
        [any | protocol]
    internal
        [yes | no]
    twelve_forward(12-forward)
        [yes | no]
    last_hop-pool
        [ [pool_name] | none]
    mask
        { [ipv4] | [ipv6] }
    mirror
        { [disabled | enabled | none] }
    nat64
        [enabled | disabled]
    persist
        [list]
    profiles
        [none | default | list ]
    policies
        [none | default | list ]
    rate_class
        [name]
    rate_limit
        [integer]
    rate_limit-mode
        [destination | object | object-destination |
        object-source | object-source-destination |
        source | source-destination]
    rate_limit_dst
        [integer]
    rate_limit_src
        [integer]
    rules
        [none | list ]
    related_rules
        [none | list ]
    reject
        [yes | no]
    source
        { [ipv4[/prefixlen]] | [ipv6[/prefixlen]] }
    source_address_translation
        [none | snat:pool_name | lsn | automap | dictionary ]
    source_port
        [change | preserve | preserve-strict]
    state
        [enabled | disabled]
    traffic_classes
        [none | default | list ]
    translate_address
        [enabled | disabled]
    translate_port
        [enabled | disabled]
    vlans
        [none | default | dictionary ]

        vlan_ids
            [ list]
        enabled
            [ true | false ]

    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;modify&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
                &quot;destination&quot;: destination,
                &quot;pool&quot;: pool,
                &quot;address_status&quot;: address_status,
                &quot;auto_lasthop&quot;: auto_lasthop,
                &quot;bwc_policy&quot;: bwc_policy,
                &quot;cmp_enabled&quot;: cmp_enabled,
                &quot;connection_limit&quot;: connection_limit,
                &quot;dhcp_relay&quot;: dhcp_relay,
                &quot;description&quot;: description,
                &quot;fallback_persistence&quot;: fallback_persistence,
                &quot;flow_eviction_policy&quot;: flow_eviction_policy,
                &quot;gtm_score&quot;: gtm_score,
                &quot;ip_forward&quot;: ip_forward,
                &quot;ip_protocol&quot;: ip_protocol,
                &quot;internal&quot;: internal,
                &quot;twelve_forward&quot;: twelve_forward,
                &quot;last_hop_pool&quot;: last_hop_pool,
                &quot;mask&quot;: mask,
                &quot;mirror&quot;: mirror,
                &quot;nat64&quot;: nat64,
                &quot;persist&quot;: persist,
                &quot;profiles&quot;: profiles,
                &quot;policies&quot;: policies,
                &quot;rate_class&quot;: rate_class,
                &quot;rate_limit&quot;: rate_limit,
                &quot;rate_limit_mode&quot;: rate_limit_mode,
                &quot;rate_limit_dst&quot;: rate_limit_dst,
                &quot;rate_limit_src&quot;: rate_limit_src,
                &quot;rules&quot;: rules,
                &quot;related_rules&quot;: related_rules,
                &quot;reject&quot;: reject,
                &quot;source&quot;: source,
                &quot;source_address_translation&quot;: source_address_translation,
                &quot;source_port&quot;: source_port,
                &quot;virtual_state&quot;: virtual_state,
                &quot;traffic_classes&quot;: traffic_classes,
                &quot;translate_address&quot;: translate_address,
                &quot;translate_port&quot;: translate_port,
                &quot;vlans&quot;: vlans,
            },
        )

    existing = __salt__[&quot;bigip.list_virtual&quot;](hostname, username, password, name)

    # does this virtual exist?
    if existing[&quot;code&quot;] == 200:

        # modify
        modified = __salt__[&quot;bigip.modify_virtual&quot;](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            destination=destination,
            description=description,
            pool=pool,
            address_status=address_status,
            auto_lasthop=auto_lasthop,
            bwc_policy=bwc_policy,
            cmp_enabled=cmp_enabled,
            connection_limit=connection_limit,
            dhcp_relay=dhcp_relay,
            fallback_persistence=fallback_persistence,
            flow_eviction_policy=flow_eviction_policy,
            gtm_score=gtm_score,
            ip_forward=ip_forward,
            ip_protocol=ip_protocol,
            internal=internal,
            twelve_forward=twelve_forward,
            last_hop_pool=last_hop_pool,
            mask=mask,
            mirror=mirror,
            nat64=nat64,
            persist=persist,
            profiles=profiles,
            policies=policies,
            rate_class=rate_class,
            rate_limit=rate_limit,
            rate_limit_mode=rate_limit_mode,
            rate_limit_dst=rate_limit_dst,
            rate_limit_src=rate_limit_src,
            rules=rules,
            related_rules=related_rules,
            reject=reject,
            source=source,
            source_address_translation=source_address_translation,
            source_port=source_port,
            state=virtual_state,
            traffic_classes=traffic_classes,
            translate_address=translate_address,
            translate_port=translate_port,
            vlans=vlans,
        )

        # was the modification successful?
        if modified[&quot;code&quot;] == 200:

            # relist it to compare
            relisting = __salt__[&quot;bigip.list_virtual&quot;](
                hostname, username, password, name
            )

            if relisting[&quot;code&quot;] == 200:

                relisting = _strip_key(relisting, &quot;generation&quot;)
                existing = _strip_key(existing, &quot;generation&quot;)

                ret = _check_for_changes(&quot;Virtual&quot;, ret, existing, relisting)
            else:
                ret = _load_result(relisting, ret)

        else:
            ret = _load_result(modified, ret)

    elif existing[&quot;code&quot;] == 404:
        ret[&quot;comment&quot;] = &quot;A Virtual with this name was not found.&quot;
        # else something else was returned
    else:
        ret = _load_result(existing, ret)

    return ret


def delete_virtual(hostname, username, password, name):
    &quot;&quot;&quot;
    Delete an existing virtual.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the virtual which will be deleted
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;delete&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
            },
        )

    # is this virtual currently configured?
    existing = __salt__[&quot;bigip.list_virtual&quot;](hostname, username, password, name)
    # if it exists by name
    if existing[&quot;code&quot;] == 200:

        deleted = __salt__[&quot;bigip.delete_virtual&quot;](hostname, username, password, name)
        # did we get rid of it?
        if deleted[&quot;code&quot;] == 200:
            ret[&quot;result&quot;] = True
            ret[&quot;comment&quot;] = &quot;Virtual was successfully deleted.&quot;
            ret[&quot;changes&quot;][&quot;old&quot;] = existing[&quot;content&quot;]
            ret[&quot;changes&quot;][&quot;new&quot;] = {}
        # something bad happened
        else:
            ret = _load_result(deleted, ret)

    # not found
    elif existing[&quot;code&quot;] == 404:
        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;This virtual already does not exist. No changes made.&quot;
        ret[&quot;changes&quot;][&quot;old&quot;] = {}
        ret[&quot;changes&quot;][&quot;new&quot;] = {}
    else:
        ret = _load_result(existing, ret)

    return ret


def list_monitor(hostname, username, password, monitor_type, name):
    &quot;&quot;&quot;
    A function to list an existing monitor.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    monitor_type
        The type of monitor to list
    name
        The name of the monitor to list
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;list&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;monitor_type&quot;: monitor_type,
                &quot;name&quot;: name,
            },
        )

    response = __salt__[&quot;bigip.list_monitor&quot;](
        hostname, username, password, monitor_type, name
    )
    return _load_result(response, ret)


def create_monitor(hostname, username, password, monitor_type, name, **kwargs):
    &quot;&quot;&quot;
    A function to connect to a bigip device and create a monitor.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    monitor_type
        The type of monitor to create
    name
        The name of the monitor to create
    kwargs
        [ arg=val ] ...

        Consult F5 BIGIP user guide for specific options for each monitor type.
        Typically, tmsh arg names are used.
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:

        params = {
            &quot;hostname&quot;: hostname,
            &quot;username&quot;: username,
            &quot;password&quot;: password,
            &quot;monitor_type&quot;: monitor_type,
            &quot;name&quot;: name,
        }

        for key, value in kwargs.items():
            params[key] = value

        return _test_output(ret, &quot;create&quot;, params)

    # is this monitor currently configured?
    existing = __salt__[&quot;bigip.list_monitor&quot;](
        hostname, username, password, monitor_type, name
    )

    # if it exists
    if existing[&quot;code&quot;] == 200:

        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;A monitor by this name currently exists.  No change made.&quot;

    # if it doesn't exist
    elif existing[&quot;code&quot;] == 404:

        response = __salt__[&quot;bigip.create_monitor&quot;](
            hostname, username, password, monitor_type, name, **kwargs
        )
        if response[&quot;code&quot;] == 200:
            ret[&quot;result&quot;] = True
            ret[&quot;changes&quot;][&quot;old&quot;] = {}
            ret[&quot;changes&quot;][&quot;new&quot;] = response[&quot;content&quot;]
            ret[&quot;comment&quot;] = &quot;Monitor was successfully created.&quot;
        else:
            ret = _load_result(response, ret)

    # else something else was returned
    else:
        ret = _load_result(existing, ret)

    return ret


def manage_monitor(hostname, username, password, monitor_type, name, **kwargs):
    &quot;&quot;&quot;
    Create a new monitor if a monitor of this type and name does not already exists.  If it does exists, only
    the parameters specified will be enforced.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    monitor_type
        The type of monitor to create
    name
        The name of the monitor to create
    kwargs
        [ arg=val ] ...

        Consult F5 BIGIP user guide for specific options for each monitor type.
        Typically, tmsh arg names are used.
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:

        params = {
            &quot;hostname&quot;: hostname,
            &quot;username&quot;: username,
            &quot;password&quot;: password,
            &quot;monitor_type&quot;: monitor_type,
            &quot;name&quot;: name,
        }

        for key, value in kwargs.items():
            params[key] = value

        return _test_output(ret, &quot;manage&quot;, params)

    # is this monitor currently configured?
    existing = __salt__[&quot;bigip.list_monitor&quot;](
        hostname, username, password, monitor_type, name
    )

    # if it exists
    if existing[&quot;code&quot;] == 200:

        # modify the monitor
        modified = __salt__[&quot;bigip.modify_monitor&quot;](
            hostname, username, password, monitor_type, name, **kwargs
        )

        # was the modification successful?
        if modified[&quot;code&quot;] == 200:
            del existing[&quot;content&quot;][&quot;selfLink&quot;]
            del modified[&quot;content&quot;][&quot;selfLink&quot;]
            ret = _check_for_changes(&quot;Monitor&quot;, ret, existing, modified)
        else:
            ret = _load_result(modified, ret)

    # if it doesn't exist
    elif existing[&quot;code&quot;] == 404:

        response = __salt__[&quot;bigip.create_monitor&quot;](
            hostname, username, password, monitor_type, name, **kwargs
        )
        if response[&quot;code&quot;] == 200:
            ret[&quot;result&quot;] = True
            ret[&quot;changes&quot;][&quot;old&quot;] = {}
            ret[&quot;changes&quot;][&quot;new&quot;] = response[&quot;content&quot;]
            ret[&quot;comment&quot;] = &quot;Monitor was successfully created.&quot;
        else:
            ret = _load_result(response, ret)

    # else something else was returned
    else:
        ret = _load_result(existing, ret)

    return ret


def modify_monitor(hostname, username, password, monitor_type, name, **kwargs):
    &quot;&quot;&quot;
    Modify an existing monitor.  If it does exists, only
    the parameters specified will be enforced.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    monitor_type
        The type of monitor to create
    name
        The name of the monitor to create
    kwargs
        [ arg=val ] ...

        Consult F5 BIGIP user guide for specific options for each monitor type.
        Typically, tmsh arg names are used.
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:

        params = {
            &quot;hostname&quot;: hostname,
            &quot;username&quot;: username,
            &quot;password&quot;: password,
            &quot;monitor_type&quot;: monitor_type,
            &quot;name&quot;: name,
        }

        for key, value in kwargs.items():
            params[key] = value

        return _test_output(ret, &quot;modify&quot;, params)

    # is this monitor currently configured?
    existing = __salt__[&quot;bigip.list_monitor&quot;](
        hostname, username, password, monitor_type, name
    )

    # if it exists
    if existing[&quot;code&quot;] == 200:

        # modify the monitor
        modified = __salt__[&quot;bigip.modify_monitor&quot;](
            hostname, username, password, monitor_type, name, **kwargs
        )

        # was the modification successful?
        if modified[&quot;code&quot;] == 200:
            del existing[&quot;content&quot;][&quot;selfLink&quot;]
            del modified[&quot;content&quot;][&quot;selfLink&quot;]
            ret = _check_for_changes(&quot;Monitor&quot;, ret, existing, modified)
        else:
            ret = _load_result(modified, ret)

    # if it doesn't exist
    elif existing[&quot;code&quot;] == 404:
        ret[&quot;comment&quot;] = &quot;A Monitor with this name was not found.&quot;
    # else something else was returned
    else:
        ret = _load_result(existing, ret)

    return ret


def delete_monitor(hostname, username, password, monitor_type, name):
    &quot;&quot;&quot;
    Modify an existing monitor.  If it does exists, only
    the parameters specified will be enforced.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    monitor_type
        The type of monitor to create
    name
        The name of the monitor to create
    kwargs
        [ arg=val ] ...

        Consult F5 BIGIP user guide for specific options for each monitor type.
        Typically, tmsh arg names are used.
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;delete&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;monitor_type&quot;: monitor_type,
                &quot;name&quot;: name,
            },
        )

    # is this profile currently configured?
    existing = __salt__[&quot;bigip.list_monitor&quot;](
        hostname, username, password, monitor_type, name
    )
    # if it exists by name
    if existing[&quot;code&quot;] == 200:

        deleted = __salt__[&quot;bigip.delete_monitor&quot;](
            hostname, username, password, monitor_type, name
        )
        # did we get rid of it?
        if deleted[&quot;code&quot;] == 200:
            ret[&quot;result&quot;] = True
            ret[&quot;comment&quot;] = &quot;Monitor was successfully deleted.&quot;
            ret[&quot;changes&quot;][&quot;old&quot;] = existing[&quot;content&quot;]
            ret[&quot;changes&quot;][&quot;new&quot;] = {}
        # something bad happened
        else:
            ret = _load_result(deleted, ret)

    # not found
    elif existing[&quot;code&quot;] == 404:
        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;This Monitor already does not exist. No changes made.&quot;
        ret[&quot;changes&quot;][&quot;old&quot;] = {}
        ret[&quot;changes&quot;][&quot;new&quot;] = {}
    else:
        ret = _load_result(existing, ret)

    return ret


def list_profile(hostname, username, password, profile_type, name):
    &quot;&quot;&quot;
    A function to list an existing profile.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    profile_type
        The type of profile to list
    name
        The name of the profile to list
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;list&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;profile_type&quot;: profile_type,
                &quot;name&quot;: name,
            },
        )

    response = __salt__[&quot;bigip.list_profile&quot;](
        hostname, username, password, profile_type, name
    )
    return _load_result(response, ret)


def create_profile(hostname, username, password, profile_type, name, **kwargs):
    r&quot;&quot;&quot;
    A function to connect to a bigip device and create a profile.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    profile_type
        The type of profile to create
    name
        The name of the profile to create
    kwargs
        [ arg=val ] ...

        Consult F5 BIGIP user guide for specific options for each profile type.
        Typically, tmsh arg names are used.

    Special Characters ``|``, ``,`` and ``:`` must be escaped using ``\`` when
    used within strings.

    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;create&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;profile_type&quot;: profile_type,
                &quot;name&quot;: name,
            },
        )

    # is this profile currently configured?
    existing = __salt__[&quot;bigip.list_profile&quot;](
        hostname, username, password, profile_type, name
    )

    # if it exists
    if existing[&quot;code&quot;] == 200:

        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;A profile by this name currently exists.  No change made.&quot;

    # if it doesn't exist
    elif existing[&quot;code&quot;] == 404:

        response = __salt__[&quot;bigip.create_profile&quot;](
            hostname, username, password, profile_type, name, **kwargs
        )

        if response[&quot;code&quot;] == 200:
            ret[&quot;result&quot;] = True
            ret[&quot;changes&quot;][&quot;old&quot;] = {}
            ret[&quot;changes&quot;][&quot;new&quot;] = response[&quot;content&quot;]
            ret[&quot;comment&quot;] = &quot;Profile was successfully created.&quot;
        else:
            ret = _load_result(response, ret)

    # else something else was returned
    else:
        ret = _load_result(existing, ret)

    return ret


def manage_profile(hostname, username, password, profile_type, name, **kwargs):
    &quot;&quot;&quot;
    Create a new profile if a monitor of this type and name does not already exists.  If it does exists, only
    the parameters specified will be enforced.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    profile_type
        The type of profile to create
    name
        The name of the profile to create
    kwargs
        [ arg=val ] ...

        Consult F5 BIGIP user guide for specific options for each profile type.
        Typically, tmsh arg names are used.
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:

        params = {
            &quot;hostname&quot;: hostname,
            &quot;username&quot;: username,
            &quot;password&quot;: password,
            &quot;profile_type&quot;: profile_type,
            &quot;name&quot;: name,
        }

        for key, value in kwargs.items():
            params[key] = value

        return _test_output(ret, &quot;manage&quot;, params)

    # is this profile currently configured?
    existing = __salt__[&quot;bigip.list_profile&quot;](
        hostname, username, password, profile_type, name
    )

    # if it exists
    if existing[&quot;code&quot;] == 200:

        # modify the profile
        modified = __salt__[&quot;bigip.modify_profile&quot;](
            hostname, username, password, profile_type, name, **kwargs
        )

        # was the modification successful?
        if modified[&quot;code&quot;] == 200:
            del existing[&quot;content&quot;][&quot;selfLink&quot;]
            del modified[&quot;content&quot;][&quot;selfLink&quot;]
            ret = _check_for_changes(&quot;Profile&quot;, ret, existing, modified)
        else:
            ret = _load_result(modified, ret)

    # if it doesn't exist
    elif existing[&quot;code&quot;] == 404:

        response = __salt__[&quot;bigip.create_profile&quot;](
            hostname, username, password, profile_type, name, **kwargs
        )
        if response[&quot;code&quot;] == 200:
            ret[&quot;result&quot;] = True
            ret[&quot;changes&quot;][&quot;old&quot;] = {}
            ret[&quot;changes&quot;][&quot;new&quot;] = response[&quot;content&quot;]
            ret[&quot;comment&quot;] = &quot;Profile was successfully created.&quot;
        else:
            ret = _load_result(existing, ret)

    # else something else was returned
    else:
        ret = _load_result(existing, ret)

    return ret


def modify_profile(hostname, username, password, profile_type, name, **kwargs):
    &quot;&quot;&quot;
    Modify an existing profile.  If it does exists, only
    the parameters specified will be enforced.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    profile_type
        The type of profile to create
    name
        The name of the profile to create
    kwargs
        [ arg=val ] ...

        Consult F5 BIGIP user guide for specific options for each monitor type.
        Typically, tmsh arg names are used.
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:

        params = {
            &quot;hostname&quot;: hostname,
            &quot;username&quot;: username,
            &quot;password&quot;: password,
            &quot;profile_type&quot;: profile_type,
            &quot;name&quot;: name,
        }

        for key, value in kwargs.items():
            params[key] = value

        return _test_output(ret, &quot;modify&quot;, params)

    # is this profile currently configured?
    existing = __salt__[&quot;bigip.list_profile&quot;](
        hostname, username, password, profile_type, name
    )

    # if it exists
    if existing[&quot;code&quot;] == 200:

        # modify the profile
        modified = __salt__[&quot;bigip.modify_profile&quot;](
            hostname, username, password, profile_type, name, **kwargs
        )

        # was the modification successful?
        if modified[&quot;code&quot;] == 200:
            del existing[&quot;content&quot;][&quot;selfLink&quot;]
            del modified[&quot;content&quot;][&quot;selfLink&quot;]
            ret = _check_for_changes(&quot;Profile&quot;, ret, existing, modified)
        else:
            ret = _load_result(modified, ret)

    # if it doesn't exist
    elif existing[&quot;code&quot;] == 404:
        ret[&quot;comment&quot;] = &quot;A Profile with this name was not found.&quot;
    # else something else was returned
    else:
        ret = _load_result(existing, ret)

    return ret


def delete_profile(hostname, username, password, profile_type, name):
    &quot;&quot;&quot;
    Modify an existing profile.  If it does exists, only
    the parameters specified will be enforced.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    profile_type
        The type of profile to create
    name
        The name of the profile to create
    kwargs
        [ arg=val ] ...

        Consult F5 BIGIP user guide for specific options for each profile type.
        Typically, tmsh arg names are used.
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;delete&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;profile_type&quot;: profile_type,
                &quot;name&quot;: name,
            },
        )

    # is this profile currently configured?
    existing = __salt__[&quot;bigip.list_profile&quot;](
        hostname, username, password, profile_type, name
    )

    # if it exists by name
    if existing[&quot;code&quot;] == 200:

        deleted = __salt__[&quot;bigip.delete_profile&quot;](
            hostname, username, password, profile_type, name
        )
        # did we get rid of it?
        if deleted[&quot;code&quot;] == 200:
            ret[&quot;result&quot;] = True
            ret[&quot;comment&quot;] = &quot;Profile was successfully deleted.&quot;
            ret[&quot;changes&quot;][&quot;old&quot;] = existing[&quot;content&quot;]
            ret[&quot;changes&quot;][&quot;new&quot;] = {}
        # something bad happened
        else:
            ret = _load_result(deleted, ret)

    # not found
    elif existing[&quot;code&quot;] == 404:
        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;This Profile already does not exist. No changes made.&quot;
        ret[&quot;changes&quot;][&quot;old&quot;] = {}
        ret[&quot;changes&quot;][&quot;new&quot;] = {}
    else:
        ret = _load_result(existing, ret)

    return ret
</PRE>
</div>
  </div>
</body>
</html>
