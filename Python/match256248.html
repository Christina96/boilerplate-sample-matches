<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for lxd_container.py &amp; bigip.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for lxd_container.py &amp; bigip.py
      </h3>
<h1 align="center">
        1.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>lxd_container.py (2.1840873%)<th>bigip.py (0.6698565%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(49-65)<td><a href="#" name="0">(627-646)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>lxd_container.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from salt.exceptions import CommandExecutionError, SaltInvocationError
2 __docformat__ = "restructuredtext en"
3 __virtualname__ = "lxd_container"
4 CONTAINER_STATUS_RUNNING = 103
5 CONTAINER_STATUS_FROZEN = 110
6 CONTAINER_STATUS_STOPPED = 102
7 def __virtual__():
8     """
9     return (F<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>alse, "lxd module could not be loaded")
10 def present(
11     name,
12     running=None,
13     source=None,
14     profiles=None,
15     config=None,
16     devices=None,
17     architecture="x86_64",
18     ephemeral=False,
19     restart_on_change=False,
20     remote_addr=None,
21     cert=None,
22     key=None,
23     verify_cert=</b></font>True,
24 ):
25     """
26     Create the named container if it does not exist
27     name
28         The name of the container to be created
29     running : None
30         * If ``True``, ensure that the container is running
31         * If ``False``, ensure that the container is stopped
32         * If ``None``, do nothing with regards to the running state of the
33           container
34     source : None
35         Can be either a string containing an image alias:
36         .. code-block:: none
37              "xenial/amd64"
38         or an dict with type "image" with alias:
39         .. code-block:: python
40             {"type": "image",
41              "alias": "xenial/amd64"}
42         or image with "fingerprint":
43         .. code-block:: python
44             {"type": "image",
45              "fingerprint": "SHA-256"}
46         or image with "properties":
47         .. code-block:: python
48             {"type": "image",
49              "properties": {
50                 "os": "ubuntu",
51                 "release": "14.04",
52                 "architecture": "x86_64"
53              }}
54         or none:
55         .. code-block:: python
56             {"type": "none"}
57         or copy:
58         .. code-block:: python
59             {"type": "copy",
60              "source": "my-old-container"}
61     profiles : ['default']
62         List of profiles to apply on this container
63     config :
64         A config dict or None (None = unset).
65         Can also be a list:
66         .. code-block:: python
67             [{'key': 'boot.autostart', 'value': 1},
68              {'key': 'security.privileged', 'value': '1'}]
69     devices :
70         A device dict or None (None = unset).
71     architecture : 'x86_64'
72         Can be one of the following:
73         * unknown
74         * i686
75         * x86_64
76         * armv7l
77         * aarch64
78         * ppc
79         * ppc64
80         * ppc64le
81         * s390x
82     ephemeral : False
83         Destroy this container after stop?
84     restart_on_change : False
85         Restart the container when we detect changes on the config or
86         its devices?
87     remote_addr :
88         An URL to a remote Server, you also have to give cert and key if you
89         provide remote_addr!
90         Examples:
91             https://myserver.lan:8443
92             /var/lib/mysocket.sock
93     cert :
94         PEM Formatted SSL Zertifikate.
95         Examples:
96             ~/.config/lxc/client.crt
97     key :
98         PEM Formatted SSL Key.
99         Examples:
100             ~/.config/lxc/client.key
101     verify_cert : True
102         Wherever to verify the cert, this is by default True
103         but in the most cases you want to set it off as LXD
104         normally uses self-signed certificates.
105     """
106     if profiles is None:
107         profiles = ["default"]
108     if source is None:
109         source = {}
110     ret = {
111         "name": name,
112         "running": running,
113         "profiles": profiles,
114         "source": source,
115         "config": config,
116         "devices": devices,
117         "architecture": architecture,
118         "ephemeral": ephemeral,
119         "restart_on_change": restart_on_change,
120         "remote_addr": remote_addr,
121         "cert": cert,
122         "key": key,
123         "verify_cert": verify_cert,
124         "changes": {},
125     }
126     container = None
127     try:
128         container = __salt__["lxd.container_get"](
129             name, remote_addr, cert, key, verify_cert, _raw=True
130         )
131     except CommandExecutionError as e:
132         return _error(ret, str(e))
133     except SaltInvocationError as e:
134         pass
135     if container is None:
136         if __opts__["test"]:
137             msg = 'Would create the container "{}"'.format(name)
138             ret["changes"] = {"created": msg}
139             if running is True:
140                 msg = msg + " and start it."
141                 ret["changes"]["started"] = 'Would start the container "{}"'.format(
142                     name
143                 )
144             ret["changes"] = {"created": msg}
145             return _unchanged(ret, msg)
146         try:
147             __salt__["lxd.container_create"](
148                 name,
149                 source,
150                 profiles,
151                 config,
152                 devices,
153                 architecture,
154                 ephemeral,
155                 True,  # Wait
156                 remote_addr,
157                 cert,
158                 key,
159                 verify_cert,
160             )
161         except CommandExecutionError as e:
162             return _error(ret, str(e))
163         msg = 'Created the container "{}"'.format(name)
164         ret["changes"] = {"created": msg}
165         if running is True:
166             try:
167                 __salt__["lxd.container_start"](
168                     name, remote_addr, cert, key, verify_cert
169                 )
170             except CommandExecutionError as e:
171                 return _error(ret, str(e))
172             msg = msg + " and started it."
173             ret["changes"] = {"started": 'Started the container "{}"'.format(name)}
174         return _success(ret, msg)
175     new_profiles = set(map(str, profiles))
176     old_profiles = set(map(str, container.profiles))
177     container_changed = False
178     profile_changes = []
179     for k in old_profiles.difference(new_profiles):
180         if not __opts__["test"]:
181             profile_changes.append('Removed profile "{}"'.format(k))
182             old_profiles.discard(k)
183         else:
184             profile_changes.append('Would remove profile "{}"'.format(k))
185     for k in new_profiles.difference(old_profiles):
186         if not __opts__["test"]:
187             profile_changes.append('Added profile "{}"'.format(k))
188             old_profiles.add(k)
189         else:
190             profile_changes.append('Would add profile "{}"'.format(k))
191     if profile_changes:
192         container_changed = True
193         ret["changes"]["profiles"] = profile_changes
194         container.profiles = list(old_profiles)
195     config, devices = __salt__["lxd.normalize_input_values"](config, devices)
196     changes = __salt__["lxd.sync_config_devices"](
197         container, config, devices, __opts__["test"]
198     )
199     if changes:
200         container_changed = True
201         ret["changes"].update(changes)
202     is_running = container.status_code == CONTAINER_STATUS_RUNNING
203     if not __opts__["test"]:
204         try:
205             __salt__["lxd.pylxd_save_object"](container)
206         except CommandExecutionError as e:
207             return _error(ret, str(e))
208     if running != is_running:
209         if running is True:
210             if __opts__["test"]:
211                 changes["running"] = "Would start the container"
212                 return _unchanged(
213                     ret,
214                     'Container "{}" would get changed and started.'.format(name),
215                 )
216             else:
217                 container.start(wait=True)
218                 changes["running"] = "Started the container"
219         elif running is False:
220             if __opts__["test"]:
221                 changes["stopped"] = "Would stopped the container"
222                 return _unchanged(
223                     ret,
224                     'Container "{}" would get changed and stopped.'.format(name),
225                 )
226             else:
227                 container.stop(wait=True)
228                 changes["stopped"] = "Stopped the container"
229     if (
230         (running is True or running is None)
231         and is_running
232         and restart_on_change
233         and container_changed
234     ):
235         if __opts__["test"]:
236             changes["restarted"] = "Would restart the container"
237             return _unchanged(ret, 'Would restart the container "{}"'.format(name))
238         else:
239             container.restart(wait=True)
240             changes["restarted"] = 'Container "{}" has been restarted'.format(name)
241             return _success(ret, 'Container "{}" has been restarted'.format(name))
242     if not container_changed:
243         return _success(ret, "No changes")
244     if __opts__["test"]:
245         return _unchanged(ret, 'Container "{}" would get changed.'.format(name))
246     return _success(ret, "{} changes".format(len(ret["changes"].keys())))
247 def absent(name, stop=False, remote_addr=None, cert=None, key=None, verify_cert=True):
248     """
249     Ensure a LXD container is not present, destroying it if present
250     name :
251         The name of the container to destroy
252     stop :
253         stop before destroying
254         default: false
255     remote_addr :
256         An URL to a remote Server, you also have to give cert and key if you
257         provide remote_addr!
258         Examples:
259             https://myserver.lan:8443
260             /var/lib/mysocket.sock
261     cert :
262         PEM Formatted SSL Zertifikate.
263         Examples:
264             ~/.config/lxc/client.crt
265     key :
266         PEM Formatted SSL Key.
267         Examples:
268             ~/.config/lxc/client.key
269     verify_cert : True
270         Wherever to verify the cert, this is by default True
271         but in the most cases you want to set it off as LXD
272         normally uses self-signed certificates.
273     """
274     ret = {
275         "name": name,
276         "stop": stop,
277         "remote_addr": remote_addr,
278         "cert": cert,
279         "key": key,
280         "verify_cert": verify_cert,
281         "changes": {},
282     }
283     try:
284         container = __salt__["lxd.container_get"](
285             name, remote_addr, cert, key, verify_cert, _raw=True
286         )
287     except CommandExecutionError as e:
288         return _error(ret, str(e))
289     except SaltInvocationError as e:
290         return _success(ret, 'Container "{}" not found.'.format(name))
291     if __opts__["test"]:
292         ret["changes"] = {"removed": 'Container "{}" would get deleted.'.format(name)}
293         return _unchanged(ret, ret["changes"]["removed"])
294     if stop and container.status_code == CONTAINER_STATUS_RUNNING:
295         container.stop(wait=True)
296     container.delete(wait=True)
297     ret["changes"]["deleted"] = 'Container "{}" has been deleted.'.format(name)
298     return _success(ret, ret["changes"]["deleted"])
299 def running(
300     name, restart=False, remote_addr=None, cert=None, key=None, verify_cert=True
301 ):
302     """
303     Ensure a LXD container is running and restart it if restart is True
304     name :
305         The name of the container to start/restart.
306     restart :
307         restart the container if it is already started.
308     remote_addr :
309         An URL to a remote Server, you also have to give cert and key if you
310         provide remote_addr!
311         Examples:
312             https://myserver.lan:8443
313             /var/lib/mysocket.sock
314     cert :
315         PEM Formatted SSL Zertifikate.
316         Examples:
317             ~/.config/lxc/client.crt
318     key :
319         PEM Formatted SSL Key.
320         Examples:
321             ~/.config/lxc/client.key
322     verify_cert : True
323         Wherever to verify the cert, this is by default True
324         but in the most cases you want to set it off as LXD
325         normally uses self-signed certificates.
326     """
327     ret = {
328         "name": name,
329         "restart": restart,
330         "remote_addr": remote_addr,
331         "cert": cert,
332         "key": key,
333         "verify_cert": verify_cert,
334         "changes": {},
335     }
336     try:
337         container = __salt__["lxd.container_get"](
338             name, remote_addr, cert, key, verify_cert, _raw=True
339         )
340     except CommandExecutionError as e:
341         return _error(ret, str(e))
342     except SaltInvocationError as e:
343         return _error(ret, 'Container "{}" not found'.format(name))
344     is_running = container.status_code == CONTAINER_STATUS_RUNNING
345     if is_running:
346         if not restart:
347             return _success(ret, 'The container "{}" is already running'.format(name))
348         else:
349             if __opts__["test"]:
350                 ret["changes"]["restarted"] = 'Would restart the container "{}"'.format(
351                     name
352                 )
353                 return _unchanged(ret, ret["changes"]["restarted"])
354             else:
355                 container.restart(wait=True)
356                 ret["changes"]["restarted"] = 'Restarted the container "{}"'.format(
357                     name
358                 )
359                 return _success(ret, ret["changes"]["restarted"])
360     if __opts__["test"]:
361         ret["changes"]["started"] = 'Would start the container "{}"'.format(name)
362         return _unchanged(ret, ret["changes"]["started"])
363     container.start(wait=True)
364     ret["changes"]["started"] = 'Started the container "{}"'.format(name)
365     return _success(ret, ret["changes"]["started"])
366 def frozen(name, start=True, remote_addr=None, cert=None, key=None, verify_cert=True):
367     """
368     Ensure a LXD container is frozen, start and freeze it if start is true
369     name :
370         The name of the container to freeze
371     start :
372         start and freeze it
373     remote_addr :
374         An URL to a remote Server, you also have to give cert and key if you
375         provide remote_addr!
376         Examples:
377             https://myserver.lan:8443
378             /var/lib/mysocket.sock
379     cert :
380         PEM Formatted SSL Zertifikate.
381         Examples:
382             ~/.config/lxc/client.crt
383     key :
384         PEM Formatted SSL Key.
385         Examples:
386             ~/.config/lxc/client.key
387     verify_cert : True
388         Wherever to verify the cert, this is by default True
389         but in the most cases you want to set it off as LXD
390         normally uses self-signed certificates.
391     """
392     ret = {
393         "name": name,
394         "start": start,
395         "remote_addr": remote_addr,
396         "cert": cert,
397         "key": key,
398         "verify_cert": verify_cert,
399         "changes": {},
400     }
401     try:
402         container = __salt__["lxd.container_get"](
403             name, remote_addr, cert, key, verify_cert, _raw=True
404         )
405     except CommandExecutionError as e:
406         return _error(ret, str(e))
407     except SaltInvocationError as e:
408         return _error(ret, 'Container "{}" not found'.format(name))
409     if container.status_code == CONTAINER_STATUS_FROZEN:
410         return _success(ret, 'Container "{}" is alredy frozen'.format(name))
411     is_running = container.status_code == CONTAINER_STATUS_RUNNING
412     if not is_running and not start:
413         return _error(
414             ret,
415             'Container "{}" is not running and start is False, cannot freeze it'.format(
416                 name
417             ),
418         )
419     elif not is_running and start:
420         if __opts__["test"]:
421             ret["changes"][
422                 "started"
423             ] = 'Would start the container "{}" and freeze it after'.format(name)
424             return _unchanged(ret, ret["changes"]["started"])
425         else:
426             container.start(wait=True)
427             ret["changes"]["started"] = 'Start the container "{}"'.format(name)
428     if __opts__["test"]:
429         ret["changes"]["frozen"] = 'Would freeze the container "{}"'.format(name)
430         return _unchanged(ret, ret["changes"]["frozen"])
431     container.freeze(wait=True)
432     ret["changes"]["frozen"] = 'Froze the container "{}"'.format(name)
433     return _success(ret, ret["changes"]["frozen"])
434 def stopped(name, kill=False, remote_addr=None, cert=None, key=None, verify_cert=True):
435     """
436     Ensure a LXD container is stopped, kill it if kill is true else stop it
437     name :
438         The name of the container to stop
439     kill :
440         kill if true
441     remote_addr :
442         An URL to a remote Server, you also have to give cert and key if you
443         provide remote_addr!
444         Examples:
445             https://myserver.lan:8443
446             /var/lib/mysocket.sock
447     cert :
448         PEM Formatted SSL Zertifikate.
449         Examples:
450             ~/.config/lxc/client.crt
451     key :
452         PEM Formatted SSL Key.
453         Examples:
454             ~/.config/lxc/client.key
455     verify_cert : True
456         Wherever to verify the cert, this is by default True
457         but in the most cases you want to set it off as LXD
458         normally uses self-signed certificates.
459     """
460     ret = {
461         "name": name,
462         "kill": kill,
463         "remote_addr": remote_addr,
464         "cert": cert,
465         "key": key,
466         "verify_cert": verify_cert,
467         "changes": {},
468     }
469     try:
470         container = __salt__["lxd.container_get"](
471             name, remote_addr, cert, key, verify_cert, _raw=True
472         )
473     except CommandExecutionError as e:
474         return _error(ret, str(e))
475     except SaltInvocationError as e:
476         return _error(ret, 'Container "{}" not found'.format(name))
477     if container.status_code == CONTAINER_STATUS_STOPPED:
478         return _success(ret, 'Container "{}" is already stopped'.format(name))
479     if __opts__["test"]:
480         ret["changes"]["stopped"] = 'Would stop the container "{}"'.format(name)
481         return _unchanged(ret, ret["changes"]["stopped"])
482     container.stop(force=kill, wait=True)
483     ret["changes"]["stopped"] = 'Stopped the container "{}"'.format(name)
484     return _success(ret, ret["changes"]["stopped"])
485 def migrated(
486     name,
487     remote_addr,
488     cert,
489     key,
490     verify_cert,
491     src_remote_addr,
492     stop_and_start=False,
493     src_cert=None,
494     src_key=None,
495     src_verify_cert=None,
496 ):
497     """Ensure a container is migrated to another host
498     If the container is running, it either must be shut down
499     first (use stop_and_start=True) or criu must be installed
500     on the source and destination machines.
501     For this operation both certs need to be authenticated,
502     use :mod:`lxd.authenticate &lt;salt.states.lxd.authenticate`
503     to authenticate your cert(s).
504     name :
505         The container to migrate
506     remote_addr :
507         An URL to the destination remote Server
508         Examples:
509             https://myserver.lan:8443
510             /var/lib/mysocket.sock
511     cert :
512         PEM Formatted SSL Zertifikate.
513         Examples:
514             ~/.config/lxc/client.crt
515     key :
516         PEM Formatted SSL Key.
517         Examples:
518             ~/.config/lxc/client.key
519     verify_cert : True
520         Wherever to verify the cert, this is by default True
521         but in the most cases you want to set it off as LXD
522         normally uses self-signed certificates.
523     src_remote_addr :
524         An URL to the source remote Server
525         Examples:
526             https://myserver.lan:8443
527             /var/lib/mysocket.sock
528     stop_and_start:
529         Stop before migrating and start after
530     src_cert :
531         PEM Formatted SSL Zertifikate, if None we copy "cert"
532         Examples:
533             ~/.config/lxc/client.crt
534     src_key :
535         PEM Formatted SSL Key, if None we copy "key"
536         Examples:
537             ~/.config/lxc/client.key
538     src_verify_cert :
539         Wherever to verify the cert, if None we copy "verify_cert"
540     """
541     ret = {
542         "name": name,
543         "remote_addr": remote_addr,
544         "cert": cert,
545         "key": key,
546         "verify_cert": verify_cert,
547         "src_remote_addr": src_remote_addr,
548         "src_and_start": stop_and_start,
549         "src_cert": src_cert,
550         "src_key": src_key,
551         "changes": {},
552     }
553     dest_container = None
554     try:
555         dest_container = __salt__["lxd.container_get"](
556             name, remote_addr, cert, key, verify_cert, _raw=True
557         )
558     except CommandExecutionError as e:
559         return _error(ret, str(e))
560     except SaltInvocationError as e:
561         pass
562     if dest_container is not None:
563         return _success(ret, 'Container "{}" exists on the destination'.format(name))
564     if src_verify_cert is None:
565         src_verify_cert = verify_cert
566     try:
567         __salt__["lxd.container_get"](
568             name, src_remote_addr, src_cert, src_key, src_verify_cert, _raw=True
569         )
570     except CommandExecutionError as e:
571         return _error(ret, str(e))
572     except SaltInvocationError as e:
573         return _error(ret, 'Source Container "{}" not found'.format(name))
574     if __opts__["test"]:
575         ret["changes"][
576             "migrated"
577         ] = 'Would migrate the container "{}" from "{}" to "{}"'.format(
578             name, src_remote_addr, remote_addr
579         )
580         return _unchanged(ret, ret["changes"]["migrated"])
581     try:
582         __salt__["lxd.container_migrate"](
583             name,
584             stop_and_start,
585             remote_addr,
586             cert,
587             key,
588             verify_cert,
589             src_remote_addr,
590             src_cert,
591             src_key,
592             src_verify_cert,
593         )
594     except CommandExecutionError as e:
595         return _error(ret, str(e))
596     ret["changes"]["migrated"] = 'Migrated the container "{}" from "{}" to "{}"'.format(
597         name, src_remote_addr, remote_addr
598     )
599     return _success(ret, ret["changes"]["migrated"])
600 def _success(ret, success_msg):
601     ret["result"] = True
602     ret["comment"] = success_msg
603     if "changes" not in ret:
604         ret["changes"] = {}
605     return ret
606 def _unchanged(ret, msg):
607     ret["result"] = None
608     ret["comment"] = msg
609     if "changes" not in ret:
610         ret["changes"] = {}
611     return ret
612 def _error(ret, err_msg):
613     ret["result"] = False
614     ret["comment"] = err_msg
615     if "changes" not in ret:
616         ret["changes"] = {}
617     return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>bigip.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 A state module designed to enforce load-balancing configurations for F5 Big-IP entities.
3     :maturity:      develop
4     :platform:      f5_bigip_11.6
5 """
6 import salt.utils.json
7 def __virtual__():
8     """
9     Only load if the bigip exec module is available in __salt__
10     """
11     if "bigip.list_transaction" in __salt__:
12         return "bigip"
13     return (False, "bigip module could not be loaded")
14 def _load_result(response, ret):
15     """
16     format the results of listing functions
17     """
18     if response["code"] is None:
19         ret["comment"] = response["content"]
20     elif response["code"] == 401:
21         ret["comment"] = "401 Forbidden: Authentication required!"
22     elif response["code"] == 404:
23         ret["comment"] = response["content"]["message"]
24     elif response["code"] == 200:
25         ret["result"] = True
26         ret["comment"] = (
27             "Listing Current Configuration Only.  "
28             "Not action or changes occurred during the execution of this state."
29         )
30         ret["changes"] = response["content"]
31     else:
32         ret["comment"] = response["content"]["message"]
33     return ret
34 def _strip_key(dictionary, keyword):
35     """
36     look for a certain key within a dictionary and nullify ti's contents, check within nested
37     dictionaries and lists as well.  Certain attributes such as "generation" will change even
38     when there were no changes made to the entity.
39     """
40     for key, value in dictionary.items():
41         if key == keyword:
42             dictionary[key] = None
43         elif isinstance(value, dict):
44             _strip_key(value, keyword)
45         elif isinstance(value, list):
46             for item in value:
47                 if isinstance(item, dict):
48                     _strip_key(item, keyword)
49     return dictionary
50 def _check_for_changes(entity_type, ret, existing, modified):
51     """
52     take an existing entity and a modified entity and check for changes.
53     """
54     ret["result"] = True
55     if isinstance(existing, dict) and isinstance(modified, dict):
56         if "generation" in modified["content"].keys():
57             del modified["content"]["generation"]
58         if "generation" in existing["content"].keys():
59             del existing["content"]["generation"]
60         if modified["content"] == existing["content"]:
61             ret["comment"] = (
62                 "{entity_type} is currently enforced to the desired state.  No changes"
63                 " made.".format(entity_type=entity_type)
64             )
65         else:
66             ret["comment"] = (
67                 "{entity_type} was enforced to the desired state.  Note: Only"
68                 " parameters specified were enforced. See changes for details.".format(
69                     entity_type=entity_type
70                 )
71             )
72             ret["changes"]["old"] = existing["content"]
73             ret["changes"]["new"] = modified["content"]
74     else:
75         if modified == existing:
76             ret["comment"] = (
77                 "{entity_type} is currently enforced to the desired state.  No changes"
78                 " made.".format(entity_type=entity_type)
79             )
80         else:
81             ret["comment"] = (
82                 "{entity_type} was enforced to the desired state.  Note: Only"
83                 " parameters specified were enforced. See changes for details.".format(
84                     entity_type=entity_type
85                 )
86             )
87             ret["changes"]["old"] = existing
88             ret["changes"]["new"] = modified
89     return ret
90 def _test_output(ret, action, params):
91     """
92     For testing just output what the state will attempt to do without actually doing it.
93     """
94     if action == "list":
95         ret[
96             "comment"
97         ] += "The list action will just list an entity and will make no changes.\n"
98     elif action == "create" or action == "add":
99         ret["comment"] += (
100             "The create action will attempt to create an entity if it does not already"
101             " exist.\n"
102         )
103     elif action == "delete":
104         ret["comment"] += (
105             "The delete action will attempt to delete an existing entity if it"
106             " exists.\n"
107         )
108     elif action == "manage":
109         ret["comment"] += (
110             "The manage action will create a new entity if it does not exist.  If it"
111             " does exist, it will be enforcedto the desired state.\n"
112         )
113     elif action == "modify":
114         ret["comment"] += (
115             "The modify action will attempt to modify an existing entity only if it"
116             " exists.\n"
117         )
118     ret["comment"] += "An iControl REST Request will be made using the parameters:\n"
119     ret["comment"] += salt.utils.json.dumps(params, indent=4)
120     ret["changes"] = {}
121     ret["result"] = None
122     return ret
123 def list_node(hostname, username, password, name):
124     """
125     A function to connect to a bigip device and list a specific node.
126     hostname
127         The host/address of the bigip device
128     username
129         The iControl REST username
130     password
131         The iControl REST password
132     name
133         The name of the node to list.
134     """
135     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
136     if __opts__["test"]:
137         return _test_output(
138             ret,
139             "list",
140             params={
141                 "hostname": hostname,
142                 "username": username,
143                 "password": password,
144                 "name": name,
145             },
146         )
147     response = __salt__["bigip.list_node"](hostname, username, password, name)
148     return _load_result(response, ret)
149 def create_node(hostname, username, password, name, address):
150     """
151     Create a new node if it does not already exist.
152     hostname
153         The host/address of the bigip device
154     username
155         The iControl REST username
156     password
157         The iControl REST password
158     name
159         The name of the node to create
160     address
161         The address of the node
162     """
163     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
164     if __opts__["test"]:
165         return _test_output(
166             ret,
167             "create",
168             params={
169                 "hostname": hostname,
170                 "username": username,
171                 "password": password,
172                 "name": name,
173                 "address": address,
174             },
175         )
176     existing = __salt__["bigip.list_node"](hostname, username, password, name)
177     if existing["code"] == 200:
178         ret["result"] = True
179         ret["comment"] = "A node by this name currently exists.  No change made."
180     elif existing["code"] == 404:
181         response = __salt__["bigip.create_node"](
182             hostname, username, password, name, address
183         )
184         ret["result"] = True
185         ret["changes"]["old"] = {}
186         ret["changes"]["new"] = response["content"]
187         ret["comment"] = "Node was successfully created."
188     else:
189         ret = _load_result(existing, ret)
190     return ret
191 def manage_node(
192     hostname,
193     username,
194     password,
195     name,
196     address,
197     connection_limit=None,
198     description=None,
199     dynamic_ratio=None,
200     logging=None,
201     monitor=None,
202     rate_limit=None,
203     ratio=None,
204     session=None,
205     node_state=None,
206 ):
207     """
208     Manages a node of a given bigip device.  If the node does not exist it will be created, otherwise,
209     only the properties which are different than the existing will be updated.
210     hostname
211         The host/address of the bigip device
212     username
213         The iControl REST username
214     password
215         The iControl REST password
216     name
217         The name of the node to manage.
218     address
219         The address of the node
220     connection_limit
221         [integer]
222     description
223         [string]
224     dynam
225         c_ratio:        [integer]
226     logging
227         [enabled | disabled]
228     monitor
229         [[name] | none | default]
230     rate_limit
231         [integer]
232     ratio
233         [integer]
234     session
235         [user-enabled | user-disabled]
236     node_state (state)
237         [user-down | user-up ]
238     """
239     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
240     if __opts__["test"]:
241         return _test_output(
242             ret,
243             "manage",
244             params={
245                 "hostname": hostname,
246                 "username": username,
247                 "password": password,
248                 "name": name,
249                 "address": address,
250                 "connection_limit": connection_limit,
251                 "description": description,
252                 "dynamic_ratio": dynamic_ratio,
253                 "logging": logging,
254                 "monitor": monitor,
255                 "rate_limit": rate_limit,
256                 "ratio": ratio,
257                 "session": session,
258                 "state:": node_state,
259             },
260         )
261     existing = __salt__["bigip.list_node"](hostname, username, password, name)
262     if existing["code"] == 200:
263         if existing["content"]["address"] != address:
264             ret["result"] = False
265             ret[
266                 "comment"
267             ] = "A node with this name exists but the address does not match."
268         modified = __salt__["bigip.modify_node"](
269             hostname=hostname,
270             username=username,
271             password=password,
272             name=name,
273             connection_limit=connection_limit,
274             description=description,
275             dynamic_ratio=dynamic_ratio,
276             logging=logging,
277             monitor=monitor,
278             rate_limit=rate_limit,
279             ratio=ratio,
280             session=session,
281             state=node_state,
282         )
283         if modified["code"] == 200:
284             ret = _check_for_changes("Node", ret, existing, modified)
285         else:
286             ret = _load_result(modified, ret)
287     elif existing["code"] == 404:
288         new = __salt__["bigip.create_node"](hostname, username, password, name, address)
289         if new["code"] == 200:
290             modified = __salt__["bigip.modify_node"](
291                 hostname=hostname,
292                 username=username,
293                 password=password,
294                 name=name,
295                 connection_limit=connection_limit,
296                 description=description,
297                 dynamic_ratio=dynamic_ratio,
298                 logging=logging,
299                 monitor=monitor,
300                 rate_limit=rate_limit,
301                 ratio=ratio,
302                 session=session,
303                 state=node_state,
304             )
305             if modified["code"] == 200:
306                 ret["result"] = True
307                 ret["comment"] = (
308                     "Node was created and enforced to the desired state.  Note: Only"
309                     " parameters specified were enforced.  See changes for details."
310                 )
311                 ret["changes"]["old"] = {}
312                 ret["changes"]["new"] = modified["content"]
313             else:
314                 deleted = __salt__["bigip.delete_node"](
315                     hostname, username, password, name
316                 )
317                 if deleted["code"] == 200:
318                     ret["comment"] = (
319                         "Node was successfully created but an error occurred during"
320                         " modification. The creation of the node has been rolled back."
321                         " Message is as follows:\n{message}".format(
322                             message=modified["content"]["message"]
323                         )
324                     )
325                 else:
326                     ret["comment"] = (
327                         "Node was successfully created but an error occurred during"
328                         " modification. The creation of the node was not able to be"
329                         " rolled back. Message is as follows:\n"
330                         " {message}\n{message_two}".format(
331                             message=modified["content"]["message"],
332                             message_two=deleted["content"]["message"],
333                         )
334                     )
335         else:
336             ret = _load_result(new, ret)
337     else:
338         ret = _load_result(existing, ret)
339     return ret
340 def modify_node(
341     hostname,
342     username,
343     password,
344     name,
345     connection_limit=None,
346     description=None,
347     dynamic_ratio=None,
348     logging=None,
349     monitor=None,
350     rate_limit=None,
351     ratio=None,
352     session=None,
353     node_state=None,
354 ):
355     """
356     Modify an existing node. Only a node which already exists will be modified and
357     only the parameters specified will be enforced.
358     hostname
359         The host/address of the bigip device
360     username
361         The iControl REST username
362     password
363         The iControl REST password
364     name
365         The name of the node to modify
366     connection_limit
367         [integer]
368     description
369         [string]
370     dynamic_ratio
371         [integer]
372     logging
373         [enabled | disabled]
374     monitor
375         [[name] | none | default]
376     rate_limit
377         [integer]
378     ratio
379         [integer]
380     session
381         [user-enabled | user-disabled]
382     node_state (state)
383         [user-down | user-up ]
384     """
385     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
386     if __opts__["test"]:
387         return _test_output(
388             ret,
389             "modify",
390             params={
391                 "hostname": hostname,
392                 "username": username,
393                 "password": password,
394                 "name": name,
395                 "connection_limit": connection_limit,
396                 "description": description,
397                 "dynamic_ratio": dynamic_ratio,
398                 "logging": logging,
399                 "monitor": monitor,
400                 "rate_limit": rate_limit,
401                 "ratio": ratio,
402                 "session": session,
403                 "state:": node_state,
404             },
405         )
406     existing = __salt__["bigip.list_node"](hostname, username, password, name)
407     if existing["code"] == 200:
408         modified = __salt__["bigip.modify_node"](
409             hostname=hostname,
410             username=username,
411             password=password,
412             name=name,
413             connection_limit=connection_limit,
414             description=description,
415             dynamic_ratio=dynamic_ratio,
416             logging=logging,
417             monitor=monitor,
418             rate_limit=rate_limit,
419             ratio=ratio,
420             session=session,
421             state=node_state,
422         )
423         if modified["code"] == 200:
424             ret = _check_for_changes("Node", ret, existing, modified)
425         else:
426             ret = _load_result(modified, ret)
427     elif existing["code"] == 404:
428         ret["comment"] = "A node with this name was not found."
429     else:
430         ret = _load_result(existing, ret)
431     return ret
432 def delete_node(hostname, username, password, name):
433     """
434     Delete an existing node.
435     hostname
436         The host/address of the bigip device
437     username
438         The iControl REST username
439     password
440         The iControl REST password
441     name
442         The name of the node which will be deleted.
443     """
444     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
445     if __opts__["test"]:
446         return _test_output(
447             ret,
448             "delete",
449             params={
450                 "hostname": hostname,
451                 "username": username,
452                 "password": password,
453                 "name": name,
454             },
455         )
456     existing = __salt__["bigip.list_node"](hostname, username, password, name)
457     if existing["code"] == 200:
458         deleted = __salt__["bigip.delete_node"](hostname, username, password, name)
459         if deleted["code"] == 200:
460             ret["result"] = True
461             ret["comment"] = "Node was successfully deleted."
462             ret["changes"]["old"] = existing["content"]
463             ret["changes"]["new"] = {}
464         else:
465             ret = _load_result(existing, ret)
466     elif existing["code"] == 404:
467         ret["result"] = True
468         ret["comment"] = "This node already does not exist. No changes made."
469         ret["changes"]["old"] = {}
470         ret["changes"]["new"] = {}
471     else:
472         ret = _load_result(existing, ret)
473     return ret
474 def list_pool(hostname, username, password, name):
475     """
476     A function to connect to a bigip device and list a specific pool.
477     hostname
478         The host/address of the bigip device
479     username
480         The iControl REST username
481     password
482         The iControl REST password
483     name
484         The name of the pool to list.
485     """
486     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
487     if __opts__["test"]:
488         return _test_output(
489             ret,
490             "list",
491             params={
492                 "hostname": hostname,
493                 "username": username,
494                 "password": password,
495                 "name": name,
496             },
497     response = __salt__["bigip.list_pool"](hostname, username, password, name)
498     return _load_result(<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>response, ret)
499 def create_pool(
500     hostname,
501     username,
502     password,
503     name,
504     members=None,
505     allow_nat=None,
506     allow_snat=None,
507     description=None,
508     gateway_failsafe_device=None,
509     ignore_persisted_weight=None,
510     ip_tos_to_client=None,
511     ip_tos_to_server=None,
512     link_qos_to_client=None,
513     link_qos_to_server=None,
514     load_balancing_mode=None,
515     min_active_members=</b></font>None,
516     min_up_members=None,
517     min_up_members_action=None,
518     min_up_members_checking=None,
519     monitor=None,
520     profiles=None,
521     queue_depth_limit=None,
522     queue_on_connection_limit=None,
523     queue_time_limit=None,
524     reselect_tries=None,
525     service_down_action=None,
526     slow_ramp_time=None,
527 ):
528     """
529     Create a new node if it does not already exist.
530     hostname
531         The host/address of the bigip device
532     username
533         The iControl REST username
534     password
535         The iControl REST password
536     name
537         The name of the pool to create
538     members
539         List of members to be added to the pool
540     allow_nat
541         [yes | no]
542     allow_snat
543         [yes | no]
544     description
545         [string]
546     gateway_failsafe_device
547         [string]
548     ignore_persisted_weight
549         [enabled | disabled]
550     ip_tos_to_client
551         [pass-through | [integer]]
552     ip_tos_to_server
553         [pass-through | [integer]]
554     link_qos_to_client
555         [pass-through | [integer]]
556     link_qos_to_server
557         [pass-through | [integer]]
558     load_balancing_mode
559         [dynamic-ratio-member | dynamic-ratio-node |
560         fastest-app-response | fastest-node |
561         least-connections-members |
562         least-connections-node |
563         least-sessions |
564         observed-member | observed-node |
565         predictive-member | predictive-node |
566         ratio-least-connections-member |
567         ratio-least-connections-node |
568         ratio-member | ratio-node | ratio-session |
569         round-robin | weighted-least-connections-member |
570         weighted-least-connections-node]
571     min_active_members
572         [integer]
573     min_up_members
574         [integer]
575     min_up_members_action
576         [failover | reboot | restart-all]
577     min_up_members_checking
578         [enabled | disabled]
579     monitor
580         [name]
581     profiles
582         [none | profile_name]
583     queue_depth_limit
584         [integer]
585     queue_on_connection_limit
586         [enabled | disabled]
587     queue_time_limit
588         [integer]
589     reselect_tries
590         [integer]
591     service_down_action
592         [drop | none | reselect | reset]
593     slow_ramp_time
594         [integer]
595     """
596     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
597     if __opts__["test"]:
598         return _test_output(
599             ret,
600             "create",
601             params={
602                 "hostname": hostname,
603                 "username": username,
604                 "password": password,
605                 "name": name,
606                 "members": members,
607                 "allow_nat": allow_nat,
608                 "allow_snat": allow_snat,
609                 "description": description,
610                 "gateway_failsafe_device": gateway_failsafe_device,
611                 "ignore_persisted_weight": ignore_persisted_weight,
612                 "ip_tos_client:": ip_tos_to_client,
613                 "ip_tos_server": ip_tos_to_server,
614                 "link_qos_to_client": link_qos_to_client,
615                 "link_qos_to_server": link_qos_to_server,
616                 "load_balancing_mode": load_balancing_mode,
617                 "min_active_members": min_active_members,
618                 "min_up_members": min_up_members,
619                 "min_up_members_checking": min_up_members_checking,
620                 "monitor": monitor,
621                 "profiles": profiles,
622                 "queue_depth_limit": queue_depth_limit,
623                 "queue_on_connection_limit": queue_on_connection_limit,
624                 "queue_time_limit": queue_time_limit,
625                 "reselect_tries": reselect_tries,
626                 "service_down_action": service_down_action,
627                 "slow_ramp_time": slow_ramp_time,
628             },
629         )
630     existing = __salt__["bigip.list_pool"](hostname, username, password, name)
631     if existing["code"] == 200:
632         ret["result"] = True
633         ret["comment"] = "A pool by this name currently exists.  No change made."
634     elif existing["code"] == 404:
635         response = __salt__["bigip.create_pool"](
636             hostname=hostname,
637             username=username,
638             password=password,
639             name=name,
640             members=members,
641             allow_nat=allow_nat,
642             allow_snat=allow_snat,
643             description=description,
644             gateway_failsafe_device=gateway_failsafe_device,
645             ignore_persisted_weight=ignore_persisted_weight,
646             ip_tos_to_client=ip_tos_to_client,
647             ip_tos_to_server=ip_tos_to_server,
648             link_qos_to_client=link_qos_to_client,
649             link_qos_to_server=link_qos_to_server,
650             load_balancing_mode=load_balancing_mode,
651             min_active_members=min_active_members,
652             min_up_members=min_up_members,
653             min_up_members_action=min_up_members_action,
654             min_up_members_checking=min_up_members_checking,
655             monitor=monitor,
656             profiles=profiles,
657             queue_depth_limit=queue_depth_limit,
658             queue_on_connection_limit=queue_on_connection_limit,
659             queue_time_limit=queue_time_limit,
660             reselect_tries=reselect_tries,
661             service_down_action=service_down_action,
662             slow_ramp_time=slow_ramp_time,
663         )
664         if response["code"] == 200:
665             ret["result"] = True
666             ret["changes"]["old"] = {}
667             ret["changes"]["new"] = response["content"]
668             ret["comment"] = "Pool was successfully created."
669         else:
670             ret = _load_result(existing, ret)
671     else:
672         ret = _load_result(existing, ret)
673     return ret
674 def manage_pool(
675     hostname,
676     username,
677     password,
678     name,
679     allow_nat=None,
680     allow_snat=None,
681     description=None,
682     gateway_failsafe_device=None,
683     ignore_persisted_weight=None,
684     ip_tos_to_client=None,
685     ip_tos_to_server=None,
686     link_qos_to_client=None,
687     link_qos_to_server=None,
688     load_balancing_mode=None,
689     min_active_members=None,
690     min_up_members=None,
691     min_up_members_action=None,
692     min_up_members_checking=None,
693     monitor=None,
694     profiles=None,
695     queue_depth_limit=None,
696     queue_on_connection_limit=None,
697     queue_time_limit=None,
698     reselect_tries=None,
699     service_down_action=None,
700     slow_ramp_time=None,
701 ):
702     """
703     Create a new pool if it does not already exist. Pool members are managed separately. Only the
704     parameters specified are enforced.
705     hostname
706         The host/address of the bigip device
707     username
708         The iControl REST username
709     password
710         The iControl REST password
711     name
712         The name of the pool to create
713     allow_nat
714         [yes | no]
715     allow_snat
716         [yes | no]
717     description
718         [string]
719     gateway_failsafe_device
720         [string]
721     ignore_persisted_weight
722         [enabled | disabled]
723     ip_tos_to_client
724         [pass-through | [integer]]
725     ip_tos_to_server
726         [pass-through | [integer]]
727     link_qos_to_client
728         [pass-through | [integer]]
729     link_qos_to_server
730         [pass-through | [integer]]
731     load_balancing_mode
732         [dynamic-ratio-member | dynamic-ratio-node |
733         fastest-app-response | fastest-node |
734         least-connections-members |
735         least-connections-node |
736         least-sessions |
737         observed-member | observed-node |
738         predictive-member | predictive-node |
739         ratio-least-connections-member |
740         ratio-least-connections-node |
741         ratio-member | ratio-node | ratio-session |
742         round-robin | weighted-least-connections-member |
743         weighted-least-connections-node]
744     min_active_members
745         [integer]
746     min_up_members
747         [integer]
748     min_up_members_action
749         [failover | reboot | restart-all]
750     min_up_members_checking
751         [enabled | disabled]
752     monitor
753         [name]
754     profiles
755         [none | profile_name]
756     queue_depth_limit
757         [integer]
758     queue_on_connection_limit
759         [enabled | disabled]
760     queue_time_limit
761         [integer]
762     reselect_tries
763         [integer]
764     service_down_action
765         [drop | none | reselect | reset]
766     slow_ramp_time
767         [integer]
768     """
769     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
770     if __opts__["test"]:
771         return _test_output(
772             ret,
773             "manage",
774             params={
775                 "hostname": hostname,
776                 "username": username,
777                 "password": password,
778                 "name": name,
779                 "allow_nat": allow_nat,
780                 "allow_snat": allow_snat,
781                 "description": description,
782                 "gateway_failsafe_device": gateway_failsafe_device,
783                 "ignore_persisted_weight": ignore_persisted_weight,
784                 "ip_tos_client:": ip_tos_to_client,
785                 "ip_tos_server": ip_tos_to_server,
786                 "link_qos_to_client": link_qos_to_client,
787                 "link_qos_to_server": link_qos_to_server,
788                 "load_balancing_mode": load_balancing_mode,
789                 "min_active_members": min_active_members,
790                 "min_up_members": min_up_members,
791                 "min_up_members_checking": min_up_members_checking,
792                 "monitor": monitor,
793                 "profiles": profiles,
794                 "queue_depth_limit": queue_depth_limit,
795                 "queue_on_connection_limit": queue_on_connection_limit,
796                 "queue_time_limit": queue_time_limit,
797                 "reselect_tries": reselect_tries,
798                 "service_down_action": service_down_action,
799                 "slow_ramp_time": slow_ramp_time,
800             },
801         )
802     existing = __salt__["bigip.list_pool"](hostname, username, password, name)
803     if existing["code"] == 200:
804         modified = __salt__["bigip.modify_pool"](
805             hostname=hostname,
806             username=username,
807             password=password,
808             name=name,
809             allow_nat=allow_nat,
810             allow_snat=allow_snat,
811             description=description,
812             gateway_failsafe_device=gateway_failsafe_device,
813             ignore_persisted_weight=ignore_persisted_weight,
814             ip_tos_to_client=ip_tos_to_client,
815             ip_tos_to_server=ip_tos_to_server,
816             link_qos_to_client=link_qos_to_client,
817             link_qos_to_server=link_qos_to_server,
818             load_balancing_mode=load_balancing_mode,
819             min_active_members=min_active_members,
820             min_up_members=min_up_members,
821             min_up_members_action=min_up_members_action,
822             min_up_members_checking=min_up_members_checking,
823             monitor=monitor,
824             profiles=profiles,
825             queue_depth_limit=queue_depth_limit,
826             queue_on_connection_limit=queue_on_connection_limit,
827             queue_time_limit=queue_time_limit,
828             reselect_tries=reselect_tries,
829             service_down_action=service_down_action,
830             slow_ramp_time=slow_ramp_time,
831         )
832         if modified["code"] == 200:
833             del existing["content"]["membersReference"]
834             del modified["content"]["membersReference"]
835             del existing["content"]["selfLink"]
836             del modified["content"]["selfLink"]
837             ret = _check_for_changes("Pool", ret, existing, modified)
838         else:
839             ret = _load_result(modified, ret)
840     elif existing["code"] == 404:
841         new = __salt__["bigip.create_pool"](
842             hostname=hostname,
843             username=username,
844             password=password,
845             name=name,
846             allow_nat=allow_nat,
847             allow_snat=allow_snat,
848             description=description,
849             gateway_failsafe_device=gateway_failsafe_device,
850             ignore_persisted_weight=ignore_persisted_weight,
851             ip_tos_to_client=ip_tos_to_client,
852             ip_tos_to_server=ip_tos_to_server,
853             link_qos_to_client=link_qos_to_client,
854             link_qos_to_server=link_qos_to_server,
855             load_balancing_mode=load_balancing_mode,
856             min_active_members=min_active_members,
857             min_up_members=min_up_members,
858             min_up_members_action=min_up_members_action,
859             min_up_members_checking=min_up_members_checking,
860             monitor=monitor,
861             profiles=profiles,
862             queue_depth_limit=queue_depth_limit,
863             queue_on_connection_limit=queue_on_connection_limit,
864             queue_time_limit=queue_time_limit,
865             reselect_tries=reselect_tries,
866             service_down_action=service_down_action,
867             slow_ramp_time=slow_ramp_time,
868         )
869         if new["code"] == 200:
870             ret["result"] = True
871             ret["comment"] = (
872                 "Pool was created and enforced to the desired state.  Note: Only"
873                 " parameters specified were enforced.  See changes for details."
874             )
875             ret["changes"]["old"] = {}
876             ret["changes"]["new"] = new["content"]
877         else:
878             ret = _load_result(new, ret)
879     else:
880         ret = _load_result(existing, ret)
881     return ret
882 def modify_pool(
883     hostname,
884     username,
885     password,
886     name,
887     allow_nat=None,
888     allow_snat=None,
889     description=None,
890     gateway_failsafe_device=None,
891     ignore_persisted_weight=None,
892     ip_tos_to_client=None,
893     ip_tos_to_server=None,
894     link_qos_to_client=None,
895     link_qos_to_server=None,
896     load_balancing_mode=None,
897     min_active_members=None,
898     min_up_members=None,
899     min_up_members_action=None,
900     min_up_members_checking=None,
901     monitor=None,
902     profiles=None,
903     queue_depth_limit=None,
904     queue_on_connection_limit=None,
905     queue_time_limit=None,
906     reselect_tries=None,
907     service_down_action=None,
908     slow_ramp_time=None,
909 ):
910     """
911     Modify an existing pool. Pool members are managed separately. Only the
912     parameters specified are enforced.
913     hostname
914         The host/address of the bigip device
915     username
916         The iControl REST username
917     password
918         The iControl REST password
919     name
920         The name of the pool to create
921     allow_nat
922         [yes | no]
923     allow_snat
924         [yes | no]
925     description
926         [string]
927     gateway_failsafe_device
928         [string]
929     ignore_persisted_weight
930         [enabled | disabled]
931     ip_tos_to_client
932         [pass-through | [integer]]
933     ip_tos_to_server
934         [pass-through | [integer]]
935     link_qos_to_client
936         [pass-through | [integer]]
937     link_qos_to_server
938         [pass-through | [integer]]
939     load_balancing_mode
940         [dynamic-ratio-member | dynamic-ratio-node |
941         fastest-app-response | fastest-node |
942         least-connections-members |
943         least-connections-node |
944         least-sessions |
945         observed-member | observed-node |
946         predictive-member | predictive-node |
947         ratio-least-connections-member |
948         ratio-least-connections-node |
949         ratio-member | ratio-node | ratio-session |
950         round-robin | weighted-least-connections-member |
951         weighted-least-connections-node]
952     min_active_members
953         [integer]
954     min_up_members
955         [integer]
956     min_up_members_action
957         [failover | reboot | restart-all]
958     min_up_members_checking
959         [enabled | disabled]
960     monitor
961         [name]
962     profiles
963         [none | profile_name]
964     queue_depth_limit
965         [integer]
966     queue_on_connection_limit
967         [enabled | disabled]
968     queue_time_limit
969         [integer]
970     reselect_tries
971         [integer]
972     service_down_action
973         [drop | none | reselect | reset]
974     slow_ramp_time
975         [integer]
976     """
977     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
978     if __opts__["test"]:
979         return _test_output(
980             ret,
981             "modify",
982             params={
983                 "hostname": hostname,
984                 "username": username,
985                 "password": password,
986                 "name": name,
987                 "allow_nat": allow_nat,
988                 "allow_snat": allow_snat,
989                 "description": description,
990                 "gateway_failsafe_device": gateway_failsafe_device,
991                 "ignore_persisted_weight": ignore_persisted_weight,
992                 "ip_tos_client:": ip_tos_to_client,
993                 "ip_tos_server": ip_tos_to_server,
994                 "link_qos_to_client": link_qos_to_client,
995                 "link_qos_to_server": link_qos_to_server,
996                 "load_balancing_mode": load_balancing_mode,
997                 "min_active_members": min_active_members,
998                 "min_up_members": min_up_members,
999                 "min_up_members_checking": min_up_members_checking,
1000                 "monitor": monitor,
1001                 "profiles": profiles,
1002                 "queue_depth_limit": queue_depth_limit,
1003                 "queue_on_connection_limit": queue_on_connection_limit,
1004                 "queue_time_limit": queue_time_limit,
1005                 "reselect_tries": reselect_tries,
1006                 "service_down_action": service_down_action,
1007                 "slow_ramp_time": slow_ramp_time,
1008             },
1009         )
1010     existing = __salt__["bigip.list_pool"](hostname, username, password, name)
1011     if existing["code"] == 200:
1012         modified = __salt__["bigip.modify_pool"](
1013             hostname=hostname,
1014             username=username,
1015             password=password,
1016             name=name,
1017             allow_nat=allow_nat,
1018             allow_snat=allow_snat,
1019             description=description,
1020             gateway_failsafe_device=gateway_failsafe_device,
1021             ignore_persisted_weight=ignore_persisted_weight,
1022             ip_tos_to_client=ip_tos_to_client,
1023             ip_tos_to_server=ip_tos_to_server,
1024             link_qos_to_client=link_qos_to_client,
1025             link_qos_to_server=link_qos_to_server,
1026             load_balancing_mode=load_balancing_mode,
1027             min_active_members=min_active_members,
1028             min_up_members=min_up_members,
1029             min_up_members_action=min_up_members_action,
1030             min_up_members_checking=min_up_members_checking,
1031             monitor=monitor,
1032             profiles=profiles,
1033             queue_depth_limit=queue_depth_limit,
1034             queue_on_connection_limit=queue_on_connection_limit,
1035             queue_time_limit=queue_time_limit,
1036             reselect_tries=reselect_tries,
1037             service_down_action=service_down_action,
1038             slow_ramp_time=slow_ramp_time,
1039         )
1040         if modified["code"] == 200:
1041             del existing["content"]["membersReference"]
1042             del modified["content"]["membersReference"]
1043             del existing["content"]["selfLink"]
1044             del modified["content"]["selfLink"]
1045             ret = _check_for_changes("Pool", ret, existing, modified)
1046         else:
1047             ret = _load_result(modified, ret)
1048     elif existing["code"] == 404:
1049         ret["comment"] = "A pool with this name was not found."
1050     else:
1051         ret = _load_result(existing, ret)
1052     return ret
1053 def delete_pool(hostname, username, password, name):
1054     """
1055     Delete an existing pool.
1056     hostname
1057         The host/address of the bigip device
1058     username
1059         The iControl REST username
1060     password
1061         The iControl REST password
1062     name
1063         The name of the pool which will be deleted
1064     """
1065     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
1066     if __opts__["test"]:
1067         return _test_output(
1068             ret,
1069             "delete",
1070             params={
1071                 "hostname": hostname,
1072                 "username": username,
1073                 "password": password,
1074                 "name": name,
1075             },
1076         )
1077     existing = __salt__["bigip.list_pool"](hostname, username, password, name)
1078     if existing["code"] == 200:
1079         deleted = __salt__["bigip.delete_pool"](hostname, username, password, name)
1080         if deleted["code"] == 200:
1081             ret["result"] = True
1082             ret["comment"] = "Pool was successfully deleted."
1083             ret["changes"]["old"] = existing["content"]
1084             ret["changes"]["new"] = {}
1085         else:
1086             ret = _load_result(deleted, ret)
1087     elif existing["code"] == 404:
1088         ret["result"] = True
1089         ret["comment"] = "This pool already does not exist. No changes made."
1090         ret["changes"]["old"] = {}
1091         ret["changes"]["new"] = {}
1092     else:
1093         ret = _load_result(existing, ret)
1094     return ret
1095 def manage_pool_members(hostname, username, password, name, members):
1096     """
1097     Manage the members of an existing pool.  This function replaces all current pool members.
1098     Only the parameters specified are enforced.
1099     hostname
1100         The host/address of the bigip device
1101     username
1102         The iControl REST username
1103     password
1104         The iControl REST password
1105     name
1106         The name of the pool to modify
1107     members
1108         list of pool members to manage.
1109     """
1110     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
1111     if __opts__["test"]:
1112         return _test_output(
1113             ret,
1114             "manage",
1115             params={
1116                 "hostname": hostname,
1117                 "username": username,
1118                 "password": password,
1119                 "name": name,
1120                 "members": members,
1121             },
1122         )
1123     existing = __salt__["bigip.list_pool"](hostname, username, password, name)
1124     if existing["code"] == 200:
1125         current_members = existing["content"]["membersReference"]["items"]
1126         modified = __salt__["bigip.replace_pool_members"](
1127             hostname, username, password, name, members
1128         )
1129         if modified["code"] == 200:
1130             new_listing = __salt__["bigip.list_pool"](
1131                 hostname, username, password, name
1132             )
1133             if new_listing["code"] != 200:
1134                 ret = _load_result(new_listing, ret)
1135                 ret["comment"] = (
1136                     "modification of the pool was successful but an error occurred upon"
1137                     " retrieving new listing."
1138                 )
1139                 return ret
1140             new_members = new_listing["content"]["membersReference"]["items"]
1141             for current_member in current_members:
1142                 del current_member["generation"]
1143             for new_member in new_members:
1144                 del new_member["generation"]
1145             ret = _check_for_changes(
1146                 "Pool Membership", ret, current_members, new_members
1147             )
1148         else:
1149             ret = _load_result(modified, ret)
1150     elif existing["code"] == 404:
1151         ret["comment"] = "A pool with this name was not found."
1152     else:
1153         ret = _load_result(existing, ret)
1154     return ret
1155 def add_pool_member(hostname, username, password, name, member):
1156     """
1157     A function to connect to a bigip device and add a new member to an existing pool.
1158     hostname
1159         The host/address of the bigip device
1160     username
1161         The iControl REST username
1162     password
1163         The iControl REST password
1164     name
1165         The name of the pool to modify
1166     member
1167         The member to add to the pool
1168     """
1169     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
1170     if __opts__["test"]:
1171         return _test_output(
1172             ret,
1173             "add",
1174             params={
1175                 "hostname": hostname,
1176                 "username": username,
1177                 "password": password,
1178                 "name": name,
1179                 "members": member,
1180             },
1181         )
1182     existing_pool = __salt__["bigip.list_pool"](hostname, username, password, name)
1183     if existing_pool["code"] == 200:
1184         current_members = existing_pool["content"]["membersReference"]["items"]
1185         exists = False
1186         for current_member in current_members:
1187             if current_member["name"] == member["name"]:
1188                 exists = True
1189                 break
1190         if exists:
1191             ret["result"] = True
1192             ret[
1193                 "comment"
1194             ] = "Member: {name} already exists within this pool.  No changes made.".format(
1195                 name=member["name"]
1196             )
1197             ret["changes"]["old"] = {}
1198             ret["changes"]["new"] = {}
1199         else:
1200             new_member = __salt__["bigip.add_pool_member"](
1201                 hostname, username, password, name, member
1202             )
1203             if new_member["code"] == 200:
1204                 ret["result"] = True
1205                 ret[
1206                     "comment"
1207                 ] = "Member: {name} has been successfully added to the pool.".format(
1208                     name=member["name"]
1209                 )
1210                 ret["changes"]["old"] = {}
1211                 pool_listing = __salt__["bigip.list_pool"](
1212                     hostname, username, password, name
1213                 )
1214                 if pool_listing["code"] != 200:
1215                     ret = _load_result(new_member, ret)
1216                     return ret
1217                 members = pool_listing["content"]["membersReference"]["items"]
1218                 for current_member in members:
1219                     if current_member["name"] == member["name"]:
1220                         added_member = current_member
1221                         break
1222                 ret["changes"]["new"] = added_member
1223             else:
1224                 ret = _load_result(new_member, ret)
1225     elif existing_pool["code"] == 404:
1226         ret["comment"] = "A pool with this name was not found."
1227     else:
1228         ret = _load_result(existing_pool, ret)
1229     return ret
1230 def modify_pool_member(
1231     hostname,
1232     username,
1233     password,
1234     name,
1235     member,
1236     connection_limit=None,
1237     description=None,
1238     dynamic_ratio=None,
1239     inherit_profile=None,
1240     logging=None,
1241     monitor=None,
1242     priority_group=None,
1243     profiles=None,
1244     rate_limit=None,
1245     ratio=None,
1246     session=None,
1247     member_state=None,
1248 ):
1249     """
1250     A function to connect to a bigip device and modify a member of an existing pool.
1251     hostname
1252         The host/address of the bigip device
1253     username
1254         The iControl REST username
1255     password
1256         The iControl REST password
1257     name
1258         The name of the pool to modify
1259     member
1260         The member modify
1261     connection_limit
1262         [integer]
1263     description
1264         [string]
1265     dynamic_ratio
1266         [integer]
1267     inherit_profile
1268         [enabled | disabled]
1269     logging
1270         [enabled | disabled]
1271     monitor
1272         [name]
1273     priority_group
1274         [integer]
1275     profiles
1276         [none | profile_name]
1277     rate_limit
1278         [integer]
1279     ratio
1280         [integer]
1281     session
1282         [user-enabled | user-disabled]
1283     member_state (state)
1284         [ user-up | user-down ]
1285     """
1286     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
1287     if __opts__["test"]:
1288         return _test_output(
1289             ret,
1290             "modify",
1291             params={
1292                 "hostname": hostname,
1293                 "username": username,
1294                 "password": password,
1295                 "name": name,
1296                 "members": member,
1297             },
1298         )
1299     existing_pool = __salt__["bigip.list_pool"](hostname, username, password, name)
1300     if existing_pool["code"] == 200:
1301         current_members = existing_pool["content"]["membersReference"]["items"]
1302         exists = False
1303         for current_member in current_members:
1304             if current_member["name"] == member:
1305                 exists = True
1306                 existing_member = current_member
1307                 break
1308         if exists:
1309             modified = __salt__["bigip.modify_pool_member"](
1310                 hostname=hostname,
1311                 username=username,
1312                 password=password,
1313                 name=name,
1314                 member=member,
1315                 connection_limit=connection_limit,
1316                 description=description,
1317                 dynamic_ratio=dynamic_ratio,
1318                 inherit_profile=inherit_profile,
1319                 logging=logging,
1320                 monitor=monitor,
1321                 priority_group=priority_group,
1322                 profiles=profiles,
1323                 rate_limit=rate_limit,
1324                 ratio=ratio,
1325                 session=session,
1326                 state=member_state,
1327             )
1328             new_pool = __salt__["bigip.list_pool"](hostname, username, password, name)
1329             if modified["code"] == 200 and modified["code"] == 200:
1330                 new_members = new_pool["content"]["membersReference"]["items"]
1331                 for new_member in new_members:
1332                     if new_member["name"] == member:
1333                         modified_member = new_member
1334                         break
1335                 old = {"content": existing_member}
1336                 new = {"content": modified_member}
1337                 ret = _check_for_changes(
1338                     "Pool Member: {member}".format(member=member), ret, old, new
1339                 )
1340             else:
1341                 ret = _load_result(modified, ret)
1342         else:
1343             ret[
1344                 "comment"
1345             ] = "Member: {name} does not exists within this pool.  No changes made.".format(
1346                 name=member["name"]
1347             )
1348     elif existing_pool["code"] == 404:
1349         ret["comment"] = "A pool with this name was not found."
1350     else:
1351         ret = _load_result(existing_pool, ret)
1352     return ret
1353 def delete_pool_member(hostname, username, password, name, member):
1354     """
1355     Delete an existing pool member.
1356     hostname
1357         The host/address of the bigip device
1358     username
1359         The iControl REST username
1360     password
1361         The iControl REST password
1362     name
1363         The name of the pool to be modified
1364     member
1365         The name of the member to delete from the pool
1366     """
1367     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
1368     if __opts__["test"]:
1369         return _test_output(
1370             ret,
1371             "delete",
1372             params={
1373                 "hostname": hostname,
1374                 "username": username,
1375                 "password": password,
1376                 "name": name,
1377                 "members": member,
1378             },
1379         )
1380     existing = __salt__["bigip.list_pool"](hostname, username, password, name)
1381     if existing["code"] == 200:
1382         current_members = existing["content"]["membersReference"]["items"]
1383         exists = False
1384         for current_member in current_members:
1385             if current_member["name"] == member:
1386                 exists = True
1387                 existing_member = current_member
1388                 break
1389         if exists:
1390             deleted = __salt__["bigip.delete_pool_member"](
1391                 hostname, username, password, name, member
1392             )
1393             if deleted["code"] == 200:
1394                 ret["result"] = True
1395                 ret[
1396                     "comment"
1397                 ] = "Pool Member: {member} was successfully deleted.".format(
1398                     member=member
1399                 )
1400                 ret["changes"]["old"] = existing_member
1401                 ret["changes"]["new"] = {}
1402         else:
1403             ret["result"] = True
1404             ret["comment"] = "This pool member already does not exist. No changes made."
1405             ret["changes"]["old"] = {}
1406             ret["changes"]["new"] = {}
1407     else:
1408         ret = _load_result(existing, ret)
1409     return ret
1410 def list_virtual(hostname, username, password, name):
1411     """
1412     A function to list a specific virtual.
1413     hostname
1414         The host/address of the bigip device
1415     username
1416         The iControl REST username
1417     password
1418         The iControl REST password
1419     name
1420         The name of the virtual to list
1421     """
1422     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
1423     if __opts__["test"]:
1424         return _test_output(
1425             ret,
1426             "list",
1427             params={
1428                 "hostname": hostname,
1429                 "username": username,
1430                 "password": password,
1431                 "name": name,
1432             },
1433         )
1434     response = __salt__["bigip.list_virtual"](hostname, username, password, name)
1435     return _load_result(response, ret)
1436 def create_virtual(
1437     hostname,
1438     username,
1439     password,
1440     name,
1441     destination,
1442     pool=None,
1443     address_status=None,
1444     auto_lasthop=None,
1445     bwc_policy=None,
1446     cmp_enabled=None,
1447     connection_limit=None,
1448     dhcp_relay=None,
1449     description=None,
1450     fallback_persistence=None,
1451     flow_eviction_policy=None,
1452     gtm_score=None,
1453     ip_forward=None,
1454     ip_protocol=None,
1455     internal=None,
1456     twelve_forward=None,
1457     last_hop_pool=None,
1458     mask=None,
1459     mirror=None,
1460     nat64=None,
1461     persist=None,
1462     profiles=None,
1463     policies=None,
1464     rate_class=None,
1465     rate_limit=None,
1466     rate_limit_mode=None,
1467     rate_limit_dst=None,
1468     rate_limit_src=None,
1469     rules=None,
1470     related_rules=None,
1471     reject=None,
1472     source=None,
1473     source_address_translation=None,
1474     source_port=None,
1475     virtual_state=None,
1476     traffic_classes=None,
1477     translate_address=None,
1478     translate_port=None,
1479     vlans=None,
1480 ):
1481     """
1482     A function to connect to a bigip device and create a virtual server if it does not already exists.
1483     hostname
1484         The host/address of the bigip device
1485     username
1486         The iControl REST username
1487     password
1488         The iControl REST password
1489     name
1490         The name of the virtual to create
1491     destination
1492         [ [virtual_address_name:port] | [ipv4:port] | [ipv6.port] ]
1493     pool
1494         [ [pool_name] | none]
1495     address_status
1496         [yes | no]
1497     auto_lasthop
1498         [default | enabled | disabled ]
1499     bwc_policy
1500         [none] | string]
1501     cmp_enabled
1502         [yes | no]
1503     dhcp_relay
1504         [yes | no}
1505     connection_limit
1506         [integer]
1507     description
1508         [string]
1509     state
1510         [disabled | enabled]
1511     fallback_persistence
1512         [none | [profile name] ]
1513     flow_eviction_policy
1514         [none | [eviction policy name] ]
1515     gtm_score
1516         [integer]
1517     ip_forward
1518         [yes | no]
1519     ip_protocol
1520         [any | protocol]
1521     internal
1522         [yes | no]
1523     twelve_forward(12-forward)
1524         [yes | no]
1525     last_hop-pool
1526         [ [pool_name] | none]
1527     mask
1528         { [ipv4] | [ipv6] }
1529     mirror
1530         { [disabled | enabled | none] }
1531     nat64
1532         [enabled | disabled]
1533     persist
1534         [list]
1535     profiles
1536         [none | default | list ]
1537     policies
1538         [none | default | list ]
1539     rate_class
1540         [name]
1541     rate_limit
1542         [integer]
1543     rate_limit-mode
1544         [destination | object | object-destination |
1545         object-source | object-source-destination |
1546         source | source-destination]
1547     rate_limit-dst
1548         [integer]
1549     rate_limit-src
1550         [integer]
1551     rules
1552         [none | list ]
1553     related_rules
1554         [none | list ]
1555     reject
1556         [yes | no]
1557     source
1558         { [ipv4[/prefixlen]] | [ipv6[/prefixlen]] }
1559     source_address_translation
1560         [none | snat:pool_name | lsn | automap | dictionary ]
1561     source_port
1562         [change | preserve | preserve-strict]
1563     state
1564         [enabled | disabled]
1565     traffic_classes
1566         [none | default | list ]
1567     translate_address
1568         [enabled | disabled]
1569     translate_port
1570         [enabled | disabled]
1571     vlans
1572         [none | default | dictionary]
1573         vlan_ids
1574             [ list]
1575         enabled
1576             [ true | false ]
1577     """
1578     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
1579     if __opts__["test"]:
1580         return _test_output(
1581             ret,
1582             "create",
1583             params={
1584                 "hostname": hostname,
1585                 "username": username,
1586                 "password": password,
1587                 "name": name,
1588                 "destination": destination,
1589                 "pool": pool,
1590                 "address_status": address_status,
1591                 "auto_lasthop": auto_lasthop,
1592                 "bwc_policy": bwc_policy,
1593                 "cmp_enabled": cmp_enabled,
1594                 "connection_limit": connection_limit,
1595                 "dhcp_relay": dhcp_relay,
1596                 "description": description,
1597                 "fallback_persistence": fallback_persistence,
1598                 "flow_eviction_policy": flow_eviction_policy,
1599                 "gtm_score": gtm_score,
1600                 "ip_forward": ip_forward,
1601                 "ip_protocol": ip_protocol,
1602                 "internal": internal,
1603                 "twelve_forward": twelve_forward,
1604                 "last_hop_pool": last_hop_pool,
1605                 "mask": mask,
1606                 "mirror": mirror,
1607                 "nat64": nat64,
1608                 "persist": persist,
1609                 "profiles": profiles,
1610                 "policies": policies,
1611                 "rate_class": rate_class,
1612                 "rate_limit": rate_limit,
1613                 "rate_limit_mode": rate_limit_mode,
1614                 "rate_limit_dst": rate_limit_dst,
1615                 "rate_limit_src": rate_limit_src,
1616                 "rules": rules,
1617                 "related_rules": related_rules,
1618                 "reject": reject,
1619                 "source": source,
1620                 "source_address_translation": source_address_translation,
1621                 "source_port": source_port,
1622                 "virtual_state": virtual_state,
1623                 "traffic_classes": traffic_classes,
1624                 "translate_address": translate_address,
1625                 "translate_port": translate_port,
1626                 "vlans": vlans,
1627             },
1628         )
1629     existing = __salt__["bigip.list_virtual"](hostname, username, password, name)
1630     if existing["code"] == 200:
1631         ret["result"] = True
1632         ret["comment"] = "A virtual by this name currently exists.  No change made."
1633     elif existing["code"] == 404:
1634         virtual = __salt__["bigip.create_virtual"](
1635             hostname=hostname,
1636             username=username,
1637             password=password,
1638             name=name,
1639             destination=destination,
1640             description=description,
1641             pool=pool,
1642             address_status=address_status,
1643             auto_lasthop=auto_lasthop,
1644             bwc_policy=bwc_policy,
1645             cmp_enabled=cmp_enabled,
1646             connection_limit=connection_limit,
1647             dhcp_relay=dhcp_relay,
1648             fallback_persistence=fallback_persistence,
1649             flow_eviction_policy=flow_eviction_policy,
1650             gtm_score=gtm_score,
1651             ip_forward=ip_forward,
1652             ip_protocol=ip_protocol,
1653             internal=internal,
1654             twelve_forward=twelve_forward,
1655             last_hop_pool=last_hop_pool,
1656             mask=mask,
1657             mirror=mirror,
1658             nat64=nat64,
1659             persist=persist,
1660             profiles=profiles,
1661             policies=policies,
1662             rate_class=rate_class,
1663             rate_limit=rate_limit,
1664             rate_limit_mode=rate_limit_mode,
1665             rate_limit_dst=rate_limit_dst,
1666             rate_limit_src=rate_limit_src,
1667             rules=rules,
1668             related_rules=related_rules,
1669             reject=reject,
1670             source=source,
1671             source_address_translation=source_address_translation,
1672             source_port=source_port,
1673             state=virtual_state,
1674             traffic_classes=traffic_classes,
1675             translate_address=translate_address,
1676             translate_port=translate_port,
1677             vlans=vlans,
1678         )
1679         if virtual["code"] == 200:
1680             ret["result"] = True
1681             ret["changes"]["old"] = {}
1682             ret["changes"]["new"] = virtual["content"]
1683             ret["comment"] = "Virtual was successfully created."
1684         else:
1685             ret = _load_result(existing, ret)
1686     else:
1687         ret = _load_result(existing, ret)
1688     return ret
1689 def manage_virtual(
1690     hostname,
1691     username,
1692     password,
1693     name,
1694     destination,
1695     pool=None,
1696     address_status=None,
1697     auto_lasthop=None,
1698     bwc_policy=None,
1699     cmp_enabled=None,
1700     connection_limit=None,
1701     dhcp_relay=None,
1702     description=None,
1703     fallback_persistence=None,
1704     flow_eviction_policy=None,
1705     gtm_score=None,
1706     ip_forward=None,
1707     ip_protocol=None,
1708     internal=None,
1709     twelve_forward=None,
1710     last_hop_pool=None,
1711     mask=None,
1712     mirror=None,
1713     nat64=None,
1714     persist=None,
1715     profiles=None,
1716     policies=None,
1717     rate_class=None,
1718     rate_limit=None,
1719     rate_limit_mode=None,
1720     rate_limit_dst=None,
1721     rate_limit_src=None,
1722     rules=None,
1723     related_rules=None,
1724     reject=None,
1725     source=None,
1726     source_address_translation=None,
1727     source_port=None,
1728     virtual_state=None,
1729     traffic_classes=None,
1730     translate_address=None,
1731     translate_port=None,
1732     vlans=None,
1733 ):
1734     """
1735     Manage a virtual server.  If a virtual does not exists it will be created, otherwise only the
1736     parameters specified will be enforced.
1737     hostname
1738         The host/address of the bigip device
1739     username
1740         The iControl REST username
1741     password
1742         The iControl REST password
1743     name
1744         The name of the virtual to create
1745     destination
1746         [ [virtual_address_name:port] | [ipv4:port] | [ipv6.port] ]
1747     pool
1748         [ [pool_name] | none]
1749     address_status
1750         [yes | no]
1751     auto_lasthop
1752         [default | enabled | disabled ]
1753     bwc_policy
1754         [none] | string]
1755     cmp_enabled
1756         [yes | no]
1757     dhcp_relay
1758         [yes | no}
1759     connection_limit
1760         [integer]
1761     description
1762         [string]
1763     state
1764         [disabled | enabled]
1765     fallback_persistence
1766         [none | [profile name] ]
1767     flow_eviction_policy
1768         [none | [eviction policy name] ]
1769     gtm_score
1770         [integer]
1771     ip_forward
1772         [yes | no]
1773     ip_protocol
1774         [any | protocol]
1775     internal
1776         [yes | no]
1777     twelve_forward(12-forward)
1778         [yes | no]
1779     last_hop-pool
1780         [ [pool_name] | none]
1781     mask
1782         { [ipv4] | [ipv6] }
1783     mirror
1784         { [disabled | enabled | none] }
1785     nat64
1786         [enabled | disabled]
1787     persist
1788         [list]
1789     profiles
1790         [none | default | list ]
1791     policies
1792         [none | default | list ]
1793     rate_class
1794         [name]
1795     rate_limit
1796         [integer]
1797     rate_limit-mode
1798         [destination | object | object-destination |
1799         object-source | object-source-destination |
1800         source | source-destination]
1801     rate_limit-dst
1802         [integer]
1803     rate_limit-src
1804         [integer]
1805     rules
1806         [none | list ]
1807     related_rules
1808         [none | list ]
1809     reject
1810         [yes | no]
1811     source
1812         { [ipv4[/prefixlen]] | [ipv6[/prefixlen]] }
1813     source_address_translation
1814         [none | snat:pool_name | lsn | automap | dictionary ]
1815     source_port
1816         [change | preserve | preserve-strict]
1817     state
1818         [enabled | disabled]
1819     traffic_classes
1820         [none | default | list ]
1821     translate_address
1822         [enabled | disabled]
1823     translate_port
1824         [enabled | disabled]
1825     vlans
1826         [none | default | dictionary]
1827         vlan_ids
1828             [ list]
1829         enabled
1830             [ true | false ]
1831     """
1832     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
1833     if __opts__["test"]:
1834         return _test_output(
1835             ret,
1836             "manage",
1837             params={
1838                 "hostname": hostname,
1839                 "username": username,
1840                 "password": password,
1841                 "name": name,
1842                 "destination": destination,
1843                 "pool": pool,
1844                 "address_status": address_status,
1845                 "auto_lasthop": auto_lasthop,
1846                 "bwc_policy": bwc_policy,
1847                 "cmp_enabled": cmp_enabled,
1848                 "connection_limit": connection_limit,
1849                 "dhcp_relay": dhcp_relay,
1850                 "description": description,
1851                 "fallback_persistence": fallback_persistence,
1852                 "flow_eviction_policy": flow_eviction_policy,
1853                 "gtm_score": gtm_score,
1854                 "ip_forward": ip_forward,
1855                 "ip_protocol": ip_protocol,
1856                 "internal": internal,
1857                 "twelve_forward": twelve_forward,
1858                 "last_hop_pool": last_hop_pool,
1859                 "mask": mask,
1860                 "mirror": mirror,
1861                 "nat64": nat64,
1862                 "persist": persist,
1863                 "profiles": profiles,
1864                 "policies": policies,
1865                 "rate_class": rate_class,
1866                 "rate_limit": rate_limit,
1867                 "rate_limit_mode": rate_limit_mode,
1868                 "rate_limit_dst": rate_limit_dst,
1869                 "rate_limit_src": rate_limit_src,
1870                 "rules": rules,
1871                 "related_rules": related_rules,
1872                 "reject": reject,
1873                 "source": source,
1874                 "source_address_translation": source_address_translation,
1875                 "source_port": source_port,
1876                 "virtual_state": virtual_state,
1877                 "traffic_classes": traffic_classes,
1878                 "translate_address": translate_address,
1879                 "translate_port": translate_port,
1880                 "vlans": vlans,
1881             },
1882         )
1883     existing = __salt__["bigip.list_virtual"](hostname, username, password, name)
1884     if existing["code"] == 200:
1885         modified = __salt__["bigip.modify_virtual"](
1886             hostname=hostname,
1887             username=username,
1888             password=password,
1889             name=name,
1890             destination=destination,
1891             description=description,
1892             pool=pool,
1893             address_status=address_status,
1894             auto_lasthop=auto_lasthop,
1895             bwc_policy=bwc_policy,
1896             cmp_enabled=cmp_enabled,
1897             connection_limit=connection_limit,
1898             dhcp_relay=dhcp_relay,
1899             fallback_persistence=fallback_persistence,
1900             flow_eviction_policy=flow_eviction_policy,
1901             gtm_score=gtm_score,
1902             ip_forward=ip_forward,
1903             ip_protocol=ip_protocol,
1904             internal=internal,
1905             twelve_forward=twelve_forward,
1906             last_hop_pool=last_hop_pool,
1907             mask=mask,
1908             mirror=mirror,
1909             nat64=nat64,
1910             persist=persist,
1911             profiles=profiles,
1912             policies=policies,
1913             rate_class=rate_class,
1914             rate_limit=rate_limit,
1915             rate_limit_mode=rate_limit_mode,
1916             rate_limit_dst=rate_limit_dst,
1917             rate_limit_src=rate_limit_src,
1918             rules=rules,
1919             related_rules=related_rules,
1920             reject=reject,
1921             source=source,
1922             source_address_translation=source_address_translation,
1923             source_port=source_port,
1924             state=virtual_state,
1925             traffic_classes=traffic_classes,
1926             translate_address=translate_address,
1927             translate_port=translate_port,
1928             vlans=vlans,
1929         )
1930         if modified["code"] == 200:
1931             relisting = __salt__["bigip.list_virtual"](
1932                 hostname, username, password, name
1933             )
1934             if relisting["code"] == 200:
1935                 relisting = _strip_key(relisting, "generation")
1936                 existing = _strip_key(existing, "generation")
1937                 ret = _check_for_changes("Virtual", ret, existing, relisting)
1938             else:
1939                 ret = _load_result(relisting, ret)
1940         else:
1941             ret = _load_result(modified, ret)
1942     elif existing["code"] == 404:
1943         virtual = __salt__["bigip.create_virtual"](
1944             hostname=hostname,
1945             username=username,
1946             password=password,
1947             name=name,
1948             destination=destination,
1949             description=description,
1950             pool=pool,
1951             address_status=address_status,
1952             auto_lasthop=auto_lasthop,
1953             bwc_policy=bwc_policy,
1954             cmp_enabled=cmp_enabled,
1955             connection_limit=connection_limit,
1956             dhcp_relay=dhcp_relay,
1957             fallback_persistence=fallback_persistence,
1958             flow_eviction_policy=flow_eviction_policy,
1959             gtm_score=gtm_score,
1960             ip_forward=ip_forward,
1961             ip_protocol=ip_protocol,
1962             internal=internal,
1963             twelve_forward=twelve_forward,
1964             last_hop_pool=last_hop_pool,
1965             mask=mask,
1966             mirror=mirror,
1967             nat64=nat64,
1968             persist=persist,
1969             profiles=profiles,
1970             policies=policies,
1971             rate_class=rate_class,
1972             rate_limit=rate_limit,
1973             rate_limit_mode=rate_limit_mode,
1974             rate_limit_dst=rate_limit_dst,
1975             rate_limit_src=rate_limit_src,
1976             rules=rules,
1977             related_rules=related_rules,
1978             reject=reject,
1979             source=source,
1980             source_address_translation=source_address_translation,
1981             source_port=source_port,
1982             state=virtual_state,
1983             traffic_classes=traffic_classes,
1984             translate_address=translate_address,
1985             translate_port=translate_port,
1986             vlans=vlans,
1987         )
1988         if virtual["code"] == 200:
1989             ret["result"] = True
1990             ret["changes"]["old"] = {}
1991             ret["changes"]["new"] = virtual["content"]
1992             ret[
1993                 "comment"
1994             ] = "Virtual was successfully created and enforced to the desired state."
1995         else:
1996             ret = _load_result(virtual, ret)
1997     else:
1998         ret = _load_result(existing, ret)
1999     return ret
2000 def modify_virtual(
2001     hostname,
2002     username,
2003     password,
2004     name,
2005     destination,
2006     pool=None,
2007     address_status=None,
2008     auto_lasthop=None,
2009     bwc_policy=None,
2010     cmp_enabled=None,
2011     connection_limit=None,
2012     dhcp_relay=None,
2013     description=None,
2014     fallback_persistence=None,
2015     flow_eviction_policy=None,
2016     gtm_score=None,
2017     ip_forward=None,
2018     ip_protocol=None,
2019     internal=None,
2020     twelve_forward=None,
2021     last_hop_pool=None,
2022     mask=None,
2023     mirror=None,
2024     nat64=None,
2025     persist=None,
2026     profiles=None,
2027     policies=None,
2028     rate_class=None,
2029     rate_limit=None,
2030     rate_limit_mode=None,
2031     rate_limit_dst=None,
2032     rate_limit_src=None,
2033     rules=None,
2034     related_rules=None,
2035     reject=None,
2036     source=None,
2037     source_address_translation=None,
2038     source_port=None,
2039     virtual_state=None,
2040     traffic_classes=None,
2041     translate_address=None,
2042     translate_port=None,
2043     vlans=None,
2044 ):
2045     """
2046     Modify an virtual server.  modify an existing virtual.  Only parameters specified will be enforced.
2047     hostname
2048         The host/address of the bigip device
2049     username
2050         The iControl REST username
2051     password
2052         The iControl REST password
2053     name
2054         The name of the virtual to create
2055     destination
2056         [ [virtual_address_name:port] | [ipv4:port] | [ipv6.port] ]
2057     pool
2058         [ [pool_name] | none]
2059     address_status
2060         [yes | no]
2061     auto_lasthop
2062         [default | enabled | disabled ]
2063     bwc_policy
2064         [none] | string]
2065     cmp_enabled
2066         [yes | no]
2067     dhcp_relay
2068         [yes | no}
2069     connection_limit
2070         [integer]
2071     description
2072         [string]
2073     state
2074         [disabled | enabled]
2075     fallback_persistence
2076         [none | [profile name] ]
2077     flow_eviction_policy
2078         [none | [eviction policy name] ]
2079     gtm_score
2080         [integer]
2081     ip_forward
2082         [yes | no]
2083     ip_protocol
2084         [any | protocol]
2085     internal
2086         [yes | no]
2087     twelve_forward(12-forward)
2088         [yes | no]
2089     last_hop-pool
2090         [ [pool_name] | none]
2091     mask
2092         { [ipv4] | [ipv6] }
2093     mirror
2094         { [disabled | enabled | none] }
2095     nat64
2096         [enabled | disabled]
2097     persist
2098         [list]
2099     profiles
2100         [none | default | list ]
2101     policies
2102         [none | default | list ]
2103     rate_class
2104         [name]
2105     rate_limit
2106         [integer]
2107     rate_limit-mode
2108         [destination | object | object-destination |
2109         object-source | object-source-destination |
2110         source | source-destination]
2111     rate_limit_dst
2112         [integer]
2113     rate_limit_src
2114         [integer]
2115     rules
2116         [none | list ]
2117     related_rules
2118         [none | list ]
2119     reject
2120         [yes | no]
2121     source
2122         { [ipv4[/prefixlen]] | [ipv6[/prefixlen]] }
2123     source_address_translation
2124         [none | snat:pool_name | lsn | automap | dictionary ]
2125     source_port
2126         [change | preserve | preserve-strict]
2127     state
2128         [enabled | disabled]
2129     traffic_classes
2130         [none | default | list ]
2131     translate_address
2132         [enabled | disabled]
2133     translate_port
2134         [enabled | disabled]
2135     vlans
2136         [none | default | dictionary ]
2137         vlan_ids
2138             [ list]
2139         enabled
2140             [ true | false ]
2141     """
2142     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
2143     if __opts__["test"]:
2144         return _test_output(
2145             ret,
2146             "modify",
2147             params={
2148                 "hostname": hostname,
2149                 "username": username,
2150                 "password": password,
2151                 "name": name,
2152                 "destination": destination,
2153                 "pool": pool,
2154                 "address_status": address_status,
2155                 "auto_lasthop": auto_lasthop,
2156                 "bwc_policy": bwc_policy,
2157                 "cmp_enabled": cmp_enabled,
2158                 "connection_limit": connection_limit,
2159                 "dhcp_relay": dhcp_relay,
2160                 "description": description,
2161                 "fallback_persistence": fallback_persistence,
2162                 "flow_eviction_policy": flow_eviction_policy,
2163                 "gtm_score": gtm_score,
2164                 "ip_forward": ip_forward,
2165                 "ip_protocol": ip_protocol,
2166                 "internal": internal,
2167                 "twelve_forward": twelve_forward,
2168                 "last_hop_pool": last_hop_pool,
2169                 "mask": mask,
2170                 "mirror": mirror,
2171                 "nat64": nat64,
2172                 "persist": persist,
2173                 "profiles": profiles,
2174                 "policies": policies,
2175                 "rate_class": rate_class,
2176                 "rate_limit": rate_limit,
2177                 "rate_limit_mode": rate_limit_mode,
2178                 "rate_limit_dst": rate_limit_dst,
2179                 "rate_limit_src": rate_limit_src,
2180                 "rules": rules,
2181                 "related_rules": related_rules,
2182                 "reject": reject,
2183                 "source": source,
2184                 "source_address_translation": source_address_translation,
2185                 "source_port": source_port,
2186                 "virtual_state": virtual_state,
2187                 "traffic_classes": traffic_classes,
2188                 "translate_address": translate_address,
2189                 "translate_port": translate_port,
2190                 "vlans": vlans,
2191             },
2192         )
2193     existing = __salt__["bigip.list_virtual"](hostname, username, password, name)
2194     if existing["code"] == 200:
2195         modified = __salt__["bigip.modify_virtual"](
2196             hostname=hostname,
2197             username=username,
2198             password=password,
2199             name=name,
2200             destination=destination,
2201             description=description,
2202             pool=pool,
2203             address_status=address_status,
2204             auto_lasthop=auto_lasthop,
2205             bwc_policy=bwc_policy,
2206             cmp_enabled=cmp_enabled,
2207             connection_limit=connection_limit,
2208             dhcp_relay=dhcp_relay,
2209             fallback_persistence=fallback_persistence,
2210             flow_eviction_policy=flow_eviction_policy,
2211             gtm_score=gtm_score,
2212             ip_forward=ip_forward,
2213             ip_protocol=ip_protocol,
2214             internal=internal,
2215             twelve_forward=twelve_forward,
2216             last_hop_pool=last_hop_pool,
2217             mask=mask,
2218             mirror=mirror,
2219             nat64=nat64,
2220             persist=persist,
2221             profiles=profiles,
2222             policies=policies,
2223             rate_class=rate_class,
2224             rate_limit=rate_limit,
2225             rate_limit_mode=rate_limit_mode,
2226             rate_limit_dst=rate_limit_dst,
2227             rate_limit_src=rate_limit_src,
2228             rules=rules,
2229             related_rules=related_rules,
2230             reject=reject,
2231             source=source,
2232             source_address_translation=source_address_translation,
2233             source_port=source_port,
2234             state=virtual_state,
2235             traffic_classes=traffic_classes,
2236             translate_address=translate_address,
2237             translate_port=translate_port,
2238             vlans=vlans,
2239         )
2240         if modified["code"] == 200:
2241             relisting = __salt__["bigip.list_virtual"](
2242                 hostname, username, password, name
2243             )
2244             if relisting["code"] == 200:
2245                 relisting = _strip_key(relisting, "generation")
2246                 existing = _strip_key(existing, "generation")
2247                 ret = _check_for_changes("Virtual", ret, existing, relisting)
2248             else:
2249                 ret = _load_result(relisting, ret)
2250         else:
2251             ret = _load_result(modified, ret)
2252     elif existing["code"] == 404:
2253         ret["comment"] = "A Virtual with this name was not found."
2254     else:
2255         ret = _load_result(existing, ret)
2256     return ret
2257 def delete_virtual(hostname, username, password, name):
2258     """
2259     Delete an existing virtual.
2260     hostname
2261         The host/address of the bigip device
2262     username
2263         The iControl REST username
2264     password
2265         The iControl REST password
2266     name
2267         The name of the virtual which will be deleted
2268     """
2269     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
2270     if __opts__["test"]:
2271         return _test_output(
2272             ret,
2273             "delete",
2274             params={
2275                 "hostname": hostname,
2276                 "username": username,
2277                 "password": password,
2278                 "name": name,
2279             },
2280         )
2281     existing = __salt__["bigip.list_virtual"](hostname, username, password, name)
2282     if existing["code"] == 200:
2283         deleted = __salt__["bigip.delete_virtual"](hostname, username, password, name)
2284         if deleted["code"] == 200:
2285             ret["result"] = True
2286             ret["comment"] = "Virtual was successfully deleted."
2287             ret["changes"]["old"] = existing["content"]
2288             ret["changes"]["new"] = {}
2289         else:
2290             ret = _load_result(deleted, ret)
2291     elif existing["code"] == 404:
2292         ret["result"] = True
2293         ret["comment"] = "This virtual already does not exist. No changes made."
2294         ret["changes"]["old"] = {}
2295         ret["changes"]["new"] = {}
2296     else:
2297         ret = _load_result(existing, ret)
2298     return ret
2299 def list_monitor(hostname, username, password, monitor_type, name):
2300     """
2301     A function to list an existing monitor.
2302     hostname
2303         The host/address of the bigip device
2304     username
2305         The iControl REST username
2306     password
2307         The iControl REST password
2308     monitor_type
2309         The type of monitor to list
2310     name
2311         The name of the monitor to list
2312     """
2313     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
2314     if __opts__["test"]:
2315         return _test_output(
2316             ret,
2317             "list",
2318             params={
2319                 "hostname": hostname,
2320                 "username": username,
2321                 "password": password,
2322                 "monitor_type": monitor_type,
2323                 "name": name,
2324             },
2325         )
2326     response = __salt__["bigip.list_monitor"](
2327         hostname, username, password, monitor_type, name
2328     )
2329     return _load_result(response, ret)
2330 def create_monitor(hostname, username, password, monitor_type, name, **kwargs):
2331     """
2332     A function to connect to a bigip device and create a monitor.
2333     hostname
2334         The host/address of the bigip device
2335     username
2336         The iControl REST username
2337     password
2338         The iControl REST password
2339     monitor_type
2340         The type of monitor to create
2341     name
2342         The name of the monitor to create
2343     kwargs
2344         [ arg=val ] ...
2345         Consult F5 BIGIP user guide for specific options for each monitor type.
2346         Typically, tmsh arg names are used.
2347     """
2348     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
2349     if __opts__["test"]:
2350         params = {
2351             "hostname": hostname,
2352             "username": username,
2353             "password": password,
2354             "monitor_type": monitor_type,
2355             "name": name,
2356         }
2357         for key, value in kwargs.items():
2358             params[key] = value
2359         return _test_output(ret, "create", params)
2360     existing = __salt__["bigip.list_monitor"](
2361         hostname, username, password, monitor_type, name
2362     )
2363     if existing["code"] == 200:
2364         ret["result"] = True
2365         ret["comment"] = "A monitor by this name currently exists.  No change made."
2366     elif existing["code"] == 404:
2367         response = __salt__["bigip.create_monitor"](
2368             hostname, username, password, monitor_type, name, **kwargs
2369         )
2370         if response["code"] == 200:
2371             ret["result"] = True
2372             ret["changes"]["old"] = {}
2373             ret["changes"]["new"] = response["content"]
2374             ret["comment"] = "Monitor was successfully created."
2375         else:
2376             ret = _load_result(response, ret)
2377     else:
2378         ret = _load_result(existing, ret)
2379     return ret
2380 def manage_monitor(hostname, username, password, monitor_type, name, **kwargs):
2381     """
2382     Create a new monitor if a monitor of this type and name does not already exists.  If it does exists, only
2383     the parameters specified will be enforced.
2384     hostname
2385         The host/address of the bigip device
2386     username
2387         The iControl REST username
2388     password
2389         The iControl REST password
2390     monitor_type
2391         The type of monitor to create
2392     name
2393         The name of the monitor to create
2394     kwargs
2395         [ arg=val ] ...
2396         Consult F5 BIGIP user guide for specific options for each monitor type.
2397         Typically, tmsh arg names are used.
2398     """
2399     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
2400     if __opts__["test"]:
2401         params = {
2402             "hostname": hostname,
2403             "username": username,
2404             "password": password,
2405             "monitor_type": monitor_type,
2406             "name": name,
2407         }
2408         for key, value in kwargs.items():
2409             params[key] = value
2410         return _test_output(ret, "manage", params)
2411     existing = __salt__["bigip.list_monitor"](
2412         hostname, username, password, monitor_type, name
2413     )
2414     if existing["code"] == 200:
2415         modified = __salt__["bigip.modify_monitor"](
2416             hostname, username, password, monitor_type, name, **kwargs
2417         )
2418         if modified["code"] == 200:
2419             del existing["content"]["selfLink"]
2420             del modified["content"]["selfLink"]
2421             ret = _check_for_changes("Monitor", ret, existing, modified)
2422         else:
2423             ret = _load_result(modified, ret)
2424     elif existing["code"] == 404:
2425         response = __salt__["bigip.create_monitor"](
2426             hostname, username, password, monitor_type, name, **kwargs
2427         )
2428         if response["code"] == 200:
2429             ret["result"] = True
2430             ret["changes"]["old"] = {}
2431             ret["changes"]["new"] = response["content"]
2432             ret["comment"] = "Monitor was successfully created."
2433         else:
2434             ret = _load_result(response, ret)
2435     else:
2436         ret = _load_result(existing, ret)
2437     return ret
2438 def modify_monitor(hostname, username, password, monitor_type, name, **kwargs):
2439     """
2440     Modify an existing monitor.  If it does exists, only
2441     the parameters specified will be enforced.
2442     hostname
2443         The host/address of the bigip device
2444     username
2445         The iControl REST username
2446     password
2447         The iControl REST password
2448     monitor_type
2449         The type of monitor to create
2450     name
2451         The name of the monitor to create
2452     kwargs
2453         [ arg=val ] ...
2454         Consult F5 BIGIP user guide for specific options for each monitor type.
2455         Typically, tmsh arg names are used.
2456     """
2457     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
2458     if __opts__["test"]:
2459         params = {
2460             "hostname": hostname,
2461             "username": username,
2462             "password": password,
2463             "monitor_type": monitor_type,
2464             "name": name,
2465         }
2466         for key, value in kwargs.items():
2467             params[key] = value
2468         return _test_output(ret, "modify", params)
2469     existing = __salt__["bigip.list_monitor"](
2470         hostname, username, password, monitor_type, name
2471     )
2472     if existing["code"] == 200:
2473         modified = __salt__["bigip.modify_monitor"](
2474             hostname, username, password, monitor_type, name, **kwargs
2475         )
2476         if modified["code"] == 200:
2477             del existing["content"]["selfLink"]
2478             del modified["content"]["selfLink"]
2479             ret = _check_for_changes("Monitor", ret, existing, modified)
2480         else:
2481             ret = _load_result(modified, ret)
2482     elif existing["code"] == 404:
2483         ret["comment"] = "A Monitor with this name was not found."
2484     else:
2485         ret = _load_result(existing, ret)
2486     return ret
2487 def delete_monitor(hostname, username, password, monitor_type, name):
2488     """
2489     Modify an existing monitor.  If it does exists, only
2490     the parameters specified will be enforced.
2491     hostname
2492         The host/address of the bigip device
2493     username
2494         The iControl REST username
2495     password
2496         The iControl REST password
2497     monitor_type
2498         The type of monitor to create
2499     name
2500         The name of the monitor to create
2501     kwargs
2502         [ arg=val ] ...
2503         Consult F5 BIGIP user guide for specific options for each monitor type.
2504         Typically, tmsh arg names are used.
2505     """
2506     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
2507     if __opts__["test"]:
2508         return _test_output(
2509             ret,
2510             "delete",
2511             params={
2512                 "hostname": hostname,
2513                 "username": username,
2514                 "password": password,
2515                 "monitor_type": monitor_type,
2516                 "name": name,
2517             },
2518         )
2519     existing = __salt__["bigip.list_monitor"](
2520         hostname, username, password, monitor_type, name
2521     )
2522     if existing["code"] == 200:
2523         deleted = __salt__["bigip.delete_monitor"](
2524             hostname, username, password, monitor_type, name
2525         )
2526         if deleted["code"] == 200:
2527             ret["result"] = True
2528             ret["comment"] = "Monitor was successfully deleted."
2529             ret["changes"]["old"] = existing["content"]
2530             ret["changes"]["new"] = {}
2531         else:
2532             ret = _load_result(deleted, ret)
2533     elif existing["code"] == 404:
2534         ret["result"] = True
2535         ret["comment"] = "This Monitor already does not exist. No changes made."
2536         ret["changes"]["old"] = {}
2537         ret["changes"]["new"] = {}
2538     else:
2539         ret = _load_result(existing, ret)
2540     return ret
2541 def list_profile(hostname, username, password, profile_type, name):
2542     """
2543     A function to list an existing profile.
2544     hostname
2545         The host/address of the bigip device
2546     username
2547         The iControl REST username
2548     password
2549         The iControl REST password
2550     profile_type
2551         The type of profile to list
2552     name
2553         The name of the profile to list
2554     """
2555     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
2556     if __opts__["test"]:
2557         return _test_output(
2558             ret,
2559             "list",
2560             params={
2561                 "hostname": hostname,
2562                 "username": username,
2563                 "password": password,
2564                 "profile_type": profile_type,
2565                 "name": name,
2566             },
2567         )
2568     response = __salt__["bigip.list_profile"](
2569         hostname, username, password, profile_type, name
2570     )
2571     return _load_result(response, ret)
2572 def create_profile(hostname, username, password, profile_type, name, **kwargs):
2573     r"""
2574     A function to connect to a bigip device and create a profile.
2575     hostname
2576         The host/address of the bigip device
2577     username
2578         The iControl REST username
2579     password
2580         The iControl REST password
2581     profile_type
2582         The type of profile to create
2583     name
2584         The name of the profile to create
2585     kwargs
2586         [ arg=val ] ...
2587         Consult F5 BIGIP user guide for specific options for each profile type.
2588         Typically, tmsh arg names are used.
2589     Special Characters ``|``, ``,`` and ``:`` must be escaped using ``\`` when
2590     used within strings.
2591     """
2592     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
2593     if __opts__["test"]:
2594         return _test_output(
2595             ret,
2596             "create",
2597             params={
2598                 "hostname": hostname,
2599                 "username": username,
2600                 "password": password,
2601                 "profile_type": profile_type,
2602                 "name": name,
2603             },
2604         )
2605     existing = __salt__["bigip.list_profile"](
2606         hostname, username, password, profile_type, name
2607     )
2608     if existing["code"] == 200:
2609         ret["result"] = True
2610         ret["comment"] = "A profile by this name currently exists.  No change made."
2611     elif existing["code"] == 404:
2612         response = __salt__["bigip.create_profile"](
2613             hostname, username, password, profile_type, name, **kwargs
2614         )
2615         if response["code"] == 200:
2616             ret["result"] = True
2617             ret["changes"]["old"] = {}
2618             ret["changes"]["new"] = response["content"]
2619             ret["comment"] = "Profile was successfully created."
2620         else:
2621             ret = _load_result(response, ret)
2622     else:
2623         ret = _load_result(existing, ret)
2624     return ret
2625 def manage_profile(hostname, username, password, profile_type, name, **kwargs):
2626     """
2627     Create a new profile if a monitor of this type and name does not already exists.  If it does exists, only
2628     the parameters specified will be enforced.
2629     hostname
2630         The host/address of the bigip device
2631     username
2632         The iControl REST username
2633     password
2634         The iControl REST password
2635     profile_type
2636         The type of profile to create
2637     name
2638         The name of the profile to create
2639     kwargs
2640         [ arg=val ] ...
2641         Consult F5 BIGIP user guide for specific options for each profile type.
2642         Typically, tmsh arg names are used.
2643     """
2644     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
2645     if __opts__["test"]:
2646         params = {
2647             "hostname": hostname,
2648             "username": username,
2649             "password": password,
2650             "profile_type": profile_type,
2651             "name": name,
2652         }
2653         for key, value in kwargs.items():
2654             params[key] = value
2655         return _test_output(ret, "manage", params)
2656     existing = __salt__["bigip.list_profile"](
2657         hostname, username, password, profile_type, name
2658     )
2659     if existing["code"] == 200:
2660         modified = __salt__["bigip.modify_profile"](
2661             hostname, username, password, profile_type, name, **kwargs
2662         )
2663         if modified["code"] == 200:
2664             del existing["content"]["selfLink"]
2665             del modified["content"]["selfLink"]
2666             ret = _check_for_changes("Profile", ret, existing, modified)
2667         else:
2668             ret = _load_result(modified, ret)
2669     elif existing["code"] == 404:
2670         response = __salt__["bigip.create_profile"](
2671             hostname, username, password, profile_type, name, **kwargs
2672         )
2673         if response["code"] == 200:
2674             ret["result"] = True
2675             ret["changes"]["old"] = {}
2676             ret["changes"]["new"] = response["content"]
2677             ret["comment"] = "Profile was successfully created."
2678         else:
2679             ret = _load_result(existing, ret)
2680     else:
2681         ret = _load_result(existing, ret)
2682     return ret
2683 def modify_profile(hostname, username, password, profile_type, name, **kwargs):
2684     """
2685     Modify an existing profile.  If it does exists, only
2686     the parameters specified will be enforced.
2687     hostname
2688         The host/address of the bigip device
2689     username
2690         The iControl REST username
2691     password
2692         The iControl REST password
2693     profile_type
2694         The type of profile to create
2695     name
2696         The name of the profile to create
2697     kwargs
2698         [ arg=val ] ...
2699         Consult F5 BIGIP user guide for specific options for each monitor type.
2700         Typically, tmsh arg names are used.
2701     """
2702     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
2703     if __opts__["test"]:
2704         params = {
2705             "hostname": hostname,
2706             "username": username,
2707             "password": password,
2708             "profile_type": profile_type,
2709             "name": name,
2710         }
2711         for key, value in kwargs.items():
2712             params[key] = value
2713         return _test_output(ret, "modify", params)
2714     existing = __salt__["bigip.list_profile"](
2715         hostname, username, password, profile_type, name
2716     )
2717     if existing["code"] == 200:
2718         modified = __salt__["bigip.modify_profile"](
2719             hostname, username, password, profile_type, name, **kwargs
2720         )
2721         if modified["code"] == 200:
2722             del existing["content"]["selfLink"]
2723             del modified["content"]["selfLink"]
2724             ret = _check_for_changes("Profile", ret, existing, modified)
2725         else:
2726             ret = _load_result(modified, ret)
2727     elif existing["code"] == 404:
2728         ret["comment"] = "A Profile with this name was not found."
2729     else:
2730         ret = _load_result(existing, ret)
2731     return ret
2732 def delete_profile(hostname, username, password, profile_type, name):
2733     """
2734     Modify an existing profile.  If it does exists, only
2735     the parameters specified will be enforced.
2736     hostname
2737         The host/address of the bigip device
2738     username
2739         The iControl REST username
2740     password
2741         The iControl REST password
2742     profile_type
2743         The type of profile to create
2744     name
2745         The name of the profile to create
2746     kwargs
2747         [ arg=val ] ...
2748         Consult F5 BIGIP user guide for specific options for each profile type.
2749         Typically, tmsh arg names are used.
2750     """
2751     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
2752     if __opts__["test"]:
2753         return _test_output(
2754             ret,
2755             "delete",
2756             params={
2757                 "hostname": hostname,
2758                 "username": username,
2759                 "password": password,
2760                 "profile_type": profile_type,
2761                 "name": name,
2762             },
2763         )
2764     existing = __salt__["bigip.list_profile"](
2765         hostname, username, password, profile_type, name
2766     )
2767     if existing["code"] == 200:
2768         deleted = __salt__["bigip.delete_profile"](
2769             hostname, username, password, profile_type, name
2770         )
2771         if deleted["code"] == 200:
2772             ret["result"] = True
2773             ret["comment"] = "Profile was successfully deleted."
2774             ret["changes"]["old"] = existing["content"]
2775             ret["changes"]["new"] = {}
2776         else:
2777             ret = _load_result(deleted, ret)
2778     elif existing["code"] == 404:
2779         ret["result"] = True
2780         ret["comment"] = "This Profile already does not exist. No changes made."
2781         ret["changes"]["old"] = {}
2782         ret["changes"]["new"] = {}
2783     else:
2784         ret = _load_result(existing, ret)
2785     return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
