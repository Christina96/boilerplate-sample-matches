
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-base_fields.py</h3>
            <pre><code>1  import binascii
2  import sys
3  from bitstring import BitArray, BitStream, CreationError
4  import esptool
5  from . import util
6  class CheckArgValue(object):
7      def __init__(self, efuses, name):
8          self.efuses = efuses
9          self.name = name
10      def __call__(self, new_value_str):
11          def check_arg_value(efuse, new_value):
12              if efuse.efuse_type.startswith("bool"):
13                  new_value = 1 if new_value is None else int(new_value, 0)
14                  if new_value != 1:
15                      raise esptool.FatalError(
16                          "New value is not accepted for efuse '{}' "
17                          "(will always burn 0->1), given value={}".format(
18                              efuse.name, new_value
19                          )
20                      )
21              elif efuse.efuse_type.startswith(("int", "uint")):
22                  if efuse.efuse_class == "bitcount":
23                      if new_value is None:
24                          old_value = efuse.get_raw()
25                          new_value = old_value
26                          bit = 1
27                          while new_value == old_value:
28                              new_value = bit | old_value
29                              bit <<= 1
30                      else:
31                          new_value = int(new_value, 0)
32                  else:
33                      if new_value is None:
34                          raise esptool.FatalError(
35                              "New value required for efuse '{}' (given None)".format(
36                                  efuse.name
37                              )
38                          )
39                      new_value = int(new_value, 0)
40                      if new_value == 0:
41                          raise esptool.FatalError(
42                              "New value should not be 0 for '{}' "
43                              "(given value= {})".format(efuse.name, new_value)
44                          )
45              elif efuse.efuse_type.startswith("bytes"):
46                  if new_value is None:
47                      raise esptool.FatalError(
48                          "New value required for efuse '{}' "
49                          "(given None)".format(efuse.name)
50                      )
51                  if len(new_value) * 8 != efuse.bitarray.len:
52                      raise esptool.FatalError(
53                          "The length of efuse '{}' ({} bits) "
54                          "(given len of the new value= {} bits)".format(
55                              efuse.name, efuse.bitarray.len, len(new_value) * 8
56                          )
57                      )
58              else:
59                  raise esptool.FatalError(
60                      "The '{}' type for the '{}' efuse is not supported yet.".format(
61                          efuse.efuse_type, efuse.name
62                      )
63                  )
64              return new_value
65          efuse = self.efuses[self.name]
66          new_value = efuse.check_format(new_value_str)
67          return check_arg_value(efuse, new_value)
68  class EfuseProtectBase(object):
69      def get_read_disable_mask(self, blk_part=None):
70          mask = 0
71          if isinstance(self.read_disable_bit, list):
72              if blk_part is None:
73                  for i in self.read_disable_bit:
74                      mask |= 1 << i
75              else:
76                  mask |= 1 << self.read_disable_bit[blk_part]
77          else:
78              mask = 1 << self.read_disable_bit
79          return mask
80      def get_count_read_disable_bits(self):
81          return bin(self.get_read_disable_mask()).count("1")
82      def is_readable(self, blk_part=None):
83          num_bit = self.read_disable_bit
84          if num_bit is None:
85              return True  # read cannot be disabled
86          return (self.parent["RD_DIS"].get() & self.get_read_disable_mask(blk_part)) == 0
87      def disable_read(self):
88          num_bit = self.read_disable_bit
89          if num_bit is None:
90              raise esptool.FatalError("This efuse cannot be read-disabled")
91          if not self.parent["RD_DIS"].is_writeable():
92              raise esptool.FatalError(
93                  "This efuse cannot be read-disabled due the to RD_DIS field is "
94                  "already write-disabled"
95              )
96          self.parent["RD_DIS"].save(self.get_read_disable_mask())
97      def is_writeable(self):
98          num_bit = self.write_disable_bit
99          if num_bit is None:
100              return True  # write cannot be disabled
101          return (self.parent["WR_DIS"].get() & (1 << num_bit)) == 0
102      def disable_write(self):
103          num_bit = self.write_disable_bit
104          if not self.parent["WR_DIS"].is_writeable():
105              raise esptool.FatalError(
106                  "This efuse cannot be write-disabled due to the WR_DIS field is "
107                  "already write-disabled"
108              )
109          self.parent["WR_DIS"].save(1 << num_bit)
110      def check_wr_rd_protect(self):
111          if not self.is_readable():
112              error_msg = "\t{} is read-protected.".format(self.name)
113              "The written value can not be read, the efuse/block looks as all 0.\n"
114              error_msg += "\tBurn in this case may damage an already written value."
115              self.parent.print_error_msg(error_msg)
116          if not self.is_writeable():
117              error_msg = "\t{} is write-protected. Burn is not possible.".format(
118                  self.name
119              )
120              self.parent.print_error_msg(error_msg)
121  class EfuseBlockBase(EfuseProtectBase):
122      def __init__(self, parent, param, skip_read=False):
123          self.parent = parent
124          self.name = param.name
125          self.alias = param.alias
126          self.id = param.id
127          self.rd_addr = param.rd_addr
<span onclick='openModal()' class='match'>128          self.wr_addr = param.wr_addr
129          self.write_disable_bit = param.write_disable_bit
130          self.read_disable_bit = param.read_disable_bit
</span>131          self.len = param.len
132          self.key_purpose_name = param.key_purpose
133          bit_block_len = self.get_block_len() * 8
134          self.bitarray = BitStream(bit_block_len)
135          self.bitarray.set(0)
136          self.wr_bitarray = BitStream(bit_block_len)
137          self.wr_bitarray.set(0)
138          self.fail = False
139          self.num_errors = 0
140          if self.id == 0:
141              self.err_bitarray = BitStream(bit_block_len)
142              self.err_bitarray.set(0)
143          else:
144              self.err_bitarray = None
145          if not skip_read:
146              self.read()
147      def get_block_len(self):
148          coding_scheme = self.get_coding_scheme()
149          if coding_scheme == self.parent.REGS.CODING_SCHEME_NONE:
150              return self.len * 4
151          elif coding_scheme == self.parent.REGS.CODING_SCHEME_34:
152              return (self.len * 3 // 4) * 4
153          elif coding_scheme == self.parent.REGS.CODING_SCHEME_RS:
154              return self.len * 4
155          else:
156              raise esptool.FatalError(
157                  "Coding scheme (%d) not supported" % (coding_scheme)
158              )
159      def get_coding_scheme(self):
160          if self.id == 0:
161              return self.parent.REGS.CODING_SCHEME_NONE
162          else:
163              return self.parent.coding_scheme
164      def get_raw(self, from_read=True):
165          if from_read:
166              return self.bitarray.bytes
167          else:
168              return self.wr_bitarray.bytes
169      def get(self, from_read=True):
170          self.get_bitstring(from_read=from_read)
171      def get_bitstring(self, from_read=True):
172          if from_read:
173              return self.bitarray
174          else:
175              return self.wr_bitarray
176      def convert_to_bitstring(self, new_data):
177          if isinstance(new_data, BitArray):
178              return new_data
179          else:
180              return BitArray(bytes=new_data, length=len(new_data) * 8)
181      def get_words(self):
182          def get_offsets(self):
183              return [x + self.rd_addr for x in range(0, self.get_block_len(), 4)]
184          return [self.parent.read_reg(offs) for offs in get_offsets(self)]
185      def read(self):
186          words = self.get_words()
187          data = BitArray()
188          for word in reversed(words):
189              data.append("uint:32=%d" % word)
190          self.bitarray.overwrite(data, pos=0)
191          self.print_block(self.bitarray, "read_regs")
192      def print_block(self, bit_string, comment, debug=False):
193          if self.parent.debug or debug:
194              bit_string.pos = 0
195              print(
196                  "%-15s (%-16s) [%-2d] %s:"
197                  % (self.name, " ".join(self.alias)[:16], self.id, comment),
198                  " ".join(
199                      [
200                          "%08x" % word
201                          for word in bit_string.readlist(
202                              "%d*uint:32" % (bit_string.len / 32)
203                          )[::-1]
204                      ]
205                  ),
206              )
207      def check_wr_data(self):
208          wr_data = self.wr_bitarray
209          if wr_data.all(False):
210              if self.parent.debug:
211                  print("[{:02}] {:20} nothing to burn".format(self.id, self.name))
212              return False
213          if len(wr_data.bytes) != len(self.bitarray.bytes):
214              raise esptool.FatalError(
215                  "Data does not fit: the block%d size is %d bytes, data is %d bytes"
216                  % (self.id, len(self.bitarray.bytes), len(wr_data.bytes))
217              )
218          self.check_wr_rd_protect()
219          if self.get_bitstring().all(False):
220              print(
221                  "[{:02}] {:20} is empty, will burn the new value".format(
222                      self.id, self.name
223                  )
224              )
225          else:
226              if self.get_bitstring() == wr_data:
227                  print(
228                      "[{:02}] {:20} is already written the same value, "
229                      "continue with EMPTY_BLOCK".format(self.id, self.name)
230                  )
231                  wr_data.set(0)
232              else:
233                  print("[{:02}] {:20} is not empty".format(self.id, self.name))
234                  print("\t(written ):", self.get_bitstring())
235                  print("\t(to write):", wr_data)
236                  mask = self.get_bitstring() & wr_data
237                  if mask == wr_data:
238                      print(
239                          "\tAll wr_data bits are set in the written block, "
240                          "continue with EMPTY_BLOCK."
241                      )
242                      wr_data.set(0)
243                  else:
244                      coding_scheme = self.get_coding_scheme()
245                      if coding_scheme == self.parent.REGS.CODING_SCHEME_NONE:
246                          print("\t(coding scheme = NONE)")
247                      elif coding_scheme == self.parent.REGS.CODING_SCHEME_RS:
248                          print("\t(coding scheme = RS)")
249                          error_msg = (
250                              "\tBurn into %s is forbidden "
251                              "(RS coding scheme does not allow this)." % (self.name)
252                          )
253                          self.parent.print_error_msg(error_msg)
254                      elif coding_scheme == self.parent.REGS.CODING_SCHEME_34:
255                          print("\t(coding scheme = 3/4)")
256                          data_can_not_be_burn = False
257                          for i in range(0, self.get_bitstring().len, 6 * 8):
258                              rd_chunk = self.get_bitstring()[i : i + 6 * 8 :]
259                              wr_chunk = wr_data[i : i + 6 * 8 :]
260                              if rd_chunk.any(True):
261                                  if wr_chunk.any(True):
262                                      print(
263                                          "\twritten chunk [%d] and wr_chunk "
264                                          "are not empty. " % (i // (6 * 8)),
265                                          end="",
266                                      )
267                                      if rd_chunk == wr_chunk:
268                                          print(
269                                              "wr_chunk == rd_chunk. "
270                                              "Countinue with empty chunk."
271                                          )
272                                          wr_data[i : i + 6 * 8 :].set(0)
273                                      else:
274                                          print("wr_chunk != rd_chunk. Can not burn.")
275                                          print("\twritten ", rd_chunk)
276                                          print("\tto write", wr_chunk)
277                                          data_can_not_be_burn = True
278                          if data_can_not_be_burn:
279                              error_msg = (
280                                  "\tBurn into %s is forbidden "
281                                  "(3/4 coding scheme does not allow this)." % (self.name)
282                              )
283                              self.parent.print_error_msg(error_msg)
284                      else:
285                          raise esptool.FatalError(
286                              "The coding scheme ({}) is not supported".format(
287                                  coding_scheme
288                              )
289                          )
290      def save(self, new_data):
291          data = BitStream(bytes=new_data[::-1], length=len(new_data) * 8)
292          if self.parent.debug:
293              print(
294                  "\twritten : {} ->\n\tto write: {}".format(self.get_bitstring(), data)
295              )
296          self.wr_bitarray.overwrite(self.wr_bitarray | data, pos=0)
297      def burn_words(self, words):
298          for burns in range(3):
299              self.parent.efuse_controller_setup()
300              if self.parent.debug:
301                  print("Write data to BLOCK%d" % (self.id))
302              write_reg_addr = self.wr_addr
303              for word in words:
304                  if self.parent.debug:
305                      print("Addr 0x%08x, data=0x%08x" % (write_reg_addr, word))
306                  self.parent.write_reg(write_reg_addr, word)
307                  write_reg_addr += 4
308              self.parent.write_efuses(self.id)
309              for _ in range(5):
310                  self.parent.efuse_read()
311                  self.parent.get_coding_scheme_warnings(silent=True)
312                  if self.fail or self.num_errors:
313                      print(
314                          "Error in BLOCK%d, re-burn it again (#%d), to fix it. "
315                          "fail_bit=%d, num_errors=%d"
316                          % (self.id, burns, self.fail, self.num_errors)
317                      )
318                      break
319              if not self.fail and self.num_errors == 0:
320                  break
321      def burn(self):
322          if self.wr_bitarray.all(False):
323              return
324          before_burn_bitarray = self.bitarray[:]
325          assert before_burn_bitarray is not self.bitarray
326          self.print_block(self.wr_bitarray, "to_write")
327          words = self.apply_coding_scheme()
328          self.burn_words(words)
329          self.read()
330          if not self.is_readable():
331              print(
332                  "{} ({}) is read-protected. "
333                  "Read back the burn value is not possible.".format(
334                      self.name, self.alias
335                  )
336              )
337              if self.bitarray.all(False):
338                  print("Read all '0'")
339              else:
340                  raise esptool.FatalError(
341                      "The {} is read-protected but not all '0' ({})".format(
342                          self.name, self.bitarray.hex
343                      )
344                  )
345          else:
346              if self.wr_bitarray == self.bitarray:
347                  print("BURN BLOCK%-2d - OK (write block == read block)" % self.id)
348              elif (
349                  self.wr_bitarray & self.bitarray == self.wr_bitarray
350                  and self.bitarray & before_burn_bitarray == before_burn_bitarray
351              ):
352                  print("BURN BLOCK%-2d - OK (all write block bits are set)" % self.id)
353              else:
354                  self.print_block(self.wr_bitarray, "Expected")
355                  self.print_block(self.bitarray, "Real    ")
356                  if self.id != 0:
357                      raise esptool.FatalError(
358                          "Burn {} ({}) was not successful".format(self.name, self.alias)
359                      )
360          self.wr_bitarray.set(0)
361  class EspEfusesBase(object):
362      _esp = None
363      blocks = []
364      efuses = []
365      coding_scheme = None
366      force_write_always = None
367      batch_mode_cnt = 0
368      def __iter__(self):
369          return self.efuses.__iter__()
370      def get_crystal_freq(self):
371          return self._esp.get_crystal_freq()
372      def read_efuse(self, n):
373          return self._esp.read_efuse(n)
374      def read_reg(self, addr):
375          return self._esp.read_reg(addr)
376      def write_reg(self, addr, value, mask=0xFFFFFFFF, delay_us=0, delay_after_us=0):
377          return self._esp.write_reg(addr, value, mask, delay_us, delay_after_us)
378      def update_reg(self, addr, mask, new_val):
379          return self._esp.update_reg(addr, mask, new_val)
380      def efuse_controller_setup(self):
381          pass
382      def reconnect_chip(self, esp):
383          print("Re-connecting...")
384          baudrate = esp._port.baudrate
385          port = esp._port.port
386          esp._port.close()
387          return esptool.cmds.detect_chip(port, baudrate)
388      def get_index_block_by_name(self, name):
389          for block in self.blocks:
390              if block.name == name or name in block.alias:
391                  return block.id
392          return None
393      def read_blocks(self):
394          for block in self.blocks:
395              block.read()
396      def update_efuses(self):
397          for efuse in self.efuses:
398              efuse.update(self.blocks[efuse.block].bitarray)
399      def burn_all(self, check_batch_mode=False):
400          if check_batch_mode:
401              if self.batch_mode_cnt != 0:
402                  print(
403                      "\nBatch mode is enabled, "
404                      "the burn will be done at the end of the command."
405                  )
406                  return False
407          print("\nCheck all blocks for burn...")
408          print("idx, BLOCK_NAME,          Conclusion")
409          have_wr_data_for_burn = False
410          for block in self.blocks:
411              block.check_wr_data()
412              if not have_wr_data_for_burn and block.get_bitstring(from_read=False).any(
413                  True
414              ):
415                  have_wr_data_for_burn = True
416          if not have_wr_data_for_burn:
417              print("Nothing to burn, see messages above.")
418              return
419          EspEfusesBase.confirm("", self.do_not_confirm)
420          for block in reversed(self.blocks):
421              old_fail = block.fail
422              old_num_errors = block.num_errors
423              block.burn()
424              if (block.fail and old_fail != block.fail) or (
425                  block.num_errors and block.num_errors > old_num_errors
426              ):
427                  raise esptool.FatalError("Error(s) were detected in eFuses")
428          print("Reading updated efuses...")
429          self.read_coding_scheme()
430          self.read_blocks()
431          self.update_efuses()
432          return True
433      @staticmethod
434      def confirm(action, do_not_confirm):
435          print(
436              "%s%s\nThis is an irreversible operation!"
437              % (action, "" if action.endswith("\n") else ". ")
438          )
439          if not do_not_confirm:
440              print("Type 'BURN' (all capitals) to continue.")
441              sys.stdout.flush()
442              yes = input()
443              if yes != "BURN":
444                  print("Aborting.")
445                  sys.exit(0)
446      def print_error_msg(self, error_msg):
447          if self.force_write_always is not None:
448              if not self.force_write_always:
449                  error_msg += "(use '--force-write-always' option to ignore it)"
450          if self.force_write_always:
451              print(error_msg, "Skipped because '--force-write-always' option.")
452          else:
453              raise esptool.FatalError(error_msg)
454      def get_block_errors(self, block_num):
455          return self.blocks[block_num].num_errors, self.blocks[block_num].fail
456  class EfuseFieldBase(EfuseProtectBase):
457      def __init__(self, parent, param):
458          self.category = param.category
459          self.parent = parent
460          self.block = param.block
461          self.word = param.word
462          self.pos = param.pos
463          self.write_disable_bit = param.write_disable_bit
464          self.read_disable_bit = param.read_disable_bit
465          self.name = param.name
466          self.efuse_class = param.class_type
467          self.efuse_type = param.type
468          self.description = param.description
469          self.dict_value = param.dictionary
470          self.bit_len = param.bit_len
471          self.alt_names = param.alt_names
472          self.fail = False
473          self.num_errors = 0
474          self.bitarray = BitStream(self.bit_len)
475          self.bitarray.set(0)
476          self.update(self.parent.blocks[self.block].bitarray)
477      def is_field_calculated(self):
478          return self.word is None or self.pos is None
479      def check_format(self, new_value_str):
480          if new_value_str is None:
481              return new_value_str
482          else:
483              if self.efuse_type.startswith("bytes"):
484                  if new_value_str.startswith("0x"):
485                      return binascii.unhexlify(new_value_str[2:])[::-1]
486                  else:
487                      return binascii.unhexlify(new_value_str)
488              else:
489                  return new_value_str
490      def convert_to_bitstring(self, new_value):
491          if isinstance(new_value, BitArray):
492              return new_value
493          else:
494              if self.efuse_type.startswith("bytes"):
495                  return BitArray(bytes=new_value[::-1], length=len(new_value) * 8)
496              else:
497                  try:
498                      return BitArray(self.efuse_type + "={}".format(new_value))
499                  except CreationError as err:
500                      print(
501                          "New value '{}' is not suitable for {} ({})".format(
502                              new_value, self.name, self.efuse_type
503                          )
504                      )
505                      raise esptool.FatalError(err)
506      def check_new_value(self, bitarray_new_value):
507          bitarray_old_value = self.get_bitstring() | self.get_bitstring(from_read=False)
508          if bitarray_new_value.len != bitarray_old_value.len:
509              raise esptool.FatalError(
510                  "For {} efuse, the length of the new value is wrong, "
511                  "expected {} bits, was {} bits.".format(
512                      self.name, bitarray_old_value.len, bitarray_new_value.len
513                  )
514              )
515          if bitarray_new_value == bitarray_old_value:
516              error_msg = "\tThe same value for {} ".format(self.name)
517              error_msg += "is already burned. Do not change the efuse."
518              print(error_msg)
519              bitarray_new_value.set(0)
520          elif bitarray_new_value == self.get_bitstring(from_read=False):
521              error_msg = "\tThe same value for {} ".format(self.name)
522              error_msg += "is already prepared for the burn operation."
523              print(error_msg)
524              bitarray_new_value.set(0)
525          else:
526              if self.name not in ["WR_DIS", "RD_DIS"]:
527                  if bitarray_new_value | bitarray_old_value != bitarray_new_value:
528                      error_msg = "\tNew value contains some bits that cannot be cleared "
529                      error_msg += "(value will be {})".format(
530                          bitarray_old_value | bitarray_new_value
531                      )
532                      self.parent.print_error_msg(error_msg)
533              self.check_wr_rd_protect()
534      def save_to_block(self, bitarray_field):
535          block = self.parent.blocks[self.block]
536          wr_bitarray_temp = block.wr_bitarray.copy()
537          position = wr_bitarray_temp.length - (
538              self.word * 32 + self.pos + bitarray_field.len
539          )
540          wr_bitarray_temp.overwrite(bitarray_field, pos=position)
541          block.wr_bitarray |= wr_bitarray_temp
542      def save(self, new_value):
543          bitarray_field = self.convert_to_bitstring(new_value)
544          self.check_new_value(bitarray_field)
545          self.save_to_block(bitarray_field)
546      def update(self, bit_array_block):
547          if self.is_field_calculated():
548              self.bitarray.overwrite(
549                  self.convert_to_bitstring(self.check_format(self.get())), pos=0
550              )
551              return
552          field_len = self.bitarray.len
553          bit_array_block.pos = bit_array_block.length - (
554              self.word * 32 + self.pos + field_len
555          )
556          self.bitarray.overwrite(bit_array_block.read(field_len), pos=0)
557          err_bitarray = self.parent.blocks[self.block].err_bitarray
558          if err_bitarray is not None:
559              err_bitarray.pos = err_bitarray.length - (
560                  self.word * 32 + self.pos + field_len
561              )
562              self.fail = not err_bitarray.read(field_len).all(False)
563          else:
564              self.fail = self.parent.blocks[self.block].fail
565              self.num_errors = self.parent.blocks[self.block].num_errors
566      def get_raw(self, from_read=True):
567          return self.get_bitstring(from_read).read(self.efuse_type)
568      def get(self, from_read=True):
569          if self.efuse_type.startswith("bytes"):
570              return util.hexify(self.get_bitstring(from_read).bytes[::-1], " ")
571          else:
572              return self.get_raw(from_read)
573      def get_meaning(self, from_read=True):
574          if self.dict_value:
575              try:
576                  return self.dict_value[self.get_raw(from_read)]
577              except KeyError:
578                  pass
579          return self.get(from_read)
580      def get_bitstring(self, from_read=True):
581          if from_read:
582              self.bitarray.pos = 0
583              return self.bitarray
584          else:
585              field_len = self.bitarray.len
586              block = self.parent.blocks[self.block]
587              block.wr_bitarray.pos = block.wr_bitarray.length - (
588                  self.word * 32 + self.pos + field_len
589              )
590              return block.wr_bitarray.read(self.bitarray.len)
591      def burn(self, new_value):
592          self.save(new_value)
593          self.parent.burn_all()
594      def get_info(self):
595          output = f"{self.name} (BLOCK{self.block})"
596          if self.block == 0:
597              if self.fail:
598                  output += "[error]"
599          else:
600              errs, fail = self.parent.get_block_errors(self.block)
601              if errs != 0 or fail:
602                  output += "[error]"
603          if self.efuse_class == "keyblock":
604              name = self.parent.blocks[self.block].key_purpose_name
605              if name is not None:
606                  output += f"\n  Purpose: {self.parent[name].get()}\n "
607          return output
</code></pre>
        </div>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-esp32h2beta1.py</h3>
            <pre><code>1  import struct
2  from .esp32c3 import ESP32C3ROM
3  from ..util import FatalError, NotImplementedInROMError
4  class ESP32H2BETA1ROM(ESP32C3ROM):
5      CHIP_NAME = "ESP32-H2(beta1)"
6      IMAGE_CHIP_ID = 10
7      IROM_MAP_START = 0x42000000
8      IROM_MAP_END = 0x42800000
9      DROM_MAP_START = 0x3C000000
10      DROM_MAP_END = 0x3C800000
11      SPI_REG_BASE = 0x60002000
12      SPI_USR_OFFS = 0x18
13      SPI_USR1_OFFS = 0x1C
14      SPI_USR2_OFFS = 0x20
15      SPI_MOSI_DLEN_OFFS = 0x24
16      SPI_MISO_DLEN_OFFS = 0x28
17      SPI_W0_OFFS = 0x58
18      BOOTLOADER_FLASH_OFFSET = 0x0
19      CHIP_DETECT_MAGIC_VALUE = [0xCA26CC22]
20      UART_DATE_REG_ADDR = 0x60000000 + 0x7C
21      EFUSE_BASE = 0x6001A000
22      EFUSE_BLOCK1_ADDR = EFUSE_BASE + 0x044
23      MAC_EFUSE_REG = EFUSE_BASE + 0x044
24      EFUSE_RD_REG_BASE = EFUSE_BASE + 0x030  # BLOCK0 read base address
25      EFUSE_PURPOSE_KEY0_REG = EFUSE_BASE + 0x34
26      EFUSE_PURPOSE_KEY0_SHIFT = 24
27      EFUSE_PURPOSE_KEY1_REG = EFUSE_BASE + 0x34
28      EFUSE_PURPOSE_KEY1_SHIFT = 28
29      EFUSE_PURPOSE_KEY2_REG = EFUSE_BASE + 0x38
30      EFUSE_PURPOSE_KEY2_SHIFT = 0
31      EFUSE_PURPOSE_KEY3_REG = EFUSE_BASE + 0x38
32      EFUSE_PURPOSE_KEY3_SHIFT = 4
33      EFUSE_PURPOSE_KEY4_REG = EFUSE_BASE + 0x38
34      EFUSE_PURPOSE_KEY4_SHIFT = 8
35      EFUSE_PURPOSE_KEY5_REG = EFUSE_BASE + 0x38
36      EFUSE_PURPOSE_KEY5_SHIFT = 12
37      EFUSE_DIS_DOWNLOAD_MANUAL_ENCRYPT_REG = EFUSE_RD_REG_BASE
38      EFUSE_DIS_DOWNLOAD_MANUAL_ENCRYPT = 1 << 20
39      EFUSE_SPI_BOOT_CRYPT_CNT_REG = EFUSE_BASE + 0x034
40      EFUSE_SPI_BOOT_CRYPT_CNT_MASK = 0x7 << 18
41      EFUSE_SECURE_BOOT_EN_REG = EFUSE_BASE + 0x038
42      EFUSE_SECURE_BOOT_EN_MASK = 1 << 20
43      PURPOSE_VAL_XTS_AES128_KEY = 4
44      SUPPORTS_ENCRYPTED_FLASH = True
45      FLASH_ENCRYPTED_WRITE_ALIGN = 16
46      MEMORY_MAP = []
47      FLASH_FREQUENCY = {
48          "48m": 0xF,
49          "24m": 0x0,
50          "16m": 0x1,
51          "12m": 0x2,
52      }
53      def get_pkg_version(self):
54          num_word = 4
55          return (self.read_reg(self.EFUSE_BLOCK1_ADDR + (4 * num_word)) >> 0) & 0x07
56      def get_minor_chip_version(self):
57          num_word = 3
58          return (self.read_reg(self.EFUSE_BLOCK1_ADDR + (4 * num_word)) >> 18) & 0x07
59      def get_major_chip_version(self):
60          num_word = 3
61          return (self.read_reg(self.EFUSE_BLOCK1_ADDR + (4 * num_word)) >> 21) & 0x03
62      def get_chip_description(self):
63          chip_name = {
64              0: "ESP32-H2",
65          }.get(self.get_pkg_version(), "unknown ESP32-H2")
66          major_rev = self.get_major_chip_version()
67          minor_rev = self.get_minor_chip_version()
68          return f"{chip_name} (revision v{major_rev}.{minor_rev})"
69      def get_chip_features(self):
70          return ["BLE", "IEEE802.15.4"]
71      def get_crystal_freq(self):
72          return 32
73      def override_vddsdio(self, new_voltage):
74          raise NotImplementedInROMError(
75              "VDD_SDIO overrides are not supported for ESP32-H2"
76          )
77      def read_mac(self, mac_type="BASE_MAC"):
78          if mac_type != "BASE_MAC":
79              return None
80          mac0 = self.read_reg(self.MAC_EFUSE_REG)
81          mac1 = self.read_reg(self.MAC_EFUSE_REG + 4)  # only bottom 16 bits are MAC
82          bitstring = struct.pack(">II", mac1, mac0)[2:]
83          return tuple(bitstring)
84      def get_flash_crypt_config(self):
85          return None  # doesn't exist on ESP32-H2
86      def get_key_block_purpose(self, key_block):
87          if key_block < 0 or key_block > 5:
88              raise FatalError("Valid key block numbers must be in range 0-5")
89          reg, shift = [
90              (self.EFUSE_PURPOSE_KEY0_REG, self.EFUSE_PURPOSE_KEY0_SHIFT),
91              (self.EFUSE_PURPOSE_KEY1_REG, self.EFUSE_PURPOSE_KEY1_SHIFT),
92              (self.EFUSE_PURPOSE_KEY2_REG, self.EFUSE_PURPOSE_KEY2_SHIFT),
93              (self.EFUSE_PURPOSE_KEY3_REG, self.EFUSE_PURPOSE_KEY3_SHIFT),
94              (self.EFUSE_PURPOSE_KEY4_REG, self.EFUSE_PURPOSE_KEY4_SHIFT),
95              (self.EFUSE_PURPOSE_KEY5_REG, self.EFUSE_PURPOSE_KEY5_SHIFT),
96          ][key_block]
97          return (self.read_reg(reg) >> shift) & 0xF
98      def is_flash_encryption_key_valid(self):
99          purposes = [self.get_key_block_purpose(b) for b in range(6)]
100          return any(p == self.PURPOSE_VAL_XTS_AES128_KEY for p in purposes)
101      def _post_connect(self):
102          pass
103  class ESP32H2BETA1StubLoader(ESP32H2BETA1ROM):
104      FLASH_WRITE_SIZE = 0x4000  # matches MAX_WRITE_BLOCK in stub_loader.c
105      STATUS_BYTES_LENGTH = 2  # same as ESP8266, different to ESP32 ROM
106      IS_STUB = True
107      def __init__(self, rom_loader):
108          self.secure_download_mode = rom_loader.secure_download_mode
109          self._port = rom_loader._port
<span onclick='openModal()' class='match'>110          self._trace_enabled = rom_loader._trace_enabled
111          self.cache = rom_loader.cache
112          self.flush_input()  # resets _slip_reader
</span>113  ESP32H2BETA1ROM.STUB_CLASS = ESP32H2BETA1StubLoader
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-base_fields.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-esp32h2beta1.py</div>
                </div>
                <div class="column column_space"><pre><code>128          self.wr_addr = param.wr_addr
129          self.write_disable_bit = param.write_disable_bit
130          self.read_disable_bit = param.read_disable_bit
</pre></code></div>
                <div class="column column_space"><pre><code>110          self._trace_enabled = rom_loader._trace_enabled
111          self.cache = rom_loader.cache
112          self.flush_input()  # resets _slip_reader
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    