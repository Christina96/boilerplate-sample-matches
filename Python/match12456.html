<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for boto_secgroup_1.py &amp; postgres_2.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for boto_secgroup_1.py &amp; postgres_2.py
      </h3>
<h1 align="center">
        13.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>boto_secgroup_1.py (28.253614%)<th>postgres_2.py (8.859435%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(564-592)<td><a href="#" name="0">(1455-1481)</a><td align="center"><font color="#ff0000">23</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(513-538)<td><a href="#" name="1">(1614-1639)</a><td align="center"><font color="#e80000">21</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(649-679)<td><a href="#" name="2">(1329-1350)</a><td align="center"><font color="#d20000">19</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(89-113)<td><a href="#" name="3">(383-389)</a><td align="center"><font color="#d20000">19</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(789-842)<td><a href="#" name="4">(1810-1840)</a><td align="center"><font color="#bc0000">17</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(419-443)<td><a href="#" name="5">(945-979)</a><td align="center"><font color="#bc0000">17</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(272-303)<td><a href="#" name="6">(1063-1093)</a><td align="center"><font color="#bc0000">17</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(358-371)<td><a href="#" name="7">(3651-3666)</a><td align="center"><font color="#b10000">16</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(868-916)<td><a href="#" name="8">(1957-1972)</a><td align="center"><font color="#a60000">15</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(342-357)<td><a href="#" name="9">(529-555)</a><td align="center"><font color="#a60000">15</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(469-491)<td><a href="#" name="10">(299-316)</a><td align="center"><font color="#9b0000">14</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(156-169)<td><a href="#" name="11">(3162-3179)</a><td align="center"><font color="#900000">13</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(735-746)<td><a href="#" name="12">(2406-2413)</a><td align="center"><font color="#850000">12</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(679-688)<td><a href="#" name="13">(271-293)</a><td align="center"><font color="#850000">12</font>
<tr onclick='openModal("#842dce")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#842dce"><font color="#842dce">-</font><td><a href="#" name="14">(445-455)<td><a href="#" name="14">(810-831)</a><td align="center"><font color="#850000">12</font>
<tr onclick='openModal("#f52887")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f52887"><font color="#f52887">-</font><td><a href="#" name="15">(121-128)<td><a href="#" name="15">(912-936)</a><td align="center"><font color="#850000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_secgroup_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import salt.utils.odict as odict
3 import salt.utils.versions
4 from salt.exceptions import CommandExecutionError, SaltInvocationError
5 log = logging.getLogger(__name__)
6 try:
7     import boto
8     import boto.ec2
9     logging.getLogger("boto").setLevel(logging.CRITICAL)
10     HAS_BOTO = True
11 except ImportError:
12     HAS_BOTO = False
13 def __virtual__():
14     has_boto_reqs = salt.utils.versions.check_boto_reqs(
15         boto_ver="2.4.0", check_boto3=False
16     )
17     if has_boto_reqs is True:
18         __utils__["boto.assign_funcs"](__name__, "ec2", pack=__salt__)
19     return has_boto_reqs
20 <a name="3"></a>def exists(
21     name=None,
22     region=None,
23     key<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None,
24     keyid=None,
25     profile=None,
26     vpc_id=None,
27     vpc_name=None,
28     group_id=None,
29 ):
30     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
31     group = _get_group(
32         conn,
33         name=name,
34         vpc_id=vpc_id,
35         vpc_name=vpc_name,
36         group_id=group_id,
37         region=</b></font>region,
38         key=key,
39         keyid=keyid,
40         profile=profile,
41     )
42 <a name="15"></a>    if group:
43         return True
44     else:
45         re<font color="#f52887"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>turn False
46 def _vpc_name_to_id(
47     vpc_id=None, vpc_name=None, region=None, key=None, keyid=None, profile=None
48 ):
49     data = __salt__["boto_vpc.get_id"](
50         name=</b></font>vpc_name, region=region, key=key, keyid=keyid, profile=profile
51     )
52     return data.get("id")
53 def _split_rules(rules):
54     split = []
55     for rule in rules:
56         ip_protocol = rule.get("ip_protocol")
57         to_port = rule.get("to_port")
58         from_port = rule.get("from_port")
59         grants = rule.get("grants")
60         for grant in grants:
61             _rule = {
62                 "ip_protocol": ip_protocol,
63                 "to_port": to_port,
64                 "from_port": from_port,
65 <a name="11"></a>            }
66             for key, val in grant.items():
67                 _rule[key] = val
68             split.append(_<font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>rule)
69     return split
70 def _get_group(
71     conn=None,
72     name=None,
73     vpc_id=None,
74     vpc_name=None,
75     group_id=None,
76     region=None,
77     key=None,
78     keyid=None,
79     profile=</b></font>None,
80 ):  # pylint: disable=W0613
81     if vpc_name and vpc_id:
82         raise SaltInvocationError(
83             "The params 'vpc_id' and 'vpc_name' are mutually exclusive."
84         )
85     if vpc_name:
86         try:
87             vpc_id = _vpc_name_to_id(
88                 vpc_id=vpc_id,
89                 vpc_name=vpc_name,
90                 region=region,
91                 key=key,
92                 keyid=keyid,
93                 profile=profile,
94             )
95         except boto.exception.BotoServerError as e:
96             log.debug(e)
97             return None
98     if name:
99         if vpc_id is None:
100             log.debug("getting group for %s", name)
101             group_filter = {"group-name": name}
102             filtered_groups = conn.get_all_security_groups(filters=group_filter)
103             for group in filtered_groups:
104                 if group.vpc_id is None:
105                     return group
106             if len(filtered_groups) &gt; 1:
107                 raise CommandExecutionError(
108                     "Security group belongs to more VPCs, specify the VPC ID!"
109                 )
110             elif len(filtered_groups) == 1:
111                 return filtered_groups[0]
112             return None
113         elif vpc_id:
114             log.debug("getting group for %s in vpc_id %s", name, vpc_id)
115             group_filter = {"group-name": name, "vpc_id": vpc_id}
116             filtered_groups = conn.get_all_security_groups(filters=group_filter)
117             if len(filtered_groups) == 1:
118                 return filtered_groups[0]
119             else:
120                 return None
121         else:
122             return None
123     elif group_id:
124         try:
125             groups = conn.get_all_security_groups(group_ids=[group_id])
126         except boto.exception.BotoServerError as e:
127             log.debug(e)
128             return None
129         if len(groups) == 1:
130             return groups[0]
131         else:
132             return None
133     else:
134         return None
135 def _parse_rules(sg, rules):
136     _rules = []
137     for rule in rules:
138         log.debug("examining rule %s for group %s", rule, sg.id)
139         attrs = ["ip_protocol", "from_port", "to_port", "grants"]
140         _rule = odict.OrderedDict()
141         for attr in attrs:
142             val = getattr(rule, attr)
143             if not val:
144                 continue
145             if attr == "grants":
146                 _grants = []
147                 for grant in val:
148                     log.debug("examining grant %s for", grant)
149                     g_attrs = {
150                         "name": "source_group_name",
151                         "owner_id": "source_group_owner_id",
152                         "group_id": "source_group_group_id",
153                         "cidr_ip": "cidr_ip",
154                     }
155                     _grant = odict.OrderedDict()
156                     for g_attr, g_attr_map in g_attrs.items():
157                         g_val = getattr(grant, g_attr)
158                         if not g_val:
159                             continue
160                         _grant[g_attr_map] = g_val
161                     _grants.append(_grant)
162                 _rule["grants"] = _grants
163             elif attr == "from_port":
164                 _rule[attr] = int(val)
165             elif attr == "to_port":
166 <a name="6"></a>                _rule[attr] = int(val)
167             else:
168                 _rule[attr] = val
169         _rules.append(<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>_rule)
170     return _rules
171 def get_all_security_groups(
172     groupnames=None,
173     group_ids=None,
174     filters=None,
175     region=None,
176     key=None,
177     keyid=None,
178     profile=None,
179 ):
180     conn = _get_conn(region=region, key=key, keyid=keyid, profile=</b></font>profile)
181     if isinstance(groupnames, str):
182         groupnames = [groupnames]
183     if isinstance(group_ids, str):
184         groupnames = [group_ids]
185     interesting = [
186         "description",
187         "id",
188         "instances",
189         "name",
190         "owner_id",
191         "region",
192         "rules",
193         "rules_egress",
194         "tags",
195         "vpc_id",
196     ]
197     ret = []
198     try:
199         r = conn.get_all_security_groups(
200             groupnames=groupnames, group_ids=group_ids, filters=filters
201         )
202         for g in r:
203             n = {}
204             for a in interesting:
205                 v = getattr(g, a, None)
206                 if a == "region":
207                     v = v.name
208                 elif a in ("rules", "rules_egress"):
209                     v = _parse_rules(g, v)
210                 elif a == "instances":
211                     v = [i.id for i in v()]
212                 n[a] = v
213             ret += [n]
214 <a name="9"></a>        return ret
215     except boto.exception.BotoServerError as e:
216         log.debug(e)
217         <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return []
218 def get_group_id(
219     name, vpc_id=None, vpc_name=None, region=None, key=None, keyid=None, profile=None
220 ):
221     conn = _get_conn(region=region, key=key, keyid=keyid, profile=</b></font>profile)
222     if name.startswith<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("sg-"):
223         log.debug("group %s is a group id. get_group_id not called.", name)
224         return name
225     group = _get_group(
226         conn=conn,
227         name=name,
228         vpc_id=vpc_id,
229         vpc_name=vpc_name,
230         region=region,
231         key=key,
232         keyid=keyid,
233         profile=profile,
234     )
235     return</b></font> getattr(group, "id", None)
236 def convert_to_group_ids(
237     groups, vpc_id=None, vpc_name=None, region=None, key=None, keyid=None, profile=None
238 ):
239     log.debug("security group contents %s pre-conversion", groups)
240     group_ids = []
241     for group in groups:
242         group_id = get_group_id(
243             name=group,
244             vpc_id=vpc_id,
245             vpc_name=vpc_name,
246             region=region,
247             key=key,
248             keyid=keyid,
249             profile=profile,
250         )
251         if not group_id:
252             if __opts__["test"]:
253                 log.warn(
254                     "Security Group `%s` could not be resolved to an ID.  This may "
255                     "cause a failure when not running in test mode.",
256                     group,
257                 )
258                 return []
259             else:
260                 raise CommandExecutionError(
261                     "Could not resolve Security Group name {} to a Group ID".format(
262                         group
263                     )
264                 )
265 <a name="5"></a>        else:
266             group_ids.append(str(group_id))
267     log.debug("security group contents %s post-conversion", group_ids)
268     r<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>eturn group_ids
269 def get_config(
270     name=None,
271     group_id=None,
272     region=None,
273     key=None,
274     keyid=None,
275     profile=None,
276     vpc_id=None,
277     vpc_name=None,
278 ):
279     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
280 <a name="14"></a>
281     sg =</b></font> _get_group(
282         conn,
283         name<font color="#842dce"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=name,
284         vpc_id=vpc_id,
285         vpc_name=vpc_name,
286         group_id=group_id,
287         region=region,
288         key=key,
289         keyid=keyid,
290         profile=profile,
291     )
292     if sg:
293         ret = odict.OrderedDict(</b></font>)
294         ret["name"] = sg.name
295         ret["group_id"] = sg.id
296         ret["owner_id"] = sg.owner_id
297         ret["description"] = sg.description
298         ret["tags"] = sg.tags
299         _rules = _parse_rules(sg, sg.rules)
300         _rules_egress = _parse_rules(sg, sg.rules_egress)
301         ret["rules"] = _split_rules(_rules)
302 <a name="10"></a>        ret["rules_egress"] = _split_rules(_rules_egress)
303         return ret
304     else:
305         re<font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>turn None
306 def create(
307     name,
308     description,
309     vpc_id=None,
310     vpc_name=None,
311     region=None,
312     key=None,
313     keyid=None,
314     profile=None,
315 ):
316     conn = _get_conn(region=region, key=key, keyid=keyid, profile=</b></font>profile)
317     if not vpc_id and vpc_name:
318         try:
319             vpc_id = _vpc_name_to_id(
320                 vpc_id=vpc_id,
321                 vpc_name=vpc_name,
322                 region=region,
323                 key=key,
324                 keyid=keyid,
325                 profile=profile,
326             )
327         except boto.exception.BotoServerError as e:
328             log.debug(e)
329             return False
330     created = conn.create_security_group(name, description, vpc_id)
331     if created:
332         log.info("Created security group %s.", name)
333 <a name="1"></a>        return True
334     else:
335         msg = "Failed to create security group {}.".format(name)
336         log<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.error(msg)
337         return False
338 def delete(
339     name=None,
340     group_id=None,
341     region=None,
342     key=None,
343     keyid=None,
344     profile=None,
345     vpc_id=None,
346     vpc_name=None,
347 ):
348     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
349     group =</b></font> _get_group(
350         conn,
351         name=name,
352         vpc_id=vpc_id,
353         vpc_name=vpc_name,
354         group_id=group_id,
355         region=region,
356         key=key,
357         keyid=keyid,
358         profile=profile,
359     )
360     if group:
361         deleted = conn.delete_security_group(group_id=group.id)
362         if deleted:
363             log.info("Deleted security group %s with id %s.", group.name, group.id)
364             return True
365         else:
366             msg = "Failed to delete security group {}.".format(name)
367             log.error(msg)
368             return False
369     else:
370         log.debug("Security group not found.")
371         return False
372 <a name="0"></a>
373 def authorize(
374     name<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None,
375     source_group_name=None,
376     source_group_owner_id=None,
377     ip_protocol=None,
378     from_port=None,
379     to_port=None,
380     cidr_ip=None,
381     group_id=None,
382     source_group_group_id=None,
383     region=None,
384     key=None,
385     keyid=None,
386     profile=None,
387     vpc_id=None,
388     vpc_name=None,
389     egress=False,
390 ):
391     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
392     group =</b></font> _get_group(
393         conn,
394         name=name,
395         vpc_id=vpc_id,
396         vpc_name=vpc_name,
397         group_id=group_id,
398         region=region,
399         key=key,
400         keyid=keyid,
401         profile=profile,
402     )
403     if group:
404         try:
405             added = None
406             if not egress:
407                 added = conn.authorize_security_group(
408                     src_security_group_name=source_group_name,
409                     src_security_group_owner_id=source_group_owner_id,
410                     ip_protocol=ip_protocol,
411                     from_port=from_port,
412                     to_port=to_port,
413                     cidr_ip=cidr_ip,
414                     group_id=group.id,
415                     src_security_group_group_id=source_group_group_id,
416                 )
417             else:
418                 added = conn.authorize_security_group_egress(
419                     ip_protocol=ip_protocol,
420                     from_port=from_port,
421                     to_port=to_port,
422                     cidr_ip=cidr_ip,
423                     group_id=group.id,
424                     src_group_id=source_group_group_id,
425                 )
426             if added:
427                 log.info(
428                     "Added rule to security group %s with id %s", group.name, group.id
429                 )
430                 return True
431             else:
432                 msg = "Failed to add rule to security group {} with id {}.".format(
433                     group.name, group.id
434                 )
435                 log.error(msg)
436                 return False
437         except boto.exception.EC2ResponseError as e:
438             if e.error_code == "InvalidPermission.Duplicate":
439                 return True
440             msg = "Failed to add rule to security group {} with id {}.".format(
441                 group.name, group.id
442             )
443             log.error(msg)
444             log.error(e)
445 <a name="2"></a>            return False
446     else:
447         log.error("Failed to add rule to security group.")
448         re<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>turn False
449 def revoke(
450     name=None,
451     source_group_name=None,
452     source_group_owner_id=None,
453     ip_protocol=None,
454     from_port=None,
455     to_port=None,
456     cidr_ip=None,
457     group_id=None,
458     source_group_group_id=None,
459     region=None,
460     key=None,
461     keyid=None,
462     profile=None,
463     vpc_id=None,
464     vpc_name=None,
465     egress=False,
466 ):
467     conn =</b></font> _get_conn(region<font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=region, key=key, keyid=keyid, profile=profile)
468     group = _get_group(
469         conn,
470         name=name,
471         vpc_id=vpc_id,
472         vpc_name=vpc_name,
473         group_id=group_id,
474         region=region,
475         key=</b></font>key,
476         keyid=keyid,
477         profile=profile,
478     )
479     if group:
480         try:
481             revoked = None
482             if not egress:
483                 revoked = conn.revoke_security_group(
484                     src_security_group_name=source_group_name,
485                     src_security_group_owner_id=source_group_owner_id,
486                     ip_protocol=ip_protocol,
487                     from_port=from_port,
488                     to_port=to_port,
489                     cidr_ip=cidr_ip,
490                     group_id=group.id,
491                     src_security_group_group_id=source_group_group_id,
492                 )
493             else:
494                 revoked = conn.revoke_security_group_egress(
495                     ip_protocol=ip_protocol,
496                     from_port=from_port,
497                     to_port=to_port,
498                     cidr_ip=cidr_ip,
499                     group_id=group.id,
500                     src_group_id=source_group_group_id,
501                 )
502             if revoked:
503                 log.info(
504                     "Removed rule from security group %s with id %s.",
505                     group.name,
506                     group.id,
507                 )
508                 return True
509             else:
510                 msg = "Failed to remove rule from security group {} with id {}.".format(
511                     group.name, group.id
512                 )
513                 log.error(msg)
514                 return False
515         except boto.exception.EC2ResponseError as e:
516             msg = "Failed to remove rule from security group {} with id {}.".format(
517                 group.name, group.id
518 <a name="12"></a>            )
519             log.error(msg)
520             log.error(e)
521             <font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return False
522     else:
523         log.error("Failed to remove rule from security group.")
524         return False
525 def _find_vpcs(
526     vpc_id=None,
527     vpc_name=None,
528     cidr=None,
529     tags=None,
530     region=</b></font>None,
531     key=None,
532     keyid=None,
533     profile=None,
534 ):
535     if all((vpc_id, vpc_name)):
536         raise SaltInvocationError("Only one of vpc_name or vpc_id may be provided.")
537     if not any((vpc_id, vpc_name, tags, cidr)):
538         raise SaltInvocationError(
539             "At least one of the following must be "
540             "provided: vpc_id, vpc_name, cidr or tags."
541         )
542     local_get_conn = __utils__["boto.get_connection_func"]("vpc")
543     conn = local_get_conn(region=region, key=key, keyid=keyid, profile=profile)
544     filter_parameters = {"filters": {}}
545     if vpc_id:
546         filter_parameters["vpc_ids"] = [vpc_id]
547     if cidr:
548         filter_parameters["filters"]["cidr"] = cidr
549     if vpc_name:
550         filter_parameters["filters"]["tag:Name"] = vpc_name
551     if tags:
552         for tag_name, tag_value in tags.items():
553             filter_parameters["filters"]["tag:{}".format(tag_name)] = tag_value
554     vpcs = conn.get_all_vpcs(**filter_parameters)
555     log.debug(
556         "The filters criteria %s matched the following VPCs:%s", filter_parameters, vpcs
557     )
558 <a name="4"></a>    if vpcs:
559         return [vpc.id for vpc in vpcs]
560     else:
561         re<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>turn []
562 def set_tags(
563     tags,
564     name=None,
565     group_id=None,
566     vpc_name=None,
567     vpc_id=None,
568     region=None,
569     key=None,
570     keyid=None,
571     profile=None,
572 ):
573     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
574     secgrp =</b></font> _get_group(
575         conn,
576         name=name,
577         vpc_id=vpc_id,
578         vpc_name=vpc_name,
579         group_id=group_id,
580         region=region,
581         key=key,
582         keyid=keyid,
583         profile=profile,
584     )
585     if secgrp:
586         if isinstance(tags, dict):
587             secgrp.add_tags(tags)
588         else:
589             msg = "Tags must be a dict of tagname:tagvalue"
590             raise SaltInvocationError(msg)
591     else:
592         msg = "The security group could not be found"
593         raise SaltInvocationError(msg)
594     return True
595 <a name="8"></a>
596 def delete_tags(
597     tags,
598     name<font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None,
599     group_id=None,
600     vpc_name=None,
601     vpc_id=None,
602     region=None,
603     key=None,
604     keyid=None,
605     profile=None,
606 ):
607     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
608     secgrp =</b></font> _get_group(
609         conn,
610         name=name,
611         vpc_id=vpc_id,
612         vpc_name=vpc_name,
613         group_id=group_id,
614         region=region,
615         key=key,
616         keyid=keyid,
617         profile=profile,
618     )
619     if secgrp:
620         if isinstance(tags, list):
621             tags_to_remove = {}
622             for tag in tags:
623                 tags_to_remove[tag] = None
624             secgrp.remove_tags(tags_to_remove)
625         else:
626             msg = "Tags must be a list of tagnames to remove from the security group"
627             raise SaltInvocationError(msg)
628     else:
629         msg = "The security group could not be found"
630         raise SaltInvocationError(msg)
631     return True
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>postgres_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import base64
2 import datetime
3 import hashlib
4 import hmac
5 import io
6 import logging
7 import os
8 import pipes
9 import re
10 import tempfile
11 import salt.utils.files
12 import salt.utils.itertools
13 import salt.utils.odict
14 import salt.utils.path
15 import salt.utils.stringutils
16 from salt.exceptions import CommandExecutionError, SaltInvocationError
17 from salt.ext.saslprep import saslprep
18 from salt.utils.versions import LooseVersion as _LooseVersion
19 try:
20     import csv
21     HAS_CSV = True
22 except ImportError:
23     HAS_CSV = False
24 try:
25     from secrets import token_bytes
26 except ImportError:
27     from os import urandom as token_bytes
28 log = logging.getLogger(__name__)
29 _DEFAULT_PASSWORDS_ENCRYPTION = "md5"
30 _EXTENSION_NOT_INSTALLED = "EXTENSION NOT INSTALLED"
31 _EXTENSION_INSTALLED = "EXTENSION INSTALLED"
32 _EXTENSION_TO_UPGRADE = "EXTENSION TO UPGRADE"
33 _EXTENSION_TO_MOVE = "EXTENSION TO MOVE"
34 _EXTENSION_FLAGS = (
35     _EXTENSION_NOT_INSTALLED,
36     _EXTENSION_INSTALLED,
37     _EXTENSION_TO_UPGRADE,
38     _EXTENSION_TO_MOVE,
39 )
40 _PRIVILEGES_MAP = {
41     "a": "INSERT",
42     "C": "CREATE",
43     "D": "TRUNCATE",
44     "c": "CONNECT",
45     "t": "TRIGGER",
46     "r": "SELECT",
47     "U": "USAGE",
48     "T": "TEMPORARY",
49     "w": "UPDATE",
50     "X": "EXECUTE",
51     "x": "REFERENCES",
52     "d": "DELETE",
53     "*": "GRANT",
54 }
55 _PRIVILEGES_OBJECTS = frozenset(
56     (
57         "schema",
58         "tablespace",
59         "language",
60         "sequence",
61         "table",
62         "group",
63         "database",
64         "function",
65     )
66 )
67 _PRIVILEGE_TYPE_MAP = {
68     "table": "arwdDxt",
69     "tablespace": "C",
70     "language": "U",
71     "sequence": "rwU",
72     "schema": "UC",
73     "database": "CTc",
74     "function": "X",
75 }
76 def __virtual__():
77     utils = ["psql"]
78     if not HAS_CSV:
79         return False
80     for util in utils:
81         if not salt.utils.path.which(util):
82             if not _find_pg_binary(util):
83                 return (False, "{} was not found".format(util))
84     return True
85 def _find_pg_binary(util):
86     pg_bin_dir = __salt__["config.option"]("postgres.bins_dir")
87     util_bin = salt.utils.path.which(util)
88     if not util_bin:
89         if pg_bin_dir:
90             return salt.utils.path.which(os.path.join(pg_bin_dir, util))
91     else:
92         return util_bin
93 def _run_psql(cmd, runas=None, password=None, host=None, port=None, user=None):
94     kwargs = {
95         "reset_system_locale": False,
96         "clean_env": True,
97     }
98     if runas is None:
99         if not host:
100             host = __salt__["config.option"]("postgres.host")
101         if not host or host.startswith("/"):
102             if "FreeBSD" in __grains__["os_family"]:
103                 runas = "postgres"
104             elif "OpenBSD" in __grains__["os_family"]:
105                 runas = "_postgresql"
106             else:
107                 runas = "postgres"
108     if user is None:
109         user = runas
110     if runas:
111         kwargs["runas"] = runas
112     if password is None:
113         password = __salt__["config.option"]("postgres.pass")
114     if password is not None:
115         pgpassfile = salt.utils.files.mkstemp(text=True)
116         with salt.utils.files.fopen(pgpassfile, "w") as fp_:
117             fp_.write(
118                 salt.utils.stringutils.to_str(
119                     "{}:{}:*:{}:{}".format(
120                         "localhost" if not host or host.startswith("/") else host,
121                         port if port else "*",
122                         user if user else "*",
123                         password,
124                     )
125                 )
126             )
127             __salt__["file.chown"](pgpassfile, runas, "")
128             kwargs["env"] = {"PGPASSFILE": pgpassfile}
129     ret = __salt__["cmd.run_all"](cmd, python_shell=False, **kwargs)
130     if ret.get("retcode", 0) != 0:
131         log.error("Error connecting to Postgresql server")
132     if password is not None and not __salt__["file.remove"](pgpassfile):
133         log.warning("Remove PGPASSFILE failed")
134     return ret
135 def _run_initdb(
136     name,
137     auth="password",
138     user=None,
139     password=None,
140     encoding="UTF8",
141     locale=None,
142     runas=None,
143     waldir=None,
144     checksums=False,
145 ):
146     if runas is None:
147         if "FreeBSD" in __grains__["os_family"]:
148             runas = "postgres"
149         elif "OpenBSD" in __grains__["os_family"]:
150             runas = "_postgresql"
151         else:
152             runas = "postgres"
153     if user is None:
154         user = runas
155     _INITDB_BIN = _find_pg_binary("initdb")
156     if not _INITDB_BIN:
157         raise CommandExecutionError("initdb executable not found.")
158     cmd = [
159         _INITDB_BIN,
160         "--pgdata={}".format(name),
161         "--username={}".format(user),
162         "--auth={}".format(auth),
163         "--encoding={}".format(encoding),
164     ]
165     if locale is not None:
166         cmd.append("--locale={}".format(locale))
167     if waldir is not None:
168         cmd.append("-X")
169         cmd.append(waldir)
170     if checksums:
171         cmd.append("--data-checksums")
172     if password is not None:
173         pgpassfile = salt.utils.files.mkstemp(text=True)
174         with salt.utils.files.fopen(pgpassfile, "w") as fp_:
175             fp_.write(salt.utils.stringutils.to_str("{}".format(password)))
176             __salt__["file.chown"](pgpassfile, runas, "")
177         cmd.extend(["--pwfile={}".format(pgpassfile)])
178     kwargs = dict(runas=runas, clean_env=True)
179     cmdstr = " ".join([pipes.quote(c) for c in cmd])
180     ret = __salt__["cmd.run_all"](cmdstr, python_shell=False, **kwargs)
181     if ret.get("retcode", 0) != 0:
182         log.error("Error initilizing the postgres data directory")
183     if password is not None and not __salt__["file.remove"](pgpassfile):
184         log.warning("Removal of PGPASSFILE failed")
185     return ret
186 <a name="13"></a>
187 def version(
188     user=None, host=None, port=None, maintenance_db<font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None, password=None, runas=None
189 ):
190     query = "SELECT setting FROM pg_catalog.pg_settings WHERE name = 'server_version'"
191     cmd = _psql_cmd(
192         "-c",
193         query,
194         "-t",
195         host=host,
196         user=user,
197         port=port,
198         maintenance_db=maintenance_db,
199         password=password,
200     )
201     ret =</b></font> _run_psql(
202         cmd, runas=runas, password=password, host=host, port=port, user=user
203     )
204 <a name="10"></a>
205     for line in salt.utils.itertools.split(ret["stdout"], "\n"):
206         re<font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>turn line
207 def _parsed_version(
208     user=None, host=None, port=None, maintenance_db=None, password=None, runas=None
209 ):
210     psql_version = version(
211         user,
212         host=host,
213         port=port,
214         maintenance_db=maintenance_db,
215         password=</b></font>password,
216         runas=runas,
217     )
218     if psql_version:
219         return _LooseVersion(psql_version)
220     else:
221         log.warning(
222             "Attempt to parse version of Postgres server failed. "
223             "Is the server responding?"
224         )
225         return None
226 def _connection_defaults(user=None, host=None, port=None, maintenance_db=None):
227     if not user:
228         user = __salt__["config.option"]("postgres.user")
229     if not host:
230         host = __salt__["config.option"]("postgres.host")
231     if not port:
232         port = __salt__["config.option"]("postgres.port")
233     if not maintenance_db:
234         maintenance_db = __salt__["config.option"]("postgres.maintenance_db")
235     return (user, host, port, maintenance_db)
236 def _psql_cmd(*args, **kwargs):
237     (user, host, port, maintenance_db) = _connection_defaults(
238         kwargs.get("user"),
239         kwargs.get("host"),
240         kwargs.get("port"),
241         kwargs.get("maintenance_db"),
242     )
243     _PSQL_BIN = _find_pg_binary("psql")
244     cmd = [
245         _PSQL_BIN,
246         "--no-align",
247         "--no-readline",
248         "--no-psqlrc",
249         "--no-password",
250     ]  # Never prompt, handled in _run_psql.
251     if user:
252         cmd += ["--username", user]
253     if host:
254         cmd += ["--host", host]
255     if port:
256         cmd += ["--port", str(port)]
257     if not maintenance_db:
258         maintenance_db = "postgres"
259     cmd.extend(["--dbname", maintenance_db])
260     cmd.extend(args)
261     return cmd
262 <a name="3"></a>
263 def _psql_prepare_and_run(
264     cmd, host<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None, port=None, maintenance_db=None, password=None, runas=None, user=None
265 ):
266     rcmd = _psql_cmd(
267         host=host, user=user, port=port, maintenance_db=maintenance_db, *cmd
268     )
269     cmdret = _run_psql(
270         rcmd, runas=runas, password=password, host=host, port=port, user=</b></font>user
271     )
272     return cmdret
273 def psql_query(
274     query,
275     user=None,
276     host=None,
277     port=None,
278     maintenance_db=None,
279     password=None,
280     runas=None,
281     write=False,
282 ):
283     ret = []
284     csv_query = "COPY ({}) TO STDOUT WITH CSV HEADER".format(query.strip().rstrip(";"))
285     if write:
286         csv_query = "START TRANSACTION READ WRITE; {}; COMMIT TRANSACTION;".format(
287             csv_query
288         )
289     cmdret = _psql_prepare_and_run(
290         ["-v", "datestyle=ISO,MDY", "-c", csv_query],
291         runas=runas,
292         host=host,
293         user=user,
294         port=port,
295         maintenance_db=maintenance_db,
296         password=password,
297     )
298     if cmdret["retcode"] &gt; 0:
299         return ret
300     csv_file = io.StringIO(cmdret["stdout"])
301     header = {}
302     for row in csv.reader(
303         csv_file,
304         delimiter=salt.utils.stringutils.to_str(","),
305         quotechar=salt.utils.stringutils.to_str('"'),
306     ):
307         if not row:
308             continue
309         if not header:
310             header = row
311             continue
312         ret.append(dict(zip(header, row)))
313     if write:
314         ret = ret[0:-1]
315     return ret
316 def db_list(
317     user=None, host=None, port=None, maintenance_db=None, password=None, runas=None
318 ):
319     ret = {}
320     query = (
321         'SELECT datname as "Name", pga.rolname as "Owner", '
322         'pg_encoding_to_char(encoding) as "Encoding", '
323         'datcollate as "Collate", datctype as "Ctype", '
324         'datacl as "Access privileges", spcname as "Tablespace" '
325         "FROM pg_database pgd, pg_roles pga, pg_tablespace pgts "
326         "WHERE pga.oid = pgd.datdba AND pgts.oid = pgd.dattablespace"
327     )
328     rows = psql_query(
329         query,
330         runas=runas,
331         host=host,
332         user=user,
333         port=port,
334         maintenance_db=maintenance_db,
335         password=password,
336     )
337     for row in rows:
338 <a name="9"></a>        ret[row["Name"]] = row
339         ret[row["Name"]].pop("Name")
340     <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return ret
341 def db_exists(
342     name,
343     user=None,
344     host=None,
345     port=None,
346     maintenance_db=None,
347     password=None,
348     runas=None,
349 ):
350     databases = db_list(
351         user=user,
352         host=host,
353         port=port,
354         maintenance_db=</b></font>maintenance_db,
355         password=password,
356         runas=runas,
357     )
358     return name in databases
359 def _quote_ddl_value(value, quote="'"):
360     if value is None:
361         return None
362     if quote in value:  # detect trivial sqli
363         raise SaltInvocationError(
364             "Unsupported character {} in value: {}".format(quote, value)
365         )
366     return "{quote}{value}{quote}".format(quote=quote, value=value)
367 def db_create(
368     name,
369     user=None,
370     host=None,
371     port=None,
372     maintenance_db=None,
373     password=None,
374     tablespace=None,
375     encoding=None,
376     lc_collate=None,
377     lc_ctype=None,
378     owner=None,
379     template=None,
380     runas=None,
381 ):
382     query = 'CREATE DATABASE "{}"'.format(name)
383     with_args = salt.utils.odict.OrderedDict(
384         [
385             ("TABLESPACE", _quote_ddl_value(tablespace, '"')),
386             ("OWNER", _quote_ddl_value(owner, '"')),
387             ("TEMPLATE", template),
388             ("ENCODING", _quote_ddl_value(encoding)),
389             ("LC_COLLATE", _quote_ddl_value(lc_collate)),
390             ("LC_CTYPE", _quote_ddl_value(lc_ctype)),
391         ]
392     )
393     with_chunks = []
394     for key, value in with_args.items():
395         if value is not None:
396             with_chunks += [key, "=", value]
397     if with_chunks:
398         with_chunks.insert(0, " WITH")
399         query += " ".join(with_chunks)
400     ret = _psql_prepare_and_run(
401         ["-c", query],
402         user=user,
403         host=host,
404         port=port,
405         maintenance_db=maintenance_db,
406         password=password,
407         runas=runas,
408     )
409     return ret["retcode"] == 0
410 def db_alter(
411     name,
412     user=None,
413     host=None,
414     port=None,
415     maintenance_db=None,
416     password=None,
417     tablespace=None,
418     owner=None,
419     owner_recurse=False,
420     runas=None,
421 ):
422     if not any((tablespace, owner)):
423         return True  # Nothing todo?
424     if owner and owner_recurse:
425         ret = owner_to(
426             name, owner, user=user, host=host, port=port, password=password, runas=runas
427         )
428     else:
429         queries = []
430         if owner:
431             queries.append('ALTER DATABASE "{}" OWNER TO "{}"'.format(name, owner))
432         if tablespace:
433             queries.append(
434                 'ALTER DATABASE "{}" SET TABLESPACE "{}"'.format(name, tablespace)
435             )
436         for query in queries:
437             ret = _psql_prepare_and_run(
438                 ["-c", query],
439                 user=user,
440                 host=host,
441                 port=port,
442                 maintenance_db=maintenance_db,
443                 password=password,
444                 runas=runas,
445             )
446     if ret["retcode"] != 0:
447         return False
448     return True
449 def db_remove(
450     name,
451     user=None,
452     host=None,
453     port=None,
454     maintenance_db=None,
455     password=None,
456     runas=None,
457 ):
458     for query in [
459         'REVOKE CONNECT ON DATABASE "{db}" FROM public;'.format(db=name),
460         "SELECT pid, pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname ="
461         " '{db}' AND pid &lt;&gt; pg_backend_pid();".format(db=name),
462         'DROP DATABASE "{db}";'.format(db=name),
463     ]:
464         ret = _psql_prepare_and_run(
465             ["-c", query],
466             user=user,
467             host=host,
468             port=port,
469             runas=runas,
470             maintenance_db=maintenance_db,
471             password=password,
472         )
473         if ret["retcode"] != 0:
474             raise Exception("Failed: ret={}".format(ret))
475     return True
476 def tablespace_list(
477     user=None, host=None, port=None, maintenance_db=None, password=None, runas=None
478 ):
479     ret = {}
480     query = (
481         'SELECT spcname as "Name", pga.rolname as "Owner", spcacl as "ACL", '
482         'spcoptions as "Opts", pg_tablespace_location(pgts.oid) as "Location" '
483         "FROM pg_tablespace pgts, pg_roles pga WHERE pga.oid = pgts.spcowner"
484     )
485     rows = __salt__["postgres.psql_query"](
486         query,
487         runas=runas,
488         host=host,
489         user=user,
490         port=port,
491         maintenance_db=maintenance_db,
492         password=password,
493     )
494     for row in rows:
495         ret[row["Name"]] = row
496         ret[row["Name"]].pop("Name")
497     return ret
498 def tablespace_exists(
499     name,
500     user=None,
501     host=None,
502     port=None,
503     maintenance_db=None,
504     password=None,
505     runas=None,
506 ):
507     tablespaces = tablespace_list(
508         user=user,
509         host=host,
510         port=port,
511         maintenance_db=maintenance_db,
512         password=password,
513         runas=runas,
514     )
515     return name in tablespaces
516 def tablespace_create(
517     name,
518 <a name="14"></a>    location,
519     options=None,
520     owner=None,
521     user<font color="#842dce"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None,
522     host=None,
523     port=None,
524     maintenance_db=None,
525     password=None,
526     runas=None,
527 ):
528     owner_query = ""
529     options_query = ""
530     if owner:
531         owner_query = 'OWNER "{}"'.format(</b></font>owner)
532     if options:
533         optionstext = ["{} = {}".format(k, v) for k, v in options.items()]
534         options_query = "WITH ( {} )".format(", ".join(optionstext))
535     query = "CREATE TABLESPACE \"{}\" {} LOCATION '{}' {}".format(
536         name, owner_query, location, options_query
537     )
538     ret = _psql_prepare_and_run(
539         ["-c", query],
540         user=user,
541         host=host,
542         port=port,
543         maintenance_db=maintenance_db,
544         password=password,
545         runas=runas,
546     )
547     return ret["retcode"] == 0
548 def tablespace_alter(
549     name,
550     user=None,
551     host=None,
552     port=None,
553     maintenance_db=None,
554     password=None,
555     new_name=None,
556     new_owner=None,
557     set_option=None,
558     reset_option=None,
559     runas=None,
560 ):
561     if not any([new_name, new_owner, set_option, reset_option]):
562         return True  # Nothing todo?
563     queries = []
564     if new_name:
565         queries.append('ALTER TABLESPACE "{}" RENAME TO "{}"'.format(name, new_name))
566     if new_owner:
567         queries.append('ALTER TABLESPACE "{}" OWNER TO "{}"'.format(name, new_owner))
568     if set_option:
569         queries.append(
570             'ALTER TABLESPACE "{}" SET ({} = {})'.format(
571                 name, *(next(iter(set_option.items())))
572             )
573         )
574     if reset_option:
575         queries.append('ALTER TABLESPACE "{}" RESET ({})'.format(name, reset_option))
576     for query in queries:
577         ret = _psql_prepare_and_run(
578             ["-c", query],
579             user=user,
580             host=host,
581             port=port,
582             maintenance_db=maintenance_db,
583             password=password,
584             runas=runas,
585         )
586 <a name="15"></a>        if ret["retcode"] != 0:
587             return False
588     r<font color="#f52887"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>eturn True
589 def tablespace_remove(
590     name,
591     user=None,
592     host=None,
593     port=None,
594     maintenance_db=None,
595     password=None,
596     runas=None,
597 ):
598     query = 'DROP TABLESPACE "{}"'.format(name)
599     ret =</b></font> _psql_prepare_and_run(
600         ["-c", query],
601         user=user,
602         host=host,
603         port=port,
604         runas=runas,
605 <a name="5"></a>        maintenance_db=maintenance_db,
606         password=password,
607     )
608     return ret[<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"retcode"] == 0
609 def user_list(
610     user=None,
611     host=None,
612     port=None,
613     maintenance_db=None,
614     password=None,
615     runas=None,
616     return_password=False,
617 ):
618     ret = {}
619     ver = _parsed_version(
620         user=user,
621         host=host,
622         port=port,
623         maintenance_db=maintenance_db,
624         password=</b></font>password,
625         runas=runas,
626     )
627     if ver:
628         if ver &gt;= _LooseVersion("9.1"):
629             replication_column = "pg_roles.rolreplication"
630         else:
631             replication_column = "NULL"
632         if ver &gt;= _LooseVersion("9.5"):
633             rolcatupdate_column = "NULL"
634         else:
635             rolcatupdate_column = "pg_roles.rolcatupdate"
636     else:
637         log.error("Could not retrieve Postgres version. Is Postgresql server running?")
638         return False
639     _x = lambda s: s if return_password else ""
640     query = "".join(
641         [
642             'SELECT pg_roles.rolname as "name",pg_roles.rolsuper as "superuser",'
643             ' pg_roles.rolinherit as "inherits privileges", pg_roles.rolcreaterole as'
644             ' "can create roles", pg_roles.rolcreatedb as "can create databases", {0}'
645             ' as "can update system catalogs", pg_roles.rolcanlogin as "can login", {1}'
646             ' as "replication", pg_roles.rolconnlimit as "connections", (SELECT'
647             " array_agg(pg_roles2.rolname)    FROM pg_catalog.pg_auth_members    JOIN"
648             " pg_catalog.pg_roles pg_roles2 ON (pg_auth_members.roleid = pg_roles2.oid)"
649             "    WHERE pg_auth_members.member = pg_roles.oid) as"
650             ' "groups",pg_roles.rolvaliduntil::timestamp(0) as "expiry time",'
651             ' pg_roles.rolconfig  as "defaults variables" ',
652             _x(', COALESCE(pg_shadow.passwd, pg_authid.rolpassword) as "password" '),
653             "FROM pg_roles ",
654             _x("LEFT JOIN pg_authid ON pg_roles.oid = pg_authid.oid "),
655             _x("LEFT JOIN pg_shadow ON pg_roles.oid = pg_shadow.usesysid"),
656         ]
657     ).format(rolcatupdate_column, replication_column)
658     rows = psql_query(
659         query,
660         runas=runas,
661         host=host,
662         user=user,
663         port=port,
664         maintenance_db=maintenance_db,
665         password=password,
666     )
667     def get_bool(rowdict, key):
668         if rowdict[key] == "t":
669             return True
670         elif rowdict[key] == "f":
671             return False
672         else:
673             return None
674     for row in rows:
675         retrow = {}
676         for key in (
677             "superuser",
678             "inherits privileges",
679             "can create roles",
680             "can create databases",
681             "can update system catalogs",
682             "can login",
683             "replication",
684             "connections",
685         ):
686             retrow[key] = get_bool(row, key)
687         for date_key in ("expiry time",):
688             try:
689                 retrow[date_key] = datetime.datetime.strptime(
690                     row[date_key], "%Y-%m-%d %H:%M:%S"
691                 )
692             except ValueError:
693                 retrow[date_key] = None
694         retrow["defaults variables"] = row["defaults variables"]
695         if return_password:
696 <a name="6"></a>            retrow["password"] = row["password"]
697         retrow["groups"] = list(csv.reader([row["groups"].strip("{}")]))[0]
698         ret[row["name"]] =<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b> retrow
699     return ret
700 def role_get(
701     name,
702     user=None,
703     host=None,
704     port=None,
705     maintenance_db=None,
706     password=None,
707     runas=None,
708     return_password=False,
709 ):
710     all_users = user_list(
711         user=user,
712         host=host,
713         port=port,
714         maintenance_db=</b></font>maintenance_db,
715         password=password,
716         runas=runas,
717         return_password=return_password,
718     )
719     try:
720         return all_users.get(name, None)
721     except AttributeError:
722         log.error("Could not retrieve Postgres role. Is Postgres running?")
723         return None
724 def user_exists(
725     name,
726     user=None,
727     host=None,
728     port=None,
729     maintenance_db=None,
730     password=None,
731     runas=None,
732 ):
733     return bool(
734         role_get(
735             name,
736             user=user,
737             host=host,
738             port=port,
739             maintenance_db=maintenance_db,
740             password=password,
741             runas=runas,
742             return_password=False,
743         )
744     )
745 def _add_role_flag(string, test, flag, cond=None, prefix="NO", addtxt="", skip=False):
746     if not skip:
747         if cond is None:
748             cond = test
749         if test is not None:
750             if cond:
751                 string = "{} {}".format(string, flag)
752             else:
753                 string = "{0} {2}{1}".format(string, flag, prefix)
754         if addtxt:
755             string = "{} {}".format(string, addtxt)
756     return string
757 def _maybe_encrypt_password(role, password, encrypted=_DEFAULT_PASSWORDS_ENCRYPTION):
758     if password is not None:
759         password = str(password)
760     else:
761         return None
762     if encrypted is True:
763         encrypted = "md5"
764     if encrypted not in (False, "md5", "scram-sha-256"):
765         raise ValueError("Unknown password algorithm: " + str(encrypted))
766     if encrypted == "scram-sha-256" and not password.startswith("SCRAM-SHA-256"):
767         password = _scram_sha_256(password)
768     elif encrypted == "md5" and not password.startswith("md5"):
769         log.warning("The md5 password algorithm was deprecated in PostgreSQL 10")
770         password = _md5_password(role, password)
771     elif encrypted is False:
772         log.warning("Unencrypted passwords were removed in PostgreSQL 10")
773     return password
774 def _verify_password(role, password, verifier, method):
775     if method == "md5" or method is True:
776         if password.startswith("md5"):
777             expected = password
778         else:
779             expected = _md5_password(role, password)
780     elif method == "scram-sha-256":
781         if password.startswith("SCRAM-SHA-256"):
782             expected = password
783         else:
784             match = re.match(r"^SCRAM-SHA-256\$(\d+):([^\$]+?)\$", verifier)
785             if match:
786                 iterations = int(match.group(1))
787                 salt_bytes = base64.b64decode(match.group(2))
788                 expected = _scram_sha_256(
789                     password, salt_bytes=salt_bytes, iterations=iterations
790                 )
791             else:
792                 expected = object()
793     elif method is False:
794         expected = password
795     else:
796         expected = object()
797     return verifier == expected
798 def _md5_password(role, password):
799     return "md5{}".format(
800         hashlib.md5(
801             salt.utils.stringutils.to_bytes("{}{}".format(password, role))
802         ).hexdigest()
803     )
804 def _scram_sha_256(password, salt_bytes=None, iterations=4096):
805     if salt_bytes is None:
806         salt_bytes = token_bytes(16)
807     password = salt.utils.stringutils.to_bytes(saslprep(password))
808     salted_password = hashlib.pbkdf2_hmac("sha256", password, salt_bytes, iterations)
809     stored_key = hmac.new(salted_password, b"Client Key", "sha256").digest()
810     stored_key = hashlib.sha256(stored_key).digest()
811     server_key = hmac.new(salted_password, b"Server Key", "sha256").digest()
812     return "SCRAM-SHA-256${}:{}${}:{}".format(
813         iterations,
814         base64.b64encode(salt_bytes).decode("ascii"),
815         base64.b64encode(stored_key).decode("ascii"),
816         base64.b64encode(server_key).decode("ascii"),
817     )
818 def _role_cmd_args(
819     name,
820     sub_cmd="",
821     typ_="role",
822     encrypted=None,
823     login=None,
824     connlimit=None,
825     inherit=None,
826     createdb=None,
827     createroles=None,
828     superuser=None,
829     groups=None,
830     replication=None,
831     rolepassword=None,
832     valid_until=None,
833     db_role=None,
834 ):
835     if inherit is None:
836         if typ_ in ["user", "group"]:
837             inherit = True
838     if login is None:
839         if typ_ == "user":
840             login = True
841         if typ_ == "group":
842             login = False
843     if encrypted is None:
844         encrypted = _DEFAULT_PASSWORDS_ENCRYPTION
845     skip_passwd = False
846     escaped_password = ""
847     escaped_valid_until = ""
848     if not (
849         rolepassword is not None
850         and (isinstance(rolepassword, str) and bool(rolepassword))
851         or (isinstance(rolepassword, bool))
852     ):
853         skip_passwd = True
854     if isinstance(rolepassword, str) and bool(rolepassword):
855         escaped_password = "'{}'".format(
856             _maybe_encrypt_password(
857                 name, rolepassword.replace("'", "''"), encrypted=encrypted
858             )
859         )
860     if isinstance(valid_until, str) and bool(valid_until):
861         escaped_valid_until = "'{}'".format(
862             valid_until.replace("'", "''"),
863         )
864     skip_superuser = False
865     if bool(db_role) and bool(superuser) == bool(db_role["superuser"]):
866         skip_superuser = True
867     flags = (
868         {"flag": "INHERIT", "test": inherit},
869         {"flag": "CREATEDB", "test": createdb},
870         {"flag": "CREATEROLE", "test": createroles},
871         {"flag": "SUPERUSER", "test": superuser, "skip": skip_superuser},
872         {"flag": "REPLICATION", "test": replication},
873         {"flag": "LOGIN", "test": login},
874         {
875             "flag": "CONNECTION LIMIT",
876             "test": bool(connlimit),
877             "addtxt": str(connlimit),
878             "skip": connlimit is None,
879         },
880         {
881             "flag": "ENCRYPTED",
882             "test": (encrypted is not None and bool(rolepassword)),
883             "skip": skip_passwd or isinstance(rolepassword, bool),
884             "cond": bool(encrypted),
885             "prefix": "UN",
886         },
887         {
888             "flag": "PASSWORD",
889             "test": bool(rolepassword),
890             "skip": skip_passwd,
891             "addtxt": escaped_password,
892         },
893         {
894             "flag": "VALID UNTIL",
895             "test": bool(valid_until),
896             "skip": valid_until is None,
897             "addtxt": escaped_valid_until,
898         },
899     )
900     for data in flags:
901         sub_cmd = _add_role_flag(sub_cmd, **data)
902     if sub_cmd.endswith("WITH"):
903         sub_cmd = sub_cmd.replace(" WITH", "")
904     if groups:
905         if isinstance(groups, list):
906 <a name="2"></a>            groups = ",".join(groups)
907         for group in groups.split(","):
908             sub_cmd = '{}; GRANT "{}" TO "{}"'.format(sub_cmd, group, name)
909     r<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>eturn sub_cmd
910 def _role_create(
911     name,
912     user=None,
913     host=None,
914     port=None,
915     maintenance_db=None,
916     password=None,
917     createdb=None,
918     createroles=None,
919     encrypted=None,
920     superuser=None,
921     login=None,
922     connlimit=None,
923     inherit=None,
924     replication=None,
925     rolepassword=None,
926     valid_until=None,
927     typ_="role",
928     groups=</b></font>None,
929     runas=None,
930 ):
931     if user_exists(
932         name, user, host, port, maintenance_db, password=password, runas=runas
933     ):
934         log.info("%s '%s' already exists", typ_.capitalize(), name)
935         return False
936     sub_cmd = 'CREATE ROLE "{}" WITH'.format(name)
937     sub_cmd = "{} {}".format(
938         sub_cmd,
939         _role_cmd_args(
940             name,
941             typ_=typ_,
942             encrypted=encrypted,
943             login=login,
944             connlimit=connlimit,
945             inherit=inherit,
946             createdb=createdb,
947             createroles=createroles,
948             superuser=superuser,
949             groups=groups,
950             replication=replication,
951             rolepassword=rolepassword,
952             valid_until=valid_until,
953         ),
954     )
955     ret = _psql_prepare_and_run(
956         ["-c", sub_cmd],
957         runas=runas,
958         host=host,
959         user=user,
960         port=port,
961         maintenance_db=maintenance_db,
962         password=password,
963     )
964     return ret["retcode"] == 0
965 def user_create(
966     username,
967     user=None,
968     host=None,
969     port=None,
970     maintenance_db=None,
971     password=None,
972     createdb=None,
973     createroles=None,
974     inherit=None,
975     login=None,
976     connlimit=None,
977     encrypted=None,
978     superuser=None,
979     replication=None,
980     rolepassword=None,
981     valid_until=None,
982     groups=None,
983     runas=None,
984 ):
985     return _role_create(
986         username,
987         typ_="user",
988         user=user,
989         host=host,
990         port=port,
991         maintenance_db=maintenance_db,
992         password=password,
993         createdb=createdb,
994         createroles=createroles,
995         inherit=inherit,
996         login=login,
997         connlimit=connlimit,
998         encrypted=encrypted,
999         superuser=superuser,
1000         replication=replication,
1001         rolepassword=rolepassword,
1002         valid_until=valid_until,
1003         groups=groups,
1004         runas=runas,
1005     )
1006 def _role_update(
1007 <a name="0"></a>    name,
1008     user=None,
1009     host=None,
1010     port<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None,
1011     maintenance_db=None,
1012     password=None,
1013     createdb=None,
1014     typ_="role",
1015     createroles=None,
1016     inherit=None,
1017     login=None,
1018     connlimit=None,
1019     encrypted=None,
1020     superuser=None,
1021     replication=None,
1022     rolepassword=None,
1023     valid_until=None,
1024     groups=None,
1025     runas=None,
1026 ):
1027     role = role_get(
1028         name,
1029         user=user,
1030         host=host,
1031         port=port,
1032         maintenance_db=maintenance_db,
1033         password=</b></font>password,
1034         runas=runas,
1035         return_password=False,
1036     )
1037     if not bool(role):
1038         log.info("%s '%s' could not be found", typ_.capitalize(), name)
1039         return False
1040     sub_cmd = 'ALTER ROLE "{}" WITH'.format(name)
1041     sub_cmd = "{} {}".format(
1042         sub_cmd,
1043         _role_cmd_args(
1044             name,
1045             encrypted=encrypted,
1046             login=login,
1047             connlimit=connlimit,
1048             inherit=inherit,
1049             createdb=createdb,
1050             createroles=createroles,
1051             superuser=superuser,
1052             groups=groups,
1053             replication=replication,
1054             rolepassword=rolepassword,
1055             valid_until=valid_until,
1056             db_role=role,
1057         ),
1058     )
1059     ret = _psql_prepare_and_run(
1060         ["-c", sub_cmd],
1061         runas=runas,
1062         host=host,
1063         user=user,
1064         port=port,
1065         maintenance_db=maintenance_db,
1066         password=password,
1067     )
1068     return ret["retcode"] == 0
1069 def user_update(
1070     username,
1071     user=None,
1072     host=None,
1073     port=None,
1074     maintenance_db=None,
1075     password=None,
1076     createdb=None,
1077     createroles=None,
1078     encrypted=None,
1079     superuser=None,
1080     inherit=None,
1081     login=None,
1082     connlimit=None,
1083     replication=None,
1084     rolepassword=None,
1085     valid_until=None,
1086     groups=None,
1087     runas=None,
1088 ):
1089     return _role_update(
1090         username,
1091         user=user,
1092         host=host,
1093         port=port,
1094         maintenance_db=maintenance_db,
1095         password=password,
1096         typ_="user",
1097         inherit=inherit,
1098         login=login,
1099         connlimit=connlimit,
1100         createdb=createdb,
1101         createroles=createroles,
1102         encrypted=encrypted,
1103         superuser=superuser,
1104         replication=replication,
1105         rolepassword=rolepassword,
1106         valid_until=valid_until,
1107         groups=groups,
1108         runas=runas,
1109     )
1110 def _role_remove(
1111     name,
1112     user=None,
1113     host=None,
1114     port=None,
1115     maintenance_db=None,
1116     password=None,
1117     runas=None,
1118 ):
1119     if not user_exists(
1120         name, user, host, port, maintenance_db, password=password, runas=runas
1121     ):
1122         log.info("User '%s' does not exist", name)
1123         return False
1124     sub_cmd = 'DROP ROLE "{}"'.format(name)
1125     _psql_prepare_and_run(
1126         ["-c", sub_cmd],
1127         runas=runas,
1128         host=host,
1129         user=user,
1130         port=port,
1131         maintenance_db=maintenance_db,
1132         password=password,
1133     )
1134     if not user_exists(
1135         name, user, host, port, maintenance_db, password=password, runas=runas
1136 <a name="1"></a>    ):
1137         return True
1138     else:
1139         log<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.info("Failed to delete user '%s'.", name)
1140         return False
1141 def available_extensions(
1142     user=None, host=None, port=None, maintenance_db=None, password=None, runas=None
1143 ):
1144     exts = []
1145     query = "select * from pg_available_extensions();"
1146     ret = psql_query(
1147         query,
1148         user=user,
1149         host=host,
1150         port=port,
1151         maintenance_db=maintenance_db,
1152         password=</b></font>password,
1153         runas=runas,
1154     )
1155     exts = {}
1156     for row in ret:
1157         if "default_version" in row and "name" in row:
1158             exts[row["name"]] = row
1159     return exts
1160 def installed_extensions(
1161     user=None, host=None, port=None, maintenance_db=None, password=None, runas=None
1162 ):
1163     exts = []
1164     query = (
1165         "select a.*, b.nspname as schema_name "
1166         "from pg_extension a,  pg_namespace b where a.extnamespace = b.oid;"
1167     )
1168     ret = psql_query(
1169         query,
1170         user=user,
1171         host=host,
1172         port=port,
1173         maintenance_db=maintenance_db,
1174         password=password,
1175         runas=runas,
1176     )
1177     exts = {}
1178     for row in ret:
1179         if "extversion" in row and "extname" in row:
1180             exts[row["extname"]] = row
1181     return exts
1182 def get_available_extension(
1183     name,
1184     user=None,
1185     host=None,
1186     port=None,
1187     maintenance_db=None,
1188     password=None,
1189     runas=None,
1190 ):
1191     return available_extensions(
1192         user=user,
1193         host=host,
1194         port=port,
1195         maintenance_db=maintenance_db,
1196         password=password,
1197         runas=runas,
1198     ).get(name, None)
1199 def get_installed_extension(
1200     name,
1201     user=None,
1202     host=None,
1203     port=None,
1204     maintenance_db=None,
1205     password=None,
1206     runas=None,
1207 ):
1208     return installed_extensions(
1209         user=user,
1210         host=host,
1211         port=port,
1212         maintenance_db=maintenance_db,
1213         password=password,
1214         runas=runas,
1215     ).get(name, None)
1216 def is_available_extension(
1217     name,
1218     user=None,
1219     host=None,
1220     port=None,
1221     maintenance_db=None,
1222     password=None,
1223     runas=None,
1224 ):
1225     exts = available_extensions(
1226         user=user,
1227         host=host,
1228         port=port,
1229         maintenance_db=maintenance_db,
1230         password=password,
1231         runas=runas,
1232     )
1233     if name.lower() in [a.lower() for a in exts]:
1234         return True
1235     return False
1236 def _pg_is_older_ext_ver(a, b):
1237     return _LooseVersion(a) &lt; _LooseVersion(b)
1238 def is_installed_extension(
1239     name,
1240     user=None,
1241     host=None,
1242     port=None,
1243     maintenance_db=None,
1244     password=None,
1245     runas=None,
1246 ):
1247     installed_ext = get_installed_extension(
1248         name,
1249         user=user,
1250         host=host,
1251         port=port,
1252         maintenance_db=maintenance_db,
1253 <a name="4"></a>        password=password,
1254         runas=runas,
1255     )
1256     return bool(<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>installed_ext)
1257 def create_metadata(
1258     name,
1259     ext_version=None,
1260     schema=None,
1261     user=None,
1262     host=None,
1263     port=None,
1264     maintenance_db=None,
1265     password=None,
1266     runas=None,
1267 ):
1268     installed_ext = get_installed_extension(
1269         name,
1270         user=user,
1271         host=host,
1272         port=port,
1273         maintenance_db=maintenance_db,
1274         password=</b></font>password,
1275         runas=runas,
1276     )
1277     ret = [_EXTENSION_NOT_INSTALLED]
1278     if installed_ext:
1279         ret = [_EXTENSION_INSTALLED]
1280         if ext_version is not None and _pg_is_older_ext_ver(
1281             installed_ext.get("extversion", ext_version), ext_version
1282         ):
1283             ret.append(_EXTENSION_TO_UPGRADE)
1284         if (
1285             schema is not None
1286             and installed_ext.get("extrelocatable", "f") == "t"
1287             and installed_ext.get("schema_name", schema) != schema
1288         ):
1289             ret.append(_EXTENSION_TO_MOVE)
1290     return ret
1291 def drop_extension(
1292     name,
1293     if_exists=None,
1294     restrict=None,
1295     cascade=None,
1296     user=None,
1297     host=None,
1298     port=None,
1299     maintenance_db=None,
1300     password=None,
1301     runas=None,
1302 ):
1303     if cascade is None:
1304         cascade = True
1305     if if_exists is None:
1306         if_exists = False
1307     if restrict is None:
1308         restrict = False
1309     args = ["DROP EXTENSION"]
1310     if if_exists:
1311         args.append("IF EXISTS")
1312     args.append(name)
1313     if cascade:
1314         args.append("CASCADE")
1315     if restrict:
1316         args.append("RESTRICT")
1317     args.append(";")
1318     cmd = " ".join(args)
1319     if is_installed_extension(
1320         name,
1321         user=user,
1322         host=host,
1323         port=port,
1324         maintenance_db=maintenance_db,
1325         password=password,
1326         runas=runas,
1327     ):
1328         _psql_prepare_and_run(
1329             ["-c", cmd],
1330             runas=runas,
1331             host=host,
1332             user=user,
1333             port=port,
1334             maintenance_db=maintenance_db,
1335             password=password,
1336         )
1337     ret = not is_installed_extension(
1338         name,
1339         user=user,
1340         host=host,
1341         port=port,
1342         maintenance_db=maintenance_db,
1343         password=password,
1344         runas=runas,
1345     )
1346     if not ret:
1347         log.info("Failed to drop ext: %s", name)
1348     return ret
1349 def create_extension(
1350     name,
1351     if_not_exists=None,
1352     schema=None,
1353     ext_version=None,
1354     from_version=None,
1355     user=None,
1356     host=None,
1357     port=None,
1358     maintenance_db=None,
1359     password=None,
1360     runas=None,
1361 ):
1362     if if_not_exists is None:
1363         if_not_exists = True
1364 <a name="8"></a>    mtdata = create_metadata(
1365         name,
1366         ext_version=ext_version,
1367         schema<font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=schema,
1368         user=user,
1369         host=host,
1370         port=port,
1371         maintenance_db=maintenance_db,
1372         password=password,
1373         runas=runas,
1374     )
1375     installed = _EXTENSION_NOT_INSTALLED not in mtdata
1376     installable = is_available_extension(
1377         name,
1378         user=user,
1379         host=host,
1380         port=port,
1381         maintenance_db=maintenance_db,
1382         password=</b></font>password,
1383         runas=runas,
1384     )
1385     if installable:
1386         if not installed:
1387             args = ["CREATE EXTENSION"]
1388             if if_not_exists:
1389                 args.append("IF NOT EXISTS")
1390             args.append('"{}"'.format(name))
1391             sargs = []
1392             if schema:
1393                 sargs.append('SCHEMA "{}"'.format(schema))
1394             if ext_version:
1395                 sargs.append("VERSION {}".format(ext_version))
1396             if from_version:
1397                 sargs.append("FROM {}".format(from_version))
1398             if sargs:
1399                 args.append("WITH")
1400                 args.extend(sargs)
1401             args.append(";")
1402             cmd = " ".join(args).strip()
1403         else:
1404             args = []
1405             if schema and _EXTENSION_TO_MOVE in mtdata:
1406                 args.append(
1407                     'ALTER EXTENSION "{}" SET SCHEMA "{}";'.format(name, schema)
1408                 )
1409             if ext_version and _EXTENSION_TO_UPGRADE in mtdata:
1410                 args.append(
1411                     'ALTER EXTENSION "{}" UPDATE TO {};'.format(name, ext_version)
1412                 )
1413             cmd = " ".join(args).strip()
1414         if cmd:
1415             _psql_prepare_and_run(
1416                 ["-c", cmd],
1417                 runas=runas,
1418                 host=host,
1419                 user=user,
1420                 port=port,
1421                 maintenance_db=maintenance_db,
1422                 password=password,
1423             )
1424     mtdata = create_metadata(
1425         name,
1426         ext_version=ext_version,
1427         schema=schema,
1428         user=user,
1429         host=host,
1430         port=port,
1431         maintenance_db=maintenance_db,
1432         password=password,
1433         runas=runas,
1434     )
1435     ret = True
1436     for i in _EXTENSION_FLAGS:
1437         if (i in mtdata) and (i != _EXTENSION_INSTALLED):
1438             ret = False
1439     if not ret:
1440         log.info("Failed to create ext: %s", name)
1441     return ret
1442 def user_remove(
1443     username,
1444     user=None,
1445     host=None,
1446     port=None,
1447     maintenance_db=None,
1448     password=None,
1449     runas=None,
1450 ):
1451     return _role_remove(
1452         username,
1453         user=user,
1454         host=host,
1455         port=port,
1456         maintenance_db=maintenance_db,
1457         password=password,
1458         runas=runas,
1459     )
1460 def group_create(
1461     groupname,
1462     user=None,
1463     host=None,
1464     port=None,
1465     maintenance_db=None,
1466     password=None,
1467     createdb=None,
1468     createroles=None,
1469     encrypted=None,
1470     login=None,
1471     inherit=None,
1472     superuser=None,
1473     replication=None,
1474     rolepassword=None,
1475     groups=None,
1476     runas=None,
1477 ):
1478     return _role_create(
1479         groupname,
1480         user=user,
1481         typ_="group",
1482         host=host,
1483         port=port,
1484         maintenance_db=maintenance_db,
1485         password=password,
1486         createdb=createdb,
1487         createroles=createroles,
1488         encrypted=encrypted,
1489         login=login,
1490         inherit=inherit,
1491         superuser=superuser,
1492         replication=replication,
1493         rolepassword=rolepassword,
1494         groups=groups,
1495         runas=runas,
1496     )
1497 def group_update(
1498     groupname,
1499     user=None,
1500     host=None,
1501     port=None,
1502     maintenance_db=None,
1503     password=None,
1504     createdb=None,
1505     createroles=None,
1506     encrypted=None,
1507     inherit=None,
1508     login=None,
1509     superuser=None,
1510     replication=None,
1511     rolepassword=None,
1512     groups=None,
1513     runas=None,
1514 ):
1515     return _role_update(
1516         groupname,
1517         user=user,
1518         host=host,
1519         port=port,
1520         maintenance_db=maintenance_db,
1521         password=password,
1522         createdb=createdb,
1523         typ_="group",
1524         createroles=createroles,
1525         encrypted=encrypted,
1526         login=login,
1527         inherit=inherit,
1528         superuser=superuser,
1529         replication=replication,
1530         rolepassword=rolepassword,
1531         groups=groups,
1532         runas=runas,
1533     )
1534 def group_remove(
1535     groupname,
1536     user=None,
1537     host=None,
1538     port=None,
1539     maintenance_db=None,
1540     password=None,
1541     runas=None,
1542 ):
1543     return _role_remove(
1544         groupname,
1545         user=user,
1546         host=host,
1547         port=port,
1548         maintenance_db=maintenance_db,
1549         password=password,
1550         runas=runas,
1551     )
1552 def owner_to(
1553     dbname, ownername, user=None, host=None, port=None, password=None, runas=None
1554 ):
1555     sqlfile = tempfile.NamedTemporaryFile()
1556     sqlfile.write("begin;\n")
1557     sqlfile.write('alter database "{}" owner to "{}";\n'.format(dbname, ownername))
1558     queries = (
1559         (
1560             "alter schema {n} owner to {owner};",
1561             "select quote_ident(schema_name) as n from information_schema.schemata;",
1562         ),
1563         (
1564             "alter table {n} owner to {owner};",
1565             "select quote_ident(table_schema)||'.'||quote_ident(table_name) as "
1566             "n from information_schema.tables where table_schema not in "
1567             "('pg_catalog', 'information_schema');",
1568         ),
1569         (
1570             "alter function {n} owner to {owner};",
1571             "select p.oid::regprocedure::text as n from pg_catalog.pg_proc p "
1572             "join pg_catalog.pg_namespace ns on p.pronamespace=ns.oid where "
1573             "ns.nspname not in ('pg_catalog', 'information_schema') "
1574             " and not p.proisagg;",
1575         ),
1576         (
1577             "alter aggregate {n} owner to {owner};",
1578             "select p.oid::regprocedure::text as n from pg_catalog.pg_proc p "
1579             "join pg_catalog.pg_namespace ns on p.pronamespace=ns.oid where "
1580             "ns.nspname not in ('pg_catalog', 'information_schema') "
1581             "and p.proisagg;",
1582         ),
1583         (
1584             "alter sequence {n} owner to {owner};",
1585             "select quote_ident(sequence_schema)||'.'||"
1586             "quote_ident(sequence_name) as n from information_schema.sequences;",
1587         ),
1588     )
1589     for fmt, query in queries:
1590         ret = psql_query(
1591             query,
1592             user=user,
1593             host=host,
1594             port=port,
1595             maintenance_db=dbname,
1596             password=password,
1597             runas=runas,
1598         )
1599         for row in ret:
1600             sqlfile.write(fmt.format(owner=ownername, n=row["n"]) + "\n")
1601     sqlfile.write("commit;\n")
1602     sqlfile.flush()
1603     os.chmod(sqlfile.name, 0o644)  # ensure psql can read the file
1604     cmdret = _psql_prepare_and_run(
1605         ["-f", sqlfile.name],
1606         user=user,
1607         runas=runas,
1608         host=host,
1609         port=port,
1610         password=password,
1611         maintenance_db=dbname,
1612     )
1613     return cmdret
1614 def schema_create(
1615     dbname,
1616     name,
1617     owner=None,
1618     user=None,
1619     db_user=None,
1620     db_password=None,
1621     db_host=None,
1622     db_port=None,
1623 ):
1624     if schema_exists(
1625         dbname,
1626         name,
1627         user=user,
1628         db_user=db_user,
1629         db_password=db_password,
1630         db_host=db_host,
1631         db_port=db_port,
1632     ):
1633         log.info("'%s' already exists in '%s'", name, dbname)
1634         return False
1635     sub_cmd = 'CREATE SCHEMA "{}"'.format(name)
1636     if owner is not None:
1637         sub_cmd = '{} AUTHORIZATION "{}"'.format(sub_cmd, owner)
1638     ret = _psql_prepare_and_run(
1639         ["-c", sub_cmd],
1640         user=db_user,
1641         password=db_password,
1642         port=db_port,
1643         host=db_host,
1644         maintenance_db=dbname,
1645         runas=user,
1646     )
1647     return ret["retcode"] == 0
1648 def schema_remove(
1649     dbname, name, user=None, db_user=None, db_password=None, db_host=None, db_port=None
1650 ):
1651     if not schema_exists(
1652         dbname,
1653         name,
1654         user=None,
1655         db_user=db_user,
1656         db_password=db_password,
1657         db_host=db_host,
1658         db_port=db_port,
1659     ):
1660         log.info("Schema '%s' does not exist in '%s'", name, dbname)
1661         return False
1662     sub_cmd = 'DROP SCHEMA "{}"'.format(name)
1663     _psql_prepare_and_run(
1664         ["-c", sub_cmd],
1665         runas=user,
1666         maintenance_db=dbname,
1667         host=db_host,
1668         user=db_user,
1669         port=db_port,
1670         password=db_password,
1671     )
1672     if not schema_exists(
1673         dbname,
1674         name,
1675         user,
1676         db_user=db_user,
1677         db_password=db_password,
1678 <a name="12"></a>        db_host=db_host,
1679         db_port=db_port,
1680     ):
1681         <font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return True
1682     else:
1683         log.info("Failed to delete schema '%s'.", name)
1684         return False
1685 def schema_exists(
1686     dbname, name, user=None, db_user=None, db_password=None, db_host=None, db_port=</b></font>None
1687 ):
1688     return bool(
1689         schema_get(
1690             dbname,
1691             name,
1692             user=user,
1693             db_user=db_user,
1694             db_host=db_host,
1695             db_port=db_port,
1696             db_password=db_password,
1697         )
1698     )
1699 def schema_get(
1700     dbname, name, user=None, db_user=None, db_password=None, db_host=None, db_port=None
1701 ):
1702     all_schemas = schema_list(
1703         dbname,
1704         user=user,
1705         db_user=db_user,
1706         db_host=db_host,
1707         db_port=db_port,
1708         db_password=db_password,
1709     )
1710     try:
1711         return all_schemas.get(name, None)
1712     except AttributeError:
1713         log.error("Could not retrieve Postgres schema. Is Postgres running?")
1714         return False
1715 def schema_list(
1716     dbname, user=None, db_user=None, db_password=None, db_host=None, db_port=None
1717 ):
1718     ret = {}
1719     query = "".join(
1720         [
1721             "SELECT "
1722             'pg_namespace.nspname as "name",'
1723             'pg_namespace.nspacl as "acl", '
1724             'pg_roles.rolname as "owner" '
1725             "FROM pg_namespace "
1726             "LEFT JOIN pg_roles ON pg_roles.oid = pg_namespace.nspowner "
1727         ]
1728     )
1729     rows = psql_query(
1730         query,
1731         runas=user,
1732         host=db_host,
1733         user=db_user,
1734         port=db_port,
1735         maintenance_db=dbname,
1736         password=db_password,
1737     )
1738     for row in rows:
1739         retrow = {}
1740         for key in ("owner", "acl"):
1741             retrow[key] = row[key]
1742         ret[row["name"]] = retrow
1743     return ret
1744 def language_list(
1745     maintenance_db, user=None, host=None, port=None, password=None, runas=None
1746 ):
1747     ret = {}
1748     query = 'SELECT lanname AS "Name" FROM pg_language'
1749     rows = psql_query(
1750         query,
1751         runas=runas,
1752         host=host,
1753         user=user,
1754         port=port,
1755         maintenance_db=maintenance_db,
1756         password=password,
1757     )
1758     for row in rows:
1759         ret[row["Name"]] = row["Name"]
1760     return ret
1761 def language_exists(
1762     name, maintenance_db, user=None, host=None, port=None, password=None, runas=None
1763 ):
1764     languages = language_list(
1765         maintenance_db, user=user, host=host, port=port, password=password, runas=runas
1766     )
1767     return name in languages
1768 def language_create(
1769     name, maintenance_db, user=None, host=None, port=None, password=None, runas=None
1770 ):
1771     if language_exists(name, maintenance_db):
1772         log.info("Language %s already exists in %s", name, maintenance_db)
1773         return False
1774     query = "CREATE LANGUAGE {}".format(name)
1775     ret = _psql_prepare_and_run(
1776         ["-c", query],
1777         user=user,
1778         host=host,
1779         port=port,
1780         maintenance_db=maintenance_db,
1781         password=password,
1782         runas=runas,
1783     )
1784     return ret["retcode"] == 0
1785 def language_remove(
1786     name, maintenance_db, user=None, host=None, port=None, password=None, runas=None
1787 ):
1788     if not language_exists(name, maintenance_db):
1789         log.info("Language %s does not exist in %s", name, maintenance_db)
1790         return False
1791     query = "DROP LANGUAGE {}".format(name)
1792     ret = _psql_prepare_and_run(
1793         ["-c", query],
1794         user=user,
1795         host=host,
1796         port=port,
1797         runas=runas,
1798         maintenance_db=maintenance_db,
1799         password=password,
1800     )
1801     return ret["retcode"] == 0
1802 def _make_privileges_list_query(name, object_type, prepend):
1803     if object_type == "table":
1804         query = (
1805             " ".join(
1806                 [
1807                     "SELECT relacl AS name",
1808                     "FROM pg_catalog.pg_class c",
1809                     "JOIN pg_catalog.pg_namespace n",
1810                     "ON n.oid = c.relnamespace",
1811                     "WHERE nspname = '{0}'",
1812                     "AND relname = '{1}'",
1813                     "AND relkind = 'r'",
1814                     "ORDER BY relname",
1815                 ]
1816             )
1817         ).format(prepend, name)
1818     elif object_type == "sequence":
1819         query = (
1820             " ".join(
1821                 [
1822                     "SELECT relacl AS name",
1823                     "FROM pg_catalog.pg_class c",
1824                     "JOIN pg_catalog.pg_namespace n",
1825                     "ON n.oid = c.relnamespace",
1826                     "WHERE nspname = '{0}'",
1827                     "AND relname = '{1}'",
1828                     "AND relkind = 'S'",
1829                     "ORDER BY relname",
1830                 ]
1831             )
1832         ).format(prepend, name)
1833     elif object_type == "schema":
1834         query = (
1835             " ".join(
1836                 [
1837                     "SELECT nspacl AS name",
1838                     "FROM pg_catalog.pg_namespace",
1839                     "WHERE nspname = '{0}'",
1840                     "ORDER BY nspname",
1841                 ]
1842             )
1843         ).format(name)
1844     elif object_type == "function":
1845         query = (
1846             " ".join(
1847                 [
1848                     "SELECT proacl AS name",
1849                     "FROM pg_catalog.pg_proc p",
1850                     "JOIN pg_catalog.pg_namespace n",
1851                     "ON n.oid = p.pronamespace",
1852                     "WHERE nspname = '{0}'",
1853                     "AND p.oid::regprocedure::text = '{1}'",
1854                     "ORDER BY proname, proargtypes",
1855                 ]
1856             )
1857         ).format(prepend, name)
1858     elif object_type == "tablespace":
1859         query = (
1860             " ".join(
1861                 [
1862                     "SELECT spcacl AS name",
1863                     "FROM pg_catalog.pg_tablespace",
1864                     "WHERE spcname = '{0}'",
1865                     "ORDER BY spcname",
1866                 ]
1867             )
1868         ).format(name)
1869     elif object_type == "language":
1870         query = (
1871             " ".join(
1872                 [
1873                     "SELECT lanacl AS name",
1874                     "FROM pg_catalog.pg_language",
1875                     "WHERE lanname = '{0}'",
1876                     "ORDER BY lanname",
1877                 ]
1878             )
1879         ).format(name)
1880     elif object_type == "database":
1881         query = (
1882             " ".join(
1883                 [
1884                     "SELECT datacl AS name",
1885                     "FROM pg_catalog.pg_database",
1886                     "WHERE datname = '{0}'",
1887                     "ORDER BY datname",
1888                 ]
1889             )
1890         ).format(name)
1891     elif object_type == "group":
1892         query = (
1893             " ".join(
1894                 [
1895                     "SELECT rolname, admin_option",
1896                     "FROM pg_catalog.pg_auth_members m",
1897                     "JOIN pg_catalog.pg_roles r",
1898                     "ON m.member=r.oid",
1899                     "WHERE m.roleid IN",
1900                     "(SELECT oid",
1901                     "FROM pg_catalog.pg_roles",
1902                     "WHERE rolname='{0}')",
1903                     "ORDER BY rolname",
1904                 ]
1905             )
1906         ).format(name)
1907     return query
1908 def _get_object_owner(
1909     name,
1910     object_type,
1911     prepend="public",
1912     maintenance_db=None,
1913     user=None,
1914     host=None,
1915     port=None,
1916     password=None,
1917     runas=None,
1918 ):
1919     if object_type == "table":
1920         query = (
1921             " ".join(
1922                 [
1923                     "SELECT tableowner AS name",
1924                     "FROM pg_tables",
1925                     "WHERE schemaname = '{0}'",
1926                     "AND tablename = '{1}'",
1927                 ]
1928             )
1929         ).format(prepend, name)
1930     elif object_type == "sequence":
1931         query = (
1932             " ".join(
1933                 [
1934                     "SELECT rolname AS name",
1935                     "FROM pg_catalog.pg_class c",
1936                     "JOIN pg_roles r",
1937                     "ON c.relowner = r.oid",
1938                     "JOIN pg_catalog.pg_namespace n",
1939                     "ON n.oid = c.relnamespace",
1940                     "WHERE relkind='S'",
1941                     "AND nspname='{0}'",
1942                     "AND relname = '{1}'",
1943                 ]
1944             )
1945         ).format(prepend, name)
1946     elif object_type == "schema":
1947         query = (
1948             " ".join(
1949                 [
1950                     "SELECT rolname AS name",
1951                     "FROM pg_namespace n",
1952                     "JOIN pg_roles r",
1953                     "ON n.nspowner = r.oid",
1954                     "WHERE nspname = '{0}'",
1955                 ]
1956             )
1957         ).format(name)
1958     elif object_type == "function":
1959         query = (
1960             " ".join(
1961                 [
1962                     "SELECT rolname AS name",
1963                     "FROM pg_catalog.pg_proc p",
1964                     "JOIN pg_catalog.pg_namespace n",
1965                     "ON n.oid = p.pronamespace",
1966                     "WHERE nspname = '{0}'",
1967                     "AND p.oid::regprocedure::text = '{1}'",
1968                     "ORDER BY proname, proargtypes",
1969                 ]
1970             )
1971         ).format(prepend, name)
1972     elif object_type == "tablespace":
1973         query = (
1974             " ".join(
1975                 [
1976                     "SELECT rolname AS name",
1977                     "FROM pg_tablespace t",
1978                     "JOIN pg_roles r",
1979                     "ON t.spcowner = r.oid",
1980                     "WHERE spcname = '{0}'",
1981                 ]
1982             )
1983         ).format(name)
1984     elif object_type == "language":
1985         query = (
1986             " ".join(
1987                 [
1988                     "SELECT rolname AS name",
1989                     "FROM pg_language l",
1990                     "JOIN pg_roles r",
1991                     "ON l.lanowner = r.oid",
1992                     "WHERE lanname = '{0}'",
1993                 ]
1994             )
1995         ).format(name)
1996     elif object_type == "database":
1997         query = (
1998             " ".join(
1999                 [
2000                     "SELECT rolname AS name",
2001                     "FROM pg_database d",
2002                     "JOIN pg_roles r",
2003                     "ON d.datdba = r.oid",
2004                     "WHERE datname = '{0}'",
2005                 ]
2006             )
2007         ).format(name)
2008     rows = psql_query(
2009         query,
2010         runas=runas,
2011         host=host,
2012         user=user,
2013         port=port,
2014         maintenance_db=maintenance_db,
2015         password=password,
2016     )
2017     try:
2018         ret = rows[0]["name"]
2019     except IndexError:
2020         ret = None
2021     return ret
2022 def _validate_privileges(object_type, privs, privileges):
2023     if object_type != "group":
2024         _perms = [_PRIVILEGES_MAP[perm] for perm in _PRIVILEGE_TYPE_MAP[object_type]]
2025         _perms.append("ALL")
2026         if object_type not in _PRIVILEGES_OBJECTS:
2027             raise SaltInvocationError(
2028                 "Invalid object_type: {} provided".format(object_type)
2029             )
2030         if not set(privs).issubset(set(_perms)):
2031             raise SaltInvocationError(
2032                 "Invalid privilege(s): {} provided for object {}".format(
2033                     privileges, object_type
2034                 )
2035             )
2036     else:
2037         if privileges:
2038             raise SaltInvocationError(
2039                 "The privileges option should not be set for object_type group"
2040             )
2041 def _mod_priv_opts(object_type, privileges):
2042     object_type = object_type.lower()
2043     privileges = "" if privileges is None else privileges
2044     _privs = re.split(r"\s?,\s?", privileges.upper())
2045     return object_type, privileges, _privs
2046 def _process_priv_part(perms):
2047     _tmp = {}
2048     previous = None
2049     for perm in perms:
2050         if previous is None:
2051             _tmp[_PRIVILEGES_MAP[perm]] = False
2052             previous = _PRIVILEGES_MAP[perm]
2053         else:
2054             if perm == "*":
2055                 _tmp[previous] = True
2056             else:
2057                 _tmp[_PRIVILEGES_MAP[perm]] = False
2058                 previous = _PRIVILEGES_MAP[perm]
2059     return _tmp
2060 def privileges_list(
2061     name,
2062     object_type,
2063     prepend="public",
2064     maintenance_db=None,
2065     user=None,
2066     host=None,
2067     port=None,
2068     password=None,
2069     runas=None,
2070 ):
2071     object_type = object_type.lower()
2072     query = _make_privileges_list_query(name, object_type, prepend)
2073     if object_type not in _PRIVILEGES_OBJECTS:
2074         raise SaltInvocationError(
2075             "Invalid object_type: {} provided".format(object_type)
2076         )
2077     rows = psql_query(
2078         query,
2079         runas=runas,
2080         host=host,
2081         user=user,
2082         port=port,
2083         maintenance_db=maintenance_db,
2084         password=password,
2085     )
2086     ret = {}
2087     for row in rows:
2088         if object_type != "group":
2089             result = row["name"]
2090             result = result.strip("{}")
2091             parts = result.split(",")
2092             for part in parts:
2093                 perms_part, _ = part.split("/")
2094                 rolename, perms = perms_part.split("=")
2095                 if rolename == "":
2096                     rolename = "public"
2097                 _tmp = _process_priv_part(perms)
2098                 ret[rolename] = _tmp
2099         else:
2100             if row["admin_option"] == "t":
2101                 admin_option = True
2102 <a name="11"></a>            else:
2103                 admin_option = False
2104             ret[row["rolname"]] = <font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>admin_option
2105     return ret
2106 def has_privileges(
2107     name,
2108     object_name,
2109     object_type,
2110     privileges=None,
2111     grant_option=None,
2112     prepend="public",
2113     maintenance_db=None,
2114     user=None,
2115     host=None,
2116     port=None,
2117     password=None,
2118     runas=</b></font>None,
2119 ):
2120     object_type, privileges, _privs = _mod_priv_opts(object_type, privileges)
2121     _validate_privileges(object_type, _privs, privileges)
2122     if object_type != "group":
2123         owner = _get_object_owner(
2124             object_name,
2125             object_type,
2126             prepend=prepend,
2127             maintenance_db=maintenance_db,
2128             user=user,
2129             host=host,
2130             port=port,
2131             password=password,
2132             runas=runas,
2133         )
2134         if owner is not None and name == owner:
2135             return True
2136     _privileges = privileges_list(
2137         object_name,
2138         object_type,
2139         prepend=prepend,
2140         maintenance_db=maintenance_db,
2141         user=user,
2142         host=host,
2143         port=port,
2144         password=password,
2145         runas=runas,
2146     )
2147     if name in _privileges:
2148         if object_type == "group":
2149             if grant_option:
2150                 retval = _privileges[name]
2151             else:
2152                 retval = True
2153             return retval
2154         else:
2155             _perms = _PRIVILEGE_TYPE_MAP[object_type]
2156             if grant_option:
2157                 perms = {_PRIVILEGES_MAP[perm]: True for perm in _perms}
2158                 retval = perms == _privileges[name]
2159             else:
2160                 perms = [_PRIVILEGES_MAP[perm] for perm in _perms]
2161                 if "ALL" in _privs:
2162                     retval = sorted(perms) == sorted(_privileges[name])
2163                 else:
2164                     retval = set(_privs).issubset(set(_privileges[name]))
2165             return retval
2166     return False
2167 def privileges_grant(
2168     name,
2169     object_name,
2170     object_type,
2171     privileges=None,
2172     grant_option=None,
2173     prepend="public",
2174     maintenance_db=None,
2175     user=None,
2176     host=None,
2177     port=None,
2178     password=None,
2179     runas=None,
2180 ):
2181     object_type, privileges, _privs = _mod_priv_opts(object_type, privileges)
2182     _validate_privileges(object_type, _privs, privileges)
2183     if has_privileges(
2184         name,
2185         object_name,
2186         object_type,
2187         privileges,
2188         prepend=prepend,
2189         maintenance_db=maintenance_db,
2190         user=user,
2191         host=host,
2192         port=port,
2193         password=password,
2194         runas=runas,
2195     ):
2196         log.info(
2197             "The object: %s of type: %s already has privileges: %s set",
2198             object_name,
2199             object_type,
2200             privileges,
2201         )
2202         return False
2203     _grants = ",".join(_privs)
2204     if object_type in ["table", "sequence"]:
2205         on_part = '{}."{}"'.format(prepend, object_name)
2206     elif object_type == "function":
2207         on_part = "{}".format(object_name)
2208     else:
2209         on_part = '"{}"'.format(object_name)
2210     if grant_option:
2211         if object_type == "group":
2212             query = 'GRANT {} TO "{}" WITH ADMIN OPTION'.format(object_name, name)
2213         elif object_type in ("table", "sequence") and object_name.upper() == "ALL":
2214             query = 'GRANT {} ON ALL {}S IN SCHEMA {} TO "{}" WITH GRANT OPTION'.format(
2215                 _grants, object_type.upper(), prepend, name
2216             )
2217         else:
2218             query = 'GRANT {} ON {} {} TO "{}" WITH GRANT OPTION'.format(
2219                 _grants, object_type.upper(), on_part, name
2220             )
2221     else:
2222         if object_type == "group":
2223             query = 'GRANT {} TO "{}"'.format(object_name, name)
2224         elif object_type in ("table", "sequence") and object_name.upper() == "ALL":
2225             query = 'GRANT {} ON ALL {}S IN SCHEMA {} TO "{}"'.format(
2226                 _grants, object_type.upper(), prepend, name
2227             )
2228         else:
2229             query = 'GRANT {} ON {} {} TO "{}"'.format(
2230                 _grants, object_type.upper(), on_part, name
2231             )
2232     ret = _psql_prepare_and_run(
2233         ["-c", query],
2234         user=user,
2235         host=host,
2236         port=port,
2237         maintenance_db=maintenance_db,
2238         password=password,
2239         runas=runas,
2240     )
2241     return ret["retcode"] == 0
2242 def privileges_revoke(
2243     name,
2244     object_name,
2245     object_type,
2246     privileges=None,
2247     prepend="public",
2248     maintenance_db=None,
2249     user=None,
2250     host=None,
2251     port=None,
2252     password=None,
2253     runas=None,
2254 ):
2255     object_type, privileges, _privs = _mod_priv_opts(object_type, privileges)
2256     _validate_privileges(object_type, _privs, privileges)
2257     if not has_privileges(
2258         name,
2259         object_name,
2260         object_type,
2261         privileges,
2262         prepend=prepend,
2263         maintenance_db=maintenance_db,
2264         user=user,
2265         host=host,
2266         port=port,
2267         password=password,
2268         runas=runas,
2269     ):
2270         log.info(
2271             "The object: %s of type: %s does not have privileges: %s set",
2272             object_name,
2273             object_type,
2274             privileges,
2275         )
2276         return False
2277     _grants = ",".join(_privs)
2278     if object_type in ["table", "sequence"]:
2279         on_part = "{}.{}".format(prepend, object_name)
2280     else:
2281         on_part = object_name
2282     if object_type == "group":
2283         query = "REVOKE {} FROM {}".format(object_name, name)
2284     else:
2285         query = "REVOKE {} ON {} {} FROM {}".format(
2286             _grants, object_type.upper(), on_part, name
2287         )
2288     ret = _psql_prepare_and_run(
2289         ["-c", query],
2290         user=user,
2291         host=host,
2292         port=port,
2293         maintenance_db=maintenance_db,
2294         password=password,
2295         runas=runas,
2296     )
2297     return ret["retcode"] == 0
2298 def datadir_init(
2299     name,
2300     auth="password",
2301     user=None,
2302     password=None,
2303     encoding="UTF8",
2304     locale=None,
2305     waldir=None,
2306     checksums=False,
2307     runas=None,
2308 ):
2309     if datadir_exists<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(name):
2310         log.info("%s already exists", name)
2311         return False
2312     ret = _run_initdb(
2313         name,
2314         auth=auth,
2315         user=user,
2316         password=password,
2317         encoding=encoding,
2318         locale=locale,
2319         waldir=waldir,
2320         checksums=checksums,
2321         runas=runas,
2322     )
2323     return</b></font> ret["retcode"] == 0
2324 def datadir_exists(name):
2325     _version_file = os.path.join(name, "PG_VERSION")
2326     _config_file = os.path.join(name, "postgresql.conf")
2327     return os.path.isfile(_version_file) and os.path.isfile(_config_file)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
