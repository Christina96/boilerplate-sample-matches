<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for boto_secgroup_1.py &amp; postgres_2.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for boto_secgroup_1.py &amp; postgres_2.py
      </h3>
<h1 align="center">
        13.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>boto_secgroup_1.py (28.253614%)<th>postgres_2.py (8.859435%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(564-592)<td><a href="#" name="0">(1455-1481)</a><td align="center"><font color="#ff0000">23</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(513-538)<td><a href="#" name="1">(1614-1639)</a><td align="center"><font color="#e80000">21</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(649-679)<td><a href="#" name="2">(1329-1350)</a><td align="center"><font color="#d20000">19</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(89-113)<td><a href="#" name="3">(383-389)</a><td align="center"><font color="#d20000">19</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(789-842)<td><a href="#" name="4">(1810-1840)</a><td align="center"><font color="#bc0000">17</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(419-443)<td><a href="#" name="5">(945-979)</a><td align="center"><font color="#bc0000">17</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(272-303)<td><a href="#" name="6">(1063-1093)</a><td align="center"><font color="#bc0000">17</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(358-371)<td><a href="#" name="7">(3651-3666)</a><td align="center"><font color="#b10000">16</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(868-916)<td><a href="#" name="8">(1957-1972)</a><td align="center"><font color="#a60000">15</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(342-357)<td><a href="#" name="9">(529-555)</a><td align="center"><font color="#a60000">15</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(469-491)<td><a href="#" name="10">(299-316)</a><td align="center"><font color="#9b0000">14</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(156-169)<td><a href="#" name="11">(3162-3179)</a><td align="center"><font color="#900000">13</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(735-746)<td><a href="#" name="12">(2406-2413)</a><td align="center"><font color="#850000">12</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(679-688)<td><a href="#" name="13">(271-293)</a><td align="center"><font color="#850000">12</font>
<tr onclick='openModal("#842dce")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#842dce"><font color="#842dce">-</font><td><a href="#" name="14">(445-455)<td><a href="#" name="14">(810-831)</a><td align="center"><font color="#850000">12</font>
<tr onclick='openModal("#f52887")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f52887"><font color="#f52887">-</font><td><a href="#" name="15">(121-128)<td><a href="#" name="15">(912-936)</a><td align="center"><font color="#850000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_secgroup_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import salt.utils.odict as odict
3 import salt.utils.versions
4 from salt.exceptions import CommandExecutionError, SaltInvocationError
5 log = logging.getLogger(__name__)
6 try:
7     import boto
8     import boto.ec2
9     logging.getLogger("boto").setLevel(logging.CRITICAL)
10     HAS_BOTO = True
11 except ImportError:
12     HAS_BOTO = False
13 def __virtual__():
14     has_boto_reqs = salt.utils.versions.check_boto_reqs(
15         boto_ver="2.4.0", check_boto3=False
16     )
17     if has_boto_reqs is True:
18         __utils__["boto.assign_funcs"](__name__, "ec2", pack=__salt__)
19     return has_boto_reqs
20     name=None,
21     region=None,
22     key<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None,
23     keyid=None,
24     profile=None,
25     vpc_id=None,
26     vpc_name=None,
27     group_id=None,
28 ):
29     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
30     group = _get_group(
31         conn,
32         name=name,
33         vpc_id=vpc_id,
34         vpc_name=vpc_name,
35         group_id=group_id,
36         region=</b></font>region,
37         key=key,
38         keyid=keyid,
39         profile=profile,
40     )
41         return True
42     else:
43         re<font color="#f52887"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>turn False
44 def _vpc_name_to_id(
45     vpc_id=None, vpc_name=None, region=None, key=None, keyid=None, profile=None
46 ):
47     data = __salt__["boto_vpc.get_id"](
48         name=</b></font>vpc_name, region=region, key=key, keyid=keyid, profile=profile
49     )
50     return data.get("id")
51 def _split_rules(rules):
52     split = []
53     for rule in rules:
54         ip_protocol = rule.get("ip_protocol")
55         to_port = rule.get("to_port")
56         from_port = rule.get("from_port")
57         grants = rule.get("grants")
58         for grant in grants:
59             _rule = {
60                 "ip_protocol": ip_protocol,
61                 "to_port": to_port,
62                 "from_port": from_port,
63             for key, val in grant.items():
64                 _rule[key] = val
65             split.append(_<font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>rule)
66     return split
67 def _get_group(
68     conn=None,
69     name=None,
70     vpc_id=None,
71     vpc_name=None,
72     group_id=None,
73     region=None,
74     key=None,
75     keyid=None,
76     profile=</b></font>None,
77 ):  # pylint: disable=W0613
78     if vpc_name and vpc_id:
79         raise SaltInvocationError(
80             "The params 'vpc_id' and 'vpc_name' are mutually exclusive."
81         )
82     if vpc_name:
83         try:
84             vpc_id = _vpc_name_to_id(
85                 vpc_id=vpc_id,
86                 vpc_name=vpc_name,
87                 region=region,
88                 key=key,
89                 keyid=keyid,
90                 profile=profile,
91             )
92         except boto.exception.BotoServerError as e:
93             log.debug(e)
94             return None
95     if name:
96         if vpc_id is None:
97             log.debug("getting group for %s", name)
98             group_filter = {"group-name": name}
99             filtered_groups = conn.get_all_security_groups(filters=group_filter)
100             for group in filtered_groups:
101                 if group.vpc_id is None:
102                     return group
103             if len(filtered_groups) &gt; 1:
104                 raise CommandExecutionError(
105                     "Security group belongs to more VPCs, specify the VPC ID!"
106                 )
107             elif len(filtered_groups) == 1:
108                 return filtered_groups[0]
109             return None
110         elif vpc_id:
111             log.debug("getting group for %s in vpc_id %s", name, vpc_id)
112             group_filter = {"group-name": name, "vpc_id": vpc_id}
113             filtered_groups = conn.get_all_security_groups(filters=group_filter)
114             if len(filtered_groups) == 1:
115                 return filtered_groups[0]
116             else:
117                 return None
118         else:
119             return None
120     elif group_id:
121         try:
122             groups = conn.get_all_security_groups(group_ids=[group_id])
123         except boto.exception.BotoServerError as e:
124             log.debug(e)
125             return None
126         if len(groups) == 1:
127             return groups[0]
128         else:
129             return None
130     else:
131         return None
132 def _parse_rules(sg, rules):
133     _rules = []
134     for rule in rules:
135         log.debug("examining rule %s for group %s", rule, sg.id)
136         attrs = ["ip_protocol", "from_port", "to_port", "grants"]
137         _rule = odict.OrderedDict()
138         for attr in attrs:
139             val = getattr(rule, attr)
140             if not val:
141                 continue
142             if attr == "grants":
143                 _grants = []
144                 for grant in val:
145                     log.debug("examining grant %s for", grant)
146                     g_attrs = {
147                         "name": "source_group_name",
148                         "owner_id": "source_group_owner_id",
149                         "group_id": "source_group_group_id",
150                         "cidr_ip": "cidr_ip",
151                     }
152                     _grant = odict.OrderedDict()
153                     for g_attr, g_attr_map in g_attrs.items():
154                         g_val = getattr(grant, g_attr)
155                         if not g_val:
156                             continue
157                         _grant[g_attr_map] = g_val
158                     _grants.append(_grant)
159                 _rule["grants"] = _grants
160             elif attr == "from_port":
161                 _rule[attr] = int(val)
162             elif attr == "to_port":
163             else:
164                 _rule[attr] = val
165         _rules.append(<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>_rule)
166     return _rules
167 def get_all_security_groups(
168     groupnames=None,
169     group_ids=None,
170     filters=None,
171     region=None,
172     key=None,
173     keyid=None,
174     profile=None,
175 ):
176     conn = _get_conn(region=region, key=key, keyid=keyid, profile=</b></font>profile)
177     if isinstance(groupnames, str):
178         groupnames = [groupnames]
179     if isinstance(group_ids, str):
180         groupnames = [group_ids]
181     interesting = [
182         "description",
183         "id",
184         "instances",
185         "name",
186         "owner_id",
187         "region",
188         "rules",
189         "rules_egress",
190         "tags",
191         "vpc_id",
192     ]
193     ret = []
194     try:
195         r = conn.get_all_security_groups(
196             groupnames=groupnames, group_ids=group_ids, filters=filters
197         )
198         for g in r:
199             n = {}
200             for a in interesting:
201                 v = getattr(g, a, None)
202                 if a == "region":
203                     v = v.name
204                 elif a in ("rules", "rules_egress"):
205                     v = _parse_rules(g, v)
206                 elif a == "instances":
207                     v = [i.id for i in v()]
208                 n[a] = v
209             ret += [n]
210     except boto.exception.BotoServerError as e:
211         log.debug(e)
212         <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return []
213 def get_group_id(
214     name, vpc_id=None, vpc_name=None, region=None, key=None, keyid=None, profile=None
215 ):
216     conn = _get_conn(region=region, key=key, keyid=keyid, profile=</b></font>profile)
217     if name.startswith<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("sg-"):
218         log.debug("group %s is a group id. get_group_id not called.", name)
219         return name
220     group = _get_group(
221         conn=conn,
222         name=name,
223         vpc_id=vpc_id,
224         vpc_name=vpc_name,
225         region=region,
226         key=key,
227         keyid=keyid,
228         profile=profile,
229     )
230     return</b></font> getattr(group, "id", None)
231 def convert_to_group_ids(
232     groups, vpc_id=None, vpc_name=None, region=None, key=None, keyid=None, profile=None
233 ):
234     log.debug("security group contents %s pre-conversion", groups)
235     group_ids = []
236     for group in groups:
237         group_id = get_group_id(
238             name=group,
239             vpc_id=vpc_id,
240             vpc_name=vpc_name,
241             region=region,
242             key=key,
243             keyid=keyid,
244             profile=profile,
245         )
246         if not group_id:
247             if __opts__["test"]:
248                 log.warn(
249                     "Security Group `%s` could not be resolved to an ID.  This may "
250                     "cause a failure when not running in test mode.",
251                     group,
252                 )
253                 return []
254             else:
255                 raise CommandExecutionError(
256                     "Could not resolve Security Group name {} to a Group ID".format(
257                         group
258                     )
259                 )
260             group_ids.append(str(group_id))
261     log.debug("security group contents %s post-conversion", group_ids)
262     r<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>eturn group_ids
263 def get_config(
264     name=None,
265     group_id=None,
266     region=None,
267     key=None,
268     keyid=None,
269     profile=None,
270     vpc_id=None,
271     vpc_name=None,
272 ):
273     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
274     sg =</b></font> _get_group(
275         conn,
276         name<font color="#842dce"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=name,
277         vpc_id=vpc_id,
278         vpc_name=vpc_name,
279         group_id=group_id,
280         region=region,
281         key=key,
282         keyid=keyid,
283         profile=profile,
284     )
285     if sg:
286         ret = odict.OrderedDict(</b></font>)
287         ret["name"] = sg.name
288         ret["group_id"] = sg.id
289         ret["owner_id"] = sg.owner_id
290         ret["description"] = sg.description
291         ret["tags"] = sg.tags
292         _rules = _parse_rules(sg, sg.rules)
293         _rules_egress = _parse_rules(sg, sg.rules_egress)
294         ret["rules"] = _split_rules(_rules)
295         return ret
296     else:
297         re<font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>turn None
298 def create(
299     name,
300     description,
301     vpc_id=None,
302     vpc_name=None,
303     region=None,
304     key=None,
305     keyid=None,
306     profile=None,
307 ):
308     conn = _get_conn(region=region, key=key, keyid=keyid, profile=</b></font>profile)
309     if not vpc_id and vpc_name:
310         try:
311             vpc_id = _vpc_name_to_id(
312                 vpc_id=vpc_id,
313                 vpc_name=vpc_name,
314                 region=region,
315                 key=key,
316                 keyid=keyid,
317                 profile=profile,
318             )
319         except boto.exception.BotoServerError as e:
320             log.debug(e)
321             return False
322     created = conn.create_security_group(name, description, vpc_id)
323     if created:
324         log.info("Created security group %s.", name)
325     else:
326         msg = "Failed to create security group {}.".format(name)
327         log<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.error(msg)
328         return False
329 def delete(
330     name=None,
331     group_id=None,
332     region=None,
333     key=None,
334     keyid=None,
335     profile=None,
336     vpc_id=None,
337     vpc_name=None,
338 ):
339     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
340     group =</b></font> _get_group(
341         conn,
342         name=name,
343         vpc_id=vpc_id,
344         vpc_name=vpc_name,
345         group_id=group_id,
346         region=region,
347         key=key,
348         keyid=keyid,
349         profile=profile,
350     )
351     if group:
352         deleted = conn.delete_security_group(group_id=group.id)
353         if deleted:
354             log.info("Deleted security group %s with id %s.", group.name, group.id)
355             return True
356         else:
357             msg = "Failed to delete security group {}.".format(name)
358             log.error(msg)
359             return False
360     else:
361         log.debug("Security group not found.")
362         return False
363 def authorize(
364     name<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None,
365     source_group_name=None,
366     source_group_owner_id=None,
367     ip_protocol=None,
368     from_port=None,
369     to_port=None,
370     cidr_ip=None,
371     group_id=None,
372     source_group_group_id=None,
373     region=None,
374     key=None,
375     keyid=None,
376     profile=None,
377     vpc_id=None,
378     vpc_name=None,
379     egress=False,
380 ):
381     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
382     group =</b></font> _get_group(
383         conn,
384         name=name,
385         vpc_id=vpc_id,
386         vpc_name=vpc_name,
387         group_id=group_id,
388         region=region,
389         key=key,
390         keyid=keyid,
391         profile=profile,
392     )
393     if group:
394         try:
395             added = None
396             if not egress:
397                 added = conn.authorize_security_group(
398                     src_security_group_name=source_group_name,
399                     src_security_group_owner_id=source_group_owner_id,
400                     ip_protocol=ip_protocol,
401                     from_port=from_port,
402                     to_port=to_port,
403                     cidr_ip=cidr_ip,
404                     group_id=group.id,
405                     src_security_group_group_id=source_group_group_id,
406                 )
407             else:
408                 added = conn.authorize_security_group_egress(
409                     ip_protocol=ip_protocol,
410                     from_port=from_port,
411                     to_port=to_port,
412                     cidr_ip=cidr_ip,
413                     group_id=group.id,
414                     src_group_id=source_group_group_id,
415                 )
416             if added:
417                 log.info(
418                     "Added rule to security group %s with id %s", group.name, group.id
419                 )
420                 return True
421             else:
422                 msg = "Failed to add rule to security group {} with id {}.".format(
423                     group.name, group.id
424                 )
425                 log.error(msg)
426                 return False
427         except boto.exception.EC2ResponseError as e:
428             if e.error_code == "InvalidPermission.Duplicate":
429                 return True
430             msg = "Failed to add rule to security group {} with id {}.".format(
431                 group.name, group.id
432             )
433             log.error(msg)
434             log.error(e)
435     else:
436         log.error("Failed to add rule to security group.")
437         re<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>turn False
438 def revoke(
439     name=None,
440     source_group_name=None,
441     source_group_owner_id=None,
442     ip_protocol=None,
443     from_port=None,
444     to_port=None,
445     cidr_ip=None,
446     group_id=None,
447     source_group_group_id=None,
448     region=None,
449     key=None,
450     keyid=None,
451     profile=None,
452     vpc_id=None,
453     vpc_name=None,
454     egress=False,
455 ):
456     conn =</b></font> _get_conn(region<font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=region, key=key, keyid=keyid, profile=profile)
457     group = _get_group(
458         conn,
459         name=name,
460         vpc_id=vpc_id,
461         vpc_name=vpc_name,
462         group_id=group_id,
463         region=region,
464         key=</b></font>key,
465         keyid=keyid,
466         profile=profile,
467     )
468     if group:
469         try:
470             revoked = None
471             if not egress:
472                 revoked = conn.revoke_security_group(
473                     src_security_group_name=source_group_name,
474                     src_security_group_owner_id=source_group_owner_id,
475                     ip_protocol=ip_protocol,
476                     from_port=from_port,
477                     to_port=to_port,
478                     cidr_ip=cidr_ip,
479                     group_id=group.id,
480                     src_security_group_group_id=source_group_group_id,
481                 )
482             else:
483                 revoked = conn.revoke_security_group_egress(
484                     ip_protocol=ip_protocol,
485                     from_port=from_port,
486                     to_port=to_port,
487                     cidr_ip=cidr_ip,
488                     group_id=group.id,
489                     src_group_id=source_group_group_id,
490                 )
491             if revoked:
492                 log.info(
493                     "Removed rule from security group %s with id %s.",
494                     group.name,
495                     group.id,
496                 )
497                 return True
498             else:
499                 msg = "Failed to remove rule from security group {} with id {}.".format(
500                     group.name, group.id
501                 )
502                 log.error(msg)
503                 return False
504         except boto.exception.EC2ResponseError as e:
505             msg = "Failed to remove rule from security group {} with id {}.".format(
506                 group.name, group.id
507             log.error(msg)
508             log.error(e)
509             <font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return False
510     else:
511         log.error("Failed to remove rule from security group.")
512         return False
513 def _find_vpcs(
514     vpc_id=None,
515     vpc_name=None,
516     cidr=None,
517     tags=None,
518     region=</b></font>None,
519     key=None,
520     keyid=None,
521     profile=None,
522 ):
523     if all((vpc_id, vpc_name)):
524         raise SaltInvocationError("Only one of vpc_name or vpc_id may be provided.")
525     if not any((vpc_id, vpc_name, tags, cidr)):
526         raise SaltInvocationError(
527             "At least one of the following must be "
528             "provided: vpc_id, vpc_name, cidr or tags."
529         )
530     local_get_conn = __utils__["boto.get_connection_func"]("vpc")
531     conn = local_get_conn(region=region, key=key, keyid=keyid, profile=profile)
532     filter_parameters = {"filters": {}}
533     if vpc_id:
534         filter_parameters["vpc_ids"] = [vpc_id]
535     if cidr:
536         filter_parameters["filters"]["cidr"] = cidr
537     if vpc_name:
538         filter_parameters["filters"]["tag:Name"] = vpc_name
539     if tags:
540         for tag_name, tag_value in tags.items():
541             filter_parameters["filters"]["tag:{}".format(tag_name)] = tag_value
542     vpcs = conn.get_all_vpcs(**filter_parameters)
543     log.debug(
544         "The filters criteria %s matched the following VPCs:%s", filter_parameters, vpcs
545     )
546         return [vpc.id for vpc in vpcs]
547     else:
548         re<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>turn []
549 def set_tags(
550     tags,
551     name=None,
552     group_id=None,
553     vpc_name=None,
554     vpc_id=None,
555     region=None,
556     key=None,
557     keyid=None,
558     profile=None,
559 ):
560     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
561     secgrp =</b></font> _get_group(
562         conn,
563         name=name,
564         vpc_id=vpc_id,
565         vpc_name=vpc_name,
566         group_id=group_id,
567         region=region,
568         key=key,
569         keyid=keyid,
570         profile=profile,
571     )
572     if secgrp:
573         if isinstance(tags, dict):
574             secgrp.add_tags(tags)
575         else:
576             msg = "Tags must be a dict of tagname:tagvalue"
577             raise SaltInvocationError(msg)
578     else:
579         msg = "The security group could not be found"
580         raise SaltInvocationError(msg)
581     return True
582 def delete_tags(
583     tags,
584     name<font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None,
585     group_id=None,
586     vpc_name=None,
587     vpc_id=None,
588     region=None,
589     key=None,
590     keyid=None,
591     profile=None,
592 ):
593     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
594     secgrp =</b></font> _get_group(
595         conn,
596         name=name,
597         vpc_id=vpc_id,
598         vpc_name=vpc_name,
599         group_id=group_id,
600         region=region,
601         key=key,
602         keyid=keyid,
603         profile=profile,
604     )
605     if secgrp:
606         if isinstance(tags, list):
607             tags_to_remove = {}
608             for tag in tags:
609                 tags_to_remove[tag] = None
610             secgrp.remove_tags(tags_to_remove)
611         else:
612             msg = "Tags must be a list of tagnames to remove from the security group"
613             raise SaltInvocationError(msg)
614     else:
615         msg = "The security group could not be found"
616         raise SaltInvocationError(msg)
617     return True
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>postgres_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import base64
2 import datetime
3 import hashlib
4 import hmac
5 import io
6 import logging
7 import os
8 import pipes
9 import re
10 import tempfile
11 import salt.utils.files
12 import salt.utils.itertools
13 import salt.utils.odict
14 import salt.utils.path
15 import salt.utils.stringutils
16 from salt.exceptions import CommandExecutionError, SaltInvocationError
17 from salt.ext.saslprep import saslprep
18 from salt.utils.versions import LooseVersion as _LooseVersion
19 try:
20     import csv
21     HAS_CSV = True
22 except ImportError:
23     HAS_CSV = False
24 try:
25     from secrets import token_bytes
26 except ImportError:
27     from os import urandom as token_bytes
28 log = logging.getLogger(__name__)
29 _DEFAULT_PASSWORDS_ENCRYPTION = "md5"
30 _EXTENSION_NOT_INSTALLED = "EXTENSION NOT INSTALLED"
31 _EXTENSION_INSTALLED = "EXTENSION INSTALLED"
32 _EXTENSION_TO_UPGRADE = "EXTENSION TO UPGRADE"
33 _EXTENSION_TO_MOVE = "EXTENSION TO MOVE"
34 _EXTENSION_FLAGS = (
35     _EXTENSION_NOT_INSTALLED,
36     _EXTENSION_INSTALLED,
37     _EXTENSION_TO_UPGRADE,
38     _EXTENSION_TO_MOVE,
39 )
40 _PRIVILEGES_MAP = {
41     "a": "INSERT",
42     "C": "CREATE",
43     "D": "TRUNCATE",
44     "c": "CONNECT",
45     "t": "TRIGGER",
46     "r": "SELECT",
47     "U": "USAGE",
48     "T": "TEMPORARY",
49     "w": "UPDATE",
50     "X": "EXECUTE",
51     "x": "REFERENCES",
52     "d": "DELETE",
53     "*": "GRANT",
54 }
55 _PRIVILEGES_OBJECTS = frozenset(
56     (
57         "schema",
58         "tablespace",
59         "language",
60         "sequence",
61         "table",
62         "group",
63         "database",
64         "function",
65     )
66 )
67 _PRIVILEGE_TYPE_MAP = {
68     "table": "arwdDxt",
69     "tablespace": "C",
70     "language": "U",
71     "sequence": "rwU",
72     "schema": "UC",
73     "database": "CTc",
74     "function": "X",
75 }
76 def __virtual__():
77     utils = ["psql"]
78     if not HAS_CSV:
79         return False
80     for util in utils:
81         if not salt.utils.path.which(util):
82             if not _find_pg_binary(util):
83                 return (False, "{} was not found".format(util))
84     return True
85 def _find_pg_binary(util):
86     pg_bin_dir = __salt__["config.option"]("postgres.bins_dir")
87     util_bin = salt.utils.path.which(util)
88     if not util_bin:
89         if pg_bin_dir:
90             return salt.utils.path.which(os.path.join(pg_bin_dir, util))
91     else:
92         return util_bin
93 def _run_psql(cmd, runas=None, password=None, host=None, port=None, user=None):
94     kwargs = {
95         "reset_system_locale": False,
96         "clean_env": True,
97     }
98     if runas is None:
99         if not host:
100             host = __salt__["config.option"]("postgres.host")
101         if not host or host.startswith("/"):
102             if "FreeBSD" in __grains__["os_family"]:
103                 runas = "postgres"
104             elif "OpenBSD" in __grains__["os_family"]:
105                 runas = "_postgresql"
106             else:
107                 runas = "postgres"
108     if user is None:
109         user = runas
110     if runas:
111         kwargs["runas"] = runas
112     if password is None:
113         password = __salt__["config.option"]("postgres.pass")
114     if password is not None:
115         pgpassfile = salt.utils.files.mkstemp(text=True)
116         with salt.utils.files.fopen(pgpassfile, "w") as fp_:
117             fp_.write(
118                 salt.utils.stringutils.to_str(
119                     "{}:{}:*:{}:{}".format(
120                         "localhost" if not host or host.startswith("/") else host,
121                         port if port else "*",
122                         user if user else "*",
123                         password,
124                     )
125                 )
126             )
127             __salt__["file.chown"](pgpassfile, runas, "")
128             kwargs["env"] = {"PGPASSFILE": pgpassfile}
129     ret = __salt__["cmd.run_all"](cmd, python_shell=False, **kwargs)
130     if ret.get("retcode", 0) != 0:
131         log.error("Error connecting to Postgresql server")
132     if password is not None and not __salt__["file.remove"](pgpassfile):
133         log.warning("Remove PGPASSFILE failed")
134     return ret
135 def _run_initdb(
136     name,
137     auth="password",
138     user=None,
139     password=None,
140     encoding="UTF8",
141     locale=None,
142     runas=None,
143     waldir=None,
144     checksums=False,
145 ):
146     if runas is None:
147         if "FreeBSD" in __grains__["os_family"]:
148             runas = "postgres"
149         elif "OpenBSD" in __grains__["os_family"]:
150             runas = "_postgresql"
151         else:
152             runas = "postgres"
153     if user is None:
154         user = runas
155     _INITDB_BIN = _find_pg_binary("initdb")
156     if not _INITDB_BIN:
157         raise CommandExecutionError("initdb executable not found.")
158     cmd = [
159         _INITDB_BIN,
160         "--pgdata={}".format(name),
161         "--username={}".format(user),
162         "--auth={}".format(auth),
163         "--encoding={}".format(encoding),
164     ]
165     if locale is not None:
166         cmd.append("--locale={}".format(locale))
167     if waldir is not None:
168         cmd.append("-X")
169         cmd.append(waldir)
170     if checksums:
171         cmd.append("--data-checksums")
172     if password is not None:
173         pgpassfile = salt.utils.files.mkstemp(text=True)
174         with salt.utils.files.fopen(pgpassfile, "w") as fp_:
175             fp_.write(salt.utils.stringutils.to_str("{}".format(password)))
176             __salt__["file.chown"](pgpassfile, runas, "")
177         cmd.extend(["--pwfile={}".format(pgpassfile)])
178     kwargs = dict(runas=runas, clean_env=True)
179     cmdstr = " ".join([pipes.quote(c) for c in cmd])
180     ret = __salt__["cmd.run_all"](cmdstr, python_shell=False, **kwargs)
181     if ret.get("retcode", 0) != 0:
182         log.error("Error initilizing the postgres data directory")
183     if password is not None and not __salt__["file.remove"](pgpassfile):
184         log.warning("Removal of PGPASSFILE failed")
185     return ret
186 def version(
187     user=None, host=None, port=None, maintenance_db<font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None, password=None, runas=None
188 ):
189     query = "SELECT setting FROM pg_catalog.pg_settings WHERE name = 'server_version'"
190     cmd = _psql_cmd(
191         "-c",
192         query,
193         "-t",
194         host=host,
195         user=user,
196         port=port,
197         maintenance_db=maintenance_db,
198         password=password,
199     )
200     ret =</b></font> _run_psql(
201         cmd, runas=runas, password=password, host=host, port=port, user=user
202     )
203     for line in salt.utils.itertools.split(ret["stdout"], "\n"):
204         re<font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>turn line
205 def _parsed_version(
206     user=None, host=None, port=None, maintenance_db=None, password=None, runas=None
207 ):
208     psql_version = version(
209         user,
210         host=host,
211         port=port,
212         maintenance_db=maintenance_db,
213         password=</b></font>password,
214         runas=runas,
215     )
216     if psql_version:
217         return _LooseVersion(psql_version)
218     else:
219         log.warning(
220             "Attempt to parse version of Postgres server failed. "
221             "Is the server responding?"
222         )
223         return None
224 def _connection_defaults(user=None, host=None, port=None, maintenance_db=None):
225     if not user:
226         user = __salt__["config.option"]("postgres.user")
227     if not host:
228         host = __salt__["config.option"]("postgres.host")
229     if not port:
230         port = __salt__["config.option"]("postgres.port")
231     if not maintenance_db:
232         maintenance_db = __salt__["config.option"]("postgres.maintenance_db")
233     return (user, host, port, maintenance_db)
234 def _psql_cmd(*args, **kwargs):
235     (user, host, port, maintenance_db) = _connection_defaults(
236         kwargs.get("user"),
237         kwargs.get("host"),
238         kwargs.get("port"),
239         kwargs.get("maintenance_db"),
240     )
241     _PSQL_BIN = _find_pg_binary("psql")
242     cmd = [
243         _PSQL_BIN,
244         "--no-align",
245         "--no-readline",
246         "--no-psqlrc",
247         "--no-password",
248     ]  # Never prompt, handled in _run_psql.
249     if user:
250         cmd += ["--username", user]
251     if host:
252         cmd += ["--host", host]
253     if port:
254         cmd += ["--port", str(port)]
255     if not maintenance_db:
256         maintenance_db = "postgres"
257     cmd.extend(["--dbname", maintenance_db])
258     cmd.extend(args)
259     return cmd
260 def _psql_prepare_and_run(
261     cmd, host<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None, port=None, maintenance_db=None, password=None, runas=None, user=None
262 ):
263     rcmd = _psql_cmd(
264         host=host, user=user, port=port, maintenance_db=maintenance_db, *cmd
265     )
266     cmdret = _run_psql(
267         rcmd, runas=runas, password=password, host=host, port=port, user=</b></font>user
268     )
269     return cmdret
270 def psql_query(
271     query,
272     user=None,
273     host=None,
274     port=None,
275     maintenance_db=None,
276     password=None,
277     runas=None,
278     write=False,
279 ):
280     ret = []
281     csv_query = "COPY ({}) TO STDOUT WITH CSV HEADER".format(query.strip().rstrip(";"))
282     if write:
283         csv_query = "START TRANSACTION READ WRITE; {}; COMMIT TRANSACTION;".format(
284             csv_query
285         )
286     cmdret = _psql_prepare_and_run(
287         ["-v", "datestyle=ISO,MDY", "-c", csv_query],
288         runas=runas,
289         host=host,
290         user=user,
291         port=port,
292         maintenance_db=maintenance_db,
293         password=password,
294     )
295     if cmdret["retcode"] &gt; 0:
296         return ret
297     csv_file = io.StringIO(cmdret["stdout"])
298     header = {}
299     for row in csv.reader(
300         csv_file,
301         delimiter=salt.utils.stringutils.to_str(","),
302         quotechar=salt.utils.stringutils.to_str('"'),
303     ):
304         if not row:
305             continue
306         if not header:
307             header = row
308             continue
309         ret.append(dict(zip(header, row)))
310     if write:
311         ret = ret[0:-1]
312     return ret
313 def db_list(
314     user=None, host=None, port=None, maintenance_db=None, password=None, runas=None
315 ):
316     ret = {}
317     query = (
318         'SELECT datname as "Name", pga.rolname as "Owner", '
319         'pg_encoding_to_char(encoding) as "Encoding", '
320         'datcollate as "Collate", datctype as "Ctype", '
321         'datacl as "Access privileges", spcname as "Tablespace" '
322         "FROM pg_database pgd, pg_roles pga, pg_tablespace pgts "
323         "WHERE pga.oid = pgd.datdba AND pgts.oid = pgd.dattablespace"
324     )
325     rows = psql_query(
326         query,
327         runas=runas,
328         host=host,
329         user=user,
330         port=port,
331         maintenance_db=maintenance_db,
332         password=password,
333     )
334     for row in rows:
335         ret[row["Name"]].pop("Name")
336     <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return ret
337 def db_exists(
338     name,
339     user=None,
340     host=None,
341     port=None,
342     maintenance_db=None,
343     password=None,
344     runas=None,
345 ):
346     databases = db_list(
347         user=user,
348         host=host,
349         port=port,
350         maintenance_db=</b></font>maintenance_db,
351         password=password,
352         runas=runas,
353     )
354     return name in databases
355 def _quote_ddl_value(value, quote="'"):
356     if value is None:
357         return None
358     if quote in value:  # detect trivial sqli
359         raise SaltInvocationError(
360             "Unsupported character {} in value: {}".format(quote, value)
361         )
362     return "{quote}{value}{quote}".format(quote=quote, value=value)
363 def db_create(
364     name,
365     user=None,
366     host=None,
367     port=None,
368     maintenance_db=None,
369     password=None,
370     tablespace=None,
371     encoding=None,
372     lc_collate=None,
373     lc_ctype=None,
374     owner=None,
375     template=None,
376     runas=None,
377 ):
378     query = 'CREATE DATABASE "{}"'.format(name)
379     with_args = salt.utils.odict.OrderedDict(
380         [
381             ("TABLESPACE", _quote_ddl_value(tablespace, '"')),
382             ("OWNER", _quote_ddl_value(owner, '"')),
383             ("TEMPLATE", template),
384             ("ENCODING", _quote_ddl_value(encoding)),
385             ("LC_COLLATE", _quote_ddl_value(lc_collate)),
386             ("LC_CTYPE", _quote_ddl_value(lc_ctype)),
387         ]
388     )
389     with_chunks = []
390     for key, value in with_args.items():
391         if value is not None:
392             with_chunks += [key, "=", value]
393     if with_chunks:
394         with_chunks.insert(0, " WITH")
395         query += " ".join(with_chunks)
396     ret = _psql_prepare_and_run(
397         ["-c", query],
398         user=user,
399         host=host,
400         port=port,
401         maintenance_db=maintenance_db,
402         password=password,
403         runas=runas,
404     )
405     return ret["retcode"] == 0
406 def db_alter(
407     name,
408     user=None,
409     host=None,
410     port=None,
411     maintenance_db=None,
412     password=None,
413     tablespace=None,
414     owner=None,
415     owner_recurse=False,
416     runas=None,
417 ):
418     if not any((tablespace, owner)):
419         return True  # Nothing todo?
420     if owner and owner_recurse:
421         ret = owner_to(
422             name, owner, user=user, host=host, port=port, password=password, runas=runas
423         )
424     else:
425         queries = []
426         if owner:
427             queries.append('ALTER DATABASE "{}" OWNER TO "{}"'.format(name, owner))
428         if tablespace:
429             queries.append(
430                 'ALTER DATABASE "{}" SET TABLESPACE "{}"'.format(name, tablespace)
431             )
432         for query in queries:
433             ret = _psql_prepare_and_run(
434                 ["-c", query],
435                 user=user,
436                 host=host,
437                 port=port,
438                 maintenance_db=maintenance_db,
439                 password=password,
440                 runas=runas,
441             )
442     if ret["retcode"] != 0:
443         return False
444     return True
445 def db_remove(
446     name,
447     user=None,
448     host=None,
449     port=None,
450     maintenance_db=None,
451     password=None,
452     runas=None,
453 ):
454     for query in [
455         'REVOKE CONNECT ON DATABASE "{db}" FROM public;'.format(db=name),
456         "SELECT pid, pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname ="
457         " '{db}' AND pid &lt;&gt; pg_backend_pid();".format(db=name),
458         'DROP DATABASE "{db}";'.format(db=name),
459     ]:
460         ret = _psql_prepare_and_run(
461             ["-c", query],
462             user=user,
463             host=host,
464             port=port,
465             runas=runas,
466             maintenance_db=maintenance_db,
467             password=password,
468         )
469         if ret["retcode"] != 0:
470             raise Exception("Failed: ret={}".format(ret))
471     return True
472 def tablespace_list(
473     user=None, host=None, port=None, maintenance_db=None, password=None, runas=None
474 ):
475     ret = {}
476     query = (
477         'SELECT spcname as "Name", pga.rolname as "Owner", spcacl as "ACL", '
478         'spcoptions as "Opts", pg_tablespace_location(pgts.oid) as "Location" '
479         "FROM pg_tablespace pgts, pg_roles pga WHERE pga.oid = pgts.spcowner"
480     )
481     rows = __salt__["postgres.psql_query"](
482         query,
483         runas=runas,
484         host=host,
485         user=user,
486         port=port,
487         maintenance_db=maintenance_db,
488         password=password,
489     )
490     for row in rows:
491         ret[row["Name"]] = row
492         ret[row["Name"]].pop("Name")
493     return ret
494 def tablespace_exists(
495     name,
496     user=None,
497     host=None,
498     port=None,
499     maintenance_db=None,
500     password=None,
501     runas=None,
502 ):
503     tablespaces = tablespace_list(
504         user=user,
505         host=host,
506         port=port,
507         maintenance_db=maintenance_db,
508         password=password,
509         runas=runas,
510     )
511     return name in tablespaces
512 def tablespace_create(
513     name,
514     options=None,
515     owner=None,
516     user<font color="#842dce"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None,
517     host=None,
518     port=None,
519     maintenance_db=None,
520     password=None,
521     runas=None,
522 ):
523     owner_query = ""
524     options_query = ""
525     if owner:
526         owner_query = 'OWNER "{}"'.format(</b></font>owner)
527     if options:
528         optionstext = ["{} = {}".format(k, v) for k, v in options.items()]
529         options_query = "WITH ( {} )".format(", ".join(optionstext))
530     query = "CREATE TABLESPACE \"{}\" {} LOCATION '{}' {}".format(
531         name, owner_query, location, options_query
532     )
533     ret = _psql_prepare_and_run(
534         ["-c", query],
535         user=user,
536         host=host,
537         port=port,
538         maintenance_db=maintenance_db,
539         password=password,
540         runas=runas,
541     )
542     return ret["retcode"] == 0
543 def tablespace_alter(
544     name,
545     user=None,
546     host=None,
547     port=None,
548     maintenance_db=None,
549     password=None,
550     new_name=None,
551     new_owner=None,
552     set_option=None,
553     reset_option=None,
554     runas=None,
555 ):
556     if not any([new_name, new_owner, set_option, reset_option]):
557         return True  # Nothing todo?
558     queries = []
559     if new_name:
560         queries.append('ALTER TABLESPACE "{}" RENAME TO "{}"'.format(name, new_name))
561     if new_owner:
562         queries.append('ALTER TABLESPACE "{}" OWNER TO "{}"'.format(name, new_owner))
563     if set_option:
564         queries.append(
565             'ALTER TABLESPACE "{}" SET ({} = {})'.format(
566                 name, *(next(iter(set_option.items())))
567             )
568         )
569     if reset_option:
570         queries.append('ALTER TABLESPACE "{}" RESET ({})'.format(name, reset_option))
571     for query in queries:
572         ret = _psql_prepare_and_run(
573             ["-c", query],
574             user=user,
575             host=host,
576             port=port,
577             maintenance_db=maintenance_db,
578             password=password,
579             runas=runas,
580         )
581             return False
582     r<font color="#f52887"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>eturn True
583 def tablespace_remove(
584     name,
585     user=None,
586     host=None,
587     port=None,
588     maintenance_db=None,
589     password=None,
590     runas=None,
591 ):
592     query = 'DROP TABLESPACE "{}"'.format(name)
593     ret =</b></font> _psql_prepare_and_run(
594         ["-c", query],
595         user=user,
596         host=host,
597         port=port,
598         runas=runas,
599         password=password,
600     )
601     return ret[<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"retcode"] == 0
602 def user_list(
603     user=None,
604     host=None,
605     port=None,
606     maintenance_db=None,
607     password=None,
608     runas=None,
609     return_password=False,
610 ):
611     ret = {}
612     ver = _parsed_version(
613         user=user,
614         host=host,
615         port=port,
616         maintenance_db=maintenance_db,
617         password=</b></font>password,
618         runas=runas,
619     )
620     if ver:
621         if ver &gt;= _LooseVersion("9.1"):
622             replication_column = "pg_roles.rolreplication"
623         else:
624             replication_column = "NULL"
625         if ver &gt;= _LooseVersion("9.5"):
626             rolcatupdate_column = "NULL"
627         else:
628             rolcatupdate_column = "pg_roles.rolcatupdate"
629     else:
630         log.error("Could not retrieve Postgres version. Is Postgresql server running?")
631         return False
632     _x = lambda s: s if return_password else ""
633     query = "".join(
634         [
635             'SELECT pg_roles.rolname as "name",pg_roles.rolsuper as "superuser",'
636             ' pg_roles.rolinherit as "inherits privileges", pg_roles.rolcreaterole as'
637             ' "can create roles", pg_roles.rolcreatedb as "can create databases", {0}'
638             ' as "can update system catalogs", pg_roles.rolcanlogin as "can login", {1}'
639             ' as "replication", pg_roles.rolconnlimit as "connections", (SELECT'
640             " array_agg(pg_roles2.rolname)    FROM pg_catalog.pg_auth_members    JOIN"
641             " pg_catalog.pg_roles pg_roles2 ON (pg_auth_members.roleid = pg_roles2.oid)"
642             "    WHERE pg_auth_members.member = pg_roles.oid) as"
643             ' "groups",pg_roles.rolvaliduntil::timestamp(0) as "expiry time",'
644             ' pg_roles.rolconfig  as "defaults variables" ',
645             _x(', COALESCE(pg_shadow.passwd, pg_authid.rolpassword) as "password" '),
646             "FROM pg_roles ",
647             _x("LEFT JOIN pg_authid ON pg_roles.oid = pg_authid.oid "),
648             _x("LEFT JOIN pg_shadow ON pg_roles.oid = pg_shadow.usesysid"),
649         ]
650     ).format(rolcatupdate_column, replication_column)
651     rows = psql_query(
652         query,
653         runas=runas,
654         host=host,
655         user=user,
656         port=port,
657         maintenance_db=maintenance_db,
658         password=password,
659     )
660     def get_bool(rowdict, key):
661         if rowdict[key] == "t":
662             return True
663         elif rowdict[key] == "f":
664             return False
665         else:
666             return None
667     for row in rows:
668         retrow = {}
669         for key in (
670             "superuser",
671             "inherits privileges",
672             "can create roles",
673             "can create databases",
674             "can update system catalogs",
675             "can login",
676             "replication",
677             "connections",
678         ):
679             retrow[key] = get_bool(row, key)
680         for date_key in ("expiry time",):
681             try:
682                 retrow[date_key] = datetime.datetime.strptime(
683                     row[date_key], "%Y-%m-%d %H:%M:%S"
684                 )
685             except ValueError:
686                 retrow[date_key] = None
687         retrow["defaults variables"] = row["defaults variables"]
688         if return_password:
689         retrow["groups"] = list(csv.reader([row["groups"].strip("{}")]))[0]
690         ret[row["name"]] =<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b> retrow
691     return ret
692 def role_get(
693     name,
694     user=None,
695     host=None,
696     port=None,
697     maintenance_db=None,
698     password=None,
699     runas=None,
700     return_password=False,
701 ):
702     all_users = user_list(
703         user=user,
704         host=host,
705         port=port,
706         maintenance_db=</b></font>maintenance_db,
707         password=password,
708         runas=runas,
709         return_password=return_password,
710     )
711     try:
712         return all_users.get(name, None)
713     except AttributeError:
714         log.error("Could not retrieve Postgres role. Is Postgres running?")
715         return None
716 def user_exists(
717     name,
718     user=None,
719     host=None,
720     port=None,
721     maintenance_db=None,
722     password=None,
723     runas=None,
724 ):
725     return bool(
726         role_get(
727             name,
728             user=user,
729             host=host,
730             port=port,
731             maintenance_db=maintenance_db,
732             password=password,
733             runas=runas,
734             return_password=False,
735         )
736     )
737 def _add_role_flag(string, test, flag, cond=None, prefix="NO", addtxt="", skip=False):
738     if not skip:
739         if cond is None:
740             cond = test
741         if test is not None:
742             if cond:
743                 string = "{} {}".format(string, flag)
744             else:
745                 string = "{0} {2}{1}".format(string, flag, prefix)
746         if addtxt:
747             string = "{} {}".format(string, addtxt)
748     return string
749 def _maybe_encrypt_password(role, password, encrypted=_DEFAULT_PASSWORDS_ENCRYPTION):
750     if password is not None:
751         password = str(password)
752     else:
753         return None
754     if encrypted is True:
755         encrypted = "md5"
756     if encrypted not in (False, "md5", "scram-sha-256"):
757         raise ValueError("Unknown password algorithm: " + str(encrypted))
758     if encrypted == "scram-sha-256" and not password.startswith("SCRAM-SHA-256"):
759         password = _scram_sha_256(password)
760     elif encrypted == "md5" and not password.startswith("md5"):
761         log.warning("The md5 password algorithm was deprecated in PostgreSQL 10")
762         password = _md5_password(role, password)
763     elif encrypted is False:
764         log.warning("Unencrypted passwords were removed in PostgreSQL 10")
765     return password
766 def _verify_password(role, password, verifier, method):
767     if method == "md5" or method is True:
768         if password.startswith("md5"):
769             expected = password
770         else:
771             expected = _md5_password(role, password)
772     elif method == "scram-sha-256":
773         if password.startswith("SCRAM-SHA-256"):
774             expected = password
775         else:
776             match = re.match(r"^SCRAM-SHA-256\$(\d+):([^\$]+?)\$", verifier)
777             if match:
778                 iterations = int(match.group(1))
779                 salt_bytes = base64.b64decode(match.group(2))
780                 expected = _scram_sha_256(
781                     password, salt_bytes=salt_bytes, iterations=iterations
782                 )
783             else:
784                 expected = object()
785     elif method is False:
786         expected = password
787     else:
788         expected = object()
789     return verifier == expected
790 def _md5_password(role, password):
791     return "md5{}".format(
792         hashlib.md5(
793             salt.utils.stringutils.to_bytes("{}{}".format(password, role))
794         ).hexdigest()
795     )
796 def _scram_sha_256(password, salt_bytes=None, iterations=4096):
797     if salt_bytes is None:
798         salt_bytes = token_bytes(16)
799     password = salt.utils.stringutils.to_bytes(saslprep(password))
800     salted_password = hashlib.pbkdf2_hmac("sha256", password, salt_bytes, iterations)
801     stored_key = hmac.new(salted_password, b"Client Key", "sha256").digest()
802     stored_key = hashlib.sha256(stored_key).digest()
803     server_key = hmac.new(salted_password, b"Server Key", "sha256").digest()
804     return "SCRAM-SHA-256${}:{}${}:{}".format(
805         iterations,
806         base64.b64encode(salt_bytes).decode("ascii"),
807         base64.b64encode(stored_key).decode("ascii"),
808         base64.b64encode(server_key).decode("ascii"),
809     )
810 def _role_cmd_args(
811     name,
812     sub_cmd="",
813     typ_="role",
814     encrypted=None,
815     login=None,
816     connlimit=None,
817     inherit=None,
818     createdb=None,
819     createroles=None,
820     superuser=None,
821     groups=None,
822     replication=None,
823     rolepassword=None,
824     valid_until=None,
825     db_role=None,
826 ):
827     if inherit is None:
828         if typ_ in ["user", "group"]:
829             inherit = True
830     if login is None:
831         if typ_ == "user":
832             login = True
833         if typ_ == "group":
834             login = False
835     if encrypted is None:
836         encrypted = _DEFAULT_PASSWORDS_ENCRYPTION
837     skip_passwd = False
838     escaped_password = ""
839     escaped_valid_until = ""
840     if not (
841         rolepassword is not None
842         and (isinstance(rolepassword, str) and bool(rolepassword))
843         or (isinstance(rolepassword, bool))
844     ):
845         skip_passwd = True
846     if isinstance(rolepassword, str) and bool(rolepassword):
847         escaped_password = "'{}'".format(
848             _maybe_encrypt_password(
849                 name, rolepassword.replace("'", "''"), encrypted=encrypted
850             )
851         )
852     if isinstance(valid_until, str) and bool(valid_until):
853         escaped_valid_until = "'{}'".format(
854             valid_until.replace("'", "''"),
855         )
856     skip_superuser = False
857     if bool(db_role) and bool(superuser) == bool(db_role["superuser"]):
858         skip_superuser = True
859     flags = (
860         {"flag": "INHERIT", "test": inherit},
861         {"flag": "CREATEDB", "test": createdb},
862         {"flag": "CREATEROLE", "test": createroles},
863         {"flag": "SUPERUSER", "test": superuser, "skip": skip_superuser},
864         {"flag": "REPLICATION", "test": replication},
865         {"flag": "LOGIN", "test": login},
866         {
867             "flag": "CONNECTION LIMIT",
868             "test": bool(connlimit),
869             "addtxt": str(connlimit),
870             "skip": connlimit is None,
871         },
872         {
873             "flag": "ENCRYPTED",
874             "test": (encrypted is not None and bool(rolepassword)),
875             "skip": skip_passwd or isinstance(rolepassword, bool),
876             "cond": bool(encrypted),
877             "prefix": "UN",
878         },
879         {
880             "flag": "PASSWORD",
881             "test": bool(rolepassword),
882             "skip": skip_passwd,
883             "addtxt": escaped_password,
884         },
885         {
886             "flag": "VALID UNTIL",
887             "test": bool(valid_until),
888             "skip": valid_until is None,
889             "addtxt": escaped_valid_until,
890         },
891     )
892     for data in flags:
893         sub_cmd = _add_role_flag(sub_cmd, **data)
894     if sub_cmd.endswith("WITH"):
895         sub_cmd = sub_cmd.replace(" WITH", "")
896     if groups:
897         if isinstance(groups, list):
898         for group in groups.split(","):
899             sub_cmd = '{}; GRANT "{}" TO "{}"'.format(sub_cmd, group, name)
900     r<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>eturn sub_cmd
901 def _role_create(
902     name,
903     user=None,
904     host=None,
905     port=None,
906     maintenance_db=None,
907     password=None,
908     createdb=None,
909     createroles=None,
910     encrypted=None,
911     superuser=None,
912     login=None,
913     connlimit=None,
914     inherit=None,
915     replication=None,
916     rolepassword=None,
917     valid_until=None,
918     typ_="role",
919     groups=</b></font>None,
920     runas=None,
921 ):
922     if user_exists(
923         name, user, host, port, maintenance_db, password=password, runas=runas
924     ):
925         log.info("%s '%s' already exists", typ_.capitalize(), name)
926         return False
927     sub_cmd = 'CREATE ROLE "{}" WITH'.format(name)
928     sub_cmd = "{} {}".format(
929         sub_cmd,
930         _role_cmd_args(
931             name,
932             typ_=typ_,
933             encrypted=encrypted,
934             login=login,
935             connlimit=connlimit,
936             inherit=inherit,
937             createdb=createdb,
938             createroles=createroles,
939             superuser=superuser,
940             groups=groups,
941             replication=replication,
942             rolepassword=rolepassword,
943             valid_until=valid_until,
944         ),
945     )
946     ret = _psql_prepare_and_run(
947         ["-c", sub_cmd],
948         runas=runas,
949         host=host,
950         user=user,
951         port=port,
952         maintenance_db=maintenance_db,
953         password=password,
954     )
955     return ret["retcode"] == 0
956 def user_create(
957     username,
958     user=None,
959     host=None,
960     port=None,
961     maintenance_db=None,
962     password=None,
963     createdb=None,
964     createroles=None,
965     inherit=None,
966     login=None,
967     connlimit=None,
968     encrypted=None,
969     superuser=None,
970     replication=None,
971     rolepassword=None,
972     valid_until=None,
973     groups=None,
974     runas=None,
975 ):
976     return _role_create(
977         username,
978         typ_="user",
979         user=user,
980         host=host,
981         port=port,
982         maintenance_db=maintenance_db,
983         password=password,
984         createdb=createdb,
985         createroles=createroles,
986         inherit=inherit,
987         login=login,
988         connlimit=connlimit,
989         encrypted=encrypted,
990         superuser=superuser,
991         replication=replication,
992         rolepassword=rolepassword,
993         valid_until=valid_until,
994         groups=groups,
995         runas=runas,
996     )
997 def _role_update(
998     user=None,
999     host=None,
1000     port<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None,
1001     maintenance_db=None,
1002     password=None,
1003     createdb=None,
1004     typ_="role",
1005     createroles=None,
1006     inherit=None,
1007     login=None,
1008     connlimit=None,
1009     encrypted=None,
1010     superuser=None,
1011     replication=None,
1012     rolepassword=None,
1013     valid_until=None,
1014     groups=None,
1015     runas=None,
1016 ):
1017     role = role_get(
1018         name,
1019         user=user,
1020         host=host,
1021         port=port,
1022         maintenance_db=maintenance_db,
1023         password=</b></font>password,
1024         runas=runas,
1025         return_password=False,
1026     )
1027     if not bool(role):
1028         log.info("%s '%s' could not be found", typ_.capitalize(), name)
1029         return False
1030     sub_cmd = 'ALTER ROLE "{}" WITH'.format(name)
1031     sub_cmd = "{} {}".format(
1032         sub_cmd,
1033         _role_cmd_args(
1034             name,
1035             encrypted=encrypted,
1036             login=login,
1037             connlimit=connlimit,
1038             inherit=inherit,
1039             createdb=createdb,
1040             createroles=createroles,
1041             superuser=superuser,
1042             groups=groups,
1043             replication=replication,
1044             rolepassword=rolepassword,
1045             valid_until=valid_until,
1046             db_role=role,
1047         ),
1048     )
1049     ret = _psql_prepare_and_run(
1050         ["-c", sub_cmd],
1051         runas=runas,
1052         host=host,
1053         user=user,
1054         port=port,
1055         maintenance_db=maintenance_db,
1056         password=password,
1057     )
1058     return ret["retcode"] == 0
1059 def user_update(
1060     username,
1061     user=None,
1062     host=None,
1063     port=None,
1064     maintenance_db=None,
1065     password=None,
1066     createdb=None,
1067     createroles=None,
1068     encrypted=None,
1069     superuser=None,
1070     inherit=None,
1071     login=None,
1072     connlimit=None,
1073     replication=None,
1074     rolepassword=None,
1075     valid_until=None,
1076     groups=None,
1077     runas=None,
1078 ):
1079     return _role_update(
1080         username,
1081         user=user,
1082         host=host,
1083         port=port,
1084         maintenance_db=maintenance_db,
1085         password=password,
1086         typ_="user",
1087         inherit=inherit,
1088         login=login,
1089         connlimit=connlimit,
1090         createdb=createdb,
1091         createroles=createroles,
1092         encrypted=encrypted,
1093         superuser=superuser,
1094         replication=replication,
1095         rolepassword=rolepassword,
1096         valid_until=valid_until,
1097         groups=groups,
1098         runas=runas,
1099     )
1100 def _role_remove(
1101     name,
1102     user=None,
1103     host=None,
1104     port=None,
1105     maintenance_db=None,
1106     password=None,
1107     runas=None,
1108 ):
1109     if not user_exists(
1110         name, user, host, port, maintenance_db, password=password, runas=runas
1111     ):
1112         log.info("User '%s' does not exist", name)
1113         return False
1114     sub_cmd = 'DROP ROLE "{}"'.format(name)
1115     _psql_prepare_and_run(
1116         ["-c", sub_cmd],
1117         runas=runas,
1118         host=host,
1119         user=user,
1120         port=port,
1121         maintenance_db=maintenance_db,
1122         password=password,
1123     )
1124     if not user_exists(
1125         name, user, host, port, maintenance_db, password=password, runas=runas
1126         return True
1127     else:
1128         log<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.info("Failed to delete user '%s'.", name)
1129         return False
1130 def available_extensions(
1131     user=None, host=None, port=None, maintenance_db=None, password=None, runas=None
1132 ):
1133     exts = []
1134     query = "select * from pg_available_extensions();"
1135     ret = psql_query(
1136         query,
1137         user=user,
1138         host=host,
1139         port=port,
1140         maintenance_db=maintenance_db,
1141         password=</b></font>password,
1142         runas=runas,
1143     )
1144     exts = {}
1145     for row in ret:
1146         if "default_version" in row and "name" in row:
1147             exts[row["name"]] = row
1148     return exts
1149 def installed_extensions(
1150     user=None, host=None, port=None, maintenance_db=None, password=None, runas=None
1151 ):
1152     exts = []
1153     query = (
1154         "select a.*, b.nspname as schema_name "
1155         "from pg_extension a,  pg_namespace b where a.extnamespace = b.oid;"
1156     )
1157     ret = psql_query(
1158         query,
1159         user=user,
1160         host=host,
1161         port=port,
1162         maintenance_db=maintenance_db,
1163         password=password,
1164         runas=runas,
1165     )
1166     exts = {}
1167     for row in ret:
1168         if "extversion" in row and "extname" in row:
1169             exts[row["extname"]] = row
1170     return exts
1171 def get_available_extension(
1172     name,
1173     user=None,
1174     host=None,
1175     port=None,
1176     maintenance_db=None,
1177     password=None,
1178     runas=None,
1179 ):
1180     return available_extensions(
1181         user=user,
1182         host=host,
1183         port=port,
1184         maintenance_db=maintenance_db,
1185         password=password,
1186         runas=runas,
1187     ).get(name, None)
1188 def get_installed_extension(
1189     name,
1190     user=None,
1191     host=None,
1192     port=None,
1193     maintenance_db=None,
1194     password=None,
1195     runas=None,
1196 ):
1197     return installed_extensions(
1198         user=user,
1199         host=host,
1200         port=port,
1201         maintenance_db=maintenance_db,
1202         password=password,
1203         runas=runas,
1204     ).get(name, None)
1205 def is_available_extension(
1206     name,
1207     user=None,
1208     host=None,
1209     port=None,
1210     maintenance_db=None,
1211     password=None,
1212     runas=None,
1213 ):
1214     exts = available_extensions(
1215         user=user,
1216         host=host,
1217         port=port,
1218         maintenance_db=maintenance_db,
1219         password=password,
1220         runas=runas,
1221     )
1222     if name.lower() in [a.lower() for a in exts]:
1223         return True
1224     return False
1225 def _pg_is_older_ext_ver(a, b):
1226     return _LooseVersion(a) &lt; _LooseVersion(b)
1227 def is_installed_extension(
1228     name,
1229     user=None,
1230     host=None,
1231     port=None,
1232     maintenance_db=None,
1233     password=None,
1234     runas=None,
1235 ):
1236     installed_ext = get_installed_extension(
1237         name,
1238         user=user,
1239         host=host,
1240         port=port,
1241         maintenance_db=maintenance_db,
1242         runas=runas,
1243     )
1244     return bool(<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>installed_ext)
1245 def create_metadata(
1246     name,
1247     ext_version=None,
1248     schema=None,
1249     user=None,
1250     host=None,
1251     port=None,
1252     maintenance_db=None,
1253     password=None,
1254     runas=None,
1255 ):
1256     installed_ext = get_installed_extension(
1257         name,
1258         user=user,
1259         host=host,
1260         port=port,
1261         maintenance_db=maintenance_db,
1262         password=</b></font>password,
1263         runas=runas,
1264     )
1265     ret = [_EXTENSION_NOT_INSTALLED]
1266     if installed_ext:
1267         ret = [_EXTENSION_INSTALLED]
1268         if ext_version is not None and _pg_is_older_ext_ver(
1269             installed_ext.get("extversion", ext_version), ext_version
1270         ):
1271             ret.append(_EXTENSION_TO_UPGRADE)
1272         if (
1273             schema is not None
1274             and installed_ext.get("extrelocatable", "f") == "t"
1275             and installed_ext.get("schema_name", schema) != schema
1276         ):
1277             ret.append(_EXTENSION_TO_MOVE)
1278     return ret
1279 def drop_extension(
1280     name,
1281     if_exists=None,
1282     restrict=None,
1283     cascade=None,
1284     user=None,
1285     host=None,
1286     port=None,
1287     maintenance_db=None,
1288     password=None,
1289     runas=None,
1290 ):
1291     if cascade is None:
1292         cascade = True
1293     if if_exists is None:
1294         if_exists = False
1295     if restrict is None:
1296         restrict = False
1297     args = ["DROP EXTENSION"]
1298     if if_exists:
1299         args.append("IF EXISTS")
1300     args.append(name)
1301     if cascade:
1302         args.append("CASCADE")
1303     if restrict:
1304         args.append("RESTRICT")
1305     args.append(";")
1306     cmd = " ".join(args)
1307     if is_installed_extension(
1308         name,
1309         user=user,
1310         host=host,
1311         port=port,
1312         maintenance_db=maintenance_db,
1313         password=password,
1314         runas=runas,
1315     ):
1316         _psql_prepare_and_run(
1317             ["-c", cmd],
1318             runas=runas,
1319             host=host,
1320             user=user,
1321             port=port,
1322             maintenance_db=maintenance_db,
1323             password=password,
1324         )
1325     ret = not is_installed_extension(
1326         name,
1327         user=user,
1328         host=host,
1329         port=port,
1330         maintenance_db=maintenance_db,
1331         password=password,
1332         runas=runas,
1333     )
1334     if not ret:
1335         log.info("Failed to drop ext: %s", name)
1336     return ret
1337 def create_extension(
1338     name,
1339     if_not_exists=None,
1340     schema=None,
1341     ext_version=None,
1342     from_version=None,
1343     user=None,
1344     host=None,
1345     port=None,
1346     maintenance_db=None,
1347     password=None,
1348     runas=None,
1349 ):
1350     if if_not_exists is None:
1351         if_not_exists = True
1352         name,
1353         ext_version=ext_version,
1354         schema<font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=schema,
1355         user=user,
1356         host=host,
1357         port=port,
1358         maintenance_db=maintenance_db,
1359         password=password,
1360         runas=runas,
1361     )
1362     installed = _EXTENSION_NOT_INSTALLED not in mtdata
1363     installable = is_available_extension(
1364         name,
1365         user=user,
1366         host=host,
1367         port=port,
1368         maintenance_db=maintenance_db,
1369         password=</b></font>password,
1370         runas=runas,
1371     )
1372     if installable:
1373         if not installed:
1374             args = ["CREATE EXTENSION"]
1375             if if_not_exists:
1376                 args.append("IF NOT EXISTS")
1377             args.append('"{}"'.format(name))
1378             sargs = []
1379             if schema:
1380                 sargs.append('SCHEMA "{}"'.format(schema))
1381             if ext_version:
1382                 sargs.append("VERSION {}".format(ext_version))
1383             if from_version:
1384                 sargs.append("FROM {}".format(from_version))
1385             if sargs:
1386                 args.append("WITH")
1387                 args.extend(sargs)
1388             args.append(";")
1389             cmd = " ".join(args).strip()
1390         else:
1391             args = []
1392             if schema and _EXTENSION_TO_MOVE in mtdata:
1393                 args.append(
1394                     'ALTER EXTENSION "{}" SET SCHEMA "{}";'.format(name, schema)
1395                 )
1396             if ext_version and _EXTENSION_TO_UPGRADE in mtdata:
1397                 args.append(
1398                     'ALTER EXTENSION "{}" UPDATE TO {};'.format(name, ext_version)
1399                 )
1400             cmd = " ".join(args).strip()
1401         if cmd:
1402             _psql_prepare_and_run(
1403                 ["-c", cmd],
1404                 runas=runas,
1405                 host=host,
1406                 user=user,
1407                 port=port,
1408                 maintenance_db=maintenance_db,
1409                 password=password,
1410             )
1411     mtdata = create_metadata(
1412         name,
1413         ext_version=ext_version,
1414         schema=schema,
1415         user=user,
1416         host=host,
1417         port=port,
1418         maintenance_db=maintenance_db,
1419         password=password,
1420         runas=runas,
1421     )
1422     ret = True
1423     for i in _EXTENSION_FLAGS:
1424         if (i in mtdata) and (i != _EXTENSION_INSTALLED):
1425             ret = False
1426     if not ret:
1427         log.info("Failed to create ext: %s", name)
1428     return ret
1429 def user_remove(
1430     username,
1431     user=None,
1432     host=None,
1433     port=None,
1434     maintenance_db=None,
1435     password=None,
1436     runas=None,
1437 ):
1438     return _role_remove(
1439         username,
1440         user=user,
1441         host=host,
1442         port=port,
1443         maintenance_db=maintenance_db,
1444         password=password,
1445         runas=runas,
1446     )
1447 def group_create(
1448     groupname,
1449     user=None,
1450     host=None,
1451     port=None,
1452     maintenance_db=None,
1453     password=None,
1454     createdb=None,
1455     createroles=None,
1456     encrypted=None,
1457     login=None,
1458     inherit=None,
1459     superuser=None,
1460     replication=None,
1461     rolepassword=None,
1462     groups=None,
1463     runas=None,
1464 ):
1465     return _role_create(
1466         groupname,
1467         user=user,
1468         typ_="group",
1469         host=host,
1470         port=port,
1471         maintenance_db=maintenance_db,
1472         password=password,
1473         createdb=createdb,
1474         createroles=createroles,
1475         encrypted=encrypted,
1476         login=login,
1477         inherit=inherit,
1478         superuser=superuser,
1479         replication=replication,
1480         rolepassword=rolepassword,
1481         groups=groups,
1482         runas=runas,
1483     )
1484 def group_update(
1485     groupname,
1486     user=None,
1487     host=None,
1488     port=None,
1489     maintenance_db=None,
1490     password=None,
1491     createdb=None,
1492     createroles=None,
1493     encrypted=None,
1494     inherit=None,
1495     login=None,
1496     superuser=None,
1497     replication=None,
1498     rolepassword=None,
1499     groups=None,
1500     runas=None,
1501 ):
1502     return _role_update(
1503         groupname,
1504         user=user,
1505         host=host,
1506         port=port,
1507         maintenance_db=maintenance_db,
1508         password=password,
1509         createdb=createdb,
1510         typ_="group",
1511         createroles=createroles,
1512         encrypted=encrypted,
1513         login=login,
1514         inherit=inherit,
1515         superuser=superuser,
1516         replication=replication,
1517         rolepassword=rolepassword,
1518         groups=groups,
1519         runas=runas,
1520     )
1521 def group_remove(
1522     groupname,
1523     user=None,
1524     host=None,
1525     port=None,
1526     maintenance_db=None,
1527     password=None,
1528     runas=None,
1529 ):
1530     return _role_remove(
1531         groupname,
1532         user=user,
1533         host=host,
1534         port=port,
1535         maintenance_db=maintenance_db,
1536         password=password,
1537         runas=runas,
1538     )
1539 def owner_to(
1540     dbname, ownername, user=None, host=None, port=None, password=None, runas=None
1541 ):
1542     sqlfile = tempfile.NamedTemporaryFile()
1543     sqlfile.write("begin;\n")
1544     sqlfile.write('alter database "{}" owner to "{}";\n'.format(dbname, ownername))
1545     queries = (
1546         (
1547             "alter schema {n} owner to {owner};",
1548             "select quote_ident(schema_name) as n from information_schema.schemata;",
1549         ),
1550         (
1551             "alter table {n} owner to {owner};",
1552             "select quote_ident(table_schema)||'.'||quote_ident(table_name) as "
1553             "n from information_schema.tables where table_schema not in "
1554             "('pg_catalog', 'information_schema');",
1555         ),
1556         (
1557             "alter function {n} owner to {owner};",
1558             "select p.oid::regprocedure::text as n from pg_catalog.pg_proc p "
1559             "join pg_catalog.pg_namespace ns on p.pronamespace=ns.oid where "
1560             "ns.nspname not in ('pg_catalog', 'information_schema') "
1561             " and not p.proisagg;",
1562         ),
1563         (
1564             "alter aggregate {n} owner to {owner};",
1565             "select p.oid::regprocedure::text as n from pg_catalog.pg_proc p "
1566             "join pg_catalog.pg_namespace ns on p.pronamespace=ns.oid where "
1567             "ns.nspname not in ('pg_catalog', 'information_schema') "
1568             "and p.proisagg;",
1569         ),
1570         (
1571             "alter sequence {n} owner to {owner};",
1572             "select quote_ident(sequence_schema)||'.'||"
1573             "quote_ident(sequence_name) as n from information_schema.sequences;",
1574         ),
1575     )
1576     for fmt, query in queries:
1577         ret = psql_query(
1578             query,
1579             user=user,
1580             host=host,
1581             port=port,
1582             maintenance_db=dbname,
1583             password=password,
1584             runas=runas,
1585         )
1586         for row in ret:
1587             sqlfile.write(fmt.format(owner=ownername, n=row["n"]) + "\n")
1588     sqlfile.write("commit;\n")
1589     sqlfile.flush()
1590     os.chmod(sqlfile.name, 0o644)  # ensure psql can read the file
1591     cmdret = _psql_prepare_and_run(
1592         ["-f", sqlfile.name],
1593         user=user,
1594         runas=runas,
1595         host=host,
1596         port=port,
1597         password=password,
1598         maintenance_db=dbname,
1599     )
1600     return cmdret
1601 def schema_create(
1602     dbname,
1603     name,
1604     owner=None,
1605     user=None,
1606     db_user=None,
1607     db_password=None,
1608     db_host=None,
1609     db_port=None,
1610 ):
1611     if schema_exists(
1612         dbname,
1613         name,
1614         user=user,
1615         db_user=db_user,
1616         db_password=db_password,
1617         db_host=db_host,
1618         db_port=db_port,
1619     ):
1620         log.info("'%s' already exists in '%s'", name, dbname)
1621         return False
1622     sub_cmd = 'CREATE SCHEMA "{}"'.format(name)
1623     if owner is not None:
1624         sub_cmd = '{} AUTHORIZATION "{}"'.format(sub_cmd, owner)
1625     ret = _psql_prepare_and_run(
1626         ["-c", sub_cmd],
1627         user=db_user,
1628         password=db_password,
1629         port=db_port,
1630         host=db_host,
1631         maintenance_db=dbname,
1632         runas=user,
1633     )
1634     return ret["retcode"] == 0
1635 def schema_remove(
1636     dbname, name, user=None, db_user=None, db_password=None, db_host=None, db_port=None
1637 ):
1638     if not schema_exists(
1639         dbname,
1640         name,
1641         user=None,
1642         db_user=db_user,
1643         db_password=db_password,
1644         db_host=db_host,
1645         db_port=db_port,
1646     ):
1647         log.info("Schema '%s' does not exist in '%s'", name, dbname)
1648         return False
1649     sub_cmd = 'DROP SCHEMA "{}"'.format(name)
1650     _psql_prepare_and_run(
1651         ["-c", sub_cmd],
1652         runas=user,
1653         maintenance_db=dbname,
1654         host=db_host,
1655         user=db_user,
1656         port=db_port,
1657         password=db_password,
1658     )
1659     if not schema_exists(
1660         dbname,
1661         name,
1662         user,
1663         db_user=db_user,
1664         db_password=db_password,
1665         db_port=db_port,
1666     ):
1667         <font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return True
1668     else:
1669         log.info("Failed to delete schema '%s'.", name)
1670         return False
1671 def schema_exists(
1672     dbname, name, user=None, db_user=None, db_password=None, db_host=None, db_port=</b></font>None
1673 ):
1674     return bool(
1675         schema_get(
1676             dbname,
1677             name,
1678             user=user,
1679             db_user=db_user,
1680             db_host=db_host,
1681             db_port=db_port,
1682             db_password=db_password,
1683         )
1684     )
1685 def schema_get(
1686     dbname, name, user=None, db_user=None, db_password=None, db_host=None, db_port=None
1687 ):
1688     all_schemas = schema_list(
1689         dbname,
1690         user=user,
1691         db_user=db_user,
1692         db_host=db_host,
1693         db_port=db_port,
1694         db_password=db_password,
1695     )
1696     try:
1697         return all_schemas.get(name, None)
1698     except AttributeError:
1699         log.error("Could not retrieve Postgres schema. Is Postgres running?")
1700         return False
1701 def schema_list(
1702     dbname, user=None, db_user=None, db_password=None, db_host=None, db_port=None
1703 ):
1704     ret = {}
1705     query = "".join(
1706         [
1707             "SELECT "
1708             'pg_namespace.nspname as "name",'
1709             'pg_namespace.nspacl as "acl", '
1710             'pg_roles.rolname as "owner" '
1711             "FROM pg_namespace "
1712             "LEFT JOIN pg_roles ON pg_roles.oid = pg_namespace.nspowner "
1713         ]
1714     )
1715     rows = psql_query(
1716         query,
1717         runas=user,
1718         host=db_host,
1719         user=db_user,
1720         port=db_port,
1721         maintenance_db=dbname,
1722         password=db_password,
1723     )
1724     for row in rows:
1725         retrow = {}
1726         for key in ("owner", "acl"):
1727             retrow[key] = row[key]
1728         ret[row["name"]] = retrow
1729     return ret
1730 def language_list(
1731     maintenance_db, user=None, host=None, port=None, password=None, runas=None
1732 ):
1733     ret = {}
1734     query = 'SELECT lanname AS "Name" FROM pg_language'
1735     rows = psql_query(
1736         query,
1737         runas=runas,
1738         host=host,
1739         user=user,
1740         port=port,
1741         maintenance_db=maintenance_db,
1742         password=password,
1743     )
1744     for row in rows:
1745         ret[row["Name"]] = row["Name"]
1746     return ret
1747 def language_exists(
1748     name, maintenance_db, user=None, host=None, port=None, password=None, runas=None
1749 ):
1750     languages = language_list(
1751         maintenance_db, user=user, host=host, port=port, password=password, runas=runas
1752     )
1753     return name in languages
1754 def language_create(
1755     name, maintenance_db, user=None, host=None, port=None, password=None, runas=None
1756 ):
1757     if language_exists(name, maintenance_db):
1758         log.info("Language %s already exists in %s", name, maintenance_db)
1759         return False
1760     query = "CREATE LANGUAGE {}".format(name)
1761     ret = _psql_prepare_and_run(
1762         ["-c", query],
1763         user=user,
1764         host=host,
1765         port=port,
1766         maintenance_db=maintenance_db,
1767         password=password,
1768         runas=runas,
1769     )
1770     return ret["retcode"] == 0
1771 def language_remove(
1772     name, maintenance_db, user=None, host=None, port=None, password=None, runas=None
1773 ):
1774     if not language_exists(name, maintenance_db):
1775         log.info("Language %s does not exist in %s", name, maintenance_db)
1776         return False
1777     query = "DROP LANGUAGE {}".format(name)
1778     ret = _psql_prepare_and_run(
1779         ["-c", query],
1780         user=user,
1781         host=host,
1782         port=port,
1783         runas=runas,
1784         maintenance_db=maintenance_db,
1785         password=password,
1786     )
1787     return ret["retcode"] == 0
1788 def _make_privileges_list_query(name, object_type, prepend):
1789     if object_type == "table":
1790         query = (
1791             " ".join(
1792                 [
1793                     "SELECT relacl AS name",
1794                     "FROM pg_catalog.pg_class c",
1795                     "JOIN pg_catalog.pg_namespace n",
1796                     "ON n.oid = c.relnamespace",
1797                     "WHERE nspname = '{0}'",
1798                     "AND relname = '{1}'",
1799                     "AND relkind = 'r'",
1800                     "ORDER BY relname",
1801                 ]
1802             )
1803         ).format(prepend, name)
1804     elif object_type == "sequence":
1805         query = (
1806             " ".join(
1807                 [
1808                     "SELECT relacl AS name",
1809                     "FROM pg_catalog.pg_class c",
1810                     "JOIN pg_catalog.pg_namespace n",
1811                     "ON n.oid = c.relnamespace",
1812                     "WHERE nspname = '{0}'",
1813                     "AND relname = '{1}'",
1814                     "AND relkind = 'S'",
1815                     "ORDER BY relname",
1816                 ]
1817             )
1818         ).format(prepend, name)
1819     elif object_type == "schema":
1820         query = (
1821             " ".join(
1822                 [
1823                     "SELECT nspacl AS name",
1824                     "FROM pg_catalog.pg_namespace",
1825                     "WHERE nspname = '{0}'",
1826                     "ORDER BY nspname",
1827                 ]
1828             )
1829         ).format(name)
1830     elif object_type == "function":
1831         query = (
1832             " ".join(
1833                 [
1834                     "SELECT proacl AS name",
1835                     "FROM pg_catalog.pg_proc p",
1836                     "JOIN pg_catalog.pg_namespace n",
1837                     "ON n.oid = p.pronamespace",
1838                     "WHERE nspname = '{0}'",
1839                     "AND p.oid::regprocedure::text = '{1}'",
1840                     "ORDER BY proname, proargtypes",
1841                 ]
1842             )
1843         ).format(prepend, name)
1844     elif object_type == "tablespace":
1845         query = (
1846             " ".join(
1847                 [
1848                     "SELECT spcacl AS name",
1849                     "FROM pg_catalog.pg_tablespace",
1850                     "WHERE spcname = '{0}'",
1851                     "ORDER BY spcname",
1852                 ]
1853             )
1854         ).format(name)
1855     elif object_type == "language":
1856         query = (
1857             " ".join(
1858                 [
1859                     "SELECT lanacl AS name",
1860                     "FROM pg_catalog.pg_language",
1861                     "WHERE lanname = '{0}'",
1862                     "ORDER BY lanname",
1863                 ]
1864             )
1865         ).format(name)
1866     elif object_type == "database":
1867         query = (
1868             " ".join(
1869                 [
1870                     "SELECT datacl AS name",
1871                     "FROM pg_catalog.pg_database",
1872                     "WHERE datname = '{0}'",
1873                     "ORDER BY datname",
1874                 ]
1875             )
1876         ).format(name)
1877     elif object_type == "group":
1878         query = (
1879             " ".join(
1880                 [
1881                     "SELECT rolname, admin_option",
1882                     "FROM pg_catalog.pg_auth_members m",
1883                     "JOIN pg_catalog.pg_roles r",
1884                     "ON m.member=r.oid",
1885                     "WHERE m.roleid IN",
1886                     "(SELECT oid",
1887                     "FROM pg_catalog.pg_roles",
1888                     "WHERE rolname='{0}')",
1889                     "ORDER BY rolname",
1890                 ]
1891             )
1892         ).format(name)
1893     return query
1894 def _get_object_owner(
1895     name,
1896     object_type,
1897     prepend="public",
1898     maintenance_db=None,
1899     user=None,
1900     host=None,
1901     port=None,
1902     password=None,
1903     runas=None,
1904 ):
1905     if object_type == "table":
1906         query = (
1907             " ".join(
1908                 [
1909                     "SELECT tableowner AS name",
1910                     "FROM pg_tables",
1911                     "WHERE schemaname = '{0}'",
1912                     "AND tablename = '{1}'",
1913                 ]
1914             )
1915         ).format(prepend, name)
1916     elif object_type == "sequence":
1917         query = (
1918             " ".join(
1919                 [
1920                     "SELECT rolname AS name",
1921                     "FROM pg_catalog.pg_class c",
1922                     "JOIN pg_roles r",
1923                     "ON c.relowner = r.oid",
1924                     "JOIN pg_catalog.pg_namespace n",
1925                     "ON n.oid = c.relnamespace",
1926                     "WHERE relkind='S'",
1927                     "AND nspname='{0}'",
1928                     "AND relname = '{1}'",
1929                 ]
1930             )
1931         ).format(prepend, name)
1932     elif object_type == "schema":
1933         query = (
1934             " ".join(
1935                 [
1936                     "SELECT rolname AS name",
1937                     "FROM pg_namespace n",
1938                     "JOIN pg_roles r",
1939                     "ON n.nspowner = r.oid",
1940                     "WHERE nspname = '{0}'",
1941                 ]
1942             )
1943         ).format(name)
1944     elif object_type == "function":
1945         query = (
1946             " ".join(
1947                 [
1948                     "SELECT rolname AS name",
1949                     "FROM pg_catalog.pg_proc p",
1950                     "JOIN pg_catalog.pg_namespace n",
1951                     "ON n.oid = p.pronamespace",
1952                     "WHERE nspname = '{0}'",
1953                     "AND p.oid::regprocedure::text = '{1}'",
1954                     "ORDER BY proname, proargtypes",
1955                 ]
1956             )
1957         ).format(prepend, name)
1958     elif object_type == "tablespace":
1959         query = (
1960             " ".join(
1961                 [
1962                     "SELECT rolname AS name",
1963                     "FROM pg_tablespace t",
1964                     "JOIN pg_roles r",
1965                     "ON t.spcowner = r.oid",
1966                     "WHERE spcname = '{0}'",
1967                 ]
1968             )
1969         ).format(name)
1970     elif object_type == "language":
1971         query = (
1972             " ".join(
1973                 [
1974                     "SELECT rolname AS name",
1975                     "FROM pg_language l",
1976                     "JOIN pg_roles r",
1977                     "ON l.lanowner = r.oid",
1978                     "WHERE lanname = '{0}'",
1979                 ]
1980             )
1981         ).format(name)
1982     elif object_type == "database":
1983         query = (
1984             " ".join(
1985                 [
1986                     "SELECT rolname AS name",
1987                     "FROM pg_database d",
1988                     "JOIN pg_roles r",
1989                     "ON d.datdba = r.oid",
1990                     "WHERE datname = '{0}'",
1991                 ]
1992             )
1993         ).format(name)
1994     rows = psql_query(
1995         query,
1996         runas=runas,
1997         host=host,
1998         user=user,
1999         port=port,
2000         maintenance_db=maintenance_db,
2001         password=password,
2002     )
2003     try:
2004         ret = rows[0]["name"]
2005     except IndexError:
2006         ret = None
2007     return ret
2008 def _validate_privileges(object_type, privs, privileges):
2009     if object_type != "group":
2010         _perms = [_PRIVILEGES_MAP[perm] for perm in _PRIVILEGE_TYPE_MAP[object_type]]
2011         _perms.append("ALL")
2012         if object_type not in _PRIVILEGES_OBJECTS:
2013             raise SaltInvocationError(
2014                 "Invalid object_type: {} provided".format(object_type)
2015             )
2016         if not set(privs).issubset(set(_perms)):
2017             raise SaltInvocationError(
2018                 "Invalid privilege(s): {} provided for object {}".format(
2019                     privileges, object_type
2020                 )
2021             )
2022     else:
2023         if privileges:
2024             raise SaltInvocationError(
2025                 "The privileges option should not be set for object_type group"
2026             )
2027 def _mod_priv_opts(object_type, privileges):
2028     object_type = object_type.lower()
2029     privileges = "" if privileges is None else privileges
2030     _privs = re.split(r"\s?,\s?", privileges.upper())
2031     return object_type, privileges, _privs
2032 def _process_priv_part(perms):
2033     _tmp = {}
2034     previous = None
2035     for perm in perms:
2036         if previous is None:
2037             _tmp[_PRIVILEGES_MAP[perm]] = False
2038             previous = _PRIVILEGES_MAP[perm]
2039         else:
2040             if perm == "*":
2041                 _tmp[previous] = True
2042             else:
2043                 _tmp[_PRIVILEGES_MAP[perm]] = False
2044                 previous = _PRIVILEGES_MAP[perm]
2045     return _tmp
2046 def privileges_list(
2047     name,
2048     object_type,
2049     prepend="public",
2050     maintenance_db=None,
2051     user=None,
2052     host=None,
2053     port=None,
2054     password=None,
2055     runas=None,
2056 ):
2057     object_type = object_type.lower()
2058     query = _make_privileges_list_query(name, object_type, prepend)
2059     if object_type not in _PRIVILEGES_OBJECTS:
2060         raise SaltInvocationError(
2061             "Invalid object_type: {} provided".format(object_type)
2062         )
2063     rows = psql_query(
2064         query,
2065         runas=runas,
2066         host=host,
2067         user=user,
2068         port=port,
2069         maintenance_db=maintenance_db,
2070         password=password,
2071     )
2072     ret = {}
2073     for row in rows:
2074         if object_type != "group":
2075             result = row["name"]
2076             result = result.strip("{}")
2077             parts = result.split(",")
2078             for part in parts:
2079                 perms_part, _ = part.split("/")
2080                 rolename, perms = perms_part.split("=")
2081                 if rolename == "":
2082                     rolename = "public"
2083                 _tmp = _process_priv_part(perms)
2084                 ret[rolename] = _tmp
2085         else:
2086             if row["admin_option"] == "t":
2087                 admin_option = True
2088                 admin_option = False
2089             ret[row["rolname"]] = <font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>admin_option
2090     return ret
2091 def has_privileges(
2092     name,
2093     object_name,
2094     object_type,
2095     privileges=None,
2096     grant_option=None,
2097     prepend="public",
2098     maintenance_db=None,
2099     user=None,
2100     host=None,
2101     port=None,
2102     password=None,
2103     runas=</b></font>None,
2104 ):
2105     object_type, privileges, _privs = _mod_priv_opts(object_type, privileges)
2106     _validate_privileges(object_type, _privs, privileges)
2107     if object_type != "group":
2108         owner = _get_object_owner(
2109             object_name,
2110             object_type,
2111             prepend=prepend,
2112             maintenance_db=maintenance_db,
2113             user=user,
2114             host=host,
2115             port=port,
2116             password=password,
2117             runas=runas,
2118         )
2119         if owner is not None and name == owner:
2120             return True
2121     _privileges = privileges_list(
2122         object_name,
2123         object_type,
2124         prepend=prepend,
2125         maintenance_db=maintenance_db,
2126         user=user,
2127         host=host,
2128         port=port,
2129         password=password,
2130         runas=runas,
2131     )
2132     if name in _privileges:
2133         if object_type == "group":
2134             if grant_option:
2135                 retval = _privileges[name]
2136             else:
2137                 retval = True
2138             return retval
2139         else:
2140             _perms = _PRIVILEGE_TYPE_MAP[object_type]
2141             if grant_option:
2142                 perms = {_PRIVILEGES_MAP[perm]: True for perm in _perms}
2143                 retval = perms == _privileges[name]
2144             else:
2145                 perms = [_PRIVILEGES_MAP[perm] for perm in _perms]
2146                 if "ALL" in _privs:
2147                     retval = sorted(perms) == sorted(_privileges[name])
2148                 else:
2149                     retval = set(_privs).issubset(set(_privileges[name]))
2150             return retval
2151     return False
2152 def privileges_grant(
2153     name,
2154     object_name,
2155     object_type,
2156     privileges=None,
2157     grant_option=None,
2158     prepend="public",
2159     maintenance_db=None,
2160     user=None,
2161     host=None,
2162     port=None,
2163     password=None,
2164     runas=None,
2165 ):
2166     object_type, privileges, _privs = _mod_priv_opts(object_type, privileges)
2167     _validate_privileges(object_type, _privs, privileges)
2168     if has_privileges(
2169         name,
2170         object_name,
2171         object_type,
2172         privileges,
2173         prepend=prepend,
2174         maintenance_db=maintenance_db,
2175         user=user,
2176         host=host,
2177         port=port,
2178         password=password,
2179         runas=runas,
2180     ):
2181         log.info(
2182             "The object: %s of type: %s already has privileges: %s set",
2183             object_name,
2184             object_type,
2185             privileges,
2186         )
2187         return False
2188     _grants = ",".join(_privs)
2189     if object_type in ["table", "sequence"]:
2190         on_part = '{}."{}"'.format(prepend, object_name)
2191     elif object_type == "function":
2192         on_part = "{}".format(object_name)
2193     else:
2194         on_part = '"{}"'.format(object_name)
2195     if grant_option:
2196         if object_type == "group":
2197             query = 'GRANT {} TO "{}" WITH ADMIN OPTION'.format(object_name, name)
2198         elif object_type in ("table", "sequence") and object_name.upper() == "ALL":
2199             query = 'GRANT {} ON ALL {}S IN SCHEMA {} TO "{}" WITH GRANT OPTION'.format(
2200                 _grants, object_type.upper(), prepend, name
2201             )
2202         else:
2203             query = 'GRANT {} ON {} {} TO "{}" WITH GRANT OPTION'.format(
2204                 _grants, object_type.upper(), on_part, name
2205             )
2206     else:
2207         if object_type == "group":
2208             query = 'GRANT {} TO "{}"'.format(object_name, name)
2209         elif object_type in ("table", "sequence") and object_name.upper() == "ALL":
2210             query = 'GRANT {} ON ALL {}S IN SCHEMA {} TO "{}"'.format(
2211                 _grants, object_type.upper(), prepend, name
2212             )
2213         else:
2214             query = 'GRANT {} ON {} {} TO "{}"'.format(
2215                 _grants, object_type.upper(), on_part, name
2216             )
2217     ret = _psql_prepare_and_run(
2218         ["-c", query],
2219         user=user,
2220         host=host,
2221         port=port,
2222         maintenance_db=maintenance_db,
2223         password=password,
2224         runas=runas,
2225     )
2226     return ret["retcode"] == 0
2227 def privileges_revoke(
2228     name,
2229     object_name,
2230     object_type,
2231     privileges=None,
2232     prepend="public",
2233     maintenance_db=None,
2234     user=None,
2235     host=None,
2236     port=None,
2237     password=None,
2238     runas=None,
2239 ):
2240     object_type, privileges, _privs = _mod_priv_opts(object_type, privileges)
2241     _validate_privileges(object_type, _privs, privileges)
2242     if not has_privileges(
2243         name,
2244         object_name,
2245         object_type,
2246         privileges,
2247         prepend=prepend,
2248         maintenance_db=maintenance_db,
2249         user=user,
2250         host=host,
2251         port=port,
2252         password=password,
2253         runas=runas,
2254     ):
2255         log.info(
2256             "The object: %s of type: %s does not have privileges: %s set",
2257             object_name,
2258             object_type,
2259             privileges,
2260         )
2261         return False
2262     _grants = ",".join(_privs)
2263     if object_type in ["table", "sequence"]:
2264         on_part = "{}.{}".format(prepend, object_name)
2265     else:
2266         on_part = object_name
2267     if object_type == "group":
2268         query = "REVOKE {} FROM {}".format(object_name, name)
2269     else:
2270         query = "REVOKE {} ON {} {} FROM {}".format(
2271             _grants, object_type.upper(), on_part, name
2272         )
2273     ret = _psql_prepare_and_run(
2274         ["-c", query],
2275         user=user,
2276         host=host,
2277         port=port,
2278         maintenance_db=maintenance_db,
2279         password=password,
2280         runas=runas,
2281     )
2282     return ret["retcode"] == 0
2283 def datadir_init(
2284     name,
2285     auth="password",
2286     user=None,
2287     password=None,
2288     encoding="UTF8",
2289     locale=None,
2290     waldir=None,
2291     checksums=False,
2292     runas=None,
2293 ):
2294     if datadir_exists<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(name):
2295         log.info("%s already exists", name)
2296         return False
2297     ret = _run_initdb(
2298         name,
2299         auth=auth,
2300         user=user,
2301         password=password,
2302         encoding=encoding,
2303         locale=locale,
2304         waldir=waldir,
2305         checksums=checksums,
2306         runas=runas,
2307     )
2308     return</b></font> ret["retcode"] == 0
2309 def datadir_exists(name):
2310     _version_file = os.path.join(name, "PG_VERSION")
2311     _config_file = os.path.join(name, "postgresql.conf")
2312     return os.path.isfile(_version_file) and os.path.isfile(_config_file)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
