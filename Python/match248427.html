<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for rbenv.py &amp; file_2.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for rbenv.py &amp; file_2.py
      </h3>
<h1 align="center">
        1.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>rbenv.py (17.96875%)<th>file_2.py (0.5757917%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(218-243)<td><a href="#" name="0">(5024-5041)</a><td align="center"><font color="#ff0000">19</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(200-206)<td><a href="#" name="1">(8887-8892)</a><td align="center"><font color="#c90000">15</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(246-252)<td><a href="#" name="2">(5224-5230)</a><td align="center"><font color="#a10000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>rbenv.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import copy
import re
def _check_rbenv(ret, user=None):
    if not __salt__["rbenv.is_installed"](user):
        ret["result"] = False
        ret["comment"] = "Rbenv is not installed."
    return ret
def _ruby_installed(ret, ruby, user=None):
    default = __salt__["rbenv.default"](runas=user)
    for version in __salt__["rbenv.versions"](user):
        if version == ruby:
            ret["result"] = True
            ret["comment"] = "Requested ruby exists"
            ret["default"] = default == ruby
            break
    return ret
def _check_and_install_ruby(ret, ruby, default=False, user=None):
    ret = _ruby_installed(ret, ruby, user=user)
    if not ret["result"]:
        if __salt__["rbenv.install_ruby"](ruby, runas=user):
            ret["result"] = True
            ret["changes"][ruby] = "Installed"
            ret["comment"] = "Successfully installed ruby"
            ret["default"] = default
        else:
            ret["result"] = False
            ret["comment"] = "Failed to install ruby"
            return ret
    if default:
        __salt__["rbenv.default"](ruby, runas=user)
    return ret
def installed(name, default=False, user=None):
    ret = {"name": name, "result": None, "comment": "", "changes": {}}
    rbenv_installed_ret = copy.deepcopy(ret)
    if name.startswith("ruby-"):
        name = re.sub(r"^ruby-", "", name)
    if __opts__["test"]:
        ret = _ruby_installed(ret, name, user=user)
        if not ret["result"]:
            ret["comment"] = "Ruby {} is set to be installed".format(name)
        else:
            ret["comment"] = "Ruby {} is already installed".format(name)
        return ret
    rbenv_installed_ret = _check_and_install_rbenv(rbenv_installed_ret, user)
    if rbenv_installed_ret["result"] is False:
        ret["result"] = False
        ret["comment"] = "Rbenv failed to install"
        return ret
    else:
        return _check_and_install_ruby(ret, name, default, user=user)
def _check_and_uninstall_ruby(ret, ruby, user=None):
    ret = _ruby_installed(ret, ruby, user=user)
    if ret["result"]:
        if ret["default"]:
            __salt__["rbenv.default"]("system", runas=user)
        if __salt__["rbenv.uninstall_ruby"](ruby, runas=user):
            ret["result"] = True
            ret["changes"][ruby] = "Uninstalled"
            ret["comment"] = "Successfully removed ruby"
            return ret
        else:
            ret["result"] = False
            ret["comment"] = "Failed to uninstall ruby"
            return ret
    else:
        ret["result"] = True
        ret["comment"] = "Ruby {} is already absent".format(ruby)
    return ret
def absent(name, user=None):
    ret = {"name": name, "result": None, "comment": "", "changes": {}}
    if name.startswith("ruby-"):
        name = re.sub(r"^ruby-", "", name)
    ret = _check_rbenv(ret, user)
    if ret["result"] is False:
        ret["result"] = True
        ret["comment"] = "Rbenv not installed, {} not either".format(name)
        return ret
<a name="1"></a>    else:
        if __opts__["test"]:
            ret = _ruby_installed(ret, name, user=user)
            if ret<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["result"]:
                ret["result"] = None
                ret["comment"] = "Ruby {} is set to be uninstalled".format(name)
            else:
                ret["result"] = True
                ret["comment"] = "Ruby {} is already uninstalled".format(name)
            return</b></font> ret
        return _check_and_uninstall_ruby(ret, name, user=user)
def _check_and_install_rbenv(ret, user=None):
<a name="0"></a>    ret = _check_rbenv(ret, user)
    if ret["result"] is False:
        if __salt__["rbenv.install"](user):
            ret<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["result"] = True
            ret["comment"] = "Rbenv installed"
        else:
            ret["result"] = False
            ret["comment"] = "Rbenv failed to install"
    else:
        ret["result"] = True
        ret["comment"] = "Rbenv is already installed"
    return ret
def install_rbenv(name, user=None):
<a name="2"></a>    ret =</b></font> {"name": name, "result": None, "comment": "", "changes": {}}
    if __opts__["test"]:
        ret = _check_rbenv(ret, user<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=user)
        if ret["result"] is False:
            ret["result"] = None
            ret["comment"] = "Rbenv is set to be installed"
        else:
            ret["result"] = True
            ret["comment"] =</b></font> "Rbenv is already installed"
        return ret
    return _check_and_install_rbenv(ret, user)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>file_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import copy
import difflib
import itertools
import logging
import os
import posixpath
import re
import shutil
import sys
import time
import traceback
import urllib.parse
from collections import defaultdict
from collections.abc import Iterable, Mapping
from datetime import date, datetime  # python3 problem in the making?
from itertools import zip_longest
import salt.loader
import salt.payload
import salt.utils.data
import salt.utils.dateutils
import salt.utils.dictupdate
import salt.utils.files
import salt.utils.hashutils
import salt.utils.path
import salt.utils.platform
import salt.utils.stringutils
import salt.utils.templates
import salt.utils.url
import salt.utils.versions
from salt.exceptions import CommandExecutionError
from salt.serializers import DeserializationError
from salt.state import get_accumulator_dir as _get_accumulator_dir
from salt.utils.odict import OrderedDict
if salt.utils.platform.is_windows():
    import salt.utils.win_dacl
    import salt.utils.win_functions
    import salt.utils.winapi
if salt.utils.platform.is_windows():
    import pywintypes
    import win32com.client
log = logging.getLogger(__name__)
COMMENT_REGEX = r"^([[:space:]]*){0}[[:space:]]?"
__NOT_FOUND = object()
__func_alias__ = {
    "copy_": "copy",
}
def _get_accumulator_filepath():
    return os.path.join(_get_accumulator_dir(__opts__["cachedir"]), __instance_id__)
def _load_accumulators():
    def _deserialize(path):
        ret = {"accumulators": {}, "accumulators_deps": {}}
        try:
            with salt.utils.files.fopen(path, "rb") as f:
                loaded = salt.payload.load(f)
                return loaded if loaded else ret
        except (OSError, NameError):
            return ret
    loaded = _deserialize(_get_accumulator_filepath())
    return loaded["accumulators"], loaded["accumulators_deps"]
def _persist_accummulators(accumulators, accumulators_deps):
    accumm_data = {"accumulators": accumulators, "accumulators_deps": accumulators_deps}
    try:
        with salt.utils.files.fopen(_get_accumulator_filepath(), "w+b") as f:
            salt.payload.dump(accumm_data, f)
    except NameError:
        pass
def _check_user(user, group):
    err = ""
    if user:
        uid = __salt__["file.user_to_uid"](user)
        if uid == "":
            err += "User {} is not available ".format(user)
    if group:
        gid = __salt__["file.group_to_gid"](group)
        if gid == "":
            err += "Group {} is not available".format(group)
    return err
def _is_valid_relpath(relpath, maxdepth=None):
    sep, pardir = posixpath.sep, posixpath.pardir
    if sep + pardir + sep in sep + relpath + sep:
        return False
    if maxdepth is not None:
        path_depth = relpath.strip(sep).count(sep)
        if path_depth &gt; maxdepth:
            return False
    return True
def _salt_to_os_path(path):
    return os.path.normpath(path.replace(posixpath.sep, os.path.sep))
def _gen_recurse_managed_files(
    name,
    source,
    keep_symlinks=False,
    include_pat=None,
    exclude_pat=None,
    maxdepth=None,
    include_empty=False,
    **kwargs
):
    def full_path(master_relpath):
        return os.path.join(name, _salt_to_os_path(master_relpath))
    def process_symlinks(filenames, symlinks):
        for lname, ltarget in symlinks.items():
            srelpath = posixpath.relpath(lname, srcpath)
            if not _is_valid_relpath(srelpath, maxdepth=maxdepth):
                continue
            if not salt.utils.stringutils.check_include_exclude(
                srelpath, include_pat, exclude_pat
            ):
                continue
            _filenames = list(filenames)
            for filename in _filenames:
                if filename.startswith(lname + os.sep):
                    log.debug(
                        "** skipping file ** %s, it intersects a symlink", filename
                    )
                    filenames.remove(filename)
            managed_symlinks.add((srelpath, ltarget))
            keep.add(full_path(srelpath))
        vdir.update(keep)
        return filenames
    managed_files = set()
    managed_directories = set()
    managed_symlinks = set()
    keep = set()
    vdir = set()
    srcpath, senv = salt.utils.url.parse(source)
    if senv is None:
        senv = __env__
    if not srcpath.endswith(posixpath.sep):
        srcpath = srcpath + posixpath.sep
    fns_ = __salt__["cp.list_master"](senv, srcpath)
    if keep_symlinks:
        symlinks = __salt__["cp.list_master_symlinks"](senv, srcpath)
        fns_ = process_symlinks(fns_, symlinks)
    for fn_ in fns_:
        if not fn_.strip():
            continue
        relname = salt.utils.data.decode(posixpath.relpath(fn_, srcpath))
        if not _is_valid_relpath(relname, maxdepth=maxdepth):
            continue
        if not salt.utils.stringutils.check_include_exclude(
            relname, include_pat, exclude_pat
        ):
            continue
        dest = full_path(relname)
        dirname = os.path.dirname(dest)
        keep.add(dest)
        if dirname not in vdir:
            managed_directories.add(dirname)
            vdir.add(dirname)
        src = salt.utils.url.create(fn_, saltenv=senv)
        managed_files.add((dest, src))
    if include_empty:
        mdirs = __salt__["cp.list_master_dirs"](senv, srcpath)
        for mdir in mdirs:
            relname = posixpath.relpath(mdir, srcpath)
            if not _is_valid_relpath(relname, maxdepth=maxdepth):
                continue
            if not salt.utils.stringutils.check_include_exclude(
                relname, include_pat, exclude_pat
            ):
                continue
            mdest = full_path(relname)
            if keep_symlinks:
                islink = False
                for link in symlinks:
                    if mdir.startswith(link + os.sep, 0):
                        log.debug(
                            "** skipping empty dir ** %s, it intersects a symlink", mdir
                        )
                        islink = True
                        break
                if islink:
                    continue
            managed_directories.add(mdest)
            keep.add(mdest)
    return managed_files, managed_directories, managed_symlinks, keep
def _gen_keep_files(name, require, walk_d=None):
    def _is_child(path, directory):
        path = os.path.abspath(path)
        directory = os.path.abspath(directory)
        relative = os.path.relpath(path, directory)
        return not relative.startswith(os.pardir)
    def _add_current_path(path):
        _ret = set()
        if os.path.isdir(path):
            dirs, files = walk_d.get(path, ((), ()))
            _ret.add(path)
            for _name in files:
                _ret.add(os.path.join(path, _name))
            for _name in dirs:
                _ret.add(os.path.join(path, _name))
        return _ret
    def _process_by_walk_d(name, ret):
        if os.path.isdir(name):
            walk_ret.update(_add_current_path(name))
            dirs, _ = walk_d.get(name, ((), ()))
            for _d in dirs:
                p = os.path.join(name, _d)
                walk_ret.update(_add_current_path(p))
                _process_by_walk_d(p, ret)
    def _process(name):
        ret = set()
        if os.path.isdir(name):
            for root, dirs, files in salt.utils.path.os_walk(name):
                ret.add(name)
                for name in files:
                    ret.add(os.path.join(root, name))
                for name in dirs:
                    ret.add(os.path.join(root, name))
        return ret
    keep = set()
    if isinstance(require, list):
        required_files = [comp for comp in require if "file" in comp]
        for comp in required_files:
            for low in __lowstate__:
                if low["name"] == comp["file"] or low["__id__"] == comp["file"]:
                    fn = low["name"]
                    fun = low["fun"]
                    if os.path.isdir(fn):
                        if _is_child(fn, name):
                            if fun == "recurse":
                                fkeep = _gen_recurse_managed_files(**low)[3]
                                log.debug("Keep from %s: %s", fn, fkeep)
                                keep.update(fkeep)
                            elif walk_d:
                                walk_ret = set()
                                _process_by_walk_d(fn, walk_ret)
                                keep.update(walk_ret)
                            else:
                                keep.update(_process(fn))
                    else:
                        keep.add(fn)
    log.debug("Files to keep from required states: %s", list(keep))
    return list(keep)
def _check_file(name):
    ret = True
    msg = ""
    if not os.path.isabs(name):
        ret = False
        msg = "Specified file {} is not an absolute path".format(name)
    elif not os.path.exists(name):
        ret = False
        msg = "{}: file not found".format(name)
    return ret, msg
def _find_keep_files(root, keep):
    real_keep = set()
    real_keep.add(root)
    if isinstance(keep, list):
        for fn_ in keep:
            if not os.path.isabs(fn_):
                continue
            fn_ = os.path.normcase(os.path.abspath(fn_))
            real_keep.add(fn_)
            while True:
                fn_ = os.path.abspath(os.path.dirname(fn_))
                real_keep.add(fn_)
                drive, path = os.path.splitdrive(fn_)
                if not path.lstrip(os.sep):
                    break
    return real_keep
def _clean_dir(root, keep, exclude_pat):
    case_keep = None
    if salt.utils.files.case_insensitive_filesystem():
        case_keep = keep
    root = os.path.normcase(root)
    real_keep = _find_keep_files(root, keep)
    removed = set()
    def _delete_not_kept(nfn):
        if nfn not in real_keep:
            if not salt.utils.stringutils.check_include_exclude(
                os.path.relpath(nfn, root), None, exclude_pat
            ):
                return
            if case_keep:
                for item in case_keep:
                    if item.casefold() == nfn.casefold():
                        return
            removed.add(nfn)
            if not __opts__["test"]:
                try:
                    os.remove(nfn)
                except OSError:
                    __salt__["file.remove"](nfn)
    for roots, dirs, files in salt.utils.path.os_walk(root):
        for name in itertools.chain(dirs, files):
            _delete_not_kept(os.path.join(roots, name))
    return list(removed)
def _error(ret, err_msg):
    ret["result"] = False
    ret["comment"] = err_msg
    return ret
def _check_directory(
    name,
    user=None,
    group=None,
    recurse=False,
    dir_mode=None,
    file_mode=None,
    clean=False,
    require=False,
    exclude_pat=None,
    max_depth=None,
    follow_symlinks=False,
):
    changes = {}
    if recurse or clean:
        assert max_depth is None or not clean
        walk_l = list(_depth_limited_walk(name, max_depth))
        walk_d = {}
        for i in walk_l:
            walk_d[i[0]] = (i[1], i[2])
    if recurse:
        try:
            recurse_set = _get_recurse_set(recurse)
        except (TypeError, ValueError) as exc:
            return False, "{}".format(exc), changes
        if "user" not in recurse_set:
            user = None
        if "group" not in recurse_set:
            group = None
        if "mode" not in recurse_set:
            dir_mode = None
            file_mode = None
        check_files = "ignore_files" not in recurse_set
        check_dirs = "ignore_dirs" not in recurse_set
        for root, dirs, files in walk_l:
            if check_files:
                for fname in files:
                    fchange = {}
                    path = os.path.join(root, fname)
                    stats = __salt__["file.stats"](path, None, follow_symlinks)
                    if user is not None and user != stats.get("user"):
                        fchange["user"] = user
                    if group is not None and group != stats.get("group"):
                        fchange["group"] = group
                    smode = salt.utils.files.normalize_mode(stats.get("mode"))
                    file_mode = salt.utils.files.normalize_mode(file_mode)
                    if (
                        file_mode is not None
                        and file_mode != smode
                        and (
                            follow_symlinks
                            or stats.get("type") != "link"
                            or not salt.utils.platform.is_linux()
                        )
                    ):
                        fchange["mode"] = file_mode
                    if fchange:
                        changes[path] = fchange
            if check_dirs:
                for name_ in dirs:
                    path = os.path.join(root, name_)
                    fchange = _check_dir_meta(
                        path, user, group, dir_mode, follow_symlinks
                    )
                    if fchange:
                        changes[path] = fchange
    fchange = _check_dir_meta(name, user, group, dir_mode, follow_symlinks)
    if fchange:
        changes[name] = fchange
    if clean:
        keep = _gen_keep_files(name, require, walk_d)
        def _check_changes(fname):
            path = os.path.join(root, fname)
            if path in keep:
                return {}
            else:
                if not salt.utils.stringutils.check_include_exclude(
                    os.path.relpath(path, name), None, exclude_pat
                ):
                    return {}
                else:
                    return {path: {"removed": "Removed due to clean"}}
        for root, dirs, files in walk_l:
            for fname in files:
                changes.update(_check_changes(fname))
            for name_ in dirs:
                changes.update(_check_changes(name_))
    if not os.path.isdir(name):
        changes[name] = {"directory": "new"}
    if changes:
        comments = ["The following files will be changed:\n"]
        for fn_ in changes:
            for key, val in changes[fn_].items():
                comments.append("{}: {} - {}\n".format(fn_, key, val))
        return None, "".join(comments), changes
    return True, "The directory {} is in the correct state".format(name), changes
def _check_directory_win(
    name,
    win_owner=None,
    win_perms=None,
    win_deny_perms=None,
    win_inheritance=None,
    win_perms_reset=None,
):
    if not os.path.isdir(name):
        changes = {name: {"directory": "new"}}
    else:
        changes = salt.utils.win_dacl.check_perms(
            obj_name=name,
            obj_type="file",
            ret={},
            owner=win_owner,
            grant_perms=win_perms,
            deny_perms=win_deny_perms,
            inheritance=win_inheritance,
            reset=win_perms_reset,
            test_mode=True,
        )["changes"]
    if changes:
        return None, 'The directory "{}" will be changed'.format(name), changes
    return True, "The directory {} is in the correct state".format(name), changes
def _check_dir_meta(name, user, group, mode, follow_symlinks=False):
    try:
        stats = __salt__["file.stats"](name, None, follow_symlinks)
    except CommandExecutionError:
        stats = {}
    changes = {}
    if not stats:
        changes["directory"] = "new"
        return changes
    if user is not None and user != stats["user"] and user != stats.get("uid"):
        changes["user"] = user
    if group is not None and group != stats["group"] and group != stats.get("gid"):
        changes["group"] = group
    smode = salt.utils.files.normalize_mode(stats["mode"])
    mode = salt.utils.files.normalize_mode(mode)
    if (
        mode is not None
        and mode != smode
        and (
            follow_symlinks
            or stats.get("type") != "link"
            or not salt.utils.platform.is_linux()
        )
    ):
        changes["mode"] = mode
    return changes
def _check_touch(name, atime, mtime):
    ret = {
        "result": None,
        "comment": "",
        "changes": {"new": name},
    }
    if not os.path.exists(name):
        ret["comment"] = "File {} is set to be created".format(name)
    else:
        stats = __salt__["file.stats"](name, follow_symlinks=False)
        if (atime is not None and str(atime) != str(stats["atime"])) or (
            mtime is not None and str(mtime) != str(stats["mtime"])
        ):
            ret["comment"] = "Times set to be updated on file {}".format(name)
            ret["changes"] = {"touched": name}
        else:
            ret["result"] = True
            ret["comment"] = "File {} exists and has the correct times".format(name)
    return ret
def _get_symlink_ownership(path):
    if salt.utils.platform.is_windows():
        owner = salt.utils.win_dacl.get_owner(path)
        return owner, owner
    else:
        return (
            __salt__["file.get_user"](path, follow_symlinks=False),
            __salt__["file.get_group"](path, follow_symlinks=False),
        )
def _check_symlink_ownership(path, user, group, win_owner):
    cur_user, cur_group = _get_symlink_ownership(path)
    if salt.utils.platform.is_windows():
        return win_owner == cur_user
    else:
        return (cur_user == user) and (cur_group == group)
def _set_symlink_ownership(path, user, group, win_owner):
    if salt.utils.platform.is_windows():
        try:
            salt.utils.win_dacl.set_owner(path, win_owner)
        except CommandExecutionError:
            pass
    else:
        try:
            __salt__["file.lchown"](path, user, group)
        except OSError:
            pass
    return _check_symlink_ownership(path, user, group, win_owner)
def _symlink_check(name, target, force, user, group, win_owner):
    changes = {}
    if not os.path.exists(name) and not __salt__["file.is_link"](name):
        changes["new"] = name
        return (
            None,
            "Symlink {} to {} is set for creation".format(name, target),
            changes,
        )
    if __salt__["file.is_link"](name):
        if __salt__["file.readlink"](name) != target:
            changes["change"] = name
            return (
                None,
                "Link {} target is set to be changed to {}".format(name, target),
                changes,
            )
        else:
            result = True
            msg = "The symlink {} is present".format(name)
            if not _check_symlink_ownership(name, user, group, win_owner):
                result = None
                changes["ownership"] = "{}:{}".format(*_get_symlink_ownership(name))
                msg += (
                    ", but the ownership of the symlink would be changed "
                    "from {2}:{3} to {0}:{1}".format(
                        user, group, *_get_symlink_ownership(name)
                    )
                )
            return result, msg, changes
    else:
        if force:
            return (
                None,
                "The file or directory {} is set for removal to "
                "make way for a new symlink targeting {}".format(name, target),
                changes,
            )
        return (
            False,
            "File or directory exists where the symlink {} "
            "should be. Did you mean to use force?".format(name),
            changes,
        )
def _hardlink_same(name, target):
    res = __salt__["file.stats"](name, None, follow_symlinks=False)
    if "inode" not in res:
        return False
    name_i = res["inode"]
    res = __salt__["file.stats"](target, None, follow_symlinks=False)
    if "inode" not in res:
        return False
    target_i = res["inode"]
    return name_i == target_i
def _hardlink_check(name, target, force):
    changes = {}
    if not os.path.exists(target):
        msg = "Target {} for hard link does not exist".format(target)
        return False, msg, changes
    elif os.path.isdir(target):
        msg = "Unable to hard link from directory {}".format(target)
        return False, msg, changes
    if os.path.isdir(name):
        msg = "Unable to hard link to directory {}".format(name)
        return False, msg, changes
    elif not os.path.exists(name):
        msg = "Hard link {} to {} is set for creation".format(name, target)
        changes["new"] = name
        return None, msg, changes
    elif __salt__["file.is_hardlink"](name):
        if _hardlink_same(name, target):
            msg = "The hard link {} is presently targetting {}".format(name, target)
            return True, msg, changes
        msg = "Link {} target is set to be changed to {}".format(name, target)
        changes["change"] = name
        return None, msg, changes
    if force:
        msg = (
            "The file or directory {} is set for removal to "
            "make way for a new hard link targeting {}".format(name, target)
        )
        return None, msg, changes
    msg = (
        "File or directory exists where the hard link {} "
        "should be. Did you mean to use force?".format(name)
    )
    return False, msg, changes
def _test_owner(kwargs, user=None):
    if user:
        return user
    if "owner" in kwargs:
        log.warning(
            'Use of argument owner found, "owner" is invalid, please use "user"'
        )
        return kwargs["owner"]
    return user
def _unify_sources_and_hashes(
    source=None, source_hash=None, sources=None, source_hashes=None
):
    if sources is None:
        sources = []
    if source_hashes is None:
        source_hashes = []
    if source and sources:
        return (False, "source and sources are mutually exclusive", [])
    if source_hash and source_hashes:
        return (False, "source_hash and source_hashes are mutually exclusive", [])
    if source:
        return (True, "", [(source, source_hash)])
    return True, "", list(zip_longest(sources, source_hashes[: len(sources)]))
def _get_template_texts(
    source_list=None, template="jinja", defaults=None, context=None, **kwargs
):
    ret = {
        "name": "_get_template_texts",
        "changes": {},
        "result": True,
        "comment": "",
        "data": [],
    }
    if source_list is None:
        return _error(ret, "_get_template_texts called with empty source_list")
    txtl = []
    for (source, source_hash) in source_list:
        tmpctx = defaults if defaults else {}
        if context:
            tmpctx.update(context)
        rndrd_templ_fn = __salt__["cp.get_template"](
            source, "", template=template, saltenv=__env__, context=tmpctx, **kwargs
        )
        log.debug(
            "cp.get_template returned %s (Called with: %s)", rndrd_templ_fn, source
        )
        if rndrd_templ_fn:
            tmplines = None
            with salt.utils.files.fopen(rndrd_templ_fn, "rb") as fp_:
                tmplines = fp_.read()
                tmplines = salt.utils.stringutils.to_unicode(tmplines)
                tmplines = tmplines.splitlines(True)
            if not tmplines:
                msg = "Failed to read rendered template file {} ({})".format(
                    rndrd_templ_fn, source
                )
                log.debug(msg)
                ret["name"] = source
                return _error(ret, msg)
            txtl.append("".join(tmplines))
        else:
            msg = "Failed to load template file {}".format(source)
            log.debug(msg)
            ret["name"] = source
            return _error(ret, msg)
    ret["data"] = txtl
    return ret
def _validate_str_list(arg, encoding=None):
    if isinstance(arg, bytes):
        ret = [salt.utils.stringutils.to_unicode(arg, encoding=encoding)]
    elif isinstance(arg, str):
        ret = [arg]
    elif isinstance(arg, Iterable) and not isinstance(arg, Mapping):
        ret = []
        for item in arg:
            if isinstance(item, str):
                ret.append(item)
            else:
                ret.append(str(item))
    else:
        ret = [str(arg)]
    return ret
def _get_shortcut_ownership(path):
    return __salt__["file.get_user"](path, follow_symlinks=False)
def _check_shortcut_ownership(path, user):
    cur_user = _get_shortcut_ownership(path)
    return cur_user == user
def _set_shortcut_ownership(path, user):
    try:
        __salt__["file.lchown"](path, user)
    except OSError:
        pass
    return _check_shortcut_ownership(path, user)
def _shortcut_check(
    name, target, arguments, working_dir, description, icon_location, force, user
):
    changes = {}
    if not os.path.exists(name):
        changes["new"] = name
        return (
            None,
            'Shortcut "{}" to "{}" is set for creation'.format(name, target),
            changes,
        )
    if os.path.isfile(name):
        with salt.utils.winapi.Com():
            shell = win32com.client.Dispatch("WScript.Shell")
            scut = shell.CreateShortcut(name)
            state_checks = [scut.TargetPath.lower() == target.lower()]
            if arguments is not None:
                state_checks.append(scut.Arguments == arguments)
            if working_dir is not None:
                state_checks.append(
                    scut.WorkingDirectory.lower() == working_dir.lower()
                )
            if description is not None:
                state_checks.append(scut.Description == description)
            if icon_location is not None:
                state_checks.append(scut.IconLocation.lower() == icon_location.lower())
        if not all(state_checks):
            changes["change"] = name
            return (
                None,
                'Shortcut "{}" target is set to be changed to "{}"'.format(
                    name, target
                ),
                changes,
            )
        else:
            result = True
            msg = 'The shortcut "{}" is present'.format(name)
            if not _check_shortcut_ownership(name, user):
                result = None
                changes["ownership"] = "{}".format(_get_shortcut_ownership(name))
                msg += (
                    ", but the ownership of the shortcut would be changed "
                    "from {1} to {0}".format(user, _get_shortcut_ownership(name))
                )
            return result, msg, changes
    else:
        if force:
            return (
                None,
                'The link or directory "{}" is set for removal to '
                'make way for a new shortcut targeting "{}"'.format(name, target),
                changes,
            )
        return (
            False,
            'Link or directory exists where the shortcut "{}" '
            "should be. Did you mean to use force?".format(name),
            changes,
        )
def _makedirs(
    name,
    user=None,
    group=None,
    dir_mode=None,
    win_owner=None,
    win_perms=None,
    win_deny_perms=None,
    win_inheritance=None,
):
    if salt.utils.platform.is_windows():
        drive, path = os.path.splitdrive(name)
        if not os.path.isdir(drive):
            raise CommandExecutionError(drive)
        win_owner = win_owner if win_owner else user
        return __salt__["file.makedirs"](
            path=name,
            owner=win_owner,
            grant_perms=win_perms,
            deny_perms=win_deny_perms,
            inheritance=win_inheritance,
        )
    else:
        return __salt__["file.makedirs"](
            path=name, user=user, group=group, mode=dir_mode
        )
def hardlink(
    name,
    target,
    force=False,
    makedirs=False,
    user=None,
    group=None,
    dir_mode=None,
    **kwargs
):
    name = os.path.expanduser(name)
    dir_mode = salt.utils.files.normalize_mode(dir_mode)
    user = _test_owner(kwargs, user=user)
    ret = {"name": name, "changes": {}, "result": True, "comment": ""}
    if not name:
        return _error(ret, "Must provide name to file.hardlink")
    if user is None:
        user = __opts__["user"]
    if salt.utils.platform.is_windows():
        if group is not None:
            log.warning(
                "The group argument for %s has been ignored as this "
                "is a Windows system.",
                name,
            )
        group = user
    if group is None:
        if "user.info" in __salt__:
            group = __salt__["file.gid_to_group"](
                __salt__["user.info"](user).get("gid", 0)
            )
        else:
            group = user
    preflight_errors = []
    uid = __salt__["file.user_to_uid"](user)
    gid = __salt__["file.group_to_gid"](group)
    if uid == "":
        preflight_errors.append("User {} does not exist".format(user))
    if gid == "":
        preflight_errors.append("Group {} does not exist".format(group))
    if not os.path.isabs(name):
        preflight_errors.append(
            "Specified file {} is not an absolute path".format(name)
        )
    if not os.path.isabs(target):
        preflight_errors.append(
            "Specified target {} is not an absolute path".format(target)
        )
    if preflight_errors:
        msg = ". ".join(preflight_errors)
        if len(preflight_errors) &gt; 1:
            msg += "."
        return _error(ret, msg)
    if __opts__["test"]:
        tresult, tcomment, tchanges = _hardlink_check(name, target, force)
        ret["result"] = tresult
        ret["comment"] = tcomment
        ret["changes"] = tchanges
        return ret
    for direction, item in zip_longest(["to", "from"], [name, target]):
        if os.path.isdir(item):
            msg = "Unable to hard link {} directory {}".format(direction, item)
            return _error(ret, msg)
    if not os.path.exists(target):
        msg = "Target {} for hard link does not exist".format(target)
        return _error(ret, msg)
    if not os.path.isdir(os.path.dirname(name)):
        if makedirs:
            __salt__["file.makedirs"](name, user=user, group=group, mode=dir_mode)
        else:
            return _error(
                ret,
                "Directory {} for hard link is not present".format(
                    os.path.dirname(name)
                ),
            )
    if os.path.isfile(name) and not __salt__["file.is_hardlink"](name):
        if force:
            os.remove(name)
            ret["changes"]["forced"] = "File for hard link was forcibly replaced"
        else:
            return _error(
                ret, "File exists where the hard link {} should be".format(name)
            )
    if __salt__["file.is_hardlink"](name):
        if _hardlink_same(name, target):
            ret["result"] = True
            ret["comment"] = "Target of hard link {} is already pointing to {}".format(
                name, target
            )
            return ret
        os.remove(name)
        try:
            __salt__["file.link"](target, name)
        except CommandExecutionError as E:
            ret["result"] = False
            ret["comment"] = "Unable to set target of hard link {} -&gt; {}: {}".format(
                name, target, E
            )
            return ret
        ret["result"] = True
        ret["comment"] = "Set target of hard link {} -&gt; {}".format(name, target)
        ret["changes"]["new"] = name
    elif not os.path.exists(name):
        try:
            __salt__["file.link"](target, name)
        except CommandExecutionError as E:
            ret["result"] = False
            ret["comment"] = "Unable to create new hard link {} -&gt; {}: {}".format(
                name, target, E
            )
            return ret
        ret["result"] = True
        ret["comment"] = "Created new hard link {} -&gt; {}".format(name, target)
        ret["changes"]["new"] = name
    return ret
def symlink(
    name,
    target,
    force=False,
    backupname=None,
    makedirs=False,
    user=None,
    group=None,
    mode=None,
    win_owner=None,
    win_perms=None,
    win_deny_perms=None,
    win_inheritance=None,
    **kwargs
):
    name = os.path.expanduser(name)
    mode = salt.utils.files.normalize_mode(mode)
    user = _test_owner(kwargs, user=user)
    ret = {"name": name, "changes": {}, "result": True, "comment": ""}
    if not name:
        return _error(ret, "Must provide name to file.symlink")
    if user is None:
        user = __opts__["user"]
    if salt.utils.platform.is_windows():
        if not __salt__["user.info"](user):
            user = __salt__["user.current"]()
            if not user:
                user = "SYSTEM"
        if win_owner is None:
            win_owner = user if user else None
        if group is not None:
            log.warning(
                "The group argument for %s has been ignored as this "
                "is a Windows system. Please use the `win_*` parameters to set "
                "permissions in Windows.",
                name,
            )
        group = user
    if group is None:
        if "user.info" in __salt__:
            group = __salt__["file.gid_to_group"](
                __salt__["user.info"](user).get("gid", 0)
            )
        else:
            group = user
    preflight_errors = []
    if salt.utils.platform.is_windows():
        try:
            salt.utils.win_functions.get_sid_from_name(win_owner)
        except CommandExecutionError as exc:
            preflight_errors.append("User {} does not exist".format(win_owner))
        if win_perms:
            for name_check in win_perms:
                try:
                    salt.utils.win_functions.get_sid_from_name(name_check)
                except CommandExecutionError as exc:
                    preflight_errors.append("User {} does not exist".format(name_check))
        if win_deny_perms:
            for name_check in win_deny_perms:
                try:
                    salt.utils.win_functions.get_sid_from_name(name_check)
                except CommandExecutionError as exc:
                    preflight_errors.append("User {} does not exist".format(name_check))
    else:
        uid = __salt__["file.user_to_uid"](user)
        gid = __salt__["file.group_to_gid"](group)
        if uid == "":
            preflight_errors.append("User {} does not exist".format(user))
        if gid == "":
            preflight_errors.append("Group {} does not exist".format(group))
    if not os.path.isabs(name):
        preflight_errors.append(
            "Specified file {} is not an absolute path".format(name)
        )
    if preflight_errors:
        msg = ". ".join(preflight_errors)
        if len(preflight_errors) &gt; 1:
            msg += "."
        return _error(ret, msg)
    tresult, tcomment, tchanges = _symlink_check(
        name, target, force, user, group, win_owner
    )
    if not os.path.isdir(os.path.dirname(name)):
        if makedirs:
            if __opts__["test"]:
                tcomment += "\n{} will be created".format(os.path.dirname(name))
            else:
                try:
                    _makedirs(
                        name=name,
                        user=user,
                        group=group,
                        dir_mode=mode,
                        win_owner=win_owner,
                        win_perms=win_perms,
                        win_deny_perms=win_deny_perms,
                        win_inheritance=win_inheritance,
                    )
                except CommandExecutionError as exc:
                    return _error(ret, "Drive {} is not mapped".format(exc.message))
        else:
            if __opts__["test"]:
                tcomment += "\nDirectory {} for symlink is not present".format(
                    os.path.dirname(name)
                )
            else:
                return _error(
                    ret,
                    "Directory {} for symlink is not present".format(
                        os.path.dirname(name)
                    ),
                )
    if __opts__["test"]:
        ret["result"] = tresult
        ret["comment"] = tcomment
        ret["changes"] = tchanges
        return ret
    if __salt__["file.is_link"](name):
        if os.path.normpath(__salt__["file.readlink"](name)) != os.path.normpath(
            target
        ):
            os.remove(name)
        else:
            if _check_symlink_ownership(name, user, group, win_owner):
                if salt.utils.platform.is_windows():
                    ret["comment"] = "Symlink {} is present and owned by {}".format(
                        name, win_owner
                    )
                else:
                    ret["comment"] = "Symlink {} is present and owned by {}:{}".format(
                        name, user, group
                    )
            else:
                if _set_symlink_ownership(name, user, group, win_owner):
                    if salt.utils.platform.is_windows():
                        ret["comment"] = "Set ownership of symlink {} to {}".format(
                            name, win_owner
                        )
                        ret["changes"]["ownership"] = win_owner
                    else:
                        ret["comment"] = "Set ownership of symlink {} to {}:{}".format(
                            name, user, group
                        )
                        ret["changes"]["ownership"] = "{}:{}".format(user, group)
                else:
                    ret["result"] = False
                    if salt.utils.platform.is_windows():
                        ret[
                            "comment"
                        ] += "Failed to set ownership of symlink {} to {}".format(
                            name, win_owner
                        )
                    else:
                        ret[
                            "comment"
                        ] += "Failed to set ownership of symlink {} to {}:{}".format(
                            name, user, group
                        )
            return ret
    elif os.path.exists(name):
        if backupname is not None:
            if not os.path.isabs(backupname):
                if backupname == os.path.basename(backupname):
                    backupname = os.path.join(
                        os.path.dirname(os.path.normpath(name)), backupname
                    )
                else:
                    return _error(
                        ret,
                        "Backupname must be an absolute path or a file name: {}".format(
                            backupname
                        ),
                    )
            if os.path.lexists(backupname):
                if not force:
                    return _error(
                        ret,
                        "Symlink &amp; backup dest exists and Force not set. {} -&gt; {} -"
                        " backup: {}".format(name, target, backupname),
                    )
                else:
                    __salt__["file.remove"](backupname)
            try:
                __salt__["file.move"](name, backupname)
            except Exception as exc:  # pylint: disable=broad-except
                ret["changes"] = {}
                log.debug(
                    "Encountered error renaming %s to %s",
                    name,
                    backupname,
                    exc_info=True,
                )
                return _error(
                    ret,
                    "Unable to rename {} to backup {} -&gt; : {}".format(
                        name, backupname, exc
                    ),
                )
        elif force:
            if __salt__["file.is_link"](name):
                __salt__["file.remove"](name)
                ret["changes"]["forced"] = "Symlink was forcibly replaced"
            else:
                __salt__["file.remove"](name)
        else:
            fs_entry_type = (
                "File"
                if os.path.isfile(name)
                else "Directory"
                if os.path.isdir(name)
                else "File system entry"
            )
            return _error(
                ret,
                "{} exists where the symlink {} should be".format(fs_entry_type, name),
            )
    if not os.path.exists(name):
        try:
            __salt__["file.symlink"](target, name)
        except OSError as exc:
            ret["result"] = False
            ret["comment"] = "Unable to create new symlink {} -&gt; {}: {}".format(
                name, target, exc
            )
            return ret
        else:
            ret["comment"] = "Created new symlink {} -&gt; {}".format(name, target)
            ret["changes"]["new"] = name
        if not _check_symlink_ownership(name, user, group, win_owner):
            if not _set_symlink_ownership(name, user, group, win_owner):
                ret["result"] = False
                ret["comment"] += ", but was unable to set ownership to {}:{}".format(
                    user, group
                )
    return ret
def absent(name, **kwargs):
    name = os.path.expanduser(name)
    ret = {"name": name, "changes": {}, "result": True, "comment": ""}
    if not name:
        return _error(ret, "Must provide name to file.absent")
    if not os.path.isabs(name):
        return _error(ret, "Specified file {} is not an absolute path".format(name))
    if name == "/":
        return _error(ret, 'Refusing to make "/" absent')
    if os.path.isfile(name) or os.path.islink(name):
        if __opts__["test"]:
            ret["result"] = None
            ret["changes"]["removed"] = name
            ret["comment"] = "File {} is set for removal".format(name)
            return ret
        try:
            if salt.utils.platform.is_windows():
                __salt__["file.remove"](name, force=True)
            else:
                __salt__["file.remove"](name)
            ret["comment"] = "Removed file {}".format(name)
            ret["changes"]["removed"] = name
            return ret
        except CommandExecutionError as exc:
            return _error(ret, "{}".format(exc))
    elif os.path.isdir(name):
        if __opts__["test"]:
            ret["result"] = None
            ret["changes"]["removed"] = name
            ret["comment"] = "Directory {} is set for removal".format(name)
            return ret
        try:
            if salt.utils.platform.is_windows():
                __salt__["file.remove"](name, force=True)
            else:
                __salt__["file.remove"](name)
            ret["comment"] = "Removed directory {}".format(name)
            ret["changes"]["removed"] = name
            return ret
        except OSError:
            return _error(ret, "Failed to remove directory {}".format(name))
    ret["comment"] = "File {} is not present".format(name)
    return ret
def tidied(name, age=0, matches=None, rmdirs=False, size=0, **kwargs):
    name = os.path.expanduser(name)
    ret = {"name": name, "changes": {}, "result": True, "comment": ""}
    if not os.path.isabs(name):
        return _error(ret, "Specified file {} is not an absolute path".format(name))
    if not os.path.isdir(name):
        return _error(ret, "{} does not exist or is not a directory.".format(name))
    todelete = []
    today = date.today()
    if matches is None:
        matches = [".*"]
    progs = []
    for regex in matches:
        progs.append(re.compile(regex))
    def _matches(name):
        for prog in progs:
            if prog.match(name):
                return True
        return False
    for root, dirs, files in os.walk(top=name, topdown=False):
        for elem in files + dirs:
            myage = 0
            mysize = 0
            deleteme = True
            path = os.path.join(root, elem)
            if os.path.islink(path):
                myage = abs(today - date.fromtimestamp(os.lstat(path).st_atime))
            elif elem in dirs:
                myage = abs(today - date.fromtimestamp(os.path.getatime(path)))
                deleteme = rmdirs
            else:
                myage = abs(today - date.fromtimestamp(os.path.getatime(path)))
                mysize = os.path.getsize(path)
            if (
                (mysize &gt;= size or myage.days &gt;= age)
                and _matches(name=elem)
                and deleteme
            ):
                todelete.append(path)
    if todelete:
        if __opts__["test"]:
            ret["result"] = None
            ret["comment"] = "{} is set for tidy".format(name)
            ret["changes"] = {"removed": todelete}
            return ret
        ret["changes"]["removed"] = []
        try:
            for path in todelete:
                if salt.utils.platform.is_windows():
                    __salt__["file.remove"](path, force=True)
                else:
                    __salt__["file.remove"](path)
                ret["changes"]["removed"].append(path)
        except CommandExecutionError as exc:
            return _error(ret, "{}".format(exc))
        ret["comment"] = "Removed {} files or directories from directory {}".format(
            len(todelete), name
        )
    else:
        ret["comment"] = "Nothing to remove from directory {}".format(name)
    return ret
def exists(name, **kwargs):
    name = os.path.expanduser(name)
    ret = {"name": name, "changes": {}, "result": True, "comment": ""}
    if not name:
        return _error(ret, "Must provide name to file.exists")
    if not os.path.exists(name):
        return _error(ret, "Specified path {} does not exist".format(name))
    ret["comment"] = "Path {} exists".format(name)
    return ret
def missing(name, **kwargs):
    name = os.path.expanduser(name)
    ret = {"name": name, "changes": {}, "result": True, "comment": ""}
    if not name:
        return _error(ret, "Must provide name to file.missing")
    if os.path.exists(name):
        return _error(ret, "Specified path {} exists".format(name))
    ret["comment"] = "Path {} is missing".format(name)
    return ret
def managed(
    name,
    source=None,
    source_hash="",
    source_hash_name=None,
    keep_source=True,
    user=None,
    group=None,
    mode=None,
    attrs=None,
    template=None,
    makedirs=False,
    dir_mode=None,
    context=None,
    replace=True,
    defaults=None,
    backup="",
    show_changes=True,
    create=True,
    contents=None,
    tmp_dir="",
    tmp_ext="",
    contents_pillar=None,
    contents_grains=None,
    contents_newline=True,
    contents_delimiter=":",
    encoding=None,
    encoding_errors="strict",
    allow_empty=True,
    follow_symlinks=True,
    check_cmd=None,
    skip_verify=False,
    selinux=None,
    win_owner=None,
    win_perms=None,
    win_deny_perms=None,
    win_inheritance=True,
    win_perms_reset=False,
    verify_ssl=True,
    use_etag=False,
    **kwargs
):
    r"""
    Manage a given file, this function allows for a file to be downloaded from
    the salt master and potentially run through a templating system.
    name
        The location of the file to manage, as an absolute path.
    source
        The source file to download to the minion, this source file can be
        hosted on either the salt master server (``salt://``), the salt minion
        local file system (``/``), or on an HTTP or FTP server (``http(s)://``,
        ``ftp://``).
        Both HTTPS and HTTP are supported as well as downloading directly
        from Amazon S3 compatible URLs with both pre-configured and automatic
        IAM credentials. (see s3.get state documentation)
        File retrieval from Openstack Swift object storage is supported via
        swift://container/object_path URLs, see swift.get documentation.
        For files hosted on the salt file server, if the file is located on
        the master in the directory named spam, and is called eggs, the source
        string is salt://spam/eggs. If source is left blank or None
        (use ~ in YAML), the file will be created as an empty file and
        the content will not be managed. This is also the case when a file
        already exists and the source is undefined; the contents of the file
        will not be changed or managed. If source is left blank or None, please
        also set replaced to False to make your intention explicit.
        If the file is hosted on a HTTP or FTP server then the source_hash
        argument is also required.
        A list of sources can also be passed in to provide a default source and
        a set of fallbacks. The first source in the list that is found to exist
        will be used and subsequent entries in the list will be ignored. Source
        list functionality only supports local files and remote files hosted on
        the salt master server or retrievable via HTTP, HTTPS, or FTP.
        .. code-block:: yaml
            file_override_example:
              file.managed:
                - source:
                  - salt://file_that_does_not_exist
                  - salt://file_that_exists
    source_hash
        This can be one of the following:
            1. a source hash string
            2. the URI of a file that contains source hash strings
        The function accepts the first encountered long unbroken alphanumeric
        string of correct length as a valid hash, in order from most secure to
        least secure:
        .. code-block:: text
            Type    Length
            ======  ======
            sha512     128
            sha384      96
            sha256      64
            sha224      56
            sha1        40
            md5         32
        **Using a Source Hash File**
            The file can contain several checksums for several files. Each line
            must contain both the file name and the hash.  If no file name is
            matched, the first hash encountered will be used, otherwise the most
            secure hash with the correct source file name will be used.
            When using a source hash file the source_hash argument needs to be a
            url, the standard download urls are supported, ftp, http, salt etc:
            Example:
            .. code-block:: yaml
                tomdroid-src-0.7.3.tar.gz:
                  file.managed:
                    - name: /tmp/tomdroid-src-0.7.3.tar.gz
                    - source: https://launchpad.net/tomdroid/beta/0.7.3/+download/tomdroid-src-0.7.3.tar.gz
                    - source_hash: https://launchpad.net/tomdroid/beta/0.7.3/+download/tomdroid-src-0.7.3.hash
            The following lines are all supported formats:
            .. code-block:: text
                /etc/rc.conf ef6e82e4006dee563d98ada2a2a80a27
                sha254c8525aee419eb649f0233be91c151178b30f0dff8ebbdcc8de71b1d5c8bcc06a  /etc/resolv.conf
                ead48423703509d37c4a90e6a0d53e143b6fc268
            Debian file type ``*.dsc`` files are also supported.
        **Inserting the Source Hash in the SLS Data**
        The source_hash can be specified as a simple checksum, like so:
        .. code-block:: yaml
            tomdroid-src-0.7.3.tar.gz:
              file.managed:
                - name: /tmp/tomdroid-src-0.7.3.tar.gz
                - source: https://launchpad.net/tomdroid/beta/0.7.3/+download/tomdroid-src-0.7.3.tar.gz
                - source_hash: 79eef25f9b0b2c642c62b7f737d4f53f
        .. note::
            Releases prior to 2016.11.0 must also include the hash type, like
            in the below example:
            .. code-block:: yaml
                tomdroid-src-0.7.3.tar.gz:
                  file.managed:
                    - name: /tmp/tomdroid-src-0.7.3.tar.gz
                    - source: https://launchpad.net/tomdroid/beta/0.7.3/+download/tomdroid-src-0.7.3.tar.gz
                    - source_hash: md5=79eef25f9b0b2c642c62b7f737d4f53f
        Known issues:
            If the remote server URL has the hash file as an apparent
            sub-directory of the source file, the module will discover that it
            has already cached a directory where a file should be cached. For
            example:
            .. code-block:: yaml
                tomdroid-src-0.7.3.tar.gz:
                  file.managed:
                    - name: /tmp/tomdroid-src-0.7.3.tar.gz
                    - source: https://launchpad.net/tomdroid/beta/0.7.3/+download/tomdroid-src-0.7.3.tar.gz
                    - source_hash: https://launchpad.net/tomdroid/beta/0.7.3/+download/tomdroid-src-0.7.3.tar.gz/+md5
    source_hash_name
        When ``source_hash`` refers to a hash file, Salt will try to find the
        correct hash by matching the filename/URI associated with that hash. By
        default, Salt will look for the filename being managed. When managing a
        file at path ``/tmp/foo.txt``, then the following line in a hash file
        would match:
        .. code-block:: text
            acbd18db4cc2f85cedef654fccc4a4d8    foo.txt
        However, sometimes a hash file will include multiple similar paths:
        .. code-block:: text
            37b51d194a7513e45b56f6524f2d51f2    ./dir1/foo.txt
            acbd18db4cc2f85cedef654fccc4a4d8    ./dir2/foo.txt
            73feffa4b7f6bb68e44cf984c85f6e88    ./dir3/foo.txt
        In cases like this, Salt may match the incorrect hash. This argument
        can be used to tell Salt which filename to match, to ensure that the
        correct hash is identified. For example:
        .. code-block:: yaml
            /tmp/foo.txt:
              file.managed:
                - source: https://mydomain.tld/dir2/foo.txt
                - source_hash: https://mydomain.tld/hashes
                - source_hash_name: ./dir2/foo.txt
        .. note::
            This argument must contain the full filename entry from the
            checksum file, as this argument is meant to disambiguate matches
            for multiple files that have the same basename. So, in the
            example above, simply using ``foo.txt`` would not match.
        .. versionadded:: 2016.3.5
    keep_source
        Set to ``False`` to discard the cached copy of the source file once the
        state completes. This can be useful for larger files to keep them from
        taking up space in minion cache. However, keep in mind that discarding
        the source file will result in the state needing to re-download the
        source file if the state is run again.
        .. versionadded:: 2017.7.3
    user
        The user to own the file, this defaults to the user salt is running as
        on the minion
    group
        The group ownership set for the file, this defaults to the group salt
        is running as on the minion. On Windows, this is ignored
    mode
        The permissions to set on this file, e.g. ``644``, ``0775``, or
        ``4664``.
        The default mode for new files and directories corresponds to the
        umask of the salt process. The mode of existing files and directories
        will only be changed if ``mode`` is specified.
        .. note::
            This option is **not** supported on Windows.
        .. versionchanged:: 2016.11.0
            This option can be set to ``keep``, and Salt will keep the mode
            from the Salt fileserver. This is only supported when the
            ``source`` URL begins with ``salt://``, or for files local to the
            minion. Because the ``source`` option cannot be used with any of
            the ``contents`` options, setting the ``mode`` to ``keep`` is also
            incompatible with the ``contents`` options.
        .. note:: keep does not work with salt-ssh.
            As a consequence of how the files are transferred to the minion, and
            the inability to connect back to the master with salt-ssh, salt is
            unable to stat the file as it exists on the fileserver and thus
            cannot mirror the mode on the salt-ssh minion
    attrs
        The attributes to have on this file, e.g. ``a``, ``i``. The attributes
        can be any or a combination of the following characters:
        ``aAcCdDeijPsStTu``.
        .. note::
            This option is **not** supported on Windows.
        .. versionadded:: 2018.3.0
    template
        If this setting is applied, the named templating engine will be used to
        render the downloaded file. The following templates are supported:
        - :mod:`cheetah&lt;salt.renderers.cheetah&gt;`
        - :mod:`genshi&lt;salt.renderers.genshi&gt;`
        - :mod:`jinja&lt;salt.renderers.jinja&gt;`
        - :mod:`mako&lt;salt.renderers.mako&gt;`
        - :mod:`py&lt;salt.renderers.py&gt;`
        - :mod:`wempy&lt;salt.renderers.wempy&gt;`
    makedirs
        If set to ``True``, then the parent directories will be created to
        facilitate the creation of the named file. If ``False``, and the parent
        directory of the destination file doesn't exist, the state will fail.
    dir_mode
        If directories are to be created, passing this option specifies the
        permissions for those directories. If this is not set, directories
        will be assigned permissions by adding the execute bit to the mode of
        the files.
        The default mode for new files and directories corresponds umask of salt
        process. For existing files and directories it's not enforced.
    replace
        If set to ``False`` and the file already exists, the file will not be
        modified even if changes would otherwise be made. Permissions and
        ownership will still be enforced, however.
    context
        Overrides default context variables passed to the template.
    defaults
        Default context passed to the template.
    backup
        Overrides the default backup mode for this specific file. See
        :ref:`backup_mode documentation &lt;file-state-backups&gt;` for more details.
    show_changes
        Output a unified diff of the old file and the new file. If ``False``
        return a boolean if any changes were made.
    create
        If set to ``False``, then the file will only be managed if the file
        already exists on the system.
    contents
        Specify the contents of the file. Cannot be used in combination with
        ``source``. Ignores hashes and does not use a templating engine.
        This value can be either a single string, a multiline YAML string or a
        list of strings.  If a list of strings, then the strings will be joined
        together with newlines in the resulting file. For example, the below
        two example states would result in identical file contents:
        .. code-block:: yaml
            /path/to/file1:
              file.managed:
                - contents:
                  - This is line 1
                  - This is line 2
            /path/to/file2:
              file.managed:
                - contents: |
                    This is line 1
                    This is line 2
    contents_pillar
        .. versionadded:: 0.17.0
        .. versionchanged:: 2016.11.0
            contents_pillar can also be a list, and the pillars will be
            concatenated together to form one file.
        Operates like ``contents``, but draws from a value stored in pillar,
        using the pillar path syntax used in :mod:`pillar.get
        &lt;salt.modules.pillar.get&gt;`. This is useful when the pillar value
        contains newlines, as referencing a pillar variable using a jinja/mako
        template can result in YAML formatting issues due to the newlines
        causing indentation mismatches.
        For example, the following could be used to deploy an SSH private key:
        .. code-block:: yaml
            /home/deployer/.ssh/id_rsa:
              file.managed:
                - user: deployer
                - group: deployer
                - mode: 600
                - attrs: a
                - contents_pillar: userdata:deployer:id_rsa
        This would populate ``/home/deployer/.ssh/id_rsa`` with the contents of
        ``pillar['userdata']['deployer']['id_rsa']``. An example of this pillar
        setup would be like so:
        .. code-block:: yaml
            userdata:
              deployer:
                id_rsa: |
                    -----BEGIN RSA PRIVATE KEY-----
                    MIIEowIBAAKCAQEAoQiwO3JhBquPAalQF9qP1lLZNXVjYMIswrMe2HcWUVBgh+vY
                    U7sCwx/dH6+VvNwmCoqmNnP+8gTPKGl1vgAObJAnMT623dMXjVKwnEagZPRJIxDy
                    B/HaAre9euNiY3LvIzBTWRSeMfT+rWvIKVBpvwlgGrfgz70m0pqxu+UyFbAGLin+
                    GpxzZAMaFpZw4sSbIlRuissXZj/sHpQb8p9M5IeO4Z3rjkCP1cxI
                    -----END RSA PRIVATE KEY-----
        .. note::
            The private key above is shortened to keep the example brief, but
            shows how to do multiline string in YAML. The key is followed by a
            pipe character, and the multiline string is indented two more
            spaces.
            To avoid the hassle of creating an indented multiline YAML string,
            the :mod:`file_tree external pillar &lt;salt.pillar.file_tree&gt;` can
            be used instead. However, this will not work for binary files in
            Salt releases before 2015.8.4.
    contents_grains
        .. versionadded:: 2014.7.0
        Operates like ``contents``, but draws from a value stored in grains,
        using the grains path syntax used in :mod:`grains.get
        &lt;salt.modules.grains.get&gt;`. This functionality works similarly to
        ``contents_pillar``, but with grains.
        For example, the following could be used to deploy a "message of the day"
        file:
        .. code-block:: yaml
            write_motd:
              file.managed:
                - name: /etc/motd
                - contents_grains: motd
        This would populate ``/etc/motd`` file with the contents of the ``motd``
        grain. The ``motd`` grain is not a default grain, and would need to be
        set prior to running the state:
        .. code-block:: bash
            salt '*' grains.set motd 'Welcome! This system is managed by Salt.'
    contents_newline
        .. versionadded:: 2014.7.0
        .. versionchanged:: 2015.8.4
            This option is now ignored if the contents being deployed contain
            binary data.
        If ``True``, files managed using ``contents``, ``contents_pillar``, or
        ``contents_grains`` will have a newline added to the end of the file if
        one is not present. Setting this option to ``False`` will ensure the
        final line, or entry, does not contain a new line. If the last line, or
        entry in the file does contain a new line already, this option will not
        remove it.
    contents_delimiter
        .. versionadded:: 2015.8.4
        Can be used to specify an alternate delimiter for ``contents_pillar``
        or ``contents_grains``. This delimiter will be passed through to
        :py:func:`pillar.get &lt;salt.modules.pillar.get&gt;` or :py:func:`grains.get
        &lt;salt.modules.grains.get&gt;` when retrieving the contents.
    encoding
        If specified, then the specified encoding will be used. Otherwise, the
        file will be encoded using the system locale (usually UTF-8). See
        https://docs.python.org/3/library/codecs.html#standard-encodings for
        the list of available encodings.
        .. versionadded:: 2017.7.0
    encoding_errors
        Error encoding scheme. Default is ```'strict'```.
        See https://docs.python.org/2/library/codecs.html#codec-base-classes
        for the list of available schemes.
        .. versionadded:: 2017.7.0
    allow_empty
        .. versionadded:: 2015.8.4
        If set to ``False``, then the state will fail if the contents specified
        by ``contents_pillar`` or ``contents_grains`` are empty.
    follow_symlinks
        .. versionadded:: 2014.7.0
        If the desired path is a symlink follow it and make changes to the
        file to which the symlink points.
    check_cmd
        .. versionadded:: 2014.7.0
        The specified command will be run with an appended argument of a
        *temporary* file containing the new managed contents.  If the command
        exits with a zero status the new managed contents will be written to
        the managed destination. If the command exits with a nonzero exit
        code, the state will fail and no changes will be made to the file.
        For example, the following could be used to verify sudoers before making
        changes:
        .. code-block:: yaml
            /etc/sudoers:
              file.managed:
                - user: root
                - group: root
                - mode: 0440
                - attrs: i
                - source: salt://sudoers/files/sudoers.jinja
                - template: jinja
                - check_cmd: /usr/sbin/visudo -c -f
        **NOTE**: This ``check_cmd`` functions differently than the requisite
        ``check_cmd``.
    tmp_dir
        Directory for temp file created by ``check_cmd``. Useful for checkers
        dependent on config file location (e.g. daemons restricted to their
        own config directories by an apparmor profile).
        .. code-block:: yaml
            /etc/dhcp/dhcpd.conf:
              file.managed:
                - user: root
                - group: root
                - mode: 0755
                - tmp_dir: '/etc/dhcp'
                - contents: "# Managed by Salt"
                - check_cmd: dhcpd -t -cf
    tmp_ext
        Suffix for temp file created by ``check_cmd``. Useful for checkers
        dependent on config file extension (e.g. the init-checkconf upstart
        config checker).
        .. code-block:: yaml
            /etc/init/test.conf:
              file.managed:
                - user: root
                - group: root
                - mode: 0440
                - tmp_ext: '.conf'
                - contents:
                  - 'description "Salt Minion"'
                  - 'start on started mountall'
                  - 'stop on shutdown'
                  - 'respawn'
                  - 'exec salt-minion'
                - check_cmd: init-checkconf -f
    skip_verify
        If ``True``, hash verification of remote file sources (``http://``,
        ``https://``, ``ftp://``) will be skipped, and the ``source_hash``
        argument will be ignored.
        .. versionadded:: 2016.3.0
    selinux
        Allows setting the selinux user, role, type, and range of a managed file
        .. code-block:: yaml
            /tmp/selinux.test
              file.managed:
                - user: root
                - selinux:
                    seuser: system_u
                    serole: object_r
                    setype: system_conf_t
                    seranage: s0
        .. versionadded:: 3000
    win_owner
        The owner of the directory. If this is not passed, user will be used. If
        user is not passed, the account under which Salt is running will be
        used.
        .. versionadded:: 2017.7.0
    win_perms
        A dictionary containing permissions to grant and their propagation. For
        example: ``{'Administrators': {'perms': 'full_control'}}`` Can be a
        single basic perm or a list of advanced perms. ``perms`` must be
        specified. ``applies_to`` does not apply to file objects.
        .. versionadded:: 2017.7.0
    win_deny_perms
        A dictionary containing permissions to deny and their propagation. For
        example: ``{'Administrators': {'perms': 'full_control'}}`` Can be a
        single basic perm or a list of advanced perms. ``perms`` must be
        specified. ``applies_to`` does not apply to file objects.
        .. versionadded:: 2017.7.0
    win_inheritance
        True to inherit permissions from the parent directory, False not to
        inherit permission.
        .. versionadded:: 2017.7.0
    win_perms_reset
        If ``True`` the existing DACL will be cleared and replaced with the
        settings defined in this function. If ``False``, new entries will be
        appended to the existing DACL. Default is ``False``.
        .. versionadded:: 2018.3.0
    Here's an example using the above ``win_*`` parameters:
    .. code-block:: yaml
        create_config_file:
          file.managed:
            - name: C:\config\settings.cfg
            - source: salt://settings.cfg
            - win_owner: Administrators
            - win_perms:
                dev_ops:
                  perms: full_control
                appuser:
                  perms:
                    - read_attributes
                    - read_ea
                    - create_folders
                    - read_permissions
                joe_snuffy:
                  perms: read
            - win_deny_perms:
                fred_snuffy:
                  perms: full_control
            - win_inheritance: False
    verify_ssl
        If ``False``, remote https file sources (``https://``) and source_hash
        will not attempt to validate the servers certificate. Default is True.
        .. versionadded:: 3002
    use_etag
        If ``True``, remote http/https file sources will attempt to use the
        ETag header to determine if the remote file needs to be downloaded.
        This provides a lightweight mechanism for promptly refreshing files
        changed on a web server without requiring a full hash comparison via
        the ``source_hash`` parameter.
        .. versionadded:: 3005
    Converse *recurse* definition to a set of strings.
    Raises TypeError or ValueError when *recurse* has wrong structure.
    Walk the directory tree under root up till reaching max_depth.
    With max_depth=None (default), do not limit depth.
    name = os.path.expanduser(name)
    ret = {"name": name, "changes": {}, "result": True, "comment": ""}
    if not name:
        return _error(ret, "Must provide name to file.directory")
    if name[-1] == "/" and name != "/":
        name = name[:-1]
    if max_depth is not None and clean:
        return _error(ret, "Cannot specify both max_depth and clean")
    user = _test_owner(kwargs, user=user)
    if salt.utils.platform.is_windows():
        if win_owner is None:
            win_owner = user if user else salt.utils.win_functions.get_current_user()
        if group is not None:
            log.warning(
                "The group argument for %s has been ignored as this is "
                "a Windows system. Please use the `win_*` parameters to set "
                "permissions in Windows.",
                name,
            )
        group = user
    if "mode" in kwargs and not dir_mode:
        dir_mode = kwargs.get("mode", [])
    if not file_mode:
        file_mode = dir_mode
    dir_mode = salt.utils.files.normalize_mode(dir_mode)
    file_mode = salt.utils.files.normalize_mode(file_mode)
    if salt.utils.platform.is_windows():
        try:
            salt.utils.win_dacl.get_sid(win_owner)
        except CommandExecutionError as exc:
            return _error(ret, exc)
    else:
        u_check = _check_user(user, group)
        if u_check:
            return _error(ret, u_check)
    if not os.path.isabs(name):
        return _error(ret, "Specified file {} is not an absolute path".format(name))
    if (
        os.path.isfile(name)
        or (not allow_symlink and os.path.islink(name))
        or (force and os.path.islink(name))
    ):
        if backupname is not None:
            if os.path.lexists(backupname):
                if not force:
                    return _error(
                        ret,
                        "File exists where the backup target {} should go".format(
                            backupname
                        ),
                    )
                else:
                    __salt__["file.remove"](backupname)
            os.rename(name, backupname)
        elif force:
            if os.path.isfile(name):
                if __opts__["test"]:
                    ret["changes"]["forced"] = "File would be forcibly replaced"
                else:
                    os.remove(name)
                    ret["changes"]["forced"] = "File was forcibly replaced"
            elif __salt__["file.is_link"](name):
                if __opts__["test"]:
                    ret["changes"]["forced"] = "Symlink would be forcibly replaced"
                else:
                    __salt__["file.remove"](name)
                    ret["changes"]["forced"] = "Symlink was forcibly replaced"
            else:
                if __opts__["test"]:
                    ret["changes"]["forced"] = "Directory would be forcibly replaced"
                else:
                    __salt__["file.remove"](name)
                    ret["changes"]["forced"] = "Directory was forcibly replaced"
        else:
            if os.path.isfile(name):
                return _error(
                    ret, "Specified location {} exists and is a file".format(name)
                )
            elif os.path.islink(name):
                return _error(
                    ret, "Specified location {} exists and is a symlink".format(name)
                )
    if salt.utils.platform.is_windows():
        tresult, tcomment, tchanges = _check_directory_win(
            name=name,
            win_owner=win_owner,
            win_perms=win_perms,
            win_deny_perms=win_deny_perms,
            win_inheritance=win_inheritance,
            win_perms_reset=win_perms_reset,
        )
    else:
        tresult, tcomment, tchanges = _check_directory(
            name,
            user,
            group,
            recurse or [],
            dir_mode,
            file_mode,
            clean,
            require,
            exclude_pat,
            max_depth,
            follow_symlinks,
        )
    if tchanges:
        ret["changes"].update(tchanges)
    if __opts__["test"] or not ret["changes"]:
        ret["result"] = tresult
        ret["comment"] = tcomment
        return ret
    if not os.path.isdir(name):
        if not os.path.isdir(os.path.dirname(name)):
            if makedirs:
                try:
                    _makedirs(
                        name=name,
                        user=user,
                        group=group,
                        dir_mode=dir_mode,
                        win_owner=win_owner,
                        win_perms=win_perms,
                        win_deny_perms=win_deny_perms,
                        win_inheritance=win_inheritance,
                    )
                except CommandExecutionError as exc:
                    return _error(ret, "Drive {} is not mapped".format(exc.message))
            else:
                return _error(ret, "No directory to create {} in".format(name))
        if salt.utils.platform.is_windows():
            __salt__["file.mkdir"](
                path=name,
                owner=win_owner,
                grant_perms=win_perms,
                deny_perms=win_deny_perms,
                inheritance=win_inheritance,
                reset=win_perms_reset,
            )
        else:
            __salt__["file.mkdir"](name, user=user, group=group, mode=dir_mode)
        if not os.path.isdir(name):
            return _error(ret, "Failed to create directory {}".format(name))
        ret["changes"][name] = {"directory": "new"}
        return ret
    if not children_only:
        if salt.utils.platform.is_windows():
            ret = __salt__["file.check_perms"](
                path=name,
                ret=ret,
                owner=win_owner,
                grant_perms=win_perms,
                deny_perms=win_deny_perms,
                inheritance=win_inheritance,
                reset=win_perms_reset,
            )
        else:
            ret, perms = __salt__["file.check_perms"](
                name, ret, user, group, dir_mode, None, follow_symlinks
            )
    errors = []
    if recurse or clean:
        walk_l = list(_depth_limited_walk(name, max_depth))
        walk_d = {}
        for i in walk_l:
            walk_d[i[0]] = (i[1], i[2])
    recurse_set = None
    if recurse:
        try:
            recurse_set = _get_recurse_set(recurse)
        except (TypeError, ValueError) as exc:
            ret["result"] = False
            ret["comment"] = "{}".format(exc)
    if recurse_set:
        if "user" in recurse_set:
            if user or isinstance(user, int):
                uid = __salt__["file.user_to_uid"](user)
                if isinstance(uid, str):
                    ret["result"] = False
                    ret["comment"] = (
                        "Failed to enforce ownership for "
                        "user {} (user does not "
                        "exist)".format(user)
                    )
            else:
                ret["result"] = False
                ret["comment"] = (
                    "user not specified, but configured as "
                    "a target for recursive ownership "
                    "management"
                )
        else:
            user = None
        if "group" in recurse_set:
            if group or isinstance(group, int):
                gid = __salt__["file.group_to_gid"](group)
                if isinstance(gid, str):
                    ret["result"] = False
                    ret[
                        "comment"
                    ] = "Failed to enforce group ownership for group {}".format(group)
            else:
                ret["result"] = False
                ret["comment"] = (
                    "group not specified, but configured "
                    "as a target for recursive ownership "
                    "management"
                )
        else:
            group = None
        if "mode" not in recurse_set:
            file_mode = None
            dir_mode = None
        if "silent" in recurse_set:
            ret["changes"] = {"recursion": "Changes silenced"}
        check_files = "ignore_files" not in recurse_set
        check_dirs = "ignore_dirs" not in recurse_set
        for root, dirs, files in walk_l:
            if check_files:
                for fn_ in files:
                    full = os.path.join(root, fn_)
                    try:
                        if salt.utils.platform.is_windows():
                            ret = __salt__["file.check_perms"](
                                path=full,
                                ret=ret,
                                owner=win_owner,
                                grant_perms=win_perms,
                                deny_perms=win_deny_perms,
                                inheritance=win_inheritance,
                                reset=win_perms_reset,
                            )
                        else:
                            ret, _ = __salt__["file.check_perms"](
                                full, ret, user, group, file_mode, None, follow_symlinks
                            )
                    except CommandExecutionError as exc:
                        if not exc.strerror.startswith("Path not found"):
                            errors.append(exc.strerror)
            if check_dirs:
                for dir_ in dirs:
                    full = os.path.join(root, dir_)
                    try:
                        if salt.utils.platform.is_windows():
                            ret = __salt__["file.check_perms"](
                                path=full,
                                ret=ret,
                                owner=win_owner,
                                grant_perms=win_perms,
                                deny_perms=win_deny_perms,
                                inheritance=win_inheritance,
                                reset=win_perms_reset,
                            )
                        else:
                            ret, _ = __salt__["file.check_perms"](
                                full, ret, user, group, dir_mode, None, follow_symlinks
                            )
                    except CommandExecutionError as exc:
                        if not exc.strerror.startswith("Path not found"):
                            errors.append(exc.strerror)
    if clean:
        keep = _gen_keep_files(name, require, walk_d)
        log.debug("List of kept files when use file.directory with clean: %s", keep)
        removed = _clean_dir(name, list(keep), exclude_pat)
        if removed:
            ret["changes"]["removed"] = removed
            ret["comment"] = "Files cleaned from directory {}".format(name)
    if not ret["comment"]:
        if children_only:
            ret["comment"] = "Directory {}/* updated".format(name)
        else:
            if ret["changes"]:
                ret["comment"] = "Directory {} updated".format(name)
    if __opts__["test"]:
        ret["comment"] = "Directory {} not updated".format(name)
    elif not ret["changes"] and ret["result"]:
        orig_comment = None
        if ret["comment"]:
            orig_comment = ret["comment"]
        ret["comment"] = "Directory {} is in the correct state".format(name)
        if orig_comment:
            ret["comment"] = "\n".join([ret["comment"], orig_comment])
    if errors:
        ret["result"] = False
        ret["comment"] += "\n\nThe following errors were encountered:\n"
        for error in errors:
            ret["comment"] += "\n- {}".format(error)
    return ret
def recurse(
    name,
    source,
    keep_source=True,
    clean=False,
    require=None,
    user=None,
    group=None,
    dir_mode=None,
    file_mode=None,
    sym_mode=None,
    template=None,
    context=None,
    replace=True,
    defaults=None,
    include_empty=False,
    backup="",
    include_pat=None,
    exclude_pat=None,
    maxdepth=None,
    keep_symlinks=False,
    force_symlinks=False,
    win_owner=None,
    win_perms=None,
    win_deny_perms=None,
    win_inheritance=True,
    **kwargs
):
    if "env" in kwargs:
        kwargs.pop("env")
    name = os.path.expanduser(salt.utils.data.decode(name))
    user = _test_owner(kwargs, user=user)
    if salt.utils.platform.is_windows():
        if group is not None:
            log.warning(
                "The group argument for %s has been ignored as this "
                "is a Windows system.",
                name,
            )
        group = user
    ret = {
        "name": name,
        "changes": {},
        "result": True,
        "comment": {},  # { path: [comment, ...] }
    }
    if "mode" in kwargs:
        ret["result"] = False
        ret["comment"] = (
            "'mode' is not allowed in 'file.recurse'. Please use "
            "'file_mode' and 'dir_mode'."
        )
        return ret
    if (
        any([x is not None for x in (dir_mode, file_mode, sym_mode)])
        and salt.utils.platform.is_windows()
    ):
        return _error(ret, "mode management is not supported on Windows")
    dir_mode = salt.utils.files.normalize_mode(dir_mode)
    try:
        keep_mode = file_mode.lower() == "keep"
        if keep_mode:
            file_mode = None
    except AttributeError:
        keep_mode = False
    file_mode = salt.utils.files.normalize_mode(file_mode)
    u_check = _check_user(user, group)
    if u_check:
        return _error(ret, u_check)
    if not os.path.isabs(name):
        return _error(ret, "Specified file {} is not an absolute path".format(name))
    source_list = _validate_str_list(source)
    for idx, val in enumerate(source_list):
        source_list[idx] = val.rstrip("/")
    for precheck in source_list:
        if not precheck.startswith("salt://"):
            return _error(
                ret,
                "Invalid source '{}' (must be a salt:// URI)".format(precheck),
            )
    try:
        source, source_hash = __salt__["file.source_list"](source_list, "", __env__)
    except CommandExecutionError as exc:
        ret["result"] = False
        ret["comment"] = "Recurse failed: {}".format(exc)
        return ret
    srcpath, senv = salt.utils.url.parse(source)
    if senv is None:
        senv = __env__
    master_dirs = __salt__["cp.list_master_dirs"](saltenv=senv)
    if srcpath not in master_dirs and not any(
        x for x in master_dirs if x.startswith(srcpath + "/")
    ):
        ret["result"] = False
        ret["comment"] = (
            "The directory '{}' does not exist on the salt fileserver "
            "in saltenv '{}'".format(srcpath, senv)
        )
        return ret
    if not os.path.isdir(name):
        if os.path.exists(name):
            return _error(ret, "The path {} exists and is not a directory".format(name))
        if not __opts__["test"]:
            if salt.utils.platform.is_windows():
                win_owner = win_owner if win_owner else user
                __salt__["file.makedirs_perms"](
                    path=name,
                    owner=win_owner,
                    grant_perms=win_perms,
                    deny_perms=win_deny_perms,
                    inheritance=win_inheritance,
                )
            else:
                __salt__["file.makedirs_perms"](
                    name=name, user=user, group=group, mode=dir_mode
                )
    def add_comment(path, comment):
        comments = ret["comment"].setdefault(path, [])
        if isinstance(comment, str):
            comments.append(comment)
        else:
            comments.extend(comment)
    def merge_ret(path, _ret):
        if _ret["result"] is False or ret["result"] is True:
            ret["result"] = _ret["result"]
        if _ret["result"] is not True and _ret["comment"]:
            add_comment(path, _ret["comment"])
        if _ret["changes"]:
            ret["changes"][path] = _ret["changes"]
    def manage_file(path, source, replace):
        if clean and os.path.exists(path) and os.path.isdir(path) and replace:
            _ret = {"name": name, "changes": {}, "result": True, "comment": ""}
            if __opts__["test"]:
                _ret["comment"] = "Replacing directory {} with a file".format(path)
                _ret["result"] = None
                merge_ret(path, _ret)
                return
            else:
                __salt__["file.remove"](path)
                _ret["changes"] = {"diff": "Replaced directory with a new file"}
                merge_ret(path, _ret)
        pass_kwargs = {}
        faults = ["mode", "makedirs"]
        for key in kwargs:
            if key not in faults:
                pass_kwargs[key] = kwargs[key]
        _ret = managed(
            path,
            source=source,
            keep_source=keep_source,
            user=user,
            group=group,
            mode="keep" if keep_mode else file_mode,
            attrs=None,
            template=template,
            makedirs=True,
            replace=replace,
            context=context,
            defaults=defaults,
            backup=backup,
            **pass_kwargs
        )
        merge_ret(path, _ret)
    def manage_directory(path):
        if os.path.basename(path) == "..":
            return
        if clean and os.path.exists(path) and not os.path.isdir(path):
            _ret = {"name": name, "changes": {}, "result": True, "comment": ""}
            if __opts__["test"]:
                _ret["comment"] = "Replacing {} with a directory".format(path)
                _ret["result"] = None
                merge_ret(path, _ret)
                return
            else:
                __salt__["file.remove"](path)
                _ret["changes"] = {"diff": "Replaced file with a directory"}
                merge_ret(path, _ret)
        _ret = directory(
            path,
            user=user,
            group=group,
            recurse=[],
            dir_mode=dir_mode,
            file_mode=None,
            makedirs=True,
            clean=False,
            require=None,
        )
        merge_ret(path, _ret)
    mng_files, mng_dirs, mng_symlinks, keep = _gen_recurse_managed_files(
        name, source, keep_symlinks, include_pat, exclude_pat, maxdepth, include_empty
    )
    for srelpath, ltarget in mng_symlinks:
        _ret = symlink(
            os.path.join(name, srelpath),
            ltarget,
            makedirs=True,
            force=force_symlinks,
            user=user,
            group=group,
            mode=sym_mode,
        )
        if not _ret:
            continue
        merge_ret(os.path.join(name, srelpath), _ret)
    for dirname in mng_dirs:
        manage_directory(dirname)
    for dest, src in mng_files:
        manage_file(dest, src, replace)
    if clean:
        keep.update(_gen_keep_files(name, require))
        removed = _clean_dir(name, list(keep), exclude_pat)
        if removed:
            if __opts__["test"]:
                if ret["result"]:
                    ret["result"] = None
                add_comment("removed", removed)
            else:
                ret["changes"]["removed"] = removed
    ret["comment"] = "\n".join(
        "\n#### {} ####\n{}".format(k, v if isinstance(v, str) else "\n".join(v))
        for (k, v) in ret["comment"].items()
    ).strip()
    if not ret["comment"]:
        ret["comment"] = "Recursively updated {}".format(name)
    if not ret["changes"] and ret["result"]:
        ret["comment"] = "The directory {} is in the correct state".format(name)
    return ret
def retention_schedule(name, retain, strptime_format=None, timezone=None):
    name = os.path.expanduser(name)
    ret = {
        "name": name,
        "changes": {"retained": [], "deleted": [], "ignored": []},
        "result": True,
        "comment": "",
    }
    if not name:
        return _error(ret, "Must provide name to file.retention_schedule")
    if not os.path.isdir(name):
        return _error(ret, "Name provided to file.retention must be a directory")
    all_files = __salt__["file.readdir"](name)
    beginning_of_unix_time = datetime(1970, 1, 1)
    def get_file_time_from_strptime(f):
        try:
            ts = datetime.strptime(f, strptime_format)
            ts_epoch = salt.utils.dateutils.total_seconds(ts - beginning_of_unix_time)
            return (ts, ts_epoch)
        except ValueError:
            return (None, None)
    def get_file_time_from_mtime(f):
        if f == "." or f == "..":
            return (None, None)
        lstat = __salt__["file.lstat"](os.path.join(name, f))
        if lstat:
            mtime = lstat["st_mtime"]
            return (datetime.fromtimestamp(mtime, timezone), mtime)
        else:  # maybe it was deleted since we did the readdir?
            return (None, None)
    get_file_time = (
        get_file_time_from_strptime if strptime_format else get_file_time_from_mtime
    )
    def dict_maker():
        return defaultdict(dict_maker)
    files_by_ymd = dict_maker()
    files_by_y_week_dow = dict_maker()
    relevant_files = set()
    ignored_files = set()
    for f in all_files:
        ts, ts_epoch = get_file_time(f)
        if ts:
            files_by_ymd[ts.year][ts.month][ts.day][ts.hour][ts_epoch] = f
            week_of_year = ts.isocalendar()[1]
            files_by_y_week_dow[ts.year][week_of_year][ts.weekday()][ts_epoch] = f
            relevant_files.add(f)
        else:
            ignored_files.add(f)
    RETAIN_TO_DEPTH = {
        "first_of_year": 1,
        "first_of_month": 2,
        "first_of_day": 3,
        "first_of_hour": 4,
        "most_recent": 5,
    }
    def get_first(fwt):
        if isinstance(fwt, dict):
            first_sub_key = sorted(fwt.keys())[0]
            return get_first(fwt[first_sub_key])
        else:
            return {fwt}
    def get_first_n_at_depth(fwt, depth, n):
        if depth &lt;= 0:
            return get_first(fwt)
        else:
            result_set = set()
            for k in sorted(fwt.keys(), reverse=True):
                needed = n - len(result_set)
                if needed &lt; 1:
                    break
                result_set |= get_first_n_at_depth(fwt[k], depth - 1, needed)
            return result_set
    retained_files = set()
    for retention_rule, keep_count in retain.items():
        keep_count = sys.maxsize if "all" == keep_count else int(keep_count)
        if "first_of_week" == retention_rule:
            first_of_week_depth = 2  # year + week_of_year = 2
            retained_files |= get_first_n_at_depth(
                files_by_y_week_dow, first_of_week_depth, keep_count + 1
            )
        else:
            retained_files |= get_first_n_at_depth(
                files_by_ymd, RETAIN_TO_DEPTH[retention_rule], keep_count
            )
    deletable_files = list(relevant_files - retained_files)
    deletable_files.sort(reverse=True)
    changes = {
        "retained": sorted(list(retained_files), reverse=True),
        "deleted": deletable_files,
        "ignored": sorted(list(ignored_files), reverse=True),
    }
    ret["changes"] = changes
    if __opts__["test"]:
        ret["comment"] = "{} backups would have been removed from {}.\n".format(
            len(deletable_files), name
        )
        if deletable_files:
            ret["result"] = None
    else:
        for f in deletable_files:
            __salt__["file.remove"](os.path.join(name, f))
        ret["comment"] = "{} backups were removed from {}.\n".format(
            len(deletable_files), name
        )
        ret["changes"] = changes
    return ret
def line(
    name,
    content=None,
    match=None,
    mode=None,
    location=None,
    before=None,
    after=None,
    show_changes=True,
    backup=False,
    quiet=False,
    indent=True,
    create=False,
    user=None,
    group=None,
    file_mode=None,
):
    name = os.path.expanduser(name)
    ret = {"name": name, "changes": {}, "result": True, "comment": ""}
    if not name:
        return _error(ret, "Must provide name to file.line")
    managed(name, create=create, user=user, group=group, mode=file_mode, replace=False)
    check_res, check_msg = _check_file(name)
    if not check_res:
        return _error(ret, check_msg)
    mode = mode and mode.lower() or mode
    if mode is None:
        return _error(ret, "Mode was not defined. How to process the file?")
    modeswithemptycontent = ["delete"]
    if mode not in modeswithemptycontent and content is None:
        return _error(
            ret,
            "Content can only be empty if mode is {}".format(modeswithemptycontent),
        )
    del modeswithemptycontent
    changes = __salt__["file.line"](
        name,
        content,
        match=match,
        mode=mode,
        location=location,
        before=before,
        after=after,
        show_changes=show_changes,
        backup=backup,
        quiet=quiet,
        indent=indent,
    )
<a name="0"></a>    if changes:
        ret["changes"]["diff"] = changes
        if __opts__["test"]:
            ret<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["result"] = None
            ret["comment"] = "Changes would be made"
        else:
            ret["result"] = True
            ret["comment"] = "Changes were made"
    else:
        ret["result"] = True
        ret["comment"] = "No changes needed to be made"
    return ret
def replace(
    name,
    pattern,
    repl,
    count=0,
    flags=</b></font>8,
    bufsize=1,
    append_if_not_found=False,
    prepend_if_not_found=False,
    not_found_content=None,
    backup=".bak",
    show_changes=True,
    ignore_if_missing=False,
    backslash_literal=False,
):
    r"""
    Maintain an edit in a file.
    .. versionadded:: 0.17.0
    name
        Filesystem path to the file to be edited. If a symlink is specified, it
        will be resolved to its target.
    pattern
        A regular expression, to be matched using Python's
        :py:func:`re.search`.
        .. note::
            If you need to match a literal string that contains regex special
            characters, you may want to use salt's custom Jinja filter,
            ``regex_escape``.
            .. code-block:: jinja
                {{ 'http://example.com?foo=bar%20baz' | regex_escape }}
    repl
        The replacement text
    count
        Maximum number of pattern occurrences to be replaced.  Defaults to 0.
        If count is a positive integer n, no more than n occurrences will be
        replaced, otherwise all occurrences will be replaced.
    flags
        A list of flags defined in the ``re`` module documentation from the
        Python standard library. Each list item should be a string that will
        correlate to the human-friendly flag name. E.g., ``['IGNORECASE',
        'MULTILINE']``.  Optionally, ``flags`` may be an int, with a value
        corresponding to the XOR (``|``) of all the desired flags. Defaults to
        ``8`` (which equates to ``['MULTILINE']``).
        .. note::
            ``file.replace`` reads the entire file as a string to support
            multiline regex patterns. Therefore, when using anchors such as
            ``^`` or ``$`` in the pattern, those anchors may be relative to
            the line OR relative to the file. The default for ``file.replace``
            is to treat anchors as relative to the line, which is implemented
            by setting the default value of ``flags`` to ``['MULTILINE']``.
            When overriding the default value for ``flags``, if
            ``'MULTILINE'`` is not present then anchors will be relative to
            the file. If the desired behavior is for anchors to be relative to
            the line, then simply add ``'MULTILINE'`` to the list of flags.
    bufsize
        How much of the file to buffer into memory at once. The default value
        ``1`` processes one line at a time. The special value ``file`` may be
        specified which will read the entire file into memory before
        processing.
    append_if_not_found
        If set to ``True``, and pattern is not found, then the content will be
        appended to the file.
        .. versionadded:: 2014.7.0
    prepend_if_not_found
        If set to ``True`` and pattern is not found, then the content will be
        prepended to the file.
        .. versionadded:: 2014.7.0
    not_found_content
        Content to use for append/prepend if not found. If ``None`` (default),
        uses ``repl``. Useful when ``repl`` uses references to group in
        pattern.
        .. versionadded:: 2014.7.0
    backup
        The file extension to use for a backup of the file before editing. Set
        to ``False`` to skip making a backup.
    show_changes
        Output a unified diff of the old file and the new file. If ``False``
        return a boolean if any changes were made. Returns a boolean or a
        string.
        .. note:
            Using this option will store two copies of the file in memory (the
            original version and the edited version) in order to generate the
            diff. This may not normally be a concern, but could impact
            performance if used with large files.
    ignore_if_missing
        .. versionadded:: 2016.3.4
        Controls what to do if the file is missing. If set to ``False``, the
        state will display an error raised by the execution module. If set to
        ``True``, the state will simply report no changes.
    backslash_literal
        .. versionadded:: 2016.11.7
        Interpret backslashes as literal backslashes for the repl and not
        escape characters.  This will help when using append/prepend so that
        the backslashes are not interpreted for the repl on the second run of
        the state.
    For complex regex patterns, it can be useful to avoid the need for complex
    quoting and escape sequences by making use of YAML's multiline string
    syntax.
    .. code-block:: yaml
        complex_search_and_replace:
          file.replace:
            - pattern: |
                CentOS \(2.6.32[^\\n]+\\n\s+root[^\\n]+\\n\)+
    .. note::
       When using YAML multiline string syntax in ``pattern:``, make sure to
       also use that syntax in the ``repl:`` part, or you might loose line
       feeds.
    When regex capture groups are used in ``pattern:``, their captured value is
    available for reuse in the ``repl:`` part as a backreference (ex. ``\1``).
    .. code-block:: yaml
        add_login_group_to_winbind_ssh_access_list:
          file.replace:
            - name: '/etc/security/pam_winbind.conf'
            - pattern: '^(require_membership_of = )(.*)$'
            - repl: '\1\2,append-new-group-to-line'
    .. note::
       The ``file.replace`` state uses Python's ``re`` module.
       For more advanced options, see https://docs.python.org/2/library/re.html
        ret["changes"]["diff"] <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= changes
        if __opts__["test"]:
            ret["result"] = None
            ret["comment"] = "Changes would have been made"
        else:
            ret["result"] = True
            ret["comment"] =</b></font> "Changes were made"
    else:
        ret["result"] = True
        ret["comment"] = "No changes needed to be made"
    return ret
def keyvalue(
    name,
    key=None,
    value=None,
    key_values=None,
    separator="=",
    append_if_not_found=False,
    prepend_if_not_found=False,
    search_only=False,
    show_changes=True,
    ignore_if_missing=False,
    count=1,
    uncomment=None,
    key_ignore_case=False,
    value_ignore_case=False,
):
    name = os.path.expanduser(name)
    ret = {
        "name": name,
        "changes": {},
        "result": None,
        "comment": "",
    }
    if not name:
        return _error(ret, "Must provide name to file.keyvalue")
    if key is not None and value is not None:
        if type(key_values) is dict:
            return _error(
                ret, "file.keyvalue can not combine key_values with key and value"
            )
        key_values = {str(key): value}
    elif not isinstance(key_values, dict) or not key_values:
        msg = "is not a dictionary"
        if not key_values:
            msg = "is empty"
        return _error(
            ret,
            "file.keyvalue key and value not supplied and key_values " + msg,
        )
    file_contents = []
    try:
        with salt.utils.files.fopen(name, "r") as fd:
            file_contents = fd.readlines()
    except OSError:
        ret["comment"] = "unable to open {n}".format(n=name)
        ret["result"] = True if ignore_if_missing else False
        return ret
    diff = []
    content = []
    tmpl = "{key}{sep}{value}" + os.linesep
    changes = 0
    diff_count = {k: count for k in key_values.keys()}
    for line in file_contents:
        test_line = line.lstrip(uncomment)
        did_uncomment = True if len(line) &gt; len(test_line) else False
        if key_ignore_case:
            test_line = test_line.lower()
        for key, value in key_values.items():
            test_key = key.lower() if key_ignore_case else key
            if test_line.startswith(test_key):
                working_line = line.lstrip(uncomment) if did_uncomment else line
                line_key, line_sep, line_value = working_line.partition(separator)
                if line_sep != separator:
                    continue
                keys_match = False
                if key_ignore_case:
                    if line_key.lower() == test_key:
                        keys_match = True
                else:
                    if line_key == test_key:
                        keys_match = True
                if keys_match:
                    line_value = line_value.strip()
                    test_value = str(value).strip()
                    if value_ignore_case:
                        line_value = line_value.lower()
                        test_value = test_value.lower()
                    values_match = True if line_value == test_value else False
                    needs_changing = False
                    if did_uncomment:
                        if diff_count[key] &gt; 0:
                            needs_changing = True
                        elif not values_match:
                            values_match = True
                    else:
                        if diff_count[key] == 0:
                            needs_changing = True
                    if not values_match or needs_changing:
                        diff.append("- {}".format(line))
                        line = line[:0]
                        if diff_count[key] != 0:
                            line = str(
                                tmpl.format(key=line_key, sep=line_sep, value=value)
                            )
                            if not isinstance(value, str):
                                diff.append(
                                    "+ {} (from {} type){}".format(
                                        line.rstrip(), type(value).__name__, os.linesep
                                    )
                                )
                            else:
                                diff.append("+ {}".format(line))
                        changes += 1
                    if diff_count[key] &gt; 0:
                        diff_count[key] -= 1
                    continue
        content.append(line)
    fd.close()
    if append_if_not_found:
        tmpdiff = []
        for key, value in key_values.items():
            if diff_count[key] &gt; 0:
                line = tmpl.format(key=key, sep=separator, value=value)
                tmpdiff.append("+ {}".format(line))
                content.append(line)
                changes += 1
        if tmpdiff:
            tmpdiff.insert(0, "- &lt;EOF&gt;" + os.linesep)
            tmpdiff.append("+ &lt;EOF&gt;" + os.linesep)
            diff.extend(tmpdiff)
    elif prepend_if_not_found:
        did_diff = False
        for key, value in key_values.items():
            if diff_count[key] &gt; 0:
                line = tmpl.format(key=key, sep=separator, value=value)
                if not did_diff:
                    diff.insert(0, "  &lt;SOF&gt;" + os.linesep)
                    did_diff = True
                diff.insert(1, "+ {}".format(line))
                content.insert(0, line)
                changes += 1
    if changes &gt; 0:
        if __opts__["test"]:
            ret["comment"] = "File {n} is set to be changed ({c} lines)".format(
                n=name, c=changes
            )
            if show_changes:
                ret["changes"]["diff"] = "".join(diff)
                ret["comment"] += "\nPredicted diff:\n\r\t\t"
                ret["comment"] += "\r\t\t".join(diff)
                ret["result"] = None
        else:
            ret["comment"] = "Changed {c} lines".format(c=changes)
            if show_changes:
                ret["changes"]["diff"] = "".join(diff)
    else:
        ret["result"] = True
        return ret
    if not __opts__["test"]:
        try:
            with salt.utils.files.fopen(name, "w") as fd:
                fd.writelines(content)
                fd.close()
        except OSError:
            ret["comment"] = "{n} not writable".format(n=name)
            ret["result"] = False
            return ret
        ret["result"] = True
    return ret
def blockreplace(
    name,
    marker_start="#-- start managed zone --",
    marker_end="#-- end managed zone --",
    source=None,
    source_hash=None,
    template="jinja",
    sources=None,
    source_hashes=None,
    defaults=None,
    context=None,
    content="",
    append_if_not_found=False,
    prepend_if_not_found=False,
    backup=".bak",
    show_changes=True,
    append_newline=None,
    insert_before_match=None,
    insert_after_match=None,
):
    name = os.path.expanduser(name)
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if not name:
        return _error(ret, "Must provide name to file.blockreplace")
    if sources is None:
        sources = []
    if source_hashes is None:
        source_hashes = []
    (ok_, err, sl_) = _unify_sources_and_hashes(
        source=source,
        source_hash=source_hash,
        sources=sources,
        source_hashes=source_hashes,
    )
    if not ok_:
        return _error(ret, err)
    check_res, check_msg = _check_file(name)
    if not check_res:
        return _error(ret, check_msg)
    accum_data, accum_deps = _load_accumulators()
    if name in accum_data:
        accumulator = accum_data[name]
        deps = accum_deps.get(name, [])
        filtered = [
            a for a in deps if __low__["__id__"] in deps[a] and a in accumulator
        ]
        if not filtered:
            filtered = [a for a in accumulator]
        for acc in filtered:
            acc_content = accumulator[acc]
            for line in acc_content:
                if content == "":
                    content = line
                else:
                    content += "\n" + line
    if sl_:
        tmpret = _get_template_texts(
            source_list=sl_, template=template, defaults=defaults, context=context
        )
        if not tmpret["result"]:
            return tmpret
        text = tmpret["data"]
        for index, item in enumerate(text):
            content += str(item)
    try:
        changes = __salt__["file.blockreplace"](
            name,
            marker_start,
            marker_end,
            content=content,
            append_if_not_found=append_if_not_found,
            prepend_if_not_found=prepend_if_not_found,
            insert_before_match=insert_before_match,
            insert_after_match=insert_after_match,
            backup=backup,
            dry_run=__opts__["test"],
            show_changes=show_changes,
            append_newline=append_newline,
        )
    except Exception as exc:  # pylint: disable=broad-except
        log.exception("Encountered error managing block")
        ret[
            "comment"
        ] = "Encountered error managing block: {}. See the log for details.".format(exc)
        return ret
    if changes:
        ret["changes"]["diff"] = changes
        if __opts__["test"]:
            ret["result"] = None
            ret["comment"] = "Changes would be made"
        else:
            ret["result"] = True
            ret["comment"] = "Changes were made"
    else:
        ret["result"] = True
        ret["comment"] = "No changes needed to be made"
    return ret
def comment(name, regex, char="#", backup=".bak"):
    name = os.path.expanduser(name)
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if not name:
        return _error(ret, "Must provide name to file.comment")
    check_res, check_msg = _check_file(name)
    if not check_res:
        return _error(ret, check_msg)
    unanchor_regex = re.sub(r"^(\(\?[iLmsux]\))?\^?(.*?)\$?$", r"\2", regex)
    comment_regex = char + unanchor_regex
    if not __salt__["file.search"](name, regex, multiline=True):
        if __salt__["file.search"](name, comment_regex, multiline=True):
            ret["comment"] = "Pattern already commented"
            ret["result"] = True
            return ret
        else:
            return _error(ret, "{}: Pattern not found".format(unanchor_regex))
    if __opts__["test"]:
        ret["changes"][name] = "updated"
        ret["comment"] = "File {} is set to be updated".format(name)
        ret["result"] = None
        return ret
    with salt.utils.files.fopen(name, "rb") as fp_:
        slines = fp_.read()
        slines = slines.decode(__salt_system_encoding__)
        slines = slines.splitlines(True)
    __salt__["file.comment_line"](name, regex, char, True, backup)
    with salt.utils.files.fopen(name, "rb") as fp_:
        nlines = fp_.read()
        nlines = nlines.decode(__salt_system_encoding__)
        nlines = nlines.splitlines(True)
    ret["result"] = __salt__["file.search"](name, unanchor_regex, multiline=True)
    if slines != nlines:
        if not __utils__["files.is_text"](name):
            ret["changes"]["diff"] = "Replace binary file"
        else:
            ret["changes"]["diff"] = "".join(difflib.unified_diff(slines, nlines))
    if ret["result"]:
        ret["comment"] = "Commented lines successfully"
    else:
        ret["comment"] = "Expected commented lines not found"
    return ret
def uncomment(name, regex, char="#", backup=".bak"):
    name = os.path.expanduser(name)
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if not name:
        return _error(ret, "Must provide name to file.uncomment")
    check_res, check_msg = _check_file(name)
    if not check_res:
        return _error(ret, check_msg)
    if __salt__["file.search"](
        name, "{}[ \t]*{}".format(char, regex.lstrip("^")), multiline=True
    ):
        pass
    elif __salt__["file.search"](
        name, "^[ \t]*{}".format(regex.lstrip("^")), multiline=True
    ):
        ret["comment"] = "Pattern already uncommented"
        ret["result"] = True
        return ret
    else:
        return _error(ret, "{}: Pattern not found".format(regex))
    if __opts__["test"]:
        ret["changes"][name] = "updated"
        ret["comment"] = "File {} is set to be updated".format(name)
        ret["result"] = None
        return ret
    with salt.utils.files.fopen(name, "rb") as fp_:
        slines = salt.utils.data.decode(fp_.readlines())
    __salt__["file.comment_line"](name, regex, char, False, backup)
    with salt.utils.files.fopen(name, "rb") as fp_:
        nlines = salt.utils.data.decode(fp_.readlines())
    ret["result"] = __salt__["file.search"](
        name, "^[ \t]*{}".format(regex.lstrip("^")), multiline=True
    )
    if slines != nlines:
        if not __utils__["files.is_text"](name):
            ret["changes"]["diff"] = "Replace binary file"
        else:
            ret["changes"]["diff"] = "".join(difflib.unified_diff(slines, nlines))
    if ret["result"]:
        ret["comment"] = "Uncommented lines successfully"
    else:
        ret["comment"] = "Expected uncommented lines not found"
    return ret
def append(
    name,
    text=None,
    makedirs=False,
    source=None,
    source_hash=None,
    template="jinja",
    sources=None,
    source_hashes=None,
    defaults=None,
    context=None,
    ignore_whitespace=True,
):
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if not name:
        return _error(ret, "Must provide name to file.append")
    name = os.path.expanduser(name)
    if sources is None:
        sources = []
    if source_hashes is None:
        source_hashes = []
    (ok_, err, sl_) = _unify_sources_and_hashes(
        source=source,
        source_hash=source_hash,
        sources=sources,
        source_hashes=source_hashes,
    )
    if not ok_:
        return _error(ret, err)
    if makedirs is True:
        dirname = os.path.dirname(name)
        if __opts__["test"]:
            ret["comment"] = "Directory {} is set to be updated".format(dirname)
            ret["result"] = None
        else:
            if not __salt__["file.directory_exists"](dirname):
                try:
                    _makedirs(name=name)
                except CommandExecutionError as exc:
                    return _error(ret, "Drive {} is not mapped".format(exc.message))
                check_res, check_msg, check_changes = (
                    _check_directory_win(dirname)
                    if salt.utils.platform.is_windows()
                    else _check_directory(dirname)
                )
                if not check_res:
                    ret["changes"] = check_changes
                    return _error(ret, check_msg)
    check_res, check_msg = _check_file(name)
    if not check_res:
        touch_ret = touch(name, makedirs=makedirs)
        if __opts__["test"]:
            return touch_ret
        retry_res, retry_msg = _check_file(name)
        if not retry_res:
            return _error(ret, check_msg)
    if sl_:
        tmpret = _get_template_texts(
            source_list=sl_, template=template, defaults=defaults, context=context
        )
        if not tmpret["result"]:
            return tmpret
        text = tmpret["data"]
    text = _validate_str_list(text)
    with salt.utils.files.fopen(name, "rb") as fp_:
        slines = fp_.read()
        slines = slines.decode(__salt_system_encoding__)
        slines = slines.splitlines()
    append_lines = []
    try:
        for chunk in text:
            if ignore_whitespace:
                if __salt__["file.search"](
                    name,
                    salt.utils.stringutils.build_whitespace_split_regex(chunk),
                    multiline=True,
                ):
                    continue
            elif __salt__["file.search"](name, chunk, multiline=True):
                continue
            for line_item in chunk.splitlines():
                append_lines.append("{}".format(line_item))
    except TypeError:
        return _error(ret, "No text found to append. Nothing appended")
    if __opts__["test"]:
        ret["comment"] = "File {} is set to be updated".format(name)
        ret["result"] = None
        nlines = list(slines)
        nlines.extend(append_lines)
        if slines != nlines:
            if not __utils__["files.is_text"](name):
                ret["changes"]["diff"] = "Replace binary file"
            else:
                ret["changes"]["diff"] = "\n".join(difflib.unified_diff(slines, nlines))
        else:
            ret["comment"] = "File {} is in correct state".format(name)
            ret["result"] = True
        return ret
    if append_lines:
        __salt__["file.append"](name, args=append_lines)
        ret["comment"] = "Appended {} lines".format(len(append_lines))
    else:
        ret["comment"] = "File {} is in correct state".format(name)
    with salt.utils.files.fopen(name, "rb") as fp_:
        nlines = fp_.read()
        nlines = nlines.decode(__salt_system_encoding__)
        nlines = nlines.splitlines()
    if slines != nlines:
        if not __utils__["files.is_text"](name):
            ret["changes"]["diff"] = "Replace binary file"
        else:
            ret["changes"]["diff"] = "\n".join(difflib.unified_diff(slines, nlines))
    ret["result"] = True
    return ret
def prepend(
    name,
    text=None,
    makedirs=False,
    source=None,
    source_hash=None,
    template="jinja",
    sources=None,
    source_hashes=None,
    defaults=None,
    context=None,
    header=None,
):
    name = os.path.expanduser(name)
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if not name:
        return _error(ret, "Must provide name to file.prepend")
    if sources is None:
        sources = []
    if source_hashes is None:
        source_hashes = []
    (ok_, err, sl_) = _unify_sources_and_hashes(
        source=source,
        source_hash=source_hash,
        sources=sources,
        source_hashes=source_hashes,
    )
    if not ok_:
        return _error(ret, err)
    if makedirs is True:
        dirname = os.path.dirname(name)
        if __opts__["test"]:
            ret["comment"] = "Directory {} is set to be updated".format(dirname)
            ret["result"] = None
        else:
            if not __salt__["file.directory_exists"](dirname):
                try:
                    _makedirs(name=name)
                except CommandExecutionError as exc:
                    return _error(ret, "Drive {} is not mapped".format(exc.message))
                check_res, check_msg, check_changes = (
                    _check_directory_win(dirname)
                    if salt.utils.platform.is_windows()
                    else _check_directory(dirname)
                )
                if not check_res:
                    ret["changes"] = check_changes
                    return _error(ret, check_msg)
    check_res, check_msg = _check_file(name)
    if not check_res:
        touch_ret = touch(name, makedirs=makedirs)
        if __opts__["test"]:
            return touch_ret
        retry_res, retry_msg = _check_file(name)
        if not retry_res:
            return _error(ret, check_msg)
    if sl_:
        tmpret = _get_template_texts(
            source_list=sl_, template=template, defaults=defaults, context=context
        )
        if not tmpret["result"]:
            return tmpret
        text = tmpret["data"]
    text = _validate_str_list(text)
    with salt.utils.files.fopen(name, "rb") as fp_:
        slines = fp_.read()
        slines = slines.decode(__salt_system_encoding__)
        slines = slines.splitlines(True)
    count = 0
    test_lines = []
    preface = []
    for chunk in text:
        if not header:
            if __salt__["file.search"](
                name,
                salt.utils.stringutils.build_whitespace_split_regex(chunk),
                multiline=True,
            ):
                continue
        lines = chunk.splitlines()
        for line in lines:
            if __opts__["test"]:
                ret["comment"] = "File {} is set to be updated".format(name)
                ret["result"] = None
                test_lines.append("{}\n".format(line))
            else:
                preface.append(line)
            count += 1
    if __opts__["test"]:
        nlines = test_lines + slines
        if slines != nlines:
            if not __utils__["files.is_text"](name):
                ret["changes"]["diff"] = "Replace binary file"
            else:
                ret["changes"]["diff"] = "".join(difflib.unified_diff(slines, nlines))
            ret["result"] = None
        else:
            ret["comment"] = "File {} is in correct state".format(name)
            ret["result"] = True
        return ret
    if header:
        with salt.utils.files.fopen(name, "rb") as fp_:
            contents = fp_.read()
            contents = contents.decode(__salt_system_encoding__)
            contents = contents.splitlines(True)
            target_head = contents[0 : len(preface)]
            target_lines = []
            for chunk in target_head:
                target_lines += chunk.splitlines()
            if target_lines != preface:
                __salt__["file.prepend"](name, *preface)
            else:
                count = 0
    else:
        __salt__["file.prepend"](name, *preface)
    with salt.utils.files.fopen(name, "rb") as fp_:
        nlines = fp_.read()
        nlines = nlines.decode(__salt_system_encoding__)
        nlines = nlines.splitlines(True)
    if slines != nlines:
        if not __utils__["files.is_text"](name):
            ret["changes"]["diff"] = "Replace binary file"
        else:
            ret["changes"]["diff"] = "".join(difflib.unified_diff(slines, nlines))
    if count:
        ret["comment"] = "Prepended {} lines".format(count)
    else:
        ret["comment"] = "File {} is in correct state".format(name)
    ret["result"] = True
    return ret
def patch(
    name,
    source=None,
    source_hash=None,
    source_hash_name=None,
    skip_verify=False,
    template=None,
    context=None,
    defaults=None,
    options="",
    reject_file=None,
    strip=None,
    saltenv=None,
    **kwargs
):
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if not salt.utils.path.which("patch"):
        ret["comment"] = "patch executable not found on minion"
        return ret
    is_dir = False
    if not name:
        ret["comment"] = "A file/directory to be patched is required"
        return ret
    else:
        try:
            name = os.path.expanduser(name)
        except Exception:  # pylint: disable=broad-except
            ret["comment"] = "Invalid path '{}'".format(name)
            return ret
        else:
            if not os.path.isabs(name):
                ret["comment"] = "{} is not an absolute path".format(name)
                return ret
            elif not os.path.exists(name):
                ret["comment"] = "{} does not exist".format(name)
                return ret
            else:
                is_dir = os.path.isdir(name)
    for deprecated_arg in ("hash", "dry_run_first"):
        if deprecated_arg in kwargs:
            ret.setdefault("warnings", []).append(
                "The '{}' argument is no longer used and has been ignored.".format(
                    deprecated_arg
                )
            )
    if reject_file is not None:
        try:
            reject_file_parent = os.path.dirname(reject_file)
        except Exception:  # pylint: disable=broad-except
            ret["comment"] = "Invalid path '{}' for reject_file".format(reject_file)
            return ret
        else:
            if not os.path.isabs(reject_file_parent):
                ret["comment"] = "'{}' is not an absolute path".format(reject_file)
                return ret
            elif not os.path.isdir(reject_file_parent):
                ret["comment"] = (
                    "Parent directory for reject_file '{}' either does "
                    "not exist, or is not a directory".format(reject_file)
                )
                return ret
    sanitized_options = []
    options = salt.utils.args.shlex_split(options)
    index = 0
    max_index = len(options) - 1
    blacklisted_options = []
    while index &lt;= max_index:
        option = options[index]
        if not isinstance(option, str):
            option = str(option)
        for item in ("-N", "--forward", "-r", "--reject-file", "-o", "--output"):
            if option.startswith(item):
                blacklisted = option
                break
        else:
            blacklisted = None
        if blacklisted is not None:
            blacklisted_options.append(blacklisted)
        if option.startswith("-p"):
            try:
                strip = int(option[2:])
            except Exception:  # pylint: disable=broad-except
                ret["comment"] = (
                    "Invalid format for '-p' CLI option. Consider using "
                    "the 'strip' option for this state."
                )
                return ret
        elif option.startswith("--strip"):
            if "=" in option:
                try:
                    strip = int(option.rsplit("=", 1)[-1])
                except Exception:  # pylint: disable=broad-except
                    ret["comment"] = (
                        "Invalid format for '-strip' CLI option. Consider "
                        "using the 'strip' option for this state."
                    )
                    return ret
            else:
                try:
                    strip = int(options[index + 1])
                except Exception:  # pylint: disable=broad-except
                    ret["comment"] = (
                        "Invalid format for '-strip' CLI option. Consider "
                        "using the 'strip' option for this state."
                    )
                    return ret
                else:
                    index += 1
        else:
            sanitized_options.append(option)
        index += 1
    if blacklisted_options:
        ret["comment"] = "The following CLI options are not allowed: {}".format(
            ", ".join(blacklisted_options)
        )
        return ret
    options = sanitized_options
    try:
        source_match = __salt__["file.source_list"](source, source_hash, __env__)[0]
    except CommandExecutionError as exc:
        ret["result"] = False
        ret["comment"] = exc.strerror
        return ret
    else:
        if saltenv is not None:
            source_match_url, source_match_saltenv = salt.utils.url.parse(source_match)
            if source_match_url.startswith("salt://"):
                if source_match_saltenv is not None and source_match_saltenv != saltenv:
                    ret.setdefault("warnings", []).append(
                        "Ignoring 'saltenv' option in favor of saltenv "
                        "included in the source URL."
                    )
                else:
                    source_match += "?saltenv={}".format(saltenv)
    cleanup = []
    try:
        patch_file = salt.utils.files.mkstemp()
        cleanup.append(patch_file)
        try:
            orig_test = __opts__["test"]
            __opts__["test"] = False
            sys.modules[__salt__["file.patch"].__module__].__opts__["test"] = False
            result = managed(
                patch_file,
                source=source_match,
                source_hash=source_hash,
                source_hash_name=source_hash_name,
                skip_verify=skip_verify,
                template=template,
                context=context,
                defaults=defaults,
            )
        except Exception as exc:  # pylint: disable=broad-except
            msg = "Failed to cache patch file {}: {}".format(
                salt.utils.url.redact_http_basic_auth(source_match), exc
            )
            log.exception(msg)
            ret["comment"] = msg
            return ret
        else:
            log.debug("file.managed: %s", result)
        finally:
            __opts__["test"] = orig_test
            sys.modules[__salt__["file.patch"].__module__].__opts__["test"] = orig_test
        if not orig_test and not result["result"]:
            log.debug(
                "failed to download %s",
                salt.utils.url.redact_http_basic_auth(source_match),
            )
            return result
        def _patch(patch_file, options=None, dry_run=False):
            patch_opts = copy.copy(sanitized_options)
            if options is not None:
                patch_opts.extend(options)
            return __salt__["file.patch"](
                name, patch_file, options=patch_opts, dry_run=dry_run
            )
        if reject_file is not None:
            patch_rejects = reject_file
        else:
            patch_rejects = salt.utils.files.mkstemp()
            cleanup.append(patch_rejects)
        patch_output = salt.utils.files.mkstemp()
        cleanup.append(patch_output)
        patch_opts = ["-N", "-r", patch_rejects, "-o", patch_output]
        if is_dir and strip is not None:
            patch_opts.append("-p{}".format(strip))
        pre_check = _patch(patch_file, patch_opts)
        if pre_check["retcode"] != 0:
            reverse_pass = _patch(patch_rejects, ["-R", "-f"], dry_run=True)
            already_applied = reverse_pass["retcode"] == 0
            if pre_check["retcode"] == 2 and pre_check["stderr"]:
                ret["comment"] = pre_check["stderr"]
                ret["result"] = False
                return ret
            if already_applied:
                ret["comment"] = "Patch was already applied"
                ret["result"] = True
                return ret
            else:
                ret["comment"] = (
                    "Patch would not apply cleanly, no changes made. Results "
                    "of dry-run are below."
                )
                if reject_file is None:
                    ret["comment"] += (
                        " Run state again using the reject_file option to "
                        "save rejects to a persistent file."
                    )
                opts = copy.copy(__opts__)
                opts["color"] = False
                ret["comment"] += "\n\n" + salt.output.out_format(
                    pre_check, "nested", opts, nested_indent=14
                )
                return ret
        if __opts__["test"]:
            ret["result"] = None
            ret["comment"] = "The patch would be applied"
            ret["changes"] = pre_check
            return ret
        patch_opts = []
        if is_dir and strip is not None:
            patch_opts.append("-p{}".format(strip))
        ret["changes"] = _patch(patch_file, patch_opts)
        if ret["changes"]["retcode"] == 0:
            ret["comment"] = "Patch successfully applied"
            ret["result"] = True
        else:
            ret["comment"] = "Failed to apply patch"
        return ret
    finally:
        for path in cleanup:
            try:
                os.remove(path)
            except OSError as exc:
                if exc.errno != os.errno.ENOENT:
                    log.error(
                        "file.patch: Failed to remove temp file %s: %s", path, exc
                    )
def touch(name, atime=None, mtime=None, makedirs=False):
    name = os.path.expanduser(name)
    ret = {
        "name": name,
        "changes": {},
    }
    if not name:
        return _error(ret, "Must provide name to file.touch")
    if not os.path.isabs(name):
        return _error(ret, "Specified file {} is not an absolute path".format(name))
    if __opts__["test"]:
        ret.update(_check_touch(name, atime, mtime))
        return ret
    if makedirs:
        try:
            _makedirs(name=name)
        except CommandExecutionError as exc:
            return _error(ret, "Drive {} is not mapped".format(exc.message))
    if not os.path.isdir(os.path.dirname(name)):
        return _error(ret, "Directory not present to touch file {}".format(name))
    extant = os.path.exists(name)
    ret["result"] = __salt__["file.touch"](name, atime, mtime)
    if not extant and ret["result"]:
        ret["comment"] = "Created empty file {}".format(name)
        ret["changes"]["new"] = name
    elif extant and ret["result"]:
        ret["comment"] = "Updated times on {} {}".format(
            "directory" if os.path.isdir(name) else "file", name
        )
        ret["changes"]["touched"] = name
    return ret
def copy_(
    name,
    source,
    force=False,
    makedirs=False,
    preserve=False,
    user=None,
    group=None,
    mode=None,
    subdir=False,
    **kwargs
):
    name = os.path.expanduser(name)
    source = os.path.expanduser(source)
    ret = {
        "name": name,
        "changes": {},
        "comment": 'Copied "{}" to "{}"'.format(source, name),
        "result": True,
    }
    if not name:
        return _error(ret, "Must provide name to file.copy")
    changed = True
    if not os.path.isabs(name):
        return _error(ret, "Specified file {} is not an absolute path".format(name))
    if not os.path.exists(source):
        return _error(ret, 'Source file "{}" is not present'.format(source))
    if preserve:
        user = __salt__["file.get_user"](source)
        group = __salt__["file.get_group"](source)
        mode = __salt__["file.get_mode"](source)
    else:
        user = _test_owner(kwargs, user=user)
        if user is None:
            user = __opts__["user"]
        if salt.utils.platform.is_windows():
            if group is not None:
                log.warning(
                    "The group argument for %s has been ignored as this is "
                    "a Windows system.",
                    name,
                )
            group = user
        if group is None:
            if "user.info" in __salt__:
                group = __salt__["file.gid_to_group"](
                    __salt__["user.info"](user).get("gid", 0)
                )
            else:
                group = user
        u_check = _check_user(user, group)
        if u_check:
            return _error(ret, u_check)
        if mode is None:
            mode = __salt__["file.get_mode"](source)
    if os.path.isdir(name) and subdir:
        name = os.path.join(name, os.path.basename(source))
    if os.path.lexists(source) and os.path.lexists(name):
        if force and os.path.isfile(name):
            hash1 = salt.utils.hashutils.get_hash(name)
            hash2 = salt.utils.hashutils.get_hash(source)
            if hash1 == hash2:
                changed = True
                ret["comment"] = " ".join(
                    [ret["comment"], "- files are identical but force flag is set"]
                )
        if not force:
            changed = False
        elif not __opts__["test"] and changed:
            try:
                __salt__["file.remove"](name)
            except OSError:
                return _error(
                    ret,
                    'Failed to delete "{}" in preparation for forced move'.format(name),
                )
    if __opts__["test"]:
        if changed:
            ret["comment"] = 'File "{}" is set to be copied to "{}"'.format(
                source, name
            )
            ret["result"] = None
        else:
            ret[
                "comment"
            ] = 'The target file "{}" exists and will not be overwritten'.format(name)
            ret["result"] = True
        return ret
    if not changed:
        ret[
            "comment"
        ] = 'The target file "{}" exists and will not be overwritten'.format(name)
        ret["result"] = True
        return ret
    dname = os.path.dirname(name)
    if not os.path.isdir(dname):
        if makedirs:
            try:
                _makedirs(name=name, user=user, group=group, dir_mode=mode)
            except CommandExecutionError as exc:
                return _error(ret, "Drive {} is not mapped".format(exc.message))
        else:
            return _error(ret, "The target directory {} is not present".format(dname))
    try:
        if os.path.isdir(source):
            shutil.copytree(source, name, symlinks=True)
            for root, dirs, files in salt.utils.path.os_walk(name):
                for dir_ in dirs:
                    __salt__["file.lchown"](os.path.join(root, dir_), user, group)
                for file_ in files:
                    __salt__["file.lchown"](os.path.join(root, file_), user, group)
        else:
            shutil.copy(source, name)
        ret["changes"] = {name: source}
        if not preserve:
            if salt.utils.platform.is_windows():
                check_ret = __salt__["file.check_perms"](path=name, ret=ret, owner=user)
            else:
                check_ret, perms = __salt__["file.check_perms"](
                    name, ret, user, group, mode
                )
            if not check_ret["result"]:
                ret["result"] = check_ret["result"]
                ret["comment"] = check_ret["comment"]
    except OSError:
        return _error(ret, 'Failed to copy "{}" to "{}"'.format(source, name))
    return ret
def rename(name, source, force=False, makedirs=False, **kwargs):
    name = os.path.expanduser(name)
    name = os.path.expandvars(name)
    source = os.path.expanduser(source)
    source = os.path.expandvars(source)
    ret = {"name": name, "changes": {}, "comment": "", "result": True}
    if not name:
        return _error(ret, "Must provide name to file.rename")
    if not os.path.isabs(name):
        return _error(ret, "Specified file {} is not an absolute path".format(name))
    if not os.path.lexists(source):
        ret["comment"] = 'Source file "{}" has already been moved out of place'.format(
            source
        )
        return ret
    if os.path.lexists(source) and os.path.lexists(name):
        if not force:
            ret[
                "comment"
            ] = 'The target file "{}" exists and will not be overwritten'.format(name)
            return ret
        elif not __opts__["test"]:
            try:
                __salt__["file.remove"](name)
            except OSError:
                return _error(
                    ret,
                    'Failed to delete "{}" in preparation for forced move'.format(name),
                )
    if __opts__["test"]:
        ret["comment"] = 'File "{}" is set to be moved to "{}"'.format(source, name)
        ret["result"] = None
        return ret
    dname = os.path.dirname(name)
    if not os.path.isdir(dname):
        if makedirs:
            try:
                _makedirs(name=name)
            except CommandExecutionError as exc:
                return _error(ret, "Drive {} is not mapped".format(exc.message))
        else:
            return _error(ret, "The target directory {} is not present".format(dname))
    try:
        if os.path.islink(source):
            linkto = salt.utils.path.readlink(source)
            os.symlink(linkto, name)
            os.unlink(source)
        else:
            shutil.move(source, name)
    except OSError:
        return _error(ret, 'Failed to move "{}" to "{}"'.format(source, name))
    ret["comment"] = 'Moved "{}" to "{}"'.format(source, name)
    ret["changes"] = {name: source}
    return ret
def accumulated(name, filename, text, **kwargs):
    ret = {"name": name, "changes": {}, "result": True, "comment": ""}
    if not name:
        return _error(ret, "Must provide name to file.accumulated")
    if text is None:
        ret["result"] = False
        ret["comment"] = "No text supplied for accumulator"
        return ret
    require_in = __low__.get("require_in", [])
    watch_in = __low__.get("watch_in", [])
    deps = require_in + watch_in
    if not [x for x in deps if "file" in x]:
        ret["result"] = False
        ret["comment"] = "Orphaned accumulator {} in {}:{}".format(
            name, __low__["__sls__"], __low__["__id__"]
        )
        return ret
    if isinstance(text, str):
        text = (text,)
    elif isinstance(text, dict):
        text = (text,)
    accum_data, accum_deps = _load_accumulators()
    if filename not in accum_data:
        accum_data[filename] = {}
    if filename not in accum_deps:
        accum_deps[filename] = {}
    if name not in accum_deps[filename]:
        accum_deps[filename][name] = []
    for accumulator in deps:
        if isinstance(accumulator, (dict, OrderedDict)):
            accum_deps[filename][name].extend(accumulator.values())
        else:
            accum_deps[filename][name].extend(accumulator)
    if name not in accum_data[filename]:
        accum_data[filename][name] = []
    for chunk in text:
        if chunk not in accum_data[filename][name]:
            accum_data[filename][name].append(chunk)
            ret["comment"] = "Accumulator {} for file {} was charged by text".format(
                name, filename
            )
    _persist_accummulators(accum_data, accum_deps)
    return ret
def serialize(
    name,
    dataset=None,
    dataset_pillar=None,
    user=None,
    group=None,
    mode=None,
    backup="",
    makedirs=False,
    show_changes=True,
    create=True,
    merge_if_exists=False,
    encoding=None,
    encoding_errors="strict",
    serializer=None,
    serializer_opts=None,
    deserializer_opts=None,
    **kwargs
):
    if "env" in kwargs:
        kwargs.pop("env")
    name = os.path.expanduser(name)
    serializer_options = {
        "yaml.serialize": {"default_flow_style": False},
        "json.serialize": {"indent": 2, "separators": (",", ": "), "sort_keys": True},
    }
    deserializer_options = {
        "yaml.deserialize": {},
        "json.deserialize": {},
    }
    if encoding:
        serializer_options["yaml.serialize"].update({"allow_unicode": True})
        serializer_options["json.serialize"].update({"ensure_ascii": False})
    ret = {"changes": {}, "comment": "", "name": name, "result": True}
    if not name:
        return _error(ret, "Must provide name to file.serialize")
    if not create:
        if not os.path.isfile(name):
            ret[
                "comment"
            ] = "File {} is not present and is not set for creation".format(name)
            return ret
    formatter = kwargs.pop("formatter", None)
    if serializer and formatter:
        return _error(ret, "Only one of serializer and formatter are allowed")
    serializer = str(serializer or formatter or "yaml").lower()
    if len([x for x in (dataset, dataset_pillar) if x]) &gt; 1:
        return _error(ret, "Only one of 'dataset' and 'dataset_pillar' is permitted")
    if dataset_pillar:
        dataset = __salt__["pillar.get"](dataset_pillar)
    if dataset is None:
        return _error(ret, "Neither 'dataset' nor 'dataset_pillar' was defined")
    if salt.utils.platform.is_windows():
        if group is not None:
            log.warning(
                "The group argument for %s has been ignored as this "
                "is a Windows system.",
                name,
            )
        group = user
    serializer_name = "{}.serialize".format(serializer)
    deserializer_name = "{}.deserialize".format(serializer)
    if serializer_name not in __serializers__:
        return {
            "changes": {},
            "comment": (
                "The {} serializer could not be found. It either does "
                "not exist or its prerequisites are not installed.".format(serializer)
            ),
            "name": name,
            "result": False,
        }
    if serializer_opts:
        serializer_options.setdefault(serializer_name, {}).update(
            salt.utils.data.repack_dictlist(serializer_opts)
        )
    if deserializer_opts:
        deserializer_options.setdefault(deserializer_name, {}).update(
            salt.utils.data.repack_dictlist(deserializer_opts)
        )
    if merge_if_exists:
        if os.path.isfile(name):
            if deserializer_name not in __serializers__:
                return {
                    "changes": {},
                    "comment": (
                        "merge_if_exists is not supported for the {} serializer".format(
                            serializer
                        )
                    ),
                    "name": name,
                    "result": False,
                }
            open_args = "r"
            if serializer == "plist":
                open_args += "b"
            with salt.utils.files.fopen(name, open_args) as fhr:
                try:
                    existing_data = __serializers__[deserializer_name](
                        fhr, **deserializer_options.get(deserializer_name, {})
                    )
                except (TypeError, DeserializationError) as exc:
                    ret["result"] = False
                    ret["comment"] = "Failed to deserialize existing data: {}".format(
                        exc
                    )
                    return False
            if existing_data is not None:
                merged_data = salt.utils.dictupdate.merge_recurse(
                    existing_data, dataset
                )
                if existing_data == merged_data:
                    ret["result"] = True
                    ret["comment"] = "The file {} is in the correct state".format(name)
                    return ret
                dataset = merged_data
    else:
        if deserializer_opts:
            ret.setdefault("warnings", []).append(
                "The 'deserializer_opts' option is ignored unless "
                "merge_if_exists is set to True."
            )
    contents = __serializers__[serializer_name](
        dataset, **serializer_options.get(serializer_name, {})
    )
    try:
        contents += "\n"
    except TypeError:
        pass
    mode = salt.utils.files.normalize_mode(mode)
    if __opts__["test"]:
        ret["changes"] = __salt__["file.check_managed_changes"](
            name=name,
            source=None,
            source_hash={},
            source_hash_name=None,
            user=user,
            group=group,
            mode=mode,
            attrs=None,
            template=None,
            context=None,
            defaults=None,
            saltenv=__env__,
            contents=contents,
            skip_verify=False,
            **kwargs
        )
        if ret["changes"]:
            ret["result"] = None
            ret["comment"] = "Dataset will be serialized and stored into {}".format(
                name
            )
            if not show_changes:
                ret["changes"]["diff"] = "&lt;show_changes=False&gt;"
        else:
            ret["result"] = True
            ret["comment"] = "The file {} is in the correct state".format(name)
        return ret
    return __salt__["file.manage_file"](
        name=name,
        sfn="",
        ret=ret,
        source=None,
        source_sum={},
        user=user,
        group=group,
        mode=mode,
        attrs=None,
        saltenv=__env__,
        backup=backup,
        makedirs=makedirs,
        template=None,
        show_changes=show_changes,
        encoding=encoding,
        encoding_errors=encoding_errors,
        contents=contents,
    )
def mknod(name, ntype, major=0, minor=0, user=None, group=None, mode="0600"):
    name = os.path.expanduser(name)
    ret = {"name": name, "changes": {}, "comment": "", "result": False}
    if not name:
        return _error(ret, "Must provide name to file.mknod")
    if ntype == "c":
        if __salt__["file.file_exists"](name):
            ret["comment"] = (
                "File {} exists and is not a character device. Refusing "
                "to continue".format(name)
            )
        elif not __salt__["file.is_chrdev"](name):
            if __opts__["test"]:
                ret["comment"] = "Character device {} is set to be created".format(name)
                ret["result"] = None
            else:
                ret = __salt__["file.mknod"](
                    name, ntype, major, minor, user, group, mode
                )
        else:
            devmaj, devmin = __salt__["file.get_devmm"](name)
            if (major, minor) != (devmaj, devmin):
                ret["comment"] = (
                    "Character device {} exists and has a different "
                    "major/minor {}/{}. Refusing to continue".format(
                        name, devmaj, devmin
                    )
                )
            else:
                ret = __salt__["file.check_perms"](name, None, user, group, mode)[0]
                if not ret["changes"]:
                    ret[
                        "comment"
                    ] = "Character device {} is in the correct state".format(name)
    elif ntype == "b":
        if __salt__["file.file_exists"](name):
            ret[
                "comment"
            ] = "File {} exists and is not a block device. Refusing to continue".format(
                name
            )
        elif not __salt__["file.is_blkdev"](name):
            if __opts__["test"]:
                ret["comment"] = "Block device {} is set to be created".format(name)
                ret["result"] = None
            else:
                ret = __salt__["file.mknod"](
                    name, ntype, major, minor, user, group, mode
                )
        else:
            devmaj, devmin = __salt__["file.get_devmm"](name)
            if (major, minor) != (devmaj, devmin):
                ret["comment"] = (
                    "Block device {} exists and has a different major/minor "
                    "{}/{}. Refusing to continue".format(name, devmaj, devmin)
                )
            else:
                ret = __salt__["file.check_perms"](name, None, user, group, mode)[0]
                if not ret["changes"]:
                    ret["comment"] = "Block device {} is in the correct state".format(
                        name
                    )
    elif ntype == "p":
        if __salt__["file.file_exists"](name):
            ret[
                "comment"
            ] = "File {} exists and is not a fifo pipe. Refusing to continue".format(
                name
            )
        elif not __salt__["file.is_fifo"](name):
            if __opts__["test"]:
                ret["comment"] = "Fifo pipe {} is set to be created".format(name)
                ret["result"] = None
            else:
                ret = __salt__["file.mknod"](
                    name, ntype, major, minor, user, group, mode
                )
        else:
            ret = __salt__["file.check_perms"](name, None, user, group, mode)[0]
            if not ret["changes"]:
                ret["comment"] = "Fifo pipe {} is in the correct state".format(name)
    else:
        ret["comment"] = (
            "Node type unavailable: '{}'. Available node types are "
            "character ('c'), block ('b'), and pipe ('p')".format(ntype)
        )
    return ret
def mod_run_check_cmd(cmd, filename, **check_cmd_opts):
    log.debug("running our check_cmd")
    _cmd = "{} {}".format(cmd, filename)
    cret = __salt__["cmd.run_all"](_cmd, **check_cmd_opts)
    if cret["retcode"] != 0:
        ret = {
            "comment": "check_cmd execution failed",
            "skip_watch": True,
            "result": False,
        }
        if cret.get("stdout"):
            ret["comment"] += "\n" + cret["stdout"]
        if cret.get("stderr"):
            ret["comment"] += "\n" + cret["stderr"]
        return ret
    return True
def decode(
    name,
    encoded_data=None,
    contents_pillar=None,
    encoding_type="base64",
    checksum="md5",
):
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if not (encoded_data or contents_pillar):
        raise CommandExecutionError(
            "Specify either the 'encoded_data' or 'contents_pillar' argument."
        )
    elif encoded_data and contents_pillar:
        raise CommandExecutionError(
            "Specify only one 'encoded_data' or 'contents_pillar' argument."
        )
    elif encoded_data:
        content = encoded_data
    elif contents_pillar:
        content = __salt__["pillar.get"](contents_pillar, False)
        if content is False:
            raise CommandExecutionError("Pillar data not found.")
    else:
        raise CommandExecutionError("No contents given.")
    dest_exists = __salt__["file.file_exists"](name)
    if dest_exists:
        instr = __salt__["hashutil.base64_decodestring"](content)
        insum = __salt__["hashutil.digest"](instr, checksum)
        del instr  # no need to keep in-memory after we have the hash
        outsum = __salt__["hashutil.digest_file"](name, checksum)
        if insum != outsum:
            ret["changes"] = {
                "old": outsum,
                "new": insum,
            }
        if not ret["changes"]:
            ret["comment"] = "File is in the correct state."
            ret["result"] = True
            return ret
    if __opts__["test"] is True:
        ret["comment"] = "File is set to be updated."
        ret["result"] = None
        return ret
    ret["result"] = __salt__["hashutil.base64_decodefile"](content, name)
    ret["comment"] = "File was updated."
    if not ret["changes"]:
        ret["changes"] = {
            "old": None,
            "new": __salt__["hashutil.digest_file"](name, checksum),
        }
    return ret
def shortcut(
    name,
    target,
    arguments=None,
    working_dir=None,
    description=None,
    icon_location=None,
    force=False,
    backupname=None,
    makedirs=False,
    user=None,
    **kwargs
):
    user = _test_owner(kwargs, user=user)
    ret = {"name": name, "changes": {}, "result": True, "comment": ""}
    if not salt.utils.platform.is_windows():
        return _error(ret, "Shortcuts are only supported on Windows")
    if not name:
        return _error(ret, "Must provide name to file.shortcut")
    if not name.endswith(".lnk") and not name.endswith(".url"):
        return _error(ret, 'Name must end with either ".lnk" or ".url"')
    name = os.path.realpath(os.path.expanduser(name))
    if name.endswith(".lnk"):
        target = os.path.realpath(os.path.expanduser(target))
    if working_dir:
        working_dir = os.path.realpath(os.path.expanduser(working_dir))
    if icon_location:
        icon_location = os.path.realpath(os.path.expanduser(icon_location))
    if user is None:
        user = __opts__["user"]
    if not __salt__["user.info"](user):
        user = __salt__["user.current"]()
        if not user:
            user = "SYSTEM"
    preflight_errors = []
    uid = __salt__["file.user_to_uid"](user)
    if uid == "":
        preflight_errors.append("User {} does not exist".format(user))
    if not os.path.isabs(name):
        preflight_errors.append(
            "Specified file {} is not an absolute path".format(name)
        )
    if preflight_errors:
        msg = ". ".join(preflight_errors)
        if len(preflight_errors) &gt; 1:
            msg += "."
        return _error(ret, msg)
    tresult, tcomment, tchanges = _shortcut_check(
        name, target, arguments, working_dir, description, icon_location, force, user
    )
    if __opts__["test"]:
        ret["result"] = tresult
        ret["comment"] = tcomment
        ret["changes"] = tchanges
        return ret
    if not os.path.isdir(os.path.dirname(name)):
        if makedirs:
            try:
                _makedirs(name=name, user=user)
            except CommandExecutionError as exc:
                return _error(ret, "Drive {} is not mapped".format(exc.message))
        else:
            return _error(
                ret,
                'Directory "{}" for shortcut is not present'.format(
                    os.path.dirname(name)
                ),
            )
    if os.path.isdir(name) or os.path.islink(name):
        if backupname is not None:
            if os.path.lexists(backupname):
                if not force:
                    return _error(
                        ret,
                        "File exists where the backup target {} should go".format(
                            backupname
                        ),
                    )
                else:
                    __salt__["file.remove"](backupname)
                    time.sleep(1)  # wait for asynchronous deletion
            if not os.path.isdir(os.path.dirname(backupname)):
                if makedirs:
                    try:
                        _makedirs(name=backupname)
                    except CommandExecutionError as exc:
                        return _error(ret, "Drive {} is not mapped".format(exc.message))
                else:
                    return _error(
                        ret,
                        'Directory does not exist for backup at "{}"'.format(
                            os.path.dirname(backupname)
                        ),
                    )
            os.rename(name, backupname)
            time.sleep(1)  # wait for asynchronous rename
        elif force:
            __salt__["file.remove"](name)
            ret["changes"]["forced"] = "Shortcut was forcibly replaced"
            time.sleep(1)  # wait for asynchronous deletion
        else:
            return _error(
                ret,
                'Directory or symlink exists where the shortcut "{}" should be'.format(
                    name
                ),
            )
    with salt.utils.winapi.Com():
        shell = win32com.client.Dispatch("WScript.Shell")
        scut = shell.CreateShortcut(name)
        state_checks = [scut.TargetPath.lower() == target.lower()]
        if arguments is not None:
            state_checks.append(scut.Arguments == arguments)
        if working_dir is not None:
            state_checks.append(scut.WorkingDirectory.lower() == working_dir.lower())
        if description is not None:
            state_checks.append(scut.Description == description)
        if icon_location is not None:
            state_checks.append(scut.IconLocation.lower() == icon_location.lower())
        if __salt__["file.file_exists"](name):
            if not all(state_checks):
                os.remove(name)
            else:
                if _check_shortcut_ownership(name, user):
                    ret["comment"] = "Shortcut {} is present and owned by {}".format(
                        name, user
                    )
                else:
                    if _set_shortcut_ownership(name, user):
                        ret["comment"] = "Set ownership of shortcut {} to {}".format(
                            name, user
                        )
                        ret["changes"]["ownership"] = "{}".format(user)
                    else:
                        ret["result"] = False
                        ret[
                            "comment"
                        ] += "Failed to set ownership of shortcut {} to {}".format(
                            name, user
                        )
                return ret
        if not os.path.exists(name):
            try:
                scut.TargetPath = target
                if arguments is not None:
                    scut.Arguments = arguments
                if working_dir is not None:
                    scut.WorkingDirectory = working_dir
                if description is not None:
                    scut.Description = description
                if icon_location is not None:
                    scut.IconLocation = icon_location
                scut.Save()
            except (AttributeError, pywintypes.com_error) as exc:
                ret["result"] = False
                ret["comment"] = "Unable to create new shortcut {} -&gt; {}: {}".format(
                    name, target, exc
                )
                return ret
            else:
                ret["comment"] = "Created new shortcut {} -&gt; {}".format(name, target)
                ret["changes"]["new"] = name
            if not _check_shortcut_ownership(name, user):
                if not _set_shortcut_ownership(name, user):
                    ret["result"] = False
                    ret["comment"] += ", but was unable to set ownership to {}".format(
                        user
                    )
    return ret
def cached(
    name,
    source_hash="",
    source_hash_name=None,
    skip_verify=False,
    saltenv="base",
    use_etag=False,
):
    ret = {"changes": {}, "comment": "", "name": name, "result": False}
    try:
        parsed = urllib.parse.urlparse(name)
    except Exception:  # pylint: disable=broad-except
        ret["comment"] = "Only URLs or local file paths are valid input"
        return ret
    if (
        not skip_verify
        and not source_hash
        and not use_etag
        and parsed.scheme in salt.utils.files.REMOTE_PROTOS
    ):
        ret["comment"] = (
            "Unable to verify upstream hash of source file {}, please set "
            "source_hash or set skip_verify or use_etag to True".format(
                salt.utils.url.redact_http_basic_auth(name)
            )
        )
        return ret
    if source_hash:
        try:
            source_sum = __salt__["file.get_source_sum"](
                source=name,
                source_hash=source_hash,
                source_hash_name=source_hash_name,
                saltenv=saltenv,
            )
        except CommandExecutionError as exc:
            ret["comment"] = exc.strerror
            return ret
        else:
            if not source_sum:
                ret["comment"] = (
                    "Failed to get source hash from {}. This may be a bug. "
                    "If this error persists, please report it and set "
                    "skip_verify to True to work around it.".format(source_hash)
                )
                return ret
    else:
        source_sum = {}
    if parsed.scheme in salt.utils.files.LOCAL_PROTOS:
        full_path = os.path.realpath(os.path.expanduser(parsed.path))
        if os.path.exists(full_path):
            if not skip_verify and source_sum:
                local_hash = __salt__["file.get_hash"](
                    full_path, source_sum.get("hash_type", __opts__["hash_type"])
                )
                if local_hash == source_sum["hsum"]:
                    ret["result"] = True
                    ret[
                        "comment"
                    ] = "File {} is present on the minion and has hash {}".format(
                        full_path, local_hash
                    )
                else:
                    ret["comment"] = (
                        "File {} is present on the minion, but the hash ({}) "
                        "does not match the specified hash ({})".format(
                            full_path, local_hash, source_sum["hsum"]
                        )
                    )
                return ret
            else:
                ret["result"] = True
                ret["comment"] = "File {} is present on the minion".format(full_path)
                return ret
        else:
            ret["comment"] = "File {} is not present on the minion".format(full_path)
            return ret
    local_copy = __salt__["cp.is_cached"](name, saltenv=saltenv)
    if local_copy:
        pre_hash = __salt__["file.get_hash"](
            local_copy, source_sum.get("hash_type", __opts__["hash_type"])
        )
        if not skip_verify and source_sum:
            if pre_hash == source_sum["hsum"]:
                ret["result"] = True
                ret["comment"] = "File is already cached to {} with hash {}".format(
                    local_copy, pre_hash
                )
    else:
        pre_hash = None
    try:
        local_copy = __salt__["cp.cache_file"](
            name, saltenv=saltenv, source_hash=source_sum.get("hsum"), use_etag=use_etag
        )
    except Exception as exc:  # pylint: disable=broad-except
        ret["comment"] = salt.utils.url.redact_http_basic_auth(exc.__str__())
        return ret
    if not local_copy:
        ret[
            "comment"
        ] = "Failed to cache {}, check minion log for more information".format(
            salt.utils.url.redact_http_basic_auth(name)
        )
        return ret
    post_hash = __salt__["file.get_hash"](
        local_copy, source_sum.get("hash_type", __opts__["hash_type"])
    )
    if pre_hash != post_hash:
        ret["changes"]["hash"] = {"old": pre_hash, "new": post_hash}
    if not skip_verify and source_sum:
        if post_hash == source_sum["hsum"]:
            ret["result"] = True
            ret["comment"] = "File is already cached to {} with hash {}".format(
                local_copy, post_hash
            )
        else:
            ret["comment"] = (
                "File is cached to {}, but the hash ({}) does not match "
                "the specified hash ({})".format(
                    local_copy, post_hash, source_sum["hsum"]
                )
            )
        return ret
    ret["result"] = True
    ret["comment"] = "File is cached to {}".format(local_copy)
    return ret
def not_cached(name, saltenv="base"):
    ret = {"changes": {}, "comment": "", "name": name, "result": False}
    try:
        parsed = urllib.parse.urlparse(name)
    except Exception:  # pylint: disable=broad-except
        ret["comment"] = "Only URLs or local file paths are valid input"
        return ret
    else:
        if parsed.scheme in salt.utils.files.LOCAL_PROTOS:
            full_path = os.path.realpath(os.path.expanduser(parsed.path))
            ret["result"] = True
            ret["comment"] = "File {} is a local path, no action taken".format(
                full_path
            )
            return ret
    local_copy = __salt__["cp.is_cached"](name, saltenv=saltenv)
    if local_copy:
        try:
            os.remove(local_copy)
        except Exception as exc:  # pylint: disable=broad-except
<a name="1"></a>            ret["comment"] = "Failed to delete {}: {}".format(local_copy, exc.__str__())
        else:
            ret["result"] = True
            ret<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["changes"]["deleted"] = True
            ret["comment"] = "{} was deleted".format(local_copy)
    else:
        ret["result"] = True
        ret["comment"] = "{} is not cached".format(name)
    return</b></font> ret
def mod_beacon(name, **kwargs):
    sfun = kwargs.pop("sfun", None)
    supported_funcs = ["managed", "directory"]
    if sfun in supported_funcs:
        if kwargs.get("beacon"):
            beacon_module = "inotify"
            data = {}
            _beacon_data = kwargs.get("beacon_data", {})
            default_mask = ["create", "delete", "modify"]
            data["mask"] = _beacon_data.get("mask", default_mask)
            if sfun == "directory":
                data["auto_add"] = _beacon_data.get("auto_add", True)
                data["recurse"] = _beacon_data.get("recurse", True)
                data["exclude"] = _beacon_data.get("exclude", [])
            beacon_name = "beacon_{}_{}".format(beacon_module, name)
            beacon_kwargs = {
                "name": beacon_name,
                "files": {name: data},
                "interval": _beacon_data.get("interval", 60),
                "coalesce": _beacon_data.get("coalesce", False),
                "beacon_module": beacon_module,
            }
            ret = __states__["beacon.present"](**beacon_kwargs)
            return ret
        else:
            return {
                "name": name,
                "changes": {},
                "comment": "Not adding beacon.",
                "result": True,
            }
    else:
        return {
            "name": name,
            "changes": {},
            "comment": "file.{} does not work with the beacon state function".format(
                sfun
            ),
            "result": False,
        }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
