<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for rbenv.py &amp; file_2.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for rbenv.py &amp; file_2.py
      </h3>
<h1 align="center">
        1.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>rbenv.py (17.96875%)<th>file_2.py (0.5757917%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(218-243)<td><a href="#" name="0">(5024-5041)</a><td align="center"><font color="#ff0000">19</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(200-206)<td><a href="#" name="1">(8887-8892)</a><td align="center"><font color="#c90000">15</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(246-252)<td><a href="#" name="2">(5224-5230)</a><td align="center"><font color="#a10000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>rbenv.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import re
3 def _check_rbenv(ret, user=None):
4     if not __salt__["rbenv.is_installed"](user):
5         ret["result"] = False
6         ret["comment"] = "Rbenv is not installed."
7     return ret
8 def _ruby_installed(ret, ruby, user=None):
9     default = __salt__["rbenv.default"](runas=user)
10     for version in __salt__["rbenv.versions"](user):
11         if version == ruby:
12             ret["result"] = True
13             ret["comment"] = "Requested ruby exists"
14             ret["default"] = default == ruby
15             break
16     return ret
17 def _check_and_install_ruby(ret, ruby, default=False, user=None):
18     ret = _ruby_installed(ret, ruby, user=user)
19     if not ret["result"]:
20         if __salt__["rbenv.install_ruby"](ruby, runas=user):
21             ret["result"] = True
22             ret["changes"][ruby] = "Installed"
23             ret["comment"] = "Successfully installed ruby"
24             ret["default"] = default
25         else:
26             ret["result"] = False
27             ret["comment"] = "Failed to install ruby"
28             return ret
29     if default:
30         __salt__["rbenv.default"](ruby, runas=user)
31     return ret
32 def installed(name, default=False, user=None):
33     ret = {"name": name, "result": None, "comment": "", "changes": {}}
34     rbenv_installed_ret = copy.deepcopy(ret)
35     if name.startswith("ruby-"):
36         name = re.sub(r"^ruby-", "", name)
37     if __opts__["test"]:
38         ret = _ruby_installed(ret, name, user=user)
39         if not ret["result"]:
40             ret["comment"] = "Ruby {} is set to be installed".format(name)
41         else:
42             ret["comment"] = "Ruby {} is already installed".format(name)
43         return ret
44     rbenv_installed_ret = _check_and_install_rbenv(rbenv_installed_ret, user)
45     if rbenv_installed_ret["result"] is False:
46         ret["result"] = False
47         ret["comment"] = "Rbenv failed to install"
48         return ret
49     else:
50         return _check_and_install_ruby(ret, name, default, user=user)
51 def _check_and_uninstall_ruby(ret, ruby, user=None):
52     ret = _ruby_installed(ret, ruby, user=user)
53     if ret["result"]:
54         if ret["default"]:
55             __salt__["rbenv.default"]("system", runas=user)
56         if __salt__["rbenv.uninstall_ruby"](ruby, runas=user):
57             ret["result"] = True
58             ret["changes"][ruby] = "Uninstalled"
59             ret["comment"] = "Successfully removed ruby"
60             return ret
61         else:
62             ret["result"] = False
63             ret["comment"] = "Failed to uninstall ruby"
64             return ret
65     else:
66         ret["result"] = True
67         ret["comment"] = "Ruby {} is already absent".format(ruby)
68     return ret
69 def absent(name, user=None):
70     ret = {"name": name, "result": None, "comment": "", "changes": {}}
71     if name.startswith("ruby-"):
72         name = re.sub(r"^ruby-", "", name)
73     ret = _check_rbenv(ret, user)
74     if ret["result"] is False:
75         ret["result"] = True
76         ret["comment"] = "Rbenv not installed, {} not either".format(name)
77         return ret
78 <a name="1"></a>    else:
79         if __opts__["test"]:
80             ret = _ruby_installed(ret, name, user=user)
81             if ret<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["result"]:
82                 ret["result"] = None
83                 ret["comment"] = "Ruby {} is set to be uninstalled".format(name)
84             else:
85                 ret["result"] = True
86                 ret["comment"] = "Ruby {} is already uninstalled".format(name)
87             return</b></font> ret
88         return _check_and_uninstall_ruby(ret, name, user=user)
89 def _check_and_install_rbenv(ret, user=None):
90 <a name="0"></a>    ret = _check_rbenv(ret, user)
91     if ret["result"] is False:
92         if __salt__["rbenv.install"](user):
93             ret<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["result"] = True
94             ret["comment"] = "Rbenv installed"
95         else:
96             ret["result"] = False
97             ret["comment"] = "Rbenv failed to install"
98     else:
99         ret["result"] = True
100         ret["comment"] = "Rbenv is already installed"
101     return ret
102 def install_rbenv(name, user=None):
103 <a name="2"></a>    ret =</b></font> {"name": name, "result": None, "comment": "", "changes": {}}
104     if __opts__["test"]:
105         ret = _check_rbenv(ret, user<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=user)
106         if ret["result"] is False:
107             ret["result"] = None
108             ret["comment"] = "Rbenv is set to be installed"
109         else:
110             ret["result"] = True
111             ret["comment"] =</b></font> "Rbenv is already installed"
112         return ret
113     return _check_and_install_rbenv(ret, user)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>file_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import difflib
3 import itertools
4 import logging
5 import os
6 import posixpath
7 import re
8 import shutil
9 import sys
10 import time
11 import traceback
12 import urllib.parse
13 from collections import defaultdict
14 from collections.abc import Iterable, Mapping
15 from datetime import date, datetime  # python3 problem in the making?
16 from itertools import zip_longest
17 import salt.loader
18 import salt.payload
19 import salt.utils.data
20 import salt.utils.dateutils
21 import salt.utils.dictupdate
22 import salt.utils.files
23 import salt.utils.hashutils
24 import salt.utils.path
25 import salt.utils.platform
26 import salt.utils.stringutils
27 import salt.utils.templates
28 import salt.utils.url
29 import salt.utils.versions
30 from salt.exceptions import CommandExecutionError
31 from salt.serializers import DeserializationError
32 from salt.state import get_accumulator_dir as _get_accumulator_dir
33 from salt.utils.odict import OrderedDict
34 if salt.utils.platform.is_windows():
35     import salt.utils.win_dacl
36     import salt.utils.win_functions
37     import salt.utils.winapi
38 if salt.utils.platform.is_windows():
39     import pywintypes
40     import win32com.client
41 log = logging.getLogger(__name__)
42 COMMENT_REGEX = r"^([[:space:]]*){0}[[:space:]]?"
43 __NOT_FOUND = object()
44 __func_alias__ = {
45     "copy_": "copy",
46 }
47 def _get_accumulator_filepath():
48     return os.path.join(_get_accumulator_dir(__opts__["cachedir"]), __instance_id__)
49 def _load_accumulators():
50     def _deserialize(path):
51         ret = {"accumulators": {}, "accumulators_deps": {}}
52         try:
53             with salt.utils.files.fopen(path, "rb") as f:
54                 loaded = salt.payload.load(f)
55                 return loaded if loaded else ret
56         except (OSError, NameError):
57             return ret
58     loaded = _deserialize(_get_accumulator_filepath())
59     return loaded["accumulators"], loaded["accumulators_deps"]
60 def _persist_accummulators(accumulators, accumulators_deps):
61     accumm_data = {"accumulators": accumulators, "accumulators_deps": accumulators_deps}
62     try:
63         with salt.utils.files.fopen(_get_accumulator_filepath(), "w+b") as f:
64             salt.payload.dump(accumm_data, f)
65     except NameError:
66         pass
67 def _check_user(user, group):
68     err = ""
69     if user:
70         uid = __salt__["file.user_to_uid"](user)
71         if uid == "":
72             err += "User {} is not available ".format(user)
73     if group:
74         gid = __salt__["file.group_to_gid"](group)
75         if gid == "":
76             err += "Group {} is not available".format(group)
77     return err
78 def _is_valid_relpath(relpath, maxdepth=None):
79     sep, pardir = posixpath.sep, posixpath.pardir
80     if sep + pardir + sep in sep + relpath + sep:
81         return False
82     if maxdepth is not None:
83         path_depth = relpath.strip(sep).count(sep)
84         if path_depth &gt; maxdepth:
85             return False
86     return True
87 def _salt_to_os_path(path):
88     return os.path.normpath(path.replace(posixpath.sep, os.path.sep))
89 def _gen_recurse_managed_files(
90     name,
91     source,
92     keep_symlinks=False,
93     include_pat=None,
94     exclude_pat=None,
95     maxdepth=None,
96     include_empty=False,
97     **kwargs
98 ):
99     def full_path(master_relpath):
100         return os.path.join(name, _salt_to_os_path(master_relpath))
101     def process_symlinks(filenames, symlinks):
102         for lname, ltarget in symlinks.items():
103             srelpath = posixpath.relpath(lname, srcpath)
104             if not _is_valid_relpath(srelpath, maxdepth=maxdepth):
105                 continue
106             if not salt.utils.stringutils.check_include_exclude(
107                 srelpath, include_pat, exclude_pat
108             ):
109                 continue
110             _filenames = list(filenames)
111             for filename in _filenames:
112                 if filename.startswith(lname + os.sep):
113                     log.debug(
114                         "** skipping file ** %s, it intersects a symlink", filename
115                     )
116                     filenames.remove(filename)
117             managed_symlinks.add((srelpath, ltarget))
118             keep.add(full_path(srelpath))
119         vdir.update(keep)
120         return filenames
121     managed_files = set()
122     managed_directories = set()
123     managed_symlinks = set()
124     keep = set()
125     vdir = set()
126     srcpath, senv = salt.utils.url.parse(source)
127     if senv is None:
128         senv = __env__
129     if not srcpath.endswith(posixpath.sep):
130         srcpath = srcpath + posixpath.sep
131     fns_ = __salt__["cp.list_master"](senv, srcpath)
132     if keep_symlinks:
133         symlinks = __salt__["cp.list_master_symlinks"](senv, srcpath)
134         fns_ = process_symlinks(fns_, symlinks)
135     for fn_ in fns_:
136         if not fn_.strip():
137             continue
138         relname = salt.utils.data.decode(posixpath.relpath(fn_, srcpath))
139         if not _is_valid_relpath(relname, maxdepth=maxdepth):
140             continue
141         if not salt.utils.stringutils.check_include_exclude(
142             relname, include_pat, exclude_pat
143         ):
144             continue
145         dest = full_path(relname)
146         dirname = os.path.dirname(dest)
147         keep.add(dest)
148         if dirname not in vdir:
149             managed_directories.add(dirname)
150             vdir.add(dirname)
151         src = salt.utils.url.create(fn_, saltenv=senv)
152         managed_files.add((dest, src))
153     if include_empty:
154         mdirs = __salt__["cp.list_master_dirs"](senv, srcpath)
155         for mdir in mdirs:
156             relname = posixpath.relpath(mdir, srcpath)
157             if not _is_valid_relpath(relname, maxdepth=maxdepth):
158                 continue
159             if not salt.utils.stringutils.check_include_exclude(
160                 relname, include_pat, exclude_pat
161             ):
162                 continue
163             mdest = full_path(relname)
164             if keep_symlinks:
165                 islink = False
166                 for link in symlinks:
167                     if mdir.startswith(link + os.sep, 0):
168                         log.debug(
169                             "** skipping empty dir ** %s, it intersects a symlink", mdir
170                         )
171                         islink = True
172                         break
173                 if islink:
174                     continue
175             managed_directories.add(mdest)
176             keep.add(mdest)
177     return managed_files, managed_directories, managed_symlinks, keep
178 def _gen_keep_files(name, require, walk_d=None):
179     def _is_child(path, directory):
180         path = os.path.abspath(path)
181         directory = os.path.abspath(directory)
182         relative = os.path.relpath(path, directory)
183         return not relative.startswith(os.pardir)
184     def _add_current_path(path):
185         _ret = set()
186         if os.path.isdir(path):
187             dirs, files = walk_d.get(path, ((), ()))
188             _ret.add(path)
189             for _name in files:
190                 _ret.add(os.path.join(path, _name))
191             for _name in dirs:
192                 _ret.add(os.path.join(path, _name))
193         return _ret
194     def _process_by_walk_d(name, ret):
195         if os.path.isdir(name):
196             walk_ret.update(_add_current_path(name))
197             dirs, _ = walk_d.get(name, ((), ()))
198             for _d in dirs:
199                 p = os.path.join(name, _d)
200                 walk_ret.update(_add_current_path(p))
201                 _process_by_walk_d(p, ret)
202     def _process(name):
203         ret = set()
204         if os.path.isdir(name):
205             for root, dirs, files in salt.utils.path.os_walk(name):
206                 ret.add(name)
207                 for name in files:
208                     ret.add(os.path.join(root, name))
209                 for name in dirs:
210                     ret.add(os.path.join(root, name))
211         return ret
212     keep = set()
213     if isinstance(require, list):
214         required_files = [comp for comp in require if "file" in comp]
215         for comp in required_files:
216             for low in __lowstate__:
217                 if low["name"] == comp["file"] or low["__id__"] == comp["file"]:
218                     fn = low["name"]
219                     fun = low["fun"]
220                     if os.path.isdir(fn):
221                         if _is_child(fn, name):
222                             if fun == "recurse":
223                                 fkeep = _gen_recurse_managed_files(**low)[3]
224                                 log.debug("Keep from %s: %s", fn, fkeep)
225                                 keep.update(fkeep)
226                             elif walk_d:
227                                 walk_ret = set()
228                                 _process_by_walk_d(fn, walk_ret)
229                                 keep.update(walk_ret)
230                             else:
231                                 keep.update(_process(fn))
232                     else:
233                         keep.add(fn)
234     log.debug("Files to keep from required states: %s", list(keep))
235     return list(keep)
236 def _check_file(name):
237     ret = True
238     msg = ""
239     if not os.path.isabs(name):
240         ret = False
241         msg = "Specified file {} is not an absolute path".format(name)
242     elif not os.path.exists(name):
243         ret = False
244         msg = "{}: file not found".format(name)
245     return ret, msg
246 def _find_keep_files(root, keep):
247     real_keep = set()
248     real_keep.add(root)
249     if isinstance(keep, list):
250         for fn_ in keep:
251             if not os.path.isabs(fn_):
252                 continue
253             fn_ = os.path.normcase(os.path.abspath(fn_))
254             real_keep.add(fn_)
255             while True:
256                 fn_ = os.path.abspath(os.path.dirname(fn_))
257                 real_keep.add(fn_)
258                 drive, path = os.path.splitdrive(fn_)
259                 if not path.lstrip(os.sep):
260                     break
261     return real_keep
262 def _clean_dir(root, keep, exclude_pat):
263     case_keep = None
264     if salt.utils.files.case_insensitive_filesystem():
265         case_keep = keep
266     root = os.path.normcase(root)
267     real_keep = _find_keep_files(root, keep)
268     removed = set()
269     def _delete_not_kept(nfn):
270         if nfn not in real_keep:
271             if not salt.utils.stringutils.check_include_exclude(
272                 os.path.relpath(nfn, root), None, exclude_pat
273             ):
274                 return
275             if case_keep:
276                 for item in case_keep:
277                     if item.casefold() == nfn.casefold():
278                         return
279             removed.add(nfn)
280             if not __opts__["test"]:
281                 try:
282                     os.remove(nfn)
283                 except OSError:
284                     __salt__["file.remove"](nfn)
285     for roots, dirs, files in salt.utils.path.os_walk(root):
286         for name in itertools.chain(dirs, files):
287             _delete_not_kept(os.path.join(roots, name))
288     return list(removed)
289 def _error(ret, err_msg):
290     ret["result"] = False
291     ret["comment"] = err_msg
292     return ret
293 def _check_directory(
294     name,
295     user=None,
296     group=None,
297     recurse=False,
298     dir_mode=None,
299     file_mode=None,
300     clean=False,
301     require=False,
302     exclude_pat=None,
303     max_depth=None,
304     follow_symlinks=False,
305 ):
306     changes = {}
307     if recurse or clean:
308         assert max_depth is None or not clean
309         walk_l = list(_depth_limited_walk(name, max_depth))
310         walk_d = {}
311         for i in walk_l:
312             walk_d[i[0]] = (i[1], i[2])
313     if recurse:
314         try:
315             recurse_set = _get_recurse_set(recurse)
316         except (TypeError, ValueError) as exc:
317             return False, "{}".format(exc), changes
318         if "user" not in recurse_set:
319             user = None
320         if "group" not in recurse_set:
321             group = None
322         if "mode" not in recurse_set:
323             dir_mode = None
324             file_mode = None
325         check_files = "ignore_files" not in recurse_set
326         check_dirs = "ignore_dirs" not in recurse_set
327         for root, dirs, files in walk_l:
328             if check_files:
329                 for fname in files:
330                     fchange = {}
331                     path = os.path.join(root, fname)
332                     stats = __salt__["file.stats"](path, None, follow_symlinks)
333                     if user is not None and user != stats.get("user"):
334                         fchange["user"] = user
335                     if group is not None and group != stats.get("group"):
336                         fchange["group"] = group
337                     smode = salt.utils.files.normalize_mode(stats.get("mode"))
338                     file_mode = salt.utils.files.normalize_mode(file_mode)
339                     if (
340                         file_mode is not None
341                         and file_mode != smode
342                         and (
343                             follow_symlinks
344                             or stats.get("type") != "link"
345                             or not salt.utils.platform.is_linux()
346                         )
347                     ):
348                         fchange["mode"] = file_mode
349                     if fchange:
350                         changes[path] = fchange
351             if check_dirs:
352                 for name_ in dirs:
353                     path = os.path.join(root, name_)
354                     fchange = _check_dir_meta(
355                         path, user, group, dir_mode, follow_symlinks
356                     )
357                     if fchange:
358                         changes[path] = fchange
359     fchange = _check_dir_meta(name, user, group, dir_mode, follow_symlinks)
360     if fchange:
361         changes[name] = fchange
362     if clean:
363         keep = _gen_keep_files(name, require, walk_d)
364         def _check_changes(fname):
365             path = os.path.join(root, fname)
366             if path in keep:
367                 return {}
368             else:
369                 if not salt.utils.stringutils.check_include_exclude(
370                     os.path.relpath(path, name), None, exclude_pat
371                 ):
372                     return {}
373                 else:
374                     return {path: {"removed": "Removed due to clean"}}
375         for root, dirs, files in walk_l:
376             for fname in files:
377                 changes.update(_check_changes(fname))
378             for name_ in dirs:
379                 changes.update(_check_changes(name_))
380     if not os.path.isdir(name):
381         changes[name] = {"directory": "new"}
382     if changes:
383         comments = ["The following files will be changed:\n"]
384         for fn_ in changes:
385             for key, val in changes[fn_].items():
386                 comments.append("{}: {} - {}\n".format(fn_, key, val))
387         return None, "".join(comments), changes
388     return True, "The directory {} is in the correct state".format(name), changes
389 def _check_directory_win(
390     name,
391     win_owner=None,
392     win_perms=None,
393     win_deny_perms=None,
394     win_inheritance=None,
395     win_perms_reset=None,
396 ):
397     if not os.path.isdir(name):
398         changes = {name: {"directory": "new"}}
399     else:
400         changes = salt.utils.win_dacl.check_perms(
401             obj_name=name,
402             obj_type="file",
403             ret={},
404             owner=win_owner,
405             grant_perms=win_perms,
406             deny_perms=win_deny_perms,
407             inheritance=win_inheritance,
408             reset=win_perms_reset,
409             test_mode=True,
410         )["changes"]
411     if changes:
412         return None, 'The directory "{}" will be changed'.format(name), changes
413     return True, "The directory {} is in the correct state".format(name), changes
414 def _check_dir_meta(name, user, group, mode, follow_symlinks=False):
415     try:
416         stats = __salt__["file.stats"](name, None, follow_symlinks)
417     except CommandExecutionError:
418         stats = {}
419     changes = {}
420     if not stats:
421         changes["directory"] = "new"
422         return changes
423     if user is not None and user != stats["user"] and user != stats.get("uid"):
424         changes["user"] = user
425     if group is not None and group != stats["group"] and group != stats.get("gid"):
426         changes["group"] = group
427     smode = salt.utils.files.normalize_mode(stats["mode"])
428     mode = salt.utils.files.normalize_mode(mode)
429     if (
430         mode is not None
431         and mode != smode
432         and (
433             follow_symlinks
434             or stats.get("type") != "link"
435             or not salt.utils.platform.is_linux()
436         )
437     ):
438         changes["mode"] = mode
439     return changes
440 def _check_touch(name, atime, mtime):
441     ret = {
442         "result": None,
443         "comment": "",
444         "changes": {"new": name},
445     }
446     if not os.path.exists(name):
447         ret["comment"] = "File {} is set to be created".format(name)
448     else:
449         stats = __salt__["file.stats"](name, follow_symlinks=False)
450         if (atime is not None and str(atime) != str(stats["atime"])) or (
451             mtime is not None and str(mtime) != str(stats["mtime"])
452         ):
453             ret["comment"] = "Times set to be updated on file {}".format(name)
454             ret["changes"] = {"touched": name}
455         else:
456             ret["result"] = True
457             ret["comment"] = "File {} exists and has the correct times".format(name)
458     return ret
459 def _get_symlink_ownership(path):
460     if salt.utils.platform.is_windows():
461         owner = salt.utils.win_dacl.get_owner(path)
462         return owner, owner
463     else:
464         return (
465             __salt__["file.get_user"](path, follow_symlinks=False),
466             __salt__["file.get_group"](path, follow_symlinks=False),
467         )
468 def _check_symlink_ownership(path, user, group, win_owner):
469     cur_user, cur_group = _get_symlink_ownership(path)
470     if salt.utils.platform.is_windows():
471         return win_owner == cur_user
472     else:
473         return (cur_user == user) and (cur_group == group)
474 def _set_symlink_ownership(path, user, group, win_owner):
475     if salt.utils.platform.is_windows():
476         try:
477             salt.utils.win_dacl.set_owner(path, win_owner)
478         except CommandExecutionError:
479             pass
480     else:
481         try:
482             __salt__["file.lchown"](path, user, group)
483         except OSError:
484             pass
485     return _check_symlink_ownership(path, user, group, win_owner)
486 def _symlink_check(name, target, force, user, group, win_owner):
487     changes = {}
488     if not os.path.exists(name) and not __salt__["file.is_link"](name):
489         changes["new"] = name
490         return (
491             None,
492             "Symlink {} to {} is set for creation".format(name, target),
493             changes,
494         )
495     if __salt__["file.is_link"](name):
496         if __salt__["file.readlink"](name) != target:
497             changes["change"] = name
498             return (
499                 None,
500                 "Link {} target is set to be changed to {}".format(name, target),
501                 changes,
502             )
503         else:
504             result = True
505             msg = "The symlink {} is present".format(name)
506             if not _check_symlink_ownership(name, user, group, win_owner):
507                 result = None
508                 changes["ownership"] = "{}:{}".format(*_get_symlink_ownership(name))
509                 msg += (
510                     ", but the ownership of the symlink would be changed "
511                     "from {2}:{3} to {0}:{1}".format(
512                         user, group, *_get_symlink_ownership(name)
513                     )
514                 )
515             return result, msg, changes
516     else:
517         if force:
518             return (
519                 None,
520                 "The file or directory {} is set for removal to "
521                 "make way for a new symlink targeting {}".format(name, target),
522                 changes,
523             )
524         return (
525             False,
526             "File or directory exists where the symlink {} "
527             "should be. Did you mean to use force?".format(name),
528             changes,
529         )
530 def _hardlink_same(name, target):
531     res = __salt__["file.stats"](name, None, follow_symlinks=False)
532     if "inode" not in res:
533         return False
534     name_i = res["inode"]
535     res = __salt__["file.stats"](target, None, follow_symlinks=False)
536     if "inode" not in res:
537         return False
538     target_i = res["inode"]
539     return name_i == target_i
540 def _hardlink_check(name, target, force):
541     changes = {}
542     if not os.path.exists(target):
543         msg = "Target {} for hard link does not exist".format(target)
544         return False, msg, changes
545     elif os.path.isdir(target):
546         msg = "Unable to hard link from directory {}".format(target)
547         return False, msg, changes
548     if os.path.isdir(name):
549         msg = "Unable to hard link to directory {}".format(name)
550         return False, msg, changes
551     elif not os.path.exists(name):
552         msg = "Hard link {} to {} is set for creation".format(name, target)
553         changes["new"] = name
554         return None, msg, changes
555     elif __salt__["file.is_hardlink"](name):
556         if _hardlink_same(name, target):
557             msg = "The hard link {} is presently targetting {}".format(name, target)
558             return True, msg, changes
559         msg = "Link {} target is set to be changed to {}".format(name, target)
560         changes["change"] = name
561         return None, msg, changes
562     if force:
563         msg = (
564             "The file or directory {} is set for removal to "
565             "make way for a new hard link targeting {}".format(name, target)
566         )
567         return None, msg, changes
568     msg = (
569         "File or directory exists where the hard link {} "
570         "should be. Did you mean to use force?".format(name)
571     )
572     return False, msg, changes
573 def _test_owner(kwargs, user=None):
574     if user:
575         return user
576     if "owner" in kwargs:
577         log.warning(
578             'Use of argument owner found, "owner" is invalid, please use "user"'
579         )
580         return kwargs["owner"]
581     return user
582 def _unify_sources_and_hashes(
583     source=None, source_hash=None, sources=None, source_hashes=None
584 ):
585     if sources is None:
586         sources = []
587     if source_hashes is None:
588         source_hashes = []
589     if source and sources:
590         return (False, "source and sources are mutually exclusive", [])
591     if source_hash and source_hashes:
592         return (False, "source_hash and source_hashes are mutually exclusive", [])
593     if source:
594         return (True, "", [(source, source_hash)])
595     return True, "", list(zip_longest(sources, source_hashes[: len(sources)]))
596 def _get_template_texts(
597     source_list=None, template="jinja", defaults=None, context=None, **kwargs
598 ):
599     ret = {
600         "name": "_get_template_texts",
601         "changes": {},
602         "result": True,
603         "comment": "",
604         "data": [],
605     }
606     if source_list is None:
607         return _error(ret, "_get_template_texts called with empty source_list")
608     txtl = []
609     for (source, source_hash) in source_list:
610         tmpctx = defaults if defaults else {}
611         if context:
612             tmpctx.update(context)
613         rndrd_templ_fn = __salt__["cp.get_template"](
614             source, "", template=template, saltenv=__env__, context=tmpctx, **kwargs
615         )
616         log.debug(
617             "cp.get_template returned %s (Called with: %s)", rndrd_templ_fn, source
618         )
619         if rndrd_templ_fn:
620             tmplines = None
621             with salt.utils.files.fopen(rndrd_templ_fn, "rb") as fp_:
622                 tmplines = fp_.read()
623                 tmplines = salt.utils.stringutils.to_unicode(tmplines)
624                 tmplines = tmplines.splitlines(True)
625             if not tmplines:
626                 msg = "Failed to read rendered template file {} ({})".format(
627                     rndrd_templ_fn, source
628                 )
629                 log.debug(msg)
630                 ret["name"] = source
631                 return _error(ret, msg)
632             txtl.append("".join(tmplines))
633         else:
634             msg = "Failed to load template file {}".format(source)
635             log.debug(msg)
636             ret["name"] = source
637             return _error(ret, msg)
638     ret["data"] = txtl
639     return ret
640 def _validate_str_list(arg, encoding=None):
641     if isinstance(arg, bytes):
642         ret = [salt.utils.stringutils.to_unicode(arg, encoding=encoding)]
643     elif isinstance(arg, str):
644         ret = [arg]
645     elif isinstance(arg, Iterable) and not isinstance(arg, Mapping):
646         ret = []
647         for item in arg:
648             if isinstance(item, str):
649                 ret.append(item)
650             else:
651                 ret.append(str(item))
652     else:
653         ret = [str(arg)]
654     return ret
655 def _get_shortcut_ownership(path):
656     return __salt__["file.get_user"](path, follow_symlinks=False)
657 def _check_shortcut_ownership(path, user):
658     cur_user = _get_shortcut_ownership(path)
659     return cur_user == user
660 def _set_shortcut_ownership(path, user):
661     try:
662         __salt__["file.lchown"](path, user)
663     except OSError:
664         pass
665     return _check_shortcut_ownership(path, user)
666 def _shortcut_check(
667     name, target, arguments, working_dir, description, icon_location, force, user
668 ):
669     changes = {}
670     if not os.path.exists(name):
671         changes["new"] = name
672         return (
673             None,
674             'Shortcut "{}" to "{}" is set for creation'.format(name, target),
675             changes,
676         )
677     if os.path.isfile(name):
678         with salt.utils.winapi.Com():
679             shell = win32com.client.Dispatch("WScript.Shell")
680             scut = shell.CreateShortcut(name)
681             state_checks = [scut.TargetPath.lower() == target.lower()]
682             if arguments is not None:
683                 state_checks.append(scut.Arguments == arguments)
684             if working_dir is not None:
685                 state_checks.append(
686                     scut.WorkingDirectory.lower() == working_dir.lower()
687                 )
688             if description is not None:
689                 state_checks.append(scut.Description == description)
690             if icon_location is not None:
691                 state_checks.append(scut.IconLocation.lower() == icon_location.lower())
692         if not all(state_checks):
693             changes["change"] = name
694             return (
695                 None,
696                 'Shortcut "{}" target is set to be changed to "{}"'.format(
697                     name, target
698                 ),
699                 changes,
700             )
701         else:
702             result = True
703             msg = 'The shortcut "{}" is present'.format(name)
704             if not _check_shortcut_ownership(name, user):
705                 result = None
706                 changes["ownership"] = "{}".format(_get_shortcut_ownership(name))
707                 msg += (
708                     ", but the ownership of the shortcut would be changed "
709                     "from {1} to {0}".format(user, _get_shortcut_ownership(name))
710                 )
711             return result, msg, changes
712     else:
713         if force:
714             return (
715                 None,
716                 'The link or directory "{}" is set for removal to '
717                 'make way for a new shortcut targeting "{}"'.format(name, target),
718                 changes,
719             )
720         return (
721             False,
722             'Link or directory exists where the shortcut "{}" '
723             "should be. Did you mean to use force?".format(name),
724             changes,
725         )
726 def _makedirs(
727     name,
728     user=None,
729     group=None,
730     dir_mode=None,
731     win_owner=None,
732     win_perms=None,
733     win_deny_perms=None,
734     win_inheritance=None,
735 ):
736     if salt.utils.platform.is_windows():
737         drive, path = os.path.splitdrive(name)
738         if not os.path.isdir(drive):
739             raise CommandExecutionError(drive)
740         win_owner = win_owner if win_owner else user
741         return __salt__["file.makedirs"](
742             path=name,
743             owner=win_owner,
744             grant_perms=win_perms,
745             deny_perms=win_deny_perms,
746             inheritance=win_inheritance,
747         )
748     else:
749         return __salt__["file.makedirs"](
750             path=name, user=user, group=group, mode=dir_mode
751         )
752 def hardlink(
753     name,
754     target,
755     force=False,
756     makedirs=False,
757     user=None,
758     group=None,
759     dir_mode=None,
760     **kwargs
761 ):
762     name = os.path.expanduser(name)
763     dir_mode = salt.utils.files.normalize_mode(dir_mode)
764     user = _test_owner(kwargs, user=user)
765     ret = {"name": name, "changes": {}, "result": True, "comment": ""}
766     if not name:
767         return _error(ret, "Must provide name to file.hardlink")
768     if user is None:
769         user = __opts__["user"]
770     if salt.utils.platform.is_windows():
771         if group is not None:
772             log.warning(
773                 "The group argument for %s has been ignored as this "
774                 "is a Windows system.",
775                 name,
776             )
777         group = user
778     if group is None:
779         if "user.info" in __salt__:
780             group = __salt__["file.gid_to_group"](
781                 __salt__["user.info"](user).get("gid", 0)
782             )
783         else:
784             group = user
785     preflight_errors = []
786     uid = __salt__["file.user_to_uid"](user)
787     gid = __salt__["file.group_to_gid"](group)
788     if uid == "":
789         preflight_errors.append("User {} does not exist".format(user))
790     if gid == "":
791         preflight_errors.append("Group {} does not exist".format(group))
792     if not os.path.isabs(name):
793         preflight_errors.append(
794             "Specified file {} is not an absolute path".format(name)
795         )
796     if not os.path.isabs(target):
797         preflight_errors.append(
798             "Specified target {} is not an absolute path".format(target)
799         )
800     if preflight_errors:
801         msg = ". ".join(preflight_errors)
802         if len(preflight_errors) &gt; 1:
803             msg += "."
804         return _error(ret, msg)
805     if __opts__["test"]:
806         tresult, tcomment, tchanges = _hardlink_check(name, target, force)
807         ret["result"] = tresult
808         ret["comment"] = tcomment
809         ret["changes"] = tchanges
810         return ret
811     for direction, item in zip_longest(["to", "from"], [name, target]):
812         if os.path.isdir(item):
813             msg = "Unable to hard link {} directory {}".format(direction, item)
814             return _error(ret, msg)
815     if not os.path.exists(target):
816         msg = "Target {} for hard link does not exist".format(target)
817         return _error(ret, msg)
818     if not os.path.isdir(os.path.dirname(name)):
819         if makedirs:
820             __salt__["file.makedirs"](name, user=user, group=group, mode=dir_mode)
821         else:
822             return _error(
823                 ret,
824                 "Directory {} for hard link is not present".format(
825                     os.path.dirname(name)
826                 ),
827             )
828     if os.path.isfile(name) and not __salt__["file.is_hardlink"](name):
829         if force:
830             os.remove(name)
831             ret["changes"]["forced"] = "File for hard link was forcibly replaced"
832         else:
833             return _error(
834                 ret, "File exists where the hard link {} should be".format(name)
835             )
836     if __salt__["file.is_hardlink"](name):
837         if _hardlink_same(name, target):
838             ret["result"] = True
839             ret["comment"] = "Target of hard link {} is already pointing to {}".format(
840                 name, target
841             )
842             return ret
843         os.remove(name)
844         try:
845             __salt__["file.link"](target, name)
846         except CommandExecutionError as E:
847             ret["result"] = False
848             ret["comment"] = "Unable to set target of hard link {} -&gt; {}: {}".format(
849                 name, target, E
850             )
851             return ret
852         ret["result"] = True
853         ret["comment"] = "Set target of hard link {} -&gt; {}".format(name, target)
854         ret["changes"]["new"] = name
855     elif not os.path.exists(name):
856         try:
857             __salt__["file.link"](target, name)
858         except CommandExecutionError as E:
859             ret["result"] = False
860             ret["comment"] = "Unable to create new hard link {} -&gt; {}: {}".format(
861                 name, target, E
862             )
863             return ret
864         ret["result"] = True
865         ret["comment"] = "Created new hard link {} -&gt; {}".format(name, target)
866         ret["changes"]["new"] = name
867     return ret
868 def symlink(
869     name,
870     target,
871     force=False,
872     backupname=None,
873     makedirs=False,
874     user=None,
875     group=None,
876     mode=None,
877     win_owner=None,
878     win_perms=None,
879     win_deny_perms=None,
880     win_inheritance=None,
881     **kwargs
882 ):
883     name = os.path.expanduser(name)
884     mode = salt.utils.files.normalize_mode(mode)
885     user = _test_owner(kwargs, user=user)
886     ret = {"name": name, "changes": {}, "result": True, "comment": ""}
887     if not name:
888         return _error(ret, "Must provide name to file.symlink")
889     if user is None:
890         user = __opts__["user"]
891     if salt.utils.platform.is_windows():
892         if not __salt__["user.info"](user):
893             user = __salt__["user.current"]()
894             if not user:
895                 user = "SYSTEM"
896         if win_owner is None:
897             win_owner = user if user else None
898         if group is not None:
899             log.warning(
900                 "The group argument for %s has been ignored as this "
901                 "is a Windows system. Please use the `win_*` parameters to set "
902                 "permissions in Windows.",
903                 name,
904             )
905         group = user
906     if group is None:
907         if "user.info" in __salt__:
908             group = __salt__["file.gid_to_group"](
909                 __salt__["user.info"](user).get("gid", 0)
910             )
911         else:
912             group = user
913     preflight_errors = []
914     if salt.utils.platform.is_windows():
915         try:
916             salt.utils.win_functions.get_sid_from_name(win_owner)
917         except CommandExecutionError as exc:
918             preflight_errors.append("User {} does not exist".format(win_owner))
919         if win_perms:
920             for name_check in win_perms:
921                 try:
922                     salt.utils.win_functions.get_sid_from_name(name_check)
923                 except CommandExecutionError as exc:
924                     preflight_errors.append("User {} does not exist".format(name_check))
925         if win_deny_perms:
926             for name_check in win_deny_perms:
927                 try:
928                     salt.utils.win_functions.get_sid_from_name(name_check)
929                 except CommandExecutionError as exc:
930                     preflight_errors.append("User {} does not exist".format(name_check))
931     else:
932         uid = __salt__["file.user_to_uid"](user)
933         gid = __salt__["file.group_to_gid"](group)
934         if uid == "":
935             preflight_errors.append("User {} does not exist".format(user))
936         if gid == "":
937             preflight_errors.append("Group {} does not exist".format(group))
938     if not os.path.isabs(name):
939         preflight_errors.append(
940             "Specified file {} is not an absolute path".format(name)
941         )
942     if preflight_errors:
943         msg = ". ".join(preflight_errors)
944         if len(preflight_errors) &gt; 1:
945             msg += "."
946         return _error(ret, msg)
947     tresult, tcomment, tchanges = _symlink_check(
948         name, target, force, user, group, win_owner
949     )
950     if not os.path.isdir(os.path.dirname(name)):
951         if makedirs:
952             if __opts__["test"]:
953                 tcomment += "\n{} will be created".format(os.path.dirname(name))
954             else:
955                 try:
956                     _makedirs(
957                         name=name,
958                         user=user,
959                         group=group,
960                         dir_mode=mode,
961                         win_owner=win_owner,
962                         win_perms=win_perms,
963                         win_deny_perms=win_deny_perms,
964                         win_inheritance=win_inheritance,
965                     )
966                 except CommandExecutionError as exc:
967                     return _error(ret, "Drive {} is not mapped".format(exc.message))
968         else:
969             if __opts__["test"]:
970                 tcomment += "\nDirectory {} for symlink is not present".format(
971                     os.path.dirname(name)
972                 )
973             else:
974                 return _error(
975                     ret,
976                     "Directory {} for symlink is not present".format(
977                         os.path.dirname(name)
978                     ),
979                 )
980     if __opts__["test"]:
981         ret["result"] = tresult
982         ret["comment"] = tcomment
983         ret["changes"] = tchanges
984         return ret
985     if __salt__["file.is_link"](name):
986         if os.path.normpath(__salt__["file.readlink"](name)) != os.path.normpath(
987             target
988         ):
989             os.remove(name)
990         else:
991             if _check_symlink_ownership(name, user, group, win_owner):
992                 if salt.utils.platform.is_windows():
993                     ret["comment"] = "Symlink {} is present and owned by {}".format(
994                         name, win_owner
995                     )
996                 else:
997                     ret["comment"] = "Symlink {} is present and owned by {}:{}".format(
998                         name, user, group
999                     )
1000             else:
1001                 if _set_symlink_ownership(name, user, group, win_owner):
1002                     if salt.utils.platform.is_windows():
1003                         ret["comment"] = "Set ownership of symlink {} to {}".format(
1004                             name, win_owner
1005                         )
1006                         ret["changes"]["ownership"] = win_owner
1007                     else:
1008                         ret["comment"] = "Set ownership of symlink {} to {}:{}".format(
1009                             name, user, group
1010                         )
1011                         ret["changes"]["ownership"] = "{}:{}".format(user, group)
1012                 else:
1013                     ret["result"] = False
1014                     if salt.utils.platform.is_windows():
1015                         ret[
1016                             "comment"
1017                         ] += "Failed to set ownership of symlink {} to {}".format(
1018                             name, win_owner
1019                         )
1020                     else:
1021                         ret[
1022                             "comment"
1023                         ] += "Failed to set ownership of symlink {} to {}:{}".format(
1024                             name, user, group
1025                         )
1026             return ret
1027     elif os.path.exists(name):
1028         if backupname is not None:
1029             if not os.path.isabs(backupname):
1030                 if backupname == os.path.basename(backupname):
1031                     backupname = os.path.join(
1032                         os.path.dirname(os.path.normpath(name)), backupname
1033                     )
1034                 else:
1035                     return _error(
1036                         ret,
1037                         "Backupname must be an absolute path or a file name: {}".format(
1038                             backupname
1039                         ),
1040                     )
1041             if os.path.lexists(backupname):
1042                 if not force:
1043                     return _error(
1044                         ret,
1045                         "Symlink &amp; backup dest exists and Force not set. {} -&gt; {} -"
1046                         " backup: {}".format(name, target, backupname),
1047                     )
1048                 else:
1049                     __salt__["file.remove"](backupname)
1050             try:
1051                 __salt__["file.move"](name, backupname)
1052             except Exception as exc:  # pylint: disable=broad-except
1053                 ret["changes"] = {}
1054                 log.debug(
1055                     "Encountered error renaming %s to %s",
1056                     name,
1057                     backupname,
1058                     exc_info=True,
1059                 )
1060                 return _error(
1061                     ret,
1062                     "Unable to rename {} to backup {} -&gt; : {}".format(
1063                         name, backupname, exc
1064                     ),
1065                 )
1066         elif force:
1067             if __salt__["file.is_link"](name):
1068                 __salt__["file.remove"](name)
1069                 ret["changes"]["forced"] = "Symlink was forcibly replaced"
1070             else:
1071                 __salt__["file.remove"](name)
1072         else:
1073             fs_entry_type = (
1074                 "File"
1075                 if os.path.isfile(name)
1076                 else "Directory"
1077                 if os.path.isdir(name)
1078                 else "File system entry"
1079             )
1080             return _error(
1081                 ret,
1082                 "{} exists where the symlink {} should be".format(fs_entry_type, name),
1083             )
1084     if not os.path.exists(name):
1085         try:
1086             __salt__["file.symlink"](target, name)
1087         except OSError as exc:
1088             ret["result"] = False
1089             ret["comment"] = "Unable to create new symlink {} -&gt; {}: {}".format(
1090                 name, target, exc
1091             )
1092             return ret
1093         else:
1094             ret["comment"] = "Created new symlink {} -&gt; {}".format(name, target)
1095             ret["changes"]["new"] = name
1096         if not _check_symlink_ownership(name, user, group, win_owner):
1097             if not _set_symlink_ownership(name, user, group, win_owner):
1098                 ret["result"] = False
1099                 ret["comment"] += ", but was unable to set ownership to {}:{}".format(
1100                     user, group
1101                 )
1102     return ret
1103 def absent(name, **kwargs):
1104     name = os.path.expanduser(name)
1105     ret = {"name": name, "changes": {}, "result": True, "comment": ""}
1106     if not name:
1107         return _error(ret, "Must provide name to file.absent")
1108     if not os.path.isabs(name):
1109         return _error(ret, "Specified file {} is not an absolute path".format(name))
1110     if name == "/":
1111         return _error(ret, 'Refusing to make "/" absent')
1112     if os.path.isfile(name) or os.path.islink(name):
1113         if __opts__["test"]:
1114             ret["result"] = None
1115             ret["changes"]["removed"] = name
1116             ret["comment"] = "File {} is set for removal".format(name)
1117             return ret
1118         try:
1119             if salt.utils.platform.is_windows():
1120                 __salt__["file.remove"](name, force=True)
1121             else:
1122                 __salt__["file.remove"](name)
1123             ret["comment"] = "Removed file {}".format(name)
1124             ret["changes"]["removed"] = name
1125             return ret
1126         except CommandExecutionError as exc:
1127             return _error(ret, "{}".format(exc))
1128     elif os.path.isdir(name):
1129         if __opts__["test"]:
1130             ret["result"] = None
1131             ret["changes"]["removed"] = name
1132             ret["comment"] = "Directory {} is set for removal".format(name)
1133             return ret
1134         try:
1135             if salt.utils.platform.is_windows():
1136                 __salt__["file.remove"](name, force=True)
1137             else:
1138                 __salt__["file.remove"](name)
1139             ret["comment"] = "Removed directory {}".format(name)
1140             ret["changes"]["removed"] = name
1141             return ret
1142         except OSError:
1143             return _error(ret, "Failed to remove directory {}".format(name))
1144     ret["comment"] = "File {} is not present".format(name)
1145     return ret
1146 def tidied(name, age=0, matches=None, rmdirs=False, size=0, **kwargs):
1147     name = os.path.expanduser(name)
1148     ret = {"name": name, "changes": {}, "result": True, "comment": ""}
1149     if not os.path.isabs(name):
1150         return _error(ret, "Specified file {} is not an absolute path".format(name))
1151     if not os.path.isdir(name):
1152         return _error(ret, "{} does not exist or is not a directory.".format(name))
1153     todelete = []
1154     today = date.today()
1155     if matches is None:
1156         matches = [".*"]
1157     progs = []
1158     for regex in matches:
1159         progs.append(re.compile(regex))
1160     def _matches(name):
1161         for prog in progs:
1162             if prog.match(name):
1163                 return True
1164         return False
1165     for root, dirs, files in os.walk(top=name, topdown=False):
1166         for elem in files + dirs:
1167             myage = 0
1168             mysize = 0
1169             deleteme = True
1170             path = os.path.join(root, elem)
1171             if os.path.islink(path):
1172                 myage = abs(today - date.fromtimestamp(os.lstat(path).st_atime))
1173             elif elem in dirs:
1174                 myage = abs(today - date.fromtimestamp(os.path.getatime(path)))
1175                 deleteme = rmdirs
1176             else:
1177                 myage = abs(today - date.fromtimestamp(os.path.getatime(path)))
1178                 mysize = os.path.getsize(path)
1179             if (
1180                 (mysize &gt;= size or myage.days &gt;= age)
1181                 and _matches(name=elem)
1182                 and deleteme
1183             ):
1184                 todelete.append(path)
1185     if todelete:
1186         if __opts__["test"]:
1187             ret["result"] = None
1188             ret["comment"] = "{} is set for tidy".format(name)
1189             ret["changes"] = {"removed": todelete}
1190             return ret
1191         ret["changes"]["removed"] = []
1192         try:
1193             for path in todelete:
1194                 if salt.utils.platform.is_windows():
1195                     __salt__["file.remove"](path, force=True)
1196                 else:
1197                     __salt__["file.remove"](path)
1198                 ret["changes"]["removed"].append(path)
1199         except CommandExecutionError as exc:
1200             return _error(ret, "{}".format(exc))
1201         ret["comment"] = "Removed {} files or directories from directory {}".format(
1202             len(todelete), name
1203         )
1204     else:
1205         ret["comment"] = "Nothing to remove from directory {}".format(name)
1206     return ret
1207 def exists(name, **kwargs):
1208     name = os.path.expanduser(name)
1209     ret = {"name": name, "changes": {}, "result": True, "comment": ""}
1210     if not name:
1211         return _error(ret, "Must provide name to file.exists")
1212     if not os.path.exists(name):
1213         return _error(ret, "Specified path {} does not exist".format(name))
1214     ret["comment"] = "Path {} exists".format(name)
1215     return ret
1216 def missing(name, **kwargs):
1217     name = os.path.expanduser(name)
1218     ret = {"name": name, "changes": {}, "result": True, "comment": ""}
1219     if not name:
1220         return _error(ret, "Must provide name to file.missing")
1221     if os.path.exists(name):
1222         return _error(ret, "Specified path {} exists".format(name))
1223     ret["comment"] = "Path {} is missing".format(name)
1224     return ret
1225 def managed(
1226     name,
1227     source=None,
1228     source_hash="",
1229     source_hash_name=None,
1230     keep_source=True,
1231     user=None,
1232     group=None,
1233     mode=None,
1234     attrs=None,
1235     template=None,
1236     makedirs=False,
1237     dir_mode=None,
1238     context=None,
1239     replace=True,
1240     defaults=None,
1241     backup="",
1242     show_changes=True,
1243     create=True,
1244     contents=None,
1245     tmp_dir="",
1246     tmp_ext="",
1247     contents_pillar=None,
1248     contents_grains=None,
1249     contents_newline=True,
1250     contents_delimiter=":",
1251     encoding=None,
1252     encoding_errors="strict",
1253     allow_empty=True,
1254     follow_symlinks=True,
1255     check_cmd=None,
1256     skip_verify=False,
1257     selinux=None,
1258     win_owner=None,
1259     win_perms=None,
1260     win_deny_perms=None,
1261     win_inheritance=True,
1262     win_perms_reset=False,
1263     verify_ssl=True,
1264     use_etag=False,
1265     **kwargs
1266 ):
1267     r"""
1268     Manage a given file, this function allows for a file to be downloaded from
1269     the salt master and potentially run through a templating system.
1270     name
1271         The location of the file to manage, as an absolute path.
1272     source
1273         The source file to download to the minion, this source file can be
1274         hosted on either the salt master server (``salt://``), the salt minion
1275         local file system (``/``), or on an HTTP or FTP server (``http(s)://``,
1276         ``ftp://``).
1277         Both HTTPS and HTTP are supported as well as downloading directly
1278         from Amazon S3 compatible URLs with both pre-configured and automatic
1279         IAM credentials. (see s3.get state documentation)
1280         File retrieval from Openstack Swift object storage is supported via
1281         swift://container/object_path URLs, see swift.get documentation.
1282         For files hosted on the salt file server, if the file is located on
1283         the master in the directory named spam, and is called eggs, the source
1284         string is salt://spam/eggs. If source is left blank or None
1285         (use ~ in YAML), the file will be created as an empty file and
1286         the content will not be managed. This is also the case when a file
1287         already exists and the source is undefined; the contents of the file
1288         will not be changed or managed. If source is left blank or None, please
1289         also set replaced to False to make your intention explicit.
1290         If the file is hosted on a HTTP or FTP server then the source_hash
1291         argument is also required.
1292         A list of sources can also be passed in to provide a default source and
1293         a set of fallbacks. The first source in the list that is found to exist
1294         will be used and subsequent entries in the list will be ignored. Source
1295         list functionality only supports local files and remote files hosted on
1296         the salt master server or retrievable via HTTP, HTTPS, or FTP.
1297         .. code-block:: yaml
1298             file_override_example:
1299               file.managed:
1300                 - source:
1301                   - salt://file_that_does_not_exist
1302                   - salt://file_that_exists
1303     source_hash
1304         This can be one of the following:
1305             1. a source hash string
1306             2. the URI of a file that contains source hash strings
1307         The function accepts the first encountered long unbroken alphanumeric
1308         string of correct length as a valid hash, in order from most secure to
1309         least secure:
1310         .. code-block:: text
1311             Type    Length
1312             ======  ======
1313             sha512     128
1314             sha384      96
1315             sha256      64
1316             sha224      56
1317             sha1        40
1318             md5         32
1319         **Using a Source Hash File**
1320             The file can contain several checksums for several files. Each line
1321             must contain both the file name and the hash.  If no file name is
1322             matched, the first hash encountered will be used, otherwise the most
1323             secure hash with the correct source file name will be used.
1324             When using a source hash file the source_hash argument needs to be a
1325             url, the standard download urls are supported, ftp, http, salt etc:
1326             Example:
1327             .. code-block:: yaml
1328                 tomdroid-src-0.7.3.tar.gz:
1329                   file.managed:
1330                     - name: /tmp/tomdroid-src-0.7.3.tar.gz
1331                     - source: https://launchpad.net/tomdroid/beta/0.7.3/+download/tomdroid-src-0.7.3.tar.gz
1332                     - source_hash: https://launchpad.net/tomdroid/beta/0.7.3/+download/tomdroid-src-0.7.3.hash
1333             The following lines are all supported formats:
1334             .. code-block:: text
1335                 /etc/rc.conf ef6e82e4006dee563d98ada2a2a80a27
1336                 sha254c8525aee419eb649f0233be91c151178b30f0dff8ebbdcc8de71b1d5c8bcc06a  /etc/resolv.conf
1337                 ead48423703509d37c4a90e6a0d53e143b6fc268
1338             Debian file type ``*.dsc`` files are also supported.
1339         **Inserting the Source Hash in the SLS Data**
1340         The source_hash can be specified as a simple checksum, like so:
1341         .. code-block:: yaml
1342             tomdroid-src-0.7.3.tar.gz:
1343               file.managed:
1344                 - name: /tmp/tomdroid-src-0.7.3.tar.gz
1345                 - source: https://launchpad.net/tomdroid/beta/0.7.3/+download/tomdroid-src-0.7.3.tar.gz
1346                 - source_hash: 79eef25f9b0b2c642c62b7f737d4f53f
1347         .. note::
1348             Releases prior to 2016.11.0 must also include the hash type, like
1349             in the below example:
1350             .. code-block:: yaml
1351                 tomdroid-src-0.7.3.tar.gz:
1352                   file.managed:
1353                     - name: /tmp/tomdroid-src-0.7.3.tar.gz
1354                     - source: https://launchpad.net/tomdroid/beta/0.7.3/+download/tomdroid-src-0.7.3.tar.gz
1355                     - source_hash: md5=79eef25f9b0b2c642c62b7f737d4f53f
1356         Known issues:
1357             If the remote server URL has the hash file as an apparent
1358             sub-directory of the source file, the module will discover that it
1359             has already cached a directory where a file should be cached. For
1360             example:
1361             .. code-block:: yaml
1362                 tomdroid-src-0.7.3.tar.gz:
1363                   file.managed:
1364                     - name: /tmp/tomdroid-src-0.7.3.tar.gz
1365                     - source: https://launchpad.net/tomdroid/beta/0.7.3/+download/tomdroid-src-0.7.3.tar.gz
1366                     - source_hash: https://launchpad.net/tomdroid/beta/0.7.3/+download/tomdroid-src-0.7.3.tar.gz/+md5
1367     source_hash_name
1368         When ``source_hash`` refers to a hash file, Salt will try to find the
1369         correct hash by matching the filename/URI associated with that hash. By
1370         default, Salt will look for the filename being managed. When managing a
1371         file at path ``/tmp/foo.txt``, then the following line in a hash file
1372         would match:
1373         .. code-block:: text
1374             acbd18db4cc2f85cedef654fccc4a4d8    foo.txt
1375         However, sometimes a hash file will include multiple similar paths:
1376         .. code-block:: text
1377             37b51d194a7513e45b56f6524f2d51f2    ./dir1/foo.txt
1378             acbd18db4cc2f85cedef654fccc4a4d8    ./dir2/foo.txt
1379             73feffa4b7f6bb68e44cf984c85f6e88    ./dir3/foo.txt
1380         In cases like this, Salt may match the incorrect hash. This argument
1381         can be used to tell Salt which filename to match, to ensure that the
1382         correct hash is identified. For example:
1383         .. code-block:: yaml
1384             /tmp/foo.txt:
1385               file.managed:
1386                 - source: https://mydomain.tld/dir2/foo.txt
1387                 - source_hash: https://mydomain.tld/hashes
1388                 - source_hash_name: ./dir2/foo.txt
1389         .. note::
1390             This argument must contain the full filename entry from the
1391             checksum file, as this argument is meant to disambiguate matches
1392             for multiple files that have the same basename. So, in the
1393             example above, simply using ``foo.txt`` would not match.
1394         .. versionadded:: 2016.3.5
1395     keep_source
1396         Set to ``False`` to discard the cached copy of the source file once the
1397         state completes. This can be useful for larger files to keep them from
1398         taking up space in minion cache. However, keep in mind that discarding
1399         the source file will result in the state needing to re-download the
1400         source file if the state is run again.
1401         .. versionadded:: 2017.7.3
1402     user
1403         The user to own the file, this defaults to the user salt is running as
1404         on the minion
1405     group
1406         The group ownership set for the file, this defaults to the group salt
1407         is running as on the minion. On Windows, this is ignored
1408     mode
1409         The permissions to set on this file, e.g. ``644``, ``0775``, or
1410         ``4664``.
1411         The default mode for new files and directories corresponds to the
1412         umask of the salt process. The mode of existing files and directories
1413         will only be changed if ``mode`` is specified.
1414         .. note::
1415             This option is **not** supported on Windows.
1416         .. versionchanged:: 2016.11.0
1417             This option can be set to ``keep``, and Salt will keep the mode
1418             from the Salt fileserver. This is only supported when the
1419             ``source`` URL begins with ``salt://``, or for files local to the
1420             minion. Because the ``source`` option cannot be used with any of
1421             the ``contents`` options, setting the ``mode`` to ``keep`` is also
1422             incompatible with the ``contents`` options.
1423         .. note:: keep does not work with salt-ssh.
1424             As a consequence of how the files are transferred to the minion, and
1425             the inability to connect back to the master with salt-ssh, salt is
1426             unable to stat the file as it exists on the fileserver and thus
1427             cannot mirror the mode on the salt-ssh minion
1428     attrs
1429         The attributes to have on this file, e.g. ``a``, ``i``. The attributes
1430         can be any or a combination of the following characters:
1431         ``aAcCdDeijPsStTu``.
1432         .. note::
1433             This option is **not** supported on Windows.
1434         .. versionadded:: 2018.3.0
1435     template
1436         If this setting is applied, the named templating engine will be used to
1437         render the downloaded file. The following templates are supported:
1438         - :mod:`cheetah&lt;salt.renderers.cheetah&gt;`
1439         - :mod:`genshi&lt;salt.renderers.genshi&gt;`
1440         - :mod:`jinja&lt;salt.renderers.jinja&gt;`
1441         - :mod:`mako&lt;salt.renderers.mako&gt;`
1442         - :mod:`py&lt;salt.renderers.py&gt;`
1443         - :mod:`wempy&lt;salt.renderers.wempy&gt;`
1444     makedirs
1445         If set to ``True``, then the parent directories will be created to
1446         facilitate the creation of the named file. If ``False``, and the parent
1447         directory of the destination file doesn't exist, the state will fail.
1448     dir_mode
1449         If directories are to be created, passing this option specifies the
1450         permissions for those directories. If this is not set, directories
1451         will be assigned permissions by adding the execute bit to the mode of
1452         the files.
1453         The default mode for new files and directories corresponds umask of salt
1454         process. For existing files and directories it's not enforced.
1455     replace
1456         If set to ``False`` and the file already exists, the file will not be
1457         modified even if changes would otherwise be made. Permissions and
1458         ownership will still be enforced, however.
1459     context
1460         Overrides default context variables passed to the template.
1461     defaults
1462         Default context passed to the template.
1463     backup
1464         Overrides the default backup mode for this specific file. See
1465         :ref:`backup_mode documentation &lt;file-state-backups&gt;` for more details.
1466     show_changes
1467         Output a unified diff of the old file and the new file. If ``False``
1468         return a boolean if any changes were made.
1469     create
1470         If set to ``False``, then the file will only be managed if the file
1471         already exists on the system.
1472     contents
1473         Specify the contents of the file. Cannot be used in combination with
1474         ``source``. Ignores hashes and does not use a templating engine.
1475         This value can be either a single string, a multiline YAML string or a
1476         list of strings.  If a list of strings, then the strings will be joined
1477         together with newlines in the resulting file. For example, the below
1478         two example states would result in identical file contents:
1479         .. code-block:: yaml
1480             /path/to/file1:
1481               file.managed:
1482                 - contents:
1483                   - This is line 1
1484                   - This is line 2
1485             /path/to/file2:
1486               file.managed:
1487                 - contents: |
1488                     This is line 1
1489                     This is line 2
1490     contents_pillar
1491         .. versionadded:: 0.17.0
1492         .. versionchanged:: 2016.11.0
1493             contents_pillar can also be a list, and the pillars will be
1494             concatenated together to form one file.
1495         Operates like ``contents``, but draws from a value stored in pillar,
1496         using the pillar path syntax used in :mod:`pillar.get
1497         &lt;salt.modules.pillar.get&gt;`. This is useful when the pillar value
1498         contains newlines, as referencing a pillar variable using a jinja/mako
1499         template can result in YAML formatting issues due to the newlines
1500         causing indentation mismatches.
1501         For example, the following could be used to deploy an SSH private key:
1502         .. code-block:: yaml
1503             /home/deployer/.ssh/id_rsa:
1504               file.managed:
1505                 - user: deployer
1506                 - group: deployer
1507                 - mode: 600
1508                 - attrs: a
1509                 - contents_pillar: userdata:deployer:id_rsa
1510         This would populate ``/home/deployer/.ssh/id_rsa`` with the contents of
1511         ``pillar['userdata']['deployer']['id_rsa']``. An example of this pillar
1512         setup would be like so:
1513         .. code-block:: yaml
1514             userdata:
1515               deployer:
1516                 id_rsa: |
1517                     -----BEGIN RSA PRIVATE KEY-----
1518                     MIIEowIBAAKCAQEAoQiwO3JhBquPAalQF9qP1lLZNXVjYMIswrMe2HcWUVBgh+vY
1519                     U7sCwx/dH6+VvNwmCoqmNnP+8gTPKGl1vgAObJAnMT623dMXjVKwnEagZPRJIxDy
1520                     B/HaAre9euNiY3LvIzBTWRSeMfT+rWvIKVBpvwlgGrfgz70m0pqxu+UyFbAGLin+
1521                     GpxzZAMaFpZw4sSbIlRuissXZj/sHpQb8p9M5IeO4Z3rjkCP1cxI
1522                     -----END RSA PRIVATE KEY-----
1523         .. note::
1524             The private key above is shortened to keep the example brief, but
1525             shows how to do multiline string in YAML. The key is followed by a
1526             pipe character, and the multiline string is indented two more
1527             spaces.
1528             To avoid the hassle of creating an indented multiline YAML string,
1529             the :mod:`file_tree external pillar &lt;salt.pillar.file_tree&gt;` can
1530             be used instead. However, this will not work for binary files in
1531             Salt releases before 2015.8.4.
1532     contents_grains
1533         .. versionadded:: 2014.7.0
1534         Operates like ``contents``, but draws from a value stored in grains,
1535         using the grains path syntax used in :mod:`grains.get
1536         &lt;salt.modules.grains.get&gt;`. This functionality works similarly to
1537         ``contents_pillar``, but with grains.
1538         For example, the following could be used to deploy a "message of the day"
1539         file:
1540         .. code-block:: yaml
1541             write_motd:
1542               file.managed:
1543                 - name: /etc/motd
1544                 - contents_grains: motd
1545         This would populate ``/etc/motd`` file with the contents of the ``motd``
1546         grain. The ``motd`` grain is not a default grain, and would need to be
1547         set prior to running the state:
1548         .. code-block:: bash
1549             salt '*' grains.set motd 'Welcome! This system is managed by Salt.'
1550     contents_newline
1551         .. versionadded:: 2014.7.0
1552         .. versionchanged:: 2015.8.4
1553             This option is now ignored if the contents being deployed contain
1554             binary data.
1555         If ``True``, files managed using ``contents``, ``contents_pillar``, or
1556         ``contents_grains`` will have a newline added to the end of the file if
1557         one is not present. Setting this option to ``False`` will ensure the
1558         final line, or entry, does not contain a new line. If the last line, or
1559         entry in the file does contain a new line already, this option will not
1560         remove it.
1561     contents_delimiter
1562         .. versionadded:: 2015.8.4
1563         Can be used to specify an alternate delimiter for ``contents_pillar``
1564         or ``contents_grains``. This delimiter will be passed through to
1565         :py:func:`pillar.get &lt;salt.modules.pillar.get&gt;` or :py:func:`grains.get
1566         &lt;salt.modules.grains.get&gt;` when retrieving the contents.
1567     encoding
1568         If specified, then the specified encoding will be used. Otherwise, the
1569         file will be encoded using the system locale (usually UTF-8). See
1570         https://docs.python.org/3/library/codecs.html#standard-encodings for
1571         the list of available encodings.
1572         .. versionadded:: 2017.7.0
1573     encoding_errors
1574         Error encoding scheme. Default is ```'strict'```.
1575         See https://docs.python.org/2/library/codecs.html#codec-base-classes
1576         for the list of available schemes.
1577         .. versionadded:: 2017.7.0
1578     allow_empty
1579         .. versionadded:: 2015.8.4
1580         If set to ``False``, then the state will fail if the contents specified
1581         by ``contents_pillar`` or ``contents_grains`` are empty.
1582     follow_symlinks
1583         .. versionadded:: 2014.7.0
1584         If the desired path is a symlink follow it and make changes to the
1585         file to which the symlink points.
1586     check_cmd
1587         .. versionadded:: 2014.7.0
1588         The specified command will be run with an appended argument of a
1589         *temporary* file containing the new managed contents.  If the command
1590         exits with a zero status the new managed contents will be written to
1591         the managed destination. If the command exits with a nonzero exit
1592         code, the state will fail and no changes will be made to the file.
1593         For example, the following could be used to verify sudoers before making
1594         changes:
1595         .. code-block:: yaml
1596             /etc/sudoers:
1597               file.managed:
1598                 - user: root
1599                 - group: root
1600                 - mode: 0440
1601                 - attrs: i
1602                 - source: salt://sudoers/files/sudoers.jinja
1603                 - template: jinja
1604                 - check_cmd: /usr/sbin/visudo -c -f
1605         **NOTE**: This ``check_cmd`` functions differently than the requisite
1606         ``check_cmd``.
1607     tmp_dir
1608         Directory for temp file created by ``check_cmd``. Useful for checkers
1609         dependent on config file location (e.g. daemons restricted to their
1610         own config directories by an apparmor profile).
1611         .. code-block:: yaml
1612             /etc/dhcp/dhcpd.conf:
1613               file.managed:
1614                 - user: root
1615                 - group: root
1616                 - mode: 0755
1617                 - tmp_dir: '/etc/dhcp'
1618                 - contents: "# Managed by Salt"
1619                 - check_cmd: dhcpd -t -cf
1620     tmp_ext
1621         Suffix for temp file created by ``check_cmd``. Useful for checkers
1622         dependent on config file extension (e.g. the init-checkconf upstart
1623         config checker).
1624         .. code-block:: yaml
1625             /etc/init/test.conf:
1626               file.managed:
1627                 - user: root
1628                 - group: root
1629                 - mode: 0440
1630                 - tmp_ext: '.conf'
1631                 - contents:
1632                   - 'description "Salt Minion"'
1633                   - 'start on started mountall'
1634                   - 'stop on shutdown'
1635                   - 'respawn'
1636                   - 'exec salt-minion'
1637                 - check_cmd: init-checkconf -f
1638     skip_verify
1639         If ``True``, hash verification of remote file sources (``http://``,
1640         ``https://``, ``ftp://``) will be skipped, and the ``source_hash``
1641         argument will be ignored.
1642         .. versionadded:: 2016.3.0
1643     selinux
1644         Allows setting the selinux user, role, type, and range of a managed file
1645         .. code-block:: yaml
1646             /tmp/selinux.test
1647               file.managed:
1648                 - user: root
1649                 - selinux:
1650                     seuser: system_u
1651                     serole: object_r
1652                     setype: system_conf_t
1653                     seranage: s0
1654         .. versionadded:: 3000
1655     win_owner
1656         The owner of the directory. If this is not passed, user will be used. If
1657         user is not passed, the account under which Salt is running will be
1658         used.
1659         .. versionadded:: 2017.7.0
1660     win_perms
1661         A dictionary containing permissions to grant and their propagation. For
1662         example: ``{'Administrators': {'perms': 'full_control'}}`` Can be a
1663         single basic perm or a list of advanced perms. ``perms`` must be
1664         specified. ``applies_to`` does not apply to file objects.
1665         .. versionadded:: 2017.7.0
1666     win_deny_perms
1667         A dictionary containing permissions to deny and their propagation. For
1668         example: ``{'Administrators': {'perms': 'full_control'}}`` Can be a
1669         single basic perm or a list of advanced perms. ``perms`` must be
1670         specified. ``applies_to`` does not apply to file objects.
1671         .. versionadded:: 2017.7.0
1672     win_inheritance
1673         True to inherit permissions from the parent directory, False not to
1674         inherit permission.
1675         .. versionadded:: 2017.7.0
1676     win_perms_reset
1677         If ``True`` the existing DACL will be cleared and replaced with the
1678         settings defined in this function. If ``False``, new entries will be
1679         appended to the existing DACL. Default is ``False``.
1680         .. versionadded:: 2018.3.0
1681     Here's an example using the above ``win_*`` parameters:
1682     .. code-block:: yaml
1683         create_config_file:
1684           file.managed:
1685             - name: C:\config\settings.cfg
1686             - source: salt://settings.cfg
1687             - win_owner: Administrators
1688             - win_perms:
1689                 dev_ops:
1690                   perms: full_control
1691                 appuser:
1692                   perms:
1693                     - read_attributes
1694                     - read_ea
1695                     - create_folders
1696                     - read_permissions
1697                 joe_snuffy:
1698                   perms: read
1699             - win_deny_perms:
1700                 fred_snuffy:
1701                   perms: full_control
1702             - win_inheritance: False
1703     verify_ssl
1704         If ``False``, remote https file sources (``https://``) and source_hash
1705         will not attempt to validate the servers certificate. Default is True.
1706         .. versionadded:: 3002
1707     use_etag
1708         If ``True``, remote http/https file sources will attempt to use the
1709         ETag header to determine if the remote file needs to be downloaded.
1710         This provides a lightweight mechanism for promptly refreshing files
1711         changed on a web server without requiring a full hash comparison via
1712         the ``source_hash`` parameter.
1713         .. versionadded:: 3005
1714     Converse *recurse* definition to a set of strings.
1715     Raises TypeError or ValueError when *recurse* has wrong structure.
1716     Walk the directory tree under root up till reaching max_depth.
1717     With max_depth=None (default), do not limit depth.
1718     name = os.path.expanduser(name)
1719     ret = {"name": name, "changes": {}, "result": True, "comment": ""}
1720     if not name:
1721         return _error(ret, "Must provide name to file.directory")
1722     if name[-1] == "/" and name != "/":
1723         name = name[:-1]
1724     if max_depth is not None and clean:
1725         return _error(ret, "Cannot specify both max_depth and clean")
1726     user = _test_owner(kwargs, user=user)
1727     if salt.utils.platform.is_windows():
1728         if win_owner is None:
1729             win_owner = user if user else salt.utils.win_functions.get_current_user()
1730         if group is not None:
1731             log.warning(
1732                 "The group argument for %s has been ignored as this is "
1733                 "a Windows system. Please use the `win_*` parameters to set "
1734                 "permissions in Windows.",
1735                 name,
1736             )
1737         group = user
1738     if "mode" in kwargs and not dir_mode:
1739         dir_mode = kwargs.get("mode", [])
1740     if not file_mode:
1741         file_mode = dir_mode
1742     dir_mode = salt.utils.files.normalize_mode(dir_mode)
1743     file_mode = salt.utils.files.normalize_mode(file_mode)
1744     if salt.utils.platform.is_windows():
1745         try:
1746             salt.utils.win_dacl.get_sid(win_owner)
1747         except CommandExecutionError as exc:
1748             return _error(ret, exc)
1749     else:
1750         u_check = _check_user(user, group)
1751         if u_check:
1752             return _error(ret, u_check)
1753     if not os.path.isabs(name):
1754         return _error(ret, "Specified file {} is not an absolute path".format(name))
1755     if (
1756         os.path.isfile(name)
1757         or (not allow_symlink and os.path.islink(name))
1758         or (force and os.path.islink(name))
1759     ):
1760         if backupname is not None:
1761             if os.path.lexists(backupname):
1762                 if not force:
1763                     return _error(
1764                         ret,
1765                         "File exists where the backup target {} should go".format(
1766                             backupname
1767                         ),
1768                     )
1769                 else:
1770                     __salt__["file.remove"](backupname)
1771             os.rename(name, backupname)
1772         elif force:
1773             if os.path.isfile(name):
1774                 if __opts__["test"]:
1775                     ret["changes"]["forced"] = "File would be forcibly replaced"
1776                 else:
1777                     os.remove(name)
1778                     ret["changes"]["forced"] = "File was forcibly replaced"
1779             elif __salt__["file.is_link"](name):
1780                 if __opts__["test"]:
1781                     ret["changes"]["forced"] = "Symlink would be forcibly replaced"
1782                 else:
1783                     __salt__["file.remove"](name)
1784                     ret["changes"]["forced"] = "Symlink was forcibly replaced"
1785             else:
1786                 if __opts__["test"]:
1787                     ret["changes"]["forced"] = "Directory would be forcibly replaced"
1788                 else:
1789                     __salt__["file.remove"](name)
1790                     ret["changes"]["forced"] = "Directory was forcibly replaced"
1791         else:
1792             if os.path.isfile(name):
1793                 return _error(
1794                     ret, "Specified location {} exists and is a file".format(name)
1795                 )
1796             elif os.path.islink(name):
1797                 return _error(
1798                     ret, "Specified location {} exists and is a symlink".format(name)
1799                 )
1800     if salt.utils.platform.is_windows():
1801         tresult, tcomment, tchanges = _check_directory_win(
1802             name=name,
1803             win_owner=win_owner,
1804             win_perms=win_perms,
1805             win_deny_perms=win_deny_perms,
1806             win_inheritance=win_inheritance,
1807             win_perms_reset=win_perms_reset,
1808         )
1809     else:
1810         tresult, tcomment, tchanges = _check_directory(
1811             name,
1812             user,
1813             group,
1814             recurse or [],
1815             dir_mode,
1816             file_mode,
1817             clean,
1818             require,
1819             exclude_pat,
1820             max_depth,
1821             follow_symlinks,
1822         )
1823     if tchanges:
1824         ret["changes"].update(tchanges)
1825     if __opts__["test"] or not ret["changes"]:
1826         ret["result"] = tresult
1827         ret["comment"] = tcomment
1828         return ret
1829     if not os.path.isdir(name):
1830         if not os.path.isdir(os.path.dirname(name)):
1831             if makedirs:
1832                 try:
1833                     _makedirs(
1834                         name=name,
1835                         user=user,
1836                         group=group,
1837                         dir_mode=dir_mode,
1838                         win_owner=win_owner,
1839                         win_perms=win_perms,
1840                         win_deny_perms=win_deny_perms,
1841                         win_inheritance=win_inheritance,
1842                     )
1843                 except CommandExecutionError as exc:
1844                     return _error(ret, "Drive {} is not mapped".format(exc.message))
1845             else:
1846                 return _error(ret, "No directory to create {} in".format(name))
1847         if salt.utils.platform.is_windows():
1848             __salt__["file.mkdir"](
1849                 path=name,
1850                 owner=win_owner,
1851                 grant_perms=win_perms,
1852                 deny_perms=win_deny_perms,
1853                 inheritance=win_inheritance,
1854                 reset=win_perms_reset,
1855             )
1856         else:
1857             __salt__["file.mkdir"](name, user=user, group=group, mode=dir_mode)
1858         if not os.path.isdir(name):
1859             return _error(ret, "Failed to create directory {}".format(name))
1860         ret["changes"][name] = {"directory": "new"}
1861         return ret
1862     if not children_only:
1863         if salt.utils.platform.is_windows():
1864             ret = __salt__["file.check_perms"](
1865                 path=name,
1866                 ret=ret,
1867                 owner=win_owner,
1868                 grant_perms=win_perms,
1869                 deny_perms=win_deny_perms,
1870                 inheritance=win_inheritance,
1871                 reset=win_perms_reset,
1872             )
1873         else:
1874             ret, perms = __salt__["file.check_perms"](
1875                 name, ret, user, group, dir_mode, None, follow_symlinks
1876             )
1877     errors = []
1878     if recurse or clean:
1879         walk_l = list(_depth_limited_walk(name, max_depth))
1880         walk_d = {}
1881         for i in walk_l:
1882             walk_d[i[0]] = (i[1], i[2])
1883     recurse_set = None
1884     if recurse:
1885         try:
1886             recurse_set = _get_recurse_set(recurse)
1887         except (TypeError, ValueError) as exc:
1888             ret["result"] = False
1889             ret["comment"] = "{}".format(exc)
1890     if recurse_set:
1891         if "user" in recurse_set:
1892             if user or isinstance(user, int):
1893                 uid = __salt__["file.user_to_uid"](user)
1894                 if isinstance(uid, str):
1895                     ret["result"] = False
1896                     ret["comment"] = (
1897                         "Failed to enforce ownership for "
1898                         "user {} (user does not "
1899                         "exist)".format(user)
1900                     )
1901             else:
1902                 ret["result"] = False
1903                 ret["comment"] = (
1904                     "user not specified, but configured as "
1905                     "a target for recursive ownership "
1906                     "management"
1907                 )
1908         else:
1909             user = None
1910         if "group" in recurse_set:
1911             if group or isinstance(group, int):
1912                 gid = __salt__["file.group_to_gid"](group)
1913                 if isinstance(gid, str):
1914                     ret["result"] = False
1915                     ret[
1916                         "comment"
1917                     ] = "Failed to enforce group ownership for group {}".format(group)
1918             else:
1919                 ret["result"] = False
1920                 ret["comment"] = (
1921                     "group not specified, but configured "
1922                     "as a target for recursive ownership "
1923                     "management"
1924                 )
1925         else:
1926             group = None
1927         if "mode" not in recurse_set:
1928             file_mode = None
1929             dir_mode = None
1930         if "silent" in recurse_set:
1931             ret["changes"] = {"recursion": "Changes silenced"}
1932         check_files = "ignore_files" not in recurse_set
1933         check_dirs = "ignore_dirs" not in recurse_set
1934         for root, dirs, files in walk_l:
1935             if check_files:
1936                 for fn_ in files:
1937                     full = os.path.join(root, fn_)
1938                     try:
1939                         if salt.utils.platform.is_windows():
1940                             ret = __salt__["file.check_perms"](
1941                                 path=full,
1942                                 ret=ret,
1943                                 owner=win_owner,
1944                                 grant_perms=win_perms,
1945                                 deny_perms=win_deny_perms,
1946                                 inheritance=win_inheritance,
1947                                 reset=win_perms_reset,
1948                             )
1949                         else:
1950                             ret, _ = __salt__["file.check_perms"](
1951                                 full, ret, user, group, file_mode, None, follow_symlinks
1952                             )
1953                     except CommandExecutionError as exc:
1954                         if not exc.strerror.startswith("Path not found"):
1955                             errors.append(exc.strerror)
1956             if check_dirs:
1957                 for dir_ in dirs:
1958                     full = os.path.join(root, dir_)
1959                     try:
1960                         if salt.utils.platform.is_windows():
1961                             ret = __salt__["file.check_perms"](
1962                                 path=full,
1963                                 ret=ret,
1964                                 owner=win_owner,
1965                                 grant_perms=win_perms,
1966                                 deny_perms=win_deny_perms,
1967                                 inheritance=win_inheritance,
1968                                 reset=win_perms_reset,
1969                             )
1970                         else:
1971                             ret, _ = __salt__["file.check_perms"](
1972                                 full, ret, user, group, dir_mode, None, follow_symlinks
1973                             )
1974                     except CommandExecutionError as exc:
1975                         if not exc.strerror.startswith("Path not found"):
1976                             errors.append(exc.strerror)
1977     if clean:
1978         keep = _gen_keep_files(name, require, walk_d)
1979         log.debug("List of kept files when use file.directory with clean: %s", keep)
1980         removed = _clean_dir(name, list(keep), exclude_pat)
1981         if removed:
1982             ret["changes"]["removed"] = removed
1983             ret["comment"] = "Files cleaned from directory {}".format(name)
1984     if not ret["comment"]:
1985         if children_only:
1986             ret["comment"] = "Directory {}/* updated".format(name)
1987         else:
1988             if ret["changes"]:
1989                 ret["comment"] = "Directory {} updated".format(name)
1990     if __opts__["test"]:
1991         ret["comment"] = "Directory {} not updated".format(name)
1992     elif not ret["changes"] and ret["result"]:
1993         orig_comment = None
1994         if ret["comment"]:
1995             orig_comment = ret["comment"]
1996         ret["comment"] = "Directory {} is in the correct state".format(name)
1997         if orig_comment:
1998             ret["comment"] = "\n".join([ret["comment"], orig_comment])
1999     if errors:
2000         ret["result"] = False
2001         ret["comment"] += "\n\nThe following errors were encountered:\n"
2002         for error in errors:
2003             ret["comment"] += "\n- {}".format(error)
2004     return ret
2005 def recurse(
2006     name,
2007     source,
2008     keep_source=True,
2009     clean=False,
2010     require=None,
2011     user=None,
2012     group=None,
2013     dir_mode=None,
2014     file_mode=None,
2015     sym_mode=None,
2016     template=None,
2017     context=None,
2018     replace=True,
2019     defaults=None,
2020     include_empty=False,
2021     backup="",
2022     include_pat=None,
2023     exclude_pat=None,
2024     maxdepth=None,
2025     keep_symlinks=False,
2026     force_symlinks=False,
2027     win_owner=None,
2028     win_perms=None,
2029     win_deny_perms=None,
2030     win_inheritance=True,
2031     **kwargs
2032 ):
2033     if "env" in kwargs:
2034         kwargs.pop("env")
2035     name = os.path.expanduser(salt.utils.data.decode(name))
2036     user = _test_owner(kwargs, user=user)
2037     if salt.utils.platform.is_windows():
2038         if group is not None:
2039             log.warning(
2040                 "The group argument for %s has been ignored as this "
2041                 "is a Windows system.",
2042                 name,
2043             )
2044         group = user
2045     ret = {
2046         "name": name,
2047         "changes": {},
2048         "result": True,
2049         "comment": {},  # { path: [comment, ...] }
2050     }
2051     if "mode" in kwargs:
2052         ret["result"] = False
2053         ret["comment"] = (
2054             "'mode' is not allowed in 'file.recurse'. Please use "
2055             "'file_mode' and 'dir_mode'."
2056         )
2057         return ret
2058     if (
2059         any([x is not None for x in (dir_mode, file_mode, sym_mode)])
2060         and salt.utils.platform.is_windows()
2061     ):
2062         return _error(ret, "mode management is not supported on Windows")
2063     dir_mode = salt.utils.files.normalize_mode(dir_mode)
2064     try:
2065         keep_mode = file_mode.lower() == "keep"
2066         if keep_mode:
2067             file_mode = None
2068     except AttributeError:
2069         keep_mode = False
2070     file_mode = salt.utils.files.normalize_mode(file_mode)
2071     u_check = _check_user(user, group)
2072     if u_check:
2073         return _error(ret, u_check)
2074     if not os.path.isabs(name):
2075         return _error(ret, "Specified file {} is not an absolute path".format(name))
2076     source_list = _validate_str_list(source)
2077     for idx, val in enumerate(source_list):
2078         source_list[idx] = val.rstrip("/")
2079     for precheck in source_list:
2080         if not precheck.startswith("salt://"):
2081             return _error(
2082                 ret,
2083                 "Invalid source '{}' (must be a salt:// URI)".format(precheck),
2084             )
2085     try:
2086         source, source_hash = __salt__["file.source_list"](source_list, "", __env__)
2087     except CommandExecutionError as exc:
2088         ret["result"] = False
2089         ret["comment"] = "Recurse failed: {}".format(exc)
2090         return ret
2091     srcpath, senv = salt.utils.url.parse(source)
2092     if senv is None:
2093         senv = __env__
2094     master_dirs = __salt__["cp.list_master_dirs"](saltenv=senv)
2095     if srcpath not in master_dirs and not any(
2096         x for x in master_dirs if x.startswith(srcpath + "/")
2097     ):
2098         ret["result"] = False
2099         ret["comment"] = (
2100             "The directory '{}' does not exist on the salt fileserver "
2101             "in saltenv '{}'".format(srcpath, senv)
2102         )
2103         return ret
2104     if not os.path.isdir(name):
2105         if os.path.exists(name):
2106             return _error(ret, "The path {} exists and is not a directory".format(name))
2107         if not __opts__["test"]:
2108             if salt.utils.platform.is_windows():
2109                 win_owner = win_owner if win_owner else user
2110                 __salt__["file.makedirs_perms"](
2111                     path=name,
2112                     owner=win_owner,
2113                     grant_perms=win_perms,
2114                     deny_perms=win_deny_perms,
2115                     inheritance=win_inheritance,
2116                 )
2117             else:
2118                 __salt__["file.makedirs_perms"](
2119                     name=name, user=user, group=group, mode=dir_mode
2120                 )
2121     def add_comment(path, comment):
2122         comments = ret["comment"].setdefault(path, [])
2123         if isinstance(comment, str):
2124             comments.append(comment)
2125         else:
2126             comments.extend(comment)
2127     def merge_ret(path, _ret):
2128         if _ret["result"] is False or ret["result"] is True:
2129             ret["result"] = _ret["result"]
2130         if _ret["result"] is not True and _ret["comment"]:
2131             add_comment(path, _ret["comment"])
2132         if _ret["changes"]:
2133             ret["changes"][path] = _ret["changes"]
2134     def manage_file(path, source, replace):
2135         if clean and os.path.exists(path) and os.path.isdir(path) and replace:
2136             _ret = {"name": name, "changes": {}, "result": True, "comment": ""}
2137             if __opts__["test"]:
2138                 _ret["comment"] = "Replacing directory {} with a file".format(path)
2139                 _ret["result"] = None
2140                 merge_ret(path, _ret)
2141                 return
2142             else:
2143                 __salt__["file.remove"](path)
2144                 _ret["changes"] = {"diff": "Replaced directory with a new file"}
2145                 merge_ret(path, _ret)
2146         pass_kwargs = {}
2147         faults = ["mode", "makedirs"]
2148         for key in kwargs:
2149             if key not in faults:
2150                 pass_kwargs[key] = kwargs[key]
2151         _ret = managed(
2152             path,
2153             source=source,
2154             keep_source=keep_source,
2155             user=user,
2156             group=group,
2157             mode="keep" if keep_mode else file_mode,
2158             attrs=None,
2159             template=template,
2160             makedirs=True,
2161             replace=replace,
2162             context=context,
2163             defaults=defaults,
2164             backup=backup,
2165             **pass_kwargs
2166         )
2167         merge_ret(path, _ret)
2168     def manage_directory(path):
2169         if os.path.basename(path) == "..":
2170             return
2171         if clean and os.path.exists(path) and not os.path.isdir(path):
2172             _ret = {"name": name, "changes": {}, "result": True, "comment": ""}
2173             if __opts__["test"]:
2174                 _ret["comment"] = "Replacing {} with a directory".format(path)
2175                 _ret["result"] = None
2176                 merge_ret(path, _ret)
2177                 return
2178             else:
2179                 __salt__["file.remove"](path)
2180                 _ret["changes"] = {"diff": "Replaced file with a directory"}
2181                 merge_ret(path, _ret)
2182         _ret = directory(
2183             path,
2184             user=user,
2185             group=group,
2186             recurse=[],
2187             dir_mode=dir_mode,
2188             file_mode=None,
2189             makedirs=True,
2190             clean=False,
2191             require=None,
2192         )
2193         merge_ret(path, _ret)
2194     mng_files, mng_dirs, mng_symlinks, keep = _gen_recurse_managed_files(
2195         name, source, keep_symlinks, include_pat, exclude_pat, maxdepth, include_empty
2196     )
2197     for srelpath, ltarget in mng_symlinks:
2198         _ret = symlink(
2199             os.path.join(name, srelpath),
2200             ltarget,
2201             makedirs=True,
2202             force=force_symlinks,
2203             user=user,
2204             group=group,
2205             mode=sym_mode,
2206         )
2207         if not _ret:
2208             continue
2209         merge_ret(os.path.join(name, srelpath), _ret)
2210     for dirname in mng_dirs:
2211         manage_directory(dirname)
2212     for dest, src in mng_files:
2213         manage_file(dest, src, replace)
2214     if clean:
2215         keep.update(_gen_keep_files(name, require))
2216         removed = _clean_dir(name, list(keep), exclude_pat)
2217         if removed:
2218             if __opts__["test"]:
2219                 if ret["result"]:
2220                     ret["result"] = None
2221                 add_comment("removed", removed)
2222             else:
2223                 ret["changes"]["removed"] = removed
2224     ret["comment"] = "\n".join(
2225         "\n#### {} ####\n{}".format(k, v if isinstance(v, str) else "\n".join(v))
2226         for (k, v) in ret["comment"].items()
2227     ).strip()
2228     if not ret["comment"]:
2229         ret["comment"] = "Recursively updated {}".format(name)
2230     if not ret["changes"] and ret["result"]:
2231         ret["comment"] = "The directory {} is in the correct state".format(name)
2232     return ret
2233 def retention_schedule(name, retain, strptime_format=None, timezone=None):
2234     name = os.path.expanduser(name)
2235     ret = {
2236         "name": name,
2237         "changes": {"retained": [], "deleted": [], "ignored": []},
2238         "result": True,
2239         "comment": "",
2240     }
2241     if not name:
2242         return _error(ret, "Must provide name to file.retention_schedule")
2243     if not os.path.isdir(name):
2244         return _error(ret, "Name provided to file.retention must be a directory")
2245     all_files = __salt__["file.readdir"](name)
2246     beginning_of_unix_time = datetime(1970, 1, 1)
2247     def get_file_time_from_strptime(f):
2248         try:
2249             ts = datetime.strptime(f, strptime_format)
2250             ts_epoch = salt.utils.dateutils.total_seconds(ts - beginning_of_unix_time)
2251             return (ts, ts_epoch)
2252         except ValueError:
2253             return (None, None)
2254     def get_file_time_from_mtime(f):
2255         if f == "." or f == "..":
2256             return (None, None)
2257         lstat = __salt__["file.lstat"](os.path.join(name, f))
2258         if lstat:
2259             mtime = lstat["st_mtime"]
2260             return (datetime.fromtimestamp(mtime, timezone), mtime)
2261         else:  # maybe it was deleted since we did the readdir?
2262             return (None, None)
2263     get_file_time = (
2264         get_file_time_from_strptime if strptime_format else get_file_time_from_mtime
2265     )
2266     def dict_maker():
2267         return defaultdict(dict_maker)
2268     files_by_ymd = dict_maker()
2269     files_by_y_week_dow = dict_maker()
2270     relevant_files = set()
2271     ignored_files = set()
2272     for f in all_files:
2273         ts, ts_epoch = get_file_time(f)
2274         if ts:
2275             files_by_ymd[ts.year][ts.month][ts.day][ts.hour][ts_epoch] = f
2276             week_of_year = ts.isocalendar()[1]
2277             files_by_y_week_dow[ts.year][week_of_year][ts.weekday()][ts_epoch] = f
2278             relevant_files.add(f)
2279         else:
2280             ignored_files.add(f)
2281     RETAIN_TO_DEPTH = {
2282         "first_of_year": 1,
2283         "first_of_month": 2,
2284         "first_of_day": 3,
2285         "first_of_hour": 4,
2286         "most_recent": 5,
2287     }
2288     def get_first(fwt):
2289         if isinstance(fwt, dict):
2290             first_sub_key = sorted(fwt.keys())[0]
2291             return get_first(fwt[first_sub_key])
2292         else:
2293             return {fwt}
2294     def get_first_n_at_depth(fwt, depth, n):
2295         if depth &lt;= 0:
2296             return get_first(fwt)
2297         else:
2298             result_set = set()
2299             for k in sorted(fwt.keys(), reverse=True):
2300                 needed = n - len(result_set)
2301                 if needed &lt; 1:
2302                     break
2303                 result_set |= get_first_n_at_depth(fwt[k], depth - 1, needed)
2304             return result_set
2305     retained_files = set()
2306     for retention_rule, keep_count in retain.items():
2307         keep_count = sys.maxsize if "all" == keep_count else int(keep_count)
2308         if "first_of_week" == retention_rule:
2309             first_of_week_depth = 2  # year + week_of_year = 2
2310             retained_files |= get_first_n_at_depth(
2311                 files_by_y_week_dow, first_of_week_depth, keep_count + 1
2312             )
2313         else:
2314             retained_files |= get_first_n_at_depth(
2315                 files_by_ymd, RETAIN_TO_DEPTH[retention_rule], keep_count
2316             )
2317     deletable_files = list(relevant_files - retained_files)
2318     deletable_files.sort(reverse=True)
2319     changes = {
2320         "retained": sorted(list(retained_files), reverse=True),
2321         "deleted": deletable_files,
2322         "ignored": sorted(list(ignored_files), reverse=True),
2323     }
2324     ret["changes"] = changes
2325     if __opts__["test"]:
2326         ret["comment"] = "{} backups would have been removed from {}.\n".format(
2327             len(deletable_files), name
2328         )
2329         if deletable_files:
2330             ret["result"] = None
2331     else:
2332         for f in deletable_files:
2333             __salt__["file.remove"](os.path.join(name, f))
2334         ret["comment"] = "{} backups were removed from {}.\n".format(
2335             len(deletable_files), name
2336         )
2337         ret["changes"] = changes
2338     return ret
2339 def line(
2340     name,
2341     content=None,
2342     match=None,
2343     mode=None,
2344     location=None,
2345     before=None,
2346     after=None,
2347     show_changes=True,
2348     backup=False,
2349     quiet=False,
2350     indent=True,
2351     create=False,
2352     user=None,
2353     group=None,
2354     file_mode=None,
2355 ):
2356     name = os.path.expanduser(name)
2357     ret = {"name": name, "changes": {}, "result": True, "comment": ""}
2358     if not name:
2359         return _error(ret, "Must provide name to file.line")
2360     managed(name, create=create, user=user, group=group, mode=file_mode, replace=False)
2361     check_res, check_msg = _check_file(name)
2362     if not check_res:
2363         return _error(ret, check_msg)
2364     mode = mode and mode.lower() or mode
2365     if mode is None:
2366         return _error(ret, "Mode was not defined. How to process the file?")
2367     modeswithemptycontent = ["delete"]
2368     if mode not in modeswithemptycontent and content is None:
2369         return _error(
2370             ret,
2371             "Content can only be empty if mode is {}".format(modeswithemptycontent),
2372         )
2373     del modeswithemptycontent
2374     changes = __salt__["file.line"](
2375         name,
2376         content,
2377         match=match,
2378         mode=mode,
2379         location=location,
2380         before=before,
2381         after=after,
2382         show_changes=show_changes,
2383         backup=backup,
2384         quiet=quiet,
2385         indent=indent,
2386     )
2387 <a name="0"></a>    if changes:
2388         ret["changes"]["diff"] = changes
2389         if __opts__["test"]:
2390             ret<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["result"] = None
2391             ret["comment"] = "Changes would be made"
2392         else:
2393             ret["result"] = True
2394             ret["comment"] = "Changes were made"
2395     else:
2396         ret["result"] = True
2397         ret["comment"] = "No changes needed to be made"
2398     return ret
2399 def replace(
2400     name,
2401     pattern,
2402     repl,
2403     count=0,
2404     flags=</b></font>8,
2405     bufsize=1,
2406     append_if_not_found=False,
2407     prepend_if_not_found=False,
2408     not_found_content=None,
2409     backup=".bak",
2410     show_changes=True,
2411     ignore_if_missing=False,
2412     backslash_literal=False,
2413 ):
2414     r"""
2415     Maintain an edit in a file.
2416     .. versionadded:: 0.17.0
2417     name
2418         Filesystem path to the file to be edited. If a symlink is specified, it
2419         will be resolved to its target.
2420     pattern
2421         A regular expression, to be matched using Python's
2422         :py:func:`re.search`.
2423         .. note::
2424             If you need to match a literal string that contains regex special
2425             characters, you may want to use salt's custom Jinja filter,
2426             ``regex_escape``.
2427             .. code-block:: jinja
2428                 {{ 'http://example.com?foo=bar%20baz' | regex_escape }}
2429     repl
2430         The replacement text
2431     count
2432         Maximum number of pattern occurrences to be replaced.  Defaults to 0.
2433         If count is a positive integer n, no more than n occurrences will be
2434         replaced, otherwise all occurrences will be replaced.
2435     flags
2436         A list of flags defined in the ``re`` module documentation from the
2437         Python standard library. Each list item should be a string that will
2438         correlate to the human-friendly flag name. E.g., ``['IGNORECASE',
2439         'MULTILINE']``.  Optionally, ``flags`` may be an int, with a value
2440         corresponding to the XOR (``|``) of all the desired flags. Defaults to
2441         ``8`` (which equates to ``['MULTILINE']``).
2442         .. note::
2443             ``file.replace`` reads the entire file as a string to support
2444             multiline regex patterns. Therefore, when using anchors such as
2445             ``^`` or ``$`` in the pattern, those anchors may be relative to
2446             the line OR relative to the file. The default for ``file.replace``
2447             is to treat anchors as relative to the line, which is implemented
2448             by setting the default value of ``flags`` to ``['MULTILINE']``.
2449             When overriding the default value for ``flags``, if
2450             ``'MULTILINE'`` is not present then anchors will be relative to
2451             the file. If the desired behavior is for anchors to be relative to
2452             the line, then simply add ``'MULTILINE'`` to the list of flags.
2453     bufsize
2454         How much of the file to buffer into memory at once. The default value
2455         ``1`` processes one line at a time. The special value ``file`` may be
2456         specified which will read the entire file into memory before
2457         processing.
2458     append_if_not_found
2459         If set to ``True``, and pattern is not found, then the content will be
2460         appended to the file.
2461         .. versionadded:: 2014.7.0
2462     prepend_if_not_found
2463         If set to ``True`` and pattern is not found, then the content will be
2464         prepended to the file.
2465         .. versionadded:: 2014.7.0
2466     not_found_content
2467         Content to use for append/prepend if not found. If ``None`` (default),
2468         uses ``repl``. Useful when ``repl`` uses references to group in
2469         pattern.
2470         .. versionadded:: 2014.7.0
2471     backup
2472         The file extension to use for a backup of the file before editing. Set
2473         to ``False`` to skip making a backup.
2474     show_changes
2475         Output a unified diff of the old file and the new file. If ``False``
2476         return a boolean if any changes were made. Returns a boolean or a
2477         string.
2478         .. note:
2479             Using this option will store two copies of the file in memory (the
2480             original version and the edited version) in order to generate the
2481             diff. This may not normally be a concern, but could impact
2482             performance if used with large files.
2483     ignore_if_missing
2484         .. versionadded:: 2016.3.4
2485         Controls what to do if the file is missing. If set to ``False``, the
2486         state will display an error raised by the execution module. If set to
2487         ``True``, the state will simply report no changes.
2488     backslash_literal
2489         .. versionadded:: 2016.11.7
2490         Interpret backslashes as literal backslashes for the repl and not
2491         escape characters.  This will help when using append/prepend so that
2492         the backslashes are not interpreted for the repl on the second run of
2493         the state.
2494     For complex regex patterns, it can be useful to avoid the need for complex
2495     quoting and escape sequences by making use of YAML's multiline string
2496     syntax.
2497     .. code-block:: yaml
2498         complex_search_and_replace:
2499           file.replace:
2500             - pattern: |
2501                 CentOS \(2.6.32[^\\n]+\\n\s+root[^\\n]+\\n\)+
2502     .. note::
2503        When using YAML multiline string syntax in ``pattern:``, make sure to
2504        also use that syntax in the ``repl:`` part, or you might loose line
2505        feeds.
2506     When regex capture groups are used in ``pattern:``, their captured value is
2507     available for reuse in the ``repl:`` part as a backreference (ex. ``\1``).
2508     .. code-block:: yaml
2509         add_login_group_to_winbind_ssh_access_list:
2510           file.replace:
2511             - name: '/etc/security/pam_winbind.conf'
2512             - pattern: '^(require_membership_of = )(.*)$'
2513             - repl: '\1\2,append-new-group-to-line'
2514     .. note::
2515        The ``file.replace`` state uses Python's ``re`` module.
2516        For more advanced options, see https://docs.python.org/2/library/re.html
2517         ret["changes"]["diff"] <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= changes
2518         if __opts__["test"]:
2519             ret["result"] = None
2520             ret["comment"] = "Changes would have been made"
2521         else:
2522             ret["result"] = True
2523             ret["comment"] =</b></font> "Changes were made"
2524     else:
2525         ret["result"] = True
2526         ret["comment"] = "No changes needed to be made"
2527     return ret
2528 def keyvalue(
2529     name,
2530     key=None,
2531     value=None,
2532     key_values=None,
2533     separator="=",
2534     append_if_not_found=False,
2535     prepend_if_not_found=False,
2536     search_only=False,
2537     show_changes=True,
2538     ignore_if_missing=False,
2539     count=1,
2540     uncomment=None,
2541     key_ignore_case=False,
2542     value_ignore_case=False,
2543 ):
2544     name = os.path.expanduser(name)
2545     ret = {
2546         "name": name,
2547         "changes": {},
2548         "result": None,
2549         "comment": "",
2550     }
2551     if not name:
2552         return _error(ret, "Must provide name to file.keyvalue")
2553     if key is not None and value is not None:
2554         if type(key_values) is dict:
2555             return _error(
2556                 ret, "file.keyvalue can not combine key_values with key and value"
2557             )
2558         key_values = {str(key): value}
2559     elif not isinstance(key_values, dict) or not key_values:
2560         msg = "is not a dictionary"
2561         if not key_values:
2562             msg = "is empty"
2563         return _error(
2564             ret,
2565             "file.keyvalue key and value not supplied and key_values " + msg,
2566         )
2567     file_contents = []
2568     try:
2569         with salt.utils.files.fopen(name, "r") as fd:
2570             file_contents = fd.readlines()
2571     except OSError:
2572         ret["comment"] = "unable to open {n}".format(n=name)
2573         ret["result"] = True if ignore_if_missing else False
2574         return ret
2575     diff = []
2576     content = []
2577     tmpl = "{key}{sep}{value}" + os.linesep
2578     changes = 0
2579     diff_count = {k: count for k in key_values.keys()}
2580     for line in file_contents:
2581         test_line = line.lstrip(uncomment)
2582         did_uncomment = True if len(line) &gt; len(test_line) else False
2583         if key_ignore_case:
2584             test_line = test_line.lower()
2585         for key, value in key_values.items():
2586             test_key = key.lower() if key_ignore_case else key
2587             if test_line.startswith(test_key):
2588                 working_line = line.lstrip(uncomment) if did_uncomment else line
2589                 line_key, line_sep, line_value = working_line.partition(separator)
2590                 if line_sep != separator:
2591                     continue
2592                 keys_match = False
2593                 if key_ignore_case:
2594                     if line_key.lower() == test_key:
2595                         keys_match = True
2596                 else:
2597                     if line_key == test_key:
2598                         keys_match = True
2599                 if keys_match:
2600                     line_value = line_value.strip()
2601                     test_value = str(value).strip()
2602                     if value_ignore_case:
2603                         line_value = line_value.lower()
2604                         test_value = test_value.lower()
2605                     values_match = True if line_value == test_value else False
2606                     needs_changing = False
2607                     if did_uncomment:
2608                         if diff_count[key] &gt; 0:
2609                             needs_changing = True
2610                         elif not values_match:
2611                             values_match = True
2612                     else:
2613                         if diff_count[key] == 0:
2614                             needs_changing = True
2615                     if not values_match or needs_changing:
2616                         diff.append("- {}".format(line))
2617                         line = line[:0]
2618                         if diff_count[key] != 0:
2619                             line = str(
2620                                 tmpl.format(key=line_key, sep=line_sep, value=value)
2621                             )
2622                             if not isinstance(value, str):
2623                                 diff.append(
2624                                     "+ {} (from {} type){}".format(
2625                                         line.rstrip(), type(value).__name__, os.linesep
2626                                     )
2627                                 )
2628                             else:
2629                                 diff.append("+ {}".format(line))
2630                         changes += 1
2631                     if diff_count[key] &gt; 0:
2632                         diff_count[key] -= 1
2633                     continue
2634         content.append(line)
2635     fd.close()
2636     if append_if_not_found:
2637         tmpdiff = []
2638         for key, value in key_values.items():
2639             if diff_count[key] &gt; 0:
2640                 line = tmpl.format(key=key, sep=separator, value=value)
2641                 tmpdiff.append("+ {}".format(line))
2642                 content.append(line)
2643                 changes += 1
2644         if tmpdiff:
2645             tmpdiff.insert(0, "- &lt;EOF&gt;" + os.linesep)
2646             tmpdiff.append("+ &lt;EOF&gt;" + os.linesep)
2647             diff.extend(tmpdiff)
2648     elif prepend_if_not_found:
2649         did_diff = False
2650         for key, value in key_values.items():
2651             if diff_count[key] &gt; 0:
2652                 line = tmpl.format(key=key, sep=separator, value=value)
2653                 if not did_diff:
2654                     diff.insert(0, "  &lt;SOF&gt;" + os.linesep)
2655                     did_diff = True
2656                 diff.insert(1, "+ {}".format(line))
2657                 content.insert(0, line)
2658                 changes += 1
2659     if changes &gt; 0:
2660         if __opts__["test"]:
2661             ret["comment"] = "File {n} is set to be changed ({c} lines)".format(
2662                 n=name, c=changes
2663             )
2664             if show_changes:
2665                 ret["changes"]["diff"] = "".join(diff)
2666                 ret["comment"] += "\nPredicted diff:\n\r\t\t"
2667                 ret["comment"] += "\r\t\t".join(diff)
2668                 ret["result"] = None
2669         else:
2670             ret["comment"] = "Changed {c} lines".format(c=changes)
2671             if show_changes:
2672                 ret["changes"]["diff"] = "".join(diff)
2673     else:
2674         ret["result"] = True
2675         return ret
2676     if not __opts__["test"]:
2677         try:
2678             with salt.utils.files.fopen(name, "w") as fd:
2679                 fd.writelines(content)
2680                 fd.close()
2681         except OSError:
2682             ret["comment"] = "{n} not writable".format(n=name)
2683             ret["result"] = False
2684             return ret
2685         ret["result"] = True
2686     return ret
2687 def blockreplace(
2688     name,
2689     marker_start="#-- start managed zone --",
2690     marker_end="#-- end managed zone --",
2691     source=None,
2692     source_hash=None,
2693     template="jinja",
2694     sources=None,
2695     source_hashes=None,
2696     defaults=None,
2697     context=None,
2698     content="",
2699     append_if_not_found=False,
2700     prepend_if_not_found=False,
2701     backup=".bak",
2702     show_changes=True,
2703     append_newline=None,
2704     insert_before_match=None,
2705     insert_after_match=None,
2706 ):
2707     name = os.path.expanduser(name)
2708     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
2709     if not name:
2710         return _error(ret, "Must provide name to file.blockreplace")
2711     if sources is None:
2712         sources = []
2713     if source_hashes is None:
2714         source_hashes = []
2715     (ok_, err, sl_) = _unify_sources_and_hashes(
2716         source=source,
2717         source_hash=source_hash,
2718         sources=sources,
2719         source_hashes=source_hashes,
2720     )
2721     if not ok_:
2722         return _error(ret, err)
2723     check_res, check_msg = _check_file(name)
2724     if not check_res:
2725         return _error(ret, check_msg)
2726     accum_data, accum_deps = _load_accumulators()
2727     if name in accum_data:
2728         accumulator = accum_data[name]
2729         deps = accum_deps.get(name, [])
2730         filtered = [
2731             a for a in deps if __low__["__id__"] in deps[a] and a in accumulator
2732         ]
2733         if not filtered:
2734             filtered = [a for a in accumulator]
2735         for acc in filtered:
2736             acc_content = accumulator[acc]
2737             for line in acc_content:
2738                 if content == "":
2739                     content = line
2740                 else:
2741                     content += "\n" + line
2742     if sl_:
2743         tmpret = _get_template_texts(
2744             source_list=sl_, template=template, defaults=defaults, context=context
2745         )
2746         if not tmpret["result"]:
2747             return tmpret
2748         text = tmpret["data"]
2749         for index, item in enumerate(text):
2750             content += str(item)
2751     try:
2752         changes = __salt__["file.blockreplace"](
2753             name,
2754             marker_start,
2755             marker_end,
2756             content=content,
2757             append_if_not_found=append_if_not_found,
2758             prepend_if_not_found=prepend_if_not_found,
2759             insert_before_match=insert_before_match,
2760             insert_after_match=insert_after_match,
2761             backup=backup,
2762             dry_run=__opts__["test"],
2763             show_changes=show_changes,
2764             append_newline=append_newline,
2765         )
2766     except Exception as exc:  # pylint: disable=broad-except
2767         log.exception("Encountered error managing block")
2768         ret[
2769             "comment"
2770         ] = "Encountered error managing block: {}. See the log for details.".format(exc)
2771         return ret
2772     if changes:
2773         ret["changes"]["diff"] = changes
2774         if __opts__["test"]:
2775             ret["result"] = None
2776             ret["comment"] = "Changes would be made"
2777         else:
2778             ret["result"] = True
2779             ret["comment"] = "Changes were made"
2780     else:
2781         ret["result"] = True
2782         ret["comment"] = "No changes needed to be made"
2783     return ret
2784 def comment(name, regex, char="#", backup=".bak"):
2785     name = os.path.expanduser(name)
2786     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
2787     if not name:
2788         return _error(ret, "Must provide name to file.comment")
2789     check_res, check_msg = _check_file(name)
2790     if not check_res:
2791         return _error(ret, check_msg)
2792     unanchor_regex = re.sub(r"^(\(\?[iLmsux]\))?\^?(.*?)\$?$", r"\2", regex)
2793     comment_regex = char + unanchor_regex
2794     if not __salt__["file.search"](name, regex, multiline=True):
2795         if __salt__["file.search"](name, comment_regex, multiline=True):
2796             ret["comment"] = "Pattern already commented"
2797             ret["result"] = True
2798             return ret
2799         else:
2800             return _error(ret, "{}: Pattern not found".format(unanchor_regex))
2801     if __opts__["test"]:
2802         ret["changes"][name] = "updated"
2803         ret["comment"] = "File {} is set to be updated".format(name)
2804         ret["result"] = None
2805         return ret
2806     with salt.utils.files.fopen(name, "rb") as fp_:
2807         slines = fp_.read()
2808         slines = slines.decode(__salt_system_encoding__)
2809         slines = slines.splitlines(True)
2810     __salt__["file.comment_line"](name, regex, char, True, backup)
2811     with salt.utils.files.fopen(name, "rb") as fp_:
2812         nlines = fp_.read()
2813         nlines = nlines.decode(__salt_system_encoding__)
2814         nlines = nlines.splitlines(True)
2815     ret["result"] = __salt__["file.search"](name, unanchor_regex, multiline=True)
2816     if slines != nlines:
2817         if not __utils__["files.is_text"](name):
2818             ret["changes"]["diff"] = "Replace binary file"
2819         else:
2820             ret["changes"]["diff"] = "".join(difflib.unified_diff(slines, nlines))
2821     if ret["result"]:
2822         ret["comment"] = "Commented lines successfully"
2823     else:
2824         ret["comment"] = "Expected commented lines not found"
2825     return ret
2826 def uncomment(name, regex, char="#", backup=".bak"):
2827     name = os.path.expanduser(name)
2828     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
2829     if not name:
2830         return _error(ret, "Must provide name to file.uncomment")
2831     check_res, check_msg = _check_file(name)
2832     if not check_res:
2833         return _error(ret, check_msg)
2834     if __salt__["file.search"](
2835         name, "{}[ \t]*{}".format(char, regex.lstrip("^")), multiline=True
2836     ):
2837         pass
2838     elif __salt__["file.search"](
2839         name, "^[ \t]*{}".format(regex.lstrip("^")), multiline=True
2840     ):
2841         ret["comment"] = "Pattern already uncommented"
2842         ret["result"] = True
2843         return ret
2844     else:
2845         return _error(ret, "{}: Pattern not found".format(regex))
2846     if __opts__["test"]:
2847         ret["changes"][name] = "updated"
2848         ret["comment"] = "File {} is set to be updated".format(name)
2849         ret["result"] = None
2850         return ret
2851     with salt.utils.files.fopen(name, "rb") as fp_:
2852         slines = salt.utils.data.decode(fp_.readlines())
2853     __salt__["file.comment_line"](name, regex, char, False, backup)
2854     with salt.utils.files.fopen(name, "rb") as fp_:
2855         nlines = salt.utils.data.decode(fp_.readlines())
2856     ret["result"] = __salt__["file.search"](
2857         name, "^[ \t]*{}".format(regex.lstrip("^")), multiline=True
2858     )
2859     if slines != nlines:
2860         if not __utils__["files.is_text"](name):
2861             ret["changes"]["diff"] = "Replace binary file"
2862         else:
2863             ret["changes"]["diff"] = "".join(difflib.unified_diff(slines, nlines))
2864     if ret["result"]:
2865         ret["comment"] = "Uncommented lines successfully"
2866     else:
2867         ret["comment"] = "Expected uncommented lines not found"
2868     return ret
2869 def append(
2870     name,
2871     text=None,
2872     makedirs=False,
2873     source=None,
2874     source_hash=None,
2875     template="jinja",
2876     sources=None,
2877     source_hashes=None,
2878     defaults=None,
2879     context=None,
2880     ignore_whitespace=True,
2881 ):
2882     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
2883     if not name:
2884         return _error(ret, "Must provide name to file.append")
2885     name = os.path.expanduser(name)
2886     if sources is None:
2887         sources = []
2888     if source_hashes is None:
2889         source_hashes = []
2890     (ok_, err, sl_) = _unify_sources_and_hashes(
2891         source=source,
2892         source_hash=source_hash,
2893         sources=sources,
2894         source_hashes=source_hashes,
2895     )
2896     if not ok_:
2897         return _error(ret, err)
2898     if makedirs is True:
2899         dirname = os.path.dirname(name)
2900         if __opts__["test"]:
2901             ret["comment"] = "Directory {} is set to be updated".format(dirname)
2902             ret["result"] = None
2903         else:
2904             if not __salt__["file.directory_exists"](dirname):
2905                 try:
2906                     _makedirs(name=name)
2907                 except CommandExecutionError as exc:
2908                     return _error(ret, "Drive {} is not mapped".format(exc.message))
2909                 check_res, check_msg, check_changes = (
2910                     _check_directory_win(dirname)
2911                     if salt.utils.platform.is_windows()
2912                     else _check_directory(dirname)
2913                 )
2914                 if not check_res:
2915                     ret["changes"] = check_changes
2916                     return _error(ret, check_msg)
2917     check_res, check_msg = _check_file(name)
2918     if not check_res:
2919         touch_ret = touch(name, makedirs=makedirs)
2920         if __opts__["test"]:
2921             return touch_ret
2922         retry_res, retry_msg = _check_file(name)
2923         if not retry_res:
2924             return _error(ret, check_msg)
2925     if sl_:
2926         tmpret = _get_template_texts(
2927             source_list=sl_, template=template, defaults=defaults, context=context
2928         )
2929         if not tmpret["result"]:
2930             return tmpret
2931         text = tmpret["data"]
2932     text = _validate_str_list(text)
2933     with salt.utils.files.fopen(name, "rb") as fp_:
2934         slines = fp_.read()
2935         slines = slines.decode(__salt_system_encoding__)
2936         slines = slines.splitlines()
2937     append_lines = []
2938     try:
2939         for chunk in text:
2940             if ignore_whitespace:
2941                 if __salt__["file.search"](
2942                     name,
2943                     salt.utils.stringutils.build_whitespace_split_regex(chunk),
2944                     multiline=True,
2945                 ):
2946                     continue
2947             elif __salt__["file.search"](name, chunk, multiline=True):
2948                 continue
2949             for line_item in chunk.splitlines():
2950                 append_lines.append("{}".format(line_item))
2951     except TypeError:
2952         return _error(ret, "No text found to append. Nothing appended")
2953     if __opts__["test"]:
2954         ret["comment"] = "File {} is set to be updated".format(name)
2955         ret["result"] = None
2956         nlines = list(slines)
2957         nlines.extend(append_lines)
2958         if slines != nlines:
2959             if not __utils__["files.is_text"](name):
2960                 ret["changes"]["diff"] = "Replace binary file"
2961             else:
2962                 ret["changes"]["diff"] = "\n".join(difflib.unified_diff(slines, nlines))
2963         else:
2964             ret["comment"] = "File {} is in correct state".format(name)
2965             ret["result"] = True
2966         return ret
2967     if append_lines:
2968         __salt__["file.append"](name, args=append_lines)
2969         ret["comment"] = "Appended {} lines".format(len(append_lines))
2970     else:
2971         ret["comment"] = "File {} is in correct state".format(name)
2972     with salt.utils.files.fopen(name, "rb") as fp_:
2973         nlines = fp_.read()
2974         nlines = nlines.decode(__salt_system_encoding__)
2975         nlines = nlines.splitlines()
2976     if slines != nlines:
2977         if not __utils__["files.is_text"](name):
2978             ret["changes"]["diff"] = "Replace binary file"
2979         else:
2980             ret["changes"]["diff"] = "\n".join(difflib.unified_diff(slines, nlines))
2981     ret["result"] = True
2982     return ret
2983 def prepend(
2984     name,
2985     text=None,
2986     makedirs=False,
2987     source=None,
2988     source_hash=None,
2989     template="jinja",
2990     sources=None,
2991     source_hashes=None,
2992     defaults=None,
2993     context=None,
2994     header=None,
2995 ):
2996     name = os.path.expanduser(name)
2997     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
2998     if not name:
2999         return _error(ret, "Must provide name to file.prepend")
3000     if sources is None:
3001         sources = []
3002     if source_hashes is None:
3003         source_hashes = []
3004     (ok_, err, sl_) = _unify_sources_and_hashes(
3005         source=source,
3006         source_hash=source_hash,
3007         sources=sources,
3008         source_hashes=source_hashes,
3009     )
3010     if not ok_:
3011         return _error(ret, err)
3012     if makedirs is True:
3013         dirname = os.path.dirname(name)
3014         if __opts__["test"]:
3015             ret["comment"] = "Directory {} is set to be updated".format(dirname)
3016             ret["result"] = None
3017         else:
3018             if not __salt__["file.directory_exists"](dirname):
3019                 try:
3020                     _makedirs(name=name)
3021                 except CommandExecutionError as exc:
3022                     return _error(ret, "Drive {} is not mapped".format(exc.message))
3023                 check_res, check_msg, check_changes = (
3024                     _check_directory_win(dirname)
3025                     if salt.utils.platform.is_windows()
3026                     else _check_directory(dirname)
3027                 )
3028                 if not check_res:
3029                     ret["changes"] = check_changes
3030                     return _error(ret, check_msg)
3031     check_res, check_msg = _check_file(name)
3032     if not check_res:
3033         touch_ret = touch(name, makedirs=makedirs)
3034         if __opts__["test"]:
3035             return touch_ret
3036         retry_res, retry_msg = _check_file(name)
3037         if not retry_res:
3038             return _error(ret, check_msg)
3039     if sl_:
3040         tmpret = _get_template_texts(
3041             source_list=sl_, template=template, defaults=defaults, context=context
3042         )
3043         if not tmpret["result"]:
3044             return tmpret
3045         text = tmpret["data"]
3046     text = _validate_str_list(text)
3047     with salt.utils.files.fopen(name, "rb") as fp_:
3048         slines = fp_.read()
3049         slines = slines.decode(__salt_system_encoding__)
3050         slines = slines.splitlines(True)
3051     count = 0
3052     test_lines = []
3053     preface = []
3054     for chunk in text:
3055         if not header:
3056             if __salt__["file.search"](
3057                 name,
3058                 salt.utils.stringutils.build_whitespace_split_regex(chunk),
3059                 multiline=True,
3060             ):
3061                 continue
3062         lines = chunk.splitlines()
3063         for line in lines:
3064             if __opts__["test"]:
3065                 ret["comment"] = "File {} is set to be updated".format(name)
3066                 ret["result"] = None
3067                 test_lines.append("{}\n".format(line))
3068             else:
3069                 preface.append(line)
3070             count += 1
3071     if __opts__["test"]:
3072         nlines = test_lines + slines
3073         if slines != nlines:
3074             if not __utils__["files.is_text"](name):
3075                 ret["changes"]["diff"] = "Replace binary file"
3076             else:
3077                 ret["changes"]["diff"] = "".join(difflib.unified_diff(slines, nlines))
3078             ret["result"] = None
3079         else:
3080             ret["comment"] = "File {} is in correct state".format(name)
3081             ret["result"] = True
3082         return ret
3083     if header:
3084         with salt.utils.files.fopen(name, "rb") as fp_:
3085             contents = fp_.read()
3086             contents = contents.decode(__salt_system_encoding__)
3087             contents = contents.splitlines(True)
3088             target_head = contents[0 : len(preface)]
3089             target_lines = []
3090             for chunk in target_head:
3091                 target_lines += chunk.splitlines()
3092             if target_lines != preface:
3093                 __salt__["file.prepend"](name, *preface)
3094             else:
3095                 count = 0
3096     else:
3097         __salt__["file.prepend"](name, *preface)
3098     with salt.utils.files.fopen(name, "rb") as fp_:
3099         nlines = fp_.read()
3100         nlines = nlines.decode(__salt_system_encoding__)
3101         nlines = nlines.splitlines(True)
3102     if slines != nlines:
3103         if not __utils__["files.is_text"](name):
3104             ret["changes"]["diff"] = "Replace binary file"
3105         else:
3106             ret["changes"]["diff"] = "".join(difflib.unified_diff(slines, nlines))
3107     if count:
3108         ret["comment"] = "Prepended {} lines".format(count)
3109     else:
3110         ret["comment"] = "File {} is in correct state".format(name)
3111     ret["result"] = True
3112     return ret
3113 def patch(
3114     name,
3115     source=None,
3116     source_hash=None,
3117     source_hash_name=None,
3118     skip_verify=False,
3119     template=None,
3120     context=None,
3121     defaults=None,
3122     options="",
3123     reject_file=None,
3124     strip=None,
3125     saltenv=None,
3126     **kwargs
3127 ):
3128     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
3129     if not salt.utils.path.which("patch"):
3130         ret["comment"] = "patch executable not found on minion"
3131         return ret
3132     is_dir = False
3133     if not name:
3134         ret["comment"] = "A file/directory to be patched is required"
3135         return ret
3136     else:
3137         try:
3138             name = os.path.expanduser(name)
3139         except Exception:  # pylint: disable=broad-except
3140             ret["comment"] = "Invalid path '{}'".format(name)
3141             return ret
3142         else:
3143             if not os.path.isabs(name):
3144                 ret["comment"] = "{} is not an absolute path".format(name)
3145                 return ret
3146             elif not os.path.exists(name):
3147                 ret["comment"] = "{} does not exist".format(name)
3148                 return ret
3149             else:
3150                 is_dir = os.path.isdir(name)
3151     for deprecated_arg in ("hash", "dry_run_first"):
3152         if deprecated_arg in kwargs:
3153             ret.setdefault("warnings", []).append(
3154                 "The '{}' argument is no longer used and has been ignored.".format(
3155                     deprecated_arg
3156                 )
3157             )
3158     if reject_file is not None:
3159         try:
3160             reject_file_parent = os.path.dirname(reject_file)
3161         except Exception:  # pylint: disable=broad-except
3162             ret["comment"] = "Invalid path '{}' for reject_file".format(reject_file)
3163             return ret
3164         else:
3165             if not os.path.isabs(reject_file_parent):
3166                 ret["comment"] = "'{}' is not an absolute path".format(reject_file)
3167                 return ret
3168             elif not os.path.isdir(reject_file_parent):
3169                 ret["comment"] = (
3170                     "Parent directory for reject_file '{}' either does "
3171                     "not exist, or is not a directory".format(reject_file)
3172                 )
3173                 return ret
3174     sanitized_options = []
3175     options = salt.utils.args.shlex_split(options)
3176     index = 0
3177     max_index = len(options) - 1
3178     blacklisted_options = []
3179     while index &lt;= max_index:
3180         option = options[index]
3181         if not isinstance(option, str):
3182             option = str(option)
3183         for item in ("-N", "--forward", "-r", "--reject-file", "-o", "--output"):
3184             if option.startswith(item):
3185                 blacklisted = option
3186                 break
3187         else:
3188             blacklisted = None
3189         if blacklisted is not None:
3190             blacklisted_options.append(blacklisted)
3191         if option.startswith("-p"):
3192             try:
3193                 strip = int(option[2:])
3194             except Exception:  # pylint: disable=broad-except
3195                 ret["comment"] = (
3196                     "Invalid format for '-p' CLI option. Consider using "
3197                     "the 'strip' option for this state."
3198                 )
3199                 return ret
3200         elif option.startswith("--strip"):
3201             if "=" in option:
3202                 try:
3203                     strip = int(option.rsplit("=", 1)[-1])
3204                 except Exception:  # pylint: disable=broad-except
3205                     ret["comment"] = (
3206                         "Invalid format for '-strip' CLI option. Consider "
3207                         "using the 'strip' option for this state."
3208                     )
3209                     return ret
3210             else:
3211                 try:
3212                     strip = int(options[index + 1])
3213                 except Exception:  # pylint: disable=broad-except
3214                     ret["comment"] = (
3215                         "Invalid format for '-strip' CLI option. Consider "
3216                         "using the 'strip' option for this state."
3217                     )
3218                     return ret
3219                 else:
3220                     index += 1
3221         else:
3222             sanitized_options.append(option)
3223         index += 1
3224     if blacklisted_options:
3225         ret["comment"] = "The following CLI options are not allowed: {}".format(
3226             ", ".join(blacklisted_options)
3227         )
3228         return ret
3229     options = sanitized_options
3230     try:
3231         source_match = __salt__["file.source_list"](source, source_hash, __env__)[0]
3232     except CommandExecutionError as exc:
3233         ret["result"] = False
3234         ret["comment"] = exc.strerror
3235         return ret
3236     else:
3237         if saltenv is not None:
3238             source_match_url, source_match_saltenv = salt.utils.url.parse(source_match)
3239             if source_match_url.startswith("salt://"):
3240                 if source_match_saltenv is not None and source_match_saltenv != saltenv:
3241                     ret.setdefault("warnings", []).append(
3242                         "Ignoring 'saltenv' option in favor of saltenv "
3243                         "included in the source URL."
3244                     )
3245                 else:
3246                     source_match += "?saltenv={}".format(saltenv)
3247     cleanup = []
3248     try:
3249         patch_file = salt.utils.files.mkstemp()
3250         cleanup.append(patch_file)
3251         try:
3252             orig_test = __opts__["test"]
3253             __opts__["test"] = False
3254             sys.modules[__salt__["file.patch"].__module__].__opts__["test"] = False
3255             result = managed(
3256                 patch_file,
3257                 source=source_match,
3258                 source_hash=source_hash,
3259                 source_hash_name=source_hash_name,
3260                 skip_verify=skip_verify,
3261                 template=template,
3262                 context=context,
3263                 defaults=defaults,
3264             )
3265         except Exception as exc:  # pylint: disable=broad-except
3266             msg = "Failed to cache patch file {}: {}".format(
3267                 salt.utils.url.redact_http_basic_auth(source_match), exc
3268             )
3269             log.exception(msg)
3270             ret["comment"] = msg
3271             return ret
3272         else:
3273             log.debug("file.managed: %s", result)
3274         finally:
3275             __opts__["test"] = orig_test
3276             sys.modules[__salt__["file.patch"].__module__].__opts__["test"] = orig_test
3277         if not orig_test and not result["result"]:
3278             log.debug(
3279                 "failed to download %s",
3280                 salt.utils.url.redact_http_basic_auth(source_match),
3281             )
3282             return result
3283         def _patch(patch_file, options=None, dry_run=False):
3284             patch_opts = copy.copy(sanitized_options)
3285             if options is not None:
3286                 patch_opts.extend(options)
3287             return __salt__["file.patch"](
3288                 name, patch_file, options=patch_opts, dry_run=dry_run
3289             )
3290         if reject_file is not None:
3291             patch_rejects = reject_file
3292         else:
3293             patch_rejects = salt.utils.files.mkstemp()
3294             cleanup.append(patch_rejects)
3295         patch_output = salt.utils.files.mkstemp()
3296         cleanup.append(patch_output)
3297         patch_opts = ["-N", "-r", patch_rejects, "-o", patch_output]
3298         if is_dir and strip is not None:
3299             patch_opts.append("-p{}".format(strip))
3300         pre_check = _patch(patch_file, patch_opts)
3301         if pre_check["retcode"] != 0:
3302             reverse_pass = _patch(patch_rejects, ["-R", "-f"], dry_run=True)
3303             already_applied = reverse_pass["retcode"] == 0
3304             if pre_check["retcode"] == 2 and pre_check["stderr"]:
3305                 ret["comment"] = pre_check["stderr"]
3306                 ret["result"] = False
3307                 return ret
3308             if already_applied:
3309                 ret["comment"] = "Patch was already applied"
3310                 ret["result"] = True
3311                 return ret
3312             else:
3313                 ret["comment"] = (
3314                     "Patch would not apply cleanly, no changes made. Results "
3315                     "of dry-run are below."
3316                 )
3317                 if reject_file is None:
3318                     ret["comment"] += (
3319                         " Run state again using the reject_file option to "
3320                         "save rejects to a persistent file."
3321                     )
3322                 opts = copy.copy(__opts__)
3323                 opts["color"] = False
3324                 ret["comment"] += "\n\n" + salt.output.out_format(
3325                     pre_check, "nested", opts, nested_indent=14
3326                 )
3327                 return ret
3328         if __opts__["test"]:
3329             ret["result"] = None
3330             ret["comment"] = "The patch would be applied"
3331             ret["changes"] = pre_check
3332             return ret
3333         patch_opts = []
3334         if is_dir and strip is not None:
3335             patch_opts.append("-p{}".format(strip))
3336         ret["changes"] = _patch(patch_file, patch_opts)
3337         if ret["changes"]["retcode"] == 0:
3338             ret["comment"] = "Patch successfully applied"
3339             ret["result"] = True
3340         else:
3341             ret["comment"] = "Failed to apply patch"
3342         return ret
3343     finally:
3344         for path in cleanup:
3345             try:
3346                 os.remove(path)
3347             except OSError as exc:
3348                 if exc.errno != os.errno.ENOENT:
3349                     log.error(
3350                         "file.patch: Failed to remove temp file %s: %s", path, exc
3351                     )
3352 def touch(name, atime=None, mtime=None, makedirs=False):
3353     name = os.path.expanduser(name)
3354     ret = {
3355         "name": name,
3356         "changes": {},
3357     }
3358     if not name:
3359         return _error(ret, "Must provide name to file.touch")
3360     if not os.path.isabs(name):
3361         return _error(ret, "Specified file {} is not an absolute path".format(name))
3362     if __opts__["test"]:
3363         ret.update(_check_touch(name, atime, mtime))
3364         return ret
3365     if makedirs:
3366         try:
3367             _makedirs(name=name)
3368         except CommandExecutionError as exc:
3369             return _error(ret, "Drive {} is not mapped".format(exc.message))
3370     if not os.path.isdir(os.path.dirname(name)):
3371         return _error(ret, "Directory not present to touch file {}".format(name))
3372     extant = os.path.exists(name)
3373     ret["result"] = __salt__["file.touch"](name, atime, mtime)
3374     if not extant and ret["result"]:
3375         ret["comment"] = "Created empty file {}".format(name)
3376         ret["changes"]["new"] = name
3377     elif extant and ret["result"]:
3378         ret["comment"] = "Updated times on {} {}".format(
3379             "directory" if os.path.isdir(name) else "file", name
3380         )
3381         ret["changes"]["touched"] = name
3382     return ret
3383 def copy_(
3384     name,
3385     source,
3386     force=False,
3387     makedirs=False,
3388     preserve=False,
3389     user=None,
3390     group=None,
3391     mode=None,
3392     subdir=False,
3393     **kwargs
3394 ):
3395     name = os.path.expanduser(name)
3396     source = os.path.expanduser(source)
3397     ret = {
3398         "name": name,
3399         "changes": {},
3400         "comment": 'Copied "{}" to "{}"'.format(source, name),
3401         "result": True,
3402     }
3403     if not name:
3404         return _error(ret, "Must provide name to file.copy")
3405     changed = True
3406     if not os.path.isabs(name):
3407         return _error(ret, "Specified file {} is not an absolute path".format(name))
3408     if not os.path.exists(source):
3409         return _error(ret, 'Source file "{}" is not present'.format(source))
3410     if preserve:
3411         user = __salt__["file.get_user"](source)
3412         group = __salt__["file.get_group"](source)
3413         mode = __salt__["file.get_mode"](source)
3414     else:
3415         user = _test_owner(kwargs, user=user)
3416         if user is None:
3417             user = __opts__["user"]
3418         if salt.utils.platform.is_windows():
3419             if group is not None:
3420                 log.warning(
3421                     "The group argument for %s has been ignored as this is "
3422                     "a Windows system.",
3423                     name,
3424                 )
3425             group = user
3426         if group is None:
3427             if "user.info" in __salt__:
3428                 group = __salt__["file.gid_to_group"](
3429                     __salt__["user.info"](user).get("gid", 0)
3430                 )
3431             else:
3432                 group = user
3433         u_check = _check_user(user, group)
3434         if u_check:
3435             return _error(ret, u_check)
3436         if mode is None:
3437             mode = __salt__["file.get_mode"](source)
3438     if os.path.isdir(name) and subdir:
3439         name = os.path.join(name, os.path.basename(source))
3440     if os.path.lexists(source) and os.path.lexists(name):
3441         if force and os.path.isfile(name):
3442             hash1 = salt.utils.hashutils.get_hash(name)
3443             hash2 = salt.utils.hashutils.get_hash(source)
3444             if hash1 == hash2:
3445                 changed = True
3446                 ret["comment"] = " ".join(
3447                     [ret["comment"], "- files are identical but force flag is set"]
3448                 )
3449         if not force:
3450             changed = False
3451         elif not __opts__["test"] and changed:
3452             try:
3453                 __salt__["file.remove"](name)
3454             except OSError:
3455                 return _error(
3456                     ret,
3457                     'Failed to delete "{}" in preparation for forced move'.format(name),
3458                 )
3459     if __opts__["test"]:
3460         if changed:
3461             ret["comment"] = 'File "{}" is set to be copied to "{}"'.format(
3462                 source, name
3463             )
3464             ret["result"] = None
3465         else:
3466             ret[
3467                 "comment"
3468             ] = 'The target file "{}" exists and will not be overwritten'.format(name)
3469             ret["result"] = True
3470         return ret
3471     if not changed:
3472         ret[
3473             "comment"
3474         ] = 'The target file "{}" exists and will not be overwritten'.format(name)
3475         ret["result"] = True
3476         return ret
3477     dname = os.path.dirname(name)
3478     if not os.path.isdir(dname):
3479         if makedirs:
3480             try:
3481                 _makedirs(name=name, user=user, group=group, dir_mode=mode)
3482             except CommandExecutionError as exc:
3483                 return _error(ret, "Drive {} is not mapped".format(exc.message))
3484         else:
3485             return _error(ret, "The target directory {} is not present".format(dname))
3486     try:
3487         if os.path.isdir(source):
3488             shutil.copytree(source, name, symlinks=True)
3489             for root, dirs, files in salt.utils.path.os_walk(name):
3490                 for dir_ in dirs:
3491                     __salt__["file.lchown"](os.path.join(root, dir_), user, group)
3492                 for file_ in files:
3493                     __salt__["file.lchown"](os.path.join(root, file_), user, group)
3494         else:
3495             shutil.copy(source, name)
3496         ret["changes"] = {name: source}
3497         if not preserve:
3498             if salt.utils.platform.is_windows():
3499                 check_ret = __salt__["file.check_perms"](path=name, ret=ret, owner=user)
3500             else:
3501                 check_ret, perms = __salt__["file.check_perms"](
3502                     name, ret, user, group, mode
3503                 )
3504             if not check_ret["result"]:
3505                 ret["result"] = check_ret["result"]
3506                 ret["comment"] = check_ret["comment"]
3507     except OSError:
3508         return _error(ret, 'Failed to copy "{}" to "{}"'.format(source, name))
3509     return ret
3510 def rename(name, source, force=False, makedirs=False, **kwargs):
3511     name = os.path.expanduser(name)
3512     name = os.path.expandvars(name)
3513     source = os.path.expanduser(source)
3514     source = os.path.expandvars(source)
3515     ret = {"name": name, "changes": {}, "comment": "", "result": True}
3516     if not name:
3517         return _error(ret, "Must provide name to file.rename")
3518     if not os.path.isabs(name):
3519         return _error(ret, "Specified file {} is not an absolute path".format(name))
3520     if not os.path.lexists(source):
3521         ret["comment"] = 'Source file "{}" has already been moved out of place'.format(
3522             source
3523         )
3524         return ret
3525     if os.path.lexists(source) and os.path.lexists(name):
3526         if not force:
3527             ret[
3528                 "comment"
3529             ] = 'The target file "{}" exists and will not be overwritten'.format(name)
3530             return ret
3531         elif not __opts__["test"]:
3532             try:
3533                 __salt__["file.remove"](name)
3534             except OSError:
3535                 return _error(
3536                     ret,
3537                     'Failed to delete "{}" in preparation for forced move'.format(name),
3538                 )
3539     if __opts__["test"]:
3540         ret["comment"] = 'File "{}" is set to be moved to "{}"'.format(source, name)
3541         ret["result"] = None
3542         return ret
3543     dname = os.path.dirname(name)
3544     if not os.path.isdir(dname):
3545         if makedirs:
3546             try:
3547                 _makedirs(name=name)
3548             except CommandExecutionError as exc:
3549                 return _error(ret, "Drive {} is not mapped".format(exc.message))
3550         else:
3551             return _error(ret, "The target directory {} is not present".format(dname))
3552     try:
3553         if os.path.islink(source):
3554             linkto = salt.utils.path.readlink(source)
3555             os.symlink(linkto, name)
3556             os.unlink(source)
3557         else:
3558             shutil.move(source, name)
3559     except OSError:
3560         return _error(ret, 'Failed to move "{}" to "{}"'.format(source, name))
3561     ret["comment"] = 'Moved "{}" to "{}"'.format(source, name)
3562     ret["changes"] = {name: source}
3563     return ret
3564 def accumulated(name, filename, text, **kwargs):
3565     ret = {"name": name, "changes": {}, "result": True, "comment": ""}
3566     if not name:
3567         return _error(ret, "Must provide name to file.accumulated")
3568     if text is None:
3569         ret["result"] = False
3570         ret["comment"] = "No text supplied for accumulator"
3571         return ret
3572     require_in = __low__.get("require_in", [])
3573     watch_in = __low__.get("watch_in", [])
3574     deps = require_in + watch_in
3575     if not [x for x in deps if "file" in x]:
3576         ret["result"] = False
3577         ret["comment"] = "Orphaned accumulator {} in {}:{}".format(
3578             name, __low__["__sls__"], __low__["__id__"]
3579         )
3580         return ret
3581     if isinstance(text, str):
3582         text = (text,)
3583     elif isinstance(text, dict):
3584         text = (text,)
3585     accum_data, accum_deps = _load_accumulators()
3586     if filename not in accum_data:
3587         accum_data[filename] = {}
3588     if filename not in accum_deps:
3589         accum_deps[filename] = {}
3590     if name not in accum_deps[filename]:
3591         accum_deps[filename][name] = []
3592     for accumulator in deps:
3593         if isinstance(accumulator, (dict, OrderedDict)):
3594             accum_deps[filename][name].extend(accumulator.values())
3595         else:
3596             accum_deps[filename][name].extend(accumulator)
3597     if name not in accum_data[filename]:
3598         accum_data[filename][name] = []
3599     for chunk in text:
3600         if chunk not in accum_data[filename][name]:
3601             accum_data[filename][name].append(chunk)
3602             ret["comment"] = "Accumulator {} for file {} was charged by text".format(
3603                 name, filename
3604             )
3605     _persist_accummulators(accum_data, accum_deps)
3606     return ret
3607 def serialize(
3608     name,
3609     dataset=None,
3610     dataset_pillar=None,
3611     user=None,
3612     group=None,
3613     mode=None,
3614     backup="",
3615     makedirs=False,
3616     show_changes=True,
3617     create=True,
3618     merge_if_exists=False,
3619     encoding=None,
3620     encoding_errors="strict",
3621     serializer=None,
3622     serializer_opts=None,
3623     deserializer_opts=None,
3624     **kwargs
3625 ):
3626     if "env" in kwargs:
3627         kwargs.pop("env")
3628     name = os.path.expanduser(name)
3629     serializer_options = {
3630         "yaml.serialize": {"default_flow_style": False},
3631         "json.serialize": {"indent": 2, "separators": (",", ": "), "sort_keys": True},
3632     }
3633     deserializer_options = {
3634         "yaml.deserialize": {},
3635         "json.deserialize": {},
3636     }
3637     if encoding:
3638         serializer_options["yaml.serialize"].update({"allow_unicode": True})
3639         serializer_options["json.serialize"].update({"ensure_ascii": False})
3640     ret = {"changes": {}, "comment": "", "name": name, "result": True}
3641     if not name:
3642         return _error(ret, "Must provide name to file.serialize")
3643     if not create:
3644         if not os.path.isfile(name):
3645             ret[
3646                 "comment"
3647             ] = "File {} is not present and is not set for creation".format(name)
3648             return ret
3649     formatter = kwargs.pop("formatter", None)
3650     if serializer and formatter:
3651         return _error(ret, "Only one of serializer and formatter are allowed")
3652     serializer = str(serializer or formatter or "yaml").lower()
3653     if len([x for x in (dataset, dataset_pillar) if x]) &gt; 1:
3654         return _error(ret, "Only one of 'dataset' and 'dataset_pillar' is permitted")
3655     if dataset_pillar:
3656         dataset = __salt__["pillar.get"](dataset_pillar)
3657     if dataset is None:
3658         return _error(ret, "Neither 'dataset' nor 'dataset_pillar' was defined")
3659     if salt.utils.platform.is_windows():
3660         if group is not None:
3661             log.warning(
3662                 "The group argument for %s has been ignored as this "
3663                 "is a Windows system.",
3664                 name,
3665             )
3666         group = user
3667     serializer_name = "{}.serialize".format(serializer)
3668     deserializer_name = "{}.deserialize".format(serializer)
3669     if serializer_name not in __serializers__:
3670         return {
3671             "changes": {},
3672             "comment": (
3673                 "The {} serializer could not be found. It either does "
3674                 "not exist or its prerequisites are not installed.".format(serializer)
3675             ),
3676             "name": name,
3677             "result": False,
3678         }
3679     if serializer_opts:
3680         serializer_options.setdefault(serializer_name, {}).update(
3681             salt.utils.data.repack_dictlist(serializer_opts)
3682         )
3683     if deserializer_opts:
3684         deserializer_options.setdefault(deserializer_name, {}).update(
3685             salt.utils.data.repack_dictlist(deserializer_opts)
3686         )
3687     if merge_if_exists:
3688         if os.path.isfile(name):
3689             if deserializer_name not in __serializers__:
3690                 return {
3691                     "changes": {},
3692                     "comment": (
3693                         "merge_if_exists is not supported for the {} serializer".format(
3694                             serializer
3695                         )
3696                     ),
3697                     "name": name,
3698                     "result": False,
3699                 }
3700             open_args = "r"
3701             if serializer == "plist":
3702                 open_args += "b"
3703             with salt.utils.files.fopen(name, open_args) as fhr:
3704                 try:
3705                     existing_data = __serializers__[deserializer_name](
3706                         fhr, **deserializer_options.get(deserializer_name, {})
3707                     )
3708                 except (TypeError, DeserializationError) as exc:
3709                     ret["result"] = False
3710                     ret["comment"] = "Failed to deserialize existing data: {}".format(
3711                         exc
3712                     )
3713                     return False
3714             if existing_data is not None:
3715                 merged_data = salt.utils.dictupdate.merge_recurse(
3716                     existing_data, dataset
3717                 )
3718                 if existing_data == merged_data:
3719                     ret["result"] = True
3720                     ret["comment"] = "The file {} is in the correct state".format(name)
3721                     return ret
3722                 dataset = merged_data
3723     else:
3724         if deserializer_opts:
3725             ret.setdefault("warnings", []).append(
3726                 "The 'deserializer_opts' option is ignored unless "
3727                 "merge_if_exists is set to True."
3728             )
3729     contents = __serializers__[serializer_name](
3730         dataset, **serializer_options.get(serializer_name, {})
3731     )
3732     try:
3733         contents += "\n"
3734     except TypeError:
3735         pass
3736     mode = salt.utils.files.normalize_mode(mode)
3737     if __opts__["test"]:
3738         ret["changes"] = __salt__["file.check_managed_changes"](
3739             name=name,
3740             source=None,
3741             source_hash={},
3742             source_hash_name=None,
3743             user=user,
3744             group=group,
3745             mode=mode,
3746             attrs=None,
3747             template=None,
3748             context=None,
3749             defaults=None,
3750             saltenv=__env__,
3751             contents=contents,
3752             skip_verify=False,
3753             **kwargs
3754         )
3755         if ret["changes"]:
3756             ret["result"] = None
3757             ret["comment"] = "Dataset will be serialized and stored into {}".format(
3758                 name
3759             )
3760             if not show_changes:
3761                 ret["changes"]["diff"] = "&lt;show_changes=False&gt;"
3762         else:
3763             ret["result"] = True
3764             ret["comment"] = "The file {} is in the correct state".format(name)
3765         return ret
3766     return __salt__["file.manage_file"](
3767         name=name,
3768         sfn="",
3769         ret=ret,
3770         source=None,
3771         source_sum={},
3772         user=user,
3773         group=group,
3774         mode=mode,
3775         attrs=None,
3776         saltenv=__env__,
3777         backup=backup,
3778         makedirs=makedirs,
3779         template=None,
3780         show_changes=show_changes,
3781         encoding=encoding,
3782         encoding_errors=encoding_errors,
3783         contents=contents,
3784     )
3785 def mknod(name, ntype, major=0, minor=0, user=None, group=None, mode="0600"):
3786     name = os.path.expanduser(name)
3787     ret = {"name": name, "changes": {}, "comment": "", "result": False}
3788     if not name:
3789         return _error(ret, "Must provide name to file.mknod")
3790     if ntype == "c":
3791         if __salt__["file.file_exists"](name):
3792             ret["comment"] = (
3793                 "File {} exists and is not a character device. Refusing "
3794                 "to continue".format(name)
3795             )
3796         elif not __salt__["file.is_chrdev"](name):
3797             if __opts__["test"]:
3798                 ret["comment"] = "Character device {} is set to be created".format(name)
3799                 ret["result"] = None
3800             else:
3801                 ret = __salt__["file.mknod"](
3802                     name, ntype, major, minor, user, group, mode
3803                 )
3804         else:
3805             devmaj, devmin = __salt__["file.get_devmm"](name)
3806             if (major, minor) != (devmaj, devmin):
3807                 ret["comment"] = (
3808                     "Character device {} exists and has a different "
3809                     "major/minor {}/{}. Refusing to continue".format(
3810                         name, devmaj, devmin
3811                     )
3812                 )
3813             else:
3814                 ret = __salt__["file.check_perms"](name, None, user, group, mode)[0]
3815                 if not ret["changes"]:
3816                     ret[
3817                         "comment"
3818                     ] = "Character device {} is in the correct state".format(name)
3819     elif ntype == "b":
3820         if __salt__["file.file_exists"](name):
3821             ret[
3822                 "comment"
3823             ] = "File {} exists and is not a block device. Refusing to continue".format(
3824                 name
3825             )
3826         elif not __salt__["file.is_blkdev"](name):
3827             if __opts__["test"]:
3828                 ret["comment"] = "Block device {} is set to be created".format(name)
3829                 ret["result"] = None
3830             else:
3831                 ret = __salt__["file.mknod"](
3832                     name, ntype, major, minor, user, group, mode
3833                 )
3834         else:
3835             devmaj, devmin = __salt__["file.get_devmm"](name)
3836             if (major, minor) != (devmaj, devmin):
3837                 ret["comment"] = (
3838                     "Block device {} exists and has a different major/minor "
3839                     "{}/{}. Refusing to continue".format(name, devmaj, devmin)
3840                 )
3841             else:
3842                 ret = __salt__["file.check_perms"](name, None, user, group, mode)[0]
3843                 if not ret["changes"]:
3844                     ret["comment"] = "Block device {} is in the correct state".format(
3845                         name
3846                     )
3847     elif ntype == "p":
3848         if __salt__["file.file_exists"](name):
3849             ret[
3850                 "comment"
3851             ] = "File {} exists and is not a fifo pipe. Refusing to continue".format(
3852                 name
3853             )
3854         elif not __salt__["file.is_fifo"](name):
3855             if __opts__["test"]:
3856                 ret["comment"] = "Fifo pipe {} is set to be created".format(name)
3857                 ret["result"] = None
3858             else:
3859                 ret = __salt__["file.mknod"](
3860                     name, ntype, major, minor, user, group, mode
3861                 )
3862         else:
3863             ret = __salt__["file.check_perms"](name, None, user, group, mode)[0]
3864             if not ret["changes"]:
3865                 ret["comment"] = "Fifo pipe {} is in the correct state".format(name)
3866     else:
3867         ret["comment"] = (
3868             "Node type unavailable: '{}'. Available node types are "
3869             "character ('c'), block ('b'), and pipe ('p')".format(ntype)
3870         )
3871     return ret
3872 def mod_run_check_cmd(cmd, filename, **check_cmd_opts):
3873     log.debug("running our check_cmd")
3874     _cmd = "{} {}".format(cmd, filename)
3875     cret = __salt__["cmd.run_all"](_cmd, **check_cmd_opts)
3876     if cret["retcode"] != 0:
3877         ret = {
3878             "comment": "check_cmd execution failed",
3879             "skip_watch": True,
3880             "result": False,
3881         }
3882         if cret.get("stdout"):
3883             ret["comment"] += "\n" + cret["stdout"]
3884         if cret.get("stderr"):
3885             ret["comment"] += "\n" + cret["stderr"]
3886         return ret
3887     return True
3888 def decode(
3889     name,
3890     encoded_data=None,
3891     contents_pillar=None,
3892     encoding_type="base64",
3893     checksum="md5",
3894 ):
3895     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
3896     if not (encoded_data or contents_pillar):
3897         raise CommandExecutionError(
3898             "Specify either the 'encoded_data' or 'contents_pillar' argument."
3899         )
3900     elif encoded_data and contents_pillar:
3901         raise CommandExecutionError(
3902             "Specify only one 'encoded_data' or 'contents_pillar' argument."
3903         )
3904     elif encoded_data:
3905         content = encoded_data
3906     elif contents_pillar:
3907         content = __salt__["pillar.get"](contents_pillar, False)
3908         if content is False:
3909             raise CommandExecutionError("Pillar data not found.")
3910     else:
3911         raise CommandExecutionError("No contents given.")
3912     dest_exists = __salt__["file.file_exists"](name)
3913     if dest_exists:
3914         instr = __salt__["hashutil.base64_decodestring"](content)
3915         insum = __salt__["hashutil.digest"](instr, checksum)
3916         del instr  # no need to keep in-memory after we have the hash
3917         outsum = __salt__["hashutil.digest_file"](name, checksum)
3918         if insum != outsum:
3919             ret["changes"] = {
3920                 "old": outsum,
3921                 "new": insum,
3922             }
3923         if not ret["changes"]:
3924             ret["comment"] = "File is in the correct state."
3925             ret["result"] = True
3926             return ret
3927     if __opts__["test"] is True:
3928         ret["comment"] = "File is set to be updated."
3929         ret["result"] = None
3930         return ret
3931     ret["result"] = __salt__["hashutil.base64_decodefile"](content, name)
3932     ret["comment"] = "File was updated."
3933     if not ret["changes"]:
3934         ret["changes"] = {
3935             "old": None,
3936             "new": __salt__["hashutil.digest_file"](name, checksum),
3937         }
3938     return ret
3939 def shortcut(
3940     name,
3941     target,
3942     arguments=None,
3943     working_dir=None,
3944     description=None,
3945     icon_location=None,
3946     force=False,
3947     backupname=None,
3948     makedirs=False,
3949     user=None,
3950     **kwargs
3951 ):
3952     user = _test_owner(kwargs, user=user)
3953     ret = {"name": name, "changes": {}, "result": True, "comment": ""}
3954     if not salt.utils.platform.is_windows():
3955         return _error(ret, "Shortcuts are only supported on Windows")
3956     if not name:
3957         return _error(ret, "Must provide name to file.shortcut")
3958     if not name.endswith(".lnk") and not name.endswith(".url"):
3959         return _error(ret, 'Name must end with either ".lnk" or ".url"')
3960     name = os.path.realpath(os.path.expanduser(name))
3961     if name.endswith(".lnk"):
3962         target = os.path.realpath(os.path.expanduser(target))
3963     if working_dir:
3964         working_dir = os.path.realpath(os.path.expanduser(working_dir))
3965     if icon_location:
3966         icon_location = os.path.realpath(os.path.expanduser(icon_location))
3967     if user is None:
3968         user = __opts__["user"]
3969     if not __salt__["user.info"](user):
3970         user = __salt__["user.current"]()
3971         if not user:
3972             user = "SYSTEM"
3973     preflight_errors = []
3974     uid = __salt__["file.user_to_uid"](user)
3975     if uid == "":
3976         preflight_errors.append("User {} does not exist".format(user))
3977     if not os.path.isabs(name):
3978         preflight_errors.append(
3979             "Specified file {} is not an absolute path".format(name)
3980         )
3981     if preflight_errors:
3982         msg = ". ".join(preflight_errors)
3983         if len(preflight_errors) &gt; 1:
3984             msg += "."
3985         return _error(ret, msg)
3986     tresult, tcomment, tchanges = _shortcut_check(
3987         name, target, arguments, working_dir, description, icon_location, force, user
3988     )
3989     if __opts__["test"]:
3990         ret["result"] = tresult
3991         ret["comment"] = tcomment
3992         ret["changes"] = tchanges
3993         return ret
3994     if not os.path.isdir(os.path.dirname(name)):
3995         if makedirs:
3996             try:
3997                 _makedirs(name=name, user=user)
3998             except CommandExecutionError as exc:
3999                 return _error(ret, "Drive {} is not mapped".format(exc.message))
4000         else:
4001             return _error(
4002                 ret,
4003                 'Directory "{}" for shortcut is not present'.format(
4004                     os.path.dirname(name)
4005                 ),
4006             )
4007     if os.path.isdir(name) or os.path.islink(name):
4008         if backupname is not None:
4009             if os.path.lexists(backupname):
4010                 if not force:
4011                     return _error(
4012                         ret,
4013                         "File exists where the backup target {} should go".format(
4014                             backupname
4015                         ),
4016                     )
4017                 else:
4018                     __salt__["file.remove"](backupname)
4019                     time.sleep(1)  # wait for asynchronous deletion
4020             if not os.path.isdir(os.path.dirname(backupname)):
4021                 if makedirs:
4022                     try:
4023                         _makedirs(name=backupname)
4024                     except CommandExecutionError as exc:
4025                         return _error(ret, "Drive {} is not mapped".format(exc.message))
4026                 else:
4027                     return _error(
4028                         ret,
4029                         'Directory does not exist for backup at "{}"'.format(
4030                             os.path.dirname(backupname)
4031                         ),
4032                     )
4033             os.rename(name, backupname)
4034             time.sleep(1)  # wait for asynchronous rename
4035         elif force:
4036             __salt__["file.remove"](name)
4037             ret["changes"]["forced"] = "Shortcut was forcibly replaced"
4038             time.sleep(1)  # wait for asynchronous deletion
4039         else:
4040             return _error(
4041                 ret,
4042                 'Directory or symlink exists where the shortcut "{}" should be'.format(
4043                     name
4044                 ),
4045             )
4046     with salt.utils.winapi.Com():
4047         shell = win32com.client.Dispatch("WScript.Shell")
4048         scut = shell.CreateShortcut(name)
4049         state_checks = [scut.TargetPath.lower() == target.lower()]
4050         if arguments is not None:
4051             state_checks.append(scut.Arguments == arguments)
4052         if working_dir is not None:
4053             state_checks.append(scut.WorkingDirectory.lower() == working_dir.lower())
4054         if description is not None:
4055             state_checks.append(scut.Description == description)
4056         if icon_location is not None:
4057             state_checks.append(scut.IconLocation.lower() == icon_location.lower())
4058         if __salt__["file.file_exists"](name):
4059             if not all(state_checks):
4060                 os.remove(name)
4061             else:
4062                 if _check_shortcut_ownership(name, user):
4063                     ret["comment"] = "Shortcut {} is present and owned by {}".format(
4064                         name, user
4065                     )
4066                 else:
4067                     if _set_shortcut_ownership(name, user):
4068                         ret["comment"] = "Set ownership of shortcut {} to {}".format(
4069                             name, user
4070                         )
4071                         ret["changes"]["ownership"] = "{}".format(user)
4072                     else:
4073                         ret["result"] = False
4074                         ret[
4075                             "comment"
4076                         ] += "Failed to set ownership of shortcut {} to {}".format(
4077                             name, user
4078                         )
4079                 return ret
4080         if not os.path.exists(name):
4081             try:
4082                 scut.TargetPath = target
4083                 if arguments is not None:
4084                     scut.Arguments = arguments
4085                 if working_dir is not None:
4086                     scut.WorkingDirectory = working_dir
4087                 if description is not None:
4088                     scut.Description = description
4089                 if icon_location is not None:
4090                     scut.IconLocation = icon_location
4091                 scut.Save()
4092             except (AttributeError, pywintypes.com_error) as exc:
4093                 ret["result"] = False
4094                 ret["comment"] = "Unable to create new shortcut {} -&gt; {}: {}".format(
4095                     name, target, exc
4096                 )
4097                 return ret
4098             else:
4099                 ret["comment"] = "Created new shortcut {} -&gt; {}".format(name, target)
4100                 ret["changes"]["new"] = name
4101             if not _check_shortcut_ownership(name, user):
4102                 if not _set_shortcut_ownership(name, user):
4103                     ret["result"] = False
4104                     ret["comment"] += ", but was unable to set ownership to {}".format(
4105                         user
4106                     )
4107     return ret
4108 def cached(
4109     name,
4110     source_hash="",
4111     source_hash_name=None,
4112     skip_verify=False,
4113     saltenv="base",
4114     use_etag=False,
4115 ):
4116     ret = {"changes": {}, "comment": "", "name": name, "result": False}
4117     try:
4118         parsed = urllib.parse.urlparse(name)
4119     except Exception:  # pylint: disable=broad-except
4120         ret["comment"] = "Only URLs or local file paths are valid input"
4121         return ret
4122     if (
4123         not skip_verify
4124         and not source_hash
4125         and not use_etag
4126         and parsed.scheme in salt.utils.files.REMOTE_PROTOS
4127     ):
4128         ret["comment"] = (
4129             "Unable to verify upstream hash of source file {}, please set "
4130             "source_hash or set skip_verify or use_etag to True".format(
4131                 salt.utils.url.redact_http_basic_auth(name)
4132             )
4133         )
4134         return ret
4135     if source_hash:
4136         try:
4137             source_sum = __salt__["file.get_source_sum"](
4138                 source=name,
4139                 source_hash=source_hash,
4140                 source_hash_name=source_hash_name,
4141                 saltenv=saltenv,
4142             )
4143         except CommandExecutionError as exc:
4144             ret["comment"] = exc.strerror
4145             return ret
4146         else:
4147             if not source_sum:
4148                 ret["comment"] = (
4149                     "Failed to get source hash from {}. This may be a bug. "
4150                     "If this error persists, please report it and set "
4151                     "skip_verify to True to work around it.".format(source_hash)
4152                 )
4153                 return ret
4154     else:
4155         source_sum = {}
4156     if parsed.scheme in salt.utils.files.LOCAL_PROTOS:
4157         full_path = os.path.realpath(os.path.expanduser(parsed.path))
4158         if os.path.exists(full_path):
4159             if not skip_verify and source_sum:
4160                 local_hash = __salt__["file.get_hash"](
4161                     full_path, source_sum.get("hash_type", __opts__["hash_type"])
4162                 )
4163                 if local_hash == source_sum["hsum"]:
4164                     ret["result"] = True
4165                     ret[
4166                         "comment"
4167                     ] = "File {} is present on the minion and has hash {}".format(
4168                         full_path, local_hash
4169                     )
4170                 else:
4171                     ret["comment"] = (
4172                         "File {} is present on the minion, but the hash ({}) "
4173                         "does not match the specified hash ({})".format(
4174                             full_path, local_hash, source_sum["hsum"]
4175                         )
4176                     )
4177                 return ret
4178             else:
4179                 ret["result"] = True
4180                 ret["comment"] = "File {} is present on the minion".format(full_path)
4181                 return ret
4182         else:
4183             ret["comment"] = "File {} is not present on the minion".format(full_path)
4184             return ret
4185     local_copy = __salt__["cp.is_cached"](name, saltenv=saltenv)
4186     if local_copy:
4187         pre_hash = __salt__["file.get_hash"](
4188             local_copy, source_sum.get("hash_type", __opts__["hash_type"])
4189         )
4190         if not skip_verify and source_sum:
4191             if pre_hash == source_sum["hsum"]:
4192                 ret["result"] = True
4193                 ret["comment"] = "File is already cached to {} with hash {}".format(
4194                     local_copy, pre_hash
4195                 )
4196     else:
4197         pre_hash = None
4198     try:
4199         local_copy = __salt__["cp.cache_file"](
4200             name, saltenv=saltenv, source_hash=source_sum.get("hsum"), use_etag=use_etag
4201         )
4202     except Exception as exc:  # pylint: disable=broad-except
4203         ret["comment"] = salt.utils.url.redact_http_basic_auth(exc.__str__())
4204         return ret
4205     if not local_copy:
4206         ret[
4207             "comment"
4208         ] = "Failed to cache {}, check minion log for more information".format(
4209             salt.utils.url.redact_http_basic_auth(name)
4210         )
4211         return ret
4212     post_hash = __salt__["file.get_hash"](
4213         local_copy, source_sum.get("hash_type", __opts__["hash_type"])
4214     )
4215     if pre_hash != post_hash:
4216         ret["changes"]["hash"] = {"old": pre_hash, "new": post_hash}
4217     if not skip_verify and source_sum:
4218         if post_hash == source_sum["hsum"]:
4219             ret["result"] = True
4220             ret["comment"] = "File is already cached to {} with hash {}".format(
4221                 local_copy, post_hash
4222             )
4223         else:
4224             ret["comment"] = (
4225                 "File is cached to {}, but the hash ({}) does not match "
4226                 "the specified hash ({})".format(
4227                     local_copy, post_hash, source_sum["hsum"]
4228                 )
4229             )
4230         return ret
4231     ret["result"] = True
4232     ret["comment"] = "File is cached to {}".format(local_copy)
4233     return ret
4234 def not_cached(name, saltenv="base"):
4235     ret = {"changes": {}, "comment": "", "name": name, "result": False}
4236     try:
4237         parsed = urllib.parse.urlparse(name)
4238     except Exception:  # pylint: disable=broad-except
4239         ret["comment"] = "Only URLs or local file paths are valid input"
4240         return ret
4241     else:
4242         if parsed.scheme in salt.utils.files.LOCAL_PROTOS:
4243             full_path = os.path.realpath(os.path.expanduser(parsed.path))
4244             ret["result"] = True
4245             ret["comment"] = "File {} is a local path, no action taken".format(
4246                 full_path
4247             )
4248             return ret
4249     local_copy = __salt__["cp.is_cached"](name, saltenv=saltenv)
4250     if local_copy:
4251         try:
4252             os.remove(local_copy)
4253         except Exception as exc:  # pylint: disable=broad-except
4254 <a name="1"></a>            ret["comment"] = "Failed to delete {}: {}".format(local_copy, exc.__str__())
4255         else:
4256             ret["result"] = True
4257             ret<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["changes"]["deleted"] = True
4258             ret["comment"] = "{} was deleted".format(local_copy)
4259     else:
4260         ret["result"] = True
4261         ret["comment"] = "{} is not cached".format(name)
4262     return</b></font> ret
4263 def mod_beacon(name, **kwargs):
4264     sfun = kwargs.pop("sfun", None)
4265     supported_funcs = ["managed", "directory"]
4266     if sfun in supported_funcs:
4267         if kwargs.get("beacon"):
4268             beacon_module = "inotify"
4269             data = {}
4270             _beacon_data = kwargs.get("beacon_data", {})
4271             default_mask = ["create", "delete", "modify"]
4272             data["mask"] = _beacon_data.get("mask", default_mask)
4273             if sfun == "directory":
4274                 data["auto_add"] = _beacon_data.get("auto_add", True)
4275                 data["recurse"] = _beacon_data.get("recurse", True)
4276                 data["exclude"] = _beacon_data.get("exclude", [])
4277             beacon_name = "beacon_{}_{}".format(beacon_module, name)
4278             beacon_kwargs = {
4279                 "name": beacon_name,
4280                 "files": {name: data},
4281                 "interval": _beacon_data.get("interval", 60),
4282                 "coalesce": _beacon_data.get("coalesce", False),
4283                 "beacon_module": beacon_module,
4284             }
4285             ret = __states__["beacon.present"](**beacon_kwargs)
4286             return ret
4287         else:
4288             return {
4289                 "name": name,
4290                 "changes": {},
4291                 "comment": "Not adding beacon.",
4292                 "result": True,
4293             }
4294     else:
4295         return {
4296             "name": name,
4297             "changes": {},
4298             "comment": "file.{} does not work with the beacon state function".format(
4299                 sfun
4300             ),
4301             "result": False,
4302         }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
