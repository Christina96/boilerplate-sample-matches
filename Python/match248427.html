<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for rbenv.py &amp; file_2.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for rbenv.py &amp; file_2.py
      </h3>
<h1 align="center">
        1.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>rbenv.py (17.96875%)<th>file_2.py (0.5757917%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(218-243)<td><a href="#" name="0">(5024-5041)</a><td align="center"><font color="#ff0000">19</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(200-206)<td><a href="#" name="1">(8887-8892)</a><td align="center"><font color="#c90000">15</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(246-252)<td><a href="#" name="2">(5224-5230)</a><td align="center"><font color="#a10000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>rbenv.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import re
3 def _check_rbenv(ret, user=None):
4     if not __salt__["rbenv.is_installed"](user):
5         ret["result"] = False
6         ret["comment"] = "Rbenv is not installed."
7     return ret
8 def _ruby_installed(ret, ruby, user=None):
9     default = __salt__["rbenv.default"](runas=user)
10     for version in __salt__["rbenv.versions"](user):
11         if version == ruby:
12             ret["result"] = True
13             ret["comment"] = "Requested ruby exists"
14             ret["default"] = default == ruby
15             break
16     return ret
17 def _check_and_install_ruby(ret, ruby, default=False, user=None):
18     ret = _ruby_installed(ret, ruby, user=user)
19     if not ret["result"]:
20         if __salt__["rbenv.install_ruby"](ruby, runas=user):
21             ret["result"] = True
22             ret["changes"][ruby] = "Installed"
23             ret["comment"] = "Successfully installed ruby"
24             ret["default"] = default
25         else:
26             ret["result"] = False
27             ret["comment"] = "Failed to install ruby"
28             return ret
29     if default:
30         __salt__["rbenv.default"](ruby, runas=user)
31     return ret
32 def installed(name, default=False, user=None):
33     ret = {"name": name, "result": None, "comment": "", "changes": {}}
34     rbenv_installed_ret = copy.deepcopy(ret)
35     if name.startswith("ruby-"):
36         name = re.sub(r"^ruby-", "", name)
37     if __opts__["test"]:
38         ret = _ruby_installed(ret, name, user=user)
39         if not ret["result"]:
40             ret["comment"] = "Ruby {} is set to be installed".format(name)
41         else:
42             ret["comment"] = "Ruby {} is already installed".format(name)
43         return ret
44     rbenv_installed_ret = _check_and_install_rbenv(rbenv_installed_ret, user)
45     if rbenv_installed_ret["result"] is False:
46         ret["result"] = False
47         ret["comment"] = "Rbenv failed to install"
48         return ret
49     else:
50         return _check_and_install_ruby(ret, name, default, user=user)
51 def _check_and_uninstall_ruby(ret, ruby, user=None):
52     ret = _ruby_installed(ret, ruby, user=user)
53     if ret["result"]:
54         if ret["default"]:
55             __salt__["rbenv.default"]("system", runas=user)
56         if __salt__["rbenv.uninstall_ruby"](ruby, runas=user):
57             ret["result"] = True
58             ret["changes"][ruby] = "Uninstalled"
59             ret["comment"] = "Successfully removed ruby"
60             return ret
61         else:
62             ret["result"] = False
63             ret["comment"] = "Failed to uninstall ruby"
64             return ret
65     else:
66         ret["result"] = True
67         ret["comment"] = "Ruby {} is already absent".format(ruby)
68     return ret
69 def absent(name, user=None):
70     ret = {"name": name, "result": None, "comment": "", "changes": {}}
71     if name.startswith("ruby-"):
72         name = re.sub(r"^ruby-", "", name)
73     ret = _check_rbenv(ret, user)
74     if ret["result"] is False:
75         ret["result"] = True
76         ret["comment"] = "Rbenv not installed, {} not either".format(name)
77         return ret
78         if __opts__["test"]:
79             ret = _ruby_installed(ret, name, user=user)
80             if ret<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["result"]:
81                 ret["result"] = None
82                 ret["comment"] = "Ruby {} is set to be uninstalled".format(name)
83             else:
84                 ret["result"] = True
85                 ret["comment"] = "Ruby {} is already uninstalled".format(name)
86             return</b></font> ret
87         return _check_and_uninstall_ruby(ret, name, user=user)
88 def _check_and_install_rbenv(ret, user=None):
89     if ret["result"] is False:
90         if __salt__["rbenv.install"](user):
91             ret<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["result"] = True
92             ret["comment"] = "Rbenv installed"
93         else:
94             ret["result"] = False
95             ret["comment"] = "Rbenv failed to install"
96     else:
97         ret["result"] = True
98         ret["comment"] = "Rbenv is already installed"
99     return ret
100 def install_rbenv(name, user=None):
101     if __opts__["test"]:
102         ret = _check_rbenv(ret, user<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=user)
103         if ret["result"] is False:
104             ret["result"] = None
105             ret["comment"] = "Rbenv is set to be installed"
106         else:
107             ret["result"] = True
108             ret["comment"] =</b></font> "Rbenv is already installed"
109         return ret
110     return _check_and_install_rbenv(ret, user)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>file_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import difflib
3 import itertools
4 import logging
5 import os
6 import posixpath
7 import re
8 import shutil
9 import sys
10 import time
11 import traceback
12 import urllib.parse
13 from collections import defaultdict
14 from collections.abc import Iterable, Mapping
15 from datetime import date, datetime  # python3 problem in the making?
16 from itertools import zip_longest
17 import salt.loader
18 import salt.payload
19 import salt.utils.data
20 import salt.utils.dateutils
21 import salt.utils.dictupdate
22 import salt.utils.files
23 import salt.utils.hashutils
24 import salt.utils.path
25 import salt.utils.platform
26 import salt.utils.stringutils
27 import salt.utils.templates
28 import salt.utils.url
29 import salt.utils.versions
30 from salt.exceptions import CommandExecutionError
31 from salt.serializers import DeserializationError
32 from salt.state import get_accumulator_dir as _get_accumulator_dir
33 from salt.utils.odict import OrderedDict
34 if salt.utils.platform.is_windows():
35     import salt.utils.win_dacl
36     import salt.utils.win_functions
37     import salt.utils.winapi
38 if salt.utils.platform.is_windows():
39     import pywintypes
40     import win32com.client
41 log = logging.getLogger(__name__)
42 COMMENT_REGEX = r"^([[:space:]]*){0}[[:space:]]?"
43 __NOT_FOUND = object()
44 __func_alias__ = {
45     "copy_": "copy",
46 }
47 def _get_accumulator_filepath():
48     return os.path.join(_get_accumulator_dir(__opts__["cachedir"]), __instance_id__)
49 def _load_accumulators():
50     def _deserialize(path):
51         ret = {"accumulators": {}, "accumulators_deps": {}}
52         try:
53             with salt.utils.files.fopen(path, "rb") as f:
54                 loaded = salt.payload.load(f)
55                 return loaded if loaded else ret
56         except (OSError, NameError):
57             return ret
58     loaded = _deserialize(_get_accumulator_filepath())
59     return loaded["accumulators"], loaded["accumulators_deps"]
60 def _persist_accummulators(accumulators, accumulators_deps):
61     accumm_data = {"accumulators": accumulators, "accumulators_deps": accumulators_deps}
62     try:
63         with salt.utils.files.fopen(_get_accumulator_filepath(), "w+b") as f:
64             salt.payload.dump(accumm_data, f)
65     except NameError:
66         pass
67 def _check_user(user, group):
68     err = ""
69     if user:
70         uid = __salt__["file.user_to_uid"](user)
71         if uid == "":
72             err += "User {} is not available ".format(user)
73     if group:
74         gid = __salt__["file.group_to_gid"](group)
75         if gid == "":
76             err += "Group {} is not available".format(group)
77     return err
78 def _is_valid_relpath(relpath, maxdepth=None):
79     sep, pardir = posixpath.sep, posixpath.pardir
80     if sep + pardir + sep in sep + relpath + sep:
81         return False
82     if maxdepth is not None:
83         path_depth = relpath.strip(sep).count(sep)
84         if path_depth &gt; maxdepth:
85             return False
86     return True
87 def _salt_to_os_path(path):
88     return os.path.normpath(path.replace(posixpath.sep, os.path.sep))
89 def _gen_recurse_managed_files(
90     name,
91     source,
92     keep_symlinks=False,
93     include_pat=None,
94     exclude_pat=None,
95     maxdepth=None,
96     include_empty=False,
97     **kwargs
98 ):
99     def full_path(master_relpath):
100         return os.path.join(name, _salt_to_os_path(master_relpath))
101     def process_symlinks(filenames, symlinks):
102         for lname, ltarget in symlinks.items():
103             srelpath = posixpath.relpath(lname, srcpath)
104             if not _is_valid_relpath(srelpath, maxdepth=maxdepth):
105                 continue
106             if not salt.utils.stringutils.check_include_exclude(
107                 srelpath, include_pat, exclude_pat
108             ):
109                 continue
110             _filenames = list(filenames)
111             for filename in _filenames:
112                 if filename.startswith(lname + os.sep):
113                     log.debug(
114                         "** skipping file ** %s, it intersects a symlink", filename
115                     )
116                     filenames.remove(filename)
117             managed_symlinks.add((srelpath, ltarget))
118             keep.add(full_path(srelpath))
119         vdir.update(keep)
120         return filenames
121     managed_files = set()
122     managed_directories = set()
123     managed_symlinks = set()
124     keep = set()
125     vdir = set()
126     srcpath, senv = salt.utils.url.parse(source)
127     if senv is None:
128         senv = __env__
129     if not srcpath.endswith(posixpath.sep):
130         srcpath = srcpath + posixpath.sep
131     fns_ = __salt__["cp.list_master"](senv, srcpath)
132     if keep_symlinks:
133         symlinks = __salt__["cp.list_master_symlinks"](senv, srcpath)
134         fns_ = process_symlinks(fns_, symlinks)
135     for fn_ in fns_:
136         if not fn_.strip():
137             continue
138         relname = salt.utils.data.decode(posixpath.relpath(fn_, srcpath))
139         if not _is_valid_relpath(relname, maxdepth=maxdepth):
140             continue
141         if not salt.utils.stringutils.check_include_exclude(
142             relname, include_pat, exclude_pat
143         ):
144             continue
145         dest = full_path(relname)
146         dirname = os.path.dirname(dest)
147         keep.add(dest)
148         if dirname not in vdir:
149             managed_directories.add(dirname)
150             vdir.add(dirname)
151         src = salt.utils.url.create(fn_, saltenv=senv)
152         managed_files.add((dest, src))
153     if include_empty:
154         mdirs = __salt__["cp.list_master_dirs"](senv, srcpath)
155         for mdir in mdirs:
156             relname = posixpath.relpath(mdir, srcpath)
157             if not _is_valid_relpath(relname, maxdepth=maxdepth):
158                 continue
159             if not salt.utils.stringutils.check_include_exclude(
160                 relname, include_pat, exclude_pat
161             ):
162                 continue
163             mdest = full_path(relname)
164             if keep_symlinks:
165                 islink = False
166                 for link in symlinks:
167                     if mdir.startswith(link + os.sep, 0):
168                         log.debug(
169                             "** skipping empty dir ** %s, it intersects a symlink", mdir
170                         )
171                         islink = True
172                         break
173                 if islink:
174                     continue
175             managed_directories.add(mdest)
176             keep.add(mdest)
177     return managed_files, managed_directories, managed_symlinks, keep
178 def _gen_keep_files(name, require, walk_d=None):
179     def _is_child(path, directory):
180         path = os.path.abspath(path)
181         directory = os.path.abspath(directory)
182         relative = os.path.relpath(path, directory)
183         return not relative.startswith(os.pardir)
184     def _add_current_path(path):
185         _ret = set()
186         if os.path.isdir(path):
187             dirs, files = walk_d.get(path, ((), ()))
188             _ret.add(path)
189             for _name in files:
190                 _ret.add(os.path.join(path, _name))
191             for _name in dirs:
192                 _ret.add(os.path.join(path, _name))
193         return _ret
194     def _process_by_walk_d(name, ret):
195         if os.path.isdir(name):
196             walk_ret.update(_add_current_path(name))
197             dirs, _ = walk_d.get(name, ((), ()))
198             for _d in dirs:
199                 p = os.path.join(name, _d)
200                 walk_ret.update(_add_current_path(p))
201                 _process_by_walk_d(p, ret)
202     def _process(name):
203         ret = set()
204         if os.path.isdir(name):
205             for root, dirs, files in salt.utils.path.os_walk(name):
206                 ret.add(name)
207                 for name in files:
208                     ret.add(os.path.join(root, name))
209                 for name in dirs:
210                     ret.add(os.path.join(root, name))
211         return ret
212     keep = set()
213     if isinstance(require, list):
214         required_files = [comp for comp in require if "file" in comp]
215         for comp in required_files:
216             for low in __lowstate__:
217                 if low["name"] == comp["file"] or low["__id__"] == comp["file"]:
218                     fn = low["name"]
219                     fun = low["fun"]
220                     if os.path.isdir(fn):
221                         if _is_child(fn, name):
222                             if fun == "recurse":
223                                 fkeep = _gen_recurse_managed_files(**low)[3]
224                                 log.debug("Keep from %s: %s", fn, fkeep)
225                                 keep.update(fkeep)
226                             elif walk_d:
227                                 walk_ret = set()
228                                 _process_by_walk_d(fn, walk_ret)
229                                 keep.update(walk_ret)
230                             else:
231                                 keep.update(_process(fn))
232                     else:
233                         keep.add(fn)
234     log.debug("Files to keep from required states: %s", list(keep))
235     return list(keep)
236 def _check_file(name):
237     ret = True
238     msg = ""
239     if not os.path.isabs(name):
240         ret = False
241         msg = "Specified file {} is not an absolute path".format(name)
242     elif not os.path.exists(name):
243         ret = False
244         msg = "{}: file not found".format(name)
245     return ret, msg
246 def _find_keep_files(root, keep):
247     real_keep = set()
248     real_keep.add(root)
249     if isinstance(keep, list):
250         for fn_ in keep:
251             if not os.path.isabs(fn_):
252                 continue
253             fn_ = os.path.normcase(os.path.abspath(fn_))
254             real_keep.add(fn_)
255             while True:
256                 fn_ = os.path.abspath(os.path.dirname(fn_))
257                 real_keep.add(fn_)
258                 drive, path = os.path.splitdrive(fn_)
259                 if not path.lstrip(os.sep):
260                     break
261     return real_keep
262 def _clean_dir(root, keep, exclude_pat):
263     case_keep = None
264     if salt.utils.files.case_insensitive_filesystem():
265         case_keep = keep
266     root = os.path.normcase(root)
267     real_keep = _find_keep_files(root, keep)
268     removed = set()
269     def _delete_not_kept(nfn):
270         if nfn not in real_keep:
271             if not salt.utils.stringutils.check_include_exclude(
272                 os.path.relpath(nfn, root), None, exclude_pat
273             ):
274                 return
275             if case_keep:
276                 for item in case_keep:
277                     if item.casefold() == nfn.casefold():
278                         return
279             removed.add(nfn)
280             if not __opts__["test"]:
281                 try:
282                     os.remove(nfn)
283                 except OSError:
284                     __salt__["file.remove"](nfn)
285     for roots, dirs, files in salt.utils.path.os_walk(root):
286         for name in itertools.chain(dirs, files):
287             _delete_not_kept(os.path.join(roots, name))
288     return list(removed)
289 def _error(ret, err_msg):
290     ret["result"] = False
291     ret["comment"] = err_msg
292     return ret
293 def _check_directory(
294     name,
295     user=None,
296     group=None,
297     recurse=False,
298     dir_mode=None,
299     file_mode=None,
300     clean=False,
301     require=False,
302     exclude_pat=None,
303     max_depth=None,
304     follow_symlinks=False,
305 ):
306     changes = {}
307     if recurse or clean:
308         assert max_depth is None or not clean
309         walk_l = list(_depth_limited_walk(name, max_depth))
310         walk_d = {}
311         for i in walk_l:
312             walk_d[i[0]] = (i[1], i[2])
313     if recurse:
314         try:
315             recurse_set = _get_recurse_set(recurse)
316         except (TypeError, ValueError) as exc:
317             return False, "{}".format(exc), changes
318         if "user" not in recurse_set:
319             user = None
320         if "group" not in recurse_set:
321             group = None
322         if "mode" not in recurse_set:
323             dir_mode = None
324             file_mode = None
325         check_files = "ignore_files" not in recurse_set
326         check_dirs = "ignore_dirs" not in recurse_set
327         for root, dirs, files in walk_l:
328             if check_files:
329                 for fname in files:
330                     fchange = {}
331                     path = os.path.join(root, fname)
332                     stats = __salt__["file.stats"](path, None, follow_symlinks)
333                     if user is not None and user != stats.get("user"):
334                         fchange["user"] = user
335                     if group is not None and group != stats.get("group"):
336                         fchange["group"] = group
337                     smode = salt.utils.files.normalize_mode(stats.get("mode"))
338                     file_mode = salt.utils.files.normalize_mode(file_mode)
339                     if (
340                         file_mode is not None
341                         and file_mode != smode
342                         and (
343                             follow_symlinks
344                             or stats.get("type") != "link"
345                             or not salt.utils.platform.is_linux()
346                         )
347                     ):
348                         fchange["mode"] = file_mode
349                     if fchange:
350                         changes[path] = fchange
351             if check_dirs:
352                 for name_ in dirs:
353                     path = os.path.join(root, name_)
354                     fchange = _check_dir_meta(
355                         path, user, group, dir_mode, follow_symlinks
356                     )
357                     if fchange:
358                         changes[path] = fchange
359     fchange = _check_dir_meta(name, user, group, dir_mode, follow_symlinks)
360     if fchange:
361         changes[name] = fchange
362     if clean:
363         keep = _gen_keep_files(name, require, walk_d)
364         def _check_changes(fname):
365             path = os.path.join(root, fname)
366             if path in keep:
367                 return {}
368             else:
369                 if not salt.utils.stringutils.check_include_exclude(
370                     os.path.relpath(path, name), None, exclude_pat
371                 ):
372                     return {}
373                 else:
374                     return {path: {"removed": "Removed due to clean"}}
375         for root, dirs, files in walk_l:
376             for fname in files:
377                 changes.update(_check_changes(fname))
378             for name_ in dirs:
379                 changes.update(_check_changes(name_))
380     if not os.path.isdir(name):
381         changes[name] = {"directory": "new"}
382     if changes:
383         comments = ["The following files will be changed:\n"]
384         for fn_ in changes:
385             for key, val in changes[fn_].items():
386                 comments.append("{}: {} - {}\n".format(fn_, key, val))
387         return None, "".join(comments), changes
388     return True, "The directory {} is in the correct state".format(name), changes
389 def _check_directory_win(
390     name,
391     win_owner=None,
392     win_perms=None,
393     win_deny_perms=None,
394     win_inheritance=None,
395     win_perms_reset=None,
396 ):
397     if not os.path.isdir(name):
398         changes = {name: {"directory": "new"}}
399     else:
400         changes = salt.utils.win_dacl.check_perms(
401             obj_name=name,
402             obj_type="file",
403             ret={},
404             owner=win_owner,
405             grant_perms=win_perms,
406             deny_perms=win_deny_perms,
407             inheritance=win_inheritance,
408             reset=win_perms_reset,
409             test_mode=True,
410         )["changes"]
411     if changes:
412         return None, 'The directory "{}" will be changed'.format(name), changes
413     return True, "The directory {} is in the correct state".format(name), changes
414 def _check_dir_meta(name, user, group, mode, follow_symlinks=False):
415     try:
416         stats = __salt__["file.stats"](name, None, follow_symlinks)
417     except CommandExecutionError:
418         stats = {}
419     changes = {}
420     if not stats:
421         changes["directory"] = "new"
422         return changes
423     if user is not None and user != stats["user"] and user != stats.get("uid"):
424         changes["user"] = user
425     if group is not None and group != stats["group"] and group != stats.get("gid"):
426         changes["group"] = group
427     smode = salt.utils.files.normalize_mode(stats["mode"])
428     mode = salt.utils.files.normalize_mode(mode)
429     if (
430         mode is not None
431         and mode != smode
432         and (
433             follow_symlinks
434             or stats.get("type") != "link"
435             or not salt.utils.platform.is_linux()
436         )
437     ):
438         changes["mode"] = mode
439     return changes
440 def _check_touch(name, atime, mtime):
441     ret = {
442         "result": None,
443         "comment": "",
444         "changes": {"new": name},
445     }
446     if not os.path.exists(name):
447         ret["comment"] = "File {} is set to be created".format(name)
448     else:
449         stats = __salt__["file.stats"](name, follow_symlinks=False)
450         if (atime is not None and str(atime) != str(stats["atime"])) or (
451             mtime is not None and str(mtime) != str(stats["mtime"])
452         ):
453             ret["comment"] = "Times set to be updated on file {}".format(name)
454             ret["changes"] = {"touched": name}
455         else:
456             ret["result"] = True
457             ret["comment"] = "File {} exists and has the correct times".format(name)
458     return ret
459 def _get_symlink_ownership(path):
460     if salt.utils.platform.is_windows():
461         owner = salt.utils.win_dacl.get_owner(path)
462         return owner, owner
463     else:
464         return (
465             __salt__["file.get_user"](path, follow_symlinks=False),
466             __salt__["file.get_group"](path, follow_symlinks=False),
467         )
468 def _check_symlink_ownership(path, user, group, win_owner):
469     cur_user, cur_group = _get_symlink_ownership(path)
470     if salt.utils.platform.is_windows():
471         return win_owner == cur_user
472     else:
473         return (cur_user == user) and (cur_group == group)
474 def _set_symlink_ownership(path, user, group, win_owner):
475     if salt.utils.platform.is_windows():
476         try:
477             salt.utils.win_dacl.set_owner(path, win_owner)
478         except CommandExecutionError:
479             pass
480     else:
481         try:
482             __salt__["file.lchown"](path, user, group)
483         except OSError:
484             pass
485     return _check_symlink_ownership(path, user, group, win_owner)
486 def _symlink_check(name, target, force, user, group, win_owner):
487     changes = {}
488     if not os.path.exists(name) and not __salt__["file.is_link"](name):
489         changes["new"] = name
490         return (
491             None,
492             "Symlink {} to {} is set for creation".format(name, target),
493             changes,
494         )
495     if __salt__["file.is_link"](name):
496         if __salt__["file.readlink"](name) != target:
497             changes["change"] = name
498             return (
499                 None,
500                 "Link {} target is set to be changed to {}".format(name, target),
501                 changes,
502             )
503         else:
504             result = True
505             msg = "The symlink {} is present".format(name)
506             if not _check_symlink_ownership(name, user, group, win_owner):
507                 result = None
508                 changes["ownership"] = "{}:{}".format(*_get_symlink_ownership(name))
509                 msg += (
510                     ", but the ownership of the symlink would be changed "
511                     "from {2}:{3} to {0}:{1}".format(
512                         user, group, *_get_symlink_ownership(name)
513                     )
514                 )
515             return result, msg, changes
516     else:
517         if force:
518             return (
519                 None,
520                 "The file or directory {} is set for removal to "
521                 "make way for a new symlink targeting {}".format(name, target),
522                 changes,
523             )
524         return (
525             False,
526             "File or directory exists where the symlink {} "
527             "should be. Did you mean to use force?".format(name),
528             changes,
529         )
530 def _hardlink_same(name, target):
531     res = __salt__["file.stats"](name, None, follow_symlinks=False)
532     if "inode" not in res:
533         return False
534     name_i = res["inode"]
535     res = __salt__["file.stats"](target, None, follow_symlinks=False)
536     if "inode" not in res:
537         return False
538     target_i = res["inode"]
539     return name_i == target_i
540 def _hardlink_check(name, target, force):
541     changes = {}
542     if not os.path.exists(target):
543         msg = "Target {} for hard link does not exist".format(target)
544         return False, msg, changes
545     elif os.path.isdir(target):
546         msg = "Unable to hard link from directory {}".format(target)
547         return False, msg, changes
548     if os.path.isdir(name):
549         msg = "Unable to hard link to directory {}".format(name)
550         return False, msg, changes
551     elif not os.path.exists(name):
552         msg = "Hard link {} to {} is set for creation".format(name, target)
553         changes["new"] = name
554         return None, msg, changes
555     elif __salt__["file.is_hardlink"](name):
556         if _hardlink_same(name, target):
557             msg = "The hard link {} is presently targetting {}".format(name, target)
558             return True, msg, changes
559         msg = "Link {} target is set to be changed to {}".format(name, target)
560         changes["change"] = name
561         return None, msg, changes
562     if force:
563         msg = (
564             "The file or directory {} is set for removal to "
565             "make way for a new hard link targeting {}".format(name, target)
566         )
567         return None, msg, changes
568     msg = (
569         "File or directory exists where the hard link {} "
570         "should be. Did you mean to use force?".format(name)
571     )
572     return False, msg, changes
573 def _test_owner(kwargs, user=None):
574     if user:
575         return user
576     if "owner" in kwargs:
577         log.warning(
578             'Use of argument owner found, "owner" is invalid, please use "user"'
579         )
580         return kwargs["owner"]
581     return user
582 def _unify_sources_and_hashes(
583     source=None, source_hash=None, sources=None, source_hashes=None
584 ):
585     if sources is None:
586         sources = []
587     if source_hashes is None:
588         source_hashes = []
589     if source and sources:
590         return (False, "source and sources are mutually exclusive", [])
591     if source_hash and source_hashes:
592         return (False, "source_hash and source_hashes are mutually exclusive", [])
593     if source:
594         return (True, "", [(source, source_hash)])
595     return True, "", list(zip_longest(sources, source_hashes[: len(sources)]))
596 def _get_template_texts(
597     source_list=None, template="jinja", defaults=None, context=None, **kwargs
598 ):
599     ret = {
600         "name": "_get_template_texts",
601         "changes": {},
602         "result": True,
603         "comment": "",
604         "data": [],
605     }
606     if source_list is None:
607         return _error(ret, "_get_template_texts called with empty source_list")
608     txtl = []
609     for (source, source_hash) in source_list:
610         tmpctx = defaults if defaults else {}
611         if context:
612             tmpctx.update(context)
613         rndrd_templ_fn = __salt__["cp.get_template"](
614             source, "", template=template, saltenv=__env__, context=tmpctx, **kwargs
615         )
616         log.debug(
617             "cp.get_template returned %s (Called with: %s)", rndrd_templ_fn, source
618         )
619         if rndrd_templ_fn:
620             tmplines = None
621             with salt.utils.files.fopen(rndrd_templ_fn, "rb") as fp_:
622                 tmplines = fp_.read()
623                 tmplines = salt.utils.stringutils.to_unicode(tmplines)
624                 tmplines = tmplines.splitlines(True)
625             if not tmplines:
626                 msg = "Failed to read rendered template file {} ({})".format(
627                     rndrd_templ_fn, source
628                 )
629                 log.debug(msg)
630                 ret["name"] = source
631                 return _error(ret, msg)
632             txtl.append("".join(tmplines))
633         else:
634             msg = "Failed to load template file {}".format(source)
635             log.debug(msg)
636             ret["name"] = source
637             return _error(ret, msg)
638     ret["data"] = txtl
639     return ret
640 def _validate_str_list(arg, encoding=None):
641     if isinstance(arg, bytes):
642         ret = [salt.utils.stringutils.to_unicode(arg, encoding=encoding)]
643     elif isinstance(arg, str):
644         ret = [arg]
645     elif isinstance(arg, Iterable) and not isinstance(arg, Mapping):
646         ret = []
647         for item in arg:
648             if isinstance(item, str):
649                 ret.append(item)
650             else:
651                 ret.append(str(item))
652     else:
653         ret = [str(arg)]
654     return ret
655 def _get_shortcut_ownership(path):
656     return __salt__["file.get_user"](path, follow_symlinks=False)
657 def _check_shortcut_ownership(path, user):
658     cur_user = _get_shortcut_ownership(path)
659     return cur_user == user
660 def _set_shortcut_ownership(path, user):
661     try:
662         __salt__["file.lchown"](path, user)
663     except OSError:
664         pass
665     return _check_shortcut_ownership(path, user)
666 def _shortcut_check(
667     name, target, arguments, working_dir, description, icon_location, force, user
668 ):
669     changes = {}
670     if not os.path.exists(name):
671         changes["new"] = name
672         return (
673             None,
674             'Shortcut "{}" to "{}" is set for creation'.format(name, target),
675             changes,
676         )
677     if os.path.isfile(name):
678         with salt.utils.winapi.Com():
679             shell = win32com.client.Dispatch("WScript.Shell")
680             scut = shell.CreateShortcut(name)
681             state_checks = [scut.TargetPath.lower() == target.lower()]
682             if arguments is not None:
683                 state_checks.append(scut.Arguments == arguments)
684             if working_dir is not None:
685                 state_checks.append(
686                     scut.WorkingDirectory.lower() == working_dir.lower()
687                 )
688             if description is not None:
689                 state_checks.append(scut.Description == description)
690             if icon_location is not None:
691                 state_checks.append(scut.IconLocation.lower() == icon_location.lower())
692         if not all(state_checks):
693             changes["change"] = name
694             return (
695                 None,
696                 'Shortcut "{}" target is set to be changed to "{}"'.format(
697                     name, target
698                 ),
699                 changes,
700             )
701         else:
702             result = True
703             msg = 'The shortcut "{}" is present'.format(name)
704             if not _check_shortcut_ownership(name, user):
705                 result = None
706                 changes["ownership"] = "{}".format(_get_shortcut_ownership(name))
707                 msg += (
708                     ", but the ownership of the shortcut would be changed "
709                     "from {1} to {0}".format(user, _get_shortcut_ownership(name))
710                 )
711             return result, msg, changes
712     else:
713         if force:
714             return (
715                 None,
716                 'The link or directory "{}" is set for removal to '
717                 'make way for a new shortcut targeting "{}"'.format(name, target),
718                 changes,
719             )
720         return (
721             False,
722             'Link or directory exists where the shortcut "{}" '
723             "should be. Did you mean to use force?".format(name),
724             changes,
725         )
726 def _makedirs(
727     name,
728     user=None,
729     group=None,
730     dir_mode=None,
731     win_owner=None,
732     win_perms=None,
733     win_deny_perms=None,
734     win_inheritance=None,
735 ):
736     if salt.utils.platform.is_windows():
737         drive, path = os.path.splitdrive(name)
738         if not os.path.isdir(drive):
739             raise CommandExecutionError(drive)
740         win_owner = win_owner if win_owner else user
741         return __salt__["file.makedirs"](
742             path=name,
743             owner=win_owner,
744             grant_perms=win_perms,
745             deny_perms=win_deny_perms,
746             inheritance=win_inheritance,
747         )
748     else:
749         return __salt__["file.makedirs"](
750             path=name, user=user, group=group, mode=dir_mode
751         )
752 def hardlink(
753     name,
754     target,
755     force=False,
756     makedirs=False,
757     user=None,
758     group=None,
759     dir_mode=None,
760     **kwargs
761 ):
762     name = os.path.expanduser(name)
763     dir_mode = salt.utils.files.normalize_mode(dir_mode)
764     user = _test_owner(kwargs, user=user)
765     ret = {"name": name, "changes": {}, "result": True, "comment": ""}
766     if not name:
767         return _error(ret, "Must provide name to file.hardlink")
768     if user is None:
769         user = __opts__["user"]
770     if salt.utils.platform.is_windows():
771         if group is not None:
772             log.warning(
773                 "The group argument for %s has been ignored as this "
774                 "is a Windows system.",
775                 name,
776             )
777         group = user
778     if group is None:
779         if "user.info" in __salt__:
780             group = __salt__["file.gid_to_group"](
781                 __salt__["user.info"](user).get("gid", 0)
782             )
783         else:
784             group = user
785     preflight_errors = []
786     uid = __salt__["file.user_to_uid"](user)
787     gid = __salt__["file.group_to_gid"](group)
788     if uid == "":
789         preflight_errors.append("User {} does not exist".format(user))
790     if gid == "":
791         preflight_errors.append("Group {} does not exist".format(group))
792     if not os.path.isabs(name):
793         preflight_errors.append(
794             "Specified file {} is not an absolute path".format(name)
795         )
796     if not os.path.isabs(target):
797         preflight_errors.append(
798             "Specified target {} is not an absolute path".format(target)
799         )
800     if preflight_errors:
801         msg = ". ".join(preflight_errors)
802         if len(preflight_errors) &gt; 1:
803             msg += "."
804         return _error(ret, msg)
805     if __opts__["test"]:
806         tresult, tcomment, tchanges = _hardlink_check(name, target, force)
807         ret["result"] = tresult
808         ret["comment"] = tcomment
809         ret["changes"] = tchanges
810         return ret
811     for direction, item in zip_longest(["to", "from"], [name, target]):
812         if os.path.isdir(item):
813             msg = "Unable to hard link {} directory {}".format(direction, item)
814             return _error(ret, msg)
815     if not os.path.exists(target):
816         msg = "Target {} for hard link does not exist".format(target)
817         return _error(ret, msg)
818     if not os.path.isdir(os.path.dirname(name)):
819         if makedirs:
820             __salt__["file.makedirs"](name, user=user, group=group, mode=dir_mode)
821         else:
822             return _error(
823                 ret,
824                 "Directory {} for hard link is not present".format(
825                     os.path.dirname(name)
826                 ),
827             )
828     if os.path.isfile(name) and not __salt__["file.is_hardlink"](name):
829         if force:
830             os.remove(name)
831             ret["changes"]["forced"] = "File for hard link was forcibly replaced"
832         else:
833             return _error(
834                 ret, "File exists where the hard link {} should be".format(name)
835             )
836     if __salt__["file.is_hardlink"](name):
837         if _hardlink_same(name, target):
838             ret["result"] = True
839             ret["comment"] = "Target of hard link {} is already pointing to {}".format(
840                 name, target
841             )
842             return ret
843         os.remove(name)
844         try:
845             __salt__["file.link"](target, name)
846         except CommandExecutionError as E:
847             ret["result"] = False
848             ret["comment"] = "Unable to set target of hard link {} -&gt; {}: {}".format(
849                 name, target, E
850             )
851             return ret
852         ret["result"] = True
853         ret["comment"] = "Set target of hard link {} -&gt; {}".format(name, target)
854         ret["changes"]["new"] = name
855     elif not os.path.exists(name):
856         try:
857             __salt__["file.link"](target, name)
858         except CommandExecutionError as E:
859             ret["result"] = False
860             ret["comment"] = "Unable to create new hard link {} -&gt; {}: {}".format(
861                 name, target, E
862             )
863             return ret
864         ret["result"] = True
865         ret["comment"] = "Created new hard link {} -&gt; {}".format(name, target)
866         ret["changes"]["new"] = name
867     return ret
868 def symlink(
869     name,
870     target,
871     force=False,
872     backupname=None,
873     makedirs=False,
874     user=None,
875     group=None,
876     mode=None,
877     win_owner=None,
878     win_perms=None,
879     win_deny_perms=None,
880     win_inheritance=None,
881     **kwargs
882 ):
883     name = os.path.expanduser(name)
884     mode = salt.utils.files.normalize_mode(mode)
885     user = _test_owner(kwargs, user=user)
886     ret = {"name": name, "changes": {}, "result": True, "comment": ""}
887     if not name:
888         return _error(ret, "Must provide name to file.symlink")
889     if user is None:
890         user = __opts__["user"]
891     if salt.utils.platform.is_windows():
892         if not __salt__["user.info"](user):
893             user = __salt__["user.current"]()
894             if not user:
895                 user = "SYSTEM"
896         if win_owner is None:
897             win_owner = user if user else None
898         if group is not None:
899             log.warning(
900                 "The group argument for %s has been ignored as this "
901                 "is a Windows system. Please use the `win_*` parameters to set "
902                 "permissions in Windows.",
903                 name,
904             )
905         group = user
906     if group is None:
907         if "user.info" in __salt__:
908             group = __salt__["file.gid_to_group"](
909                 __salt__["user.info"](user).get("gid", 0)
910             )
911         else:
912             group = user
913     preflight_errors = []
914     if salt.utils.platform.is_windows():
915         try:
916             salt.utils.win_functions.get_sid_from_name(win_owner)
917         except CommandExecutionError as exc:
918             preflight_errors.append("User {} does not exist".format(win_owner))
919         if win_perms:
920             for name_check in win_perms:
921                 try:
922                     salt.utils.win_functions.get_sid_from_name(name_check)
923                 except CommandExecutionError as exc:
924                     preflight_errors.append("User {} does not exist".format(name_check))
925         if win_deny_perms:
926             for name_check in win_deny_perms:
927                 try:
928                     salt.utils.win_functions.get_sid_from_name(name_check)
929                 except CommandExecutionError as exc:
930                     preflight_errors.append("User {} does not exist".format(name_check))
931     else:
932         uid = __salt__["file.user_to_uid"](user)
933         gid = __salt__["file.group_to_gid"](group)
934         if uid == "":
935             preflight_errors.append("User {} does not exist".format(user))
936         if gid == "":
937             preflight_errors.append("Group {} does not exist".format(group))
938     if not os.path.isabs(name):
939         preflight_errors.append(
940             "Specified file {} is not an absolute path".format(name)
941         )
942     if preflight_errors:
943         msg = ". ".join(preflight_errors)
944         if len(preflight_errors) &gt; 1:
945             msg += "."
946         return _error(ret, msg)
947     tresult, tcomment, tchanges = _symlink_check(
948         name, target, force, user, group, win_owner
949     )
950     if not os.path.isdir(os.path.dirname(name)):
951         if makedirs:
952             if __opts__["test"]:
953                 tcomment += "\n{} will be created".format(os.path.dirname(name))
954             else:
955                 try:
956                     _makedirs(
957                         name=name,
958                         user=user,
959                         group=group,
960                         dir_mode=mode,
961                         win_owner=win_owner,
962                         win_perms=win_perms,
963                         win_deny_perms=win_deny_perms,
964                         win_inheritance=win_inheritance,
965                     )
966                 except CommandExecutionError as exc:
967                     return _error(ret, "Drive {} is not mapped".format(exc.message))
968         else:
969             if __opts__["test"]:
970                 tcomment += "\nDirectory {} for symlink is not present".format(
971                     os.path.dirname(name)
972                 )
973             else:
974                 return _error(
975                     ret,
976                     "Directory {} for symlink is not present".format(
977                         os.path.dirname(name)
978                     ),
979                 )
980     if __opts__["test"]:
981         ret["result"] = tresult
982         ret["comment"] = tcomment
983         ret["changes"] = tchanges
984         return ret
985     if __salt__["file.is_link"](name):
986         if os.path.normpath(__salt__["file.readlink"](name)) != os.path.normpath(
987             target
988         ):
989             os.remove(name)
990         else:
991             if _check_symlink_ownership(name, user, group, win_owner):
992                 if salt.utils.platform.is_windows():
993                     ret["comment"] = "Symlink {} is present and owned by {}".format(
994                         name, win_owner
995                     )
996                 else:
997                     ret["comment"] = "Symlink {} is present and owned by {}:{}".format(
998                         name, user, group
999                     )
1000             else:
1001                 if _set_symlink_ownership(name, user, group, win_owner):
1002                     if salt.utils.platform.is_windows():
1003                         ret["comment"] = "Set ownership of symlink {} to {}".format(
1004                             name, win_owner
1005                         )
1006                         ret["changes"]["ownership"] = win_owner
1007                     else:
1008                         ret["comment"] = "Set ownership of symlink {} to {}:{}".format(
1009                             name, user, group
1010                         )
1011                         ret["changes"]["ownership"] = "{}:{}".format(user, group)
1012                 else:
1013                     ret["result"] = False
1014                     if salt.utils.platform.is_windows():
1015                         ret[
1016                             "comment"
1017                         ] += "Failed to set ownership of symlink {} to {}".format(
1018                             name, win_owner
1019                         )
1020                     else:
1021                         ret[
1022                             "comment"
1023                         ] += "Failed to set ownership of symlink {} to {}:{}".format(
1024                             name, user, group
1025                         )
1026             return ret
1027     elif os.path.exists(name):
1028         if backupname is not None:
1029             if not os.path.isabs(backupname):
1030                 if backupname == os.path.basename(backupname):
1031                     backupname = os.path.join(
1032                         os.path.dirname(os.path.normpath(name)), backupname
1033                     )
1034                 else:
1035                     return _error(
1036                         ret,
1037                         "Backupname must be an absolute path or a file name: {}".format(
1038                             backupname
1039                         ),
1040                     )
1041             if os.path.lexists(backupname):
1042                 if not force:
1043                     return _error(
1044                         ret,
1045                         "Symlink &amp; backup dest exists and Force not set. {} -&gt; {} -"
1046                         " backup: {}".format(name, target, backupname),
1047                     )
1048                 else:
1049                     __salt__["file.remove"](backupname)
1050             try:
1051                 __salt__["file.move"](name, backupname)
1052             except Exception as exc:  # pylint: disable=broad-except
1053                 ret["changes"] = {}
1054                 log.debug(
1055                     "Encountered error renaming %s to %s",
1056                     name,
1057                     backupname,
1058                     exc_info=True,
1059                 )
1060                 return _error(
1061                     ret,
1062                     "Unable to rename {} to backup {} -&gt; : {}".format(
1063                         name, backupname, exc
1064                     ),
1065                 )
1066         elif force:
1067             if __salt__["file.is_link"](name):
1068                 __salt__["file.remove"](name)
1069                 ret["changes"]["forced"] = "Symlink was forcibly replaced"
1070             else:
1071                 __salt__["file.remove"](name)
1072         else:
1073             fs_entry_type = (
1074                 "File"
1075                 if os.path.isfile(name)
1076                 else "Directory"
1077                 if os.path.isdir(name)
1078                 else "File system entry"
1079             )
1080             return _error(
1081                 ret,
1082                 "{} exists where the symlink {} should be".format(fs_entry_type, name),
1083             )
1084     if not os.path.exists(name):
1085         try:
1086             __salt__["file.symlink"](target, name)
1087         except OSError as exc:
1088             ret["result"] = False
1089             ret["comment"] = "Unable to create new symlink {} -&gt; {}: {}".format(
1090                 name, target, exc
1091             )
1092             return ret
1093         else:
1094             ret["comment"] = "Created new symlink {} -&gt; {}".format(name, target)
1095             ret["changes"]["new"] = name
1096         if not _check_symlink_ownership(name, user, group, win_owner):
1097             if not _set_symlink_ownership(name, user, group, win_owner):
1098                 ret["result"] = False
1099                 ret["comment"] += ", but was unable to set ownership to {}:{}".format(
1100                     user, group
1101                 )
1102     return ret
1103 def absent(name, **kwargs):
1104     name = os.path.expanduser(name)
1105     ret = {"name": name, "changes": {}, "result": True, "comment": ""}
1106     if not name:
1107         return _error(ret, "Must provide name to file.absent")
1108     if not os.path.isabs(name):
1109         return _error(ret, "Specified file {} is not an absolute path".format(name))
1110     if name == "/":
1111         return _error(ret, 'Refusing to make "/" absent')
1112     if os.path.isfile(name) or os.path.islink(name):
1113         if __opts__["test"]:
1114             ret["result"] = None
1115             ret["changes"]["removed"] = name
1116             ret["comment"] = "File {} is set for removal".format(name)
1117             return ret
1118         try:
1119             if salt.utils.platform.is_windows():
1120                 __salt__["file.remove"](name, force=True)
1121             else:
1122                 __salt__["file.remove"](name)
1123             ret["comment"] = "Removed file {}".format(name)
1124             ret["changes"]["removed"] = name
1125             return ret
1126         except CommandExecutionError as exc:
1127             return _error(ret, "{}".format(exc))
1128     elif os.path.isdir(name):
1129         if __opts__["test"]:
1130             ret["result"] = None
1131             ret["changes"]["removed"] = name
1132             ret["comment"] = "Directory {} is set for removal".format(name)
1133             return ret
1134         try:
1135             if salt.utils.platform.is_windows():
1136                 __salt__["file.remove"](name, force=True)
1137             else:
1138                 __salt__["file.remove"](name)
1139             ret["comment"] = "Removed directory {}".format(name)
1140             ret["changes"]["removed"] = name
1141             return ret
1142         except OSError:
1143             return _error(ret, "Failed to remove directory {}".format(name))
1144     ret["comment"] = "File {} is not present".format(name)
1145     return ret
1146 def tidied(name, age=0, matches=None, rmdirs=False, size=0, **kwargs):
1147     name = os.path.expanduser(name)
1148     ret = {"name": name, "changes": {}, "result": True, "comment": ""}
1149     if not os.path.isabs(name):
1150         return _error(ret, "Specified file {} is not an absolute path".format(name))
1151     if not os.path.isdir(name):
1152         return _error(ret, "{} does not exist or is not a directory.".format(name))
1153     todelete = []
1154     today = date.today()
1155     if matches is None:
1156         matches = [".*"]
1157     progs = []
1158     for regex in matches:
1159         progs.append(re.compile(regex))
1160     def _matches(name):
1161         for prog in progs:
1162             if prog.match(name):
1163                 return True
1164         return False
1165     for root, dirs, files in os.walk(top=name, topdown=False):
1166         for elem in files + dirs:
1167             myage = 0
1168             mysize = 0
1169             deleteme = True
1170             path = os.path.join(root, elem)
1171             if os.path.islink(path):
1172                 myage = abs(today - date.fromtimestamp(os.lstat(path).st_atime))
1173             elif elem in dirs:
1174                 myage = abs(today - date.fromtimestamp(os.path.getatime(path)))
1175                 deleteme = rmdirs
1176             else:
1177                 myage = abs(today - date.fromtimestamp(os.path.getatime(path)))
1178                 mysize = os.path.getsize(path)
1179             if (
1180                 (mysize &gt;= size or myage.days &gt;= age)
1181                 and _matches(name=elem)
1182                 and deleteme
1183             ):
1184                 todelete.append(path)
1185     if todelete:
1186         if __opts__["test"]:
1187             ret["result"] = None
1188             ret["comment"] = "{} is set for tidy".format(name)
1189             ret["changes"] = {"removed": todelete}
1190             return ret
1191         ret["changes"]["removed"] = []
1192         try:
1193             for path in todelete:
1194                 if salt.utils.platform.is_windows():
1195                     __salt__["file.remove"](path, force=True)
1196                 else:
1197                     __salt__["file.remove"](path)
1198                 ret["changes"]["removed"].append(path)
1199         except CommandExecutionError as exc:
1200             return _error(ret, "{}".format(exc))
1201         ret["comment"] = "Removed {} files or directories from directory {}".format(
1202             len(todelete), name
1203         )
1204     else:
1205         ret["comment"] = "Nothing to remove from directory {}".format(name)
1206     return ret
1207 def exists(name, **kwargs):
1208     name = os.path.expanduser(name)
1209     ret = {"name": name, "changes": {}, "result": True, "comment": ""}
1210     if not name:
1211         return _error(ret, "Must provide name to file.exists")
1212     if not os.path.exists(name):
1213         return _error(ret, "Specified path {} does not exist".format(name))
1214     ret["comment"] = "Path {} exists".format(name)
1215     return ret
1216 def missing(name, **kwargs):
1217     name = os.path.expanduser(name)
1218     ret = {"name": name, "changes": {}, "result": True, "comment": ""}
1219     if not name:
1220         return _error(ret, "Must provide name to file.missing")
1221     if os.path.exists(name):
1222         return _error(ret, "Specified path {} exists".format(name))
1223     ret["comment"] = "Path {} is missing".format(name)
1224     return ret
1225 def managed(
1226     name,
1227     source=None,
1228     source_hash="",
1229     source_hash_name=None,
1230     keep_source=True,
1231     user=None,
1232     group=None,
1233     mode=None,
1234     attrs=None,
1235     template=None,
1236     makedirs=False,
1237     dir_mode=None,
1238     context=None,
1239     replace=True,
1240     defaults=None,
1241     backup="",
1242     show_changes=True,
1243     create=True,
1244     contents=None,
1245     tmp_dir="",
1246     tmp_ext="",
1247     contents_pillar=None,
1248     contents_grains=None,
1249     contents_newline=True,
1250     contents_delimiter=":",
1251     encoding=None,
1252     encoding_errors="strict",
1253     allow_empty=True,
1254     follow_symlinks=True,
1255     check_cmd=None,
1256     skip_verify=False,
1257     selinux=None,
1258     win_owner=None,
1259     win_perms=None,
1260     win_deny_perms=None,
1261     win_inheritance=True,
1262     win_perms_reset=False,
1263     verify_ssl=True,
1264     use_etag=False,
1265     **kwargs
1266 ):
1267     r"""
1268     Manage a given file, this function allows for a file to be downloaded from
1269     the salt master and potentially run through a templating system.
1270     name
1271         The location of the file to manage, as an absolute path.
1272     source
1273         The source file to download to the minion, this source file can be
1274         hosted on either the salt master server (``salt://``), the salt minion
1275         local file system (``/``), or on an HTTP or FTP server (``http(s)://``,
1276         ``ftp://``).
1277         Both HTTPS and HTTP are supported as well as downloading directly
1278         from Amazon S3 compatible URLs with both pre-configured and automatic
1279         IAM credentials. (see s3.get state documentation)
1280         File retrieval from Openstack Swift object storage is supported via
1281         swift://container/object_path URLs, see swift.get documentation.
1282         For files hosted on the salt file server, if the file is located on
1283         the master in the directory named spam, and is called eggs, the source
1284         string is salt://spam/eggs. If source is left blank or None
1285         (use ~ in YAML), the file will be created as an empty file and
1286         the content will not be managed. This is also the case when a file
1287         already exists and the source is undefined; the contents of the file
1288         will not be changed or managed. If source is left blank or None, please
1289         also set replaced to False to make your intention explicit.
1290         If the file is hosted on a HTTP or FTP server then the source_hash
1291         argument is also required.
1292         A list of sources can also be passed in to provide a default source and
1293         a set of fallbacks. The first source in the list that is found to exist
1294         will be used and subsequent entries in the list will be ignored. Source
1295         list functionality only supports local files and remote files hosted on
1296         the salt master server or retrievable via HTTP, HTTPS, or FTP.
1297         .. code-block:: yaml
1298             file_override_example:
1299               file.managed:
1300                 - source:
1301                   - salt://file_that_does_not_exist
1302                   - salt://file_that_exists
1303     source_hash
1304         This can be one of the following:
1305             1. a source hash string
1306             2. the URI of a file that contains source hash strings
1307         The function accepts the first encountered long unbroken alphanumeric
1308         string of correct length as a valid hash, in order from most secure to
1309         least secure:
1310         .. code-block:: text
1311             Type    Length
1312             ======  ======
1313             sha512     128
1314             sha384      96
1315             sha256      64
1316             sha224      56
1317             sha1        40
1318             md5         32
1319         **Using a Source Hash File**
1320             The file can contain several checksums for several files. Each line
1321             must contain both the file name and the hash.  If no file name is
1322             matched, the first hash encountered will be used, otherwise the most
1323             secure hash with the correct source file name will be used.
1324             When using a source hash file the source_hash argument needs to be a
1325             url, the standard download urls are supported, ftp, http, salt etc:
1326             Example:
1327             .. code-block:: yaml
1328                 tomdroid-src-0.7.3.tar.gz:
1329                   file.managed:
1330                     - name: /tmp/tomdroid-src-0.7.3.tar.gz
1331                     - source: https://launchpad.net/tomdroid/beta/0.7.3/+download/tomdroid-src-0.7.3.tar.gz
1332                     - source_hash: https://launchpad.net/tomdroid/beta/0.7.3/+download/tomdroid-src-0.7.3.hash
1333             The following lines are all supported formats:
1334             .. code-block:: text
1335                 /etc/rc.conf ef6e82e4006dee563d98ada2a2a80a27
1336                 sha254c8525aee419eb649f0233be91c151178b30f0dff8ebbdcc8de71b1d5c8bcc06a  /etc/resolv.conf
1337                 ead48423703509d37c4a90e6a0d53e143b6fc268
1338             Debian file type ``*.dsc`` files are also supported.
1339         **Inserting the Source Hash in the SLS Data**
1340         The source_hash can be specified as a simple checksum, like so:
1341         .. code-block:: yaml
1342             tomdroid-src-0.7.3.tar.gz:
1343               file.managed:
1344                 - name: /tmp/tomdroid-src-0.7.3.tar.gz
1345                 - source: https://launchpad.net/tomdroid/beta/0.7.3/+download/tomdroid-src-0.7.3.tar.gz
1346                 - source_hash: 79eef25f9b0b2c642c62b7f737d4f53f
1347         .. note::
1348             Releases prior to 2016.11.0 must also include the hash type, like
1349             in the below example:
1350             .. code-block:: yaml
1351                 tomdroid-src-0.7.3.tar.gz:
1352                   file.managed:
1353                     - name: /tmp/tomdroid-src-0.7.3.tar.gz
1354                     - source: https://launchpad.net/tomdroid/beta/0.7.3/+download/tomdroid-src-0.7.3.tar.gz
1355                     - source_hash: md5=79eef25f9b0b2c642c62b7f737d4f53f
1356         Known issues:
1357             If the remote server URL has the hash file as an apparent
1358             sub-directory of the source file, the module will discover that it
1359             has already cached a directory where a file should be cached. For
1360             example:
1361             .. code-block:: yaml
1362                 tomdroid-src-0.7.3.tar.gz:
1363                   file.managed:
1364                     - name: /tmp/tomdroid-src-0.7.3.tar.gz
1365                     - source: https://launchpad.net/tomdroid/beta/0.7.3/+download/tomdroid-src-0.7.3.tar.gz
1366                     - source_hash: https://launchpad.net/tomdroid/beta/0.7.3/+download/tomdroid-src-0.7.3.tar.gz/+md5
1367     source_hash_name
1368         When ``source_hash`` refers to a hash file, Salt will try to find the
1369         correct hash by matching the filename/URI associated with that hash. By
1370         default, Salt will look for the filename being managed. When managing a
1371         file at path ``/tmp/foo.txt``, then the following line in a hash file
1372         would match:
1373         .. code-block:: text
1374             acbd18db4cc2f85cedef654fccc4a4d8    foo.txt
1375         However, sometimes a hash file will include multiple similar paths:
1376         .. code-block:: text
1377             37b51d194a7513e45b56f6524f2d51f2    ./dir1/foo.txt
1378             acbd18db4cc2f85cedef654fccc4a4d8    ./dir2/foo.txt
1379             73feffa4b7f6bb68e44cf984c85f6e88    ./dir3/foo.txt
1380         In cases like this, Salt may match the incorrect hash. This argument
1381         can be used to tell Salt which filename to match, to ensure that the
1382         correct hash is identified. For example:
1383         .. code-block:: yaml
1384             /tmp/foo.txt:
1385               file.managed:
1386                 - source: https://mydomain.tld/dir2/foo.txt
1387                 - source_hash: https://mydomain.tld/hashes
1388                 - source_hash_name: ./dir2/foo.txt
1389         .. note::
1390             This argument must contain the full filename entry from the
1391             checksum file, as this argument is meant to disambiguate matches
1392             for multiple files that have the same basename. So, in the
1393             example above, simply using ``foo.txt`` would not match.
1394         .. versionadded:: 2016.3.5
1395     keep_source
1396         Set to ``False`` to discard the cached copy of the source file once the
1397         state completes. This can be useful for larger files to keep them from
1398         taking up space in minion cache. However, keep in mind that discarding
1399         the source file will result in the state needing to re-download the
1400         source file if the state is run again.
1401         .. versionadded:: 2017.7.3
1402     user
1403         The user to own the file, this defaults to the user salt is running as
1404         on the minion
1405     group
1406         The group ownership set for the file, this defaults to the group salt
1407         is running as on the minion. On Windows, this is ignored
1408     mode
1409         The permissions to set on this file, e.g. ``644``, ``0775``, or
1410         ``4664``.
1411         The default mode for new files and directories corresponds to the
1412         umask of the salt process. The mode of existing files and directories
1413         will only be changed if ``mode`` is specified.
1414         .. note::
1415             This option is **not** supported on Windows.
1416         .. versionchanged:: 2016.11.0
1417             This option can be set to ``keep``, and Salt will keep the mode
1418             from the Salt fileserver. This is only supported when the
1419             ``source`` URL begins with ``salt://``, or for files local to the
1420             minion. Because the ``source`` option cannot be used with any of
1421             the ``contents`` options, setting the ``mode`` to ``keep`` is also
1422             incompatible with the ``contents`` options.
1423         .. note:: keep does not work with salt-ssh.
1424             As a consequence of how the files are transferred to the minion, and
1425             the inability to connect back to the master with salt-ssh, salt is
1426             unable to stat the file as it exists on the fileserver and thus
1427             cannot mirror the mode on the salt-ssh minion
1428     attrs
1429         The attributes to have on this file, e.g. ``a``, ``i``. The attributes
1430         can be any or a combination of the following characters:
1431         ``aAcCdDeijPsStTu``.
1432         .. note::
1433             This option is **not** supported on Windows.
1434         .. versionadded:: 2018.3.0
1435     template
1436         If this setting is applied, the named templating engine will be used to
1437         render the downloaded file. The following templates are supported:
1438         - :mod:`cheetah&lt;salt.renderers.cheetah&gt;`
1439         - :mod:`genshi&lt;salt.renderers.genshi&gt;`
1440         - :mod:`jinja&lt;salt.renderers.jinja&gt;`
1441         - :mod:`mako&lt;salt.renderers.mako&gt;`
1442         - :mod:`py&lt;salt.renderers.py&gt;`
1443         - :mod:`wempy&lt;salt.renderers.wempy&gt;`
1444     makedirs
1445         If set to ``True``, then the parent directories will be created to
1446         facilitate the creation of the named file. If ``False``, and the parent
1447         directory of the destination file doesn't exist, the state will fail.
1448     dir_mode
1449         If directories are to be created, passing this option specifies the
1450         permissions for those directories. If this is not set, directories
1451         will be assigned permissions by adding the execute bit to the mode of
1452         the files.
1453         The default mode for new files and directories corresponds umask of salt
1454         process. For existing files and directories it's not enforced.
1455     replace
1456         If set to ``False`` and the file already exists, the file will not be
1457         modified even if changes would otherwise be made. Permissions and
1458         ownership will still be enforced, however.
1459     context
1460         Overrides default context variables passed to the template.
1461     defaults
1462         Default context passed to the template.
1463     backup
1464         Overrides the default backup mode for this specific file. See
1465         :ref:`backup_mode documentation &lt;file-state-backups&gt;` for more details.
1466     show_changes
1467         Output a unified diff of the old file and the new file. If ``False``
1468         return a boolean if any changes were made.
1469     create
1470         If set to ``False``, then the file will only be managed if the file
1471         already exists on the system.
1472     contents
1473         Specify the contents of the file. Cannot be used in combination with
1474         ``source``. Ignores hashes and does not use a templating engine.
1475         This value can be either a single string, a multiline YAML string or a
1476         list of strings.  If a list of strings, then the strings will be joined
1477         together with newlines in the resulting file. For example, the below
1478         two example states would result in identical file contents:
1479         .. code-block:: yaml
1480             /path/to/file1:
1481               file.managed:
1482                 - contents:
1483                   - This is line 1
1484                   - This is line 2
1485             /path/to/file2:
1486               file.managed:
1487                 - contents: |
1488                     This is line 1
1489                     This is line 2
1490     contents_pillar
1491         .. versionadded:: 0.17.0
1492         .. versionchanged:: 2016.11.0
1493             contents_pillar can also be a list, and the pillars will be
1494             concatenated together to form one file.
1495         Operates like ``contents``, but draws from a value stored in pillar,
1496         using the pillar path syntax used in :mod:`pillar.get
1497         &lt;salt.modules.pillar.get&gt;`. This is useful when the pillar value
1498         contains newlines, as referencing a pillar variable using a jinja/mako
1499         template can result in YAML formatting issues due to the newlines
1500         causing indentation mismatches.
1501         For example, the following could be used to deploy an SSH private key:
1502         .. code-block:: yaml
1503             /home/deployer/.ssh/id_rsa:
1504               file.managed:
1505                 - user: deployer
1506                 - group: deployer
1507                 - mode: 600
1508                 - attrs: a
1509                 - contents_pillar: userdata:deployer:id_rsa
1510         This would populate ``/home/deployer/.ssh/id_rsa`` with the contents of
1511         ``pillar['userdata']['deployer']['id_rsa']``. An example of this pillar
1512         setup would be like so:
1513         .. code-block:: yaml
1514             userdata:
1515               deployer:
1516                 id_rsa: |
1517                     -----BEGIN RSA PRIVATE KEY-----
1518                     MIIEowIBAAKCAQEAoQiwO3JhBquPAalQF9qP1lLZNXVjYMIswrMe2HcWUVBgh+vY
1519                     U7sCwx/dH6+VvNwmCoqmNnP+8gTPKGl1vgAObJAnMT623dMXjVKwnEagZPRJIxDy
1520                     B/HaAre9euNiY3LvIzBTWRSeMfT+rWvIKVBpvwlgGrfgz70m0pqxu+UyFbAGLin+
1521                     GpxzZAMaFpZw4sSbIlRuissXZj/sHpQb8p9M5IeO4Z3rjkCP1cxI
1522                     -----END RSA PRIVATE KEY-----
1523         .. note::
1524             The private key above is shortened to keep the example brief, but
1525             shows how to do multiline string in YAML. The key is followed by a
1526             pipe character, and the multiline string is indented two more
1527             spaces.
1528             To avoid the hassle of creating an indented multiline YAML string,
1529             the :mod:`file_tree external pillar &lt;salt.pillar.file_tree&gt;` can
1530             be used instead. However, this will not work for binary files in
1531             Salt releases before 2015.8.4.
1532     contents_grains
1533         .. versionadded:: 2014.7.0
1534         Operates like ``contents``, but draws from a value stored in grains,
1535         using the grains path syntax used in :mod:`grains.get
1536         &lt;salt.modules.grains.get&gt;`. This functionality works similarly to
1537         ``contents_pillar``, but with grains.
1538         For example, the following could be used to deploy a "message of the day"
1539         file:
1540         .. code-block:: yaml
1541             write_motd:
1542               file.managed:
1543                 - name: /etc/motd
1544                 - contents_grains: motd
1545         This would populate ``/etc/motd`` file with the contents of the ``motd``
1546         grain. The ``motd`` grain is not a default grain, and would need to be
1547         set prior to running the state:
1548         .. code-block:: bash
1549             salt '*' grains.set motd 'Welcome! This system is managed by Salt.'
1550     contents_newline
1551         .. versionadded:: 2014.7.0
1552         .. versionchanged:: 2015.8.4
1553             This option is now ignored if the contents being deployed contain
1554             binary data.
1555         If ``True``, files managed using ``contents``, ``contents_pillar``, or
1556         ``contents_grains`` will have a newline added to the end of the file if
1557         one is not present. Setting this option to ``False`` will ensure the
1558         final line, or entry, does not contain a new line. If the last line, or
1559         entry in the file does contain a new line already, this option will not
1560         remove it.
1561     contents_delimiter
1562         .. versionadded:: 2015.8.4
1563         Can be used to specify an alternate delimiter for ``contents_pillar``
1564         or ``contents_grains``. This delimiter will be passed through to
1565         :py:func:`pillar.get &lt;salt.modules.pillar.get&gt;` or :py:func:`grains.get
1566         &lt;salt.modules.grains.get&gt;` when retrieving the contents.
1567     encoding
1568         If specified, then the specified encoding will be used. Otherwise, the
1569         file will be encoded using the system locale (usually UTF-8). See
1570         https://docs.python.org/3/library/codecs.html#standard-encodings for
1571         the list of available encodings.
1572         .. versionadded:: 2017.7.0
1573     encoding_errors
1574         Error encoding scheme. Default is ```'strict'```.
1575         See https://docs.python.org/2/library/codecs.html#codec-base-classes
1576         for the list of available schemes.
1577         .. versionadded:: 2017.7.0
1578     allow_empty
1579         .. versionadded:: 2015.8.4
1580         If set to ``False``, then the state will fail if the contents specified
1581         by ``contents_pillar`` or ``contents_grains`` are empty.
1582     follow_symlinks
1583         .. versionadded:: 2014.7.0
1584         If the desired path is a symlink follow it and make changes to the
1585         file to which the symlink points.
1586     check_cmd
1587         .. versionadded:: 2014.7.0
1588         The specified command will be run with an appended argument of a
1589         *temporary* file containing the new managed contents.  If the command
1590         exits with a zero status the new managed contents will be written to
1591         the managed destination. If the command exits with a nonzero exit
1592         code, the state will fail and no changes will be made to the file.
1593         For example, the following could be used to verify sudoers before making
1594         changes:
1595         .. code-block:: yaml
1596             /etc/sudoers:
1597               file.managed:
1598                 - user: root
1599                 - group: root
1600                 - mode: 0440
1601                 - attrs: i
1602                 - source: salt://sudoers/files/sudoers.jinja
1603                 - template: jinja
1604                 - check_cmd: /usr/sbin/visudo -c -f
1605         **NOTE**: This ``check_cmd`` functions differently than the requisite
1606         ``check_cmd``.
1607     tmp_dir
1608         Directory for temp file created by ``check_cmd``. Useful for checkers
1609         dependent on config file location (e.g. daemons restricted to their
1610         own config directories by an apparmor profile).
1611         .. code-block:: yaml
1612             /etc/dhcp/dhcpd.conf:
1613               file.managed:
1614                 - user: root
1615                 - group: root
1616                 - mode: 0755
1617                 - tmp_dir: '/etc/dhcp'
1618                 - contents: "# Managed by Salt"
1619                 - check_cmd: dhcpd -t -cf
1620     tmp_ext
1621         Suffix for temp file created by ``check_cmd``. Useful for checkers
1622         dependent on config file extension (e.g. the init-checkconf upstart
1623         config checker).
1624         .. code-block:: yaml
1625             /etc/init/test.conf:
1626               file.managed:
1627                 - user: root
1628                 - group: root
1629                 - mode: 0440
1630                 - tmp_ext: '.conf'
1631                 - contents:
1632                   - 'description "Salt Minion"'
1633                   - 'start on started mountall'
1634                   - 'stop on shutdown'
1635                   - 'respawn'
1636                   - 'exec salt-minion'
1637                 - check_cmd: init-checkconf -f
1638     skip_verify
1639         If ``True``, hash verification of remote file sources (``http://``,
1640         ``https://``, ``ftp://``) will be skipped, and the ``source_hash``
1641         argument will be ignored.
1642         .. versionadded:: 2016.3.0
1643     selinux
1644         Allows setting the selinux user, role, type, and range of a managed file
1645         .. code-block:: yaml
1646             /tmp/selinux.test
1647               file.managed:
1648                 - user: root
1649                 - selinux:
1650                     seuser: system_u
1651                     serole: object_r
1652                     setype: system_conf_t
1653                     seranage: s0
1654         .. versionadded:: 3000
1655     win_owner
1656         The owner of the directory. If this is not passed, user will be used. If
1657         user is not passed, the account under which Salt is running will be
1658         used.
1659         .. versionadded:: 2017.7.0
1660     win_perms
1661         A dictionary containing permissions to grant and their propagation. For
1662         example: ``{'Administrators': {'perms': 'full_control'}}`` Can be a
1663         single basic perm or a list of advanced perms. ``perms`` must be
1664         specified. ``applies_to`` does not apply to file objects.
1665         .. versionadded:: 2017.7.0
1666     win_deny_perms
1667         A dictionary containing permissions to deny and their propagation. For
1668         example: ``{'Administrators': {'perms': 'full_control'}}`` Can be a
1669         single basic perm or a list of advanced perms. ``perms`` must be
1670         specified. ``applies_to`` does not apply to file objects.
1671         .. versionadded:: 2017.7.0
1672     win_inheritance
1673         True to inherit permissions from the parent directory, False not to
1674         inherit permission.
1675         .. versionadded:: 2017.7.0
1676     win_perms_reset
1677         If ``True`` the existing DACL will be cleared and replaced with the
1678         settings defined in this function. If ``False``, new entries will be
1679         appended to the existing DACL. Default is ``False``.
1680         .. versionadded:: 2018.3.0
1681     Here's an example using the above ``win_*`` parameters:
1682     .. code-block:: yaml
1683         create_config_file:
1684           file.managed:
1685             - name: C:\config\settings.cfg
1686             - source: salt://settings.cfg
1687             - win_owner: Administrators
1688             - win_perms:
1689                 dev_ops:
1690                   perms: full_control
1691                 appuser:
1692                   perms:
1693                     - read_attributes
1694                     - read_ea
1695                     - create_folders
1696                     - read_permissions
1697                 joe_snuffy:
1698                   perms: read
1699             - win_deny_perms:
1700                 fred_snuffy:
1701                   perms: full_control
1702             - win_inheritance: False
1703     verify_ssl
1704         If ``False``, remote https file sources (``https://``) and source_hash
1705         will not attempt to validate the servers certificate. Default is True.
1706         .. versionadded:: 3002
1707     use_etag
1708         If ``True``, remote http/https file sources will attempt to use the
1709         ETag header to determine if the remote file needs to be downloaded.
1710         This provides a lightweight mechanism for promptly refreshing files
1711         changed on a web server without requiring a full hash comparison via
1712         the ``source_hash`` parameter.
1713         .. versionadded:: 3005
1714     Converse *recurse* definition to a set of strings.
1715     Raises TypeError or ValueError when *recurse* has wrong structure.
1716     Walk the directory tree under root up till reaching max_depth.
1717     With max_depth=None (default), do not limit depth.
1718     name = os.path.expanduser(name)
1719     ret = {"name": name, "changes": {}, "result": True, "comment": ""}
1720     if not name:
1721         return _error(ret, "Must provide name to file.directory")
1722     if name[-1] == "/" and name != "/":
1723         name = name[:-1]
1724     if max_depth is not None and clean:
1725         return _error(ret, "Cannot specify both max_depth and clean")
1726     user = _test_owner(kwargs, user=user)
1727     if salt.utils.platform.is_windows():
1728         if win_owner is None:
1729             win_owner = user if user else salt.utils.win_functions.get_current_user()
1730         if group is not None:
1731             log.warning(
1732                 "The group argument for %s has been ignored as this is "
1733                 "a Windows system. Please use the `win_*` parameters to set "
1734                 "permissions in Windows.",
1735                 name,
1736             )
1737         group = user
1738     if "mode" in kwargs and not dir_mode:
1739         dir_mode = kwargs.get("mode", [])
1740     if not file_mode:
1741         file_mode = dir_mode
1742     dir_mode = salt.utils.files.normalize_mode(dir_mode)
1743     file_mode = salt.utils.files.normalize_mode(file_mode)
1744     if salt.utils.platform.is_windows():
1745         try:
1746             salt.utils.win_dacl.get_sid(win_owner)
1747         except CommandExecutionError as exc:
1748             return _error(ret, exc)
1749     else:
1750         u_check = _check_user(user, group)
1751         if u_check:
1752             return _error(ret, u_check)
1753     if not os.path.isabs(name):
1754         return _error(ret, "Specified file {} is not an absolute path".format(name))
1755     if (
1756         os.path.isfile(name)
1757         or (not allow_symlink and os.path.islink(name))
1758         or (force and os.path.islink(name))
1759     ):
1760         if backupname is not None:
1761             if os.path.lexists(backupname):
1762                 if not force:
1763                     return _error(
1764                         ret,
1765                         "File exists where the backup target {} should go".format(
1766                             backupname
1767                         ),
1768                     )
1769                 else:
1770                     __salt__["file.remove"](backupname)
1771             os.rename(name, backupname)
1772         elif force:
1773             if os.path.isfile(name):
1774                 if __opts__["test"]:
1775                     ret["changes"]["forced"] = "File would be forcibly replaced"
1776                 else:
1777                     os.remove(name)
1778                     ret["changes"]["forced"] = "File was forcibly replaced"
1779             elif __salt__["file.is_link"](name):
1780                 if __opts__["test"]:
1781                     ret["changes"]["forced"] = "Symlink would be forcibly replaced"
1782                 else:
1783                     __salt__["file.remove"](name)
1784                     ret["changes"]["forced"] = "Symlink was forcibly replaced"
1785             else:
1786                 if __opts__["test"]:
1787                     ret["changes"]["forced"] = "Directory would be forcibly replaced"
1788                 else:
1789                     __salt__["file.remove"](name)
1790                     ret["changes"]["forced"] = "Directory was forcibly replaced"
1791         else:
1792             if os.path.isfile(name):
1793                 return _error(
1794                     ret, "Specified location {} exists and is a file".format(name)
1795                 )
1796             elif os.path.islink(name):
1797                 return _error(
1798                     ret, "Specified location {} exists and is a symlink".format(name)
1799                 )
1800     if salt.utils.platform.is_windows():
1801         tresult, tcomment, tchanges = _check_directory_win(
1802             name=name,
1803             win_owner=win_owner,
1804             win_perms=win_perms,
1805             win_deny_perms=win_deny_perms,
1806             win_inheritance=win_inheritance,
1807             win_perms_reset=win_perms_reset,
1808         )
1809     else:
1810         tresult, tcomment, tchanges = _check_directory(
1811             name,
1812             user,
1813             group,
1814             recurse or [],
1815             dir_mode,
1816             file_mode,
1817             clean,
1818             require,
1819             exclude_pat,
1820             max_depth,
1821             follow_symlinks,
1822         )
1823     if tchanges:
1824         ret["changes"].update(tchanges)
1825     if __opts__["test"] or not ret["changes"]:
1826         ret["result"] = tresult
1827         ret["comment"] = tcomment
1828         return ret
1829     if not os.path.isdir(name):
1830         if not os.path.isdir(os.path.dirname(name)):
1831             if makedirs:
1832                 try:
1833                     _makedirs(
1834                         name=name,
1835                         user=user,
1836                         group=group,
1837                         dir_mode=dir_mode,
1838                         win_owner=win_owner,
1839                         win_perms=win_perms,
1840                         win_deny_perms=win_deny_perms,
1841                         win_inheritance=win_inheritance,
1842                     )
1843                 except CommandExecutionError as exc:
1844                     return _error(ret, "Drive {} is not mapped".format(exc.message))
1845             else:
1846                 return _error(ret, "No directory to create {} in".format(name))
1847         if salt.utils.platform.is_windows():
1848             __salt__["file.mkdir"](
1849                 path=name,
1850                 owner=win_owner,
1851                 grant_perms=win_perms,
1852                 deny_perms=win_deny_perms,
1853                 inheritance=win_inheritance,
1854                 reset=win_perms_reset,
1855             )
1856         else:
1857             __salt__["file.mkdir"](name, user=user, group=group, mode=dir_mode)
1858         if not os.path.isdir(name):
1859             return _error(ret, "Failed to create directory {}".format(name))
1860         ret["changes"][name] = {"directory": "new"}
1861         return ret
1862     if not children_only:
1863         if salt.utils.platform.is_windows():
1864             ret = __salt__["file.check_perms"](
1865                 path=name,
1866                 ret=ret,
1867                 owner=win_owner,
1868                 grant_perms=win_perms,
1869                 deny_perms=win_deny_perms,
1870                 inheritance=win_inheritance,
1871                 reset=win_perms_reset,
1872             )
1873         else:
1874             ret, perms = __salt__["file.check_perms"](
1875                 name, ret, user, group, dir_mode, None, follow_symlinks
1876             )
1877     errors = []
1878     if recurse or clean:
1879         walk_l = list(_depth_limited_walk(name, max_depth))
1880         walk_d = {}
1881         for i in walk_l:
1882             walk_d[i[0]] = (i[1], i[2])
1883     recurse_set = None
1884     if recurse:
1885         try:
1886             recurse_set = _get_recurse_set(recurse)
1887         except (TypeError, ValueError) as exc:
1888             ret["result"] = False
1889             ret["comment"] = "{}".format(exc)
1890     if recurse_set:
1891         if "user" in recurse_set:
1892             if user or isinstance(user, int):
1893                 uid = __salt__["file.user_to_uid"](user)
1894                 if isinstance(uid, str):
1895                     ret["result"] = False
1896                     ret["comment"] = (
1897                         "Failed to enforce ownership for "
1898                         "user {} (user does not "
1899                         "exist)".format(user)
1900                     )
1901             else:
1902                 ret["result"] = False
1903                 ret["comment"] = (
1904                     "user not specified, but configured as "
1905                     "a target for recursive ownership "
1906                     "management"
1907                 )
1908         else:
1909             user = None
1910         if "group" in recurse_set:
1911             if group or isinstance(group, int):
1912                 gid = __salt__["file.group_to_gid"](group)
1913                 if isinstance(gid, str):
1914                     ret["result"] = False
1915                     ret[
1916                         "comment"
1917                     ] = "Failed to enforce group ownership for group {}".format(group)
1918             else:
1919                 ret["result"] = False
1920                 ret["comment"] = (
1921                     "group not specified, but configured "
1922                     "as a target for recursive ownership "
1923                     "management"
1924                 )
1925         else:
1926             group = None
1927         if "mode" not in recurse_set:
1928             file_mode = None
1929             dir_mode = None
1930         if "silent" in recurse_set:
1931             ret["changes"] = {"recursion": "Changes silenced"}
1932         check_files = "ignore_files" not in recurse_set
1933         check_dirs = "ignore_dirs" not in recurse_set
1934         for root, dirs, files in walk_l:
1935             if check_files:
1936                 for fn_ in files:
1937                     full = os.path.join(root, fn_)
1938                     try:
1939                         if salt.utils.platform.is_windows():
1940                             ret = __salt__["file.check_perms"](
1941                                 path=full,
1942                                 ret=ret,
1943                                 owner=win_owner,
1944                                 grant_perms=win_perms,
1945                                 deny_perms=win_deny_perms,
1946                                 inheritance=win_inheritance,
1947                                 reset=win_perms_reset,
1948                             )
1949                         else:
1950                             ret, _ = __salt__["file.check_perms"](
1951                                 full, ret, user, group, file_mode, None, follow_symlinks
1952                             )
1953                     except CommandExecutionError as exc:
1954                         if not exc.strerror.startswith("Path not found"):
1955                             errors.append(exc.strerror)
1956             if check_dirs:
1957                 for dir_ in dirs:
1958                     full = os.path.join(root, dir_)
1959                     try:
1960                         if salt.utils.platform.is_windows():
1961                             ret = __salt__["file.check_perms"](
1962                                 path=full,
1963                                 ret=ret,
1964                                 owner=win_owner,
1965                                 grant_perms=win_perms,
1966                                 deny_perms=win_deny_perms,
1967                                 inheritance=win_inheritance,
1968                                 reset=win_perms_reset,
1969                             )
1970                         else:
1971                             ret, _ = __salt__["file.check_perms"](
1972                                 full, ret, user, group, dir_mode, None, follow_symlinks
1973                             )
1974                     except CommandExecutionError as exc:
1975                         if not exc.strerror.startswith("Path not found"):
1976                             errors.append(exc.strerror)
1977     if clean:
1978         keep = _gen_keep_files(name, require, walk_d)
1979         log.debug("List of kept files when use file.directory with clean: %s", keep)
1980         removed = _clean_dir(name, list(keep), exclude_pat)
1981         if removed:
1982             ret["changes"]["removed"] = removed
1983             ret["comment"] = "Files cleaned from directory {}".format(name)
1984     if not ret["comment"]:
1985         if children_only:
1986             ret["comment"] = "Directory {}/* updated".format(name)
1987         else:
1988             if ret["changes"]:
1989                 ret["comment"] = "Directory {} updated".format(name)
1990     if __opts__["test"]:
1991         ret["comment"] = "Directory {} not updated".format(name)
1992     elif not ret["changes"] and ret["result"]:
1993         orig_comment = None
1994         if ret["comment"]:
1995             orig_comment = ret["comment"]
1996         ret["comment"] = "Directory {} is in the correct state".format(name)
1997         if orig_comment:
1998             ret["comment"] = "\n".join([ret["comment"], orig_comment])
1999     if errors:
2000         ret["result"] = False
2001         ret["comment"] += "\n\nThe following errors were encountered:\n"
2002         for error in errors:
2003             ret["comment"] += "\n- {}".format(error)
2004     return ret
2005 def recurse(
2006     name,
2007     source,
2008     keep_source=True,
2009     clean=False,
2010     require=None,
2011     user=None,
2012     group=None,
2013     dir_mode=None,
2014     file_mode=None,
2015     sym_mode=None,
2016     template=None,
2017     context=None,
2018     replace=True,
2019     defaults=None,
2020     include_empty=False,
2021     backup="",
2022     include_pat=None,
2023     exclude_pat=None,
2024     maxdepth=None,
2025     keep_symlinks=False,
2026     force_symlinks=False,
2027     win_owner=None,
2028     win_perms=None,
2029     win_deny_perms=None,
2030     win_inheritance=True,
2031     **kwargs
2032 ):
2033     if "env" in kwargs:
2034         kwargs.pop("env")
2035     name = os.path.expanduser(salt.utils.data.decode(name))
2036     user = _test_owner(kwargs, user=user)
2037     if salt.utils.platform.is_windows():
2038         if group is not None:
2039             log.warning(
2040                 "The group argument for %s has been ignored as this "
2041                 "is a Windows system.",
2042                 name,
2043             )
2044         group = user
2045     ret = {
2046         "name": name,
2047         "changes": {},
2048         "result": True,
2049         "comment": {},  # { path: [comment, ...] }
2050     }
2051     if "mode" in kwargs:
2052         ret["result"] = False
2053         ret["comment"] = (
2054             "'mode' is not allowed in 'file.recurse'. Please use "
2055             "'file_mode' and 'dir_mode'."
2056         )
2057         return ret
2058     if (
2059         any([x is not None for x in (dir_mode, file_mode, sym_mode)])
2060         and salt.utils.platform.is_windows()
2061     ):
2062         return _error(ret, "mode management is not supported on Windows")
2063     dir_mode = salt.utils.files.normalize_mode(dir_mode)
2064     try:
2065         keep_mode = file_mode.lower() == "keep"
2066         if keep_mode:
2067             file_mode = None
2068     except AttributeError:
2069         keep_mode = False
2070     file_mode = salt.utils.files.normalize_mode(file_mode)
2071     u_check = _check_user(user, group)
2072     if u_check:
2073         return _error(ret, u_check)
2074     if not os.path.isabs(name):
2075         return _error(ret, "Specified file {} is not an absolute path".format(name))
2076     source_list = _validate_str_list(source)
2077     for idx, val in enumerate(source_list):
2078         source_list[idx] = val.rstrip("/")
2079     for precheck in source_list:
2080         if not precheck.startswith("salt://"):
2081             return _error(
2082                 ret,
2083                 "Invalid source '{}' (must be a salt:// URI)".format(precheck),
2084             )
2085     try:
2086         source, source_hash = __salt__["file.source_list"](source_list, "", __env__)
2087     except CommandExecutionError as exc:
2088         ret["result"] = False
2089         ret["comment"] = "Recurse failed: {}".format(exc)
2090         return ret
2091     srcpath, senv = salt.utils.url.parse(source)
2092     if senv is None:
2093         senv = __env__
2094     master_dirs = __salt__["cp.list_master_dirs"](saltenv=senv)
2095     if srcpath not in master_dirs and not any(
2096         x for x in master_dirs if x.startswith(srcpath + "/")
2097     ):
2098         ret["result"] = False
2099         ret["comment"] = (
2100             "The directory '{}' does not exist on the salt fileserver "
2101             "in saltenv '{}'".format(srcpath, senv)
2102         )
2103         return ret
2104     if not os.path.isdir(name):
2105         if os.path.exists(name):
2106             return _error(ret, "The path {} exists and is not a directory".format(name))
2107         if not __opts__["test"]:
2108             if salt.utils.platform.is_windows():
2109                 win_owner = win_owner if win_owner else user
2110                 __salt__["file.makedirs_perms"](
2111                     path=name,
2112                     owner=win_owner,
2113                     grant_perms=win_perms,
2114                     deny_perms=win_deny_perms,
2115                     inheritance=win_inheritance,
2116                 )
2117             else:
2118                 __salt__["file.makedirs_perms"](
2119                     name=name, user=user, group=group, mode=dir_mode
2120                 )
2121     def add_comment(path, comment):
2122         comments = ret["comment"].setdefault(path, [])
2123         if isinstance(comment, str):
2124             comments.append(comment)
2125         else:
2126             comments.extend(comment)
2127     def merge_ret(path, _ret):
2128         if _ret["result"] is False or ret["result"] is True:
2129             ret["result"] = _ret["result"]
2130         if _ret["result"] is not True and _ret["comment"]:
2131             add_comment(path, _ret["comment"])
2132         if _ret["changes"]:
2133             ret["changes"][path] = _ret["changes"]
2134     def manage_file(path, source, replace):
2135         if clean and os.path.exists(path) and os.path.isdir(path) and replace:
2136             _ret = {"name": name, "changes": {}, "result": True, "comment": ""}
2137             if __opts__["test"]:
2138                 _ret["comment"] = "Replacing directory {} with a file".format(path)
2139                 _ret["result"] = None
2140                 merge_ret(path, _ret)
2141                 return
2142             else:
2143                 __salt__["file.remove"](path)
2144                 _ret["changes"] = {"diff": "Replaced directory with a new file"}
2145                 merge_ret(path, _ret)
2146         pass_kwargs = {}
2147         faults = ["mode", "makedirs"]
2148         for key in kwargs:
2149             if key not in faults:
2150                 pass_kwargs[key] = kwargs[key]
2151         _ret = managed(
2152             path,
2153             source=source,
2154             keep_source=keep_source,
2155             user=user,
2156             group=group,
2157             mode="keep" if keep_mode else file_mode,
2158             attrs=None,
2159             template=template,
2160             makedirs=True,
2161             replace=replace,
2162             context=context,
2163             defaults=defaults,
2164             backup=backup,
2165             **pass_kwargs
2166         )
2167         merge_ret(path, _ret)
2168     def manage_directory(path):
2169         if os.path.basename(path) == "..":
2170             return
2171         if clean and os.path.exists(path) and not os.path.isdir(path):
2172             _ret = {"name": name, "changes": {}, "result": True, "comment": ""}
2173             if __opts__["test"]:
2174                 _ret["comment"] = "Replacing {} with a directory".format(path)
2175                 _ret["result"] = None
2176                 merge_ret(path, _ret)
2177                 return
2178             else:
2179                 __salt__["file.remove"](path)
2180                 _ret["changes"] = {"diff": "Replaced file with a directory"}
2181                 merge_ret(path, _ret)
2182         _ret = directory(
2183             path,
2184             user=user,
2185             group=group,
2186             recurse=[],
2187             dir_mode=dir_mode,
2188             file_mode=None,
2189             makedirs=True,
2190             clean=False,
2191             require=None,
2192         )
2193         merge_ret(path, _ret)
2194     mng_files, mng_dirs, mng_symlinks, keep = _gen_recurse_managed_files(
2195         name, source, keep_symlinks, include_pat, exclude_pat, maxdepth, include_empty
2196     )
2197     for srelpath, ltarget in mng_symlinks:
2198         _ret = symlink(
2199             os.path.join(name, srelpath),
2200             ltarget,
2201             makedirs=True,
2202             force=force_symlinks,
2203             user=user,
2204             group=group,
2205             mode=sym_mode,
2206         )
2207         if not _ret:
2208             continue
2209         merge_ret(os.path.join(name, srelpath), _ret)
2210     for dirname in mng_dirs:
2211         manage_directory(dirname)
2212     for dest, src in mng_files:
2213         manage_file(dest, src, replace)
2214     if clean:
2215         keep.update(_gen_keep_files(name, require))
2216         removed = _clean_dir(name, list(keep), exclude_pat)
2217         if removed:
2218             if __opts__["test"]:
2219                 if ret["result"]:
2220                     ret["result"] = None
2221                 add_comment("removed", removed)
2222             else:
2223                 ret["changes"]["removed"] = removed
2224     ret["comment"] = "\n".join(
2225         "\n#### {} ####\n{}".format(k, v if isinstance(v, str) else "\n".join(v))
2226         for (k, v) in ret["comment"].items()
2227     ).strip()
2228     if not ret["comment"]:
2229         ret["comment"] = "Recursively updated {}".format(name)
2230     if not ret["changes"] and ret["result"]:
2231         ret["comment"] = "The directory {} is in the correct state".format(name)
2232     return ret
2233 def retention_schedule(name, retain, strptime_format=None, timezone=None):
2234     name = os.path.expanduser(name)
2235     ret = {
2236         "name": name,
2237         "changes": {"retained": [], "deleted": [], "ignored": []},
2238         "result": True,
2239         "comment": "",
2240     }
2241     if not name:
2242         return _error(ret, "Must provide name to file.retention_schedule")
2243     if not os.path.isdir(name):
2244         return _error(ret, "Name provided to file.retention must be a directory")
2245     all_files = __salt__["file.readdir"](name)
2246     beginning_of_unix_time = datetime(1970, 1, 1)
2247     def get_file_time_from_strptime(f):
2248         try:
2249             ts = datetime.strptime(f, strptime_format)
2250             ts_epoch = salt.utils.dateutils.total_seconds(ts - beginning_of_unix_time)
2251             return (ts, ts_epoch)
2252         except ValueError:
2253             return (None, None)
2254     def get_file_time_from_mtime(f):
2255         if f == "." or f == "..":
2256             return (None, None)
2257         lstat = __salt__["file.lstat"](os.path.join(name, f))
2258         if lstat:
2259             mtime = lstat["st_mtime"]
2260             return (datetime.fromtimestamp(mtime, timezone), mtime)
2261         else:  # maybe it was deleted since we did the readdir?
2262             return (None, None)
2263     get_file_time = (
2264         get_file_time_from_strptime if strptime_format else get_file_time_from_mtime
2265     )
2266     def dict_maker():
2267         return defaultdict(dict_maker)
2268     files_by_ymd = dict_maker()
2269     files_by_y_week_dow = dict_maker()
2270     relevant_files = set()
2271     ignored_files = set()
2272     for f in all_files:
2273         ts, ts_epoch = get_file_time(f)
2274         if ts:
2275             files_by_ymd[ts.year][ts.month][ts.day][ts.hour][ts_epoch] = f
2276             week_of_year = ts.isocalendar()[1]
2277             files_by_y_week_dow[ts.year][week_of_year][ts.weekday()][ts_epoch] = f
2278             relevant_files.add(f)
2279         else:
2280             ignored_files.add(f)
2281     RETAIN_TO_DEPTH = {
2282         "first_of_year": 1,
2283         "first_of_month": 2,
2284         "first_of_day": 3,
2285         "first_of_hour": 4,
2286         "most_recent": 5,
2287     }
2288     def get_first(fwt):
2289         if isinstance(fwt, dict):
2290             first_sub_key = sorted(fwt.keys())[0]
2291             return get_first(fwt[first_sub_key])
2292         else:
2293             return {fwt}
2294     def get_first_n_at_depth(fwt, depth, n):
2295         if depth &lt;= 0:
2296             return get_first(fwt)
2297         else:
2298             result_set = set()
2299             for k in sorted(fwt.keys(), reverse=True):
2300                 needed = n - len(result_set)
2301                 if needed &lt; 1:
2302                     break
2303                 result_set |= get_first_n_at_depth(fwt[k], depth - 1, needed)
2304             return result_set
2305     retained_files = set()
2306     for retention_rule, keep_count in retain.items():
2307         keep_count = sys.maxsize if "all" == keep_count else int(keep_count)
2308         if "first_of_week" == retention_rule:
2309             first_of_week_depth = 2  # year + week_of_year = 2
2310             retained_files |= get_first_n_at_depth(
2311                 files_by_y_week_dow, first_of_week_depth, keep_count + 1
2312             )
2313         else:
2314             retained_files |= get_first_n_at_depth(
2315                 files_by_ymd, RETAIN_TO_DEPTH[retention_rule], keep_count
2316             )
2317     deletable_files = list(relevant_files - retained_files)
2318     deletable_files.sort(reverse=True)
2319     changes = {
2320         "retained": sorted(list(retained_files), reverse=True),
2321         "deleted": deletable_files,
2322         "ignored": sorted(list(ignored_files), reverse=True),
2323     }
2324     ret["changes"] = changes
2325     if __opts__["test"]:
2326         ret["comment"] = "{} backups would have been removed from {}.\n".format(
2327             len(deletable_files), name
2328         )
2329         if deletable_files:
2330             ret["result"] = None
2331     else:
2332         for f in deletable_files:
2333             __salt__["file.remove"](os.path.join(name, f))
2334         ret["comment"] = "{} backups were removed from {}.\n".format(
2335             len(deletable_files), name
2336         )
2337         ret["changes"] = changes
2338     return ret
2339 def line(
2340     name,
2341     content=None,
2342     match=None,
2343     mode=None,
2344     location=None,
2345     before=None,
2346     after=None,
2347     show_changes=True,
2348     backup=False,
2349     quiet=False,
2350     indent=True,
2351     create=False,
2352     user=None,
2353     group=None,
2354     file_mode=None,
2355 ):
2356     name = os.path.expanduser(name)
2357     ret = {"name": name, "changes": {}, "result": True, "comment": ""}
2358     if not name:
2359         return _error(ret, "Must provide name to file.line")
2360     managed(name, create=create, user=user, group=group, mode=file_mode, replace=False)
2361     check_res, check_msg = _check_file(name)
2362     if not check_res:
2363         return _error(ret, check_msg)
2364     mode = mode and mode.lower() or mode
2365     if mode is None:
2366         return _error(ret, "Mode was not defined. How to process the file?")
2367     modeswithemptycontent = ["delete"]
2368     if mode not in modeswithemptycontent and content is None:
2369         return _error(
2370             ret,
2371             "Content can only be empty if mode is {}".format(modeswithemptycontent),
2372         )
2373     del modeswithemptycontent
2374     changes = __salt__["file.line"](
2375         name,
2376         content,
2377         match=match,
2378         mode=mode,
2379         location=location,
2380         before=before,
2381         after=after,
2382         show_changes=show_changes,
2383         backup=backup,
2384         quiet=quiet,
2385         indent=indent,
2386     )
2387         ret["changes"]["diff"] = changes
2388         if __opts__["test"]:
2389             ret<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["result"] = None
2390             ret["comment"] = "Changes would be made"
2391         else:
2392             ret["result"] = True
2393             ret["comment"] = "Changes were made"
2394     else:
2395         ret["result"] = True
2396         ret["comment"] = "No changes needed to be made"
2397     return ret
2398 def replace(
2399     name,
2400     pattern,
2401     repl,
2402     count=0,
2403     flags=</b></font>8,
2404     bufsize=1,
2405     append_if_not_found=False,
2406     prepend_if_not_found=False,
2407     not_found_content=None,
2408     backup=".bak",
2409     show_changes=True,
2410     ignore_if_missing=False,
2411     backslash_literal=False,
2412 ):
2413     r"""
2414     Maintain an edit in a file.
2415     .. versionadded:: 0.17.0
2416     name
2417         Filesystem path to the file to be edited. If a symlink is specified, it
2418         will be resolved to its target.
2419     pattern
2420         A regular expression, to be matched using Python's
2421         :py:func:`re.search`.
2422         .. note::
2423             If you need to match a literal string that contains regex special
2424             characters, you may want to use salt's custom Jinja filter,
2425             ``regex_escape``.
2426             .. code-block:: jinja
2427                 {{ 'http://example.com?foo=bar%20baz' | regex_escape }}
2428     repl
2429         The replacement text
2430     count
2431         Maximum number of pattern occurrences to be replaced.  Defaults to 0.
2432         If count is a positive integer n, no more than n occurrences will be
2433         replaced, otherwise all occurrences will be replaced.
2434     flags
2435         A list of flags defined in the ``re`` module documentation from the
2436         Python standard library. Each list item should be a string that will
2437         correlate to the human-friendly flag name. E.g., ``['IGNORECASE',
2438         'MULTILINE']``.  Optionally, ``flags`` may be an int, with a value
2439         corresponding to the XOR (``|``) of all the desired flags. Defaults to
2440         ``8`` (which equates to ``['MULTILINE']``).
2441         .. note::
2442             ``file.replace`` reads the entire file as a string to support
2443             multiline regex patterns. Therefore, when using anchors such as
2444             ``^`` or ``$`` in the pattern, those anchors may be relative to
2445             the line OR relative to the file. The default for ``file.replace``
2446             is to treat anchors as relative to the line, which is implemented
2447             by setting the default value of ``flags`` to ``['MULTILINE']``.
2448             When overriding the default value for ``flags``, if
2449             ``'MULTILINE'`` is not present then anchors will be relative to
2450             the file. If the desired behavior is for anchors to be relative to
2451             the line, then simply add ``'MULTILINE'`` to the list of flags.
2452     bufsize
2453         How much of the file to buffer into memory at once. The default value
2454         ``1`` processes one line at a time. The special value ``file`` may be
2455         specified which will read the entire file into memory before
2456         processing.
2457     append_if_not_found
2458         If set to ``True``, and pattern is not found, then the content will be
2459         appended to the file.
2460         .. versionadded:: 2014.7.0
2461     prepend_if_not_found
2462         If set to ``True`` and pattern is not found, then the content will be
2463         prepended to the file.
2464         .. versionadded:: 2014.7.0
2465     not_found_content
2466         Content to use for append/prepend if not found. If ``None`` (default),
2467         uses ``repl``. Useful when ``repl`` uses references to group in
2468         pattern.
2469         .. versionadded:: 2014.7.0
2470     backup
2471         The file extension to use for a backup of the file before editing. Set
2472         to ``False`` to skip making a backup.
2473     show_changes
2474         Output a unified diff of the old file and the new file. If ``False``
2475         return a boolean if any changes were made. Returns a boolean or a
2476         string.
2477         .. note:
2478             Using this option will store two copies of the file in memory (the
2479             original version and the edited version) in order to generate the
2480             diff. This may not normally be a concern, but could impact
2481             performance if used with large files.
2482     ignore_if_missing
2483         .. versionadded:: 2016.3.4
2484         Controls what to do if the file is missing. If set to ``False``, the
2485         state will display an error raised by the execution module. If set to
2486         ``True``, the state will simply report no changes.
2487     backslash_literal
2488         .. versionadded:: 2016.11.7
2489         Interpret backslashes as literal backslashes for the repl and not
2490         escape characters.  This will help when using append/prepend so that
2491         the backslashes are not interpreted for the repl on the second run of
2492         the state.
2493     For complex regex patterns, it can be useful to avoid the need for complex
2494     quoting and escape sequences by making use of YAML's multiline string
2495     syntax.
2496     .. code-block:: yaml
2497         complex_search_and_replace:
2498           file.replace:
2499             - pattern: |
2500                 CentOS \(2.6.32[^\\n]+\\n\s+root[^\\n]+\\n\)+
2501     .. note::
2502        When using YAML multiline string syntax in ``pattern:``, make sure to
2503        also use that syntax in the ``repl:`` part, or you might loose line
2504        feeds.
2505     When regex capture groups are used in ``pattern:``, their captured value is
2506     available for reuse in the ``repl:`` part as a backreference (ex. ``\1``).
2507     .. code-block:: yaml
2508         add_login_group_to_winbind_ssh_access_list:
2509           file.replace:
2510             - name: '/etc/security/pam_winbind.conf'
2511             - pattern: '^(require_membership_of = )(.*)$'
2512             - repl: '\1\2,append-new-group-to-line'
2513     .. note::
2514        The ``file.replace`` state uses Python's ``re`` module.
2515        For more advanced options, see https://docs.python.org/2/library/re.html
2516     """
2517         ret["changes"]["diff"] <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= changes
2518         if __opts__["test"]:
2519             ret["result"] = None
2520             ret["comment"] = "Changes would have been made"
2521         else:
2522             ret["result"] = True
2523             ret["comment"] =</b></font> "Changes were made"
2524     else:
2525         ret["result"] = True
2526         ret["comment"] = "No changes needed to be made"
2527     return ret
2528 def keyvalue(
2529     name,
2530     key=None,
2531     value=None,
2532     key_values=None,
2533     separator="=",
2534     append_if_not_found=False,
2535     prepend_if_not_found=False,
2536     search_only=False,
2537     show_changes=True,
2538     ignore_if_missing=False,
2539     count=1,
2540     uncomment=None,
2541     key_ignore_case=False,
2542     value_ignore_case=False,
2543 ):
2544     """
2545     Key/Value based editing of a file.
2546     .. versionadded:: 3001
2547     This function differs from ``file.replace`` in that it is able to search for
2548     keys, followed by a customizable separator, and replace the value with the
2549     given value. Should the value be the same as the one already in the file, no
2550     changes will be made.
2551     Either supply both ``key`` and ``value`` parameters, or supply a dictionary
2552     with key / value pairs. It is an error to supply both.
2553     name
2554         Name of the file to search/replace in.
2555     key
2556         Key to search for when ensuring a value. Use in combination with a
2557         ``value`` parameter.
2558     value
2559         Value to set for a given key. Use in combination with a ``key``
2560         parameter.
2561     key_values
2562         Dictionary of key / value pairs to search for and ensure values for.
2563         Used to specify multiple key / values at once.
2564     separator
2565         Separator which separates key from value.
2566     append_if_not_found
2567         Append the key/value to the end of the file if not found. Note that this
2568         takes precedence over ``prepend_if_not_found``.
2569     prepend_if_not_found
2570         Prepend the key/value to the beginning of the file if not found. Note
2571         that ``append_if_not_found`` takes precedence.
2572     show_changes
2573         Show a diff of the resulting removals and inserts.
2574     ignore_if_missing
2575         Return with success even if the file is not found (or not readable).
2576     count
2577         Number of occurrences to allow (and correct), default is 1. Set to -1 to
2578         replace all, or set to 0 to remove all lines with this key regardsless
2579         of its value.
2580     .. note::
2581         Any additional occurrences after ``count`` are removed.
2582         A count of -1 will only replace all occurrences that are currently
2583         uncommented already. Lines commented out will be left alone.
2584     uncomment
2585         Disregard and remove supplied leading characters when finding keys. When
2586         set to None, lines that are commented out are left for what they are.
2587     .. note::
2588         The argument to ``uncomment`` is not a prefix string. Rather; it is a
2589         set of characters, each of which are stripped.
2590     key_ignore_case
2591         Keys are matched case insensitively. When a value is changed the matched
2592         key is kept as-is.
2593     value_ignore_case
2594         Values are checked case insensitively, trying to set e.g. 'Yes' while
2595         the current value is 'yes', will not result in changes when
2596         ``value_ignore_case`` is set to True.
2597     An example of using ``file.keyvalue`` to ensure sshd does not allow
2598     for root to login with a password and at the same time setting the
2599     login-gracetime to 1 minute and disabling all forwarding:
2600     .. code-block:: yaml
2601         sshd_config_harden:
2602             file.keyvalue:
2603               - name: /etc/ssh/sshd_config
2604               - key_values:
2605                   permitrootlogin: 'without-password'
2606                   LoginGraceTime: '1m'
2607                   DisableForwarding: 'yes'
2608               - separator: ' '
2609               - uncomment: '# '
2610               - key_ignore_case: True
2611               - append_if_not_found: True
2612     The same example, except for only ensuring PermitRootLogin is set correctly.
2613     Thus being able to use the shorthand ``key`` and ``value`` parameters
2614     instead of ``key_values``.
2615     .. code-block:: yaml
2616         sshd_config_harden:
2617             file.keyvalue:
2618               - name: /etc/ssh/sshd_config
2619               - key: PermitRootLogin
2620               - value: without-password
2621               - separator: ' '
2622               - uncomment: '# '
2623               - key_ignore_case: True
2624               - append_if_not_found: True
2625     .. note::
2626         Notice how the key is not matched case-sensitively, this way it will
2627         correctly identify both 'PermitRootLogin' as well as 'permitrootlogin'.
2628     """
2629     name = os.path.expanduser(name)
2630     ret = {
2631         "name": name,
2632         "changes": {},
2633         "result": None,
2634         "comment": "",
2635     }
2636     if not name:
2637         return _error(ret, "Must provide name to file.keyvalue")
2638     if key is not None and value is not None:
2639         if type(key_values) is dict:
2640             return _error(
2641                 ret, "file.keyvalue can not combine key_values with key and value"
2642             )
2643         key_values = {str(key): value}
2644     elif not isinstance(key_values, dict) or not key_values:
2645         msg = "is not a dictionary"
2646         if not key_values:
2647             msg = "is empty"
2648         return _error(
2649             ret,
2650             "file.keyvalue key and value not supplied and key_values " + msg,
2651         )
2652     file_contents = []
2653     try:
2654         with salt.utils.files.fopen(name, "r") as fd:
2655             file_contents = fd.readlines()
2656     except OSError:
2657         ret["comment"] = "unable to open {n}".format(n=name)
2658         ret["result"] = True if ignore_if_missing else False
2659         return ret
2660     diff = []
2661     content = []
2662     tmpl = "{key}{sep}{value}" + os.linesep
2663     changes = 0
2664     diff_count = {k: count for k in key_values.keys()}
2665     for line in file_contents:
2666         test_line = line.lstrip(uncomment)
2667         did_uncomment = True if len(line) &gt; len(test_line) else False
2668         if key_ignore_case:
2669             test_line = test_line.lower()
2670         for key, value in key_values.items():
2671             test_key = key.lower() if key_ignore_case else key
2672             if test_line.startswith(test_key):
2673                 working_line = line.lstrip(uncomment) if did_uncomment else line
2674                 line_key, line_sep, line_value = working_line.partition(separator)
2675                 if line_sep != separator:
2676                     continue
2677                 keys_match = False
2678                 if key_ignore_case:
2679                     if line_key.lower() == test_key:
2680                         keys_match = True
2681                 else:
2682                     if line_key == test_key:
2683                         keys_match = True
2684                 if keys_match:
2685                     line_value = line_value.strip()
2686                     test_value = str(value).strip()
2687                     if value_ignore_case:
2688                         line_value = line_value.lower()
2689                         test_value = test_value.lower()
2690                     values_match = True if line_value == test_value else False
2691                     needs_changing = False
2692                     if did_uncomment:
2693                         if diff_count[key] &gt; 0:
2694                             needs_changing = True
2695                         elif not values_match:
2696                             values_match = True
2697                     else:
2698                         if diff_count[key] == 0:
2699                             needs_changing = True
2700                     if not values_match or needs_changing:
2701                         diff.append("- {}".format(line))
2702                         line = line[:0]
2703                         if diff_count[key] != 0:
2704                             line = str(
2705                                 tmpl.format(key=line_key, sep=line_sep, value=value)
2706                             )
2707                             if not isinstance(value, str):
2708                                 diff.append(
2709                                     "+ {} (from {} type){}".format(
2710                                         line.rstrip(), type(value).__name__, os.linesep
2711                                     )
2712                                 )
2713                             else:
2714                                 diff.append("+ {}".format(line))
2715                         changes += 1
2716                     if diff_count[key] &gt; 0:
2717                         diff_count[key] -= 1
2718                     continue
2719         content.append(line)
2720     fd.close()
2721     if append_if_not_found:
2722         tmpdiff = []
2723         for key, value in key_values.items():
2724             if diff_count[key] &gt; 0:
2725                 line = tmpl.format(key=key, sep=separator, value=value)
2726                 tmpdiff.append("+ {}".format(line))
2727                 content.append(line)
2728                 changes += 1
2729         if tmpdiff:
2730             tmpdiff.insert(0, "- &lt;EOF&gt;" + os.linesep)
2731             tmpdiff.append("+ &lt;EOF&gt;" + os.linesep)
2732             diff.extend(tmpdiff)
2733     elif prepend_if_not_found:
2734         did_diff = False
2735         for key, value in key_values.items():
2736             if diff_count[key] &gt; 0:
2737                 line = tmpl.format(key=key, sep=separator, value=value)
2738                 if not did_diff:
2739                     diff.insert(0, "  &lt;SOF&gt;" + os.linesep)
2740                     did_diff = True
2741                 diff.insert(1, "+ {}".format(line))
2742                 content.insert(0, line)
2743                 changes += 1
2744     if changes &gt; 0:
2745         if __opts__["test"]:
2746             ret["comment"] = "File {n} is set to be changed ({c} lines)".format(
2747                 n=name, c=changes
2748             )
2749             if show_changes:
2750                 ret["changes"]["diff"] = "".join(diff)
2751                 ret["comment"] += "\nPredicted diff:\n\r\t\t"
2752                 ret["comment"] += "\r\t\t".join(diff)
2753                 ret["result"] = None
2754         else:
2755             ret["comment"] = "Changed {c} lines".format(c=changes)
2756             if show_changes:
2757                 ret["changes"]["diff"] = "".join(diff)
2758     else:
2759         ret["result"] = True
2760         return ret
2761     if not __opts__["test"]:
2762         try:
2763             with salt.utils.files.fopen(name, "w") as fd:
2764                 fd.writelines(content)
2765                 fd.close()
2766         except OSError:
2767             ret["comment"] = "{n} not writable".format(n=name)
2768             ret["result"] = False
2769             return ret
2770         ret["result"] = True
2771     return ret
2772 def blockreplace(
2773     name,
2774     marker_start="#-- start managed zone --",
2775     marker_end="#-- end managed zone --",
2776     source=None,
2777     source_hash=None,
2778     template="jinja",
2779     sources=None,
2780     source_hashes=None,
2781     defaults=None,
2782     context=None,
2783     content="",
2784     append_if_not_found=False,
2785     prepend_if_not_found=False,
2786     backup=".bak",
2787     show_changes=True,
2788     append_newline=None,
2789     insert_before_match=None,
2790     insert_after_match=None,
2791 ):
2792     """
2793     Maintain an edit in a file in a zone delimited by two line markers
2794     .. versionadded:: 2014.1.0
2795     .. versionchanged:: 2017.7.5,2018.3.1
2796         ``append_newline`` argument added. Additionally, to improve
2797         idempotence, if the string represented by ``marker_end`` is found in
2798         the middle of the line, the content preceding the marker will be
2799         removed when the block is replaced. This allows one to remove
2800         ``append_newline: False`` from the SLS and have the block properly
2801         replaced if the end of the content block is immediately followed by the
2802         ``marker_end`` (i.e. no newline before the marker).
2803     A block of content delimited by comments can help you manage several lines
2804     entries without worrying about old entries removal. This can help you
2805     maintaining an un-managed file containing manual edits.
2806     .. note::
2807         This function will store two copies of the file in-memory (the original
2808         version and the edited version) in order to detect changes and only
2809         edit the targeted file if necessary.
2810         Additionally, you can use :py:func:`file.accumulated
2811         &lt;salt.states.file.accumulated&gt;` and target this state. All accumulated
2812         data dictionaries' content will be added in the content block.
2813     name
2814         Filesystem path to the file to be edited
2815     marker_start
2816         The line content identifying a line as the start of the content block.
2817         Note that the whole line containing this marker will be considered, so
2818         whitespace or extra content before or after the marker is included in
2819         final output
2820     marker_end
2821         The line content identifying the end of the content block. As of
2822         versions 2017.7.5 and 2018.3.1, everything up to the text matching the
2823         marker will be replaced, so it's important to ensure that your marker
2824         includes the beginning of the text you wish to replace.
2825     content
2826         The content to be used between the two lines identified by
2827         ``marker_start`` and ``marker_end``
2828     source
2829         The source file to download to the minion, this source file can be
2830         hosted on either the salt master server, or on an HTTP or FTP server.
2831         Both HTTPS and HTTP are supported as well as downloading directly
2832         from Amazon S3 compatible URLs with both pre-configured and automatic
2833         IAM credentials. (see s3.get state documentation)
2834         File retrieval from Openstack Swift object storage is supported via
2835         swift://container/object_path URLs, see swift.get documentation.
2836         For files hosted on the salt file server, if the file is located on
2837         the master in the directory named spam, and is called eggs, the source
2838         string is salt://spam/eggs. If source is left blank or None
2839         (use ~ in YAML), the file will be created as an empty file and
2840         the content will not be managed. This is also the case when a file
2841         already exists and the source is undefined; the contents of the file
2842         will not be changed or managed.
2843         If the file is hosted on a HTTP or FTP server then the source_hash
2844         argument is also required.
2845         A list of sources can also be passed in to provide a default source and
2846         a set of fallbacks. The first source in the list that is found to exist
2847         will be used and subsequent entries in the list will be ignored.
2848         .. code-block:: yaml
2849             file_override_example:
2850               file.blockreplace:
2851                 - name: /etc/example.conf
2852                 - source:
2853                   - salt://file_that_does_not_exist
2854                   - salt://file_that_exists
2855     source_hash
2856         This can be one of the following:
2857             1. a source hash string
2858             2. the URI of a file that contains source hash strings
2859         The function accepts the first encountered long unbroken alphanumeric
2860         string of correct length as a valid hash, in order from most secure to
2861         least secure:
2862         .. code-block:: text
2863             Type    Length
2864             ======  ======
2865             sha512     128
2866             sha384      96
2867             sha256      64
2868             sha224      56
2869             sha1        40
2870             md5         32
2871         See the ``source_hash`` parameter description for :mod:`file.managed
2872         &lt;salt.states.file.managed&gt;` function for more details and examples.
2873     template
2874         Templating engine to be used to render the downloaded file. The
2875         following engines are supported:
2876         - :mod:`cheetah &lt;salt.renderers.cheetah&gt;`
2877         - :mod:`genshi &lt;salt.renderers.genshi&gt;`
2878         - :mod:`jinja &lt;salt.renderers.jinja&gt;`
2879         - :mod:`mako &lt;salt.renderers.mako&gt;`
2880         - :mod:`py &lt;salt.renderers.py&gt;`
2881         - :mod:`wempy &lt;salt.renderers.wempy&gt;`
2882     context
2883         Overrides default context variables passed to the template
2884     defaults
2885         Default context passed to the template
2886     append_if_not_found
2887         If markers are not found and this option is set to ``True``, the
2888         content block will be appended to the file.
2889     prepend_if_not_found
2890         If markers are not found and this option is set to ``True``, the
2891         content block will be prepended to the file.
2892     insert_before_match
2893         If markers are not found, this parameter can be set to a regex which will
2894         insert the block before the first found occurrence in the file.
2895         .. versionadded:: 3001
2896     insert_after_match
2897         If markers are not found, this parameter can be set to a regex which will
2898         insert the block after the first found occurrence in the file.
2899         .. versionadded:: 3001
2900     backup
2901         The file extension to use for a backup of the file if any edit is made.
2902         Set this to ``False`` to skip making a backup.
2903     dry_run
2904         If ``True``, do not make any edits to the file and simply return the
2905         changes that *would* be made.
2906     show_changes
2907         Controls how changes are presented. If ``True``, the ``Changes``
2908         section of the state return will contain a unified diff of the changes
2909         made. If False, then it will contain a boolean (``True`` if any changes
2910         were made, otherwise ``False``).
2911     append_newline
2912         Controls whether or not a newline is appended to the content block. If
2913         the value of this argument is ``True`` then a newline will be added to
2914         the content block. If it is ``False``, then a newline will *not* be
2915         added to the content block. If it is unspecified, then a newline will
2916         only be added to the content block if it does not already end in a
2917         newline.
2918         .. versionadded:: 2017.7.5,2018.3.1
2919     Example of usage with an accumulator and with a variable:
2920     .. code-block:: jinja
2921         {% set myvar = 42 %}
2922         hosts-config-block-{{ myvar }}:
2923           file.blockreplace:
2924             - name: /etc/hosts
2925             - marker_start: "# START managed zone {{ myvar }} -DO-NOT-EDIT-"
2926             - marker_end: "# END managed zone {{ myvar }} --"
2927             - content: 'First line of content'
2928             - append_if_not_found: True
2929             - backup: '.bak'
2930             - show_changes: True
2931         hosts-config-block-{{ myvar }}-accumulated1:
2932           file.accumulated:
2933             - filename: /etc/hosts
2934             - name: my-accumulator-{{ myvar }}
2935             - text: "text 2"
2936             - require_in:
2937               - file: hosts-config-block-{{ myvar }}
2938         hosts-config-block-{{ myvar }}-accumulated2:
2939           file.accumulated:
2940             - filename: /etc/hosts
2941             - name: my-accumulator-{{ myvar }}
2942             - text: |
2943                  text 3
2944                  text 4
2945             - require_in:
2946               - file: hosts-config-block-{{ myvar }}
2947     will generate and maintain a block of content in ``/etc/hosts``:
2948     .. code-block:: text
2949         First line of content
2950         text 2
2951         text 3
2952         text 4
2953     """
2954     name = os.path.expanduser(name)
2955     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
2956     if not name:
2957         return _error(ret, "Must provide name to file.blockreplace")
2958     if sources is None:
2959         sources = []
2960     if source_hashes is None:
2961         source_hashes = []
2962     (ok_, err, sl_) = _unify_sources_and_hashes(
2963         source=source,
2964         source_hash=source_hash,
2965         sources=sources,
2966         source_hashes=source_hashes,
2967     )
2968     if not ok_:
2969         return _error(ret, err)
2970     check_res, check_msg = _check_file(name)
2971     if not check_res:
2972         return _error(ret, check_msg)
2973     accum_data, accum_deps = _load_accumulators()
2974     if name in accum_data:
2975         accumulator = accum_data[name]
2976         deps = accum_deps.get(name, [])
2977         filtered = [
2978             a for a in deps if __low__["__id__"] in deps[a] and a in accumulator
2979         ]
2980         if not filtered:
2981             filtered = [a for a in accumulator]
2982         for acc in filtered:
2983             acc_content = accumulator[acc]
2984             for line in acc_content:
2985                 if content == "":
2986                     content = line
2987                 else:
2988                     content += "\n" + line
2989     if sl_:
2990         tmpret = _get_template_texts(
2991             source_list=sl_, template=template, defaults=defaults, context=context
2992         )
2993         if not tmpret["result"]:
2994             return tmpret
2995         text = tmpret["data"]
2996         for index, item in enumerate(text):
2997             content += str(item)
2998     try:
2999         changes = __salt__["file.blockreplace"](
3000             name,
3001             marker_start,
3002             marker_end,
3003             content=content,
3004             append_if_not_found=append_if_not_found,
3005             prepend_if_not_found=prepend_if_not_found,
3006             insert_before_match=insert_before_match,
3007             insert_after_match=insert_after_match,
3008             backup=backup,
3009             dry_run=__opts__["test"],
3010             show_changes=show_changes,
3011             append_newline=append_newline,
3012         )
3013     except Exception as exc:  # pylint: disable=broad-except
3014         log.exception("Encountered error managing block")
3015         ret[
3016             "comment"
3017         ] = "Encountered error managing block: {}. See the log for details.".format(exc)
3018         return ret
3019     if changes:
3020         ret["changes"]["diff"] = changes
3021         if __opts__["test"]:
3022             ret["result"] = None
3023             ret["comment"] = "Changes would be made"
3024         else:
3025             ret["result"] = True
3026             ret["comment"] = "Changes were made"
3027     else:
3028         ret["result"] = True
3029         ret["comment"] = "No changes needed to be made"
3030     return ret
3031 def comment(name, regex, char="#", backup=".bak"):
3032     """
3033     Comment out specified lines in a file.
3034     name
3035         The full path to the file to be edited
3036     regex
3037         A regular expression used to find the lines that are to be commented;
3038         this pattern will be wrapped in parenthesis and will move any
3039         preceding/trailing ``^`` or ``$`` characters outside the parenthesis
3040         (e.g., the pattern ``^foo$`` will be rewritten as ``^(foo)$``)
3041         Note that you _need_ the leading ^, otherwise each time you run
3042         highstate, another comment char will be inserted.
3043     char
3044         The character to be inserted at the beginning of a line in order to
3045         comment it out
3046     backup
3047         The file will be backed up before edit with this file extension
3048         .. warning::
3049             This backup will be overwritten each time ``sed`` / ``comment`` /
3050             ``uncomment`` is called. Meaning the backup will only be useful
3051             after the first invocation.
3052         Set to False/None to not keep a backup.
3053     Usage:
3054     .. code-block:: yaml
3055         /etc/fstab:
3056           file.comment:
3057             - regex: ^bind 127.0.0.1
3058     .. versionadded:: 0.9.5
3059     """
3060     name = os.path.expanduser(name)
3061     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
3062     if not name:
3063         return _error(ret, "Must provide name to file.comment")
3064     check_res, check_msg = _check_file(name)
3065     if not check_res:
3066         return _error(ret, check_msg)
3067     unanchor_regex = re.sub(r"^(\(\?[iLmsux]\))?\^?(.*?)\$?$", r"\2", regex)
3068     comment_regex = char + unanchor_regex
3069     if not __salt__["file.search"](name, regex, multiline=True):
3070         if __salt__["file.search"](name, comment_regex, multiline=True):
3071             ret["comment"] = "Pattern already commented"
3072             ret["result"] = True
3073             return ret
3074         else:
3075             return _error(ret, "{}: Pattern not found".format(unanchor_regex))
3076     if __opts__["test"]:
3077         ret["changes"][name] = "updated"
3078         ret["comment"] = "File {} is set to be updated".format(name)
3079         ret["result"] = None
3080         return ret
3081     with salt.utils.files.fopen(name, "rb") as fp_:
3082         slines = fp_.read()
3083         slines = slines.decode(__salt_system_encoding__)
3084         slines = slines.splitlines(True)
3085     __salt__["file.comment_line"](name, regex, char, True, backup)
3086     with salt.utils.files.fopen(name, "rb") as fp_:
3087         nlines = fp_.read()
3088         nlines = nlines.decode(__salt_system_encoding__)
3089         nlines = nlines.splitlines(True)
3090     ret["result"] = __salt__["file.search"](name, unanchor_regex, multiline=True)
3091     if slines != nlines:
3092         if not __utils__["files.is_text"](name):
3093             ret["changes"]["diff"] = "Replace binary file"
3094         else:
3095             ret["changes"]["diff"] = "".join(difflib.unified_diff(slines, nlines))
3096     if ret["result"]:
3097         ret["comment"] = "Commented lines successfully"
3098     else:
3099         ret["comment"] = "Expected commented lines not found"
3100     return ret
3101 def uncomment(name, regex, char="#", backup=".bak"):
3102     """
3103     Uncomment specified commented lines in a file
3104     name
3105         The full path to the file to be edited
3106     regex
3107         A regular expression used to find the lines that are to be uncommented.
3108         This regex should not include the comment character. A leading ``^``
3109         character will be stripped for convenience (for easily switching
3110         between comment() and uncomment()).  The regex will be searched for
3111         from the beginning of the line, ignoring leading spaces (we prepend
3112         '^[ \\t]*')
3113     char
3114         The character to remove in order to uncomment a line
3115     backup
3116         The file will be backed up before edit with this file extension;
3117         .. warning::
3118             This backup will be overwritten each time ``sed`` / ``comment`` /
3119             ``uncomment`` is called. Meaning the backup will only be useful
3120             after the first invocation.
3121         Set to False/None to not keep a backup.
3122     Usage:
3123     .. code-block:: yaml
3124         /etc/adduser.conf:
3125           file.uncomment:
3126             - regex: EXTRA_GROUPS
3127     .. versionadded:: 0.9.5
3128     """
3129     name = os.path.expanduser(name)
3130     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
3131     if not name:
3132         return _error(ret, "Must provide name to file.uncomment")
3133     check_res, check_msg = _check_file(name)
3134     if not check_res:
3135         return _error(ret, check_msg)
3136     if __salt__["file.search"](
3137         name, "{}[ \t]*{}".format(char, regex.lstrip("^")), multiline=True
3138     ):
3139         pass
3140     elif __salt__["file.search"](
3141         name, "^[ \t]*{}".format(regex.lstrip("^")), multiline=True
3142     ):
3143         ret["comment"] = "Pattern already uncommented"
3144         ret["result"] = True
3145         return ret
3146     else:
3147         return _error(ret, "{}: Pattern not found".format(regex))
3148     if __opts__["test"]:
3149         ret["changes"][name] = "updated"
3150         ret["comment"] = "File {} is set to be updated".format(name)
3151         ret["result"] = None
3152         return ret
3153     with salt.utils.files.fopen(name, "rb") as fp_:
3154         slines = salt.utils.data.decode(fp_.readlines())
3155     __salt__["file.comment_line"](name, regex, char, False, backup)
3156     with salt.utils.files.fopen(name, "rb") as fp_:
3157         nlines = salt.utils.data.decode(fp_.readlines())
3158     ret["result"] = __salt__["file.search"](
3159         name, "^[ \t]*{}".format(regex.lstrip("^")), multiline=True
3160     )
3161     if slines != nlines:
3162         if not __utils__["files.is_text"](name):
3163             ret["changes"]["diff"] = "Replace binary file"
3164         else:
3165             ret["changes"]["diff"] = "".join(difflib.unified_diff(slines, nlines))
3166     if ret["result"]:
3167         ret["comment"] = "Uncommented lines successfully"
3168     else:
3169         ret["comment"] = "Expected uncommented lines not found"
3170     return ret
3171 def append(
3172     name,
3173     text=None,
3174     makedirs=False,
3175     source=None,
3176     source_hash=None,
3177     template="jinja",
3178     sources=None,
3179     source_hashes=None,
3180     defaults=None,
3181     context=None,
3182     ignore_whitespace=True,
3183 ):
3184     """
3185     Ensure that some text appears at the end of a file.
3186     The text will not be appended if it already exists in the file.
3187     A single string of text or a list of strings may be appended.
3188     name
3189         The location of the file to append to.
3190     text
3191         The text to be appended, which can be a single string or a list
3192         of strings.
3193     makedirs
3194         If the file is located in a path without a parent directory,
3195         then the state will fail. If makedirs is set to True, then
3196         the parent directories will be created to facilitate the
3197         creation of the named file. Defaults to False.
3198     source
3199         A single source file to append. This source file can be hosted on either
3200         the salt master server, or on an HTTP or FTP server. Both HTTPS and
3201         HTTP are supported as well as downloading directly from Amazon S3
3202         compatible URLs with both pre-configured and automatic IAM credentials
3203         (see s3.get state documentation). File retrieval from Openstack Swift
3204         object storage is supported via swift://container/object_path URLs
3205         (see swift.get documentation).
3206         For files hosted on the salt file server, if the file is located on
3207         the master in the directory named spam, and is called eggs, the source
3208         string is salt://spam/eggs.
3209         If the file is hosted on an HTTP or FTP server, the source_hash argument
3210         is also required.
3211     source_hash
3212         This can be one of the following:
3213             1. a source hash string
3214             2. the URI of a file that contains source hash strings
3215         The function accepts the first encountered long unbroken alphanumeric
3216         string of correct length as a valid hash, in order from most secure to
3217         least secure:
3218         .. code-block:: text
3219             Type    Length
3220             ======  ======
3221             sha512     128
3222             sha384      96
3223             sha256      64
3224             sha224      56
3225             sha1        40
3226             md5         32
3227         See the ``source_hash`` parameter description for :mod:`file.managed
3228         &lt;salt.states.file.managed&gt;` function for more details and examples.
3229     template
3230         The named templating engine will be used to render the appended-to file.
3231         Defaults to ``jinja``. The following templates are supported:
3232         - :mod:`cheetah&lt;salt.renderers.cheetah&gt;`
3233         - :mod:`genshi&lt;salt.renderers.genshi&gt;`
3234         - :mod:`jinja&lt;salt.renderers.jinja&gt;`
3235         - :mod:`mako&lt;salt.renderers.mako&gt;`
3236         - :mod:`py&lt;salt.renderers.py&gt;`
3237         - :mod:`wempy&lt;salt.renderers.wempy&gt;`
3238     sources
3239         A list of source files to append. If the files are hosted on an HTTP or
3240         FTP server, the source_hashes argument is also required.
3241     source_hashes
3242         A list of source_hashes corresponding to the sources list specified in
3243         the sources argument.
3244     defaults
3245         Default context passed to the template.
3246     context
3247         Overrides default context variables passed to the template.
3248     ignore_whitespace
3249         .. versionadded:: 2015.8.4
3250         Spaces and Tabs in text are ignored by default, when searching for the
3251         appending content, one space or multiple tabs are the same for salt.
3252         Set this option to ``False`` if you want to change this behavior.
3253     Multi-line example:
3254     .. code-block:: yaml
3255         /etc/motd:
3256           file.append:
3257             - text: |
3258                 Thou hadst better eat salt with the Philosophers of Greece,
3259                 than sugar with the Courtiers of Italy.
3260                 - Benjamin Franklin
3261     Multiple lines of text:
3262     .. code-block:: yaml
3263         /etc/motd:
3264           file.append:
3265             - text:
3266               - Trust no one unless you have eaten much salt with him.
3267               - "Salt is born of the purest of parents: the sun and the sea."
3268     Gather text from multiple template files:
3269     .. code-block:: yaml
3270         /etc/motd:
3271           file:
3272             - append
3273             - template: jinja
3274             - sources:
3275               - salt://motd/devops-messages.tmpl
3276               - salt://motd/hr-messages.tmpl
3277               - salt://motd/general-messages.tmpl
3278     .. versionadded:: 0.9.5
3279     """
3280     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
3281     if not name:
3282         return _error(ret, "Must provide name to file.append")
3283     name = os.path.expanduser(name)
3284     if sources is None:
3285         sources = []
3286     if source_hashes is None:
3287         source_hashes = []
3288     (ok_, err, sl_) = _unify_sources_and_hashes(
3289         source=source,
3290         source_hash=source_hash,
3291         sources=sources,
3292         source_hashes=source_hashes,
3293     )
3294     if not ok_:
3295         return _error(ret, err)
3296     if makedirs is True:
3297         dirname = os.path.dirname(name)
3298         if __opts__["test"]:
3299             ret["comment"] = "Directory {} is set to be updated".format(dirname)
3300             ret["result"] = None
3301         else:
3302             if not __salt__["file.directory_exists"](dirname):
3303                 try:
3304                     _makedirs(name=name)
3305                 except CommandExecutionError as exc:
3306                     return _error(ret, "Drive {} is not mapped".format(exc.message))
3307                 check_res, check_msg, check_changes = (
3308                     _check_directory_win(dirname)
3309                     if salt.utils.platform.is_windows()
3310                     else _check_directory(dirname)
3311                 )
3312                 if not check_res:
3313                     ret["changes"] = check_changes
3314                     return _error(ret, check_msg)
3315     check_res, check_msg = _check_file(name)
3316     if not check_res:
3317         touch_ret = touch(name, makedirs=makedirs)
3318         if __opts__["test"]:
3319             return touch_ret
3320         retry_res, retry_msg = _check_file(name)
3321         if not retry_res:
3322             return _error(ret, check_msg)
3323     if sl_:
3324         tmpret = _get_template_texts(
3325             source_list=sl_, template=template, defaults=defaults, context=context
3326         )
3327         if not tmpret["result"]:
3328             return tmpret
3329         text = tmpret["data"]
3330     text = _validate_str_list(text)
3331     with salt.utils.files.fopen(name, "rb") as fp_:
3332         slines = fp_.read()
3333         slines = slines.decode(__salt_system_encoding__)
3334         slines = slines.splitlines()
3335     append_lines = []
3336     try:
3337         for chunk in text:
3338             if ignore_whitespace:
3339                 if __salt__["file.search"](
3340                     name,
3341                     salt.utils.stringutils.build_whitespace_split_regex(chunk),
3342                     multiline=True,
3343                 ):
3344                     continue
3345             elif __salt__["file.search"](name, chunk, multiline=True):
3346                 continue
3347             for line_item in chunk.splitlines():
3348                 append_lines.append("{}".format(line_item))
3349     except TypeError:
3350         return _error(ret, "No text found to append. Nothing appended")
3351     if __opts__["test"]:
3352         ret["comment"] = "File {} is set to be updated".format(name)
3353         ret["result"] = None
3354         nlines = list(slines)
3355         nlines.extend(append_lines)
3356         if slines != nlines:
3357             if not __utils__["files.is_text"](name):
3358                 ret["changes"]["diff"] = "Replace binary file"
3359             else:
3360                 ret["changes"]["diff"] = "\n".join(difflib.unified_diff(slines, nlines))
3361         else:
3362             ret["comment"] = "File {} is in correct state".format(name)
3363             ret["result"] = True
3364         return ret
3365     if append_lines:
3366         __salt__["file.append"](name, args=append_lines)
3367         ret["comment"] = "Appended {} lines".format(len(append_lines))
3368     else:
3369         ret["comment"] = "File {} is in correct state".format(name)
3370     with salt.utils.files.fopen(name, "rb") as fp_:
3371         nlines = fp_.read()
3372         nlines = nlines.decode(__salt_system_encoding__)
3373         nlines = nlines.splitlines()
3374     if slines != nlines:
3375         if not __utils__["files.is_text"](name):
3376             ret["changes"]["diff"] = "Replace binary file"
3377         else:
3378             ret["changes"]["diff"] = "\n".join(difflib.unified_diff(slines, nlines))
3379     ret["result"] = True
3380     return ret
3381 def prepend(
3382     name,
3383     text=None,
3384     makedirs=False,
3385     source=None,
3386     source_hash=None,
3387     template="jinja",
3388     sources=None,
3389     source_hashes=None,
3390     defaults=None,
3391     context=None,
3392     header=None,
3393 ):
3394     """
3395     Ensure that some text appears at the beginning of a file
3396     The text will not be prepended again if it already exists in the file. You
3397     may specify a single line of text or a list of lines to append.
3398     name
3399         The location of the file to append to.
3400     text
3401         The text to be appended, which can be a single string or a list
3402         of strings.
3403     makedirs
3404         If the file is located in a path without a parent directory,
3405         then the state will fail. If makedirs is set to True, then
3406         the parent directories will be created to facilitate the
3407         creation of the named file. Defaults to False.
3408     source
3409         A single source file to append. This source file can be hosted on either
3410         the salt master server, or on an HTTP or FTP server. Both HTTPS and
3411         HTTP are supported as well as downloading directly from Amazon S3
3412         compatible URLs with both pre-configured and automatic IAM credentials
3413         (see s3.get state documentation). File retrieval from Openstack Swift
3414         object storage is supported via swift://container/object_path URLs
3415         (see swift.get documentation).
3416         For files hosted on the salt file server, if the file is located on
3417         the master in the directory named spam, and is called eggs, the source
3418         string is salt://spam/eggs.
3419         If the file is hosted on an HTTP or FTP server, the source_hash argument
3420         is also required.
3421     source_hash
3422         This can be one of the following:
3423             1. a source hash string
3424             2. the URI of a file that contains source hash strings
3425         The function accepts the first encountered long unbroken alphanumeric
3426         string of correct length as a valid hash, in order from most secure to
3427         least secure:
3428         .. code-block:: text
3429             Type    Length
3430             ======  ======
3431             sha512     128
3432             sha384      96
3433             sha256      64
3434             sha224      56
3435             sha1        40
3436             md5         32
3437         See the ``source_hash`` parameter description for :mod:`file.managed
3438         &lt;salt.states.file.managed&gt;` function for more details and examples.
3439     template
3440         The named templating engine will be used to render the appended-to file.
3441         Defaults to ``jinja``. The following templates are supported:
3442         - :mod:`cheetah&lt;salt.renderers.cheetah&gt;`
3443         - :mod:`genshi&lt;salt.renderers.genshi&gt;`
3444         - :mod:`jinja&lt;salt.renderers.jinja&gt;`
3445         - :mod:`mako&lt;salt.renderers.mako&gt;`
3446         - :mod:`py&lt;salt.renderers.py&gt;`
3447         - :mod:`wempy&lt;salt.renderers.wempy&gt;`
3448     sources
3449         A list of source files to append. If the files are hosted on an HTTP or
3450         FTP server, the source_hashes argument is also required.
3451     source_hashes
3452         A list of source_hashes corresponding to the sources list specified in
3453         the sources argument.
3454     defaults
3455         Default context passed to the template.
3456     context
3457         Overrides default context variables passed to the template.
3458     ignore_whitespace
3459         .. versionadded:: 2015.8.4
3460         Spaces and Tabs in text are ignored by default, when searching for the
3461         appending content, one space or multiple tabs are the same for salt.
3462         Set this option to ``False`` if you want to change this behavior.
3463     Multi-line example:
3464     .. code-block:: yaml
3465         /etc/motd:
3466           file.prepend:
3467             - text: |
3468                 Thou hadst better eat salt with the Philosophers of Greece,
3469                 than sugar with the Courtiers of Italy.
3470                 - Benjamin Franklin
3471     Multiple lines of text:
3472     .. code-block:: yaml
3473         /etc/motd:
3474           file.prepend:
3475             - text:
3476               - Trust no one unless you have eaten much salt with him.
3477               - "Salt is born of the purest of parents: the sun and the sea."
3478     Optionally, require the text to appear exactly as specified
3479     (order and position). Combine with multi-line or multiple lines of input.
3480     .. code-block:: yaml
3481         /etc/motd:
3482           file.prepend:
3483             - header: True
3484             - text:
3485               - This will be the very first line in the file.
3486               - The 2nd line, regardless of duplicates elsewhere in the file.
3487               - These will be written anew if they do not appear verbatim.
3488     Gather text from multiple template files:
3489     .. code-block:: yaml
3490         /etc/motd:
3491           file:
3492             - prepend
3493             - template: jinja
3494             - sources:
3495               - salt://motd/devops-messages.tmpl
3496               - salt://motd/hr-messages.tmpl
3497               - salt://motd/general-messages.tmpl
3498     .. versionadded:: 2014.7.0
3499     """
3500     name = os.path.expanduser(name)
3501     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
3502     if not name:
3503         return _error(ret, "Must provide name to file.prepend")
3504     if sources is None:
3505         sources = []
3506     if source_hashes is None:
3507         source_hashes = []
3508     (ok_, err, sl_) = _unify_sources_and_hashes(
3509         source=source,
3510         source_hash=source_hash,
3511         sources=sources,
3512         source_hashes=source_hashes,
3513     )
3514     if not ok_:
3515         return _error(ret, err)
3516     if makedirs is True:
3517         dirname = os.path.dirname(name)
3518         if __opts__["test"]:
3519             ret["comment"] = "Directory {} is set to be updated".format(dirname)
3520             ret["result"] = None
3521         else:
3522             if not __salt__["file.directory_exists"](dirname):
3523                 try:
3524                     _makedirs(name=name)
3525                 except CommandExecutionError as exc:
3526                     return _error(ret, "Drive {} is not mapped".format(exc.message))
3527                 check_res, check_msg, check_changes = (
3528                     _check_directory_win(dirname)
3529                     if salt.utils.platform.is_windows()
3530                     else _check_directory(dirname)
3531                 )
3532                 if not check_res:
3533                     ret["changes"] = check_changes
3534                     return _error(ret, check_msg)
3535     check_res, check_msg = _check_file(name)
3536     if not check_res:
3537         touch_ret = touch(name, makedirs=makedirs)
3538         if __opts__["test"]:
3539             return touch_ret
3540         retry_res, retry_msg = _check_file(name)
3541         if not retry_res:
3542             return _error(ret, check_msg)
3543     if sl_:
3544         tmpret = _get_template_texts(
3545             source_list=sl_, template=template, defaults=defaults, context=context
3546         )
3547         if not tmpret["result"]:
3548             return tmpret
3549         text = tmpret["data"]
3550     text = _validate_str_list(text)
3551     with salt.utils.files.fopen(name, "rb") as fp_:
3552         slines = fp_.read()
3553         slines = slines.decode(__salt_system_encoding__)
3554         slines = slines.splitlines(True)
3555     count = 0
3556     test_lines = []
3557     preface = []
3558     for chunk in text:
3559         if not header:
3560             if __salt__["file.search"](
3561                 name,
3562                 salt.utils.stringutils.build_whitespace_split_regex(chunk),
3563                 multiline=True,
3564             ):
3565                 continue
3566         lines = chunk.splitlines()
3567         for line in lines:
3568             if __opts__["test"]:
3569                 ret["comment"] = "File {} is set to be updated".format(name)
3570                 ret["result"] = None
3571                 test_lines.append("{}\n".format(line))
3572             else:
3573                 preface.append(line)
3574             count += 1
3575     if __opts__["test"]:
3576         nlines = test_lines + slines
3577         if slines != nlines:
3578             if not __utils__["files.is_text"](name):
3579                 ret["changes"]["diff"] = "Replace binary file"
3580             else:
3581                 ret["changes"]["diff"] = "".join(difflib.unified_diff(slines, nlines))
3582             ret["result"] = None
3583         else:
3584             ret["comment"] = "File {} is in correct state".format(name)
3585             ret["result"] = True
3586         return ret
3587     if header:
3588         with salt.utils.files.fopen(name, "rb") as fp_:
3589             contents = fp_.read()
3590             contents = contents.decode(__salt_system_encoding__)
3591             contents = contents.splitlines(True)
3592             target_head = contents[0 : len(preface)]
3593             target_lines = []
3594             for chunk in target_head:
3595                 target_lines += chunk.splitlines()
3596             if target_lines != preface:
3597                 __salt__["file.prepend"](name, *preface)
3598             else:
3599                 count = 0
3600     else:
3601         __salt__["file.prepend"](name, *preface)
3602     with salt.utils.files.fopen(name, "rb") as fp_:
3603         nlines = fp_.read()
3604         nlines = nlines.decode(__salt_system_encoding__)
3605         nlines = nlines.splitlines(True)
3606     if slines != nlines:
3607         if not __utils__["files.is_text"](name):
3608             ret["changes"]["diff"] = "Replace binary file"
3609         else:
3610             ret["changes"]["diff"] = "".join(difflib.unified_diff(slines, nlines))
3611     if count:
3612         ret["comment"] = "Prepended {} lines".format(count)
3613     else:
3614         ret["comment"] = "File {} is in correct state".format(name)
3615     ret["result"] = True
3616     return ret
3617 def patch(
3618     name,
3619     source=None,
3620     source_hash=None,
3621     source_hash_name=None,
3622     skip_verify=False,
3623     template=None,
3624     context=None,
3625     defaults=None,
3626     options="",
3627     reject_file=None,
3628     strip=None,
3629     saltenv=None,
3630     **kwargs
3631 ):
3632     """
3633     Ensure that a patch has been applied to the specified file or directory
3634     .. versionchanged:: 2019.2.0
3635         The ``hash`` and ``dry_run_first`` options are now ignored, as the
3636         logic which determines whether or not the patch has already been
3637         applied no longer requires them. Additionally, this state now supports
3638         patch files that modify more than one file. To use these sort of
3639         patches, specify a directory (and, if necessary, the ``strip`` option)
3640         instead of a file.
3641     .. note::
3642         A suitable ``patch`` executable must be available on the minion. Also,
3643         keep in mind that the pre-check this state does to determine whether or
3644         not changes need to be made will create a temp file and send all patch
3645         output to that file. This means that, in the event that the patch would
3646         not have applied cleanly, the comment included in the state results will
3647         reference a temp file that will no longer exist once the state finishes
3648         running.
3649     name
3650         The file or directory to which the patch should be applied
3651     source
3652         The patch file to apply
3653         .. versionchanged:: 2019.2.0
3654             The source can now be from any file source supported by Salt
3655             (``salt://``, ``http://``, ``https://``, ``ftp://``, etc.).
3656             Templating is also now supported.
3657     source_hash
3658         Works the same way as in :py:func:`file.managed
3659         &lt;salt.states.file.managed&gt;`.
3660         .. versionadded:: 2019.2.0
3661     source_hash_name
3662         Works the same way as in :py:func:`file.managed
3663         &lt;salt.states.file.managed&gt;`
3664         .. versionadded:: 2019.2.0
3665     skip_verify
3666         Works the same way as in :py:func:`file.managed
3667         &lt;salt.states.file.managed&gt;`
3668         .. versionadded:: 2019.2.0
3669     template
3670         Works the same way as in :py:func:`file.managed
3671         &lt;salt.states.file.managed&gt;`
3672         .. versionadded:: 2019.2.0
3673     context
3674         Works the same way as in :py:func:`file.managed
3675         &lt;salt.states.file.managed&gt;`
3676         .. versionadded:: 2019.2.0
3677     defaults
3678         Works the same way as in :py:func:`file.managed
3679         &lt;salt.states.file.managed&gt;`
3680         .. versionadded:: 2019.2.0
3681     options
3682         Extra options to pass to patch. This should not be necessary in most
3683         cases.
3684         .. note::
3685             For best results, short opts should be separate from one another.
3686             The ``-N`` and ``-r``, and ``-o`` options are used internally by
3687             this state and cannot be used here. Additionally, instead of using
3688             ``-pN`` or ``--strip=N``, use the ``strip`` option documented
3689             below.
3690     reject_file
3691         If specified, any rejected hunks will be written to this file. If not
3692         specified, then they will be written to a temp file which will be
3693         deleted when the state finishes running.
3694         .. important::
3695             The parent directory must exist. Also, this will overwrite the file
3696             if it is already present.
3697         .. versionadded:: 2019.2.0
3698     strip
3699         Number of directories to strip from paths in the patch file. For
3700         example, using the below SLS would instruct Salt to use ``-p1`` when
3701         applying the patch:
3702         .. code-block:: yaml
3703             /etc/myfile.conf:
3704               file.patch:
3705                 - source: salt://myfile.patch
3706                 - strip: 1
3707         .. versionadded:: 2019.2.0
3708             In previous versions, ``-p1`` would need to be passed as part of
3709             the ``options`` value.
3710     saltenv
3711         Specify the environment from which to retrieve the patch file indicated
3712         by the ``source`` parameter. If not provided, this defaults to the
3713         environment from which the state is being executed.
3714         .. note::
3715             Ignored when the patch file is from a non-``salt://`` source.
3716     **Usage:**
3717     .. code-block:: yaml
3718         /opt/myfile.txt:
3719           file.patch:
3720             - source: salt://myfile.patch
3721     """
3722     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
3723     if not salt.utils.path.which("patch"):
3724         ret["comment"] = "patch executable not found on minion"
3725         return ret
3726     is_dir = False
3727     if not name:
3728         ret["comment"] = "A file/directory to be patched is required"
3729         return ret
3730     else:
3731         try:
3732             name = os.path.expanduser(name)
3733         except Exception:  # pylint: disable=broad-except
3734             ret["comment"] = "Invalid path '{}'".format(name)
3735             return ret
3736         else:
3737             if not os.path.isabs(name):
3738                 ret["comment"] = "{} is not an absolute path".format(name)
3739                 return ret
3740             elif not os.path.exists(name):
3741                 ret["comment"] = "{} does not exist".format(name)
3742                 return ret
3743             else:
3744                 is_dir = os.path.isdir(name)
3745     for deprecated_arg in ("hash", "dry_run_first"):
3746         if deprecated_arg in kwargs:
3747             ret.setdefault("warnings", []).append(
3748                 "The '{}' argument is no longer used and has been ignored.".format(
3749                     deprecated_arg
3750                 )
3751             )
3752     if reject_file is not None:
3753         try:
3754             reject_file_parent = os.path.dirname(reject_file)
3755         except Exception:  # pylint: disable=broad-except
3756             ret["comment"] = "Invalid path '{}' for reject_file".format(reject_file)
3757             return ret
3758         else:
3759             if not os.path.isabs(reject_file_parent):
3760                 ret["comment"] = "'{}' is not an absolute path".format(reject_file)
3761                 return ret
3762             elif not os.path.isdir(reject_file_parent):
3763                 ret["comment"] = (
3764                     "Parent directory for reject_file '{}' either does "
3765                     "not exist, or is not a directory".format(reject_file)
3766                 )
3767                 return ret
3768     sanitized_options = []
3769     options = salt.utils.args.shlex_split(options)
3770     index = 0
3771     max_index = len(options) - 1
3772     blacklisted_options = []
3773     while index &lt;= max_index:
3774         option = options[index]
3775         if not isinstance(option, str):
3776             option = str(option)
3777         for item in ("-N", "--forward", "-r", "--reject-file", "-o", "--output"):
3778             if option.startswith(item):
3779                 blacklisted = option
3780                 break
3781         else:
3782             blacklisted = None
3783         if blacklisted is not None:
3784             blacklisted_options.append(blacklisted)
3785         if option.startswith("-p"):
3786             try:
3787                 strip = int(option[2:])
3788             except Exception:  # pylint: disable=broad-except
3789                 ret["comment"] = (
3790                     "Invalid format for '-p' CLI option. Consider using "
3791                     "the 'strip' option for this state."
3792                 )
3793                 return ret
3794         elif option.startswith("--strip"):
3795             if "=" in option:
3796                 try:
3797                     strip = int(option.rsplit("=", 1)[-1])
3798                 except Exception:  # pylint: disable=broad-except
3799                     ret["comment"] = (
3800                         "Invalid format for '-strip' CLI option. Consider "
3801                         "using the 'strip' option for this state."
3802                     )
3803                     return ret
3804             else:
3805                 try:
3806                     strip = int(options[index + 1])
3807                 except Exception:  # pylint: disable=broad-except
3808                     ret["comment"] = (
3809                         "Invalid format for '-strip' CLI option. Consider "
3810                         "using the 'strip' option for this state."
3811                     )
3812                     return ret
3813                 else:
3814                     index += 1
3815         else:
3816             sanitized_options.append(option)
3817         index += 1
3818     if blacklisted_options:
3819         ret["comment"] = "The following CLI options are not allowed: {}".format(
3820             ", ".join(blacklisted_options)
3821         )
3822         return ret
3823     options = sanitized_options
3824     try:
3825         source_match = __salt__["file.source_list"](source, source_hash, __env__)[0]
3826     except CommandExecutionError as exc:
3827         ret["result"] = False
3828         ret["comment"] = exc.strerror
3829         return ret
3830     else:
3831         if saltenv is not None:
3832             source_match_url, source_match_saltenv = salt.utils.url.parse(source_match)
3833             if source_match_url.startswith("salt://"):
3834                 if source_match_saltenv is not None and source_match_saltenv != saltenv:
3835                     ret.setdefault("warnings", []).append(
3836                         "Ignoring 'saltenv' option in favor of saltenv "
3837                         "included in the source URL."
3838                     )
3839                 else:
3840                     source_match += "?saltenv={}".format(saltenv)
3841     cleanup = []
3842     try:
3843         patch_file = salt.utils.files.mkstemp()
3844         cleanup.append(patch_file)
3845         try:
3846             orig_test = __opts__["test"]
3847             __opts__["test"] = False
3848             sys.modules[__salt__["file.patch"].__module__].__opts__["test"] = False
3849             result = managed(
3850                 patch_file,
3851                 source=source_match,
3852                 source_hash=source_hash,
3853                 source_hash_name=source_hash_name,
3854                 skip_verify=skip_verify,
3855                 template=template,
3856                 context=context,
3857                 defaults=defaults,
3858             )
3859         except Exception as exc:  # pylint: disable=broad-except
3860             msg = "Failed to cache patch file {}: {}".format(
3861                 salt.utils.url.redact_http_basic_auth(source_match), exc
3862             )
3863             log.exception(msg)
3864             ret["comment"] = msg
3865             return ret
3866         else:
3867             log.debug("file.managed: %s", result)
3868         finally:
3869             __opts__["test"] = orig_test
3870             sys.modules[__salt__["file.patch"].__module__].__opts__["test"] = orig_test
3871         if not orig_test and not result["result"]:
3872             log.debug(
3873                 "failed to download %s",
3874                 salt.utils.url.redact_http_basic_auth(source_match),
3875             )
3876             return result
3877         def _patch(patch_file, options=None, dry_run=False):
3878             patch_opts = copy.copy(sanitized_options)
3879             if options is not None:
3880                 patch_opts.extend(options)
3881             return __salt__["file.patch"](
3882                 name, patch_file, options=patch_opts, dry_run=dry_run
3883             )
3884         if reject_file is not None:
3885             patch_rejects = reject_file
3886         else:
3887             patch_rejects = salt.utils.files.mkstemp()
3888             cleanup.append(patch_rejects)
3889         patch_output = salt.utils.files.mkstemp()
3890         cleanup.append(patch_output)
3891         patch_opts = ["-N", "-r", patch_rejects, "-o", patch_output]
3892         if is_dir and strip is not None:
3893             patch_opts.append("-p{}".format(strip))
3894         pre_check = _patch(patch_file, patch_opts)
3895         if pre_check["retcode"] != 0:
3896             reverse_pass = _patch(patch_rejects, ["-R", "-f"], dry_run=True)
3897             already_applied = reverse_pass["retcode"] == 0
3898             if pre_check["retcode"] == 2 and pre_check["stderr"]:
3899                 ret["comment"] = pre_check["stderr"]
3900                 ret["result"] = False
3901                 return ret
3902             if already_applied:
3903                 ret["comment"] = "Patch was already applied"
3904                 ret["result"] = True
3905                 return ret
3906             else:
3907                 ret["comment"] = (
3908                     "Patch would not apply cleanly, no changes made. Results "
3909                     "of dry-run are below."
3910                 )
3911                 if reject_file is None:
3912                     ret["comment"] += (
3913                         " Run state again using the reject_file option to "
3914                         "save rejects to a persistent file."
3915                     )
3916                 opts = copy.copy(__opts__)
3917                 opts["color"] = False
3918                 ret["comment"] += "\n\n" + salt.output.out_format(
3919                     pre_check, "nested", opts, nested_indent=14
3920                 )
3921                 return ret
3922         if __opts__["test"]:
3923             ret["result"] = None
3924             ret["comment"] = "The patch would be applied"
3925             ret["changes"] = pre_check
3926             return ret
3927         patch_opts = []
3928         if is_dir and strip is not None:
3929             patch_opts.append("-p{}".format(strip))
3930         ret["changes"] = _patch(patch_file, patch_opts)
3931         if ret["changes"]["retcode"] == 0:
3932             ret["comment"] = "Patch successfully applied"
3933             ret["result"] = True
3934         else:
3935             ret["comment"] = "Failed to apply patch"
3936         return ret
3937     finally:
3938         for path in cleanup:
3939             try:
3940                 os.remove(path)
3941             except OSError as exc:
3942                 if exc.errno != os.errno.ENOENT:
3943                     log.error(
3944                         "file.patch: Failed to remove temp file %s: %s", path, exc
3945                     )
3946 def touch(name, atime=None, mtime=None, makedirs=False):
3947     """
3948     Replicate the 'nix "touch" command to create a new empty
3949     file or update the atime and mtime of an existing file.
3950     Note that if you just want to create a file and don't care about atime or
3951     mtime, you should use ``file.managed`` instead, as it is more
3952     feature-complete.  (Just leave out the ``source``/``template``/``contents``
3953     arguments, and it will just create the file and/or check its permissions,
3954     without messing with contents)
3955     name
3956         name of the file
3957     atime
3958         atime of the file
3959     mtime
3960         mtime of the file
3961     makedirs
3962         whether we should create the parent directory/directories in order to
3963         touch the file
3964     Usage:
3965     .. code-block:: yaml
3966         /var/log/httpd/logrotate.empty:
3967           file.touch
3968     .. versionadded:: 0.9.5
3969     """
3970     name = os.path.expanduser(name)
3971     ret = {
3972         "name": name,
3973         "changes": {},
3974     }
3975     if not name:
3976         return _error(ret, "Must provide name to file.touch")
3977     if not os.path.isabs(name):
3978         return _error(ret, "Specified file {} is not an absolute path".format(name))
3979     if __opts__["test"]:
3980         ret.update(_check_touch(name, atime, mtime))
3981         return ret
3982     if makedirs:
3983         try:
3984             _makedirs(name=name)
3985         except CommandExecutionError as exc:
3986             return _error(ret, "Drive {} is not mapped".format(exc.message))
3987     if not os.path.isdir(os.path.dirname(name)):
3988         return _error(ret, "Directory not present to touch file {}".format(name))
3989     extant = os.path.exists(name)
3990     ret["result"] = __salt__["file.touch"](name, atime, mtime)
3991     if not extant and ret["result"]:
3992         ret["comment"] = "Created empty file {}".format(name)
3993         ret["changes"]["new"] = name
3994     elif extant and ret["result"]:
3995         ret["comment"] = "Updated times on {} {}".format(
3996             "directory" if os.path.isdir(name) else "file", name
3997         )
3998         ret["changes"]["touched"] = name
3999     return ret
4000 def copy_(
4001     name,
4002     source,
4003     force=False,
4004     makedirs=False,
4005     preserve=False,
4006     user=None,
4007     group=None,
4008     mode=None,
4009     subdir=False,
4010     **kwargs
4011 ):
4012     """
4013     If the file defined by the ``source`` option exists on the minion, copy it
4014     to the named path. The file will not be overwritten if it already exists,
4015     unless the ``force`` option is set to ``True``.
4016     .. note::
4017         This state only copies files from one location on a minion to another
4018         location on the same minion. For copying files from the master, use a
4019         :py:func:`file.managed &lt;salt.states.file.managed&gt;` state.
4020     name
4021         The location of the file to copy to
4022     source
4023         The location of the file to copy to the location specified with name
4024     force
4025         If the target location is present then the file will not be moved,
4026         specify "force: True" to overwrite the target file
4027     makedirs
4028         If the target subdirectories don't exist create them
4029     preserve
4030         .. versionadded:: 2015.5.0
4031         Set ``preserve: True`` to preserve user/group ownership and mode
4032         after copying. Default is ``False``. If ``preserve`` is set to ``True``,
4033         then user/group/mode attributes will be ignored.
4034     user
4035         .. versionadded:: 2015.5.0
4036         The user to own the copied file, this defaults to the user salt is
4037         running as on the minion. If ``preserve`` is set to ``True``, then
4038         this will be ignored
4039     group
4040         .. versionadded:: 2015.5.0
4041         The group to own the copied file, this defaults to the group salt is
4042         running as on the minion. If ``preserve`` is set to ``True`` or on
4043         Windows this will be ignored
4044     mode
4045         .. versionadded:: 2015.5.0
4046         The permissions to set on the copied file, aka 644, '0775', '4664'.
4047         If ``preserve`` is set to ``True``, then this will be ignored.
4048         Not supported on Windows.
4049         The default mode for new files and directories corresponds umask of salt
4050         process. For existing files and directories it's not enforced.
4051     subdir
4052         .. versionadded:: 2015.5.0
4053         If the name is a directory then place the file inside the named
4054         directory
4055     .. note::
4056         The copy function accepts paths that are local to the Salt minion.
4057         This function does not support salt://, http://, or the other
4058         additional file paths that are supported by :mod:`states.file.managed
4059         &lt;salt.states.file.managed&gt;` and :mod:`states.file.recurse
4060         &lt;salt.states.file.recurse&gt;`.
4061     Usage:
4062     .. code-block:: yaml
4063         /etc/example.conf:
4064           file.copy:
4065             - source: /tmp/example.conf
4066     """
4067     name = os.path.expanduser(name)
4068     source = os.path.expanduser(source)
4069     ret = {
4070         "name": name,
4071         "changes": {},
4072         "comment": 'Copied "{}" to "{}"'.format(source, name),
4073         "result": True,
4074     }
4075     if not name:
4076         return _error(ret, "Must provide name to file.copy")
4077     changed = True
4078     if not os.path.isabs(name):
4079         return _error(ret, "Specified file {} is not an absolute path".format(name))
4080     if not os.path.exists(source):
4081         return _error(ret, 'Source file "{}" is not present'.format(source))
4082     if preserve:
4083         user = __salt__["file.get_user"](source)
4084         group = __salt__["file.get_group"](source)
4085         mode = __salt__["file.get_mode"](source)
4086     else:
4087         user = _test_owner(kwargs, user=user)
4088         if user is None:
4089             user = __opts__["user"]
4090         if salt.utils.platform.is_windows():
4091             if group is not None:
4092                 log.warning(
4093                     "The group argument for %s has been ignored as this is "
4094                     "a Windows system.",
4095                     name,
4096                 )
4097             group = user
4098         if group is None:
4099             if "user.info" in __salt__:
4100                 group = __salt__["file.gid_to_group"](
4101                     __salt__["user.info"](user).get("gid", 0)
4102                 )
4103             else:
4104                 group = user
4105         u_check = _check_user(user, group)
4106         if u_check:
4107             return _error(ret, u_check)
4108         if mode is None:
4109             mode = __salt__["file.get_mode"](source)
4110     if os.path.isdir(name) and subdir:
4111         name = os.path.join(name, os.path.basename(source))
4112     if os.path.lexists(source) and os.path.lexists(name):
4113         if force and os.path.isfile(name):
4114             hash1 = salt.utils.hashutils.get_hash(name)
4115             hash2 = salt.utils.hashutils.get_hash(source)
4116             if hash1 == hash2:
4117                 changed = True
4118                 ret["comment"] = " ".join(
4119                     [ret["comment"], "- files are identical but force flag is set"]
4120                 )
4121         if not force:
4122             changed = False
4123         elif not __opts__["test"] and changed:
4124             try:
4125                 __salt__["file.remove"](name)
4126             except OSError:
4127                 return _error(
4128                     ret,
4129                     'Failed to delete "{}" in preparation for forced move'.format(name),
4130                 )
4131     if __opts__["test"]:
4132         if changed:
4133             ret["comment"] = 'File "{}" is set to be copied to "{}"'.format(
4134                 source, name
4135             )
4136             ret["result"] = None
4137         else:
4138             ret[
4139                 "comment"
4140             ] = 'The target file "{}" exists and will not be overwritten'.format(name)
4141             ret["result"] = True
4142         return ret
4143     if not changed:
4144         ret[
4145             "comment"
4146         ] = 'The target file "{}" exists and will not be overwritten'.format(name)
4147         ret["result"] = True
4148         return ret
4149     dname = os.path.dirname(name)
4150     if not os.path.isdir(dname):
4151         if makedirs:
4152             try:
4153                 _makedirs(name=name, user=user, group=group, dir_mode=mode)
4154             except CommandExecutionError as exc:
4155                 return _error(ret, "Drive {} is not mapped".format(exc.message))
4156         else:
4157             return _error(ret, "The target directory {} is not present".format(dname))
4158     try:
4159         if os.path.isdir(source):
4160             shutil.copytree(source, name, symlinks=True)
4161             for root, dirs, files in salt.utils.path.os_walk(name):
4162                 for dir_ in dirs:
4163                     __salt__["file.lchown"](os.path.join(root, dir_), user, group)
4164                 for file_ in files:
4165                     __salt__["file.lchown"](os.path.join(root, file_), user, group)
4166         else:
4167             shutil.copy(source, name)
4168         ret["changes"] = {name: source}
4169         if not preserve:
4170             if salt.utils.platform.is_windows():
4171                 check_ret = __salt__["file.check_perms"](path=name, ret=ret, owner=user)
4172             else:
4173                 check_ret, perms = __salt__["file.check_perms"](
4174                     name, ret, user, group, mode
4175                 )
4176             if not check_ret["result"]:
4177                 ret["result"] = check_ret["result"]
4178                 ret["comment"] = check_ret["comment"]
4179     except OSError:
4180         return _error(ret, 'Failed to copy "{}" to "{}"'.format(source, name))
4181     return ret
4182 def rename(name, source, force=False, makedirs=False, **kwargs):
4183     """
4184     If the source file exists on the system, rename it to the named file. The
4185     named file will not be overwritten if it already exists unless the force
4186     option is set to True.
4187     name
4188         The location of the file to rename to
4189     source
4190         The location of the file to move to the location specified with name
4191     force
4192         If the target location is present then the file will not be moved,
4193         specify "force: True" to overwrite the target file
4194     makedirs
4195         If the target subdirectories don't exist create them
4196     """
4197     name = os.path.expanduser(name)
4198     name = os.path.expandvars(name)
4199     source = os.path.expanduser(source)
4200     source = os.path.expandvars(source)
4201     ret = {"name": name, "changes": {}, "comment": "", "result": True}
4202     if not name:
4203         return _error(ret, "Must provide name to file.rename")
4204     if not os.path.isabs(name):
4205         return _error(ret, "Specified file {} is not an absolute path".format(name))
4206     if not os.path.lexists(source):
4207         ret["comment"] = 'Source file "{}" has already been moved out of place'.format(
4208             source
4209         )
4210         return ret
4211     if os.path.lexists(source) and os.path.lexists(name):
4212         if not force:
4213             ret[
4214                 "comment"
4215             ] = 'The target file "{}" exists and will not be overwritten'.format(name)
4216             return ret
4217         elif not __opts__["test"]:
4218             try:
4219                 __salt__["file.remove"](name)
4220             except OSError:
4221                 return _error(
4222                     ret,
4223                     'Failed to delete "{}" in preparation for forced move'.format(name),
4224                 )
4225     if __opts__["test"]:
4226         ret["comment"] = 'File "{}" is set to be moved to "{}"'.format(source, name)
4227         ret["result"] = None
4228         return ret
4229     dname = os.path.dirname(name)
4230     if not os.path.isdir(dname):
4231         if makedirs:
4232             try:
4233                 _makedirs(name=name)
4234             except CommandExecutionError as exc:
4235                 return _error(ret, "Drive {} is not mapped".format(exc.message))
4236         else:
4237             return _error(ret, "The target directory {} is not present".format(dname))
4238     try:
4239         if os.path.islink(source):
4240             linkto = salt.utils.path.readlink(source)
4241             os.symlink(linkto, name)
4242             os.unlink(source)
4243         else:
4244             shutil.move(source, name)
4245     except OSError:
4246         return _error(ret, 'Failed to move "{}" to "{}"'.format(source, name))
4247     ret["comment"] = 'Moved "{}" to "{}"'.format(source, name)
4248     ret["changes"] = {name: source}
4249     return ret
4250 def accumulated(name, filename, text, **kwargs):
4251     """
4252     Prepare accumulator which can be used in template in file.managed state.
4253     Accumulator dictionary becomes available in template. It can also be used
4254     in file.blockreplace.
4255     name
4256         Accumulator name
4257     filename
4258         Filename which would receive this accumulator (see file.managed state
4259         documentation about ``name``)
4260     text
4261         String or list for adding in accumulator
4262     require_in / watch_in
4263         One of them required for sure we fill up accumulator before we manage
4264         the file. Probably the same as filename
4265     Example:
4266     Given the following:
4267     .. code-block:: yaml
4268         animals_doing_things:
4269           file.accumulated:
4270             - filename: /tmp/animal_file.txt
4271             - text: ' jumps over the lazy dog.'
4272             - require_in:
4273               - file: animal_file
4274         animal_file:
4275           file.managed:
4276             - name: /tmp/animal_file.txt
4277             - source: salt://animal_file.txt
4278             - template: jinja
4279     One might write a template for ``animal_file.txt`` like the following:
4280     .. code-block:: jinja
4281         The quick brown fox{% for animal in accumulator['animals_doing_things'] %}{{ animal }}{% endfor %}
4282     Collectively, the above states and template file will produce:
4283     .. code-block:: text
4284         The quick brown fox jumps over the lazy dog.
4285     Multiple accumulators can be "chained" together.
4286     .. note::
4287         The 'accumulator' data structure is a Python dictionary.
4288         Do not expect any loop over the keys in a deterministic order!
4289     """
4290     ret = {"name": name, "changes": {}, "result": True, "comment": ""}
4291     if not name:
4292         return _error(ret, "Must provide name to file.accumulated")
4293     if text is None:
4294         ret["result"] = False
4295         ret["comment"] = "No text supplied for accumulator"
4296         return ret
4297     require_in = __low__.get("require_in", [])
4298     watch_in = __low__.get("watch_in", [])
4299     deps = require_in + watch_in
4300     if not [x for x in deps if "file" in x]:
4301         ret["result"] = False
4302         ret["comment"] = "Orphaned accumulator {} in {}:{}".format(
4303             name, __low__["__sls__"], __low__["__id__"]
4304         )
4305         return ret
4306     if isinstance(text, str):
4307         text = (text,)
4308     elif isinstance(text, dict):
4309         text = (text,)
4310     accum_data, accum_deps = _load_accumulators()
4311     if filename not in accum_data:
4312         accum_data[filename] = {}
4313     if filename not in accum_deps:
4314         accum_deps[filename] = {}
4315     if name not in accum_deps[filename]:
4316         accum_deps[filename][name] = []
4317     for accumulator in deps:
4318         if isinstance(accumulator, (dict, OrderedDict)):
4319             accum_deps[filename][name].extend(accumulator.values())
4320         else:
4321             accum_deps[filename][name].extend(accumulator)
4322     if name not in accum_data[filename]:
4323         accum_data[filename][name] = []
4324     for chunk in text:
4325         if chunk not in accum_data[filename][name]:
4326             accum_data[filename][name].append(chunk)
4327             ret["comment"] = "Accumulator {} for file {} was charged by text".format(
4328                 name, filename
4329             )
4330     _persist_accummulators(accum_data, accum_deps)
4331     return ret
4332 def serialize(
4333     name,
4334     dataset=None,
4335     dataset_pillar=None,
4336     user=None,
4337     group=None,
4338     mode=None,
4339     backup="",
4340     makedirs=False,
4341     show_changes=True,
4342     create=True,
4343     merge_if_exists=False,
4344     encoding=None,
4345     encoding_errors="strict",
4346     serializer=None,
4347     serializer_opts=None,
4348     deserializer_opts=None,
4349     **kwargs
4350 ):
4351     """
4352     Serializes dataset and store it into managed file. Useful for sharing
4353     simple configuration files.
4354     name
4355         The location of the file to create
4356     dataset
4357         The dataset that will be serialized
4358     dataset_pillar
4359         Operates like ``dataset``, but draws from a value stored in pillar,
4360         using the pillar path syntax used in :mod:`pillar.get
4361         &lt;salt.modules.pillar.get&gt;`. This is useful when the pillar value
4362         contains newlines, as referencing a pillar variable using a jinja/mako
4363         template can result in YAML formatting issues due to the newlines
4364         causing indentation mismatches.
4365         .. versionadded:: 2015.8.0
4366     serializer (or formatter)
4367         Write the data as this format. See the list of
4368         :ref:`all-salt.serializers` for supported output formats.
4369         .. versionchanged:: 3002
4370             ``serializer`` argument added as an alternative to ``formatter``.
4371             Both are accepted, but using both will result in an error.
4372     encoding
4373         If specified, then the specified encoding will be used. Otherwise, the
4374         file will be encoded using the system locale (usually UTF-8). See
4375         https://docs.python.org/3/library/codecs.html#standard-encodings for
4376         the list of available encodings.
4377         .. versionadded:: 2017.7.0
4378     encoding_errors
4379         Error encoding scheme. Default is ```'strict'```.
4380         See https://docs.python.org/2/library/codecs.html#codec-base-classes
4381         for the list of available schemes.
4382         .. versionadded:: 2017.7.0
4383     user
4384         The user to own the directory, this defaults to the user salt is
4385         running as on the minion
4386     group
4387         The group ownership set for the directory, this defaults to the group
4388         salt is running as on the minion
4389     mode
4390         The permissions to set on this file, e.g. ``644``, ``0775``, or
4391         ``4664``.
4392         The default mode for new files and directories corresponds umask of salt
4393         process. For existing files and directories it's not enforced.
4394         .. note::
4395             This option is **not** supported on Windows.
4396     backup
4397         Overrides the default backup mode for this specific file.
4398     makedirs
4399         Create parent directories for destination file.
4400         .. versionadded:: 2014.1.3
4401     show_changes
4402         Output a unified diff of the old file and the new file. If ``False``
4403         return a boolean if any changes were made.
4404     create
4405         Default is True, if create is set to False then the file will only be
4406         managed if the file already exists on the system.
4407     merge_if_exists
4408         Default is False, if merge_if_exists is True then the existing file will
4409         be parsed and the dataset passed in will be merged with the existing
4410         content
4411         .. versionadded:: 2014.7.0
4412     serializer_opts
4413         Pass through options to serializer. For example:
4414         .. code-block:: yaml
4415            /etc/dummy/package.yaml
4416              file.serialize:
4417                - serializer: yaml
4418                - serializer_opts:
4419                  - explicit_start: True
4420                  - default_flow_style: True
4421                  - indent: 4
4422         The valid opts are the additional opts (i.e. not the data being
4423         serialized) for the function used to serialize the data. Documentation
4424         for the these functions can be found in the list below:
4425         - For **yaml**: `yaml.dump()`_
4426         - For **json**: `json.dumps()`_
4427         - For **python**: `pprint.pformat()`_
4428         - For **msgpack**: Run ``python -c 'import msgpack; help(msgpack.Packer)'``
4429           to see the available options (``encoding``, ``unicode_errors``, etc.)
4430         .. _`yaml.dump()`: https://pyyaml.org/wiki/PyYAMLDocumentation
4431         .. _`json.dumps()`: https://docs.python.org/2/library/json.html#json.dumps
4432         .. _`pprint.pformat()`: https://docs.python.org/2/library/pprint.html#pprint.pformat
4433     deserializer_opts
4434         Like ``serializer_opts`` above, but only used when merging with an
4435         existing file (i.e. when ``merge_if_exists`` is set to ``True``).
4436         The options specified here will be passed to the deserializer to load
4437         the existing data, before merging with the specified data and
4438         re-serializing.
4439         .. code-block:: yaml
4440            /etc/dummy/package.yaml
4441              file.serialize:
4442                - serializer: yaml
4443                - serializer_opts:
4444                  - explicit_start: True
4445                  - default_flow_style: True
4446                  - indent: 4
4447                - deserializer_opts:
4448                  - encoding: latin-1
4449                - merge_if_exists: True
4450         The valid opts are the additional opts (i.e. not the data being
4451         deserialized) for the function used to deserialize the data.
4452         Documentation for the these functions can be found in the list below:
4453         - For **yaml**: `yaml.load()`_
4454         - For **json**: `json.loads()`_
4455         .. _`yaml.load()`: https://pyyaml.org/wiki/PyYAMLDocumentation
4456         .. _`json.loads()`: https://docs.python.org/2/library/json.html#json.loads
4457         However, note that not all arguments are supported. For example, when
4458         deserializing JSON, arguments like ``parse_float`` and ``parse_int``
4459         which accept a callable object cannot be handled in an SLS file.
4460         .. versionadded:: 2019.2.0
4461     For example, this state:
4462     .. code-block:: yaml
4463         /etc/dummy/package.json:
4464           file.serialize:
4465             - dataset:
4466                 name: naive
4467                 description: A package using naive versioning
4468                 author: A confused individual &lt;iam@confused.com&gt;
4469                 dependencies:
4470                   express: '&gt;= 1.2.0'
4471                   optimist: '&gt;= 0.1.0'
4472                 engine: node 0.4.1
4473             - serializer: json
4474     will manage the file ``/etc/dummy/package.json``:
4475     .. code-block:: json
4476         {
4477           "author": "A confused individual &lt;iam@confused.com&gt;",
4478           "dependencies": {
4479             "express": "&gt;= 1.2.0",
4480             "optimist": "&gt;= 0.1.0"
4481           },
4482           "description": "A package using naive versioning",
4483           "engine": "node 0.4.1",
4484           "name": "naive"
4485         }
4486     """
4487     if "env" in kwargs:
4488         kwargs.pop("env")
4489     name = os.path.expanduser(name)
4490     serializer_options = {
4491         "yaml.serialize": {"default_flow_style": False},
4492         "json.serialize": {"indent": 2, "separators": (",", ": "), "sort_keys": True},
4493     }
4494     deserializer_options = {
4495         "yaml.deserialize": {},
4496         "json.deserialize": {},
4497     }
4498     if encoding:
4499         serializer_options["yaml.serialize"].update({"allow_unicode": True})
4500         serializer_options["json.serialize"].update({"ensure_ascii": False})
4501     ret = {"changes": {}, "comment": "", "name": name, "result": True}
4502     if not name:
4503         return _error(ret, "Must provide name to file.serialize")
4504     if not create:
4505         if not os.path.isfile(name):
4506             ret[
4507                 "comment"
4508             ] = "File {} is not present and is not set for creation".format(name)
4509             return ret
4510     formatter = kwargs.pop("formatter", None)
4511     if serializer and formatter:
4512         return _error(ret, "Only one of serializer and formatter are allowed")
4513     serializer = str(serializer or formatter or "yaml").lower()
4514     if len([x for x in (dataset, dataset_pillar) if x]) &gt; 1:
4515         return _error(ret, "Only one of 'dataset' and 'dataset_pillar' is permitted")
4516     if dataset_pillar:
4517         dataset = __salt__["pillar.get"](dataset_pillar)
4518     if dataset is None:
4519         return _error(ret, "Neither 'dataset' nor 'dataset_pillar' was defined")
4520     if salt.utils.platform.is_windows():
4521         if group is not None:
4522             log.warning(
4523                 "The group argument for %s has been ignored as this "
4524                 "is a Windows system.",
4525                 name,
4526             )
4527         group = user
4528     serializer_name = "{}.serialize".format(serializer)
4529     deserializer_name = "{}.deserialize".format(serializer)
4530     if serializer_name not in __serializers__:
4531         return {
4532             "changes": {},
4533             "comment": (
4534                 "The {} serializer could not be found. It either does "
4535                 "not exist or its prerequisites are not installed.".format(serializer)
4536             ),
4537             "name": name,
4538             "result": False,
4539         }
4540     if serializer_opts:
4541         serializer_options.setdefault(serializer_name, {}).update(
4542             salt.utils.data.repack_dictlist(serializer_opts)
4543         )
4544     if deserializer_opts:
4545         deserializer_options.setdefault(deserializer_name, {}).update(
4546             salt.utils.data.repack_dictlist(deserializer_opts)
4547         )
4548     if merge_if_exists:
4549         if os.path.isfile(name):
4550             if deserializer_name not in __serializers__:
4551                 return {
4552                     "changes": {},
4553                     "comment": (
4554                         "merge_if_exists is not supported for the {} serializer".format(
4555                             serializer
4556                         )
4557                     ),
4558                     "name": name,
4559                     "result": False,
4560                 }
4561             open_args = "r"
4562             if serializer == "plist":
4563                 open_args += "b"
4564             with salt.utils.files.fopen(name, open_args) as fhr:
4565                 try:
4566                     existing_data = __serializers__[deserializer_name](
4567                         fhr, **deserializer_options.get(deserializer_name, {})
4568                     )
4569                 except (TypeError, DeserializationError) as exc:
4570                     ret["result"] = False
4571                     ret["comment"] = "Failed to deserialize existing data: {}".format(
4572                         exc
4573                     )
4574                     return False
4575             if existing_data is not None:
4576                 merged_data = salt.utils.dictupdate.merge_recurse(
4577                     existing_data, dataset
4578                 )
4579                 if existing_data == merged_data:
4580                     ret["result"] = True
4581                     ret["comment"] = "The file {} is in the correct state".format(name)
4582                     return ret
4583                 dataset = merged_data
4584     else:
4585         if deserializer_opts:
4586             ret.setdefault("warnings", []).append(
4587                 "The 'deserializer_opts' option is ignored unless "
4588                 "merge_if_exists is set to True."
4589             )
4590     contents = __serializers__[serializer_name](
4591         dataset, **serializer_options.get(serializer_name, {})
4592     )
4593     try:
4594         contents += "\n"
4595     except TypeError:
4596         pass
4597     mode = salt.utils.files.normalize_mode(mode)
4598     if __opts__["test"]:
4599         ret["changes"] = __salt__["file.check_managed_changes"](
4600             name=name,
4601             source=None,
4602             source_hash={},
4603             source_hash_name=None,
4604             user=user,
4605             group=group,
4606             mode=mode,
4607             attrs=None,
4608             template=None,
4609             context=None,
4610             defaults=None,
4611             saltenv=__env__,
4612             contents=contents,
4613             skip_verify=False,
4614             **kwargs
4615         )
4616         if ret["changes"]:
4617             ret["result"] = None
4618             ret["comment"] = "Dataset will be serialized and stored into {}".format(
4619                 name
4620             )
4621             if not show_changes:
4622                 ret["changes"]["diff"] = "&lt;show_changes=False&gt;"
4623         else:
4624             ret["result"] = True
4625             ret["comment"] = "The file {} is in the correct state".format(name)
4626         return ret
4627     return __salt__["file.manage_file"](
4628         name=name,
4629         sfn="",
4630         ret=ret,
4631         source=None,
4632         source_sum={},
4633         user=user,
4634         group=group,
4635         mode=mode,
4636         attrs=None,
4637         saltenv=__env__,
4638         backup=backup,
4639         makedirs=makedirs,
4640         template=None,
4641         show_changes=show_changes,
4642         encoding=encoding,
4643         encoding_errors=encoding_errors,
4644         contents=contents,
4645     )
4646 def mknod(name, ntype, major=0, minor=0, user=None, group=None, mode="0600"):
4647     """
4648     Create a special file similar to the 'nix mknod command. The supported
4649     device types are ``p`` (fifo pipe), ``c`` (character device), and ``b``
4650     (block device). Provide the major and minor numbers when specifying a
4651     character device or block device. A fifo pipe does not require this
4652     information. The command will create the necessary dirs if needed. If a
4653     file of the same name not of the same type/major/minor exists, it will not
4654     be overwritten or unlinked (deleted). This is logically in place as a
4655     safety measure because you can really shoot yourself in the foot here and
4656     it is the behavior of 'nix ``mknod``. It is also important to note that not
4657     just anyone can create special devices. Usually this is only done as root.
4658     If the state is executed as none other than root on a minion, you may
4659     receive a permission error.
4660     name
4661         name of the file
4662     ntype
4663         node type 'p' (fifo pipe), 'c' (character device), or 'b'
4664         (block device)
4665     major
4666         major number of the device
4667         does not apply to a fifo pipe
4668     minor
4669         minor number of the device
4670         does not apply to a fifo pipe
4671     user
4672         owning user of the device/pipe
4673     group
4674         owning group of the device/pipe
4675     mode
4676         permissions on the device/pipe
4677     Usage:
4678     .. code-block:: yaml
4679         /dev/chr:
4680           file.mknod:
4681             - ntype: c
4682             - major: 180
4683             - minor: 31
4684             - user: root
4685             - group: root
4686             - mode: 660
4687         /dev/blk:
4688           file.mknod:
4689             - ntype: b
4690             - major: 8
4691             - minor: 999
4692             - user: root
4693             - group: root
4694             - mode: 660
4695         /dev/fifo:
4696           file.mknod:
4697             - ntype: p
4698             - user: root
4699             - group: root
4700             - mode: 660
4701     .. versionadded:: 0.17.0
4702     """
4703     name = os.path.expanduser(name)
4704     ret = {"name": name, "changes": {}, "comment": "", "result": False}
4705     if not name:
4706         return _error(ret, "Must provide name to file.mknod")
4707     if ntype == "c":
4708         if __salt__["file.file_exists"](name):
4709             ret["comment"] = (
4710                 "File {} exists and is not a character device. Refusing "
4711                 "to continue".format(name)
4712             )
4713         elif not __salt__["file.is_chrdev"](name):
4714             if __opts__["test"]:
4715                 ret["comment"] = "Character device {} is set to be created".format(name)
4716                 ret["result"] = None
4717             else:
4718                 ret = __salt__["file.mknod"](
4719                     name, ntype, major, minor, user, group, mode
4720                 )
4721         else:
4722             devmaj, devmin = __salt__["file.get_devmm"](name)
4723             if (major, minor) != (devmaj, devmin):
4724                 ret["comment"] = (
4725                     "Character device {} exists and has a different "
4726                     "major/minor {}/{}. Refusing to continue".format(
4727                         name, devmaj, devmin
4728                     )
4729                 )
4730             else:
4731                 ret = __salt__["file.check_perms"](name, None, user, group, mode)[0]
4732                 if not ret["changes"]:
4733                     ret[
4734                         "comment"
4735                     ] = "Character device {} is in the correct state".format(name)
4736     elif ntype == "b":
4737         if __salt__["file.file_exists"](name):
4738             ret[
4739                 "comment"
4740             ] = "File {} exists and is not a block device. Refusing to continue".format(
4741                 name
4742             )
4743         elif not __salt__["file.is_blkdev"](name):
4744             if __opts__["test"]:
4745                 ret["comment"] = "Block device {} is set to be created".format(name)
4746                 ret["result"] = None
4747             else:
4748                 ret = __salt__["file.mknod"](
4749                     name, ntype, major, minor, user, group, mode
4750                 )
4751         else:
4752             devmaj, devmin = __salt__["file.get_devmm"](name)
4753             if (major, minor) != (devmaj, devmin):
4754                 ret["comment"] = (
4755                     "Block device {} exists and has a different major/minor "
4756                     "{}/{}. Refusing to continue".format(name, devmaj, devmin)
4757                 )
4758             else:
4759                 ret = __salt__["file.check_perms"](name, None, user, group, mode)[0]
4760                 if not ret["changes"]:
4761                     ret["comment"] = "Block device {} is in the correct state".format(
4762                         name
4763                     )
4764     elif ntype == "p":
4765         if __salt__["file.file_exists"](name):
4766             ret[
4767                 "comment"
4768             ] = "File {} exists and is not a fifo pipe. Refusing to continue".format(
4769                 name
4770             )
4771         elif not __salt__["file.is_fifo"](name):
4772             if __opts__["test"]:
4773                 ret["comment"] = "Fifo pipe {} is set to be created".format(name)
4774                 ret["result"] = None
4775             else:
4776                 ret = __salt__["file.mknod"](
4777                     name, ntype, major, minor, user, group, mode
4778                 )
4779         else:
4780             ret = __salt__["file.check_perms"](name, None, user, group, mode)[0]
4781             if not ret["changes"]:
4782                 ret["comment"] = "Fifo pipe {} is in the correct state".format(name)
4783     else:
4784         ret["comment"] = (
4785             "Node type unavailable: '{}'. Available node types are "
4786             "character ('c'), block ('b'), and pipe ('p')".format(ntype)
4787         )
4788     return ret
4789 def mod_run_check_cmd(cmd, filename, **check_cmd_opts):
4790     """
4791     Execute the check_cmd logic.
4792     Return a result dict if ``check_cmd`` succeeds (check_cmd == 0)
4793     otherwise return True
4794     """
4795     log.debug("running our check_cmd")
4796     _cmd = "{} {}".format(cmd, filename)
4797     cret = __salt__["cmd.run_all"](_cmd, **check_cmd_opts)
4798     if cret["retcode"] != 0:
4799         ret = {
4800             "comment": "check_cmd execution failed",
4801             "skip_watch": True,
4802             "result": False,
4803         }
4804         if cret.get("stdout"):
4805             ret["comment"] += "\n" + cret["stdout"]
4806         if cret.get("stderr"):
4807             ret["comment"] += "\n" + cret["stderr"]
4808         return ret
4809     return True
4810 def decode(
4811     name,
4812     encoded_data=None,
4813     contents_pillar=None,
4814     encoding_type="base64",
4815     checksum="md5",
4816 ):
4817     """
4818     Decode an encoded file and write it to disk
4819     .. versionadded:: 2016.3.0
4820     name
4821         Path of the file to be written.
4822     encoded_data
4823         The encoded file. Either this option or ``contents_pillar`` must be
4824         specified.
4825     contents_pillar
4826         A Pillar path to the encoded file. Uses the same path syntax as
4827         :py:func:`pillar.get &lt;salt.modules.pillar.get&gt;`. The
4828         :py:func:`hashutil.base64_encodefile
4829         &lt;salt.modules.hashutil.base64_encodefile&gt;` function can load encoded
4830         content into Pillar. Either this option or ``encoded_data`` must be
4831         specified.
4832     encoding_type
4833         The type of encoding.
4834     checksum
4835         The hashing algorithm to use to generate checksums. Wraps the
4836         :py:func:`hashutil.digest &lt;salt.modules.hashutil.digest&gt;` execution
4837         function.
4838     Usage:
4839     .. code-block:: yaml
4840         write_base64_encoded_string_to_a_file:
4841           file.decode:
4842             - name: /tmp/new_file
4843             - encoding_type: base64
4844             - contents_pillar: mypillar:thefile
4845         write_base64_encoded_string_to_a_file:
4846           file.decode:
4847             - name: /tmp/new_file
4848             - encoding_type: base64
4849             - encoded_data: |
4850                 Z2V0IHNhbHRlZAo=
4851     Be careful with multi-line strings that the YAML indentation is correct.
4852     E.g.,
4853     .. code-block:: jinja
4854         write_base64_encoded_string_to_a_file:
4855           file.decode:
4856             - name: /tmp/new_file
4857             - encoding_type: base64
4858             - encoded_data: |
4859                 {{ salt.pillar.get('path:to:data') | indent(8) }}
4860     """
4861     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
4862     if not (encoded_data or contents_pillar):
4863         raise CommandExecutionError(
4864             "Specify either the 'encoded_data' or 'contents_pillar' argument."
4865         )
4866     elif encoded_data and contents_pillar:
4867         raise CommandExecutionError(
4868             "Specify only one 'encoded_data' or 'contents_pillar' argument."
4869         )
4870     elif encoded_data:
4871         content = encoded_data
4872     elif contents_pillar:
4873         content = __salt__["pillar.get"](contents_pillar, False)
4874         if content is False:
4875             raise CommandExecutionError("Pillar data not found.")
4876     else:
4877         raise CommandExecutionError("No contents given.")
4878     dest_exists = __salt__["file.file_exists"](name)
4879     if dest_exists:
4880         instr = __salt__["hashutil.base64_decodestring"](content)
4881         insum = __salt__["hashutil.digest"](instr, checksum)
4882         del instr  # no need to keep in-memory after we have the hash
4883         outsum = __salt__["hashutil.digest_file"](name, checksum)
4884         if insum != outsum:
4885             ret["changes"] = {
4886                 "old": outsum,
4887                 "new": insum,
4888             }
4889         if not ret["changes"]:
4890             ret["comment"] = "File is in the correct state."
4891             ret["result"] = True
4892             return ret
4893     if __opts__["test"] is True:
4894         ret["comment"] = "File is set to be updated."
4895         ret["result"] = None
4896         return ret
4897     ret["result"] = __salt__["hashutil.base64_decodefile"](content, name)
4898     ret["comment"] = "File was updated."
4899     if not ret["changes"]:
4900         ret["changes"] = {
4901             "old": None,
4902             "new": __salt__["hashutil.digest_file"](name, checksum),
4903         }
4904     return ret
4905 def shortcut(
4906     name,
4907     target,
4908     arguments=None,
4909     working_dir=None,
4910     description=None,
4911     icon_location=None,
4912     force=False,
4913     backupname=None,
4914     makedirs=False,
4915     user=None,
4916     **kwargs
4917 ):
4918     """
4919     Create a Windows shortcut
4920     If the file already exists and is a shortcut pointing to any location other
4921     than the specified target, the shortcut will be replaced. If it is
4922     a regular file or directory then the state will return False. If the
4923     regular file or directory is desired to be replaced with a shortcut pass
4924     force: True, if it is to be renamed, pass a backupname.
4925     name
4926         The location of the shortcut to create. Must end with either
4927         ".lnk" or ".url"
4928     target
4929         The location that the shortcut points to
4930     arguments
4931         Any arguments to pass in the shortcut
4932     working_dir
4933         Working directory in which to execute target
4934     description
4935         Description to set on shortcut
4936     icon_location
4937         Location of shortcut's icon
4938     force
4939         If the name of the shortcut exists and is not a file and
4940         force is set to False, the state will fail. If force is set to
4941         True, the link or directory in the way of the shortcut file
4942         will be deleted to make room for the shortcut, unless
4943         backupname is set, when it will be renamed
4944     backupname
4945         If the name of the shortcut exists and is not a file, it will be
4946         renamed to the backupname. If the backupname already
4947         exists and force is False, the state will fail. Otherwise, the
4948         backupname will be removed first.
4949     makedirs
4950         If the location of the shortcut does not already have a parent
4951         directory then the state will fail, setting makedirs to True will
4952         allow Salt to create the parent directory. Setting this to True will
4953         also create the parent for backupname if necessary.
4954     user
4955         The user to own the file, this defaults to the user salt is running as
4956         on the minion
4957         The default mode for new files and directories corresponds umask of salt
4958         process. For existing files and directories it's not enforced.
4959     """
4960     user = _test_owner(kwargs, user=user)
4961     ret = {"name": name, "changes": {}, "result": True, "comment": ""}
4962     if not salt.utils.platform.is_windows():
4963         return _error(ret, "Shortcuts are only supported on Windows")
4964     if not name:
4965         return _error(ret, "Must provide name to file.shortcut")
4966     if not name.endswith(".lnk") and not name.endswith(".url"):
4967         return _error(ret, 'Name must end with either ".lnk" or ".url"')
4968     name = os.path.realpath(os.path.expanduser(name))
4969     if name.endswith(".lnk"):
4970         target = os.path.realpath(os.path.expanduser(target))
4971     if working_dir:
4972         working_dir = os.path.realpath(os.path.expanduser(working_dir))
4973     if icon_location:
4974         icon_location = os.path.realpath(os.path.expanduser(icon_location))
4975     if user is None:
4976         user = __opts__["user"]
4977     if not __salt__["user.info"](user):
4978         user = __salt__["user.current"]()
4979         if not user:
4980             user = "SYSTEM"
4981     preflight_errors = []
4982     uid = __salt__["file.user_to_uid"](user)
4983     if uid == "":
4984         preflight_errors.append("User {} does not exist".format(user))
4985     if not os.path.isabs(name):
4986         preflight_errors.append(
4987             "Specified file {} is not an absolute path".format(name)
4988         )
4989     if preflight_errors:
4990         msg = ". ".join(preflight_errors)
4991         if len(preflight_errors) &gt; 1:
4992             msg += "."
4993         return _error(ret, msg)
4994     tresult, tcomment, tchanges = _shortcut_check(
4995         name, target, arguments, working_dir, description, icon_location, force, user
4996     )
4997     if __opts__["test"]:
4998         ret["result"] = tresult
4999         ret["comment"] = tcomment
5000         ret["changes"] = tchanges
5001         return ret
5002     if not os.path.isdir(os.path.dirname(name)):
5003         if makedirs:
5004             try:
5005                 _makedirs(name=name, user=user)
5006             except CommandExecutionError as exc:
5007                 return _error(ret, "Drive {} is not mapped".format(exc.message))
5008         else:
5009             return _error(
5010                 ret,
5011                 'Directory "{}" for shortcut is not present'.format(
5012                     os.path.dirname(name)
5013                 ),
5014             )
5015     if os.path.isdir(name) or os.path.islink(name):
5016         if backupname is not None:
5017             if os.path.lexists(backupname):
5018                 if not force:
5019                     return _error(
5020                         ret,
5021                         "File exists where the backup target {} should go".format(
5022                             backupname
5023                         ),
5024                     )
5025                 else:
5026                     __salt__["file.remove"](backupname)
5027                     time.sleep(1)  # wait for asynchronous deletion
5028             if not os.path.isdir(os.path.dirname(backupname)):
5029                 if makedirs:
5030                     try:
5031                         _makedirs(name=backupname)
5032                     except CommandExecutionError as exc:
5033                         return _error(ret, "Drive {} is not mapped".format(exc.message))
5034                 else:
5035                     return _error(
5036                         ret,
5037                         'Directory does not exist for backup at "{}"'.format(
5038                             os.path.dirname(backupname)
5039                         ),
5040                     )
5041             os.rename(name, backupname)
5042             time.sleep(1)  # wait for asynchronous rename
5043         elif force:
5044             __salt__["file.remove"](name)
5045             ret["changes"]["forced"] = "Shortcut was forcibly replaced"
5046             time.sleep(1)  # wait for asynchronous deletion
5047         else:
5048             return _error(
5049                 ret,
5050                 'Directory or symlink exists where the shortcut "{}" should be'.format(
5051                     name
5052                 ),
5053             )
5054     with salt.utils.winapi.Com():
5055         shell = win32com.client.Dispatch("WScript.Shell")
5056         scut = shell.CreateShortcut(name)
5057         state_checks = [scut.TargetPath.lower() == target.lower()]
5058         if arguments is not None:
5059             state_checks.append(scut.Arguments == arguments)
5060         if working_dir is not None:
5061             state_checks.append(scut.WorkingDirectory.lower() == working_dir.lower())
5062         if description is not None:
5063             state_checks.append(scut.Description == description)
5064         if icon_location is not None:
5065             state_checks.append(scut.IconLocation.lower() == icon_location.lower())
5066         if __salt__["file.file_exists"](name):
5067             if not all(state_checks):
5068                 os.remove(name)
5069             else:
5070                 if _check_shortcut_ownership(name, user):
5071                     ret["comment"] = "Shortcut {} is present and owned by {}".format(
5072                         name, user
5073                     )
5074                 else:
5075                     if _set_shortcut_ownership(name, user):
5076                         ret["comment"] = "Set ownership of shortcut {} to {}".format(
5077                             name, user
5078                         )
5079                         ret["changes"]["ownership"] = "{}".format(user)
5080                     else:
5081                         ret["result"] = False
5082                         ret[
5083                             "comment"
5084                         ] += "Failed to set ownership of shortcut {} to {}".format(
5085                             name, user
5086                         )
5087                 return ret
5088         if not os.path.exists(name):
5089             try:
5090                 scut.TargetPath = target
5091                 if arguments is not None:
5092                     scut.Arguments = arguments
5093                 if working_dir is not None:
5094                     scut.WorkingDirectory = working_dir
5095                 if description is not None:
5096                     scut.Description = description
5097                 if icon_location is not None:
5098                     scut.IconLocation = icon_location
5099                 scut.Save()
5100             except (AttributeError, pywintypes.com_error) as exc:
5101                 ret["result"] = False
5102                 ret["comment"] = "Unable to create new shortcut {} -&gt; {}: {}".format(
5103                     name, target, exc
5104                 )
5105                 return ret
5106             else:
5107                 ret["comment"] = "Created new shortcut {} -&gt; {}".format(name, target)
5108                 ret["changes"]["new"] = name
5109             if not _check_shortcut_ownership(name, user):
5110                 if not _set_shortcut_ownership(name, user):
5111                     ret["result"] = False
5112                     ret["comment"] += ", but was unable to set ownership to {}".format(
5113                         user
5114                     )
5115     return ret
5116 def cached(
5117     name,
5118     source_hash="",
5119     source_hash_name=None,
5120     skip_verify=False,
5121     saltenv="base",
5122     use_etag=False,
5123 ):
5124     """
5125     .. versionadded:: 2017.7.3
5126     .. versionchanged:: 3005
5127     Ensures that a file is saved to the minion's cache. This state is primarily
5128     invoked by other states to ensure that we do not re-download a source file
5129     if we do not need to.
5130     name
5131         The URL of the file to be cached. To cache a file from an environment
5132         other than ``base``, either use the ``saltenv`` argument or include the
5133         saltenv in the URL (e.g. ``salt://path/to/file.conf?saltenv=dev``).
5134         .. note::
5135             A list of URLs is not supported, this must be a single URL. If a
5136             local file is passed here, then the state will obviously not try to
5137             download anything, but it will compare a hash if one is specified.
5138     source_hash
5139         See the documentation for this same argument in the
5140         :py:func:`file.managed &lt;salt.states.file.managed&gt;` state.
5141         .. note::
5142             For remote files not originating from the ``salt://`` fileserver,
5143             such as http(s) or ftp servers, this state will not re-download the
5144             file if the locally-cached copy matches this hash. This is done to
5145             prevent unnecessary downloading on repeated runs of this state. To
5146             update the cached copy of a file, it is necessary to update this
5147             hash.
5148     source_hash_name
5149         See the documentation for this same argument in the
5150         :py:func:`file.managed &lt;salt.states.file.managed&gt;` state.
5151     skip_verify
5152         See the documentation for this same argument in the
5153         :py:func:`file.managed &lt;salt.states.file.managed&gt;` state.
5154         .. note::
5155             Setting this to ``True`` will result in a copy of the file being
5156             downloaded from a remote (http(s), ftp, etc.) source each time the
5157             state is run.
5158     saltenv
5159         Used to specify the environment from which to download a file from the
5160         Salt fileserver (i.e. those with ``salt://`` URL).
5161     use_etag
5162         If ``True``, remote http/https file sources will attempt to use the
5163         ETag header to determine if the remote file needs to be downloaded.
5164         This provides a lightweight mechanism for promptly refreshing files
5165         changed on a web server without requiring a full hash comparison via
5166         the ``source_hash`` parameter.
5167         .. versionadded:: 3005
5168     This state will in most cases not be useful in SLS files, but it is useful
5169     when writing a state or remote-execution module that needs to make sure
5170     that a file at a given URL has been downloaded to the cachedir. One example
5171     of this is in the :py:func:`archive.extracted &lt;salt.states.file.extracted&gt;`
5172     state:
5173     .. code-block:: python
5174         result = __states__['file.cached'](source_match,
5175                                            source_hash=source_hash,
5176                                            source_hash_name=source_hash_name,
5177                                            skip_verify=skip_verify,
5178                                            saltenv=__env__)
5179     This will return a dictionary containing the state's return data, including
5180     a ``result`` key which will state whether or not the state was successful.
5181     Note that this will not catch exceptions, so it is best used within a
5182     try/except.
5183     Once this state has been run from within another state or remote-execution
5184     module, the actual location of the cached file can be obtained using
5185     :py:func:`cp.is_cached &lt;salt.modules.cp.is_cached&gt;`:
5186     .. code-block:: python
5187         cached = __salt__['cp.is_cached'](source_match, saltenv=__env__)
5188     This function will return the cached path of the file, or an empty string
5189     if the file is not present in the minion cache.
5190     """
5191     ret = {"changes": {}, "comment": "", "name": name, "result": False}
5192     try:
5193         parsed = urllib.parse.urlparse(name)
5194     except Exception:  # pylint: disable=broad-except
5195         ret["comment"] = "Only URLs or local file paths are valid input"
5196         return ret
5197     if (
5198         not skip_verify
5199         and not source_hash
5200         and not use_etag
5201         and parsed.scheme in salt.utils.files.REMOTE_PROTOS
5202     ):
5203         ret["comment"] = (
5204             "Unable to verify upstream hash of source file {}, please set "
5205             "source_hash or set skip_verify or use_etag to True".format(
5206                 salt.utils.url.redact_http_basic_auth(name)
5207             )
5208         )
5209         return ret
5210     if source_hash:
5211         try:
5212             source_sum = __salt__["file.get_source_sum"](
5213                 source=name,
5214                 source_hash=source_hash,
5215                 source_hash_name=source_hash_name,
5216                 saltenv=saltenv,
5217             )
5218         except CommandExecutionError as exc:
5219             ret["comment"] = exc.strerror
5220             return ret
5221         else:
5222             if not source_sum:
5223                 ret["comment"] = (
5224                     "Failed to get source hash from {}. This may be a bug. "
5225                     "If this error persists, please report it and set "
5226                     "skip_verify to True to work around it.".format(source_hash)
5227                 )
5228                 return ret
5229     else:
5230         source_sum = {}
5231     if parsed.scheme in salt.utils.files.LOCAL_PROTOS:
5232         full_path = os.path.realpath(os.path.expanduser(parsed.path))
5233         if os.path.exists(full_path):
5234             if not skip_verify and source_sum:
5235                 local_hash = __salt__["file.get_hash"](
5236                     full_path, source_sum.get("hash_type", __opts__["hash_type"])
5237                 )
5238                 if local_hash == source_sum["hsum"]:
5239                     ret["result"] = True
5240                     ret[
5241                         "comment"
5242                     ] = "File {} is present on the minion and has hash {}".format(
5243                         full_path, local_hash
5244                     )
5245                 else:
5246                     ret["comment"] = (
5247                         "File {} is present on the minion, but the hash ({}) "
5248                         "does not match the specified hash ({})".format(
5249                             full_path, local_hash, source_sum["hsum"]
5250                         )
5251                     )
5252                 return ret
5253             else:
5254                 ret["result"] = True
5255                 ret["comment"] = "File {} is present on the minion".format(full_path)
5256                 return ret
5257         else:
5258             ret["comment"] = "File {} is not present on the minion".format(full_path)
5259             return ret
5260     local_copy = __salt__["cp.is_cached"](name, saltenv=saltenv)
5261     if local_copy:
5262         pre_hash = __salt__["file.get_hash"](
5263             local_copy, source_sum.get("hash_type", __opts__["hash_type"])
5264         )
5265         if not skip_verify and source_sum:
5266             if pre_hash == source_sum["hsum"]:
5267                 ret["result"] = True
5268                 ret["comment"] = "File is already cached to {} with hash {}".format(
5269                     local_copy, pre_hash
5270                 )
5271     else:
5272         pre_hash = None
5273     try:
5274         local_copy = __salt__["cp.cache_file"](
5275             name, saltenv=saltenv, source_hash=source_sum.get("hsum"), use_etag=use_etag
5276         )
5277     except Exception as exc:  # pylint: disable=broad-except
5278         ret["comment"] = salt.utils.url.redact_http_basic_auth(exc.__str__())
5279         return ret
5280     if not local_copy:
5281         ret[
5282             "comment"
5283         ] = "Failed to cache {}, check minion log for more information".format(
5284             salt.utils.url.redact_http_basic_auth(name)
5285         )
5286         return ret
5287     post_hash = __salt__["file.get_hash"](
5288         local_copy, source_sum.get("hash_type", __opts__["hash_type"])
5289     )
5290     if pre_hash != post_hash:
5291         ret["changes"]["hash"] = {"old": pre_hash, "new": post_hash}
5292     if not skip_verify and source_sum:
5293         if post_hash == source_sum["hsum"]:
5294             ret["result"] = True
5295             ret["comment"] = "File is already cached to {} with hash {}".format(
5296                 local_copy, post_hash
5297             )
5298         else:
5299             ret["comment"] = (
5300                 "File is cached to {}, but the hash ({}) does not match "
5301                 "the specified hash ({})".format(
5302                     local_copy, post_hash, source_sum["hsum"]
5303                 )
5304             )
5305         return ret
5306     ret["result"] = True
5307     ret["comment"] = "File is cached to {}".format(local_copy)
5308     return ret
5309 def not_cached(name, saltenv="base"):
5310     """
5311     .. versionadded:: 2017.7.3
5312     Ensures that a file is not present in the minion's cache, deleting it
5313     if found. This state is primarily invoked by other states to ensure
5314     that a fresh copy is fetched.
5315     name
5316         The URL of the file to be removed from cache. To remove a file from
5317         cache in an environment other than ``base``, either use the ``saltenv``
5318         argument or include the saltenv in the URL (e.g.
5319         ``salt://path/to/file.conf?saltenv=dev``).
5320         .. note::
5321             A list of URLs is not supported, this must be a single URL. If a
5322             local file is passed here, the state will take no action.
5323     saltenv
5324         Used to specify the environment from which to download a file from the
5325         Salt fileserver (i.e. those with ``salt://`` URL).
5326     """
5327     ret = {"changes": {}, "comment": "", "name": name, "result": False}
5328     try:
5329         parsed = urllib.parse.urlparse(name)
5330     except Exception:  # pylint: disable=broad-except
5331         ret["comment"] = "Only URLs or local file paths are valid input"
5332         return ret
5333     else:
5334         if parsed.scheme in salt.utils.files.LOCAL_PROTOS:
5335             full_path = os.path.realpath(os.path.expanduser(parsed.path))
5336             ret["result"] = True
5337             ret["comment"] = "File {} is a local path, no action taken".format(
5338                 full_path
5339             )
5340             return ret
5341     local_copy = __salt__["cp.is_cached"](name, saltenv=saltenv)
5342     if local_copy:
5343         try:
5344             os.remove(local_copy)
5345         except Exception as exc:  # pylint: disable=broad-except
5346         else:
5347             ret["result"] = True
5348             ret<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["changes"]["deleted"] = True
5349             ret["comment"] = "{} was deleted".format(local_copy)
5350     else:
5351         ret["result"] = True
5352         ret["comment"] = "{} is not cached".format(name)
5353     return</b></font> ret
5354 def mod_beacon(name, **kwargs):
5355     """
5356     Create a beacon to monitor a file based on a beacon state argument.
5357     .. note::
5358         This state exists to support special handling of the ``beacon``
5359         state argument for supported state functions. It should not be called directly.
5360     """
5361     sfun = kwargs.pop("sfun", None)
5362     supported_funcs = ["managed", "directory"]
5363     if sfun in supported_funcs:
5364         if kwargs.get("beacon"):
5365             beacon_module = "inotify"
5366             data = {}
5367             _beacon_data = kwargs.get("beacon_data", {})
5368             default_mask = ["create", "delete", "modify"]
5369             data["mask"] = _beacon_data.get("mask", default_mask)
5370             if sfun == "directory":
5371                 data["auto_add"] = _beacon_data.get("auto_add", True)
5372                 data["recurse"] = _beacon_data.get("recurse", True)
5373                 data["exclude"] = _beacon_data.get("exclude", [])
5374             beacon_name = "beacon_{}_{}".format(beacon_module, name)
5375             beacon_kwargs = {
5376                 "name": beacon_name,
5377                 "files": {name: data},
5378                 "interval": _beacon_data.get("interval", 60),
5379                 "coalesce": _beacon_data.get("coalesce", False),
5380                 "beacon_module": beacon_module,
5381             }
5382             ret = __states__["beacon.present"](**beacon_kwargs)
5383             return ret
5384         else:
5385             return {
5386                 "name": name,
5387                 "changes": {},
5388                 "comment": "Not adding beacon.",
5389                 "result": True,
5390             }
5391     else:
5392         return {
5393             "name": name,
5394             "changes": {},
5395             "comment": "file.{} does not work with the beacon state function".format(
5396                 sfun
5397             ),
5398             "result": False,
5399         }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
