<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for highstate_doc_1.py &amp; test_file_2.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for highstate_doc_1.py &amp; test_file_2.py
      </h3>
<h1 align="center">
        0.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>highstate_doc_1.py (5.7395144%)<th>test_file_2.py (0.31968522%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(591-592)<td><a href="#" name="0">(3163-3164)</a><td align="center"><font color="#ff0000">13</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(429-430)<td><a href="#" name="1">(3130-3131)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>highstate_doc_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import re
3 import salt.utils.files
4 import salt.utils.stringutils
5 import salt.utils.templates as tpl
6 import salt.utils.yaml
7 __virtualname__ = "highstate_doc"
8 log = logging.getLogger(__name__)
9 markdown_basic_jinja_template_txt = """
10 {% for s in lowstates %}
11 `{{s.id_full}}`
12 -----------------------------------------------------------------
13  * state: {{s.state_function}}
14  * name: `{{s.name}}`
15 {{s.markdown.requisites}}
16 {{s.markdown.details}}
17 {%- endfor %}
18 Configuration Managment
19 ===============================================================================
20 ```
21 fqdn: {{grains.get('fqdn')}}
22 os: {{grains.get('os')}}
23 osfinger: {{grains.get('osfinger')}}
24 mem_total: {{grains.get('mem_total')}}MB
25 num_cpus: {{grains.get('num_cpus')}}
26 ipv4: {{grains.get('ipv4')}}
27 master: {{opts.get('master')}}
28 ```
29 This system is fully or partly managed using Salt.
30 The following sections are a rendered view of what the configuration management system
31 controlled on this system. Each item is handled in order from top to bottom unless some
32 requisites like `require` force other ordering.
33 )
34 def markdown_basic_jinja_template(**kwargs):
35     return markdown_basic_jinja_template_txt
36 def markdown_default_jinja_template(**kwargs):
37     return markdown_default_jinja_template_txt
38 def markdown_full_jinja_template(**kwargs):
39     return markdown_advanced_jinja_template_txt
40 def _get_config(**kwargs):
41     config = {
42         "filter_id_regex": [".*!doc_skip"],
43         "filter_function_regex": [],
44         "replace_text_regex": {},
45         "processor": "highstate_doc.processor_markdown",
46         "max_render_file_size": 10000,
47         "note": None,
48     }
49     if "__salt__" in globals():
50         config_key = "{}.config".format(__virtualname__)
51         config.update(__salt__["config.get"](config_key, {}))
52     for k in set(config.keys()) &amp; set(kwargs.keys()):
53         config[k] = kwargs[k]
54     return config
55 def read_file(name):
56         <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>with salt.utils.files.fopen(name, "r") as f:
57             out = salt.utils.stringutils.to_unicode(f.read(</b></font>))
58     except Exception as ex:  # pylint: disable=broad-except
59         log.error(ex)
60         return None
61     return out
62 def render(
63     jinja_template_text=None,
64     jinja_template_function="highstate_doc.markdown_default_jinja_template",
65     **kwargs
66 ):
67     config = _get_config(**kwargs)
68     lowstates = process_lowstates(**kwargs)
69     context = {
70         "saltenv": None,
71         "config": config,
72         "lowstates": lowstates,
73         "salt": __salt__,
74         "pillar": __pillar__,
75         "grains": __grains__,
76         "opts": __opts__,
77         "kwargs": kwargs,
78     }
79     template_text = jinja_template_text
80     if template_text is None and jinja_template_function:
81         template_text = __salt__[jinja_template_function](**kwargs)
82     if template_text is None:
83         raise Exception("No jinja template text")
84     txt = tpl.render_jinja_tmpl(template_text, context, tmplpath=None)
85     rt = config.get("replace_text_regex")
86     for r in rt:
87         txt = re.sub(r, rt[r], txt)
88     return txt
89 def _blacklist_filter(s, config):
90     ss = s["state"]
91     sf = s["fun"]
92     state_function = "{}.{}".format(s["state"], s["fun"])
93     for b in config["filter_function_regex"]:
94         if re.match(b, state_function):
95             return True
96     for b in config["filter_id_regex"]:
97         if re.match(b, s["__id__"]):
98             return True
99     return False
100 def process_lowstates(**kwargs):
101     states = []
102     config = _get_config(**kwargs)
103     processor = config.get("processor")
104     ls = __salt__["state.show_lowstate"]()
105     if not isinstance(ls, list):
106         raise Exception(
107             "ERROR: to see details run: [salt-call state.show_lowstate]"
108             " &lt;-----***-SEE-***"
109         )
110     else:
111         if ls:
112             if not isinstance(ls[0], dict):
113                 raise Exception(
114                     "ERROR: to see details run: [salt-call state.show_lowstate]"
115                     " &lt;-----***-SEE-***"
116                 )
117     for s in ls:
118         if _blacklist_filter(s, config):
119             continue
120         doc = __salt__[processor](s, config, **kwargs)
121         states.append(doc)
122     return states
123 def _state_data_to_yaml_string(data, whitelist=None, blacklist=None):
124     y = {}
125     if blacklist is None:
126         blacklist = [
127             "__env__",
128             "__id__",
129             "__sls__",
130             "fun",
131             "name",
132             "context",
133             "order",
134             "state",
135             "require",
136             "require_in",
137             "watch",
138             "watch_in",
139         ]
140     kset = set(data.keys())
141     if blacklist:
142         kset -= set(blacklist)
143     if whitelist:
144         kset &amp;= set(whitelist)
145     for k in kset:
146         y[k] = data[k]
147     if not y:
148         return None
149     return salt.utils.yaml.safe_dump(y, default_flow_style=False)
150 def _md_fix(text):
151     return text.replace("```", "``[`][markdown parse fix]")
152 def _format_markdown_system_file(filename, config):
153     ret = ""
154     file_stats = __salt__["file.stats"](filename)
155     y = _state_data_to_yaml_string(
156         file_stats, whitelist=["user", "group", "mode", "uid", "gid", "size"]
157     )
158     if y:
159         ret += "file stat {1}\n```\n{0}```\n".format(y, filename)
160     file_size = file_stats.get("size")
161     if file_size &lt;= config.get("max_render_file_size"):
162         is_binary = True
163         try:
164             file_type = __salt__["cmd.shell"]("\\file -i '{}'".format(filename))
165             if "charset=binary" not in file_type:
166                 is_binary = False
167         except Exception as ex:  # pylint: disable=broad-except
168             is_binary = False
169 <a name="0"></a>        if is_binary:
170             file_data = "[[skipped binary data]]"
171         else:
172             <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>with salt.utils.files.fopen(filename, "r") as f:
173                 file_data = salt.utils.stringutils.to_unicode(f.read(</b></font>))
174         file_data = _md_fix(file_data)
175         ret += "file data {1}\n```\n{0}\n```\n".format(file_data, filename)
176     else:
177         ret += "```\n{}\n```\n".format(
178             "SKIPPED LARGE FILE!\nSet {}:max_render_file_size &gt; {} to render.".format(
179                 "{}.config".format(__virtualname__), file_size
180             )
181         )
182     return ret
183 def _format_markdown_link(name):
184     link = name
185     symbals = "~`!@#$%^&amp;*()+={}[]:;\"&lt;&gt;,.?/|'\\"
186     for s in symbals:
187         link = link.replace(s, "")
188     link = link.replace(" ", "-")
189     return link
190 def _format_markdown_requisite(state, stateid, makelink=True):
191     fmt_id = "{}: {}".format(state, stateid)
192     if makelink:
193         return " * [{}](#{})\n".format(fmt_id, _format_markdown_link(fmt_id))
194     else:
195         return " * `{}`\n".format(fmt_id)
196 def processor_markdown(lowstate_item, config, **kwargs):
197     s = lowstate_item
198     state_function = "{}.{}".format(s["state"], s["fun"])
199     id_full = "{}: {}".format(s["state"], s["__id__"])
200     requisites = ""
201     for comment, key in (
202         ("run or update after changes in:\n", "watch"),
203         ("after changes, run or update:\n", "watch_in"),
204         ("require:\n", "require"),
205         ("required in:\n", "require_in"),
206     ):
207         reqs = s.get(key, [])
208         if reqs:
209             requisites += comment
210             for w in reqs:
211                 requisites += _format_markdown_requisite(*next(iter(w.items())))
212     details = ""
213     if state_function == "highstate_doc.note":
214         if "contents" in s:
215             details += "\n{}\n".format(s["contents"])
216         if "source" in s:
217             text = __salt__["cp.get_file_str"](s["source"])
218             if text:
219                 details += "\n{}\n".format(text)
220             else:
221                 details += "\n{}\n".format("ERROR: opening {}".format(s["source"]))
222     if state_function == "pkg.installed":
223         pkgs = s.get("pkgs", s.get("name"))
224         details += "\n```\ninstall: {}\n```\n".format(pkgs)
225     if state_function == "file.recurse":
226         details += """recurse copy of files\n"""
227         y = _state_data_to_yaml_string(s)
228         if y:
229             details += "```\n{}\n```\n".format(y)
230         if "!doc_recurse" in id_full:
231             findfiles = __salt__["file.find"](path=s.get("name"), type="f")
232             if len(findfiles) &lt; 10 or "!doc_recurse_force" in id_full:
233                 for f in findfiles:
234                     details += _format_markdown_system_file(f, config)
235             else:
236                 details += """ &gt; Skipping because more than 10 files to display.\n"""
237                 details += (
238                 )
239         else:
240             details += """ &gt; For more details review logs and Salt state files.\n\n"""
241             details += """ &gt; HINT: for improved docs use multiple file.managed states or file.archive, git.latest. etc.\n"""
242             details += """ &gt; HINT: to force doc to show all files in path add !doc_recurse .\n"""
243     if state_function == "file.blockreplace":
244         if s.get("content"):
245             details += "ensure block of content is in file\n```\n{}\n```\n".format(
246                 _md_fix(s["content"])
247             )
248         if s.get("source"):
249             text = "** source: " + s.get("source")
250             details += "ensure block of content is in file\n```\n{}\n```\n".format(
251                 _md_fix(text)
252             )
253     if state_function == "file.managed":
254         details += _format_markdown_system_file(s["name"], config)
255     if not details:
256         y = _state_data_to_yaml_string(s)
257         if y:
258             details += "```\n{}```\n".format(y)
259     r = {
260         "vars": lowstate_item,
261         "state": s["state"],
262         "name": s["name"],
263         "function": s["fun"],
264         "id": s["__id__"],
265         "id_full": id_full,
266         "state_function": state_function,
267         "markdown": {
268             "requisites": requisites.decode("utf-8"),
269             "details": details.decode("utf-8"),
270         },
271     }
272     return r
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_file_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import errno
2 import filecmp
3 import logging
4 import os
5 import pathlib
6 import re
7 import shutil
8 import stat
9 import sys
10 import tempfile
11 import textwrap
12 import pytest
13 import salt.serializers.configparser
14 import salt.serializers.plist
15 import salt.utils.atomicfile
16 import salt.utils.data
17 import salt.utils.files
18 import salt.utils.json
19 import salt.utils.path
20 import salt.utils.platform
21 import salt.utils.stringutils
22 from salt.utils.versions import LooseVersion as _LooseVersion
23 from tests.support.case import ModuleCase
24 from tests.support.helpers import (
25     Webserver,
26     dedent,
27     requires_system_grains,
28     with_system_user_and_group,
29     with_tempdir,
30     with_tempfile,
31 )
32 from tests.support.mixins import SaltReturnAssertsMixin
33 from tests.support.runtests import RUNTIME_VARS
34 from tests.support.unit import skipIf
35 log = logging.getLogger(__name__)
36 HAS_PWD = True
37 try:
38     import pwd
39 except ImportError:
40     HAS_PWD = False
41 HAS_GRP = True
42 try:
43     import grp
44 except ImportError:
45     HAS_GRP = False
46 IS_WINDOWS = salt.utils.platform.is_windows()
47 BINARY_FILE = b"GIF89a\x01\x00\x01\x00\x80\x00\x00\x05\x04\x04\x00\x00\x00,\x00\x00\x00\x00\x01\x00\x01\x00\x00\x02\x02D\x01\x00;"
48 TEST_SYSTEM_USER = "test_system_user"
49 TEST_SYSTEM_GROUP = "test_system_group"
50 DEFAULT_ENDING = salt.utils.stringutils.to_bytes(os.linesep)
51 pytestmark = [
52     pytest.mark.skip_on_freebsd(reason="These tests timeout on FreeBSD"),
53 ]
54 def _test_managed_file_mode_keep_helper(testcase, local=False):
55     name = testcase.tmp_dir / "scene33"
56     testcase.addCleanup(salt.utils.files.safe_rm, str(name))
57     grail_fs_path = os.path.join(RUNTIME_VARS.BASE_FILES, "grail", "scene33")
58     grail = "salt://grail/scene33" if not local else grail_fs_path
59     grail_fs_mode = int(testcase.run_function("file.get_mode", [grail_fs_path]), 8)
60     initial_mode = 0o770
61     new_mode_1 = 0o600
62     new_mode_2 = 0o644
63     ret = testcase.run_state(
64         "file.managed",
65         name=str(name),
66         mode=oct(initial_mode),
67         source=grail,
68     )
69     if IS_WINDOWS:
70         testcase.assertSaltFalseReturn(ret)
71         return
72     testcase.assertSaltTrueReturn(ret)
73     try:
74         os.chmod(grail_fs_path, new_mode_1)
75         ret = testcase.run_state(
76             "file.managed",
77             name=str(name),
78             mode="keep",
79             source=grail,
80         )
81         testcase.assertSaltTrueReturn(ret)
82         managed_mode = stat.S_IMODE(name.stat().st_mode)
83         testcase.assertEqual(oct(managed_mode), oct(new_mode_1))
84         os.chmod(grail_fs_path, new_mode_2)
85         ret = testcase.run_state(
86             "file.managed",
87             name=str(name),
88             mode="keep",
89             source=grail,
90         )
91         testcase.assertSaltTrueReturn(ret)
92         managed_mode = stat.S_IMODE(name.stat().st_mode)
93         testcase.assertEqual(oct(managed_mode), oct(new_mode_2))
94     finally:
95         os.chmod(grail_fs_path, grail_fs_mode)
96 @pytest.mark.windows_whitelisted
97 class FileTest(ModuleCase, SaltReturnAssertsMixin):
98     @classmethod
99     def setUpClass(cls):
100         cls.tmp_dir = pathlib.Path(tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)).resolve()
101         def _reline(path, ending=DEFAULT_ENDING):
102             with salt.utils.files.fopen(path, "rb") as fhr:
103                 lines = fhr.read().splitlines()
104             with salt.utils.atomicfile.atomic_open(path, "wb") as fhw:
105                 for line in lines:
106                     fhw.write(line + ending)
107         destpath = os.path.join(RUNTIME_VARS.BASE_FILES, "testappend", "firstif")
108         _reline(destpath)
109         destpath = os.path.join(RUNTIME_VARS.BASE_FILES, "testappend", "secondif")
110         _reline(destpath)
111     @classmethod
112     def tearDownClass(cls):
113         salt.utils.files.rm_rf(str(cls.tmp_dir))
114     def _delete_file(self, path):
115         try:
116             os.remove(path)
117         except OSError as exc:
118             if exc.errno != errno.ENOENT:
119                 log.error("Failed to remove %s: %s", path, exc)
120     def tearDown(self):
121         user = "salt"
122         if user in str(self.run_function("user.list_users")):
123             self.run_function("user.delete", [user])
124     def test_symlink(self):
125         name = self.tmp_dir / "symlink"
126         tgt = self.tmp_dir / "target"
127         if IS_WINDOWS and not tgt.is_dir():
128             tgt.mkdir()
129         if IS_WINDOWS and name.is_symlink():
130             name.unlink()
131         ret = self.run_state("file.symlink", name=str(name), target=str(tgt))
132         self.assertSaltTrueReturn(ret)
133     def test_test_symlink(self):
134         name = self.tmp_dir / "symlink2"
135         tgt = self.tmp_dir / "target2"
136         ret = self.run_state("file.symlink", test=True, name=str(name), target=str(tgt))
137         self.assertSaltNoneReturn(ret)
138     def test_absent_file(self):
139         name = self.tmp_dir / "file_to_kill"
140         name.write_text("killme")
141         ret = self.run_state("file.absent", name=str(name))
142         self.assertSaltTrueReturn(ret)
143         self.assertFalse(name.is_file())
144     def test_absent_dir(self):
145         name = self.tmp_dir / "dir_to_kill"
146         name.mkdir(exist_ok=True)
147         ret = self.run_state("file.absent", name=str(name))
148         self.assertSaltTrueReturn(ret)
149         self.assertFalse(name.is_dir())
150     def test_absent_link(self):
151         name = self.tmp_dir / "link_to_kill"
152         self.addCleanup(salt.utils.files.safe_rm, str(name))
153         tgt = self.tmp_dir / "link_to_kill.tgt"
154         self.addCleanup(salt.utils.files.safe_rm, str(tgt))
155         tgt.symlink_to(name, target_is_directory=IS_WINDOWS)
156         ret = self.run_state("file.absent", name=str(name))
157         self.assertSaltTrueReturn(ret)
158         self.assertFalse(name.exists())
159         self.assertFalse(name.is_symlink())
160     @with_tempfile()
161     def test_test_absent(self, name):
162         with salt.utils.files.fopen(name, "w+") as fp_:
163             fp_.write("killme")
164         ret = self.run_state("file.absent", test=True, name=name)
165         self.assertSaltNoneReturn(ret)
166         self.assertTrue(os.path.isfile(name))
167     def test_managed(self):
168         name = self.tmp_dir / "grail_scene33"
169         self.addCleanup(salt.utils.files.safe_rm, str(name))
170         ret = self.run_state(
171             "file.managed", name=str(name), source="salt://grail/scene33"
172         )
173         src = pathlib.Path(RUNTIME_VARS.BASE_FILES) / "grail" / "scene33"
174         master_data = src.read_text()
175         minion_data = name.read_text()
176         self.assertEqual(master_data, minion_data)
177         self.assertSaltTrueReturn(ret)
178     def test_managed_file_mode(self):
179         desired_mode = 504  # 0770 octal
180         name = self.tmp_dir / "grail_scene33"
181         self.addCleanup(salt.utils.files.safe_rm, str(name))
182         ret = self.run_state(
183             "file.managed", name=str(name), mode="0770", source="salt://grail/scene33"
184         )
185         if IS_WINDOWS:
186             expected = "The 'mode' option is not supported on Windows"
187             self.assertEqual(ret[list(ret)[0]]["comment"], expected)
188             self.assertSaltFalseReturn(ret)
189             return
190         resulting_mode = stat.S_IMODE(name.stat().st_mode)
191         self.assertEqual(oct(desired_mode), oct(resulting_mode))
192         self.assertSaltTrueReturn(ret)
193     @skipIf(IS_WINDOWS, "Windows does not report any file modes. Skipping.")
194     def test_managed_file_mode_keep(self):
195         _test_managed_file_mode_keep_helper(self, local=False)
196     @skipIf(IS_WINDOWS, "Windows does not report any file modes. Skipping.")
197     def test_managed_file_mode_keep_local_source(self):
198         _test_managed_file_mode_keep_helper(self, local=True)
199     def test_managed_file_mode_file_exists_replace(self):
200         initial_mode = 504  # 0770 octal
201         desired_mode = 384  # 0600 octal
202         name = self.tmp_dir / "grail_scene33"
203         self.addCleanup(salt.utils.files.safe_rm, str(name))
204         ret = self.run_state(
205             "file.managed",
206             name=str(name),
207             mode=oct(initial_mode),
208             source="salt://grail/scene33",
209         )
210         if IS_WINDOWS:
211             expected = "The 'mode' option is not supported on Windows"
212             self.assertEqual(ret[list(ret)[0]]["comment"], expected)
213             self.assertSaltFalseReturn(ret)
214             return
215         resulting_mode = stat.S_IMODE(name.stat().st_mode)
216         self.assertEqual(oct(initial_mode), oct(resulting_mode))
217         ret = self.run_state(
218             "file.managed",
219             name=str(name),
220             replace=True,
221             mode=oct(desired_mode),
222             source="salt://grail/scene33",
223         )
224         resulting_mode = stat.S_IMODE(name.stat().st_mode)
225         self.assertEqual(oct(desired_mode), oct(resulting_mode))
226         self.assertSaltTrueReturn(ret)
227     def test_managed_file_mode_file_exists_noreplace(self):
228         initial_mode = 504  # 0770 octal
229         desired_mode = 384  # 0600 octal
230         name = self.tmp_dir / "grail_scene33"
231         self.addCleanup(salt.utils.files.safe_rm, str(name))
232         ret = self.run_state(
233             "file.managed",
234             name=str(name),
235             replace=True,
236             mode=oct(initial_mode),
237             source="salt://grail/scene33",
238         )
239         if IS_WINDOWS:
240             expected = "The 'mode' option is not supported on Windows"
241             self.assertEqual(ret[list(ret)[0]]["comment"], expected)
242             self.assertSaltFalseReturn(ret)
243             return
244         ret = self.run_state(
245             "file.managed",
246             name=str(name),
247             replace=False,
248             mode=oct(desired_mode),
249             source="salt://grail/scene33",
250         )
251         resulting_mode = stat.S_IMODE(name.stat().st_mode)
252         self.assertEqual(oct(desired_mode), oct(resulting_mode))
253         self.assertSaltTrueReturn(ret)
254     def test_managed_file_with_grains_data(self):
255         grain_path = self.tmp_dir / "file-grain-test"
256         self.addCleanup(salt.utils.files.safe_rm, str(grain_path))
257         state_file = "file-grainget"
258         self.run_function(
259             "state.sls", [state_file], pillar={"grain_path": str(grain_path)}
260         )
261         self.assertTrue(grain_path.exists())
262         file_contents = grain_path.read_text().splitlines(True)
263         match = "^minion\n"
264         self.assertTrue(re.match(match, file_contents[0]))
265     def test_managed_file_with_pillardefault_sls(self):
266         file_pillar_def = os.path.join(RUNTIME_VARS.TMP, "filepillar-defaultvalue")
267         self.addCleanup(self._delete_file, file_pillar_def)
268         state_name = "file-pillardefaultget"
269         log.warning("File Path: %s", file_pillar_def)
270         ret = self.run_function("state.sls", [state_name])
271         self.assertSaltTrueReturn(ret)
272         check_file = self.run_function("file.file_exists", [file_pillar_def])
273         self.assertTrue(check_file)
274     @pytest.mark.skip_if_not_root
275     def test_managed_dir_mode(self):
276         desired_mode = 511  # 0777 in octal
277         name = self.tmp_dir / "a" / "managed_dir_mode_test_file"
278         self.addCleanup(salt.utils.files.safe_rm, str(name))
279         desired_owner = "nobody"
280         ret = self.run_state(
281             "file.managed",
282             name=str(name),
283             source="salt://grail/scene33",
284             mode=600,
285             makedirs=True,
286             user=desired_owner,
287             dir_mode=oct(desired_mode),  # 0777
288         )
289         if IS_WINDOWS:
290             expected = "The 'mode' option is not supported on Windows"
291             self.assertEqual(ret[list(ret)[0]]["comment"], expected)
292             self.assertSaltFalseReturn(ret)
293             return
294         resulting_mode = stat.S_IMODE(name.parent.stat().st_mode)
295         resulting_owner = pwd.getpwuid(name.parent.stat().st_uid).pw_name
296         self.assertEqual(oct(desired_mode), oct(resulting_mode))
297         self.assertSaltTrueReturn(ret)
298         self.assertEqual(desired_owner, resulting_owner)
299     def test_test_managed(self):
300         name = self.tmp_dir / "grail_not_not_scene33"
301         self.addCleanup(salt.utils.files.safe_rm, str(name))
302         ret = self.run_state(
303             "file.managed", test=True, name=str(name), source="salt://grail/scene33"
304         )
305         self.assertSaltNoneReturn(ret)
306         self.assertFalse(name.is_file())
307     def test_managed_show_changes_false(self):
308         name = self.tmp_dir / "grail_not_scene33"
309         self.addCleanup(salt.utils.files.safe_rm, str(name))
310         name.write_bytes(b"test_managed_show_changes_false\n")
311         ret = self.run_state(
312             "file.managed",
313             name=str(name),
314             source="salt://grail/scene33",
315             show_changes=False,
316         )
317         changes = next(iter(ret.values()))["changes"]
318         self.assertEqual("&lt;show_changes=False&gt;", changes["diff"])
319     def test_managed_show_changes_true(self):
320         name = self.tmp_dir / "grail_not_scene33"
321         self.addCleanup(salt.utils.files.safe_rm, str(name))
322         name.write_bytes(b"test_managed_show_changes_false\n")
323         ret = self.run_state(
324             "file.managed",
325             name=str(name),
326             source="salt://grail/scene33",
327         )
328         changes = next(iter(ret.values()))["changes"]
329         self.assertIn("diff", changes)
330     @skipIf(IS_WINDOWS, "Don't know how to fix for Windows")
331     def test_managed_escaped_file_path(self):
332         funny_file = salt.utils.files.mkstemp(
333             prefix="?f!le? n@=3&amp;", suffix=".file type"
334         )
335         funny_file_name = os.path.split(funny_file)[1]
336         funny_url = "salt://|" + funny_file_name
337         funny_url_path = os.path.join(RUNTIME_VARS.BASE_FILES, funny_file_name)
338         state_name = "funny_file"
339         state_file_name = state_name + ".sls"
340         state_file = os.path.join(RUNTIME_VARS.BASE_FILES, state_file_name)
341         state_key = "file_|-{0}_|-{0}_|-managed".format(funny_file)
342         self.addCleanup(os.remove, state_file)
343         self.addCleanup(os.remove, funny_file)
344         self.addCleanup(os.remove, funny_url_path)
345         with salt.utils.files.fopen(funny_url_path, "w"):
346             pass
347         with salt.utils.files.fopen(state_file, "w") as fp_:
348             fp_.write(
349                 textwrap.dedent(
350                         funny_file, funny_url
351                     )
352                 )
353             )
354         ret = self.run_function("state.sls", [state_name])
355         self.assertTrue(ret[state_key]["result"])
356     def test_managed_contents(self):
357         state_name = "file-FileTest-test_managed_contents"
358         state_filename = state_name + ".sls"
359         state_file = os.path.join(RUNTIME_VARS.BASE_FILES, state_filename)
360         managed_files = {}
361         state_keys = {}
362         for typ in ("bool", "str", "int", "float", "list", "dict"):
363             managed_files[typ] = salt.utils.files.mkstemp()
364             state_keys[typ] = "file_|-{} file_|-{}_|-managed".format(
365                 typ, managed_files[typ]
366             )
367         try:
368             with salt.utils.files.fopen(state_file, "w") as fd_:
369                 fd_.write(
370                     textwrap.dedent(
371                             **managed_files
372                         )
373                     )
374                 )
375             ret = self.run_function("state.sls", [state_name])
376             self.assertSaltTrueReturn(ret)
377             for typ in state_keys:
378                 self.assertTrue(ret[state_keys[typ]]["result"])
379                 self.assertIn("diff", ret[state_keys[typ]]["changes"])
380         finally:
381             if os.path.exists(state_file):
382                 os.remove(state_file)
383             for typ in managed_files:
384                 if os.path.exists(managed_files[typ]):
385                     os.remove(managed_files[typ])
386     def test_onchanges_any_recursive_error_issues_50811(self):
387         state_name = "onchanges_any_recursive_error"
388         state_filename = state_name + ".sls"
389         state_file = os.path.join(RUNTIME_VARS.BASE_FILES, state_filename)
390         try:
391             with salt.utils.files.fopen(state_file, "w") as fd_:
392                 fd_.write(
393                     textwrap.dedent(
394                     )
395                 )
396             ret = self.run_function("state.sls", [state_name])
397             self.assertSaltFalseReturn(ret)
398         finally:
399             if os.path.exists(state_file):
400                 os.remove(state_file)
401     def test_prerequired_issues_55775(self):
402         state_name = "Test_Issues_55775"
403         state_filename = state_name + ".sls"
404         state_file = os.path.join(RUNTIME_VARS.BASE_FILES, state_filename)
405         test_file = os.path.join(RUNTIME_VARS.BASE_FILES, "Issues_55775.txt")
406         try:
407             with salt.utils.files.fopen(state_file, "w") as fd_:
408                 fd_.write(
409                     textwrap.dedent(
410                             test_file
411                         )
412                     )
413                 )
414             ret = self.run_function("state.sls", [state_name])
415             self.assertSaltTrueReturn(ret)
416         finally:
417             for fpath in (state_file, test_file):
418                 if os.path.exists(fpath):
419                     os.remove(fpath)
420     def test_managed_contents_with_contents_newline(self):
421         contents = "test_managed_contents_with_newline_one"
422         name = self.tmp_dir / "foo"
423         self.addCleanup(salt.utils.files.safe_rm, str(name))
424         self.run_state(
425             "file.managed", name=str(name), contents=contents, contents_newline=True
426         )
427         last_line = name.read_text()
428         self.assertEqual((contents + "\n"), last_line)
429     def test_managed_contents_with_contents_newline_false(self):
430         contents = "test_managed_contents_with_newline_one"
431         name = self.tmp_dir / "bar"
432         self.addCleanup(salt.utils.files.safe_rm, str(name))
433         self.run_state(
434             "file.managed", name=str(name), contents=contents, contents_newline=False
435         )
436         last_line = name.read_text()
437         self.assertEqual(contents, last_line)
438     def test_managed_multiline_contents_with_contents_newline(self):
439         contents = "this is a cookie\nthis is another cookie"
440         name = self.tmp_dir / "bar"
441         self.addCleanup(salt.utils.files.safe_rm, str(name))
442         self.run_state(
443             "file.managed", name=str(name), contents=contents, contents_newline=True
444         )
445         last_line = name.read_text()
446         self.assertEqual((contents + "\n"), last_line)
447     def test_managed_multiline_contents_with_contents_newline_false(self):
448         contents = "this is a cookie\nthis is another cookie"
449         name = self.tmp_dir / "bar"
450         self.addCleanup(salt.utils.files.safe_rm, str(name))
451         self.run_state(
452             "file.managed", name=str(name), contents=contents, contents_newline=False
453         )
454         last_line = name.read_text()
455         self.assertEqual(contents, last_line)
456     @pytest.mark.skip_if_not_root
457     @skipIf(IS_WINDOWS, 'Windows does not support "mode" kwarg. Skipping.')
458     @skipIf(not salt.utils.path.which("visudo"), "sudo is missing")
459     def test_managed_check_cmd(self):
460         r_group = "root"
461         if salt.utils.platform.is_darwin() or salt.utils.platform.is_freebsd():
462             r_group = "wheel"
463         name = self.tmp_dir / "sudoers"
464         self.addCleanup(salt.utils.files.safe_rm, str(name))
465         ret = self.run_state(
466             "file.managed",
467             name=str(name),
468             user="root",
469             group=r_group,
470             mode=440,
471             check_cmd="visudo -c -s -f",
472         )
473         self.assertSaltTrueReturn(ret)
474         self.assertInSaltComment("Empty file", ret)
475         self.assertEqual(
476             ret["file_|-{0}_|-{0}_|-managed".format(name)]["changes"],
477             {"new": "file {} created".format(name), "mode": "0440"},
478         )
479     def test_managed_local_source_with_source_hash(self):
480         name = self.tmp_dir / "local_source_with_source_hash"
481         self.addCleanup(salt.utils.files.safe_rm, str(name))
482         local_path = os.path.join(RUNTIME_VARS.BASE_FILES, "grail", "scene33")
483         actual_hash = "567fd840bf1548edc35c48eb66cdd78bfdfcccff"
484         if IS_WINDOWS:
485             actual_hash = "f658a0ec121d9c17088795afcc6ff3c43cb9842a"
486         bad_hash = actual_hash[::-1]
487         def remove_file():
488             try:
489                 os.remove(str(name))
490             except OSError as exc:
491                 if exc.errno != errno.ENOENT:
492                     raise
493         def do_test(clean=False):
494             for proto in ("file://", ""):
495                 source = proto + local_path
496                 log.debug("Trying source %s", source)
497                 try:
498                     ret = self.run_state(
499                         "file.managed",
500                         name=str(name),
501                         source=source,
502                         source_hash="sha1={}".format(bad_hash),
503                     )
504                     self.assertSaltFalseReturn(ret)
505                     ret = ret[next(iter(ret))]
506                     self.assertFalse(ret["changes"])
507                     self.assertIn("does not match actual checksum", ret["comment"])
508                     ret = self.run_state(
509                         "file.managed",
510                         name=str(name),
511                         source=source,
512                         source_hash="sha1={}".format(actual_hash),
513                     )
514                     self.assertSaltTrueReturn(ret)
515                 finally:
516                     if clean:
517                         remove_file()
518         remove_file()
519         log.debug("Trying with nonexistant destination file")
520         do_test()
521         log.debug("Trying with destination file already present")
522         name.write_text("")
523         try:
524             do_test(clean=False)
525         finally:
526             remove_file()
527     def test_managed_local_source_does_not_exist(self):
528         name = self.tmp_dir / "local_source_does_not_exist"
529         self.addCleanup(salt.utils.files.safe_rm, str(name))
530         local_path = os.path.join(RUNTIME_VARS.BASE_FILES, "grail", "scene99")
531         for proto in ("file://", ""):
532             source = proto + local_path
533             log.debug("Trying source %s", source)
534             ret = self.run_state("file.managed", name=str(name), source=source)
535             self.assertSaltFalseReturn(ret)
536             ret = ret[next(iter(ret))]
537             self.assertFalse(ret["changes"])
538             self.assertIn("does not exist", ret["comment"])
539     def test_managed_unicode_jinja_with_tojson_filter(self):
540         test_file = self.tmp_dir / "test-tojson.txt"
541         self.addCleanup(salt.utils.files.safe_rm, str(test_file))
542         ret = self.run_function(
543             "state.apply", mods="tojson", pillar={"tojson-file": str(test_file)}
544         )
545         ret = ret[next(iter(ret))]
546         assert ret["result"], ret
547         managed = salt.utils.stringutils.to_unicode(test_file.read_bytes())
548         expected = dedent(
549         )
550         assert managed == expected, "{!r} != {!r}".format(managed, expected)
551     def test_managed_source_hash_indifferent_case(self):
552         name = self.tmp_dir / "source_hash_indifferent_case"
553         self.addCleanup(salt.utils.files.safe_rm, str(name))
554         state_name = "file_|-{0}_|-{0}_|-managed".format(name)
555         local_path = os.path.join(RUNTIME_VARS.BASE_FILES, "hello_world.txt")
556         actual_hash = "c98c24b677eff44860afea6f493bbaec5bb1c4cbb209c6fc2bbb47f66ff2ad31"
557         if IS_WINDOWS:
558             actual_hash = (
559                 "92b772380a3f8e27a93e57e6deeca6c01da07f5aadce78bb2fbb20de10a66925"
560             )
561         uppercase_hash = actual_hash.upper()
562         self.run_state(
563             "file.managed", name=str(name), source=local_path, source_hash=actual_hash
564         )
565         ret = self.run_state(
566             "file.managed",
567             name=str(name),
568             source=local_path,
569             source_hash=uppercase_hash,
570         )
571         assert ret[state_name]["result"] is True
572         assert ret[state_name]["changes"] == {}
573         ret = self.run_state(
574             "file.managed",
575             name=str(name),
576             source=local_path,
577             source_hash=uppercase_hash,
578             test=True,
579         )
580         assert ret[state_name]["result"] is True
581         assert ret[state_name]["changes"] == {}
582     @with_tempfile(create=False)
583     def test_managed_latin1_diff(self, name):
584         ret = self.run_state(
585             "file.managed", name=name, source="salt://issue-48777/old.html"
586         )
587         ret = ret[next(iter(ret))]
588         assert ret["result"] is True, ret
589         ret = self.run_state(
590             "file.managed", name=name, source="salt://issue-48777/new.html"
591         )
592         ret = ret[next(iter(ret))]
593         assert ret["result"] is True, ret
594         diff_lines = ret["changes"]["diff"].split(os.linesep)
595         assert "+räksmörgås" in diff_lines, diff_lines
596     @with_tempfile()
597     def test_managed_keep_source_false_salt(self, name):
598         source = "salt://grail/scene33"
599         saltenv = "base"
600         ret = self.run_state(
601             "file.managed", name=name, source=source, saltenv=saltenv, keep_source=False
602         )
603         ret = ret[next(iter(ret))]
604         assert ret["result"] is True
605         result = self.run_function("cp.is_cached", [source, saltenv])
606         assert result == "", "File is still cached at {}".format(result)
607     @with_tempfile(create=False)
608     @with_tempfile(create=False)
609     def test_file_managed_onchanges(self, file1, file2):
610         pillar = {
611             "file1": file1,
612             "file2": file2,
613             "source": "salt://testfile",
614             "req": "onchanges",
615         }
616         self.run_state("file.managed", name=pillar["file2"], source=pillar["source"])
617         ret = self.repack_state_returns(
618             self.run_function(
619                 "state.apply",
620                 mods="onchanges_prereq",
621                 pillar=pillar,
622                 test=True,
623             )
624         )
625         assert ret["one"]["result"] is None, ret["one"]["result"]
626         assert ret["three"]["result"] is True, ret["three"]["result"]
627         assert ret["one"]["changes"]
628         assert not ret["three"]["changes"], ret["three"]["changes"]
629         assert ret["two"]["comment"] == "Success!", ret["two"]["comment"]
630         assert (
631             ret["four"]["comment"]
632             == "State was not run because none of the onchanges reqs changed"
633         ), ret["four"]["comment"]
634     @with_tempfile(create=False)
635     @with_tempfile(create=False)
636     def test_file_managed_prereq(self, file1, file2):
637         pillar = {
638             "file1": file1,
639             "file2": file2,
640             "source": "salt://testfile",
641             "req": "prereq",
642         }
643         self.run_state("file.managed", name=pillar["file2"], source=pillar["source"])
644         ret = self.repack_state_returns(
645             self.run_function(
646                 "state.apply",
647                 mods="onchanges_prereq",
648                 pillar=pillar,
649                 test=True,
650             )
651         )
652         assert ret["one"]["result"] is None, ret["one"]["result"]
653         assert ret["three"]["result"] is True, ret["three"]["result"]
654         assert ret["one"]["changes"]
655         assert not ret["three"]["changes"], ret["three"]["changes"]
656         assert ret["two"]["comment"] == "Success!", ret["two"]["comment"]
657         assert ret["four"]["comment"] == "No changes detected", ret["four"]["comment"]
658     def test_directory(self):
659         name = self.tmp_dir / "a_new_dir"
660         self.addCleanup(salt.utils.files.rm_rf, str(name))
661         ret = self.run_state("file.directory", name=str(name))
662         self.assertSaltTrueReturn(ret)
663         self.assertTrue(name.is_dir())
664     def test_directory_symlink_dry_run(self):
665         tmp_dir = self.tmp_dir / "pgdata"
666         self.addCleanup(salt.utils.files.rm_rf, str(tmp_dir))
667         sym_dir = self.tmp_dir / "pg_data"
668         self.addCleanup(salt.utils.files.safe_rm, str(sym_dir))
669         tmp_dir.mkdir(0o0700)
670         sym_dir.symlink_to(tmp_dir, target_is_directory=IS_WINDOWS)
671         if IS_WINDOWS:
672             ret = self.run_state(
673                 "file.directory",
674                 test=True,
675                 name=str(sym_dir),
676                 follow_symlinks=True,
677                 win_owner="Administrators",
678             )
679         else:
680             ret = self.run_state(
681                 "file.directory",
682                 test=True,
683                 name=str(sym_dir),
684                 follow_symlinks=True,
685                 mode=700,
686             )
687         self.assertSaltTrueReturn(ret)
688     @requires_system_grains
689     @pytest.mark.skip_if_not_root
690     @skipIf(IS_WINDOWS, "Mode not available in Windows")
691     def test_directory_max_depth(self, grains):
692         def _get_oct_mode(name):
693             return salt.utils.files.normalize_mode(oct(os.stat(name).st_mode &amp; 0o777))
694         top = os.path.join(RUNTIME_VARS.TMP, "top_dir")
695         self.addCleanup(salt.utils.files.rm_rf, top)
696         sub = os.path.join(top, "sub_dir")
697         subsub = os.path.join(sub, "sub_sub_dir")
698         dirs = [top, sub, subsub]
699         initial_mode = "0111"
700         changed_mode = "0555"
701         if grains["os"] in ("VMware Photon OS",):
702             initial_modes = {
703                 0: {sub: "0750", subsub: "0110"},
704                 1: {sub: "0110", subsub: "0110"},
705                 2: {sub: "0110", subsub: "0110"},
706             }
707         else:
708             initial_modes = {
709                 0: {sub: "0755", subsub: "0111"},
710                 1: {sub: "0111", subsub: "0111"},
711                 2: {sub: "0111", subsub: "0111"},
712             }
713         if not os.path.isdir(subsub):
714             os.makedirs(subsub, int(initial_mode, 8))
715         for depth in range(0, 3):
716             ret = self.run_state(
717                 "file.directory",
718                 name=top,
719                 max_depth=depth,
720                 dir_mode=changed_mode,
721                 recurse=["mode"],
722             )
723             self.assertSaltTrueReturn(ret)
724             for changed_dir in dirs[0 : depth + 1]:
725                 self.assertEqual(changed_mode, _get_oct_mode(changed_dir))
726             for untouched_dir in dirs[depth + 1 :]:
727                 if sys.version_info &gt;= (3, 7):
728                     _mode = initial_modes[depth][untouched_dir]
729                     self.assertEqual(_mode, _get_oct_mode(untouched_dir))
730                 else:
731                     self.assertEqual(initial_mode, _get_oct_mode(untouched_dir))
732     def test_test_directory(self):
733         name = self.tmp_dir / "a_not_dir"
734         self.addCleanup(shutil.rmtree, str(name), ignore_errors=True)
735         ret = self.run_state("file.directory", test=True, name=str(name))
736         self.assertSaltNoneReturn(ret)
737         self.assertFalse(name.is_dir())
738     @with_tempdir()
739     def test_directory_clean(self, base_dir):
740         name = os.path.join(base_dir, "directory_clean_dir")
741         os.mkdir(name)
742         strayfile = os.path.join(name, "strayfile")
743         with salt.utils.files.fopen(strayfile, "w"):
744             pass
745         straydir = os.path.join(name, "straydir")
746         if not os.path.isdir(straydir):
747             os.makedirs(straydir)
748         with salt.utils.files.fopen(os.path.join(straydir, "strayfile2"), "w"):
749             pass
750         ret = self.run_state("file.directory", name=name, clean=True)
751         self.assertSaltTrueReturn(ret)
752         self.assertFalse(os.path.exists(strayfile))
753         self.assertFalse(os.path.exists(straydir))
754         self.assertTrue(os.path.isdir(name))
755     def test_directory_is_idempotent(self):
756         name = self.tmp_dir / "a_dir_twice"
757         self.addCleanup(salt.utils.files.rm_rf, str(name))
758         if IS_WINDOWS:
759             username = os.environ.get("USERNAME", "Administrators")
760             domain = os.environ.get("USERDOMAIN", "")
761             fullname = "{}\\{}".format(domain, username)
762             ret = self.run_state("file.directory", name=str(name), win_owner=fullname)
763         else:
764             ret = self.run_state("file.directory", name=str(name))
765         self.assertSaltTrueReturn(ret)
766         if IS_WINDOWS:
767             ret = self.run_state("file.directory", name=str(name), win_owner=username)
768         else:
769             ret = self.run_state("file.directory", name=str(name))
770         self.assertSaltTrueReturn(ret)
771         self.assertSaltStateChangesEqual(ret, {})
772     @with_tempdir()
773     def test_directory_clean_exclude(self, base_dir):
774         name = os.path.join(base_dir, "directory_clean_dir")
775         if not os.path.isdir(name):
776             os.makedirs(name)
777         strayfile = os.path.join(name, "strayfile")
778         with salt.utils.files.fopen(strayfile, "w"):
779             pass
780         straydir = os.path.join(name, "straydir")
781         if not os.path.isdir(straydir):
782             os.makedirs(straydir)
783         strayfile2 = os.path.join(straydir, "strayfile2")
784         with salt.utils.files.fopen(strayfile2, "w"):
785             pass
786         keepfile = os.path.join(straydir, "keepfile")
787         with salt.utils.files.fopen(keepfile, "w"):
788             pass
789         exclude_pat = "E@^straydir(|/keepfile)$"
790         if IS_WINDOWS:
791             exclude_pat = "E@^straydir(|\\\\keepfile)$"
792         ret = self.run_state(
793             "file.directory", name=name, clean=True, exclude_pat=exclude_pat
794         )
795         self.assertSaltTrueReturn(ret)
796         self.assertFalse(os.path.exists(strayfile))
797         self.assertFalse(os.path.exists(strayfile2))
798         self.assertTrue(os.path.exists(keepfile))
799     @skipIf(IS_WINDOWS, "Skip on windows")
800     @with_tempdir()
801     def test_test_directory_clean_exclude(self, base_dir):
802         name = os.path.join(base_dir, "directory_clean_dir")
803         os.mkdir(name)
804         strayfile = os.path.join(name, "strayfile")
805         with salt.utils.files.fopen(strayfile, "w"):
806             pass
807         straydir = os.path.join(name, "straydir")
808         if not os.path.isdir(straydir):
809             os.makedirs(straydir)
810         strayfile2 = os.path.join(straydir, "strayfile2")
811         with salt.utils.files.fopen(strayfile2, "w"):
812             pass
813         keepfile = os.path.join(straydir, "keepfile")
814         with salt.utils.files.fopen(keepfile, "w"):
815             pass
816         exclude_pat = "E@^straydir(|/keepfile)$"
817         if IS_WINDOWS:
818             exclude_pat = "E@^straydir(|\\\\keepfile)$"
819         ret = self.run_state(
820             "file.directory", test=True, name=name, clean=True, exclude_pat=exclude_pat
821         )
822         comment = next(iter(ret.values()))["comment"]
823         self.assertSaltNoneReturn(ret)
824         self.assertTrue(os.path.exists(strayfile))
825         self.assertTrue(os.path.exists(strayfile2))
826         self.assertTrue(os.path.exists(keepfile))
827         self.assertIn(strayfile, comment)
828         self.assertIn(strayfile2, comment)
829         self.assertNotIn(keepfile, comment)
830     @with_tempdir()
831     def test_directory_clean_require_in(self, name):
832         state_name = "file-FileTest-test_directory_clean_require_in"
833         state_filename = state_name + ".sls"
834         state_file = os.path.join(RUNTIME_VARS.BASE_FILES, state_filename)
835         wrong_file = os.path.join(name, "wrong")
836         with salt.utils.files.fopen(wrong_file, "w") as fp:
837             fp.write("foo")
838         good_file = os.path.join(name, "bar")
839         with salt.utils.files.fopen(state_file, "w") as fp:
840             self.addCleanup(salt.utils.files.safe_rm, state_file)
841             fp.write(
842                 textwrap.dedent(
843                         name=name, good_file=good_file
844                     )
845                 )
846             )
847         ret = self.run_function("state.sls", [state_name])
848         self.assertTrue(os.path.exists(good_file))
849         self.assertFalse(os.path.exists(wrong_file))
850     @with_tempdir()
851     def test_directory_clean_require_in_with_id(self, name):
852         state_name = "file-FileTest-test_directory_clean_require_in_with_id"
853         state_filename = state_name + ".sls"
854         state_file = os.path.join(RUNTIME_VARS.BASE_FILES, state_filename)
855         wrong_file = os.path.join(name, "wrong")
856         with salt.utils.files.fopen(wrong_file, "w") as fp:
857             fp.write("foo")
858         good_file = os.path.join(name, "bar")
859         with salt.utils.files.fopen(state_file, "w") as fp:
860             self.addCleanup(salt.utils.files.safe_rm, state_file)
861             fp.write(
862                 textwrap.dedent(
863                         name=name, good_file=good_file
864                     )
865                 )
866             )
867         ret = self.run_function("state.sls", [state_name])
868         self.assertTrue(os.path.exists(good_file))
869         self.assertFalse(os.path.exists(wrong_file))
870     @skipIf(
871         salt.utils.platform.is_darwin(),
872         "WAR ROOM TEMPORARY SKIP, Test is flaky on macosx",
873     )
874     @with_tempdir()
875     def test_directory_clean_require_with_name(self, name):
876         state_name = "file-FileTest-test_directory_clean_require_in_with_id"
877         state_filename = state_name + ".sls"
878         state_file = os.path.join(RUNTIME_VARS.BASE_FILES, state_filename)
879         wrong_file = os.path.join(name, "wrong")
880         with salt.utils.files.fopen(wrong_file, "w") as fp:
881             fp.write("foo")
882         good_file = os.path.join(name, "bar")
883         with salt.utils.files.fopen(state_file, "w") as fp:
884             self.addCleanup(salt.utils.files.safe_rm, state_file)
885             fp.write(
886                 textwrap.dedent(
887                         name=name, good_file=good_file
888                     )
889                 )
890             )
891         ret = self.run_function("state.sls", [state_name])
892         self.assertTrue(os.path.exists(good_file))
893         self.assertFalse(os.path.exists(wrong_file))
894     def test_directory_broken_symlink(self):
895         tmp_dir = self.tmp_dir / "foo"
896         tmp_dir.mkdir(0o700)
897         self.addCleanup(salt.utils.files.rm_rf, str(tmp_dir))
898         null_file = tmp_dir / "null"
899         broken_link = tmp_dir / "broken"
900         broken_link.symlink_to(null_file)
901         if IS_WINDOWS:
902             ret = self.run_state(
903                 "file.directory",
904                 name=str(tmp_dir),
905                 recurse=["mode"],
906                 follow_symlinks=True,
907                 win_owner="Administrators",
908             )
909         else:
910             ret = self.run_state(
911                 "file.directory",
912                 name=str(tmp_dir),
913                 recurse=["mode"],
914                 file_mode=644,
915                 dir_mode=755,
916             )
917         self.assertSaltTrueReturn(ret)
918     @with_tempdir(create=False)
919     def test_recurse(self, name):
920         ret = self.run_state("file.recurse", name=name, source="salt://grail")
921         self.assertSaltTrueReturn(ret)
922         self.assertTrue(os.path.isfile(os.path.join(name, "36", "scene")))
923     @with_tempdir(create=False)
924     @with_tempdir(create=False)
925     def test_recurse_specific_env(self, dir1, dir2):
926         ret = self.run_state(
927             "file.recurse", name=dir1, source="salt://holy", __env__="prod"
928         )
929         self.assertSaltTrueReturn(ret)
930         self.assertTrue(os.path.isfile(os.path.join(dir1, "32", "scene")))
931         ret = self.run_state(
932             "file.recurse", name=dir2, source="salt://holy", saltenv="prod"
933         )
934         self.assertSaltTrueReturn(ret)
935         self.assertTrue(os.path.isfile(os.path.join(dir2, "32", "scene")))
936     @with_tempdir(create=False)
937     @with_tempdir(create=False)
938     def test_recurse_specific_env_in_url(self, dir1, dir2):
939         ret = self.run_state(
940             "file.recurse", name=dir1, source="salt://holy?saltenv=prod"
941         )
942         self.assertSaltTrueReturn(ret)
943         self.assertTrue(os.path.isfile(os.path.join(dir1, "32", "scene")))
944         ret = self.run_state(
945             "file.recurse", name=dir2, source="salt://holy?saltenv=prod"
946         )
947         self.assertSaltTrueReturn(ret)
948         self.assertTrue(os.path.isfile(os.path.join(dir2, "32", "scene")))
949     @with_tempdir(create=False)
950     def test_test_recurse(self, name):
951         ret = self.run_state(
952             "file.recurse",
953             test=True,
954             name=name,
955             source="salt://grail",
956         )
957         self.assertSaltNoneReturn(ret)
958         self.assertFalse(os.path.isfile(os.path.join(name, "36", "scene")))
959         self.assertFalse(os.path.exists(name))
960     @with_tempdir(create=False)
961     @with_tempdir(create=False)
962     def test_test_recurse_specific_env(self, dir1, dir2):
963         ret = self.run_state(
964             "file.recurse", test=True, name=dir1, source="salt://holy", __env__="prod"
965         )
966         self.assertSaltNoneReturn(ret)
967         self.assertFalse(os.path.isfile(os.path.join(dir1, "32", "scene")))
968         self.assertFalse(os.path.exists(dir1))
969         ret = self.run_state(
970             "file.recurse", test=True, name=dir2, source="salt://holy", saltenv="prod"
971         )
972         self.assertSaltNoneReturn(ret)
973         self.assertFalse(os.path.isfile(os.path.join(dir2, "32", "scene")))
974         self.assertFalse(os.path.exists(dir2))
975     @with_tempdir(create=False)
976     def test_recurse_template(self, name):
977         _ts = "TEMPLATE TEST STRING"
978         ret = self.run_state(
979             "file.recurse",
980             name=name,
981             source="salt://grail",
982             template="jinja",
983             defaults={"spam": _ts},
984         )
985         self.assertSaltTrueReturn(ret)
986         with salt.utils.files.fopen(os.path.join(name, "scene33"), "r") as fp_:
987             contents = fp_.read()
988         self.assertIn(_ts, contents)
989     @with_tempdir()
990     def test_recurse_clean(self, name):
991         strayfile = os.path.join(name, "strayfile")
992         with salt.utils.files.fopen(strayfile, "w"):
993             pass
994         with salt.utils.files.fopen(os.path.join(name, "36"), "w"):
995             pass
996         os.makedirs(os.path.join(name, "scene33"))
997         ret = self.run_state(
998             "file.recurse", name=name, source="salt://grail", clean=True
999         )
1000         self.assertSaltTrueReturn(ret)
1001         self.assertFalse(os.path.exists(strayfile))
1002         self.assertTrue(os.path.isfile(os.path.join(name, "36", "scene")))
1003         self.assertTrue(os.path.isfile(os.path.join(name, "scene33")))
1004     @with_tempdir()
1005     def test_recurse_clean_specific_env(self, name):
1006         strayfile = os.path.join(name, "strayfile")
1007         with salt.utils.files.fopen(strayfile, "w"):
1008             pass
1009         with salt.utils.files.fopen(os.path.join(name, "32"), "w"):
1010             pass
1011         os.makedirs(os.path.join(name, "scene34"))
1012         ret = self.run_state(
1013             "file.recurse", name=name, source="salt://holy", clean=True, __env__="prod"
1014         )
1015         self.assertSaltTrueReturn(ret)
1016         self.assertFalse(os.path.exists(strayfile))
1017         self.assertTrue(os.path.isfile(os.path.join(name, "32", "scene")))
1018         self.assertTrue(os.path.isfile(os.path.join(name, "scene34")))
1019     @skipIf(IS_WINDOWS, "Skip on windows")
1020     @with_tempdir()
1021     def test_recurse_issue_34945(self, base_dir):
1022         dir_mode = "2775"
1023         issue_dir = "issue-34945"
1024         name = os.path.join(base_dir, issue_dir)
1025         ret = self.run_state(
1026             "file.recurse", name=name, source="salt://" + issue_dir, dir_mode=dir_mode
1027         )
1028         self.assertSaltTrueReturn(ret)
1029         actual_dir_mode = oct(stat.S_IMODE(os.stat(name).st_mode))[-4:]
1030         self.assertEqual(dir_mode, actual_dir_mode)
1031     @with_tempdir(create=False)
1032     def test_recurse_issue_40578(self, name):
1033         ret = self.run_state("file.recurse", name=name, source="salt://соль")
1034         self.assertSaltTrueReturn(ret)
1035         files = salt.utils.data.decode(os.listdir(name), normalize=True)
1036         self.assertEqual(
1037             sorted(files),
1038             sorted(["foo.txt", "спам.txt", "яйца.txt"]),
1039         )
1040     @with_tempfile()
1041     def test_replace(self, name):
1042         with salt.utils.files.fopen(name, "w+") as fp_:
1043             fp_.write("change_me")
1044         ret = self.run_state(
1045             "file.replace", name=name, pattern="change", repl="salt", backup=False
1046         )
1047         with salt.utils.files.fopen(name, "r") as fp_:
1048             self.assertIn("salt", fp_.read())
1049         self.assertSaltTrueReturn(ret)
1050     @with_tempdir()
1051     def test_replace_issue_18612(self, base_dir):
1052         test_name = "test_replace_issue_18612"
1053         path_test = os.path.join(base_dir, test_name)
1054         with salt.utils.files.fopen(path_test, "w+") as fp_test_:
1055             fp_test_.write("# en_US.UTF-8")
1056         ret = []
1057         for x in range(0, 3):
1058             ret.append(
1059                 self.run_state(
1060                     "file.replace",
1061                     name=path_test,
1062                     pattern="^# en_US.UTF-8$",
1063                     repl="en_US.UTF-8",
1064                     append_if_not_found=True,
1065                 )
1066             )
1067         with salt.utils.files.fopen(path_test, "r") as fp_test_:
1068             self.assertTrue(sum(1 for _ in fp_test_) == 1)
1069         with salt.utils.files.fopen(path_test, "r") as fp_test_:
1070             self.assertTrue(fp_test_.read().startswith("en_US.UTF-8"))
1071         for item in ret:
1072             self.assertSaltTrueReturn(item)
1073     @with_tempdir()
1074     def test_replace_issue_18612_prepend(self, base_dir):
1075         test_name = "test_replace_issue_18612_prepend"
1076         path_in = os.path.join(
1077             RUNTIME_VARS.FILES, "file.replace", "{}.in".format(test_name)
1078         )
1079         path_out = os.path.join(
1080             RUNTIME_VARS.FILES, "file.replace", "{}.out".format(test_name)
1081         )
1082         path_test = os.path.join(base_dir, test_name)
1083         shutil.copyfile(path_in, path_test)
1084         ret = []
1085         for x in range(0, 3):
1086             ret.append(
1087                 self.run_state(
1088                     "file.replace",
1089                     name=path_test,
1090                     pattern="^# en_US.UTF-8$",
1091                     repl="en_US.UTF-8",
1092                     prepend_if_not_found=True,
1093                 )
1094             )
1095         self.assertTrue(filecmp.cmp(path_test, path_out))
1096         self.assertTrue(filecmp.cmp(path_test + ".bak", path_in))
1097         for item in ret:
1098             self.assertSaltTrueReturn(item)
1099     @with_tempdir()
1100     def test_replace_issue_18612_append(self, base_dir):
1101         test_name = "test_replace_issue_18612_append"
1102         path_in = os.path.join(
1103             RUNTIME_VARS.FILES, "file.replace", "{}.in".format(test_name)
1104         )
1105         path_out = os.path.join(
1106             RUNTIME_VARS.FILES, "file.replace", "{}.out".format(test_name)
1107         )
1108         path_test = os.path.join(base_dir, test_name)
1109         shutil.copyfile(path_in, path_test)
1110         ret = []
1111         for x in range(0, 3):
1112             ret.append(
1113                 self.run_state(
1114                     "file.replace",
1115                     name=path_test,
1116                     pattern="^# en_US.UTF-8$",
1117                     repl="en_US.UTF-8",
1118                     append_if_not_found=True,
1119                 )
1120             )
1121         self.assertTrue(filecmp.cmp(path_test, path_out))
1122         self.assertTrue(filecmp.cmp(path_test + ".bak", path_in))
1123         for item in ret:
1124             self.assertSaltTrueReturn(item)
1125     @with_tempdir()
1126     def test_replace_issue_18612_append_not_found_content(self, base_dir):
1127         test_name = "test_replace_issue_18612_append_not_found_content"
1128         path_in = os.path.join(
1129             RUNTIME_VARS.FILES, "file.replace", "{}.in".format(test_name)
1130         )
1131         path_out = os.path.join(
1132             RUNTIME_VARS.FILES, "file.replace", "{}.out".format(test_name)
1133         )
1134         path_test = os.path.join(base_dir, test_name)
1135         shutil.copyfile(path_in, path_test)
1136         ret = []
1137         for x in range(0, 3):
1138             ret.append(
1139                 self.run_state(
1140                     "file.replace",
1141                     name=path_test,
1142                     pattern="^# en_US.UTF-8$",
1143                     repl="en_US.UTF-8",
1144                     append_if_not_found=True,
1145                     not_found_content=(
1146                         "THIS LINE WASN'T FOUND! SO WE'RE APPENDING IT HERE!"
1147                     ),
1148                 )
1149             )
1150         self.assertTrue(filecmp.cmp(path_test, path_out))
1151         self.assertTrue(filecmp.cmp(path_test + ".bak", path_in))
1152         for item in ret:
1153             self.assertSaltTrueReturn(item)
1154     @with_tempdir()
1155     def test_replace_issue_18612_change_mid_line_with_comment(self, base_dir):
1156         test_name = "test_replace_issue_18612_change_mid_line_with_comment"
1157         path_in = os.path.join(
1158             RUNTIME_VARS.FILES, "file.replace", "{}.in".format(test_name)
1159         )
1160         path_out = os.path.join(
1161             RUNTIME_VARS.FILES, "file.replace", "{}.out".format(test_name)
1162         )
1163         path_test = os.path.join(base_dir, test_name)
1164         shutil.copyfile(path_in, path_test)
1165         ret = []
1166         for x in range(0, 3):
1167             ret.append(
1168                 self.run_state(
1169                     "file.replace",
1170                     name=path_test,
1171                     pattern="^#foo=bar($|(?=\r\n))",
1172                     repl="foo=salt",
1173                     append_if_not_found=True,
1174                 )
1175             )
1176         self.assertTrue(filecmp.cmp(path_test, path_out))
1177         self.assertTrue(filecmp.cmp(path_test + ".bak", path_in))
1178         for item in ret:
1179             self.assertSaltTrueReturn(item)
1180     @with_tempdir()
1181     def test_replace_issue_18841_no_changes(self, base_dir):
1182         test_name = "test_replace_issue_18841_no_changes"
1183         path_in = os.path.join(
1184             RUNTIME_VARS.FILES, "file.replace", "{}.in".format(test_name)
1185         )
1186         path_test = os.path.join(base_dir, test_name)
1187         shutil.copyfile(path_in, path_test)
1188         fstats_orig = os.stat(path_test)
1189         age = 5 * 24 * 60 * 60
1190         os.utime(path_test, (fstats_orig.st_mtime - age, fstats_orig.st_atime - age))
1191         ret = self.run_state(
1192             "file.replace",
1193             name=path_test,
1194             pattern="^hello world$",
1195             repl="goodbye world",
1196             show_changes=True,
1197             flags=["IGNORECASE"],
1198             backup=False,
1199         )
1200         fstats_post = os.stat(path_test)
1201         self.assertTrue(filecmp.cmp(path_in, path_test))
1202         self.assertFalse(os.path.exists(path_test + ".bak"))
1203         self.assertTrue(fstats_post.st_mtime, fstats_orig.st_mtime - age)
1204         self.assertSaltTrueReturn(ret)
1205     def test_serialize(self):
1206         path_test = self.tmp_dir / "test_serialize"
1207         self.addCleanup(salt.utils.files.safe_rm, str(path_test))
1208         ret = self.run_state(
1209             "file.serialize",
1210             name=str(path_test),
1211             dataset={
1212                 "name": "naive",
1213                 "description": "A basic test",
1214                 "a_list": ["first_element", "second_element"],
1215                 "finally": "the last item",
1216             },
1217             formatter="json",
1218         )
1219         serialized_file = salt.utils.stringutils.to_unicode(path_test.read_bytes())
1220         expected_file = "\n".join(
1221             [
1222                 "{",
1223                 '  "a_list": [',
1224                 '    "first_element",',
1225                 '    "second_element"',
1226                 "  ],",
1227                 '  "description": "A basic test",',
1228                 '  "finally": "the last item",',
1229                 '  "name": "naive"',
1230                 "}",
1231                 "",
1232             ]
1233         )
1234         self.assertEqual(serialized_file, expected_file)
1235     @with_tempfile(create=False)
1236     def test_serializer_deserializer_opts(self, name):
1237         data1 = {"foo": {"bar": "%(x)s"}}
1238         data2 = {"foo": {"abc": 123}}
1239         merged = {"foo": {"y": "not_used", "x": "baz", "abc": 123, "bar": "baz"}}
1240         ret = self.run_state(
1241             "file.serialize",
1242             name=name,
1243             dataset=data1,
1244             formatter="configparser",
1245             deserializer_opts=[{"defaults": {"y": "not_used"}}],
1246         )
1247         ret = ret[next(iter(ret))]
1248         assert ret["result"], ret
1249         assert "warnings" in ret
1250         ret = self.run_state(
1251             "file.serialize",
1252             name=name,
1253             dataset=data2,
1254             formatter="configparser",
1255             merge_if_exists=True,
1256             serializer_opts=[{"defaults": {"y": "not_used"}}],
1257             deserializer_opts=[{"defaults": {"x": "baz"}}],
1258         )
1259         ret = ret[next(iter(ret))]
1260         assert ret["result"], ret
1261         with salt.utils.files.fopen(name) as fp_:
1262             serialized_data = salt.serializers.configparser.deserialize(fp_)
1263         log.debug("serialized_data = %r", serialized_data)
1264         log.debug("merged = %r", merged)
1265         assert serialized_data["foo"]["y"] == merged["foo"]["y"]
1266         assert serialized_data["foo"]["bar"] == merged["foo"]["bar"]
1267     @with_tempfile(create=False)
1268     def test_serializer_plist_binary_file_open(self, name):
1269         data1 = {"foo": {"bar": "%(x)s"}}
1270         data2 = {"foo": {"abc": 123}}
1271         merged = {"foo": {"abc": 123, "bar": "%(x)s"}}
1272         ret = self.run_state(
1273             "file.serialize",
1274             name=name,
1275             dataset=data1,
1276             formatter="plist",
1277             serializer_opts=[{"fmt": "FMT_BINARY"}],
1278         )
1279         ret = ret[next(iter(ret))]
1280         assert ret["result"], ret
1281         ret = self.run_state(
1282             "file.serialize",
1283             name=name,
1284             dataset=data2,
1285             formatter="plist",
1286             merge_if_exists=True,
1287             serializer_opts=[{"fmt": "FMT_BINARY"}],
1288         )
1289         ret = ret[next(iter(ret))]
1290         assert ret["result"], ret
1291         with salt.utils.files.fopen(name, "rb") as fp_:
1292             serialized_data = salt.serializers.plist.deserialize(fp_)
1293         assert serialized_data["foo"] == merged["foo"]
1294     @with_tempfile(create=False)
1295     def test_serializer_plist_file_open(self, name):
1296         data1 = {"foo": {"bar": "%(x)s"}}
1297         data2 = {"foo": {"abc": 123}}
1298         merged = {"foo": {"abc": 123, "bar": "%(x)s"}}
1299         ret = self.run_state(
1300             "file.serialize",
1301             name=name,
1302             dataset=data1,
1303             formatter="plist",
1304         )
1305         ret = ret[next(iter(ret))]
1306         assert ret["result"], ret
1307         ret = self.run_state(
1308             "file.serialize",
1309             name=name,
1310             dataset=data2,
1311             formatter="plist",
1312             merge_if_exists=True,
1313         )
1314         ret = ret[next(iter(ret))]
1315         assert ret["result"], ret
1316         with salt.utils.files.fopen(name, "rb") as fp_:
1317             serialized_data = salt.serializers.plist.deserialize(fp_)
1318         assert serialized_data["foo"] == merged["foo"]
1319     @with_tempdir()
1320     def test_replace_issue_18841_omit_backup(self, base_dir):
1321         test_name = "test_replace_issue_18841_omit_backup"
1322         path_in = os.path.join(
1323             RUNTIME_VARS.FILES, "file.replace", "{}.in".format(test_name)
1324         )
1325         path_test = os.path.join(base_dir, test_name)
1326         shutil.copyfile(path_in, path_test)
1327         fstats_orig = os.stat(path_test)
1328         age = 5 * 24 * 60 * 60
1329         os.utime(path_test, (fstats_orig.st_mtime - age, fstats_orig.st_atime - age))
1330         ret = self.run_state(
1331             "file.replace",
1332             name=path_test,
1333             pattern="^hello world$",
1334             repl="goodbye world",
1335             show_changes=True,
1336             flags=["IGNORECASE"],
1337         )
1338         fstats_post = os.stat(path_test)
1339         self.assertTrue(filecmp.cmp(path_in, path_test))
1340         self.assertFalse(os.path.exists(path_test + ".bak"))
1341         self.assertTrue(fstats_post.st_mtime, fstats_orig.st_mtime - age)
1342         self.assertSaltTrueReturn(ret)
1343     @with_tempfile()
1344     def test_comment(self, name):
1345         with salt.utils.files.fopen(name, "w+") as fp_:
1346             fp_.write("comment_me")
1347         ret = self.run_state("file.comment", test=True, name=name, regex="^comment")
1348         self.assertSaltNoneReturn(ret)
1349         ret = self.run_state("file.comment", name=name, regex="^comment")
1350         self.assertSaltTrueReturn(ret)
1351         with salt.utils.files.fopen(name, "r") as fp_:
1352             self.assertTrue(fp_.read().startswith("#comment"))
1353         ret = self.run_state("file.comment", name=name, regex="^comment")
1354         self.assertSaltTrueReturn(ret)
1355         with salt.utils.files.fopen(name, "r") as fp_:
1356             self.assertTrue(fp_.read().startswith("#comment"))
1357         ret = self.run_state("file.comment", test=True, name=name, regex="^comment")
1358         self.assertSaltTrueReturn(ret)
1359     @with_tempfile()
1360     def test_test_comment(self, name):
1361         with salt.utils.files.fopen(name, "w+") as fp_:
1362             fp_.write("comment_me")
1363         ret = self.run_state(
1364             "file.comment",
1365             test=True,
1366             name=name,
1367             regex=".*comment.*",
1368         )
1369         with salt.utils.files.fopen(name, "r") as fp_:
1370             self.assertNotIn("#comment", fp_.read())
1371         self.assertSaltNoneReturn(ret)
1372     @with_tempfile()
1373     def test_uncomment(self, name):
1374         with salt.utils.files.fopen(name, "w+") as fp_:
1375             fp_.write("#comment_me")
1376         ret = self.run_state("file.uncomment", name=name, regex="^comment")
1377         with salt.utils.files.fopen(name, "r") as fp_:
1378             self.assertNotIn("#comment", fp_.read())
1379         self.assertSaltTrueReturn(ret)
1380     @with_tempfile()
1381     def test_test_uncomment(self, name):
1382         with salt.utils.files.fopen(name, "w+") as fp_:
1383             fp_.write("#comment_me")
1384         ret = self.run_state("file.uncomment", test=True, name=name, regex="^comment.*")
1385         with salt.utils.files.fopen(name, "r") as fp_:
1386             self.assertIn("#comment", fp_.read())
1387         self.assertSaltNoneReturn(ret)
1388     @with_tempfile()
1389     def test_append(self, name):
1390         with salt.utils.files.fopen(name, "w+") as fp_:
1391             fp_.write("#salty!")
1392         ret = self.run_state("file.append", name=name, text="cheese")
1393         with salt.utils.files.fopen(name, "r") as fp_:
1394             self.assertIn("cheese", fp_.read())
1395         self.assertSaltTrueReturn(ret)
1396     @with_tempfile()
1397     def test_test_append(self, name):
1398         with salt.utils.files.fopen(name, "w+") as fp_:
1399             fp_.write("#salty!")
1400         ret = self.run_state("file.append", test=True, name=name, text="cheese")
1401         with salt.utils.files.fopen(name, "r") as fp_:
1402             self.assertNotIn("cheese", fp_.read())
1403         self.assertSaltNoneReturn(ret)
1404     @with_tempdir()
1405     def test_append_issue_1864_makedirs(self, base_dir):
1406         fname = "append_issue_1864_makedirs"
1407         name = os.path.join(base_dir, fname)
1408         ret = self.run_state("file.append", name=name, text="cheese", makedirs=True)
1409         self.assertSaltTrueReturn(ret)
1410         name = os.path.join(base_dir, "issue_1864", fname)
1411         ret = self.run_state("file.append", name=name, text="cheese", makedirs=True)
1412         self.assertSaltTrueReturn(ret)
1413         name = os.path.join(base_dir, "issue_1864", fname + "2")
1414         ret = self.run_state("file.append", name=name, text="cheese")
1415         self.assertSaltTrueReturn(ret)
1416         self.assertTrue(os.path.isfile(name))
1417     @with_tempdir()
1418     def test_prepend_issue_27401_makedirs(self, base_dir):
1419         fname = "prepend_issue_27401"
1420         name = os.path.join(base_dir, fname)
1421         ret = self.run_state("file.prepend", name=name, text="cheese", makedirs=True)
1422         self.assertSaltTrueReturn(ret)
1423         name = os.path.join(base_dir, "issue_27401", fname)
1424         ret = self.run_state("file.prepend", name=name, text="cheese", makedirs=True)
1425         self.assertSaltTrueReturn(ret)
1426         name = os.path.join(base_dir, "issue_27401", fname + "2")
1427         ret = self.run_state("file.prepend", name=name, text="cheese")
1428         self.assertSaltTrueReturn(ret)
1429         self.assertTrue(os.path.isfile(name))
1430     @with_tempfile()
1431     def test_touch(self, name):
1432         ret = self.run_state("file.touch", name=name)
1433         self.assertTrue(os.path.isfile(name))
1434         self.assertSaltTrueReturn(ret)
1435     @with_tempfile(create=False)
1436     def test_test_touch(self, name):
1437         ret = self.run_state("file.touch", test=True, name=name)
1438         self.assertFalse(os.path.isfile(name))
1439         self.assertSaltNoneReturn(ret)
1440     @with_tempdir()
1441     def test_touch_directory(self, base_dir):
1442         name = os.path.join(base_dir, "touch_test_dir")
1443         os.mkdir(name)
1444         ret = self.run_state("file.touch", name=name)
1445         self.assertSaltTrueReturn(ret)
1446         self.assertTrue(os.path.isdir(name))
1447     @with_tempdir()
1448     def test_issue_2227_file_append(self, base_dir):
1449         tmp_file_append = os.path.join(base_dir, "test.append")
1450         self.run_state("file.touch", name=tmp_file_append)
1451         self.run_state(
1452             "file.append", name=tmp_file_append, source="salt://testappend/firstif"
1453         )
1454         self.run_state(
1455             "file.append", name=tmp_file_append, source="salt://testappend/secondif"
1456         )
1457         try:
1458             ret = self.run_state(
1459                 "file.append", name=tmp_file_append, text="HISTTIMEFORMAT='%F %T '"
1460             )
1461             self.assertSaltTrueReturn(ret)
1462             with salt.utils.files.fopen(tmp_file_append, "r") as fp_:
1463                 contents_pre = fp_.read()
1464             ret = self.run_state(
1465                 "file.append", name=tmp_file_append, text="HISTTIMEFORMAT='%F %T '"
1466             )
1467             self.assertSaltTrueReturn(ret)
1468             with salt.utils.files.fopen(tmp_file_append, "r") as fp_:
1469                 contents_post = fp_.read()
1470             self.assertEqual(contents_pre, contents_post)
1471         except AssertionError:
1472             if os.path.exists(tmp_file_append):
1473                 shutil.copy(tmp_file_append, tmp_file_append + ".bak")
1474             raise
1475     @with_tempdir()
1476     def test_issue_2401_file_comment(self, base_dir):
1477         tmp_file = os.path.join(base_dir, "issue-2041-comment.txt")
1478         with salt.utils.files.fopen(tmp_file, "w") as fp_:
1479             fp_.write("hello\nworld\n")
1480         template_lines = [
1481             "{}:".format(tmp_file),
1482             "  file.comment:",
1483             "    - regex: ^world",
1484         ]
1485         template = "\n".join(template_lines)
1486         try:
1487             ret = self.run_function("state.template_str", [template], timeout=120)
1488             self.assertSaltTrueReturn(ret)
1489             self.assertNotInSaltComment("Pattern already commented", ret)
1490             self.assertInSaltComment("Commented lines successfully", ret)
1491             ret = self.run_function("state.template_str", [template], timeout=120)
1492             self.assertSaltTrueReturn(ret)
1493             self.assertInSaltComment("Pattern already commented", ret)
1494         except AssertionError:
1495             shutil.copy(tmp_file, tmp_file + ".bak")
1496             raise
1497     @with_tempdir()
1498     def test_issue_2379_file_append(self, base_dir):
1499         tmp_file = os.path.join(base_dir, "issue-2379-file-append.txt")
1500         with salt.utils.files.fopen(tmp_file, "w") as fp_:
1501             fp_.write(
1502                 "hello\nworld\n"  # Some junk
1503                 "#PermitRootLogin yes\n"  # Commented text
1504                 "# PermitRootLogin yes\n"  # Commented text with space
1505             )
1506         template_lines = [
1507             "{}:".format(tmp_file),
1508             "  file.append:",
1509             "    - text: PermitRootLogin yes",
1510         ]
1511         template = "\n".join(template_lines)
1512         try:
1513             ret = self.run_function("state.template_str", [template])
1514             self.assertSaltTrueReturn(ret)
1515             self.assertInSaltComment("Appended 1 lines", ret)
1516         except AssertionError:
1517             shutil.copy(tmp_file, tmp_file + ".bak")
1518             raise
1519     @skipIf(IS_WINDOWS, "Mode not available in Windows")
1520     @with_tempdir(create=False)
1521     @with_tempdir(create=False)
1522     def test_issue_2726_mode_kwarg(self, dir1, dir2):
1523         bad_mode_kwarg_testfile = os.path.join(dir1, "bad_mode_kwarg", "testfile")
1524         bad_template = [
1525             "{}:".format(bad_mode_kwarg_testfile),
1526             "  file.recurse:",
1527             "    - source: salt://testfile",
1528             "    - mode: 644",
1529         ]
1530         ret = self.run_function("state.template_str", [os.linesep.join(bad_template)])
1531         self.assertSaltFalseReturn(ret)
1532         self.assertInSaltComment(
1533             "'mode' is not allowed in 'file.recurse'. Please use "
1534             "'file_mode' and 'dir_mode'.",
1535             ret,
1536         )
1537         self.assertNotInSaltComment(
1538             "TypeError: managed() got multiple values for keyword argument 'mode'",
1539             ret,
1540         )
1541         good_mode_kwargs_testfile = os.path.join(dir2, "good_mode_kwargs", "testappend")
1542         good_template = [
1543             "{}:".format(good_mode_kwargs_testfile),
1544             "  file.recurse:",
1545             "    - source: salt://testappend",
1546             "    - dir_mode: 744",
1547             "    - file_mode: 644",
1548         ]
1549         ret = self.run_function("state.template_str", [os.linesep.join(good_template)])
1550         self.assertSaltTrueReturn(ret)
1551     @with_tempdir()
1552     def test_issue_8343_accumulated_require_in(self, base_dir):
1553         template_path = os.path.join(RUNTIME_VARS.TMP_STATE_TREE, "issue-8343.sls")
1554         testcase_filedest = os.path.join(base_dir, "issue-8343.txt")
1555         if os.path.exists(template_path):
1556             os.remove(template_path)
1557         if os.path.exists(testcase_filedest):
1558             os.remove(testcase_filedest)
1559         sls_template = [
1560             "{0}:",
1561             "  file.managed:",
1562             "    - contents: |",
1563             "                #",
1564             "",
1565             "prepend-foo-accumulator-from-pillar:",
1566             "  file.accumulated:",
1567             "    - require_in:",
1568             "      - file: prepend-foo-management",
1569             "    - filename: {0}",
1570             "    - text: |",
1571             "            foo",
1572             "",
1573             "append-foo-accumulator-from-pillar:",
1574             "  file.accumulated:",
1575             "    - require_in:",
1576             "      - file: append-foo-management",
1577             "    - filename: {0}",
1578             "    - text: |",
1579             "            bar",
1580             "",
1581             "prepend-foo-management:",
1582             "  file.blockreplace:",
1583             "    - name: {0}",
1584             '    - marker_start: "#-- start salt managed zonestart -- PLEASE, DO NOT'
1585             ' EDIT"',
1586             '    - marker_end: "#-- end salt managed zonestart --"',
1587             "    - content: ''",
1588             "    - prepend_if_not_found: True",
1589             "    - backup: '.bak'",
1590             "    - show_changes: True",
1591             "",
1592             "append-foo-management:",
1593             "  file.blockreplace:",
1594             "    - name: {0}",
1595             '    - marker_start: "#-- start salt managed zoneend -- PLEASE, DO NOT'
1596             ' EDIT"',
1597             '    - marker_end: "#-- end salt managed zoneend --"',
1598             "    - content: ''",
1599             "    - append_if_not_found: True",
1600             "    - backup: '.bak2'",
1601             "    - show_changes: True",
1602             "",
1603         ]
1604         with salt.utils.files.fopen(template_path, "w") as fp_:
1605             fp_.write(os.linesep.join(sls_template).format(testcase_filedest))
1606         ret = self.run_function("state.sls", mods="issue-8343")
1607         for name, step in ret.items():
1608             self.assertSaltTrueReturn({name: step})
1609         with salt.utils.files.fopen(testcase_filedest) as fp_:
1610             contents = fp_.read().split(os.linesep)
1611         expected = [
1612             "#-- start salt managed zonestart -- PLEASE, DO NOT EDIT",
1613             "foo",
1614             "#-- end salt managed zonestart --",
1615             "#",
1616             "#-- start salt managed zoneend -- PLEASE, DO NOT EDIT",
1617             "bar",
1618             "#-- end salt managed zoneend --",
1619             "",
1620         ]
1621         self.assertEqual(
1622             [salt.utils.stringutils.to_str(line) for line in expected], contents
1623         )
1624     @with_tempdir()
1625     def test_issue_11003_immutable_lazy_proxy_sum(self, base_dir):
1626         template_path = os.path.join(RUNTIME_VARS.TMP_STATE_TREE, "issue-11003.sls")
1627         testcase_filedest = os.path.join(base_dir, "issue-11003.txt")
1628         sls_template = [
1629             "a{0}:",
1630             "  file.absent:",
1631             "    - name: {0}",
1632             "",
1633             "{0}:",
1634             "  file.managed:",
1635             "    - contents: |",
1636             "                #",
1637             "",
1638             "test-acc1:",
1639             "  file.accumulated:",
1640             "    - require_in:",
1641             "      - file: final",
1642             "    - filename: {0}",
1643             "    - text: |",
1644             "            bar",
1645             "",
1646             "test-acc2:",
1647             "  file.accumulated:",
1648             "    - watch_in:",
1649             "      - file: final",
1650             "    - filename: {0}",
1651             "    - text: |",
1652             "            baz",
1653             "",
1654             "final:",
1655             "  file.blockreplace:",
1656             "    - name: {0}",
1657             '    - marker_start: "#-- start managed zone PLEASE, DO NOT EDIT"',
1658             '    - marker_end: "#-- end managed zone"',
1659             "    - content: ''",
1660             "    - append_if_not_found: True",
1661             "    - show_changes: True",
1662         ]
1663         with salt.utils.files.fopen(template_path, "w") as fp_:
1664             fp_.write(os.linesep.join(sls_template).format(testcase_filedest))
1665         ret = self.run_function("state.sls", mods="issue-11003", timeout=600)
1666         for name, step in ret.items():
1667             self.assertSaltTrueReturn({name: step})
1668         with salt.utils.files.fopen(testcase_filedest) as fp_:
1669             contents = fp_.read().split(os.linesep)
1670         begin = contents.index("#-- start managed zone PLEASE, DO NOT EDIT") + 1
1671         end = contents.index("#-- end managed zone")
1672         block_contents = contents[begin:end]
1673         for item in ("", "bar", "baz"):
1674             block_contents.remove(item)
1675         self.assertEqual(block_contents, [])
1676     @with_tempdir()
1677     def test_issue_8947_utf8_sls(self, base_dir):
1678         self.maxDiff = None
1679         korean_1 = "한국어 시험"
1680         korean_2 = "첫 번째 행"
1681         korean_3 = "마지막 행"
1682         test_file = os.path.join(base_dir, "{}.txt".format(korean_1))
1683         test_file_encoded = test_file
1684         template_path = os.path.join(RUNTIME_VARS.TMP_STATE_TREE, "issue-8947.sls")
1685         template = textwrap.dedent(
1686                 **locals()
1687             )
1688         )
1689         if not salt.utils.platform.is_windows():
1690             template += textwrap.dedent(
1691                     **locals()
1692                 )
1693             )
1694         with salt.utils.files.fopen(template_path, "wb") as fp_:
1695             fp_.write(salt.utils.stringutils.to_bytes(template))
1696         try:
1697             result = self.run_function("state.sls", mods="issue-8947")
1698             if not isinstance(result, dict):
1699                 raise AssertionError(
1700                     "Something went really wrong while testing this sls: {!r}".format(
1701                         result
1702                     )
1703                 )
1704             diff = "--- \n+++ \n@@ -1 +1,3 @@\n"
1705             diff += "+첫 번째 행{0} 한국어 시험{0}+마지막 행{0}".format(os.linesep)
1706             ret = {x.split("_|-")[1]: y for x, y in result.items()}
1707             self.assertEqual(
1708                 ret["some-utf8-file-create"]["comment"],
1709                 "File {} updated".format(test_file_encoded),
1710             )
1711             self.assertEqual(
1712                 ret["some-utf8-file-create"]["changes"], {"diff": "New file"}
1713             )
1714             self.assertEqual(
1715                 ret["some-utf8-file-create2"]["comment"],
1716                 "File {} updated".format(test_file_encoded),
1717             )
1718             self.assertEqual(ret["some-utf8-file-create2"]["changes"], {"diff": diff})
1719             if salt.utils.platform.is_windows():
1720                 import subprocess
1721                 import win32api
1722                 proc = subprocess.run(
1723                     ["type", win32api.GetShortPathName(test_file)],
1724                     stdout=subprocess.PIPE,
1725                     stderr=subprocess.PIPE,
1726                     check=True,
1727                     shell=True,  # nosec
1728                 )
1729                 self.assertEqual(
1730                     proc.stdout.decode("utf-8"),
1731                     os.linesep.join((korean_2, korean_1, korean_3)) + os.linesep,
1732                 )
1733             else:
1734                 self.assertEqual(
1735                     ret["some-utf8-file-content-test"]["comment"],
1736                     'Command "cat "{}"" run'.format(test_file_encoded),
1737                 )
1738                 self.assertEqual(
1739                     ret["some-utf8-file-content-test"]["changes"]["stdout"],
1740                     "\n".join((korean_2, korean_1, korean_3)),
1741                 )
1742         finally:
1743             try:
1744                 os.remove(template_path)
1745             except OSError:
1746                 pass
1747     @pytest.mark.skip_if_not_root
1748     @skipIf(not HAS_PWD, "pwd not available. Skipping test")
1749     @skipIf(not HAS_GRP, "grp not available. Skipping test")
1750     @with_system_user_and_group(
1751         TEST_SYSTEM_USER, TEST_SYSTEM_GROUP, on_existing="delete", delete=True
1752     )
1753     @with_tempdir()
1754     @skipIf(salt.utils.platform.is_freebsd(), "Test is failing on FreeBSD")
1755     def test_issue_12209_follow_symlinks(self, tempdir, user, group):
1756         onedir = os.path.join(tempdir, "one")
1757         twodir = os.path.join(tempdir, "two")
1758         os.mkdir(onedir)
1759         os.symlink(onedir, twodir)
1760         ret = self.run_state(
1761             "file.directory",
1762             name=tempdir,
1763             follow_symlinks=True,
1764             user=user,
1765             group=group,
1766             recurse=["user", "group"],
1767         )
1768         self.assertSaltTrueReturn(ret)
1769         onestats = os.stat(onedir)
1770         twostats = os.lstat(twodir)
1771         self.assertEqual(pwd.getpwuid(onestats.st_uid).pw_name, user)
1772         self.assertEqual(pwd.getpwuid(twostats.st_uid).pw_name, "root")
1773         self.assertEqual(grp.getgrgid(onestats.st_gid).gr_name, group)
1774         if salt.utils.path.which("id"):
1775             root_group = self.run_function("user.primary_group", ["root"])
1776             self.assertEqual(grp.getgrgid(twostats.st_gid).gr_name, root_group)
1777     @pytest.mark.skip_if_not_root
1778     @skipIf(not HAS_PWD, "pwd not available. Skipping test")
1779     @skipIf(not HAS_GRP, "grp not available. Skipping test")
1780     @with_system_user_and_group(
1781         TEST_SYSTEM_USER, TEST_SYSTEM_GROUP, on_existing="delete", delete=True
1782     )
1783     @with_tempdir()
1784     def test_issue_12209_no_follow_symlinks(self, tempdir, user, group):
1785         onedir = os.path.join(tempdir, "one")
1786         twodir = os.path.join(tempdir, "two")
1787         os.mkdir(onedir)
1788         os.symlink(onedir, twodir)
1789         ret = self.run_state(
1790             "file.directory",
1791             name=tempdir,
1792             follow_symlinks=False,
1793             user=user,
1794             group=group,
1795             recurse=["user", "group"],
1796         )
1797         self.assertSaltTrueReturn(ret)
1798         onestats = os.stat(onedir)
1799         twostats = os.lstat(twodir)
1800         self.assertEqual(pwd.getpwuid(onestats.st_uid).pw_name, user)
1801         self.assertEqual(pwd.getpwuid(twostats.st_uid).pw_name, user)
1802         self.assertEqual(grp.getgrgid(onestats.st_gid).gr_name, group)
1803         self.assertEqual(grp.getgrgid(twostats.st_gid).gr_name, group)
1804     @with_tempfile(create=False)
1805     @with_tempfile()
1806     def test_template_local_file(self, source, dest):
1807         with salt.utils.files.fopen(source, "w") as fp_:
1808             fp_.write("{{ foo }}\n")
1809         for prefix in ("file://", ""):
1810             ret = self.run_state(
1811                 "file.managed",
1812                 name=dest,
1813                 source=prefix + source,
1814                 template="jinja",
1815                 context={"foo": "Hello world!"},
1816             )
1817             self.assertSaltTrueReturn(ret)
1818     @with_tempfile()
1819     def test_template_local_file_noclobber(self, source):
1820         with salt.utils.files.fopen(source, "w") as fp_:
1821             fp_.write("{{ foo }}\n")
1822         ret = self.run_state(
1823             "file.managed",
1824             name=source,
1825             source=source,
1826             template="jinja",
1827             context={"foo": "Hello world!"},
1828         )
1829         self.assertSaltFalseReturn(ret)
1830         self.assertIn(
1831             "Source file cannot be the same as destination",
1832             ret[next(iter(ret))]["comment"],
1833         )
1834     @with_tempfile(create=False)
1835     @with_tempfile(create=False)
1836     def test_issue_25250_force_copy_deletes(self, source, dest):
1837         shutil.copyfile(os.path.join(RUNTIME_VARS.FILES, "hosts"), source)
1838         shutil.copyfile(os.path.join(RUNTIME_VARS.FILES, "file/base/cheese"), dest)
1839         self.run_state("file.copy", name=dest, source=source, force=True)
1840         self.assertTrue(os.path.exists(dest))
1841         self.assertTrue(filecmp.cmp(source, dest))
1842         os.remove(source)
1843         os.remove(dest)
1844     @pytest.mark.destructive_test
1845     @pytest.mark.skip_if_not_root
1846     @skipIf(IS_WINDOWS, "Windows does not report any file modes. Skipping.")
1847     @with_tempfile()
1848     def test_file_copy_make_dirs(self, source):
1849         shutil.copyfile(os.path.join(RUNTIME_VARS.FILES, "hosts"), source)
1850         dest = self.tmp_dir / "dir1" / "dir2" / "copied_file.txt"
1851         self.addCleanup(salt.utils.files.rm_rf, str(dest.parent.parent))
1852         user = "salt"
1853         mode = "0644"
1854         ret = self.run_function("user.add", [user])
1855         self.assertTrue(ret, "Failed to add user. Are you running as sudo?")
1856         ret = self.run_state(
1857             "file.copy",
1858             name=str(dest),
1859             source=source,
1860             user=user,
1861             makedirs=True,
1862             mode=mode,
1863         )
1864         self.assertSaltTrueReturn(ret)
1865         file_checks = [str(dest), str(dest.parent), str(dest.parent.parent)]
1866         for check in file_checks:
1867             user_check = self.run_function("file.get_user", [check])
1868             mode_check = self.run_function("file.get_mode", [check])
1869             self.assertEqual(user_check, user)
1870             self.assertEqual(salt.utils.files.normalize_mode(mode_check), mode)
1871     @pytest.mark.skip_if_not_root
1872     @skipIf(not HAS_PWD, "pwd not available. Skipping test")
1873     @skipIf(not HAS_GRP, "grp not available. Skipping test")
1874     @with_system_user_and_group(
1875         TEST_SYSTEM_USER, TEST_SYSTEM_GROUP, on_existing="delete", delete=True
1876     )
1877     def test_owner_after_setuid(self, user, group):
1878         desired_file = self.tmp_dir / "file_with_setuid"
1879         self.addCleanup(salt.utils.files.safe_rm, str(desired_file))
1880         desired = {
1881             "file": str(desired_file),
1882             "user": user,
1883             "group": group,
1884             "mode": "4750",
1885         }
1886         ret = self.run_state(
1887             "file.managed",
1888             name=desired["file"],
1889             user=desired["user"],
1890             group=desired["group"],
1891             mode=desired["mode"],
1892         )
1893         file_stat = desired_file.stat()
1894         result = {
1895             "user": pwd.getpwuid(file_stat.st_uid).pw_name,
1896             "group": grp.getgrgid(file_stat.st_gid).gr_name,
1897             "mode": oct(stat.S_IMODE(file_stat.st_mode)),
1898         }
1899         self.assertSaltTrueReturn(ret)
1900         self.assertEqual(desired["user"], result["user"])
1901         self.assertEqual(desired["group"], result["group"])
1902         self.assertEqual(desired["mode"], result["mode"].lstrip("0Oo"))
1903     def test_binary_contents(self):
1904         name = self.tmp_dir / "1px.gif"
1905         self.addCleanup(salt.utils.files.safe_rm, str(name))
1906         ret = self.run_state("file.managed", name=str(name), contents=BINARY_FILE)
1907         self.assertSaltTrueReturn(ret)
1908     def test_binary_contents_twice(self):
1909         name = self.tmp_dir / "1px.gif"
1910         self.addCleanup(salt.utils.files.safe_rm, str(name))
1911         ret = self.run_state("file.managed", name=str(name), contents=BINARY_FILE)
1912         self.assertSaltTrueReturn(ret)
1913         ret = self.run_state("file.managed", name=str(name), contents=BINARY_FILE)
1914         self.assertSaltTrueReturn(ret)
1915     @pytest.mark.skip_if_not_root
1916     @skipIf(not HAS_PWD, "pwd not available. Skipping test")
1917     @skipIf(not HAS_GRP, "grp not available. Skipping test")
1918     @with_system_user_and_group(
1919         TEST_SYSTEM_USER, TEST_SYSTEM_GROUP, on_existing="delete", delete=True
1920     )
1921     @with_tempdir()
1922     def test_issue_48336_file_managed_mode_setuid(self, tempdir, user, group):
1923         tempfile = os.path.join(tempdir, "temp_file_issue_48336")
1924         ret = self.run_state(
1925             "file.managed",
1926             name=tempfile,
1927             user=user,
1928             group=group,
1929             mode="4750",
1930         )
1931         self.assertSaltTrueReturn(ret)
1932         temp_file_stats = os.stat(tempfile)
1933         temp_file_mode = str(oct(stat.S_IMODE(temp_file_stats.st_mode)))
1934         temp_file_mode = salt.utils.files.normalize_mode(temp_file_mode)
1935         self.assertEqual(temp_file_mode, "4750")
1936         self.assertEqual(pwd.getpwuid(temp_file_stats.st_uid).pw_name, user)
1937         self.assertEqual(grp.getgrgid(temp_file_stats.st_gid).gr_name, group)
1938     @with_tempdir()
1939     def test_issue_48557(self, tempdir):
1940         tempfile = os.path.join(tempdir, "temp_file_issue_48557")
1941         with salt.utils.files.fopen(tempfile, "wb") as fp:
1942             fp.write(os.linesep.join(["test1", "test2", "test3", ""]).encode("utf-8"))
1943         ret = self.run_state(
1944             "file.line", name=tempfile, after="test2", mode="insert", content="test4"
1945         )
1946         self.assertSaltTrueReturn(ret)
1947         with salt.utils.files.fopen(tempfile, "rb") as fp:
1948             content = fp.read()
1949         self.assertEqual(
1950             content,
1951             os.linesep.join(["test1", "test2", "test4", "test3", ""]).encode("utf-8"),
1952         )
1953     def test_managed_file_issue_51208(self):
1954         name = self.tmp_dir / "issue_51208.txt"
1955         self.addCleanup(salt.utils.files.safe_rm, str(name))
1956         ret = self.run_state(
1957             "file.managed", name=str(name), source="salt://issue-51208/vimrc.stub"
1958         )
1959         src = pathlib.Path(RUNTIME_VARS.BASE_FILES) / "issue-51208" / "vimrc.stub"
1960         master_data = src.read_text()
1961         minion_data = name.read_text()
1962         self.assertEqual(master_data, minion_data)
1963         self.assertSaltTrueReturn(ret)
1964     @with_tempfile()
1965     def test_keyvalue(self, name):
1966         content = dedent(
1967         )
1968         with salt.utils.files.fopen(name, "w+") as fp_:
1969             fp_.write(content)
1970         ret = self.run_state(
1971             "file.keyvalue",
1972             name=name,
1973             key="permitrootlogin",
1974             value="no",
1975             separator=" ",
1976             uncomment=" #",
1977             key_ignore_case=True,
1978         )
1979         with salt.utils.files.fopen(name, "r") as fp_:
1980             file_contents = fp_.read()
1981             self.assertNotIn("#PermitRootLogin", file_contents)
1982             self.assertNotIn("prohibit-password", file_contents)
1983             self.assertIn("PermitRootLogin no", file_contents)
1984         self.assertSaltTrueReturn(ret)
1985     @with_tempdir()
1986     @pytest.mark.slow_test
1987     def test_issue_1896_file_append_source(self, base_dir):
1988         testfile = os.path.join(base_dir, "test.append")
1989         ret = self.run_state("file.touch", name=testfile)
1990         self.assertSaltTrueReturn(ret)
1991         ret = self.run_state(
1992             "file.append", name=testfile, source="salt://testappend/firstif"
1993         )
1994         self.assertSaltTrueReturn(ret)
1995         ret = self.run_state(
1996             "file.append", name=testfile, source="salt://testappend/secondif"
1997 <a name="1"></a>        )
1998         self.assertSaltTrueReturn(ret)
1999         <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>with salt.utils.files.fopen(testfile, "r") as fp_:
2000             testfile_contents = salt.utils.stringutils.to_unicode(fp_.read(</b></font>))
2001         contents = textwrap.dedent(
2002         )
2003         if salt.utils.platform.is_windows():
2004             new_contents = contents.splitlines()
2005             contents = os.linesep.join(new_contents)
2006             contents += os.linesep
2007         self.assertMultiLineEqual(contents, testfile_contents)
2008         ret = self.run_state(
2009             "file.append", name=testfile, source="salt://testappend/secondif"
2010         )
2011         self.assertSaltTrueReturn(ret)
2012         ret = self.run_state(
2013             "file.append", name=testfile, source="salt://testappend/firstif"
2014 <a name="0"></a>        )
2015         self.assertSaltTrueReturn(ret)
2016         <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>with salt.utils.files.fopen(testfile, "r") as fp_:
2017             testfile_contents = salt.utils.stringutils.to_unicode(fp_.read(</b></font>))
2018         self.assertMultiLineEqual(contents, testfile_contents)
2019 @pytest.mark.windows_whitelisted
2020 class BlockreplaceTest(ModuleCase, SaltReturnAssertsMixin):
2021     marker_start = "# start"
2022     marker_end = "# end"
2023     content = dedent(
2024     )
2025     without_block = dedent(
2026     )
2027     with_non_matching_block = dedent(
2028     )
2029     with_non_matching_block_and_marker_end_not_after_newline = dedent(
2030     )
2031     with_matching_block = dedent(
2032     )
2033     with_matching_block_and_extra_newline = dedent(
2034     )
2035     with_matching_block_and_marker_end_not_after_newline = dedent(
2036     )
2037     content_explicit_posix_newlines = "Line 1 of block\nLine 2 of block\n"
2038     content_explicit_windows_newlines = "Line 1 of block\r\nLine 2 of block\r\n"
2039     without_block_explicit_posix_newlines = "Hello world!\n\n# comment here\n"
2040     without_block_explicit_windows_newlines = "Hello world!\r\n\r\n# comment here\r\n"
2041     with_block_prepended_explicit_posix_newlines = (
2042         "# start\n"
2043         "Line 1 of block\n"
2044         "Line 2 of block\n"
2045         "# end\n"
2046         "Hello world!\n\n"
2047         "# comment here\n"
2048     )
2049     with_block_prepended_explicit_windows_newlines = (
2050         "# start\r\n"
2051         "Line 1 of block\r\n"
2052         "Line 2 of block\r\n"
2053         "# end\r\n"
2054         "Hello world!\r\n\r\n"
2055         "# comment here\r\n"
2056     )
2057     with_block_appended_explicit_posix_newlines = (
2058         "Hello world!\n\n"
2059         "# comment here\n"
2060         "# start\n"
2061         "Line 1 of block\n"
2062         "Line 2 of block\n"
2063         "# end\n"
2064     )
2065     with_block_appended_explicit_windows_newlines = (
2066         "Hello world!\r\n\r\n"
2067         "# comment here\r\n"
2068         "# start\r\n"
2069         "Line 1 of block\r\n"
2070         "Line 2 of block\r\n"
2071         "# end\r\n"
2072     )
2073     @staticmethod
2074     def _write(dest, content):
2075         with salt.utils.files.fopen(dest, "wb") as fp_:
2076             fp_.write(salt.utils.stringutils.to_bytes(content))
2077     @staticmethod
2078     def _read(src):
2079         with salt.utils.files.fopen(src, "rb") as fp_:
2080             return salt.utils.stringutils.to_unicode(fp_.read())
2081     @with_tempfile()
2082     def test_prepend(self, name):
2083         expected = (
2084             self.marker_start
2085             + os.linesep
2086             + self.content
2087             + self.marker_end
2088             + os.linesep
2089             + self.without_block
2090         )
2091         self._write(name, self.without_block)
2092         ret = self.run_state(
2093             "file.blockreplace",
2094             name=name,
2095             content=self.content,
2096             marker_start=self.marker_start,
2097             marker_end=self.marker_end,
2098             prepend_if_not_found=True,
2099         )
2100         self.assertSaltTrueReturn(ret)
2101         self.assertTrue(ret[next(iter(ret))]["changes"])
2102         self.assertEqual(self._read(name), expected)
2103         ret = self.run_state(
2104             "file.blockreplace",
2105             name=name,
2106             content=self.content,
2107             marker_start=self.marker_start,
2108             marker_end=self.marker_end,
2109             prepend_if_not_found=True,
2110         )
2111         self.assertSaltTrueReturn(ret)
2112         self.assertFalse(ret[next(iter(ret))]["changes"])
2113         self.assertEqual(self._read(name), expected)
2114         self._write(name, self.without_block)
2115         ret = self.run_state(
2116             "file.blockreplace",
2117             name=name,
2118             content=self.content.rstrip("\r\n"),
2119             marker_start=self.marker_start,
2120             marker_end=self.marker_end,
2121             prepend_if_not_found=True,
2122         )
2123         self.assertSaltTrueReturn(ret)
2124         self.assertTrue(ret[next(iter(ret))]["changes"])
2125         self.assertEqual(self._read(name), expected)
2126         ret = self.run_state(
2127             "file.blockreplace",
2128             name=name,
2129             content=self.content.rstrip("\r\n"),
2130             marker_start=self.marker_start,
2131             marker_end=self.marker_end,
2132             prepend_if_not_found=True,
2133         )
2134         self.assertSaltTrueReturn(ret)
2135         self.assertFalse(ret[next(iter(ret))]["changes"])
2136         self.assertEqual(self._read(name), expected)
2137     @with_tempfile()
2138     def test_prepend_append_newline(self, name):
2139         expected = (
2140             self.marker_start
2141             + os.linesep
2142             + self.content
2143             + os.linesep
2144             + self.marker_end
2145             + os.linesep
2146             + self.without_block
2147         )
2148         self._write(name, self.without_block)
2149         ret = self.run_state(
2150             "file.blockreplace",
2151             name=name,
2152             content=self.content,
2153             marker_start=self.marker_start,
2154             marker_end=self.marker_end,
2155             prepend_if_not_found=True,
2156             append_newline=True,
2157         )
2158         self.assertSaltTrueReturn(ret)
2159         self.assertTrue(ret[next(iter(ret))]["changes"])
2160         self.assertEqual(self._read(name), expected)
2161         ret = self.run_state(
2162             "file.blockreplace",
2163             name=name,
2164             content=self.content,
2165             marker_start=self.marker_start,
2166             marker_end=self.marker_end,
2167             prepend_if_not_found=True,
2168             append_newline=True,
2169         )
2170         self.assertSaltTrueReturn(ret)
2171         self.assertFalse(ret[next(iter(ret))]["changes"])
2172         self.assertEqual(self._read(name), expected)
2173         expected = (
2174             self.marker_start
2175             + os.linesep
2176             + self.content
2177             + self.marker_end
2178             + os.linesep
2179             + self.without_block
2180         )
2181         self._write(name, self.without_block)
2182         ret = self.run_state(
2183             "file.blockreplace",
2184             name=name,
2185             content=self.content.rstrip("\r\n"),
2186             marker_start=self.marker_start,
2187             marker_end=self.marker_end,
2188             prepend_if_not_found=True,
2189             append_newline=True,
2190         )
2191         self.assertSaltTrueReturn(ret)
2192         self.assertTrue(ret[next(iter(ret))]["changes"])
2193         self.assertEqual(self._read(name), expected)
2194         ret = self.run_state(
2195             "file.blockreplace",
2196             name=name,
2197             content=self.content.rstrip("\r\n"),
2198             marker_start=self.marker_start,
2199             marker_end=self.marker_end,
2200             prepend_if_not_found=True,
2201             append_newline=True,
2202         )
2203         self.assertSaltTrueReturn(ret)
2204         self.assertFalse(ret[next(iter(ret))]["changes"])
2205         self.assertEqual(self._read(name), expected)
2206     @with_tempfile()
2207     def test_prepend_no_append_newline(self, name):
2208         expected = (
2209             self.marker_start
2210             + os.linesep
2211             + self.content
2212             + self.marker_end
2213             + os.linesep
2214             + self.without_block
2215         )
2216         self._write(name, self.without_block)
2217         ret = self.run_state(
2218             "file.blockreplace",
2219             name=name,
2220             content=self.content,
2221             marker_start=self.marker_start,
2222             marker_end=self.marker_end,
2223             prepend_if_not_found=True,
2224             append_newline=False,
2225         )
2226         self.assertSaltTrueReturn(ret)
2227         self.assertTrue(ret[next(iter(ret))]["changes"])
2228         self.assertEqual(self._read(name), expected)
2229         ret = self.run_state(
2230             "file.blockreplace",
2231             name=name,
2232             content=self.content,
2233             marker_start=self.marker_start,
2234             marker_end=self.marker_end,
2235             prepend_if_not_found=True,
2236             append_newline=False,
2237         )
2238         self.assertSaltTrueReturn(ret)
2239         self.assertFalse(ret[next(iter(ret))]["changes"])
2240         self.assertEqual(self._read(name), expected)
2241         expected = (
2242             self.marker_start
2243             + os.linesep
2244             + self.content.rstrip("\r\n")
2245             + self.marker_end
2246             + os.linesep
2247             + self.without_block
2248         )
2249         self._write(name, self.without_block)
2250         ret = self.run_state(
2251             "file.blockreplace",
2252             name=name,
2253             content=self.content.rstrip("\r\n"),
2254             marker_start=self.marker_start,
2255             marker_end=self.marker_end,
2256             prepend_if_not_found=True,
2257             append_newline=False,
2258         )
2259         self.assertSaltTrueReturn(ret)
2260         self.assertTrue(ret[next(iter(ret))]["changes"])
2261         self.assertEqual(self._read(name), expected)
2262         ret = self.run_state(
2263             "file.blockreplace",
2264             name=name,
2265             content=self.content.rstrip("\r\n"),
2266             marker_start=self.marker_start,
2267             marker_end=self.marker_end,
2268             prepend_if_not_found=True,
2269             append_newline=False,
2270         )
2271         self.assertSaltTrueReturn(ret)
2272         self.assertFalse(ret[next(iter(ret))]["changes"])
2273         self.assertEqual(self._read(name), expected)
2274     @with_tempfile()
2275     def test_append(self, name):
2276         expected = (
2277             self.without_block
2278             + self.marker_start
2279             + os.linesep
2280             + self.content
2281             + self.marker_end
2282             + os.linesep
2283         )
2284         self._write(name, self.without_block)
2285         ret = self.run_state(
2286             "file.blockreplace",
2287             name=name,
2288             content=self.content,
2289             marker_start=self.marker_start,
2290             marker_end=self.marker_end,
2291             append_if_not_found=True,
2292         )
2293         self.assertSaltTrueReturn(ret)
2294         self.assertTrue(ret[next(iter(ret))]["changes"])
2295         self.assertEqual(self._read(name), expected)
2296         ret = self.run_state(
2297             "file.blockreplace",
2298             name=name,
2299             content=self.content,
2300             marker_start=self.marker_start,
2301             marker_end=self.marker_end,
2302             append_if_not_found=True,
2303         )
2304         self.assertSaltTrueReturn(ret)
2305         self.assertFalse(ret[next(iter(ret))]["changes"])
2306         self.assertEqual(self._read(name), expected)
2307         self._write(name, self.without_block)
2308         ret = self.run_state(
2309             "file.blockreplace",
2310             name=name,
2311             content=self.content.rstrip("\r\n"),
2312             marker_start=self.marker_start,
2313             marker_end=self.marker_end,
2314             append_if_not_found=True,
2315         )
2316         self.assertSaltTrueReturn(ret)
2317         self.assertTrue(ret[next(iter(ret))]["changes"])
2318         self.assertEqual(self._read(name), expected)
2319         ret = self.run_state(
2320             "file.blockreplace",
2321             name=name,
2322             content=self.content.rstrip("\r\n"),
2323             marker_start=self.marker_start,
2324             marker_end=self.marker_end,
2325             append_if_not_found=True,
2326         )
2327         self.assertSaltTrueReturn(ret)
2328         self.assertFalse(ret[next(iter(ret))]["changes"])
2329         self.assertEqual(self._read(name), expected)
2330     @with_tempfile()
2331     def test_append_append_newline(self, name):
2332         expected = (
2333             self.without_block
2334             + self.marker_start
2335             + os.linesep
2336             + self.content
2337             + os.linesep
2338             + self.marker_end
2339             + os.linesep
2340         )
2341         self._write(name, self.without_block)
2342         ret = self.run_state(
2343             "file.blockreplace",
2344             name=name,
2345             content=self.content,
2346             marker_start=self.marker_start,
2347             marker_end=self.marker_end,
2348             append_if_not_found=True,
2349             append_newline=True,
2350         )
2351         self.assertSaltTrueReturn(ret)
2352         self.assertTrue(ret[next(iter(ret))]["changes"])
2353         self.assertEqual(self._read(name), expected)
2354         ret = self.run_state(
2355             "file.blockreplace",
2356             name=name,
2357             content=self.content,
2358             marker_start=self.marker_start,
2359             marker_end=self.marker_end,
2360             append_if_not_found=True,
2361             append_newline=True,
2362         )
2363         self.assertSaltTrueReturn(ret)
2364         self.assertFalse(ret[next(iter(ret))]["changes"])
2365         self.assertEqual(self._read(name), expected)
2366         expected = (
2367             self.without_block
2368             + self.marker_start
2369             + os.linesep
2370             + self.content
2371             + self.marker_end
2372             + os.linesep
2373         )
2374         self._write(name, self.without_block)
2375         ret = self.run_state(
2376             "file.blockreplace",
2377             name=name,
2378             content=self.content.rstrip("\r\n"),
2379             marker_start=self.marker_start,
2380             marker_end=self.marker_end,
2381             append_if_not_found=True,
2382             append_newline=True,
2383         )
2384         self.assertSaltTrueReturn(ret)
2385         self.assertTrue(ret[next(iter(ret))]["changes"])
2386         self.assertEqual(self._read(name), expected)
2387         ret = self.run_state(
2388             "file.blockreplace",
2389             name=name,
2390             content=self.content.rstrip("\r\n"),
2391             marker_start=self.marker_start,
2392             marker_end=self.marker_end,
2393             append_if_not_found=True,
2394             append_newline=True,
2395         )
2396         self.assertSaltTrueReturn(ret)
2397         self.assertFalse(ret[next(iter(ret))]["changes"])
2398         self.assertEqual(self._read(name), expected)
2399     @with_tempfile()
2400     def test_append_no_append_newline(self, name):
2401         expected = (
2402             self.without_block
2403             + self.marker_start
2404             + os.linesep
2405             + self.content
2406             + self.marker_end
2407             + os.linesep
2408         )
2409         self._write(name, self.without_block)
2410         ret = self.run_state(
2411             "file.blockreplace",
2412             name=name,
2413             content=self.content,
2414             marker_start=self.marker_start,
2415             marker_end=self.marker_end,
2416             append_if_not_found=True,
2417             append_newline=False,
2418         )
2419         self.assertSaltTrueReturn(ret)
2420         self.assertTrue(ret[next(iter(ret))]["changes"])
2421         self.assertEqual(self._read(name), expected)
2422         ret = self.run_state(
2423             "file.blockreplace",
2424             name=name,
2425             content=self.content,
2426             marker_start=self.marker_start,
2427             marker_end=self.marker_end,
2428             append_if_not_found=True,
2429             append_newline=False,
2430         )
2431         self.assertSaltTrueReturn(ret)
2432         self.assertFalse(ret[next(iter(ret))]["changes"])
2433         self.assertEqual(self._read(name), expected)
2434         expected = (
2435             self.without_block
2436             + self.marker_start
2437             + os.linesep
2438             + self.content.rstrip("\r\n")
2439             + self.marker_end
2440             + os.linesep
2441         )
2442         self._write(name, self.without_block)
2443         ret = self.run_state(
2444             "file.blockreplace",
2445             name=name,
2446             content=self.content.rstrip("\r\n"),
2447             marker_start=self.marker_start,
2448             marker_end=self.marker_end,
2449             append_if_not_found=True,
2450             append_newline=False,
2451         )
2452         self.assertSaltTrueReturn(ret)
2453         self.assertTrue(ret[next(iter(ret))]["changes"])
2454         self.assertEqual(self._read(name), expected)
2455         ret = self.run_state(
2456             "file.blockreplace",
2457             name=name,
2458             content=self.content.rstrip("\r\n"),
2459             marker_start=self.marker_start,
2460             marker_end=self.marker_end,
2461             append_if_not_found=True,
2462             append_newline=False,
2463         )
2464         self.assertSaltTrueReturn(ret)
2465         self.assertFalse(ret[next(iter(ret))]["changes"])
2466         self.assertEqual(self._read(name), expected)
2467     @with_tempfile()
2468     def test_prepend_auto_line_separator(self, name):
2469         self._write(name, self.without_block_explicit_windows_newlines)
2470         ret = self.run_state(
2471             "file.blockreplace",
2472             name=name,
2473             content=self.content_explicit_posix_newlines,
2474             marker_start=self.marker_start,
2475             marker_end=self.marker_end,
2476             prepend_if_not_found=True,
2477         )
2478         self.assertSaltTrueReturn(ret)
2479         self.assertTrue(ret[next(iter(ret))]["changes"])
2480         self.assertEqual(
2481             self._read(name), self.with_block_prepended_explicit_windows_newlines
2482         )
2483         ret = self.run_state(
2484             "file.blockreplace",
2485             name=name,
2486             content=self.content_explicit_posix_newlines,
2487             marker_start=self.marker_start,
2488             marker_end=self.marker_end,
2489             prepend_if_not_found=True,
2490         )
2491         self.assertSaltTrueReturn(ret)
2492         self.assertFalse(ret[next(iter(ret))]["changes"])
2493         self.assertEqual(
2494             self._read(name), self.with_block_prepended_explicit_windows_newlines
2495         )
2496         self._write(name, self.without_block_explicit_posix_newlines)
2497         ret = self.run_state(
2498             "file.blockreplace",
2499             name=name,
2500             content=self.content_explicit_windows_newlines,
2501             marker_start=self.marker_start,
2502             marker_end=self.marker_end,
2503             prepend_if_not_found=True,
2504         )
2505         self.assertSaltTrueReturn(ret)
2506         self.assertTrue(ret[next(iter(ret))]["changes"])
2507         self.assertEqual(
2508             self._read(name), self.with_block_prepended_explicit_posix_newlines
2509         )
2510         ret = self.run_state(
2511             "file.blockreplace",
2512             name=name,
2513             content=self.content_explicit_windows_newlines,
2514             marker_start=self.marker_start,
2515             marker_end=self.marker_end,
2516             prepend_if_not_found=True,
2517         )
2518         self.assertSaltTrueReturn(ret)
2519         self.assertFalse(ret[next(iter(ret))]["changes"])
2520         self.assertEqual(
2521             self._read(name), self.with_block_prepended_explicit_posix_newlines
2522         )
2523     @with_tempfile()
2524     def test_append_auto_line_separator(self, name):
2525         self._write(name, self.without_block_explicit_windows_newlines)
2526         ret = self.run_state(
2527             "file.blockreplace",
2528             name=name,
2529             content=self.content_explicit_posix_newlines,
2530             marker_start=self.marker_start,
2531             marker_end=self.marker_end,
2532             append_if_not_found=True,
2533         )
2534         self.assertSaltTrueReturn(ret)
2535         self.assertTrue(ret[next(iter(ret))]["changes"])
2536         self.assertEqual(
2537             self._read(name), self.with_block_appended_explicit_windows_newlines
2538         )
2539         ret = self.run_state(
2540             "file.blockreplace",
2541             name=name,
2542             content=self.content_explicit_posix_newlines,
2543             marker_start=self.marker_start,
2544             marker_end=self.marker_end,
2545             append_if_not_found=True,
2546         )
2547         self.assertSaltTrueReturn(ret)
2548         self.assertFalse(ret[next(iter(ret))]["changes"])
2549         self.assertEqual(
2550             self._read(name), self.with_block_appended_explicit_windows_newlines
2551         )
2552         self._write(name, self.without_block_explicit_posix_newlines)
2553         ret = self.run_state(
2554             "file.blockreplace",
2555             name=name,
2556             content=self.content_explicit_windows_newlines,
2557             marker_start=self.marker_start,
2558             marker_end=self.marker_end,
2559             append_if_not_found=True,
2560         )
2561         self.assertSaltTrueReturn(ret)
2562         self.assertTrue(ret[next(iter(ret))]["changes"])
2563         self.assertEqual(
2564             self._read(name), self.with_block_appended_explicit_posix_newlines
2565         )
2566         ret = self.run_state(
2567             "file.blockreplace",
2568             name=name,
2569             content=self.content_explicit_windows_newlines,
2570             marker_start=self.marker_start,
2571             marker_end=self.marker_end,
2572             append_if_not_found=True,
2573         )
2574         self.assertSaltTrueReturn(ret)
2575         self.assertFalse(ret[next(iter(ret))]["changes"])
2576         self.assertEqual(
2577             self._read(name), self.with_block_appended_explicit_posix_newlines
2578         )
2579     @with_tempfile()
2580     def test_non_matching_block(self, name):
2581         self._write(name, self.with_non_matching_block)
2582         ret = self.run_state(
2583             "file.blockreplace",
2584             name=name,
2585             content=self.content,
2586             marker_start=self.marker_start,
2587             marker_end=self.marker_end,
2588         )
2589         self.assertSaltTrueReturn(ret)
2590         self.assertTrue(ret[next(iter(ret))]["changes"])
2591         self.assertEqual(self._read(name), self.with_matching_block)
2592         ret = self.run_state(
2593             "file.blockreplace",
2594             name=name,
2595             content=self.content,
2596             marker_start=self.marker_start,
2597             marker_end=self.marker_end,
2598         )
2599         self.assertSaltTrueReturn(ret)
2600         self.assertFalse(ret[next(iter(ret))]["changes"])
2601         self.assertEqual(self._read(name), self.with_matching_block)
2602         self._write(name, self.with_non_matching_block)
2603         ret = self.run_state(
2604             "file.blockreplace",
2605             name=name,
2606             content=self.content.rstrip("\r\n"),
2607             marker_start=self.marker_start,
2608             marker_end=self.marker_end,
2609         )
2610         self.assertSaltTrueReturn(ret)
2611         self.assertTrue(ret[next(iter(ret))]["changes"])
2612         self.assertEqual(self._read(name), self.with_matching_block)
2613         ret = self.run_state(
2614             "file.blockreplace",
2615             name=name,
2616             content=self.content.rstrip("\r\n"),
2617             marker_start=self.marker_start,
2618             marker_end=self.marker_end,
2619         )
2620         self.assertSaltTrueReturn(ret)
2621         self.assertFalse(ret[next(iter(ret))]["changes"])
2622         self.assertEqual(self._read(name), self.with_matching_block)
2623     @with_tempfile()
2624     def test_non_matching_block_append_newline(self, name):
2625         self._write(name, self.with_non_matching_block)
2626         ret = self.run_state(
2627             "file.blockreplace",
2628             name=name,
2629             content=self.content,
2630             marker_start=self.marker_start,
2631             marker_end=self.marker_end,
2632             append_newline=True,
2633         )
2634         self.assertSaltTrueReturn(ret)
2635         self.assertTrue(ret[next(iter(ret))]["changes"])
2636         self.assertEqual(self._read(name), self.with_matching_block_and_extra_newline)
2637         ret = self.run_state(
2638             "file.blockreplace",
2639             name=name,
2640             content=self.content,
2641             marker_start=self.marker_start,
2642             marker_end=self.marker_end,
2643             append_newline=True,
2644         )
2645         self.assertSaltTrueReturn(ret)
2646         self.assertFalse(ret[next(iter(ret))]["changes"])
2647         self.assertEqual(self._read(name), self.with_matching_block_and_extra_newline)
2648         self._write(name, self.with_non_matching_block)
2649         ret = self.run_state(
2650             "file.blockreplace",
2651             name=name,
2652             content=self.content.rstrip("\r\n"),
2653             marker_start=self.marker_start,
2654             marker_end=self.marker_end,
2655             append_newline=True,
2656         )
2657         self.assertSaltTrueReturn(ret)
2658         self.assertTrue(ret[next(iter(ret))]["changes"])
2659         self.assertEqual(self._read(name), self.with_matching_block)
2660         ret = self.run_state(
2661             "file.blockreplace",
2662             name=name,
2663             content=self.content.rstrip("\r\n"),
2664             marker_start=self.marker_start,
2665             marker_end=self.marker_end,
2666             append_newline=True,
2667         )
2668         self.assertSaltTrueReturn(ret)
2669         self.assertFalse(ret[next(iter(ret))]["changes"])
2670         self.assertEqual(self._read(name), self.with_matching_block)
2671     @with_tempfile()
2672     def test_non_matching_block_no_append_newline(self, name):
2673         self._write(name, self.with_non_matching_block)
2674         ret = self.run_state(
2675             "file.blockreplace",
2676             name=name,
2677             content=self.content,
2678             marker_start=self.marker_start,
2679             marker_end=self.marker_end,
2680             append_newline=False,
2681         )
2682         self.assertSaltTrueReturn(ret)
2683         self.assertTrue(ret[next(iter(ret))]["changes"])
2684         self.assertEqual(self._read(name), self.with_matching_block)
2685         ret = self.run_state(
2686             "file.blockreplace",
2687             name=name,
2688             content=self.content,
2689             marker_start=self.marker_start,
2690             marker_end=self.marker_end,
2691             append_newline=False,
2692         )
2693         self.assertSaltTrueReturn(ret)
2694         self.assertFalse(ret[next(iter(ret))]["changes"])
2695         self.assertEqual(self._read(name), self.with_matching_block)
2696         self._write(name, self.with_non_matching_block)
2697         ret = self.run_state(
2698             "file.blockreplace",
2699             name=name,
2700             content=self.content.rstrip("\r\n"),
2701             marker_start=self.marker_start,
2702             marker_end=self.marker_end,
2703             append_newline=False,
2704         )
2705         self.assertSaltTrueReturn(ret)
2706         self.assertTrue(ret[next(iter(ret))]["changes"])
2707         self.assertEqual(
2708             self._read(name), self.with_matching_block_and_marker_end_not_after_newline
2709         )
2710         ret = self.run_state(
2711             "file.blockreplace",
2712             name=name,
2713             content=self.content.rstrip("\r\n"),
2714             marker_start=self.marker_start,
2715             marker_end=self.marker_end,
2716             append_newline=False,
2717         )
2718         self.assertSaltTrueReturn(ret)
2719         self.assertFalse(ret[next(iter(ret))]["changes"])
2720         self.assertEqual(
2721             self._read(name), self.with_matching_block_and_marker_end_not_after_newline
2722         )
2723     @with_tempfile()
2724     def test_non_matching_block_and_marker_not_after_newline(self, name):
2725         self._write(name, self.with_non_matching_block_and_marker_end_not_after_newline)
2726         ret = self.run_state(
2727             "file.blockreplace",
2728             name=name,
2729             content=self.content,
2730             marker_start=self.marker_start,
2731             marker_end=self.marker_end,
2732         )
2733         self.assertSaltTrueReturn(ret)
2734         self.assertTrue(ret[next(iter(ret))]["changes"])
2735         self.assertEqual(self._read(name), self.with_matching_block)
2736         ret = self.run_state(
2737             "file.blockreplace",
2738             name=name,
2739             content=self.content,
2740             marker_start=self.marker_start,
2741             marker_end=self.marker_end,
2742         )
2743         self.assertSaltTrueReturn(ret)
2744         self.assertFalse(ret[next(iter(ret))]["changes"])
2745         self.assertEqual(self._read(name), self.with_matching_block)
2746         self._write(name, self.with_non_matching_block_and_marker_end_not_after_newline)
2747         ret = self.run_state(
2748             "file.blockreplace",
2749             name=name,
2750             content=self.content.rstrip("\r\n"),
2751             marker_start=self.marker_start,
2752             marker_end=self.marker_end,
2753         )
2754         self.assertSaltTrueReturn(ret)
2755         self.assertTrue(ret[next(iter(ret))]["changes"])
2756         self.assertEqual(self._read(name), self.with_matching_block)
2757         ret = self.run_state(
2758             "file.blockreplace",
2759             name=name,
2760             content=self.content.rstrip("\r\n"),
2761             marker_start=self.marker_start,
2762             marker_end=self.marker_end,
2763         )
2764         self.assertSaltTrueReturn(ret)
2765         self.assertFalse(ret[next(iter(ret))]["changes"])
2766         self.assertEqual(self._read(name), self.with_matching_block)
2767     @with_tempfile()
2768     def test_non_matching_block_and_marker_not_after_newline_append_newline(self, name):
2769         self._write(name, self.with_non_matching_block_and_marker_end_not_after_newline)
2770         ret = self.run_state(
2771             "file.blockreplace",
2772             name=name,
2773             content=self.content,
2774             marker_start=self.marker_start,
2775             marker_end=self.marker_end,
2776             append_newline=True,
2777         )
2778         self.assertSaltTrueReturn(ret)
2779         self.assertTrue(ret[next(iter(ret))]["changes"])
2780         self.assertEqual(self._read(name), self.with_matching_block_and_extra_newline)
2781         ret = self.run_state(
2782             "file.blockreplace",
2783             name=name,
2784             content=self.content,
2785             marker_start=self.marker_start,
2786             marker_end=self.marker_end,
2787             append_newline=True,
2788         )
2789         self.assertSaltTrueReturn(ret)
2790         self.assertFalse(ret[next(iter(ret))]["changes"])
2791         self.assertEqual(self._read(name), self.with_matching_block_and_extra_newline)
2792         self._write(name, self.with_non_matching_block_and_marker_end_not_after_newline)
2793         ret = self.run_state(
2794             "file.blockreplace",
2795             name=name,
2796             content=self.content.rstrip("\r\n"),
2797             marker_start=self.marker_start,
2798             marker_end=self.marker_end,
2799             append_newline=True,
2800         )
2801         self.assertSaltTrueReturn(ret)
2802         self.assertTrue(ret[next(iter(ret))]["changes"])
2803         self.assertEqual(self._read(name), self.with_matching_block)
2804         ret = self.run_state(
2805             "file.blockreplace",
2806             name=name,
2807             content=self.content.rstrip("\r\n"),
2808             marker_start=self.marker_start,
2809             marker_end=self.marker_end,
2810             append_newline=True,
2811         )
2812         self.assertSaltTrueReturn(ret)
2813         self.assertFalse(ret[next(iter(ret))]["changes"])
2814         self.assertEqual(self._read(name), self.with_matching_block)
2815     @with_tempfile()
2816     def test_non_matching_block_and_marker_not_after_newline_no_append_newline(
2817         self, name
2818     ):
2819         self._write(name, self.with_non_matching_block_and_marker_end_not_after_newline)
2820         ret = self.run_state(
2821             "file.blockreplace",
2822             name=name,
2823             content=self.content,
2824             marker_start=self.marker_start,
2825             marker_end=self.marker_end,
2826             append_newline=False,
2827         )
2828         self.assertSaltTrueReturn(ret)
2829         self.assertTrue(ret[next(iter(ret))]["changes"])
2830         self.assertEqual(self._read(name), self.with_matching_block)
2831         ret = self.run_state(
2832             "file.blockreplace",
2833             name=name,
2834             content=self.content,
2835             marker_start=self.marker_start,
2836             marker_end=self.marker_end,
2837             append_newline=False,
2838         )
2839         self.assertSaltTrueReturn(ret)
2840         self.assertFalse(ret[next(iter(ret))]["changes"])
2841         self.assertEqual(self._read(name), self.with_matching_block)
2842         self._write(name, self.with_non_matching_block_and_marker_end_not_after_newline)
2843         ret = self.run_state(
2844             "file.blockreplace",
2845             name=name,
2846             content=self.content.rstrip("\r\n"),
2847             marker_start=self.marker_start,
2848             marker_end=self.marker_end,
2849             append_newline=False,
2850         )
2851         self.assertSaltTrueReturn(ret)
2852         self.assertTrue(ret[next(iter(ret))]["changes"])
2853         self.assertEqual(
2854             self._read(name), self.with_matching_block_and_marker_end_not_after_newline
2855         )
2856         ret = self.run_state(
2857             "file.blockreplace",
2858             name=name,
2859             content=self.content.rstrip("\r\n"),
2860             marker_start=self.marker_start,
2861             marker_end=self.marker_end,
2862             append_newline=False,
2863         )
2864         self.assertSaltTrueReturn(ret)
2865         self.assertFalse(ret[next(iter(ret))]["changes"])
2866         self.assertEqual(
2867             self._read(name), self.with_matching_block_and_marker_end_not_after_newline
2868         )
2869     @with_tempfile()
2870     def test_matching_block(self, name):
2871         self._write(name, self.with_matching_block)
2872         ret = self.run_state(
2873             "file.blockreplace",
2874             name=name,
2875             content=self.content,
2876             marker_start=self.marker_start,
2877             marker_end=self.marker_end,
2878         )
2879         self.assertSaltTrueReturn(ret)
2880         self.assertFalse(ret[next(iter(ret))]["changes"])
2881         self.assertEqual(self._read(name), self.with_matching_block)
2882         ret = self.run_state(
2883             "file.blockreplace",
2884             name=name,
2885             content=self.content,
2886             marker_start=self.marker_start,
2887             marker_end=self.marker_end,
2888         )
2889         self.assertSaltTrueReturn(ret)
2890         self.assertFalse(ret[next(iter(ret))]["changes"])
2891         self.assertEqual(self._read(name), self.with_matching_block)
2892         self._write(name, self.with_matching_block)
2893         ret = self.run_state(
2894             "file.blockreplace",
2895             name=name,
2896             content=self.content.rstrip("\r\n"),
2897             marker_start=self.marker_start,
2898             marker_end=self.marker_end,
2899         )
2900         self.assertSaltTrueReturn(ret)
2901         self.assertFalse(ret[next(iter(ret))]["changes"])
2902         self.assertEqual(self._read(name), self.with_matching_block)
2903         ret = self.run_state(
2904             "file.blockreplace",
2905             name=name,
2906             content=self.content.rstrip("\r\n"),
2907             marker_start=self.marker_start,
2908             marker_end=self.marker_end,
2909         )
2910         self.assertSaltTrueReturn(ret)
2911         self.assertFalse(ret[next(iter(ret))]["changes"])
2912         self.assertEqual(self._read(name), self.with_matching_block)
2913     @with_tempfile()
2914     def test_matching_block_append_newline(self, name):
2915         self._write(name, self.with_matching_block)
2916         ret = self.run_state(
2917             "file.blockreplace",
2918             name=name,
2919             content=self.content,
2920             marker_start=self.marker_start,
2921             marker_end=self.marker_end,
2922             append_newline=True,
2923         )
2924         self.assertSaltTrueReturn(ret)
2925         self.assertTrue(ret[next(iter(ret))]["changes"])
2926         self.assertEqual(self._read(name), self.with_matching_block_and_extra_newline)
2927         ret = self.run_state(
2928             "file.blockreplace",
2929             name=name,
2930             content=self.content,
2931             marker_start=self.marker_start,
2932             marker_end=self.marker_end,
2933             append_newline=True,
2934         )
2935         self.assertSaltTrueReturn(ret)
2936         self.assertFalse(ret[next(iter(ret))]["changes"])
2937         self.assertEqual(self._read(name), self.with_matching_block_and_extra_newline)
2938         self._write(name, self.with_matching_block)
2939         ret = self.run_state(
2940             "file.blockreplace",
2941             name=name,
2942             content=self.content.rstrip("\r\n"),
2943             marker_start=self.marker_start,
2944             marker_end=self.marker_end,
2945             append_newline=True,
2946         )
2947         self.assertSaltTrueReturn(ret)
2948         self.assertFalse(ret[next(iter(ret))]["changes"])
2949         self.assertEqual(self._read(name), self.with_matching_block)
2950         ret = self.run_state(
2951             "file.blockreplace",
2952             name=name,
2953             content=self.content.rstrip("\r\n"),
2954             marker_start=self.marker_start,
2955             marker_end=self.marker_end,
2956             append_newline=True,
2957         )
2958         self.assertSaltTrueReturn(ret)
2959         self.assertFalse(ret[next(iter(ret))]["changes"])
2960         self.assertEqual(self._read(name), self.with_matching_block)
2961     @with_tempfile()
2962     def test_matching_block_no_append_newline(self, name):
2963         self._write(name, self.with_matching_block)
2964         ret = self.run_state(
2965             "file.blockreplace",
2966             name=name,
2967             content=self.content,
2968             marker_start=self.marker_start,
2969             marker_end=self.marker_end,
2970             append_newline=False,
2971         )
2972         self.assertSaltTrueReturn(ret)
2973         self.assertFalse(ret[next(iter(ret))]["changes"])
2974         self.assertEqual(self._read(name), self.with_matching_block)
2975         ret = self.run_state(
2976             "file.blockreplace",
2977             name=name,
2978             content=self.content,
2979             marker_start=self.marker_start,
2980             marker_end=self.marker_end,
2981             append_newline=False,
2982         )
2983         self.assertSaltTrueReturn(ret)
2984         self.assertFalse(ret[next(iter(ret))]["changes"])
2985         self.assertEqual(self._read(name), self.with_matching_block)
2986         self._write(name, self.with_matching_block)
2987         ret = self.run_state(
2988             "file.blockreplace",
2989             name=name,
2990             content=self.content.rstrip("\r\n"),
2991             marker_start=self.marker_start,
2992             marker_end=self.marker_end,
2993             append_newline=False,
2994         )
2995         self.assertSaltTrueReturn(ret)
2996         self.assertTrue(ret[next(iter(ret))]["changes"])
2997         self.assertEqual(
2998             self._read(name), self.with_matching_block_and_marker_end_not_after_newline
2999         )
3000         ret = self.run_state(
3001             "file.blockreplace",
3002             name=name,
3003             content=self.content.rstrip("\r\n"),
3004             marker_start=self.marker_start,
3005             marker_end=self.marker_end,
3006             append_newline=False,
3007         )
3008         self.assertSaltTrueReturn(ret)
3009         self.assertFalse(ret[next(iter(ret))]["changes"])
3010         self.assertEqual(
3011             self._read(name), self.with_matching_block_and_marker_end_not_after_newline
3012         )
3013     @with_tempfile()
3014     def test_matching_block_and_marker_not_after_newline(self, name):
3015         self._write(name, self.with_matching_block_and_marker_end_not_after_newline)
3016         ret = self.run_state(
3017             "file.blockreplace",
3018             name=name,
3019             content=self.content,
3020             marker_start=self.marker_start,
3021             marker_end=self.marker_end,
3022         )
3023         self.assertSaltTrueReturn(ret)
3024         self.assertTrue(ret[next(iter(ret))]["changes"])
3025         self.assertEqual(self._read(name), self.with_matching_block)
3026         ret = self.run_state(
3027             "file.blockreplace",
3028             name=name,
3029             content=self.content,
3030             marker_start=self.marker_start,
3031             marker_end=self.marker_end,
3032         )
3033         self.assertSaltTrueReturn(ret)
3034         self.assertFalse(ret[next(iter(ret))]["changes"])
3035         self.assertEqual(self._read(name), self.with_matching_block)
3036         self._write(name, self.with_matching_block_and_marker_end_not_after_newline)
3037         ret = self.run_state(
3038             "file.blockreplace",
3039             name=name,
3040             content=self.content.rstrip("\r\n"),
3041             marker_start=self.marker_start,
3042             marker_end=self.marker_end,
3043         )
3044         self.assertSaltTrueReturn(ret)
3045         self.assertTrue(ret[next(iter(ret))]["changes"])
3046         self.assertEqual(self._read(name), self.with_matching_block)
3047         ret = self.run_state(
3048             "file.blockreplace",
3049             name=name,
3050             content=self.content.rstrip("\r\n"),
3051             marker_start=self.marker_start,
3052             marker_end=self.marker_end,
3053         )
3054         self.assertSaltTrueReturn(ret)
3055         self.assertFalse(ret[next(iter(ret))]["changes"])
3056         self.assertEqual(self._read(name), self.with_matching_block)
3057     @with_tempfile()
3058     def test_matching_block_and_marker_not_after_newline_append_newline(self, name):
3059         self._write(name, self.with_matching_block_and_marker_end_not_after_newline)
3060         ret = self.run_state(
3061             "file.blockreplace",
3062             name=name,
3063             content=self.content,
3064             marker_start=self.marker_start,
3065             marker_end=self.marker_end,
3066             append_newline=True,
3067         )
3068         self.assertSaltTrueReturn(ret)
3069         self.assertTrue(ret[next(iter(ret))]["changes"])
3070         self.assertEqual(self._read(name), self.with_matching_block_and_extra_newline)
3071         ret = self.run_state(
3072             "file.blockreplace",
3073             name=name,
3074             content=self.content,
3075             marker_start=self.marker_start,
3076             marker_end=self.marker_end,
3077             append_newline=True,
3078         )
3079         self.assertSaltTrueReturn(ret)
3080         self.assertFalse(ret[next(iter(ret))]["changes"])
3081         self.assertEqual(self._read(name), self.with_matching_block_and_extra_newline)
3082         self._write(name, self.with_matching_block_and_marker_end_not_after_newline)
3083         ret = self.run_state(
3084             "file.blockreplace",
3085             name=name,
3086             content=self.content.rstrip("\r\n"),
3087             marker_start=self.marker_start,
3088             marker_end=self.marker_end,
3089             append_newline=True,
3090         )
3091         self.assertSaltTrueReturn(ret)
3092         self.assertTrue(ret[next(iter(ret))]["changes"])
3093         self.assertEqual(self._read(name), self.with_matching_block)
3094         ret = self.run_state(
3095             "file.blockreplace",
3096             name=name,
3097             content=self.content.rstrip("\r\n"),
3098             marker_start=self.marker_start,
3099             marker_end=self.marker_end,
3100             append_newline=True,
3101         )
3102         self.assertSaltTrueReturn(ret)
3103         self.assertFalse(ret[next(iter(ret))]["changes"])
3104         self.assertEqual(self._read(name), self.with_matching_block)
3105     @with_tempfile()
3106     def test_matching_block_and_marker_not_after_newline_no_append_newline(self, name):
3107         self._write(name, self.with_matching_block_and_marker_end_not_after_newline)
3108         ret = self.run_state(
3109             "file.blockreplace",
3110             name=name,
3111             content=self.content,
3112             marker_start=self.marker_start,
3113             marker_end=self.marker_end,
3114             append_newline=False,
3115         )
3116         self.assertSaltTrueReturn(ret)
3117         self.assertTrue(ret[next(iter(ret))]["changes"])
3118         self.assertEqual(self._read(name), self.with_matching_block)
3119         ret = self.run_state(
3120             "file.blockreplace",
3121             name=name,
3122             content=self.content,
3123             marker_start=self.marker_start,
3124             marker_end=self.marker_end,
3125             append_newline=False,
3126         )
3127         self.assertSaltTrueReturn(ret)
3128         self.assertFalse(ret[next(iter(ret))]["changes"])
3129         self.assertEqual(self._read(name), self.with_matching_block)
3130         self._write(name, self.with_matching_block_and_marker_end_not_after_newline)
3131         ret = self.run_state(
3132             "file.blockreplace",
3133             name=name,
3134             content=self.content.rstrip("\r\n"),
3135             marker_start=self.marker_start,
3136             marker_end=self.marker_end,
3137             append_newline=False,
3138         )
3139         self.assertSaltTrueReturn(ret)
3140         self.assertFalse(ret[next(iter(ret))]["changes"])
3141         self.assertEqual(
3142             self._read(name), self.with_matching_block_and_marker_end_not_after_newline
3143         )
3144         ret = self.run_state(
3145             "file.blockreplace",
3146             name=name,
3147             content=self.content.rstrip("\r\n"),
3148             marker_start=self.marker_start,
3149             marker_end=self.marker_end,
3150             append_newline=False,
3151         )
3152         self.assertSaltTrueReturn(ret)
3153         self.assertFalse(ret[next(iter(ret))]["changes"])
3154         self.assertEqual(
3155             self._read(name), self.with_matching_block_and_marker_end_not_after_newline
3156         )
3157     @with_tempfile()
3158     def test_issue_49043(self, name):
3159         ret = self.run_function(
3160             "state.sls",
3161             mods="issue-49043",
3162             pillar={"name": name},
3163         )
3164         log.error("ret = %s", repr(ret))
3165         diff = "--- \n+++ \n@@ -0,0 +1,3 @@\n"
3166         diff += dedent(
3167         )
3168         job = "file_|-somefile-blockreplace_|-{}_|-blockreplace".format(name)
3169         self.assertEqual(ret[job]["changes"]["diff"], diff)
3170 @pytest.mark.windows_whitelisted
3171 class RemoteFileTest(ModuleCase, SaltReturnAssertsMixin):
3172     @classmethod
3173     def setUpClass(cls):
3174         cls.webserver = Webserver()
3175         cls.webserver.start()
3176         cls.source = cls.webserver.url("grail/scene33")
3177         if IS_WINDOWS:
3178             cls.source_hash = "21438b3d5fd2c0028bcab92f7824dc69"
3179         else:
3180             cls.source_hash = "d2feb3beb323c79fc7a0f44f1408b4a3"
3181     @classmethod
3182     def tearDownClass(cls):
3183         cls.webserver.stop()
3184     @with_tempfile(create=False)
3185     def setUp(self, name):  # pylint: disable=arguments-differ
3186         self.name = name
3187     def tearDown(self):
3188         try:
3189             os.remove(self.name)
3190         except OSError as exc:
3191             if exc.errno != errno.ENOENT:
3192                 raise
3193     def run_state(self, *args, **kwargs):  # pylint: disable=arguments-differ
3194         ret = super().run_state(*args, **kwargs)
3195         log.debug("ret = %s", ret)
3196         return ret
3197     def test_file_managed_http_source_no_hash(self):
3198         ret = self.run_state(
3199             "file.managed", name=self.name, source=self.source, skip_verify=False
3200         )
3201         self.assertSaltFalseReturn(ret)
3202     def test_file_managed_http_source(self):
3203         ret = self.run_state(
3204             "file.managed",
3205             name=self.name,
3206             source=self.source,
3207             source_hash=self.source_hash,
3208             skip_verify=False,
3209         )
3210         self.assertSaltTrueReturn(ret)
3211     def test_file_managed_http_source_skip_verify(self):
3212         ret = self.run_state(
3213             "file.managed", name=self.name, source=self.source, skip_verify=True
3214         )
3215         self.assertSaltTrueReturn(ret)
3216     def test_file_managed_keep_source_false_http(self):
3217         ret = self.run_state(
3218             "file.managed",
3219             name=self.name,
3220             source=self.source,
3221             source_hash=self.source_hash,
3222             keep_source=False,
3223         )
3224         ret = ret[next(iter(ret))]
3225         assert ret["result"] is True
3226         result = self.run_function("cp.is_cached", [self.source])
3227         assert result == "", "File is still cached at {}".format(result)
3228 @skipIf(not salt.utils.path.which("patch"), "patch is not installed")
3229 @pytest.mark.windows_whitelisted
3230 class PatchTest(ModuleCase, SaltReturnAssertsMixin):
3231     def _check_patch_version(self, min_version):
3232         version = self.run_function("cmd.run", ["patch --version"]).splitlines()[0]
3233         version = version.split()[1]
3234         if _LooseVersion(version) &lt; _LooseVersion(min_version):
3235             self.skipTest(
3236                 "Minimum patch version required: {}. "
3237                 "Patch version installed: {}".format(min_version, version)
3238             )
3239     @classmethod
3240     def setUpClass(cls):
3241         cls.webserver = Webserver()
3242         cls.webserver.start()
3243         cls.numbers_patch_name = "numbers.patch"
3244         cls.math_patch_name = "math.patch"
3245         cls.all_patch_name = "all.patch"
3246         cls.numbers_patch_template_name = cls.numbers_patch_name + ".jinja"
3247         cls.math_patch_template_name = cls.math_patch_name + ".jinja"
3248         cls.all_patch_template_name = cls.all_patch_name + ".jinja"
3249         cls.numbers_patch_path = "patches/" + cls.numbers_patch_name
3250         cls.math_patch_path = "patches/" + cls.math_patch_name
3251         cls.all_patch_path = "patches/" + cls.all_patch_name
3252         cls.numbers_patch_template_path = "patches/" + cls.numbers_patch_template_name
3253         cls.math_patch_template_path = "patches/" + cls.math_patch_template_name
3254         cls.all_patch_template_path = "patches/" + cls.all_patch_template_name
3255         cls.numbers_patch = "salt://" + cls.numbers_patch_path
3256         cls.math_patch = "salt://" + cls.math_patch_path
3257         cls.all_patch = "salt://" + cls.all_patch_path
3258         cls.numbers_patch_template = "salt://" + cls.numbers_patch_template_path
3259         cls.math_patch_template = "salt://" + cls.math_patch_template_path
3260         cls.all_patch_template = "salt://" + cls.all_patch_template_path
3261         cls.numbers_patch_http = cls.webserver.url(cls.numbers_patch_path)
3262         cls.math_patch_http = cls.webserver.url(cls.math_patch_path)
3263         cls.all_patch_http = cls.webserver.url(cls.all_patch_path)
3264         cls.numbers_patch_template_http = cls.webserver.url(
3265             cls.numbers_patch_template_path
3266         )
3267         cls.math_patch_template_http = cls.webserver.url(cls.math_patch_template_path)
3268         cls.all_patch_template_http = cls.webserver.url(cls.all_patch_template_path)
3269         patches_dir = os.path.join(RUNTIME_VARS.FILES, "file", "base", "patches")
3270         cls.numbers_patch_hash = salt.utils.hashutils.get_hash(
3271             os.path.join(patches_dir, cls.numbers_patch_name)
3272         )
3273         cls.math_patch_hash = salt.utils.hashutils.get_hash(
3274             os.path.join(patches_dir, cls.math_patch_name)
3275         )
3276         cls.all_patch_hash = salt.utils.hashutils.get_hash(
3277             os.path.join(patches_dir, cls.all_patch_name)
3278         )
3279         cls.numbers_patch_template_hash = salt.utils.hashutils.get_hash(
3280             os.path.join(patches_dir, cls.numbers_patch_template_name)
3281         )
3282         cls.math_patch_template_hash = salt.utils.hashutils.get_hash(
3283             os.path.join(patches_dir, cls.math_patch_template_name)
3284         )
3285         cls.all_patch_template_hash = salt.utils.hashutils.get_hash(
3286             os.path.join(patches_dir, cls.all_patch_template_name)
3287         )
3288         cls.context = {"two": "two", "ten": 10}
3289     @classmethod
3290     def tearDownClass(cls):
3291         cls.webserver.stop()
3292     def setUp(self):
3293         self.base_dir = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
3294         os.makedirs(os.path.join(self.base_dir, "foo", "bar"))
3295         self.numbers_file = os.path.join(self.base_dir, "foo", "numbers.txt")
3296         self.math_file = os.path.join(self.base_dir, "foo", "bar", "math.txt")
3297         with salt.utils.files.fopen(self.numbers_file, "w") as fp_:
3298             fp_.write(
3299                 textwrap.dedent(
3300                 )
3301             )
3302         with salt.utils.files.fopen(self.math_file, "w") as fp_:
3303             fp_.write(
3304                 textwrap.dedent(
3305                 )
3306             )
3307         self.addCleanup(shutil.rmtree, self.base_dir, ignore_errors=True)
3308     def test_patch_single_file(self):
3309         ret = self.run_state(
3310             "file.patch",
3311             name=self.numbers_file,
3312             source=self.numbers_patch,
3313         )
3314         self.assertSaltTrueReturn(ret)
3315         ret = ret[next(iter(ret))]
3316         self.assertEqual(ret["comment"], "Patch successfully applied")
3317         ret = self.run_state(
3318             "file.patch",
3319             name=self.numbers_file,
3320             source=self.numbers_patch,
3321         )
3322         self.assertSaltTrueReturn(ret)
3323         ret = ret[next(iter(ret))]
3324         self.assertEqual(ret["comment"], "Patch was already applied")
3325         self.assertEqual(ret["changes"], {})
3326     def test_patch_directory(self):
3327         self._check_patch_version("2.6")
3328         ret = self.run_state(
3329             "file.patch",
3330             name=self.base_dir,
3331             source=self.all_patch,
3332             strip=1,
3333         )
3334         self.assertSaltTrueReturn(ret)
3335         ret = ret[next(iter(ret))]
3336         self.assertEqual(ret["comment"], "Patch successfully applied")
3337         ret = self.run_state(
3338             "file.patch",
3339             name=self.base_dir,
3340             source=self.all_patch,
3341             strip=1,
3342         )
3343         self.assertSaltTrueReturn(ret)
3344         ret = ret[next(iter(ret))]
3345         self.assertEqual(ret["comment"], "Patch was already applied")
3346         self.assertEqual(ret["changes"], {})
3347     def test_patch_strip_parsing(self):
3348         self._check_patch_version("2.6")
3349         ret = self.run_state(
3350             "file.patch",
3351             name=self.base_dir,
3352             source=self.all_patch,
3353             options="-p1",
3354         )
3355         self.assertSaltTrueReturn(ret)
3356         ret = ret[next(iter(ret))]
3357         self.assertEqual(ret["comment"], "Patch successfully applied")
3358         ret = self.run_state(
3359             "file.patch",
3360             name=self.base_dir,
3361             source=self.all_patch,
3362             options="--strip=1",
3363         )
3364         self.assertSaltTrueReturn(ret)
3365         ret = ret[next(iter(ret))]
3366         self.assertEqual(ret["comment"], "Patch was already applied")
3367         self.assertEqual(ret["changes"], {})
3368         ret = self.run_state(
3369             "file.patch",
3370             name=self.base_dir,
3371             source=self.all_patch,
3372             options="--strip 1",
3373         )
3374         self.assertSaltTrueReturn(ret)
3375         ret = ret[next(iter(ret))]
3376         self.assertEqual(ret["comment"], "Patch was already applied")
3377         self.assertEqual(ret["changes"], {})
3378     def test_patch_saltenv(self):
3379         ret = self.run_state(
3380             "file.patch",
3381             name=self.math_file,
3382             source=self.math_patch,
3383             saltenv="prod",
3384         )
3385         self.assertSaltFalseReturn(ret)
3386         ret = ret[next(iter(ret))]
3387         self.assertEqual(
3388             ret["comment"],
3389             "Source file {} not found in saltenv 'prod'".format(self.math_patch),
3390         )
3391     def test_patch_single_file_failure(self):
3392         with salt.utils.files.fopen(self.numbers_file, "w"):
3393             pass
3394         ret = self.run_state(
3395             "file.patch",
3396             name=self.numbers_file,
3397             source=self.numbers_patch,
3398         )
3399         self.assertSaltFalseReturn(ret)
3400         ret = ret[next(iter(ret))]
3401         self.assertIn("Patch would not apply cleanly", ret["comment"])
3402         reject_file = salt.utils.files.mkstemp()
3403         ret = self.run_state(
3404             "file.patch",
3405             name=self.numbers_file,
3406             source=self.numbers_patch,
3407             reject_file=reject_file,
3408             strip=1,
3409         )
3410         self.assertSaltFalseReturn(ret)
3411         ret = ret[next(iter(ret))]
3412         self.assertIn("Patch would not apply cleanly", ret["comment"])
3413         if IS_WINDOWS:
3414             reject_file = reject_file.replace("\\", "\\\\")
3415             reject_file = "'{}'".format(reject_file)
3416         self.assertRegex(
3417             ret["comment"], "saving rejects to (file )?{}".format(reject_file)
3418         )
3419     def test_patch_directory_failure(self):
3420         with salt.utils.files.fopen(self.math_file, "w"):
3421             pass
3422         ret = self.run_state(
3423             "file.patch",
3424             name=self.base_dir,
3425             source=self.all_patch,
3426             strip=1,
3427         )
3428         self.assertSaltFalseReturn(ret)
3429         ret = ret[next(iter(ret))]
3430         self.assertIn("Patch would not apply cleanly", ret["comment"])
3431         reject_file = salt.utils.files.mkstemp()
3432         ret = self.run_state(
3433             "file.patch",
3434             name=self.base_dir,
3435             source=self.all_patch,
3436             reject_file=reject_file,
3437             strip=1,
3438         )
3439         self.assertSaltFalseReturn(ret)
3440         ret = ret[next(iter(ret))]
3441         self.assertIn("Patch would not apply cleanly", ret["comment"])
3442         if IS_WINDOWS:
3443             reject_file = reject_file.replace("\\", "\\\\")
3444             reject_file = "'{}'".format(reject_file)
3445         self.assertRegex(
3446             ret["comment"], "saving rejects to (file )?{}".format(reject_file)
3447         )
3448     def test_patch_single_file_remote_source(self):
3449         ret = self.run_state(
3450             "file.patch",
3451             name=self.math_file,
3452             source=self.math_patch_http,
3453         )
3454         self.assertSaltFalseReturn(ret)
3455         ret = ret[next(iter(ret))]
3456         self.assertIn("Unable to verify upstream hash", ret["comment"])
3457         ret = self.run_state(
3458             "file.patch",
3459             name=self.math_file,
3460             source=self.math_patch_http,
3461             source_hash=self.math_patch_hash,
3462         )
3463         self.assertSaltTrueReturn(ret)
3464         ret = ret[next(iter(ret))]
3465         self.assertEqual(ret["comment"], "Patch successfully applied")
3466         ret = self.run_state(
3467             "file.patch",
3468             name=self.math_file,
3469             source=self.math_patch_http,
3470             skip_verify=True,
3471         )
3472         self.assertSaltTrueReturn(ret)
3473         ret = ret[next(iter(ret))]
3474         self.assertEqual(ret["comment"], "Patch was already applied")
3475         self.assertEqual(ret["changes"], {})
3476     def test_patch_directory_remote_source(self):
3477         self._check_patch_version("2.6")
3478         ret = self.run_state(
3479             "file.patch",
3480             name=self.base_dir,
3481             source=self.all_patch_http,
3482             strip=1,
3483         )
3484         self.assertSaltFalseReturn(ret)
3485         ret = ret[next(iter(ret))]
3486         self.assertIn("Unable to verify upstream hash", ret["comment"])
3487         ret = self.run_state(
3488             "file.patch",
3489             name=self.base_dir,
3490             source=self.all_patch_http,
3491             source_hash=self.all_patch_hash,
3492             strip=1,
3493         )
3494         self.assertSaltTrueReturn(ret)
3495         ret = ret[next(iter(ret))]
3496         self.assertEqual(ret["comment"], "Patch successfully applied")
3497         ret = self.run_state(
3498             "file.patch",
3499             name=self.base_dir,
3500             source=self.all_patch_http,
3501             strip=1,
3502             skip_verify=True,
3503         )
3504         self.assertSaltTrueReturn(ret)
3505         ret = ret[next(iter(ret))]
3506         self.assertEqual(ret["comment"], "Patch was already applied")
3507         self.assertEqual(ret["changes"], {})
3508     def test_patch_single_file_template(self):
3509         ret = self.run_state(
3510             "file.patch",
3511             name=self.numbers_file,
3512             source=self.numbers_patch_template,
3513             template="jinja",
3514             context=self.context,
3515         )
3516         self.assertSaltTrueReturn(ret)
3517         ret = ret[next(iter(ret))]
3518         self.assertEqual(ret["comment"], "Patch successfully applied")
3519         ret = self.run_state(
3520             "file.patch",
3521             name=self.numbers_file,
3522             source=self.numbers_patch_template,
3523             template="jinja",
3524             context=self.context,
3525         )
3526         self.assertSaltTrueReturn(ret)
3527         ret = ret[next(iter(ret))]
3528         self.assertEqual(ret["comment"], "Patch was already applied")
3529         self.assertEqual(ret["changes"], {})
3530     def test_patch_directory_template(self):
3531         self._check_patch_version("2.6")
3532         ret = self.run_state(
3533             "file.patch",
3534             name=self.base_dir,
3535             source=self.all_patch_template,
3536             template="jinja",
3537             context=self.context,
3538             strip=1,
3539         )
3540         self.assertSaltTrueReturn(ret)
3541         ret = ret[next(iter(ret))]
3542         self.assertEqual(ret["comment"], "Patch successfully applied")
3543         ret = self.run_state(
3544             "file.patch",
3545             name=self.base_dir,
3546             source=self.all_patch_template,
3547             template="jinja",
3548             context=self.context,
3549             strip=1,
3550         )
3551         self.assertSaltTrueReturn(ret)
3552         ret = ret[next(iter(ret))]
3553         self.assertEqual(ret["comment"], "Patch was already applied")
3554         self.assertEqual(ret["changes"], {})
3555     def test_patch_single_file_remote_source_template(self):
3556         ret = self.run_state(
3557             "file.patch",
3558             name=self.math_file,
3559             source=self.math_patch_template_http,
3560             template="jinja",
3561             context=self.context,
3562         )
3563         self.assertSaltFalseReturn(ret)
3564         ret = ret[next(iter(ret))]
3565         self.assertIn("Unable to verify upstream hash", ret["comment"])
3566         ret = self.run_state(
3567             "file.patch",
3568             name=self.math_file,
3569             source=self.math_patch_template_http,
3570             source_hash=self.math_patch_template_hash,
3571             template="jinja",
3572             context=self.context,
3573         )
3574         self.assertSaltTrueReturn(ret)
3575         ret = ret[next(iter(ret))]
3576         self.assertEqual(ret["comment"], "Patch successfully applied")
3577         ret = self.run_state(
3578             "file.patch",
3579             name=self.math_file,
3580             source=self.math_patch_template_http,
3581             template="jinja",
3582             context=self.context,
3583             skip_verify=True,
3584         )
3585         self.assertSaltTrueReturn(ret)
3586         ret = ret[next(iter(ret))]
3587         self.assertEqual(ret["comment"], "Patch was already applied")
3588         self.assertEqual(ret["changes"], {})
3589     def test_patch_directory_remote_source_template(self):
3590         self._check_patch_version("2.6")
3591         ret = self.run_state(
3592             "file.patch",
3593             name=self.base_dir,
3594             source=self.all_patch_template_http,
3595             template="jinja",
3596             context=self.context,
3597             strip=1,
3598         )
3599         self.assertSaltFalseReturn(ret)
3600         ret = ret[next(iter(ret))]
3601         self.assertIn("Unable to verify upstream hash", ret["comment"])
3602         ret = self.run_state(
3603             "file.patch",
3604             name=self.base_dir,
3605             source=self.all_patch_template_http,
3606             source_hash=self.all_patch_template_hash,
3607             template="jinja",
3608             context=self.context,
3609             strip=1,
3610         )
3611         self.assertSaltTrueReturn(ret)
3612         ret = ret[next(iter(ret))]
3613         self.assertEqual(ret["comment"], "Patch successfully applied")
3614         ret = self.run_state(
3615             "file.patch",
3616             name=self.base_dir,
3617             source=self.all_patch_template_http,
3618             template="jinja",
3619             context=self.context,
3620             strip=1,
3621             skip_verify=True,
3622         )
3623         self.assertSaltTrueReturn(ret)
3624         ret = ret[next(iter(ret))]
3625         self.assertEqual(ret["comment"], "Patch was already applied")
3626         self.assertEqual(ret["changes"], {})
3627     def test_patch_test_mode(self):
3628         ret = self.run_state(
3629             "file.patch",
3630             name=self.numbers_file,
3631             source=self.numbers_patch,
3632             test=True,
3633         )
3634         self.assertSaltNoneReturn(ret)
3635         ret = ret[next(iter(ret))]
3636         self.assertEqual(ret["comment"], "The patch would be applied")
3637         self.assertTrue(ret["changes"])
3638         ret = self.run_state(
3639             "file.patch",
3640             name=self.numbers_file,
3641             source=self.numbers_patch,
3642         )
3643         self.assertSaltTrueReturn(ret)
3644         ret = ret[next(iter(ret))]
3645         self.assertEqual(ret["comment"], "Patch successfully applied")
3646         self.assertTrue(ret["changes"])
3647         ret = self.run_state(
3648             "file.patch",
3649             name=self.numbers_file,
3650             source=self.numbers_patch,
3651             test=True,
3652         )
3653         self.assertSaltTrueReturn(ret)
3654         ret = ret[next(iter(ret))]
3655         self.assertEqual(ret["comment"], "Patch was already applied")
3656         self.assertEqual(ret["changes"], {})
3657         with salt.utils.files.fopen(self.numbers_file, "w"):
3658             pass
3659         ret = self.run_state(
3660             "file.patch",
3661             name=self.numbers_file,
3662             source=self.numbers_patch,
3663             test=True,
3664         )
3665         self.assertSaltFalseReturn(ret)
3666         ret = ret[next(iter(ret))]
3667         self.assertIn("Patch would not apply cleanly", ret["comment"])
3668         self.assertEqual(ret["changes"], {})
3669 WIN_TEST_FILE = "c:/testfile"
3670 @pytest.mark.destructive_test
3671 @skipIf(not IS_WINDOWS, "windows test only")
3672 @pytest.mark.windows_whitelisted
3673 class WinFileTest(ModuleCase):
3674     def setUp(self):
3675         self.run_state(
3676             "file.managed", name=WIN_TEST_FILE, makedirs=True, contents="Only a test"
3677         )
3678     def tearDown(self):
3679         self.run_state("file.absent", name=WIN_TEST_FILE)
3680     def test_file_managed(self):
3681         self.assertTrue(self.run_state("file.exists", name=WIN_TEST_FILE))
3682     def test_file_copy(self):
3683         ret = self.run_state(
3684             "file.copy", name="c:/testfile_copy", makedirs=True, source=WIN_TEST_FILE
3685         )
3686         self.assertTrue(ret)
3687     def test_file_comment(self):
3688         self.run_state("file.comment", name=WIN_TEST_FILE, regex="^Only")
3689         with salt.utils.files.fopen(WIN_TEST_FILE, "r") as fp_:
3690             self.assertTrue(fp_.read().startswith("#Only"))
3691     def test_file_replace(self):
3692         self.run_state(
3693             "file.replace", name=WIN_TEST_FILE, pattern="test", repl="testing"
3694         )
3695         with salt.utils.files.fopen(WIN_TEST_FILE, "r") as fp_:
3696             self.assertIn("testing", fp_.read())
3697     def test_file_absent(self):
3698         ret = self.run_state("file.absent", name=WIN_TEST_FILE)
3699         self.assertTrue(ret)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
