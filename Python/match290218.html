<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for highstate_doc_1.py &amp; test_file_2.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for highstate_doc_1.py &amp; test_file_2.py
      </h3>
<h1 align="center">
        0.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>highstate_doc_1.py (5.7395144%)<th>test_file_2.py (0.31968522%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(591-592)<td><a href="#" name="0">(3163-3164)</a><td align="center"><font color="#ff0000">13</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(429-430)<td><a href="#" name="1">(3130-3131)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>highstate_doc_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import re
3 import salt.utils.files
4 import salt.utils.stringutils
5 import salt.utils.templates as tpl
6 import salt.utils.yaml
7 __virtualname__ = "highstate_doc"
8 log = logging.getLogger(__name__)
9 markdown_basic_jinja_template_txt = """
10 {% for s in lowstates %}
11 `{{s.id_full}}`
12 -----------------------------------------------------------------
13  * state: {{s.state_function}}
14  * name: `{{s.name}}`
15 {{s.markdown.requisites}}
16 {{s.markdown.details}}
17 {%- endfor %}
18 Configuration Managment
19 ===============================================================================
20 ```
21 fqdn: {{grains.get('fqdn')}}
22 os: {{grains.get('os')}}
23 osfinger: {{grains.get('osfinger')}}
24 mem_total: {{grains.get('mem_total')}}MB
25 num_cpus: {{grains.get('num_cpus')}}
26 ipv4: {{grains.get('ipv4')}}
27 master: {{opts.get('master')}}
28 ```
29 This system is fully or partly managed using Salt.
30 The following sections are a rendered view of what the configuration management system
31 controlled on this system. Each item is handled in order from top to bottom unless some
32 requisites like `require` force other ordering.
33 )
34 def markdown_basic_jinja_template(**kwargs):
35     return markdown_basic_jinja_template_txt
36 def markdown_default_jinja_template(**kwargs):
37     return markdown_default_jinja_template_txt
38 def markdown_full_jinja_template(**kwargs):
39     return markdown_advanced_jinja_template_txt
40 def _get_config(**kwargs):
41     config = {
42         "filter_id_regex": [".*!doc_skip"],
43         "filter_function_regex": [],
44         "replace_text_regex": {},
45         "processor": "highstate_doc.processor_markdown",
46         "max_render_file_size": 10000,
47         "note": None,
48     }
49     if "__salt__" in globals():
50         config_key = "{}.config".format(__virtualname__)
51         config.update(__salt__["config.get"](config_key, {}))
52     for k in set(config.keys()) &amp; set(kwargs.keys()):
53         config[k] = kwargs[k]
54     return config
55 def read_file(name):
56     """
57         <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>with salt.utils.files.fopen(name, "r") as f:
58             out = salt.utils.stringutils.to_unicode(f.read(</b></font>))
59     except Exception as ex:  # pylint: disable=broad-except
60         log.error(ex)
61         return None
62     return out
63 def render(
64     jinja_template_text=None,
65     jinja_template_function="highstate_doc.markdown_default_jinja_template",
66     **kwargs
67 ):
68     """
69     Render highstate to a text format (default Markdown)
70     if `jinja_template_text` is not set, `jinja_template_function` is used.
71     jinja_template_text: jinja text that the render uses to create the document.
72     jinja_template_function: a salt module call that returns template text.
73     :options:
74         highstate_doc.markdown_basic_jinja_template
75         highstate_doc.markdown_default_jinja_template
76         highstate_doc.markdown_full_jinja_template
77     """
78     config = _get_config(**kwargs)
79     lowstates = process_lowstates(**kwargs)
80     context = {
81         "saltenv": None,
82         "config": config,
83         "lowstates": lowstates,
84         "salt": __salt__,
85         "pillar": __pillar__,
86         "grains": __grains__,
87         "opts": __opts__,
88         "kwargs": kwargs,
89     }
90     template_text = jinja_template_text
91     if template_text is None and jinja_template_function:
92         template_text = __salt__[jinja_template_function](**kwargs)
93     if template_text is None:
94         raise Exception("No jinja template text")
95     txt = tpl.render_jinja_tmpl(template_text, context, tmplpath=None)
96     rt = config.get("replace_text_regex")
97     for r in rt:
98         txt = re.sub(r, rt[r], txt)
99     return txt
100 def _blacklist_filter(s, config):
101     ss = s["state"]
102     sf = s["fun"]
103     state_function = "{}.{}".format(s["state"], s["fun"])
104     for b in config["filter_function_regex"]:
105         if re.match(b, state_function):
106             return True
107     for b in config["filter_id_regex"]:
108         if re.match(b, s["__id__"]):
109             return True
110     return False
111 def process_lowstates(**kwargs):
112     """
113     return processed lowstate data that was not blacklisted
114     render_module_function is used to provide your own.
115     defaults to from_lowstate
116     """
117     states = []
118     config = _get_config(**kwargs)
119     processor = config.get("processor")
120     ls = __salt__["state.show_lowstate"]()
121     if not isinstance(ls, list):
122         raise Exception(
123             "ERROR: to see details run: [salt-call state.show_lowstate]"
124             " &lt;-----***-SEE-***"
125         )
126     else:
127         if ls:
128             if not isinstance(ls[0], dict):
129                 raise Exception(
130                     "ERROR: to see details run: [salt-call state.show_lowstate]"
131                     " &lt;-----***-SEE-***"
132                 )
133     for s in ls:
134         if _blacklist_filter(s, config):
135             continue
136         doc = __salt__[processor](s, config, **kwargs)
137         states.append(doc)
138     return states
139 def _state_data_to_yaml_string(data, whitelist=None, blacklist=None):
140     """
141     return a data dict in yaml string format.
142     """
143     y = {}
144     if blacklist is None:
145         blacklist = [
146             "__env__",
147             "__id__",
148             "__sls__",
149             "fun",
150             "name",
151             "context",
152             "order",
153             "state",
154             "require",
155             "require_in",
156             "watch",
157             "watch_in",
158         ]
159     kset = set(data.keys())
160     if blacklist:
161         kset -= set(blacklist)
162     if whitelist:
163         kset &amp;= set(whitelist)
164     for k in kset:
165         y[k] = data[k]
166     if not y:
167         return None
168     return salt.utils.yaml.safe_dump(y, default_flow_style=False)
169 def _md_fix(text):
170     """
171     sanitize text data that is to be displayed in a markdown code block
172     """
173     return text.replace("```", "``[`][markdown parse fix]")
174 def _format_markdown_system_file(filename, config):
175     ret = ""
176     file_stats = __salt__["file.stats"](filename)
177     y = _state_data_to_yaml_string(
178         file_stats, whitelist=["user", "group", "mode", "uid", "gid", "size"]
179     )
180     if y:
181         ret += "file stat {1}\n```\n{0}```\n".format(y, filename)
182     file_size = file_stats.get("size")
183     if file_size &lt;= config.get("max_render_file_size"):
184         is_binary = True
185         try:
186             file_type = __salt__["cmd.shell"]("\\file -i '{}'".format(filename))
187             if "charset=binary" not in file_type:
188                 is_binary = False
189         except Exception as ex:  # pylint: disable=broad-except
190             is_binary = False
191             file_data = "[[skipped binary data]]"
192         else:
193             <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>with salt.utils.files.fopen(filename, "r") as f:
194                 file_data = salt.utils.stringutils.to_unicode(f.read(</b></font>))
195         file_data = _md_fix(file_data)
196         ret += "file data {1}\n```\n{0}\n```\n".format(file_data, filename)
197     else:
198         ret += "```\n{}\n```\n".format(
199             "SKIPPED LARGE FILE!\nSet {}:max_render_file_size &gt; {} to render.".format(
200                 "{}.config".format(__virtualname__), file_size
201             )
202         )
203     return ret
204 def _format_markdown_link(name):
205     link = name
206     symbals = "~`!@#$%^&amp;*()+={}[]:;\"&lt;&gt;,.?/|'\\"
207     for s in symbals:
208         link = link.replace(s, "")
209     link = link.replace(" ", "-")
210     return link
211 def _format_markdown_requisite(state, stateid, makelink=True):
212     """
213     format requisite as a link users can click
214     """
215     fmt_id = "{}: {}".format(state, stateid)
216     if makelink:
217         return " * [{}](#{})\n".format(fmt_id, _format_markdown_link(fmt_id))
218     else:
219         return " * `{}`\n".format(fmt_id)
220 def processor_markdown(lowstate_item, config, **kwargs):
221     """
222     Takes low state data and returns a dict of processed data
223     that is by default used in a jinja template when rendering a markdown highstate_doc.
224     This `lowstate_item_markdown` given a lowstate item, returns a dict like:
225     .. code-block:: none
226         vars:       # the raw lowstate_item that was processed
227         id:         # the 'id' of the state.
228         id_full:    # combo of the state type and id "state: id"
229         state:      # name of the salt state module
230         function:   # name of the state function
231         name:       # value of 'name:' passed to the salt state module
232         state_function:    # the state name and function name
233         markdown:          # text data to describe a state
234             requisites:    # requisite like [watch_in, require_in]
235             details:       # state name, parameters and other details like file contents
236     """
237     s = lowstate_item
238     state_function = "{}.{}".format(s["state"], s["fun"])
239     id_full = "{}: {}".format(s["state"], s["__id__"])
240     requisites = ""
241     for comment, key in (
242         ("run or update after changes in:\n", "watch"),
243         ("after changes, run or update:\n", "watch_in"),
244         ("require:\n", "require"),
245         ("required in:\n", "require_in"),
246     ):
247         reqs = s.get(key, [])
248         if reqs:
249             requisites += comment
250             for w in reqs:
251                 requisites += _format_markdown_requisite(*next(iter(w.items())))
252     details = ""
253     if state_function == "highstate_doc.note":
254         if "contents" in s:
255             details += "\n{}\n".format(s["contents"])
256         if "source" in s:
257             text = __salt__["cp.get_file_str"](s["source"])
258             if text:
259                 details += "\n{}\n".format(text)
260             else:
261                 details += "\n{}\n".format("ERROR: opening {}".format(s["source"]))
262     if state_function == "pkg.installed":
263         pkgs = s.get("pkgs", s.get("name"))
264         details += "\n```\ninstall: {}\n```\n".format(pkgs)
265     if state_function == "file.recurse":
266         details += """recurse copy of files\n"""
267         y = _state_data_to_yaml_string(s)
268         if y:
269             details += "```\n{}\n```\n".format(y)
270         if "!doc_recurse" in id_full:
271             findfiles = __salt__["file.find"](path=s.get("name"), type="f")
272             if len(findfiles) &lt; 10 or "!doc_recurse_force" in id_full:
273                 for f in findfiles:
274                     details += _format_markdown_system_file(f, config)
275             else:
276                 details += """ &gt; Skipping because more than 10 files to display.\n"""
277                 details += (
278                 )
279         else:
280             details += """ &gt; For more details review logs and Salt state files.\n\n"""
281             details += """ &gt; HINT: for improved docs use multiple file.managed states or file.archive, git.latest. etc.\n"""
282             details += """ &gt; HINT: to force doc to show all files in path add !doc_recurse .\n"""
283     if state_function == "file.blockreplace":
284         if s.get("content"):
285             details += "ensure block of content is in file\n```\n{}\n```\n".format(
286                 _md_fix(s["content"])
287             )
288         if s.get("source"):
289             text = "** source: " + s.get("source")
290             details += "ensure block of content is in file\n```\n{}\n```\n".format(
291                 _md_fix(text)
292             )
293     if state_function == "file.managed":
294         details += _format_markdown_system_file(s["name"], config)
295     if not details:
296         y = _state_data_to_yaml_string(s)
297         if y:
298             details += "```\n{}```\n".format(y)
299     r = {
300         "vars": lowstate_item,
301         "state": s["state"],
302         "name": s["name"],
303         "function": s["fun"],
304         "id": s["__id__"],
305         "id_full": id_full,
306         "state_function": state_function,
307         "markdown": {
308             "requisites": requisites.decode("utf-8"),
309             "details": details.decode("utf-8"),
310         },
311     }
312     return r
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_file_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 Tests for the file state
3 """
4 import errno
5 import filecmp
6 import logging
7 import os
8 import pathlib
9 import re
10 import shutil
11 import stat
12 import sys
13 import tempfile
14 import textwrap
15 import pytest
16 import salt.serializers.configparser
17 import salt.serializers.plist
18 import salt.utils.atomicfile
19 import salt.utils.data
20 import salt.utils.files
21 import salt.utils.json
22 import salt.utils.path
23 import salt.utils.platform
24 import salt.utils.stringutils
25 from salt.utils.versions import LooseVersion as _LooseVersion
26 from tests.support.case import ModuleCase
27 from tests.support.helpers import (
28     Webserver,
29     dedent,
30     requires_system_grains,
31     with_system_user_and_group,
32     with_tempdir,
33     with_tempfile,
34 )
35 from tests.support.mixins import SaltReturnAssertsMixin
36 from tests.support.runtests import RUNTIME_VARS
37 from tests.support.unit import skipIf
38 log = logging.getLogger(__name__)
39 HAS_PWD = True
40 try:
41     import pwd
42 except ImportError:
43     HAS_PWD = False
44 HAS_GRP = True
45 try:
46     import grp
47 except ImportError:
48     HAS_GRP = False
49 IS_WINDOWS = salt.utils.platform.is_windows()
50 BINARY_FILE = b"GIF89a\x01\x00\x01\x00\x80\x00\x00\x05\x04\x04\x00\x00\x00,\x00\x00\x00\x00\x01\x00\x01\x00\x00\x02\x02D\x01\x00;"
51 TEST_SYSTEM_USER = "test_system_user"
52 TEST_SYSTEM_GROUP = "test_system_group"
53 DEFAULT_ENDING = salt.utils.stringutils.to_bytes(os.linesep)
54 pytestmark = [
55     pytest.mark.skip_on_freebsd(reason="These tests timeout on FreeBSD"),
56 ]
57 def _test_managed_file_mode_keep_helper(testcase, local=False):
58     """
59     DRY helper function to run the same test with a local or remote path
60     """
61     name = testcase.tmp_dir / "scene33"
62     testcase.addCleanup(salt.utils.files.safe_rm, str(name))
63     grail_fs_path = os.path.join(RUNTIME_VARS.BASE_FILES, "grail", "scene33")
64     grail = "salt://grail/scene33" if not local else grail_fs_path
65     grail_fs_mode = int(testcase.run_function("file.get_mode", [grail_fs_path]), 8)
66     initial_mode = 0o770
67     new_mode_1 = 0o600
68     new_mode_2 = 0o644
69     ret = testcase.run_state(
70         "file.managed",
71         name=str(name),
72         mode=oct(initial_mode),
73         source=grail,
74     )
75     if IS_WINDOWS:
76         testcase.assertSaltFalseReturn(ret)
77         return
78     testcase.assertSaltTrueReturn(ret)
79     try:
80         os.chmod(grail_fs_path, new_mode_1)
81         ret = testcase.run_state(
82             "file.managed",
83             name=str(name),
84             mode="keep",
85             source=grail,
86         )
87         testcase.assertSaltTrueReturn(ret)
88         managed_mode = stat.S_IMODE(name.stat().st_mode)
89         testcase.assertEqual(oct(managed_mode), oct(new_mode_1))
90         os.chmod(grail_fs_path, new_mode_2)
91         ret = testcase.run_state(
92             "file.managed",
93             name=str(name),
94             mode="keep",
95             source=grail,
96         )
97         testcase.assertSaltTrueReturn(ret)
98         managed_mode = stat.S_IMODE(name.stat().st_mode)
99         testcase.assertEqual(oct(managed_mode), oct(new_mode_2))
100     finally:
101         os.chmod(grail_fs_path, grail_fs_mode)
102 @pytest.mark.windows_whitelisted
103 class FileTest(ModuleCase, SaltReturnAssertsMixin):
104     """
105     Validate the file state
106     """
107     @classmethod
108     def setUpClass(cls):
109         cls.tmp_dir = pathlib.Path(tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)).resolve()
110         def _reline(path, ending=DEFAULT_ENDING):
111             """
112             Normalize the line endings of a file.
113             """
114             with salt.utils.files.fopen(path, "rb") as fhr:
115                 lines = fhr.read().splitlines()
116             with salt.utils.atomicfile.atomic_open(path, "wb") as fhw:
117                 for line in lines:
118                     fhw.write(line + ending)
119         destpath = os.path.join(RUNTIME_VARS.BASE_FILES, "testappend", "firstif")
120         _reline(destpath)
121         destpath = os.path.join(RUNTIME_VARS.BASE_FILES, "testappend", "secondif")
122         _reline(destpath)
123     @classmethod
124     def tearDownClass(cls):
125         salt.utils.files.rm_rf(str(cls.tmp_dir))
126     def _delete_file(self, path):
127         try:
128             os.remove(path)
129         except OSError as exc:
130             if exc.errno != errno.ENOENT:
131                 log.error("Failed to remove %s: %s", path, exc)
132     def tearDown(self):
133         """
134         remove files created in previous tests
135         """
136         user = "salt"
137         if user in str(self.run_function("user.list_users")):
138             self.run_function("user.delete", [user])
139     def test_symlink(self):
140         """
141         file.symlink
142         """
143         name = self.tmp_dir / "symlink"
144         tgt = self.tmp_dir / "target"
145         if IS_WINDOWS and not tgt.is_dir():
146             tgt.mkdir()
147         if IS_WINDOWS and name.is_symlink():
148             name.unlink()
149         ret = self.run_state("file.symlink", name=str(name), target=str(tgt))
150         self.assertSaltTrueReturn(ret)
151     def test_test_symlink(self):
152         """
153         file.symlink test interface
154         """
155         name = self.tmp_dir / "symlink2"
156         tgt = self.tmp_dir / "target2"
157         ret = self.run_state("file.symlink", test=True, name=str(name), target=str(tgt))
158         self.assertSaltNoneReturn(ret)
159     def test_absent_file(self):
160         """
161         file.absent
162         """
163         name = self.tmp_dir / "file_to_kill"
164         name.write_text("killme")
165         ret = self.run_state("file.absent", name=str(name))
166         self.assertSaltTrueReturn(ret)
167         self.assertFalse(name.is_file())
168     def test_absent_dir(self):
169         """
170         file.absent
171         """
172         name = self.tmp_dir / "dir_to_kill"
173         name.mkdir(exist_ok=True)
174         ret = self.run_state("file.absent", name=str(name))
175         self.assertSaltTrueReturn(ret)
176         self.assertFalse(name.is_dir())
177     def test_absent_link(self):
178         """
179         file.absent
180         """
181         name = self.tmp_dir / "link_to_kill"
182         self.addCleanup(salt.utils.files.safe_rm, str(name))
183         tgt = self.tmp_dir / "link_to_kill.tgt"
184         self.addCleanup(salt.utils.files.safe_rm, str(tgt))
185         tgt.symlink_to(name, target_is_directory=IS_WINDOWS)
186         ret = self.run_state("file.absent", name=str(name))
187         self.assertSaltTrueReturn(ret)
188         self.assertFalse(name.exists())
189         self.assertFalse(name.is_symlink())
190     @with_tempfile()
191     def test_test_absent(self, name):
192         """
193         file.absent test interface
194         """
195         with salt.utils.files.fopen(name, "w+") as fp_:
196             fp_.write("killme")
197         ret = self.run_state("file.absent", test=True, name=name)
198         self.assertSaltNoneReturn(ret)
199         self.assertTrue(os.path.isfile(name))
200     def test_managed(self):
201         """
202         file.managed
203         """
204         name = self.tmp_dir / "grail_scene33"
205         self.addCleanup(salt.utils.files.safe_rm, str(name))
206         ret = self.run_state(
207             "file.managed", name=str(name), source="salt://grail/scene33"
208         )
209         src = pathlib.Path(RUNTIME_VARS.BASE_FILES) / "grail" / "scene33"
210         master_data = src.read_text()
211         minion_data = name.read_text()
212         self.assertEqual(master_data, minion_data)
213         self.assertSaltTrueReturn(ret)
214     def test_managed_file_mode(self):
215         """
216         file.managed, correct file permissions
217         """
218         desired_mode = 504  # 0770 octal
219         name = self.tmp_dir / "grail_scene33"
220         self.addCleanup(salt.utils.files.safe_rm, str(name))
221         ret = self.run_state(
222             "file.managed", name=str(name), mode="0770", source="salt://grail/scene33"
223         )
224         if IS_WINDOWS:
225             expected = "The 'mode' option is not supported on Windows"
226             self.assertEqual(ret[list(ret)[0]]["comment"], expected)
227             self.assertSaltFalseReturn(ret)
228             return
229         resulting_mode = stat.S_IMODE(name.stat().st_mode)
230         self.assertEqual(oct(desired_mode), oct(resulting_mode))
231         self.assertSaltTrueReturn(ret)
232     @skipIf(IS_WINDOWS, "Windows does not report any file modes. Skipping.")
233     def test_managed_file_mode_keep(self):
234         """
235         Test using "mode: keep" in a file.managed state
236         """
237         _test_managed_file_mode_keep_helper(self, local=False)
238     @skipIf(IS_WINDOWS, "Windows does not report any file modes. Skipping.")
239     def test_managed_file_mode_keep_local_source(self):
240         """
241         Test using "mode: keep" in a file.managed state, with a local file path
242         as the source.
243         """
244         _test_managed_file_mode_keep_helper(self, local=True)
245     def test_managed_file_mode_file_exists_replace(self):
246         """
247         file.managed, existing file with replace=True, change permissions
248         """
249         initial_mode = 504  # 0770 octal
250         desired_mode = 384  # 0600 octal
251         name = self.tmp_dir / "grail_scene33"
252         self.addCleanup(salt.utils.files.safe_rm, str(name))
253         ret = self.run_state(
254             "file.managed",
255             name=str(name),
256             mode=oct(initial_mode),
257             source="salt://grail/scene33",
258         )
259         if IS_WINDOWS:
260             expected = "The 'mode' option is not supported on Windows"
261             self.assertEqual(ret[list(ret)[0]]["comment"], expected)
262             self.assertSaltFalseReturn(ret)
263             return
264         resulting_mode = stat.S_IMODE(name.stat().st_mode)
265         self.assertEqual(oct(initial_mode), oct(resulting_mode))
266         ret = self.run_state(
267             "file.managed",
268             name=str(name),
269             replace=True,
270             mode=oct(desired_mode),
271             source="salt://grail/scene33",
272         )
273         resulting_mode = stat.S_IMODE(name.stat().st_mode)
274         self.assertEqual(oct(desired_mode), oct(resulting_mode))
275         self.assertSaltTrueReturn(ret)
276     def test_managed_file_mode_file_exists_noreplace(self):
277         """
278         file.managed, existing file with replace=False, change permissions
279         """
280         initial_mode = 504  # 0770 octal
281         desired_mode = 384  # 0600 octal
282         name = self.tmp_dir / "grail_scene33"
283         self.addCleanup(salt.utils.files.safe_rm, str(name))
284         ret = self.run_state(
285             "file.managed",
286             name=str(name),
287             replace=True,
288             mode=oct(initial_mode),
289             source="salt://grail/scene33",
290         )
291         if IS_WINDOWS:
292             expected = "The 'mode' option is not supported on Windows"
293             self.assertEqual(ret[list(ret)[0]]["comment"], expected)
294             self.assertSaltFalseReturn(ret)
295             return
296         ret = self.run_state(
297             "file.managed",
298             name=str(name),
299             replace=False,
300             mode=oct(desired_mode),
301             source="salt://grail/scene33",
302         )
303         resulting_mode = stat.S_IMODE(name.stat().st_mode)
304         self.assertEqual(oct(desired_mode), oct(resulting_mode))
305         self.assertSaltTrueReturn(ret)
306     def test_managed_file_with_grains_data(self):
307         """
308         Test to ensure we can render grains data into a managed
309         file.
310         """
311         grain_path = self.tmp_dir / "file-grain-test"
312         self.addCleanup(salt.utils.files.safe_rm, str(grain_path))
313         state_file = "file-grainget"
314         self.run_function(
315             "state.sls", [state_file], pillar={"grain_path": str(grain_path)}
316         )
317         self.assertTrue(grain_path.exists())
318         file_contents = grain_path.read_text().splitlines(True)
319         match = "^minion\n"
320         self.assertTrue(re.match(match, file_contents[0]))
321     def test_managed_file_with_pillardefault_sls(self):
322         """
323         Test to ensure when pillar data is not available
324         in sls file with pillar.get it uses the default
325         value.
326         """
327         file_pillar_def = os.path.join(RUNTIME_VARS.TMP, "filepillar-defaultvalue")
328         self.addCleanup(self._delete_file, file_pillar_def)
329         state_name = "file-pillardefaultget"
330         log.warning("File Path: %s", file_pillar_def)
331         ret = self.run_function("state.sls", [state_name])
332         self.assertSaltTrueReturn(ret)
333         check_file = self.run_function("file.file_exists", [file_pillar_def])
334         self.assertTrue(check_file)
335     @pytest.mark.skip_if_not_root
336     def test_managed_dir_mode(self):
337         """
338         Tests to ensure that file.managed creates directories with the
339         permissions requested with the dir_mode argument
340         """
341         desired_mode = 511  # 0777 in octal
342         name = self.tmp_dir / "a" / "managed_dir_mode_test_file"
343         self.addCleanup(salt.utils.files.safe_rm, str(name))
344         desired_owner = "nobody"
345         ret = self.run_state(
346             "file.managed",
347             name=str(name),
348             source="salt://grail/scene33",
349             mode=600,
350             makedirs=True,
351             user=desired_owner,
352             dir_mode=oct(desired_mode),  # 0777
353         )
354         if IS_WINDOWS:
355             expected = "The 'mode' option is not supported on Windows"
356             self.assertEqual(ret[list(ret)[0]]["comment"], expected)
357             self.assertSaltFalseReturn(ret)
358             return
359         resulting_mode = stat.S_IMODE(name.parent.stat().st_mode)
360         resulting_owner = pwd.getpwuid(name.parent.stat().st_uid).pw_name
361         self.assertEqual(oct(desired_mode), oct(resulting_mode))
362         self.assertSaltTrueReturn(ret)
363         self.assertEqual(desired_owner, resulting_owner)
364     def test_test_managed(self):
365         """
366         file.managed test interface
367         """
368         name = self.tmp_dir / "grail_not_not_scene33"
369         self.addCleanup(salt.utils.files.safe_rm, str(name))
370         ret = self.run_state(
371             "file.managed", test=True, name=str(name), source="salt://grail/scene33"
372         )
373         self.assertSaltNoneReturn(ret)
374         self.assertFalse(name.is_file())
375     def test_managed_show_changes_false(self):
376         """
377         file.managed test interface
378         """
379         name = self.tmp_dir / "grail_not_scene33"
380         self.addCleanup(salt.utils.files.safe_rm, str(name))
381         name.write_bytes(b"test_managed_show_changes_false\n")
382         ret = self.run_state(
383             "file.managed",
384             name=str(name),
385             source="salt://grail/scene33",
386             show_changes=False,
387         )
388         changes = next(iter(ret.values()))["changes"]
389         self.assertEqual("&lt;show_changes=False&gt;", changes["diff"])
390     def test_managed_show_changes_true(self):
391         """
392         file.managed test interface
393         """
394         name = self.tmp_dir / "grail_not_scene33"
395         self.addCleanup(salt.utils.files.safe_rm, str(name))
396         name.write_bytes(b"test_managed_show_changes_false\n")
397         ret = self.run_state(
398             "file.managed",
399             name=str(name),
400             source="salt://grail/scene33",
401         )
402         changes = next(iter(ret.values()))["changes"]
403         self.assertIn("diff", changes)
404     @skipIf(IS_WINDOWS, "Don't know how to fix for Windows")
405     def test_managed_escaped_file_path(self):
406         """
407         file.managed test that 'salt://|' protects unusual characters in file path
408         """
409         funny_file = salt.utils.files.mkstemp(
410             prefix="?f!le? n@=3&amp;", suffix=".file type"
411         )
412         funny_file_name = os.path.split(funny_file)[1]
413         funny_url = "salt://|" + funny_file_name
414         funny_url_path = os.path.join(RUNTIME_VARS.BASE_FILES, funny_file_name)
415         state_name = "funny_file"
416         state_file_name = state_name + ".sls"
417         state_file = os.path.join(RUNTIME_VARS.BASE_FILES, state_file_name)
418         state_key = "file_|-{0}_|-{0}_|-managed".format(funny_file)
419         self.addCleanup(os.remove, state_file)
420         self.addCleanup(os.remove, funny_file)
421         self.addCleanup(os.remove, funny_url_path)
422         with salt.utils.files.fopen(funny_url_path, "w"):
423             pass
424         with salt.utils.files.fopen(state_file, "w") as fp_:
425             fp_.write(
426                 textwrap.dedent(
427                     """\
428             {}:
429               file.managed:
430                 - source: {}
431                 - makedirs: True
432             """.format(
433                         funny_file, funny_url
434                     )
435                 )
436             )
437         ret = self.run_function("state.sls", [state_name])
438         self.assertTrue(ret[state_key]["result"])
439     def test_managed_contents(self):
440         """
441         test file.managed with contents that is a boolean, string, integer,
442         float, list, and dictionary
443         """
444         state_name = "file-FileTest-test_managed_contents"
445         state_filename = state_name + ".sls"
446         state_file = os.path.join(RUNTIME_VARS.BASE_FILES, state_filename)
447         managed_files = {}
448         state_keys = {}
449         for typ in ("bool", "str", "int", "float", "list", "dict"):
450             managed_files[typ] = salt.utils.files.mkstemp()
451             state_keys[typ] = "file_|-{} file_|-{}_|-managed".format(
452                 typ, managed_files[typ]
453             )
454         try:
455             with salt.utils.files.fopen(state_file, "w") as fd_:
456                 fd_.write(
457                     textwrap.dedent(
458                         """\
459                     bool file:
460                       file.managed:
461                         - name: {bool}
462                         - contents: True
463                     str file:
464                       file.managed:
465                         - name: {str}
466                         - contents: Salt was here.
467                     int file:
468                       file.managed:
469                         - name: {int}
470                         - contents: 340282366920938463463374607431768211456
471                     float file:
472                       file.managed:
473                         - name: {float}
474                         - contents: 1.7518e-45  # gravitational coupling constant
475                     list file:
476                       file.managed:
477                         - name: {list}
478                         - contents: [1, 1, 2, 3, 5, 8, 13]
479                     dict file:
480                       file.managed:
481                         - name: {dict}
482                         - contents:
483                             C: charge
484                             P: parity
485                             T: time
486                     """.format(
487                             **managed_files
488                         )
489                     )
490                 )
491             ret = self.run_function("state.sls", [state_name])
492             self.assertSaltTrueReturn(ret)
493             for typ in state_keys:
494                 self.assertTrue(ret[state_keys[typ]]["result"])
495                 self.assertIn("diff", ret[state_keys[typ]]["changes"])
496         finally:
497             if os.path.exists(state_file):
498                 os.remove(state_file)
499             for typ in managed_files:
500                 if os.path.exists(managed_files[typ]):
501                     os.remove(managed_files[typ])
502     def test_onchanges_any_recursive_error_issues_50811(self):
503         """
504         test that onchanges_any does not causes a recursive error
505         """
506         state_name = "onchanges_any_recursive_error"
507         state_filename = state_name + ".sls"
508         state_file = os.path.join(RUNTIME_VARS.BASE_FILES, state_filename)
509         try:
510             with salt.utils.files.fopen(state_file, "w") as fd_:
511                 fd_.write(
512                     textwrap.dedent(
513                         """\
514                     command-test:
515                       cmd.run:
516                           - name: ls
517                           - onchanges_any:
518                             - file: /tmp/an-unfollowed-file
519                     """
520                     )
521                 )
522             ret = self.run_function("state.sls", [state_name])
523             self.assertSaltFalseReturn(ret)
524         finally:
525             if os.path.exists(state_file):
526                 os.remove(state_file)
527     def test_prerequired_issues_55775(self):
528         """
529         Test that __prereqired__ is filter from file.replace
530         if __prereqired__ is not filter from file.replace an error will be raised
531         """
532         state_name = "Test_Issues_55775"
533         state_filename = state_name + ".sls"
534         state_file = os.path.join(RUNTIME_VARS.BASE_FILES, state_filename)
535         test_file = os.path.join(RUNTIME_VARS.BASE_FILES, "Issues_55775.txt")
536         try:
537             with salt.utils.files.fopen(state_file, "w") as fd_:
538                 fd_.write(
539                     textwrap.dedent(
540                         """\
541                     /tmp/bug.txt:
542                       file.managed:
543                         - name: {0}
544                         - contents:
545                           - foo
546                     file.replace:
547                       file.replace:
548                         - name: {0}
549                         - pattern: 'foo'
550                         - repl: 'bar'
551                         - prereq:
552                           - test no changes
553                           - test changes
554                     test no changes:
555                       test.succeed_without_changes:
556                         - name: no changes
557                     test changes:
558                       test.succeed_with_changes:
559                         - name: changes
560                         - require:
561                           - test: test no changes
562                     """.format(
563                             test_file
564                         )
565                     )
566                 )
567             ret = self.run_function("state.sls", [state_name])
568             self.assertSaltTrueReturn(ret)
569         finally:
570             for fpath in (state_file, test_file):
571                 if os.path.exists(fpath):
572                     os.remove(fpath)
573     def test_managed_contents_with_contents_newline(self):
574         """
575         test file.managed with contents by using the default content_newline
576         flag.
577         """
578         contents = "test_managed_contents_with_newline_one"
579         name = self.tmp_dir / "foo"
580         self.addCleanup(salt.utils.files.safe_rm, str(name))
581         self.run_state(
582             "file.managed", name=str(name), contents=contents, contents_newline=True
583         )
584         last_line = name.read_text()
585         self.assertEqual((contents + "\n"), last_line)
586     def test_managed_contents_with_contents_newline_false(self):
587         """
588         test file.managed with contents by using the non default content_newline
589         flag.
590         """
591         contents = "test_managed_contents_with_newline_one"
592         name = self.tmp_dir / "bar"
593         self.addCleanup(salt.utils.files.safe_rm, str(name))
594         self.run_state(
595             "file.managed", name=str(name), contents=contents, contents_newline=False
596         )
597         last_line = name.read_text()
598         self.assertEqual(contents, last_line)
599     def test_managed_multiline_contents_with_contents_newline(self):
600         """
601         test file.managed with contents by using the non default content_newline
602         flag.
603         """
604         contents = "this is a cookie\nthis is another cookie"
605         name = self.tmp_dir / "bar"
606         self.addCleanup(salt.utils.files.safe_rm, str(name))
607         self.run_state(
608             "file.managed", name=str(name), contents=contents, contents_newline=True
609         )
610         last_line = name.read_text()
611         self.assertEqual((contents + "\n"), last_line)
612     def test_managed_multiline_contents_with_contents_newline_false(self):
613         """
614         test file.managed with contents by using the non default content_newline
615         flag.
616         """
617         contents = "this is a cookie\nthis is another cookie"
618         name = self.tmp_dir / "bar"
619         self.addCleanup(salt.utils.files.safe_rm, str(name))
620         self.run_state(
621             "file.managed", name=str(name), contents=contents, contents_newline=False
622         )
623         last_line = name.read_text()
624         self.assertEqual(contents, last_line)
625     @pytest.mark.skip_if_not_root
626     @skipIf(IS_WINDOWS, 'Windows does not support "mode" kwarg. Skipping.')
627     @skipIf(not salt.utils.path.which("visudo"), "sudo is missing")
628     def test_managed_check_cmd(self):
629         """
630         Test file.managed passing a basic check_cmd kwarg. See Issue #38111.
631         """
632         r_group = "root"
633         if salt.utils.platform.is_darwin() or salt.utils.platform.is_freebsd():
634             r_group = "wheel"
635         name = self.tmp_dir / "sudoers"
636         self.addCleanup(salt.utils.files.safe_rm, str(name))
637         ret = self.run_state(
638             "file.managed",
639             name=str(name),
640             user="root",
641             group=r_group,
642             mode=440,
643             check_cmd="visudo -c -s -f",
644         )
645         self.assertSaltTrueReturn(ret)
646         self.assertInSaltComment("Empty file", ret)
647         self.assertEqual(
648             ret["file_|-{0}_|-{0}_|-managed".format(name)]["changes"],
649             {"new": "file {} created".format(name), "mode": "0440"},
650         )
651     def test_managed_local_source_with_source_hash(self):
652         """
653         Make sure that we enforce the source_hash even with local files
654         """
655         name = self.tmp_dir / "local_source_with_source_hash"
656         self.addCleanup(salt.utils.files.safe_rm, str(name))
657         local_path = os.path.join(RUNTIME_VARS.BASE_FILES, "grail", "scene33")
658         actual_hash = "567fd840bf1548edc35c48eb66cdd78bfdfcccff"
659         if IS_WINDOWS:
660             actual_hash = "f658a0ec121d9c17088795afcc6ff3c43cb9842a"
661         bad_hash = actual_hash[::-1]
662         def remove_file():
663             try:
664                 os.remove(str(name))
665             except OSError as exc:
666                 if exc.errno != errno.ENOENT:
667                     raise
668         def do_test(clean=False):
669             for proto in ("file://", ""):
670                 source = proto + local_path
671                 log.debug("Trying source %s", source)
672                 try:
673                     ret = self.run_state(
674                         "file.managed",
675                         name=str(name),
676                         source=source,
677                         source_hash="sha1={}".format(bad_hash),
678                     )
679                     self.assertSaltFalseReturn(ret)
680                     ret = ret[next(iter(ret))]
681                     self.assertFalse(ret["changes"])
682                     self.assertIn("does not match actual checksum", ret["comment"])
683                     ret = self.run_state(
684                         "file.managed",
685                         name=str(name),
686                         source=source,
687                         source_hash="sha1={}".format(actual_hash),
688                     )
689                     self.assertSaltTrueReturn(ret)
690                 finally:
691                     if clean:
692                         remove_file()
693         remove_file()
694         log.debug("Trying with nonexistant destination file")
695         do_test()
696         log.debug("Trying with destination file already present")
697         name.write_text("")
698         try:
699             do_test(clean=False)
700         finally:
701             remove_file()
702     def test_managed_local_source_does_not_exist(self):
703         """
704         Make sure that we exit gracefully when a local source doesn't exist
705         """
706         name = self.tmp_dir / "local_source_does_not_exist"
707         self.addCleanup(salt.utils.files.safe_rm, str(name))
708         local_path = os.path.join(RUNTIME_VARS.BASE_FILES, "grail", "scene99")
709         for proto in ("file://", ""):
710             source = proto + local_path
711             log.debug("Trying source %s", source)
712             ret = self.run_state("file.managed", name=str(name), source=source)
713             self.assertSaltFalseReturn(ret)
714             ret = ret[next(iter(ret))]
715             self.assertFalse(ret["changes"])
716             self.assertIn("does not exist", ret["comment"])
717     def test_managed_unicode_jinja_with_tojson_filter(self):
718         """
719         Using {{ varname }} with a list or dictionary which contains unicode
720         types on Python 2 will result in Jinja rendering the "u" prefix on each
721         string. This tests that using the "tojson" jinja filter will dump them
722         to a format which can be successfully loaded by our YAML loader.
723         The two lines that should end up being rendered are meant to test two
724         issues that would trip up PyYAML if the "tojson" filter were not used:
725         1. A unicode string type would be loaded as a unicode literal with the
726            leading "u" as well as the quotes, rather than simply being loaded
727            as the proper unicode type which matches the content of the string
728            literal. In other words, u'foo' would be loaded literally as
729            u"u'foo'". This test includes actual non-ascii unicode in one of the
730            strings to confirm that this also handles these international
731            characters properly.
732         2. Any unicode string type (such as a URL) which contains a colon would
733            cause a ScannerError in PyYAML, as it would be assumed to delimit a
734            mapping node.
735         Dumping the data structure to JSON using the "tojson" jinja filter
736         should produce an inline data structure which is valid YAML and will be
737         loaded properly by our YAML loader.
738         """
739         test_file = self.tmp_dir / "test-tojson.txt"
740         self.addCleanup(salt.utils.files.safe_rm, str(test_file))
741         ret = self.run_function(
742             "state.apply", mods="tojson", pillar={"tojson-file": str(test_file)}
743         )
744         ret = ret[next(iter(ret))]
745         assert ret["result"], ret
746         managed = salt.utils.stringutils.to_unicode(test_file.read_bytes())
747         expected = dedent(
748             """\
749             Die Webseite ist https://saltproject.io.
750             Der Zucker ist süß.
751             """
752         )
753         assert managed == expected, "{!r} != {!r}".format(managed, expected)
754     def test_managed_source_hash_indifferent_case(self):
755         """
756         Test passing a source_hash as an uppercase hash.
757         This is a regression test for Issue #38914 and Issue #48230 (test=true use).
758         """
759         name = self.tmp_dir / "source_hash_indifferent_case"
760         self.addCleanup(salt.utils.files.safe_rm, str(name))
761         state_name = "file_|-{0}_|-{0}_|-managed".format(name)
762         local_path = os.path.join(RUNTIME_VARS.BASE_FILES, "hello_world.txt")
763         actual_hash = "c98c24b677eff44860afea6f493bbaec5bb1c4cbb209c6fc2bbb47f66ff2ad31"
764         if IS_WINDOWS:
765             actual_hash = (
766                 "92b772380a3f8e27a93e57e6deeca6c01da07f5aadce78bb2fbb20de10a66925"
767             )
768         uppercase_hash = actual_hash.upper()
769         self.run_state(
770             "file.managed", name=str(name), source=local_path, source_hash=actual_hash
771         )
772         ret = self.run_state(
773             "file.managed",
774             name=str(name),
775             source=local_path,
776             source_hash=uppercase_hash,
777         )
778         assert ret[state_name]["result"] is True
779         assert ret[state_name]["changes"] == {}
780         ret = self.run_state(
781             "file.managed",
782             name=str(name),
783             source=local_path,
784             source_hash=uppercase_hash,
785             test=True,
786         )
787         assert ret[state_name]["result"] is True
788         assert ret[state_name]["changes"] == {}
789     @with_tempfile(create=False)
790     def test_managed_latin1_diff(self, name):
791         """
792         Tests that latin-1 file contents are represented properly in the diff
793         """
794         ret = self.run_state(
795             "file.managed", name=name, source="salt://issue-48777/old.html"
796         )
797         ret = ret[next(iter(ret))]
798         assert ret["result"] is True, ret
799         ret = self.run_state(
800             "file.managed", name=name, source="salt://issue-48777/new.html"
801         )
802         ret = ret[next(iter(ret))]
803         assert ret["result"] is True, ret
804         diff_lines = ret["changes"]["diff"].split(os.linesep)
805         assert "+räksmörgås" in diff_lines, diff_lines
806     @with_tempfile()
807     def test_managed_keep_source_false_salt(self, name):
808         """
809         This test ensures that we properly clean the cached file if keep_source
810         is set to False, for source files using a salt:// URL
811         """
812         source = "salt://grail/scene33"
813         saltenv = "base"
814         ret = self.run_state(
815             "file.managed", name=name, source=source, saltenv=saltenv, keep_source=False
816         )
817         ret = ret[next(iter(ret))]
818         assert ret["result"] is True
819         result = self.run_function("cp.is_cached", [source, saltenv])
820         assert result == "", "File is still cached at {}".format(result)
821     @with_tempfile(create=False)
822     @with_tempfile(create=False)
823     def test_file_managed_onchanges(self, file1, file2):
824         """
825         Test file.managed state with onchanges
826         """
827         pillar = {
828             "file1": file1,
829             "file2": file2,
830             "source": "salt://testfile",
831             "req": "onchanges",
832         }
833         self.run_state("file.managed", name=pillar["file2"], source=pillar["source"])
834         ret = self.repack_state_returns(
835             self.run_function(
836                 "state.apply",
837                 mods="onchanges_prereq",
838                 pillar=pillar,
839                 test=True,
840             )
841         )
842         assert ret["one"]["result"] is None, ret["one"]["result"]
843         assert ret["three"]["result"] is True, ret["three"]["result"]
844         assert ret["one"]["changes"]
845         assert not ret["three"]["changes"], ret["three"]["changes"]
846         assert ret["two"]["comment"] == "Success!", ret["two"]["comment"]
847         assert (
848             ret["four"]["comment"]
849             == "State was not run because none of the onchanges reqs changed"
850         ), ret["four"]["comment"]
851     @with_tempfile(create=False)
852     @with_tempfile(create=False)
853     def test_file_managed_prereq(self, file1, file2):
854         """
855         Test file.managed state with prereq
856         """
857         pillar = {
858             "file1": file1,
859             "file2": file2,
860             "source": "salt://testfile",
861             "req": "prereq",
862         }
863         self.run_state("file.managed", name=pillar["file2"], source=pillar["source"])
864         ret = self.repack_state_returns(
865             self.run_function(
866                 "state.apply",
867                 mods="onchanges_prereq",
868                 pillar=pillar,
869                 test=True,
870             )
871         )
872         assert ret["one"]["result"] is None, ret["one"]["result"]
873         assert ret["three"]["result"] is True, ret["three"]["result"]
874         assert ret["one"]["changes"]
875         assert not ret["three"]["changes"], ret["three"]["changes"]
876         assert ret["two"]["comment"] == "Success!", ret["two"]["comment"]
877         assert ret["four"]["comment"] == "No changes detected", ret["four"]["comment"]
878     def test_directory(self):
879         """
880         file.directory
881         """
882         name = self.tmp_dir / "a_new_dir"
883         self.addCleanup(salt.utils.files.rm_rf, str(name))
884         ret = self.run_state("file.directory", name=str(name))
885         self.assertSaltTrueReturn(ret)
886         self.assertTrue(name.is_dir())
887     def test_directory_symlink_dry_run(self):
888         """
889         Ensure that symlinks are followed when file.directory is run with
890         test=True
891         """
892         tmp_dir = self.tmp_dir / "pgdata"
893         self.addCleanup(salt.utils.files.rm_rf, str(tmp_dir))
894         sym_dir = self.tmp_dir / "pg_data"
895         self.addCleanup(salt.utils.files.safe_rm, str(sym_dir))
896         tmp_dir.mkdir(0o0700)
897         sym_dir.symlink_to(tmp_dir, target_is_directory=IS_WINDOWS)
898         if IS_WINDOWS:
899             ret = self.run_state(
900                 "file.directory",
901                 test=True,
902                 name=str(sym_dir),
903                 follow_symlinks=True,
904                 win_owner="Administrators",
905             )
906         else:
907             ret = self.run_state(
908                 "file.directory",
909                 test=True,
910                 name=str(sym_dir),
911                 follow_symlinks=True,
912                 mode=700,
913             )
914         self.assertSaltTrueReturn(ret)
915     @requires_system_grains
916     @pytest.mark.skip_if_not_root
917     @skipIf(IS_WINDOWS, "Mode not available in Windows")
918     def test_directory_max_depth(self, grains):
919         """
920         file.directory
921         Test the max_depth option by iteratively increasing the depth and
922         checking that no changes deeper than max_depth have been attempted
923         """
924         def _get_oct_mode(name):
925             """
926             Return a string octal representation of the permissions for name
927             """
928             return salt.utils.files.normalize_mode(oct(os.stat(name).st_mode &amp; 0o777))
929         top = os.path.join(RUNTIME_VARS.TMP, "top_dir")
930         self.addCleanup(salt.utils.files.rm_rf, top)
931         sub = os.path.join(top, "sub_dir")
932         subsub = os.path.join(sub, "sub_sub_dir")
933         dirs = [top, sub, subsub]
934         initial_mode = "0111"
935         changed_mode = "0555"
936         if grains["os"] in ("VMware Photon OS",):
937             initial_modes = {
938                 0: {sub: "0750", subsub: "0110"},
939                 1: {sub: "0110", subsub: "0110"},
940                 2: {sub: "0110", subsub: "0110"},
941             }
942         else:
943             initial_modes = {
944                 0: {sub: "0755", subsub: "0111"},
945                 1: {sub: "0111", subsub: "0111"},
946                 2: {sub: "0111", subsub: "0111"},
947             }
948         if not os.path.isdir(subsub):
949             os.makedirs(subsub, int(initial_mode, 8))
950         for depth in range(0, 3):
951             ret = self.run_state(
952                 "file.directory",
953                 name=top,
954                 max_depth=depth,
955                 dir_mode=changed_mode,
956                 recurse=["mode"],
957             )
958             self.assertSaltTrueReturn(ret)
959             for changed_dir in dirs[0 : depth + 1]:
960                 self.assertEqual(changed_mode, _get_oct_mode(changed_dir))
961             for untouched_dir in dirs[depth + 1 :]:
962                 if sys.version_info &gt;= (3, 7):
963                     _mode = initial_modes[depth][untouched_dir]
964                     self.assertEqual(_mode, _get_oct_mode(untouched_dir))
965                 else:
966                     self.assertEqual(initial_mode, _get_oct_mode(untouched_dir))
967     def test_test_directory(self):
968         """
969         file.directory
970         """
971         name = self.tmp_dir / "a_not_dir"
972         self.addCleanup(shutil.rmtree, str(name), ignore_errors=True)
973         ret = self.run_state("file.directory", test=True, name=str(name))
974         self.assertSaltNoneReturn(ret)
975         self.assertFalse(name.is_dir())
976     @with_tempdir()
977     def test_directory_clean(self, base_dir):
978         """
979         file.directory with clean=True
980         """
981         name = os.path.join(base_dir, "directory_clean_dir")
982         os.mkdir(name)
983         strayfile = os.path.join(name, "strayfile")
984         with salt.utils.files.fopen(strayfile, "w"):
985             pass
986         straydir = os.path.join(name, "straydir")
987         if not os.path.isdir(straydir):
988             os.makedirs(straydir)
989         with salt.utils.files.fopen(os.path.join(straydir, "strayfile2"), "w"):
990             pass
991         ret = self.run_state("file.directory", name=name, clean=True)
992         self.assertSaltTrueReturn(ret)
993         self.assertFalse(os.path.exists(strayfile))
994         self.assertFalse(os.path.exists(straydir))
995         self.assertTrue(os.path.isdir(name))
996     def test_directory_is_idempotent(self):
997         """
998         Ensure the file.directory state produces no changes when rerun.
999         """
1000         name = self.tmp_dir / "a_dir_twice"
1001         self.addCleanup(salt.utils.files.rm_rf, str(name))
1002         if IS_WINDOWS:
1003             username = os.environ.get("USERNAME", "Administrators")
1004             domain = os.environ.get("USERDOMAIN", "")
1005             fullname = "{}\\{}".format(domain, username)
1006             ret = self.run_state("file.directory", name=str(name), win_owner=fullname)
1007         else:
1008             ret = self.run_state("file.directory", name=str(name))
1009         self.assertSaltTrueReturn(ret)
1010         if IS_WINDOWS:
1011             ret = self.run_state("file.directory", name=str(name), win_owner=username)
1012         else:
1013             ret = self.run_state("file.directory", name=str(name))
1014         self.assertSaltTrueReturn(ret)
1015         self.assertSaltStateChangesEqual(ret, {})
1016     @with_tempdir()
1017     def test_directory_clean_exclude(self, base_dir):
1018         """
1019         file.directory with clean=True and exclude_pat set
1020         """
1021         name = os.path.join(base_dir, "directory_clean_dir")
1022         if not os.path.isdir(name):
1023             os.makedirs(name)
1024         strayfile = os.path.join(name, "strayfile")
1025         with salt.utils.files.fopen(strayfile, "w"):
1026             pass
1027         straydir = os.path.join(name, "straydir")
1028         if not os.path.isdir(straydir):
1029             os.makedirs(straydir)
1030         strayfile2 = os.path.join(straydir, "strayfile2")
1031         with salt.utils.files.fopen(strayfile2, "w"):
1032             pass
1033         keepfile = os.path.join(straydir, "keepfile")
1034         with salt.utils.files.fopen(keepfile, "w"):
1035             pass
1036         exclude_pat = "E@^straydir(|/keepfile)$"
1037         if IS_WINDOWS:
1038             exclude_pat = "E@^straydir(|\\\\keepfile)$"
1039         ret = self.run_state(
1040             "file.directory", name=name, clean=True, exclude_pat=exclude_pat
1041         )
1042         self.assertSaltTrueReturn(ret)
1043         self.assertFalse(os.path.exists(strayfile))
1044         self.assertFalse(os.path.exists(strayfile2))
1045         self.assertTrue(os.path.exists(keepfile))
1046     @skipIf(IS_WINDOWS, "Skip on windows")
1047     @with_tempdir()
1048     def test_test_directory_clean_exclude(self, base_dir):
1049         """
1050         file.directory with test=True, clean=True and exclude_pat set
1051         Skipped on windows because clean and exclude_pat not supported by
1052         salt.sates.file._check_directory_win
1053         """
1054         name = os.path.join(base_dir, "directory_clean_dir")
1055         os.mkdir(name)
1056         strayfile = os.path.join(name, "strayfile")
1057         with salt.utils.files.fopen(strayfile, "w"):
1058             pass
1059         straydir = os.path.join(name, "straydir")
1060         if not os.path.isdir(straydir):
1061             os.makedirs(straydir)
1062         strayfile2 = os.path.join(straydir, "strayfile2")
1063         with salt.utils.files.fopen(strayfile2, "w"):
1064             pass
1065         keepfile = os.path.join(straydir, "keepfile")
1066         with salt.utils.files.fopen(keepfile, "w"):
1067             pass
1068         exclude_pat = "E@^straydir(|/keepfile)$"
1069         if IS_WINDOWS:
1070             exclude_pat = "E@^straydir(|\\\\keepfile)$"
1071         ret = self.run_state(
1072             "file.directory", test=True, name=name, clean=True, exclude_pat=exclude_pat
1073         )
1074         comment = next(iter(ret.values()))["comment"]
1075         self.assertSaltNoneReturn(ret)
1076         self.assertTrue(os.path.exists(strayfile))
1077         self.assertTrue(os.path.exists(strayfile2))
1078         self.assertTrue(os.path.exists(keepfile))
1079         self.assertIn(strayfile, comment)
1080         self.assertIn(strayfile2, comment)
1081         self.assertNotIn(keepfile, comment)
1082     @with_tempdir()
1083     def test_directory_clean_require_in(self, name):
1084         """
1085         file.directory test with clean=True and require_in file
1086         """
1087         state_name = "file-FileTest-test_directory_clean_require_in"
1088         state_filename = state_name + ".sls"
1089         state_file = os.path.join(RUNTIME_VARS.BASE_FILES, state_filename)
1090         wrong_file = os.path.join(name, "wrong")
1091         with salt.utils.files.fopen(wrong_file, "w") as fp:
1092             fp.write("foo")
1093         good_file = os.path.join(name, "bar")
1094         with salt.utils.files.fopen(state_file, "w") as fp:
1095             self.addCleanup(salt.utils.files.safe_rm, state_file)
1096             fp.write(
1097                 textwrap.dedent(
1098                     """\
1099                 some_dir:
1100                   file.directory:
1101                     - name: {name}
1102                     - clean: true
1103                 {good_file}:
1104                   file.managed:
1105                     - require_in:
1106                       - file: some_dir
1107                 """.format(
1108                         name=name, good_file=good_file
1109                     )
1110                 )
1111             )
1112         ret = self.run_function("state.sls", [state_name])
1113         self.assertTrue(os.path.exists(good_file))
1114         self.assertFalse(os.path.exists(wrong_file))
1115     @with_tempdir()
1116     def test_directory_clean_require_in_with_id(self, name):
1117         """
1118         file.directory test with clean=True and require_in file with an ID
1119         different from the file name
1120         """
1121         state_name = "file-FileTest-test_directory_clean_require_in_with_id"
1122         state_filename = state_name + ".sls"
1123         state_file = os.path.join(RUNTIME_VARS.BASE_FILES, state_filename)
1124         wrong_file = os.path.join(name, "wrong")
1125         with salt.utils.files.fopen(wrong_file, "w") as fp:
1126             fp.write("foo")
1127         good_file = os.path.join(name, "bar")
1128         with salt.utils.files.fopen(state_file, "w") as fp:
1129             self.addCleanup(salt.utils.files.safe_rm, state_file)
1130             fp.write(
1131                 textwrap.dedent(
1132                     """\
1133                 some_dir:
1134                   file.directory:
1135                     - name: {name}
1136                     - clean: true
1137                 some_file:
1138                   file.managed:
1139                     - name: {good_file}
1140                     - require_in:
1141                       - file: some_dir
1142                 """.format(
1143                         name=name, good_file=good_file
1144                     )
1145                 )
1146             )
1147         ret = self.run_function("state.sls", [state_name])
1148         self.assertTrue(os.path.exists(good_file))
1149         self.assertFalse(os.path.exists(wrong_file))
1150     @skipIf(
1151         salt.utils.platform.is_darwin(),
1152         "WAR ROOM TEMPORARY SKIP, Test is flaky on macosx",
1153     )
1154     @with_tempdir()
1155     def test_directory_clean_require_with_name(self, name):
1156         """
1157         file.directory test with clean=True and require with a file state
1158         relatively to the state's name, not its ID.
1159         """
1160         state_name = "file-FileTest-test_directory_clean_require_in_with_id"
1161         state_filename = state_name + ".sls"
1162         state_file = os.path.join(RUNTIME_VARS.BASE_FILES, state_filename)
1163         wrong_file = os.path.join(name, "wrong")
1164         with salt.utils.files.fopen(wrong_file, "w") as fp:
1165             fp.write("foo")
1166         good_file = os.path.join(name, "bar")
1167         with salt.utils.files.fopen(state_file, "w") as fp:
1168             self.addCleanup(salt.utils.files.safe_rm, state_file)
1169             fp.write(
1170                 textwrap.dedent(
1171                     """\
1172                 some_dir:
1173                   file.directory:
1174                     - name: {name}
1175                     - clean: true
1176                     - require:
1177                       - file: {good_file}
1178                 some_file:
1179                   file.managed:
1180                     - name: {good_file}
1181                 """.format(
1182                         name=name, good_file=good_file
1183                     )
1184                 )
1185             )
1186         ret = self.run_function("state.sls", [state_name])
1187         self.assertTrue(os.path.exists(good_file))
1188         self.assertFalse(os.path.exists(wrong_file))
1189     def test_directory_broken_symlink(self):
1190         """
1191         Ensure that file.directory works even if a directory
1192         contains broken symbolic link
1193         """
1194         tmp_dir = self.tmp_dir / "foo"
1195         tmp_dir.mkdir(0o700)
1196         self.addCleanup(salt.utils.files.rm_rf, str(tmp_dir))
1197         null_file = tmp_dir / "null"
1198         broken_link = tmp_dir / "broken"
1199         broken_link.symlink_to(null_file)
1200         if IS_WINDOWS:
1201             ret = self.run_state(
1202                 "file.directory",
1203                 name=str(tmp_dir),
1204                 recurse=["mode"],
1205                 follow_symlinks=True,
1206                 win_owner="Administrators",
1207             )
1208         else:
1209             ret = self.run_state(
1210                 "file.directory",
1211                 name=str(tmp_dir),
1212                 recurse=["mode"],
1213                 file_mode=644,
1214                 dir_mode=755,
1215             )
1216         self.assertSaltTrueReturn(ret)
1217     @with_tempdir(create=False)
1218     def test_recurse(self, name):
1219         """
1220         file.recurse
1221         """
1222         ret = self.run_state("file.recurse", name=name, source="salt://grail")
1223         self.assertSaltTrueReturn(ret)
1224         self.assertTrue(os.path.isfile(os.path.join(name, "36", "scene")))
1225     @with_tempdir(create=False)
1226     @with_tempdir(create=False)
1227     def test_recurse_specific_env(self, dir1, dir2):
1228         """
1229         file.recurse passing __env__
1230         """
1231         ret = self.run_state(
1232             "file.recurse", name=dir1, source="salt://holy", __env__="prod"
1233         )
1234         self.assertSaltTrueReturn(ret)
1235         self.assertTrue(os.path.isfile(os.path.join(dir1, "32", "scene")))
1236         ret = self.run_state(
1237             "file.recurse", name=dir2, source="salt://holy", saltenv="prod"
1238         )
1239         self.assertSaltTrueReturn(ret)
1240         self.assertTrue(os.path.isfile(os.path.join(dir2, "32", "scene")))
1241     @with_tempdir(create=False)
1242     @with_tempdir(create=False)
1243     def test_recurse_specific_env_in_url(self, dir1, dir2):
1244         """
1245         file.recurse passing __env__
1246         """
1247         ret = self.run_state(
1248             "file.recurse", name=dir1, source="salt://holy?saltenv=prod"
1249         )
1250         self.assertSaltTrueReturn(ret)
1251         self.assertTrue(os.path.isfile(os.path.join(dir1, "32", "scene")))
1252         ret = self.run_state(
1253             "file.recurse", name=dir2, source="salt://holy?saltenv=prod"
1254         )
1255         self.assertSaltTrueReturn(ret)
1256         self.assertTrue(os.path.isfile(os.path.join(dir2, "32", "scene")))
1257     @with_tempdir(create=False)
1258     def test_test_recurse(self, name):
1259         """
1260         file.recurse test interface
1261         """
1262         ret = self.run_state(
1263             "file.recurse",
1264             test=True,
1265             name=name,
1266             source="salt://grail",
1267         )
1268         self.assertSaltNoneReturn(ret)
1269         self.assertFalse(os.path.isfile(os.path.join(name, "36", "scene")))
1270         self.assertFalse(os.path.exists(name))
1271     @with_tempdir(create=False)
1272     @with_tempdir(create=False)
1273     def test_test_recurse_specific_env(self, dir1, dir2):
1274         """
1275         file.recurse test interface
1276         """
1277         ret = self.run_state(
1278             "file.recurse", test=True, name=dir1, source="salt://holy", __env__="prod"
1279         )
1280         self.assertSaltNoneReturn(ret)
1281         self.assertFalse(os.path.isfile(os.path.join(dir1, "32", "scene")))
1282         self.assertFalse(os.path.exists(dir1))
1283         ret = self.run_state(
1284             "file.recurse", test=True, name=dir2, source="salt://holy", saltenv="prod"
1285         )
1286         self.assertSaltNoneReturn(ret)
1287         self.assertFalse(os.path.isfile(os.path.join(dir2, "32", "scene")))
1288         self.assertFalse(os.path.exists(dir2))
1289     @with_tempdir(create=False)
1290     def test_recurse_template(self, name):
1291         """
1292         file.recurse with jinja template enabled
1293         """
1294         _ts = "TEMPLATE TEST STRING"
1295         ret = self.run_state(
1296             "file.recurse",
1297             name=name,
1298             source="salt://grail",
1299             template="jinja",
1300             defaults={"spam": _ts},
1301         )
1302         self.assertSaltTrueReturn(ret)
1303         with salt.utils.files.fopen(os.path.join(name, "scene33"), "r") as fp_:
1304             contents = fp_.read()
1305         self.assertIn(_ts, contents)
1306     @with_tempdir()
1307     def test_recurse_clean(self, name):
1308         """
1309         file.recurse with clean=True
1310         """
1311         strayfile = os.path.join(name, "strayfile")
1312         with salt.utils.files.fopen(strayfile, "w"):
1313             pass
1314         with salt.utils.files.fopen(os.path.join(name, "36"), "w"):
1315             pass
1316         os.makedirs(os.path.join(name, "scene33"))
1317         ret = self.run_state(
1318             "file.recurse", name=name, source="salt://grail", clean=True
1319         )
1320         self.assertSaltTrueReturn(ret)
1321         self.assertFalse(os.path.exists(strayfile))
1322         self.assertTrue(os.path.isfile(os.path.join(name, "36", "scene")))
1323         self.assertTrue(os.path.isfile(os.path.join(name, "scene33")))
1324     @with_tempdir()
1325     def test_recurse_clean_specific_env(self, name):
1326         """
1327         file.recurse with clean=True and __env__=prod
1328         """
1329         strayfile = os.path.join(name, "strayfile")
1330         with salt.utils.files.fopen(strayfile, "w"):
1331             pass
1332         with salt.utils.files.fopen(os.path.join(name, "32"), "w"):
1333             pass
1334         os.makedirs(os.path.join(name, "scene34"))
1335         ret = self.run_state(
1336             "file.recurse", name=name, source="salt://holy", clean=True, __env__="prod"
1337         )
1338         self.assertSaltTrueReturn(ret)
1339         self.assertFalse(os.path.exists(strayfile))
1340         self.assertTrue(os.path.isfile(os.path.join(name, "32", "scene")))
1341         self.assertTrue(os.path.isfile(os.path.join(name, "scene34")))
1342     @skipIf(IS_WINDOWS, "Skip on windows")
1343     @with_tempdir()
1344     def test_recurse_issue_34945(self, base_dir):
1345         """
1346         This tests the case where the source dir for the file.recurse state
1347         does not contain any files (only subdirectories), and the dir_mode is
1348         being managed. For a long time, this corner case resulted in the top
1349         level of the destination directory being created with the wrong initial
1350         permissions, a problem that would be corrected later on in the
1351         file.recurse state via running state.directory. However, the
1352         file.directory state only gets called when there are files to be
1353         managed in that directory, and when the source directory contains only
1354         subdirectories, the incorrectly-set initial perms would not be
1355         repaired.
1356         This was fixed in https://github.com/saltstack/salt/pull/35309
1357         Skipped on windows because dir_mode is not supported.
1358         """
1359         dir_mode = "2775"
1360         issue_dir = "issue-34945"
1361         name = os.path.join(base_dir, issue_dir)
1362         ret = self.run_state(
1363             "file.recurse", name=name, source="salt://" + issue_dir, dir_mode=dir_mode
1364         )
1365         self.assertSaltTrueReturn(ret)
1366         actual_dir_mode = oct(stat.S_IMODE(os.stat(name).st_mode))[-4:]
1367         self.assertEqual(dir_mode, actual_dir_mode)
1368     @with_tempdir(create=False)
1369     def test_recurse_issue_40578(self, name):
1370         """
1371         This ensures that the state doesn't raise an exception when it
1372         encounters a file with a unicode filename in the process of invoking
1373         file.source_list.
1374         """
1375         ret = self.run_state("file.recurse", name=name, source="salt://соль")
1376         self.assertSaltTrueReturn(ret)
1377         files = salt.utils.data.decode(os.listdir(name), normalize=True)
1378         self.assertEqual(
1379             sorted(files),
1380             sorted(["foo.txt", "спам.txt", "яйца.txt"]),
1381         )
1382     @with_tempfile()
1383     def test_replace(self, name):
1384         """
1385         file.replace
1386         """
1387         with salt.utils.files.fopen(name, "w+") as fp_:
1388             fp_.write("change_me")
1389         ret = self.run_state(
1390             "file.replace", name=name, pattern="change", repl="salt", backup=False
1391         )
1392         with salt.utils.files.fopen(name, "r") as fp_:
1393             self.assertIn("salt", fp_.read())
1394         self.assertSaltTrueReturn(ret)
1395     @with_tempdir()
1396     def test_replace_issue_18612(self, base_dir):
1397         """
1398         Test the (mis-)behaviour of file.replace as described in #18612:
1399         Using 'prepend_if_not_found' or 'append_if_not_found' resulted in
1400         an infinitely growing file as 'file.replace' didn't check beforehand
1401         whether the changes had already been done to the file
1402         The tested file contains one commented line
1403         The commented line should be uncommented in the end, nothing else should change
1404         """
1405         test_name = "test_replace_issue_18612"
1406         path_test = os.path.join(base_dir, test_name)
1407         with salt.utils.files.fopen(path_test, "w+") as fp_test_:
1408             fp_test_.write("# en_US.UTF-8")
1409         ret = []
1410         for x in range(0, 3):
1411             ret.append(
1412                 self.run_state(
1413                     "file.replace",
1414                     name=path_test,
1415                     pattern="^# en_US.UTF-8$",
1416                     repl="en_US.UTF-8",
1417                     append_if_not_found=True,
1418                 )
1419             )
1420         with salt.utils.files.fopen(path_test, "r") as fp_test_:
1421             self.assertTrue(sum(1 for _ in fp_test_) == 1)
1422         with salt.utils.files.fopen(path_test, "r") as fp_test_:
1423             self.assertTrue(fp_test_.read().startswith("en_US.UTF-8"))
1424         for item in ret:
1425             self.assertSaltTrueReturn(item)
1426     @with_tempdir()
1427     def test_replace_issue_18612_prepend(self, base_dir):
1428         """
1429         Test the (mis-)behaviour of file.replace as described in #18612:
1430         Using 'prepend_if_not_found' or 'append_if_not_found' resulted in
1431         an infinitely growing file as 'file.replace' didn't check beforehand
1432         whether the changes had already been done to the file
1433         The tested multifile contains multiple lines not matching the pattern or replacement in any way
1434         The replacement pattern should be prepended to the file
1435         """
1436         test_name = "test_replace_issue_18612_prepend"
1437         path_in = os.path.join(
1438             RUNTIME_VARS.FILES, "file.replace", "{}.in".format(test_name)
1439         )
1440         path_out = os.path.join(
1441             RUNTIME_VARS.FILES, "file.replace", "{}.out".format(test_name)
1442         )
1443         path_test = os.path.join(base_dir, test_name)
1444         shutil.copyfile(path_in, path_test)
1445         ret = []
1446         for x in range(0, 3):
1447             ret.append(
1448                 self.run_state(
1449                     "file.replace",
1450                     name=path_test,
1451                     pattern="^# en_US.UTF-8$",
1452                     repl="en_US.UTF-8",
1453                     prepend_if_not_found=True,
1454                 )
1455             )
1456         self.assertTrue(filecmp.cmp(path_test, path_out))
1457         self.assertTrue(filecmp.cmp(path_test + ".bak", path_in))
1458         for item in ret:
1459             self.assertSaltTrueReturn(item)
1460     @with_tempdir()
1461     def test_replace_issue_18612_append(self, base_dir):
1462         """
1463         Test the (mis-)behaviour of file.replace as described in #18612:
1464         Using 'prepend_if_not_found' or 'append_if_not_found' resulted in
1465         an infinitely growing file as 'file.replace' didn't check beforehand
1466         whether the changes had already been done to the file
1467         The tested multifile contains multiple lines not matching the pattern or replacement in any way
1468         The replacement pattern should be appended to the file
1469         """
1470         test_name = "test_replace_issue_18612_append"
1471         path_in = os.path.join(
1472             RUNTIME_VARS.FILES, "file.replace", "{}.in".format(test_name)
1473         )
1474         path_out = os.path.join(
1475             RUNTIME_VARS.FILES, "file.replace", "{}.out".format(test_name)
1476         )
1477         path_test = os.path.join(base_dir, test_name)
1478         shutil.copyfile(path_in, path_test)
1479         ret = []
1480         for x in range(0, 3):
1481             ret.append(
1482                 self.run_state(
1483                     "file.replace",
1484                     name=path_test,
1485                     pattern="^# en_US.UTF-8$",
1486                     repl="en_US.UTF-8",
1487                     append_if_not_found=True,
1488                 )
1489             )
1490         self.assertTrue(filecmp.cmp(path_test, path_out))
1491         self.assertTrue(filecmp.cmp(path_test + ".bak", path_in))
1492         for item in ret:
1493             self.assertSaltTrueReturn(item)
1494     @with_tempdir()
1495     def test_replace_issue_18612_append_not_found_content(self, base_dir):
1496         """
1497         Test the (mis-)behaviour of file.replace as described in #18612:
1498         Using 'prepend_if_not_found' or 'append_if_not_found' resulted in
1499         an infinitely growing file as 'file.replace' didn't check beforehand
1500         whether the changes had already been done to the file
1501         The tested multifile contains multiple lines not matching the pattern or replacement in any way
1502         The 'not_found_content' value should be appended to the file
1503         """
1504         test_name = "test_replace_issue_18612_append_not_found_content"
1505         path_in = os.path.join(
1506             RUNTIME_VARS.FILES, "file.replace", "{}.in".format(test_name)
1507         )
1508         path_out = os.path.join(
1509             RUNTIME_VARS.FILES, "file.replace", "{}.out".format(test_name)
1510         )
1511         path_test = os.path.join(base_dir, test_name)
1512         shutil.copyfile(path_in, path_test)
1513         ret = []
1514         for x in range(0, 3):
1515             ret.append(
1516                 self.run_state(
1517                     "file.replace",
1518                     name=path_test,
1519                     pattern="^# en_US.UTF-8$",
1520                     repl="en_US.UTF-8",
1521                     append_if_not_found=True,
1522                     not_found_content=(
1523                         "THIS LINE WASN'T FOUND! SO WE'RE APPENDING IT HERE!"
1524                     ),
1525                 )
1526             )
1527         self.assertTrue(filecmp.cmp(path_test, path_out))
1528         self.assertTrue(filecmp.cmp(path_test + ".bak", path_in))
1529         for item in ret:
1530             self.assertSaltTrueReturn(item)
1531     @with_tempdir()
1532     def test_replace_issue_18612_change_mid_line_with_comment(self, base_dir):
1533         """
1534         Test the (mis-)behaviour of file.replace as described in #18612:
1535         Using 'prepend_if_not_found' or 'append_if_not_found' resulted in
1536         an infinitely growing file as 'file.replace' didn't check beforehand
1537         whether the changes had already been done to the file
1538         The tested file contains 5 key=value pairs
1539         The commented key=value pair #foo=bar should be changed to foo=salt
1540         The comment char (#) in front of foo=bar should be removed
1541         """
1542         test_name = "test_replace_issue_18612_change_mid_line_with_comment"
1543         path_in = os.path.join(
1544             RUNTIME_VARS.FILES, "file.replace", "{}.in".format(test_name)
1545         )
1546         path_out = os.path.join(
1547             RUNTIME_VARS.FILES, "file.replace", "{}.out".format(test_name)
1548         )
1549         path_test = os.path.join(base_dir, test_name)
1550         shutil.copyfile(path_in, path_test)
1551         ret = []
1552         for x in range(0, 3):
1553             ret.append(
1554                 self.run_state(
1555                     "file.replace",
1556                     name=path_test,
1557                     pattern="^#foo=bar($|(?=\r\n))",
1558                     repl="foo=salt",
1559                     append_if_not_found=True,
1560                 )
1561             )
1562         self.assertTrue(filecmp.cmp(path_test, path_out))
1563         self.assertTrue(filecmp.cmp(path_test + ".bak", path_in))
1564         for item in ret:
1565             self.assertSaltTrueReturn(item)
1566     @with_tempdir()
1567     def test_replace_issue_18841_no_changes(self, base_dir):
1568         """
1569         Test the (mis-)behaviour of file.replace as described in #18841:
1570         Using file.replace in a way which shouldn't modify the file at all
1571         results in changed mtime of the original file and a backup file being created.
1572         The tested file contains multiple lines
1573         The tested file contains a line already matching the replacement (no change needed)
1574         The tested file's content shouldn't change at all
1575         The tested file's mtime shouldn't change at all
1576         No backup file should be created
1577         """
1578         test_name = "test_replace_issue_18841_no_changes"
1579         path_in = os.path.join(
1580             RUNTIME_VARS.FILES, "file.replace", "{}.in".format(test_name)
1581         )
1582         path_test = os.path.join(base_dir, test_name)
1583         shutil.copyfile(path_in, path_test)
1584         fstats_orig = os.stat(path_test)
1585         age = 5 * 24 * 60 * 60
1586         os.utime(path_test, (fstats_orig.st_mtime - age, fstats_orig.st_atime - age))
1587         ret = self.run_state(
1588             "file.replace",
1589             name=path_test,
1590             pattern="^hello world$",
1591             repl="goodbye world",
1592             show_changes=True,
1593             flags=["IGNORECASE"],
1594             backup=False,
1595         )
1596         fstats_post = os.stat(path_test)
1597         self.assertTrue(filecmp.cmp(path_in, path_test))
1598         self.assertFalse(os.path.exists(path_test + ".bak"))
1599         self.assertTrue(fstats_post.st_mtime, fstats_orig.st_mtime - age)
1600         self.assertSaltTrueReturn(ret)
1601     def test_serialize(self):
1602         """
1603         Test to ensure that file.serialize returns a data structure that's
1604         both serialized and formatted properly
1605         """
1606         path_test = self.tmp_dir / "test_serialize"
1607         self.addCleanup(salt.utils.files.safe_rm, str(path_test))
1608         ret = self.run_state(
1609             "file.serialize",
1610             name=str(path_test),
1611             dataset={
1612                 "name": "naive",
1613                 "description": "A basic test",
1614                 "a_list": ["first_element", "second_element"],
1615                 "finally": "the last item",
1616             },
1617             formatter="json",
1618         )
1619         serialized_file = salt.utils.stringutils.to_unicode(path_test.read_bytes())
1620         expected_file = "\n".join(
1621             [
1622                 "{",
1623                 '  "a_list": [',
1624                 '    "first_element",',
1625                 '    "second_element"',
1626                 "  ],",
1627                 '  "description": "A basic test",',
1628                 '  "finally": "the last item",',
1629                 '  "name": "naive"',
1630                 "}",
1631                 "",
1632             ]
1633         )
1634         self.assertEqual(serialized_file, expected_file)
1635     @with_tempfile(create=False)
1636     def test_serializer_deserializer_opts(self, name):
1637         """
1638         Test the serializer_opts and deserializer_opts options
1639         """
1640         data1 = {"foo": {"bar": "%(x)s"}}
1641         data2 = {"foo": {"abc": 123}}
1642         merged = {"foo": {"y": "not_used", "x": "baz", "abc": 123, "bar": "baz"}}
1643         ret = self.run_state(
1644             "file.serialize",
1645             name=name,
1646             dataset=data1,
1647             formatter="configparser",
1648             deserializer_opts=[{"defaults": {"y": "not_used"}}],
1649         )
1650         ret = ret[next(iter(ret))]
1651         assert ret["result"], ret
1652         assert "warnings" in ret
1653         ret = self.run_state(
1654             "file.serialize",
1655             name=name,
1656             dataset=data2,
1657             formatter="configparser",
1658             merge_if_exists=True,
1659             serializer_opts=[{"defaults": {"y": "not_used"}}],
1660             deserializer_opts=[{"defaults": {"x": "baz"}}],
1661         )
1662         ret = ret[next(iter(ret))]
1663         assert ret["result"], ret
1664         with salt.utils.files.fopen(name) as fp_:
1665             serialized_data = salt.serializers.configparser.deserialize(fp_)
1666         log.debug("serialized_data = %r", serialized_data)
1667         log.debug("merged = %r", merged)
1668         assert serialized_data["foo"]["y"] == merged["foo"]["y"]
1669         assert serialized_data["foo"]["bar"] == merged["foo"]["bar"]
1670     @with_tempfile(create=False)
1671     def test_serializer_plist_binary_file_open(self, name):
1672         """
1673         Test the serialization and deserialization of plists which should include
1674         the "rb" file open arguments change specifically for this formatter to handle
1675         binary plists.
1676         """
1677         data1 = {"foo": {"bar": "%(x)s"}}
1678         data2 = {"foo": {"abc": 123}}
1679         merged = {"foo": {"abc": 123, "bar": "%(x)s"}}
1680         ret = self.run_state(
1681             "file.serialize",
1682             name=name,
1683             dataset=data1,
1684             formatter="plist",
1685             serializer_opts=[{"fmt": "FMT_BINARY"}],
1686         )
1687         ret = ret[next(iter(ret))]
1688         assert ret["result"], ret
1689         ret = self.run_state(
1690             "file.serialize",
1691             name=name,
1692             dataset=data2,
1693             formatter="plist",
1694             merge_if_exists=True,
1695             serializer_opts=[{"fmt": "FMT_BINARY"}],
1696         )
1697         ret = ret[next(iter(ret))]
1698         assert ret["result"], ret
1699         with salt.utils.files.fopen(name, "rb") as fp_:
1700             serialized_data = salt.serializers.plist.deserialize(fp_)
1701         assert serialized_data["foo"] == merged["foo"]
1702     @with_tempfile(create=False)
1703     def test_serializer_plist_file_open(self, name):
1704         """
1705         Test the serialization and deserialization of non binary plists with
1706         the new line concatenation.
1707         """
1708         data1 = {"foo": {"bar": "%(x)s"}}
1709         data2 = {"foo": {"abc": 123}}
1710         merged = {"foo": {"abc": 123, "bar": "%(x)s"}}
1711         ret = self.run_state(
1712             "file.serialize",
1713             name=name,
1714             dataset=data1,
1715             formatter="plist",
1716         )
1717         ret = ret[next(iter(ret))]
1718         assert ret["result"], ret
1719         ret = self.run_state(
1720             "file.serialize",
1721             name=name,
1722             dataset=data2,
1723             formatter="plist",
1724             merge_if_exists=True,
1725         )
1726         ret = ret[next(iter(ret))]
1727         assert ret["result"], ret
1728         with salt.utils.files.fopen(name, "rb") as fp_:
1729             serialized_data = salt.serializers.plist.deserialize(fp_)
1730         assert serialized_data["foo"] == merged["foo"]
1731     @with_tempdir()
1732     def test_replace_issue_18841_omit_backup(self, base_dir):
1733         """
1734         Test the (mis-)behaviour of file.replace as described in #18841:
1735         Using file.replace in a way which shouldn't modify the file at all
1736         results in changed mtime of the original file and a backup file being created.
1737         The tested file contains multiple lines
1738         The tested file contains a line already matching the replacement (no change needed)
1739         The tested file's content shouldn't change at all
1740         The tested file's mtime shouldn't change at all
1741         No backup file should be created, although backup=False isn't explicitly defined
1742         """
1743         test_name = "test_replace_issue_18841_omit_backup"
1744         path_in = os.path.join(
1745             RUNTIME_VARS.FILES, "file.replace", "{}.in".format(test_name)
1746         )
1747         path_test = os.path.join(base_dir, test_name)
1748         shutil.copyfile(path_in, path_test)
1749         fstats_orig = os.stat(path_test)
1750         age = 5 * 24 * 60 * 60
1751         os.utime(path_test, (fstats_orig.st_mtime - age, fstats_orig.st_atime - age))
1752         ret = self.run_state(
1753             "file.replace",
1754             name=path_test,
1755             pattern="^hello world$",
1756             repl="goodbye world",
1757             show_changes=True,
1758             flags=["IGNORECASE"],
1759         )
1760         fstats_post = os.stat(path_test)
1761         self.assertTrue(filecmp.cmp(path_in, path_test))
1762         self.assertFalse(os.path.exists(path_test + ".bak"))
1763         self.assertTrue(fstats_post.st_mtime, fstats_orig.st_mtime - age)
1764         self.assertSaltTrueReturn(ret)
1765     @with_tempfile()
1766     def test_comment(self, name):
1767         """
1768         file.comment
1769         """
1770         with salt.utils.files.fopen(name, "w+") as fp_:
1771             fp_.write("comment_me")
1772         ret = self.run_state("file.comment", test=True, name=name, regex="^comment")
1773         self.assertSaltNoneReturn(ret)
1774         ret = self.run_state("file.comment", name=name, regex="^comment")
1775         self.assertSaltTrueReturn(ret)
1776         with salt.utils.files.fopen(name, "r") as fp_:
1777             self.assertTrue(fp_.read().startswith("#comment"))
1778         ret = self.run_state("file.comment", name=name, regex="^comment")
1779         self.assertSaltTrueReturn(ret)
1780         with salt.utils.files.fopen(name, "r") as fp_:
1781             self.assertTrue(fp_.read().startswith("#comment"))
1782         ret = self.run_state("file.comment", test=True, name=name, regex="^comment")
1783         self.assertSaltTrueReturn(ret)
1784     @with_tempfile()
1785     def test_test_comment(self, name):
1786         """
1787         file.comment test interface
1788         """
1789         with salt.utils.files.fopen(name, "w+") as fp_:
1790             fp_.write("comment_me")
1791         ret = self.run_state(
1792             "file.comment",
1793             test=True,
1794             name=name,
1795             regex=".*comment.*",
1796         )
1797         with salt.utils.files.fopen(name, "r") as fp_:
1798             self.assertNotIn("#comment", fp_.read())
1799         self.assertSaltNoneReturn(ret)
1800     @with_tempfile()
1801     def test_uncomment(self, name):
1802         """
1803         file.uncomment
1804         """
1805         with salt.utils.files.fopen(name, "w+") as fp_:
1806             fp_.write("#comment_me")
1807         ret = self.run_state("file.uncomment", name=name, regex="^comment")
1808         with salt.utils.files.fopen(name, "r") as fp_:
1809             self.assertNotIn("#comment", fp_.read())
1810         self.assertSaltTrueReturn(ret)
1811     @with_tempfile()
1812     def test_test_uncomment(self, name):
1813         """
1814         file.comment test interface
1815         """
1816         with salt.utils.files.fopen(name, "w+") as fp_:
1817             fp_.write("#comment_me")
1818         ret = self.run_state("file.uncomment", test=True, name=name, regex="^comment.*")
1819         with salt.utils.files.fopen(name, "r") as fp_:
1820             self.assertIn("#comment", fp_.read())
1821         self.assertSaltNoneReturn(ret)
1822     @with_tempfile()
1823     def test_append(self, name):
1824         """
1825         file.append
1826         """
1827         with salt.utils.files.fopen(name, "w+") as fp_:
1828             fp_.write("#salty!")
1829         ret = self.run_state("file.append", name=name, text="cheese")
1830         with salt.utils.files.fopen(name, "r") as fp_:
1831             self.assertIn("cheese", fp_.read())
1832         self.assertSaltTrueReturn(ret)
1833     @with_tempfile()
1834     def test_test_append(self, name):
1835         """
1836         file.append test interface
1837         """
1838         with salt.utils.files.fopen(name, "w+") as fp_:
1839             fp_.write("#salty!")
1840         ret = self.run_state("file.append", test=True, name=name, text="cheese")
1841         with salt.utils.files.fopen(name, "r") as fp_:
1842             self.assertNotIn("cheese", fp_.read())
1843         self.assertSaltNoneReturn(ret)
1844     @with_tempdir()
1845     def test_append_issue_1864_makedirs(self, base_dir):
1846         """
1847         file.append but create directories if needed as an option, and create
1848         the file if it doesn't exist
1849         """
1850         fname = "append_issue_1864_makedirs"
1851         name = os.path.join(base_dir, fname)
1852         ret = self.run_state("file.append", name=name, text="cheese", makedirs=True)
1853         self.assertSaltTrueReturn(ret)
1854         name = os.path.join(base_dir, "issue_1864", fname)
1855         ret = self.run_state("file.append", name=name, text="cheese", makedirs=True)
1856         self.assertSaltTrueReturn(ret)
1857         name = os.path.join(base_dir, "issue_1864", fname + "2")
1858         ret = self.run_state("file.append", name=name, text="cheese")
1859         self.assertSaltTrueReturn(ret)
1860         self.assertTrue(os.path.isfile(name))
1861     @with_tempdir()
1862     def test_prepend_issue_27401_makedirs(self, base_dir):
1863         """
1864         file.prepend but create directories if needed as an option, and create
1865         the file if it doesn't exist
1866         """
1867         fname = "prepend_issue_27401"
1868         name = os.path.join(base_dir, fname)
1869         ret = self.run_state("file.prepend", name=name, text="cheese", makedirs=True)
1870         self.assertSaltTrueReturn(ret)
1871         name = os.path.join(base_dir, "issue_27401", fname)
1872         ret = self.run_state("file.prepend", name=name, text="cheese", makedirs=True)
1873         self.assertSaltTrueReturn(ret)
1874         name = os.path.join(base_dir, "issue_27401", fname + "2")
1875         ret = self.run_state("file.prepend", name=name, text="cheese")
1876         self.assertSaltTrueReturn(ret)
1877         self.assertTrue(os.path.isfile(name))
1878     @with_tempfile()
1879     def test_touch(self, name):
1880         """
1881         file.touch
1882         """
1883         ret = self.run_state("file.touch", name=name)
1884         self.assertTrue(os.path.isfile(name))
1885         self.assertSaltTrueReturn(ret)
1886     @with_tempfile(create=False)
1887     def test_test_touch(self, name):
1888         """
1889         file.touch test interface
1890         """
1891         ret = self.run_state("file.touch", test=True, name=name)
1892         self.assertFalse(os.path.isfile(name))
1893         self.assertSaltNoneReturn(ret)
1894     @with_tempdir()
1895     def test_touch_directory(self, base_dir):
1896         """
1897         file.touch a directory
1898         """
1899         name = os.path.join(base_dir, "touch_test_dir")
1900         os.mkdir(name)
1901         ret = self.run_state("file.touch", name=name)
1902         self.assertSaltTrueReturn(ret)
1903         self.assertTrue(os.path.isdir(name))
1904     @with_tempdir()
1905     def test_issue_2227_file_append(self, base_dir):
1906         """
1907         Text to append includes a percent symbol
1908         """
1909         tmp_file_append = os.path.join(base_dir, "test.append")
1910         self.run_state("file.touch", name=tmp_file_append)
1911         self.run_state(
1912             "file.append", name=tmp_file_append, source="salt://testappend/firstif"
1913         )
1914         self.run_state(
1915             "file.append", name=tmp_file_append, source="salt://testappend/secondif"
1916         )
1917         try:
1918             ret = self.run_state(
1919                 "file.append", name=tmp_file_append, text="HISTTIMEFORMAT='%F %T '"
1920             )
1921             self.assertSaltTrueReturn(ret)
1922             with salt.utils.files.fopen(tmp_file_append, "r") as fp_:
1923                 contents_pre = fp_.read()
1924             ret = self.run_state(
1925                 "file.append", name=tmp_file_append, text="HISTTIMEFORMAT='%F %T '"
1926             )
1927             self.assertSaltTrueReturn(ret)
1928             with salt.utils.files.fopen(tmp_file_append, "r") as fp_:
1929                 contents_post = fp_.read()
1930             self.assertEqual(contents_pre, contents_post)
1931         except AssertionError:
1932             if os.path.exists(tmp_file_append):
1933                 shutil.copy(tmp_file_append, tmp_file_append + ".bak")
1934             raise
1935     @with_tempdir()
1936     def test_issue_2401_file_comment(self, base_dir):
1937         tmp_file = os.path.join(base_dir, "issue-2041-comment.txt")
1938         with salt.utils.files.fopen(tmp_file, "w") as fp_:
1939             fp_.write("hello\nworld\n")
1940         template_lines = [
1941             "{}:".format(tmp_file),
1942             "  file.comment:",
1943             "    - regex: ^world",
1944         ]
1945         template = "\n".join(template_lines)
1946         try:
1947             ret = self.run_function("state.template_str", [template], timeout=120)
1948             self.assertSaltTrueReturn(ret)
1949             self.assertNotInSaltComment("Pattern already commented", ret)
1950             self.assertInSaltComment("Commented lines successfully", ret)
1951             ret = self.run_function("state.template_str", [template], timeout=120)
1952             self.assertSaltTrueReturn(ret)
1953             self.assertInSaltComment("Pattern already commented", ret)
1954         except AssertionError:
1955             shutil.copy(tmp_file, tmp_file + ".bak")
1956             raise
1957     @with_tempdir()
1958     def test_issue_2379_file_append(self, base_dir):
1959         tmp_file = os.path.join(base_dir, "issue-2379-file-append.txt")
1960         with salt.utils.files.fopen(tmp_file, "w") as fp_:
1961             fp_.write(
1962                 "hello\nworld\n"  # Some junk
1963                 "#PermitRootLogin yes\n"  # Commented text
1964                 "# PermitRootLogin yes\n"  # Commented text with space
1965             )
1966         template_lines = [
1967             "{}:".format(tmp_file),
1968             "  file.append:",
1969             "    - text: PermitRootLogin yes",
1970         ]
1971         template = "\n".join(template_lines)
1972         try:
1973             ret = self.run_function("state.template_str", [template])
1974             self.assertSaltTrueReturn(ret)
1975             self.assertInSaltComment("Appended 1 lines", ret)
1976         except AssertionError:
1977             shutil.copy(tmp_file, tmp_file + ".bak")
1978             raise
1979     @skipIf(IS_WINDOWS, "Mode not available in Windows")
1980     @with_tempdir(create=False)
1981     @with_tempdir(create=False)
1982     def test_issue_2726_mode_kwarg(self, dir1, dir2):
1983         bad_mode_kwarg_testfile = os.path.join(dir1, "bad_mode_kwarg", "testfile")
1984         bad_template = [
1985             "{}:".format(bad_mode_kwarg_testfile),
1986             "  file.recurse:",
1987             "    - source: salt://testfile",
1988             "    - mode: 644",
1989         ]
1990         ret = self.run_function("state.template_str", [os.linesep.join(bad_template)])
1991         self.assertSaltFalseReturn(ret)
1992         self.assertInSaltComment(
1993             "'mode' is not allowed in 'file.recurse'. Please use "
1994             "'file_mode' and 'dir_mode'.",
1995             ret,
1996         )
1997         self.assertNotInSaltComment(
1998             "TypeError: managed() got multiple values for keyword argument 'mode'",
1999             ret,
2000         )
2001         good_mode_kwargs_testfile = os.path.join(dir2, "good_mode_kwargs", "testappend")
2002         good_template = [
2003             "{}:".format(good_mode_kwargs_testfile),
2004             "  file.recurse:",
2005             "    - source: salt://testappend",
2006             "    - dir_mode: 744",
2007             "    - file_mode: 644",
2008         ]
2009         ret = self.run_function("state.template_str", [os.linesep.join(good_template)])
2010         self.assertSaltTrueReturn(ret)
2011     @with_tempdir()
2012     def test_issue_8343_accumulated_require_in(self, base_dir):
2013         template_path = os.path.join(RUNTIME_VARS.TMP_STATE_TREE, "issue-8343.sls")
2014         testcase_filedest = os.path.join(base_dir, "issue-8343.txt")
2015         if os.path.exists(template_path):
2016             os.remove(template_path)
2017         if os.path.exists(testcase_filedest):
2018             os.remove(testcase_filedest)
2019         sls_template = [
2020             "{0}:",
2021             "  file.managed:",
2022             "    - contents: |",
2023             "                #",
2024             "",
2025             "prepend-foo-accumulator-from-pillar:",
2026             "  file.accumulated:",
2027             "    - require_in:",
2028             "      - file: prepend-foo-management",
2029             "    - filename: {0}",
2030             "    - text: |",
2031             "            foo",
2032             "",
2033             "append-foo-accumulator-from-pillar:",
2034             "  file.accumulated:",
2035             "    - require_in:",
2036             "      - file: append-foo-management",
2037             "    - filename: {0}",
2038             "    - text: |",
2039             "            bar",
2040             "",
2041             "prepend-foo-management:",
2042             "  file.blockreplace:",
2043             "    - name: {0}",
2044             '    - marker_start: "#-- start salt managed zonestart -- PLEASE, DO NOT'
2045             ' EDIT"',
2046             '    - marker_end: "#-- end salt managed zonestart --"',
2047             "    - content: ''",
2048             "    - prepend_if_not_found: True",
2049             "    - backup: '.bak'",
2050             "    - show_changes: True",
2051             "",
2052             "append-foo-management:",
2053             "  file.blockreplace:",
2054             "    - name: {0}",
2055             '    - marker_start: "#-- start salt managed zoneend -- PLEASE, DO NOT'
2056             ' EDIT"',
2057             '    - marker_end: "#-- end salt managed zoneend --"',
2058             "    - content: ''",
2059             "    - append_if_not_found: True",
2060             "    - backup: '.bak2'",
2061             "    - show_changes: True",
2062             "",
2063         ]
2064         with salt.utils.files.fopen(template_path, "w") as fp_:
2065             fp_.write(os.linesep.join(sls_template).format(testcase_filedest))
2066         ret = self.run_function("state.sls", mods="issue-8343")
2067         for name, step in ret.items():
2068             self.assertSaltTrueReturn({name: step})
2069         with salt.utils.files.fopen(testcase_filedest) as fp_:
2070             contents = fp_.read().split(os.linesep)
2071         expected = [
2072             "#-- start salt managed zonestart -- PLEASE, DO NOT EDIT",
2073             "foo",
2074             "#-- end salt managed zonestart --",
2075             "#",
2076             "#-- start salt managed zoneend -- PLEASE, DO NOT EDIT",
2077             "bar",
2078             "#-- end salt managed zoneend --",
2079             "",
2080         ]
2081         self.assertEqual(
2082             [salt.utils.stringutils.to_str(line) for line in expected], contents
2083         )
2084     @with_tempdir()
2085     def test_issue_11003_immutable_lazy_proxy_sum(self, base_dir):
2086         template_path = os.path.join(RUNTIME_VARS.TMP_STATE_TREE, "issue-11003.sls")
2087         testcase_filedest = os.path.join(base_dir, "issue-11003.txt")
2088         sls_template = [
2089             "a{0}:",
2090             "  file.absent:",
2091             "    - name: {0}",
2092             "",
2093             "{0}:",
2094             "  file.managed:",
2095             "    - contents: |",
2096             "                #",
2097             "",
2098             "test-acc1:",
2099             "  file.accumulated:",
2100             "    - require_in:",
2101             "      - file: final",
2102             "    - filename: {0}",
2103             "    - text: |",
2104             "            bar",
2105             "",
2106             "test-acc2:",
2107             "  file.accumulated:",
2108             "    - watch_in:",
2109             "      - file: final",
2110             "    - filename: {0}",
2111             "    - text: |",
2112             "            baz",
2113             "",
2114             "final:",
2115             "  file.blockreplace:",
2116             "    - name: {0}",
2117             '    - marker_start: "#-- start managed zone PLEASE, DO NOT EDIT"',
2118             '    - marker_end: "#-- end managed zone"',
2119             "    - content: ''",
2120             "    - append_if_not_found: True",
2121             "    - show_changes: True",
2122         ]
2123         with salt.utils.files.fopen(template_path, "w") as fp_:
2124             fp_.write(os.linesep.join(sls_template).format(testcase_filedest))
2125         ret = self.run_function("state.sls", mods="issue-11003", timeout=600)
2126         for name, step in ret.items():
2127             self.assertSaltTrueReturn({name: step})
2128         with salt.utils.files.fopen(testcase_filedest) as fp_:
2129             contents = fp_.read().split(os.linesep)
2130         begin = contents.index("#-- start managed zone PLEASE, DO NOT EDIT") + 1
2131         end = contents.index("#-- end managed zone")
2132         block_contents = contents[begin:end]
2133         for item in ("", "bar", "baz"):
2134             block_contents.remove(item)
2135         self.assertEqual(block_contents, [])
2136     @with_tempdir()
2137     def test_issue_8947_utf8_sls(self, base_dir):
2138         """
2139         Test some file operation with utf-8 characters on the sls
2140         This is more generic than just a file test. Feel free to move
2141         """
2142         self.maxDiff = None
2143         korean_1 = "한국어 시험"
2144         korean_2 = "첫 번째 행"
2145         korean_3 = "마지막 행"
2146         test_file = os.path.join(base_dir, "{}.txt".format(korean_1))
2147         test_file_encoded = test_file
2148         template_path = os.path.join(RUNTIME_VARS.TMP_STATE_TREE, "issue-8947.sls")
2149         template = textwrap.dedent(
2150             """\
2151             some-utf8-file-create:
2152               file.managed:
2153                 - name: {test_file}
2154                 - contents: {korean_1}
2155                 - makedirs: True
2156                 - replace: True
2157                 - show_diff: True
2158             some-utf8-file-create2:
2159               file.managed:
2160                 - name: {test_file}
2161                 - contents: |
2162                    {korean_2}
2163                    {korean_1}
2164                    {korean_3}
2165                 - replace: True
2166                 - show_diff: True
2167             """.format(
2168                 **locals()
2169             )
2170         )
2171         if not salt.utils.platform.is_windows():
2172             template += textwrap.dedent(
2173                 """\
2174             some-utf8-file-content-test:
2175               cmd.run:
2176                 - name: 'cat "{test_file}"'
2177                 - require:
2178                   - file: some-utf8-file-create2
2179             """.format(
2180                     **locals()
2181                 )
2182             )
2183         with salt.utils.files.fopen(template_path, "wb") as fp_:
2184             fp_.write(salt.utils.stringutils.to_bytes(template))
2185         try:
2186             result = self.run_function("state.sls", mods="issue-8947")
2187             if not isinstance(result, dict):
2188                 raise AssertionError(
2189                     "Something went really wrong while testing this sls: {!r}".format(
2190                         result
2191                     )
2192                 )
2193             diff = "--- \n+++ \n@@ -1 +1,3 @@\n"
2194             diff += "+첫 번째 행{0} 한국어 시험{0}+마지막 행{0}".format(os.linesep)
2195             ret = {x.split("_|-")[1]: y for x, y in result.items()}
2196             self.assertEqual(
2197                 ret["some-utf8-file-create"]["comment"],
2198                 "File {} updated".format(test_file_encoded),
2199             )
2200             self.assertEqual(
2201                 ret["some-utf8-file-create"]["changes"], {"diff": "New file"}
2202             )
2203             self.assertEqual(
2204                 ret["some-utf8-file-create2"]["comment"],
2205                 "File {} updated".format(test_file_encoded),
2206             )
2207             self.assertEqual(ret["some-utf8-file-create2"]["changes"], {"diff": diff})
2208             if salt.utils.platform.is_windows():
2209                 import subprocess
2210                 import win32api
2211                 proc = subprocess.run(
2212                     ["type", win32api.GetShortPathName(test_file)],
2213                     stdout=subprocess.PIPE,
2214                     stderr=subprocess.PIPE,
2215                     check=True,
2216                     shell=True,  # nosec
2217                 )
2218                 self.assertEqual(
2219                     proc.stdout.decode("utf-8"),
2220                     os.linesep.join((korean_2, korean_1, korean_3)) + os.linesep,
2221                 )
2222             else:
2223                 self.assertEqual(
2224                     ret["some-utf8-file-content-test"]["comment"],
2225                     'Command "cat "{}"" run'.format(test_file_encoded),
2226                 )
2227                 self.assertEqual(
2228                     ret["some-utf8-file-content-test"]["changes"]["stdout"],
2229                     "\n".join((korean_2, korean_1, korean_3)),
2230                 )
2231         finally:
2232             try:
2233                 os.remove(template_path)
2234             except OSError:
2235                 pass
2236     @pytest.mark.skip_if_not_root
2237     @skipIf(not HAS_PWD, "pwd not available. Skipping test")
2238     @skipIf(not HAS_GRP, "grp not available. Skipping test")
2239     @with_system_user_and_group(
2240         TEST_SYSTEM_USER, TEST_SYSTEM_GROUP, on_existing="delete", delete=True
2241     )
2242     @with_tempdir()
2243     @skipIf(salt.utils.platform.is_freebsd(), "Test is failing on FreeBSD")
2244     def test_issue_12209_follow_symlinks(self, tempdir, user, group):
2245         """
2246         Ensure that symlinks are properly chowned when recursing (following
2247         symlinks)
2248         """
2249         onedir = os.path.join(tempdir, "one")
2250         twodir = os.path.join(tempdir, "two")
2251         os.mkdir(onedir)
2252         os.symlink(onedir, twodir)
2253         ret = self.run_state(
2254             "file.directory",
2255             name=tempdir,
2256             follow_symlinks=True,
2257             user=user,
2258             group=group,
2259             recurse=["user", "group"],
2260         )
2261         self.assertSaltTrueReturn(ret)
2262         onestats = os.stat(onedir)
2263         twostats = os.lstat(twodir)
2264         self.assertEqual(pwd.getpwuid(onestats.st_uid).pw_name, user)
2265         self.assertEqual(pwd.getpwuid(twostats.st_uid).pw_name, "root")
2266         self.assertEqual(grp.getgrgid(onestats.st_gid).gr_name, group)
2267         if salt.utils.path.which("id"):
2268             root_group = self.run_function("user.primary_group", ["root"])
2269             self.assertEqual(grp.getgrgid(twostats.st_gid).gr_name, root_group)
2270     @pytest.mark.skip_if_not_root
2271     @skipIf(not HAS_PWD, "pwd not available. Skipping test")
2272     @skipIf(not HAS_GRP, "grp not available. Skipping test")
2273     @with_system_user_and_group(
2274         TEST_SYSTEM_USER, TEST_SYSTEM_GROUP, on_existing="delete", delete=True
2275     )
2276     @with_tempdir()
2277     def test_issue_12209_no_follow_symlinks(self, tempdir, user, group):
2278         """
2279         Ensure that symlinks are properly chowned when recursing (not following
2280         symlinks)
2281         """
2282         onedir = os.path.join(tempdir, "one")
2283         twodir = os.path.join(tempdir, "two")
2284         os.mkdir(onedir)
2285         os.symlink(onedir, twodir)
2286         ret = self.run_state(
2287             "file.directory",
2288             name=tempdir,
2289             follow_symlinks=False,
2290             user=user,
2291             group=group,
2292             recurse=["user", "group"],
2293         )
2294         self.assertSaltTrueReturn(ret)
2295         onestats = os.stat(onedir)
2296         twostats = os.lstat(twodir)
2297         self.assertEqual(pwd.getpwuid(onestats.st_uid).pw_name, user)
2298         self.assertEqual(pwd.getpwuid(twostats.st_uid).pw_name, user)
2299         self.assertEqual(grp.getgrgid(onestats.st_gid).gr_name, group)
2300         self.assertEqual(grp.getgrgid(twostats.st_gid).gr_name, group)
2301     @with_tempfile(create=False)
2302     @with_tempfile()
2303     def test_template_local_file(self, source, dest):
2304         """
2305         Test a file.managed state with a local file as the source. Test both
2306         with the file:// protocol designation prepended, and without it.
2307         """
2308         with salt.utils.files.fopen(source, "w") as fp_:
2309             fp_.write("{{ foo }}\n")
2310         for prefix in ("file://", ""):
2311             ret = self.run_state(
2312                 "file.managed",
2313                 name=dest,
2314                 source=prefix + source,
2315                 template="jinja",
2316                 context={"foo": "Hello world!"},
2317             )
2318             self.assertSaltTrueReturn(ret)
2319     @with_tempfile()
2320     def test_template_local_file_noclobber(self, source):
2321         """
2322         Test the case where a source file is in the minion's local filesystem,
2323         and the source path is the same as the destination path.
2324         """
2325         with salt.utils.files.fopen(source, "w") as fp_:
2326             fp_.write("{{ foo }}\n")
2327         ret = self.run_state(
2328             "file.managed",
2329             name=source,
2330             source=source,
2331             template="jinja",
2332             context={"foo": "Hello world!"},
2333         )
2334         self.assertSaltFalseReturn(ret)
2335         self.assertIn(
2336             "Source file cannot be the same as destination",
2337             ret[next(iter(ret))]["comment"],
2338         )
2339     @with_tempfile(create=False)
2340     @with_tempfile(create=False)
2341     def test_issue_25250_force_copy_deletes(self, source, dest):
2342         """
2343         ensure force option in copy state does not delete target file
2344         """
2345         shutil.copyfile(os.path.join(RUNTIME_VARS.FILES, "hosts"), source)
2346         shutil.copyfile(os.path.join(RUNTIME_VARS.FILES, "file/base/cheese"), dest)
2347         self.run_state("file.copy", name=dest, source=source, force=True)
2348         self.assertTrue(os.path.exists(dest))
2349         self.assertTrue(filecmp.cmp(source, dest))
2350         os.remove(source)
2351         os.remove(dest)
2352     @pytest.mark.destructive_test
2353     @pytest.mark.skip_if_not_root
2354     @skipIf(IS_WINDOWS, "Windows does not report any file modes. Skipping.")
2355     @with_tempfile()
2356     def test_file_copy_make_dirs(self, source):
2357         """
2358         ensure make_dirs creates correct user perms
2359         """
2360         shutil.copyfile(os.path.join(RUNTIME_VARS.FILES, "hosts"), source)
2361         dest = self.tmp_dir / "dir1" / "dir2" / "copied_file.txt"
2362         self.addCleanup(salt.utils.files.rm_rf, str(dest.parent.parent))
2363         user = "salt"
2364         mode = "0644"
2365         ret = self.run_function("user.add", [user])
2366         self.assertTrue(ret, "Failed to add user. Are you running as sudo?")
2367         ret = self.run_state(
2368             "file.copy",
2369             name=str(dest),
2370             source=source,
2371             user=user,
2372             makedirs=True,
2373             mode=mode,
2374         )
2375         self.assertSaltTrueReturn(ret)
2376         file_checks = [str(dest), str(dest.parent), str(dest.parent.parent)]
2377         for check in file_checks:
2378             user_check = self.run_function("file.get_user", [check])
2379             mode_check = self.run_function("file.get_mode", [check])
2380             self.assertEqual(user_check, user)
2381             self.assertEqual(salt.utils.files.normalize_mode(mode_check), mode)
2382     @pytest.mark.skip_if_not_root
2383     @skipIf(not HAS_PWD, "pwd not available. Skipping test")
2384     @skipIf(not HAS_GRP, "grp not available. Skipping test")
2385     @with_system_user_and_group(
2386         TEST_SYSTEM_USER, TEST_SYSTEM_GROUP, on_existing="delete", delete=True
2387     )
2388     def test_owner_after_setuid(self, user, group):
2389         """
2390         Test to check file user/group after setting setuid or setgid.
2391         Because Python os.chown() does reset the setuid/setgid to 0.
2392         https://github.com/saltstack/salt/pull/45257
2393         """
2394         desired_file = self.tmp_dir / "file_with_setuid"
2395         self.addCleanup(salt.utils.files.safe_rm, str(desired_file))
2396         desired = {
2397             "file": str(desired_file),
2398             "user": user,
2399             "group": group,
2400             "mode": "4750",
2401         }
2402         ret = self.run_state(
2403             "file.managed",
2404             name=desired["file"],
2405             user=desired["user"],
2406             group=desired["group"],
2407             mode=desired["mode"],
2408         )
2409         file_stat = desired_file.stat()
2410         result = {
2411             "user": pwd.getpwuid(file_stat.st_uid).pw_name,
2412             "group": grp.getgrgid(file_stat.st_gid).gr_name,
2413             "mode": oct(stat.S_IMODE(file_stat.st_mode)),
2414         }
2415         self.assertSaltTrueReturn(ret)
2416         self.assertEqual(desired["user"], result["user"])
2417         self.assertEqual(desired["group"], result["group"])
2418         self.assertEqual(desired["mode"], result["mode"].lstrip("0Oo"))
2419     def test_binary_contents(self):
2420         """
2421         This tests to ensure that binary contents do not cause a traceback.
2422         """
2423         name = self.tmp_dir / "1px.gif"
2424         self.addCleanup(salt.utils.files.safe_rm, str(name))
2425         ret = self.run_state("file.managed", name=str(name), contents=BINARY_FILE)
2426         self.assertSaltTrueReturn(ret)
2427     def test_binary_contents_twice(self):
2428         """
2429         This test ensures that after a binary file is created, salt can confirm
2430         that the file is in the correct state.
2431         """
2432         name = self.tmp_dir / "1px.gif"
2433         self.addCleanup(salt.utils.files.safe_rm, str(name))
2434         ret = self.run_state("file.managed", name=str(name), contents=BINARY_FILE)
2435         self.assertSaltTrueReturn(ret)
2436         ret = self.run_state("file.managed", name=str(name), contents=BINARY_FILE)
2437         self.assertSaltTrueReturn(ret)
2438     @pytest.mark.skip_if_not_root
2439     @skipIf(not HAS_PWD, "pwd not available. Skipping test")
2440     @skipIf(not HAS_GRP, "grp not available. Skipping test")
2441     @with_system_user_and_group(
2442         TEST_SYSTEM_USER, TEST_SYSTEM_GROUP, on_existing="delete", delete=True
2443     )
2444     @with_tempdir()
2445     def test_issue_48336_file_managed_mode_setuid(self, tempdir, user, group):
2446         """
2447         Ensure that mode is correct with changing of ownership and group
2448         symlinks)
2449         """
2450         tempfile = os.path.join(tempdir, "temp_file_issue_48336")
2451         ret = self.run_state(
2452             "file.managed",
2453             name=tempfile,
2454             user=user,
2455             group=group,
2456             mode="4750",
2457         )
2458         self.assertSaltTrueReturn(ret)
2459         temp_file_stats = os.stat(tempfile)
2460         temp_file_mode = str(oct(stat.S_IMODE(temp_file_stats.st_mode)))
2461         temp_file_mode = salt.utils.files.normalize_mode(temp_file_mode)
2462         self.assertEqual(temp_file_mode, "4750")
2463         self.assertEqual(pwd.getpwuid(temp_file_stats.st_uid).pw_name, user)
2464         self.assertEqual(grp.getgrgid(temp_file_stats.st_gid).gr_name, group)
2465     @with_tempdir()
2466     def test_issue_48557(self, tempdir):
2467         tempfile = os.path.join(tempdir, "temp_file_issue_48557")
2468         with salt.utils.files.fopen(tempfile, "wb") as fp:
2469             fp.write(os.linesep.join(["test1", "test2", "test3", ""]).encode("utf-8"))
2470         ret = self.run_state(
2471             "file.line", name=tempfile, after="test2", mode="insert", content="test4"
2472         )
2473         self.assertSaltTrueReturn(ret)
2474         with salt.utils.files.fopen(tempfile, "rb") as fp:
2475             content = fp.read()
2476         self.assertEqual(
2477             content,
2478             os.linesep.join(["test1", "test2", "test4", "test3", ""]).encode("utf-8"),
2479         )
2480     def test_managed_file_issue_51208(self):
2481         """
2482         Test to ensure we can handle a file with escaped double-quotes
2483         """
2484         name = self.tmp_dir / "issue_51208.txt"
2485         self.addCleanup(salt.utils.files.safe_rm, str(name))
2486         ret = self.run_state(
2487             "file.managed", name=str(name), source="salt://issue-51208/vimrc.stub"
2488         )
2489         src = pathlib.Path(RUNTIME_VARS.BASE_FILES) / "issue-51208" / "vimrc.stub"
2490         master_data = src.read_text()
2491         minion_data = name.read_text()
2492         self.assertEqual(master_data, minion_data)
2493         self.assertSaltTrueReturn(ret)
2494     @with_tempfile()
2495     def test_keyvalue(self, name):
2496         """
2497         file.keyvalue
2498         """
2499         content = dedent(
2500             """\
2501             """
2502         )
2503         with salt.utils.files.fopen(name, "w+") as fp_:
2504             fp_.write(content)
2505         ret = self.run_state(
2506             "file.keyvalue",
2507             name=name,
2508             key="permitrootlogin",
2509             value="no",
2510             separator=" ",
2511             uncomment=" #",
2512             key_ignore_case=True,
2513         )
2514         with salt.utils.files.fopen(name, "r") as fp_:
2515             file_contents = fp_.read()
2516             self.assertNotIn("#PermitRootLogin", file_contents)
2517             self.assertNotIn("prohibit-password", file_contents)
2518             self.assertIn("PermitRootLogin no", file_contents)
2519         self.assertSaltTrueReturn(ret)
2520     @with_tempdir()
2521     @pytest.mark.slow_test
2522     def test_issue_1896_file_append_source(self, base_dir):
2523         """
2524         Verify that we can append a file's contents
2525         """
2526         testfile = os.path.join(base_dir, "test.append")
2527         ret = self.run_state("file.touch", name=testfile)
2528         self.assertSaltTrueReturn(ret)
2529         ret = self.run_state(
2530             "file.append", name=testfile, source="salt://testappend/firstif"
2531         )
2532         self.assertSaltTrueReturn(ret)
2533         ret = self.run_state(
2534             "file.append", name=testfile, source="salt://testappend/secondif"
2535         self.assertSaltTrueReturn(ret)
2536         <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>with salt.utils.files.fopen(testfile, "r") as fp_:
2537             testfile_contents = salt.utils.stringutils.to_unicode(fp_.read(</b></font>))
2538         contents = textwrap.dedent(
2539             """\
2540             if [ -z "$debian_chroot" ] &amp;&amp; [ -r /etc/debian_chroot ]; then
2541                 debian_chroot=$(cat /etc/debian_chroot)
2542             fi
2543             if [ -f /etc/bash_completion ] &amp;&amp; ! shopt -oq posix; then
2544                 . /etc/bash_completion
2545             fi
2546             """
2547         )
2548         if salt.utils.platform.is_windows():
2549             new_contents = contents.splitlines()
2550             contents = os.linesep.join(new_contents)
2551             contents += os.linesep
2552         self.assertMultiLineEqual(contents, testfile_contents)
2553         ret = self.run_state(
2554             "file.append", name=testfile, source="salt://testappend/secondif"
2555         )
2556         self.assertSaltTrueReturn(ret)
2557         ret = self.run_state(
2558             "file.append", name=testfile, source="salt://testappend/firstif"
2559         self.assertSaltTrueReturn(ret)
2560         <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>with salt.utils.files.fopen(testfile, "r") as fp_:
2561             testfile_contents = salt.utils.stringutils.to_unicode(fp_.read(</b></font>))
2562         self.assertMultiLineEqual(contents, testfile_contents)
2563 @pytest.mark.windows_whitelisted
2564 class BlockreplaceTest(ModuleCase, SaltReturnAssertsMixin):
2565     marker_start = "# start"
2566     marker_end = "# end"
2567     content = dedent(
2568         """\
2569         Line 1 of block
2570         Line 2 of block
2571         """
2572     )
2573     without_block = dedent(
2574         """\
2575         Hello world!
2576         """
2577     )
2578     with_non_matching_block = dedent(
2579         """\
2580         Hello world!
2581         No match here
2582         """
2583     )
2584     with_non_matching_block_and_marker_end_not_after_newline = dedent(
2585         """\
2586         Hello world!
2587         No match here# end
2588         """
2589     )
2590     with_matching_block = dedent(
2591         """\
2592         Hello world!
2593         Line 1 of block
2594         Line 2 of block
2595         """
2596     )
2597     with_matching_block_and_extra_newline = dedent(
2598         """\
2599         Hello world!
2600         Line 1 of block
2601         Line 2 of block
2602         """
2603     )
2604     with_matching_block_and_marker_end_not_after_newline = dedent(
2605         """\
2606         Hello world!
2607         Line 1 of block
2608         Line 2 of block# end
2609         """
2610     )
2611     content_explicit_posix_newlines = "Line 1 of block\nLine 2 of block\n"
2612     content_explicit_windows_newlines = "Line 1 of block\r\nLine 2 of block\r\n"
2613     without_block_explicit_posix_newlines = "Hello world!\n\n# comment here\n"
2614     without_block_explicit_windows_newlines = "Hello world!\r\n\r\n# comment here\r\n"
2615     with_block_prepended_explicit_posix_newlines = (
2616         "# start\n"
2617         "Line 1 of block\n"
2618         "Line 2 of block\n"
2619         "# end\n"
2620         "Hello world!\n\n"
2621         "# comment here\n"
2622     )
2623     with_block_prepended_explicit_windows_newlines = (
2624         "# start\r\n"
2625         "Line 1 of block\r\n"
2626         "Line 2 of block\r\n"
2627         "# end\r\n"
2628         "Hello world!\r\n\r\n"
2629         "# comment here\r\n"
2630     )
2631     with_block_appended_explicit_posix_newlines = (
2632         "Hello world!\n\n"
2633         "# comment here\n"
2634         "# start\n"
2635         "Line 1 of block\n"
2636         "Line 2 of block\n"
2637         "# end\n"
2638     )
2639     with_block_appended_explicit_windows_newlines = (
2640         "Hello world!\r\n\r\n"
2641         "# comment here\r\n"
2642         "# start\r\n"
2643         "Line 1 of block\r\n"
2644         "Line 2 of block\r\n"
2645         "# end\r\n"
2646     )
2647     @staticmethod
2648     def _write(dest, content):
2649         with salt.utils.files.fopen(dest, "wb") as fp_:
2650             fp_.write(salt.utils.stringutils.to_bytes(content))
2651     @staticmethod
2652     def _read(src):
2653         with salt.utils.files.fopen(src, "rb") as fp_:
2654             return salt.utils.stringutils.to_unicode(fp_.read())
2655     @with_tempfile()
2656     def test_prepend(self, name):
2657         """
2658         Test blockreplace when prepend_if_not_found=True and block doesn't
2659         exist in file.
2660         """
2661         expected = (
2662             self.marker_start
2663             + os.linesep
2664             + self.content
2665             + self.marker_end
2666             + os.linesep
2667             + self.without_block
2668         )
2669         self._write(name, self.without_block)
2670         ret = self.run_state(
2671             "file.blockreplace",
2672             name=name,
2673             content=self.content,
2674             marker_start=self.marker_start,
2675             marker_end=self.marker_end,
2676             prepend_if_not_found=True,
2677         )
2678         self.assertSaltTrueReturn(ret)
2679         self.assertTrue(ret[next(iter(ret))]["changes"])
2680         self.assertEqual(self._read(name), expected)
2681         ret = self.run_state(
2682             "file.blockreplace",
2683             name=name,
2684             content=self.content,
2685             marker_start=self.marker_start,
2686             marker_end=self.marker_end,
2687             prepend_if_not_found=True,
2688         )
2689         self.assertSaltTrueReturn(ret)
2690         self.assertFalse(ret[next(iter(ret))]["changes"])
2691         self.assertEqual(self._read(name), expected)
2692         self._write(name, self.without_block)
2693         ret = self.run_state(
2694             "file.blockreplace",
2695             name=name,
2696             content=self.content.rstrip("\r\n"),
2697             marker_start=self.marker_start,
2698             marker_end=self.marker_end,
2699             prepend_if_not_found=True,
2700         )
2701         self.assertSaltTrueReturn(ret)
2702         self.assertTrue(ret[next(iter(ret))]["changes"])
2703         self.assertEqual(self._read(name), expected)
2704         ret = self.run_state(
2705             "file.blockreplace",
2706             name=name,
2707             content=self.content.rstrip("\r\n"),
2708             marker_start=self.marker_start,
2709             marker_end=self.marker_end,
2710             prepend_if_not_found=True,
2711         )
2712         self.assertSaltTrueReturn(ret)
2713         self.assertFalse(ret[next(iter(ret))]["changes"])
2714         self.assertEqual(self._read(name), expected)
2715     @with_tempfile()
2716     def test_prepend_append_newline(self, name):
2717         """
2718         Test blockreplace when prepend_if_not_found=True and block doesn't
2719         exist in file. Test with append_newline explicitly set to True.
2720         """
2721         expected = (
2722             self.marker_start
2723             + os.linesep
2724             + self.content
2725             + os.linesep
2726             + self.marker_end
2727             + os.linesep
2728             + self.without_block
2729         )
2730         self._write(name, self.without_block)
2731         ret = self.run_state(
2732             "file.blockreplace",
2733             name=name,
2734             content=self.content,
2735             marker_start=self.marker_start,
2736             marker_end=self.marker_end,
2737             prepend_if_not_found=True,
2738             append_newline=True,
2739         )
2740         self.assertSaltTrueReturn(ret)
2741         self.assertTrue(ret[next(iter(ret))]["changes"])
2742         self.assertEqual(self._read(name), expected)
2743         ret = self.run_state(
2744             "file.blockreplace",
2745             name=name,
2746             content=self.content,
2747             marker_start=self.marker_start,
2748             marker_end=self.marker_end,
2749             prepend_if_not_found=True,
2750             append_newline=True,
2751         )
2752         self.assertSaltTrueReturn(ret)
2753         self.assertFalse(ret[next(iter(ret))]["changes"])
2754         self.assertEqual(self._read(name), expected)
2755         expected = (
2756             self.marker_start
2757             + os.linesep
2758             + self.content
2759             + self.marker_end
2760             + os.linesep
2761             + self.without_block
2762         )
2763         self._write(name, self.without_block)
2764         ret = self.run_state(
2765             "file.blockreplace",
2766             name=name,
2767             content=self.content.rstrip("\r\n"),
2768             marker_start=self.marker_start,
2769             marker_end=self.marker_end,
2770             prepend_if_not_found=True,
2771             append_newline=True,
2772         )
2773         self.assertSaltTrueReturn(ret)
2774         self.assertTrue(ret[next(iter(ret))]["changes"])
2775         self.assertEqual(self._read(name), expected)
2776         ret = self.run_state(
2777             "file.blockreplace",
2778             name=name,
2779             content=self.content.rstrip("\r\n"),
2780             marker_start=self.marker_start,
2781             marker_end=self.marker_end,
2782             prepend_if_not_found=True,
2783             append_newline=True,
2784         )
2785         self.assertSaltTrueReturn(ret)
2786         self.assertFalse(ret[next(iter(ret))]["changes"])
2787         self.assertEqual(self._read(name), expected)
2788     @with_tempfile()
2789     def test_prepend_no_append_newline(self, name):
2790         """
2791         Test blockreplace when prepend_if_not_found=True and block doesn't
2792         exist in file. Test with append_newline explicitly set to False.
2793         """
2794         expected = (
2795             self.marker_start
2796             + os.linesep
2797             + self.content
2798             + self.marker_end
2799             + os.linesep
2800             + self.without_block
2801         )
2802         self._write(name, self.without_block)
2803         ret = self.run_state(
2804             "file.blockreplace",
2805             name=name,
2806             content=self.content,
2807             marker_start=self.marker_start,
2808             marker_end=self.marker_end,
2809             prepend_if_not_found=True,
2810             append_newline=False,
2811         )
2812         self.assertSaltTrueReturn(ret)
2813         self.assertTrue(ret[next(iter(ret))]["changes"])
2814         self.assertEqual(self._read(name), expected)
2815         ret = self.run_state(
2816             "file.blockreplace",
2817             name=name,
2818             content=self.content,
2819             marker_start=self.marker_start,
2820             marker_end=self.marker_end,
2821             prepend_if_not_found=True,
2822             append_newline=False,
2823         )
2824         self.assertSaltTrueReturn(ret)
2825         self.assertFalse(ret[next(iter(ret))]["changes"])
2826         self.assertEqual(self._read(name), expected)
2827         expected = (
2828             self.marker_start
2829             + os.linesep
2830             + self.content.rstrip("\r\n")
2831             + self.marker_end
2832             + os.linesep
2833             + self.without_block
2834         )
2835         self._write(name, self.without_block)
2836         ret = self.run_state(
2837             "file.blockreplace",
2838             name=name,
2839             content=self.content.rstrip("\r\n"),
2840             marker_start=self.marker_start,
2841             marker_end=self.marker_end,
2842             prepend_if_not_found=True,
2843             append_newline=False,
2844         )
2845         self.assertSaltTrueReturn(ret)
2846         self.assertTrue(ret[next(iter(ret))]["changes"])
2847         self.assertEqual(self._read(name), expected)
2848         ret = self.run_state(
2849             "file.blockreplace",
2850             name=name,
2851             content=self.content.rstrip("\r\n"),
2852             marker_start=self.marker_start,
2853             marker_end=self.marker_end,
2854             prepend_if_not_found=True,
2855             append_newline=False,
2856         )
2857         self.assertSaltTrueReturn(ret)
2858         self.assertFalse(ret[next(iter(ret))]["changes"])
2859         self.assertEqual(self._read(name), expected)
2860     @with_tempfile()
2861     def test_append(self, name):
2862         """
2863         Test blockreplace when append_if_not_found=True and block doesn't
2864         exist in file.
2865         """
2866         expected = (
2867             self.without_block
2868             + self.marker_start
2869             + os.linesep
2870             + self.content
2871             + self.marker_end
2872             + os.linesep
2873         )
2874         self._write(name, self.without_block)
2875         ret = self.run_state(
2876             "file.blockreplace",
2877             name=name,
2878             content=self.content,
2879             marker_start=self.marker_start,
2880             marker_end=self.marker_end,
2881             append_if_not_found=True,
2882         )
2883         self.assertSaltTrueReturn(ret)
2884         self.assertTrue(ret[next(iter(ret))]["changes"])
2885         self.assertEqual(self._read(name), expected)
2886         ret = self.run_state(
2887             "file.blockreplace",
2888             name=name,
2889             content=self.content,
2890             marker_start=self.marker_start,
2891             marker_end=self.marker_end,
2892             append_if_not_found=True,
2893         )
2894         self.assertSaltTrueReturn(ret)
2895         self.assertFalse(ret[next(iter(ret))]["changes"])
2896         self.assertEqual(self._read(name), expected)
2897         self._write(name, self.without_block)
2898         ret = self.run_state(
2899             "file.blockreplace",
2900             name=name,
2901             content=self.content.rstrip("\r\n"),
2902             marker_start=self.marker_start,
2903             marker_end=self.marker_end,
2904             append_if_not_found=True,
2905         )
2906         self.assertSaltTrueReturn(ret)
2907         self.assertTrue(ret[next(iter(ret))]["changes"])
2908         self.assertEqual(self._read(name), expected)
2909         ret = self.run_state(
2910             "file.blockreplace",
2911             name=name,
2912             content=self.content.rstrip("\r\n"),
2913             marker_start=self.marker_start,
2914             marker_end=self.marker_end,
2915             append_if_not_found=True,
2916         )
2917         self.assertSaltTrueReturn(ret)
2918         self.assertFalse(ret[next(iter(ret))]["changes"])
2919         self.assertEqual(self._read(name), expected)
2920     @with_tempfile()
2921     def test_append_append_newline(self, name):
2922         """
2923         Test blockreplace when append_if_not_found=True and block doesn't
2924         exist in file. Test with append_newline explicitly set to True.
2925         """
2926         expected = (
2927             self.without_block
2928             + self.marker_start
2929             + os.linesep
2930             + self.content
2931             + os.linesep
2932             + self.marker_end
2933             + os.linesep
2934         )
2935         self._write(name, self.without_block)
2936         ret = self.run_state(
2937             "file.blockreplace",
2938             name=name,
2939             content=self.content,
2940             marker_start=self.marker_start,
2941             marker_end=self.marker_end,
2942             append_if_not_found=True,
2943             append_newline=True,
2944         )
2945         self.assertSaltTrueReturn(ret)
2946         self.assertTrue(ret[next(iter(ret))]["changes"])
2947         self.assertEqual(self._read(name), expected)
2948         ret = self.run_state(
2949             "file.blockreplace",
2950             name=name,
2951             content=self.content,
2952             marker_start=self.marker_start,
2953             marker_end=self.marker_end,
2954             append_if_not_found=True,
2955             append_newline=True,
2956         )
2957         self.assertSaltTrueReturn(ret)
2958         self.assertFalse(ret[next(iter(ret))]["changes"])
2959         self.assertEqual(self._read(name), expected)
2960         expected = (
2961             self.without_block
2962             + self.marker_start
2963             + os.linesep
2964             + self.content
2965             + self.marker_end
2966             + os.linesep
2967         )
2968         self._write(name, self.without_block)
2969         ret = self.run_state(
2970             "file.blockreplace",
2971             name=name,
2972             content=self.content.rstrip("\r\n"),
2973             marker_start=self.marker_start,
2974             marker_end=self.marker_end,
2975             append_if_not_found=True,
2976             append_newline=True,
2977         )
2978         self.assertSaltTrueReturn(ret)
2979         self.assertTrue(ret[next(iter(ret))]["changes"])
2980         self.assertEqual(self._read(name), expected)
2981         ret = self.run_state(
2982             "file.blockreplace",
2983             name=name,
2984             content=self.content.rstrip("\r\n"),
2985             marker_start=self.marker_start,
2986             marker_end=self.marker_end,
2987             append_if_not_found=True,
2988             append_newline=True,
2989         )
2990         self.assertSaltTrueReturn(ret)
2991         self.assertFalse(ret[next(iter(ret))]["changes"])
2992         self.assertEqual(self._read(name), expected)
2993     @with_tempfile()
2994     def test_append_no_append_newline(self, name):
2995         """
2996         Test blockreplace when append_if_not_found=True and block doesn't
2997         exist in file. Test with append_newline explicitly set to False.
2998         """
2999         expected = (
3000             self.without_block
3001             + self.marker_start
3002             + os.linesep
3003             + self.content
3004             + self.marker_end
3005             + os.linesep
3006         )
3007         self._write(name, self.without_block)
3008         ret = self.run_state(
3009             "file.blockreplace",
3010             name=name,
3011             content=self.content,
3012             marker_start=self.marker_start,
3013             marker_end=self.marker_end,
3014             append_if_not_found=True,
3015             append_newline=False,
3016         )
3017         self.assertSaltTrueReturn(ret)
3018         self.assertTrue(ret[next(iter(ret))]["changes"])
3019         self.assertEqual(self._read(name), expected)
3020         ret = self.run_state(
3021             "file.blockreplace",
3022             name=name,
3023             content=self.content,
3024             marker_start=self.marker_start,
3025             marker_end=self.marker_end,
3026             append_if_not_found=True,
3027             append_newline=False,
3028         )
3029         self.assertSaltTrueReturn(ret)
3030         self.assertFalse(ret[next(iter(ret))]["changes"])
3031         self.assertEqual(self._read(name), expected)
3032         expected = (
3033             self.without_block
3034             + self.marker_start
3035             + os.linesep
3036             + self.content.rstrip("\r\n")
3037             + self.marker_end
3038             + os.linesep
3039         )
3040         self._write(name, self.without_block)
3041         ret = self.run_state(
3042             "file.blockreplace",
3043             name=name,
3044             content=self.content.rstrip("\r\n"),
3045             marker_start=self.marker_start,
3046             marker_end=self.marker_end,
3047             append_if_not_found=True,
3048             append_newline=False,
3049         )
3050         self.assertSaltTrueReturn(ret)
3051         self.assertTrue(ret[next(iter(ret))]["changes"])
3052         self.assertEqual(self._read(name), expected)
3053         ret = self.run_state(
3054             "file.blockreplace",
3055             name=name,
3056             content=self.content.rstrip("\r\n"),
3057             marker_start=self.marker_start,
3058             marker_end=self.marker_end,
3059             append_if_not_found=True,
3060             append_newline=False,
3061         )
3062         self.assertSaltTrueReturn(ret)
3063         self.assertFalse(ret[next(iter(ret))]["changes"])
3064         self.assertEqual(self._read(name), expected)
3065     @with_tempfile()
3066     def test_prepend_auto_line_separator(self, name):
3067         """
3068         This tests the line separator auto-detection when prepending the block
3069         """
3070         self._write(name, self.without_block_explicit_windows_newlines)
3071         ret = self.run_state(
3072             "file.blockreplace",
3073             name=name,
3074             content=self.content_explicit_posix_newlines,
3075             marker_start=self.marker_start,
3076             marker_end=self.marker_end,
3077             prepend_if_not_found=True,
3078         )
3079         self.assertSaltTrueReturn(ret)
3080         self.assertTrue(ret[next(iter(ret))]["changes"])
3081         self.assertEqual(
3082             self._read(name), self.with_block_prepended_explicit_windows_newlines
3083         )
3084         ret = self.run_state(
3085             "file.blockreplace",
3086             name=name,
3087             content=self.content_explicit_posix_newlines,
3088             marker_start=self.marker_start,
3089             marker_end=self.marker_end,
3090             prepend_if_not_found=True,
3091         )
3092         self.assertSaltTrueReturn(ret)
3093         self.assertFalse(ret[next(iter(ret))]["changes"])
3094         self.assertEqual(
3095             self._read(name), self.with_block_prepended_explicit_windows_newlines
3096         )
3097         self._write(name, self.without_block_explicit_posix_newlines)
3098         ret = self.run_state(
3099             "file.blockreplace",
3100             name=name,
3101             content=self.content_explicit_windows_newlines,
3102             marker_start=self.marker_start,
3103             marker_end=self.marker_end,
3104             prepend_if_not_found=True,
3105         )
3106         self.assertSaltTrueReturn(ret)
3107         self.assertTrue(ret[next(iter(ret))]["changes"])
3108         self.assertEqual(
3109             self._read(name), self.with_block_prepended_explicit_posix_newlines
3110         )
3111         ret = self.run_state(
3112             "file.blockreplace",
3113             name=name,
3114             content=self.content_explicit_windows_newlines,
3115             marker_start=self.marker_start,
3116             marker_end=self.marker_end,
3117             prepend_if_not_found=True,
3118         )
3119         self.assertSaltTrueReturn(ret)
3120         self.assertFalse(ret[next(iter(ret))]["changes"])
3121         self.assertEqual(
3122             self._read(name), self.with_block_prepended_explicit_posix_newlines
3123         )
3124     @with_tempfile()
3125     def test_append_auto_line_separator(self, name):
3126         """
3127         This tests the line separator auto-detection when appending the block
3128         """
3129         self._write(name, self.without_block_explicit_windows_newlines)
3130         ret = self.run_state(
3131             "file.blockreplace",
3132             name=name,
3133             content=self.content_explicit_posix_newlines,
3134             marker_start=self.marker_start,
3135             marker_end=self.marker_end,
3136             append_if_not_found=True,
3137         )
3138         self.assertSaltTrueReturn(ret)
3139         self.assertTrue(ret[next(iter(ret))]["changes"])
3140         self.assertEqual(
3141             self._read(name), self.with_block_appended_explicit_windows_newlines
3142         )
3143         ret = self.run_state(
3144             "file.blockreplace",
3145             name=name,
3146             content=self.content_explicit_posix_newlines,
3147             marker_start=self.marker_start,
3148             marker_end=self.marker_end,
3149             append_if_not_found=True,
3150         )
3151         self.assertSaltTrueReturn(ret)
3152         self.assertFalse(ret[next(iter(ret))]["changes"])
3153         self.assertEqual(
3154             self._read(name), self.with_block_appended_explicit_windows_newlines
3155         )
3156         self._write(name, self.without_block_explicit_posix_newlines)
3157         ret = self.run_state(
3158             "file.blockreplace",
3159             name=name,
3160             content=self.content_explicit_windows_newlines,
3161             marker_start=self.marker_start,
3162             marker_end=self.marker_end,
3163             append_if_not_found=True,
3164         )
3165         self.assertSaltTrueReturn(ret)
3166         self.assertTrue(ret[next(iter(ret))]["changes"])
3167         self.assertEqual(
3168             self._read(name), self.with_block_appended_explicit_posix_newlines
3169         )
3170         ret = self.run_state(
3171             "file.blockreplace",
3172             name=name,
3173             content=self.content_explicit_windows_newlines,
3174             marker_start=self.marker_start,
3175             marker_end=self.marker_end,
3176             append_if_not_found=True,
3177         )
3178         self.assertSaltTrueReturn(ret)
3179         self.assertFalse(ret[next(iter(ret))]["changes"])
3180         self.assertEqual(
3181             self._read(name), self.with_block_appended_explicit_posix_newlines
3182         )
3183     @with_tempfile()
3184     def test_non_matching_block(self, name):
3185         """
3186         Test blockreplace when block exists but its contents are not a
3187         match.
3188         """
3189         self._write(name, self.with_non_matching_block)
3190         ret = self.run_state(
3191             "file.blockreplace",
3192             name=name,
3193             content=self.content,
3194             marker_start=self.marker_start,
3195             marker_end=self.marker_end,
3196         )
3197         self.assertSaltTrueReturn(ret)
3198         self.assertTrue(ret[next(iter(ret))]["changes"])
3199         self.assertEqual(self._read(name), self.with_matching_block)
3200         ret = self.run_state(
3201             "file.blockreplace",
3202             name=name,
3203             content=self.content,
3204             marker_start=self.marker_start,
3205             marker_end=self.marker_end,
3206         )
3207         self.assertSaltTrueReturn(ret)
3208         self.assertFalse(ret[next(iter(ret))]["changes"])
3209         self.assertEqual(self._read(name), self.with_matching_block)
3210         self._write(name, self.with_non_matching_block)
3211         ret = self.run_state(
3212             "file.blockreplace",
3213             name=name,
3214             content=self.content.rstrip("\r\n"),
3215             marker_start=self.marker_start,
3216             marker_end=self.marker_end,
3217         )
3218         self.assertSaltTrueReturn(ret)
3219         self.assertTrue(ret[next(iter(ret))]["changes"])
3220         self.assertEqual(self._read(name), self.with_matching_block)
3221         ret = self.run_state(
3222             "file.blockreplace",
3223             name=name,
3224             content=self.content.rstrip("\r\n"),
3225             marker_start=self.marker_start,
3226             marker_end=self.marker_end,
3227         )
3228         self.assertSaltTrueReturn(ret)
3229         self.assertFalse(ret[next(iter(ret))]["changes"])
3230         self.assertEqual(self._read(name), self.with_matching_block)
3231     @with_tempfile()
3232     def test_non_matching_block_append_newline(self, name):
3233         """
3234         Test blockreplace when block exists but its contents are not a
3235         match. Test with append_newline explicitly set to True.
3236         """
3237         self._write(name, self.with_non_matching_block)
3238         ret = self.run_state(
3239             "file.blockreplace",
3240             name=name,
3241             content=self.content,
3242             marker_start=self.marker_start,
3243             marker_end=self.marker_end,
3244             append_newline=True,
3245         )
3246         self.assertSaltTrueReturn(ret)
3247         self.assertTrue(ret[next(iter(ret))]["changes"])
3248         self.assertEqual(self._read(name), self.with_matching_block_and_extra_newline)
3249         ret = self.run_state(
3250             "file.blockreplace",
3251             name=name,
3252             content=self.content,
3253             marker_start=self.marker_start,
3254             marker_end=self.marker_end,
3255             append_newline=True,
3256         )
3257         self.assertSaltTrueReturn(ret)
3258         self.assertFalse(ret[next(iter(ret))]["changes"])
3259         self.assertEqual(self._read(name), self.with_matching_block_and_extra_newline)
3260         self._write(name, self.with_non_matching_block)
3261         ret = self.run_state(
3262             "file.blockreplace",
3263             name=name,
3264             content=self.content.rstrip("\r\n"),
3265             marker_start=self.marker_start,
3266             marker_end=self.marker_end,
3267             append_newline=True,
3268         )
3269         self.assertSaltTrueReturn(ret)
3270         self.assertTrue(ret[next(iter(ret))]["changes"])
3271         self.assertEqual(self._read(name), self.with_matching_block)
3272         ret = self.run_state(
3273             "file.blockreplace",
3274             name=name,
3275             content=self.content.rstrip("\r\n"),
3276             marker_start=self.marker_start,
3277             marker_end=self.marker_end,
3278             append_newline=True,
3279         )
3280         self.assertSaltTrueReturn(ret)
3281         self.assertFalse(ret[next(iter(ret))]["changes"])
3282         self.assertEqual(self._read(name), self.with_matching_block)
3283     @with_tempfile()
3284     def test_non_matching_block_no_append_newline(self, name):
3285         """
3286         Test blockreplace when block exists but its contents are not a
3287         match. Test with append_newline explicitly set to False.
3288         """
3289         self._write(name, self.with_non_matching_block)
3290         ret = self.run_state(
3291             "file.blockreplace",
3292             name=name,
3293             content=self.content,
3294             marker_start=self.marker_start,
3295             marker_end=self.marker_end,
3296             append_newline=False,
3297         )
3298         self.assertSaltTrueReturn(ret)
3299         self.assertTrue(ret[next(iter(ret))]["changes"])
3300         self.assertEqual(self._read(name), self.with_matching_block)
3301         ret = self.run_state(
3302             "file.blockreplace",
3303             name=name,
3304             content=self.content,
3305             marker_start=self.marker_start,
3306             marker_end=self.marker_end,
3307             append_newline=False,
3308         )
3309         self.assertSaltTrueReturn(ret)
3310         self.assertFalse(ret[next(iter(ret))]["changes"])
3311         self.assertEqual(self._read(name), self.with_matching_block)
3312         self._write(name, self.with_non_matching_block)
3313         ret = self.run_state(
3314             "file.blockreplace",
3315             name=name,
3316             content=self.content.rstrip("\r\n"),
3317             marker_start=self.marker_start,
3318             marker_end=self.marker_end,
3319             append_newline=False,
3320         )
3321         self.assertSaltTrueReturn(ret)
3322         self.assertTrue(ret[next(iter(ret))]["changes"])
3323         self.assertEqual(
3324             self._read(name), self.with_matching_block_and_marker_end_not_after_newline
3325         )
3326         ret = self.run_state(
3327             "file.blockreplace",
3328             name=name,
3329             content=self.content.rstrip("\r\n"),
3330             marker_start=self.marker_start,
3331             marker_end=self.marker_end,
3332             append_newline=False,
3333         )
3334         self.assertSaltTrueReturn(ret)
3335         self.assertFalse(ret[next(iter(ret))]["changes"])
3336         self.assertEqual(
3337             self._read(name), self.with_matching_block_and_marker_end_not_after_newline
3338         )
3339     @with_tempfile()
3340     def test_non_matching_block_and_marker_not_after_newline(self, name):
3341         """
3342         Test blockreplace when block exists but its contents are not a
3343         match, and the marker_end is not directly preceded by a newline.
3344         """
3345         self._write(name, self.with_non_matching_block_and_marker_end_not_after_newline)
3346         ret = self.run_state(
3347             "file.blockreplace",
3348             name=name,
3349             content=self.content,
3350             marker_start=self.marker_start,
3351             marker_end=self.marker_end,
3352         )
3353         self.assertSaltTrueReturn(ret)
3354         self.assertTrue(ret[next(iter(ret))]["changes"])
3355         self.assertEqual(self._read(name), self.with_matching_block)
3356         ret = self.run_state(
3357             "file.blockreplace",
3358             name=name,
3359             content=self.content,
3360             marker_start=self.marker_start,
3361             marker_end=self.marker_end,
3362         )
3363         self.assertSaltTrueReturn(ret)
3364         self.assertFalse(ret[next(iter(ret))]["changes"])
3365         self.assertEqual(self._read(name), self.with_matching_block)
3366         self._write(name, self.with_non_matching_block_and_marker_end_not_after_newline)
3367         ret = self.run_state(
3368             "file.blockreplace",
3369             name=name,
3370             content=self.content.rstrip("\r\n"),
3371             marker_start=self.marker_start,
3372             marker_end=self.marker_end,
3373         )
3374         self.assertSaltTrueReturn(ret)
3375         self.assertTrue(ret[next(iter(ret))]["changes"])
3376         self.assertEqual(self._read(name), self.with_matching_block)
3377         ret = self.run_state(
3378             "file.blockreplace",
3379             name=name,
3380             content=self.content.rstrip("\r\n"),
3381             marker_start=self.marker_start,
3382             marker_end=self.marker_end,
3383         )
3384         self.assertSaltTrueReturn(ret)
3385         self.assertFalse(ret[next(iter(ret))]["changes"])
3386         self.assertEqual(self._read(name), self.with_matching_block)
3387     @with_tempfile()
3388     def test_non_matching_block_and_marker_not_after_newline_append_newline(self, name):
3389         """
3390         Test blockreplace when block exists but its contents are not a match,
3391         and the marker_end is not directly preceded by a newline. Test with
3392         append_newline explicitly set to True.
3393         """
3394         self._write(name, self.with_non_matching_block_and_marker_end_not_after_newline)
3395         ret = self.run_state(
3396             "file.blockreplace",
3397             name=name,
3398             content=self.content,
3399             marker_start=self.marker_start,
3400             marker_end=self.marker_end,
3401             append_newline=True,
3402         )
3403         self.assertSaltTrueReturn(ret)
3404         self.assertTrue(ret[next(iter(ret))]["changes"])
3405         self.assertEqual(self._read(name), self.with_matching_block_and_extra_newline)
3406         ret = self.run_state(
3407             "file.blockreplace",
3408             name=name,
3409             content=self.content,
3410             marker_start=self.marker_start,
3411             marker_end=self.marker_end,
3412             append_newline=True,
3413         )
3414         self.assertSaltTrueReturn(ret)
3415         self.assertFalse(ret[next(iter(ret))]["changes"])
3416         self.assertEqual(self._read(name), self.with_matching_block_and_extra_newline)
3417         self._write(name, self.with_non_matching_block_and_marker_end_not_after_newline)
3418         ret = self.run_state(
3419             "file.blockreplace",
3420             name=name,
3421             content=self.content.rstrip("\r\n"),
3422             marker_start=self.marker_start,
3423             marker_end=self.marker_end,
3424             append_newline=True,
3425         )
3426         self.assertSaltTrueReturn(ret)
3427         self.assertTrue(ret[next(iter(ret))]["changes"])
3428         self.assertEqual(self._read(name), self.with_matching_block)
3429         ret = self.run_state(
3430             "file.blockreplace",
3431             name=name,
3432             content=self.content.rstrip("\r\n"),
3433             marker_start=self.marker_start,
3434             marker_end=self.marker_end,
3435             append_newline=True,
3436         )
3437         self.assertSaltTrueReturn(ret)
3438         self.assertFalse(ret[next(iter(ret))]["changes"])
3439         self.assertEqual(self._read(name), self.with_matching_block)
3440     @with_tempfile()
3441     def test_non_matching_block_and_marker_not_after_newline_no_append_newline(
3442         self, name
3443     ):
3444         """
3445         Test blockreplace when block exists but its contents are not a match,
3446         and the marker_end is not directly preceded by a newline. Test with
3447         append_newline explicitly set to False.
3448         """
3449         self._write(name, self.with_non_matching_block_and_marker_end_not_after_newline)
3450         ret = self.run_state(
3451             "file.blockreplace",
3452             name=name,
3453             content=self.content,
3454             marker_start=self.marker_start,
3455             marker_end=self.marker_end,
3456             append_newline=False,
3457         )
3458         self.assertSaltTrueReturn(ret)
3459         self.assertTrue(ret[next(iter(ret))]["changes"])
3460         self.assertEqual(self._read(name), self.with_matching_block)
3461         ret = self.run_state(
3462             "file.blockreplace",
3463             name=name,
3464             content=self.content,
3465             marker_start=self.marker_start,
3466             marker_end=self.marker_end,
3467             append_newline=False,
3468         )
3469         self.assertSaltTrueReturn(ret)
3470         self.assertFalse(ret[next(iter(ret))]["changes"])
3471         self.assertEqual(self._read(name), self.with_matching_block)
3472         self._write(name, self.with_non_matching_block_and_marker_end_not_after_newline)
3473         ret = self.run_state(
3474             "file.blockreplace",
3475             name=name,
3476             content=self.content.rstrip("\r\n"),
3477             marker_start=self.marker_start,
3478             marker_end=self.marker_end,
3479             append_newline=False,
3480         )
3481         self.assertSaltTrueReturn(ret)
3482         self.assertTrue(ret[next(iter(ret))]["changes"])
3483         self.assertEqual(
3484             self._read(name), self.with_matching_block_and_marker_end_not_after_newline
3485         )
3486         ret = self.run_state(
3487             "file.blockreplace",
3488             name=name,
3489             content=self.content.rstrip("\r\n"),
3490             marker_start=self.marker_start,
3491             marker_end=self.marker_end,
3492             append_newline=False,
3493         )
3494         self.assertSaltTrueReturn(ret)
3495         self.assertFalse(ret[next(iter(ret))]["changes"])
3496         self.assertEqual(
3497             self._read(name), self.with_matching_block_and_marker_end_not_after_newline
3498         )
3499     @with_tempfile()
3500     def test_matching_block(self, name):
3501         """
3502         Test blockreplace when block exists and its contents are a match. No
3503         changes should be made.
3504         """
3505         self._write(name, self.with_matching_block)
3506         ret = self.run_state(
3507             "file.blockreplace",
3508             name=name,
3509             content=self.content,
3510             marker_start=self.marker_start,
3511             marker_end=self.marker_end,
3512         )
3513         self.assertSaltTrueReturn(ret)
3514         self.assertFalse(ret[next(iter(ret))]["changes"])
3515         self.assertEqual(self._read(name), self.with_matching_block)
3516         ret = self.run_state(
3517             "file.blockreplace",
3518             name=name,
3519             content=self.content,
3520             marker_start=self.marker_start,
3521             marker_end=self.marker_end,
3522         )
3523         self.assertSaltTrueReturn(ret)
3524         self.assertFalse(ret[next(iter(ret))]["changes"])
3525         self.assertEqual(self._read(name), self.with_matching_block)
3526         self._write(name, self.with_matching_block)
3527         ret = self.run_state(
3528             "file.blockreplace",
3529             name=name,
3530             content=self.content.rstrip("\r\n"),
3531             marker_start=self.marker_start,
3532             marker_end=self.marker_end,
3533         )
3534         self.assertSaltTrueReturn(ret)
3535         self.assertFalse(ret[next(iter(ret))]["changes"])
3536         self.assertEqual(self._read(name), self.with_matching_block)
3537         ret = self.run_state(
3538             "file.blockreplace",
3539             name=name,
3540             content=self.content.rstrip("\r\n"),
3541             marker_start=self.marker_start,
3542             marker_end=self.marker_end,
3543         )
3544         self.assertSaltTrueReturn(ret)
3545         self.assertFalse(ret[next(iter(ret))]["changes"])
3546         self.assertEqual(self._read(name), self.with_matching_block)
3547     @with_tempfile()
3548     def test_matching_block_append_newline(self, name):
3549         """
3550         Test blockreplace when block exists and its contents are a match. Test
3551         with append_newline explicitly set to True. This will result in an
3552         extra newline when the content ends in a newline, and will not when the
3553         content does not end in a newline.
3554         """
3555         self._write(name, self.with_matching_block)
3556         ret = self.run_state(
3557             "file.blockreplace",
3558             name=name,
3559             content=self.content,
3560             marker_start=self.marker_start,
3561             marker_end=self.marker_end,
3562             append_newline=True,
3563         )
3564         self.assertSaltTrueReturn(ret)
3565         self.assertTrue(ret[next(iter(ret))]["changes"])
3566         self.assertEqual(self._read(name), self.with_matching_block_and_extra_newline)
3567         ret = self.run_state(
3568             "file.blockreplace",
3569             name=name,
3570             content=self.content,
3571             marker_start=self.marker_start,
3572             marker_end=self.marker_end,
3573             append_newline=True,
3574         )
3575         self.assertSaltTrueReturn(ret)
3576         self.assertFalse(ret[next(iter(ret))]["changes"])
3577         self.assertEqual(self._read(name), self.with_matching_block_and_extra_newline)
3578         self._write(name, self.with_matching_block)
3579         ret = self.run_state(
3580             "file.blockreplace",
3581             name=name,
3582             content=self.content.rstrip("\r\n"),
3583             marker_start=self.marker_start,
3584             marker_end=self.marker_end,
3585             append_newline=True,
3586         )
3587         self.assertSaltTrueReturn(ret)
3588         self.assertFalse(ret[next(iter(ret))]["changes"])
3589         self.assertEqual(self._read(name), self.with_matching_block)
3590         ret = self.run_state(
3591             "file.blockreplace",
3592             name=name,
3593             content=self.content.rstrip("\r\n"),
3594             marker_start=self.marker_start,
3595             marker_end=self.marker_end,
3596             append_newline=True,
3597         )
3598         self.assertSaltTrueReturn(ret)
3599         self.assertFalse(ret[next(iter(ret))]["changes"])
3600         self.assertEqual(self._read(name), self.with_matching_block)
3601     @with_tempfile()
3602     def test_matching_block_no_append_newline(self, name):
3603         """
3604         Test blockreplace when block exists and its contents are a match. Test
3605         with append_newline explicitly set to False. This will result in the
3606         marker_end not being directly preceded by a newline when the content
3607         does not end in a newline.
3608         """
3609         self._write(name, self.with_matching_block)
3610         ret = self.run_state(
3611             "file.blockreplace",
3612             name=name,
3613             content=self.content,
3614             marker_start=self.marker_start,
3615             marker_end=self.marker_end,
3616             append_newline=False,
3617         )
3618         self.assertSaltTrueReturn(ret)
3619         self.assertFalse(ret[next(iter(ret))]["changes"])
3620         self.assertEqual(self._read(name), self.with_matching_block)
3621         ret = self.run_state(
3622             "file.blockreplace",
3623             name=name,
3624             content=self.content,
3625             marker_start=self.marker_start,
3626             marker_end=self.marker_end,
3627             append_newline=False,
3628         )
3629         self.assertSaltTrueReturn(ret)
3630         self.assertFalse(ret[next(iter(ret))]["changes"])
3631         self.assertEqual(self._read(name), self.with_matching_block)
3632         self._write(name, self.with_matching_block)
3633         ret = self.run_state(
3634             "file.blockreplace",
3635             name=name,
3636             content=self.content.rstrip("\r\n"),
3637             marker_start=self.marker_start,
3638             marker_end=self.marker_end,
3639             append_newline=False,
3640         )
3641         self.assertSaltTrueReturn(ret)
3642         self.assertTrue(ret[next(iter(ret))]["changes"])
3643         self.assertEqual(
3644             self._read(name), self.with_matching_block_and_marker_end_not_after_newline
3645         )
3646         ret = self.run_state(
3647             "file.blockreplace",
3648             name=name,
3649             content=self.content.rstrip("\r\n"),
3650             marker_start=self.marker_start,
3651             marker_end=self.marker_end,
3652             append_newline=False,
3653         )
3654         self.assertSaltTrueReturn(ret)
3655         self.assertFalse(ret[next(iter(ret))]["changes"])
3656         self.assertEqual(
3657             self._read(name), self.with_matching_block_and_marker_end_not_after_newline
3658         )
3659     @with_tempfile()
3660     def test_matching_block_and_marker_not_after_newline(self, name):
3661         """
3662         Test blockreplace when block exists and its contents are a match, but
3663         the marker_end is not directly preceded by a newline.
3664         """
3665         self._write(name, self.with_matching_block_and_marker_end_not_after_newline)
3666         ret = self.run_state(
3667             "file.blockreplace",
3668             name=name,
3669             content=self.content,
3670             marker_start=self.marker_start,
3671             marker_end=self.marker_end,
3672         )
3673         self.assertSaltTrueReturn(ret)
3674         self.assertTrue(ret[next(iter(ret))]["changes"])
3675         self.assertEqual(self._read(name), self.with_matching_block)
3676         ret = self.run_state(
3677             "file.blockreplace",
3678             name=name,
3679             content=self.content,
3680             marker_start=self.marker_start,
3681             marker_end=self.marker_end,
3682         )
3683         self.assertSaltTrueReturn(ret)
3684         self.assertFalse(ret[next(iter(ret))]["changes"])
3685         self.assertEqual(self._read(name), self.with_matching_block)
3686         self._write(name, self.with_matching_block_and_marker_end_not_after_newline)
3687         ret = self.run_state(
3688             "file.blockreplace",
3689             name=name,
3690             content=self.content.rstrip("\r\n"),
3691             marker_start=self.marker_start,
3692             marker_end=self.marker_end,
3693         )
3694         self.assertSaltTrueReturn(ret)
3695         self.assertTrue(ret[next(iter(ret))]["changes"])
3696         self.assertEqual(self._read(name), self.with_matching_block)
3697         ret = self.run_state(
3698             "file.blockreplace",
3699             name=name,
3700             content=self.content.rstrip("\r\n"),
3701             marker_start=self.marker_start,
3702             marker_end=self.marker_end,
3703         )
3704         self.assertSaltTrueReturn(ret)
3705         self.assertFalse(ret[next(iter(ret))]["changes"])
3706         self.assertEqual(self._read(name), self.with_matching_block)
3707     @with_tempfile()
3708     def test_matching_block_and_marker_not_after_newline_append_newline(self, name):
3709         """
3710         Test blockreplace when block exists and its contents are a match, but
3711         the marker_end is not directly preceded by a newline. Test with
3712         append_newline explicitly set to True. This will result in an extra
3713         newline when the content ends in a newline, and will not when the
3714         content does not end in a newline.
3715         """
3716         self._write(name, self.with_matching_block_and_marker_end_not_after_newline)
3717         ret = self.run_state(
3718             "file.blockreplace",
3719             name=name,
3720             content=self.content,
3721             marker_start=self.marker_start,
3722             marker_end=self.marker_end,
3723             append_newline=True,
3724         )
3725         self.assertSaltTrueReturn(ret)
3726         self.assertTrue(ret[next(iter(ret))]["changes"])
3727         self.assertEqual(self._read(name), self.with_matching_block_and_extra_newline)
3728         ret = self.run_state(
3729             "file.blockreplace",
3730             name=name,
3731             content=self.content,
3732             marker_start=self.marker_start,
3733             marker_end=self.marker_end,
3734             append_newline=True,
3735         )
3736         self.assertSaltTrueReturn(ret)
3737         self.assertFalse(ret[next(iter(ret))]["changes"])
3738         self.assertEqual(self._read(name), self.with_matching_block_and_extra_newline)
3739         self._write(name, self.with_matching_block_and_marker_end_not_after_newline)
3740         ret = self.run_state(
3741             "file.blockreplace",
3742             name=name,
3743             content=self.content.rstrip("\r\n"),
3744             marker_start=self.marker_start,
3745             marker_end=self.marker_end,
3746             append_newline=True,
3747         )
3748         self.assertSaltTrueReturn(ret)
3749         self.assertTrue(ret[next(iter(ret))]["changes"])
3750         self.assertEqual(self._read(name), self.with_matching_block)
3751         ret = self.run_state(
3752             "file.blockreplace",
3753             name=name,
3754             content=self.content.rstrip("\r\n"),
3755             marker_start=self.marker_start,
3756             marker_end=self.marker_end,
3757             append_newline=True,
3758         )
3759         self.assertSaltTrueReturn(ret)
3760         self.assertFalse(ret[next(iter(ret))]["changes"])
3761         self.assertEqual(self._read(name), self.with_matching_block)
3762     @with_tempfile()
3763     def test_matching_block_and_marker_not_after_newline_no_append_newline(self, name):
3764         """
3765         Test blockreplace when block exists and its contents are a match, but
3766         the marker_end is not directly preceded by a newline. Test with
3767         append_newline explicitly set to False.
3768         """
3769         self._write(name, self.with_matching_block_and_marker_end_not_after_newline)
3770         ret = self.run_state(
3771             "file.blockreplace",
3772             name=name,
3773             content=self.content,
3774             marker_start=self.marker_start,
3775             marker_end=self.marker_end,
3776             append_newline=False,
3777         )
3778         self.assertSaltTrueReturn(ret)
3779         self.assertTrue(ret[next(iter(ret))]["changes"])
3780         self.assertEqual(self._read(name), self.with_matching_block)
3781         ret = self.run_state(
3782             "file.blockreplace",
3783             name=name,
3784             content=self.content,
3785             marker_start=self.marker_start,
3786             marker_end=self.marker_end,
3787             append_newline=False,
3788         )
3789         self.assertSaltTrueReturn(ret)
3790         self.assertFalse(ret[next(iter(ret))]["changes"])
3791         self.assertEqual(self._read(name), self.with_matching_block)
3792         self._write(name, self.with_matching_block_and_marker_end_not_after_newline)
3793         ret = self.run_state(
3794             "file.blockreplace",
3795             name=name,
3796             content=self.content.rstrip("\r\n"),
3797             marker_start=self.marker_start,
3798             marker_end=self.marker_end,
3799             append_newline=False,
3800         )
3801         self.assertSaltTrueReturn(ret)
3802         self.assertFalse(ret[next(iter(ret))]["changes"])
3803         self.assertEqual(
3804             self._read(name), self.with_matching_block_and_marker_end_not_after_newline
3805         )
3806         ret = self.run_state(
3807             "file.blockreplace",
3808             name=name,
3809             content=self.content.rstrip("\r\n"),
3810             marker_start=self.marker_start,
3811             marker_end=self.marker_end,
3812             append_newline=False,
3813         )
3814         self.assertSaltTrueReturn(ret)
3815         self.assertFalse(ret[next(iter(ret))]["changes"])
3816         self.assertEqual(
3817             self._read(name), self.with_matching_block_and_marker_end_not_after_newline
3818         )
3819     @with_tempfile()
3820     def test_issue_49043(self, name):
3821         ret = self.run_function(
3822             "state.sls",
3823             mods="issue-49043",
3824             pillar={"name": name},
3825         )
3826         log.error("ret = %s", repr(ret))
3827         diff = "--- \n+++ \n@@ -0,0 +1,3 @@\n"
3828         diff += dedent(
3829             """\
3830         +#-- start managed zone --
3831         +äöü
3832         +#-- end managed zone --
3833         """
3834         )
3835         job = "file_|-somefile-blockreplace_|-{}_|-blockreplace".format(name)
3836         self.assertEqual(ret[job]["changes"]["diff"], diff)
3837 @pytest.mark.windows_whitelisted
3838 class RemoteFileTest(ModuleCase, SaltReturnAssertsMixin):
3839     """
3840     Uses a local tornado webserver to test http(s) file.managed states with and
3841     without skip_verify
3842     """
3843     @classmethod
3844     def setUpClass(cls):
3845         cls.webserver = Webserver()
3846         cls.webserver.start()
3847         cls.source = cls.webserver.url("grail/scene33")
3848         if IS_WINDOWS:
3849             cls.source_hash = "21438b3d5fd2c0028bcab92f7824dc69"
3850         else:
3851             cls.source_hash = "d2feb3beb323c79fc7a0f44f1408b4a3"
3852     @classmethod
3853     def tearDownClass(cls):
3854         cls.webserver.stop()
3855     @with_tempfile(create=False)
3856     def setUp(self, name):  # pylint: disable=arguments-differ
3857         self.name = name
3858     def tearDown(self):
3859         try:
3860             os.remove(self.name)
3861         except OSError as exc:
3862             if exc.errno != errno.ENOENT:
3863                 raise
3864     def run_state(self, *args, **kwargs):  # pylint: disable=arguments-differ
3865         ret = super().run_state(*args, **kwargs)
3866         log.debug("ret = %s", ret)
3867         return ret
3868     def test_file_managed_http_source_no_hash(self):
3869         """
3870         Test a remote file with no hash
3871         """
3872         ret = self.run_state(
3873             "file.managed", name=self.name, source=self.source, skip_verify=False
3874         )
3875         self.assertSaltFalseReturn(ret)
3876     def test_file_managed_http_source(self):
3877         """
3878         Test a remote file with no hash
3879         """
3880         ret = self.run_state(
3881             "file.managed",
3882             name=self.name,
3883             source=self.source,
3884             source_hash=self.source_hash,
3885             skip_verify=False,
3886         )
3887         self.assertSaltTrueReturn(ret)
3888     def test_file_managed_http_source_skip_verify(self):
3889         """
3890         Test a remote file using skip_verify
3891         """
3892         ret = self.run_state(
3893             "file.managed", name=self.name, source=self.source, skip_verify=True
3894         )
3895         self.assertSaltTrueReturn(ret)
3896     def test_file_managed_keep_source_false_http(self):
3897         """
3898         This test ensures that we properly clean the cached file if keep_source
3899         is set to False, for source files using an http:// URL
3900         """
3901         ret = self.run_state(
3902             "file.managed",
3903             name=self.name,
3904             source=self.source,
3905             source_hash=self.source_hash,
3906             keep_source=False,
3907         )
3908         ret = ret[next(iter(ret))]
3909         assert ret["result"] is True
3910         result = self.run_function("cp.is_cached", [self.source])
3911         assert result == "", "File is still cached at {}".format(result)
3912 @skipIf(not salt.utils.path.which("patch"), "patch is not installed")
3913 @pytest.mark.windows_whitelisted
3914 class PatchTest(ModuleCase, SaltReturnAssertsMixin):
3915     def _check_patch_version(self, min_version):
3916         """
3917         patch version check
3918         """
3919         version = self.run_function("cmd.run", ["patch --version"]).splitlines()[0]
3920         version = version.split()[1]
3921         if _LooseVersion(version) &lt; _LooseVersion(min_version):
3922             self.skipTest(
3923                 "Minimum patch version required: {}. "
3924                 "Patch version installed: {}".format(min_version, version)
3925             )
3926     @classmethod
3927     def setUpClass(cls):
3928         cls.webserver = Webserver()
3929         cls.webserver.start()
3930         cls.numbers_patch_name = "numbers.patch"
3931         cls.math_patch_name = "math.patch"
3932         cls.all_patch_name = "all.patch"
3933         cls.numbers_patch_template_name = cls.numbers_patch_name + ".jinja"
3934         cls.math_patch_template_name = cls.math_patch_name + ".jinja"
3935         cls.all_patch_template_name = cls.all_patch_name + ".jinja"
3936         cls.numbers_patch_path = "patches/" + cls.numbers_patch_name
3937         cls.math_patch_path = "patches/" + cls.math_patch_name
3938         cls.all_patch_path = "patches/" + cls.all_patch_name
3939         cls.numbers_patch_template_path = "patches/" + cls.numbers_patch_template_name
3940         cls.math_patch_template_path = "patches/" + cls.math_patch_template_name
3941         cls.all_patch_template_path = "patches/" + cls.all_patch_template_name
3942         cls.numbers_patch = "salt://" + cls.numbers_patch_path
3943         cls.math_patch = "salt://" + cls.math_patch_path
3944         cls.all_patch = "salt://" + cls.all_patch_path
3945         cls.numbers_patch_template = "salt://" + cls.numbers_patch_template_path
3946         cls.math_patch_template = "salt://" + cls.math_patch_template_path
3947         cls.all_patch_template = "salt://" + cls.all_patch_template_path
3948         cls.numbers_patch_http = cls.webserver.url(cls.numbers_patch_path)
3949         cls.math_patch_http = cls.webserver.url(cls.math_patch_path)
3950         cls.all_patch_http = cls.webserver.url(cls.all_patch_path)
3951         cls.numbers_patch_template_http = cls.webserver.url(
3952             cls.numbers_patch_template_path
3953         )
3954         cls.math_patch_template_http = cls.webserver.url(cls.math_patch_template_path)
3955         cls.all_patch_template_http = cls.webserver.url(cls.all_patch_template_path)
3956         patches_dir = os.path.join(RUNTIME_VARS.FILES, "file", "base", "patches")
3957         cls.numbers_patch_hash = salt.utils.hashutils.get_hash(
3958             os.path.join(patches_dir, cls.numbers_patch_name)
3959         )
3960         cls.math_patch_hash = salt.utils.hashutils.get_hash(
3961             os.path.join(patches_dir, cls.math_patch_name)
3962         )
3963         cls.all_patch_hash = salt.utils.hashutils.get_hash(
3964             os.path.join(patches_dir, cls.all_patch_name)
3965         )
3966         cls.numbers_patch_template_hash = salt.utils.hashutils.get_hash(
3967             os.path.join(patches_dir, cls.numbers_patch_template_name)
3968         )
3969         cls.math_patch_template_hash = salt.utils.hashutils.get_hash(
3970             os.path.join(patches_dir, cls.math_patch_template_name)
3971         )
3972         cls.all_patch_template_hash = salt.utils.hashutils.get_hash(
3973             os.path.join(patches_dir, cls.all_patch_template_name)
3974         )
3975         cls.context = {"two": "two", "ten": 10}
3976     @classmethod
3977     def tearDownClass(cls):
3978         cls.webserver.stop()
3979     def setUp(self):
3980         """
3981         Create a new unpatched set of files
3982         """
3983         self.base_dir = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
3984         os.makedirs(os.path.join(self.base_dir, "foo", "bar"))
3985         self.numbers_file = os.path.join(self.base_dir, "foo", "numbers.txt")
3986         self.math_file = os.path.join(self.base_dir, "foo", "bar", "math.txt")
3987         with salt.utils.files.fopen(self.numbers_file, "w") as fp_:
3988             fp_.write(
3989                 textwrap.dedent(
3990                     """\
3991                 one
3992                 two
3993                 three
3994                 1
3995                 2
3996                 3
3997                 """
3998                 )
3999             )
4000         with salt.utils.files.fopen(self.math_file, "w") as fp_:
4001             fp_.write(
4002                 textwrap.dedent(
4003                     """\
4004                 Five plus five is ten
4005                 Four squared is sixteen
4006                 """
4007                 )
4008             )
4009         self.addCleanup(shutil.rmtree, self.base_dir, ignore_errors=True)
4010     def test_patch_single_file(self):
4011         """
4012         Test file.patch using a patch applied to a single file
4013         """
4014         ret = self.run_state(
4015             "file.patch",
4016             name=self.numbers_file,
4017             source=self.numbers_patch,
4018         )
4019         self.assertSaltTrueReturn(ret)
4020         ret = ret[next(iter(ret))]
4021         self.assertEqual(ret["comment"], "Patch successfully applied")
4022         ret = self.run_state(
4023             "file.patch",
4024             name=self.numbers_file,
4025             source=self.numbers_patch,
4026         )
4027         self.assertSaltTrueReturn(ret)
4028         ret = ret[next(iter(ret))]
4029         self.assertEqual(ret["comment"], "Patch was already applied")
4030         self.assertEqual(ret["changes"], {})
4031     def test_patch_directory(self):
4032         """
4033         Test file.patch using a patch applied to a directory, with changes
4034         spanning multiple files.
4035         """
4036         self._check_patch_version("2.6")
4037         ret = self.run_state(
4038             "file.patch",
4039             name=self.base_dir,
4040             source=self.all_patch,
4041             strip=1,
4042         )
4043         self.assertSaltTrueReturn(ret)
4044         ret = ret[next(iter(ret))]
4045         self.assertEqual(ret["comment"], "Patch successfully applied")
4046         ret = self.run_state(
4047             "file.patch",
4048             name=self.base_dir,
4049             source=self.all_patch,
4050             strip=1,
4051         )
4052         self.assertSaltTrueReturn(ret)
4053         ret = ret[next(iter(ret))]
4054         self.assertEqual(ret["comment"], "Patch was already applied")
4055         self.assertEqual(ret["changes"], {})
4056     def test_patch_strip_parsing(self):
4057         """
4058         Test that we successfuly parse -p/--strip when included in the options
4059         """
4060         self._check_patch_version("2.6")
4061         ret = self.run_state(
4062             "file.patch",
4063             name=self.base_dir,
4064             source=self.all_patch,
4065             options="-p1",
4066         )
4067         self.assertSaltTrueReturn(ret)
4068         ret = ret[next(iter(ret))]
4069         self.assertEqual(ret["comment"], "Patch successfully applied")
4070         ret = self.run_state(
4071             "file.patch",
4072             name=self.base_dir,
4073             source=self.all_patch,
4074             options="--strip=1",
4075         )
4076         self.assertSaltTrueReturn(ret)
4077         ret = ret[next(iter(ret))]
4078         self.assertEqual(ret["comment"], "Patch was already applied")
4079         self.assertEqual(ret["changes"], {})
4080         ret = self.run_state(
4081             "file.patch",
4082             name=self.base_dir,
4083             source=self.all_patch,
4084             options="--strip 1",
4085         )
4086         self.assertSaltTrueReturn(ret)
4087         ret = ret[next(iter(ret))]
4088         self.assertEqual(ret["comment"], "Patch was already applied")
4089         self.assertEqual(ret["changes"], {})
4090     def test_patch_saltenv(self):
4091         """
4092         Test that we attempt to download the patch from a non-base saltenv
4093         """
4094         ret = self.run_state(
4095             "file.patch",
4096             name=self.math_file,
4097             source=self.math_patch,
4098             saltenv="prod",
4099         )
4100         self.assertSaltFalseReturn(ret)
4101         ret = ret[next(iter(ret))]
4102         self.assertEqual(
4103             ret["comment"],
4104             "Source file {} not found in saltenv 'prod'".format(self.math_patch),
4105         )
4106     def test_patch_single_file_failure(self):
4107         """
4108         Test file.patch using a patch applied to a single file. This tests a
4109         failed patch.
4110         """
4111         with salt.utils.files.fopen(self.numbers_file, "w"):
4112             pass
4113         ret = self.run_state(
4114             "file.patch",
4115             name=self.numbers_file,
4116             source=self.numbers_patch,
4117         )
4118         self.assertSaltFalseReturn(ret)
4119         ret = ret[next(iter(ret))]
4120         self.assertIn("Patch would not apply cleanly", ret["comment"])
4121         reject_file = salt.utils.files.mkstemp()
4122         ret = self.run_state(
4123             "file.patch",
4124             name=self.numbers_file,
4125             source=self.numbers_patch,
4126             reject_file=reject_file,
4127             strip=1,
4128         )
4129         self.assertSaltFalseReturn(ret)
4130         ret = ret[next(iter(ret))]
4131         self.assertIn("Patch would not apply cleanly", ret["comment"])
4132         if IS_WINDOWS:
4133             reject_file = reject_file.replace("\\", "\\\\")
4134             reject_file = "'{}'".format(reject_file)
4135         self.assertRegex(
4136             ret["comment"], "saving rejects to (file )?{}".format(reject_file)
4137         )
4138     def test_patch_directory_failure(self):
4139         """
4140         Test file.patch using a patch applied to a directory, with changes
4141         spanning multiple files.
4142         """
4143         with salt.utils.files.fopen(self.math_file, "w"):
4144             pass
4145         ret = self.run_state(
4146             "file.patch",
4147             name=self.base_dir,
4148             source=self.all_patch,
4149             strip=1,
4150         )
4151         self.assertSaltFalseReturn(ret)
4152         ret = ret[next(iter(ret))]
4153         self.assertIn("Patch would not apply cleanly", ret["comment"])
4154         reject_file = salt.utils.files.mkstemp()
4155         ret = self.run_state(
4156             "file.patch",
4157             name=self.base_dir,
4158             source=self.all_patch,
4159             reject_file=reject_file,
4160             strip=1,
4161         )
4162         self.assertSaltFalseReturn(ret)
4163         ret = ret[next(iter(ret))]
4164         self.assertIn("Patch would not apply cleanly", ret["comment"])
4165         if IS_WINDOWS:
4166             reject_file = reject_file.replace("\\", "\\\\")
4167             reject_file = "'{}'".format(reject_file)
4168         self.assertRegex(
4169             ret["comment"], "saving rejects to (file )?{}".format(reject_file)
4170         )
4171     def test_patch_single_file_remote_source(self):
4172         """
4173         Test file.patch using a patch applied to a single file, with the patch
4174         coming from a remote source.
4175         """
4176         ret = self.run_state(
4177             "file.patch",
4178             name=self.math_file,
4179             source=self.math_patch_http,
4180         )
4181         self.assertSaltFalseReturn(ret)
4182         ret = ret[next(iter(ret))]
4183         self.assertIn("Unable to verify upstream hash", ret["comment"])
4184         ret = self.run_state(
4185             "file.patch",
4186             name=self.math_file,
4187             source=self.math_patch_http,
4188             source_hash=self.math_patch_hash,
4189         )
4190         self.assertSaltTrueReturn(ret)
4191         ret = ret[next(iter(ret))]
4192         self.assertEqual(ret["comment"], "Patch successfully applied")
4193         ret = self.run_state(
4194             "file.patch",
4195             name=self.math_file,
4196             source=self.math_patch_http,
4197             skip_verify=True,
4198         )
4199         self.assertSaltTrueReturn(ret)
4200         ret = ret[next(iter(ret))]
4201         self.assertEqual(ret["comment"], "Patch was already applied")
4202         self.assertEqual(ret["changes"], {})
4203     def test_patch_directory_remote_source(self):
4204         """
4205         Test file.patch using a patch applied to a directory, with changes
4206         spanning multiple files, and the patch file coming from a remote
4207         source.
4208         """
4209         self._check_patch_version("2.6")
4210         ret = self.run_state(
4211             "file.patch",
4212             name=self.base_dir,
4213             source=self.all_patch_http,
4214             strip=1,
4215         )
4216         self.assertSaltFalseReturn(ret)
4217         ret = ret[next(iter(ret))]
4218         self.assertIn("Unable to verify upstream hash", ret["comment"])
4219         ret = self.run_state(
4220             "file.patch",
4221             name=self.base_dir,
4222             source=self.all_patch_http,
4223             source_hash=self.all_patch_hash,
4224             strip=1,
4225         )
4226         self.assertSaltTrueReturn(ret)
4227         ret = ret[next(iter(ret))]
4228         self.assertEqual(ret["comment"], "Patch successfully applied")
4229         ret = self.run_state(
4230             "file.patch",
4231             name=self.base_dir,
4232             source=self.all_patch_http,
4233             strip=1,
4234             skip_verify=True,
4235         )
4236         self.assertSaltTrueReturn(ret)
4237         ret = ret[next(iter(ret))]
4238         self.assertEqual(ret["comment"], "Patch was already applied")
4239         self.assertEqual(ret["changes"], {})
4240     def test_patch_single_file_template(self):
4241         """
4242         Test file.patch using a patch applied to a single file, with jinja
4243         templating applied to the patch file.
4244         """
4245         ret = self.run_state(
4246             "file.patch",
4247             name=self.numbers_file,
4248             source=self.numbers_patch_template,
4249             template="jinja",
4250             context=self.context,
4251         )
4252         self.assertSaltTrueReturn(ret)
4253         ret = ret[next(iter(ret))]
4254         self.assertEqual(ret["comment"], "Patch successfully applied")
4255         ret = self.run_state(
4256             "file.patch",
4257             name=self.numbers_file,
4258             source=self.numbers_patch_template,
4259             template="jinja",
4260             context=self.context,
4261         )
4262         self.assertSaltTrueReturn(ret)
4263         ret = ret[next(iter(ret))]
4264         self.assertEqual(ret["comment"], "Patch was already applied")
4265         self.assertEqual(ret["changes"], {})
4266     def test_patch_directory_template(self):
4267         """
4268         Test file.patch using a patch applied to a directory, with changes
4269         spanning multiple files, and with jinja templating applied to the patch
4270         file.
4271         """
4272         self._check_patch_version("2.6")
4273         ret = self.run_state(
4274             "file.patch",
4275             name=self.base_dir,
4276             source=self.all_patch_template,
4277             template="jinja",
4278             context=self.context,
4279             strip=1,
4280         )
4281         self.assertSaltTrueReturn(ret)
4282         ret = ret[next(iter(ret))]
4283         self.assertEqual(ret["comment"], "Patch successfully applied")
4284         ret = self.run_state(
4285             "file.patch",
4286             name=self.base_dir,
4287             source=self.all_patch_template,
4288             template="jinja",
4289             context=self.context,
4290             strip=1,
4291         )
4292         self.assertSaltTrueReturn(ret)
4293         ret = ret[next(iter(ret))]
4294         self.assertEqual(ret["comment"], "Patch was already applied")
4295         self.assertEqual(ret["changes"], {})
4296     def test_patch_single_file_remote_source_template(self):
4297         """
4298         Test file.patch using a patch applied to a single file, with the patch
4299         coming from a remote source.
4300         """
4301         ret = self.run_state(
4302             "file.patch",
4303             name=self.math_file,
4304             source=self.math_patch_template_http,
4305             template="jinja",
4306             context=self.context,
4307         )
4308         self.assertSaltFalseReturn(ret)
4309         ret = ret[next(iter(ret))]
4310         self.assertIn("Unable to verify upstream hash", ret["comment"])
4311         ret = self.run_state(
4312             "file.patch",
4313             name=self.math_file,
4314             source=self.math_patch_template_http,
4315             source_hash=self.math_patch_template_hash,
4316             template="jinja",
4317             context=self.context,
4318         )
4319         self.assertSaltTrueReturn(ret)
4320         ret = ret[next(iter(ret))]
4321         self.assertEqual(ret["comment"], "Patch successfully applied")
4322         ret = self.run_state(
4323             "file.patch",
4324             name=self.math_file,
4325             source=self.math_patch_template_http,
4326             template="jinja",
4327             context=self.context,
4328             skip_verify=True,
4329         )
4330         self.assertSaltTrueReturn(ret)
4331         ret = ret[next(iter(ret))]
4332         self.assertEqual(ret["comment"], "Patch was already applied")
4333         self.assertEqual(ret["changes"], {})
4334     def test_patch_directory_remote_source_template(self):
4335         """
4336         Test file.patch using a patch applied to a directory, with changes
4337         spanning multiple files, and the patch file coming from a remote
4338         source.
4339         """
4340         self._check_patch_version("2.6")
4341         ret = self.run_state(
4342             "file.patch",
4343             name=self.base_dir,
4344             source=self.all_patch_template_http,
4345             template="jinja",
4346             context=self.context,
4347             strip=1,
4348         )
4349         self.assertSaltFalseReturn(ret)
4350         ret = ret[next(iter(ret))]
4351         self.assertIn("Unable to verify upstream hash", ret["comment"])
4352         ret = self.run_state(
4353             "file.patch",
4354             name=self.base_dir,
4355             source=self.all_patch_template_http,
4356             source_hash=self.all_patch_template_hash,
4357             template="jinja",
4358             context=self.context,
4359             strip=1,
4360         )
4361         self.assertSaltTrueReturn(ret)
4362         ret = ret[next(iter(ret))]
4363         self.assertEqual(ret["comment"], "Patch successfully applied")
4364         ret = self.run_state(
4365             "file.patch",
4366             name=self.base_dir,
4367             source=self.all_patch_template_http,
4368             template="jinja",
4369             context=self.context,
4370             strip=1,
4371             skip_verify=True,
4372         )
4373         self.assertSaltTrueReturn(ret)
4374         ret = ret[next(iter(ret))]
4375         self.assertEqual(ret["comment"], "Patch was already applied")
4376         self.assertEqual(ret["changes"], {})
4377     def test_patch_test_mode(self):
4378         """
4379         Test file.patch using test=True
4380         """
4381         ret = self.run_state(
4382             "file.patch",
4383             name=self.numbers_file,
4384             source=self.numbers_patch,
4385             test=True,
4386         )
4387         self.assertSaltNoneReturn(ret)
4388         ret = ret[next(iter(ret))]
4389         self.assertEqual(ret["comment"], "The patch would be applied")
4390         self.assertTrue(ret["changes"])
4391         ret = self.run_state(
4392             "file.patch",
4393             name=self.numbers_file,
4394             source=self.numbers_patch,
4395         )
4396         self.assertSaltTrueReturn(ret)
4397         ret = ret[next(iter(ret))]
4398         self.assertEqual(ret["comment"], "Patch successfully applied")
4399         self.assertTrue(ret["changes"])
4400         ret = self.run_state(
4401             "file.patch",
4402             name=self.numbers_file,
4403             source=self.numbers_patch,
4404             test=True,
4405         )
4406         self.assertSaltTrueReturn(ret)
4407         ret = ret[next(iter(ret))]
4408         self.assertEqual(ret["comment"], "Patch was already applied")
4409         self.assertEqual(ret["changes"], {})
4410         with salt.utils.files.fopen(self.numbers_file, "w"):
4411             pass
4412         ret = self.run_state(
4413             "file.patch",
4414             name=self.numbers_file,
4415             source=self.numbers_patch,
4416             test=True,
4417         )
4418         self.assertSaltFalseReturn(ret)
4419         ret = ret[next(iter(ret))]
4420         self.assertIn("Patch would not apply cleanly", ret["comment"])
4421         self.assertEqual(ret["changes"], {})
4422 WIN_TEST_FILE = "c:/testfile"
4423 @pytest.mark.destructive_test
4424 @skipIf(not IS_WINDOWS, "windows test only")
4425 @pytest.mark.windows_whitelisted
4426 class WinFileTest(ModuleCase):
4427     """
4428     Test for the file state on Windows
4429     """
4430     def setUp(self):
4431         self.run_state(
4432             "file.managed", name=WIN_TEST_FILE, makedirs=True, contents="Only a test"
4433         )
4434     def tearDown(self):
4435         self.run_state("file.absent", name=WIN_TEST_FILE)
4436     def test_file_managed(self):
4437         """
4438         Test file.managed on Windows
4439         """
4440         self.assertTrue(self.run_state("file.exists", name=WIN_TEST_FILE))
4441     def test_file_copy(self):
4442         """
4443         Test file.copy on Windows
4444         """
4445         ret = self.run_state(
4446             "file.copy", name="c:/testfile_copy", makedirs=True, source=WIN_TEST_FILE
4447         )
4448         self.assertTrue(ret)
4449     def test_file_comment(self):
4450         """
4451         Test file.comment on Windows
4452         """
4453         self.run_state("file.comment", name=WIN_TEST_FILE, regex="^Only")
4454         with salt.utils.files.fopen(WIN_TEST_FILE, "r") as fp_:
4455             self.assertTrue(fp_.read().startswith("#Only"))
4456     def test_file_replace(self):
4457         """
4458         Test file.replace on Windows
4459         """
4460         self.run_state(
4461             "file.replace", name=WIN_TEST_FILE, pattern="test", repl="testing"
4462         )
4463         with salt.utils.files.fopen(WIN_TEST_FILE, "r") as fp_:
4464             self.assertIn("testing", fp_.read())
4465     def test_file_absent(self):
4466         """
4467         Test file.absent on Windows
4468         """
4469         ret = self.run_state("file.absent", name=WIN_TEST_FILE)
4470         self.assertTrue(ret)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
