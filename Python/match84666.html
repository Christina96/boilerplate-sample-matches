<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for proxy_1.py &amp; state_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for proxy_1.py &amp; state_1.py
      </h3>
<h1 align="center">
        3.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>proxy_1.py (11.363636%)<th>state_1.py (2.3715951%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(15-58)<td><a href="#" name="0">(15-56)</a><td align="center"><font color="#ff0000">40</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(189-192)<td><a href="#" name="1">(1179-1186)</a><td align="center"><font color="#720000">18</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(96-101)<td><a href="#" name="2">(3521-3524)</a><td align="center"><font color="#5f0000">15</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(192-193)<td><a href="#" name="3">(2333-2340)</a><td align="center"><font color="#590000">14</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(133-139)<td><a href="#" name="4">(4740-4744)</a><td align="center"><font color="#590000">14</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(608-613)<td><a href="#" name="5">(644-649)</a><td align="center"><font color="#520000">13</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(150-154)<td><a href="#" name="6">(3019-3022)</a><td align="center"><font color="#520000">13</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(564-568)<td><a href="#" name="7">(3513-3518)</a><td align="center"><font color="#4c0000">12</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(259-271)<td><a href="#" name="8">(3621-3629)</a><td align="center"><font color="#4c0000">12</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(251-256)<td><a href="#" name="9">(2930-2940)</a><td align="center"><font color="#4c0000">12</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(184-187)<td><a href="#" name="10">(1166-1171)</a><td align="center"><font color="#4c0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>proxy_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import os
3 import signal
4 import sys
5 import threading
6 import traceback
7 import types
8 import salt
9 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import salt.beacons
10 import salt.cli.daemons
11 import salt.client
12 import salt.crypt
13 import salt.defaults.exitcodes
14 import salt.engines
15 import salt.ext.tornado.gen  # pylint: disable=F0401
16 import salt.ext.tornado.ioloop  # pylint: disable=F0401
17 import salt.loader
18 import salt.log.setup
19 import salt.minion
20 import salt.payload
21 import salt.pillar
22 import salt.serializers.msgpack
23 import salt.syspaths
24 import salt.utils.args
25 import salt.utils.context
26 import salt.utils.data
27 import salt.utils.dictupdate
28 import salt.utils.error
29 import salt.utils.event
30 import salt.utils.files
31 import salt.utils.jid
32 import salt.utils.minion
33 import salt.utils.minions
34 import salt.utils.network
35 import salt.utils.platform
36 import salt.utils.process
37 import salt.utils.schedule
38 import salt.utils.ssdp
39 import salt.utils.user
40 import salt.utils.zeromq
41 from salt.defaults import DEFAULT_TARGET_DELIM
42 from salt.exceptions import (
43     CommandExecutionError,
44     CommandNotFoundError,
45     SaltInvocationError,
46     SaltSystemExit,
47 )
48 from salt.minion import ProxyMinion
49 from salt.utils.event import tagify
50 from salt.utils.process import SignalHandlingProcess, default_signals
51 log = logging.getLogger(</b></font>__name__)
52 def post_master_init(self, master):
53     log.debug("subclassed LazyLoaded _post_master_init")
54     if self.connected:
55         self.opts["master"] = master
56         self.opts["pillar"] = yield salt.pillar.get_async_pillar(
57             self.opts,
58             self.opts["grains"],
59             self.opts["id"],
60             saltenv=self.opts["saltenv"],
61             pillarenv=self.opts.get("pillarenv"),
62         ).compile_pillar()
63     if "proxy" not in self.opts["pillar"] and "proxy" not in self.opts:
64         errmsg = (
65             "No proxy key found in pillar or opts for id "
66             + self.opts["id"]
67             + ". "
68             + "Check your pillar/opts configuration and contents.  Salt-proxy aborted."
69         )
70         log.error(errmsg)
71         self._running = False
72         raise SaltSystemExit(code=-1, msg=errmsg)
73         self.opts["proxy"] = self.opts["pillar"]["proxy"]
74     if self<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.opts.get("proxy_merge_pillar_in_opts"):
75         self.opts = salt.utils.dictupdate.merge(
76             self.opts,
77             self.opts["pillar"],
78             strategy=self.opts.</b></font>get("proxy_merge_pillar_in_opts_strategy"),
79             merge_lists=self.opts.get("proxy_deep_merge_pillar_in_opts", False),
80         )
81     elif self.opts.get("proxy_mines_pillar"):
82         if "mine_interval" in self.opts["pillar"]:
83             self.opts["mine_interval"] = self.opts["pillar"]["mine_interval"]
84         if "mine_functions" in self.opts["pillar"]:
85             general_proxy_mines = self.opts.get("mine_functions", {})
86             specific_proxy_mines = self.opts["pillar"]["mine_functions"]
87             try:
88                 self.opts["mine_functions"] = general_proxy_mines + specific_proxy_mines
89             except TypeError as terr:
90                 log.error(
91                     "Unable to merge mine functions from the pillar in the opts, for proxy %s",
92                     self.opts["id"],
93                 )
94     fq_proxyname = self.opts["proxy"]["proxytype"]
95     (
96         self.functions,
97         self.returners,
98         self.function_errors,
99         self.executors,
100     ) = self._load_modules()
101     self.functions["saltutil.sync_all"](saltenv=self<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.opts["saltenv"])
102     self.utils = salt.loader.utils(self.opts)
103     self.proxy = salt.loader.proxy(self.</b></font>opts, utils=self.utils)
104     (
105         self.functions,
106         self.returners,
107         self.function_errors,
108         self.executors,
109     self.functions.pack["__proxy__"] = self.proxy
110     self.proxy.pack["__salt__"] = self.functions
111     self.proxy<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.pack["__ret__"] = self.returners
112     self.proxy.pack["__pillar__"] = self.opts["pillar"]
113     self.utils = salt.</b></font>loader.utils(self.opts, proxy=self.proxy)
114     self.proxy.pack["__utils__"] = self.utils
115     self.proxy.reload_modules()
116     self.io_loop.spawn_callback(
117         salt.engines.start_engines, self.opts, self.process_manager, proxy=self.proxy
118     )
119     if (
120         "{}.init".format(fq_proxyname) not in self.proxy
121         or "{}.shutdown".format(fq_proxyname) not in self.proxy
122     ):
123         errmsg = (
124             "Proxymodule {} is missing an init() or a shutdown() or both. ".format(
125                 fq_proxyname
126             )
127             + "Check your proxymodule.  Salt-proxy aborted."
128         )
129         log.error(errmsg)
130         self._running = False
131         raise SaltSystemExit(code=-1, msg=errmsg)
132         "{}.module_executors".format(fq_proxyname), lambda: []
133     )()
134     proxy_init_fn <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= self.proxy[fq_proxyname + ".init"]
135     proxy_init_fn(self.opts)
136     self.opts["grains"] = salt.loader.grains(self.</b></font>opts, proxy=self.proxy)
137     self.matchers = salt.loader.matchers(self.opts)
138     self.beacons = salt.beacons.Beacon(self.opts, self.functions)
139     uid = salt.</b></font>utils<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.user.get_uid(user=self.opts.get("user", None))
140     self.proc_dir = salt.minion.get_proc_dir(self.opts[</b></font>"cachedir"], uid=uid)
141     if self.connected and self.opts["pillar"]:
142         (
143             self.functions,
144             self.returners,
145             self.function_errors,
146             self.executors,
147         ) = self._load_modules()
148         if hasattr(self, "schedule"):
149             self.schedule.functions = self.functions
150             self.schedule.returners = self.returners
151     if not hasattr(self, "schedule"):
152         self.schedule = salt.utils.schedule.Schedule(
153             self.opts,
154             self.functions,
155             self.returners,
156             cleanup=[salt.minion.master_event(type="alive")],
157             proxy=self.proxy,
158         )
159     if self.opts["mine_enabled"] and "mine.update" in self.functions:
160         self.schedule.add_job(
161             {
162                 "__mine_interval": {
163                     "function": "mine.update",
164                     "minutes": self.opts["mine_interval"],
165                     "jid_include": True,
166                     "maxrunning": 2,
167                     "run_on_start": True,
168                     "return_job": self.opts.get("mine_return_job", False),
169                 }
170             },
171             persist=True,
172         )
173         log.info("Added mine.update to scheduler")
174     else:
175         self.schedule.delete_job("__mine_interval", persist=True)
176     if self.opts["transport"] != "tcp" and self.opts["master_alive_interval"] &gt; 0:
177         self.schedule.add_job(
178             {
179                 salt.minion.master_event(type="alive", master=self.opts["master"]): {
180                     "function": "status.master",
181                     "seconds": self.opts["master_alive_interval"],
182                     "jid_include": True,
183                     "maxrunning": 1,
184                     "return_job": False,
185                     "kwargs": {"master": self.opts["master"], "connected": True},
186                 }
187             persist=True,
188         )
189         <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>if (
190             self.opts["master_failback"]
191             and "master_list" in self.opts
192             and self.opts["master"] != self.opts["master_list"][0]
193         ):
194                 {
195                     salt.minion.master_event(type="failback"): {
196                         <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"function": "status.ping_master",
197                         "seconds": self.opts["master_failback_interval"],
198                         "jid_include": True,
199                         "maxrunning": 1,
200                         "return_job": False,
201                         "kwargs": {"master": self.opts["master_list"][0]},
202                     }
203                 },
204                 persist=True,
205             )
206         else:
207             self.schedule.delete_job(
208                 salt.</b></font>minion.master_event(type="failback"), persist=True
209             )
210     else:
211         self.schedule.delete_job(
212             salt.minion.master_event(type="alive", master=self.opts["master"]),
213             persist=True,
214         )
215         self.schedule.delete_job(
216             salt.minion.master_event(type="failback"), persist=True
217         )
218     proxy_alive_fn = fq_proxyname + ".alive"
219     if (
220         proxy_alive_fn in self.proxy
221         and "status.proxy_reconnect" in self.functions
222         and self.opts.get("proxy_keep_alive", True)
223     ):
224         self.schedule.add_job(
225             {
226                 "__proxy_keepalive": {
227                     "function": "status.proxy_reconnect",
228                     "minutes": self.opts.get(
229                         "proxy_keep_alive_interval", 1
230                     ),  # by default, check once per minute
231                     "jid_include": True,
232                     "maxrunning": 1,
233                     "return_job": False,
234                     "kwargs": {"proxy_name": fq_proxyname},
235                 }
236             },
237             persist=True,
238         )
239         self.schedule.enable_schedule()
240     else:
241         self.schedule.delete_job("__proxy_keepalive", persist=True)
242     self.functions["saltutil.sync_grains"](saltenv="base")
243     self.grains_cache = self.opts["grains"]
244     self.ready = True
245 def target(cls, minion_instance, opts, data, connected):
246     if not minion_instance:
247         minion_instance = cls(opts)
248         minion_instance.connected = connected
249         if not hasattr(minion_instance, "functions"):
250             (
251                 functions,
252                 returners,
253                 function_errors,
254                 executors,
255             ) = minion_instance._load_modules(grains=opts["grains"])
256             minion_instance.functions = functions
257             minion_instance.returners = returners
258             minion_instance.function_errors = function_errors
259             minion_instance.executors = executors
260             minion_instance.utils = salt.loader.utils(minion_instance.opts)
261             minion_instance.proxy = salt.loader.proxy(
262                 minion_instance.opts, utils=minion_instance.utils
263             )
264             (
265                 functions,
266                 returners,
267                 function_errors,
268                 executors,
269             ) = minion_instance._load_modules(grains=opts["grains"])
270             minion_instance.functions = functions
271             minion_instance.returners = returners
272             minion_instance.function_errors = function_errors
273             minion_instance.executors = executors
274             minion_instance.functions.pack["__proxy__"] = minion_instance.proxy
275             minion_instance.proxy.pack["__salt__"] = minion_instance.functions
276             minion_instance.proxy.pack["__ret__"] = minion_instance.returners
277             minion_instance.proxy.pack["__pillar__"] = minion_instance.opts["pillar"]
278             minion_instance.utils = salt.loader.utils(
279                 minion_instance.opts, proxy=minion_instance.proxy
280             )
281             minion_instance.proxy.pack["__utils__"] = minion_instance.utils
282             minion_instance.proxy.reload_modules()
283             fq_proxyname = opts["proxy"]["proxytype"]
284             minion_instance.module_executors = minion_instance.proxy.get(
285                 "{}.module_executors".format(fq_proxyname), lambda: []
286             )()
287             proxy_init_fn = minion_instance.proxy[fq_proxyname + ".init"]
288             proxy_init_fn(opts)
289         if not hasattr(minion_instance, "proc_dir"):
290             uid = salt.utils.user.get_uid(user=opts.get("user", None))
291             minion_instance.proc_dir = salt.minion.get_proc_dir(
292                 opts["cachedir"], uid=uid
293             )
294     with salt.ext.tornado.stack_context.StackContext(minion_instance.ctx):
295         if isinstance(data["fun"], tuple) or isinstance(data["fun"], list):
296             ProxyMinion._thread_multi_return(minion_instance, opts, data)
297         else:
298             ProxyMinion._thread_return(minion_instance, opts, data)
299 def thread_return(cls, minion_instance, opts, data):
300     fn_ = os.path.join(minion_instance.proc_dir, data["jid"])
301     salt.utils.process.appendproctitle(
302         "{}._thread_return {}".format(cls.__name__, data["jid"])
303     )
304     sdata = {"pid": os.getpid()}
305     sdata.update(data)
306     log.info("Starting a new job with PID %s", sdata["pid"])
307     with salt.utils.files.fopen(fn_, "w+b") as fp_:
308         fp_.write(salt.payload.dumps(sdata))
309     ret = {"success": False}
310     function_name = data["fun"]
311     executors = (
312         data.get("module_executors")
313         or getattr(minion_instance, "module_executors", [])
314         or opts.get("module_executors", ["direct_call"])
315     )
316     allow_missing_funcs = any(
317         [
318             minion_instance.executors["{}.allow_missing_func".format(executor)](
319                 function_name
320             )
321             for executor in executors
322             if "{}.allow_missing_func".format(executor) in minion_instance.executors
323         ]
324     )
325     if function_name in minion_instance.functions or allow_missing_funcs is True:
326         try:
327             minion_blackout_violation = False
328             if minion_instance.connected and minion_instance.opts["pillar"].get(
329                 "minion_blackout", False
330             ):
331                 whitelist = minion_instance.opts["pillar"].get(
332                     "minion_blackout_whitelist", []
333                 )
334                 if (
335                     function_name != "saltutil.refresh_pillar"
336                     and function_name not in whitelist
337                 ):
338                     minion_blackout_violation = True
339             if minion_instance.opts["grains"].get("minion_blackout", False):
340                 whitelist = minion_instance.opts["grains"].get(
341                     "minion_blackout_whitelist", []
342                 )
343                 if (
344                     function_name != "saltutil.refresh_pillar"
345                     and function_name not in whitelist
346                 ):
347                     minion_blackout_violation = True
348             if minion_blackout_violation:
349                 raise SaltInvocationError(
350                     "Minion in blackout mode. Set 'minion_blackout' "
351                     "to False in pillar or grains to resume operations. Only "
352                     "saltutil.refresh_pillar allowed in blackout mode."
353                 )
354             if function_name in minion_instance.functions:
355                 func = minion_instance.functions[function_name]
356                 args, kwargs = salt.minion.load_args_and_kwargs(func, data["arg"], data)
357             else:
358                 func = function_name
359                 args, kwargs = data["arg"], data
360             minion_instance.functions.pack["__context__"]["retcode"] = 0
361             if isinstance(executors, str):
362                 executors = [executors]
363             elif not isinstance(executors, list) or not executors:
364                 raise SaltInvocationError(
365                     "Wrong executors specification: {}. String or non-empty list"
366                     " expected".format(executors)
367                 )
368             if opts.get("sudo_user", "") and executors[-1] != "sudo":
369                 executors[-1] = "sudo"  # replace the last one with sudo
370             log.trace("Executors list %s", executors)  # pylint: disable=no-member
371             for name in executors:
372                 fname = "{}.execute".format(name)
373                 if fname not in minion_instance.executors:
374                     raise SaltInvocationError(
375                         "Executor '{}' is not available".format(name)
376                     )
377                 return_data = minion_instance.executors[fname](
378                     opts, data, func, args, kwargs
379                 )
380                 if return_data is not None:
381                     break
382             if isinstance(return_data, types.GeneratorType):
383                 ind = 0
384                 iret = {}
385                 for single in return_data:
386                     if isinstance(single, dict) and isinstance(iret, dict):
387                         iret.update(single)
388                     else:
389                         if not iret:
390                             iret = []
391                         iret.append(single)
392                     tag = tagify([data["jid"], "prog", opts["id"], str(ind)], "job")
393                     event_data = {"return": single}
394                     minion_instance._fire_master(event_data, tag)
395                     ind += 1
396                 ret["return"] = iret
397             else:
398                 ret["return"] = return_data
399             retcode = minion_instance.functions.pack["__context__"].get(
400                 "retcode", salt.defaults.exitcodes.EX_OK
401             )
402             if retcode == salt.defaults.exitcodes.EX_OK:
403                 try:
404                     func_result = all(
405                         return_data.get(x, True) for x in ("result", "success")
406                     )
407                 except Exception:  # pylint: disable=broad-except
408                     func_result = True
409                 if not func_result:
410                     retcode = salt.defaults.exitcodes.EX_GENERIC
411             ret["retcode"] = retcode
412             ret["success"] = retcode == salt.defaults.exitcodes.EX_OK
413         except CommandNotFoundError as exc:
414             msg = "Command required for '{}' not found".format(function_name)
415             log.debug(msg, exc_info=True)
416             ret["return"] = "{}: {}".format(msg, exc)
417             ret["out"] = "nested"
418             ret["retcode"] = salt.defaults.exitcodes.EX_GENERIC
419         except CommandExecutionError as exc:
420             log.error(
421                 "A command in '%s' had a problem: %s",
422                 function_name,
423                 exc,
424                 exc_info_on_loglevel=logging.DEBUG,
425             )
426             ret["return"] = "ERROR: {}".format(exc)
427             ret["out"] = "nested"
428             ret["retcode"] = salt.defaults.exitcodes.EX_GENERIC
429         except SaltInvocationError as exc:
430             log.error(
431                 "Problem executing '%s': %s",
432                 function_name,
433                 exc,
434                 exc_info_on_loglevel=logging.DEBUG,
435             )
436             ret["return"] = "ERROR executing '{}': {}".format(function_name, exc)
437             ret["out"] = "nested"
438             ret["retcode"] = salt.defaults.exitcodes.EX_GENERIC
439         except TypeError as exc:
440             msg = "Passed invalid arguments to {}: {}\n{}".format(
441                 function_name, exc, func.__doc__ or ""
442             )
443             log.warning(msg, exc_info_on_loglevel=logging.DEBUG)
444             ret["return"] = msg
445             ret["out"] = "nested"
446             ret["retcode"] = salt.defaults.exitcodes.EX_GENERIC
447         except Exception:  # pylint: disable=broad-except
448             msg = "The minion function caused an exception"
449             log.warning(msg, exc_info=True)
450                 salt.exceptions.MinionError(msg), opts, job=data
451             )
452             ret["return"] = "{}: {}".format(msg, traceback<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.format_exc())
453             ret["out"] = "nested"
454             ret["retcode"] = salt.defaults.exitcodes.EX_GENERIC
455     else:
456         docs = minion_instance.functions[</b></font>"sys.doc"]("{}*".format(function_name))
457         if docs:
458             docs[function_name] = minion_instance.functions.missing_fun_string(
459                 function_name
460             )
461             ret["return"] = docs
462         else:
463             ret["return"] = minion_instance.functions.missing_fun_string(function_name)
464             mod_name = function_name.split(".")[0]
465             if mod_name in minion_instance.function_errors:
466                 ret["return"] += " Possible reasons: '{}'".format(
467                     minion_instance.function_errors[mod_name]
468                 )
469         ret["success"] = False
470         ret["retcode"] = salt.defaults.exitcodes.EX_GENERIC
471         ret["out"] = "nested"
472     ret["jid"] = data["jid"]
473     ret["fun"] = data["fun"]
474     ret["fun_args"] = data["arg"]
475     if "master_id" in data:
476         ret["master_id"] = data["master_id"]
477     if "metadata" in data:
478         if isinstance(data["metadata"], dict):
479             ret["metadata"] = data["metadata"]
480         else:
481             log.warning("The metadata parameter must be a dictionary. Ignoring.")
482     if minion_instance.connected:
483         minion_instance._return_pub(ret, timeout=minion_instance._return_retry_timer())
484     if isinstance(opts.get("return"), str):
485         if data["ret"]:
486             data["ret"] = ",".join((data["ret"], opts["return"]))
487         else:
488             data["ret"] = opts["return"]
489     log.debug("minion return: %s", ret)
490     if data["ret"] and isinstance(data<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["ret"], str):
491         if "ret_config" in data:
492             ret["ret_config"] = data["ret_config"]
493         if "ret_kwargs" in data:
494             ret["ret_kwargs"] = data["ret_kwargs"]
495         ret["id"] =</b></font> opts["id"]
496         for returner in set(data["ret"].split(",")):
497             try:
498                 returner_str = "{}.returner".format(returner)
499                 if returner_str in minion_instance.returners:
500                     minion_instance.returners[returner_str](ret)
501                 else:
502                     returner_err = minion_instance.returners.missing_fun_string(
503                         returner_str
504                     )
505                     log.error(
506                         "Returner %s could not be loaded: %s",
507                         returner_str,
508                         returner_err,
509                     )
510             except Exception as exc:  # pylint: disable=broad-except
511                 log.exception("The return failed for job %s: %s", data["jid"], exc)
512 def thread_multi_return(cls, minion_instance, opts, data):
513     fn_ = os.path.join(minion_instance.proc_dir, data["jid"])
514     salt.utils.process.appendproctitle(
515         "{}._thread_multi_return {}".format(cls.__name__, data["jid"])
516     )
517     sdata = {"pid": os.getpid()}
518     sdata.update(data)
519     log.info("Starting a new job with PID %s", sdata["pid"])
520     with salt.utils.files.fopen(fn_, "w+b") as fp_:
521         fp_.write(salt.payload.dumps(sdata))
522     multifunc_ordered = opts.get("multifunc_ordered", False)
523     num_funcs = len(data["fun"])
524     if multifunc_ordered:
525         ret = {
526             "return": [None] * num_funcs,
527             "retcode": [None] * num_funcs,
528             "success": [False] * num_funcs,
529         }
530     else:
531         ret = {"return": {}, "retcode": {}, "success": {}}
532     for ind in range(0, num_funcs):
533         if not multifunc_ordered:
534             ret["success"][data["fun"][ind]] = False
535         try:
536             minion_blackout_violation = False
537             if minion_instance.connected and minion_instance.opts["pillar"].get(
538                 "minion_blackout", False
539             ):
540                 whitelist = minion_instance.opts["pillar"].get(
541                     "minion_blackout_whitelist", []
542                 )
543                 if (
544                     data["fun"][ind] != "saltutil.refresh_pillar"
545                     and data["fun"][ind] not in whitelist
546                 ):
547                     minion_blackout_violation = True
548             elif minion_instance.opts["grains"].get("minion_blackout", False):
549                 whitelist = minion_instance.opts["grains"].get(
550                     "minion_blackout_whitelist", []
551                 )
552                 if (
553                     data["fun"][ind] != "saltutil.refresh_pillar"
554                     and data["fun"][ind] not in whitelist
555                 ):
556                     minion_blackout_violation = True
557             if minion_blackout_violation:
558                 raise SaltInvocationError(
559                     "Minion in blackout mode. Set 'minion_blackout' "
560                     "to False in pillar or grains to resume operations. Only "
561                     "saltutil.refresh_pillar allowed in blackout mode."
562                 )
563             func = minion_instance.functions[data["fun"][ind]]
564             args, kwargs = salt.minion.load_args_and_kwargs(
565                 func, data["arg"][ind], data
566             )
567             minion_instance.functions.pack["__context__"]["retcode"] = 0
568             key = ind if multifunc_ordered else data["fun"][ind]
569             ret["return"][key] = func(*args, **kwargs)
570             retcode = minion_instance.functions.pack["__context__"].get("retcode", 0)
571             if retcode == 0:
572                 try:
573                     func_result = all(
574                         ret["return"][key].get(x, True) for x in ("result", "success")
575                     )
576                 except Exception:  # pylint: disable=broad-except
577                     func_result = True
578                 if not func_result:
579                     retcode = 1
580             ret["retcode"][key] = retcode
581             ret["success"][key] = retcode == 0
582         except Exception as exc:  # pylint: disable=broad-except
583             trb = traceback.format_exc()
584             log.warning("The minion function caused an exception: %s", exc)
585             if multifunc_ordered:
586                 ret["return"][ind] = trb
587             else:
588                 ret["return"][data["fun"][ind]] = trb
589         ret["jid"] = data["jid"]
590         ret["fun"] = data["fun"]
591         ret["fun_args"] = data["arg"]
592     if "metadata" in data:
593         ret["metadata"] = data["metadata"]
594     if minion_instance.connected:
595         minion_instance._return_pub(ret, timeout=minion_instance._return_retry_timer())
596     if data["ret"]:
597         if "ret_config" in data:
598             ret["ret_config"] = data["ret_config"]
599         if "ret_kwargs" in data:
600             ret["ret_kwargs"] = data["ret_kwargs"]
601         for returner in set(data["ret"].split(",")):
602             ret["id"] = opts["id"]
603             try:
604                 minion_instance.returners["{}.returner".format(returner)](ret)
605             except Exception as exc:  # pylint: disable=broad-except
606                 log.error("The return failed for job %s: %s", data["jid"], exc)
607 def handle_payload(self, payload):
608     if payload is not None and payload["enc"] == "aes":
609         if self._target_load(payload["load"]):
610             self._handle_decoded_payload(payload["load"])
611         elif self.opts["zmq_filtering"]:
612             log.trace(
613                 "Broadcast message received not for this minion, Load: %s",
614                 payload["load"],
615             )
616 def handle_decoded_payload(self, data):
617     if "user" in data:
618         log.info(
619             "User %s Executing command %s with jid %s",
620             data["user"],
621             data["fun"],
622             data["jid"],
623         )
624     else:
625         log.info("Executing command %s with jid %s", data["fun"], data["jid"])
626     log.debug("Command details %s", data)
627     log.trace("Started JIDs: %s", self.jid_queue)
628     if self.jid_queue is not None:
629         if data["jid"] in self.jid_queue:
630             return
631         else:
632             self.jid_queue.append(data["jid"])
633             if len(self.jid_queue) &gt; self.opts["minion_jid_queue_hwm"]:
634                 self.jid_queue.pop(0)
635     if isinstance(data["fun"], str):
636         if data["fun"] == "sys.reload_modules":
637             (
638                 self.functions,
639                 self.returners,
640                 self.function_errors,
641                 self.executors,
642             ) = self._load_modules()
643             self.schedule.functions = self.functions
644             self.schedule.returners = self.returners
645     process_count_max = self.opts.get("process_count_max")
646     if process_count_max &gt; 0:
647         process_count = len(salt.utils.minion.running(self.opts))
648         while process_count &gt;= process_count_max:
649             log.warning(
650                 "Maximum number of processes reached while executing jid %s, waiting...",
651                 data["jid"],
652             )
653             yield salt.ext.tornado.gen.sleep(10)
654             process_count = len(salt.utils.minion.running(self.opts))
655     instance = self
656     multiprocessing_enabled = self.opts.get("multiprocessing", True)
657     name = "ProcessPayload(jid={})".format(data["jid"])
658     if multiprocessing_enabled:
659         if sys.platform.startswith("win"):
660             instance = None
661         with default_signals(signal.SIGINT, signal.SIGTERM):
662             process = SignalHandlingProcess(
663                 target=self._target,
664                 name=name,
665                 args=(instance, self.opts, data, self.connected),
666             )
667     else:
668         process = threading.Thread(
669             target=self._target,
670             args=(instance, self.opts, data, self.connected),
671             name=name,
672         )
673     if multiprocessing_enabled:
674         with default_signals(signal.SIGINT, signal.SIGTERM):
675             process.start()
676     else:
677         process.start()
678     self.subprocess_list.add(process)
679 def target_load(self, load):
680     if "tgt" not in load or "jid" not in load or "fun" not in load or "arg" not in load:
681         return False
682     if "tgt_type" in load:
683         match_func = self.matchers.get("{}_match.match".format(load["tgt_type"]), None)
684         if match_func is None:
685             return False
686         if load["tgt_type"] in ("grain", "grain_pcre", "pillar"):
687             delimiter = load.get("delimiter", DEFAULT_TARGET_DELIM)
688             if not match_func(load["tgt"], delimiter=delimiter):
689                 return False
690         elif not match_func(load["tgt"]):
691             return False
692     else:
693         if not self.matchers["glob_match.match"](load["tgt"]):
694             return False
695     return True
696 def tune_in(self, start=True):
697     super(ProxyMinion, self).tune_in(start=start)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>state_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import copy
3 import datetime
4 import fnmatch
5 import importlib
6 import logging
7 import os
8 import random
9 import re
10 import site
11 import sys
12 import time
13 import traceback
14 import salt.channel.client
15 import salt.fileclient
16 import salt.loader
17 import salt.minion
18 import salt.pillar
19 import salt.syspaths as syspaths
20 import salt.utils.args
21 import salt.utils.crypt
22 import salt.utils.data
23 import salt.utils.decorators.state
24 import salt.utils.dictupdate
25 import salt.utils.event
26 import salt.utils.files
27 import salt.utils.hashutils
28 import salt.utils.immutabletypes as immutabletypes
29 import salt.utils.msgpack
30 import salt.utils.platform
31 import salt.utils.process
32 import salt.utils.url
33 import salt.utils.yamlloader as yamlloader
34 from salt.exceptions import CommandExecutionError, SaltRenderError, SaltReqTimeoutError
35 from salt.serializers.msgpack import deserialize as msgpack_deserialize
36 from salt.serializers.msgpack import serialize as msgpack_serialize
37 from salt.template import compile_template, compile_template_str
38 from salt.utils.odict import DefaultOrderedDict, OrderedDict
39 log = logging.getLogger(</b></font>__name__)
40 STATE_REQUISITE_KEYWORDS = frozenset(
41     [
42         "onchanges",
43         "onchanges_any",
44         "onfail",
45         "onfail_any",
46         "onfail_all",
47         "onfail_stop",
48         "prereq",
49         "prerequired",
50         "watch",
51         "watch_any",
52         "require",
53         "require_any",
54         "listen",
55     ]
56 )
57 STATE_REQUISITE_IN_KEYWORDS = frozenset(
58     ["onchanges_in", "onfail_in", "prereq_in", "watch_in", "require_in", "listen_in"]
59 )
60 STATE_RUNTIME_KEYWORDS = frozenset(
61     [
62         "fun",
63         "state",
64         "check_cmd",
65         "failhard",
66         "onlyif",
67         "unless",
68         "creates",
69         "retry",
70         "order",
71         "parallel",
72         "prereq",
73         "prereq_in",
74         "prerequired",
75         "reload_modules",
76         "reload_grains",
77         "reload_pillar",
78         "runas",
79         "runas_password",
80         "fire_event",
81         "saltenv",
82         "use",
83         "use_in",
84         "__env__",
85         "__sls__",
86         "__id__",
87         "__orchestration_jid__",
88         "__pub_user",
89         "__pub_arg",
90         "__pub_jid",
91         "__pub_fun",
92         "__pub_tgt",
93         "__pub_ret",
94         "__pub_pid",
95         "__pub_tgt_type",
96         "__prereq__",
97         "__prerequired__",
98     ]
99 )
100 STATE_INTERNAL_KEYWORDS = STATE_REQUISITE_KEYWORDS.union(
101     STATE_REQUISITE_IN_KEYWORDS
102 ).union(STATE_RUNTIME_KEYWORDS)
103 def _odict_hashable(self):
104     return id(self)
105 OrderedDict.__hash__ = _odict_hashable
106 def split_low_tag(tag):
107     """
108     Take a low tag and split it back into the low dict that it came from
109     """
110     state, id_, name, fun = tag.split("_|-")
111     return {"state": state, "__id__": id_, "name": name, "fun": fun}
112 def _gen_tag(low):
113     """
114     Generate the running dict tag string from the low data structure
115     """
116     return "{0[state]}_|-{0[__id__]}_|-{0[name]}_|-{0[fun]}".format(low)
117 def _clean_tag(tag):
118     """
119     Make tag name safe for filenames
120     """
121     return salt.utils.files.safe_filename_leaf(tag)
122 def _l_tag(name, id_):
123     low = {
124         "name": "listen_{}".format(name),
125         "__id__": "listen_{}".format(id_),
126         "state": "Listen_Error",
127         "fun": "Listen_Error",
128     }
129     return _gen_tag(low)
130 def _calculate_fake_duration():
131     """
132     Generate a NULL duration for when states do not run
133     but we want the results to be consistent.
134     """
135     utc_start_time = datetime.datetime.utcnow()
136     local_start_time = utc_start_time - (
137         datetime.datetime.utcnow() - datetime.datetime.now()
138     )
139     utc_finish_time = datetime.datetime.utcnow()
140     start_time = local_start_time.time().isoformat()
141     delta = utc_finish_time - utc_start_time
142     duration = (delta.seconds * 1000000 + delta.microseconds) / 1000.0
143     return start_time, duration
144 def get_accumulator_dir(cachedir):
145     """
146     Return the directory that accumulator data is stored in, creating it if it
147     doesn't exist.
148     """
149     fn_ = os.path.join(cachedir, "accumulator")
150     if not os.path.isdir(fn_):
151         os.makedirs(fn_)
152     return fn_
153 def trim_req(req):
154     """
155     Trim any function off of a requisite
156     """
157     reqfirst = next(iter(req))
158     if "." in reqfirst:
159         return {reqfirst.split(".")[0]: req[reqfirst]}
160     return req
161 def state_args(id_, state, high):
162     """
163     Return a set of the arguments passed to the named state
164     """
165     args = set()
166     if id_ not in high:
167         return args
168     if state not in high[id_]:
169         return args
170     for item in high[id_][state]:
171         if not isinstance(item, dict):
172             continue
173         if len(item) != 1:
174             continue
175         args.add(next(iter(item)))
176     return args
177 def find_name(name, state, high, strict=False):
178     """
179     Scan high data for the id referencing the given name and return a list of (IDs, state) tuples that match
180     Note: if `state` is sls, then we are looking for all IDs that match the given SLS
181     """
182     ext_id = []
183     if strict is False:
184         check2 = True
185     else:
186         check2 = state in high.get(name, {})
187     if name in high and check2:
188         ext_id.append((name, state))
189     elif state == "sls":
190         for nid, item in high.items():
191             if item["__sls__"] == name:
192                 ext_id.append((nid, next(iter(item))))
193     else:
194         for nid in high:
195             if state in high[nid]:
196                 if isinstance(high[nid][state], list):
197                     for arg in high[nid][state]:
198                         if not isinstance(arg, dict):
199                             continue
200                         if len(arg) != 1:
201                             continue
202                         if arg[next(iter(arg))] == name:
203                             ext_id.append((nid, state))
204     return ext_id
205 def find_sls_ids(sls, high):
206     """
207     Scan for all ids in the given sls and return them in a dict; {name: state}
208     """
209     ret = []
210     for nid, item in high.items():
211         try:
212             sls_tgt = item["__sls__"]
213         except TypeError:
214             if nid != "__exclude__":
215                 log.error(
216                     "Invalid non-dict item '%s' in high data. Value: %r", nid, item
217                 )
218             continue
219         else:
220             if sls_tgt == sls:
221                 for st_ in item:
222                     if st_.startswith("__"):
223                         continue
224                     ret.append((nid, st_))
225     return ret
226 def format_log(ret):
227     """
228     Format the state into a log message
229     """
230     msg = ""
231     if isinstance(ret, dict):
232         if "changes" in ret:
233             chg = ret["changes"]
234             if not chg:
235                 if ret["comment"]:
236                     msg = ret["comment"]
237                 else:
238                     msg = "No changes made for {0[name]}".format(ret)
239             elif isinstance(chg, dict):
240                 if "diff" in chg:
241                     if isinstance(chg["diff"], str):
242                         msg = "File changed:\n{}".format(chg["diff"])
243                 if all([isinstance(x, dict) for x in chg.values()]):
244                     if all([("old" in x and "new" in x) for x in chg.values()]):
245                         msg = "Made the following changes:\n"
246                         for pkg in chg:
247                             old = chg[pkg]["old"]
248                             if not old and old not in (False, None):
249                                 old = "absent"
250                             new = chg[pkg]["new"]
251                             if not new and new not in (False, None):
252                                 new = "absent"
253                             msg += "'{}' changed from '{}' to '{}'\n".format(
254                                 pkg, old, new
255                             )
256             if not msg:
257                 msg = str(ret["changes"])
258             if ret["result"] is True or ret["result"] is None:
259                 log.info(msg)
260             else:
261                 log.error(msg)
262     else:
263         log.info(str(ret))
264 def master_compile(master_opts, minion_opts, grains, id_, saltenv):
265     """
266     Compile the master side low state data, and build the hidden state file
267     """
268     st_ = MasterHighState(master_opts, minion_opts, grains, id_, saltenv)
269     return st_.compile_highstate()
270 def ishashable(obj):
271     try:
272         hash(obj)
273     except TypeError:
274         return False
275     return True
276 def mock_ret(cdata):
277     """
278     Returns a mocked return dict with information about the run, without
279     executing the state function
280     """
281     if cdata["args"]:
282         name = cdata["args"][0]
283     else:
284         name = cdata["kwargs"]["name"]
285     return {
286         "name": name,
287         "comment": "Not called, mocked",
288         "changes": {},
289         "result": True,
290     }
291 class StateError(Exception):
292     """
293     Custom exception class.
294     """
295 class Compiler:
296     """
297     Class used to compile and manage the High Data structure
298     """
299     def __init__(self, opts, renderers):
300         self.opts = opts
301         self.rend = renderers
302     def render_template(self, template, **kwargs):
303         """
304         Enforce the states in a template
305         """
306         high = compile_template(
307             template,
308             self.rend,
309             self.opts["renderer"],
310             self.opts["renderer_blacklist"],
311             self.opts["renderer_whitelist"],
312             **kwargs
313         )
314         if not high:
315             return high
316         return self.pad_funcs(high)
317     def pad_funcs(self, high):
318         """
319         Turns dot delimited function refs into function strings
320         """
321         for name in high:
322             if not isinstance(high[name], dict):
323                 if isinstance(high[name], str):
324                     if "." in high[name]:
325                         comps = high[name].split(".")
326                         if len(comps) &gt;= 2:
327                             comps[1] = ".".join(comps[1 : len(comps)])
328                         high[name] = {
329                             comps[0]: [comps[1]]
330                         }
331                         continue
332                     continue
333             skeys = set()
334             for key in sorted(high[name]):
335                 if key.startswith("_"):
336                     continue
337                 if not isinstance(high[name][key], list):
338                     continue
339                 if "." in key:
340                     comps = key.split(".")
341                     if len(comps) &gt;= 2:
342                         comps[1] = ".".join(comps[1 : len(comps)])
343                     if comps[0] in skeys:
344                         continue
345                     high[name][comps[0]] = high[name].pop(key)
346                     high[name][comps[0]].append(comps[1])
347                     skeys.add(comps[0])
348                     continue
349                 skeys.add(key)
350         return high
351     def verify_high(self, high):
352         """
353         Verify that the high data is viable and follows the data structure
354         """
355         errors = []
356         if not isinstance(high, dict):
357             errors.append("High data is not a dictionary and is invalid")
358         reqs = OrderedDict()
359         for name, body in high.items():
360             if name.startswith("__"):
361                 continue
362             if not isinstance(name, str):
363                 errors.append(
364                     "ID '{}' in SLS '{}' is not formed as a string, but is a {}".format(
365                         name, body["__sls__"], type(name).__name__
366                     )
367                 )
368             if not isinstance(body, dict):
369                 err = "The type {} in {} is not formatted as a dictionary".format(
370                     name, body
371                 )
372                 errors.append(err)
373                 continue
374             for state in body:
375                 if state.startswith("__"):
376                     continue
377                 if not isinstance(body[state], list):
378                     errors.append(
379                         "State '{}' in SLS '{}' is not formed as a list".format(
380                             name, body["__sls__"]
381                         )
382                     )
383                 else:
384                     fun = 0
385                     if "." in state:
386                         fun += 1
387                     for arg in body[state]:
388                         if isinstance(arg, str):
389                             fun += 1
390                             if " " in arg.strip():
391                                 errors.append(
392                                     'The function "{}" in state '
393                                     '"{}" in SLS "{}" has '
394                                     "whitespace, a function with whitespace is "
395                                     "not supported, perhaps this is an argument "
396                                     'that is missing a ":"'.format(
397                                         arg, name, body["__sls__"]
398                                     )
399                                 )
400                         elif isinstance(arg, dict):
401                             argfirst = next(iter(arg))
402                             if argfirst in ("require", "watch", "prereq", "onchanges"):
403                                 if not isinstance(arg[argfirst], list):
404                                     errors.append(
405                                         "The {} statement in state '{}' in SLS '{}' "
406                                         "needs to be formed as a list".format(
407                                             argfirst, name, body["__sls__"]
408                                         )
409                                     )
410                                 else:
411                                     reqs[name] = {"state": state}
412                                     for req in arg[argfirst]:
413                                         if isinstance(req, str):
414                                             req = {"id": req}
415                                         if not isinstance(req, dict):
416                                             errors.append(
417                                                 "Requisite declaration {} in SLS {} "
418                                                 "is not formed as a single key "
419                                                 "dictionary".format(
420                                                     req, body["__sls__"]
421                                                 )
422                                             )
423                                             continue
424                                         req_key = next(iter(req))
425                                         req_val = req[req_key]
426                                         if "." in req_key:
427                                             errors.append(
428                                                 "Invalid requisite type '{}' "
429                                                 "in state '{}', in SLS "
430                                                 "'{}'. Requisite types must "
431                                                 "not contain dots, did you "
432                                                 "mean '{}'?".format(
433                                                     req_key,
434                                                     name,
435                                                     body["__sls__"],
436                                                     req_key[: req_key.find(".")],
437                                                 )
438                                             )
439                                         if not ishashable(req_val):
440                                             errors.append(
441                                                 'Illegal requisite "{}", is SLS {}\n'.format(
442                                                     str(req_val),
443                                                     body["__sls__"],
444                                                 )
445                                             )
446                                             continue
447                                         reqs[name][req_val] = req_key
448                                         if req_val in reqs:
449                                             if name in reqs[req_val]:
450                                                 if reqs[req_val][name] == state:
451                                                     if (
452                                                         reqs[req_val]["state"]
453                                                         == reqs[name][req_val]
454                                                     ):
455                                                         errors.append(
456                                                             "A recursive requisite was"
457                                                             ' found, SLS "{}" ID "{}"'
458                                                             ' ID "{}"'.format(
459                                                                 body["__sls__"],
460                                                                 name,
461                                                                 req_val,
462                                                             )
463                                                         )
464                                 if len(list(arg)) != 1:
465                                     errors.append(
466                                         "Multiple dictionaries defined in argument "
467                                         "of state '{}' in SLS '{}'".format(
468                                             name, body["__sls__"]
469                                         )
470                                     )
471                     if not fun:
472                         if state == "require" or state == "watch":
473                             continue
474                         errors.append(
475                             "No function declared in state '{}' in SLS '{}'".format(
476                                 state, body["__sls__"]
477                             )
478                         )
479                     elif fun &gt; 1:
480                         errors.append(
481                             "Too many functions declared in state '{}' in "
482                             "SLS '{}'".format(state, body["__sls__"])
483                         )
484         return errors
485     def order_chunks(self, chunks):
486         """
487         Sort the chunk list verifying that the chunks follow the order
488         specified in the order options.
489         """
490         cap = 1
491         for chunk in chunks:
492             if "order" in chunk:
493                 if not isinstance(chunk["order"], int):
494                     continue
495                 chunk_order = chunk["order"]
496                 if chunk_order &gt; cap - 1 and chunk_order &gt; 0:
497                     cap = chunk_order + 100
498         for chunk in chunks:
499             if "order" not in chunk:
500                 chunk["order"] = cap
501                 continue
502             if not isinstance(chunk["order"], (int, float)):
503                 if chunk["order"] == "last":
504                     chunk["order"] = cap + 1000000
505                 elif chunk["order"] == "first":
506                     chunk["order"] = 0
507                 else:
508                     chunk["order"] = cap
509             if "name_order" in chunk:
510                 chunk["order"] = chunk["order"] + chunk.pop("name_order") / 10000.0
511             if chunk["order"] &lt; 0:
512                 chunk["order"] = cap + 1000000 + chunk["order"]
513             chunk["name"] = salt.utils.data.decode(chunk["name"])
514         chunks.sort(
515             key=lambda chunk: (
516                 chunk["order"],
517                 "{0[state]}{0[name]}{0[fun]}".format(chunk),
518             )
519         )
520         return chunks
521     def compile_high_data(self, high):
522         """
523         "Compile" the high data as it is retrieved from the CLI or YAML into
524         the individual state executor structures
525         """
526         chunks = []
527         for name, body in high.items():
528             if name.startswith("__"):
529                 continue
530             for state, run in body.items():
531                 funcs = set()
532                 if state.startswith("__"):
533                     continue
534                 chunk = {<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"state": state, "name": name}
535                 if "__sls__" in body:
536                     chunk["__sls__"] = body["__sls__"]
537                 if "__env__" in body:
538                     chunk["__env__"] = body["__env__"]
539                 chunk["__id__"] =</b></font> name
540                 for arg in run:
541                     if isinstance(arg, str):
542                         funcs.add(arg)
543                         continue
544                     if isinstance(arg, dict):
545                         for key, val in arg.items():
546                             if key == "names":
547                                 for _name in val:
548                                     if _name not in names:
549                                         names.append(_name)
550                                 continue
551                             else:
552                                 chunk.update(arg)
553                 if names:
554                     name_order = 1
555                     for entry in names:
556                         live = copy.deepcopy(chunk)
557                         if isinstance(entry, dict):
558                             low_name = next(iter(entry.keys()))
559                             live["name"] = low_name
560                             list(map(live.update, entry[low_name]))
561                         else:
562                             live["name"] = entry
563                         live["name_order"] = name_order
564                         name_order = name_order + 1
565                         for fun in funcs:
566                             live["fun"] = fun
567                             chunks.append(live)
568                 else:
569                     live = copy.deepcopy(chunk)
570                     for fun in funcs:
571                         live["fun"] = fun
572                         chunks.append(live)
573         chunks = self.order_chunks(chunks)
574         return chunks
575     def apply_exclude(self, high):
576         """
577         Read in the __exclude__ list and remove all excluded objects from the
578         high data
579         """
580         if "__exclude__" not in high:
581             return high
582         ex_sls = set()
583         ex_id = set()
584         exclude = high.pop("__exclude__")
585         for exc in exclude:
586             if isinstance(exc, str):
587                 ex_sls.add(exc)
588             if isinstance(exc, dict):
589                 if len(exc) != 1:
590                     continue
591                 key = next(iter(exc.keys()))
592                 if key == "sls":
593                     ex_sls.add(exc["sls"])
594                 elif key == "id":
595                     ex_id.add(exc["id"])
596         if ex_sls:
597             for name, body in high.items():
598                 if name.startswith("__"):
599                     continue
600                 if body.get("__sls__", "") in ex_sls:
601                     ex_id.add(name)
602         for id_ in ex_id:
603             if id_ in high:
604                 high.pop(id_)
605         return high
606 class State:
607     """
608     Class used to execute salt states
609     """
610     def __init__(
611         self,
612         opts,
613         pillar_override=None,
614         jid=None,
615         pillar_enc=None,
616         proxy=None,
617         context=None,
618         mocked=False,
619         loader="states",
620         initial_pillar=None,
621     ):
622         self.states_loader = loader
623         if "grains" not in opts:
624             opts["grains"] = salt.loader.grains(opts)
625         self.opts = opts
626         self.proxy = proxy
627         self._pillar_override = pillar_override
628         if pillar_enc is not None:
629             try:
630                 pillar_enc = pillar_enc.lower()
631             except AttributeError:
632                 pillar_enc = str(pillar_enc).lower()
633         self._pillar_enc = pillar_enc
634         log.debug("Gathering pillar data for state run")
635         if initial_pillar and not self._pillar_override:
636             self.opts["pillar"] = initial_pillar
637         else:
638             self.opts["pillar"] = self._gather_pillar()
639             if self._pillar_override:
640                 self.opts["pillar"] = salt.utils.dictupdate.merge(
641                     self.opts["pillar"],
642                     self._pillar_override,
643                     self.opts.get("pillar_source_merging_strategy", "smart"),
644                     self.opts.get("renderer", "yaml"),
645                     self.opts.get("pillar_merge_lists", False),
646                 )
647         log.debug("Finished gathering pillar data for state run")
648         self.state_con = context or {}
649         self.load_modules()
650         self.active = set()
651         self.mod_init = set()
652         self.pre = {}
653         self.__run_num = 0
654         self.jid = jid
655         self.instance_id = str(id(self))
656         self.inject_globals = {}
657         self.mocked = mocked
658     def _gather_pillar(self):
659         """
660         Whenever a state run starts, gather the pillar data fresh
661         """
662         if self._pillar_override:
663             if self._pillar_enc:
664                 try:
665                     self._pillar_override = salt.utils.crypt.decrypt(
666                         self._pillar_override,
667                         self._pillar_enc,
668                         translate_newlines=True,
669                         renderers=getattr(self, "rend", None),
670                         opts=self.opts,
671                         valid_rend=self.opts["decrypt_pillar_renderers"],
672                     )
673                 except Exception as exc:  # pylint: disable=broad-except
674                     log.error("Failed to decrypt pillar override: %s", exc)
675             if isinstance(self._pillar_override, str):
676                 try:
677                     self._pillar_override = yamlloader.load(
678                         self._pillar_override, Loader=yamlloader.SaltYamlSafeLoader
679                     )
680                 except Exception as exc:  # pylint: disable=broad-except
681                     log.error("Failed to load CLI pillar override")
682                     log.exception(exc)
683             if not isinstance(self._pillar_override, dict):
684                 log.error("Pillar override was not passed as a dictionary")
685                 self._pillar_override = None
686         pillar = salt.pillar.get_pillar(
687             self.opts,
688             self.opts["grains"],
689             self.opts["id"],
690             self.opts["saltenv"],
691             pillar_override=self._pillar_override,
692             pillarenv=self.opts.get("pillarenv"),
693         )
694         return pillar.compile_pillar()
695     def _mod_init(self, low):
696         """
697         Check the module initialization function, if this is the first run
698         of a state package that has a mod_init function, then execute the
699         mod_init function in the state module.
700         """
701         try:
702             self.states[
703                 "{}.{}".format(low["state"], low["fun"])
704             ]  # pylint: disable=W0106
705         except KeyError:
706             return
707         minit = "{}.mod_init".format(low["state"])
708         if low["state"] not in self.mod_init:
709             if minit in self.states._dict:
710                 mret = self.states[minit](low)
711                 if not mret:
712                     return
713                 self.mod_init.add(low["state"])
714     def _aggregate_requisites(self, low, chunks):
715         """
716         Aggregate the requisites
717         """
718         requisites = {}
719         low_state = low["state"]
720         for chunk in chunks:
721             if chunk["state"] == low["state"] and chunk.get("__agg__"):
722                 for req in frozenset.union(
723                     *[STATE_REQUISITE_KEYWORDS, STATE_REQUISITE_IN_KEYWORDS]
724                 ):
725                     if req in chunk:
726                         if req in requisites:
727                             requisites[req].extend(chunk[req])
728                         else:
729                             requisites[req] = chunk[req]
730         low.update(requisites)
731         return low
732     def _mod_aggregate(self, low, running, chunks):
733         """
734         Execute the aggregation systems to runtime modify the low chunk
735         """
736         agg_opt = self.functions["config.option"]("state_aggregate")
737         if "aggregate" in low:
738             agg_opt = low["aggregate"]
739         if agg_opt is True:
740             agg_opt = [low["state"]]
741         elif not isinstance(agg_opt, list):
742             return low
743         if low["state"] in agg_opt and not low.get("__agg__"):
744             agg_fun = "{}.mod_aggregate".format(low["state"])
745             if agg_fun in self.states:
746                 try:
747                     low = self.states[agg_fun](low, chunks, running)
748                     low = self._aggregate_requisites(low, chunks)
749                     low["__agg__"] = True
750                 except TypeError:
751                     log.error("Failed to execute aggregate for state %s", low["state"])
752         return low
753     def _run_check(self, low_data):
754         """
755         Check that unless doesn't return 0, and that onlyif returns a 0.
756         """
757         ret = {"result": False, "comment": []}
758         cmd_opts = {}
759         POSSIBLE_CMD_ARGS = (
760             "cwd",
761             "root",
762             "runas",
763             "env",
764             "prepend_path",
765             "umask",
766             "timeout",
767             "success_retcodes",
768         )
769         for run_cmd_arg in POSSIBLE_CMD_ARGS:
770             cmd_opts[run_cmd_arg] = low_data.get(run_cmd_arg)
771         if "shell" in low_data:
772             cmd_opts["shell"] = low_data["shell"]
773         elif "shell" in self.opts["grains"]:
774             cmd_opts["shell"] = self.opts["grains"].get("shell")
775         if "onlyif" in low_data:
776             _ret = self._run_check_onlyif(low_data, cmd_opts)
777             ret["result"] = _ret["result"]
778             ret["comment"].append(_ret["comment"])
779             if "skip_watch" in _ret:
780                 ret["skip_watch"] = _ret["skip_watch"]
781         if "unless" in low_data:
782             _ret = self._run_check_unless(low_data, cmd_opts)
783             ret["result"] = _ret["result"] or ret["result"]
784             ret["comment"].append(_ret["comment"])
785             if "skip_watch" in _ret:
786                 ret["skip_watch"] = _ret["skip_watch"] or ret["skip_watch"]
787         if "creates" in low_data:
788             _ret = self._run_check_creates(low_data)
789             ret["result"] = _ret["result"] or ret["result"]
790             ret["comment"].append(_ret["comment"])
791             if "skip_watch" in _ret:
792                 ret["skip_watch"] = _ret["skip_watch"] or ret["skip_watch"]
793         return ret
794     def _run_check_function(self, entry):
795         fun = entry.pop("fun")
796         args = entry.pop("args") if "args" in entry else []
797         cdata = {"args": args, "kwargs": entry}
798         self.format_slots(cdata)
799         return self.functions[fun](*cdata["args"], **cdata["kwargs"])
800     def _run_check_onlyif(self, low_data, cmd_opts):
801         """
802         Make sure that all commands return True for the state to run. If any
803         command returns False (non 0), the state will not run
804         """
805         ret = {"result": False}
806         if not isinstance(low_data["onlyif"], list):
807             low_data_onlyif = [low_data["onlyif"]]
808         else:
809             low_data_onlyif = low_data["onlyif"]
810         def _check_cmd(cmd):
811             if cmd != 0 and ret["result"] is False:
812                 ret.update(
813                     {
814                         "comment": "onlyif condition is false",
815                         "skip_watch": True,
816                         "result": True,
817                     }
818                 )
819                 return False
820             elif cmd == 0:
821                 ret.update({"comment": "onlyif condition is true", "result": False})
822             return True
823         for entry in low_data_onlyif:
824             if isinstance(entry, str):
825                 try:
826                     cmd = self.functions["cmd.retcode"](
827                         entry, ignore_retcode=True, python_shell=True, **cmd_opts
828                     )
829                 except CommandExecutionError:
830                     cmd = 100
831                 log.debug("Last command return code: %s", cmd)
832                 if not _check_cmd(cmd):
833                     return ret
834             elif isinstance(entry, dict):
835                 if "fun" not in entry:
836                     ret["comment"] = "no `fun` argument in onlyif: {}".format(entry)
837                     log.warning(ret["comment"])
838                     return ret
839                 get_return = entry.pop("get_return", None)
840                 result = self._run_check_function(entry)
841                 if get_return:
842                     result = salt.utils.data.traverse_dict_and_list(result, get_return)
843                 if self.state_con.get("retcode", 0):
844                     if not _check_cmd(self.state_con["retcode"]):
845                         return ret
846                 elif not result:
847                     ret.update(
848                         {
849                             "comment": "onlyif condition is false",
850                             "skip_watch": True,
851                             "result": True,
852                         }
853                     )
854                     return ret
855                 else:
856                     ret.update({"comment": "onlyif condition is true", "result": False})
857             else:
858                 ret.update(
859                     {
860                         "comment": "onlyif execution failed, bad type passed",
861                         "result": False,
862                     }
863                 )
864                 return ret
865         return ret
866     def _run_check_unless(self, low_data, cmd_opts):
867         """
868         Check if any of the commands return False (non 0). If any are False the
869         state will run.
870         """
871         ret = {"result": False}
872         if not isinstance(low_data["unless"], list):
873             low_data_unless = [low_data["unless"]]
874         else:
875             low_data_unless = low_data["unless"]
876         def _check_cmd(cmd):
877             if cmd == 0:
878                 ret.update(
879                     {
880                         "comment": "unless condition is true",
881                         "skip_watch": True,
882                         "result": True,
883                     }
884                 )
885                 return False
886             else:
887                 ret.pop("skip_watch", None)
888                 ret.update({"comment": "unless condition is false", "result": False})
889                 return True
890         for entry in low_data_unless:
891             if isinstance(entry, str):
892                 try:
893                     cmd = self.functions["cmd.retcode"](
894                         entry, ignore_retcode=True, python_shell=True, **cmd_opts
895                     )
896                     log.debug("Last command return code: %s", cmd)
897                 except CommandExecutionError:
898                     cmd = 0
899                 if _check_cmd(cmd):
900                     return ret
901             elif isinstance(entry, dict):
902                 if "fun" not in entry:
903                     ret["comment"] = "no `fun` argument in unless: {}".format(entry)
904                     log.warning(ret["comment"])
905                     return ret
906                 get_return = entry.pop("get_return", None)
907                 result = self._run_check_function(entry)
908                 if get_return:
909                     result = salt.utils.data.traverse_dict_and_list(result, get_return)
910                 if self.state_con.get("retcode", 0):
911                     if _check_cmd(self.state_con["retcode"]):
912                         return ret
913                 elif result:
914                     ret.update(
915                         {
916                             "comment": "unless condition is true",
917                             "skip_watch": True,
918                             "result": True,
919                         }
920                     )
921                 else:
922                     ret.update(
923                         {"comment": "unless condition is false", "result": False}
924                     )
925                     return ret
926             else:
927                 ret.update(
928                     {
929                         "comment": "unless condition is false, bad type passed",
930                         "result": False,
931                     }
932                 )
933         return ret
934     def _run_check_cmd(self, low_data):
935         """
936         Alter the way a successful state run is determined
937         """
938         ret = {"result": False}
939         cmd_opts = {}
940         if "shell" in self.opts["grains"]:
941             cmd_opts["shell"] = self.opts["grains"].get("shell")
942         for entry in low_data["check_cmd"]:
943             cmd = self.functions["cmd.retcode"](
944                 entry, ignore_retcode=True, python_shell=True, **cmd_opts
945             )
946             log.debug("Last command return code: %s", cmd)
947             if cmd == 0 and ret["result"] is False:
948                 ret.update(
949                     {
950                         "comment": "check_cmd determined the state succeeded",
951                         "result": True,
952                     }
953                 )
954             elif cmd != 0:
955                 ret.update(
956                     {
957                         "comment": "check_cmd determined the state failed",
958                         "result": False,
959                     }
960                 )
961                 return ret
962         return ret
963     def _run_check_creates(self, low_data):
964         """
965         Check that listed files exist
966         """
967         ret = {"result": False}
968         if isinstance(low_data["creates"], str) and os.path.exists(low_data["creates"]):
969             ret["comment"] = "{} exists".format(low_data["creates"])
970             ret["result"] = True
971             ret["skip_watch"] = True
972         elif isinstance(low_data["creates"], list) and all(
973             [os.path.exists(path) for path in low_data["creates"]]
974         ):
975             ret["comment"] = "All files in creates exist"
976             ret["result"] = True
977             ret["skip_watch"] = True
978         else:
979             ret["comment"] = "Creates files not found"
980             ret["result"] = False
981         return ret
982     def reset_run_num(self):
983         """
984         Rest the run_num value to 0
985         """
986         self.__run_num = 0
987     def _load_states(self):
988         """
989         """
990         if self.states_loader == "thorium":
991             self.states <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= salt.loader.thorium(
992                 self.opts, self.functions, {}
993             )  # TODO: Add runners, proxy?
994         else:
995             self.states = salt.loader.states(
996                 self.</b></font>opts,
997                 self.functions,
998                 self.utils,
999                 self.serializers,
1000                 context=self.state_con,
1001             )
1002     def load_modules(self, data=None, proxy<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None):
1003         """
1004         Load the modules into the state
1005         """
1006         log.info("Loading fresh modules for state activity")
1007         self.utils = salt.loader.utils(self.opts)
1008         self.functions = salt.loader.minion_mods(
1009             self.opts, self.state_con, utils=self.</b></font>utils, proxy=self.proxy
1010         )
1011         if isinstance(data, dict):
1012             if data.get("provider", False):
1013                 if isinstance(data["provider"], str):
1014                     providers = [{data["state"]: data["provider"]}]
1015                 elif isinstance(data["provider"], list):
1016                     providers = data["provider"]
1017                 else:
1018                     providers = {}
1019                 for provider in providers:
1020                     for mod in provider:
1021                         funcs = salt.loader.raw_mod(
1022                             self.opts, provider[mod], self.functions
1023                         )
1024                         if funcs:
1025                             for func in funcs:
1026                                 f_key = "{}{}".format(mod, func[func.rindex(".") :])
1027                                 self.functions[f_key] = funcs[func]
1028         self.serializers = salt.loader.serializers(self.opts)
1029         self._load_states()
1030         self.rend = salt.loader.render(
1031             self.opts,
1032             self.functions,
1033             states=self.states,
1034             proxy=self.proxy,
1035             context=self.state_con,
1036         )
1037     def module_refresh(self):
1038         """
1039         Refresh all the modules
1040         """
1041         log.debug("Refreshing modules...")
1042         if self.opts["grains"].get("os") != "MacOS":
1043             try:
1044                 importlib.reload(site)
1045             except RuntimeError:
1046                 log.error(
1047                     "Error encountered during module reload. Modules were not reloaded."
1048                 )
1049             except TypeError:
1050                 log.error(
1051                     "Error encountered during module reload. Modules were not reloaded."
1052                 )
1053         self.load_modules()
1054         if not self.opts.get("local", False) and self.opts.get("multiprocessing", True):
1055             self.functions["saltutil.refresh_modules"]()
1056     def check_refresh(self, data, ret):
1057         """
1058         Check to see if the modules for this state instance need to be updated,
1059         only update if the state is a file or a package and if it changed
1060         something. If the file function is managed check to see if the file is a
1061         possible module type, e.g. a python, pyx, or .so. Always refresh if the
1062         function is recurse, since that can lay down anything.
1063         """
1064         _reload_modules = False
1065         if data.get("reload_grains", False):
1066             log.debug("Refreshing grains...")
1067             self.opts["grains"] = salt.loader.grains(self.opts)
1068             _reload_modules = True
1069         if data.get("reload_pillar", False):
1070             log.debug("Refreshing pillar...")
1071             self.opts["pillar"] = self._gather_pillar()
1072             _reload_modules = True
1073         if not ret["changes"]:
1074             if data.get("force_reload_modules", False):
1075                 self.module_refresh()
1076             return
1077         if data.get("reload_modules", False) or _reload_modules:
1078             self.module_refresh()
1079             return
1080         if data["state"] == "file":
1081             if data["fun"] == "managed":
1082                 if data["name"].endswith((".py", ".pyx", ".pyo", ".pyc", ".so")):
1083                     self.module_refresh()
1084             elif data["fun"] == "recurse":
1085                 self.module_refresh()
1086             elif data["fun"] == "symlink":
1087                 if "bin" in data["name"]:
1088                     self.module_refresh()
1089         elif data["state"] in ("pkg", "ports", "pip"):
1090             self.module_refresh()
1091     def verify_data(self, data):
1092         """
1093         Verify the data, return an error statement if something is wrong
1094         """
1095         errors = []
1096         if "state" not in data:
1097             errors.append('Missing "state" data')
1098         if "fun" not in data:
1099             errors.append('Missing "fun" data')
1100         if "name" not in data:
1101             errors.append('Missing "name" data')
1102         if data["name"] and not isinstance(data["name"], str):
1103             errors.append(
1104                 "ID '{}' {}is not formed as a string, but is a {}".format(
1105                     data["name"],
1106                     "in SLS '{}' ".format(data["__sls__"]) if "__sls__" in data else "",
1107                     type(data["name"]).__name__,
1108                 )
1109             )
1110         if errors:
1111             return errors
1112         full = data["state"] + "." + data["fun"]
1113         if full not in self.states:
1114             if "__sls__" in data:
1115                 errors.append(
1116                     "State '{}' was not found in SLS '{}'".format(full, data["__sls__"])
1117                 )
1118                 reason = self.states.missing_fun_string(full)
1119                 if reason:
1120                     errors.append("Reason: {}".format(reason))
1121             else:
1122                 errors.append("Specified state '{}' was not found".format(full))
1123         else:
1124             aspec = salt.utils.args.get_function_argspec(self.states[full])
1125             arglen = 0
1126             deflen = 0
1127             if isinstance(aspec.args, list):
1128                 arglen = len(aspec.args)
1129             if isinstance(aspec.defaults, tuple):
1130                 deflen = len(aspec.defaults)
1131             for ind in range(arglen - deflen):
1132                 if aspec.args[ind] not in data:
1133                     errors.append(
1134                         "Missing parameter {} for state {}".format(
1135                             aspec.args[ind], full
1136                         )
1137                     )
1138         reqdec = ""
1139         if "require" in data:
1140             reqdec = "require"
1141         if "watch" in data:
1142             if "{}.mod_watch".format(data["state"]) not in self.states:
1143                 if "require" in data:
1144                     data["require"].extend(data.pop("watch"))
1145                 else:
1146                     data["require"] = data.pop("watch")
1147                 reqdec = "require"
1148             else:
1149                 reqdec = "watch"
1150         if reqdec:
1151             for req in data[reqdec]:
1152                 reqfirst = next(iter(req))
1153                 if data["state"] == reqfirst:
1154                     if fnmatch.fnmatch(data["name"], req[reqfirst]) or fnmatch.fnmatch(
1155                         data["__id__"], req[reqfirst]
1156                     ):
1157                         errors.append(
1158                             "Recursive require detected in SLS {} for "
1159                             "require {} in ID {}".format(
1160                                 data["__sls__"], req, data["__id__"]
1161                             )
1162                         )
1163         return errors
1164     def verify_high(self, high):
1165         """
1166         Verify that the high data is viable and follows the data structure
1167         """
1168         errors = []
1169         if not isinstance(high, dict):
1170             errors.append("High data is not a dictionary and is invalid")
1171         reqs = OrderedDict()
1172         for name, body in high.items():
1173             try:
1174                 if name.startswith("__"):
1175                     continue
1176             except AttributeError:
1177                 pass
1178             if not isinstance(name, str):
1179                 errors.append(
1180                     "ID '{}' in SLS '{}' is not formed as a string, but "
1181                     "is a {}. It may need to be quoted.".format(
1182                         name, body["__sls__"], type(name).__name__
1183                     )
1184                 )
1185             if not isinstance(body, dict):
1186                 err = "The type {} in {} is not formatted as a dictionary".format(
1187                     name, body
1188                 )
1189                 errors.append(err)
1190                 continue
1191             for state in body:
1192                 if state.startswith("__"):
1193                     continue
1194                 if body[state] is None:
1195                     errors.append(
1196                         "ID '{}' in SLS '{}' contains a short declaration "
1197                         "({}) with a trailing colon. When not passing any "
1198                         "arguments to a state, the colon must be omitted.".format(
1199                             name, body["__sls__"], state
1200                         )
1201                     )
1202                     continue
1203                 if not isinstance(body[state], list):
1204                     errors.append(
1205                         "State '{}' in SLS '{}' is not formed as a list".format(
1206                             name, body["__sls__"]
1207                         )
1208                     )
1209                 else:
1210                     fun = 0
1211                     if "." in state:
1212                         fun += 1
1213                     for arg in body[state]:
1214                         if isinstance(arg, str):
1215                             fun += 1
1216                             if " " in arg.strip():
1217                                 errors.append(
1218                                     'The function "{}" in state "{}" in SLS "{}" has '
1219                                     "whitespace, a function with whitespace is not "
1220                                     "supported, perhaps this is an argument that is "
1221                                     'missing a ":"'.format(arg, name, body["__sls__"])
1222                                 )
1223                         elif isinstance(arg, dict):
1224                             argfirst = next(iter(arg))
1225                             if argfirst == "names":
1226                                 if not isinstance(arg[argfirst], list):
1227                                     errors.append(
1228                                         "The 'names' argument in state "
1229                                         "'{}' in SLS '{}' needs to be "
1230                                         "formed as a list".format(name, body["__sls__"])
1231                                     )
1232                             if argfirst in ("require", "watch", "prereq", "onchanges"):
1233                                 if not isinstance(arg[argfirst], list):
1234                                     errors.append(
1235                                         "The {} statement in state '{}' in "
1236                                         "SLS '{}' needs to be formed as a "
1237                                         "list".format(argfirst, name, body["__sls__"])
1238                                     )
1239                                 else:
1240                                     reqs[name] = OrderedDict(state=state)
1241                                     for req in arg[argfirst]:
1242                                         if isinstance(req, str):
1243                                             req = {"id": req}
1244                                         if not isinstance(req, dict):
1245                                             errors.append(
1246                                                 "Requisite declaration {} in SLS {} is"
1247                                                 " not formed as a single key dictionary".format(
1248                                                     req, body["__sls__"]
1249                                                 )
1250                                             )
1251                                             continue
1252                                         req_key = next(iter(req))
1253                                         req_val = req[req_key]
1254                                         if "." in req_key:
1255                                             errors.append(
1256                                                 "Invalid requisite type '{}' "
1257                                                 "in state '{}', in SLS "
1258                                                 "'{}'. Requisite types must "
1259                                                 "not contain dots, did you "
1260                                                 "mean '{}'?".format(
1261                                                     req_key,
1262                                                     name,
1263                                                     body["__sls__"],
1264                                                     req_key[: req_key.find(".")],
1265                                                 )
1266                                             )
1267                                         if not ishashable(req_val):
1268                                             errors.append(
1269                                                 'Illegal requisite "{}", please check '
1270                                                 "your syntax.\n".format(req_val)
1271                                             )
1272                                             continue
1273                                         reqs[name][req_val] = req_key
1274                                         if req_val in reqs:
1275                                             if name in reqs[req_val]:
1276                                                 if reqs[req_val][name] == state:
1277                                                     if (
1278                                                         reqs[req_val]["state"]
1279                                                         == reqs[name][req_val]
1280                                                     ):
1281                                                         errors.append(
1282                                                             "A recursive requisite was"
1283                                                             ' found, SLS "{}" ID "{}"'
1284                                                             ' ID "{}"'.format(
1285                                                                 body["__sls__"],
1286                                                                 name,
1287                                                                 req_val,
1288                                                             )
1289                                                         )
1290                                 if len(list(arg)) != 1:
1291                                     errors.append(
1292                                         "Multiple dictionaries defined in "
1293                                         "argument of state '{}' in SLS '{}'".format(
1294                                             name, body["__sls__"]
1295                                         )
1296                                     )
1297                     if not fun:
1298                         if state == "require" or state == "watch":
1299                             continue
1300                         errors.append(
1301                             "No function declared in state '{}' in SLS '{}'".format(
1302                                 state, body["__sls__"]
1303                             )
1304                         )
1305                     elif fun &gt; 1:
1306                         errors.append(
1307                             "Too many functions declared in state '{}' in "
1308                             "SLS '{}'".format(state, body["__sls__"])
1309                         )
1310         return errors
1311     def verify_chunks(self, chunks):
1312         """
1313         Verify the chunks in a list of low data structures
1314         """
1315         err = []
1316         for chunk in chunks:
1317             err.extend(self.verify_data(chunk))
1318         return err
1319     def order_chunks(self, chunks):
1320         """
1321         Sort the chunk list verifying that the chunks follow the order
1322         specified in the order options.
1323         """
1324         cap = 1
1325         for chunk in chunks:
1326             if "order" in chunk:
1327                 if not isinstance(chunk["order"], int):
1328                     continue
1329                 chunk_order = chunk["order"]
1330                 if chunk_order &gt; cap - 1 and chunk_order &gt; 0:
1331                     cap = chunk_order + 100
1332         for chunk in chunks:
1333             if "order" not in chunk:
1334                 chunk["order"] = cap
1335                 continue
1336             if not isinstance(chunk["order"], (int, float)):
1337                 if chunk["order"] == "last":
1338                     chunk["order"] = cap + 1000000
1339                 elif chunk["order"] == "first":
1340                     chunk["order"] = 0
1341                 else:
1342                     chunk["order"] = cap
1343             if "name_order" in chunk:
1344                 chunk["order"] = chunk["order"] + chunk.pop("name_order") / 10000.0
1345             if chunk["order"] &lt; 0:
1346                 chunk["order"] = cap + 1000000 + chunk["order"]
1347         chunks.sort(
1348             key=lambda chunk: (
1349                 chunk["order"],
1350                 "{0[state]}{0[name]}{0[fun]}".format(chunk),
1351             )
1352         )
1353         return chunks
1354     def compile_high_data(self, high, orchestration_jid=None):
1355         """
1356         "Compile" the high data as it is retrieved from the CLI or YAML into
1357         the individual state executor structures
1358         """
1359         chunks = []
1360         for name, body in high.items():
1361             if name.startswith("__"):
1362                 continue
1363             for state, run in body.items():
1364                 funcs = set()
1365                 names = []
1366                 if state.startswith("__"):
1367                     continue
1368                 chunk = {"state": state, "name": name}
1369                 if orchestration_jid is not None:
1370                     chunk["__orchestration_jid__"] = orchestration_jid
1371                 if "__sls__" in body:
1372                     chunk["__sls__"] = body["__sls__"]
1373                 if "__env__" in body:
1374                     chunk["__env__"] = body["__env__"]
1375                 chunk["__id__"] = name
1376                 for arg in run:
1377                     if isinstance(arg, str):
1378                         funcs.add(arg)
1379                         continue
1380                     if isinstance(arg, dict):
1381                         for key, val in arg.items():
1382                             if key == "names":
1383                                 for _name in val:
1384                                     if _name not in names:
1385                                         names.append(_name)
1386                             elif key == "state":
1387                                 continue
1388                             elif key == "name" and not isinstance(val, str):
1389                                 chunk[key] = name
1390                             else:
1391                                 chunk[key] = val
1392                 if names:
1393                     name_order = 1
1394                     for entry in names:
1395                         live = copy.deepcopy(chunk)
1396                         if isinstance(entry, dict):
1397                             low_name = next(iter(entry.keys()))
1398                             live["name"] = low_name
1399                             list(map(live.update, entry[low_name]))
1400                         else:
1401                             live["name"] = entry
1402                         live["name_order"] = name_order
1403                         name_order += 1
1404                         for fun in funcs:
1405                             live["fun"] = fun
1406                             chunks.append(live)
1407                 else:
1408                     live = copy.deepcopy(chunk)
1409                     for fun in funcs:
1410                         live["fun"] = fun
1411                         chunks.append(live)
1412         chunks = self.order_chunks(chunks)
1413         return chunks
1414     def reconcile_extend(self, high, strict=False):
1415         """
1416         Pull the extend data and add it to the respective high data
1417         """
1418         errors = []
1419         if "__extend__" not in high:
1420             return high, errors
1421         ext = high.pop("__extend__")
1422         for ext_chunk in ext:
1423             for name, body in ext_chunk.items():
1424                 state_type = next(x for x in body if not x.startswith("__"))
1425                 if name not in high or state_type not in high[name]:
1426                     ids = find_name(name, state_type, high, strict=strict)
1427                     if len(ids) != 1:
1428                         errors.append(
1429                             "Cannot extend ID '{0}' in '{1}:{2}'. It is not "
1430                             "part of the high state.\n"
1431                             "This is likely due to a missing include statement "
1432                             "or an incorrectly typed ID.\nEnsure that a "
1433                             "state with an ID of '{0}' is available\nin "
1434                             "environment '{1}' and to SLS '{2}'".format(
1435                                 name,
1436                                 body.get("__env__", "base"),
1437                                 body.get("__sls__", "base"),
1438                             )
1439                         )
1440                         continue
1441                     else:
1442                         name = ids[0][0]
1443                 for state, run in body.items():
1444                     if state.startswith("__"):
1445                         continue
1446                     if state not in high[name]:
1447                         high[name][state] = run
1448                         continue
1449                     for arg in run:
1450                         update = False
1451                         for hind, val in enumerate(high[name][state]):
1452                             if isinstance(arg, str) and isinstance(val, str):
1453                                 high[name][state].pop(hind)
1454                                 high[name][state].insert(hind, arg)
1455                                 update = True
1456                                 continue
1457                             if isinstance(arg, dict) and isinstance(val, dict):
1458                                 argfirst = next(iter(arg))
1459                                 if argfirst == next(iter(high[name][state][hind])):
1460                                     if argfirst in STATE_REQUISITE_KEYWORDS:
1461                                         high[name][state][hind][argfirst].extend(
1462                                             arg[argfirst]
1463                                         )
1464                                     else:
1465                                         high[name][state][hind] = arg
1466                                     update = True
1467                                 if (
1468                                     argfirst == "name"
1469                                     and next(iter(high[name][state][hind])) == "names"
1470                                 ):
1471                                     high[name][state][hind] = arg
1472                         if not update:
1473                             high[name][state].append(arg)
1474         return high, errors
1475     def apply_exclude(self, high):
1476         """
1477         Read in the __exclude__ list and remove all excluded objects from the
1478         high data
1479         """
1480         if "__exclude__" not in high:
1481             return high
1482         ex_sls = set()
1483         ex_id = set()
1484         exclude = high.pop("__exclude__")
1485         for exc in exclude:
1486             if isinstance(exc, str):
1487                 ex_sls.add(exc)
1488             if isinstance(exc, dict):
1489                 if len(exc) != 1:
1490                     continue
1491                 key = next(iter(exc.keys()))
1492                 if key == "sls":
1493                     ex_sls.add(exc["sls"])
1494                 elif key == "id":
1495                     ex_id.add(exc["id"])
1496         if ex_sls:
1497             for name, body in high.items():
1498                 if name.startswith("__"):
1499                     continue
1500                 sls = body.get("__sls__", "")
1501                 if not sls:
1502                     continue
1503                 for ex_ in ex_sls:
1504                     if fnmatch.fnmatch(sls, ex_):
1505                         ex_id.add(name)
1506         for id_ in ex_id:
1507             if id_ in high:
1508                 high.pop(id_)
1509         return high
1510     def requisite_in(self, high):
1511         """
1512         Extend the data reference with requisite_in arguments
1513         """
1514         req_in = {
1515             "require_in",
1516             "watch_in",
1517             "onfail_in",
1518             "onchanges_in",
1519             "use",
1520             "use_in",
1521             "prereq",
1522             "prereq_in",
1523         }
1524         req_in_all = req_in.union(
1525             {"require", "watch", "onfail", "onfail_stop", "onchanges"}
1526         )
1527         extend = {}
1528         errors = []
1529         disabled_reqs = self.opts.get("disabled_requisites", [])
1530         if not isinstance(disabled_reqs, list):
1531             disabled_reqs = [disabled_reqs]
1532         for id_, body in high.items():
1533             if not isinstance(body, dict):
1534                 continue
1535             for state, run in body.items():
1536                 if state.startswith("__"):
1537                     continue
1538                 for arg in run:
1539                     if isinstance(arg, dict):
1540                         if len(arg) &lt; 1:
1541                             continue
1542                         key = next(iter(arg))
1543                         if key not in req_in:
1544                             continue
1545                         if key in disabled_reqs:
1546                             log.warning(
1547                                 "The %s requisite has been disabled, Ignoring.", key
1548                             )
1549                             continue
1550                         rkey = key.split("_")[0]
1551                         items = arg[key]
1552                         if isinstance(items, dict):
1553                             for _state, name in items.items():
1554                                 found = False
1555                                 if name not in extend:
1556                                     extend[name] = OrderedDict()
1557                                 if "." in _state:
1558                                     errors.append(
1559                                         "Invalid requisite in {}: {} for "
1560                                         "{}, in SLS '{}'. Requisites must "
1561                                         "not contain dots, did you mean '{}'?".format(
1562                                             rkey,
1563                                             _state,
1564                                             name,
1565                                             body["__sls__"],
1566                                             _state[: _state.find(".")],
1567                                         )
1568                                     )
1569                                     _state = _state.split(".")[0]
1570                                 if _state not in extend[name]:
1571                                     extend[name][_state] = []
1572                                 extend[name]["__env__"] = body["__env__"]
1573                                 extend[name]["__sls__"] = body["__sls__"]
1574                                 for ind in range(len(extend[name][_state])):
1575                                     if next(iter(extend[name][_state][ind])) == rkey:
1576                                         extend[name][_state][ind][rkey].append(
1577                                             {state: id_}
1578                                         )
1579                                         found = True
1580                                 if found:
1581                                     continue
1582                                 extend[name][_state].append({rkey: [{state: id_}]})
1583                         if isinstance(items, list):
1584                             hinges = []
1585                             for ind in items:
1586                                 if not isinstance(ind, dict):
1587                                     if ind in high:
1588                                         _ind_high = [
1589                                             x
1590                                             for x in high[ind]
1591                                             if not x.startswith("__")
1592                                         ]
1593                                         ind = {_ind_high[0]: ind}
1594                                     else:
1595                                         found = False
1596                                         for _id in iter(high):
1597                                             for state in [
1598                                                 state
1599                                                 for state in iter(high[_id])
1600                                                 if not state.startswith("__")
1601                                             ]:
1602                                                 for j in iter(high[_id][state]):
1603                                                     if (
1604                                                         isinstance(j, dict)
1605                                                         and "name" in j
1606                                                     ):
1607                                                         if j["name"] == ind:
1608                                                             ind = {state: _id}
1609                                                             found = True
1610                                         if not found:
1611                                             continue
1612                                 if len(ind) &lt; 1:
1613                                     continue
1614                                 pstate = next(iter(ind))
1615                                 pname = ind[pstate]
1616                                 if pstate == "sls":
1617                                     hinges = find_sls_ids(pname, high)
1618                                 else:
1619                                     hinges.append((pname, pstate))
1620                                 if "." in pstate:
1621                                     errors.append(
1622                                         "Invalid requisite in {}: {} for "
1623                                         "{}, in SLS '{}'. Requisites must "
1624                                         "not contain dots, did you mean '{}'?".format(
1625                                             rkey,
1626                                             pstate,
1627                                             pname,
1628                                             body["__sls__"],
1629                                             pstate[: pstate.find(".")],
1630                                         )
1631                                     )
1632                                     pstate = pstate.split(".")[0]
1633                                 for tup in hinges:
1634                                     name, _state = tup
1635                                     if key == "prereq_in":
1636                                         if id_ not in extend:
1637                                             extend[id_] = OrderedDict()
1638                                         if state not in extend[id_]:
1639                                             extend[id_][state] = []
1640                                         extend[id_][state].append(
1641                                             {"prerequired": [{_state: name}]}
1642                                         )
1643                                     if key == "prereq":
1644                                         ext_ids = find_name(
1645                                             name, _state, high, strict=True
1646                                         )
1647                                         for ext_id, _req_state in ext_ids:
1648                                             if ext_id not in extend:
1649                                                 extend[ext_id] = OrderedDict()
1650                                             if _req_state not in extend[ext_id]:
1651                                                 extend[ext_id][_req_state] = []
1652                                             extend[ext_id][_req_state].append(
1653                                                 {"prerequired": [{state: id_}]}
1654                                             )
1655                                         continue
1656                                     if key == "use_in":
1657                                         ext_ids = find_name(
1658                                             name, _state, high, strict=True
1659                                         )
1660                                         for ext_id, _req_state in ext_ids:
1661                                             if not ext_id:
1662                                                 continue
1663                                             ext_args = state_args(ext_id, _state, high)
1664                                             if ext_id not in extend:
1665                                                 extend[ext_id] = OrderedDict()
1666                                             if _req_state not in extend[ext_id]:
1667                                                 extend[ext_id][_req_state] = []
1668                                             ignore_args = req_in_all.union(ext_args)
1669                                             for arg in high[id_][state]:
1670                                                 if not isinstance(arg, dict):
1671                                                     continue
1672                                                 if len(arg) != 1:
1673                                                     continue
1674                                                 if next(iter(arg)) in ignore_args:
1675                                                     continue
1676                                                 if next(iter(arg.keys())) == "name":
1677                                                     continue
1678                                                 if next(iter(arg.keys())) == "names":
1679                                                     continue
1680                                                 extend[ext_id][_req_state].append(arg)
1681                                         continue
1682                                     if key == "use":
1683                                         ext_ids = find_name(
1684                                             name, _state, high, strict=True
1685                                         )
1686                                         for ext_id, _req_state in ext_ids:
1687                                             if not ext_id:
1688                                                 continue
1689                                             loc_args = state_args(id_, state, high)
1690                                             if id_ not in extend:
1691                                                 extend[id_] = OrderedDict()
1692                                             if state not in extend[id_]:
1693                                                 extend[id_][state] = []
1694                                             ignore_args = req_in_all.union(loc_args)
1695                                             for arg in high[ext_id][_req_state]:
1696                                                 if not isinstance(arg, dict):
1697                                                     continue
1698                                                 if len(arg) != 1:
1699                                                     continue
1700                                                 if next(iter(arg)) in ignore_args:
1701                                                     continue
1702                                                 if next(iter(arg.keys())) == "name":
1703                                                     continue
1704                                                 if next(iter(arg.keys())) == "names":
1705                                                     continue
1706                                                 extend[id_][state].append(arg)
1707                                         continue
1708                                     found = False
1709                                     if name not in extend:
1710                                         extend[name] = OrderedDict()
1711                                     if _state not in extend[name]:
1712                                         extend[name][_state] = []
1713                                     extend[name]["__env__"] = body["__env__"]
1714                                     extend[name]["__sls__"] = body["__sls__"]
1715                                     for ind in range(len(extend[name][_state])):
1716                                         if (
1717                                             next(iter(extend[name][_state][ind]))
1718                                             == rkey
1719                                         ):
1720                                             extend[name][_state][ind][rkey].append(
1721                                                 {state: id_}
1722                                             )
1723                                             found = True
1724                                     if found:
1725                                         continue
1726                                     extend[name][_state].append({rkey: [{state: id_}]})
1727         high["__extend__"] = []
1728         for key, val in extend.items():
1729             high["__extend__"].append({key: val})
1730         req_in_high, req_in_errors = self.reconcile_extend(high, strict=True)
1731         errors.extend(req_in_errors)
1732         return req_in_high, errors
1733     def _call_parallel_target(self, name, cdata, low):
1734         """
1735         The target function to call that will create the parallel thread/process
1736         """
1737         utc_start_time = datetime.datetime.utcnow()
1738         self.format_slots(cdata)
1739         tag = _gen_tag(low)
1740         try:
1741             ret = self.states[cdata["full"]](*cdata["args"], **cdata["kwargs"])
1742         except Exception as exc:  # pylint: disable=broad-except
1743             log.debug(
1744                 "An exception occurred in this state: %s",
1745                 exc,
1746                 exc_info_on_loglevel=logging.DEBUG,
1747             )
1748             trb = traceback.format_exc()
1749             ret = {
1750                 "result": False,
1751                 "name": name,
1752                 "changes": {},
1753                 "comment": "An exception occurred in this state: {}".format(trb),
1754             }
1755         utc_finish_time = datetime.datetime.utcnow()
1756         delta = utc_finish_time - utc_start_time
1757         duration = (delta.seconds * 1000000 + delta.microseconds) / 1000.0
1758         ret["duration"] = duration
1759         troot = os.path.join(self.opts["cachedir"], self.jid)
1760         tfile = os.path.join(troot, salt.utils.hashutils.sha1_digest(tag))
1761         if not os.path.isdir(troot):
1762             try:
1763                 os.makedirs(troot)
1764             except OSError:
1765                 pass
1766         with salt.utils.files.fopen(tfile, "wb+") as fp_:
1767             fp_.write(msgpack_serialize(ret))
1768     def call_parallel(self, cdata, low):
1769         """
1770         Call the state defined in the given cdata in parallel
1771         """
1772         name = (cdata.get("args") or [None])[0] or cdata["kwargs"].get("name")
1773         if not name:
1774             name = low.get("name", low.get("__id__"))
1775         proc = salt.utils.process.Process(
1776             target=self._call_parallel_target,
1777             args=(name, cdata, low),
1778             name="ParallelState({})".format(name),
1779         )
1780         proc.start()
1781         ret = {
1782             "name": name,
1783             "result": None,
1784             "changes": {},
1785             "comment": "Started in a separate process",
1786             "proc": proc,
1787         }
1788         return ret
1789     @salt.utils.decorators.state.OutputUnifier("content_check", "unify")
1790     def call(self, low, chunks=None, running=None, retries=1):
1791         """
1792         Call a state directly with the low data structure, verify data
1793         before processing.
1794         """
1795         utc_start_time = datetime.datetime.utcnow()
1796         local_start_time = utc_start_time - (
1797             datetime.datetime.utcnow() - datetime.datetime.now()
1798         )
1799         log.info(
1800             "Running state [%s] at time %s",
1801             low["name"].strip() if isinstance(low["name"], str) else low["name"],
1802             local_start_time.time().isoformat(),
1803         )
1804         errors = self.verify_data(low)
1805         if errors:
1806             ret = {
1807                 "result": False,
1808                 "name": low["name"],
1809                 "changes": {},
1810                 "comment": "",
1811             }
1812             for err in errors:
1813                 ret["comment"] += "{}\n".format(err)
1814             ret["__run_num__"] = self.__run_num
1815             self.__run_num += 1
1816             format_log(ret)
1817             self.check_refresh(low, ret)
1818             return ret
1819         else:
1820             ret = {"result": False, "name": low["name"], "changes": {}}
1821         self.state_con["runas"] = low.get("runas", None)
1822         if low["state"] == "cmd" and "password" in low:
1823             self.state_con["runas_password"] = low["password"]
1824         else:
1825             self.state_con["runas_password"] = low.get("runas_password", None)
1826         if not low.get("__prereq__"):
1827             log.info(
1828                 "Executing state %s.%s for [%s]",
1829                 low["state"],
1830                 low["fun"],
1831                 low["name"].strip() if isinstance(low["name"], str) else low["name"],
1832             )
1833         if "provider" in low:
1834             self.load_modules(low)
1835         state_func_name = "{0[state]}.{0[fun]}".format(low)
1836         cdata = salt.utils.args.format_call(
1837             self.states[state_func_name],
1838             low,
1839             initial_ret={"full": state_func_name},
1840             expected_extra_kws=STATE_INTERNAL_KEYWORDS,
1841         )
1842         inject_globals = {
1843             "__low__": immutabletypes.freeze(low),
1844             "__running__": immutabletypes.freeze(running) if running else {},
1845             "__instance_id__": self.instance_id,
1846             "__lowstate__": immutabletypes.freeze(chunks) if chunks else {},
1847         }
1848         if "__env__" in low:
1849             inject_globals["__env__"] = str(low["__env__"])
1850         if self.inject_globals:
1851             inject_globals.update(self.inject_globals)
1852         if low.get("__prereq__"):
1853             test = sys.modules[self.states[cdata["full"]].__module__].__opts__["test"]
1854             sys.modules[self.states[cdata["full"]].__module__].__opts__["test"] = True
1855         try:
1856             req_list = ("unless", "onlyif", "creates")
1857             if (
1858                 any(req in low for req in req_list)
1859                 and "{0[state]}.mod_run_check".format(low) not in self.states
1860             ):
1861                 ret.update(self._run_check(low))
1862             if not self.opts.get("lock_saltenv", False):
1863                 if "saltenv" in low:
1864                     inject_globals["__env__"] = str(low["saltenv"])
1865                 elif isinstance(cdata["kwargs"].get("env", None), str):
1866                     inject_globals["__env__"] = str(cdata["kwargs"]["env"])
1867             if "__env__" not in inject_globals:
1868                 inject_globals["__env__"] = "base"
1869             if "__orchestration_jid__" in low:
1870                 inject_globals["__orchestration_jid__"] = low["__orchestration_jid__"]
1871             if "result" not in ret or ret["result"] is False:
1872                 self.states.inject_globals = inject_globals
1873                 if self.mocked:
1874                     ret = mock_ret(cdata)
1875                 else:
1876                     if not low.get("__prereq__") and low.get("parallel"):
1877                         ret = self.call_parallel(cdata, low)
1878                     else:
1879                         self.format_slots(cdata)
1880                         ret = self.states[cdata["full"]](
1881                             *cdata["args"], **cdata["kwargs"]
1882                         )
1883                 self.states.inject_globals = {}
1884             if (
1885                 "check_cmd" in low
1886                 and "{0[state]}.mod_run_check_cmd".format(low) not in self.states
1887             ):
1888                 ret.update(self._run_check_cmd(low))
1889         except Exception as exc:  # pylint: disable=broad-except
1890             log.debug(
1891                 "An exception occurred in this state: %s",
1892                 exc,
1893                 exc_info_on_loglevel=logging.DEBUG,
1894             )
1895             trb = traceback.format_exc()
1896             name = (cdata.get("args") or [None])[0] or cdata["kwargs"].get("name")
1897             if not name:
1898                 name = low.get("name", low.get("__id__"))
1899             ret = {
1900                 "result": False,
1901                 "name": name,
1902                 "changes": {},
1903                 "comment": "An exception occurred in this state: {}".format(trb),
1904             }
1905         finally:
1906             if low.get("__prereq__"):
1907                 sys.modules[self.states[cdata["full"]].__module__].__opts__[
1908                     "test"
1909                 ] = test
1910             self.state_con.pop("runas", None)
1911             self.state_con.pop("runas_password", None)
1912         if not isinstance(ret, dict):
1913             return ret
1914         if "warnings" in cdata:
1915             ret.setdefault("warnings", []).extend(cdata["warnings"])
1916         if "provider" in low:
1917             self.load_modules()
1918         if low.get("__prereq__"):
1919             low["__prereq__"] = False
1920             return ret
1921         ret["__sls__"] = low.get("__sls__")
1922         ret["__run_num__"] = self.__run_num
1923         self.__run_num += 1
1924         format_log(ret)
1925         self.check_refresh(low, ret)
1926         utc_finish_time = datetime.datetime.utcnow()
1927         timezone_delta = datetime.datetime.utcnow() - datetime.datetime.now()
1928         local_finish_time = utc_finish_time - timezone_delta
1929         local_start_time = utc_start_time - timezone_delta
1930         ret["start_time"] = local_start_time.time().isoformat()
1931         delta = utc_finish_time - utc_start_time
1932         duration = (delta.seconds * 1000000 + delta.microseconds) / 1000.0
1933         ret["duration"] = duration
1934         ret["__id__"] = low["__id__"]
1935         log.info(
1936             "Completed state [%s] at time %s (duration_in_ms=%s)",
1937             low["name"].strip() if isinstance(low["name"], str) else low["name"],
1938             local_finish_time.time().isoformat(),
1939             duration,
1940         )
1941         if "retry" in low:
1942             low["retry"] = self.verify_retry_data(low["retry"])
1943             if not sys.modules[self.states[cdata["full"]].__module__].__opts__["test"]:
1944                 if low["retry"]["until"] != ret["result"]:
1945                     if low["retry"]["attempts"] &gt; retries:
1946                         interval = low["retry"]["interval"]
1947                         if low["retry"]["splay"] != 0:
1948                             interval = interval + random.randint(
1949                                 0, low["retry"]["splay"]
1950                             )
1951                         log.info(
1952                             "State result does not match retry until value, "
1953                             "state will be re-run in %s seconds",
1954                             interval,
1955                         )
1956                         self.functions["test.sleep"](interval)
1957                         retry_ret = self.call(low, chunks, running, retries=retries + 1)
1958                         orig_ret = ret
1959                         ret = retry_ret
1960                         ret["comment"] = "\n".join(
1961                             [
1962                                 'Attempt {}: Returned a result of "{}", '
1963                                 'with the following comment: "{}"'.format(
1964                                     retries, orig_ret["result"], orig_ret["comment"]
1965                                 ),
1966                                 "" if not ret["comment"] else ret["comment"],
1967                             ]
1968                         )
1969                         ret["duration"] = (
1970                             ret["duration"] + orig_ret["duration"] + (interval * 1000)
1971                         )
1972                         if retries == 1:
1973                             ret["start_time"] = orig_ret["start_time"]
1974             else:
1975                 ret["comment"] = "  ".join(
1976                     [
1977                         "" if not ret["comment"] else str(ret["comment"]),
1978                         "The state would be retried every {interval} seconds "
1979                         "(with a splay of up to {splay} seconds) a maximum of "
1980                         "{attempts} times or until a result of {until} "
1981                         "is returned".format(**low["retry"]),
1982                     ]
1983                 )
1984         return ret
1985     def __eval_slot(self, slot):
1986         log.debug("Evaluating slot: %s", slot)
1987         fmt = slot.split(":", 2)
1988         if len(fmt) != 3:
1989             log.warning("Malformed slot: %s", slot)
1990             return slot
1991         if fmt[1] != "salt":
1992             log.warning("Malformed slot: %s", slot)
1993             log.warning(
1994                 "Only execution modules are currently supported in slots. This means"
1995                 ' slot should start with "__slot__:salt:"'
1996             )
1997             return slot
1998         fun, args, kwargs = salt.utils.args.parse_function(fmt[2])
1999         if not fun or fun not in self.functions:
2000             log.warning("Malformed slot: %s", slot)
2001             log.warning(
2002                 "Execution module should be specified in a function call format: "
2003                 "test.arg('arg', kw='kwarg')"
2004             return slot
2005         log.debug("Calling slot: %s(%s, %s)", fun, args, kwargs)
2006         slot_return = self<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.functions[fun](*args, **kwargs)
2007         slot_text = fmt[2].split("~")[0]
2008         append_data = fmt[2].split("~", 1)[1:]
2009         log.</b></font>debug("slot_text: %s", slot_text)
2010         log.debug("append_data: %s", append_data)
2011         return_get = None
2012         try:
2013             return_get = slot_text[slot_text.rindex(")") + 1 :]
2014         except ValueError:
2015             pass
2016         if return_get:
2017             return_get = return_get.split(".", 1)[1].strip()
2018             log.debug("Searching slot result %s for %s", slot_return, return_get)
2019             slot_return = salt.utils.data.traverse_dict_and_list(
2020                 slot_return, return_get, default=None, delimiter="."
2021             )
2022         if append_data:
2023             if isinstance(slot_return, str):
2024                 append_data = " ".join(append_data).strip()
2025                 log.debug("appending to slot result: %s", append_data)
2026                 slot_return += append_data
2027             else:
2028                 log.error("Ignoring slot append, slot result is not a string")
2029         return slot_return
2030     def format_slots(self, cdata):
2031         """
2032         Read in the arguments from the low level slot syntax to make a last
2033         minute runtime call to gather relevant data for the specific routine
2034         Will parse strings, first level of dictionary values, and strings and
2035         first level dict values inside of lists
2036         """
2037         SLOT_TEXT = "__slot__:"
2038         ctx = (("args", enumerate(cdata["args"])), ("kwargs", cdata["kwargs"].items()))
2039         for atype, avalues in ctx:
2040             for ind, arg in avalues:
2041                 arg = salt.utils.data.decode(arg, keep=True)
2042                 if isinstance(arg, dict):
2043                     for key, value in arg.items():
2044                         try:
2045                             if value.startswith(SLOT_TEXT):
2046                                 log.trace("Slot processsing dict value %s", value)
2047                                 cdata[atype][ind][key] = self.__eval_slot(value)
2048                         except AttributeError:
2049                             continue
2050                 elif isinstance(arg, list):
2051                     for idx, listvalue in enumerate(arg):
2052                         log.trace("Slot processing list value: %s", listvalue)
2053                         if isinstance(listvalue, dict):
2054                             for key, value in listvalue.items():
2055                                 try:
2056                                     if value.startswith(SLOT_TEXT):
2057                                         log.trace(
2058                                             "Slot processsing nested dict value %s",
2059                                             value,
2060                                         )
2061                                         cdata[atype][ind][idx][key] = self.__eval_slot(
2062                                             value
2063                                         )
2064                                 except AttributeError:
2065                                     continue
2066                         if isinstance(listvalue, str):
2067                             if listvalue.startswith(SLOT_TEXT):
2068                                 log.trace(
2069                                     "Slot processsing nested string %s", listvalue
2070                                 )
2071                                 cdata[atype][ind][idx] = self.__eval_slot(listvalue)
2072                 elif isinstance(arg, str) and arg.startswith(SLOT_TEXT):
2073                     log.trace("Slot processsing %s", arg)
2074                     cdata[atype][ind] = self.__eval_slot(arg)
2075                 else:
2076                     continue
2077     def verify_retry_data(self, retry_data):
2078         """
2079         verifies the specified retry data
2080         """
2081         retry_defaults = {
2082             "until": True,
2083             "attempts": 2,
2084             "splay": 0,
2085             "interval": 30,
2086         }
2087         expected_data = {
2088             "until": bool,
2089             "attempts": int,
2090             "interval": int,
2091             "splay": int,
2092         }
2093         validated_retry_data = {}
2094         if isinstance(retry_data, dict):
2095             for expected_key, value_type in expected_data.items():
2096                 if expected_key in retry_data:
2097                     if isinstance(retry_data[expected_key], value_type):
2098                         validated_retry_data[expected_key] = retry_data[expected_key]
2099                     else:
2100                         log.warning(
2101                             "An invalid value was passed for the retry %s, "
2102                             "using default value '%s'",
2103                             expected_key,
2104                             retry_defaults[expected_key],
2105                         )
2106                         validated_retry_data[expected_key] = retry_defaults[
2107                             expected_key
2108                         ]
2109                 else:
2110                     validated_retry_data[expected_key] = retry_defaults[expected_key]
2111         else:
2112             log.warning(
2113                 "State is set to retry, but a valid dict for retry "
2114                 "configuration was not found.  Using retry defaults"
2115             )
2116             validated_retry_data = retry_defaults
2117         return validated_retry_data
2118     def call_chunks(self, chunks):
2119         """
2120         Iterate over a list of chunks and call them, checking for requires.
2121         """
2122         disabled = {}
2123         if "state_runs_disabled" in self.opts["grains"]:
2124             for low in chunks[:]:
2125                 state_ = "{}.{}".format(low["state"], low["fun"])
2126                 for pat in self.opts["grains"]["state_runs_disabled"]:
2127                     if fnmatch.fnmatch(state_, pat):
2128                         comment = (
2129                             'The state function "{0}" is currently disabled by "{1}", '
2130                             "to re-enable, run state.enable {1}.".format(
2131                                 state_,
2132                                 pat,
2133                             )
2134                         )
2135                         _tag = _gen_tag(low)
2136                         disabled[_tag] = {
2137                             "changes": {},
2138                             "result": False,
2139                             "comment": comment,
2140                             "__run_num__": self.__run_num,
2141                             "__sls__": low["__sls__"],
2142                         }
2143                         self.__run_num += 1
2144                         chunks.remove(low)
2145                         break
2146         running = {}
2147         for low in chunks:
2148             if "__FAILHARD__" in running:
2149                 running.pop("__FAILHARD__")
2150                 return running
2151             tag = _gen_tag(low)
2152             if tag not in running:
2153                 action = self.check_pause(low)
2154                 if action == "kill":
2155                     break
2156                 running = self.call_chunk(low, running, chunks)
2157                 if self.check_failhard(low, running):
2158                     return running
2159             self.active = set()
2160         while True:
2161             if self.reconcile_procs(running):
2162                 break
2163             time.sleep(0.01)
2164         ret = dict(list(disabled.items()) + list(running.items()))
2165         return ret
2166     def check_failhard(self, low, running):
2167         """
2168         Check if the low data chunk should send a failhard signal
2169         """
2170         tag = _gen_tag(low)
2171         if self.opts.get("test", False):
2172             return False
2173         if low.get("failhard", self.opts["failhard"]) and tag in running:
2174             if running[tag]["result"] is None:
2175                 return False
2176             return not running[tag]["result"]
2177         return False
2178     def check_pause(self, low):
2179         """
2180         Check to see if this low chunk has been paused
2181         """
2182         if not self.jid:
2183             return
2184         pause_path = os.path.join(self.opts["cachedir"], "state_pause", self.jid)
2185         start = time.time()
2186         if os.path.isfile(pause_path):
2187             try:
2188                 while True:
2189                     tries = 0
2190                     with salt.utils.files.fopen(pause_path, "rb") as fp_:
2191                         try:
2192                             pdat = msgpack_deserialize(fp_.read())
2193                         except salt.utils.msgpack.exceptions.UnpackValueError:
2194                             if tries &gt; 10:
2195                                 return
2196                             tries += 1
2197                             time.sleep(1)
2198                             continue
2199                         id_ = low["__id__"]
2200                         key = ""
2201                         if id_ in pdat:
2202                             key = id_
2203                         elif "__all__" in pdat:
2204                             key = "__all__"
2205                         if key:
2206                             if "duration" in pdat[key]:
2207                                 now = time.time()
2208                                 if now - start &gt; pdat[key]["duration"]:
2209                                     return "run"
2210                             if "kill" in pdat[key]:
2211                                 return "kill"
2212                         else:
2213                             return "run"
2214                         time.sleep(1)
2215             except Exception as exc:  # pylint: disable=broad-except
2216                 log.error(
2217                     "Failed to read in pause data for file located at: %s", pause_path
2218                 )
2219                 return "run"
2220         return "run"
2221     def reconcile_procs(self, running):
2222         """
2223         Check the running dict for processes and resolve them
2224         """
2225         retset = set()
2226         for tag in running:
2227             proc = running[tag].get("proc")
2228             if proc:
2229                 if not proc.is_alive():
2230                     ret_cache = os.path.join(
2231                         self.opts["cachedir"],
2232                         self.jid,
2233                         salt.utils.hashutils.sha1_digest(tag),
2234                     )
2235                     if not os.path.isfile(ret_cache):
2236                         ret = {
2237                             "result": False,
2238                             "comment": "Parallel process failed to return",
2239                             "name": running[tag]["name"],
2240                             "changes": {},
2241                         }
2242                     try:
2243                         with salt.utils.files.fopen(ret_cache, "rb") as fp_:
2244                             ret = msgpack_deserialize(fp_.read())
2245                     except OSError:
2246                         ret = {
2247                             "result": False,
2248                             "comment": "Parallel cache failure",
2249                             "name": running[tag]["name"],
2250                             "changes": {},
2251                         }
2252                     running[tag].update(ret)
2253                     running[tag].pop("proc")
2254                 else:
2255                     retset.add(False)
2256         return False not in retset
2257     def check_requisite(self, low, running, chunks, pre=False):
2258         """
2259         Look into the running data to check the status of all requisite
2260         states
2261         """
2262         disabled_reqs = self.opts.get("disabled_requisites", [])
2263         if not isinstance(disabled_reqs, list):
2264             disabled_reqs = [disabled_reqs]
2265         present = False
2266         if "watch" in low:
2267             if "{}.mod_watch".format(low["state"]) not in self.states:
2268                 if "require" in low:
2269                     low["require"].extend(low.pop("watch"))
2270                 else:
2271                     low["require"] = low.pop("watch")
2272             else:
2273                 present = True
2274         if "watch_any" in low:
2275             if "{}.mod_watch".format(low["state"]) not in self.states:
2276                 if "require_any" in low:
2277                     low["require_any"].extend(low.pop("watch_any"))
2278                 else:
2279                     low["require_any"] = low.pop("watch_any")
2280             else:
2281                 present = True
2282         if "require" in low:
2283             present = True
2284         if "require_any" in low:
2285             present = True
2286         if "prerequired" in low:
2287             present = True
2288         if "prereq" in low:
2289             present = True
2290         if "onfail" in low:
2291             present = True
2292         if "onfail_any" in low:
2293             present = True
2294         if "onfail_all" in low:
2295             present = True
2296         if "onchanges" in low:
2297             present = True
2298         if "onchanges_any" in low:
2299             present = True
2300         if not present:
2301             return "met", ()
2302         self.reconcile_procs(running)
2303         reqs = {
2304             "require": [],
2305             "require_any": [],
2306             "watch": [],
2307             "watch_any": [],
2308             "prereq": [],
2309             "onfail": [],
2310             "onfail_any": [],
2311             "onfail_all": [],
2312             "onchanges": [],
2313             "onchanges_any": [],
2314         }
2315         if pre:
2316             reqs["prerequired"] = []
2317         for r_state in reqs:
2318             if r_state in low and low[r_state] is not None:
2319                 if r_state in disabled_reqs:
2320                     log.warning(
2321                         "The %s requisite has been disabled, Ignoring.", r_state
2322                     )
2323                     continue
2324                 for req in low[r_state]:
2325                     if isinstance(req, str):
2326                         req = {"id": req}
2327                     req = trim_req(req)
2328                     found = False
2329                     for chunk in chunks:
2330                         req_key = next(iter(req))
2331                         req_val = req[req_key]
2332                         if req_val is None:
2333                             continue
2334                         if req_key == "sls":
2335                             if fnmatch.fnmatch(chunk["__sls__"], req_val):
2336                                 found = True
2337                                 reqs[r_state].append(chunk)
2338                             continue
2339                         try:
2340                             if isinstance(req_val, str):
2341                                 if fnmatch.fnmatch(
2342                                     chunk["name"], req_val
2343                                 ) or fnmatch.fnmatch(chunk["__id__"], req_val):
2344                                     if req_key == "id" or chunk["state"] == req_key:
2345                                         found = True
2346                                         reqs[r_state].append(chunk)
2347                             else:
2348                                 raise KeyError
2349                         except KeyError as exc:
2350                             raise SaltRenderError(
2351                                 "Could not locate requisite of [{}] present in state"
2352                                 " with name [{}]".format(req_key, chunk["name"])
2353                             )
2354                         except TypeError:
2355                             raise SaltRenderError(
2356                                 "Could not locate requisite of [{}] present in state"
2357                                 " with name [{}]".format(req_key, chunk["name"])
2358                             )
2359                     if not found:
2360                         return "unmet", ()
2361         fun_stats = set()
2362         for r_state, chunks in reqs.items():
2363             req_stats = set()
2364             if r_state.startswith("prereq") and not r_state.startswith("prerequired"):
2365                 run_dict = self.pre
2366             else:
2367                 run_dict = running
2368             filtered_run_dict = {}
2369             for chunk in chunks:
2370                 tag = _gen_tag(chunk)
2371                 run_dict_chunk = run_dict.get(tag)
2372                 if run_dict_chunk:
2373                     filtered_run_dict[tag] = run_dict_chunk
2374             run_dict = filtered_run_dict
2375             while True:
2376                 if self.reconcile_procs(run_dict):
2377                     break
2378                 time.sleep(0.01)
2379             for chunk in chunks:
2380                 tag = _gen_tag(chunk)
2381                 if tag not in run_dict:
2382                     req_stats.add("unmet")
2383                     continue
2384                 if r_state.startswith("onfail"):
2385                     if run_dict[tag]["result"] is True:
2386                         req_stats.add("onfail")  # At least one state is OK
2387                         continue
2388                 else:
2389                     if run_dict[tag]["result"] is False:
2390                         req_stats.add("fail")
2391                         continue
2392                 if r_state.startswith("onchanges"):
2393                     if not run_dict[tag]["changes"]:
2394                         req_stats.add("onchanges")
2395                     else:
2396                         req_stats.add("onchangesmet")
2397                     continue
2398                 if r_state.startswith("watch") and run_dict[tag]["changes"]:
2399                     req_stats.add("change")
2400                     continue
2401                 if r_state.startswith("prereq") and run_dict[tag]["result"] is None:
2402                     if not r_state.startswith("prerequired"):
2403                         req_stats.add("premet")
2404                 if r_state.startswith("prereq") and not run_dict[tag]["result"] is None:
2405                     if not r_state.startswith("prerequired"):
2406                         req_stats.add("pre")
2407                 else:
2408                     if run_dict[tag].get("__state_ran__", True):
2409                         req_stats.add("met")
2410             if r_state.endswith("_any") or r_state == "onfail":
2411                 if "met" in req_stats or "change" in req_stats:
2412                     if "fail" in req_stats:
2413                         req_stats.remove("fail")
2414                 if "onchangesmet" in req_stats:
2415                     if "onchanges" in req_stats:
2416                         req_stats.remove("onchanges")
2417                     if "fail" in req_stats:
2418                         req_stats.remove("fail")
2419                 if "onfail" in req_stats:
2420                     if "met" in req_stats:
2421                         req_stats.remove("onfail")
2422             if r_state.endswith("_all"):
2423                 if "onfail" in req_stats:
2424                     if "met" in req_stats:
2425                         req_stats.remove("met")
2426             fun_stats.update(req_stats)
2427         if "unmet" in fun_stats:
2428             status = "unmet"
2429         elif "fail" in fun_stats:
2430             status = "fail"
2431         elif "pre" in fun_stats:
2432             if "premet" in fun_stats:
2433                 status = "met"
2434             else:
2435                 status = "pre"
2436         elif "onfail" in fun_stats and "onchangesmet" not in fun_stats:
2437             status = "onfail"
2438         elif "onchanges" in fun_stats and "onchangesmet" not in fun_stats:
2439             status = "onchanges"
2440         elif "change" in fun_stats:
2441             status = "change"
2442         elif "onfail" in fun_stats:
2443             status = "onfail"
2444         else:
2445             status = "met"
2446         return status, reqs
2447     def event(self, chunk_ret, length, fire_event=False):
2448         """
2449         Fire an event on the master bus
2450         If `fire_event` is set to True an event will be sent with the
2451         chunk name in the tag and the chunk result in the event data.
2452         If `fire_event` is set to a string such as `mystate/is/finished`,
2453         an event will be sent with the string added to the tag and the chunk
2454         result in the event data.
2455         If the `state_events` is set to True in the config, then after the
2456         chunk is evaluated an event will be set up to the master with the
2457         results.
2458         """
2459         if not self.opts.get("local") and (
2460             self.opts.get("state_events", True) or fire_event
2461         ):
2462             if not self.opts.get("master_uri"):
2463                 ev_func = (
2464                     lambda ret, tag, preload=None: salt.utils.event.get_master_event(
2465                         self.opts, self.opts["sock_dir"], listen=False
2466                     ).fire_event(ret, tag)
2467                 )
2468             else:
2469                 ev_func = self.functions["event.fire_master"]
2470             ret = {"ret": chunk_ret}
2471             if fire_event is True:
2472                 tag = salt.utils.event.tagify(
2473                     [self.jid, self.opts["id"], str(chunk_ret["name"])],
2474                     "state_result",
2475                 )
2476             elif isinstance(fire_event, str):
2477                 tag = salt.utils.event.tagify(
2478                     [self.jid, self.opts["id"], str(fire_event)],
2479                     "state_result",
2480                 )
2481             else:
2482                 tag = salt.utils.event.tagify(
2483                     [self.jid, "prog", self.opts["id"], str(chunk_ret["__run_num__"])],
2484                     "job",
2485                 )
2486                 ret["len"] = length
2487             preload = {"jid": self.jid}
2488             ev_func(ret, tag, preload=preload)
2489     def call_chunk(self, low, running, chunks):
2490         """
2491         Check if a chunk has any requires, execute the requires and then
2492         the chunk
2493         """
2494         low = self._mod_aggregate(low, running, chunks)
2495         self._mod_init(low)
2496         tag = _gen_tag(low)
2497         if not low.get("prerequired"):
2498             self.active.add(tag)
2499         requisites = [
2500             "require",
2501             "require_any",
2502             "watch",
2503             "watch_any",
2504             "prereq",
2505             "onfail",
2506             "onfail_any",
2507             "onchanges",
2508             "onchanges_any",
2509         ]
2510         if not low.get("__prereq__"):
2511             requisites.append("prerequired")
2512             status, reqs = self.check_requisite(low, running, chunks, pre=True)
2513         else:
2514             status, reqs = self.check_requisite(low, running, chunks)
2515         if status == "unmet":
2516             lost = {}
2517             reqs = []
2518             for requisite in requisites:
2519                 lost[requisite] = []
2520                 if requisite not in low:
2521                     continue
2522                 for req in low[requisite]:
2523                     if isinstance(req, str):
2524                         req = {"id": req}
2525                     req = trim_req(req)
2526                     found = False
2527                     req_key = next(iter(req))
2528                     req_val = req[req_key]
2529                     for chunk in chunks:
2530                         if req_val is None:
2531                             continue
2532                         if req_key == "sls":
2533                             if fnmatch.fnmatch(chunk["__sls__"], req_val):
2534                                 if requisite == "prereq":
2535                                     chunk["__prereq__"] = True
2536                                 reqs.append(chunk)
2537                                 found = True
2538                             continue
2539                         if fnmatch.fnmatch(chunk["name"], req_val) or fnmatch.fnmatch(
2540                             chunk["__id__"], req_val
2541                         ):
2542                             if req_key == "id" or chunk["state"] == req_key:
2543                                 if requisite == "prereq":
2544                                     chunk["__prereq__"] = True
2545                                 elif requisite == "prerequired":
2546                                     chunk["__prerequired__"] = True
2547                                 reqs.append(chunk)
2548                     if not found:
2549                         lost[requisite].append(req)
2550             <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>if (
2551                 lost["require"]
2552                 or lost["watch"]
2553                 or lost["prereq"]
2554                 or lost["onfail"]
2555                 or lost["onchanges"]
2556                 or lost["require_any"]
2557                 or lost["watch_any"]
2558                 or lost["onfail_any"]
2559                 or lost["onchanges_any"]
2560                 or lost.get(</b></font>"prerequired")
2561             ):
2562                 comment = "The following requisites were not found:\n"
2563                 for requisite, lreqs in lost.items():
2564                     if not lreqs:
2565                         continue
2566                     comment += "{}{}:\n".format(" " * 19, requisite)
2567                     for lreq in lreqs:
2568                         req_key = next(iter(lreq))
2569                         req_val = lreq[req_key]
2570                         comment += "{}{}: {}\n".format(" " * 23, req_key, req_val)
2571                 if low.get("__prereq__"):
2572                     run_dict = self.pre
2573                 else:
2574                     run_dict = running
2575                 start_time, duration = _calculate_fake_duration()
2576                 run_dict[tag] = {
2577                     "changes": {},
2578                     "result": False,
2579                     "duration": duration,
2580                     "start_time": start_time,
2581                     "comment": comment,
2582                     "__run_num__": self.__run_num,
2583                     "__sls__": low["__sls__"],
2584                 }
2585                 self.__run_num += 1
2586                 self.event(run_dict[tag], len(chunks), fire_event=low.get("fire_event"))
2587                 return running
2588             for chunk in reqs:
2589                 ctag = _gen_tag(chunk)
2590                 if ctag not in running:
2591                     if ctag in self.active:
2592                         if chunk.get("__prerequired__"):
2593                             if tag not in self.pre:
2594                                 low["__prereq__"] = True
2595                                 self.pre[ctag] = self.call(low, chunks, running)
2596                                 return running
2597                             else:
2598                                 return running
2599                         elif ctag not in running:
2600                             log.error("Recursive requisite found")
2601                             running[tag] = {
2602                                 "changes": {},
2603                                 "result": False,
2604                                 "comment": "Recursive requisite found",
2605                                 "__run_num__": self.__run_num,
2606                                 "__sls__": low["__sls__"],
2607                             }
2608                         self.__run_num += 1
2609                         self.event(
2610                             running[tag], len(chunks), fire_event=low.get("fire_event")
2611                         )
2612                         return running
2613                     running = self.call_chunk(chunk, running, chunks)
2614                     if self.check_failhard(chunk, running):
2615                         running["__FAILHARD__"] = True
2616                         return running
2617             if low.get("__prereq__"):
2618                 status, reqs = self.check_requisite(low, running, chunks)
2619                 self.pre[tag] = self.call(low, chunks, running)
2620                 if not self.pre[tag]["changes"] and status == "change":
2621                     self.pre[tag]["changes"] = {"watch": "watch"}
2622                     self.pre[tag]["result"] = None
2623             else:
2624                 running = self.call_chunk(low, running, chunks)
2625             if self.check_failhard(chunk, running):
2626                 running["__FAILHARD__"] = True
2627                 return running
2628         elif status == "met":
2629             if low.get("__prereq__"):
2630                 self.pre[tag] = self.call(low, chunks, running)
2631             else:
2632                 running[tag] = self.call(low, chunks, running)
2633             if tag in self<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.pre:
2634                 running[tag] = self.pre[tag]
2635                 running[tag]["__run_num__"] = self.__run_num
2636                 running[tag]["__sls__"] = low[</b></font>"__sls__"]
2637             else:
2638                 failed_requisites = set()
2639                 for req_lows in reqs.values():
2640                     for req_low in req_lows:
2641                         req_tag = _gen_tag(req_low)
2642                         req_ret = self.pre.get(req_tag, running.get(req_tag))
2643                         if req_ret is None:
2644                             continue
2645                         if req_ret["result"] is False:
2646                             key = "{sls}.{_id}".format(
2647                                 sls=req_low["__sls__"], _id=req_low["__id__"]
2648                             )
2649                             failed_requisites.add(key)
2650                 _cmt = "One or more requisite failed: {}".format(
2651                     ", ".join(str(i) for i in failed_requisites)
2652                 )
2653                 start_time, duration = _calculate_fake_duration()
2654                 running[tag] = {
2655                     "changes": {},
2656                     "result": False,
2657                     "duration": duration,
2658                     "start_time": start_time,
2659                     "comment": _cmt,
2660                     "__run_num__": self.__run_num,
2661                     "__sls__": low["__sls__"],
2662                 }
2663                 self.pre[tag] = running[tag]
2664             self.__run_num += 1
2665         elif status == "change" and not low.get("__prereq__"):
2666             ret = self.call(low, chunks, running)
2667             if not ret["changes"] and not ret.get("skip_watch", False):
2668                 low = low.copy()
2669                 low["sfun"] = low["fun"]
2670                 low["fun"] = "mod_watch"
2671                 low["__reqs__"] = reqs
2672                 ret = self.call(low, chunks, running)
2673             running[tag] = ret
2674         elif status == "pre":
2675             start_time, duration = _calculate_fake_duration()
2676             pre_ret = {
2677                 "changes": {},
2678                 "result": True,
2679                 "duration": duration,
2680                 "start_time": start_time,
2681                 "comment": "No changes detected",
2682                 "__run_num__": self.__run_num,
2683                 "__sls__": low["__sls__"],
2684             }
2685             running[tag] = pre_ret
2686             self.pre[tag] = pre_ret
2687             self.__run_num += 1
2688         elif status == "onfail":
2689             start_time, duration = _calculate_fake_duration()
2690             running[tag] = {
2691                 "changes": {},
2692                 "result": True,
2693                 "duration": duration,
2694                 "start_time": start_time,
2695                 "comment": "State was not run because onfail req did not change",
2696                 "__state_ran__": False,
2697                 "__run_num__": self.__run_num,
2698                 "__sls__": low["__sls__"],
2699             }
2700             self.__run_num += 1
2701         elif status == "onchanges":
2702             start_time, duration = _calculate_fake_duration()
2703             running[tag] = {
2704                 "changes": {},
2705                 "result": True,
2706                 "duration": duration,
2707                 "start_time": start_time,
2708                 "comment": (
2709                     "State was not run because none of the onchanges reqs changed"
2710                 ),
2711                 "__state_ran__": False,
2712                 "__run_num__": self.__run_num,
2713                 "__sls__": low["__sls__"],
2714             }
2715             self.__run_num += 1
2716         else:
2717             if low.get("__prereq__"):
2718                 self.pre[tag] = self.call(low, chunks, running)
2719             else:
2720                 running[tag] = self.call(low, chunks, running)
2721         if tag in running:
2722             self.event(running[tag], len(chunks), fire_event=low.get("fire_event"))
2723             for sub_state_data in running[tag].pop("sub_state_run", ()):
2724                 start_time, duration = _calculate_fake_duration()
2725                 self.__run_num += 1
2726                 sub_tag = _gen_tag(sub_state_data["low"])
2727                 running[sub_tag] = {
2728                     "name": sub_state_data["low"]["name"],
2729                     "changes": sub_state_data["changes"],
2730                     "result": sub_state_data["result"],
2731                     "duration": sub_state_data.get("duration", duration),
2732                     "start_time": sub_state_data.get("start_time", start_time),
2733                     "comment": sub_state_data.get("comment", ""),
2734                     "__state_ran__": True,
2735                     "__run_num__": self.__run_num,
2736                     "__sls__": low["__sls__"],
2737                 }
2738         return running
2739     def call_beacons(self, chunks, running):
2740         """
2741         Find all of the beacon routines and call the associated mod_beacon runs
2742         """
2743         listeners = []
2744         crefs = {}
2745         beacons = []
2746         for chunk in chunks:
2747             if "beacon" in chunk:
2748                 beacons.append(chunk)
2749         mod_beacons = []
2750         errors = {}
2751         for chunk in beacons:
2752             low = chunk.copy()
2753             low["sfun"] = chunk["fun"]
2754             low["fun"] = "mod_beacon"
2755             low["__id__"] = "beacon_{}".format(low["__id__"])
2756             mod_beacons.append(low)
2757         ret = self.call_chunks(mod_beacons)
2758         running.update(ret)
2759         for err in errors:
2760             errors[err]["__run_num__"] = self.__run_num
2761             self.__run_num += 1
2762         running.update(errors)
2763         return running
2764     def call_listen(self, chunks, running):
2765         """
2766         Find all of the listen routines and call the associated mod_watch runs
2767         """
2768         listeners = []
2769         crefs = {}
2770         for chunk in chunks:
2771             crefs[(chunk["state"], chunk["__id__"], chunk["name"])] = chunk
2772             if "listen" in chunk:
2773                 listeners.append(
2774                     {(chunk["state"], chunk["__id__"], chunk["name"]): chunk["listen"]}
2775                 )
2776             if "listen_in" in chunk:
2777                 for l_in in chunk["listen_in"]:
2778                     for key, val in l_in.items():
2779                         listeners.append(
2780                             {(key, val, "lookup"): [{chunk["state"]: chunk["__id__"]}]}
2781                         )
2782         mod_watchers = []
2783         errors = {}
2784         for l_dict in listeners:
2785             for key, val in l_dict.items():
2786                 for listen_to in val:
2787                     if not isinstance(listen_to, dict):
2788                         found = False
2789                         for chunk in chunks:
2790                             if (
2791                                 chunk["__id__"] == listen_to
2792                                 or chunk["name"] == listen_to
2793                             ):
2794                                 listen_to = {chunk["state"]: chunk["__id__"]}
2795                                 found = True
2796                         if not found:
2797                             continue
2798                     for lkey, lval in listen_to.items():
2799                         if not any(lkey == cref[0] and lval in cref for cref in crefs):
2800                             rerror = {
2801                                 _l_tag(lkey, lval): {
2802                                     "comment": (
2803                                         "Referenced state {}: {} does not exist".format(
2804                                             lkey, lval
2805                                         )
2806                                     ),
2807                                     "name": "listen_{}:{}".format(lkey, lval),
2808                                     "result": False,
2809                                     "changes": {},
2810                                 }
2811                             }
2812                             errors.update(rerror)
2813                             continue
2814                         to_tags = [
2815                             _gen_tag(data)
2816                             for cref, data in crefs.items()
2817                             if lkey == cref[0] and lval in cref
2818                         ]
2819                         for to_tag in to_tags:
2820                             if to_tag not in running:
2821                                 continue
2822                             if running[to_tag]["changes"]:
2823                                 if not any(
2824                                     key[0] == cref[0] and key[1] in cref
2825                                     for cref in crefs
2826                                 ):
2827                                     rerror = {
2828                                         _l_tag(key[0], key[1]): {
2829                                             "comment": (
2830                                                 "Referenced state {}: {} does not exist".format(
2831                                                     key[0], key[1]
2832                                                 )
2833                                             ),
2834                                             "name": "listen_{}:{}".format(
2835                                                 key[0], key[1]
2836                                             ),
2837                                             "result": False,
2838                                             "changes": {},
2839                                         }
2840                                     }
2841                                     errors.update(rerror)
2842                                     continue
2843                                 new_chunks = [
2844                                     data
2845                                     for cref, data in crefs.items()
2846                                     if key[0] == cref[0] and key[1] in cref
2847                                 ]
2848                                 for chunk in new_chunks:
2849                                     low = chunk.copy()
2850                                     low["sfun"] = chunk["fun"]
2851                                     low["fun"] = "mod_watch"
2852                                     low["__id__"] = "listener_{}".format(low["__id__"])
2853                                     for req in STATE_REQUISITE_KEYWORDS:
2854                                         if req in low:
2855                                             low.pop(req)
2856                                     mod_watchers.append(low)
2857         ret = self.call_chunks(mod_watchers)
2858         running.update(ret)
2859         for err in errors:
2860             errors[err]["__run_num__"] = self.__run_num
2861             self.__run_num += 1
2862         running.update(errors)
2863         return running
2864     def call_high(self, high, orchestration_jid=None):
2865         """
2866         Process a high data call and ensure the defined states.
2867         """
2868         errors = []
2869         high, ext_errors = self.reconcile_extend(high)
2870         errors.extend(ext_errors)
2871         errors.extend(self.verify_high(high))
2872         if errors:
2873             return errors
2874         high, req_in_errors = self.requisite_in(high)
2875         errors.extend(req_in_errors)
2876         high = self.apply_exclude(high)
2877         if errors:
2878             return errors
2879         chunks = self.compile_high_data(high, orchestration_jid)
2880         if errors:
2881             return errors
2882         ret = self.call_chunks(chunks)
2883         ret = self.call_listen(chunks, ret)
2884         ret = self.call_beacons(chunks, ret)
2885         def _cleanup_accumulator_data():
2886             accum_data_path = os.path.join(
2887                 get_accumulator_dir(self.opts["cachedir"]), self.instance_id
2888             )
2889             try:
2890                 os.remove(accum_data_path)
2891                 log.debug("Deleted accumulator data file %s", accum_data_path)
2892             except OSError:
2893                 log.debug("File %s does not exist, no need to cleanup", accum_data_path)
2894         _cleanup_accumulator_data()
2895         if self.jid is not None:
2896             pause_path = os.path.join(self.opts["cachedir"], "state_pause", self.jid)
2897             if os.path.isfile(pause_path):
2898                 try:
2899                     os.remove(pause_path)
2900                 except OSError:
2901                     pass
2902         return ret
2903     def render_template(self, high, template):
2904         errors = []
2905         if not high:
2906             return high, errors
2907         if not isinstance(high, dict):
2908             errors.append(
2909                 "Template {} does not render to a dictionary".format(template)
2910             )
2911             return high, errors
2912         invalid_items = ("include", "exclude", "extends")
2913         for item in invalid_items:
2914             if item in high:
2915                 errors.append(
2916                     "The '{}' declaration found on '{}' is invalid when "
2917                     "rendering single templates".format(item, template)
2918                 )
2919                 return high, errors
2920         for name in high:
2921             if not isinstance(high[name], dict):
2922                 if isinstance(high[name], str):
2923                     if "." in high[name]:
2924                         comps = high[name].split(".")
2925                         high[name] = {
2926                             comps[0]: [comps[1]]
2927                         }
2928                         continue
2929                     errors.append(
2930                         "ID {} in template {} is not a dictionary".format(
2931                             name, template
2932                         )
2933                     )
2934                     continue
2935             skeys = set()
2936             for key in sorted(high[name]):
2937                 if key.startswith("_"):
2938                     continue
2939                 if high[name][key] is None:
2940                     errors.append(
2941                         "ID '{}' in template {} contains a short "
2942                         "declaration ({}) with a trailing colon. When not "
2943                         "passing any arguments to a state, the colon must be "
2944                         "omitted.".format(name, template, key)
2945                     )
2946                     continue
2947                 if not isinstance(high[name][key], list):
2948                     continue
2949                 if "." in key:
2950                     comps = key.split(".")
2951                     if comps[0] in skeys:
2952                         errors.append(
2953                             "ID '{}' in template '{}' contains multiple "
2954                             "state declarations of the same type".format(name, template)
2955                         )
2956                         continue
2957                     high[name][comps[0]] = high[name].pop(key)
2958                     high[name][comps[0]].append(comps[1])
2959                     skeys.add(comps[0])
2960                     continue
2961                 skeys.add(key)
2962         return high, errors
2963     def call_template(self, template):
2964         """
2965         Enforce the states in a template
2966         """
2967         high = compile_template(
2968             template,
2969             self.rend,
2970             self.opts["renderer"],
2971             self.opts["renderer_blacklist"],
2972             self.opts["renderer_whitelist"],
2973         )
2974         if not high:
2975             return high
2976         high, errors = self.render_template(high, template)
2977         if errors:
2978             return errors
2979         return self.call_high(high)
2980     def call_template_str(self, template):
2981         """
2982         Enforce the states in a template, pass the template as a string
2983         """
2984         high = compile_template_str(
2985             template,
2986             self.rend,
2987             self.opts["renderer"],
2988             self.opts["renderer_blacklist"],
2989             self.opts["renderer_whitelist"],
2990         )
2991         if not high:
2992             return high
2993         high, errors = self.render_template(high, "&lt;template-str&gt;")
2994         if errors:
2995             return errors
2996         return self.call_high(high)
2997 class LazyAvailStates:
2998     """
2999     The LazyAvailStates lazily loads the list of states of available
3000     environments.
3001     This is particularly usefull when top_file_merging_strategy=same and there
3002     are many environments.
3003     """
3004     def __init__(self, hs):
3005         self._hs = hs
3006         self._avail = {"base": None}
3007         self._filled = False
3008     def _fill(self):
3009         if self._filled:
3010             return
3011         for saltenv in self._hs._get_envs():
3012             if saltenv not in self._avail:
3013                 self._avail[saltenv] = None
3014         self._filled = True
3015     def __contains__(self, saltenv):
3016         if saltenv == "base":
3017             return True
3018         self._fill()
3019         return saltenv in self._avail
3020     def __getitem__(self, saltenv):
3021         if saltenv != "base":
3022             self._fill()
3023         if saltenv not in self._avail or self._avail[saltenv] is None:
3024             self._avail[saltenv] = self._hs.client.list_states(saltenv)
3025         return self._avail[saltenv]
3026     def items(self):
3027         self._fill()
3028         ret = []
3029         for saltenv, states in self._avail.items():
3030             ret.append((saltenv, self.__getitem__(saltenv)))
3031         return ret
3032 class BaseHighState:
3033     """
3034     The BaseHighState is an abstract base class that is the foundation of
3035     running a highstate, extend it and add a self.state object of type State.
3036     When extending this class, please note that ``self.client`` and
3037     ``self.matcher`` should be instantiated and handled.
3038     """
3039     def __init__(self, opts):
3040         self.opts = self.__gen_opts(opts)
3041         self.iorder = 10000
3042         self.avail = self.__gather_avail()
3043         self.building_highstate = OrderedDict()
3044     def __gather_avail(self):
3045         """
3046         Lazily gather the lists of available sls data from the master
3047         """
3048         return LazyAvailStates(self)
3049     def __gen_opts(self, opts):
3050         """
3051         The options used by the High State object are derived from options
3052         on the minion and the master, or just the minion if the high state
3053         call is entirely local.
3054         """
3055         if "local_state" in opts:
3056             if opts["local_state"]:
3057                 return opts
3058         mopts = self.client.master_opts()
3059         if not isinstance(mopts, dict):
3060             opts["renderer"] = "jinja|yaml"
3061             opts["failhard"] = False
3062             opts["state_top"] = salt.utils.url<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.create("top.sls")
3063             opts["nodegroups"] = {}
3064             opts["file_roots"] = {"base": [syspaths.BASE_FILE_ROOTS_DIR]}
3065         else:
3066             opts["renderer"] = mopts["renderer"]
3067             if mopts["state_top"].startswith("salt://"):
3068                 opts["state_top"] = mopts["state_top"]
3069             elif mopts<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["state_top"].startswith("/"):
3070                 opts["state_top"] = salt.utils.url.create(mopts["state_top"][1:])
3071             else:
3072                 opts["state_top"] = salt.utils.</b></font>url.create(mopts["state_top"])
3073             opts["state_top_saltenv"] = mopts.get("state_top_saltenv", None)
3074             opts["nodegroups"] = mopts.get("nodegroups", {})
3075             opts["state_auto_order"] = mopts.get(
3076                 "state_auto_order", opts["state_auto_order"]
3077             )
3078             opts["file_roots"] = mopts["file_roots"]
3079             opts["top_file_merging_strategy"] = mopts.get(
3080                 "top_file_merging_strategy", opts.get("top_file_merging_strategy")
3081             )
3082             opts["env_order"] = mopts.get("env_order", opts.get("env_order", []))
3083             opts["default_top"] = mopts.get("default_top", opts.get("default_top"))
3084             opts["state_events"] = mopts.get("state_events")
3085             opts["state_aggregate"] = (
3086                 opts.get("state_aggregate") or mopts.get("state_aggregate") or False
3087             )
3088             opts["jinja_env"] = mopts.get("jinja_env", {})
3089             opts["jinja_sls_env"] = mopts.get("jinja_sls_env", {})
3090             opts["jinja_lstrip_blocks"] = mopts.get("jinja_lstrip_blocks", False)
3091             opts["jinja_trim_blocks"] = mopts.get("jinja_trim_blocks", False)
3092         return opts
3093     def _get_envs(self):
3094         """
3095         Pull the file server environments out of the master options
3096         """
3097         envs = ["base"]
3098         if "file_roots" in self.opts:
3099             envs.extend([x for x in list(self.opts["file_roots"]) if x not in envs])
3100         env_order = self.opts.get("env_order", [])
3101         members = set()
3102         env_order = [
3103             env for env in env_order if not (env in members or members.add(env))
3104         ]
3105         client_envs = self.client.envs()
3106         if env_order and client_envs:
3107             return [env for env in env_order if env in client_envs]
3108         elif env_order:
3109             return env_order
3110         else:
3111             envs.extend([env for env in client_envs if env not in envs])
3112             return envs
3113     def get_tops(self):
3114         """
3115         Gather the top files
3116         """
3117         tops = DefaultOrderedDict(list)
3118         include = DefaultOrderedDict(list)
3119         done = DefaultOrderedDict(list)
3120         found = 0  # did we find any contents in the top files?
3121         merging_strategy = self.opts["top_file_merging_strategy"]
3122         if merging_strategy == "same" and not self.opts["saltenv"]:
3123             if not self.opts["default_top"]:
3124                 raise SaltRenderError(
3125                     "top_file_merging_strategy set to 'same', but no "
3126                     "default_top configuration option was set"
3127                 )
3128         if self.opts["saltenv"]:
3129             contents = self.client.cache_file(
3130                 self.opts["state_top"], self.opts["saltenv"]
3131             )
3132             if contents:
3133                 found = 1
3134                 tops[self.opts["saltenv"]] = [
3135                     compile_template(
3136                         contents,
3137                         self.state.rend,
3138                         self.state.opts["renderer"],
3139                         self.state.opts["renderer_blacklist"],
3140                         self.state.opts["renderer_whitelist"],
3141                         saltenv=self.opts["saltenv"],
3142                     )
3143                 ]
3144             else:
3145                 tops[self.opts["saltenv"]] = [{}]
3146         else:
3147             found = 0
3148             state_top_saltenv = self.opts.get("state_top_saltenv", False)
3149             if state_top_saltenv and not isinstance(state_top_saltenv, str):
3150                 state_top_saltenv = str(state_top_saltenv)
3151             for saltenv in (
3152                 [state_top_saltenv] if state_top_saltenv else self._get_envs()
3153             ):
3154                 contents = self.client.cache_file(self.opts["state_top"], saltenv)
3155                 if contents:
3156                     found = found + 1
3157                     tops[saltenv].append(
3158                             contents,
3159                             self.state.rend,
3160                             self.state.opts<font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["renderer"],
3161                             self.state.opts["renderer_blacklist"],
3162                             self.state.opts["renderer_whitelist"],
3163                             saltenv=saltenv,
3164                         )
3165                     )
3166                 else:
3167                     tops[saltenv].append({})
3168                     log.</b></font>debug("No contents loaded for saltenv '%s'", saltenv)
3169             if (
3170                 found &gt; 1
3171                 and merging_strategy == "merge"
3172                 and not self.opts.get("env_order", None)
3173             ):
3174                 log.warning(
3175                     "top_file_merging_strategy is set to '%s' and "
3176                     "multiple top files were found. Merging order is not "
3177                     "deterministic, it may be desirable to either set "
3178                     "top_file_merging_strategy to 'same' or use the "
3179                     "'env_order' configuration parameter to specify the "
3180                     "merging order.",
3181                     merging_strategy,
3182                 )
3183         if found == 0:
3184             log.debug(
3185                 "No contents found in top file. If this is not expected, "
3186                 "verify that the 'file_roots' specified in 'etc/master' "
3187                 "are accessible. The 'file_roots' configuration is: %s",
3188                 repr(self.state.opts["file_roots"]),
3189             )
3190         for saltenv, ctops in tops.items():
3191             for ctop in ctops:
3192                 if "include" not in ctop:
3193                     continue
3194                 for sls in ctop["include"]:
3195                     include[saltenv].append(sls)
3196                 ctop.pop("include")
3197         while include:
3198             pops = []
3199             for saltenv, states in include.items():
3200                 pops.append(saltenv)
3201                 if not states:
3202                     continue
3203                 for sls_match in states:
3204                     for sls in fnmatch.filter(self.avail[saltenv], sls_match):
3205                         if sls in done[saltenv]:
3206                             continue
3207                         tops[saltenv].append(
3208                             compile_template(
3209                                 self.client.get_state(sls, saltenv).get("dest", False),
3210                                 self.state.rend,
3211                                 self.state.opts["renderer"],
3212                                 self.state.opts["renderer_blacklist"],
3213                                 self.state.opts["renderer_whitelist"],
3214                                 saltenv,
3215                             )
3216                         )
3217                         done[saltenv].append(sls)
3218             for saltenv in pops:
3219                 if saltenv in include:
3220                     include.pop(saltenv)
3221         return tops
3222     def merge_tops(self, tops):
3223         """
3224         Cleanly merge the top files
3225         """
3226         merging_strategy = self.opts["top_file_merging_strategy"]
3227         try:
3228             merge_attr = "_merge_tops_{}".format(merging_strategy)
3229             merge_func = getattr(self, merge_attr)
3230             if not hasattr(merge_func, "__call__"):
3231                 msg = "'{}' is not callable".format(merge_attr)
3232                 log.error(msg)
3233                 raise TypeError(msg)
3234         except (AttributeError, TypeError):
3235             log.warning(
3236                 "Invalid top_file_merging_strategy '%s', falling back to 'merge'",
3237                 merging_strategy,
3238             )
3239             merge_func = self._merge_tops_merge
3240         return merge_func(tops)
3241     def _merge_tops_merge(self, tops):
3242         """
3243         The default merging strategy. The base env is authoritative, so it is
3244         checked first, followed by the remaining environments. In top files
3245         from environments other than "base", only the section matching the
3246         environment from the top file will be considered, and it too will be
3247         ignored if that environment was defined in the "base" top file.
3248         """
3249         top = DefaultOrderedDict(OrderedDict)
3250         base_tops = tops.pop("base", DefaultOrderedDict(OrderedDict))
3251         for ctop in base_tops:
3252             for saltenv, targets in ctop.items():
3253                 if saltenv == "include":
3254                     continue
3255                 try:
3256                     for tgt in targets:
3257                         top[saltenv][tgt] = ctop[saltenv][tgt]
3258                 except TypeError:
3259                     raise SaltRenderError(
3260                         "Unable to render top file. No targets found."
3261                     )
3262         for cenv, ctops in tops.items():
3263             for ctop in ctops:
3264                 for saltenv, targets in ctop.items():
3265                     if saltenv == "include":
3266                         continue
3267                     elif saltenv != cenv:
3268                         log.debug(
3269                             "Section for saltenv '%s' in the '%s' "
3270                             "saltenv's top file will be ignored, as the "
3271                             "top_file_merging_strategy is set to 'merge' "
3272                             "and the saltenvs do not match",
3273                             saltenv,
3274                             cenv,
3275                         )
3276                         continue
3277                     elif saltenv in top:
3278                         log.debug(
3279                             "Section for saltenv '%s' in the '%s' "
3280                             "saltenv's top file will be ignored, as this "
3281                             "saltenv was already defined in the 'base' top "
3282                             "file",
3283                             saltenv,
3284                             cenv,
3285                         )
3286                         continue
3287                     try:
3288                         for tgt in targets:
3289                             top[saltenv][tgt] = ctop[saltenv][tgt]
3290                     except TypeError:
3291                         raise SaltRenderError(
3292                             "Unable to render top file. No targets found."
3293                         )
3294         return top
3295     def _merge_tops_same(self, tops):
3296         """
3297         For each saltenv, only consider the top file from that saltenv. All
3298         sections matching a given saltenv, which appear in a different
3299         saltenv's top file, will be ignored.
3300         """
3301         top = DefaultOrderedDict(OrderedDict)
3302         for cenv, ctops in tops.items():
3303             if all([x == {} for x in ctops]):
3304                 default_top = self.opts["default_top"]
3305                 fallback_tops = tops.get(default_top, [])
3306                 if all([x == {} for x in fallback_tops]):
3307                     log.error(
3308                         "The '%s' saltenv has no top file, and the fallback "
3309                         "saltenv specified by default_top (%s) also has no "
3310                         "top file",
3311                         cenv,
3312                         default_top,
3313                     )
3314                     continue
3315                 for ctop in fallback_tops:
3316                     for saltenv, targets in ctop.items():
3317                         if saltenv != cenv:
3318                             continue
3319                         log.debug(
3320                             "The '%s' saltenv has no top file, using the "
3321                             "default_top saltenv (%s)",
3322                             cenv,
3323                             default_top,
3324                         )
3325                         for tgt in targets:
3326                             top[saltenv][tgt] = ctop[saltenv][tgt]
3327                         break
3328                     else:
3329                         log.error(
3330                             "The '%s' saltenv has no top file, and no "
3331                             "matches were found in the top file for the "
3332                             "default_top saltenv (%s)",
3333                             cenv,
3334                             default_top,
3335                         )
3336                 continue
3337             else:
3338                 for ctop in ctops:
3339                     for saltenv, targets in ctop.items():
3340                         if saltenv == "include":
3341                             continue
3342                         elif saltenv != cenv:
3343                             log.debug(
3344                                 "Section for saltenv '%s' in the '%s' "
3345                                 "saltenv's top file will be ignored, as the "
3346                                 "top_file_merging_strategy is set to 'same' "
3347                                 "and the saltenvs do not match",
3348                                 saltenv,
3349                                 cenv,
3350                             )
3351                             continue
3352                         try:
3353                             for tgt in targets:
3354                                 top[saltenv][tgt] = ctop[saltenv][tgt]
3355                         except TypeError:
3356                             raise SaltRenderError(
3357                                 "Unable to render top file. No targets found."
3358                             )
3359         return top
3360     def _merge_tops_merge_all(self, tops):
3361         """
3362         Merge the top files into a single dictionary
3363         """
3364         def _read_tgt(tgt):
3365             match_type = None
3366             states = []
3367             for item in tgt:
3368                 if isinstance(item, dict):
3369                     match_type = item
3370                 if isinstance(item, str):
3371                     states.append(item)
3372             return match_type, states
3373         top = DefaultOrderedDict(OrderedDict)
3374         for ctops in tops.values():
3375             for ctop in ctops:
3376                 for saltenv, targets in ctop.items():
3377                     if saltenv == "include":
3378                         continue
3379                     try:
3380                         for tgt in targets:
3381                             if tgt not in top[saltenv]:
3382                                 top[saltenv][tgt] = ctop[saltenv][tgt]
3383                                 continue
3384                             m_type1, m_states1 = _read_tgt(top[saltenv][tgt])
3385                             m_type2, m_states2 = _read_tgt(ctop[saltenv][tgt])
3386                             merged = []
3387                             match_type = m_type2 or m_type1
3388                             if match_type is not None:
3389                                 merged.append(match_type)
3390                             merged.extend(m_states1)
3391                             merged.extend([x for x in m_states2 if x not in merged])
3392                             top[saltenv][tgt] = merged
3393                     except TypeError:
3394                         raise SaltRenderError(
3395                             "Unable to render top file. No targets found."
3396                         )
3397         return top
3398     def verify_tops(self, tops):
3399         """
3400         Verify the contents of the top file data
3401         """
3402         errors = []
3403         if not isinstance(tops, dict):
3404             errors.append("Top data was not formed as a dict")
3405             return errors
3406         for saltenv, matches in tops.items():
3407             if saltenv == "include":
3408                 continue
3409             if not isinstance(saltenv, str):
3410                 errors.append(
3411                     "Environment {} in top file is not formed as a string".format(
3412                         saltenv
3413                     )
3414                 )
3415             if saltenv == "":
3416                 errors.append("Empty saltenv statement in top file")
3417             if not isinstance(matches, dict):
3418                 errors.append(
3419                     "The top file matches for saltenv {} are not "
3420                     "formatted as a dict".format(saltenv)
3421                 )
3422             for slsmods in matches.values():
3423                 if not isinstance(slsmods, list):
3424                     errors.append(
3425                         "Malformed topfile (state declarations not formed as a list)"
3426                     )
3427                     continue
3428                 for slsmod in slsmods:
3429                     if isinstance(slsmod, dict):
3430                         for val in slsmod.values():
3431                             if not val:
3432                                 errors.append(
3433                                     "Improperly formatted top file matcher "
3434                                     "in saltenv {}: {} file".format(slsmod, val)
3435                                 )
3436                     elif isinstance(slsmod, str):
3437                         if not slsmod:
3438                             errors.append(
3439                                 "Environment {} contains an empty sls index".format(
3440                                     saltenv
3441                                 )
3442                             )
3443         return errors
3444     def get_top(self):
3445         """
3446         Returns the high data derived from the top file
3447         """
3448         try:
3449             tops = self.get_tops()
3450         except SaltRenderError as err:
3451             log.error("Unable to render top file: %s", err.error)
3452             return {}
3453         return self.merge_tops(tops)
3454     def top_matches(self, top):
3455         """
3456         Search through the top high data for matches and return the states
3457         that this minion needs to execute.
3458         Returns:
3459         {'saltenv': ['state1', 'state2', ...]}
3460         """
3461         matches = DefaultOrderedDict(OrderedDict)
3462         for saltenv, body in top.items():
3463             if self.opts["saltenv"]:
3464                 if saltenv != self.opts["saltenv"]:
3465                     continue
3466             for match, data in body.items():
3467                 def _filter_matches(_match, _data, _opts):
3468                     if isinstance(_data, str):
3469                         _data = [_data]
3470                     if self.matchers["confirm_top.confirm_top"](_match, _data, _opts):
3471                         if saltenv not in matches:
3472                             matches[saltenv] = []
3473                         for item in _data:
3474                             if "subfilter" in item:
3475                                 _tmpdata = item.pop("subfilter")
3476                                 for match, data in _tmpdata.items():
3477                                     _filter_matches(match, data, _opts)
3478                             if isinstance(item, str):
3479                                 matches[saltenv].append(item)
3480                             elif isinstance(item, dict):
3481                                 env_key, inc_sls = item.popitem()
3482                                 if env_key not in self.avail:
3483                                     continue
3484                                 if env_key not in matches:
3485                                     matches[env_key] = []
3486                                 matches[env_key].append(inc_sls)
3487                 _filter_matches(match, data, self.opts["nodegroups"])
3488         ext_matches = self._master_tops()
3489         for saltenv in ext_matches:
3490             top_file_matches = matches.get(saltenv, [])
3491             if self.opts.get("master_tops_first"):
3492                 first = ext_matches[saltenv]
3493                 second = top_file_matches
3494             else:
3495                 first = top_file_matches
3496                 second = ext_matches[saltenv]
3497             matches[saltenv] = first + [x for x in second if x not in first]
3498         return matches
3499     def _master_tops(self):
3500         """
3501         Get results from the master_tops system. Override this function if the
3502         execution of the master_tops needs customization.
3503         """
3504         return self.client.master_tops()
3505     def load_dynamic(self, matches):
3506         """
3507         If autoload_dynamic_modules is True then automatically load the
3508         dynamic modules
3509         """
3510         if not self.opts["autoload_dynamic_modules"]:
3511             return
3512         syncd = self.state.functions["saltutil.sync_all"](list(matches), refresh=False)
3513         if syncd["grains"]:
3514             self.opts["grains"] = salt.loader.grains(self.opts)
3515             self.state.opts["pillar"] = self.state._gather_pillar()
3516         self.state.module_refresh()
3517     def render_state(self, sls, saltenv, mods, matches, local=False, context=None):
3518         """
3519         Render a state file and retrieve all of the include states
3520         """
3521         errors = []
3522         if not local:
3523             state_data = self.client.get_state(sls, saltenv)
3524             fn_ = state_data.get("dest", False)
3525         else:
3526             fn_ = sls
3527             if not os.path.isfile(fn_):
3528                 errors.append(
3529                     "Specified SLS {} on local filesystem cannot be found.".format(sls)
3530                 )
3531         state = None
3532         if not fn_:
3533             errors.append(
3534                 "Specified SLS {} in saltenv {} is not "
3535                 "available on the salt master or through a configured "
3536                 "fileserver".format(sls, saltenv)
3537             )
3538         else:
3539             try:
3540                 state = compile_template(
3541                     fn_,
3542                     self.state.rend,
3543                     self.state.opts["renderer"],
3544                     self.state.opts["renderer_blacklist"],
3545                     self.state.opts["renderer_whitelist"],
3546                     saltenv,
3547                     sls,
3548                     rendered_sls=mods,
3549                     context=context,
3550                 )
3551             except SaltRenderError as exc:
3552                 msg = "Rendering SLS '{}:{}' failed: {}".format(saltenv, sls, exc)
3553                 log.critical(msg)
3554                 errors.append(msg)
3555             except Exception as exc:  # pylint: disable=broad-except
3556                 msg = "Rendering SLS {} failed, render error: {}".format(sls, exc)
3557                 log.critical(
3558                     msg,
3559                     exc_info_on_loglevel=logging.DEBUG,
3560                 )
3561                 errors.append("{}\n{}".format(msg, traceback.format_exc()))
3562             try:
3563                 mods.add("{}:{}".format(saltenv, sls))
3564             except AttributeError:
3565                 pass
3566         if state:
3567             if not isinstance(state, dict):
3568                 errors.append("SLS {} does not render to a dictionary".format(sls))
3569             else:
3570                 include = []
3571                 if "include" in state:
3572                     if not isinstance(state["include"], list):
3573                         err = (
3574                             "Include Declaration in SLS {} is not formed "
3575                             "as a list".format(sls)
3576                         )
3577                         errors.append(err)
3578                     else:
3579                         include = state.pop("include")
3580                 self._handle_extend(state, sls, saltenv, errors)
3581                 self._handle_exclude(state, sls, saltenv, errors)
3582                 self._handle_state_decls(state, sls, saltenv, errors)
3583                 for inc_sls in include:
3584                     xenv_key = "_xenv"
3585                     if isinstance(inc_sls, dict):
3586                         env_key, inc_sls = inc_sls.popitem()
3587                     else:
3588                         env_key = saltenv
3589                     if env_key not in self.avail and "__env__" not in self.avail:
3590                         msg = (
3591                             "Nonexistent saltenv '{}' found in include "
3592                             "of '{}' within SLS '{}:{}'".format(
3593                                 env_key, inc_sls, saltenv, sls
3594                             )
3595                         )
3596                         log.error(msg)
3597                         errors.append(msg)
3598                         continue
3599                     if inc_sls.startswith("."):
3600                         match = re.match(r"^(\.+)(.*)$", inc_sls)
3601                         if match:
3602                             levels, include = match.groups()
3603                         else:
3604                             msg = (
3605                                 "Badly formatted include {} found in include "
3606                                 "in SLS '{}:{}'".format(inc_sls, saltenv, sls)
3607                             )
3608                             log.error(msg)
3609                             errors.append(msg)
3610                             continue
3611                         level_count = len(levels)
3612                         p_comps = sls.split(".")
3613                         if state_data.get("source", "").endswith("/init.sls"):
3614                             p_comps.append("init")
3615                         if level_count &gt; len(p_comps):
3616                             msg = (
3617                                 "Attempted relative include of '{}' "
3618                                 "within SLS '{}:{}' "
3619                                 "goes beyond top level package ".format(
3620                                     inc_sls, saltenv, sls
3621                                 )
3622                             )
3623                             log.error(msg)
3624                             errors.append(msg)
3625                             continue
3626                         inc_sls = ".".join(p_comps[:-level_count] + [include])
3627                     if env_key != xenv_key:
3628                         if matches is None:
3629                             matches = []
3630                         if env_key in matches or fnmatch.filter(
3631                             self.avail[env_key], inc_sls
3632                         ):
3633                             resolved_envs = [env_key]
3634                         else:
3635                             resolved_envs = []
3636                     else:
3637                         resolved_envs = [
3638                             aenv
3639                             for aenv in matches
3640                             if fnmatch.filter(self.avail[aenv], inc_sls)
3641                         ]
3642                     if len(resolved_envs) == 1 or saltenv in resolved_envs:
3643                         sls_targets = fnmatch.filter(self.avail[saltenv], inc_sls) or [
3644                             inc_sls
3645                         ]
3646                         for sls_target in sls_targets:
3647                             r_env = (
3648                                 resolved_envs[0] if len(resolved_envs) == 1 else saltenv
3649                             )
3650                             mod_tgt = "{}:{}".format(r_env, sls_target)
3651                             if mod_tgt not in mods:
3652                                 nstate, err = self.render_state(
3653                                     sls_target, r_env, mods, matches
3654                                 )
3655                                 if nstate:
3656                                     self.merge_included_states(state, nstate, errors)
3657                                     state.update(nstate)
3658                                 if err:
3659                                     errors.extend(err)
3660                     else:
3661                         msg = ""
3662                         if not resolved_envs:
3663                             msg = (
3664                                 "Unknown include: Specified SLS {}: {} is not available"
3665                                 " on the salt master in saltenv(s): {} ".format(
3666                                     env_key,
3667                                     inc_sls,
3668                                     ", ".join(matches)
3669                                     if env_key == xenv_key
3670                                     else env_key,
3671                                 )
3672                             )
3673                         elif len(resolved_envs) &gt; 1:
3674                             msg = (
3675                                 "Ambiguous include: Specified SLS {}: {} is available"
3676                                 " on the salt master in multiple available saltenvs: {}".format(
3677                                     env_key, inc_sls, ", ".join(resolved_envs)
3678                                 )
3679                             )
3680                         log.critical(msg)
3681                         errors.append(msg)
3682                 try:
3683                     self._handle_iorder(state)
3684                 except TypeError:
3685                     log.critical("Could not render SLS %s. Syntax error detected.", sls)
3686         else:
3687             state = {}
3688         return state, errors
3689     def _handle_iorder(self, state):
3690         """
3691         Take a state and apply the iorder system
3692         """
3693         if self.opts["state_auto_order"]:
3694             for name in state:
3695                 for s_dec in state[name]:
3696                     if not isinstance(s_dec, str):
3697                         continue
3698                     if not isinstance(state[name], dict):
3699                         continue
3700                     if not isinstance(state[name][s_dec], list):
3701                         continue
3702                     found = False
3703                     if s_dec.startswith("_"):
3704                         continue
3705                     for arg in state[name][s_dec]:
3706                         if isinstance(arg, dict):
3707                             if len(arg) &gt; 0:
3708                                 if next(iter(arg.keys())) == "order":
3709                                     found = True
3710                     if not found:
3711                         if not isinstance(state[name][s_dec], list):
3712                             continue
3713                         state[name][s_dec].append({"order": self.iorder})
3714                         self.iorder += 1
3715         return state
3716     def _handle_state_decls(self, state, sls, saltenv, errors):
3717         """
3718         Add sls and saltenv components to the state
3719         """
3720         for name in state:
3721             if not isinstance(state[name], dict):
3722                 if name == "__extend__":
3723                     continue
3724                 if name == "__exclude__":
3725                     continue
3726                 if isinstance(state[name], str):
3727                     if "." in state[name]:
3728                         comps = state[name].split(".")
3729                         state[name] = {
3730                             "__sls__": sls,
3731                             "__env__": saltenv,
3732                             comps[0]: [comps[1]],
3733                         }
3734                         continue
3735                 errors.append("ID {} in SLS {} is not a dictionary".format(name, sls))
3736                 continue
3737             skeys = set()
3738             for key in list(state[name]):
3739                 if key.startswith("_"):
3740                     continue
3741                 if not isinstance(state[name][key], list):
3742                     continue
3743                 if "." in key:
3744                     comps = key.split(".")
3745                     if comps[0] in skeys:
3746                         errors.append(
3747                             "ID '{}' in SLS '{}' contains multiple state "
3748                             "declarations of the same type".format(name, sls)
3749                         )
3750                         continue
3751                     state[name][comps[0]] = state[name].pop(key)
3752                     state[name][comps[0]].append(comps[1])
3753                     skeys.add(comps[0])
3754                     continue
3755                 skeys.add(key)
3756             if "__sls__" not in state[name]:
3757                 state[name]["__sls__"] = sls
3758             if "__env__" not in state[name]:
3759                 state[name]["__env__"] = saltenv
3760     def _handle_extend(self, state, sls, saltenv, errors):
3761         """
3762         Take the extend dec out of state and apply to the highstate global
3763         dec
3764         """
3765         if "extend" in state:
3766             ext = state.pop("extend")
3767             if not isinstance(ext, dict):
3768                 errors.append(
3769                     "Extension value in SLS '{}' is not a dictionary".format(sls)
3770                 )
3771                 return
3772             for name in ext:
3773                 if not isinstance(ext[name], dict):
3774                     errors.append(
3775                         "Extension name '{}' in SLS '{}' is not a dictionary".format(
3776                             name, sls
3777                         )
3778                     )
3779                     continue
3780                 if "__sls__" not in ext[name]:
3781                     ext[name]["__sls__"] = sls
3782                 if "__env__" not in ext[name]:
3783                     ext[name]["__env__"] = saltenv
3784                 for key in list(ext[name]):
3785                     if key.startswith("_"):
3786                         continue
3787                     if not isinstance(ext[name][key], list):
3788                         continue
3789                     if "." in key:
3790                         comps = key.split(".")
3791                         ext[name][comps[0]] = ext[name].pop(key)
3792                         ext[name][comps[0]].append(comps[1])
3793             state.setdefault("__extend__", []).append(ext)
3794     def _handle_exclude(self, state, sls, saltenv, errors):
3795         """
3796         Take the exclude dec out of the state and apply it to the highstate
3797         global dec
3798         """
3799         if "exclude" in state:
3800             exc = state.pop("exclude")
3801             if not isinstance(exc, list):
3802                 err = "Exclude Declaration in SLS {} is not formed as a list".format(
3803                     sls
3804                 )
3805                 errors.append(err)
3806             state.setdefault("__exclude__", []).extend(exc)
3807     def render_highstate(self, matches, context=None):
3808         """
3809         Gather the state files and render them into a single unified salt
3810         high data structure.
3811         """
3812         highstate = self.building_highstate
3813         all_errors = []
3814         mods = set()
3815         statefiles = []
3816         for saltenv, states in matches.items():
3817             for sls_match in states:
3818                 if saltenv in self.avail:
3819                     statefiles = fnmatch.filter(self.avail[saltenv], sls_match)
3820                 elif "__env__" in self.avail:
3821                     statefiles = fnmatch.filter(self.avail["__env__"], sls_match)
3822                 else:
3823                     all_errors.append(
3824                         "No matching salt environment for environment "
3825                         "'{}' found".format(saltenv)
3826                     )
3827                 if not statefiles:
3828                     statefiles = [sls_match]
3829                 for sls in statefiles:
3830                     r_env = "{}:{}".format(saltenv, sls)
3831                     if r_env in mods:
3832                         continue
3833                     state, errors = self.render_state(
3834                         sls, saltenv, mods, matches, context=context
3835                     )
3836                     if state:
3837                         self.merge_included_states(highstate, state, errors)
3838                     for i, error in enumerate(errors[:]):
3839                         if "is not available" in error:
3840                             this_sls = "SLS {} in saltenv".format(sls_match)
3841                             if this_sls in error:
3842                                 errors[
3843                                     i
3844                                 ] = "No matching sls found for '{}' in env '{}'".format(
3845                                     sls_match, saltenv
3846                                 )
3847                     all_errors.extend(errors)
3848         self.clean_duplicate_extends(highstate)
3849         return highstate, all_errors
3850     def clean_duplicate_extends(self, highstate):
3851         if "__extend__" in highstate:
3852             highext = []
3853             for items in (ext.items() for ext in highstate["__extend__"]):
3854                 for item in items:
3855                     if item not in highext:
3856                         highext.append(item)
3857             highstate["__extend__"] = [{t[0]: t[1]} for t in highext]
3858     def merge_included_states(self, highstate, state, errors):
3859         if "__extend__" in state:
3860             highstate.setdefault("__extend__", []).extend(state.pop("__extend__"))
3861         if "__exclude__" in state:
3862             highstate.setdefault("__exclude__", []).extend(state.pop("__exclude__"))
3863         for id_ in state:
3864             if id_ in highstate:
3865                 if highstate[id_] != state[id_]:
3866                     errors.append(
3867                         "Detected conflicting IDs, SLS"
3868                         " IDs need to be globally unique.\n    The"
3869                         " conflicting ID is '{}' and is found in SLS"
3870                         " '{}:{}' and SLS '{}:{}'".format(
3871                             id_,
3872                             highstate[id_]["__env__"],
3873                             highstate[id_]["__sls__"],
3874                             state[id_]["__env__"],
3875                             state[id_]["__sls__"],
3876                         )
3877                     )
3878         try:
3879             highstate.update(state)
3880         except ValueError:
3881             errors.append("Error when rendering state with contents: {}".format(state))
3882     def _check_pillar(self, force=False):
3883         """
3884         Check the pillar for errors, refuse to run the state if there are
3885         errors in the pillar and return the pillar errors
3886         """
3887         if force:
3888             return True
3889         if "_errors" in self.state.opts["pillar"]:
3890             return False
3891         return True
3892     def matches_whitelist(self, matches, whitelist):
3893         """
3894         Reads over the matches and returns a matches dict with just the ones
3895         that are in the whitelist
3896         """
3897         if not whitelist:
3898             return matches
3899         ret_matches = {}
3900         if not isinstance(whitelist, list):
3901             whitelist = whitelist.split(",")
3902         for env in matches:
3903             for sls in matches[env]:
3904                 if sls in whitelist:
3905                     ret_matches[env] = ret_matches[env] if env in ret_matches else []
3906                     ret_matches[env].append(sls)
3907         return ret_matches
3908     def call_highstate(
3909         self,
3910         exclude=None,
3911         cache=None,
3912         cache_name="highstate",
3913         force=False,
3914         whitelist=None,
3915         orchestration_jid=None,
3916     ):
3917         """
3918         Run the sequence to execute the salt highstate for this minion
3919         """
3920         tag_name = "no_|-states_|-states_|-None"
3921         ret = {
3922             tag_name: {
3923                 "result": False,
3924                 "comment": "No states found for this minion",
3925                 "name": "No States",
3926                 "changes": {},
3927                 "__run_num__": 0,
3928             }
3929         }
3930         cfn = os.path.join(self.opts["cachedir"], "{}.cache.p".format(cache_name))
3931         if cache:
3932             if os.path.isfile(cfn):
3933                 with salt.utils.files.fopen(cfn, "rb") as fp_:
3934                     high = salt.payload.load(fp_)
3935                     return self.state.call_high(high, orchestration_jid)
3936         err = []
3937         try:
3938             top = self.get_top()
3939         except SaltRenderError as err:
3940             ret[tag_name]["comment"] = "Unable to render top file: "
3941             ret[tag_name]["comment"] += str(err.error)
3942             return ret
3943         except Exception:  # pylint: disable=broad-except
3944             trb = traceback.format_exc()
3945             err.append(trb)
3946             return err
3947         err += self.verify_tops(top)
3948         matches = self.top_matches(top)
3949         if not matches:
3950             msg = (
3951                 "No Top file or master_tops data matches found. Please see "
3952                 "master log for details."
3953             )
3954             ret[tag_name]["comment"] = msg
3955             return ret
3956         matches = self.matches_whitelist(matches, whitelist)
3957         self.load_dynamic(matches)
3958         if not self._check_pillar(force):
3959             err += ["Pillar failed to render with the following messages:"]
3960             err += self.state.opts["pillar"]["_errors"]
3961         else:
3962             high, errors = self.render_highstate(matches)
3963             if exclude:
3964                 if isinstance(exclude, str):
3965                     exclude = exclude.split(",")
3966                 if "__exclude__" in high:
3967                     high["__exclude__"].extend(exclude)
3968                 else:
3969                     high["__exclude__"] = exclude
3970             err += errors
3971         if err:
3972             return err
3973         if not high:
3974             return ret
3975         with salt.utils.files.set_umask(0o077):
3976             try:
3977                 if salt.utils.platform.is_windows():
3978                     self.state.functions["cmd.run"](
3979                         ["attrib", "-R", cfn],
3980                         python_shell=False,
3981                         output_loglevel="quiet",
3982                     )
3983                 with salt.utils.files.fopen(cfn, "w+b") as fp_:
3984                     try:
3985                         salt.payload.dump(high, fp_)
3986                     except TypeError:
3987                         pass
3988             except OSError:
3989                 log.error('Unable to write to "state.highstate" cache file %s', cfn)
3990         return self.state.call_high(high, orchestration_jid)
3991     def compile_highstate(self):
3992         """
3993         Return just the highstate or the errors
3994         """
3995         err = []
3996         top = self.get_top()
3997         err += self.verify_tops(top)
3998         matches = self.top_matches(top)
3999         high, errors = self.render_highstate(matches)
4000         err += errors
4001         if err:
4002             return err
4003         return high
4004     def compile_low_chunks(self):
4005         """
4006         Compile the highstate but don't run it, return the low chunks to
4007         see exactly what the highstate will execute
4008         """
4009         top = self.get_top()
4010         matches = self.top_matches(top)
4011         high, errors = self.render_highstate(matches)
4012         high, ext_errors = self.state.reconcile_extend(high)
4013         errors += ext_errors
4014         errors += self.state.verify_high(high)
4015         high, req_in_errors = self.state.requisite_in(high)
4016         errors += req_in_errors
4017         high = self.state.apply_exclude(high)
4018         if errors:
4019             return errors
4020         chunks = self.state.compile_high_data(high)
4021         return chunks
4022     def compile_state_usage(self):
4023         """
4024         Return all used and unused states for the minion based on the top match data
4025         """
4026         err = []
4027         top = self.get_top()
4028         err += self.verify_tops(top)
4029         if err:
4030             return err
4031         matches = self.top_matches(top)
4032         state_usage = {}
4033         for saltenv, states in self.avail.items():
4034             env_usage = {
4035                 "used": [],
4036                 "unused": [],
4037                 "count_all": 0,
4038                 "count_used": 0,
4039                 "count_unused": 0,
4040             }
4041             env_matches = matches.get(saltenv, [])
4042             for state in states:
4043                 env_usage["count_all"] += 1
4044                 if state in env_matches:
4045                     env_usage["count_used"] += 1
4046                     env_usage["used"].append(state)
4047                 else:
4048                     env_usage["count_unused"] += 1
4049                     env_usage["unused"].append(state)
4050             state_usage[saltenv] = env_usage
4051         return state_usage
4052     def destroy(self):
4053         raise NotImplementedError
4054     def __enter__(self):
4055         return self
4056     def __exit__(self, *_):
4057         self.destroy()
4058 class HighState(BaseHighState):
4059     """
4060     Generate and execute the salt "High State". The High State is the
4061     compound state derived from a group of template files stored on the
4062     salt master or in the local cache.
4063     """
4064     stack = []
4065     def __init__(
4066         self,
4067         opts,
4068         pillar_override=None,
4069         jid=None,
4070         pillar_enc=None,
4071         proxy=None,
4072         context=None,
4073         mocked=False,
4074         loader="states",
4075         initial_pillar=None,
4076     ):
4077         self.opts = opts
4078         self.client = salt.fileclient.get_file_client(self.opts)
4079         BaseHighState.__init__(self, opts)
4080         self.state = State(
4081             self.opts,
4082             pillar_override,
4083             jid,
4084             pillar_enc,
4085             proxy=proxy,
4086             context=context,
4087             mocked=mocked,
4088             loader=loader,
4089             initial_pillar=initial_pillar,
4090         )
4091         self.matchers = salt.loader.matchers(self.opts)
4092         self.proxy = proxy
4093         self._pydsl_all_decls = {}
4094         self._pydsl_render_stack = []
4095     def push_active(self):
4096         self.stack.append(self)
4097     @classmethod
4098     def clear_active(cls):
4099         cls.stack = []
4100     @classmethod
4101     def pop_active(cls):
4102         cls.stack.pop()
4103     @classmethod
4104     def get_active(cls):
4105         try:
4106             return cls.stack[-1]
4107         except IndexError:
4108             return None
4109     def destroy(self):
4110         self.client.destroy()
4111     def __enter__(self):
4112         return self
4113     def __exit__(self, *_):
4114         self.destroy()
4115 class MasterState(State):
4116     """
4117     Create a State object for master side compiling
4118     """
4119     def __init__(self, opts, minion):
4120         State.__init__(self, opts)
4121     def load_modules(self, data=None, proxy=None):
4122         """
4123         Load the modules into the state
4124         """
4125         log.info("Loading fresh modules for state activity")
4126         self.functions = salt.client.FunctionWrapper(self.opts, self<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.opts["id"])
4127         self.utils = salt.loader.utils(self.opts)
4128         self.serializers = salt.loader.serializers(self.</b></font>opts)
4129         self.states = salt.loader.states(
4130             self.opts, self.functions, self.utils, self.serializers
4131         )
4132         self.rend = salt.loader.render(
4133             self.opts, self.functions, states=self.states, context=self.state_con
4134         )
4135 class MasterHighState(HighState):
4136     """
4137     Execute highstate compilation from the master
4138     """
4139     def __init__(self, master_opts, minion_opts, grains, id_, saltenv=None):
4140         opts = copy.deepcopy(minion_opts)
4141         opts["file_client"] = "local"
4142         opts["file_roots"] = master_opts["master_roots"]
4143         opts["renderer"] = master_opts["renderer"]
4144         opts["state_top"] = master_opts["state_top"]
4145         opts["id"] = id_
4146         opts["grains"] = grains
4147         HighState.__init__(self, opts)
4148 class RemoteHighState:
4149     """
4150     Manage gathering the data from the master
4151     """
4152     def __init__(self, opts, grains):
4153         self.opts = opts
4154         self.grains = grains
4155         self.channel = salt.channel.client.ReqChannel.factory(self.opts["master_uri"])
4156         self._closing = False
4157     def compile_master(self):
4158         """
4159         Return the state data from the master
4160         """
4161         load = {"grains": self.grains, "opts": self.opts, "cmd": "_master_state"}
4162         try:
4163             return self.channel.send(load, tries=3, timeout=72000)
4164         except SaltReqTimeoutError:
4165             return {}
4166     def destroy(self):
4167         if self._closing:
4168             return
4169         self._closing = True
4170         self.channel.close()
4171     def __del__(self):
4172         self.destroy()
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
