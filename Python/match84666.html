<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for proxy_1.py &amp; state_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for proxy_1.py &amp; state_1.py
      </h3>
<h1 align="center">
        3.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>proxy_1.py (11.363636%)<th>state_1.py (2.3715951%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(15-58)<td><a href="#" name="0">(15-56)</a><td align="center"><font color="#ff0000">40</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(189-192)<td><a href="#" name="1">(1179-1186)</a><td align="center"><font color="#720000">18</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(96-101)<td><a href="#" name="2">(3521-3524)</a><td align="center"><font color="#5f0000">15</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(192-193)<td><a href="#" name="3">(2333-2340)</a><td align="center"><font color="#590000">14</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(133-139)<td><a href="#" name="4">(4740-4744)</a><td align="center"><font color="#590000">14</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(608-613)<td><a href="#" name="5">(644-649)</a><td align="center"><font color="#520000">13</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(150-154)<td><a href="#" name="6">(3019-3022)</a><td align="center"><font color="#520000">13</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(564-568)<td><a href="#" name="7">(3513-3518)</a><td align="center"><font color="#4c0000">12</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(259-271)<td><a href="#" name="8">(3621-3629)</a><td align="center"><font color="#4c0000">12</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(251-256)<td><a href="#" name="9">(2930-2940)</a><td align="center"><font color="#4c0000">12</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(184-187)<td><a href="#" name="10">(1166-1171)</a><td align="center"><font color="#4c0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>proxy_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import os
3 import signal
4 import sys
5 import threading
6 import traceback
7 import types
8 <a name="0"></a>
9 import salt
10 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import salt.beacons
11 import salt.cli.daemons
12 import salt.client
13 import salt.crypt
14 import salt.defaults.exitcodes
15 import salt.engines
16 import salt.ext.tornado.gen  # pylint: disable=F0401
17 import salt.ext.tornado.ioloop  # pylint: disable=F0401
18 import salt.loader
19 import salt.log.setup
20 import salt.minion
21 import salt.payload
22 import salt.pillar
23 import salt.serializers.msgpack
24 import salt.syspaths
25 import salt.utils.args
26 import salt.utils.context
27 import salt.utils.data
28 import salt.utils.dictupdate
29 import salt.utils.error
30 import salt.utils.event
31 import salt.utils.files
32 import salt.utils.jid
33 import salt.utils.minion
34 import salt.utils.minions
35 import salt.utils.network
36 import salt.utils.platform
37 import salt.utils.process
38 import salt.utils.schedule
39 import salt.utils.ssdp
40 import salt.utils.user
41 import salt.utils.zeromq
42 from salt.defaults import DEFAULT_TARGET_DELIM
43 from salt.exceptions import (
44     CommandExecutionError,
45     CommandNotFoundError,
46     SaltInvocationError,
47     SaltSystemExit,
48 )
49 from salt.minion import ProxyMinion
50 from salt.utils.event import tagify
51 from salt.utils.process import SignalHandlingProcess, default_signals
52 log = logging.getLogger(</b></font>__name__)
53 def post_master_init(self, master):
54     log.debug("subclassed LazyLoaded _post_master_init")
55     if self.connected:
56         self.opts["master"] = master
57         self.opts["pillar"] = yield salt.pillar.get_async_pillar(
58             self.opts,
59             self.opts["grains"],
60             self.opts["id"],
61             saltenv=self.opts["saltenv"],
62             pillarenv=self.opts.get("pillarenv"),
63         ).compile_pillar()
64     if "proxy" not in self.opts["pillar"] and "proxy" not in self.opts:
65         errmsg = (
66             "No proxy key found in pillar or opts for id "
67             + self.opts["id"]
68             + ". "
69             + "Check your pillar/opts configuration and contents.  Salt-proxy aborted."
70         )
71         log.error(errmsg)
72         self._running = False
73         raise SaltSystemExit(code=-1, msg=errmsg)
74 <a name="2"></a>    if "proxy" not in self.opts:
75         self.opts["proxy"] = self.opts["pillar"]["proxy"]
76     if self<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.opts.get("proxy_merge_pillar_in_opts"):
77         self.opts = salt.utils.dictupdate.merge(
78             self.opts,
79             self.opts["pillar"],
80             strategy=self.opts.</b></font>get("proxy_merge_pillar_in_opts_strategy"),
81             merge_lists=self.opts.get("proxy_deep_merge_pillar_in_opts", False),
82         )
83     elif self.opts.get("proxy_mines_pillar"):
84         if "mine_interval" in self.opts["pillar"]:
85             self.opts["mine_interval"] = self.opts["pillar"]["mine_interval"]
86         if "mine_functions" in self.opts["pillar"]:
87             general_proxy_mines = self.opts.get("mine_functions", {})
88             specific_proxy_mines = self.opts["pillar"]["mine_functions"]
89             try:
90                 self.opts["mine_functions"] = general_proxy_mines + specific_proxy_mines
91             except TypeError as terr:
92                 log.error(
93                     "Unable to merge mine functions from the pillar in the opts, for proxy %s",
94                     self.opts["id"],
95                 )
96     fq_proxyname = self.opts["proxy"]["proxytype"]
97     (
98         self.functions,
99         self.returners,
100         self.function_errors,
101         self.executors,
102     ) = self._load_modules()
103     self.functions["saltutil.sync_all"](saltenv=self<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.opts["saltenv"])
104     self.utils = salt.loader.utils(self.opts)
105     self.proxy = salt.loader.proxy(self.</b></font>opts, utils=self.utils)
106     (
107         self.functions,
108         self.returners,
109         self.function_errors,
110         self.executors,
111 <a name="6"></a>    ) = self._load_modules()
112     self.functions.pack["__proxy__"] = self.proxy
113     self.proxy.pack["__salt__"] = self.functions
114     self.proxy<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.pack["__ret__"] = self.returners
115     self.proxy.pack["__pillar__"] = self.opts["pillar"]
116     self.utils = salt.</b></font>loader.utils(self.opts, proxy=self.proxy)
117     self.proxy.pack["__utils__"] = self.utils
118     self.proxy.reload_modules()
119     self.io_loop.spawn_callback(
120         salt.engines.start_engines, self.opts, self.process_manager, proxy=self.proxy
121     )
122     if (
123         "{}.init".format(fq_proxyname) not in self.proxy
124         or "{}.shutdown".format(fq_proxyname) not in self.proxy
125     ):
126         errmsg = (
127             "Proxymodule {} is missing an init() or a shutdown() or both. ".format(
128                 fq_proxyname
129             )
130             + "Check your proxymodule.  Salt-proxy aborted."
131         )
132         log.error(errmsg)
133         self._running = False
134         raise SaltSystemExit(code=-1, msg=errmsg)
135 <a name="10"></a>    self.module_executors = self.proxy.get(
136         "{}.module_executors".format(fq_proxyname), lambda: []
137     )()
138     proxy_init_fn <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= self.proxy[fq_proxyname + ".init"]
139     proxy_init_fn(self.opts)
140 <a name="1"></a>
141     self.opts["grains"] = salt.loader.grains(self.</b></font>opts, proxy=self.proxy)
142 <a name="3"></a>    self.mod_opts <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= self._prep_mod_opts()
143     self.matchers = salt.loader.matchers(self.opts)
144     self.beacons = salt.beacons.Beacon(self.opts, self.functions)
145     uid = salt.</b></font>utils<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.user.get_uid(user=self.opts.get("user", None))
146     self.proc_dir = salt.minion.get_proc_dir(self.opts[</b></font>"cachedir"], uid=uid)
147     if self.connected and self.opts["pillar"]:
148         (
149             self.functions,
150             self.returners,
151             self.function_errors,
152             self.executors,
153         ) = self._load_modules()
154         if hasattr(self, "schedule"):
155             self.schedule.functions = self.functions
156             self.schedule.returners = self.returners
157     if not hasattr(self, "schedule"):
158         self.schedule = salt.utils.schedule.Schedule(
159             self.opts,
160             self.functions,
161             self.returners,
162             cleanup=[salt.minion.master_event(type="alive")],
163             proxy=self.proxy,
164         )
165     if self.opts["mine_enabled"] and "mine.update" in self.functions:
166         self.schedule.add_job(
167             {
168                 "__mine_interval": {
169                     "function": "mine.update",
170                     "minutes": self.opts["mine_interval"],
171                     "jid_include": True,
172                     "maxrunning": 2,
173                     "run_on_start": True,
174                     "return_job": self.opts.get("mine_return_job", False),
175                 }
176             },
177             persist=True,
178         )
179         log.info("Added mine.update to scheduler")
180     else:
181         self.schedule.delete_job("__mine_interval", persist=True)
182     if self.opts["transport"] != "tcp" and self.opts["master_alive_interval"] &gt; 0:
183         self.schedule.add_job(
184             {
185                 salt.minion.master_event(type="alive", master=self.opts["master"]): {
186                     "function": "status.master",
187                     "seconds": self.opts["master_alive_interval"],
188                     "jid_include": True,
189                     "maxrunning": 1,
190                     "return_job": False,
191                     "kwargs": {"master": self.opts["master"], "connected": True},
192                 }
193 <a name="9"></a>            },
194             persist=True,
195         )
196         <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>if (
197             self.opts["master_failback"]
198             and "master_list" in self.opts
199             and self.opts["master"] != self.opts["master_list"][0]
200         ):
201 <a name="8"></a>            self.schedule.add_job(</b></font>
202                 {
203                     salt.minion.master_event(type="failback"): {
204                         <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"function": "status.ping_master",
205                         "seconds": self.opts["master_failback_interval"],
206                         "jid_include": True,
207                         "maxrunning": 1,
208                         "return_job": False,
209                         "kwargs": {"master": self.opts["master_list"][0]},
210                     }
211                 },
212                 persist=True,
213             )
214         else:
215             self.schedule.delete_job(
216                 salt.</b></font>minion.master_event(type="failback"), persist=True
217             )
218     else:
219         self.schedule.delete_job(
220             salt.minion.master_event(type="alive", master=self.opts["master"]),
221             persist=True,
222         )
223         self.schedule.delete_job(
224             salt.minion.master_event(type="failback"), persist=True
225         )
226     proxy_alive_fn = fq_proxyname + ".alive"
227     if (
228         proxy_alive_fn in self.proxy
229         and "status.proxy_reconnect" in self.functions
230         and self.opts.get("proxy_keep_alive", True)
231     ):
232         self.schedule.add_job(
233             {
234                 "__proxy_keepalive": {
235                     "function": "status.proxy_reconnect",
236                     "minutes": self.opts.get(
237                         "proxy_keep_alive_interval", 1
238                     ),  # by default, check once per minute
239                     "jid_include": True,
240                     "maxrunning": 1,
241                     "return_job": False,
242                     "kwargs": {"proxy_name": fq_proxyname},
243                 }
244             },
245             persist=True,
246         )
247         self.schedule.enable_schedule()
248     else:
249         self.schedule.delete_job("__proxy_keepalive", persist=True)
250     self.functions["saltutil.sync_grains"](saltenv="base")
251     self.grains_cache = self.opts["grains"]
252     self.ready = True
253 def target(cls, minion_instance, opts, data, connected):
254     if not minion_instance:
255         minion_instance = cls(opts)
256         minion_instance.connected = connected
257         if not hasattr(minion_instance, "functions"):
258             (
259                 functions,
260                 returners,
261                 function_errors,
262                 executors,
263             ) = minion_instance._load_modules(grains=opts["grains"])
264             minion_instance.functions = functions
265             minion_instance.returners = returners
266             minion_instance.function_errors = function_errors
267             minion_instance.executors = executors
268             minion_instance.utils = salt.loader.utils(minion_instance.opts)
269             minion_instance.proxy = salt.loader.proxy(
270                 minion_instance.opts, utils=minion_instance.utils
271             )
272             (
273                 functions,
274                 returners,
275                 function_errors,
276                 executors,
277             ) = minion_instance._load_modules(grains=opts["grains"])
278             minion_instance.functions = functions
279             minion_instance.returners = returners
280             minion_instance.function_errors = function_errors
281             minion_instance.executors = executors
282             minion_instance.functions.pack["__proxy__"] = minion_instance.proxy
283             minion_instance.proxy.pack["__salt__"] = minion_instance.functions
284             minion_instance.proxy.pack["__ret__"] = minion_instance.returners
285             minion_instance.proxy.pack["__pillar__"] = minion_instance.opts["pillar"]
286             minion_instance.utils = salt.loader.utils(
287                 minion_instance.opts, proxy=minion_instance.proxy
288             )
289             minion_instance.proxy.pack["__utils__"] = minion_instance.utils
290             minion_instance.proxy.reload_modules()
291             fq_proxyname = opts["proxy"]["proxytype"]
292             minion_instance.module_executors = minion_instance.proxy.get(
293                 "{}.module_executors".format(fq_proxyname), lambda: []
294             )()
295             proxy_init_fn = minion_instance.proxy[fq_proxyname + ".init"]
296             proxy_init_fn(opts)
297         if not hasattr(minion_instance, "proc_dir"):
298             uid = salt.utils.user.get_uid(user=opts.get("user", None))
299             minion_instance.proc_dir = salt.minion.get_proc_dir(
300                 opts["cachedir"], uid=uid
301             )
302     with salt.ext.tornado.stack_context.StackContext(minion_instance.ctx):
303         if isinstance(data["fun"], tuple) or isinstance(data["fun"], list):
304             ProxyMinion._thread_multi_return(minion_instance, opts, data)
305         else:
306             ProxyMinion._thread_return(minion_instance, opts, data)
307 def thread_return(cls, minion_instance, opts, data):
308     fn_ = os.path.join(minion_instance.proc_dir, data["jid"])
309     salt.utils.process.appendproctitle(
310         "{}._thread_return {}".format(cls.__name__, data["jid"])
311     )
312     sdata = {"pid": os.getpid()}
313     sdata.update(data)
314     log.info("Starting a new job with PID %s", sdata["pid"])
315     with salt.utils.files.fopen(fn_, "w+b") as fp_:
316         fp_.write(salt.payload.dumps(sdata))
317     ret = {"success": False}
318     function_name = data["fun"]
319     executors = (
320         data.get("module_executors")
321         or getattr(minion_instance, "module_executors", [])
322         or opts.get("module_executors", ["direct_call"])
323     )
324     allow_missing_funcs = any(
325         [
326             minion_instance.executors["{}.allow_missing_func".format(executor)](
327                 function_name
328             )
329             for executor in executors
330             if "{}.allow_missing_func".format(executor) in minion_instance.executors
331         ]
332     )
333     if function_name in minion_instance.functions or allow_missing_funcs is True:
334         try:
335             minion_blackout_violation = False
336             if minion_instance.connected and minion_instance.opts["pillar"].get(
337                 "minion_blackout", False
338             ):
339                 whitelist = minion_instance.opts["pillar"].get(
340                     "minion_blackout_whitelist", []
341                 )
342                 if (
343                     function_name != "saltutil.refresh_pillar"
344                     and function_name not in whitelist
345                 ):
346                     minion_blackout_violation = True
347             if minion_instance.opts["grains"].get("minion_blackout", False):
348                 whitelist = minion_instance.opts["grains"].get(
349                     "minion_blackout_whitelist", []
350                 )
351                 if (
352                     function_name != "saltutil.refresh_pillar"
353                     and function_name not in whitelist
354                 ):
355                     minion_blackout_violation = True
356             if minion_blackout_violation:
357                 raise SaltInvocationError(
358                     "Minion in blackout mode. Set 'minion_blackout' "
359                     "to False in pillar or grains to resume operations. Only "
360                     "saltutil.refresh_pillar allowed in blackout mode."
361                 )
362             if function_name in minion_instance.functions:
363                 func = minion_instance.functions[function_name]
364                 args, kwargs = salt.minion.load_args_and_kwargs(func, data["arg"], data)
365             else:
366                 func = function_name
367                 args, kwargs = data["arg"], data
368             minion_instance.functions.pack["__context__"]["retcode"] = 0
369             if isinstance(executors, str):
370                 executors = [executors]
371             elif not isinstance(executors, list) or not executors:
372                 raise SaltInvocationError(
373                     "Wrong executors specification: {}. String or non-empty list"
374                     " expected".format(executors)
375                 )
376             if opts.get("sudo_user", "") and executors[-1] != "sudo":
377                 executors[-1] = "sudo"  # replace the last one with sudo
378             log.trace("Executors list %s", executors)  # pylint: disable=no-member
379             for name in executors:
380                 fname = "{}.execute".format(name)
381                 if fname not in minion_instance.executors:
382                     raise SaltInvocationError(
383                         "Executor '{}' is not available".format(name)
384                     )
385                 return_data = minion_instance.executors[fname](
386                     opts, data, func, args, kwargs
387                 )
388                 if return_data is not None:
389                     break
390             if isinstance(return_data, types.GeneratorType):
391                 ind = 0
392                 iret = {}
393                 for single in return_data:
394                     if isinstance(single, dict) and isinstance(iret, dict):
395                         iret.update(single)
396                     else:
397                         if not iret:
398                             iret = []
399                         iret.append(single)
400                     tag = tagify([data["jid"], "prog", opts["id"], str(ind)], "job")
401                     event_data = {"return": single}
402                     minion_instance._fire_master(event_data, tag)
403                     ind += 1
404                 ret["return"] = iret
405             else:
406                 ret["return"] = return_data
407             retcode = minion_instance.functions.pack["__context__"].get(
408                 "retcode", salt.defaults.exitcodes.EX_OK
409             )
410             if retcode == salt.defaults.exitcodes.EX_OK:
411                 try:
412                     func_result = all(
413                         return_data.get(x, True) for x in ("result", "success")
414                     )
415                 except Exception:  # pylint: disable=broad-except
416                     func_result = True
417                 if not func_result:
418                     retcode = salt.defaults.exitcodes.EX_GENERIC
419             ret["retcode"] = retcode
420             ret["success"] = retcode == salt.defaults.exitcodes.EX_OK
421         except CommandNotFoundError as exc:
422             msg = "Command required for '{}' not found".format(function_name)
423             log.debug(msg, exc_info=True)
424             ret["return"] = "{}: {}".format(msg, exc)
425             ret["out"] = "nested"
426             ret["retcode"] = salt.defaults.exitcodes.EX_GENERIC
427         except CommandExecutionError as exc:
428             log.error(
429                 "A command in '%s' had a problem: %s",
430                 function_name,
431                 exc,
432                 exc_info_on_loglevel=logging.DEBUG,
433             )
434             ret["return"] = "ERROR: {}".format(exc)
435             ret["out"] = "nested"
436             ret["retcode"] = salt.defaults.exitcodes.EX_GENERIC
437         except SaltInvocationError as exc:
438             log.error(
439                 "Problem executing '%s': %s",
440                 function_name,
441                 exc,
442                 exc_info_on_loglevel=logging.DEBUG,
443             )
444             ret["return"] = "ERROR executing '{}': {}".format(function_name, exc)
445             ret["out"] = "nested"
446             ret["retcode"] = salt.defaults.exitcodes.EX_GENERIC
447         except TypeError as exc:
448             msg = "Passed invalid arguments to {}: {}\n{}".format(
449                 function_name, exc, func.__doc__ or ""
450             )
451             log.warning(msg, exc_info_on_loglevel=logging.DEBUG)
452             ret["return"] = msg
453             ret["out"] = "nested"
454             ret["retcode"] = salt.defaults.exitcodes.EX_GENERIC
455         except Exception:  # pylint: disable=broad-except
456             msg = "The minion function caused an exception"
457             log.warning(msg, exc_info=True)
458 <a name="7"></a>            salt.utils.error.fire_exception(
459                 salt.exceptions.MinionError(msg), opts, job=data
460             )
461             ret["return"] = "{}: {}".format(msg, traceback<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.format_exc())
462             ret["out"] = "nested"
463             ret["retcode"] = salt.defaults.exitcodes.EX_GENERIC
464     else:
465         docs = minion_instance.functions[</b></font>"sys.doc"]("{}*".format(function_name))
466         if docs:
467             docs[function_name] = minion_instance.functions.missing_fun_string(
468                 function_name
469             )
470             ret["return"] = docs
471         else:
472             ret["return"] = minion_instance.functions.missing_fun_string(function_name)
473             mod_name = function_name.split(".")[0]
474             if mod_name in minion_instance.function_errors:
475                 ret["return"] += " Possible reasons: '{}'".format(
476                     minion_instance.function_errors[mod_name]
477                 )
478         ret["success"] = False
479         ret["retcode"] = salt.defaults.exitcodes.EX_GENERIC
480         ret["out"] = "nested"
481     ret["jid"] = data["jid"]
482     ret["fun"] = data["fun"]
483     ret["fun_args"] = data["arg"]
484     if "master_id" in data:
485         ret["master_id"] = data["master_id"]
486     if "metadata" in data:
487         if isinstance(data["metadata"], dict):
488             ret["metadata"] = data["metadata"]
489         else:
490             log.warning("The metadata parameter must be a dictionary. Ignoring.")
491     if minion_instance.connected:
492         minion_instance._return_pub(ret, timeout=minion_instance._return_retry_timer())
493     if isinstance(opts.get("return"), str):
494         if data["ret"]:
495             data["ret"] = ",".join((data["ret"], opts["return"]))
496         else:
497             data["ret"] = opts["return"]
498 <a name="5"></a>
499     log.debug("minion return: %s", ret)
500     if data["ret"] and isinstance(data<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["ret"], str):
501         if "ret_config" in data:
502             ret["ret_config"] = data["ret_config"]
503         if "ret_kwargs" in data:
504             ret["ret_kwargs"] = data["ret_kwargs"]
505         ret["id"] =</b></font> opts["id"]
506         for returner in set(data["ret"].split(",")):
507             try:
508                 returner_str = "{}.returner".format(returner)
509                 if returner_str in minion_instance.returners:
510                     minion_instance.returners[returner_str](ret)
511                 else:
512                     returner_err = minion_instance.returners.missing_fun_string(
513                         returner_str
514                     )
515                     log.error(
516                         "Returner %s could not be loaded: %s",
517                         returner_str,
518                         returner_err,
519                     )
520             except Exception as exc:  # pylint: disable=broad-except
521                 log.exception("The return failed for job %s: %s", data["jid"], exc)
522 def thread_multi_return(cls, minion_instance, opts, data):
523     fn_ = os.path.join(minion_instance.proc_dir, data["jid"])
524     salt.utils.process.appendproctitle(
525         "{}._thread_multi_return {}".format(cls.__name__, data["jid"])
526     )
527     sdata = {"pid": os.getpid()}
528     sdata.update(data)
529     log.info("Starting a new job with PID %s", sdata["pid"])
530     with salt.utils.files.fopen(fn_, "w+b") as fp_:
531         fp_.write(salt.payload.dumps(sdata))
532     multifunc_ordered = opts.get("multifunc_ordered", False)
533     num_funcs = len(data["fun"])
534     if multifunc_ordered:
535         ret = {
536             "return": [None] * num_funcs,
537             "retcode": [None] * num_funcs,
538             "success": [False] * num_funcs,
539         }
540     else:
541         ret = {"return": {}, "retcode": {}, "success": {}}
542     for ind in range(0, num_funcs):
543         if not multifunc_ordered:
544             ret["success"][data["fun"][ind]] = False
545         try:
546             minion_blackout_violation = False
547             if minion_instance.connected and minion_instance.opts["pillar"].get(
548                 "minion_blackout", False
549             ):
550                 whitelist = minion_instance.opts["pillar"].get(
551                     "minion_blackout_whitelist", []
552                 )
553                 if (
554                     data["fun"][ind] != "saltutil.refresh_pillar"
555                     and data["fun"][ind] not in whitelist
556                 ):
557                     minion_blackout_violation = True
558             elif minion_instance.opts["grains"].get("minion_blackout", False):
559                 whitelist = minion_instance.opts["grains"].get(
560                     "minion_blackout_whitelist", []
561                 )
562                 if (
563                     data["fun"][ind] != "saltutil.refresh_pillar"
564                     and data["fun"][ind] not in whitelist
565                 ):
566                     minion_blackout_violation = True
567             if minion_blackout_violation:
568                 raise SaltInvocationError(
569                     "Minion in blackout mode. Set 'minion_blackout' "
570                     "to False in pillar or grains to resume operations. Only "
571                     "saltutil.refresh_pillar allowed in blackout mode."
572                 )
573             func = minion_instance.functions[data["fun"][ind]]
574             args, kwargs = salt.minion.load_args_and_kwargs(
575                 func, data["arg"][ind], data
576             )
577             minion_instance.functions.pack["__context__"]["retcode"] = 0
578             key = ind if multifunc_ordered else data["fun"][ind]
579             ret["return"][key] = func(*args, **kwargs)
580             retcode = minion_instance.functions.pack["__context__"].get("retcode", 0)
581             if retcode == 0:
582                 try:
583                     func_result = all(
584                         ret["return"][key].get(x, True) for x in ("result", "success")
585                     )
586                 except Exception:  # pylint: disable=broad-except
587                     func_result = True
588                 if not func_result:
589                     retcode = 1
590             ret["retcode"][key] = retcode
591             ret["success"][key] = retcode == 0
592         except Exception as exc:  # pylint: disable=broad-except
593             trb = traceback.format_exc()
594             log.warning("The minion function caused an exception: %s", exc)
595             if multifunc_ordered:
596                 ret["return"][ind] = trb
597             else:
598                 ret["return"][data["fun"][ind]] = trb
599         ret["jid"] = data["jid"]
600         ret["fun"] = data["fun"]
601         ret["fun_args"] = data["arg"]
602     if "metadata" in data:
603         ret["metadata"] = data["metadata"]
604     if minion_instance.connected:
605         minion_instance._return_pub(ret, timeout=minion_instance._return_retry_timer())
606     if data["ret"]:
607         if "ret_config" in data:
608             ret["ret_config"] = data["ret_config"]
609         if "ret_kwargs" in data:
610             ret["ret_kwargs"] = data["ret_kwargs"]
611         for returner in set(data["ret"].split(",")):
612             ret["id"] = opts["id"]
613             try:
614                 minion_instance.returners["{}.returner".format(returner)](ret)
615             except Exception as exc:  # pylint: disable=broad-except
616                 log.error("The return failed for job %s: %s", data["jid"], exc)
617 def handle_payload(self, payload):
618     if payload is not None and payload["enc"] == "aes":
619         if self._target_load(payload["load"]):
620             self._handle_decoded_payload(payload["load"])
621         elif self.opts["zmq_filtering"]:
622             log.trace(
623                 "Broadcast message received not for this minion, Load: %s",
624                 payload["load"],
625             )
626 def handle_decoded_payload(self, data):
627     if "user" in data:
628         log.info(
629             "User %s Executing command %s with jid %s",
630             data["user"],
631             data["fun"],
632             data["jid"],
633         )
634     else:
635         log.info("Executing command %s with jid %s", data["fun"], data["jid"])
636     log.debug("Command details %s", data)
637     log.trace("Started JIDs: %s", self.jid_queue)
638     if self.jid_queue is not None:
639         if data["jid"] in self.jid_queue:
640             return
641         else:
642             self.jid_queue.append(data["jid"])
643             if len(self.jid_queue) &gt; self.opts["minion_jid_queue_hwm"]:
644                 self.jid_queue.pop(0)
645     if isinstance(data["fun"], str):
646         if data["fun"] == "sys.reload_modules":
647             (
648                 self.functions,
649                 self.returners,
650                 self.function_errors,
651                 self.executors,
652             ) = self._load_modules()
653             self.schedule.functions = self.functions
654             self.schedule.returners = self.returners
655     process_count_max = self.opts.get("process_count_max")
656     if process_count_max &gt; 0:
657         process_count = len(salt.utils.minion.running(self.opts))
658         while process_count &gt;= process_count_max:
659             log.warning(
660                 "Maximum number of processes reached while executing jid %s, waiting...",
661                 data["jid"],
662             )
663             yield salt.ext.tornado.gen.sleep(10)
664             process_count = len(salt.utils.minion.running(self.opts))
665     instance = self
666     multiprocessing_enabled = self.opts.get("multiprocessing", True)
667     name = "ProcessPayload(jid={})".format(data["jid"])
668     if multiprocessing_enabled:
669         if sys.platform.startswith("win"):
670             instance = None
671         with default_signals(signal.SIGINT, signal.SIGTERM):
672             process = SignalHandlingProcess(
673                 target=self._target,
674                 name=name,
675                 args=(instance, self.opts, data, self.connected),
676             )
677     else:
678         process = threading.Thread(
679             target=self._target,
680             args=(instance, self.opts, data, self.connected),
681             name=name,
682         )
683     if multiprocessing_enabled:
684         with default_signals(signal.SIGINT, signal.SIGTERM):
685             process.start()
686     else:
687         process.start()
688     self.subprocess_list.add(process)
689 def target_load(self, load):
690     if "tgt" not in load or "jid" not in load or "fun" not in load or "arg" not in load:
691         return False
692     if "tgt_type" in load:
693         match_func = self.matchers.get("{}_match.match".format(load["tgt_type"]), None)
694         if match_func is None:
695             return False
696         if load["tgt_type"] in ("grain", "grain_pcre", "pillar"):
697             delimiter = load.get("delimiter", DEFAULT_TARGET_DELIM)
698             if not match_func(load["tgt"], delimiter=delimiter):
699                 return False
700         elif not match_func(load["tgt"]):
701             return False
702     else:
703         if not self.matchers["glob_match.match"](load["tgt"]):
704             return False
705     return True
706 def tune_in(self, start=True):
707     super(ProxyMinion, self).tune_in(start=start)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>state_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import copy
2 import datetime
3 import fnmatch
4 import importlib
5 import logging
6 import os
7 import random
8 import re
9 import site
10 import sys
11 import time
12 import traceback
13 import salt.channel.client
14 import salt.fileclient
15 import salt.loader
16 import salt.minion
17 import salt.pillar
18 import salt.syspaths as syspaths
19 import salt.utils.args
20 import salt.utils.crypt
21 import salt.utils.data
22 import salt.utils.decorators.state
23 import salt.utils.dictupdate
24 import salt.utils.event
25 import salt.utils.files
26 import salt.utils.hashutils
27 import salt.utils.immutabletypes as immutabletypes
28 import salt.utils.msgpack
29 import salt.utils.platform
30 import salt.utils.process
31 import salt.utils.url
32 import salt.utils.yamlloader as yamlloader
33 from salt.exceptions import CommandExecutionError, SaltRenderError, SaltReqTimeoutError
34 from salt.serializers.msgpack import deserialize as msgpack_deserialize
35 from salt.serializers.msgpack import serialize as msgpack_serialize
36 from salt.template import compile_template, compile_template_str
37 from salt.utils.odict import DefaultOrderedDict, OrderedDict
38 log = logging.getLogger(</b></font>__name__)
39 STATE_REQUISITE_KEYWORDS = frozenset(
40     [
41         "onchanges",
42         "onchanges_any",
43         "onfail",
44         "onfail_any",
45         "onfail_all",
46         "onfail_stop",
47         "prereq",
48         "prerequired",
49         "watch",
50         "watch_any",
51         "require",
52         "require_any",
53         "listen",
54     ]
55 )
56 STATE_REQUISITE_IN_KEYWORDS = frozenset(
57     ["onchanges_in", "onfail_in", "prereq_in", "watch_in", "require_in", "listen_in"]
58 )
59 STATE_RUNTIME_KEYWORDS = frozenset(
60     [
61         "fun",
62         "state",
63         "check_cmd",
64         "failhard",
65         "onlyif",
66         "unless",
67         "creates",
68         "retry",
69         "order",
70         "parallel",
71         "prereq",
72         "prereq_in",
73         "prerequired",
74         "reload_modules",
75         "reload_grains",
76         "reload_pillar",
77         "runas",
78         "runas_password",
79         "fire_event",
80         "saltenv",
81         "use",
82         "use_in",
83         "__env__",
84         "__sls__",
85         "__id__",
86         "__orchestration_jid__",
87         "__pub_user",
88         "__pub_arg",
89         "__pub_jid",
90         "__pub_fun",
91         "__pub_tgt",
92         "__pub_ret",
93         "__pub_pid",
94         "__pub_tgt_type",
95         "__prereq__",
96         "__prerequired__",
97     ]
98 )
99 STATE_INTERNAL_KEYWORDS = STATE_REQUISITE_KEYWORDS.union(
100     STATE_REQUISITE_IN_KEYWORDS
101 ).union(STATE_RUNTIME_KEYWORDS)
102 def _odict_hashable(self):
103     return id(self)
104 OrderedDict.__hash__ = _odict_hashable
105 def split_low_tag(tag):
106     state, id_, name, fun = tag.split("_|-")
107     return {"state": state, "__id__": id_, "name": name, "fun": fun}
108 def _gen_tag(low):
109     return "{0[state]}_|-{0[__id__]}_|-{0[name]}_|-{0[fun]}".format(low)
110 def _clean_tag(tag):
111     return salt.utils.files.safe_filename_leaf(tag)
112 def _l_tag(name, id_):
113     low = {
114         "name": "listen_{}".format(name),
115         "__id__": "listen_{}".format(id_),
116         "state": "Listen_Error",
117         "fun": "Listen_Error",
118     }
119     return _gen_tag(low)
120 def _calculate_fake_duration():
121     utc_start_time = datetime.datetime.utcnow()
122     local_start_time = utc_start_time - (
123         datetime.datetime.utcnow() - datetime.datetime.now()
124     )
125     utc_finish_time = datetime.datetime.utcnow()
126     start_time = local_start_time.time().isoformat()
127     delta = utc_finish_time - utc_start_time
128     duration = (delta.seconds * 1000000 + delta.microseconds) / 1000.0
129     return start_time, duration
130 def get_accumulator_dir(cachedir):
131     fn_ = os.path.join(cachedir, "accumulator")
132     if not os.path.isdir(fn_):
133         os.makedirs(fn_)
134     return fn_
135 def trim_req(req):
136     reqfirst = next(iter(req))
137     if "." in reqfirst:
138         return {reqfirst.split(".")[0]: req[reqfirst]}
139     return req
140 def state_args(id_, state, high):
141     args = set()
142     if id_ not in high:
143         return args
144     if state not in high[id_]:
145         return args
146     for item in high[id_][state]:
147         if not isinstance(item, dict):
148             continue
149         if len(item) != 1:
150             continue
151         args.add(next(iter(item)))
152     return args
153 def find_name(name, state, high, strict=False):
154     ext_id = []
155     if strict is False:
156         check2 = True
157     else:
158         check2 = state in high.get(name, {})
159     if name in high and check2:
160         ext_id.append((name, state))
161     elif state == "sls":
162         for nid, item in high.items():
163             if item["__sls__"] == name:
164                 ext_id.append((nid, next(iter(item))))
165     else:
166         for nid in high:
167             if state in high[nid]:
168                 if isinstance(high[nid][state], list):
169                     for arg in high[nid][state]:
170                         if not isinstance(arg, dict):
171                             continue
172                         if len(arg) != 1:
173                             continue
174                         if arg[next(iter(arg))] == name:
175                             ext_id.append((nid, state))
176     return ext_id
177 def find_sls_ids(sls, high):
178     ret = []
179     for nid, item in high.items():
180         try:
181             sls_tgt = item["__sls__"]
182         except TypeError:
183             if nid != "__exclude__":
184                 log.error(
185                     "Invalid non-dict item '%s' in high data. Value: %r", nid, item
186                 )
187             continue
188         else:
189             if sls_tgt == sls:
190                 for st_ in item:
191                     if st_.startswith("__"):
192                         continue
193                     ret.append((nid, st_))
194     return ret
195 def format_log(ret):
196     msg = ""
197     if isinstance(ret, dict):
198         if "changes" in ret:
199             chg = ret["changes"]
200             if not chg:
201                 if ret["comment"]:
202                     msg = ret["comment"]
203                 else:
204                     msg = "No changes made for {0[name]}".format(ret)
205             elif isinstance(chg, dict):
206                 if "diff" in chg:
207                     if isinstance(chg["diff"], str):
208                         msg = "File changed:\n{}".format(chg["diff"])
209                 if all([isinstance(x, dict) for x in chg.values()]):
210                     if all([("old" in x and "new" in x) for x in chg.values()]):
211                         msg = "Made the following changes:\n"
212                         for pkg in chg:
213                             old = chg[pkg]["old"]
214                             if not old and old not in (False, None):
215                                 old = "absent"
216                             new = chg[pkg]["new"]
217                             if not new and new not in (False, None):
218                                 new = "absent"
219                             msg += "'{}' changed from '{}' to '{}'\n".format(
220                                 pkg, old, new
221                             )
222             if not msg:
223                 msg = str(ret["changes"])
224             if ret["result"] is True or ret["result"] is None:
225                 log.info(msg)
226             else:
227                 log.error(msg)
228     else:
229         log.info(str(ret))
230 def master_compile(master_opts, minion_opts, grains, id_, saltenv):
231     st_ = MasterHighState(master_opts, minion_opts, grains, id_, saltenv)
232     return st_.compile_highstate()
233 def ishashable(obj):
234     try:
235         hash(obj)
236     except TypeError:
237         return False
238     return True
239 def mock_ret(cdata):
240     if cdata["args"]:
241         name = cdata["args"][0]
242     else:
243         name = cdata["kwargs"]["name"]
244     return {
245         "name": name,
246         "comment": "Not called, mocked",
247         "changes": {},
248         "result": True,
249     }
250 class StateError(Exception):
251 class Compiler:
252     def __init__(self, opts, renderers):
253         self.opts = opts
254         self.rend = renderers
255     def render_template(self, template, **kwargs):
256         high = compile_template(
257             template,
258             self.rend,
259             self.opts["renderer"],
260             self.opts["renderer_blacklist"],
261             self.opts["renderer_whitelist"],
262             **kwargs
263         )
264         if not high:
265             return high
266         return self.pad_funcs(high)
267     def pad_funcs(self, high):
268         for name in high:
269             if not isinstance(high[name], dict):
270                 if isinstance(high[name], str):
271                     if "." in high[name]:
272                         comps = high[name].split(".")
273                         if len(comps) &gt;= 2:
274                             comps[1] = ".".join(comps[1 : len(comps)])
275                         high[name] = {
276                             comps[0]: [comps[1]]
277                         }
278                         continue
279                     continue
280             skeys = set()
281             for key in sorted(high[name]):
282                 if key.startswith("_"):
283                     continue
284                 if not isinstance(high[name][key], list):
285                     continue
286                 if "." in key:
287                     comps = key.split(".")
288                     if len(comps) &gt;= 2:
289                         comps[1] = ".".join(comps[1 : len(comps)])
290                     if comps[0] in skeys:
291                         continue
292                     high[name][comps[0]] = high[name].pop(key)
293                     high[name][comps[0]].append(comps[1])
294                     skeys.add(comps[0])
295                     continue
296                 skeys.add(key)
297         return high
298     def verify_high(self, high):
299         errors = []
300         if not isinstance(high, dict):
301             errors.append("High data is not a dictionary and is invalid")
302         reqs = OrderedDict()
303         for name, body in high.items():
304             if name.startswith("__"):
305                 continue
306             if not isinstance(name, str):
307                 errors.append(
308                     "ID '{}' in SLS '{}' is not formed as a string, but is a {}".format(
309                         name, body["__sls__"], type(name).__name__
310                     )
311                 )
312             if not isinstance(body, dict):
313                 err = "The type {} in {} is not formatted as a dictionary".format(
314                     name, body
315                 )
316                 errors.append(err)
317                 continue
318             for state in body:
319                 if state.startswith("__"):
320                     continue
321                 if not isinstance(body[state], list):
322                     errors.append(
323                         "State '{}' in SLS '{}' is not formed as a list".format(
324                             name, body["__sls__"]
325                         )
326                     )
327                 else:
328                     fun = 0
329                     if "." in state:
330                         fun += 1
331                     for arg in body[state]:
332                         if isinstance(arg, str):
333                             fun += 1
334                             if " " in arg.strip():
335                                 errors.append(
336                                     'The function "{}" in state '
337                                     '"{}" in SLS "{}" has '
338                                     "whitespace, a function with whitespace is "
339                                     "not supported, perhaps this is an argument "
340                                     'that is missing a ":"'.format(
341                                         arg, name, body["__sls__"]
342                                     )
343                                 )
344                         elif isinstance(arg, dict):
345                             argfirst = next(iter(arg))
346                             if argfirst in ("require", "watch", "prereq", "onchanges"):
347                                 if not isinstance(arg[argfirst], list):
348                                     errors.append(
349                                         "The {} statement in state '{}' in SLS '{}' "
350                                         "needs to be formed as a list".format(
351                                             argfirst, name, body["__sls__"]
352                                         )
353                                     )
354                                 else:
355                                     reqs[name] = {"state": state}
356                                     for req in arg[argfirst]:
357                                         if isinstance(req, str):
358                                             req = {"id": req}
359                                         if not isinstance(req, dict):
360                                             errors.append(
361                                                 "Requisite declaration {} in SLS {} "
362                                                 "is not formed as a single key "
363                                                 "dictionary".format(
364                                                     req, body["__sls__"]
365                                                 )
366                                             )
367                                             continue
368                                         req_key = next(iter(req))
369                                         req_val = req[req_key]
370                                         if "." in req_key:
371                                             errors.append(
372                                                 "Invalid requisite type '{}' "
373                                                 "in state '{}', in SLS "
374                                                 "'{}'. Requisite types must "
375                                                 "not contain dots, did you "
376                                                 "mean '{}'?".format(
377                                                     req_key,
378                                                     name,
379                                                     body["__sls__"],
380                                                     req_key[: req_key.find(".")],
381                                                 )
382                                             )
383                                         if not ishashable(req_val):
384                                             errors.append(
385                                                 'Illegal requisite "{}", is SLS {}\n'.format(
386                                                     str(req_val),
387                                                     body["__sls__"],
388                                                 )
389                                             )
390                                             continue
391                                         reqs[name][req_val] = req_key
392                                         if req_val in reqs:
393                                             if name in reqs[req_val]:
394                                                 if reqs[req_val][name] == state:
395                                                     if (
396                                                         reqs[req_val]["state"]
397                                                         == reqs[name][req_val]
398                                                     ):
399                                                         errors.append(
400                                                             "A recursive requisite was"
401                                                             ' found, SLS "{}" ID "{}"'
402                                                             ' ID "{}"'.format(
403                                                                 body["__sls__"],
404                                                                 name,
405                                                                 req_val,
406                                                             )
407                                                         )
408                                 if len(list(arg)) != 1:
409                                     errors.append(
410                                         "Multiple dictionaries defined in argument "
411                                         "of state '{}' in SLS '{}'".format(
412                                             name, body["__sls__"]
413                                         )
414                                     )
415                     if not fun:
416                         if state == "require" or state == "watch":
417                             continue
418                         errors.append(
419                             "No function declared in state '{}' in SLS '{}'".format(
420                                 state, body["__sls__"]
421                             )
422                         )
423                     elif fun &gt; 1:
424                         errors.append(
425                             "Too many functions declared in state '{}' in "
426                             "SLS '{}'".format(state, body["__sls__"])
427                         )
428         return errors
429     def order_chunks(self, chunks):
430         cap = 1
431         for chunk in chunks:
432             if "order" in chunk:
433                 if not isinstance(chunk["order"], int):
434                     continue
435                 chunk_order = chunk["order"]
436                 if chunk_order &gt; cap - 1 and chunk_order &gt; 0:
437                     cap = chunk_order + 100
438         for chunk in chunks:
439             if "order" not in chunk:
440                 chunk["order"] = cap
441                 continue
442             if not isinstance(chunk["order"], (int, float)):
443                 if chunk["order"] == "last":
444                     chunk["order"] = cap + 1000000
445                 elif chunk["order"] == "first":
446                     chunk["order"] = 0
447                 else:
448                     chunk["order"] = cap
449             if "name_order" in chunk:
450                 chunk["order"] = chunk["order"] + chunk.pop("name_order") / 10000.0
451             if chunk["order"] &lt; 0:
452                 chunk["order"] = cap + 1000000 + chunk["order"]
453             chunk["name"] = salt.utils.data.decode(chunk["name"])
454         chunks.sort(
455             key=lambda chunk: (
456                 chunk["order"],
457                 "{0[state]}{0[name]}{0[fun]}".format(chunk),
458             )
459         )
460         return chunks
461     def compile_high_data(self, high):
462         chunks = []
463         for name, body in high.items():
464             if name.startswith("__"):
465                 continue
466             for state, run in body.items():
467                 funcs = set()
468 <a name="5"></a>                names = []
469                 if state.startswith("__"):
470                     continue
471                 chunk = {<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"state": state, "name": name}
472                 if "__sls__" in body:
473                     chunk["__sls__"] = body["__sls__"]
474                 if "__env__" in body:
475                     chunk["__env__"] = body["__env__"]
476                 chunk["__id__"] =</b></font> name
477                 for arg in run:
478                     if isinstance(arg, str):
479                         funcs.add(arg)
480                         continue
481                     if isinstance(arg, dict):
482                         for key, val in arg.items():
483                             if key == "names":
484                                 for _name in val:
485                                     if _name not in names:
486                                         names.append(_name)
487                                 continue
488                             else:
489                                 chunk.update(arg)
490                 if names:
491                     name_order = 1
492                     for entry in names:
493                         live = copy.deepcopy(chunk)
494                         if isinstance(entry, dict):
495                             low_name = next(iter(entry.keys()))
496                             live["name"] = low_name
497                             list(map(live.update, entry[low_name]))
498                         else:
499                             live["name"] = entry
500                         live["name_order"] = name_order
501                         name_order = name_order + 1
502                         for fun in funcs:
503                             live["fun"] = fun
504                             chunks.append(live)
505                 else:
506                     live = copy.deepcopy(chunk)
507                     for fun in funcs:
508                         live["fun"] = fun
509                         chunks.append(live)
510         chunks = self.order_chunks(chunks)
511         return chunks
512     def apply_exclude(self, high):
513         if "__exclude__" not in high:
514             return high
515         ex_sls = set()
516         ex_id = set()
517         exclude = high.pop("__exclude__")
518         for exc in exclude:
519             if isinstance(exc, str):
520                 ex_sls.add(exc)
521             if isinstance(exc, dict):
522                 if len(exc) != 1:
523                     continue
524                 key = next(iter(exc.keys()))
525                 if key == "sls":
526                     ex_sls.add(exc["sls"])
527                 elif key == "id":
528                     ex_id.add(exc["id"])
529         if ex_sls:
530             for name, body in high.items():
531                 if name.startswith("__"):
532                     continue
533                 if body.get("__sls__", "") in ex_sls:
534                     ex_id.add(name)
535         for id_ in ex_id:
536             if id_ in high:
537                 high.pop(id_)
538         return high
539 class State:
540     def __init__(
541         self,
542         opts,
543         pillar_override=None,
544         jid=None,
545         pillar_enc=None,
546         proxy=None,
547         context=None,
548         mocked=False,
549         loader="states",
550         initial_pillar=None,
551     ):
552         self.states_loader = loader
553         if "grains" not in opts:
554             opts["grains"] = salt.loader.grains(opts)
555         self.opts = opts
556         self.proxy = proxy
557         self._pillar_override = pillar_override
558         if pillar_enc is not None:
559             try:
560                 pillar_enc = pillar_enc.lower()
561             except AttributeError:
562                 pillar_enc = str(pillar_enc).lower()
563         self._pillar_enc = pillar_enc
564         log.debug("Gathering pillar data for state run")
565         if initial_pillar and not self._pillar_override:
566             self.opts["pillar"] = initial_pillar
567         else:
568             self.opts["pillar"] = self._gather_pillar()
569             if self._pillar_override:
570                 self.opts["pillar"] = salt.utils.dictupdate.merge(
571                     self.opts["pillar"],
572                     self._pillar_override,
573                     self.opts.get("pillar_source_merging_strategy", "smart"),
574                     self.opts.get("renderer", "yaml"),
575                     self.opts.get("pillar_merge_lists", False),
576                 )
577         log.debug("Finished gathering pillar data for state run")
578         self.state_con = context or {}
579         self.load_modules()
580         self.active = set()
581         self.mod_init = set()
582         self.pre = {}
583         self.__run_num = 0
584         self.jid = jid
585         self.instance_id = str(id(self))
586         self.inject_globals = {}
587         self.mocked = mocked
588     def _gather_pillar(self):
589         if self._pillar_override:
590             if self._pillar_enc:
591                 try:
592                     self._pillar_override = salt.utils.crypt.decrypt(
593                         self._pillar_override,
594                         self._pillar_enc,
595                         translate_newlines=True,
596                         renderers=getattr(self, "rend", None),
597                         opts=self.opts,
598                         valid_rend=self.opts["decrypt_pillar_renderers"],
599                     )
600                 except Exception as exc:  # pylint: disable=broad-except
601                     log.error("Failed to decrypt pillar override: %s", exc)
602             if isinstance(self._pillar_override, str):
603                 try:
604                     self._pillar_override = yamlloader.load(
605                         self._pillar_override, Loader=yamlloader.SaltYamlSafeLoader
606                     )
607                 except Exception as exc:  # pylint: disable=broad-except
608                     log.error("Failed to load CLI pillar override")
609                     log.exception(exc)
610             if not isinstance(self._pillar_override, dict):
611                 log.error("Pillar override was not passed as a dictionary")
612                 self._pillar_override = None
613         pillar = salt.pillar.get_pillar(
614             self.opts,
615             self.opts["grains"],
616             self.opts["id"],
617             self.opts["saltenv"],
618             pillar_override=self._pillar_override,
619             pillarenv=self.opts.get("pillarenv"),
620         )
621         return pillar.compile_pillar()
622     def _mod_init(self, low):
623         try:
624             self.states[
625                 "{}.{}".format(low["state"], low["fun"])
626             ]  # pylint: disable=W0106
627         except KeyError:
628             return
629         minit = "{}.mod_init".format(low["state"])
630         if low["state"] not in self.mod_init:
631             if minit in self.states._dict:
632                 mret = self.states[minit](low)
633                 if not mret:
634                     return
635                 self.mod_init.add(low["state"])
636     def _aggregate_requisites(self, low, chunks):
637         requisites = {}
638         low_state = low["state"]
639         for chunk in chunks:
640             if chunk["state"] == low["state"] and chunk.get("__agg__"):
641                 for req in frozenset.union(
642                     *[STATE_REQUISITE_KEYWORDS, STATE_REQUISITE_IN_KEYWORDS]
643                 ):
644                     if req in chunk:
645                         if req in requisites:
646                             requisites[req].extend(chunk[req])
647                         else:
648                             requisites[req] = chunk[req]
649         low.update(requisites)
650         return low
651     def _mod_aggregate(self, low, running, chunks):
652         agg_opt = self.functions["config.option"]("state_aggregate")
653         if "aggregate" in low:
654             agg_opt = low["aggregate"]
655         if agg_opt is True:
656             agg_opt = [low["state"]]
657         elif not isinstance(agg_opt, list):
658             return low
659         if low["state"] in agg_opt and not low.get("__agg__"):
660             agg_fun = "{}.mod_aggregate".format(low["state"])
661             if agg_fun in self.states:
662                 try:
663                     low = self.states[agg_fun](low, chunks, running)
664                     low = self._aggregate_requisites(low, chunks)
665                     low["__agg__"] = True
666                 except TypeError:
667                     log.error("Failed to execute aggregate for state %s", low["state"])
668         return low
669     def _run_check(self, low_data):
670         ret = {"result": False, "comment": []}
671         cmd_opts = {}
672         POSSIBLE_CMD_ARGS = (
673             "cwd",
674             "root",
675             "runas",
676             "env",
677             "prepend_path",
678             "umask",
679             "timeout",
680             "success_retcodes",
681         )
682         for run_cmd_arg in POSSIBLE_CMD_ARGS:
683             cmd_opts[run_cmd_arg] = low_data.get(run_cmd_arg)
684         if "shell" in low_data:
685             cmd_opts["shell"] = low_data["shell"]
686         elif "shell" in self.opts["grains"]:
687             cmd_opts["shell"] = self.opts["grains"].get("shell")
688         if "onlyif" in low_data:
689             _ret = self._run_check_onlyif(low_data, cmd_opts)
690             ret["result"] = _ret["result"]
691             ret["comment"].append(_ret["comment"])
692             if "skip_watch" in _ret:
693                 ret["skip_watch"] = _ret["skip_watch"]
694         if "unless" in low_data:
695             _ret = self._run_check_unless(low_data, cmd_opts)
696             ret["result"] = _ret["result"] or ret["result"]
697             ret["comment"].append(_ret["comment"])
698             if "skip_watch" in _ret:
699                 ret["skip_watch"] = _ret["skip_watch"] or ret["skip_watch"]
700         if "creates" in low_data:
701             _ret = self._run_check_creates(low_data)
702             ret["result"] = _ret["result"] or ret["result"]
703             ret["comment"].append(_ret["comment"])
704             if "skip_watch" in _ret:
705                 ret["skip_watch"] = _ret["skip_watch"] or ret["skip_watch"]
706         return ret
707     def _run_check_function(self, entry):
708         fun = entry.pop("fun")
709         args = entry.pop("args") if "args" in entry else []
710         cdata = {"args": args, "kwargs": entry}
711         self.format_slots(cdata)
712         return self.functions[fun](*cdata["args"], **cdata["kwargs"])
713     def _run_check_onlyif(self, low_data, cmd_opts):
714         ret = {"result": False}
715         if not isinstance(low_data["onlyif"], list):
716             low_data_onlyif = [low_data["onlyif"]]
717         else:
718             low_data_onlyif = low_data["onlyif"]
719         def _check_cmd(cmd):
720             if cmd != 0 and ret["result"] is False:
721                 ret.update(
722                     {
723                         "comment": "onlyif condition is false",
724                         "skip_watch": True,
725                         "result": True,
726                     }
727                 )
728                 return False
729             elif cmd == 0:
730                 ret.update({"comment": "onlyif condition is true", "result": False})
731             return True
732         for entry in low_data_onlyif:
733             if isinstance(entry, str):
734                 try:
735                     cmd = self.functions["cmd.retcode"](
736                         entry, ignore_retcode=True, python_shell=True, **cmd_opts
737                     )
738                 except CommandExecutionError:
739                     cmd = 100
740                 log.debug("Last command return code: %s", cmd)
741                 if not _check_cmd(cmd):
742                     return ret
743             elif isinstance(entry, dict):
744                 if "fun" not in entry:
745                     ret["comment"] = "no `fun` argument in onlyif: {}".format(entry)
746                     log.warning(ret["comment"])
747                     return ret
748                 get_return = entry.pop("get_return", None)
749                 result = self._run_check_function(entry)
750                 if get_return:
751                     result = salt.utils.data.traverse_dict_and_list(result, get_return)
752                 if self.state_con.get("retcode", 0):
753                     if not _check_cmd(self.state_con["retcode"]):
754                         return ret
755                 elif not result:
756                     ret.update(
757                         {
758                             "comment": "onlyif condition is false",
759                             "skip_watch": True,
760                             "result": True,
761                         }
762                     )
763                     return ret
764                 else:
765                     ret.update({"comment": "onlyif condition is true", "result": False})
766             else:
767                 ret.update(
768                     {
769                         "comment": "onlyif execution failed, bad type passed",
770                         "result": False,
771                     }
772                 )
773                 return ret
774         return ret
775     def _run_check_unless(self, low_data, cmd_opts):
776         ret = {"result": False}
777         if not isinstance(low_data["unless"], list):
778             low_data_unless = [low_data["unless"]]
779         else:
780             low_data_unless = low_data["unless"]
781         def _check_cmd(cmd):
782             if cmd == 0:
783                 ret.update(
784                     {
785                         "comment": "unless condition is true",
786                         "skip_watch": True,
787                         "result": True,
788                     }
789                 )
790                 return False
791             else:
792                 ret.pop("skip_watch", None)
793                 ret.update({"comment": "unless condition is false", "result": False})
794                 return True
795         for entry in low_data_unless:
796             if isinstance(entry, str):
797                 try:
798                     cmd = self.functions["cmd.retcode"](
799                         entry, ignore_retcode=True, python_shell=True, **cmd_opts
800                     )
801                     log.debug("Last command return code: %s", cmd)
802                 except CommandExecutionError:
803                     cmd = 0
804                 if _check_cmd(cmd):
805                     return ret
806             elif isinstance(entry, dict):
807                 if "fun" not in entry:
808                     ret["comment"] = "no `fun` argument in unless: {}".format(entry)
809                     log.warning(ret["comment"])
810                     return ret
811                 get_return = entry.pop("get_return", None)
812                 result = self._run_check_function(entry)
813                 if get_return:
814                     result = salt.utils.data.traverse_dict_and_list(result, get_return)
815                 if self.state_con.get("retcode", 0):
816                     if _check_cmd(self.state_con["retcode"]):
817                         return ret
818                 elif result:
819                     ret.update(
820                         {
821                             "comment": "unless condition is true",
822                             "skip_watch": True,
823                             "result": True,
824                         }
825                     )
826                 else:
827                     ret.update(
828                         {"comment": "unless condition is false", "result": False}
829                     )
830                     return ret
831             else:
832                 ret.update(
833                     {
834                         "comment": "unless condition is false, bad type passed",
835                         "result": False,
836                     }
837                 )
838         return ret
839     def _run_check_cmd(self, low_data):
840         ret = {"result": False}
841         cmd_opts = {}
842         if "shell" in self.opts["grains"]:
843             cmd_opts["shell"] = self.opts["grains"].get("shell")
844         for entry in low_data["check_cmd"]:
845             cmd = self.functions["cmd.retcode"](
846                 entry, ignore_retcode=True, python_shell=True, **cmd_opts
847             )
848             log.debug("Last command return code: %s", cmd)
849             if cmd == 0 and ret["result"] is False:
850                 ret.update(
851                     {
852                         "comment": "check_cmd determined the state succeeded",
853                         "result": True,
854                     }
855                 )
856             elif cmd != 0:
857                 ret.update(
858                     {
859                         "comment": "check_cmd determined the state failed",
860                         "result": False,
861                     }
862                 )
863                 return ret
864         return ret
865     def _run_check_creates(self, low_data):
866         ret = {"result": False}
867         if isinstance(low_data["creates"], str) and os.path.exists(low_data["creates"]):
868             ret["comment"] = "{} exists".format(low_data["creates"])
869             ret["result"] = True
870             ret["skip_watch"] = True
871         elif isinstance(low_data["creates"], list) and all(
872             [os.path.exists(path) for path in low_data["creates"]]
873         ):
874             ret["comment"] = "All files in creates exist"
875             ret["result"] = True
876             ret["skip_watch"] = True
877         else:
878             ret["comment"] = "Creates files not found"
879             ret["result"] = False
880         return ret
881     def reset_run_num(self):
882         self.__run_num = 0
883     def _load_states(self):
884         if self.states_loader == "thorium":
885             self.states <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= salt.loader.thorium(
886                 self.opts, self.functions, {}
887             )  # TODO: Add runners, proxy?
888         else:
889             self.states = salt.loader.states(
890                 self.</b></font>opts,
891                 self.functions,
892                 self.utils,
893                 self.serializers,
894                 context=self.state_con,
895 <a name="1"></a>                proxy=self.proxy,
896             )
897     def load_modules(self, data=None, proxy<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None):
898         log.info("Loading fresh modules for state activity")
899         self.utils = salt.loader.utils(self.opts)
900         self.functions = salt.loader.minion_mods(
901             self.opts, self.state_con, utils=self.</b></font>utils, proxy=self.proxy
902         )
903         if isinstance(data, dict):
904             if data.get("provider", False):
905                 if isinstance(data["provider"], str):
906                     providers = [{data["state"]: data["provider"]}]
907                 elif isinstance(data["provider"], list):
908                     providers = data["provider"]
909                 else:
910                     providers = {}
911                 for provider in providers:
912                     for mod in provider:
913                         funcs = salt.loader.raw_mod(
914                             self.opts, provider[mod], self.functions
915                         )
916                         if funcs:
917                             for func in funcs:
918                                 f_key = "{}{}".format(mod, func[func.rindex(".") :])
919                                 self.functions[f_key] = funcs[func]
920         self.serializers = salt.loader.serializers(self.opts)
921         self._load_states()
922         self.rend = salt.loader.render(
923             self.opts,
924             self.functions,
925             states=self.states,
926             proxy=self.proxy,
927             context=self.state_con,
928         )
929     def module_refresh(self):
930         log.debug("Refreshing modules...")
931         if self.opts["grains"].get("os") != "MacOS":
932             try:
933                 importlib.reload(site)
934             except RuntimeError:
935                 log.error(
936                     "Error encountered during module reload. Modules were not reloaded."
937                 )
938             except TypeError:
939                 log.error(
940                     "Error encountered during module reload. Modules were not reloaded."
941                 )
942         self.load_modules()
943         if not self.opts.get("local", False) and self.opts.get("multiprocessing", True):
944             self.functions["saltutil.refresh_modules"]()
945     def check_refresh(self, data, ret):
946         _reload_modules = False
947         if data.get("reload_grains", False):
948             log.debug("Refreshing grains...")
949             self.opts["grains"] = salt.loader.grains(self.opts)
950             _reload_modules = True
951         if data.get("reload_pillar", False):
952             log.debug("Refreshing pillar...")
953             self.opts["pillar"] = self._gather_pillar()
954             _reload_modules = True
955         if not ret["changes"]:
956             if data.get("force_reload_modules", False):
957                 self.module_refresh()
958             return
959         if data.get("reload_modules", False) or _reload_modules:
960             self.module_refresh()
961             return
962         if data["state"] == "file":
963             if data["fun"] == "managed":
964                 if data["name"].endswith((".py", ".pyx", ".pyo", ".pyc", ".so")):
965                     self.module_refresh()
966             elif data["fun"] == "recurse":
967                 self.module_refresh()
968             elif data["fun"] == "symlink":
969                 if "bin" in data["name"]:
970                     self.module_refresh()
971         elif data["state"] in ("pkg", "ports", "pip"):
972             self.module_refresh()
973     def verify_data(self, data):
974         errors = []
975         if "state" not in data:
976             errors.append('Missing "state" data')
977         if "fun" not in data:
978             errors.append('Missing "fun" data')
979         if "name" not in data:
980             errors.append('Missing "name" data')
981         if data["name"] and not isinstance(data["name"], str):
982             errors.append(
983                 "ID '{}' {}is not formed as a string, but is a {}".format(
984                     data["name"],
985                     "in SLS '{}' ".format(data["__sls__"]) if "__sls__" in data else "",
986                     type(data["name"]).__name__,
987                 )
988             )
989         if errors:
990             return errors
991         full = data["state"] + "." + data["fun"]
992         if full not in self.states:
993             if "__sls__" in data:
994                 errors.append(
995                     "State '{}' was not found in SLS '{}'".format(full, data["__sls__"])
996                 )
997                 reason = self.states.missing_fun_string(full)
998                 if reason:
999                     errors.append("Reason: {}".format(reason))
1000             else:
1001                 errors.append("Specified state '{}' was not found".format(full))
1002         else:
1003             aspec = salt.utils.args.get_function_argspec(self.states[full])
1004             arglen = 0
1005             deflen = 0
1006             if isinstance(aspec.args, list):
1007                 arglen = len(aspec.args)
1008             if isinstance(aspec.defaults, tuple):
1009                 deflen = len(aspec.defaults)
1010             for ind in range(arglen - deflen):
1011                 if aspec.args[ind] not in data:
1012                     errors.append(
1013                         "Missing parameter {} for state {}".format(
1014                             aspec.args[ind], full
1015                         )
1016                     )
1017         reqdec = ""
1018         if "require" in data:
1019             reqdec = "require"
1020         if "watch" in data:
1021             if "{}.mod_watch".format(data["state"]) not in self.states:
1022                 if "require" in data:
1023                     data["require"].extend(data.pop("watch"))
1024                 else:
1025                     data["require"] = data.pop("watch")
1026                 reqdec = "require"
1027             else:
1028                 reqdec = "watch"
1029         if reqdec:
1030             for req in data[reqdec]:
1031                 reqfirst = next(iter(req))
1032                 if data["state"] == reqfirst:
1033                     if fnmatch.fnmatch(data["name"], req[reqfirst]) or fnmatch.fnmatch(
1034                         data["__id__"], req[reqfirst]
1035                     ):
1036                         errors.append(
1037                             "Recursive require detected in SLS {} for "
1038                             "require {} in ID {}".format(
1039                                 data["__sls__"], req, data["__id__"]
1040                             )
1041                         )
1042         return errors
1043     def verify_high(self, high):
1044         errors = []
1045         if not isinstance(high, dict):
1046             errors.append("High data is not a dictionary and is invalid")
1047         reqs = OrderedDict()
1048         for name, body in high.items():
1049             try:
1050                 if name.startswith("__"):
1051                     continue
1052             except AttributeError:
1053                 pass
1054             if not isinstance(name, str):
1055                 errors.append(
1056                     "ID '{}' in SLS '{}' is not formed as a string, but "
1057                     "is a {}. It may need to be quoted.".format(
1058                         name, body["__sls__"], type(name).__name__
1059                     )
1060                 )
1061             if not isinstance(body, dict):
1062                 err = "The type {} in {} is not formatted as a dictionary".format(
1063                     name, body
1064                 )
1065                 errors.append(err)
1066                 continue
1067             for state in body:
1068                 if state.startswith("__"):
1069                     continue
1070                 if body[state] is None:
1071                     errors.append(
1072                         "ID '{}' in SLS '{}' contains a short declaration "
1073                         "({}) with a trailing colon. When not passing any "
1074                         "arguments to a state, the colon must be omitted.".format(
1075                             name, body["__sls__"], state
1076                         )
1077                     )
1078                     continue
1079                 if not isinstance(body[state], list):
1080                     errors.append(
1081                         "State '{}' in SLS '{}' is not formed as a list".format(
1082                             name, body["__sls__"]
1083                         )
1084                     )
1085                 else:
1086                     fun = 0
1087                     if "." in state:
1088                         fun += 1
1089                     for arg in body[state]:
1090                         if isinstance(arg, str):
1091                             fun += 1
1092                             if " " in arg.strip():
1093                                 errors.append(
1094                                     'The function "{}" in state "{}" in SLS "{}" has '
1095                                     "whitespace, a function with whitespace is not "
1096                                     "supported, perhaps this is an argument that is "
1097                                     'missing a ":"'.format(arg, name, body["__sls__"])
1098                                 )
1099                         elif isinstance(arg, dict):
1100                             argfirst = next(iter(arg))
1101                             if argfirst == "names":
1102                                 if not isinstance(arg[argfirst], list):
1103                                     errors.append(
1104                                         "The 'names' argument in state "
1105                                         "'{}' in SLS '{}' needs to be "
1106                                         "formed as a list".format(name, body["__sls__"])
1107                                     )
1108                             if argfirst in ("require", "watch", "prereq", "onchanges"):
1109                                 if not isinstance(arg[argfirst], list):
1110                                     errors.append(
1111                                         "The {} statement in state '{}' in "
1112                                         "SLS '{}' needs to be formed as a "
1113                                         "list".format(argfirst, name, body["__sls__"])
1114                                     )
1115                                 else:
1116                                     reqs[name] = OrderedDict(state=state)
1117                                     for req in arg[argfirst]:
1118                                         if isinstance(req, str):
1119                                             req = {"id": req}
1120                                         if not isinstance(req, dict):
1121                                             errors.append(
1122                                                 "Requisite declaration {} in SLS {} is"
1123                                                 " not formed as a single key dictionary".format(
1124                                                     req, body["__sls__"]
1125                                                 )
1126                                             )
1127                                             continue
1128                                         req_key = next(iter(req))
1129                                         req_val = req[req_key]
1130                                         if "." in req_key:
1131                                             errors.append(
1132                                                 "Invalid requisite type '{}' "
1133                                                 "in state '{}', in SLS "
1134                                                 "'{}'. Requisite types must "
1135                                                 "not contain dots, did you "
1136                                                 "mean '{}'?".format(
1137                                                     req_key,
1138                                                     name,
1139                                                     body["__sls__"],
1140                                                     req_key[: req_key.find(".")],
1141                                                 )
1142                                             )
1143                                         if not ishashable(req_val):
1144                                             errors.append(
1145                                                 'Illegal requisite "{}", please check '
1146                                                 "your syntax.\n".format(req_val)
1147                                             )
1148                                             continue
1149                                         reqs[name][req_val] = req_key
1150                                         if req_val in reqs:
1151                                             if name in reqs[req_val]:
1152                                                 if reqs[req_val][name] == state:
1153                                                     if (
1154                                                         reqs[req_val]["state"]
1155                                                         == reqs[name][req_val]
1156                                                     ):
1157                                                         errors.append(
1158                                                             "A recursive requisite was"
1159                                                             ' found, SLS "{}" ID "{}"'
1160                                                             ' ID "{}"'.format(
1161                                                                 body["__sls__"],
1162                                                                 name,
1163                                                                 req_val,
1164                                                             )
1165                                                         )
1166                                 if len(list(arg)) != 1:
1167                                     errors.append(
1168                                         "Multiple dictionaries defined in "
1169                                         "argument of state '{}' in SLS '{}'".format(
1170                                             name, body["__sls__"]
1171                                         )
1172                                     )
1173                     if not fun:
1174                         if state == "require" or state == "watch":
1175                             continue
1176                         errors.append(
1177                             "No function declared in state '{}' in SLS '{}'".format(
1178                                 state, body["__sls__"]
1179                             )
1180                         )
1181                     elif fun &gt; 1:
1182                         errors.append(
1183                             "Too many functions declared in state '{}' in "
1184                             "SLS '{}'".format(state, body["__sls__"])
1185                         )
1186         return errors
1187     def verify_chunks(self, chunks):
1188         err = []
1189         for chunk in chunks:
1190             err.extend(self.verify_data(chunk))
1191         return err
1192     def order_chunks(self, chunks):
1193         cap = 1
1194         for chunk in chunks:
1195             if "order" in chunk:
1196                 if not isinstance(chunk["order"], int):
1197                     continue
1198                 chunk_order = chunk["order"]
1199                 if chunk_order &gt; cap - 1 and chunk_order &gt; 0:
1200                     cap = chunk_order + 100
1201         for chunk in chunks:
1202             if "order" not in chunk:
1203                 chunk["order"] = cap
1204                 continue
1205             if not isinstance(chunk["order"], (int, float)):
1206                 if chunk["order"] == "last":
1207                     chunk["order"] = cap + 1000000
1208                 elif chunk["order"] == "first":
1209                     chunk["order"] = 0
1210                 else:
1211                     chunk["order"] = cap
1212             if "name_order" in chunk:
1213                 chunk["order"] = chunk["order"] + chunk.pop("name_order") / 10000.0
1214             if chunk["order"] &lt; 0:
1215                 chunk["order"] = cap + 1000000 + chunk["order"]
1216         chunks.sort(
1217             key=lambda chunk: (
1218                 chunk["order"],
1219                 "{0[state]}{0[name]}{0[fun]}".format(chunk),
1220             )
1221         )
1222         return chunks
1223     def compile_high_data(self, high, orchestration_jid=None):
1224         chunks = []
1225         for name, body in high.items():
1226             if name.startswith("__"):
1227                 continue
1228             for state, run in body.items():
1229                 funcs = set()
1230                 names = []
1231                 if state.startswith("__"):
1232                     continue
1233                 chunk = {"state": state, "name": name}
1234                 if orchestration_jid is not None:
1235                     chunk["__orchestration_jid__"] = orchestration_jid
1236                 if "__sls__" in body:
1237                     chunk["__sls__"] = body["__sls__"]
1238                 if "__env__" in body:
1239                     chunk["__env__"] = body["__env__"]
1240                 chunk["__id__"] = name
1241                 for arg in run:
1242                     if isinstance(arg, str):
1243                         funcs.add(arg)
1244                         continue
1245                     if isinstance(arg, dict):
1246                         for key, val in arg.items():
1247                             if key == "names":
1248                                 for _name in val:
1249                                     if _name not in names:
1250                                         names.append(_name)
1251                             elif key == "state":
1252                                 continue
1253                             elif key == "name" and not isinstance(val, str):
1254                                 chunk[key] = name
1255                             else:
1256                                 chunk[key] = val
1257                 if names:
1258                     name_order = 1
1259                     for entry in names:
1260                         live = copy.deepcopy(chunk)
1261                         if isinstance(entry, dict):
1262                             low_name = next(iter(entry.keys()))
1263                             live["name"] = low_name
1264                             list(map(live.update, entry[low_name]))
1265                         else:
1266                             live["name"] = entry
1267                         live["name_order"] = name_order
1268                         name_order += 1
1269                         for fun in funcs:
1270                             live["fun"] = fun
1271                             chunks.append(live)
1272                 else:
1273                     live = copy.deepcopy(chunk)
1274                     for fun in funcs:
1275                         live["fun"] = fun
1276                         chunks.append(live)
1277         chunks = self.order_chunks(chunks)
1278         return chunks
1279     def reconcile_extend(self, high, strict=False):
1280         errors = []
1281         if "__extend__" not in high:
1282             return high, errors
1283         ext = high.pop("__extend__")
1284         for ext_chunk in ext:
1285             for name, body in ext_chunk.items():
1286                 state_type = next(x for x in body if not x.startswith("__"))
1287                 if name not in high or state_type not in high[name]:
1288                     ids = find_name(name, state_type, high, strict=strict)
1289                     if len(ids) != 1:
1290                         errors.append(
1291                             "Cannot extend ID '{0}' in '{1}:{2}'. It is not "
1292                             "part of the high state.\n"
1293                             "This is likely due to a missing include statement "
1294                             "or an incorrectly typed ID.\nEnsure that a "
1295                             "state with an ID of '{0}' is available\nin "
1296                             "environment '{1}' and to SLS '{2}'".format(
1297                                 name,
1298                                 body.get("__env__", "base"),
1299                                 body.get("__sls__", "base"),
1300                             )
1301                         )
1302                         continue
1303                     else:
1304                         name = ids[0][0]
1305                 for state, run in body.items():
1306                     if state.startswith("__"):
1307                         continue
1308                     if state not in high[name]:
1309                         high[name][state] = run
1310                         continue
1311                     for arg in run:
1312                         update = False
1313                         for hind, val in enumerate(high[name][state]):
1314                             if isinstance(arg, str) and isinstance(val, str):
1315                                 high[name][state].pop(hind)
1316                                 high[name][state].insert(hind, arg)
1317                                 update = True
1318                                 continue
1319                             if isinstance(arg, dict) and isinstance(val, dict):
1320                                 argfirst = next(iter(arg))
1321                                 if argfirst == next(iter(high[name][state][hind])):
1322                                     if argfirst in STATE_REQUISITE_KEYWORDS:
1323                                         high[name][state][hind][argfirst].extend(
1324                                             arg[argfirst]
1325                                         )
1326                                     else:
1327                                         high[name][state][hind] = arg
1328                                     update = True
1329                                 if (
1330                                     argfirst == "name"
1331                                     and next(iter(high[name][state][hind])) == "names"
1332                                 ):
1333                                     high[name][state][hind] = arg
1334                         if not update:
1335                             high[name][state].append(arg)
1336         return high, errors
1337     def apply_exclude(self, high):
1338         if "__exclude__" not in high:
1339             return high
1340         ex_sls = set()
1341         ex_id = set()
1342         exclude = high.pop("__exclude__")
1343         for exc in exclude:
1344             if isinstance(exc, str):
1345                 ex_sls.add(exc)
1346             if isinstance(exc, dict):
1347                 if len(exc) != 1:
1348                     continue
1349                 key = next(iter(exc.keys()))
1350                 if key == "sls":
1351                     ex_sls.add(exc["sls"])
1352                 elif key == "id":
1353                     ex_id.add(exc["id"])
1354         if ex_sls:
1355             for name, body in high.items():
1356                 if name.startswith("__"):
1357                     continue
1358                 sls = body.get("__sls__", "")
1359                 if not sls:
1360                     continue
1361                 for ex_ in ex_sls:
1362                     if fnmatch.fnmatch(sls, ex_):
1363                         ex_id.add(name)
1364         for id_ in ex_id:
1365             if id_ in high:
1366                 high.pop(id_)
1367         return high
1368     def requisite_in(self, high):
1369         req_in = {
1370             "require_in",
1371             "watch_in",
1372             "onfail_in",
1373             "onchanges_in",
1374             "use",
1375             "use_in",
1376             "prereq",
1377             "prereq_in",
1378         }
1379         req_in_all = req_in.union(
1380             {"require", "watch", "onfail", "onfail_stop", "onchanges"}
1381         )
1382         extend = {}
1383         errors = []
1384         disabled_reqs = self.opts.get("disabled_requisites", [])
1385         if not isinstance(disabled_reqs, list):
1386             disabled_reqs = [disabled_reqs]
1387         for id_, body in high.items():
1388             if not isinstance(body, dict):
1389                 continue
1390             for state, run in body.items():
1391                 if state.startswith("__"):
1392                     continue
1393                 for arg in run:
1394                     if isinstance(arg, dict):
1395                         if len(arg) &lt; 1:
1396                             continue
1397                         key = next(iter(arg))
1398                         if key not in req_in:
1399                             continue
1400                         if key in disabled_reqs:
1401                             log.warning(
1402                                 "The %s requisite has been disabled, Ignoring.", key
1403                             )
1404                             continue
1405                         rkey = key.split("_")[0]
1406                         items = arg[key]
1407                         if isinstance(items, dict):
1408                             for _state, name in items.items():
1409                                 found = False
1410                                 if name not in extend:
1411                                     extend[name] = OrderedDict()
1412                                 if "." in _state:
1413                                     errors.append(
1414                                         "Invalid requisite in {}: {} for "
1415                                         "{}, in SLS '{}'. Requisites must "
1416                                         "not contain dots, did you mean '{}'?".format(
1417                                             rkey,
1418                                             _state,
1419                                             name,
1420                                             body["__sls__"],
1421                                             _state[: _state.find(".")],
1422                                         )
1423                                     )
1424                                     _state = _state.split(".")[0]
1425                                 if _state not in extend[name]:
1426                                     extend[name][_state] = []
1427                                 extend[name]["__env__"] = body["__env__"]
1428                                 extend[name]["__sls__"] = body["__sls__"]
1429                                 for ind in range(len(extend[name][_state])):
1430                                     if next(iter(extend[name][_state][ind])) == rkey:
1431                                         extend[name][_state][ind][rkey].append(
1432                                             {state: id_}
1433                                         )
1434                                         found = True
1435                                 if found:
1436                                     continue
1437                                 extend[name][_state].append({rkey: [{state: id_}]})
1438                         if isinstance(items, list):
1439                             hinges = []
1440                             for ind in items:
1441                                 if not isinstance(ind, dict):
1442                                     if ind in high:
1443                                         _ind_high = [
1444                                             x
1445                                             for x in high[ind]
1446                                             if not x.startswith("__")
1447                                         ]
1448                                         ind = {_ind_high[0]: ind}
1449                                     else:
1450                                         found = False
1451                                         for _id in iter(high):
1452                                             for state in [
1453                                                 state
1454                                                 for state in iter(high[_id])
1455                                                 if not state.startswith("__")
1456                                             ]:
1457                                                 for j in iter(high[_id][state]):
1458                                                     if (
1459                                                         isinstance(j, dict)
1460                                                         and "name" in j
1461                                                     ):
1462                                                         if j["name"] == ind:
1463                                                             ind = {state: _id}
1464                                                             found = True
1465                                         if not found:
1466                                             continue
1467                                 if len(ind) &lt; 1:
1468                                     continue
1469                                 pstate = next(iter(ind))
1470                                 pname = ind[pstate]
1471                                 if pstate == "sls":
1472                                     hinges = find_sls_ids(pname, high)
1473                                 else:
1474                                     hinges.append((pname, pstate))
1475                                 if "." in pstate:
1476                                     errors.append(
1477                                         "Invalid requisite in {}: {} for "
1478                                         "{}, in SLS '{}'. Requisites must "
1479                                         "not contain dots, did you mean '{}'?".format(
1480                                             rkey,
1481                                             pstate,
1482                                             pname,
1483                                             body["__sls__"],
1484                                             pstate[: pstate.find(".")],
1485                                         )
1486                                     )
1487                                     pstate = pstate.split(".")[0]
1488                                 for tup in hinges:
1489                                     name, _state = tup
1490                                     if key == "prereq_in":
1491                                         if id_ not in extend:
1492                                             extend[id_] = OrderedDict()
1493                                         if state not in extend[id_]:
1494                                             extend[id_][state] = []
1495                                         extend[id_][state].append(
1496                                             {"prerequired": [{_state: name}]}
1497                                         )
1498                                     if key == "prereq":
1499                                         ext_ids = find_name(
1500                                             name, _state, high, strict=True
1501                                         )
1502                                         for ext_id, _req_state in ext_ids:
1503                                             if ext_id not in extend:
1504                                                 extend[ext_id] = OrderedDict()
1505                                             if _req_state not in extend[ext_id]:
1506                                                 extend[ext_id][_req_state] = []
1507                                             extend[ext_id][_req_state].append(
1508                                                 {"prerequired": [{state: id_}]}
1509                                             )
1510                                         continue
1511                                     if key == "use_in":
1512                                         ext_ids = find_name(
1513                                             name, _state, high, strict=True
1514                                         )
1515                                         for ext_id, _req_state in ext_ids:
1516                                             if not ext_id:
1517                                                 continue
1518                                             ext_args = state_args(ext_id, _state, high)
1519                                             if ext_id not in extend:
1520                                                 extend[ext_id] = OrderedDict()
1521                                             if _req_state not in extend[ext_id]:
1522                                                 extend[ext_id][_req_state] = []
1523                                             ignore_args = req_in_all.union(ext_args)
1524                                             for arg in high[id_][state]:
1525                                                 if not isinstance(arg, dict):
1526                                                     continue
1527                                                 if len(arg) != 1:
1528                                                     continue
1529                                                 if next(iter(arg)) in ignore_args:
1530                                                     continue
1531                                                 if next(iter(arg.keys())) == "name":
1532                                                     continue
1533                                                 if next(iter(arg.keys())) == "names":
1534                                                     continue
1535                                                 extend[ext_id][_req_state].append(arg)
1536                                         continue
1537                                     if key == "use":
1538                                         ext_ids = find_name(
1539                                             name, _state, high, strict=True
1540                                         )
1541                                         for ext_id, _req_state in ext_ids:
1542                                             if not ext_id:
1543                                                 continue
1544                                             loc_args = state_args(id_, state, high)
1545                                             if id_ not in extend:
1546                                                 extend[id_] = OrderedDict()
1547                                             if state not in extend[id_]:
1548                                                 extend[id_][state] = []
1549                                             ignore_args = req_in_all.union(loc_args)
1550                                             for arg in high[ext_id][_req_state]:
1551                                                 if not isinstance(arg, dict):
1552                                                     continue
1553                                                 if len(arg) != 1:
1554                                                     continue
1555                                                 if next(iter(arg)) in ignore_args:
1556                                                     continue
1557                                                 if next(iter(arg.keys())) == "name":
1558                                                     continue
1559                                                 if next(iter(arg.keys())) == "names":
1560                                                     continue
1561                                                 extend[id_][state].append(arg)
1562                                         continue
1563                                     found = False
1564                                     if name not in extend:
1565                                         extend[name] = OrderedDict()
1566                                     if _state not in extend[name]:
1567                                         extend[name][_state] = []
1568                                     extend[name]["__env__"] = body["__env__"]
1569                                     extend[name]["__sls__"] = body["__sls__"]
1570                                     for ind in range(len(extend[name][_state])):
1571                                         if (
1572                                             next(iter(extend[name][_state][ind]))
1573                                             == rkey
1574                                         ):
1575                                             extend[name][_state][ind][rkey].append(
1576                                                 {state: id_}
1577                                             )
1578                                             found = True
1579                                     if found:
1580                                         continue
1581                                     extend[name][_state].append({rkey: [{state: id_}]})
1582         high["__extend__"] = []
1583         for key, val in extend.items():
1584             high["__extend__"].append({key: val})
1585         req_in_high, req_in_errors = self.reconcile_extend(high, strict=True)
1586         errors.extend(req_in_errors)
1587         return req_in_high, errors
1588     def _call_parallel_target(self, name, cdata, low):
1589         utc_start_time = datetime.datetime.utcnow()
1590         self.format_slots(cdata)
1591         tag = _gen_tag(low)
1592         try:
1593             ret = self.states[cdata["full"]](*cdata["args"], **cdata["kwargs"])
1594         except Exception as exc:  # pylint: disable=broad-except
1595             log.debug(
1596                 "An exception occurred in this state: %s",
1597                 exc,
1598                 exc_info_on_loglevel=logging.DEBUG,
1599             )
1600             trb = traceback.format_exc()
1601             ret = {
1602                 "result": False,
1603                 "name": name,
1604                 "changes": {},
1605                 "comment": "An exception occurred in this state: {}".format(trb),
1606             }
1607         utc_finish_time = datetime.datetime.utcnow()
1608         delta = utc_finish_time - utc_start_time
1609         duration = (delta.seconds * 1000000 + delta.microseconds) / 1000.0
1610         ret["duration"] = duration
1611         troot = os.path.join(self.opts["cachedir"], self.jid)
1612         tfile = os.path.join(troot, salt.utils.hashutils.sha1_digest(tag))
1613         if not os.path.isdir(troot):
1614             try:
1615                 os.makedirs(troot)
1616             except OSError:
1617                 pass
1618         with salt.utils.files.fopen(tfile, "wb+") as fp_:
1619             fp_.write(msgpack_serialize(ret))
1620     def call_parallel(self, cdata, low):
1621         name = (cdata.get("args") or [None])[0] or cdata["kwargs"].get("name")
1622         if not name:
1623             name = low.get("name", low.get("__id__"))
1624         proc = salt.utils.process.Process(
1625             target=self._call_parallel_target,
1626             args=(name, cdata, low),
1627             name="ParallelState({})".format(name),
1628         )
1629         proc.start()
1630         ret = {
1631             "name": name,
1632             "result": None,
1633             "changes": {},
1634             "comment": "Started in a separate process",
1635             "proc": proc,
1636         }
1637         return ret
1638     @salt.utils.decorators.state.OutputUnifier("content_check", "unify")
1639     def call(self, low, chunks=None, running=None, retries=1):
1640         utc_start_time = datetime.datetime.utcnow()
1641         local_start_time = utc_start_time - (
1642             datetime.datetime.utcnow() - datetime.datetime.now()
1643         )
1644         log.info(
1645             "Running state [%s] at time %s",
1646             low["name"].strip() if isinstance(low["name"], str) else low["name"],
1647             local_start_time.time().isoformat(),
1648         )
1649         errors = self.verify_data(low)
1650         if errors:
1651             ret = {
1652                 "result": False,
1653                 "name": low["name"],
1654                 "changes": {},
1655                 "comment": "",
1656             }
1657             for err in errors:
1658                 ret["comment"] += "{}\n".format(err)
1659             ret["__run_num__"] = self.__run_num
1660             self.__run_num += 1
1661             format_log(ret)
1662             self.check_refresh(low, ret)
1663             return ret
1664         else:
1665             ret = {"result": False, "name": low["name"], "changes": {}}
1666         self.state_con["runas"] = low.get("runas", None)
1667         if low["state"] == "cmd" and "password" in low:
1668             self.state_con["runas_password"] = low["password"]
1669         else:
1670             self.state_con["runas_password"] = low.get("runas_password", None)
1671         if not low.get("__prereq__"):
1672             log.info(
1673                 "Executing state %s.%s for [%s]",
1674                 low["state"],
1675                 low["fun"],
1676                 low["name"].strip() if isinstance(low["name"], str) else low["name"],
1677             )
1678         if "provider" in low:
1679             self.load_modules(low)
1680         state_func_name = "{0[state]}.{0[fun]}".format(low)
1681         cdata = salt.utils.args.format_call(
1682             self.states[state_func_name],
1683             low,
1684             initial_ret={"full": state_func_name},
1685             expected_extra_kws=STATE_INTERNAL_KEYWORDS,
1686         )
1687         inject_globals = {
1688             "__low__": immutabletypes.freeze(low),
1689             "__running__": immutabletypes.freeze(running) if running else {},
1690             "__instance_id__": self.instance_id,
1691             "__lowstate__": immutabletypes.freeze(chunks) if chunks else {},
1692         }
1693         if "__env__" in low:
1694             inject_globals["__env__"] = str(low["__env__"])
1695         if self.inject_globals:
1696             inject_globals.update(self.inject_globals)
1697         if low.get("__prereq__"):
1698             test = sys.modules[self.states[cdata["full"]].__module__].__opts__["test"]
1699             sys.modules[self.states[cdata["full"]].__module__].__opts__["test"] = True
1700         try:
1701             req_list = ("unless", "onlyif", "creates")
1702             if (
1703                 any(req in low for req in req_list)
1704                 and "{0[state]}.mod_run_check".format(low) not in self.states
1705             ):
1706                 ret.update(self._run_check(low))
1707             if not self.opts.get("lock_saltenv", False):
1708                 if "saltenv" in low:
1709                     inject_globals["__env__"] = str(low["saltenv"])
1710                 elif isinstance(cdata["kwargs"].get("env", None), str):
1711                     inject_globals["__env__"] = str(cdata["kwargs"]["env"])
1712             if "__env__" not in inject_globals:
1713                 inject_globals["__env__"] = "base"
1714             if "__orchestration_jid__" in low:
1715                 inject_globals["__orchestration_jid__"] = low["__orchestration_jid__"]
1716             if "result" not in ret or ret["result"] is False:
1717                 self.states.inject_globals = inject_globals
1718                 if self.mocked:
1719                     ret = mock_ret(cdata)
1720                 else:
1721                     if not low.get("__prereq__") and low.get("parallel"):
1722                         ret = self.call_parallel(cdata, low)
1723                     else:
1724                         self.format_slots(cdata)
1725                         ret = self.states[cdata["full"]](
1726                             *cdata["args"], **cdata["kwargs"]
1727                         )
1728                 self.states.inject_globals = {}
1729             if (
1730                 "check_cmd" in low
1731                 and "{0[state]}.mod_run_check_cmd".format(low) not in self.states
1732             ):
1733                 ret.update(self._run_check_cmd(low))
1734         except Exception as exc:  # pylint: disable=broad-except
1735             log.debug(
1736                 "An exception occurred in this state: %s",
1737                 exc,
1738                 exc_info_on_loglevel=logging.DEBUG,
1739             )
1740             trb = traceback.format_exc()
1741             name = (cdata.get("args") or [None])[0] or cdata["kwargs"].get("name")
1742             if not name:
1743                 name = low.get("name", low.get("__id__"))
1744             ret = {
1745                 "result": False,
1746                 "name": name,
1747                 "changes": {},
1748                 "comment": "An exception occurred in this state: {}".format(trb),
1749             }
1750         finally:
1751             if low.get("__prereq__"):
1752                 sys.modules[self.states[cdata["full"]].__module__].__opts__[
1753                     "test"
1754                 ] = test
1755             self.state_con.pop("runas", None)
1756             self.state_con.pop("runas_password", None)
1757         if not isinstance(ret, dict):
1758             return ret
1759         if "warnings" in cdata:
1760             ret.setdefault("warnings", []).extend(cdata["warnings"])
1761         if "provider" in low:
1762             self.load_modules()
1763         if low.get("__prereq__"):
1764             low["__prereq__"] = False
1765             return ret
1766         ret["__sls__"] = low.get("__sls__")
1767         ret["__run_num__"] = self.__run_num
1768         self.__run_num += 1
1769         format_log(ret)
1770         self.check_refresh(low, ret)
1771         utc_finish_time = datetime.datetime.utcnow()
1772         timezone_delta = datetime.datetime.utcnow() - datetime.datetime.now()
1773         local_finish_time = utc_finish_time - timezone_delta
1774         local_start_time = utc_start_time - timezone_delta
1775         ret["start_time"] = local_start_time.time().isoformat()
1776         delta = utc_finish_time - utc_start_time
1777         duration = (delta.seconds * 1000000 + delta.microseconds) / 1000.0
1778         ret["duration"] = duration
1779         ret["__id__"] = low["__id__"]
1780         log.info(
1781             "Completed state [%s] at time %s (duration_in_ms=%s)",
1782             low["name"].strip() if isinstance(low["name"], str) else low["name"],
1783             local_finish_time.time().isoformat(),
1784             duration,
1785         )
1786         if "retry" in low:
1787             low["retry"] = self.verify_retry_data(low["retry"])
1788             if not sys.modules[self.states[cdata["full"]].__module__].__opts__["test"]:
1789                 if low["retry"]["until"] != ret["result"]:
1790                     if low["retry"]["attempts"] &gt; retries:
1791                         interval = low["retry"]["interval"]
1792                         if low["retry"]["splay"] != 0:
1793                             interval = interval + random.randint(
1794                                 0, low["retry"]["splay"]
1795                             )
1796                         log.info(
1797                             "State result does not match retry until value, "
1798                             "state will be re-run in %s seconds",
1799                             interval,
1800                         )
1801                         self.functions["test.sleep"](interval)
1802                         retry_ret = self.call(low, chunks, running, retries=retries + 1)
1803                         orig_ret = ret
1804                         ret = retry_ret
1805                         ret["comment"] = "\n".join(
1806                             [
1807                                 'Attempt {}: Returned a result of "{}", '
1808                                 'with the following comment: "{}"'.format(
1809                                     retries, orig_ret["result"], orig_ret["comment"]
1810                                 ),
1811                                 "" if not ret["comment"] else ret["comment"],
1812                             ]
1813                         )
1814                         ret["duration"] = (
1815                             ret["duration"] + orig_ret["duration"] + (interval * 1000)
1816                         )
1817                         if retries == 1:
1818                             ret["start_time"] = orig_ret["start_time"]
1819             else:
1820                 ret["comment"] = "  ".join(
1821                     [
1822                         "" if not ret["comment"] else str(ret["comment"]),
1823                         "The state would be retried every {interval} seconds "
1824                         "(with a splay of up to {splay} seconds) a maximum of "
1825                         "{attempts} times or until a result of {until} "
1826                         "is returned".format(**low["retry"]),
1827                     ]
1828                 )
1829         return ret
1830     def __eval_slot(self, slot):
1831         log.debug("Evaluating slot: %s", slot)
1832         fmt = slot.split(":", 2)
1833         if len(fmt) != 3:
1834             log.warning("Malformed slot: %s", slot)
1835             return slot
1836         if fmt[1] != "salt":
1837             log.warning("Malformed slot: %s", slot)
1838             log.warning(
1839                 "Only execution modules are currently supported in slots. This means"
1840                 ' slot should start with "__slot__:salt:"'
1841             )
1842             return slot
1843         fun, args, kwargs = salt.utils.args.parse_function(fmt[2])
1844         if not fun or fun not in self.functions:
1845             log.warning("Malformed slot: %s", slot)
1846             log.warning(
1847                 "Execution module should be specified in a function call format: "
1848                 "test.arg('arg', kw='kwarg')"
1849 <a name="3"></a>            )
1850             return slot
1851         log.debug("Calling slot: %s(%s, %s)", fun, args, kwargs)
1852         slot_return = self<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.functions[fun](*args, **kwargs)
1853         slot_text = fmt[2].split("~")[0]
1854         append_data = fmt[2].split("~", 1)[1:]
1855         log.</b></font>debug("slot_text: %s", slot_text)
1856         log.debug("append_data: %s", append_data)
1857         return_get = None
1858         try:
1859             return_get = slot_text[slot_text.rindex(")") + 1 :]
1860         except ValueError:
1861             pass
1862         if return_get:
1863             return_get = return_get.split(".", 1)[1].strip()
1864             log.debug("Searching slot result %s for %s", slot_return, return_get)
1865             slot_return = salt.utils.data.traverse_dict_and_list(
1866                 slot_return, return_get, default=None, delimiter="."
1867             )
1868         if append_data:
1869             if isinstance(slot_return, str):
1870                 append_data = " ".join(append_data).strip()
1871                 log.debug("appending to slot result: %s", append_data)
1872                 slot_return += append_data
1873             else:
1874                 log.error("Ignoring slot append, slot result is not a string")
1875         return slot_return
1876     def format_slots(self, cdata):
1877         SLOT_TEXT = "__slot__:"
1878         ctx = (("args", enumerate(cdata["args"])), ("kwargs", cdata["kwargs"].items()))
1879         for atype, avalues in ctx:
1880             for ind, arg in avalues:
1881                 arg = salt.utils.data.decode(arg, keep=True)
1882                 if isinstance(arg, dict):
1883                     for key, value in arg.items():
1884                         try:
1885                             if value.startswith(SLOT_TEXT):
1886                                 log.trace("Slot processsing dict value %s", value)
1887                                 cdata[atype][ind][key] = self.__eval_slot(value)
1888                         except AttributeError:
1889                             continue
1890                 elif isinstance(arg, list):
1891                     for idx, listvalue in enumerate(arg):
1892                         log.trace("Slot processing list value: %s", listvalue)
1893                         if isinstance(listvalue, dict):
1894                             for key, value in listvalue.items():
1895                                 try:
1896                                     if value.startswith(SLOT_TEXT):
1897                                         log.trace(
1898                                             "Slot processsing nested dict value %s",
1899                                             value,
1900                                         )
1901                                         cdata[atype][ind][idx][key] = self.__eval_slot(
1902                                             value
1903                                         )
1904                                 except AttributeError:
1905                                     continue
1906                         if isinstance(listvalue, str):
1907                             if listvalue.startswith(SLOT_TEXT):
1908                                 log.trace(
1909                                     "Slot processsing nested string %s", listvalue
1910                                 )
1911                                 cdata[atype][ind][idx] = self.__eval_slot(listvalue)
1912                 elif isinstance(arg, str) and arg.startswith(SLOT_TEXT):
1913                     log.trace("Slot processsing %s", arg)
1914                     cdata[atype][ind] = self.__eval_slot(arg)
1915                 else:
1916                     continue
1917     def verify_retry_data(self, retry_data):
1918         retry_defaults = {
1919             "until": True,
1920             "attempts": 2,
1921             "splay": 0,
1922             "interval": 30,
1923         }
1924         expected_data = {
1925             "until": bool,
1926             "attempts": int,
1927             "interval": int,
1928             "splay": int,
1929         }
1930         validated_retry_data = {}
1931         if isinstance(retry_data, dict):
1932             for expected_key, value_type in expected_data.items():
1933                 if expected_key in retry_data:
1934                     if isinstance(retry_data[expected_key], value_type):
1935                         validated_retry_data[expected_key] = retry_data[expected_key]
1936                     else:
1937                         log.warning(
1938                             "An invalid value was passed for the retry %s, "
1939                             "using default value '%s'",
1940                             expected_key,
1941                             retry_defaults[expected_key],
1942                         )
1943                         validated_retry_data[expected_key] = retry_defaults[
1944                             expected_key
1945                         ]
1946                 else:
1947                     validated_retry_data[expected_key] = retry_defaults[expected_key]
1948         else:
1949             log.warning(
1950                 "State is set to retry, but a valid dict for retry "
1951                 "configuration was not found.  Using retry defaults"
1952             )
1953             validated_retry_data = retry_defaults
1954         return validated_retry_data
1955     def call_chunks(self, chunks):
1956         disabled = {}
1957         if "state_runs_disabled" in self.opts["grains"]:
1958             for low in chunks[:]:
1959                 state_ = "{}.{}".format(low["state"], low["fun"])
1960                 for pat in self.opts["grains"]["state_runs_disabled"]:
1961                     if fnmatch.fnmatch(state_, pat):
1962                         comment = (
1963                             'The state function "{0}" is currently disabled by "{1}", '
1964                             "to re-enable, run state.enable {1}.".format(
1965                                 state_,
1966                                 pat,
1967                             )
1968                         )
1969                         _tag = _gen_tag(low)
1970                         disabled[_tag] = {
1971                             "changes": {},
1972                             "result": False,
1973                             "comment": comment,
1974                             "__run_num__": self.__run_num,
1975                             "__sls__": low["__sls__"],
1976                         }
1977                         self.__run_num += 1
1978                         chunks.remove(low)
1979                         break
1980         running = {}
1981         for low in chunks:
1982             if "__FAILHARD__" in running:
1983                 running.pop("__FAILHARD__")
1984                 return running
1985             tag = _gen_tag(low)
1986             if tag not in running:
1987                 action = self.check_pause(low)
1988                 if action == "kill":
1989                     break
1990                 running = self.call_chunk(low, running, chunks)
1991                 if self.check_failhard(low, running):
1992                     return running
1993             self.active = set()
1994         while True:
1995             if self.reconcile_procs(running):
1996                 break
1997             time.sleep(0.01)
1998         ret = dict(list(disabled.items()) + list(running.items()))
1999         return ret
2000     def check_failhard(self, low, running):
2001         tag = _gen_tag(low)
2002         if self.opts.get("test", False):
2003             return False
2004         if low.get("failhard", self.opts["failhard"]) and tag in running:
2005             if running[tag]["result"] is None:
2006                 return False
2007             return not running[tag]["result"]
2008         return False
2009     def check_pause(self, low):
2010         if not self.jid:
2011             return
2012         pause_path = os.path.join(self.opts["cachedir"], "state_pause", self.jid)
2013         start = time.time()
2014         if os.path.isfile(pause_path):
2015             try:
2016                 while True:
2017                     tries = 0
2018                     with salt.utils.files.fopen(pause_path, "rb") as fp_:
2019                         try:
2020                             pdat = msgpack_deserialize(fp_.read())
2021                         except salt.utils.msgpack.exceptions.UnpackValueError:
2022                             if tries &gt; 10:
2023                                 return
2024                             tries += 1
2025                             time.sleep(1)
2026                             continue
2027                         id_ = low["__id__"]
2028                         key = ""
2029                         if id_ in pdat:
2030                             key = id_
2031                         elif "__all__" in pdat:
2032                             key = "__all__"
2033                         if key:
2034                             if "duration" in pdat[key]:
2035                                 now = time.time()
2036                                 if now - start &gt; pdat[key]["duration"]:
2037                                     return "run"
2038                             if "kill" in pdat[key]:
2039                                 return "kill"
2040                         else:
2041                             return "run"
2042                         time.sleep(1)
2043             except Exception as exc:  # pylint: disable=broad-except
2044                 log.error(
2045                     "Failed to read in pause data for file located at: %s", pause_path
2046                 )
2047                 return "run"
2048         return "run"
2049     def reconcile_procs(self, running):
2050         retset = set()
2051         for tag in running:
2052             proc = running[tag].get("proc")
2053             if proc:
2054                 if not proc.is_alive():
2055                     ret_cache = os.path.join(
2056                         self.opts["cachedir"],
2057                         self.jid,
2058                         salt.utils.hashutils.sha1_digest(tag),
2059                     )
2060                     if not os.path.isfile(ret_cache):
2061                         ret = {
2062                             "result": False,
2063                             "comment": "Parallel process failed to return",
2064                             "name": running[tag]["name"],
2065                             "changes": {},
2066                         }
2067                     try:
2068                         with salt.utils.files.fopen(ret_cache, "rb") as fp_:
2069                             ret = msgpack_deserialize(fp_.read())
2070                     except OSError:
2071                         ret = {
2072                             "result": False,
2073                             "comment": "Parallel cache failure",
2074                             "name": running[tag]["name"],
2075                             "changes": {},
2076                         }
2077                     running[tag].update(ret)
2078                     running[tag].pop("proc")
2079                 else:
2080                     retset.add(False)
2081         return False not in retset
2082     def check_requisite(self, low, running, chunks, pre=False):
2083         disabled_reqs = self.opts.get("disabled_requisites", [])
2084         if not isinstance(disabled_reqs, list):
2085             disabled_reqs = [disabled_reqs]
2086         present = False
2087         if "watch" in low:
2088             if "{}.mod_watch".format(low["state"]) not in self.states:
2089                 if "require" in low:
2090                     low["require"].extend(low.pop("watch"))
2091                 else:
2092                     low["require"] = low.pop("watch")
2093             else:
2094                 present = True
2095         if "watch_any" in low:
2096             if "{}.mod_watch".format(low["state"]) not in self.states:
2097                 if "require_any" in low:
2098                     low["require_any"].extend(low.pop("watch_any"))
2099                 else:
2100                     low["require_any"] = low.pop("watch_any")
2101             else:
2102                 present = True
2103         if "require" in low:
2104             present = True
2105         if "require_any" in low:
2106             present = True
2107         if "prerequired" in low:
2108             present = True
2109         if "prereq" in low:
2110             present = True
2111         if "onfail" in low:
2112             present = True
2113         if "onfail_any" in low:
2114             present = True
2115         if "onfail_all" in low:
2116             present = True
2117         if "onchanges" in low:
2118             present = True
2119         if "onchanges_any" in low:
2120             present = True
2121         if not present:
2122             return "met", ()
2123         self.reconcile_procs(running)
2124         reqs = {
2125             "require": [],
2126             "require_any": [],
2127             "watch": [],
2128             "watch_any": [],
2129             "prereq": [],
2130             "onfail": [],
2131             "onfail_any": [],
2132             "onfail_all": [],
2133             "onchanges": [],
2134             "onchanges_any": [],
2135         }
2136         if pre:
2137             reqs["prerequired"] = []
2138         for r_state in reqs:
2139             if r_state in low and low[r_state] is not None:
2140                 if r_state in disabled_reqs:
2141                     log.warning(
2142                         "The %s requisite has been disabled, Ignoring.", r_state
2143                     )
2144                     continue
2145                 for req in low[r_state]:
2146                     if isinstance(req, str):
2147                         req = {"id": req}
2148                     req = trim_req(req)
2149                     found = False
2150                     for chunk in chunks:
2151                         req_key = next(iter(req))
2152                         req_val = req[req_key]
2153                         if req_val is None:
2154                             continue
2155                         if req_key == "sls":
2156                             if fnmatch.fnmatch(chunk["__sls__"], req_val):
2157                                 found = True
2158                                 reqs[r_state].append(chunk)
2159                             continue
2160                         try:
2161                             if isinstance(req_val, str):
2162                                 if fnmatch.fnmatch(
2163                                     chunk["name"], req_val
2164                                 ) or fnmatch.fnmatch(chunk["__id__"], req_val):
2165                                     if req_key == "id" or chunk["state"] == req_key:
2166                                         found = True
2167                                         reqs[r_state].append(chunk)
2168                             else:
2169                                 raise KeyError
2170                         except KeyError as exc:
2171                             raise SaltRenderError(
2172                                 "Could not locate requisite of [{}] present in state"
2173                                 " with name [{}]".format(req_key, chunk["name"])
2174                             )
2175                         except TypeError:
2176                             raise SaltRenderError(
2177                                 "Could not locate requisite of [{}] present in state"
2178                                 " with name [{}]".format(req_key, chunk["name"])
2179                             )
2180                     if not found:
2181                         return "unmet", ()
2182         fun_stats = set()
2183         for r_state, chunks in reqs.items():
2184             req_stats = set()
2185             if r_state.startswith("prereq") and not r_state.startswith("prerequired"):
2186                 run_dict = self.pre
2187             else:
2188                 run_dict = running
2189             filtered_run_dict = {}
2190             for chunk in chunks:
2191                 tag = _gen_tag(chunk)
2192                 run_dict_chunk = run_dict.get(tag)
2193                 if run_dict_chunk:
2194                     filtered_run_dict[tag] = run_dict_chunk
2195             run_dict = filtered_run_dict
2196             while True:
2197                 if self.reconcile_procs(run_dict):
2198                     break
2199                 time.sleep(0.01)
2200             for chunk in chunks:
2201                 tag = _gen_tag(chunk)
2202                 if tag not in run_dict:
2203                     req_stats.add("unmet")
2204                     continue
2205                 if r_state.startswith("onfail"):
2206                     if run_dict[tag]["result"] is True:
2207                         req_stats.add("onfail")  # At least one state is OK
2208                         continue
2209                 else:
2210                     if run_dict[tag]["result"] is False:
2211                         req_stats.add("fail")
2212                         continue
2213                 if r_state.startswith("onchanges"):
2214                     if not run_dict[tag]["changes"]:
2215                         req_stats.add("onchanges")
2216                     else:
2217                         req_stats.add("onchangesmet")
2218                     continue
2219                 if r_state.startswith("watch") and run_dict[tag]["changes"]:
2220                     req_stats.add("change")
2221                     continue
2222                 if r_state.startswith("prereq") and run_dict[tag]["result"] is None:
2223                     if not r_state.startswith("prerequired"):
2224                         req_stats.add("premet")
2225                 if r_state.startswith("prereq") and not run_dict[tag]["result"] is None:
2226                     if not r_state.startswith("prerequired"):
2227                         req_stats.add("pre")
2228                 else:
2229                     if run_dict[tag].get("__state_ran__", True):
2230                         req_stats.add("met")
2231             if r_state.endswith("_any") or r_state == "onfail":
2232                 if "met" in req_stats or "change" in req_stats:
2233                     if "fail" in req_stats:
2234                         req_stats.remove("fail")
2235                 if "onchangesmet" in req_stats:
2236                     if "onchanges" in req_stats:
2237                         req_stats.remove("onchanges")
2238                     if "fail" in req_stats:
2239                         req_stats.remove("fail")
2240                 if "onfail" in req_stats:
2241                     if "met" in req_stats:
2242                         req_stats.remove("onfail")
2243             if r_state.endswith("_all"):
2244                 if "onfail" in req_stats:
2245                     if "met" in req_stats:
2246                         req_stats.remove("met")
2247             fun_stats.update(req_stats)
2248         if "unmet" in fun_stats:
2249             status = "unmet"
2250         elif "fail" in fun_stats:
2251             status = "fail"
2252         elif "pre" in fun_stats:
2253             if "premet" in fun_stats:
2254                 status = "met"
2255             else:
2256                 status = "pre"
2257         elif "onfail" in fun_stats and "onchangesmet" not in fun_stats:
2258             status = "onfail"
2259         elif "onchanges" in fun_stats and "onchangesmet" not in fun_stats:
2260             status = "onchanges"
2261         elif "change" in fun_stats:
2262             status = "change"
2263         elif "onfail" in fun_stats:
2264             status = "onfail"
2265         else:
2266             status = "met"
2267         return status, reqs
2268     def event(self, chunk_ret, length, fire_event=False):
2269         if not self.opts.get("local") and (
2270             self.opts.get("state_events", True) or fire_event
2271         ):
2272             if not self.opts.get("master_uri"):
2273                 ev_func = (
2274                     lambda ret, tag, preload=None: salt.utils.event.get_master_event(
2275                         self.opts, self.opts["sock_dir"], listen=False
2276                     ).fire_event(ret, tag)
2277                 )
2278             else:
2279                 ev_func = self.functions["event.fire_master"]
2280             ret = {"ret": chunk_ret}
2281             if fire_event is True:
2282                 tag = salt.utils.event.tagify(
2283                     [self.jid, self.opts["id"], str(chunk_ret["name"])],
2284                     "state_result",
2285                 )
2286             elif isinstance(fire_event, str):
2287                 tag = salt.utils.event.tagify(
2288                     [self.jid, self.opts["id"], str(fire_event)],
2289                     "state_result",
2290                 )
2291             else:
2292                 tag = salt.utils.event.tagify(
2293                     [self.jid, "prog", self.opts["id"], str(chunk_ret["__run_num__"])],
2294                     "job",
2295                 )
2296                 ret["len"] = length
2297             preload = {"jid": self.jid}
2298             ev_func(ret, tag, preload=preload)
2299     def call_chunk(self, low, running, chunks):
2300         low = self._mod_aggregate(low, running, chunks)
2301         self._mod_init(low)
2302         tag = _gen_tag(low)
2303         if not low.get("prerequired"):
2304             self.active.add(tag)
2305         requisites = [
2306             "require",
2307             "require_any",
2308             "watch",
2309             "watch_any",
2310             "prereq",
2311             "onfail",
2312             "onfail_any",
2313             "onchanges",
2314             "onchanges_any",
2315         ]
2316         if not low.get("__prereq__"):
2317             requisites.append("prerequired")
2318             status, reqs = self.check_requisite(low, running, chunks, pre=True)
2319         else:
2320             status, reqs = self.check_requisite(low, running, chunks)
2321         if status == "unmet":
2322             lost = {}
2323             reqs = []
2324             for requisite in requisites:
2325                 lost[requisite] = []
2326                 if requisite not in low:
2327                     continue
2328                 for req in low[requisite]:
2329                     if isinstance(req, str):
2330                         req = {"id": req}
2331                     req = trim_req(req)
2332                     found = False
2333                     req_key = next(iter(req))
2334                     req_val = req[req_key]
2335                     for chunk in chunks:
2336                         if req_val is None:
2337                             continue
2338                         if req_key == "sls":
2339                             if fnmatch.fnmatch(chunk["__sls__"], req_val):
2340                                 if requisite == "prereq":
2341                                     chunk["__prereq__"] = True
2342                                 reqs.append(chunk)
2343                                 found = True
2344                             continue
2345                         if fnmatch.fnmatch(chunk["name"], req_val) or fnmatch.fnmatch(
2346                             chunk["__id__"], req_val
2347                         ):
2348                             if req_key == "id" or chunk["state"] == req_key:
2349                                 if requisite == "prereq":
2350                                     chunk["__prereq__"] = True
2351                                 elif requisite == "prerequired":
2352                                     chunk["__prerequired__"] = True
2353                                 reqs.append(chunk)
2354 <a name="9"></a>                                found = True
2355                     if not found:
2356                         lost[requisite].append(req)
2357             <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>if (
2358                 lost["require"]
2359                 or lost["watch"]
2360                 or lost["prereq"]
2361                 or lost["onfail"]
2362                 or lost["onchanges"]
2363                 or lost["require_any"]
2364                 or lost["watch_any"]
2365                 or lost["onfail_any"]
2366                 or lost["onchanges_any"]
2367                 or lost.get(</b></font>"prerequired")
2368             ):
2369                 comment = "The following requisites were not found:\n"
2370                 for requisite, lreqs in lost.items():
2371                     if not lreqs:
2372                         continue
2373                     comment += "{}{}:\n".format(" " * 19, requisite)
2374                     for lreq in lreqs:
2375                         req_key = next(iter(lreq))
2376                         req_val = lreq[req_key]
2377                         comment += "{}{}: {}\n".format(" " * 23, req_key, req_val)
2378                 if low.get("__prereq__"):
2379                     run_dict = self.pre
2380                 else:
2381                     run_dict = running
2382                 start_time, duration = _calculate_fake_duration()
2383                 run_dict[tag] = {
2384                     "changes": {},
2385                     "result": False,
2386                     "duration": duration,
2387                     "start_time": start_time,
2388                     "comment": comment,
2389                     "__run_num__": self.__run_num,
2390                     "__sls__": low["__sls__"],
2391                 }
2392                 self.__run_num += 1
2393                 self.event(run_dict[tag], len(chunks), fire_event=low.get("fire_event"))
2394                 return running
2395             for chunk in reqs:
2396                 ctag = _gen_tag(chunk)
2397                 if ctag not in running:
2398                     if ctag in self.active:
2399                         if chunk.get("__prerequired__"):
2400                             if tag not in self.pre:
2401                                 low["__prereq__"] = True
2402                                 self.pre[ctag] = self.call(low, chunks, running)
2403                                 return running
2404                             else:
2405                                 return running
2406                         elif ctag not in running:
2407                             log.error("Recursive requisite found")
2408                             running[tag] = {
2409                                 "changes": {},
2410                                 "result": False,
2411                                 "comment": "Recursive requisite found",
2412                                 "__run_num__": self.__run_num,
2413                                 "__sls__": low["__sls__"],
2414                             }
2415                         self.__run_num += 1
2416                         self.event(
2417                             running[tag], len(chunks), fire_event=low.get("fire_event")
2418                         )
2419                         return running
2420                     running = self.call_chunk(chunk, running, chunks)
2421                     if self.check_failhard(chunk, running):
2422                         running["__FAILHARD__"] = True
2423                         return running
2424             if low.get("__prereq__"):
2425                 status, reqs = self.check_requisite(low, running, chunks)
2426                 self.pre[tag] = self.call(low, chunks, running)
2427                 if not self.pre[tag]["changes"] and status == "change":
2428                     self.pre[tag]["changes"] = {"watch": "watch"}
2429                     self.pre[tag]["result"] = None
2430             else:
2431                 running = self.call_chunk(low, running, chunks)
2432             if self.check_failhard(chunk, running):
2433                 running["__FAILHARD__"] = True
2434                 return running
2435         elif status == "met":
2436             if low.get("__prereq__"):
2437                 self.pre[tag] = self.call(low, chunks, running)
2438             else:
2439                 running[tag] = self.call(low, chunks, running)
2440 <a name="6"></a>        elif status == "fail":
2441             if tag in self<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.pre:
2442                 running[tag] = self.pre[tag]
2443                 running[tag]["__run_num__"] = self.__run_num
2444                 running[tag]["__sls__"] = low[</b></font>"__sls__"]
2445             else:
2446                 failed_requisites = set()
2447                 for req_lows in reqs.values():
2448                     for req_low in req_lows:
2449                         req_tag = _gen_tag(req_low)
2450                         req_ret = self.pre.get(req_tag, running.get(req_tag))
2451                         if req_ret is None:
2452                             continue
2453                         if req_ret["result"] is False:
2454                             key = "{sls}.{_id}".format(
2455                                 sls=req_low["__sls__"], _id=req_low["__id__"]
2456                             )
2457                             failed_requisites.add(key)
2458                 _cmt = "One or more requisite failed: {}".format(
2459                     ", ".join(str(i) for i in failed_requisites)
2460                 )
2461                 start_time, duration = _calculate_fake_duration()
2462                 running[tag] = {
2463                     "changes": {},
2464                     "result": False,
2465                     "duration": duration,
2466                     "start_time": start_time,
2467                     "comment": _cmt,
2468                     "__run_num__": self.__run_num,
2469                     "__sls__": low["__sls__"],
2470                 }
2471                 self.pre[tag] = running[tag]
2472             self.__run_num += 1
2473         elif status == "change" and not low.get("__prereq__"):
2474             ret = self.call(low, chunks, running)
2475             if not ret["changes"] and not ret.get("skip_watch", False):
2476                 low = low.copy()
2477                 low["sfun"] = low["fun"]
2478                 low["fun"] = "mod_watch"
2479                 low["__reqs__"] = reqs
2480                 ret = self.call(low, chunks, running)
2481             running[tag] = ret
2482         elif status == "pre":
2483             start_time, duration = _calculate_fake_duration()
2484             pre_ret = {
2485                 "changes": {},
2486                 "result": True,
2487                 "duration": duration,
2488                 "start_time": start_time,
2489                 "comment": "No changes detected",
2490                 "__run_num__": self.__run_num,
2491                 "__sls__": low["__sls__"],
2492             }
2493             running[tag] = pre_ret
2494             self.pre[tag] = pre_ret
2495             self.__run_num += 1
2496         elif status == "onfail":
2497             start_time, duration = _calculate_fake_duration()
2498             running[tag] = {
2499                 "changes": {},
2500                 "result": True,
2501                 "duration": duration,
2502                 "start_time": start_time,
2503                 "comment": "State was not run because onfail req did not change",
2504                 "__state_ran__": False,
2505                 "__run_num__": self.__run_num,
2506                 "__sls__": low["__sls__"],
2507             }
2508             self.__run_num += 1
2509         elif status == "onchanges":
2510             start_time, duration = _calculate_fake_duration()
2511             running[tag] = {
2512                 "changes": {},
2513                 "result": True,
2514                 "duration": duration,
2515                 "start_time": start_time,
2516                 "comment": (
2517                     "State was not run because none of the onchanges reqs changed"
2518                 ),
2519                 "__state_ran__": False,
2520                 "__run_num__": self.__run_num,
2521                 "__sls__": low["__sls__"],
2522             }
2523             self.__run_num += 1
2524         else:
2525             if low.get("__prereq__"):
2526                 self.pre[tag] = self.call(low, chunks, running)
2527             else:
2528                 running[tag] = self.call(low, chunks, running)
2529         if tag in running:
2530             self.event(running[tag], len(chunks), fire_event=low.get("fire_event"))
2531             for sub_state_data in running[tag].pop("sub_state_run", ()):
2532                 start_time, duration = _calculate_fake_duration()
2533                 self.__run_num += 1
2534                 sub_tag = _gen_tag(sub_state_data["low"])
2535                 running[sub_tag] = {
2536                     "name": sub_state_data["low"]["name"],
2537                     "changes": sub_state_data["changes"],
2538                     "result": sub_state_data["result"],
2539                     "duration": sub_state_data.get("duration", duration),
2540                     "start_time": sub_state_data.get("start_time", start_time),
2541                     "comment": sub_state_data.get("comment", ""),
2542                     "__state_ran__": True,
2543                     "__run_num__": self.__run_num,
2544                     "__sls__": low["__sls__"],
2545                 }
2546         return running
2547     def call_beacons(self, chunks, running):
2548         listeners = []
2549         crefs = {}
2550         beacons = []
2551         for chunk in chunks:
2552             if "beacon" in chunk:
2553                 beacons.append(chunk)
2554         mod_beacons = []
2555         errors = {}
2556         for chunk in beacons:
2557             low = chunk.copy()
2558             low["sfun"] = chunk["fun"]
2559             low["fun"] = "mod_beacon"
2560             low["__id__"] = "beacon_{}".format(low["__id__"])
2561             mod_beacons.append(low)
2562         ret = self.call_chunks(mod_beacons)
2563         running.update(ret)
2564         for err in errors:
2565             errors[err]["__run_num__"] = self.__run_num
2566             self.__run_num += 1
2567         running.update(errors)
2568         return running
2569     def call_listen(self, chunks, running):
2570         listeners = []
2571         crefs = {}
2572         for chunk in chunks:
2573             crefs[(chunk["state"], chunk["__id__"], chunk["name"])] = chunk
2574             if "listen" in chunk:
2575                 listeners.append(
2576                     {(chunk["state"], chunk["__id__"], chunk["name"]): chunk["listen"]}
2577                 )
2578             if "listen_in" in chunk:
2579                 for l_in in chunk["listen_in"]:
2580                     for key, val in l_in.items():
2581                         listeners.append(
2582                             {(key, val, "lookup"): [{chunk["state"]: chunk["__id__"]}]}
2583                         )
2584         mod_watchers = []
2585         errors = {}
2586         for l_dict in listeners:
2587             for key, val in l_dict.items():
2588                 for listen_to in val:
2589                     if not isinstance(listen_to, dict):
2590                         found = False
2591                         for chunk in chunks:
2592                             if (
2593                                 chunk["__id__"] == listen_to
2594                                 or chunk["name"] == listen_to
2595                             ):
2596                                 listen_to = {chunk["state"]: chunk["__id__"]}
2597                                 found = True
2598                         if not found:
2599                             continue
2600                     for lkey, lval in listen_to.items():
2601                         if not any(lkey == cref[0] and lval in cref for cref in crefs):
2602                             rerror = {
2603                                 _l_tag(lkey, lval): {
2604                                     "comment": (
2605                                         "Referenced state {}: {} does not exist".format(
2606                                             lkey, lval
2607                                         )
2608                                     ),
2609                                     "name": "listen_{}:{}".format(lkey, lval),
2610                                     "result": False,
2611                                     "changes": {},
2612                                 }
2613                             }
2614                             errors.update(rerror)
2615                             continue
2616                         to_tags = [
2617                             _gen_tag(data)
2618                             for cref, data in crefs.items()
2619                             if lkey == cref[0] and lval in cref
2620                         ]
2621                         for to_tag in to_tags:
2622                             if to_tag not in running:
2623                                 continue
2624                             if running[to_tag]["changes"]:
2625                                 if not any(
2626                                     key[0] == cref[0] and key[1] in cref
2627                                     for cref in crefs
2628                                 ):
2629                                     rerror = {
2630                                         _l_tag(key[0], key[1]): {
2631                                             "comment": (
2632                                                 "Referenced state {}: {} does not exist".format(
2633                                                     key[0], key[1]
2634                                                 )
2635                                             ),
2636                                             "name": "listen_{}:{}".format(
2637                                                 key[0], key[1]
2638                                             ),
2639                                             "result": False,
2640                                             "changes": {},
2641                                         }
2642                                     }
2643                                     errors.update(rerror)
2644                                     continue
2645                                 new_chunks = [
2646                                     data
2647                                     for cref, data in crefs.items()
2648                                     if key[0] == cref[0] and key[1] in cref
2649                                 ]
2650                                 for chunk in new_chunks:
2651                                     low = chunk.copy()
2652                                     low["sfun"] = chunk["fun"]
2653                                     low["fun"] = "mod_watch"
2654                                     low["__id__"] = "listener_{}".format(low["__id__"])
2655                                     for req in STATE_REQUISITE_KEYWORDS:
2656                                         if req in low:
2657                                             low.pop(req)
2658                                     mod_watchers.append(low)
2659         ret = self.call_chunks(mod_watchers)
2660         running.update(ret)
2661         for err in errors:
2662             errors[err]["__run_num__"] = self.__run_num
2663             self.__run_num += 1
2664         running.update(errors)
2665         return running
2666     def call_high(self, high, orchestration_jid=None):
2667         errors = []
2668         high, ext_errors = self.reconcile_extend(high)
2669         errors.extend(ext_errors)
2670         errors.extend(self.verify_high(high))
2671         if errors:
2672             return errors
2673         high, req_in_errors = self.requisite_in(high)
2674         errors.extend(req_in_errors)
2675         high = self.apply_exclude(high)
2676         if errors:
2677             return errors
2678         chunks = self.compile_high_data(high, orchestration_jid)
2679         if errors:
2680             return errors
2681         ret = self.call_chunks(chunks)
2682         ret = self.call_listen(chunks, ret)
2683         ret = self.call_beacons(chunks, ret)
2684         def _cleanup_accumulator_data():
2685             accum_data_path = os.path.join(
2686                 get_accumulator_dir(self.opts["cachedir"]), self.instance_id
2687             )
2688             try:
2689                 os.remove(accum_data_path)
2690                 log.debug("Deleted accumulator data file %s", accum_data_path)
2691             except OSError:
2692                 log.debug("File %s does not exist, no need to cleanup", accum_data_path)
2693         _cleanup_accumulator_data()
2694         if self.jid is not None:
2695             pause_path = os.path.join(self.opts["cachedir"], "state_pause", self.jid)
2696             if os.path.isfile(pause_path):
2697                 try:
2698                     os.remove(pause_path)
2699                 except OSError:
2700                     pass
2701         return ret
2702     def render_template(self, high, template):
2703         errors = []
2704         if not high:
2705             return high, errors
2706         if not isinstance(high, dict):
2707             errors.append(
2708                 "Template {} does not render to a dictionary".format(template)
2709             )
2710             return high, errors
2711         invalid_items = ("include", "exclude", "extends")
2712         for item in invalid_items:
2713             if item in high:
2714                 errors.append(
2715                     "The '{}' declaration found on '{}' is invalid when "
2716                     "rendering single templates".format(item, template)
2717                 )
2718                 return high, errors
2719         for name in high:
2720             if not isinstance(high[name], dict):
2721                 if isinstance(high[name], str):
2722                     if "." in high[name]:
2723                         comps = high[name].split(".")
2724                         high[name] = {
2725                             comps[0]: [comps[1]]
2726                         }
2727                         continue
2728                     errors.append(
2729                         "ID {} in template {} is not a dictionary".format(
2730                             name, template
2731                         )
2732                     )
2733                     continue
2734             skeys = set()
2735             for key in sorted(high[name]):
2736                 if key.startswith("_"):
2737                     continue
2738                 if high[name][key] is None:
2739                     errors.append(
2740                         "ID '{}' in template {} contains a short "
2741                         "declaration ({}) with a trailing colon. When not "
2742                         "passing any arguments to a state, the colon must be "
2743                         "omitted.".format(name, template, key)
2744                     )
2745                     continue
2746                 if not isinstance(high[name][key], list):
2747                     continue
2748                 if "." in key:
2749                     comps = key.split(".")
2750                     if comps[0] in skeys:
2751                         errors.append(
2752                             "ID '{}' in template '{}' contains multiple "
2753                             "state declarations of the same type".format(name, template)
2754                         )
2755                         continue
2756                     high[name][comps[0]] = high[name].pop(key)
2757                     high[name][comps[0]].append(comps[1])
2758                     skeys.add(comps[0])
2759                     continue
2760                 skeys.add(key)
2761         return high, errors
2762     def call_template(self, template):
2763         high = compile_template(
2764             template,
2765             self.rend,
2766             self.opts["renderer"],
2767             self.opts["renderer_blacklist"],
2768             self.opts["renderer_whitelist"],
2769         )
2770         if not high:
2771             return high
2772         high, errors = self.render_template(high, template)
2773         if errors:
2774             return errors
2775         return self.call_high(high)
2776     def call_template_str(self, template):
2777         high = compile_template_str(
2778             template,
2779             self.rend,
2780             self.opts["renderer"],
2781             self.opts["renderer_blacklist"],
2782             self.opts["renderer_whitelist"],
2783         )
2784         if not high:
2785             return high
2786         high, errors = self.render_template(high, "&lt;template-str&gt;")
2787         if errors:
2788             return errors
2789         return self.call_high(high)
2790 class LazyAvailStates:
2791     def __init__(self, hs):
2792         self._hs = hs
2793         self._avail = {"base": None}
2794         self._filled = False
2795     def _fill(self):
2796         if self._filled:
2797             return
2798         for saltenv in self._hs._get_envs():
2799             if saltenv not in self._avail:
2800                 self._avail[saltenv] = None
2801         self._filled = True
2802     def __contains__(self, saltenv):
2803         if saltenv == "base":
2804             return True
2805         self._fill()
2806         return saltenv in self._avail
2807     def __getitem__(self, saltenv):
2808         if saltenv != "base":
2809             self._fill()
2810         if saltenv not in self._avail or self._avail[saltenv] is None:
2811             self._avail[saltenv] = self._hs.client.list_states(saltenv)
2812         return self._avail[saltenv]
2813     def items(self):
2814         self._fill()
2815         ret = []
2816         for saltenv, states in self._avail.items():
2817             ret.append((saltenv, self.__getitem__(saltenv)))
2818         return ret
2819 class BaseHighState:
2820     def __init__(self, opts):
2821         self.opts = self.__gen_opts(opts)
2822         self.iorder = 10000
2823         self.avail = self.__gather_avail()
2824         self.building_highstate = OrderedDict()
2825     def __gather_avail(self):
2826         return LazyAvailStates(self)
2827     def __gen_opts(self, opts):
2828         if "local_state" in opts:
2829             if opts["local_state"]:
2830                 return opts
2831         mopts = self.client.master_opts()
2832         if not isinstance(mopts, dict):
2833             opts["renderer"] = "jinja|yaml"
2834             opts["failhard"] = False
2835             opts["state_top"] = salt.utils.url<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.create("top.sls")
2836             opts["nodegroups"] = {}
2837             opts["file_roots"] = {"base": [syspaths.BASE_FILE_ROOTS_DIR]}
2838         else:
2839             opts["renderer"] = mopts["renderer"]
2840 <a name="2"></a>            opts[</b></font>"failhard"] = mopts.get("failhard", False)
2841             if mopts["state_top"].startswith("salt://"):
2842                 opts["state_top"] = mopts["state_top"]
2843             elif mopts<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["state_top"].startswith("/"):
2844                 opts["state_top"] = salt.utils.url.create(mopts["state_top"][1:])
2845             else:
2846                 opts["state_top"] = salt.utils.</b></font>url.create(mopts["state_top"])
2847             opts["state_top_saltenv"] = mopts.get("state_top_saltenv", None)
2848             opts["nodegroups"] = mopts.get("nodegroups", {})
2849             opts["state_auto_order"] = mopts.get(
2850                 "state_auto_order", opts["state_auto_order"]
2851             )
2852             opts["file_roots"] = mopts["file_roots"]
2853             opts["top_file_merging_strategy"] = mopts.get(
2854                 "top_file_merging_strategy", opts.get("top_file_merging_strategy")
2855             )
2856             opts["env_order"] = mopts.get("env_order", opts.get("env_order", []))
2857             opts["default_top"] = mopts.get("default_top", opts.get("default_top"))
2858             opts["state_events"] = mopts.get("state_events")
2859             opts["state_aggregate"] = (
2860                 opts.get("state_aggregate") or mopts.get("state_aggregate") or False
2861             )
2862             opts["jinja_env"] = mopts.get("jinja_env", {})
2863             opts["jinja_sls_env"] = mopts.get("jinja_sls_env", {})
2864             opts["jinja_lstrip_blocks"] = mopts.get("jinja_lstrip_blocks", False)
2865             opts["jinja_trim_blocks"] = mopts.get("jinja_trim_blocks", False)
2866         return opts
2867     def _get_envs(self):
2868         envs = ["base"]
2869         if "file_roots" in self.opts:
2870             envs.extend([x for x in list(self.opts["file_roots"]) if x not in envs])
2871         env_order = self.opts.get("env_order", [])
2872         members = set()
2873         env_order = [
2874             env for env in env_order if not (env in members or members.add(env))
2875         ]
2876         client_envs = self.client.envs()
2877         if env_order and client_envs:
2878             return [env for env in env_order if env in client_envs]
2879         elif env_order:
2880             return env_order
2881         else:
2882             envs.extend([env for env in client_envs if env not in envs])
2883             return envs
2884     def get_tops(self):
2885         tops = DefaultOrderedDict(list)
2886         include = DefaultOrderedDict(list)
2887         done = DefaultOrderedDict(list)
2888         found = 0  # did we find any contents in the top files?
2889         merging_strategy = self.opts["top_file_merging_strategy"]
2890         if merging_strategy == "same" and not self.opts["saltenv"]:
2891             if not self.opts["default_top"]:
2892                 raise SaltRenderError(
2893                     "top_file_merging_strategy set to 'same', but no "
2894                     "default_top configuration option was set"
2895                 )
2896         if self.opts["saltenv"]:
2897             contents = self.client.cache_file(
2898                 self.opts["state_top"], self.opts["saltenv"]
2899             )
2900             if contents:
2901                 found = 1
2902                 tops[self.opts["saltenv"]] = [
2903                     compile_template(
2904                         contents,
2905                         self.state.rend,
2906                         self.state.opts["renderer"],
2907                         self.state.opts["renderer_blacklist"],
2908                         self.state.opts["renderer_whitelist"],
2909                         saltenv=self.opts["saltenv"],
2910                     )
2911                 ]
2912             else:
2913                 tops[self.opts["saltenv"]] = [{}]
2914         else:
2915             found = 0
2916             state_top_saltenv = self.opts.get("state_top_saltenv", False)
2917             if state_top_saltenv and not isinstance(state_top_saltenv, str):
2918                 state_top_saltenv = str(state_top_saltenv)
2919             for saltenv in (
2920                 [state_top_saltenv] if state_top_saltenv else self._get_envs()
2921             ):
2922                 contents = self.client.cache_file(self.opts["state_top"], saltenv)
2923                 if contents:
2924                     found = found + 1
2925                     tops[saltenv].append(
2926 <a name="8"></a>                        compile_template(
2927                             contents,
2928                             self.state.rend,
2929                             self.state.opts<font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["renderer"],
2930                             self.state.opts["renderer_blacklist"],
2931                             self.state.opts["renderer_whitelist"],
2932                             saltenv=saltenv,
2933                         )
2934                     )
2935                 else:
2936                     tops[saltenv].append({})
2937                     log.</b></font>debug("No contents loaded for saltenv '%s'", saltenv)
2938             if (
2939                 found &gt; 1
2940                 and merging_strategy == "merge"
2941                 and not self.opts.get("env_order", None)
2942             ):
2943                 log.warning(
2944                     "top_file_merging_strategy is set to '%s' and "
2945                     "multiple top files were found. Merging order is not "
2946                     "deterministic, it may be desirable to either set "
2947                     "top_file_merging_strategy to 'same' or use the "
2948                     "'env_order' configuration parameter to specify the "
2949                     "merging order.",
2950                     merging_strategy,
2951                 )
2952         if found == 0:
2953             log.debug(
2954                 "No contents found in top file. If this is not expected, "
2955                 "verify that the 'file_roots' specified in 'etc/master' "
2956                 "are accessible. The 'file_roots' configuration is: %s",
2957                 repr(self.state.opts["file_roots"]),
2958             )
2959         for saltenv, ctops in tops.items():
2960             for ctop in ctops:
2961                 if "include" not in ctop:
2962                     continue
2963                 for sls in ctop["include"]:
2964                     include[saltenv].append(sls)
2965                 ctop.pop("include")
2966         while include:
2967             pops = []
2968             for saltenv, states in include.items():
2969                 pops.append(saltenv)
2970                 if not states:
2971                     continue
2972                 for sls_match in states:
2973                     for sls in fnmatch.filter(self.avail[saltenv], sls_match):
2974                         if sls in done[saltenv]:
2975                             continue
2976                         tops[saltenv].append(
2977                             compile_template(
2978                                 self.client.get_state(sls, saltenv).get("dest", False),
2979                                 self.state.rend,
2980                                 self.state.opts["renderer"],
2981                                 self.state.opts["renderer_blacklist"],
2982                                 self.state.opts["renderer_whitelist"],
2983                                 saltenv,
2984                             )
2985                         )
2986                         done[saltenv].append(sls)
2987             for saltenv in pops:
2988                 if saltenv in include:
2989                     include.pop(saltenv)
2990         return tops
2991     def merge_tops(self, tops):
2992         merging_strategy = self.opts["top_file_merging_strategy"]
2993         try:
2994             merge_attr = "_merge_tops_{}".format(merging_strategy)
2995             merge_func = getattr(self, merge_attr)
2996             if not hasattr(merge_func, "__call__"):
2997                 msg = "'{}' is not callable".format(merge_attr)
2998                 log.error(msg)
2999                 raise TypeError(msg)
3000         except (AttributeError, TypeError):
3001             log.warning(
3002                 "Invalid top_file_merging_strategy '%s', falling back to 'merge'",
3003                 merging_strategy,
3004             )
3005             merge_func = self._merge_tops_merge
3006         return merge_func(tops)
3007     def _merge_tops_merge(self, tops):
3008         top = DefaultOrderedDict(OrderedDict)
3009         base_tops = tops.pop("base", DefaultOrderedDict(OrderedDict))
3010         for ctop in base_tops:
3011             for saltenv, targets in ctop.items():
3012                 if saltenv == "include":
3013                     continue
3014                 try:
3015                     for tgt in targets:
3016                         top[saltenv][tgt] = ctop[saltenv][tgt]
3017                 except TypeError:
3018                     raise SaltRenderError(
3019                         "Unable to render top file. No targets found."
3020                     )
3021         for cenv, ctops in tops.items():
3022             for ctop in ctops:
3023                 for saltenv, targets in ctop.items():
3024                     if saltenv == "include":
3025                         continue
3026                     elif saltenv != cenv:
3027                         log.debug(
3028                             "Section for saltenv '%s' in the '%s' "
3029                             "saltenv's top file will be ignored, as the "
3030                             "top_file_merging_strategy is set to 'merge' "
3031                             "and the saltenvs do not match",
3032                             saltenv,
3033                             cenv,
3034                         )
3035                         continue
3036                     elif saltenv in top:
3037                         log.debug(
3038                             "Section for saltenv '%s' in the '%s' "
3039                             "saltenv's top file will be ignored, as this "
3040                             "saltenv was already defined in the 'base' top "
3041                             "file",
3042                             saltenv,
3043                             cenv,
3044                         )
3045                         continue
3046                     try:
3047                         for tgt in targets:
3048                             top[saltenv][tgt] = ctop[saltenv][tgt]
3049                     except TypeError:
3050                         raise SaltRenderError(
3051                             "Unable to render top file. No targets found."
3052                         )
3053         return top
3054     def _merge_tops_same(self, tops):
3055         top = DefaultOrderedDict(OrderedDict)
3056         for cenv, ctops in tops.items():
3057             if all([x == {} for x in ctops]):
3058                 default_top = self.opts["default_top"]
3059                 fallback_tops = tops.get(default_top, [])
3060                 if all([x == {} for x in fallback_tops]):
3061                     log.error(
3062                         "The '%s' saltenv has no top file, and the fallback "
3063                         "saltenv specified by default_top (%s) also has no "
3064                         "top file",
3065                         cenv,
3066                         default_top,
3067                     )
3068                     continue
3069                 for ctop in fallback_tops:
3070                     for saltenv, targets in ctop.items():
3071                         if saltenv != cenv:
3072                             continue
3073                         log.debug(
3074                             "The '%s' saltenv has no top file, using the "
3075                             "default_top saltenv (%s)",
3076                             cenv,
3077                             default_top,
3078                         )
3079                         for tgt in targets:
3080                             top[saltenv][tgt] = ctop[saltenv][tgt]
3081                         break
3082                     else:
3083                         log.error(
3084                             "The '%s' saltenv has no top file, and no "
3085                             "matches were found in the top file for the "
3086                             "default_top saltenv (%s)",
3087                             cenv,
3088                             default_top,
3089                         )
3090                 continue
3091             else:
3092                 for ctop in ctops:
3093                     for saltenv, targets in ctop.items():
3094                         if saltenv == "include":
3095                             continue
3096                         elif saltenv != cenv:
3097                             log.debug(
3098                                 "Section for saltenv '%s' in the '%s' "
3099                                 "saltenv's top file will be ignored, as the "
3100                                 "top_file_merging_strategy is set to 'same' "
3101                                 "and the saltenvs do not match",
3102                                 saltenv,
3103                                 cenv,
3104                             )
3105                             continue
3106                         try:
3107                             for tgt in targets:
3108                                 top[saltenv][tgt] = ctop[saltenv][tgt]
3109                         except TypeError:
3110                             raise SaltRenderError(
3111                                 "Unable to render top file. No targets found."
3112                             )
3113         return top
3114     def _merge_tops_merge_all(self, tops):
3115         def _read_tgt(tgt):
3116             match_type = None
3117             states = []
3118             for item in tgt:
3119                 if isinstance(item, dict):
3120                     match_type = item
3121                 if isinstance(item, str):
3122                     states.append(item)
3123             return match_type, states
3124         top = DefaultOrderedDict(OrderedDict)
3125         for ctops in tops.values():
3126             for ctop in ctops:
3127                 for saltenv, targets in ctop.items():
3128                     if saltenv == "include":
3129                         continue
3130                     try:
3131                         for tgt in targets:
3132                             if tgt not in top[saltenv]:
3133                                 top[saltenv][tgt] = ctop[saltenv][tgt]
3134                                 continue
3135                             m_type1, m_states1 = _read_tgt(top[saltenv][tgt])
3136                             m_type2, m_states2 = _read_tgt(ctop[saltenv][tgt])
3137                             merged = []
3138                             match_type = m_type2 or m_type1
3139                             if match_type is not None:
3140                                 merged.append(match_type)
3141                             merged.extend(m_states1)
3142                             merged.extend([x for x in m_states2 if x not in merged])
3143                             top[saltenv][tgt] = merged
3144                     except TypeError:
3145                         raise SaltRenderError(
3146                             "Unable to render top file. No targets found."
3147                         )
3148         return top
3149     def verify_tops(self, tops):
3150         errors = []
3151         if not isinstance(tops, dict):
3152             errors.append("Top data was not formed as a dict")
3153             return errors
3154         for saltenv, matches in tops.items():
3155             if saltenv == "include":
3156                 continue
3157             if not isinstance(saltenv, str):
3158                 errors.append(
3159                     "Environment {} in top file is not formed as a string".format(
3160                         saltenv
3161                     )
3162                 )
3163             if saltenv == "":
3164                 errors.append("Empty saltenv statement in top file")
3165             if not isinstance(matches, dict):
3166                 errors.append(
3167                     "The top file matches for saltenv {} are not "
3168                     "formatted as a dict".format(saltenv)
3169                 )
3170             for slsmods in matches.values():
3171                 if not isinstance(slsmods, list):
3172                     errors.append(
3173                         "Malformed topfile (state declarations not formed as a list)"
3174                     )
3175                     continue
3176                 for slsmod in slsmods:
3177                     if isinstance(slsmod, dict):
3178                         for val in slsmod.values():
3179                             if not val:
3180                                 errors.append(
3181                                     "Improperly formatted top file matcher "
3182                                     "in saltenv {}: {} file".format(slsmod, val)
3183                                 )
3184                     elif isinstance(slsmod, str):
3185                         if not slsmod:
3186                             errors.append(
3187                                 "Environment {} contains an empty sls index".format(
3188                                     saltenv
3189                                 )
3190                             )
3191         return errors
3192     def get_top(self):
3193         try:
3194             tops = self.get_tops()
3195         except SaltRenderError as err:
3196             log.error("Unable to render top file: %s", err.error)
3197             return {}
3198         return self.merge_tops(tops)
3199     def top_matches(self, top):
3200         matches = DefaultOrderedDict(OrderedDict)
3201         for saltenv, body in top.items():
3202             if self.opts["saltenv"]:
3203                 if saltenv != self.opts["saltenv"]:
3204                     continue
3205             for match, data in body.items():
3206                 def _filter_matches(_match, _data, _opts):
3207                     if isinstance(_data, str):
3208                         _data = [_data]
3209                     if self.matchers["confirm_top.confirm_top"](_match, _data, _opts):
3210                         if saltenv not in matches:
3211                             matches[saltenv] = []
3212                         for item in _data:
3213                             if "subfilter" in item:
3214                                 _tmpdata = item.pop("subfilter")
3215                                 for match, data in _tmpdata.items():
3216                                     _filter_matches(match, data, _opts)
3217                             if isinstance(item, str):
3218                                 matches[saltenv].append(item)
3219                             elif isinstance(item, dict):
3220                                 env_key, inc_sls = item.popitem()
3221                                 if env_key not in self.avail:
3222                                     continue
3223                                 if env_key not in matches:
3224                                     matches[env_key] = []
3225                                 matches[env_key].append(inc_sls)
3226                 _filter_matches(match, data, self.opts["nodegroups"])
3227         ext_matches = self._master_tops()
3228         for saltenv in ext_matches:
3229             top_file_matches = matches.get(saltenv, [])
3230             if self.opts.get("master_tops_first"):
3231                 first = ext_matches[saltenv]
3232                 second = top_file_matches
3233             else:
3234                 first = top_file_matches
3235                 second = ext_matches[saltenv]
3236             matches[saltenv] = first + [x for x in second if x not in first]
3237         return matches
3238     def _master_tops(self):
3239         return self.client.master_tops()
3240     def load_dynamic(self, matches):
3241         if not self.opts["autoload_dynamic_modules"]:
3242             return
3243         syncd = self.state.functions["saltutil.sync_all"](list(matches), refresh=False)
3244         if syncd["grains"]:
3245             self.opts["grains"] = salt.loader.grains(self.opts)
3246             self.state.opts["pillar"] = self.state._gather_pillar()
3247         self.state.module_refresh()
3248     def render_state(self, sls, saltenv, mods, matches, local=False, context=None):
3249         errors = []
3250         if not local:
3251             state_data = self.client.get_state(sls, saltenv)
3252             fn_ = state_data.get("dest", False)
3253         else:
3254             fn_ = sls
3255             if not os.path.isfile(fn_):
3256                 errors.append(
3257                     "Specified SLS {} on local filesystem cannot be found.".format(sls)
3258                 )
3259         state = None
3260         if not fn_:
3261             errors.append(
3262                 "Specified SLS {} in saltenv {} is not "
3263                 "available on the salt master or through a configured "
3264                 "fileserver".format(sls, saltenv)
3265             )
3266         else:
3267             try:
3268                 state = compile_template(
3269                     fn_,
3270                     self.state.rend,
3271                     self.state.opts["renderer"],
3272                     self.state.opts["renderer_blacklist"],
3273                     self.state.opts["renderer_whitelist"],
3274                     saltenv,
3275                     sls,
3276                     rendered_sls=mods,
3277                     context=context,
3278                 )
3279             except SaltRenderError as exc:
3280                 msg = "Rendering SLS '{}:{}' failed: {}".format(saltenv, sls, exc)
3281                 log.critical(msg)
3282                 errors.append(msg)
3283             except Exception as exc:  # pylint: disable=broad-except
3284                 msg = "Rendering SLS {} failed, render error: {}".format(sls, exc)
3285                 log.critical(
3286                     msg,
3287                     exc_info_on_loglevel=logging.DEBUG,
3288                 )
3289                 errors.append("{}\n{}".format(msg, traceback.format_exc()))
3290             try:
3291                 mods.add("{}:{}".format(saltenv, sls))
3292             except AttributeError:
3293                 pass
3294         if state:
3295             if not isinstance(state, dict):
3296                 errors.append("SLS {} does not render to a dictionary".format(sls))
3297             else:
3298                 include = []
3299                 if "include" in state:
3300                     if not isinstance(state["include"], list):
3301                         err = (
3302                             "Include Declaration in SLS {} is not formed "
3303                             "as a list".format(sls)
3304                         )
3305                         errors.append(err)
3306                     else:
3307                         include = state.pop("include")
3308                 self._handle_extend(state, sls, saltenv, errors)
3309                 self._handle_exclude(state, sls, saltenv, errors)
3310                 self._handle_state_decls(state, sls, saltenv, errors)
3311                 for inc_sls in include:
3312                     xenv_key = "_xenv"
3313                     if isinstance(inc_sls, dict):
3314                         env_key, inc_sls = inc_sls.popitem()
3315                     else:
3316                         env_key = saltenv
3317                     if env_key not in self.avail and "__env__" not in self.avail:
3318                         msg = (
3319                             "Nonexistent saltenv '{}' found in include "
3320                             "of '{}' within SLS '{}:{}'".format(
3321                                 env_key, inc_sls, saltenv, sls
3322                             )
3323                         )
3324                         log.error(msg)
3325                         errors.append(msg)
3326                         continue
3327                     if inc_sls.startswith("."):
3328                         match = re.match(r"^(\.+)(.*)$", inc_sls)
3329                         if match:
3330                             levels, include = match.groups()
3331                         else:
3332                             msg = (
3333                                 "Badly formatted include {} found in include "
3334                                 "in SLS '{}:{}'".format(inc_sls, saltenv, sls)
3335                             )
3336                             log.error(msg)
3337                             errors.append(msg)
3338                             continue
3339                         level_count = len(levels)
3340                         p_comps = sls.split(".")
3341                         if state_data.get("source", "").endswith("/init.sls"):
3342                             p_comps.append("init")
3343                         if level_count &gt; len(p_comps):
3344                             msg = (
3345                                 "Attempted relative include of '{}' "
3346                                 "within SLS '{}:{}' "
3347                                 "goes beyond top level package ".format(
3348                                     inc_sls, saltenv, sls
3349                                 )
3350                             )
3351                             log.error(msg)
3352                             errors.append(msg)
3353                             continue
3354                         inc_sls = ".".join(p_comps[:-level_count] + [include])
3355                     if env_key != xenv_key:
3356                         if matches is None:
3357                             matches = []
3358                         if env_key in matches or fnmatch.filter(
3359                             self.avail[env_key], inc_sls
3360                         ):
3361                             resolved_envs = [env_key]
3362                         else:
3363                             resolved_envs = []
3364                     else:
3365                         resolved_envs = [
3366                             aenv
3367                             for aenv in matches
3368                             if fnmatch.filter(self.avail[aenv], inc_sls)
3369                         ]
3370                     if len(resolved_envs) == 1 or saltenv in resolved_envs:
3371                         sls_targets = fnmatch.filter(self.avail[saltenv], inc_sls) or [
3372                             inc_sls
3373                         ]
3374                         for sls_target in sls_targets:
3375                             r_env = (
3376                                 resolved_envs[0] if len(resolved_envs) == 1 else saltenv
3377                             )
3378                             mod_tgt = "{}:{}".format(r_env, sls_target)
3379                             if mod_tgt not in mods:
3380                                 nstate, err = self.render_state(
3381                                     sls_target, r_env, mods, matches
3382                                 )
3383                                 if nstate:
3384                                     self.merge_included_states(state, nstate, errors)
3385                                     state.update(nstate)
3386                                 if err:
3387                                     errors.extend(err)
3388                     else:
3389                         msg = ""
3390                         if not resolved_envs:
3391                             msg = (
3392                                 "Unknown include: Specified SLS {}: {} is not available"
3393                                 " on the salt master in saltenv(s): {} ".format(
3394                                     env_key,
3395                                     inc_sls,
3396                                     ", ".join(matches)
3397                                     if env_key == xenv_key
3398                                     else env_key,
3399                                 )
3400                             )
3401                         elif len(resolved_envs) &gt; 1:
3402                             msg = (
3403                                 "Ambiguous include: Specified SLS {}: {} is available"
3404                                 " on the salt master in multiple available saltenvs: {}".format(
3405                                     env_key, inc_sls, ", ".join(resolved_envs)
3406                                 )
3407                             )
3408                         log.critical(msg)
3409                         errors.append(msg)
3410                 try:
3411                     self._handle_iorder(state)
3412                 except TypeError:
3413                     log.critical("Could not render SLS %s. Syntax error detected.", sls)
3414         else:
3415             state = {}
3416         return state, errors
3417     def _handle_iorder(self, state):
3418         if self.opts["state_auto_order"]:
3419             for name in state:
3420                 for s_dec in state[name]:
3421                     if not isinstance(s_dec, str):
3422                         continue
3423                     if not isinstance(state[name], dict):
3424                         continue
3425                     if not isinstance(state[name][s_dec], list):
3426                         continue
3427                     found = False
3428                     if s_dec.startswith("_"):
3429                         continue
3430                     for arg in state[name][s_dec]:
3431                         if isinstance(arg, dict):
3432                             if len(arg) &gt; 0:
3433                                 if next(iter(arg.keys())) == "order":
3434                                     found = True
3435                     if not found:
3436                         if not isinstance(state[name][s_dec], list):
3437                             continue
3438                         state[name][s_dec].append({"order": self.iorder})
3439                         self.iorder += 1
3440         return state
3441     def _handle_state_decls(self, state, sls, saltenv, errors):
3442         for name in state:
3443             if not isinstance(state[name], dict):
3444                 if name == "__extend__":
3445                     continue
3446                 if name == "__exclude__":
3447                     continue
3448                 if isinstance(state[name], str):
3449                     if "." in state[name]:
3450                         comps = state[name].split(".")
3451                         state[name] = {
3452                             "__sls__": sls,
3453                             "__env__": saltenv,
3454                             comps[0]: [comps[1]],
3455                         }
3456                         continue
3457                 errors.append("ID {} in SLS {} is not a dictionary".format(name, sls))
3458                 continue
3459             skeys = set()
3460             for key in list(state[name]):
3461                 if key.startswith("_"):
3462                     continue
3463                 if not isinstance(state[name][key], list):
3464                     continue
3465                 if "." in key:
3466                     comps = key.split(".")
3467                     if comps[0] in skeys:
3468                         errors.append(
3469                             "ID '{}' in SLS '{}' contains multiple state "
3470                             "declarations of the same type".format(name, sls)
3471                         )
3472                         continue
3473                     state[name][comps[0]] = state[name].pop(key)
3474                     state[name][comps[0]].append(comps[1])
3475                     skeys.add(comps[0])
3476                     continue
3477                 skeys.add(key)
3478             if "__sls__" not in state[name]:
3479                 state[name]["__sls__"] = sls
3480             if "__env__" not in state[name]:
3481                 state[name]["__env__"] = saltenv
3482     def _handle_extend(self, state, sls, saltenv, errors):
3483         if "extend" in state:
3484             ext = state.pop("extend")
3485             if not isinstance(ext, dict):
3486                 errors.append(
3487                     "Extension value in SLS '{}' is not a dictionary".format(sls)
3488                 )
3489                 return
3490             for name in ext:
3491                 if not isinstance(ext[name], dict):
3492                     errors.append(
3493                         "Extension name '{}' in SLS '{}' is not a dictionary".format(
3494                             name, sls
3495                         )
3496                     )
3497                     continue
3498                 if "__sls__" not in ext[name]:
3499                     ext[name]["__sls__"] = sls
3500                 if "__env__" not in ext[name]:
3501                     ext[name]["__env__"] = saltenv
3502                 for key in list(ext[name]):
3503                     if key.startswith("_"):
3504                         continue
3505                     if not isinstance(ext[name][key], list):
3506                         continue
3507                     if "." in key:
3508                         comps = key.split(".")
3509                         ext[name][comps[0]] = ext[name].pop(key)
3510                         ext[name][comps[0]].append(comps[1])
3511             state.setdefault("__extend__", []).append(ext)
3512     def _handle_exclude(self, state, sls, saltenv, errors):
3513         if "exclude" in state:
3514             exc = state.pop("exclude")
3515             if not isinstance(exc, list):
3516                 err = "Exclude Declaration in SLS {} is not formed as a list".format(
3517                     sls
3518                 )
3519                 errors.append(err)
3520             state.setdefault("__exclude__", []).extend(exc)
3521     def render_highstate(self, matches, context=None):
3522         highstate = self.building_highstate
3523         all_errors = []
3524         mods = set()
3525         statefiles = []
3526         for saltenv, states in matches.items():
3527             for sls_match in states:
3528                 if saltenv in self.avail:
3529                     statefiles = fnmatch.filter(self.avail[saltenv], sls_match)
3530                 elif "__env__" in self.avail:
3531                     statefiles = fnmatch.filter(self.avail["__env__"], sls_match)
3532                 else:
3533                     all_errors.append(
3534                         "No matching salt environment for environment "
3535                         "'{}' found".format(saltenv)
3536                     )
3537                 if not statefiles:
3538                     statefiles = [sls_match]
3539                 for sls in statefiles:
3540                     r_env = "{}:{}".format(saltenv, sls)
3541                     if r_env in mods:
3542                         continue
3543                     state, errors = self.render_state(
3544                         sls, saltenv, mods, matches, context=context
3545                     )
3546                     if state:
3547                         self.merge_included_states(highstate, state, errors)
3548                     for i, error in enumerate(errors[:]):
3549                         if "is not available" in error:
3550                             this_sls = "SLS {} in saltenv".format(sls_match)
3551                             if this_sls in error:
3552                                 errors[
3553                                     i
3554                                 ] = "No matching sls found for '{}' in env '{}'".format(
3555                                     sls_match, saltenv
3556                                 )
3557                     all_errors.extend(errors)
3558         self.clean_duplicate_extends(highstate)
3559         return highstate, all_errors
3560     def clean_duplicate_extends(self, highstate):
3561         if "__extend__" in highstate:
3562             highext = []
3563             for items in (ext.items() for ext in highstate["__extend__"]):
3564                 for item in items:
3565                     if item not in highext:
3566                         highext.append(item)
3567             highstate["__extend__"] = [{t[0]: t[1]} for t in highext]
3568     def merge_included_states(self, highstate, state, errors):
3569         if "__extend__" in state:
3570             highstate.setdefault("__extend__", []).extend(state.pop("__extend__"))
3571         if "__exclude__" in state:
3572             highstate.setdefault("__exclude__", []).extend(state.pop("__exclude__"))
3573         for id_ in state:
3574             if id_ in highstate:
3575                 if highstate[id_] != state[id_]:
3576                     errors.append(
3577                         "Detected conflicting IDs, SLS"
3578                         " IDs need to be globally unique.\n    The"
3579                         " conflicting ID is '{}' and is found in SLS"
3580                         " '{}:{}' and SLS '{}:{}'".format(
3581                             id_,
3582                             highstate[id_]["__env__"],
3583                             highstate[id_]["__sls__"],
3584                             state[id_]["__env__"],
3585                             state[id_]["__sls__"],
3586                         )
3587                     )
3588         try:
3589             highstate.update(state)
3590         except ValueError:
3591             errors.append("Error when rendering state with contents: {}".format(state))
3592     def _check_pillar(self, force=False):
3593         if force:
3594             return True
3595         if "_errors" in self.state.opts["pillar"]:
3596             return False
3597         return True
3598     def matches_whitelist(self, matches, whitelist):
3599         if not whitelist:
3600             return matches
3601         ret_matches = {}
3602         if not isinstance(whitelist, list):
3603             whitelist = whitelist.split(",")
3604         for env in matches:
3605             for sls in matches[env]:
3606                 if sls in whitelist:
3607                     ret_matches[env] = ret_matches[env] if env in ret_matches else []
3608                     ret_matches[env].append(sls)
3609         return ret_matches
3610     def call_highstate(
3611         self,
3612         exclude=None,
3613         cache=None,
3614         cache_name="highstate",
3615         force=False,
3616         whitelist=None,
3617         orchestration_jid=None,
3618     ):
3619         tag_name = "no_|-states_|-states_|-None"
3620         ret = {
3621             tag_name: {
3622                 "result": False,
3623                 "comment": "No states found for this minion",
3624                 "name": "No States",
3625                 "changes": {},
3626                 "__run_num__": 0,
3627             }
3628         }
3629         cfn = os.path.join(self.opts["cachedir"], "{}.cache.p".format(cache_name))
3630         if cache:
3631             if os.path.isfile(cfn):
3632                 with salt.utils.files.fopen(cfn, "rb") as fp_:
3633                     high = salt.payload.load(fp_)
3634                     return self.state.call_high(high, orchestration_jid)
3635         err = []
3636         try:
3637             top = self.get_top()
3638         except SaltRenderError as err:
3639             ret[tag_name]["comment"] = "Unable to render top file: "
3640             ret[tag_name]["comment"] += str(err.error)
3641             return ret
3642         except Exception:  # pylint: disable=broad-except
3643             trb = traceback.format_exc()
3644             err.append(trb)
3645             return err
3646         err += self.verify_tops(top)
3647         matches = self.top_matches(top)
3648         if not matches:
3649             msg = (
3650                 "No Top file or master_tops data matches found. Please see "
3651                 "master log for details."
3652             )
3653             ret[tag_name]["comment"] = msg
3654             return ret
3655         matches = self.matches_whitelist(matches, whitelist)
3656         self.load_dynamic(matches)
3657         if not self._check_pillar(force):
3658             err += ["Pillar failed to render with the following messages:"]
3659             err += self.state.opts["pillar"]["_errors"]
3660         else:
3661             high, errors = self.render_highstate(matches)
3662             if exclude:
3663                 if isinstance(exclude, str):
3664                     exclude = exclude.split(",")
3665                 if "__exclude__" in high:
3666                     high["__exclude__"].extend(exclude)
3667                 else:
3668                     high["__exclude__"] = exclude
3669             err += errors
3670         if err:
3671             return err
3672         if not high:
3673             return ret
3674         with salt.utils.files.set_umask(0o077):
3675             try:
3676                 if salt.utils.platform.is_windows():
3677                     self.state.functions["cmd.run"](
3678                         ["attrib", "-R", cfn],
3679                         python_shell=False,
3680                         output_loglevel="quiet",
3681                     )
3682                 with salt.utils.files.fopen(cfn, "w+b") as fp_:
3683                     try:
3684                         salt.payload.dump(high, fp_)
3685                     except TypeError:
3686                         pass
3687             except OSError:
3688                 log.error('Unable to write to "state.highstate" cache file %s', cfn)
3689         return self.state.call_high(high, orchestration_jid)
3690     def compile_highstate(self):
3691         err = []
3692         top = self.get_top()
3693         err += self.verify_tops(top)
3694         matches = self.top_matches(top)
3695         high, errors = self.render_highstate(matches)
3696         err += errors
3697         if err:
3698             return err
3699         return high
3700     def compile_low_chunks(self):
3701         top = self.get_top()
3702         matches = self.top_matches(top)
3703         high, errors = self.render_highstate(matches)
3704         high, ext_errors = self.state.reconcile_extend(high)
3705         errors += ext_errors
3706         errors += self.state.verify_high(high)
3707         high, req_in_errors = self.state.requisite_in(high)
3708         errors += req_in_errors
3709         high = self.state.apply_exclude(high)
3710         if errors:
3711             return errors
3712         chunks = self.state.compile_high_data(high)
3713         return chunks
3714     def compile_state_usage(self):
3715         err = []
3716         top = self.get_top()
3717         err += self.verify_tops(top)
3718         if err:
3719             return err
3720         matches = self.top_matches(top)
3721         state_usage = {}
3722         for saltenv, states in self.avail.items():
3723             env_usage = {
3724                 "used": [],
3725                 "unused": [],
3726                 "count_all": 0,
3727                 "count_used": 0,
3728                 "count_unused": 0,
3729             }
3730             env_matches = matches.get(saltenv, [])
3731             for state in states:
3732                 env_usage["count_all"] += 1
3733                 if state in env_matches:
3734                     env_usage["count_used"] += 1
3735                     env_usage["used"].append(state)
3736                 else:
3737                     env_usage["count_unused"] += 1
3738                     env_usage["unused"].append(state)
3739             state_usage[saltenv] = env_usage
3740         return state_usage
3741     def destroy(self):
3742         raise NotImplementedError
3743     def __enter__(self):
3744         return self
3745     def __exit__(self, *_):
3746         self.destroy()
3747 class HighState(BaseHighState):
3748     stack = []
3749     def __init__(
3750         self,
3751         opts,
3752         pillar_override=None,
3753         jid=None,
3754         pillar_enc=None,
3755         proxy=None,
3756         context=None,
3757         mocked=False,
3758         loader="states",
3759         initial_pillar=None,
3760     ):
3761         self.opts = opts
3762         self.client = salt.fileclient.get_file_client(self.opts)
3763         BaseHighState.__init__(self, opts)
3764         self.state = State(
3765             self.opts,
3766             pillar_override,
3767             jid,
3768             pillar_enc,
3769             proxy=proxy,
3770             context=context,
3771             mocked=mocked,
3772             loader=loader,
3773             initial_pillar=initial_pillar,
3774         )
3775         self.matchers = salt.loader.matchers(self.opts)
3776         self.proxy = proxy
3777         self._pydsl_all_decls = {}
3778         self._pydsl_render_stack = []
3779     def push_active(self):
3780         self.stack.append(self)
3781     @classmethod
3782     def clear_active(cls):
3783         cls.stack = []
3784     @classmethod
3785     def pop_active(cls):
3786         cls.stack.pop()
3787     @classmethod
3788     def get_active(cls):
3789         try:
3790             return cls.stack[-1]
3791         except IndexError:
3792             return None
3793     def destroy(self):
3794         self.client.destroy()
3795     def __enter__(self):
3796         return self
3797     def __exit__(self, *_):
3798         self.destroy()
3799 class MasterState(State):
3800     def __init__(self, opts, minion):
3801         State.__init__(self, opts)
3802     def load_modules(self, data=None, proxy=None):
3803         log.info("Loading fresh modules for state activity")
3804         self.functions = salt.client.FunctionWrapper(self.opts, self<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.opts["id"])
3805         self.utils = salt.loader.utils(self.opts)
3806         self.serializers = salt.loader.serializers(self.</b></font>opts)
3807         self.states = salt.loader.states(
3808             self.opts, self.functions, self.utils, self.serializers
3809         )
3810         self.rend = salt.loader.render(
3811             self.opts, self.functions, states=self.states, context=self.state_con
3812         )
3813 class MasterHighState(HighState):
3814     def __init__(self, master_opts, minion_opts, grains, id_, saltenv=None):
3815         opts = copy.deepcopy(minion_opts)
3816         opts["file_client"] = "local"
3817         opts["file_roots"] = master_opts["master_roots"]
3818         opts["renderer"] = master_opts["renderer"]
3819         opts["state_top"] = master_opts["state_top"]
3820         opts["id"] = id_
3821         opts["grains"] = grains
3822         HighState.__init__(self, opts)
3823 class RemoteHighState:
3824     def __init__(self, opts, grains):
3825         self.opts = opts
3826         self.grains = grains
3827         self.channel = salt.channel.client.ReqChannel.factory(self.opts["master_uri"])
3828         self._closing = False
3829     def compile_master(self):
3830         load = {"grains": self.grains, "opts": self.opts, "cmd": "_master_state"}
3831         try:
3832             return self.channel.send(load, tries=3, timeout=72000)
3833         except SaltReqTimeoutError:
3834             return {}
3835     def destroy(self):
3836         if self._closing:
3837             return
3838         self._closing = True
3839         self.channel.close()
3840     def __del__(self):
3841         self.destroy()
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
