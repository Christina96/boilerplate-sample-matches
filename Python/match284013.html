<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_iptables_1.py &amp; postgres_2.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_iptables_1.py &amp; postgres_2.py
      </h3>
<h1 align="center">
        0.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_iptables_1.py (1.5738499%)<th>postgres_2.py (0.45343566%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(49-55)<td><a href="#" name="0">(605-614)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_iptables_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import textwrap
2 import uuid
3 import salt.modules.iptables as iptables
4 from tests.support.mixins import LoaderModuleMockMixin
5 from tests.support.mock import MagicMock, mock_open, patch
6 from tests.support.unit import TestCase
7 class IptablesTestCase(TestCase, LoaderModuleMockMixin):
8     def setup_loader_modules(self):
9         return {iptables: {}}
10     def test_version(self):
11         mock = MagicMock(return_value="iptables v1.4.21")
12         with patch.dict(iptables.__salt__, {"cmd.run_stdout": mock}):
13             self.assertEqual(iptables.version(), "v1.4.21")
14     def test_build_rule(self):
15         with patch.object(iptables, "_has_option", MagicMock(return_value=True)):
16             self.assertEqual(iptables.build_rule(), "")
17             self.assertEqual(
18                 iptables.build_rule(name="ignored", state="ignored"),
19                 "",
20                 "build_rule should ignore name and state",
21             self.assertEqual(iptables<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.build_rule(**{"if": "!eth0"}), "! -i eth0")
22             self.assertEqual(iptables.build_rule(**{"if": "not eth0"}), "! -i eth0")
23             self.assertEqual(
24                 iptables.build_rule(**{"protocol"</b></font>: "tcp", "syn": "!"}), "-p tcp ! --syn"
25             )
26             self.assertEqual(
27                 iptables.build_rule(dports=[80, 443], protocol="tcp"),
28                 "-p tcp -m multiport --dports 80,443",
29             )
30             self.assertEqual(
31                 iptables.build_rule(dports="80,443", protocol="tcp"),
32                 "-p tcp -m multiport --dports 80,443",
33             )
34             self.assertEqual(
35                 iptables.build_rule(dports=["!80", 443], protocol="tcp"),
36                 "-p tcp -m multiport ! --dports 80,443",
37             )
38             self.assertEqual(
39                 iptables.build_rule(dports="!80,443", protocol="tcp"),
40                 "-p tcp -m multiport ! --dports 80,443",
41             )
42             self.assertEqual(
43                 iptables.build_rule(sports=[80, 443], protocol="tcp"),
44                 "-p tcp -m multiport --sports 80,443",
45             )
46             self.assertEqual(
47                 iptables.build_rule(sports="80,443", protocol="tcp"),
48                 "-p tcp -m multiport --sports 80,443",
49             )
50             self.assertEqual(
51                 iptables.build_rule(
52                     "filter",
53                     "INPUT",
54                     command="I",
55                     position="3",
56                     full=True,
57                     dports="protocol",
58                     jump="ACCEPT",
59                 ),
60                 "Error: protocol must be specified",
61             )
62             self.assertEqual(
63                 iptables.build_rule(
64                     "filter",
65                     "INPUT",
66                     command="I",
67                     position="3",
68                     full=True,
69                     sports="protocol",
70                     jump="ACCEPT",
71                 ),
72                 "Error: protocol must be specified",
73             )
74             self.assertEqual(
75                 iptables.build_rule(
76                     "",
77                     "INPUT",
78                     command="I",
79                     position="3",
80                     full="True",
81                     match="state",
82                     jump="ACCEPT",
83                 ),
84                 "Error: Table needs to be specified",
85             )
86             self.assertEqual(
87                 iptables.build_rule(
88                     "filter",
89                     "",
90                     command="I",
91                     position="3",
92                     full="True",
93                     match="state",
94                     jump="ACCEPT",
95                 ),
96                 "Error: Chain needs to be specified",
97             )
98             self.assertEqual(
99                 iptables.build_rule(
100                     "filter",
101                     "INPUT",
102                     command="",
103                     position="3",
104                     full="True",
105                     match="state",
106                     jump="ACCEPT",
107                 ),
108                 "Error: Command needs to be specified",
109             )
110             self.assertEqual(
111                 iptables.build_rule(jump="REDIRECT", **{"to-port": 8080}),
112                 "--jump REDIRECT --to-port 8080",
113             )
114             self.assertEqual(
115                 iptables.build_rule(jump="LOG", **{"log-prefix": "long prefix"}),
116                 '--jump LOG --log-prefix "long prefix"',
117             )
118             self.assertEqual(
119                 iptables.build_rule(jump="LOG", **{"log-prefix": "spam: "}),
120                 '--jump LOG --log-prefix "spam: "',
121             )
122             self.assertEqual(
123                 iptables.build_rule(jump="CLUSTERIP", **{"new": ""}),
124                 "--jump CLUSTERIP --new",
125             )
126             self.assertEqual(
127                 iptables.build_rule(jump="CT", **{"notrack": None}),
128                 "--jump CT --notrack",
129             )
130             self.assertEqual(
131                 iptables.build_rule(**{"match-set": "src flag1,flag2"}),
132                 "-m set --match-set src flag1,flag2",
133             )
134             match_sets = [
135                 "src1 flag1",
136                 "src2 flag2,flag3",
137             ]
138             self.assertEqual(
139                 iptables.build_rule(**{"match-set": match_sets}),
140                 "-m set --match-set src1 flag1 -m set --match-set src2 flag2,flag3",
141             )
142             self.assertEqual(
143                 iptables.build_rule(**{"match-set": "!src flag"}),
144                 "-m set ! --match-set src flag",
145             )
146             match_sets = ["src1 flag", "not src2 flag2"]
147             self.assertEqual(
148                 iptables.build_rule(**{"match-set": match_sets}),
149                 "-m set --match-set src1 flag -m set ! --match-set src2 flag2",
150             )
151             self.assertEqual(
152                 iptables.build_rule(**{"match": "recent", "name_": "SSH"}),
153                 "-m recent --name SSH",
154             )
155             self.assertEqual(
156                 iptables.build_rule(**{"match": "recent", "update": None}),
157                 "-m recent --update",
158             )
159             ret = "/sbin/iptables --wait -t salt -I INPUT 3 -m state --jump ACCEPT"
160             with patch.object(
161                 iptables, "_iptables_cmd", MagicMock(return_value="/sbin/iptables")
162             ):
163                 self.assertEqual(
164                     iptables.build_rule(
165                         "salt",
166                         "INPUT",
167                         command="I",
168                         position="3",
169                         full="True",
170                         match="state",
171                         jump="ACCEPT",
172                     ),
173                     ret,
174                 )
175     def test_get_saved_rules(self):
176         mock = MagicMock(return_value=False)
177         with patch.object(iptables, "_parse_conf", mock):
178             self.assertFalse(iptables.get_saved_rules())
179             mock.assert_called_with(conf_file=None, family="ipv4")
180     def test_get_saved_rules_nilinuxrt(self):
181         data = {
182             "/etc/natinst/share/iptables.conf": textwrap.dedent(
183             )
184         }
185         expected_input_rules = [
186             {
187                 "protocol": ["tcp"],
188                 "jump": ["ACCEPT"],
189                 "match": ["tcp"],
190                 "destination_port": ["80"],
191             }
192         ]
193         file_mock = mock_open(read_data=data)
194         with patch.dict(
195             iptables.__grains__, {"os_family": "NILinuxRT", "os": "NILinuxRT"}
196         ):
197             with patch.object(iptables.salt.utils.files, "fopen", file_mock):
198                 rules = iptables.get_saved_rules()
199                 self.assertEqual(
200                     expected_input_rules, rules["filter"]["INPUT"]["rules"]
201                 )
202     def test_get_rules(self):
203         mock = MagicMock(return_value=False)
204         with patch.object(iptables, "_parse_conf", mock):
205             self.assertFalse(iptables.get_rules())
206             mock.assert_called_with(in_mem=True, family="ipv4")
207     def test_get_saved_policy(self):
208         self.assertEqual(
209             iptables.get_saved_policy(
210                 table="filter", chain=None, conf_file=None, family="ipv4"
211             ),
212             "Error: Chain needs to be specified",
213         )
214         with patch.object(
215             iptables,
216             "_parse_conf",
217             MagicMock(return_value={"filter": {"INPUT": {"policy": True}}}),
218         ):
219             self.assertTrue(
220                 iptables.get_saved_policy(
221                     table="filter", chain="INPUT", conf_file=None, family="ipv4"
222                 )
223             )
224         with patch.object(
225             iptables,
226             "_parse_conf",
227             MagicMock(return_value={"filter": {"INPUT": {"policy1": True}}}),
228         ):
229             self.assertIsNone(
230                 iptables.get_saved_policy(
231                     table="filter", chain="INPUT", conf_file=None, family="ipv4"
232                 )
233             )
234     def test_get_policy(self):
235         self.assertEqual(
236             iptables.get_policy(table="filter", chain=None, family="ipv4"),
237             "Error: Chain needs to be specified",
238         )
239         with patch.object(
240             iptables,
241             "_parse_conf",
242             MagicMock(return_value={"filter": {"INPUT": {"policy": True}}}),
243         ):
244             self.assertTrue(
245                 iptables.get_policy(table="filter", chain="INPUT", family="ipv4")
246             )
247         with patch.object(
248             iptables,
249             "_parse_conf",
250             MagicMock(return_value={"filter": {"INPUT": {"policy1": True}}}),
251         ):
252             self.assertIsNone(
253                 iptables.get_policy(table="filter", chain="INPUT", family="ipv4")
254             )
255     def test_set_policy(self):
256         with patch.object(iptables, "_has_option", MagicMock(return_value=True)):
257             self.assertEqual(
258                 iptables.set_policy(
259                     table="filter", chain=None, policy=None, family="ipv4"
260                 ),
261                 "Error: Chain needs to be specified",
262             )
263             self.assertEqual(
264                 iptables.set_policy(
265                     table="filter", chain="INPUT", policy=None, family="ipv4"
266                 ),
267                 "Error: Policy needs to be specified",
268             )
269             mock = MagicMock(return_value=True)
270             with patch.dict(iptables.__salt__, {"cmd.run_stderr": mock}):
271                 self.assertTrue(
272                     iptables.set_policy(
273                         table="filter", chain="INPUT", policy="ACCEPT", family="ipv4"
274                     )
275                 )
276     def test_save(self):
277         with patch("salt.modules.iptables._conf", MagicMock(return_value=False)), patch(
278             "os.path.isdir", MagicMock(return_value=True)
279         ):
280             mock = MagicMock(return_value=True)
281             with patch.dict(
282                 iptables.__salt__,
283                 {
284                     "cmd.run_stdout": mock,
285                     "file.write": mock,
286                     "config.option": MagicMock(return_value=[]),
287                 },
288             ):
289                 self.assertTrue(iptables.save(filename="/xyz", family="ipv4"))
290     def test_check(self):
291         self.assertEqual(
292             iptables.check(table="filter", chain=None, rule=None, family="ipv4"),
293             "Error: Chain needs to be specified",
294         )
295         self.assertEqual(
296             iptables.check(table="filter", chain="INPUT", rule=None, family="ipv4"),
297             "Error: Rule needs to be specified",
298         )
299         mock_rule = "m state --state RELATED,ESTABLISHED -j ACCEPT"
300         mock_chain = "INPUT"
301         mock_uuid = 31337
302         mock_cmd_rule = MagicMock(
303             return_value="-A {}\n-A {}".format(mock_chain, hex(mock_uuid))
304         )
305         mock_cmd_nooutput = MagicMock(return_value="")
306         mock_has = MagicMock(return_value=True)
307         mock_not = MagicMock(return_value=False)
308         with patch.object(iptables, "_has_option", mock_not):
309             with patch.object(uuid, "getnode", MagicMock(return_value=mock_uuid)):
310                 with patch.dict(
311                     iptables.__salt__,
312                     {"cmd.run_stdout": mock_cmd_rule, "cmd.run": mock_cmd_nooutput},
313                 ):
314                     self.assertTrue(
315                         iptables.check(
316                             table="filter",
317                             chain=mock_chain,
318                             rule=mock_rule,
319                             family="ipv4",
320                         )
321                     )
322         mock_cmd = MagicMock(return_value="")
323         with patch.object(iptables, "_has_option", mock_not):
324             with patch.object(uuid, "getnode", MagicMock(return_value=mock_uuid)):
325                 with patch.dict(
326                     iptables.__salt__,
327                     {
328                         "cmd.run_stdout": mock_cmd_nooutput,
329                         "cmd.run": mock_cmd_nooutput,
330                     },
331                 ):
332                     self.assertFalse(
333                         iptables.check(
334                             table="filter",
335                             chain=mock_chain,
336                             rule=mock_rule,
337                             family="ipv4",
338                         )
339                     )
340         with patch.object(iptables, "_has_option", mock_has):
341             with patch.dict(iptables.__salt__, {"cmd.run_stderr": mock_cmd}):
342                 self.assertTrue(
343                     iptables.check(
344                         table="filter", chain="INPUT", rule=mock_rule, family="ipv4"
345                     )
346                 )
347         mock_cmd = MagicMock(return_value="-A 0x4d2")
348         mock_uuid = MagicMock(return_value=1234)
349         with patch.object(iptables, "_has_option", mock_has):
350             with patch.object(uuid, "getnode", mock_uuid):
351                 with patch.dict(iptables.__salt__, {"cmd.run_stderr": mock_cmd}):
352                     self.assertTrue(
353                         iptables.check(
354                             table="filter", chain="0x4d2", rule=mock_rule, family="ipv4"
355                         )
356                     )
357     def test_check_chain(self):
358         self.assertEqual(
359             iptables.check_chain(table="filter", chain=None, family="ipv4"),
360             "Error: Chain needs to be specified",
361         )
362         mock_cmd = MagicMock(return_value="")
363         with patch.dict(iptables.__salt__, {"cmd.run_stdout": mock_cmd}):
364             self.assertFalse(
365                 iptables.check_chain(table="filter", chain="INPUT", family="ipv4")
366             )
367     def test_new_chain(self):
368         self.assertEqual(
369             iptables.new_chain(table="filter", chain=None, family="ipv4"),
370             "Error: Chain needs to be specified",
371         )
372         mock_cmd = MagicMock(return_value="")
373         with patch.dict(
374             iptables.__salt__,
375             {
376                 "cmd.run_stdout": mock_cmd,  # called by iptables._has_option
377                 "cmd.run_stderr": mock_cmd,
378             },
379         ):
380             self.assertTrue(
381                 iptables.new_chain(table="filter", chain="INPUT", family="ipv4")
382             )
383     def test_delete_chain(self):
384         self.assertEqual(
385             iptables.delete_chain(table="filter", chain=None, family="ipv4"),
386             "Error: Chain needs to be specified",
387         )
388         mock_cmd = MagicMock(return_value="")
389         with patch.dict(
390             iptables.__salt__,
391             {
392                 "cmd.run_stdout": mock_cmd,  # called by iptables._has_option
393                 "cmd.run_stderr": mock_cmd,
394             },
395         ):
396             self.assertTrue(
397                 iptables.delete_chain(table="filter", chain="INPUT", family="ipv4")
398             )
399     def test_append(self):
400         with patch.object(
401             iptables, "_has_option", MagicMock(return_value=True)
402         ), patch.object(iptables, "check", MagicMock(return_value=False)):
403             self.assertEqual(
404                 iptables.append(table="filter", chain=None, rule=None, family="ipv4"),
405                 "Error: Chain needs to be specified",
406             )
407             self.assertEqual(
408                 iptables.append(
409                     table="filter", chain="INPUT", rule=None, family="ipv4"
410                 ),
411                 "Error: Rule needs to be specified",
412             )
413             _rule = "m state --state RELATED,ESTABLISHED -j ACCEPT"
414             mock = MagicMock(side_effect=["", "SALT"])
415             with patch.dict(iptables.__salt__, {"cmd.run_stderr": mock}):
416                 self.assertTrue(
417                     iptables.append(
418                         table="filter", chain="INPUT", rule=_rule, family="ipv4"
419                     )
420                 )
421                 self.assertFalse(
422                     iptables.append(
423                         table="filter", chain="INPUT", rule=_rule, family="ipv4"
424                     )
425                 )
426     def test_insert(self):
427         with patch.object(
428             iptables, "_has_option", MagicMock(return_value=True)
429         ), patch.object(iptables, "check", MagicMock(return_value=False)):
430             self.assertEqual(
431                 iptables.insert(
432                     table="filter", chain=None, position=None, rule=None, family="ipv4"
433                 ),
434                 "Error: Chain needs to be specified",
435             )
436             pos_err = "Error: Position needs to be specified or use append (-A)"
437             self.assertEqual(
438                 iptables.insert(
439                     table="filter",
440                     chain="INPUT",
441                     position=None,
442                     rule=None,
443                     family="ipv4",
444                 ),
445                 pos_err,
446             )
447             self.assertEqual(
448                 iptables.insert(
449                     table="filter", chain="INPUT", position=3, rule=None, family="ipv4"
450                 ),
451                 "Error: Rule needs to be specified",
452             )
453             _rule = "m state --state RELATED,ESTABLISHED -j ACCEPT"
454             mock = MagicMock(return_value=True)
455             with patch.dict(iptables.__salt__, {"cmd.run_stderr": mock}):
456                 self.assertTrue(
457                     iptables.insert(
458                         table="filter",
459                         chain="INPUT",
460                         position=3,
461                         rule=_rule,
462                         family="ipv4",
463                     )
464                 )
465     def test_delete(self):
466         with patch.object(iptables, "_has_option", MagicMock(return_value=True)):
467             _rule = "m state --state RELATED,ESTABLISHED -j ACCEPT"
468             self.assertEqual(
469                 iptables.delete(
470                     table="filter", chain=None, position=3, rule=_rule, family="ipv4"
471                 ),
472                 "Error: Only specify a position or a rule, not both",
473             )
474             mock = MagicMock(return_value=True)
475             with patch.dict(iptables.__salt__, {"cmd.run_stderr": mock}):
476                 self.assertTrue(
477                     iptables.delete(
478                         table="filter",
479                         chain="INPUT",
480                         position=3,
481                         rule="",
482                         family="ipv4",
483                     )
484                 )
485     def test_flush(self):
486         with patch.object(iptables, "_has_option", MagicMock(return_value=True)):
487             mock_cmd = MagicMock(return_value=True)
488             with patch.dict(iptables.__salt__, {"cmd.run_stderr": mock_cmd}):
489                 self.assertTrue(
490                     iptables.flush(table="filter", chain="INPUT", family="ipv4")
491                 )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>postgres_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import base64
2 import datetime
3 import hashlib
4 import hmac
5 import io
6 import logging
7 import os
8 import pipes
9 import re
10 import tempfile
11 import salt.utils.files
12 import salt.utils.itertools
13 import salt.utils.odict
14 import salt.utils.path
15 import salt.utils.stringutils
16 from salt.exceptions import CommandExecutionError, SaltInvocationError
17 from salt.ext.saslprep import saslprep
18 from salt.utils.versions import LooseVersion as _LooseVersion
19 try:
20     import csv
21     HAS_CSV = True
22 except ImportError:
23     HAS_CSV = False
24 try:
25     from secrets import token_bytes
26 except ImportError:
27     from os import urandom as token_bytes
28 log = logging.getLogger(__name__)
29 _DEFAULT_PASSWORDS_ENCRYPTION = "md5"
30 _EXTENSION_NOT_INSTALLED = "EXTENSION NOT INSTALLED"
31 _EXTENSION_INSTALLED = "EXTENSION INSTALLED"
32 _EXTENSION_TO_UPGRADE = "EXTENSION TO UPGRADE"
33 _EXTENSION_TO_MOVE = "EXTENSION TO MOVE"
34 _EXTENSION_FLAGS = (
35     _EXTENSION_NOT_INSTALLED,
36     _EXTENSION_INSTALLED,
37     _EXTENSION_TO_UPGRADE,
38     _EXTENSION_TO_MOVE,
39 )
40 _PRIVILEGES_MAP = {
41     "a": "INSERT",
42     "C": "CREATE",
43     "D": "TRUNCATE",
44     "c": "CONNECT",
45     "t": "TRIGGER",
46     "r": "SELECT",
47     "U": "USAGE",
48     "T": "TEMPORARY",
49     "w": "UPDATE",
50     "X": "EXECUTE",
51     "x": "REFERENCES",
52     "d": "DELETE",
53     "*": "GRANT",
54 }
55 _PRIVILEGES_OBJECTS = frozenset(
56     (
57         "schema",
58         "tablespace",
59         "language",
60         "sequence",
61         "table",
62         "group",
63         "database",
64         "function",
65     )
66 )
67 _PRIVILEGE_TYPE_MAP = {
68     "table": "arwdDxt",
69     "tablespace": "C",
70     "language": "U",
71     "sequence": "rwU",
72     "schema": "UC",
73     "database": "CTc",
74     "function": "X",
75 }
76 def __virtual__():
77     utils = ["psql"]
78     if not HAS_CSV:
79         return False
80     for util in utils:
81         if not salt.utils.path.which(util):
82             if not _find_pg_binary(util):
83                 return (False, "{} was not found".format(util))
84     return True
85 def _find_pg_binary(util):
86     pg_bin_dir = __salt__["config.option"]("postgres.bins_dir")
87     util_bin = salt.utils.path.which(util)
88     if not util_bin:
89         if pg_bin_dir:
90             return salt.utils.path.which(os.path.join(pg_bin_dir, util))
91     else:
92         return util_bin
93 def _run_psql(cmd, runas=None, password=None, host=None, port=None, user=None):
94     kwargs = {
95         "reset_system_locale": False,
96         "clean_env": True,
97     }
98     if runas is None:
99         if not host:
100             host = __salt__["config.option"]("postgres.host")
101         if not host or host.startswith("/"):
102             if "FreeBSD" in __grains__["os_family"]:
103                 runas = "postgres"
104             elif "OpenBSD" in __grains__["os_family"]:
105                 runas = "_postgresql"
106             else:
107                 runas = "postgres"
108     if user is None:
109         user = runas
110     if runas:
111         kwargs["runas"] = runas
112     if password is None:
113         password = __salt__["config.option"]("postgres.pass")
114     if password is not None:
115         pgpassfile = salt.utils.files.mkstemp(text=True)
116         with salt.utils.files.fopen(pgpassfile, "w") as fp_:
117             fp_.write(
118                 salt.utils.stringutils.to_str(
119                     "{}:{}:*:{}:{}".format(
120                         "localhost" if not host or host.startswith("/") else host,
121                         port if port else "*",
122                         user if user else "*",
123                         password,
124                     )
125                 )
126             )
127             __salt__["file.chown"](pgpassfile, runas, "")
128             kwargs["env"] = {"PGPASSFILE": pgpassfile}
129     ret = __salt__["cmd.run_all"](cmd, python_shell=False, **kwargs)
130     if ret.get("retcode", 0) != 0:
131         log.error("Error connecting to Postgresql server")
132     if password is not None and not __salt__["file.remove"](pgpassfile):
133         log.warning("Remove PGPASSFILE failed")
134     return ret
135 def _run_initdb(
136     name,
137     auth="password",
138     user=None,
139     password=None,
140     encoding="UTF8",
141     locale=None,
142     runas=None,
143     waldir=None,
144     checksums=False,
145 ):
146     if runas is None:
147         if "FreeBSD" in __grains__["os_family"]:
148             runas = "postgres"
149         elif "OpenBSD" in __grains__["os_family"]:
150             runas = "_postgresql"
151         else:
152             runas = "postgres"
153     if user is None:
154         user = runas
155     _INITDB_BIN = _find_pg_binary("initdb")
156     if not _INITDB_BIN:
157         raise CommandExecutionError("initdb executable not found.")
158     cmd = [
159         _INITDB_BIN,
160         "--pgdata={}".format(name),
161         "--username={}".format(user),
162         "--auth={}".format(auth),
163         "--encoding={}".format(encoding),
164     ]
165     if locale is not None:
166         cmd.append("--locale={}".format(locale))
167     if waldir is not None:
168         cmd.append("-X")
169         cmd.append(waldir)
170     if checksums:
171         cmd.append("--data-checksums")
172     if password is not None:
173         pgpassfile = salt.utils.files.mkstemp(text=True)
174         with salt.utils.files.fopen(pgpassfile, "w") as fp_:
175             fp_.write(salt.utils.stringutils.to_str("{}".format(password)))
176             __salt__["file.chown"](pgpassfile, runas, "")
177         cmd.extend(["--pwfile={}".format(pgpassfile)])
178     kwargs = dict(runas=runas, clean_env=True)
179     cmdstr = " ".join([pipes.quote(c) for c in cmd])
180     ret = __salt__["cmd.run_all"](cmdstr, python_shell=False, **kwargs)
181     if ret.get("retcode", 0) != 0:
182         log.error("Error initilizing the postgres data directory")
183     if password is not None and not __salt__["file.remove"](pgpassfile):
184         log.warning("Removal of PGPASSFILE failed")
185     return ret
186 def version(
187     user=None, host=None, port=None, maintenance_db=None, password=None, runas=None
188 ):
189     query = "SELECT setting FROM pg_catalog.pg_settings WHERE name = 'server_version'"
190     cmd = _psql_cmd(
191         "-c",
192         query,
193         "-t",
194         host=host,
195         user=user,
196         port=port,
197         maintenance_db=maintenance_db,
198         password=password,
199     )
200     ret = _run_psql(
201         cmd, runas=runas, password=password, host=host, port=port, user=user
202     )
203     for line in salt.utils.itertools.split(ret["stdout"], "\n"):
204         return line
205 def _parsed_version(
206     user=None, host=None, port=None, maintenance_db=None, password=None, runas=None
207 ):
208     psql_version = version(
209         user,
210         host=host,
211         port=port,
212         maintenance_db=maintenance_db,
213         password=password,
214         runas=runas,
215     )
216     if psql_version:
217         return _LooseVersion(psql_version)
218     else:
219         log.warning(
220             "Attempt to parse version of Postgres server failed. "
221             "Is the server responding?"
222         )
223         return None
224 def _connection_defaults(user=None, host=None, port=None, maintenance_db=None):
225     if not user:
226         user = __salt__["config.option"]("postgres.user")
227     if not host:
228         host = __salt__["config.option"]("postgres.host")
229     if not port:
230         port = __salt__["config.option"]("postgres.port")
231     if not maintenance_db:
232         maintenance_db = __salt__["config.option"]("postgres.maintenance_db")
233     return (user, host, port, maintenance_db)
234 def _psql_cmd(*args, **kwargs):
235     (user, host, port, maintenance_db) = _connection_defaults(
236         kwargs.get("user"),
237         kwargs.get("host"),
238         kwargs.get("port"),
239         kwargs.get("maintenance_db"),
240     )
241     _PSQL_BIN = _find_pg_binary("psql")
242     cmd = [
243         _PSQL_BIN,
244         "--no-align",
245         "--no-readline",
246         "--no-psqlrc",
247         "--no-password",
248     ]  # Never prompt, handled in _run_psql.
249     if user:
250         cmd += ["--username", user]
251     if host:
252         cmd += ["--host", host]
253     if port:
254         cmd += ["--port", str(port)]
255     if not maintenance_db:
256         maintenance_db = "postgres"
257     cmd.extend(["--dbname", maintenance_db])
258     cmd.extend(args)
259     return cmd
260 def _psql_prepare_and_run(
261     cmd, host=None, port=None, maintenance_db=None, password=None, runas=None, user=None
262 ):
263     rcmd = _psql_cmd(
264         host=host, user=user, port=port, maintenance_db=maintenance_db, *cmd
265     )
266     cmdret = _run_psql(
267         rcmd, runas=runas, password=password, host=host, port=port, user=user
268     )
269     return cmdret
270 def psql_query(
271     query,
272     user=None,
273     host=None,
274     port=None,
275     maintenance_db=None,
276     password=None,
277     runas=None,
278     write=False,
279 ):
280     ret = []
281     csv_query = "COPY ({}) TO STDOUT WITH CSV HEADER".format(query.strip().rstrip(";"))
282     if write:
283         csv_query = "START TRANSACTION READ WRITE; {}; COMMIT TRANSACTION;".format(
284             csv_query
285         )
286     cmdret = _psql_prepare_and_run(
287         ["-v", "datestyle=ISO,MDY", "-c", csv_query],
288         runas=runas,
289         host=host,
290         user=user,
291         port=port,
292         maintenance_db=maintenance_db,
293         password=password,
294     )
295     if cmdret["retcode"] &gt; 0:
296         return ret
297     csv_file = io.StringIO(cmdret["stdout"])
298     header = {}
299     for row in csv.reader(
300         csv_file,
301         delimiter=salt.utils.stringutils.to_str(","),
302         quotechar=salt.utils.stringutils.to_str('"'),
303     ):
304         if not row:
305             continue
306         if not header:
307             header = row
308             continue
309         ret.append(dict(zip(header, row)))
310     if write:
311         ret = ret[0:-1]
312     return ret
313 def db_list(
314     user=None, host=None, port=None, maintenance_db=None, password=None, runas=None
315 ):
316     ret = {}
317     query = (
318         'SELECT datname as "Name", pga.rolname as "Owner", '
319         'pg_encoding_to_char(encoding) as "Encoding", '
320         'datcollate as "Collate", datctype as "Ctype", '
321         'datacl as "Access privileges", spcname as "Tablespace" '
322         "FROM pg_database pgd, pg_roles pga, pg_tablespace pgts "
323         "WHERE pga.oid = pgd.datdba AND pgts.oid = pgd.dattablespace"
324     )
325     rows = psql_query(
326         query,
327         runas=runas,
328         host=host,
329         user=user,
330         port=port,
331         maintenance_db=maintenance_db,
332         password=password,
333     )
334     for row in rows:
335         ret[row["Name"]] = row
336         ret[row["Name"]].pop("Name")
337     return ret
338 def db_exists(
339     name,
340     user=None,
341     host=None,
342     port=None,
343     maintenance_db=None,
344     password=None,
345     runas=None,
346 ):
347     databases = db_list(
348         user=user,
349         host=host,
350         port=port,
351         maintenance_db=maintenance_db,
352         password=password,
353         runas=runas,
354     )
355     return name in databases
356 def _quote_ddl_value(value, quote="'"):
357     if value is None:
358         return None
359     if quote in value:  # detect trivial sqli
360         raise SaltInvocationError(
361             "Unsupported character {} in value: {}".format(quote, value)
362         )
363     return "{quote}{value}{quote}".format(quote=quote, value=value)
364 def db_create(
365     name,
366     user=None,
367     host=None,
368     port=None,
369     maintenance_db=None,
370     password=None,
371     tablespace=None,
372     encoding=None,
373     lc_collate=None,
374     lc_ctype=None,
375     owner=None,
376     template=None,
377     runas=None,
378 ):
379     with_args = salt.utils.odict<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.OrderedDict(
380         [
381             ("TABLESPACE", _quote_ddl_value(tablespace, '"')),
382             ("OWNER", _quote_ddl_value(owner, '"')),
383             ("TEMPLATE", template),
384             ("ENCODING", _quote_ddl_value(encoding)),
385             ("LC_COLLATE", _quote_ddl_value(lc_collate)),
386             ("LC_CTYPE"</b></font>, _quote_ddl_value(lc_ctype)),
387         ]
388     )
389     with_chunks = []
390     for key, value in with_args.items():
391         if value is not None:
392             with_chunks += [key, "=", value]
393     if with_chunks:
394         with_chunks.insert(0, " WITH")
395         query += " ".join(with_chunks)
396     ret = _psql_prepare_and_run(
397         ["-c", query],
398         user=user,
399         host=host,
400         port=port,
401         maintenance_db=maintenance_db,
402         password=password,
403         runas=runas,
404     )
405     return ret["retcode"] == 0
406 def db_alter(
407     name,
408     user=None,
409     host=None,
410     port=None,
411     maintenance_db=None,
412     password=None,
413     tablespace=None,
414     owner=None,
415     owner_recurse=False,
416     runas=None,
417 ):
418     if not any((tablespace, owner)):
419         return True  # Nothing todo?
420     if owner and owner_recurse:
421         ret = owner_to(
422             name, owner, user=user, host=host, port=port, password=password, runas=runas
423         )
424     else:
425         queries = []
426         if owner:
427             queries.append('ALTER DATABASE "{}" OWNER TO "{}"'.format(name, owner))
428         if tablespace:
429             queries.append(
430                 'ALTER DATABASE "{}" SET TABLESPACE "{}"'.format(name, tablespace)
431             )
432         for query in queries:
433             ret = _psql_prepare_and_run(
434                 ["-c", query],
435                 user=user,
436                 host=host,
437                 port=port,
438                 maintenance_db=maintenance_db,
439                 password=password,
440                 runas=runas,
441             )
442     if ret["retcode"] != 0:
443         return False
444     return True
445 def db_remove(
446     name,
447     user=None,
448     host=None,
449     port=None,
450     maintenance_db=None,
451     password=None,
452     runas=None,
453 ):
454     for query in [
455         'REVOKE CONNECT ON DATABASE "{db}" FROM public;'.format(db=name),
456         "SELECT pid, pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname ="
457         " '{db}' AND pid &lt;&gt; pg_backend_pid();".format(db=name),
458         'DROP DATABASE "{db}";'.format(db=name),
459     ]:
460         ret = _psql_prepare_and_run(
461             ["-c", query],
462             user=user,
463             host=host,
464             port=port,
465             runas=runas,
466             maintenance_db=maintenance_db,
467             password=password,
468         )
469         if ret["retcode"] != 0:
470             raise Exception("Failed: ret={}".format(ret))
471     return True
472 def tablespace_list(
473     user=None, host=None, port=None, maintenance_db=None, password=None, runas=None
474 ):
475     ret = {}
476     query = (
477         'SELECT spcname as "Name", pga.rolname as "Owner", spcacl as "ACL", '
478         'spcoptions as "Opts", pg_tablespace_location(pgts.oid) as "Location" '
479         "FROM pg_tablespace pgts, pg_roles pga WHERE pga.oid = pgts.spcowner"
480     )
481     rows = __salt__["postgres.psql_query"](
482         query,
483         runas=runas,
484         host=host,
485         user=user,
486         port=port,
487         maintenance_db=maintenance_db,
488         password=password,
489     )
490     for row in rows:
491         ret[row["Name"]] = row
492         ret[row["Name"]].pop("Name")
493     return ret
494 def tablespace_exists(
495     name,
496     user=None,
497     host=None,
498     port=None,
499     maintenance_db=None,
500     password=None,
501     runas=None,
502 ):
503     tablespaces = tablespace_list(
504         user=user,
505         host=host,
506         port=port,
507         maintenance_db=maintenance_db,
508         password=password,
509         runas=runas,
510     )
511     return name in tablespaces
512 def tablespace_create(
513     name,
514     location,
515     options=None,
516     owner=None,
517     user=None,
518     host=None,
519     port=None,
520     maintenance_db=None,
521     password=None,
522     runas=None,
523 ):
524     owner_query = ""
525     options_query = ""
526     if owner:
527         owner_query = 'OWNER "{}"'.format(owner)
528     if options:
529         optionstext = ["{} = {}".format(k, v) for k, v in options.items()]
530         options_query = "WITH ( {} )".format(", ".join(optionstext))
531     query = "CREATE TABLESPACE \"{}\" {} LOCATION '{}' {}".format(
532         name, owner_query, location, options_query
533     )
534     ret = _psql_prepare_and_run(
535         ["-c", query],
536         user=user,
537         host=host,
538         port=port,
539         maintenance_db=maintenance_db,
540         password=password,
541         runas=runas,
542     )
543     return ret["retcode"] == 0
544 def tablespace_alter(
545     name,
546     user=None,
547     host=None,
548     port=None,
549     maintenance_db=None,
550     password=None,
551     new_name=None,
552     new_owner=None,
553     set_option=None,
554     reset_option=None,
555     runas=None,
556 ):
557     if not any([new_name, new_owner, set_option, reset_option]):
558         return True  # Nothing todo?
559     queries = []
560     if new_name:
561         queries.append('ALTER TABLESPACE "{}" RENAME TO "{}"'.format(name, new_name))
562     if new_owner:
563         queries.append('ALTER TABLESPACE "{}" OWNER TO "{}"'.format(name, new_owner))
564     if set_option:
565         queries.append(
566             'ALTER TABLESPACE "{}" SET ({} = {})'.format(
567                 name, *(next(iter(set_option.items())))
568             )
569         )
570     if reset_option:
571         queries.append('ALTER TABLESPACE "{}" RESET ({})'.format(name, reset_option))
572     for query in queries:
573         ret = _psql_prepare_and_run(
574             ["-c", query],
575             user=user,
576             host=host,
577             port=port,
578             maintenance_db=maintenance_db,
579             password=password,
580             runas=runas,
581         )
582         if ret["retcode"] != 0:
583             return False
584     return True
585 def tablespace_remove(
586     name,
587     user=None,
588     host=None,
589     port=None,
590     maintenance_db=None,
591     password=None,
592     runas=None,
593 ):
594     query = 'DROP TABLESPACE "{}"'.format(name)
595     ret = _psql_prepare_and_run(
596         ["-c", query],
597         user=user,
598         host=host,
599         port=port,
600         runas=runas,
601         maintenance_db=maintenance_db,
602         password=password,
603     )
604     return ret["retcode"] == 0
605 def user_list(
606     user=None,
607     host=None,
608     port=None,
609     maintenance_db=None,
610     password=None,
611     runas=None,
612     return_password=False,
613 ):
614     ret = {}
615     ver = _parsed_version(
616         user=user,
617         host=host,
618         port=port,
619         maintenance_db=maintenance_db,
620         password=password,
621         runas=runas,
622     )
623     if ver:
624         if ver &gt;= _LooseVersion("9.1"):
625             replication_column = "pg_roles.rolreplication"
626         else:
627             replication_column = "NULL"
628         if ver &gt;= _LooseVersion("9.5"):
629             rolcatupdate_column = "NULL"
630         else:
631             rolcatupdate_column = "pg_roles.rolcatupdate"
632     else:
633         log.error("Could not retrieve Postgres version. Is Postgresql server running?")
634         return False
635     _x = lambda s: s if return_password else ""
636     query = "".join(
637         [
638             'SELECT pg_roles.rolname as "name",pg_roles.rolsuper as "superuser",'
639             ' pg_roles.rolinherit as "inherits privileges", pg_roles.rolcreaterole as'
640             ' "can create roles", pg_roles.rolcreatedb as "can create databases", {0}'
641             ' as "can update system catalogs", pg_roles.rolcanlogin as "can login", {1}'
642             ' as "replication", pg_roles.rolconnlimit as "connections", (SELECT'
643             " array_agg(pg_roles2.rolname)    FROM pg_catalog.pg_auth_members    JOIN"
644             " pg_catalog.pg_roles pg_roles2 ON (pg_auth_members.roleid = pg_roles2.oid)"
645             "    WHERE pg_auth_members.member = pg_roles.oid) as"
646             ' "groups",pg_roles.rolvaliduntil::timestamp(0) as "expiry time",'
647             ' pg_roles.rolconfig  as "defaults variables" ',
648             _x(', COALESCE(pg_shadow.passwd, pg_authid.rolpassword) as "password" '),
649             "FROM pg_roles ",
650             _x("LEFT JOIN pg_authid ON pg_roles.oid = pg_authid.oid "),
651             _x("LEFT JOIN pg_shadow ON pg_roles.oid = pg_shadow.usesysid"),
652         ]
653     ).format(rolcatupdate_column, replication_column)
654     rows = psql_query(
655         query,
656         runas=runas,
657         host=host,
658         user=user,
659         port=port,
660         maintenance_db=maintenance_db,
661         password=password,
662     )
663     def get_bool(rowdict, key):
664         if rowdict[key] == "t":
665             return True
666         elif rowdict[key] == "f":
667             return False
668         else:
669             return None
670     for row in rows:
671         retrow = {}
672         for key in (
673             "superuser",
674             "inherits privileges",
675             "can create roles",
676             "can create databases",
677             "can update system catalogs",
678             "can login",
679             "replication",
680             "connections",
681         ):
682             retrow[key] = get_bool(row, key)
683         for date_key in ("expiry time",):
684             try:
685                 retrow[date_key] = datetime.datetime.strptime(
686                     row[date_key], "%Y-%m-%d %H:%M:%S"
687                 )
688             except ValueError:
689                 retrow[date_key] = None
690         retrow["defaults variables"] = row["defaults variables"]
691         if return_password:
692             retrow["password"] = row["password"]
693         retrow["groups"] = list(csv.reader([row["groups"].strip("{}")]))[0]
694         ret[row["name"]] = retrow
695     return ret
696 def role_get(
697     name,
698     user=None,
699     host=None,
700     port=None,
701     maintenance_db=None,
702     password=None,
703     runas=None,
704     return_password=False,
705 ):
706     all_users = user_list(
707         user=user,
708         host=host,
709         port=port,
710         maintenance_db=maintenance_db,
711         password=password,
712         runas=runas,
713         return_password=return_password,
714     )
715     try:
716         return all_users.get(name, None)
717     except AttributeError:
718         log.error("Could not retrieve Postgres role. Is Postgres running?")
719         return None
720 def user_exists(
721     name,
722     user=None,
723     host=None,
724     port=None,
725     maintenance_db=None,
726     password=None,
727     runas=None,
728 ):
729     return bool(
730         role_get(
731             name,
732             user=user,
733             host=host,
734             port=port,
735             maintenance_db=maintenance_db,
736             password=password,
737             runas=runas,
738             return_password=False,
739         )
740     )
741 def _add_role_flag(string, test, flag, cond=None, prefix="NO", addtxt="", skip=False):
742     if not skip:
743         if cond is None:
744             cond = test
745         if test is not None:
746             if cond:
747                 string = "{} {}".format(string, flag)
748             else:
749                 string = "{0} {2}{1}".format(string, flag, prefix)
750         if addtxt:
751             string = "{} {}".format(string, addtxt)
752     return string
753 def _maybe_encrypt_password(role, password, encrypted=_DEFAULT_PASSWORDS_ENCRYPTION):
754     if password is not None:
755         password = str(password)
756     else:
757         return None
758     if encrypted is True:
759         encrypted = "md5"
760     if encrypted not in (False, "md5", "scram-sha-256"):
761         raise ValueError("Unknown password algorithm: " + str(encrypted))
762     if encrypted == "scram-sha-256" and not password.startswith("SCRAM-SHA-256"):
763         password = _scram_sha_256(password)
764     elif encrypted == "md5" and not password.startswith("md5"):
765         log.warning("The md5 password algorithm was deprecated in PostgreSQL 10")
766         password = _md5_password(role, password)
767     elif encrypted is False:
768         log.warning("Unencrypted passwords were removed in PostgreSQL 10")
769     return password
770 def _verify_password(role, password, verifier, method):
771     if method == "md5" or method is True:
772         if password.startswith("md5"):
773             expected = password
774         else:
775             expected = _md5_password(role, password)
776     elif method == "scram-sha-256":
777         if password.startswith("SCRAM-SHA-256"):
778             expected = password
779         else:
780             match = re.match(r"^SCRAM-SHA-256\$(\d+):([^\$]+?)\$", verifier)
781             if match:
782                 iterations = int(match.group(1))
783                 salt_bytes = base64.b64decode(match.group(2))
784                 expected = _scram_sha_256(
785                     password, salt_bytes=salt_bytes, iterations=iterations
786                 )
787             else:
788                 expected = object()
789     elif method is False:
790         expected = password
791     else:
792         expected = object()
793     return verifier == expected
794 def _md5_password(role, password):
795     return "md5{}".format(
796         hashlib.md5(
797             salt.utils.stringutils.to_bytes("{}{}".format(password, role))
798         ).hexdigest()
799     )
800 def _scram_sha_256(password, salt_bytes=None, iterations=4096):
801     if salt_bytes is None:
802         salt_bytes = token_bytes(16)
803     password = salt.utils.stringutils.to_bytes(saslprep(password))
804     salted_password = hashlib.pbkdf2_hmac("sha256", password, salt_bytes, iterations)
805     stored_key = hmac.new(salted_password, b"Client Key", "sha256").digest()
806     stored_key = hashlib.sha256(stored_key).digest()
807     server_key = hmac.new(salted_password, b"Server Key", "sha256").digest()
808     return "SCRAM-SHA-256${}:{}${}:{}".format(
809         iterations,
810         base64.b64encode(salt_bytes).decode("ascii"),
811         base64.b64encode(stored_key).decode("ascii"),
812         base64.b64encode(server_key).decode("ascii"),
813     )
814 def _role_cmd_args(
815     name,
816     sub_cmd="",
817     typ_="role",
818     encrypted=None,
819     login=None,
820     connlimit=None,
821     inherit=None,
822     createdb=None,
823     createroles=None,
824     superuser=None,
825     groups=None,
826     replication=None,
827     rolepassword=None,
828     valid_until=None,
829     db_role=None,
830 ):
831     if inherit is None:
832         if typ_ in ["user", "group"]:
833             inherit = True
834     if login is None:
835         if typ_ == "user":
836             login = True
837         if typ_ == "group":
838             login = False
839     if encrypted is None:
840         encrypted = _DEFAULT_PASSWORDS_ENCRYPTION
841     skip_passwd = False
842     escaped_password = ""
843     escaped_valid_until = ""
844     if not (
845         rolepassword is not None
846         and (isinstance(rolepassword, str) and bool(rolepassword))
847         or (isinstance(rolepassword, bool))
848     ):
849         skip_passwd = True
850     if isinstance(rolepassword, str) and bool(rolepassword):
851         escaped_password = "'{}'".format(
852             _maybe_encrypt_password(
853                 name, rolepassword.replace("'", "''"), encrypted=encrypted
854             )
855         )
856     if isinstance(valid_until, str) and bool(valid_until):
857         escaped_valid_until = "'{}'".format(
858             valid_until.replace("'", "''"),
859         )
860     skip_superuser = False
861     if bool(db_role) and bool(superuser) == bool(db_role["superuser"]):
862         skip_superuser = True
863     flags = (
864         {"flag": "INHERIT", "test": inherit},
865         {"flag": "CREATEDB", "test": createdb},
866         {"flag": "CREATEROLE", "test": createroles},
867         {"flag": "SUPERUSER", "test": superuser, "skip": skip_superuser},
868         {"flag": "REPLICATION", "test": replication},
869         {"flag": "LOGIN", "test": login},
870         {
871             "flag": "CONNECTION LIMIT",
872             "test": bool(connlimit),
873             "addtxt": str(connlimit),
874             "skip": connlimit is None,
875         },
876         {
877             "flag": "ENCRYPTED",
878             "test": (encrypted is not None and bool(rolepassword)),
879             "skip": skip_passwd or isinstance(rolepassword, bool),
880             "cond": bool(encrypted),
881             "prefix": "UN",
882         },
883         {
884             "flag": "PASSWORD",
885             "test": bool(rolepassword),
886             "skip": skip_passwd,
887             "addtxt": escaped_password,
888         },
889         {
890             "flag": "VALID UNTIL",
891             "test": bool(valid_until),
892             "skip": valid_until is None,
893             "addtxt": escaped_valid_until,
894         },
895     )
896     for data in flags:
897         sub_cmd = _add_role_flag(sub_cmd, **data)
898     if sub_cmd.endswith("WITH"):
899         sub_cmd = sub_cmd.replace(" WITH", "")
900     if groups:
901         if isinstance(groups, list):
902             groups = ",".join(groups)
903         for group in groups.split(","):
904             sub_cmd = '{}; GRANT "{}" TO "{}"'.format(sub_cmd, group, name)
905     return sub_cmd
906 def _role_create(
907     name,
908     user=None,
909     host=None,
910     port=None,
911     maintenance_db=None,
912     password=None,
913     createdb=None,
914     createroles=None,
915     encrypted=None,
916     superuser=None,
917     login=None,
918     connlimit=None,
919     inherit=None,
920     replication=None,
921     rolepassword=None,
922     valid_until=None,
923     typ_="role",
924     groups=None,
925     runas=None,
926 ):
927     if user_exists(
928         name, user, host, port, maintenance_db, password=password, runas=runas
929     ):
930         log.info("%s '%s' already exists", typ_.capitalize(), name)
931         return False
932     sub_cmd = 'CREATE ROLE "{}" WITH'.format(name)
933     sub_cmd = "{} {}".format(
934         sub_cmd,
935         _role_cmd_args(
936             name,
937             typ_=typ_,
938             encrypted=encrypted,
939             login=login,
940             connlimit=connlimit,
941             inherit=inherit,
942             createdb=createdb,
943             createroles=createroles,
944             superuser=superuser,
945             groups=groups,
946             replication=replication,
947             rolepassword=rolepassword,
948             valid_until=valid_until,
949         ),
950     )
951     ret = _psql_prepare_and_run(
952         ["-c", sub_cmd],
953         runas=runas,
954         host=host,
955         user=user,
956         port=port,
957         maintenance_db=maintenance_db,
958         password=password,
959     )
960     return ret["retcode"] == 0
961 def user_create(
962     username,
963     user=None,
964     host=None,
965     port=None,
966     maintenance_db=None,
967     password=None,
968     createdb=None,
969     createroles=None,
970     inherit=None,
971     login=None,
972     connlimit=None,
973     encrypted=None,
974     superuser=None,
975     replication=None,
976     rolepassword=None,
977     valid_until=None,
978     groups=None,
979     runas=None,
980 ):
981     return _role_create(
982         username,
983         typ_="user",
984         user=user,
985         host=host,
986         port=port,
987         maintenance_db=maintenance_db,
988         password=password,
989         createdb=createdb,
990         createroles=createroles,
991         inherit=inherit,
992         login=login,
993         connlimit=connlimit,
994         encrypted=encrypted,
995         superuser=superuser,
996         replication=replication,
997         rolepassword=rolepassword,
998         valid_until=valid_until,
999         groups=groups,
1000         runas=runas,
1001     )
1002 def _role_update(
1003     name,
1004     user=None,
1005     host=None,
1006     port=None,
1007     maintenance_db=None,
1008     password=None,
1009     createdb=None,
1010     typ_="role",
1011     createroles=None,
1012     inherit=None,
1013     login=None,
1014     connlimit=None,
1015     encrypted=None,
1016     superuser=None,
1017     replication=None,
1018     rolepassword=None,
1019     valid_until=None,
1020     groups=None,
1021     runas=None,
1022 ):
1023     role = role_get(
1024         name,
1025         user=user,
1026         host=host,
1027         port=port,
1028         maintenance_db=maintenance_db,
1029         password=password,
1030         runas=runas,
1031         return_password=False,
1032     )
1033     if not bool(role):
1034         log.info("%s '%s' could not be found", typ_.capitalize(), name)
1035         return False
1036     sub_cmd = 'ALTER ROLE "{}" WITH'.format(name)
1037     sub_cmd = "{} {}".format(
1038         sub_cmd,
1039         _role_cmd_args(
1040             name,
1041             encrypted=encrypted,
1042             login=login,
1043             connlimit=connlimit,
1044             inherit=inherit,
1045             createdb=createdb,
1046             createroles=createroles,
1047             superuser=superuser,
1048             groups=groups,
1049             replication=replication,
1050             rolepassword=rolepassword,
1051             valid_until=valid_until,
1052             db_role=role,
1053         ),
1054     )
1055     ret = _psql_prepare_and_run(
1056         ["-c", sub_cmd],
1057         runas=runas,
1058         host=host,
1059         user=user,
1060         port=port,
1061         maintenance_db=maintenance_db,
1062         password=password,
1063     )
1064     return ret["retcode"] == 0
1065 def user_update(
1066     username,
1067     user=None,
1068     host=None,
1069     port=None,
1070     maintenance_db=None,
1071     password=None,
1072     createdb=None,
1073     createroles=None,
1074     encrypted=None,
1075     superuser=None,
1076     inherit=None,
1077     login=None,
1078     connlimit=None,
1079     replication=None,
1080     rolepassword=None,
1081     valid_until=None,
1082     groups=None,
1083     runas=None,
1084 ):
1085     return _role_update(
1086         username,
1087         user=user,
1088         host=host,
1089         port=port,
1090         maintenance_db=maintenance_db,
1091         password=password,
1092         typ_="user",
1093         inherit=inherit,
1094         login=login,
1095         connlimit=connlimit,
1096         createdb=createdb,
1097         createroles=createroles,
1098         encrypted=encrypted,
1099         superuser=superuser,
1100         replication=replication,
1101         rolepassword=rolepassword,
1102         valid_until=valid_until,
1103         groups=groups,
1104         runas=runas,
1105     )
1106 def _role_remove(
1107     name,
1108     user=None,
1109     host=None,
1110     port=None,
1111     maintenance_db=None,
1112     password=None,
1113     runas=None,
1114 ):
1115     if not user_exists(
1116         name, user, host, port, maintenance_db, password=password, runas=runas
1117     ):
1118         log.info("User '%s' does not exist", name)
1119         return False
1120     sub_cmd = 'DROP ROLE "{}"'.format(name)
1121     _psql_prepare_and_run(
1122         ["-c", sub_cmd],
1123         runas=runas,
1124         host=host,
1125         user=user,
1126         port=port,
1127         maintenance_db=maintenance_db,
1128         password=password,
1129     )
1130     if not user_exists(
1131         name, user, host, port, maintenance_db, password=password, runas=runas
1132     ):
1133         return True
1134     else:
1135         log.info("Failed to delete user '%s'.", name)
1136         return False
1137 def available_extensions(
1138     user=None, host=None, port=None, maintenance_db=None, password=None, runas=None
1139 ):
1140     exts = []
1141     query = "select * from pg_available_extensions();"
1142     ret = psql_query(
1143         query,
1144         user=user,
1145         host=host,
1146         port=port,
1147         maintenance_db=maintenance_db,
1148         password=password,
1149         runas=runas,
1150     )
1151     exts = {}
1152     for row in ret:
1153         if "default_version" in row and "name" in row:
1154             exts[row["name"]] = row
1155     return exts
1156 def installed_extensions(
1157     user=None, host=None, port=None, maintenance_db=None, password=None, runas=None
1158 ):
1159     exts = []
1160     query = (
1161         "select a.*, b.nspname as schema_name "
1162         "from pg_extension a,  pg_namespace b where a.extnamespace = b.oid;"
1163     )
1164     ret = psql_query(
1165         query,
1166         user=user,
1167         host=host,
1168         port=port,
1169         maintenance_db=maintenance_db,
1170         password=password,
1171         runas=runas,
1172     )
1173     exts = {}
1174     for row in ret:
1175         if "extversion" in row and "extname" in row:
1176             exts[row["extname"]] = row
1177     return exts
1178 def get_available_extension(
1179     name,
1180     user=None,
1181     host=None,
1182     port=None,
1183     maintenance_db=None,
1184     password=None,
1185     runas=None,
1186 ):
1187     return available_extensions(
1188         user=user,
1189         host=host,
1190         port=port,
1191         maintenance_db=maintenance_db,
1192         password=password,
1193         runas=runas,
1194     ).get(name, None)
1195 def get_installed_extension(
1196     name,
1197     user=None,
1198     host=None,
1199     port=None,
1200     maintenance_db=None,
1201     password=None,
1202     runas=None,
1203 ):
1204     return installed_extensions(
1205         user=user,
1206         host=host,
1207         port=port,
1208         maintenance_db=maintenance_db,
1209         password=password,
1210         runas=runas,
1211     ).get(name, None)
1212 def is_available_extension(
1213     name,
1214     user=None,
1215     host=None,
1216     port=None,
1217     maintenance_db=None,
1218     password=None,
1219     runas=None,
1220 ):
1221     exts = available_extensions(
1222         user=user,
1223         host=host,
1224         port=port,
1225         maintenance_db=maintenance_db,
1226         password=password,
1227         runas=runas,
1228     )
1229     if name.lower() in [a.lower() for a in exts]:
1230         return True
1231     return False
1232 def _pg_is_older_ext_ver(a, b):
1233     return _LooseVersion(a) &lt; _LooseVersion(b)
1234 def is_installed_extension(
1235     name,
1236     user=None,
1237     host=None,
1238     port=None,
1239     maintenance_db=None,
1240     password=None,
1241     runas=None,
1242 ):
1243     installed_ext = get_installed_extension(
1244         name,
1245         user=user,
1246         host=host,
1247         port=port,
1248         maintenance_db=maintenance_db,
1249         password=password,
1250         runas=runas,
1251     )
1252     return bool(installed_ext)
1253 def create_metadata(
1254     name,
1255     ext_version=None,
1256     schema=None,
1257     user=None,
1258     host=None,
1259     port=None,
1260     maintenance_db=None,
1261     password=None,
1262     runas=None,
1263 ):
1264     installed_ext = get_installed_extension(
1265         name,
1266         user=user,
1267         host=host,
1268         port=port,
1269         maintenance_db=maintenance_db,
1270         password=password,
1271         runas=runas,
1272     )
1273     ret = [_EXTENSION_NOT_INSTALLED]
1274     if installed_ext:
1275         ret = [_EXTENSION_INSTALLED]
1276         if ext_version is not None and _pg_is_older_ext_ver(
1277             installed_ext.get("extversion", ext_version), ext_version
1278         ):
1279             ret.append(_EXTENSION_TO_UPGRADE)
1280         if (
1281             schema is not None
1282             and installed_ext.get("extrelocatable", "f") == "t"
1283             and installed_ext.get("schema_name", schema) != schema
1284         ):
1285             ret.append(_EXTENSION_TO_MOVE)
1286     return ret
1287 def drop_extension(
1288     name,
1289     if_exists=None,
1290     restrict=None,
1291     cascade=None,
1292     user=None,
1293     host=None,
1294     port=None,
1295     maintenance_db=None,
1296     password=None,
1297     runas=None,
1298 ):
1299     if cascade is None:
1300         cascade = True
1301     if if_exists is None:
1302         if_exists = False
1303     if restrict is None:
1304         restrict = False
1305     args = ["DROP EXTENSION"]
1306     if if_exists:
1307         args.append("IF EXISTS")
1308     args.append(name)
1309     if cascade:
1310         args.append("CASCADE")
1311     if restrict:
1312         args.append("RESTRICT")
1313     args.append(";")
1314     cmd = " ".join(args)
1315     if is_installed_extension(
1316         name,
1317         user=user,
1318         host=host,
1319         port=port,
1320         maintenance_db=maintenance_db,
1321         password=password,
1322         runas=runas,
1323     ):
1324         _psql_prepare_and_run(
1325             ["-c", cmd],
1326             runas=runas,
1327             host=host,
1328             user=user,
1329             port=port,
1330             maintenance_db=maintenance_db,
1331             password=password,
1332         )
1333     ret = not is_installed_extension(
1334         name,
1335         user=user,
1336         host=host,
1337         port=port,
1338         maintenance_db=maintenance_db,
1339         password=password,
1340         runas=runas,
1341     )
1342     if not ret:
1343         log.info("Failed to drop ext: %s", name)
1344     return ret
1345 def create_extension(
1346     name,
1347     if_not_exists=None,
1348     schema=None,
1349     ext_version=None,
1350     from_version=None,
1351     user=None,
1352     host=None,
1353     port=None,
1354     maintenance_db=None,
1355     password=None,
1356     runas=None,
1357 ):
1358     if if_not_exists is None:
1359         if_not_exists = True
1360     mtdata = create_metadata(
1361         name,
1362         ext_version=ext_version,
1363         schema=schema,
1364         user=user,
1365         host=host,
1366         port=port,
1367         maintenance_db=maintenance_db,
1368         password=password,
1369         runas=runas,
1370     )
1371     installed = _EXTENSION_NOT_INSTALLED not in mtdata
1372     installable = is_available_extension(
1373         name,
1374         user=user,
1375         host=host,
1376         port=port,
1377         maintenance_db=maintenance_db,
1378         password=password,
1379         runas=runas,
1380     )
1381     if installable:
1382         if not installed:
1383             args = ["CREATE EXTENSION"]
1384             if if_not_exists:
1385                 args.append("IF NOT EXISTS")
1386             args.append('"{}"'.format(name))
1387             sargs = []
1388             if schema:
1389                 sargs.append('SCHEMA "{}"'.format(schema))
1390             if ext_version:
1391                 sargs.append("VERSION {}".format(ext_version))
1392             if from_version:
1393                 sargs.append("FROM {}".format(from_version))
1394             if sargs:
1395                 args.append("WITH")
1396                 args.extend(sargs)
1397             args.append(";")
1398             cmd = " ".join(args).strip()
1399         else:
1400             args = []
1401             if schema and _EXTENSION_TO_MOVE in mtdata:
1402                 args.append(
1403                     'ALTER EXTENSION "{}" SET SCHEMA "{}";'.format(name, schema)
1404                 )
1405             if ext_version and _EXTENSION_TO_UPGRADE in mtdata:
1406                 args.append(
1407                     'ALTER EXTENSION "{}" UPDATE TO {};'.format(name, ext_version)
1408                 )
1409             cmd = " ".join(args).strip()
1410         if cmd:
1411             _psql_prepare_and_run(
1412                 ["-c", cmd],
1413                 runas=runas,
1414                 host=host,
1415                 user=user,
1416                 port=port,
1417                 maintenance_db=maintenance_db,
1418                 password=password,
1419             )
1420     mtdata = create_metadata(
1421         name,
1422         ext_version=ext_version,
1423         schema=schema,
1424         user=user,
1425         host=host,
1426         port=port,
1427         maintenance_db=maintenance_db,
1428         password=password,
1429         runas=runas,
1430     )
1431     ret = True
1432     for i in _EXTENSION_FLAGS:
1433         if (i in mtdata) and (i != _EXTENSION_INSTALLED):
1434             ret = False
1435     if not ret:
1436         log.info("Failed to create ext: %s", name)
1437     return ret
1438 def user_remove(
1439     username,
1440     user=None,
1441     host=None,
1442     port=None,
1443     maintenance_db=None,
1444     password=None,
1445     runas=None,
1446 ):
1447     return _role_remove(
1448         username,
1449         user=user,
1450         host=host,
1451         port=port,
1452         maintenance_db=maintenance_db,
1453         password=password,
1454         runas=runas,
1455     )
1456 def group_create(
1457     groupname,
1458     user=None,
1459     host=None,
1460     port=None,
1461     maintenance_db=None,
1462     password=None,
1463     createdb=None,
1464     createroles=None,
1465     encrypted=None,
1466     login=None,
1467     inherit=None,
1468     superuser=None,
1469     replication=None,
1470     rolepassword=None,
1471     groups=None,
1472     runas=None,
1473 ):
1474     return _role_create(
1475         groupname,
1476         user=user,
1477         typ_="group",
1478         host=host,
1479         port=port,
1480         maintenance_db=maintenance_db,
1481         password=password,
1482         createdb=createdb,
1483         createroles=createroles,
1484         encrypted=encrypted,
1485         login=login,
1486         inherit=inherit,
1487         superuser=superuser,
1488         replication=replication,
1489         rolepassword=rolepassword,
1490         groups=groups,
1491         runas=runas,
1492     )
1493 def group_update(
1494     groupname,
1495     user=None,
1496     host=None,
1497     port=None,
1498     maintenance_db=None,
1499     password=None,
1500     createdb=None,
1501     createroles=None,
1502     encrypted=None,
1503     inherit=None,
1504     login=None,
1505     superuser=None,
1506     replication=None,
1507     rolepassword=None,
1508     groups=None,
1509     runas=None,
1510 ):
1511     return _role_update(
1512         groupname,
1513         user=user,
1514         host=host,
1515         port=port,
1516         maintenance_db=maintenance_db,
1517         password=password,
1518         createdb=createdb,
1519         typ_="group",
1520         createroles=createroles,
1521         encrypted=encrypted,
1522         login=login,
1523         inherit=inherit,
1524         superuser=superuser,
1525         replication=replication,
1526         rolepassword=rolepassword,
1527         groups=groups,
1528         runas=runas,
1529     )
1530 def group_remove(
1531     groupname,
1532     user=None,
1533     host=None,
1534     port=None,
1535     maintenance_db=None,
1536     password=None,
1537     runas=None,
1538 ):
1539     return _role_remove(
1540         groupname,
1541         user=user,
1542         host=host,
1543         port=port,
1544         maintenance_db=maintenance_db,
1545         password=password,
1546         runas=runas,
1547     )
1548 def owner_to(
1549     dbname, ownername, user=None, host=None, port=None, password=None, runas=None
1550 ):
1551     sqlfile = tempfile.NamedTemporaryFile()
1552     sqlfile.write("begin;\n")
1553     sqlfile.write('alter database "{}" owner to "{}";\n'.format(dbname, ownername))
1554     queries = (
1555         (
1556             "alter schema {n} owner to {owner};",
1557             "select quote_ident(schema_name) as n from information_schema.schemata;",
1558         ),
1559         (
1560             "alter table {n} owner to {owner};",
1561             "select quote_ident(table_schema)||'.'||quote_ident(table_name) as "
1562             "n from information_schema.tables where table_schema not in "
1563             "('pg_catalog', 'information_schema');",
1564         ),
1565         (
1566             "alter function {n} owner to {owner};",
1567             "select p.oid::regprocedure::text as n from pg_catalog.pg_proc p "
1568             "join pg_catalog.pg_namespace ns on p.pronamespace=ns.oid where "
1569             "ns.nspname not in ('pg_catalog', 'information_schema') "
1570             " and not p.proisagg;",
1571         ),
1572         (
1573             "alter aggregate {n} owner to {owner};",
1574             "select p.oid::regprocedure::text as n from pg_catalog.pg_proc p "
1575             "join pg_catalog.pg_namespace ns on p.pronamespace=ns.oid where "
1576             "ns.nspname not in ('pg_catalog', 'information_schema') "
1577             "and p.proisagg;",
1578         ),
1579         (
1580             "alter sequence {n} owner to {owner};",
1581             "select quote_ident(sequence_schema)||'.'||"
1582             "quote_ident(sequence_name) as n from information_schema.sequences;",
1583         ),
1584     )
1585     for fmt, query in queries:
1586         ret = psql_query(
1587             query,
1588             user=user,
1589             host=host,
1590             port=port,
1591             maintenance_db=dbname,
1592             password=password,
1593             runas=runas,
1594         )
1595         for row in ret:
1596             sqlfile.write(fmt.format(owner=ownername, n=row["n"]) + "\n")
1597     sqlfile.write("commit;\n")
1598     sqlfile.flush()
1599     os.chmod(sqlfile.name, 0o644)  # ensure psql can read the file
1600     cmdret = _psql_prepare_and_run(
1601         ["-f", sqlfile.name],
1602         user=user,
1603         runas=runas,
1604         host=host,
1605         port=port,
1606         password=password,
1607         maintenance_db=dbname,
1608     )
1609     return cmdret
1610 def schema_create(
1611     dbname,
1612     name,
1613     owner=None,
1614     user=None,
1615     db_user=None,
1616     db_password=None,
1617     db_host=None,
1618     db_port=None,
1619 ):
1620     if schema_exists(
1621         dbname,
1622         name,
1623         user=user,
1624         db_user=db_user,
1625         db_password=db_password,
1626         db_host=db_host,
1627         db_port=db_port,
1628     ):
1629         log.info("'%s' already exists in '%s'", name, dbname)
1630         return False
1631     sub_cmd = 'CREATE SCHEMA "{}"'.format(name)
1632     if owner is not None:
1633         sub_cmd = '{} AUTHORIZATION "{}"'.format(sub_cmd, owner)
1634     ret = _psql_prepare_and_run(
1635         ["-c", sub_cmd],
1636         user=db_user,
1637         password=db_password,
1638         port=db_port,
1639         host=db_host,
1640         maintenance_db=dbname,
1641         runas=user,
1642     )
1643     return ret["retcode"] == 0
1644 def schema_remove(
1645     dbname, name, user=None, db_user=None, db_password=None, db_host=None, db_port=None
1646 ):
1647     if not schema_exists(
1648         dbname,
1649         name,
1650         user=None,
1651         db_user=db_user,
1652         db_password=db_password,
1653         db_host=db_host,
1654         db_port=db_port,
1655     ):
1656         log.info("Schema '%s' does not exist in '%s'", name, dbname)
1657         return False
1658     sub_cmd = 'DROP SCHEMA "{}"'.format(name)
1659     _psql_prepare_and_run(
1660         ["-c", sub_cmd],
1661         runas=user,
1662         maintenance_db=dbname,
1663         host=db_host,
1664         user=db_user,
1665         port=db_port,
1666         password=db_password,
1667     )
1668     if not schema_exists(
1669         dbname,
1670         name,
1671         user,
1672         db_user=db_user,
1673         db_password=db_password,
1674         db_host=db_host,
1675         db_port=db_port,
1676     ):
1677         return True
1678     else:
1679         log.info("Failed to delete schema '%s'.", name)
1680         return False
1681 def schema_exists(
1682     dbname, name, user=None, db_user=None, db_password=None, db_host=None, db_port=None
1683 ):
1684     return bool(
1685         schema_get(
1686             dbname,
1687             name,
1688             user=user,
1689             db_user=db_user,
1690             db_host=db_host,
1691             db_port=db_port,
1692             db_password=db_password,
1693         )
1694     )
1695 def schema_get(
1696     dbname, name, user=None, db_user=None, db_password=None, db_host=None, db_port=None
1697 ):
1698     all_schemas = schema_list(
1699         dbname,
1700         user=user,
1701         db_user=db_user,
1702         db_host=db_host,
1703         db_port=db_port,
1704         db_password=db_password,
1705     )
1706     try:
1707         return all_schemas.get(name, None)
1708     except AttributeError:
1709         log.error("Could not retrieve Postgres schema. Is Postgres running?")
1710         return False
1711 def schema_list(
1712     dbname, user=None, db_user=None, db_password=None, db_host=None, db_port=None
1713 ):
1714     ret = {}
1715     query = "".join(
1716         [
1717             "SELECT "
1718             'pg_namespace.nspname as "name",'
1719             'pg_namespace.nspacl as "acl", '
1720             'pg_roles.rolname as "owner" '
1721             "FROM pg_namespace "
1722             "LEFT JOIN pg_roles ON pg_roles.oid = pg_namespace.nspowner "
1723         ]
1724     )
1725     rows = psql_query(
1726         query,
1727         runas=user,
1728         host=db_host,
1729         user=db_user,
1730         port=db_port,
1731         maintenance_db=dbname,
1732         password=db_password,
1733     )
1734     for row in rows:
1735         retrow = {}
1736         for key in ("owner", "acl"):
1737             retrow[key] = row[key]
1738         ret[row["name"]] = retrow
1739     return ret
1740 def language_list(
1741     maintenance_db, user=None, host=None, port=None, password=None, runas=None
1742 ):
1743     ret = {}
1744     query = 'SELECT lanname AS "Name" FROM pg_language'
1745     rows = psql_query(
1746         query,
1747         runas=runas,
1748         host=host,
1749         user=user,
1750         port=port,
1751         maintenance_db=maintenance_db,
1752         password=password,
1753     )
1754     for row in rows:
1755         ret[row["Name"]] = row["Name"]
1756     return ret
1757 def language_exists(
1758     name, maintenance_db, user=None, host=None, port=None, password=None, runas=None
1759 ):
1760     languages = language_list(
1761         maintenance_db, user=user, host=host, port=port, password=password, runas=runas
1762     )
1763     return name in languages
1764 def language_create(
1765     name, maintenance_db, user=None, host=None, port=None, password=None, runas=None
1766 ):
1767     if language_exists(name, maintenance_db):
1768         log.info("Language %s already exists in %s", name, maintenance_db)
1769         return False
1770     query = "CREATE LANGUAGE {}".format(name)
1771     ret = _psql_prepare_and_run(
1772         ["-c", query],
1773         user=user,
1774         host=host,
1775         port=port,
1776         maintenance_db=maintenance_db,
1777         password=password,
1778         runas=runas,
1779     )
1780     return ret["retcode"] == 0
1781 def language_remove(
1782     name, maintenance_db, user=None, host=None, port=None, password=None, runas=None
1783 ):
1784     if not language_exists(name, maintenance_db):
1785         log.info("Language %s does not exist in %s", name, maintenance_db)
1786         return False
1787     query = "DROP LANGUAGE {}".format(name)
1788     ret = _psql_prepare_and_run(
1789         ["-c", query],
1790         user=user,
1791         host=host,
1792         port=port,
1793         runas=runas,
1794         maintenance_db=maintenance_db,
1795         password=password,
1796     )
1797     return ret["retcode"] == 0
1798 def _make_privileges_list_query(name, object_type, prepend):
1799     if object_type == "table":
1800         query = (
1801             " ".join(
1802                 [
1803                     "SELECT relacl AS name",
1804                     "FROM pg_catalog.pg_class c",
1805                     "JOIN pg_catalog.pg_namespace n",
1806                     "ON n.oid = c.relnamespace",
1807                     "WHERE nspname = '{0}'",
1808                     "AND relname = '{1}'",
1809                     "AND relkind = 'r'",
1810                     "ORDER BY relname",
1811                 ]
1812             )
1813         ).format(prepend, name)
1814     elif object_type == "sequence":
1815         query = (
1816             " ".join(
1817                 [
1818                     "SELECT relacl AS name",
1819                     "FROM pg_catalog.pg_class c",
1820                     "JOIN pg_catalog.pg_namespace n",
1821                     "ON n.oid = c.relnamespace",
1822                     "WHERE nspname = '{0}'",
1823                     "AND relname = '{1}'",
1824                     "AND relkind = 'S'",
1825                     "ORDER BY relname",
1826                 ]
1827             )
1828         ).format(prepend, name)
1829     elif object_type == "schema":
1830         query = (
1831             " ".join(
1832                 [
1833                     "SELECT nspacl AS name",
1834                     "FROM pg_catalog.pg_namespace",
1835                     "WHERE nspname = '{0}'",
1836                     "ORDER BY nspname",
1837                 ]
1838             )
1839         ).format(name)
1840     elif object_type == "function":
1841         query = (
1842             " ".join(
1843                 [
1844                     "SELECT proacl AS name",
1845                     "FROM pg_catalog.pg_proc p",
1846                     "JOIN pg_catalog.pg_namespace n",
1847                     "ON n.oid = p.pronamespace",
1848                     "WHERE nspname = '{0}'",
1849                     "AND p.oid::regprocedure::text = '{1}'",
1850                     "ORDER BY proname, proargtypes",
1851                 ]
1852             )
1853         ).format(prepend, name)
1854     elif object_type == "tablespace":
1855         query = (
1856             " ".join(
1857                 [
1858                     "SELECT spcacl AS name",
1859                     "FROM pg_catalog.pg_tablespace",
1860                     "WHERE spcname = '{0}'",
1861                     "ORDER BY spcname",
1862                 ]
1863             )
1864         ).format(name)
1865     elif object_type == "language":
1866         query = (
1867             " ".join(
1868                 [
1869                     "SELECT lanacl AS name",
1870                     "FROM pg_catalog.pg_language",
1871                     "WHERE lanname = '{0}'",
1872                     "ORDER BY lanname",
1873                 ]
1874             )
1875         ).format(name)
1876     elif object_type == "database":
1877         query = (
1878             " ".join(
1879                 [
1880                     "SELECT datacl AS name",
1881                     "FROM pg_catalog.pg_database",
1882                     "WHERE datname = '{0}'",
1883                     "ORDER BY datname",
1884                 ]
1885             )
1886         ).format(name)
1887     elif object_type == "group":
1888         query = (
1889             " ".join(
1890                 [
1891                     "SELECT rolname, admin_option",
1892                     "FROM pg_catalog.pg_auth_members m",
1893                     "JOIN pg_catalog.pg_roles r",
1894                     "ON m.member=r.oid",
1895                     "WHERE m.roleid IN",
1896                     "(SELECT oid",
1897                     "FROM pg_catalog.pg_roles",
1898                     "WHERE rolname='{0}')",
1899                     "ORDER BY rolname",
1900                 ]
1901             )
1902         ).format(name)
1903     return query
1904 def _get_object_owner(
1905     name,
1906     object_type,
1907     prepend="public",
1908     maintenance_db=None,
1909     user=None,
1910     host=None,
1911     port=None,
1912     password=None,
1913     runas=None,
1914 ):
1915     if object_type == "table":
1916         query = (
1917             " ".join(
1918                 [
1919                     "SELECT tableowner AS name",
1920                     "FROM pg_tables",
1921                     "WHERE schemaname = '{0}'",
1922                     "AND tablename = '{1}'",
1923                 ]
1924             )
1925         ).format(prepend, name)
1926     elif object_type == "sequence":
1927         query = (
1928             " ".join(
1929                 [
1930                     "SELECT rolname AS name",
1931                     "FROM pg_catalog.pg_class c",
1932                     "JOIN pg_roles r",
1933                     "ON c.relowner = r.oid",
1934                     "JOIN pg_catalog.pg_namespace n",
1935                     "ON n.oid = c.relnamespace",
1936                     "WHERE relkind='S'",
1937                     "AND nspname='{0}'",
1938                     "AND relname = '{1}'",
1939                 ]
1940             )
1941         ).format(prepend, name)
1942     elif object_type == "schema":
1943         query = (
1944             " ".join(
1945                 [
1946                     "SELECT rolname AS name",
1947                     "FROM pg_namespace n",
1948                     "JOIN pg_roles r",
1949                     "ON n.nspowner = r.oid",
1950                     "WHERE nspname = '{0}'",
1951                 ]
1952             )
1953         ).format(name)
1954     elif object_type == "function":
1955         query = (
1956             " ".join(
1957                 [
1958                     "SELECT rolname AS name",
1959                     "FROM pg_catalog.pg_proc p",
1960                     "JOIN pg_catalog.pg_namespace n",
1961                     "ON n.oid = p.pronamespace",
1962                     "WHERE nspname = '{0}'",
1963                     "AND p.oid::regprocedure::text = '{1}'",
1964                     "ORDER BY proname, proargtypes",
1965                 ]
1966             )
1967         ).format(prepend, name)
1968     elif object_type == "tablespace":
1969         query = (
1970             " ".join(
1971                 [
1972                     "SELECT rolname AS name",
1973                     "FROM pg_tablespace t",
1974                     "JOIN pg_roles r",
1975                     "ON t.spcowner = r.oid",
1976                     "WHERE spcname = '{0}'",
1977                 ]
1978             )
1979         ).format(name)
1980     elif object_type == "language":
1981         query = (
1982             " ".join(
1983                 [
1984                     "SELECT rolname AS name",
1985                     "FROM pg_language l",
1986                     "JOIN pg_roles r",
1987                     "ON l.lanowner = r.oid",
1988                     "WHERE lanname = '{0}'",
1989                 ]
1990             )
1991         ).format(name)
1992     elif object_type == "database":
1993         query = (
1994             " ".join(
1995                 [
1996                     "SELECT rolname AS name",
1997                     "FROM pg_database d",
1998                     "JOIN pg_roles r",
1999                     "ON d.datdba = r.oid",
2000                     "WHERE datname = '{0}'",
2001                 ]
2002             )
2003         ).format(name)
2004     rows = psql_query(
2005         query,
2006         runas=runas,
2007         host=host,
2008         user=user,
2009         port=port,
2010         maintenance_db=maintenance_db,
2011         password=password,
2012     )
2013     try:
2014         ret = rows[0]["name"]
2015     except IndexError:
2016         ret = None
2017     return ret
2018 def _validate_privileges(object_type, privs, privileges):
2019     if object_type != "group":
2020         _perms = [_PRIVILEGES_MAP[perm] for perm in _PRIVILEGE_TYPE_MAP[object_type]]
2021         _perms.append("ALL")
2022         if object_type not in _PRIVILEGES_OBJECTS:
2023             raise SaltInvocationError(
2024                 "Invalid object_type: {} provided".format(object_type)
2025             )
2026         if not set(privs).issubset(set(_perms)):
2027             raise SaltInvocationError(
2028                 "Invalid privilege(s): {} provided for object {}".format(
2029                     privileges, object_type
2030                 )
2031             )
2032     else:
2033         if privileges:
2034             raise SaltInvocationError(
2035                 "The privileges option should not be set for object_type group"
2036             )
2037 def _mod_priv_opts(object_type, privileges):
2038     object_type = object_type.lower()
2039     privileges = "" if privileges is None else privileges
2040     _privs = re.split(r"\s?,\s?", privileges.upper())
2041     return object_type, privileges, _privs
2042 def _process_priv_part(perms):
2043     _tmp = {}
2044     previous = None
2045     for perm in perms:
2046         if previous is None:
2047             _tmp[_PRIVILEGES_MAP[perm]] = False
2048             previous = _PRIVILEGES_MAP[perm]
2049         else:
2050             if perm == "*":
2051                 _tmp[previous] = True
2052             else:
2053                 _tmp[_PRIVILEGES_MAP[perm]] = False
2054                 previous = _PRIVILEGES_MAP[perm]
2055     return _tmp
2056 def privileges_list(
2057     name,
2058     object_type,
2059     prepend="public",
2060     maintenance_db=None,
2061     user=None,
2062     host=None,
2063     port=None,
2064     password=None,
2065     runas=None,
2066 ):
2067     object_type = object_type.lower()
2068     query = _make_privileges_list_query(name, object_type, prepend)
2069     if object_type not in _PRIVILEGES_OBJECTS:
2070         raise SaltInvocationError(
2071             "Invalid object_type: {} provided".format(object_type)
2072         )
2073     rows = psql_query(
2074         query,
2075         runas=runas,
2076         host=host,
2077         user=user,
2078         port=port,
2079         maintenance_db=maintenance_db,
2080         password=password,
2081     )
2082     ret = {}
2083     for row in rows:
2084         if object_type != "group":
2085             result = row["name"]
2086             result = result.strip("{}")
2087             parts = result.split(",")
2088             for part in parts:
2089                 perms_part, _ = part.split("/")
2090                 rolename, perms = perms_part.split("=")
2091                 if rolename == "":
2092                     rolename = "public"
2093                 _tmp = _process_priv_part(perms)
2094                 ret[rolename] = _tmp
2095         else:
2096             if row["admin_option"] == "t":
2097                 admin_option = True
2098             else:
2099                 admin_option = False
2100             ret[row["rolname"]] = admin_option
2101     return ret
2102 def has_privileges(
2103     name,
2104     object_name,
2105     object_type,
2106     privileges=None,
2107     grant_option=None,
2108     prepend="public",
2109     maintenance_db=None,
2110     user=None,
2111     host=None,
2112     port=None,
2113     password=None,
2114     runas=None,
2115 ):
2116     object_type, privileges, _privs = _mod_priv_opts(object_type, privileges)
2117     _validate_privileges(object_type, _privs, privileges)
2118     if object_type != "group":
2119         owner = _get_object_owner(
2120             object_name,
2121             object_type,
2122             prepend=prepend,
2123             maintenance_db=maintenance_db,
2124             user=user,
2125             host=host,
2126             port=port,
2127             password=password,
2128             runas=runas,
2129         )
2130         if owner is not None and name == owner:
2131             return True
2132     _privileges = privileges_list(
2133         object_name,
2134         object_type,
2135         prepend=prepend,
2136         maintenance_db=maintenance_db,
2137         user=user,
2138         host=host,
2139         port=port,
2140         password=password,
2141         runas=runas,
2142     )
2143     if name in _privileges:
2144         if object_type == "group":
2145             if grant_option:
2146                 retval = _privileges[name]
2147             else:
2148                 retval = True
2149             return retval
2150         else:
2151             _perms = _PRIVILEGE_TYPE_MAP[object_type]
2152             if grant_option:
2153                 perms = {_PRIVILEGES_MAP[perm]: True for perm in _perms}
2154                 retval = perms == _privileges[name]
2155             else:
2156                 perms = [_PRIVILEGES_MAP[perm] for perm in _perms]
2157                 if "ALL" in _privs:
2158                     retval = sorted(perms) == sorted(_privileges[name])
2159                 else:
2160                     retval = set(_privs).issubset(set(_privileges[name]))
2161             return retval
2162     return False
2163 def privileges_grant(
2164     name,
2165     object_name,
2166     object_type,
2167     privileges=None,
2168     grant_option=None,
2169     prepend="public",
2170     maintenance_db=None,
2171     user=None,
2172     host=None,
2173     port=None,
2174     password=None,
2175     runas=None,
2176 ):
2177     object_type, privileges, _privs = _mod_priv_opts(object_type, privileges)
2178     _validate_privileges(object_type, _privs, privileges)
2179     if has_privileges(
2180         name,
2181         object_name,
2182         object_type,
2183         privileges,
2184         prepend=prepend,
2185         maintenance_db=maintenance_db,
2186         user=user,
2187         host=host,
2188         port=port,
2189         password=password,
2190         runas=runas,
2191     ):
2192         log.info(
2193             "The object: %s of type: %s already has privileges: %s set",
2194             object_name,
2195             object_type,
2196             privileges,
2197         )
2198         return False
2199     _grants = ",".join(_privs)
2200     if object_type in ["table", "sequence"]:
2201         on_part = '{}."{}"'.format(prepend, object_name)
2202     elif object_type == "function":
2203         on_part = "{}".format(object_name)
2204     else:
2205         on_part = '"{}"'.format(object_name)
2206     if grant_option:
2207         if object_type == "group":
2208             query = 'GRANT {} TO "{}" WITH ADMIN OPTION'.format(object_name, name)
2209         elif object_type in ("table", "sequence") and object_name.upper() == "ALL":
2210             query = 'GRANT {} ON ALL {}S IN SCHEMA {} TO "{}" WITH GRANT OPTION'.format(
2211                 _grants, object_type.upper(), prepend, name
2212             )
2213         else:
2214             query = 'GRANT {} ON {} {} TO "{}" WITH GRANT OPTION'.format(
2215                 _grants, object_type.upper(), on_part, name
2216             )
2217     else:
2218         if object_type == "group":
2219             query = 'GRANT {} TO "{}"'.format(object_name, name)
2220         elif object_type in ("table", "sequence") and object_name.upper() == "ALL":
2221             query = 'GRANT {} ON ALL {}S IN SCHEMA {} TO "{}"'.format(
2222                 _grants, object_type.upper(), prepend, name
2223             )
2224         else:
2225             query = 'GRANT {} ON {} {} TO "{}"'.format(
2226                 _grants, object_type.upper(), on_part, name
2227             )
2228     ret = _psql_prepare_and_run(
2229         ["-c", query],
2230         user=user,
2231         host=host,
2232         port=port,
2233         maintenance_db=maintenance_db,
2234         password=password,
2235         runas=runas,
2236     )
2237     return ret["retcode"] == 0
2238 def privileges_revoke(
2239     name,
2240     object_name,
2241     object_type,
2242     privileges=None,
2243     prepend="public",
2244     maintenance_db=None,
2245     user=None,
2246     host=None,
2247     port=None,
2248     password=None,
2249     runas=None,
2250 ):
2251     object_type, privileges, _privs = _mod_priv_opts(object_type, privileges)
2252     _validate_privileges(object_type, _privs, privileges)
2253     if not has_privileges(
2254         name,
2255         object_name,
2256         object_type,
2257         privileges,
2258         prepend=prepend,
2259         maintenance_db=maintenance_db,
2260         user=user,
2261         host=host,
2262         port=port,
2263         password=password,
2264         runas=runas,
2265     ):
2266         log.info(
2267             "The object: %s of type: %s does not have privileges: %s set",
2268             object_name,
2269             object_type,
2270             privileges,
2271         )
2272         return False
2273     _grants = ",".join(_privs)
2274     if object_type in ["table", "sequence"]:
2275         on_part = "{}.{}".format(prepend, object_name)
2276     else:
2277         on_part = object_name
2278     if object_type == "group":
2279         query = "REVOKE {} FROM {}".format(object_name, name)
2280     else:
2281         query = "REVOKE {} ON {} {} FROM {}".format(
2282             _grants, object_type.upper(), on_part, name
2283         )
2284     ret = _psql_prepare_and_run(
2285         ["-c", query],
2286         user=user,
2287         host=host,
2288         port=port,
2289         maintenance_db=maintenance_db,
2290         password=password,
2291         runas=runas,
2292     )
2293     return ret["retcode"] == 0
2294 def datadir_init(
2295     name,
2296     auth="password",
2297     user=None,
2298     password=None,
2299     encoding="UTF8",
2300     locale=None,
2301     waldir=None,
2302     checksums=False,
2303     runas=None,
2304 ):
2305     if datadir_exists(name):
2306         log.info("%s already exists", name)
2307         return False
2308     ret = _run_initdb(
2309         name,
2310         auth=auth,
2311         user=user,
2312         password=password,
2313         encoding=encoding,
2314         locale=locale,
2315         waldir=waldir,
2316         checksums=checksums,
2317         runas=runas,
2318     )
2319     return ret["retcode"] == 0
2320 def datadir_exists(name):
2321     _version_file = os.path.join(name, "PG_VERSION")
2322     _config_file = os.path.join(name, "postgresql.conf")
2323     return os.path.isfile(_version_file) and os.path.isfile(_config_file)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
