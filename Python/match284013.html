<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_iptables_1.py &amp; postgres_2.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_iptables_1.py &amp; postgres_2.py
      </h3>
<h1 align="center">
        0.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_iptables_1.py (1.5738499%)<th>postgres_2.py (0.45343566%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(49-55)<td><a href="#" name="0">(605-614)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_iptables_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import textwrap
import uuid
import salt.modules.iptables as iptables
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import MagicMock, mock_open, patch
from tests.support.unit import TestCase
class IptablesTestCase(TestCase, LoaderModuleMockMixin):
    def setup_loader_modules(self):
        return {iptables: {}}
    def test_version(self):
        mock = MagicMock(return_value="iptables v1.4.21")
        with patch.dict(iptables.__salt__, {"cmd.run_stdout": mock}):
            self.assertEqual(iptables.version(), "v1.4.21")
    def test_build_rule(self):
        with patch.object(iptables, "_has_option", MagicMock(return_value=True)):
            self.assertEqual(iptables.build_rule(), "")
            self.assertEqual(
                iptables.build_rule(name="ignored", state="ignored"),
                "",
                "build_rule should ignore name and state",
<a name="0"></a>            )
            self.assertEqual(iptables<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.build_rule(**{"if": "!eth0"}), "! -i eth0")
            self.assertEqual(iptables.build_rule(**{"if": "not eth0"}), "! -i eth0")
            self.assertEqual(
                iptables.build_rule(**{"protocol"</b></font>: "tcp", "syn": "!"}), "-p tcp ! --syn"
            )
            self.assertEqual(
                iptables.build_rule(dports=[80, 443], protocol="tcp"),
                "-p tcp -m multiport --dports 80,443",
            )
            self.assertEqual(
                iptables.build_rule(dports="80,443", protocol="tcp"),
                "-p tcp -m multiport --dports 80,443",
            )
            self.assertEqual(
                iptables.build_rule(dports=["!80", 443], protocol="tcp"),
                "-p tcp -m multiport ! --dports 80,443",
            )
            self.assertEqual(
                iptables.build_rule(dports="!80,443", protocol="tcp"),
                "-p tcp -m multiport ! --dports 80,443",
            )
            self.assertEqual(
                iptables.build_rule(sports=[80, 443], protocol="tcp"),
                "-p tcp -m multiport --sports 80,443",
            )
            self.assertEqual(
                iptables.build_rule(sports="80,443", protocol="tcp"),
                "-p tcp -m multiport --sports 80,443",
            )
            self.assertEqual(
                iptables.build_rule(
                    "filter",
                    "INPUT",
                    command="I",
                    position="3",
                    full=True,
                    dports="protocol",
                    jump="ACCEPT",
                ),
                "Error: protocol must be specified",
            )
            self.assertEqual(
                iptables.build_rule(
                    "filter",
                    "INPUT",
                    command="I",
                    position="3",
                    full=True,
                    sports="protocol",
                    jump="ACCEPT",
                ),
                "Error: protocol must be specified",
            )
            self.assertEqual(
                iptables.build_rule(
                    "",
                    "INPUT",
                    command="I",
                    position="3",
                    full="True",
                    match="state",
                    jump="ACCEPT",
                ),
                "Error: Table needs to be specified",
            )
            self.assertEqual(
                iptables.build_rule(
                    "filter",
                    "",
                    command="I",
                    position="3",
                    full="True",
                    match="state",
                    jump="ACCEPT",
                ),
                "Error: Chain needs to be specified",
            )
            self.assertEqual(
                iptables.build_rule(
                    "filter",
                    "INPUT",
                    command="",
                    position="3",
                    full="True",
                    match="state",
                    jump="ACCEPT",
                ),
                "Error: Command needs to be specified",
            )
            self.assertEqual(
                iptables.build_rule(jump="REDIRECT", **{"to-port": 8080}),
                "--jump REDIRECT --to-port 8080",
            )
            self.assertEqual(
                iptables.build_rule(jump="LOG", **{"log-prefix": "long prefix"}),
                '--jump LOG --log-prefix "long prefix"',
            )
            self.assertEqual(
                iptables.build_rule(jump="LOG", **{"log-prefix": "spam: "}),
                '--jump LOG --log-prefix "spam: "',
            )
            self.assertEqual(
                iptables.build_rule(jump="CLUSTERIP", **{"new": ""}),
                "--jump CLUSTERIP --new",
            )
            self.assertEqual(
                iptables.build_rule(jump="CT", **{"notrack": None}),
                "--jump CT --notrack",
            )
            self.assertEqual(
                iptables.build_rule(**{"match-set": "src flag1,flag2"}),
                "-m set --match-set src flag1,flag2",
            )
            match_sets = [
                "src1 flag1",
                "src2 flag2,flag3",
            ]
            self.assertEqual(
                iptables.build_rule(**{"match-set": match_sets}),
                "-m set --match-set src1 flag1 -m set --match-set src2 flag2,flag3",
            )
            self.assertEqual(
                iptables.build_rule(**{"match-set": "!src flag"}),
                "-m set ! --match-set src flag",
            )
            match_sets = ["src1 flag", "not src2 flag2"]
            self.assertEqual(
                iptables.build_rule(**{"match-set": match_sets}),
                "-m set --match-set src1 flag -m set ! --match-set src2 flag2",
            )
            self.assertEqual(
                iptables.build_rule(**{"match": "recent", "name_": "SSH"}),
                "-m recent --name SSH",
            )
            self.assertEqual(
                iptables.build_rule(**{"match": "recent", "update": None}),
                "-m recent --update",
            )
            ret = "/sbin/iptables --wait -t salt -I INPUT 3 -m state --jump ACCEPT"
            with patch.object(
                iptables, "_iptables_cmd", MagicMock(return_value="/sbin/iptables")
            ):
                self.assertEqual(
                    iptables.build_rule(
                        "salt",
                        "INPUT",
                        command="I",
                        position="3",
                        full="True",
                        match="state",
                        jump="ACCEPT",
                    ),
                    ret,
                )
    def test_get_saved_rules(self):
        mock = MagicMock(return_value=False)
        with patch.object(iptables, "_parse_conf", mock):
            self.assertFalse(iptables.get_saved_rules())
            mock.assert_called_with(conf_file=None, family="ipv4")
    def test_get_saved_rules_nilinuxrt(self):
        data = {
            "/etc/natinst/share/iptables.conf": textwrap.dedent(
            )
        }
        expected_input_rules = [
            {
                "protocol": ["tcp"],
                "jump": ["ACCEPT"],
                "match": ["tcp"],
                "destination_port": ["80"],
            }
        ]
        file_mock = mock_open(read_data=data)
        with patch.dict(
            iptables.__grains__, {"os_family": "NILinuxRT", "os": "NILinuxRT"}
        ):
            with patch.object(iptables.salt.utils.files, "fopen", file_mock):
                rules = iptables.get_saved_rules()
                self.assertEqual(
                    expected_input_rules, rules["filter"]["INPUT"]["rules"]
                )
    def test_get_rules(self):
        mock = MagicMock(return_value=False)
        with patch.object(iptables, "_parse_conf", mock):
            self.assertFalse(iptables.get_rules())
            mock.assert_called_with(in_mem=True, family="ipv4")
    def test_get_saved_policy(self):
        self.assertEqual(
            iptables.get_saved_policy(
                table="filter", chain=None, conf_file=None, family="ipv4"
            ),
            "Error: Chain needs to be specified",
        )
        with patch.object(
            iptables,
            "_parse_conf",
            MagicMock(return_value={"filter": {"INPUT": {"policy": True}}}),
        ):
            self.assertTrue(
                iptables.get_saved_policy(
                    table="filter", chain="INPUT", conf_file=None, family="ipv4"
                )
            )
        with patch.object(
            iptables,
            "_parse_conf",
            MagicMock(return_value={"filter": {"INPUT": {"policy1": True}}}),
        ):
            self.assertIsNone(
                iptables.get_saved_policy(
                    table="filter", chain="INPUT", conf_file=None, family="ipv4"
                )
            )
    def test_get_policy(self):
        self.assertEqual(
            iptables.get_policy(table="filter", chain=None, family="ipv4"),
            "Error: Chain needs to be specified",
        )
        with patch.object(
            iptables,
            "_parse_conf",
            MagicMock(return_value={"filter": {"INPUT": {"policy": True}}}),
        ):
            self.assertTrue(
                iptables.get_policy(table="filter", chain="INPUT", family="ipv4")
            )
        with patch.object(
            iptables,
            "_parse_conf",
            MagicMock(return_value={"filter": {"INPUT": {"policy1": True}}}),
        ):
            self.assertIsNone(
                iptables.get_policy(table="filter", chain="INPUT", family="ipv4")
            )
    def test_set_policy(self):
        with patch.object(iptables, "_has_option", MagicMock(return_value=True)):
            self.assertEqual(
                iptables.set_policy(
                    table="filter", chain=None, policy=None, family="ipv4"
                ),
                "Error: Chain needs to be specified",
            )
            self.assertEqual(
                iptables.set_policy(
                    table="filter", chain="INPUT", policy=None, family="ipv4"
                ),
                "Error: Policy needs to be specified",
            )
            mock = MagicMock(return_value=True)
            with patch.dict(iptables.__salt__, {"cmd.run_stderr": mock}):
                self.assertTrue(
                    iptables.set_policy(
                        table="filter", chain="INPUT", policy="ACCEPT", family="ipv4"
                    )
                )
    def test_save(self):
        with patch("salt.modules.iptables._conf", MagicMock(return_value=False)), patch(
            "os.path.isdir", MagicMock(return_value=True)
        ):
            mock = MagicMock(return_value=True)
            with patch.dict(
                iptables.__salt__,
                {
                    "cmd.run_stdout": mock,
                    "file.write": mock,
                    "config.option": MagicMock(return_value=[]),
                },
            ):
                self.assertTrue(iptables.save(filename="/xyz", family="ipv4"))
    def test_check(self):
        self.assertEqual(
            iptables.check(table="filter", chain=None, rule=None, family="ipv4"),
            "Error: Chain needs to be specified",
        )
        self.assertEqual(
            iptables.check(table="filter", chain="INPUT", rule=None, family="ipv4"),
            "Error: Rule needs to be specified",
        )
        mock_rule = "m state --state RELATED,ESTABLISHED -j ACCEPT"
        mock_chain = "INPUT"
        mock_uuid = 31337
        mock_cmd_rule = MagicMock(
            return_value="-A {}\n-A {}".format(mock_chain, hex(mock_uuid))
        )
        mock_cmd_nooutput = MagicMock(return_value="")
        mock_has = MagicMock(return_value=True)
        mock_not = MagicMock(return_value=False)
        with patch.object(iptables, "_has_option", mock_not):
            with patch.object(uuid, "getnode", MagicMock(return_value=mock_uuid)):
                with patch.dict(
                    iptables.__salt__,
                    {"cmd.run_stdout": mock_cmd_rule, "cmd.run": mock_cmd_nooutput},
                ):
                    self.assertTrue(
                        iptables.check(
                            table="filter",
                            chain=mock_chain,
                            rule=mock_rule,
                            family="ipv4",
                        )
                    )
        mock_cmd = MagicMock(return_value="")
        with patch.object(iptables, "_has_option", mock_not):
            with patch.object(uuid, "getnode", MagicMock(return_value=mock_uuid)):
                with patch.dict(
                    iptables.__salt__,
                    {
                        "cmd.run_stdout": mock_cmd_nooutput,
                        "cmd.run": mock_cmd_nooutput,
                    },
                ):
                    self.assertFalse(
                        iptables.check(
                            table="filter",
                            chain=mock_chain,
                            rule=mock_rule,
                            family="ipv4",
                        )
                    )
        with patch.object(iptables, "_has_option", mock_has):
            with patch.dict(iptables.__salt__, {"cmd.run_stderr": mock_cmd}):
                self.assertTrue(
                    iptables.check(
                        table="filter", chain="INPUT", rule=mock_rule, family="ipv4"
                    )
                )
        mock_cmd = MagicMock(return_value="-A 0x4d2")
        mock_uuid = MagicMock(return_value=1234)
        with patch.object(iptables, "_has_option", mock_has):
            with patch.object(uuid, "getnode", mock_uuid):
                with patch.dict(iptables.__salt__, {"cmd.run_stderr": mock_cmd}):
                    self.assertTrue(
                        iptables.check(
                            table="filter", chain="0x4d2", rule=mock_rule, family="ipv4"
                        )
                    )
    def test_check_chain(self):
        self.assertEqual(
            iptables.check_chain(table="filter", chain=None, family="ipv4"),
            "Error: Chain needs to be specified",
        )
        mock_cmd = MagicMock(return_value="")
        with patch.dict(iptables.__salt__, {"cmd.run_stdout": mock_cmd}):
            self.assertFalse(
                iptables.check_chain(table="filter", chain="INPUT", family="ipv4")
            )
    def test_new_chain(self):
        self.assertEqual(
            iptables.new_chain(table="filter", chain=None, family="ipv4"),
            "Error: Chain needs to be specified",
        )
        mock_cmd = MagicMock(return_value="")
        with patch.dict(
            iptables.__salt__,
            {
                "cmd.run_stdout": mock_cmd,  # called by iptables._has_option
                "cmd.run_stderr": mock_cmd,
            },
        ):
            self.assertTrue(
                iptables.new_chain(table="filter", chain="INPUT", family="ipv4")
            )
    def test_delete_chain(self):
        self.assertEqual(
            iptables.delete_chain(table="filter", chain=None, family="ipv4"),
            "Error: Chain needs to be specified",
        )
        mock_cmd = MagicMock(return_value="")
        with patch.dict(
            iptables.__salt__,
            {
                "cmd.run_stdout": mock_cmd,  # called by iptables._has_option
                "cmd.run_stderr": mock_cmd,
            },
        ):
            self.assertTrue(
                iptables.delete_chain(table="filter", chain="INPUT", family="ipv4")
            )
    def test_append(self):
        with patch.object(
            iptables, "_has_option", MagicMock(return_value=True)
        ), patch.object(iptables, "check", MagicMock(return_value=False)):
            self.assertEqual(
                iptables.append(table="filter", chain=None, rule=None, family="ipv4"),
                "Error: Chain needs to be specified",
            )
            self.assertEqual(
                iptables.append(
                    table="filter", chain="INPUT", rule=None, family="ipv4"
                ),
                "Error: Rule needs to be specified",
            )
            _rule = "m state --state RELATED,ESTABLISHED -j ACCEPT"
            mock = MagicMock(side_effect=["", "SALT"])
            with patch.dict(iptables.__salt__, {"cmd.run_stderr": mock}):
                self.assertTrue(
                    iptables.append(
                        table="filter", chain="INPUT", rule=_rule, family="ipv4"
                    )
                )
                self.assertFalse(
                    iptables.append(
                        table="filter", chain="INPUT", rule=_rule, family="ipv4"
                    )
                )
    def test_insert(self):
        with patch.object(
            iptables, "_has_option", MagicMock(return_value=True)
        ), patch.object(iptables, "check", MagicMock(return_value=False)):
            self.assertEqual(
                iptables.insert(
                    table="filter", chain=None, position=None, rule=None, family="ipv4"
                ),
                "Error: Chain needs to be specified",
            )
            pos_err = "Error: Position needs to be specified or use append (-A)"
            self.assertEqual(
                iptables.insert(
                    table="filter",
                    chain="INPUT",
                    position=None,
                    rule=None,
                    family="ipv4",
                ),
                pos_err,
            )
            self.assertEqual(
                iptables.insert(
                    table="filter", chain="INPUT", position=3, rule=None, family="ipv4"
                ),
                "Error: Rule needs to be specified",
            )
            _rule = "m state --state RELATED,ESTABLISHED -j ACCEPT"
            mock = MagicMock(return_value=True)
            with patch.dict(iptables.__salt__, {"cmd.run_stderr": mock}):
                self.assertTrue(
                    iptables.insert(
                        table="filter",
                        chain="INPUT",
                        position=3,
                        rule=_rule,
                        family="ipv4",
                    )
                )
    def test_delete(self):
        with patch.object(iptables, "_has_option", MagicMock(return_value=True)):
            _rule = "m state --state RELATED,ESTABLISHED -j ACCEPT"
            self.assertEqual(
                iptables.delete(
                    table="filter", chain=None, position=3, rule=_rule, family="ipv4"
                ),
                "Error: Only specify a position or a rule, not both",
            )
            mock = MagicMock(return_value=True)
            with patch.dict(iptables.__salt__, {"cmd.run_stderr": mock}):
                self.assertTrue(
                    iptables.delete(
                        table="filter",
                        chain="INPUT",
                        position=3,
                        rule="",
                        family="ipv4",
                    )
                )
    def test_flush(self):
        with patch.object(iptables, "_has_option", MagicMock(return_value=True)):
            mock_cmd = MagicMock(return_value=True)
            with patch.dict(iptables.__salt__, {"cmd.run_stderr": mock_cmd}):
                self.assertTrue(
                    iptables.flush(table="filter", chain="INPUT", family="ipv4")
                )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>postgres_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import base64
import datetime
import hashlib
import hmac
import io
import logging
import os
import pipes
import re
import tempfile
import salt.utils.files
import salt.utils.itertools
import salt.utils.odict
import salt.utils.path
import salt.utils.stringutils
from salt.exceptions import CommandExecutionError, SaltInvocationError
from salt.ext.saslprep import saslprep
from salt.utils.versions import LooseVersion as _LooseVersion
try:
    import csv
    HAS_CSV = True
except ImportError:
    HAS_CSV = False
try:
    from secrets import token_bytes
except ImportError:
    from os import urandom as token_bytes
log = logging.getLogger(__name__)
_DEFAULT_PASSWORDS_ENCRYPTION = "md5"
_EXTENSION_NOT_INSTALLED = "EXTENSION NOT INSTALLED"
_EXTENSION_INSTALLED = "EXTENSION INSTALLED"
_EXTENSION_TO_UPGRADE = "EXTENSION TO UPGRADE"
_EXTENSION_TO_MOVE = "EXTENSION TO MOVE"
_EXTENSION_FLAGS = (
    _EXTENSION_NOT_INSTALLED,
    _EXTENSION_INSTALLED,
    _EXTENSION_TO_UPGRADE,
    _EXTENSION_TO_MOVE,
)
_PRIVILEGES_MAP = {
    "a": "INSERT",
    "C": "CREATE",
    "D": "TRUNCATE",
    "c": "CONNECT",
    "t": "TRIGGER",
    "r": "SELECT",
    "U": "USAGE",
    "T": "TEMPORARY",
    "w": "UPDATE",
    "X": "EXECUTE",
    "x": "REFERENCES",
    "d": "DELETE",
    "*": "GRANT",
}
_PRIVILEGES_OBJECTS = frozenset(
    (
        "schema",
        "tablespace",
        "language",
        "sequence",
        "table",
        "group",
        "database",
        "function",
    )
)
_PRIVILEGE_TYPE_MAP = {
    "table": "arwdDxt",
    "tablespace": "C",
    "language": "U",
    "sequence": "rwU",
    "schema": "UC",
    "database": "CTc",
    "function": "X",
}
def __virtual__():
    utils = ["psql"]
    if not HAS_CSV:
        return False
    for util in utils:
        if not salt.utils.path.which(util):
            if not _find_pg_binary(util):
                return (False, "{} was not found".format(util))
    return True
def _find_pg_binary(util):
    pg_bin_dir = __salt__["config.option"]("postgres.bins_dir")
    util_bin = salt.utils.path.which(util)
    if not util_bin:
        if pg_bin_dir:
            return salt.utils.path.which(os.path.join(pg_bin_dir, util))
    else:
        return util_bin
def _run_psql(cmd, runas=None, password=None, host=None, port=None, user=None):
    kwargs = {
        "reset_system_locale": False,
        "clean_env": True,
    }
    if runas is None:
        if not host:
            host = __salt__["config.option"]("postgres.host")
        if not host or host.startswith("/"):
            if "FreeBSD" in __grains__["os_family"]:
                runas = "postgres"
            elif "OpenBSD" in __grains__["os_family"]:
                runas = "_postgresql"
            else:
                runas = "postgres"
    if user is None:
        user = runas
    if runas:
        kwargs["runas"] = runas
    if password is None:
        password = __salt__["config.option"]("postgres.pass")
    if password is not None:
        pgpassfile = salt.utils.files.mkstemp(text=True)
        with salt.utils.files.fopen(pgpassfile, "w") as fp_:
            fp_.write(
                salt.utils.stringutils.to_str(
                    "{}:{}:*:{}:{}".format(
                        "localhost" if not host or host.startswith("/") else host,
                        port if port else "*",
                        user if user else "*",
                        password,
                    )
                )
            )
            __salt__["file.chown"](pgpassfile, runas, "")
            kwargs["env"] = {"PGPASSFILE": pgpassfile}
    ret = __salt__["cmd.run_all"](cmd, python_shell=False, **kwargs)
    if ret.get("retcode", 0) != 0:
        log.error("Error connecting to Postgresql server")
    if password is not None and not __salt__["file.remove"](pgpassfile):
        log.warning("Remove PGPASSFILE failed")
    return ret
def _run_initdb(
    name,
    auth="password",
    user=None,
    password=None,
    encoding="UTF8",
    locale=None,
    runas=None,
    waldir=None,
    checksums=False,
):
    if runas is None:
        if "FreeBSD" in __grains__["os_family"]:
            runas = "postgres"
        elif "OpenBSD" in __grains__["os_family"]:
            runas = "_postgresql"
        else:
            runas = "postgres"
    if user is None:
        user = runas
    _INITDB_BIN = _find_pg_binary("initdb")
    if not _INITDB_BIN:
        raise CommandExecutionError("initdb executable not found.")
    cmd = [
        _INITDB_BIN,
        "--pgdata={}".format(name),
        "--username={}".format(user),
        "--auth={}".format(auth),
        "--encoding={}".format(encoding),
    ]
    if locale is not None:
        cmd.append("--locale={}".format(locale))
    if waldir is not None:
        cmd.append("-X")
        cmd.append(waldir)
    if checksums:
        cmd.append("--data-checksums")
    if password is not None:
        pgpassfile = salt.utils.files.mkstemp(text=True)
        with salt.utils.files.fopen(pgpassfile, "w") as fp_:
            fp_.write(salt.utils.stringutils.to_str("{}".format(password)))
            __salt__["file.chown"](pgpassfile, runas, "")
        cmd.extend(["--pwfile={}".format(pgpassfile)])
    kwargs = dict(runas=runas, clean_env=True)
    cmdstr = " ".join([pipes.quote(c) for c in cmd])
    ret = __salt__["cmd.run_all"](cmdstr, python_shell=False, **kwargs)
    if ret.get("retcode", 0) != 0:
        log.error("Error initilizing the postgres data directory")
    if password is not None and not __salt__["file.remove"](pgpassfile):
        log.warning("Removal of PGPASSFILE failed")
    return ret
def version(
    user=None, host=None, port=None, maintenance_db=None, password=None, runas=None
):
    query = "SELECT setting FROM pg_catalog.pg_settings WHERE name = 'server_version'"
    cmd = _psql_cmd(
        "-c",
        query,
        "-t",
        host=host,
        user=user,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
    )
    ret = _run_psql(
        cmd, runas=runas, password=password, host=host, port=port, user=user
    )
    for line in salt.utils.itertools.split(ret["stdout"], "\n"):
        return line
def _parsed_version(
    user=None, host=None, port=None, maintenance_db=None, password=None, runas=None
):
    psql_version = version(
        user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )
    if psql_version:
        return _LooseVersion(psql_version)
    else:
        log.warning(
            "Attempt to parse version of Postgres server failed. "
            "Is the server responding?"
        )
        return None
def _connection_defaults(user=None, host=None, port=None, maintenance_db=None):
    if not user:
        user = __salt__["config.option"]("postgres.user")
    if not host:
        host = __salt__["config.option"]("postgres.host")
    if not port:
        port = __salt__["config.option"]("postgres.port")
    if not maintenance_db:
        maintenance_db = __salt__["config.option"]("postgres.maintenance_db")
    return (user, host, port, maintenance_db)
def _psql_cmd(*args, **kwargs):
    (user, host, port, maintenance_db) = _connection_defaults(
        kwargs.get("user"),
        kwargs.get("host"),
        kwargs.get("port"),
        kwargs.get("maintenance_db"),
    )
    _PSQL_BIN = _find_pg_binary("psql")
    cmd = [
        _PSQL_BIN,
        "--no-align",
        "--no-readline",
        "--no-psqlrc",
        "--no-password",
    ]  # Never prompt, handled in _run_psql.
    if user:
        cmd += ["--username", user]
    if host:
        cmd += ["--host", host]
    if port:
        cmd += ["--port", str(port)]
    if not maintenance_db:
        maintenance_db = "postgres"
    cmd.extend(["--dbname", maintenance_db])
    cmd.extend(args)
    return cmd
def _psql_prepare_and_run(
    cmd, host=None, port=None, maintenance_db=None, password=None, runas=None, user=None
):
    rcmd = _psql_cmd(
        host=host, user=user, port=port, maintenance_db=maintenance_db, *cmd
    )
    cmdret = _run_psql(
        rcmd, runas=runas, password=password, host=host, port=port, user=user
    )
    return cmdret
def psql_query(
    query,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
    write=False,
):
    ret = []
    csv_query = "COPY ({}) TO STDOUT WITH CSV HEADER".format(query.strip().rstrip(";"))
    if write:
        csv_query = "START TRANSACTION READ WRITE; {}; COMMIT TRANSACTION;".format(
            csv_query
        )
    cmdret = _psql_prepare_and_run(
        ["-v", "datestyle=ISO,MDY", "-c", csv_query],
        runas=runas,
        host=host,
        user=user,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
    )
    if cmdret["retcode"] &gt; 0:
        return ret
    csv_file = io.StringIO(cmdret["stdout"])
    header = {}
    for row in csv.reader(
        csv_file,
        delimiter=salt.utils.stringutils.to_str(","),
        quotechar=salt.utils.stringutils.to_str('"'),
    ):
        if not row:
            continue
        if not header:
            header = row
            continue
        ret.append(dict(zip(header, row)))
    if write:
        ret = ret[0:-1]
    return ret
def db_list(
    user=None, host=None, port=None, maintenance_db=None, password=None, runas=None
):
    ret = {}
    query = (
        'SELECT datname as "Name", pga.rolname as "Owner", '
        'pg_encoding_to_char(encoding) as "Encoding", '
        'datcollate as "Collate", datctype as "Ctype", '
        'datacl as "Access privileges", spcname as "Tablespace" '
        "FROM pg_database pgd, pg_roles pga, pg_tablespace pgts "
        "WHERE pga.oid = pgd.datdba AND pgts.oid = pgd.dattablespace"
    )
    rows = psql_query(
        query,
        runas=runas,
        host=host,
        user=user,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
    )
    for row in rows:
        ret[row["Name"]] = row
        ret[row["Name"]].pop("Name")
    return ret
def db_exists(
    name,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
):
    databases = db_list(
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )
    return name in databases
def _quote_ddl_value(value, quote="'"):
    if value is None:
        return None
    if quote in value:  # detect trivial sqli
        raise SaltInvocationError(
            "Unsupported character {} in value: {}".format(quote, value)
        )
    return "{quote}{value}{quote}".format(quote=quote, value=value)
def db_create(
    name,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    tablespace=None,
    encoding=None,
    lc_collate=None,
    lc_ctype=None,
    owner=None,
    template=None,
    runas=None,
):
<a name="0"></a>    query = 'CREATE DATABASE "{}"'.format(name)
    with_args = salt.utils.odict<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.OrderedDict(
        [
            ("TABLESPACE", _quote_ddl_value(tablespace, '"')),
            ("OWNER", _quote_ddl_value(owner, '"')),
            ("TEMPLATE", template),
            ("ENCODING", _quote_ddl_value(encoding)),
            ("LC_COLLATE", _quote_ddl_value(lc_collate)),
            ("LC_CTYPE"</b></font>, _quote_ddl_value(lc_ctype)),
        ]
    )
    with_chunks = []
    for key, value in with_args.items():
        if value is not None:
            with_chunks += [key, "=", value]
    if with_chunks:
        with_chunks.insert(0, " WITH")
        query += " ".join(with_chunks)
    ret = _psql_prepare_and_run(
        ["-c", query],
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )
    return ret["retcode"] == 0
def db_alter(
    name,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    tablespace=None,
    owner=None,
    owner_recurse=False,
    runas=None,
):
    if not any((tablespace, owner)):
        return True  # Nothing todo?
    if owner and owner_recurse:
        ret = owner_to(
            name, owner, user=user, host=host, port=port, password=password, runas=runas
        )
    else:
        queries = []
        if owner:
            queries.append('ALTER DATABASE "{}" OWNER TO "{}"'.format(name, owner))
        if tablespace:
            queries.append(
                'ALTER DATABASE "{}" SET TABLESPACE "{}"'.format(name, tablespace)
            )
        for query in queries:
            ret = _psql_prepare_and_run(
                ["-c", query],
                user=user,
                host=host,
                port=port,
                maintenance_db=maintenance_db,
                password=password,
                runas=runas,
            )
    if ret["retcode"] != 0:
        return False
    return True
def db_remove(
    name,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
):
    for query in [
        'REVOKE CONNECT ON DATABASE "{db}" FROM public;'.format(db=name),
        "SELECT pid, pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname ="
        " '{db}' AND pid &lt;&gt; pg_backend_pid();".format(db=name),
        'DROP DATABASE "{db}";'.format(db=name),
    ]:
        ret = _psql_prepare_and_run(
            ["-c", query],
            user=user,
            host=host,
            port=port,
            runas=runas,
            maintenance_db=maintenance_db,
            password=password,
        )
        if ret["retcode"] != 0:
            raise Exception("Failed: ret={}".format(ret))
    return True
def tablespace_list(
    user=None, host=None, port=None, maintenance_db=None, password=None, runas=None
):
    ret = {}
    query = (
        'SELECT spcname as "Name", pga.rolname as "Owner", spcacl as "ACL", '
        'spcoptions as "Opts", pg_tablespace_location(pgts.oid) as "Location" '
        "FROM pg_tablespace pgts, pg_roles pga WHERE pga.oid = pgts.spcowner"
    )
    rows = __salt__["postgres.psql_query"](
        query,
        runas=runas,
        host=host,
        user=user,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
    )
    for row in rows:
        ret[row["Name"]] = row
        ret[row["Name"]].pop("Name")
    return ret
def tablespace_exists(
    name,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
):
    tablespaces = tablespace_list(
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )
    return name in tablespaces
def tablespace_create(
    name,
    location,
    options=None,
    owner=None,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
):
    owner_query = ""
    options_query = ""
    if owner:
        owner_query = 'OWNER "{}"'.format(owner)
    if options:
        optionstext = ["{} = {}".format(k, v) for k, v in options.items()]
        options_query = "WITH ( {} )".format(", ".join(optionstext))
    query = "CREATE TABLESPACE \"{}\" {} LOCATION '{}' {}".format(
        name, owner_query, location, options_query
    )
    ret = _psql_prepare_and_run(
        ["-c", query],
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )
    return ret["retcode"] == 0
def tablespace_alter(
    name,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    new_name=None,
    new_owner=None,
    set_option=None,
    reset_option=None,
    runas=None,
):
    if not any([new_name, new_owner, set_option, reset_option]):
        return True  # Nothing todo?
    queries = []
    if new_name:
        queries.append('ALTER TABLESPACE "{}" RENAME TO "{}"'.format(name, new_name))
    if new_owner:
        queries.append('ALTER TABLESPACE "{}" OWNER TO "{}"'.format(name, new_owner))
    if set_option:
        queries.append(
            'ALTER TABLESPACE "{}" SET ({} = {})'.format(
                name, *(next(iter(set_option.items())))
            )
        )
    if reset_option:
        queries.append('ALTER TABLESPACE "{}" RESET ({})'.format(name, reset_option))
    for query in queries:
        ret = _psql_prepare_and_run(
            ["-c", query],
            user=user,
            host=host,
            port=port,
            maintenance_db=maintenance_db,
            password=password,
            runas=runas,
        )
        if ret["retcode"] != 0:
            return False
    return True
def tablespace_remove(
    name,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
):
    query = 'DROP TABLESPACE "{}"'.format(name)
    ret = _psql_prepare_and_run(
        ["-c", query],
        user=user,
        host=host,
        port=port,
        runas=runas,
        maintenance_db=maintenance_db,
        password=password,
    )
    return ret["retcode"] == 0
def user_list(
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
    return_password=False,
):
    ret = {}
    ver = _parsed_version(
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )
    if ver:
        if ver &gt;= _LooseVersion("9.1"):
            replication_column = "pg_roles.rolreplication"
        else:
            replication_column = "NULL"
        if ver &gt;= _LooseVersion("9.5"):
            rolcatupdate_column = "NULL"
        else:
            rolcatupdate_column = "pg_roles.rolcatupdate"
    else:
        log.error("Could not retrieve Postgres version. Is Postgresql server running?")
        return False
    _x = lambda s: s if return_password else ""
    query = "".join(
        [
            'SELECT pg_roles.rolname as "name",pg_roles.rolsuper as "superuser",'
            ' pg_roles.rolinherit as "inherits privileges", pg_roles.rolcreaterole as'
            ' "can create roles", pg_roles.rolcreatedb as "can create databases", {0}'
            ' as "can update system catalogs", pg_roles.rolcanlogin as "can login", {1}'
            ' as "replication", pg_roles.rolconnlimit as "connections", (SELECT'
            " array_agg(pg_roles2.rolname)    FROM pg_catalog.pg_auth_members    JOIN"
            " pg_catalog.pg_roles pg_roles2 ON (pg_auth_members.roleid = pg_roles2.oid)"
            "    WHERE pg_auth_members.member = pg_roles.oid) as"
            ' "groups",pg_roles.rolvaliduntil::timestamp(0) as "expiry time",'
            ' pg_roles.rolconfig  as "defaults variables" ',
            _x(', COALESCE(pg_shadow.passwd, pg_authid.rolpassword) as "password" '),
            "FROM pg_roles ",
            _x("LEFT JOIN pg_authid ON pg_roles.oid = pg_authid.oid "),
            _x("LEFT JOIN pg_shadow ON pg_roles.oid = pg_shadow.usesysid"),
        ]
    ).format(rolcatupdate_column, replication_column)
    rows = psql_query(
        query,
        runas=runas,
        host=host,
        user=user,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
    )
    def get_bool(rowdict, key):
        if rowdict[key] == "t":
            return True
        elif rowdict[key] == "f":
            return False
        else:
            return None
    for row in rows:
        retrow = {}
        for key in (
            "superuser",
            "inherits privileges",
            "can create roles",
            "can create databases",
            "can update system catalogs",
            "can login",
            "replication",
            "connections",
        ):
            retrow[key] = get_bool(row, key)
        for date_key in ("expiry time",):
            try:
                retrow[date_key] = datetime.datetime.strptime(
                    row[date_key], "%Y-%m-%d %H:%M:%S"
                )
            except ValueError:
                retrow[date_key] = None
        retrow["defaults variables"] = row["defaults variables"]
        if return_password:
            retrow["password"] = row["password"]
        retrow["groups"] = list(csv.reader([row["groups"].strip("{}")]))[0]
        ret[row["name"]] = retrow
    return ret
def role_get(
    name,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
    return_password=False,
):
    all_users = user_list(
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
        return_password=return_password,
    )
    try:
        return all_users.get(name, None)
    except AttributeError:
        log.error("Could not retrieve Postgres role. Is Postgres running?")
        return None
def user_exists(
    name,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
):
    return bool(
        role_get(
            name,
            user=user,
            host=host,
            port=port,
            maintenance_db=maintenance_db,
            password=password,
            runas=runas,
            return_password=False,
        )
    )
def _add_role_flag(string, test, flag, cond=None, prefix="NO", addtxt="", skip=False):
    if not skip:
        if cond is None:
            cond = test
        if test is not None:
            if cond:
                string = "{} {}".format(string, flag)
            else:
                string = "{0} {2}{1}".format(string, flag, prefix)
        if addtxt:
            string = "{} {}".format(string, addtxt)
    return string
def _maybe_encrypt_password(role, password, encrypted=_DEFAULT_PASSWORDS_ENCRYPTION):
    if password is not None:
        password = str(password)
    else:
        return None
    if encrypted is True:
        encrypted = "md5"
    if encrypted not in (False, "md5", "scram-sha-256"):
        raise ValueError("Unknown password algorithm: " + str(encrypted))
    if encrypted == "scram-sha-256" and not password.startswith("SCRAM-SHA-256"):
        password = _scram_sha_256(password)
    elif encrypted == "md5" and not password.startswith("md5"):
        log.warning("The md5 password algorithm was deprecated in PostgreSQL 10")
        password = _md5_password(role, password)
    elif encrypted is False:
        log.warning("Unencrypted passwords were removed in PostgreSQL 10")
    return password
def _verify_password(role, password, verifier, method):
    if method == "md5" or method is True:
        if password.startswith("md5"):
            expected = password
        else:
            expected = _md5_password(role, password)
    elif method == "scram-sha-256":
        if password.startswith("SCRAM-SHA-256"):
            expected = password
        else:
            match = re.match(r"^SCRAM-SHA-256\$(\d+):([^\$]+?)\$", verifier)
            if match:
                iterations = int(match.group(1))
                salt_bytes = base64.b64decode(match.group(2))
                expected = _scram_sha_256(
                    password, salt_bytes=salt_bytes, iterations=iterations
                )
            else:
                expected = object()
    elif method is False:
        expected = password
    else:
        expected = object()
    return verifier == expected
def _md5_password(role, password):
    return "md5{}".format(
        hashlib.md5(
            salt.utils.stringutils.to_bytes("{}{}".format(password, role))
        ).hexdigest()
    )
def _scram_sha_256(password, salt_bytes=None, iterations=4096):
    if salt_bytes is None:
        salt_bytes = token_bytes(16)
    password = salt.utils.stringutils.to_bytes(saslprep(password))
    salted_password = hashlib.pbkdf2_hmac("sha256", password, salt_bytes, iterations)
    stored_key = hmac.new(salted_password, b"Client Key", "sha256").digest()
    stored_key = hashlib.sha256(stored_key).digest()
    server_key = hmac.new(salted_password, b"Server Key", "sha256").digest()
    return "SCRAM-SHA-256${}:{}${}:{}".format(
        iterations,
        base64.b64encode(salt_bytes).decode("ascii"),
        base64.b64encode(stored_key).decode("ascii"),
        base64.b64encode(server_key).decode("ascii"),
    )
def _role_cmd_args(
    name,
    sub_cmd="",
    typ_="role",
    encrypted=None,
    login=None,
    connlimit=None,
    inherit=None,
    createdb=None,
    createroles=None,
    superuser=None,
    groups=None,
    replication=None,
    rolepassword=None,
    valid_until=None,
    db_role=None,
):
    if inherit is None:
        if typ_ in ["user", "group"]:
            inherit = True
    if login is None:
        if typ_ == "user":
            login = True
        if typ_ == "group":
            login = False
    if encrypted is None:
        encrypted = _DEFAULT_PASSWORDS_ENCRYPTION
    skip_passwd = False
    escaped_password = ""
    escaped_valid_until = ""
    if not (
        rolepassword is not None
        and (isinstance(rolepassword, str) and bool(rolepassword))
        or (isinstance(rolepassword, bool))
    ):
        skip_passwd = True
    if isinstance(rolepassword, str) and bool(rolepassword):
        escaped_password = "'{}'".format(
            _maybe_encrypt_password(
                name, rolepassword.replace("'", "''"), encrypted=encrypted
            )
        )
    if isinstance(valid_until, str) and bool(valid_until):
        escaped_valid_until = "'{}'".format(
            valid_until.replace("'", "''"),
        )
    skip_superuser = False
    if bool(db_role) and bool(superuser) == bool(db_role["superuser"]):
        skip_superuser = True
    flags = (
        {"flag": "INHERIT", "test": inherit},
        {"flag": "CREATEDB", "test": createdb},
        {"flag": "CREATEROLE", "test": createroles},
        {"flag": "SUPERUSER", "test": superuser, "skip": skip_superuser},
        {"flag": "REPLICATION", "test": replication},
        {"flag": "LOGIN", "test": login},
        {
            "flag": "CONNECTION LIMIT",
            "test": bool(connlimit),
            "addtxt": str(connlimit),
            "skip": connlimit is None,
        },
        {
            "flag": "ENCRYPTED",
            "test": (encrypted is not None and bool(rolepassword)),
            "skip": skip_passwd or isinstance(rolepassword, bool),
            "cond": bool(encrypted),
            "prefix": "UN",
        },
        {
            "flag": "PASSWORD",
            "test": bool(rolepassword),
            "skip": skip_passwd,
            "addtxt": escaped_password,
        },
        {
            "flag": "VALID UNTIL",
            "test": bool(valid_until),
            "skip": valid_until is None,
            "addtxt": escaped_valid_until,
        },
    )
    for data in flags:
        sub_cmd = _add_role_flag(sub_cmd, **data)
    if sub_cmd.endswith("WITH"):
        sub_cmd = sub_cmd.replace(" WITH", "")
    if groups:
        if isinstance(groups, list):
            groups = ",".join(groups)
        for group in groups.split(","):
            sub_cmd = '{}; GRANT "{}" TO "{}"'.format(sub_cmd, group, name)
    return sub_cmd
def _role_create(
    name,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    createdb=None,
    createroles=None,
    encrypted=None,
    superuser=None,
    login=None,
    connlimit=None,
    inherit=None,
    replication=None,
    rolepassword=None,
    valid_until=None,
    typ_="role",
    groups=None,
    runas=None,
):
    if user_exists(
        name, user, host, port, maintenance_db, password=password, runas=runas
    ):
        log.info("%s '%s' already exists", typ_.capitalize(), name)
        return False
    sub_cmd = 'CREATE ROLE "{}" WITH'.format(name)
    sub_cmd = "{} {}".format(
        sub_cmd,
        _role_cmd_args(
            name,
            typ_=typ_,
            encrypted=encrypted,
            login=login,
            connlimit=connlimit,
            inherit=inherit,
            createdb=createdb,
            createroles=createroles,
            superuser=superuser,
            groups=groups,
            replication=replication,
            rolepassword=rolepassword,
            valid_until=valid_until,
        ),
    )
    ret = _psql_prepare_and_run(
        ["-c", sub_cmd],
        runas=runas,
        host=host,
        user=user,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
    )
    return ret["retcode"] == 0
def user_create(
    username,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    createdb=None,
    createroles=None,
    inherit=None,
    login=None,
    connlimit=None,
    encrypted=None,
    superuser=None,
    replication=None,
    rolepassword=None,
    valid_until=None,
    groups=None,
    runas=None,
):
    return _role_create(
        username,
        typ_="user",
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        createdb=createdb,
        createroles=createroles,
        inherit=inherit,
        login=login,
        connlimit=connlimit,
        encrypted=encrypted,
        superuser=superuser,
        replication=replication,
        rolepassword=rolepassword,
        valid_until=valid_until,
        groups=groups,
        runas=runas,
    )
def _role_update(
    name,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    createdb=None,
    typ_="role",
    createroles=None,
    inherit=None,
    login=None,
    connlimit=None,
    encrypted=None,
    superuser=None,
    replication=None,
    rolepassword=None,
    valid_until=None,
    groups=None,
    runas=None,
):
    role = role_get(
        name,
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
        return_password=False,
    )
    if not bool(role):
        log.info("%s '%s' could not be found", typ_.capitalize(), name)
        return False
    sub_cmd = 'ALTER ROLE "{}" WITH'.format(name)
    sub_cmd = "{} {}".format(
        sub_cmd,
        _role_cmd_args(
            name,
            encrypted=encrypted,
            login=login,
            connlimit=connlimit,
            inherit=inherit,
            createdb=createdb,
            createroles=createroles,
            superuser=superuser,
            groups=groups,
            replication=replication,
            rolepassword=rolepassword,
            valid_until=valid_until,
            db_role=role,
        ),
    )
    ret = _psql_prepare_and_run(
        ["-c", sub_cmd],
        runas=runas,
        host=host,
        user=user,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
    )
    return ret["retcode"] == 0
def user_update(
    username,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    createdb=None,
    createroles=None,
    encrypted=None,
    superuser=None,
    inherit=None,
    login=None,
    connlimit=None,
    replication=None,
    rolepassword=None,
    valid_until=None,
    groups=None,
    runas=None,
):
    return _role_update(
        username,
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        typ_="user",
        inherit=inherit,
        login=login,
        connlimit=connlimit,
        createdb=createdb,
        createroles=createroles,
        encrypted=encrypted,
        superuser=superuser,
        replication=replication,
        rolepassword=rolepassword,
        valid_until=valid_until,
        groups=groups,
        runas=runas,
    )
def _role_remove(
    name,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
):
    if not user_exists(
        name, user, host, port, maintenance_db, password=password, runas=runas
    ):
        log.info("User '%s' does not exist", name)
        return False
    sub_cmd = 'DROP ROLE "{}"'.format(name)
    _psql_prepare_and_run(
        ["-c", sub_cmd],
        runas=runas,
        host=host,
        user=user,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
    )
    if not user_exists(
        name, user, host, port, maintenance_db, password=password, runas=runas
    ):
        return True
    else:
        log.info("Failed to delete user '%s'.", name)
        return False
def available_extensions(
    user=None, host=None, port=None, maintenance_db=None, password=None, runas=None
):
    exts = []
    query = "select * from pg_available_extensions();"
    ret = psql_query(
        query,
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )
    exts = {}
    for row in ret:
        if "default_version" in row and "name" in row:
            exts[row["name"]] = row
    return exts
def installed_extensions(
    user=None, host=None, port=None, maintenance_db=None, password=None, runas=None
):
    exts = []
    query = (
        "select a.*, b.nspname as schema_name "
        "from pg_extension a,  pg_namespace b where a.extnamespace = b.oid;"
    )
    ret = psql_query(
        query,
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )
    exts = {}
    for row in ret:
        if "extversion" in row and "extname" in row:
            exts[row["extname"]] = row
    return exts
def get_available_extension(
    name,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
):
    return available_extensions(
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    ).get(name, None)
def get_installed_extension(
    name,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
):
    return installed_extensions(
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    ).get(name, None)
def is_available_extension(
    name,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
):
    exts = available_extensions(
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )
    if name.lower() in [a.lower() for a in exts]:
        return True
    return False
def _pg_is_older_ext_ver(a, b):
    return _LooseVersion(a) &lt; _LooseVersion(b)
def is_installed_extension(
    name,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
):
    installed_ext = get_installed_extension(
        name,
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )
    return bool(installed_ext)
def create_metadata(
    name,
    ext_version=None,
    schema=None,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
):
    installed_ext = get_installed_extension(
        name,
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )
    ret = [_EXTENSION_NOT_INSTALLED]
    if installed_ext:
        ret = [_EXTENSION_INSTALLED]
        if ext_version is not None and _pg_is_older_ext_ver(
            installed_ext.get("extversion", ext_version), ext_version
        ):
            ret.append(_EXTENSION_TO_UPGRADE)
        if (
            schema is not None
            and installed_ext.get("extrelocatable", "f") == "t"
            and installed_ext.get("schema_name", schema) != schema
        ):
            ret.append(_EXTENSION_TO_MOVE)
    return ret
def drop_extension(
    name,
    if_exists=None,
    restrict=None,
    cascade=None,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
):
    if cascade is None:
        cascade = True
    if if_exists is None:
        if_exists = False
    if restrict is None:
        restrict = False
    args = ["DROP EXTENSION"]
    if if_exists:
        args.append("IF EXISTS")
    args.append(name)
    if cascade:
        args.append("CASCADE")
    if restrict:
        args.append("RESTRICT")
    args.append(";")
    cmd = " ".join(args)
    if is_installed_extension(
        name,
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    ):
        _psql_prepare_and_run(
            ["-c", cmd],
            runas=runas,
            host=host,
            user=user,
            port=port,
            maintenance_db=maintenance_db,
            password=password,
        )
    ret = not is_installed_extension(
        name,
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )
    if not ret:
        log.info("Failed to drop ext: %s", name)
    return ret
def create_extension(
    name,
    if_not_exists=None,
    schema=None,
    ext_version=None,
    from_version=None,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
):
    if if_not_exists is None:
        if_not_exists = True
    mtdata = create_metadata(
        name,
        ext_version=ext_version,
        schema=schema,
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )
    installed = _EXTENSION_NOT_INSTALLED not in mtdata
    installable = is_available_extension(
        name,
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )
    if installable:
        if not installed:
            args = ["CREATE EXTENSION"]
            if if_not_exists:
                args.append("IF NOT EXISTS")
            args.append('"{}"'.format(name))
            sargs = []
            if schema:
                sargs.append('SCHEMA "{}"'.format(schema))
            if ext_version:
                sargs.append("VERSION {}".format(ext_version))
            if from_version:
                sargs.append("FROM {}".format(from_version))
            if sargs:
                args.append("WITH")
                args.extend(sargs)
            args.append(";")
            cmd = " ".join(args).strip()
        else:
            args = []
            if schema and _EXTENSION_TO_MOVE in mtdata:
                args.append(
                    'ALTER EXTENSION "{}" SET SCHEMA "{}";'.format(name, schema)
                )
            if ext_version and _EXTENSION_TO_UPGRADE in mtdata:
                args.append(
                    'ALTER EXTENSION "{}" UPDATE TO {};'.format(name, ext_version)
                )
            cmd = " ".join(args).strip()
        if cmd:
            _psql_prepare_and_run(
                ["-c", cmd],
                runas=runas,
                host=host,
                user=user,
                port=port,
                maintenance_db=maintenance_db,
                password=password,
            )
    mtdata = create_metadata(
        name,
        ext_version=ext_version,
        schema=schema,
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )
    ret = True
    for i in _EXTENSION_FLAGS:
        if (i in mtdata) and (i != _EXTENSION_INSTALLED):
            ret = False
    if not ret:
        log.info("Failed to create ext: %s", name)
    return ret
def user_remove(
    username,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
):
    return _role_remove(
        username,
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )
def group_create(
    groupname,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    createdb=None,
    createroles=None,
    encrypted=None,
    login=None,
    inherit=None,
    superuser=None,
    replication=None,
    rolepassword=None,
    groups=None,
    runas=None,
):
    return _role_create(
        groupname,
        user=user,
        typ_="group",
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        createdb=createdb,
        createroles=createroles,
        encrypted=encrypted,
        login=login,
        inherit=inherit,
        superuser=superuser,
        replication=replication,
        rolepassword=rolepassword,
        groups=groups,
        runas=runas,
    )
def group_update(
    groupname,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    createdb=None,
    createroles=None,
    encrypted=None,
    inherit=None,
    login=None,
    superuser=None,
    replication=None,
    rolepassword=None,
    groups=None,
    runas=None,
):
    return _role_update(
        groupname,
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        createdb=createdb,
        typ_="group",
        createroles=createroles,
        encrypted=encrypted,
        login=login,
        inherit=inherit,
        superuser=superuser,
        replication=replication,
        rolepassword=rolepassword,
        groups=groups,
        runas=runas,
    )
def group_remove(
    groupname,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
):
    return _role_remove(
        groupname,
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )
def owner_to(
    dbname, ownername, user=None, host=None, port=None, password=None, runas=None
):
    sqlfile = tempfile.NamedTemporaryFile()
    sqlfile.write("begin;\n")
    sqlfile.write('alter database "{}" owner to "{}";\n'.format(dbname, ownername))
    queries = (
        (
            "alter schema {n} owner to {owner};",
            "select quote_ident(schema_name) as n from information_schema.schemata;",
        ),
        (
            "alter table {n} owner to {owner};",
            "select quote_ident(table_schema)||'.'||quote_ident(table_name) as "
            "n from information_schema.tables where table_schema not in "
            "('pg_catalog', 'information_schema');",
        ),
        (
            "alter function {n} owner to {owner};",
            "select p.oid::regprocedure::text as n from pg_catalog.pg_proc p "
            "join pg_catalog.pg_namespace ns on p.pronamespace=ns.oid where "
            "ns.nspname not in ('pg_catalog', 'information_schema') "
            " and not p.proisagg;",
        ),
        (
            "alter aggregate {n} owner to {owner};",
            "select p.oid::regprocedure::text as n from pg_catalog.pg_proc p "
            "join pg_catalog.pg_namespace ns on p.pronamespace=ns.oid where "
            "ns.nspname not in ('pg_catalog', 'information_schema') "
            "and p.proisagg;",
        ),
        (
            "alter sequence {n} owner to {owner};",
            "select quote_ident(sequence_schema)||'.'||"
            "quote_ident(sequence_name) as n from information_schema.sequences;",
        ),
    )
    for fmt, query in queries:
        ret = psql_query(
            query,
            user=user,
            host=host,
            port=port,
            maintenance_db=dbname,
            password=password,
            runas=runas,
        )
        for row in ret:
            sqlfile.write(fmt.format(owner=ownername, n=row["n"]) + "\n")
    sqlfile.write("commit;\n")
    sqlfile.flush()
    os.chmod(sqlfile.name, 0o644)  # ensure psql can read the file
    cmdret = _psql_prepare_and_run(
        ["-f", sqlfile.name],
        user=user,
        runas=runas,
        host=host,
        port=port,
        password=password,
        maintenance_db=dbname,
    )
    return cmdret
def schema_create(
    dbname,
    name,
    owner=None,
    user=None,
    db_user=None,
    db_password=None,
    db_host=None,
    db_port=None,
):
    if schema_exists(
        dbname,
        name,
        user=user,
        db_user=db_user,
        db_password=db_password,
        db_host=db_host,
        db_port=db_port,
    ):
        log.info("'%s' already exists in '%s'", name, dbname)
        return False
    sub_cmd = 'CREATE SCHEMA "{}"'.format(name)
    if owner is not None:
        sub_cmd = '{} AUTHORIZATION "{}"'.format(sub_cmd, owner)
    ret = _psql_prepare_and_run(
        ["-c", sub_cmd],
        user=db_user,
        password=db_password,
        port=db_port,
        host=db_host,
        maintenance_db=dbname,
        runas=user,
    )
    return ret["retcode"] == 0
def schema_remove(
    dbname, name, user=None, db_user=None, db_password=None, db_host=None, db_port=None
):
    if not schema_exists(
        dbname,
        name,
        user=None,
        db_user=db_user,
        db_password=db_password,
        db_host=db_host,
        db_port=db_port,
    ):
        log.info("Schema '%s' does not exist in '%s'", name, dbname)
        return False
    sub_cmd = 'DROP SCHEMA "{}"'.format(name)
    _psql_prepare_and_run(
        ["-c", sub_cmd],
        runas=user,
        maintenance_db=dbname,
        host=db_host,
        user=db_user,
        port=db_port,
        password=db_password,
    )
    if not schema_exists(
        dbname,
        name,
        user,
        db_user=db_user,
        db_password=db_password,
        db_host=db_host,
        db_port=db_port,
    ):
        return True
    else:
        log.info("Failed to delete schema '%s'.", name)
        return False
def schema_exists(
    dbname, name, user=None, db_user=None, db_password=None, db_host=None, db_port=None
):
    return bool(
        schema_get(
            dbname,
            name,
            user=user,
            db_user=db_user,
            db_host=db_host,
            db_port=db_port,
            db_password=db_password,
        )
    )
def schema_get(
    dbname, name, user=None, db_user=None, db_password=None, db_host=None, db_port=None
):
    all_schemas = schema_list(
        dbname,
        user=user,
        db_user=db_user,
        db_host=db_host,
        db_port=db_port,
        db_password=db_password,
    )
    try:
        return all_schemas.get(name, None)
    except AttributeError:
        log.error("Could not retrieve Postgres schema. Is Postgres running?")
        return False
def schema_list(
    dbname, user=None, db_user=None, db_password=None, db_host=None, db_port=None
):
    ret = {}
    query = "".join(
        [
            "SELECT "
            'pg_namespace.nspname as "name",'
            'pg_namespace.nspacl as "acl", '
            'pg_roles.rolname as "owner" '
            "FROM pg_namespace "
            "LEFT JOIN pg_roles ON pg_roles.oid = pg_namespace.nspowner "
        ]
    )
    rows = psql_query(
        query,
        runas=user,
        host=db_host,
        user=db_user,
        port=db_port,
        maintenance_db=dbname,
        password=db_password,
    )
    for row in rows:
        retrow = {}
        for key in ("owner", "acl"):
            retrow[key] = row[key]
        ret[row["name"]] = retrow
    return ret
def language_list(
    maintenance_db, user=None, host=None, port=None, password=None, runas=None
):
    ret = {}
    query = 'SELECT lanname AS "Name" FROM pg_language'
    rows = psql_query(
        query,
        runas=runas,
        host=host,
        user=user,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
    )
    for row in rows:
        ret[row["Name"]] = row["Name"]
    return ret
def language_exists(
    name, maintenance_db, user=None, host=None, port=None, password=None, runas=None
):
    languages = language_list(
        maintenance_db, user=user, host=host, port=port, password=password, runas=runas
    )
    return name in languages
def language_create(
    name, maintenance_db, user=None, host=None, port=None, password=None, runas=None
):
    if language_exists(name, maintenance_db):
        log.info("Language %s already exists in %s", name, maintenance_db)
        return False
    query = "CREATE LANGUAGE {}".format(name)
    ret = _psql_prepare_and_run(
        ["-c", query],
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )
    return ret["retcode"] == 0
def language_remove(
    name, maintenance_db, user=None, host=None, port=None, password=None, runas=None
):
    if not language_exists(name, maintenance_db):
        log.info("Language %s does not exist in %s", name, maintenance_db)
        return False
    query = "DROP LANGUAGE {}".format(name)
    ret = _psql_prepare_and_run(
        ["-c", query],
        user=user,
        host=host,
        port=port,
        runas=runas,
        maintenance_db=maintenance_db,
        password=password,
    )
    return ret["retcode"] == 0
def _make_privileges_list_query(name, object_type, prepend):
    if object_type == "table":
        query = (
            " ".join(
                [
                    "SELECT relacl AS name",
                    "FROM pg_catalog.pg_class c",
                    "JOIN pg_catalog.pg_namespace n",
                    "ON n.oid = c.relnamespace",
                    "WHERE nspname = '{0}'",
                    "AND relname = '{1}'",
                    "AND relkind = 'r'",
                    "ORDER BY relname",
                ]
            )
        ).format(prepend, name)
    elif object_type == "sequence":
        query = (
            " ".join(
                [
                    "SELECT relacl AS name",
                    "FROM pg_catalog.pg_class c",
                    "JOIN pg_catalog.pg_namespace n",
                    "ON n.oid = c.relnamespace",
                    "WHERE nspname = '{0}'",
                    "AND relname = '{1}'",
                    "AND relkind = 'S'",
                    "ORDER BY relname",
                ]
            )
        ).format(prepend, name)
    elif object_type == "schema":
        query = (
            " ".join(
                [
                    "SELECT nspacl AS name",
                    "FROM pg_catalog.pg_namespace",
                    "WHERE nspname = '{0}'",
                    "ORDER BY nspname",
                ]
            )
        ).format(name)
    elif object_type == "function":
        query = (
            " ".join(
                [
                    "SELECT proacl AS name",
                    "FROM pg_catalog.pg_proc p",
                    "JOIN pg_catalog.pg_namespace n",
                    "ON n.oid = p.pronamespace",
                    "WHERE nspname = '{0}'",
                    "AND p.oid::regprocedure::text = '{1}'",
                    "ORDER BY proname, proargtypes",
                ]
            )
        ).format(prepend, name)
    elif object_type == "tablespace":
        query = (
            " ".join(
                [
                    "SELECT spcacl AS name",
                    "FROM pg_catalog.pg_tablespace",
                    "WHERE spcname = '{0}'",
                    "ORDER BY spcname",
                ]
            )
        ).format(name)
    elif object_type == "language":
        query = (
            " ".join(
                [
                    "SELECT lanacl AS name",
                    "FROM pg_catalog.pg_language",
                    "WHERE lanname = '{0}'",
                    "ORDER BY lanname",
                ]
            )
        ).format(name)
    elif object_type == "database":
        query = (
            " ".join(
                [
                    "SELECT datacl AS name",
                    "FROM pg_catalog.pg_database",
                    "WHERE datname = '{0}'",
                    "ORDER BY datname",
                ]
            )
        ).format(name)
    elif object_type == "group":
        query = (
            " ".join(
                [
                    "SELECT rolname, admin_option",
                    "FROM pg_catalog.pg_auth_members m",
                    "JOIN pg_catalog.pg_roles r",
                    "ON m.member=r.oid",
                    "WHERE m.roleid IN",
                    "(SELECT oid",
                    "FROM pg_catalog.pg_roles",
                    "WHERE rolname='{0}')",
                    "ORDER BY rolname",
                ]
            )
        ).format(name)
    return query
def _get_object_owner(
    name,
    object_type,
    prepend="public",
    maintenance_db=None,
    user=None,
    host=None,
    port=None,
    password=None,
    runas=None,
):
    if object_type == "table":
        query = (
            " ".join(
                [
                    "SELECT tableowner AS name",
                    "FROM pg_tables",
                    "WHERE schemaname = '{0}'",
                    "AND tablename = '{1}'",
                ]
            )
        ).format(prepend, name)
    elif object_type == "sequence":
        query = (
            " ".join(
                [
                    "SELECT rolname AS name",
                    "FROM pg_catalog.pg_class c",
                    "JOIN pg_roles r",
                    "ON c.relowner = r.oid",
                    "JOIN pg_catalog.pg_namespace n",
                    "ON n.oid = c.relnamespace",
                    "WHERE relkind='S'",
                    "AND nspname='{0}'",
                    "AND relname = '{1}'",
                ]
            )
        ).format(prepend, name)
    elif object_type == "schema":
        query = (
            " ".join(
                [
                    "SELECT rolname AS name",
                    "FROM pg_namespace n",
                    "JOIN pg_roles r",
                    "ON n.nspowner = r.oid",
                    "WHERE nspname = '{0}'",
                ]
            )
        ).format(name)
    elif object_type == "function":
        query = (
            " ".join(
                [
                    "SELECT rolname AS name",
                    "FROM pg_catalog.pg_proc p",
                    "JOIN pg_catalog.pg_namespace n",
                    "ON n.oid = p.pronamespace",
                    "WHERE nspname = '{0}'",
                    "AND p.oid::regprocedure::text = '{1}'",
                    "ORDER BY proname, proargtypes",
                ]
            )
        ).format(prepend, name)
    elif object_type == "tablespace":
        query = (
            " ".join(
                [
                    "SELECT rolname AS name",
                    "FROM pg_tablespace t",
                    "JOIN pg_roles r",
                    "ON t.spcowner = r.oid",
                    "WHERE spcname = '{0}'",
                ]
            )
        ).format(name)
    elif object_type == "language":
        query = (
            " ".join(
                [
                    "SELECT rolname AS name",
                    "FROM pg_language l",
                    "JOIN pg_roles r",
                    "ON l.lanowner = r.oid",
                    "WHERE lanname = '{0}'",
                ]
            )
        ).format(name)
    elif object_type == "database":
        query = (
            " ".join(
                [
                    "SELECT rolname AS name",
                    "FROM pg_database d",
                    "JOIN pg_roles r",
                    "ON d.datdba = r.oid",
                    "WHERE datname = '{0}'",
                ]
            )
        ).format(name)
    rows = psql_query(
        query,
        runas=runas,
        host=host,
        user=user,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
    )
    try:
        ret = rows[0]["name"]
    except IndexError:
        ret = None
    return ret
def _validate_privileges(object_type, privs, privileges):
    if object_type != "group":
        _perms = [_PRIVILEGES_MAP[perm] for perm in _PRIVILEGE_TYPE_MAP[object_type]]
        _perms.append("ALL")
        if object_type not in _PRIVILEGES_OBJECTS:
            raise SaltInvocationError(
                "Invalid object_type: {} provided".format(object_type)
            )
        if not set(privs).issubset(set(_perms)):
            raise SaltInvocationError(
                "Invalid privilege(s): {} provided for object {}".format(
                    privileges, object_type
                )
            )
    else:
        if privileges:
            raise SaltInvocationError(
                "The privileges option should not be set for object_type group"
            )
def _mod_priv_opts(object_type, privileges):
    object_type = object_type.lower()
    privileges = "" if privileges is None else privileges
    _privs = re.split(r"\s?,\s?", privileges.upper())
    return object_type, privileges, _privs
def _process_priv_part(perms):
    _tmp = {}
    previous = None
    for perm in perms:
        if previous is None:
            _tmp[_PRIVILEGES_MAP[perm]] = False
            previous = _PRIVILEGES_MAP[perm]
        else:
            if perm == "*":
                _tmp[previous] = True
            else:
                _tmp[_PRIVILEGES_MAP[perm]] = False
                previous = _PRIVILEGES_MAP[perm]
    return _tmp
def privileges_list(
    name,
    object_type,
    prepend="public",
    maintenance_db=None,
    user=None,
    host=None,
    port=None,
    password=None,
    runas=None,
):
    object_type = object_type.lower()
    query = _make_privileges_list_query(name, object_type, prepend)
    if object_type not in _PRIVILEGES_OBJECTS:
        raise SaltInvocationError(
            "Invalid object_type: {} provided".format(object_type)
        )
    rows = psql_query(
        query,
        runas=runas,
        host=host,
        user=user,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
    )
    ret = {}
    for row in rows:
        if object_type != "group":
            result = row["name"]
            result = result.strip("{}")
            parts = result.split(",")
            for part in parts:
                perms_part, _ = part.split("/")
                rolename, perms = perms_part.split("=")
                if rolename == "":
                    rolename = "public"
                _tmp = _process_priv_part(perms)
                ret[rolename] = _tmp
        else:
            if row["admin_option"] == "t":
                admin_option = True
            else:
                admin_option = False
            ret[row["rolname"]] = admin_option
    return ret
def has_privileges(
    name,
    object_name,
    object_type,
    privileges=None,
    grant_option=None,
    prepend="public",
    maintenance_db=None,
    user=None,
    host=None,
    port=None,
    password=None,
    runas=None,
):
    object_type, privileges, _privs = _mod_priv_opts(object_type, privileges)
    _validate_privileges(object_type, _privs, privileges)
    if object_type != "group":
        owner = _get_object_owner(
            object_name,
            object_type,
            prepend=prepend,
            maintenance_db=maintenance_db,
            user=user,
            host=host,
            port=port,
            password=password,
            runas=runas,
        )
        if owner is not None and name == owner:
            return True
    _privileges = privileges_list(
        object_name,
        object_type,
        prepend=prepend,
        maintenance_db=maintenance_db,
        user=user,
        host=host,
        port=port,
        password=password,
        runas=runas,
    )
    if name in _privileges:
        if object_type == "group":
            if grant_option:
                retval = _privileges[name]
            else:
                retval = True
            return retval
        else:
            _perms = _PRIVILEGE_TYPE_MAP[object_type]
            if grant_option:
                perms = {_PRIVILEGES_MAP[perm]: True for perm in _perms}
                retval = perms == _privileges[name]
            else:
                perms = [_PRIVILEGES_MAP[perm] for perm in _perms]
                if "ALL" in _privs:
                    retval = sorted(perms) == sorted(_privileges[name])
                else:
                    retval = set(_privs).issubset(set(_privileges[name]))
            return retval
    return False
def privileges_grant(
    name,
    object_name,
    object_type,
    privileges=None,
    grant_option=None,
    prepend="public",
    maintenance_db=None,
    user=None,
    host=None,
    port=None,
    password=None,
    runas=None,
):
    object_type, privileges, _privs = _mod_priv_opts(object_type, privileges)
    _validate_privileges(object_type, _privs, privileges)
    if has_privileges(
        name,
        object_name,
        object_type,
        privileges,
        prepend=prepend,
        maintenance_db=maintenance_db,
        user=user,
        host=host,
        port=port,
        password=password,
        runas=runas,
    ):
        log.info(
            "The object: %s of type: %s already has privileges: %s set",
            object_name,
            object_type,
            privileges,
        )
        return False
    _grants = ",".join(_privs)
    if object_type in ["table", "sequence"]:
        on_part = '{}."{}"'.format(prepend, object_name)
    elif object_type == "function":
        on_part = "{}".format(object_name)
    else:
        on_part = '"{}"'.format(object_name)
    if grant_option:
        if object_type == "group":
            query = 'GRANT {} TO "{}" WITH ADMIN OPTION'.format(object_name, name)
        elif object_type in ("table", "sequence") and object_name.upper() == "ALL":
            query = 'GRANT {} ON ALL {}S IN SCHEMA {} TO "{}" WITH GRANT OPTION'.format(
                _grants, object_type.upper(), prepend, name
            )
        else:
            query = 'GRANT {} ON {} {} TO "{}" WITH GRANT OPTION'.format(
                _grants, object_type.upper(), on_part, name
            )
    else:
        if object_type == "group":
            query = 'GRANT {} TO "{}"'.format(object_name, name)
        elif object_type in ("table", "sequence") and object_name.upper() == "ALL":
            query = 'GRANT {} ON ALL {}S IN SCHEMA {} TO "{}"'.format(
                _grants, object_type.upper(), prepend, name
            )
        else:
            query = 'GRANT {} ON {} {} TO "{}"'.format(
                _grants, object_type.upper(), on_part, name
            )
    ret = _psql_prepare_and_run(
        ["-c", query],
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )
    return ret["retcode"] == 0
def privileges_revoke(
    name,
    object_name,
    object_type,
    privileges=None,
    prepend="public",
    maintenance_db=None,
    user=None,
    host=None,
    port=None,
    password=None,
    runas=None,
):
    object_type, privileges, _privs = _mod_priv_opts(object_type, privileges)
    _validate_privileges(object_type, _privs, privileges)
    if not has_privileges(
        name,
        object_name,
        object_type,
        privileges,
        prepend=prepend,
        maintenance_db=maintenance_db,
        user=user,
        host=host,
        port=port,
        password=password,
        runas=runas,
    ):
        log.info(
            "The object: %s of type: %s does not have privileges: %s set",
            object_name,
            object_type,
            privileges,
        )
        return False
    _grants = ",".join(_privs)
    if object_type in ["table", "sequence"]:
        on_part = "{}.{}".format(prepend, object_name)
    else:
        on_part = object_name
    if object_type == "group":
        query = "REVOKE {} FROM {}".format(object_name, name)
    else:
        query = "REVOKE {} ON {} {} FROM {}".format(
            _grants, object_type.upper(), on_part, name
        )
    ret = _psql_prepare_and_run(
        ["-c", query],
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )
    return ret["retcode"] == 0
def datadir_init(
    name,
    auth="password",
    user=None,
    password=None,
    encoding="UTF8",
    locale=None,
    waldir=None,
    checksums=False,
    runas=None,
):
    if datadir_exists(name):
        log.info("%s already exists", name)
        return False
    ret = _run_initdb(
        name,
        auth=auth,
        user=user,
        password=password,
        encoding=encoding,
        locale=locale,
        waldir=waldir,
        checksums=checksums,
        runas=runas,
    )
    return ret["retcode"] == 0
def datadir_exists(name):
    _version_file = os.path.join(name, "PG_VERSION")
    _config_file = os.path.join(name, "postgresql.conf")
    return os.path.isfile(_version_file) and os.path.isfile(_config_file)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
