
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.5247252747252755%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>yolact-MDEwOlJlcG9zaXRvcnkxMzg3OTY2OTk=-flat-multibox_loss.py</h3>
            <pre><code>1  import torch
2  import torch.nn as nn
3  import torch.nn.functional as F
4  from torch.autograd import Variable
5  from ..box_utils import match, log_sum_exp, decode, center_size, crop, elemwise_mask_iou, elemwise_box_iou
6  from data import cfg, mask_type, activation_func
7  class MultiBoxLoss(nn.Module):
8      def __init__(self, num_classes, pos_threshold, neg_threshold, negpos_ratio):
9          super(MultiBoxLoss, self).__init__()
10          self.num_classes = num_classes
11          self.pos_threshold = pos_threshold
12          self.neg_threshold = neg_threshold
13          self.negpos_ratio = negpos_ratio
14          self.l1_expected_area = 20*20/70/70
15          self.l1_alpha = 0.1
16          if cfg.use_class_balanced_conf:
17              self.class_instances = None
18              self.total_instances = 0
19      def forward(self, net, predictions, targets, masks, num_crowds):
20          loc_data  = predictions['loc']
21          conf_data = predictions['conf']
22          mask_data = predictions['mask']
23          priors    = predictions['priors']
24          if cfg.mask_type == mask_type.lincomb:
25              proto_data = predictions['proto']
26          score_data = predictions['score'] if cfg.use_mask_scoring   else None   
27          inst_data  = predictions['inst']  if cfg.use_instance_coeff else None
28          labels = [None] * len(targets) # Used in sem segm loss
29          batch_size = loc_data.size(0)
30          num_priors = priors.size(0)
31          num_classes = self.num_classes
32          loc_t = loc_data.new(batch_size, num_priors, 4)
33          gt_box_t = loc_data.new(batch_size, num_priors, 4)
34          conf_t = loc_data.new(batch_size, num_priors).long()
35          idx_t = loc_data.new(batch_size, num_priors).long()
36          if cfg.use_class_existence_loss:
37              class_existence_t = loc_data.new(batch_size, num_classes-1)
38          for idx in range(batch_size):
39              truths      = targets[idx][:, :-1].data
40              labels[idx] = targets[idx][:, -1].data.long()
41              if cfg.use_class_existence_loss:
42                  class_existence_t[idx, :] = torch.eye(num_classes-1, device=conf_t.get_device())[labels[idx]].max(dim=0)[0]
43              cur_crowds = num_crowds[idx]
44              if cur_crowds > 0:
45                  split = lambda x: (x[-cur_crowds:], x[:-cur_crowds])
46                  crowd_boxes, truths = split(truths)
47                  _, labels[idx] = split(labels[idx])
48                  _, masks[idx]  = split(masks[idx])
49              else:
50                  crowd_boxes = None
51              match(self.pos_threshold, self.neg_threshold,
52                    truths, priors.data, labels[idx], crowd_boxes,
53                    loc_t, conf_t, idx_t, idx, loc_data[idx])
54              gt_box_t[idx, :, :] = truths[idx_t[idx]]
55          loc_t = Variable(loc_t, requires_grad=False)
56          conf_t = Variable(conf_t, requires_grad=False)
57          idx_t = Variable(idx_t, requires_grad=False)
58          pos = conf_t > 0
59          num_pos = pos.sum(dim=1, keepdim=True)
60          pos_idx = pos.unsqueeze(pos.dim()).expand_as(loc_data)
61          losses = {}
62          if cfg.train_boxes:
63              loc_p = loc_data[pos_idx].view(-1, 4)
64              loc_t = loc_t[pos_idx].view(-1, 4)
65              losses['B'] = F.smooth_l1_loss(loc_p, loc_t, reduction='sum') * cfg.bbox_alpha
66          if cfg.train_masks:
67              if cfg.mask_type == mask_type.direct:
68                  if cfg.use_gt_bboxes:
69                      pos_masks = []
70                      for idx in range(batch_size):
71                          pos_masks.append(masks[idx][idx_t[idx, pos[idx]]])
72                      masks_t = torch.cat(pos_masks, 0)
73                      masks_p = mask_data[pos, :].view(-1, cfg.mask_dim)
74                      losses['M'] = F.binary_cross_entropy(torch.clamp(masks_p, 0, 1), masks_t, reduction='sum') * cfg.mask_alpha
75                  else:
76                      losses['M'] = self.direct_mask_loss(pos_idx, idx_t, loc_data, mask_data, priors, masks)
77              elif cfg.mask_type == mask_type.lincomb:
78                  ret = self.lincomb_mask_loss(pos, idx_t, loc_data, mask_data, priors, proto_data, masks, gt_box_t, score_data, inst_data, labels)
79                  if cfg.use_maskiou:
80                      loss, maskiou_targets = ret
81                  else:
82                      loss = ret
83                  losses.update(loss)
84                  if cfg.mask_proto_loss is not None:
85                      if cfg.mask_proto_loss == 'l1':
86                          losses['P'] = torch.mean(torch.abs(proto_data)) / self.l1_expected_area * self.l1_alpha
87                      elif cfg.mask_proto_loss == 'disj':
88                          losses['P'] = -torch.mean(torch.max(F.log_softmax(proto_data, dim=-1), dim=-1)[0])
89          if cfg.use_focal_loss:
90              if cfg.use_sigmoid_focal_loss:
91                  losses['C'] = self.focal_conf_sigmoid_loss(conf_data, conf_t)
92              elif cfg.use_objectness_score:
93                  losses['C'] = self.focal_conf_objectness_loss(conf_data, conf_t)
94              else:
95                  losses['C'] = self.focal_conf_loss(conf_data, conf_t)
96          else:
97              if cfg.use_objectness_score:
98                  losses['C'] = self.conf_objectness_loss(conf_data, conf_t, batch_size, loc_p, loc_t, priors)
99              else:
100                  losses['C'] = self.ohem_conf_loss(conf_data, conf_t, pos, batch_size)
101          if cfg.use_maskiou and maskiou_targets is not None:
102              losses['I'] = self.mask_iou_loss(net, maskiou_targets)
103          if cfg.use_class_existence_loss:
104              losses['E'] = self.class_existence_loss(predictions['classes'], class_existence_t)
105          if cfg.use_semantic_segmentation_loss:
106              losses['S'] = self.semantic_segmentation_loss(predictions['segm'], masks, labels)
107          total_num_pos = num_pos.data.sum().float()
108          for k in losses:
109              if k not in ('P', 'E', 'S'):
110                  losses[k] /= total_num_pos
111              else:
112                  losses[k] /= batch_size
113          return losses
114      def class_existence_loss(self, class_data, class_existence_t):
115          return cfg.class_existence_alpha * F.binary_cross_entropy_with_logits(class_data, class_existence_t, reduction='sum')
116      def semantic_segmentation_loss(self, segment_data, mask_t, class_t, interpolation_mode='bilinear'):
117          batch_size, num_classes, mask_h, mask_w = segment_data.size()
118          loss_s = 0
119          for idx in range(batch_size):
120              cur_segment = segment_data[idx]
121              cur_class_t = class_t[idx]
122              with torch.no_grad():
123                  downsampled_masks = F.interpolate(mask_t[idx].unsqueeze(0), (mask_h, mask_w),
124                                                    mode=interpolation_mode, align_corners=False).squeeze(0)
125                  downsampled_masks = downsampled_masks.gt(0.5).float()
126                  segment_t = torch.zeros_like(cur_segment, requires_grad=False)
127                  for obj_idx in range(downsampled_masks.size(0)):
128                      segment_t[cur_class_t[obj_idx]] = torch.max(segment_t[cur_class_t[obj_idx]], downsampled_masks[obj_idx])
129              loss_s += F.binary_cross_entropy_with_logits(cur_segment, segment_t, reduction='sum')
130          return loss_s / mask_h / mask_w * cfg.semantic_segmentation_alpha
131      def ohem_conf_loss(self, conf_data, conf_t, pos, num):
132          batch_conf = conf_data.view(-1, self.num_classes)
133          if cfg.ohem_use_most_confident:
134              batch_conf = F.softmax(batch_conf, dim=1)
135              loss_c, _ = batch_conf[:, 1:].max(dim=1)
136          else:
137              loss_c = log_sum_exp(batch_conf) - batch_conf[:, 0]
138          loss_c = loss_c.view(num, -1)
139          loss_c[pos]        = 0 # filter out pos boxes
140          loss_c[conf_t < 0] = 0 # filter out neutrals (conf_t = -1)
141          _, loss_idx = loss_c.sort(1, descending=True)
142          _, idx_rank = loss_idx.sort(1)
143          num_pos = pos.long().sum(1, keepdim=True)
144          num_neg = torch.clamp(self.negpos_ratio*num_pos, max=pos.size(1)-1)
145          neg = idx_rank < num_neg.expand_as(idx_rank)
146          neg[pos]        = 0
147          neg[conf_t < 0] = 0 # Filter out neutrals
148          pos_idx = pos.unsqueeze(2).expand_as(conf_data)
149          neg_idx = neg.unsqueeze(2).expand_as(conf_data)
150          conf_p = conf_data[(pos_idx+neg_idx).gt(0)].view(-1, self.num_classes)
151          targets_weighted = conf_t[(pos+neg).gt(0)]
152          loss_c = F.cross_entropy(conf_p, targets_weighted, reduction='none')
153          if cfg.use_class_balanced_conf:
154              if self.class_instances is None:
155                  self.class_instances = torch.zeros(self.num_classes, device=targets_weighted.device)
156              classes, counts = targets_weighted.unique(return_counts=True)
157              for _cls, _cnt in zip(classes.cpu().numpy(), counts.cpu().numpy()):
158                  self.class_instances[_cls] += _cnt
159              self.total_instances += targets_weighted.size(0)
160              weighting = 1 - (self.class_instances[targets_weighted] / self.total_instances)
161              weighting = torch.clamp(weighting, min=1/self.num_classes)
162              avg_weight = (self.num_classes - 1) / self.num_classes
163              loss_c = (loss_c * weighting).sum() / avg_weight
164          else:
165              loss_c = loss_c.sum()
166          return cfg.conf_alpha * loss_c
167      def focal_conf_loss(self, conf_data, conf_t):
168          conf_t = conf_t.view(-1) # [batch_size*num_priors]
169          conf_data = conf_data.view(-1, conf_data.size(-1)) # [batch_size*num_priors, num_classes]
170          keep = (conf_t >= 0).float()
171          conf_t[conf_t < 0] = 0 # so that gather doesn't drum up a fuss
172          logpt = F.log_softmax(conf_data, dim=-1)
173          logpt = logpt.gather(1, conf_t.unsqueeze(-1))
174          logpt = logpt.view(-1)
175          pt    = logpt.exp()
176          background = (conf_t == 0).float()
177          at = (1 - cfg.focal_loss_alpha) * background + cfg.focal_loss_alpha * (1 - background)
178          loss = -at * (1 - pt) ** cfg.focal_loss_gamma * logpt
179          return cfg.conf_alpha * (loss * keep).sum()
180      def focal_conf_sigmoid_loss(self, conf_data, conf_t):
181          num_classes = conf_data.size(-1)
182          conf_t = conf_t.view(-1) # [batch_size*num_priors]
183          conf_data = conf_data.view(-1, num_classes) # [batch_size*num_priors, num_classes]
184          keep = (conf_t >= 0).float()
185          conf_t[conf_t < 0] = 0 # can't mask with -1, so filter that out
186          conf_one_t = torch.eye(num_classes, device=conf_t.get_device())[conf_t]
187          conf_pm_t  = conf_one_t * 2 - 1 # -1 if background, +1 if forground for specific class
188          logpt = F.logsigmoid(conf_data * conf_pm_t) # note: 1 - sigmoid(x) = sigmoid(-x)
189          pt    = logpt.exp()
190          at = cfg.focal_loss_alpha * conf_one_t + (1 - cfg.focal_loss_alpha) * (1 - conf_one_t)
191          at[..., 0] = 0 # Set alpha for the background class to 0 because sigmoid focal loss doesn't use it
192          loss = -at * (1 - pt) ** cfg.focal_loss_gamma * logpt
193          loss = keep * loss.sum(dim=-1)
194          return cfg.conf_alpha * loss.sum()
195      def focal_conf_objectness_loss(self, conf_data, conf_t):
196          conf_t = conf_t.view(-1) # [batch_size*num_priors]
197          conf_data = conf_data.view(-1, conf_data.size(-1)) # [batch_size*num_priors, num_classes]
198          keep = (conf_t >= 0).float()
199          conf_t[conf_t < 0] = 0 # so that gather doesn't drum up a fuss
200          background = (conf_t == 0).float()
201          at = (1 - cfg.focal_loss_alpha) * background + cfg.focal_loss_alpha * (1 - background)
202          logpt = F.logsigmoid(conf_data[:, 0]) * (1 - background) + F.logsigmoid(-conf_data[:, 0]) * background
203          pt    = logpt.exp()
204          obj_loss = -at * (1 - pt) ** cfg.focal_loss_gamma * logpt
205          pos_mask = conf_t > 0
206          conf_data_pos = (conf_data[:, 1:])[pos_mask] # Now this has just 80 classes
207          conf_t_pos    = conf_t[pos_mask] - 1         # So subtract 1 here
208          class_loss = F.cross_entropy(conf_data_pos, conf_t_pos, reduction='sum')
209          return cfg.conf_alpha * (class_loss + (obj_loss * keep).sum())
210      def conf_objectness_loss(self, conf_data, conf_t, batch_size, loc_p, loc_t, priors):
211          conf_t = conf_t.view(-1) # [batch_size*num_priors]
212          conf_data = conf_data.view(-1, conf_data.size(-1)) # [batch_size*num_priors, num_classes]
213          pos_mask = (conf_t > 0)
214          neg_mask = (conf_t == 0)
215          obj_data = conf_data[:, 0]
216          obj_data_pos = obj_data[pos_mask]
217          obj_data_neg = obj_data[neg_mask]
<span onclick='openModal()' class='match'>218          obj_neg_loss = - F.logsigmoid(-obj_data_neg).sum()
219          with torch.no_grad():
220              pos_priors = priors.unsqueeze(0).expand(batch_size, -1, -1).reshape(-1, 4)[pos_mask, :]
</span>221              boxes_pred = decode(loc_p, pos_priors, cfg.use_yolo_regressors)
222              boxes_targ = decode(loc_t, pos_priors, cfg.use_yolo_regressors)
223              iou_targets = elemwise_box_iou(boxes_pred, boxes_targ)
224          obj_pos_loss = - iou_targets * F.logsigmoid(obj_data_pos) - (1 - iou_targets) * F.logsigmoid(-obj_data_pos)
225          obj_pos_loss = obj_pos_loss.sum()
226          conf_data_pos = (conf_data[:, 1:])[pos_mask] # Now this has just 80 classes
227          conf_t_pos    = conf_t[pos_mask] - 1         # So subtract 1 here
228          class_loss = F.cross_entropy(conf_data_pos, conf_t_pos, reduction='sum')
229          return cfg.conf_alpha * (class_loss + obj_pos_loss + obj_neg_loss)
230      def direct_mask_loss(self, pos_idx, idx_t, loc_data, mask_data, priors, masks):
231          loss_m = 0
232          for idx in range(mask_data.size(0)):
233              with torch.no_grad():
234                  cur_pos_idx = pos_idx[idx, :, :]
235                  cur_pos_idx_squeezed = cur_pos_idx[:, 1]
236                  pos_bboxes = decode(loc_data[idx, :, :], priors.data, cfg.use_yolo_regressors)
237                  pos_bboxes = pos_bboxes[cur_pos_idx].view(-1, 4).clamp(0, 1)
238                  pos_lookup = idx_t[idx, cur_pos_idx_squeezed]
239                  cur_masks = masks[idx]
240                  pos_masks = cur_masks[pos_lookup, :, :]
241                  num_pos, img_height, img_width = pos_masks.size()
242                  x1, x2 = sanitize_coordinates(pos_bboxes[:, 0], pos_bboxes[:, 2], img_width)
243                  y1, y2 = sanitize_coordinates(pos_bboxes[:, 1], pos_bboxes[:, 3], img_height)
244                  scaled_masks = []
245                  for jdx in range(num_pos):
246                      tmp_mask = pos_masks[jdx, y1[jdx]:y2[jdx], x1[jdx]:x2[jdx]]
247                      while tmp_mask.dim() < 2:
248                          tmp_mask = tmp_mask.unsqueeze(0)
249                      new_mask = F.adaptive_avg_pool2d(tmp_mask.unsqueeze(0), cfg.mask_size)
250                      scaled_masks.append(new_mask.view(1, -1))
251                  mask_t = torch.cat(scaled_masks, 0).gt(0.5).float() # Threshold downsampled mask
252              pos_mask_data = mask_data[idx, cur_pos_idx_squeezed, :]
253              loss_m += F.binary_cross_entropy(torch.clamp(pos_mask_data, 0, 1), mask_t, reduction='sum') * cfg.mask_alpha
254          return loss_m
255      def coeff_diversity_loss(self, coeffs, instance_t):
256          num_pos = coeffs.size(0)
257          instance_t = instance_t.view(-1) # juuuust to make sure
258          coeffs_norm = F.normalize(coeffs, dim=1)
259          cos_sim = coeffs_norm @ coeffs_norm.t()
260          inst_eq = (instance_t[:, None].expand_as(cos_sim) == instance_t[None, :].expand_as(cos_sim)).float()
261          cos_sim = (cos_sim + 1) / 2
262          loss = (1 - cos_sim) * inst_eq + cos_sim * (1 - inst_eq)
263          return cfg.mask_proto_coeff_diversity_alpha * loss.sum() / num_pos
264      def lincomb_mask_loss(self, pos, idx_t, loc_data, mask_data, priors, proto_data, masks, gt_box_t, score_data, inst_data, labels, interpolation_mode='bilinear'):
265          mask_h = proto_data.size(1)
266          mask_w = proto_data.size(2)
267          process_gt_bboxes = cfg.mask_proto_normalize_emulate_roi_pooling or cfg.mask_proto_crop
268          if cfg.mask_proto_remove_empty_masks:
269              pos = pos.clone()
270          loss_m = 0
271          loss_d = 0 # Coefficient diversity loss
272          maskiou_t_list = []
273          maskiou_net_input_list = []
274          label_t_list = []
275          for idx in range(mask_data.size(0)):
276              with torch.no_grad():
277                  downsampled_masks = F.interpolate(masks[idx].unsqueeze(0), (mask_h, mask_w),
278                                                    mode=interpolation_mode, align_corners=False).squeeze(0)
279                  downsampled_masks = downsampled_masks.permute(1, 2, 0).contiguous()
280                  if cfg.mask_proto_binarize_downsampled_gt:
281                      downsampled_masks = downsampled_masks.gt(0.5).float()
282                  if cfg.mask_proto_remove_empty_masks:
283                      very_small_masks = (downsampled_masks.sum(dim=(0,1)) <= 0.0001)
284                      for i in range(very_small_masks.size(0)):
285                          if very_small_masks[i]:
286                              pos[idx, idx_t[idx] == i] = 0
287                  if cfg.mask_proto_reweight_mask_loss:
288                      if not cfg.mask_proto_binarize_downsampled_gt:
289                          bin_gt = downsampled_masks.gt(0.5).float()
290                      else:
291                          bin_gt = downsampled_masks
292                      gt_foreground_norm = bin_gt     / (torch.sum(bin_gt,   dim=(0,1), keepdim=True) + 0.0001)
293                      gt_background_norm = (1-bin_gt) / (torch.sum(1-bin_gt, dim=(0,1), keepdim=True) + 0.0001)
294                      mask_reweighting   = gt_foreground_norm * cfg.mask_proto_reweight_coeff + gt_background_norm
295                      mask_reweighting  *= mask_h * mask_w
296              cur_pos = pos[idx]
297              pos_idx_t = idx_t[idx, cur_pos]
298              if process_gt_bboxes:
299                  if cfg.mask_proto_crop_with_pred_box:
300                      pos_gt_box_t = decode(loc_data[idx, :, :], priors.data, cfg.use_yolo_regressors)[cur_pos]
301                  else:
302                      pos_gt_box_t = gt_box_t[idx, cur_pos]
303              if pos_idx_t.size(0) == 0:
304                  continue
305              proto_masks = proto_data[idx]
306              proto_coef  = mask_data[idx, cur_pos, :]
307              if cfg.use_mask_scoring:
308                  mask_scores = score_data[idx, cur_pos, :]
309              if cfg.mask_proto_coeff_diversity_loss:
310                  if inst_data is not None:
311                      div_coeffs = inst_data[idx, cur_pos, :]
312                  else:
313                      div_coeffs = proto_coef
314                  loss_d += self.coeff_diversity_loss(div_coeffs, pos_idx_t)
315              old_num_pos = proto_coef.size(0)
316              if old_num_pos > cfg.masks_to_train:
317                  perm = torch.randperm(proto_coef.size(0))
318                  select = perm[:cfg.masks_to_train]
319                  proto_coef = proto_coef[select, :]
320                  pos_idx_t  = pos_idx_t[select]
321                  if process_gt_bboxes:
322                      pos_gt_box_t = pos_gt_box_t[select, :]
323                  if cfg.use_mask_scoring:
324                      mask_scores = mask_scores[select, :]
325              num_pos = proto_coef.size(0)
326              mask_t = downsampled_masks[:, :, pos_idx_t]     
327              label_t = labels[idx][pos_idx_t]     
328              pred_masks = proto_masks @ proto_coef.t()
329              pred_masks = cfg.mask_proto_mask_activation(pred_masks)
330              if cfg.mask_proto_double_loss:
331                  if cfg.mask_proto_mask_activation == activation_func.sigmoid:
332                      pre_loss = F.binary_cross_entropy(torch.clamp(pred_masks, 0, 1), mask_t, reduction='sum')
333                  else:
334                      pre_loss = F.smooth_l1_loss(pred_masks, mask_t, reduction='sum')
335                  loss_m += cfg.mask_proto_double_loss_alpha * pre_loss
336              if cfg.mask_proto_crop:
337                  pred_masks = crop(pred_masks, pos_gt_box_t)
338              if cfg.mask_proto_mask_activation == activation_func.sigmoid:
339                  pre_loss = F.binary_cross_entropy(torch.clamp(pred_masks, 0, 1), mask_t, reduction='none')
340              else:
341                  pre_loss = F.smooth_l1_loss(pred_masks, mask_t, reduction='none')
342              if cfg.mask_proto_normalize_mask_loss_by_sqrt_area:
343                  gt_area  = torch.sum(mask_t, dim=(0, 1), keepdim=True)
344                  pre_loss = pre_loss / (torch.sqrt(gt_area) + 0.0001)
345              if cfg.mask_proto_reweight_mask_loss:
346                  pre_loss = pre_loss * mask_reweighting[:, :, pos_idx_t]
347              if cfg.mask_proto_normalize_emulate_roi_pooling:
348                  weight = mask_h * mask_w if cfg.mask_proto_crop else 1
349                  pos_gt_csize = center_size(pos_gt_box_t)
350                  gt_box_width  = pos_gt_csize[:, 2] * mask_w
351                  gt_box_height = pos_gt_csize[:, 3] * mask_h
352                  pre_loss = pre_loss.sum(dim=(0, 1)) / gt_box_width / gt_box_height * weight
353              if old_num_pos > num_pos:
354                  pre_loss *= old_num_pos / num_pos
355              loss_m += torch.sum(pre_loss)
356              if cfg.use_maskiou:
357                  if cfg.discard_mask_area > 0:
358                      gt_mask_area = torch.sum(mask_t, dim=(0, 1))
359                      select = gt_mask_area > cfg.discard_mask_area
360                      if torch.sum(select) < 1:
361                          continue
362                      pos_gt_box_t = pos_gt_box_t[select, :]
363                      pred_masks = pred_masks[:, :, select]
364                      mask_t = mask_t[:, :, select]
365                      label_t = label_t[select]
366                  maskiou_net_input = pred_masks.permute(2, 0, 1).contiguous().unsqueeze(1)
367                  pred_masks = pred_masks.gt(0.5).float()                
368                  maskiou_t = self._mask_iou(pred_masks, mask_t)
369                  maskiou_net_input_list.append(maskiou_net_input)
370                  maskiou_t_list.append(maskiou_t)
371                  label_t_list.append(label_t)
372          losses = {'M': loss_m * cfg.mask_alpha / mask_h / mask_w}
373          if cfg.mask_proto_coeff_diversity_loss:
374              losses['D'] = loss_d
375          if cfg.use_maskiou:
376              if len(maskiou_t_list) == 0:
377                  return losses, None
378              maskiou_t = torch.cat(maskiou_t_list)
379              label_t = torch.cat(label_t_list)
380              maskiou_net_input = torch.cat(maskiou_net_input_list)
381              num_samples = maskiou_t.size(0)
382              if cfg.maskious_to_train > 0 and num_samples > cfg.maskious_to_train:
383                  perm = torch.randperm(num_samples)
384                  select = perm[:cfg.masks_to_train]
385                  maskiou_t = maskiou_t[select]
386                  label_t = label_t[select]
387                  maskiou_net_input = maskiou_net_input[select]
388              return losses, [maskiou_net_input, maskiou_t, label_t]
389          return losses
390      def _mask_iou(self, mask1, mask2):
391          intersection = torch.sum(mask1*mask2, dim=(0, 1))
392          area1 = torch.sum(mask1, dim=(0, 1))
393          area2 = torch.sum(mask2, dim=(0, 1))
394          union = (area1 + area2) - intersection
395          ret = intersection / union
396          return ret
397      def mask_iou_loss(self, net, maskiou_targets):
398          maskiou_net_input, maskiou_t, label_t = maskiou_targets
399          maskiou_p = net.maskiou_net(maskiou_net_input)
400          label_t = label_t[:, None]
401          maskiou_p = torch.gather(maskiou_p, dim=1, index=label_t).view(-1)
402          loss_i = F.smooth_l1_loss(maskiou_p, maskiou_t, reduction='sum')
403          return loss_i * cfg.maskiou_alpha
</code></pre>
        </div>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-test_esptool.py</h3>
            <pre><code>1  import os
2  import os.path
3  import random
4  import re
5  import struct
6  import subprocess
7  import sys
8  import tempfile
9  import time
10  from socket import AF_INET, SOCK_STREAM, socket
11  from time import sleep
12  from conftest import (
13      arg_baud,
14      arg_chip,
15      arg_port,
16      arg_preload_port,
17      arg_trace,
18      need_to_install_package_err,
19  )
20  import pytest
21  try:
22      import esptool
23      import espefuse
24  except ImportError:
25      need_to_install_package_err()
26  import serial
27  TEST_DIR = os.path.abspath(os.path.dirname(__file__))
28  os.environ["ESPTOOL_TESTING"] = "1"
29  print("Running esptool.py tests...")
30  class ESPRFC2217Server(object):
31      def __init__(self, rfc2217_port=None):
32          self.port = rfc2217_port or self.get_free_port()
33          self.cmd = [
34              sys.executable,
35              os.path.join(TEST_DIR, "..", "esp_rfc2217_server.py"),
36              "-p",
37              str(self.port),
38              arg_port,
39          ]
40          self.server_output_file = open(f"{TEST_DIR}/{str(arg_chip)}_server.out", "a")
41          self.server_output_file.write("************************************")
42          self.p = None
43          self.wait_for_server_starts(attempts_count=5)
44      @staticmethod
45      def get_free_port():
46          s = socket(AF_INET, SOCK_STREAM)
47          s.bind(("", 0))
48          port = s.getsockname()[1]
49          s.close()
50          return port
51      def wait_for_server_starts(self, attempts_count):
52          for attempt in range(attempts_count):
53              try:
54                  self.p = subprocess.Popen(
55                      self.cmd,
56                      cwd=TEST_DIR,
57                      stdout=self.server_output_file,
58                      stderr=subprocess.STDOUT,
59                      close_fds=True,
60                  )
61                  sleep(2)
62                  s = socket(AF_INET, SOCK_STREAM)
63                  result = s.connect_ex(("localhost", self.port))
64                  s.close()
65                  if result == 0:
66                      print("Server started successfully.")
67                      return
68              except Exception as e:
69                  print(e)
70              print(
71                  "Server start failed."
72                  + (" Retrying . . ." if attempt < attempts_count - 1 else "")
73              )
74              self.p.terminate()
75          raise Exception("Server not started successfully!")
76      def __enter__(self):
77          return self
78      def __exit__(self, type, value, traceback):
79          self.server_output_file.close()
80          self.p.terminate()
81  @pytest.mark.flaky(reruns=1, condition=arg_preload_port is not False)
82  class EsptoolTestCase:
83      def run_espsecure(self, args):
84          cmd = [sys.executable, "-m", "espsecure"] + args.split(" ")
85          print("\nExecuting {}...".format(" ".join(cmd)))
86          try:
87              output = subprocess.check_output(
88                  [str(s) for s in cmd], cwd=TEST_DIR, stderr=subprocess.STDOUT
89              )
90              output = output.decode("utf-8")
91              print(output)  # for more complete stdout logs on failure
92              return output
93          except subprocess.CalledProcessError as e:
94              print(e.output)
95              raise e
96      def run_esptool(self, args, baud=None, chip=None, port=None, preload=True):
97          def run_esptool_process(cmd):
98              print("Executing {}...".format(" ".join(cmd)))
99              try:
100                  output = subprocess.check_output(
101                      [str(s) for s in cmd],
102                      cwd=TEST_DIR,
103                      stderr=subprocess.STDOUT,
104                  )
105                  return output.decode("utf-8")
106              except subprocess.CalledProcessError as e:
107                  print(e.output.decode("utf-8"))
108                  raise e
109          try:
110              esptool = [os.environ["ESPTOOL_PY"]]
111          except KeyError:
112              esptool = ["-m", "esptool"]
113          trace_arg = ["--trace"] if arg_trace else []
114          base_cmd = [sys.executable] + esptool + trace_arg
115          if chip or arg_chip is not None and chip != "auto":
116              base_cmd += ["--chip", chip or arg_chip]
117          if port or arg_port is not None:
118              base_cmd += ["--port", port or arg_port]
119          if baud or arg_baud is not None:
120              base_cmd += ["--baud", str(baud or arg_baud)]
121          usb_jtag_serial_reset = ["--before", "usb_reset"] if arg_preload_port else []
122          full_cmd = base_cmd + usb_jtag_serial_reset + args.split(" ")
123          if (
124              preload
125              and arg_preload_port
126              and arg_chip
127              in ["esp32c3", "esp32s3", "esp32c6", "esp32h2"]  # With USB-JTAG/Serial
128          ):
129              port_index = base_cmd.index("--port") + 1
130              base_cmd[port_index] = arg_preload_port  # Set the port to the preload one
131              preload_cmd = base_cmd + [
132                  "--no-stub",
133                  "load_ram",
134                  f"{TEST_DIR}/images/ram_helloworld/helloworld-{arg_chip}.bin",
135              ]
136              print("\nPreloading dummy binary to disable RTC watchdog...")
137              run_esptool_process(preload_cmd)
138              print("Dummy binary preloaded successfully.")
139              time.sleep(0.3)  # Wait for the app to run and port to appear
140          print(f'\nRunning the "{args}" command...')
141          output = run_esptool_process(full_cmd)
142          print(output)  # for more complete stdout logs on failure
143          return output
144      def run_esptool_error(self, args, baud=None):
145          with pytest.raises(subprocess.CalledProcessError) as fail:
146              self.run_esptool(args, baud)
147          failure = fail.value
148          assert failure.returncode == 2  # esptool.FatalError return code
149          return failure.output.decode("utf-8")
150      @classmethod
151      def setup_class(self):
152          print()
153          print(50 * "*")
154          self.stored_dir = os.getcwd()
155          os.chdir(TEST_DIR)
156      @classmethod
157      def teardown_class(self):
158          os.chdir(self.stored_dir)
159      def readback(self, offset, length):
160          dump_file = tempfile.NamedTemporaryFile(delete=False)  # a file we can read into
161          try:
162              self.run_esptool(
163                  f"--before default_reset read_flash {offset} {length} {dump_file.name}"
164              )
165              with open(dump_file.name, "rb") as f:
166                  rb = f.read()
167              assert length == len(
168                  rb
169              ), f"read_flash length {length} offset {offset:#x} yielded {len(rb)} bytes!"
170              return rb
171          finally:
172              dump_file.close()
173              os.unlink(dump_file.name)
174      def verify_readback(self, offset, length, compare_to, is_bootloader=False):
175          rb = self.readback(offset, length)
176          with open(compare_to, "rb") as f:
177              ct = f.read()
178          if len(rb) != len(ct):
179              print(
180                  f"WARNING: Expected length {len(ct)} doesn't match comparison {len(rb)}"
181              )
182          print(f"Readback {len(rb)} bytes")
183          if is_bootloader:
184              assert ct[0] == rb[0], "First bytes should be identical"
185              rb = rb[8:]
186              ct = ct[8:]
187          for rb_b, ct_b, offs in zip(rb, ct, range(len(rb))):
188              assert (
189                  rb_b == ct_b
190              ), f"First difference at offset {offs:#x} Expected {ct_b} got {rb_b}"
191  @pytest.mark.skipif(arg_chip != "esp32", reason="ESP32 only")
192  class TestFlashEncryption(EsptoolTestCase):
193      def valid_key_present(self):
194          try:
195              esp = esptool.ESP32ROM(arg_port)
196              esp.connect()
197              efuses, _ = espefuse.get_efuses(esp=esp)
198              blk1_rd_en = efuses["BLOCK1"].is_readable()
199              return not blk1_rd_en
200          finally:
201              esp._port.close()
202      def test_blank_efuse_encrypt_write_abort(self):
203          if self.valid_key_present() is True:
204              pytest.skip("Valid encryption key already programmed, aborting the test")
205          self.run_esptool(
206              "write_flash 0x1000 images/bootloader_esp32.bin "
207              "0x8000 images/partitions_singleapp.bin "
208              "0x10000 images/ram_helloworld/helloworld-esp32.bin"
209          )
210          output = self.run_esptool_error(
211              "write_flash --encrypt 0x10000 images/ram_helloworld/helloworld-esp32.bin"
212          )
213          assert "Flash encryption key is not programmed".lower() in output.lower()
214      def test_blank_efuse_encrypt_write_continue1(self):
215          if self.valid_key_present() is True:
216              pytest.skip("Valid encryption key already programmed, aborting the test")
217          self.run_esptool(
218              "write_flash --encrypt --ignore-flash-encryption-efuse-setting "
219              "0x10000 images/ram_helloworld/helloworld-esp32.bin"
220          )
221          self.run_esptool("read_flash 0x10000 192 images/read_encrypted_flash.bin")
222          self.run_espsecure(
223              "encrypt_flash_data --address 0x10000 --keyfile images/aes_key.bin "
224              "--flash_crypt_conf 0 --output images/local_enc.bin "
225              "images/ram_helloworld/helloworld-esp32.bin"
226          )
227          try:
228              with open("images/read_encrypted_flash.bin", "rb") as file1:
229                  read_file1 = file1.read()
230              with open("images/local_enc.bin", "rb") as file2:
231                  read_file2 = file2.read()
232              for rf1, rf2, i in zip(read_file1, read_file2, range(len(read_file2))):
233                  assert (
234                      rf1 == rf2
235                  ), f"Encrypted write failed: file mismatch at byte position {i}"
236              print("Encrypted write success")
237          finally:
238              os.remove("images/read_encrypted_flash.bin")
239              os.remove("images/local_enc.bin")
240      def test_blank_efuse_encrypt_write_continue2(self):
241          if self.valid_key_present() is True:
242              pytest.skip("Valid encryption key already programmed, aborting the test")
243          self.run_esptool(
244              "write_flash --encrypt --ignore-flash-encryption-efuse-setting "
245              "0x10000 images/ram_helloworld/helloworld-esp32_edit.bin"
246          )
247          self.run_esptool("read_flash 0x10000 192 images/read_encrypted_flash.bin")
248          self.run_espsecure(
249              "encrypt_flash_data --address 0x10000 --keyfile images/aes_key.bin "
250              "--flash_crypt_conf 0 --output images/local_enc.bin "
251              "images/ram_helloworld/helloworld-esp32.bin"
252          )
253          try:
254              with open("images/read_encrypted_flash.bin", "rb") as file1:
255                  read_file1 = file1.read()
256              with open("images/local_enc.bin", "rb") as file2:
257                  read_file2 = file2.read()
258              mismatch = any(rf1 != rf2 for rf1, rf2 in zip(read_file1, read_file2))
259              assert mismatch, "Files should mismatch"
260          finally:
261              os.remove("images/read_encrypted_flash.bin")
262              os.remove("images/local_enc.bin")
263  class TestFlashing(EsptoolTestCase):
264      @pytest.mark.quick_test
265      def test_short_flash(self):
266          self.run_esptool("write_flash 0x0 images/one_kb.bin")
267          self.verify_readback(0, 1024, "images/one_kb.bin")
268      @pytest.mark.quick_test
269      def test_highspeed_flash(self):
270          self.run_esptool("write_flash 0x0 images/fifty_kb.bin", baud=921600)
271          self.verify_readback(0, 50 * 1024, "images/fifty_kb.bin")
272      def test_adjacent_flash(self):
273          self.run_esptool("write_flash 0x0 images/sector.bin 0x1000 images/fifty_kb.bin")
274          self.verify_readback(0, 4096, "images/sector.bin")
275          self.verify_readback(4096, 50 * 1024, "images/fifty_kb.bin")
276      def test_adjacent_independent_flash(self):
277          self.run_esptool("write_flash 0x0 images/sector.bin")
278          self.verify_readback(0, 4096, "images/sector.bin")
279          self.run_esptool("write_flash 0x1000 images/fifty_kb.bin")
280          self.verify_readback(4096, 50 * 1024, "images/fifty_kb.bin")
281          self.verify_readback(0, 4096, "images/sector.bin")
282      @pytest.mark.skipif(
283          int(os.getenv("ESPTOOL_TEST_FLASH_SIZE", "0")) < 32, reason="needs 32MB flash"
284      )
285      def test_last_bytes_of_32M_flash(self):
286          flash_size = 32 * 1024 * 1024
287          image_size = 1024
288          offset = flash_size - image_size
289          self.run_esptool("write_flash {} images/one_kb.bin".format(hex(offset)))
290          offset2 = offset & 0xFFFFFF
291          self.run_esptool("write_flash {} images/one_kb_all_ef.bin".format(hex(offset2)))
292          self.verify_readback(offset, image_size, "images/one_kb.bin")
293      @pytest.mark.skipif(
294          int(os.getenv("ESPTOOL_TEST_FLASH_SIZE", "0")) < 32, reason="needs 32MB flash"
295      )
296      def test_write_larger_area_to_32M_flash(self):
297          offset = 18 * 1024 * 1024
298          self.run_esptool("write_flash {} images/one_mb.bin".format(hex(offset)))
299          offset2 = offset & 0xFFFFFF
300          self.run_esptool("write_flash {} images/one_kb_all_ef.bin".format(hex(offset2)))
301          self.verify_readback(offset, 1 * 1024 * 1024, "images/one_mb.bin")
302      def test_correct_offset(self):
303          self.run_esptool("write_flash 0x2000 images/sector.bin")
304          time.sleep(0.1)
305          three_sectors = self.readback(0, 0x3000)
306          last_sector = three_sectors[0x2000:]
307          with open("images/sector.bin", "rb") as f:
308              ct = f.read()
309          assert last_sector == ct
310      @pytest.mark.quick_test
311      def test_no_compression_flash(self):
312          self.run_esptool(
313              "write_flash -u 0x0 images/sector.bin 0x1000 images/fifty_kb.bin"
314          )
315          self.verify_readback(0, 4096, "images/sector.bin")
316          self.verify_readback(4096, 50 * 1024, "images/fifty_kb.bin")
317      @pytest.mark.quick_test
318      @pytest.mark.skipif(arg_chip == "esp8266", reason="Added in ESP32")
319      def test_compressed_nostub_flash(self):
320          self.run_esptool(
321              "--no-stub write_flash -z 0x0 images/sector.bin 0x1000 images/fifty_kb.bin"
322          )
323          self.verify_readback(0, 4096, "images/sector.bin")
324          self.verify_readback(4096, 50 * 1024, "images/fifty_kb.bin")
325      def _test_partition_table_then_bootloader(self, args):
326          self.run_esptool(args + " 0x4000 images/partitions_singleapp.bin")
327          self.verify_readback(0x4000, 96, "images/partitions_singleapp.bin")
328          self.run_esptool(args + " 0x1000 images/bootloader_esp32.bin")
329          self.verify_readback(0x1000, 7888, "images/bootloader_esp32.bin", True)
330          self.verify_readback(0x4000, 96, "images/partitions_singleapp.bin")
331      def test_partition_table_then_bootloader(self):
332          self._test_partition_table_then_bootloader("write_flash --force")
333      def test_partition_table_then_bootloader_no_compression(self):
334          self._test_partition_table_then_bootloader("write_flash --force -u")
335      def test_partition_table_then_bootloader_nostub(self):
336          self._test_partition_table_then_bootloader("--no-stub write_flash --force")
337      def test_length_not_aligned_4bytes(self):
338          self.run_esptool("write_flash 0x0 images/not_4_byte_aligned.bin")
339      def test_length_not_aligned_4bytes_no_compression(self):
340          self.run_esptool("write_flash -u 0x0 images/not_4_byte_aligned.bin")
341      @pytest.mark.quick_test
342      @pytest.mark.host_test
343      def test_write_overlap(self):
344          output = self.run_esptool_error(
345              "write_flash 0x0 images/bootloader_esp32.bin 0x1000 images/one_kb.bin"
346          )
347          assert "Detected overlap at address: 0x1000 " in output
348      @pytest.mark.quick_test
349      @pytest.mark.host_test
350      def test_repeated_address(self):
351          output = self.run_esptool_error(
352              "write_flash 0x0 images/one_kb.bin 0x0 images/one_kb.bin"
353          )
354          assert "Detected overlap at address: 0x0 " in output
355      @pytest.mark.quick_test
356      @pytest.mark.host_test
357      def test_write_sector_overlap(self):
358          output = self.run_esptool_error(
359              "write_flash 0xd00 images/one_kb.bin 0x1d00 images/one_kb.bin"
360          )
361          assert "Detected overlap at address: 0x1d00" in output
362      def test_write_no_overlap(self):
363          output = self.run_esptool(
364              "write_flash 0x0 images/one_kb.bin 0x2000 images/one_kb.bin"
365          )
366          assert "Detected overlap at address" not in output
367      def test_compressible_file(self):
368          try:
369              input_file = tempfile.NamedTemporaryFile(delete=False)
370              file_size = 1024 * 1024
371              input_file.write(b"\x00" * file_size)
372              input_file.close()
373              self.run_esptool(f"write_flash 0x10000 {input_file.name}")
374          finally:
375              os.unlink(input_file.name)
376      def test_compressible_non_trivial_file(self):
377          try:
378              input_file = tempfile.NamedTemporaryFile(delete=False)
379              file_size = 1000 * 1000
380              same_bytes = 8000
381              for _ in range(file_size // same_bytes):
382                  input_file.write(
383                      struct.pack("B", random.randrange(0, 1 << 8)) * same_bytes
384                  )
385              input_file.close()
386              self.run_esptool(f"write_flash 0x10000 {input_file.name}")
387          finally:
388              os.unlink(input_file.name)
389      @pytest.mark.quick_test
390      def test_zero_length(self):
391          output = self.run_esptool(
392              "write_flash 0x10000 images/one_kb.bin 0x11000 images/zerolength.bin"
393          )
394          self.verify_readback(0x10000, 1024, "images/one_kb.bin")
395          assert "zerolength.bin is empty" in output
396      @pytest.mark.quick_test
397      def test_single_byte(self):
398          self.run_esptool("write_flash 0x0 images/onebyte.bin")
399          self.verify_readback(0x0, 1, "images/onebyte.bin")
400      def test_erase_range_messages(self):
401          output = self.run_esptool(
402              "write_flash 0x1000 images/sector.bin 0x0FC00 images/one_kb.bin"
403          )
404          assert "Flash will be erased from 0x00001000 to 0x00001fff..." in output
405          assert (
406              "WARNING: Flash address 0x0000fc00 is not aligned to a 0x1000 "
407              "byte flash sector. 0xc00 bytes before this address will be erased."
408              in output
409          )
410          assert "Flash will be erased from 0x0000f000 to 0x0000ffff..." in output
411      @pytest.mark.skipif(
412          arg_chip == "esp8266", reason="chip_id field exist in ESP32 and later images"
413      )
414      @pytest.mark.skipif(
415          arg_chip == "esp32s3", reason="This is a valid ESP32-S3 image, would pass"
416      )
417      def test_write_image_for_another_target(self):
418          output = self.run_esptool_error(
419              "write_flash 0x0 images/esp32s3_header.bin 0x1000 images/one_kb.bin"
420          )
421          assert "Unexpected chip id in image." in output
422          assert "value was 9. Is this image for a different chip model?" in output
423          assert "images/esp32s3_header.bin is not an " in output
424          assert "image. Use --force to flash anyway." in output
425      @pytest.mark.skipif(
426          arg_chip == "esp8266", reason="chip_id field exist in ESP32 and later images"
427      )
428      @pytest.mark.skipif(
429          arg_chip != "esp32s3", reason="This check happens only on a valid image"
430      )
431      def test_write_image_for_another_revision(self):
432          output = self.run_esptool_error(
433              "write_flash 0x0 images/one_kb.bin 0x1000 images/esp32s3_header.bin"
434          )
435          assert "images/esp32s3_header.bin requires chip revision 10" in output
436          assert "or higher (this chip is revision" in output
437          assert "Use --force to flash anyway." in output
438      @pytest.mark.skipif(
439          arg_chip != "esp32c3", reason="This check happens only on a valid image"
440      )
441      def test_flash_with_min_max_rev(self):
442          output = self.run_esptool_error(
443              "write_flash 0x0 images/one_kb.bin 0x1000 images/esp32c3_header_min_rev.bin"
444          )
445          assert (
446              "images/esp32c3_header_min_rev.bin "
447              "requires chip revision in range [v0.10 - max rev not set]" in output
448          )
449          assert "Use --force to flash anyway." in output
450      @pytest.mark.quick_test
451      def test_erase_before_write(self):
452          output = self.run_esptool("write_flash --erase-all 0x0 images/one_kb.bin")
453          assert "Chip erase completed successfully" in output
454          assert "Hash of data verified" in output
455  @pytest.mark.skipif(
456      arg_chip in ["esp8266", "esp32"],
457      reason="get_security_info command is supported on ESP32S2 and later",
458  )
459  class TestSecurityInfo(EsptoolTestCase):
460      def test_show_security_info(self):
461          res = self.run_esptool("get_security_info")
462          assert "Flags" in res
463          assert "Flash_Crypt_Cnt" in res
464          assert "Key_Purposes" in res
465          if arg_chip != "esp32s2":
466              esp = esptool.get_default_connected_device(
467                  [arg_port], arg_port, 10, 115200, arg_chip
468              )
469              assert f"Chip_ID: {esp.IMAGE_CHIP_ID}" in res
470              assert "Api_Version" in res
471  class TestFlashSizes(EsptoolTestCase):
472      def test_high_offset(self):
473          self.run_esptool("write_flash -fs 4MB 0x300000 images/one_kb.bin")
474          self.verify_readback(0x300000, 1024, "images/one_kb.bin")
475      def test_high_offset_no_compression(self):
476          self.run_esptool("write_flash -u -fs 4MB 0x300000 images/one_kb.bin")
477          self.verify_readback(0x300000, 1024, "images/one_kb.bin")
478      def test_large_image(self):
479          self.run_esptool("write_flash -fs 4MB 0x280000 images/one_mb.bin")
480          self.verify_readback(0x280000, 0x100000, "images/one_mb.bin")
481      def test_large_no_compression(self):
482          self.run_esptool("write_flash -u -fs 4MB 0x280000 images/one_mb.bin")
483          self.verify_readback(0x280000, 0x100000, "images/one_mb.bin")
484      @pytest.mark.quick_test
485      @pytest.mark.host_test
486      def test_invalid_size_arg(self):
487          self.run_esptool_error("write_flash -fs 10MB 0x6000 images/one_kb.bin")
488      def test_write_past_end_fails(self):
489          output = self.run_esptool_error(
490              "write_flash -fs 1MB 0x280000 images/one_kb.bin"
491          )
492          assert "File images/one_kb.bin" in output
493          assert "will not fit" in output
494      def test_write_no_compression_past_end_fails(self):
495          output = self.run_esptool_error(
496              "write_flash -u -fs 1MB 0x280000 images/one_kb.bin"
497          )
498          assert "File images/one_kb.bin" in output
499          assert "will not fit" in output
500      @pytest.mark.skipif(
501          arg_chip not in ["esp8266", "esp32", "esp32c3"],
502          reason="Don't run on every chip, so other bootloader images are not needed",
503      )
504      def test_flash_size_keep(self):
505          offset = 0x1000 if arg_chip in ["esp32", "esp32s2"] else 0x0
506          image = f"images/bootloader_{arg_chip}.bin"
507          with open(image, "rb") as f:
508              f.seek(0, 2)
509              image_len = f.tell()
510          self.run_esptool(f"write_flash -fs keep {offset} {image}")
511          self.verify_readback(offset, image_len, image)
512  class TestFlashDetection(EsptoolTestCase):
513      @pytest.mark.quick_test
514      def test_flash_id(self):
515          res = self.run_esptool("flash_id")
516          assert "Manufacturer:" in res
517          assert "Device:" in res
518      @pytest.mark.quick_test
519      def test_flash_id_expand_args(self):
520          try:
521              arg_file = tempfile.NamedTemporaryFile(delete=False)
522              arg_file.write(b"flash_id\n")
523              arg_file.close()
524              res = self.run_esptool(f"@{arg_file.name}")
525              assert "Manufacturer:" in res
526              assert "Device:" in res
527          finally:
528              os.unlink(arg_file.name)
529      @pytest.mark.quick_test
530      def test_flash_id_trace(self):
531          res = self.run_esptool("--trace flash_id")
532          assert re.search(r"TRACE \+\d.\d{3} command op=0x0a .*", res) is not None
533          assert re.search(r"TRACE \+\d.\d{3} command op=0x09 .*", res) is not None
534          assert re.search(r"TRACE \+\d.\d{3} Read \d* bytes: .*", res) is not None
535          assert re.search(r"TRACE \+\d.\d{3} Write \d* bytes: .*", res) is not None
536          assert re.search(r"TRACE \+\d.\d{3} Received full packet: .*", res) is not None
537          assert (
538              re.search(r"TRACE \+\d.\d{3} Received full packet: 4f484149", res)
539              is not None
540          )
541          assert "Manufacturer:" in res
542          assert "Device:" in res
543  @pytest.mark.skipif(
544      os.name == "nt", reason="Temporarily disabled on windows"
545  )  # TODO: ESPTOOL-673
546  class TestStubReuse(EsptoolTestCase):
547      def test_stub_reuse_with_synchronization(self):
548          res = self.run_esptool(
549              "--after no_reset_stub flash_id"
550          )  # flasher stub keeps running after this
551          assert "Manufacturer:" in res
552          res = self.run_esptool(
553              "--before no_reset flash_id",
554              preload=False,
555          )  # do sync before (without reset it talks to the flasher stub)
556          assert "Manufacturer:" in res
557      @pytest.mark.skipif(arg_chip != "esp8266", reason="ESP8266 only")
558      def test_stub_reuse_without_synchronization(self):
559          res = self.run_esptool("--after no_reset_stub flash_id")
560          assert "Manufacturer:" in res
561          res = self.run_esptool("--before no_reset_no_sync flash_id")
562          assert "Manufacturer:" in res
563  class TestErase(EsptoolTestCase):
564      @pytest.mark.quick_test
565      def test_chip_erase(self):
566          self.run_esptool("write_flash 0x10000 images/one_kb.bin")
567          self.verify_readback(0x10000, 0x400, "images/one_kb.bin")
568          self.run_esptool("erase_flash")
569          empty = self.readback(0x10000, 0x400)
570          assert empty == b"\xFF" * 0x400
571      def test_region_erase(self):
572          self.run_esptool("write_flash 0x10000 images/one_kb.bin")
573          self.run_esptool("write_flash 0x11000 images/sector.bin")
574          self.verify_readback(0x10000, 0x400, "images/one_kb.bin")
575          self.verify_readback(0x11000, 0x1000, "images/sector.bin")
576          self.run_esptool("erase_region 0x10000 0x1000")
577          self.verify_readback(0x11000, 0x1000, "images/sector.bin")
578          empty = self.readback(0x10000, 0x1000)
579          assert empty == b"\xFF" * 0x1000
580      def test_region_erase_all(self):
581          res = self.run_esptool("erase_region 0x0 ALL")
582          assert re.search(r"Detected flash size: \d+[KM]B", res) is not None
583      def test_large_region_erase(self):
584          self.run_esptool("erase_region 0x0 0x100000")
585  class TestSectorBoundaries(EsptoolTestCase):
586      def test_end_sector(self):
587          self.run_esptool("write_flash 0x10000 images/sector.bin")
588          self.run_esptool("write_flash 0x0FC00 images/one_kb.bin")
589          self.verify_readback(0x0FC00, 0x400, "images/one_kb.bin")
590          self.verify_readback(0x10000, 0x1000, "images/sector.bin")
591      def test_end_sector_uncompressed(self):
592          self.run_esptool("write_flash -u 0x10000 images/sector.bin")
593          self.run_esptool("write_flash -u 0x0FC00 images/one_kb.bin")
594          self.verify_readback(0x0FC00, 0x400, "images/one_kb.bin")
595          self.verify_readback(0x10000, 0x1000, "images/sector.bin")
596      def test_overlap(self):
597          self.run_esptool("write_flash 0x20800 images/sector.bin")
598          self.verify_readback(0x20800, 0x1000, "images/sector.bin")
599  class TestVerifyCommand(EsptoolTestCase):
600      @pytest.mark.quick_test
601      def test_verify_success(self):
602          self.run_esptool("write_flash 0x5000 images/one_kb.bin")
603          self.run_esptool("verify_flash 0x5000 images/one_kb.bin")
604      def test_verify_failure(self):
605          self.run_esptool("write_flash 0x6000 images/sector.bin")
606          output = self.run_esptool_error(
607              "verify_flash --diff=yes 0x6000 images/one_kb.bin"
608          )
609          assert "verify FAILED" in output
610          assert "first @ 0x00006000" in output
611      def test_verify_unaligned_length(self):
612          self.run_esptool("write_flash 0x0 images/not_4_byte_aligned.bin")
613          self.run_esptool("verify_flash 0x0 images/not_4_byte_aligned.bin")
614  class TestReadIdentityValues(EsptoolTestCase):
615      @pytest.mark.quick_test
616      def test_read_mac(self):
617          output = self.run_esptool("read_mac")
618          mac = re.search(r"[0-9a-f:]{17}", output)
619          assert mac is not None
620          mac = mac.group(0)
621          assert mac != "00:00:00:00:00:00"
622          assert mac != "ff:ff:ff:ff:ff:ff"
623      @pytest.mark.skipif(arg_chip != "esp8266", reason="ESP8266 only")
624      def test_read_chip_id(self):
625          output = self.run_esptool("chip_id")
626          idstr = re.search("Chip ID: 0x([0-9a-f]+)", output)
627          assert idstr is not None
628          idstr = idstr.group(1)
629          assert idstr != "0" * 8
630          assert idstr != "f" * 8
631  class TestMemoryOperations(EsptoolTestCase):
632      @pytest.mark.quick_test
633      def test_memory_dump(self):
634          output = self.run_esptool("dump_mem 0x50000000 128 memout.bin")
635          assert "Read 128 bytes" in output
636          os.remove("memout.bin")
637      def test_memory_write(self):
638          output = self.run_esptool("write_mem 0x400C0000 0xabad1dea 0x0000ffff")
639          assert "Wrote abad1dea" in output
640          assert "mask 0000ffff" in output
641          assert "to 400c0000" in output
642      def test_memory_read(self):
643          output = self.run_esptool("read_mem 0x400C0000")
644          assert "0x400c0000 =" in output
645  class TestKeepImageSettings(EsptoolTestCase):
646      @classmethod
647      def setup_class(self):
648          super(TestKeepImageSettings, self).setup_class()
649          self.BL_IMAGE = f"images/bootloader_{arg_chip}.bin"
650          self.flash_offset = (
651              0x1000 if arg_chip in ("esp32", "esp32s2") else 0
652          )  # bootloader offset
653          with open(self.BL_IMAGE, "rb") as f:
654              self.header = f.read(8)
655      @pytest.mark.skipif(
656          arg_chip not in ["esp8266", "esp32", "esp32c3"],
657          reason="Don't run on every chip, so other bootloader images are not needed",
658      )
659      def test_keep_does_not_change_settings(self):
660          self.run_esptool(f"write_flash -fs keep {self.flash_offset:#x} {self.BL_IMAGE}")
661          self.verify_readback(self.flash_offset, 8, self.BL_IMAGE, False)
662          self.run_esptool(
663              f"write_flash -fm keep -ff keep -fs keep "
664              f"{self.flash_offset:#x} {self.BL_IMAGE}"
665          )
666          self.verify_readback(self.flash_offset, 8, self.BL_IMAGE, False)
667          self.run_esptool(
668              f"verify_flash -fs keep {self.flash_offset:#x} {self.BL_IMAGE}"
669          )
670      @pytest.mark.skipif(
671          arg_chip not in ["esp8266", "esp32", "esp32c3"],
672          reason="Don't run for every chip, so other bootloader images are not needed",
673      )
674      @pytest.mark.quick_test
675      def test_detect_size_changes_size(self):
676          self.run_esptool(
677              f"write_flash -fs detect {self.flash_offset:#x} {self.BL_IMAGE}"
678          )
679          readback = self.readback(self.flash_offset, 8)
680          assert self.header[:3] == readback[:3]  # first 3 bytes unchanged
681          if arg_chip in ["esp8266", "esp32"]:
682              assert self.header[3] != readback[3]  # size_freq byte changed
683          else:
684              assert self.header[3] == readback[3]  # size_freq byte unchanged
685          assert self.header[4:] == readback[4:]  # rest unchanged
686      @pytest.mark.skipif(
687          arg_chip not in ["esp8266", "esp32"],
688          reason="Bootloader header needs to be modifiable - without sha256",
689      )
690      def test_explicit_set_size_freq_mode(self):
691          self.run_esptool(
692              f"write_flash -fs 2MB -fm dout -ff 80m "
693              f"{self.flash_offset:#x} {self.BL_IMAGE}"
694          )
695          readback = self.readback(self.flash_offset, 8)
696          assert self.header[0] == readback[0]
697          assert self.header[1] == readback[1]
698          assert (0x3F if arg_chip == "esp8266" else 0x1F) == readback[3]  # size_freq
699          assert 3 != self.header[2]  # original image not dout mode
700          assert 3 == readback[2]  # value in flash is dout mode
701          assert self.header[3] != readback[3]  # size/freq values have changed
702          assert self.header[4:] == readback[4:]  # entrypoint address hasn't changed
703          self.run_esptool(
704              f"verify_flash -fs 2MB -fm dout -ff 80m "
705              f"{self.flash_offset:#x} {self.BL_IMAGE}"
706          )
707          self.run_esptool_error(f"verify_flash {self.flash_offset:#x} {self.BL_IMAGE}")
708  @pytest.mark.skipif(
709      arg_chip in ["esp32s2", "esp32s3"],
710      reason="Not supported on targets with USB-CDC.",
711  )
712  class TestLoadRAM(EsptoolTestCase):
713      @pytest.mark.quick_test
714      def test_load_ram(self):
715          self.run_esptool(f"load_ram images/ram_helloworld/helloworld-{arg_chip}.bin")
716          try:
717              p = serial.serial_for_url(arg_port, arg_baud)
718              p.timeout = 5
719              output = p.read(100)
720              print(f"Output: {output}")
721              assert (
722                  b"Hello world!" in output  # xtensa
723                  or b'\xce?\x13\x05\x04\xd0\x97A\x11"\xc4\x06\xc67\x04' in output  # C3
724              )
725          finally:
726              p.close()
727  class TestDeepSleepFlash(EsptoolTestCase):
728      @pytest.mark.skipif(arg_chip != "esp8266", reason="ESP8266 only")
729      def test_deep_sleep_flash(self):
730          self.run_esptool("write_flash 0x0 images/esp8266_deepsleep.bin", baud=230400)
731          time.sleep(0.25)  # give ESP8266 time to enter deep sleep
732          self.run_esptool("write_flash 0x0 images/fifty_kb.bin", baud=230400)
733          self.verify_readback(0, 50 * 1024, "images/fifty_kb.bin")
734  class TestBootloaderHeaderRewriteCases(EsptoolTestCase):
735      @pytest.mark.skipif(
736          arg_chip not in ["esp8266", "esp32", "esp32c3"],
737          reason="Don't run on every chip, so other bootloader images are not needed",
738      )
739      @pytest.mark.quick_test
740      def test_flash_header_rewrite(self):
741          bl_offset = 0x1000 if arg_chip in ("esp32", "esp32s2") else 0
742          bl_image = f"images/bootloader_{arg_chip}.bin"
743          output = self.run_esptool(
744              f"write_flash -fm dout -ff 20m {bl_offset:#x} {bl_image}"
745          )
746          if arg_chip in ["esp8266", "esp32"]:
747              "Flash params set to" in output
748          else:
749              assert "Flash params set to" not in output
750              "not changing the flash mode setting" in output
751              "not changing the flash frequency setting" in output
752      def test_flash_header_no_magic_no_rewrite(self):
753          bl_offset = 0x1000 if arg_chip in ("esp32", "esp32s2") else 0
754          for image in ["images/one_kb.bin", "images/one_kb_all_ef.bin"]:
755              output = self.run_esptool(
756                  f"write_flash -fm dout -ff 20m {bl_offset:#x} {image}"
757              )
758              "not changing any flash settings" in output
759              self.verify_readback(bl_offset, 1024, image)
760  class TestAutoDetect(EsptoolTestCase):
761      def _check_output(self, output):
762          expected_chip_name = esptool.util.expand_chip_name(arg_chip)
763          if arg_chip not in ["esp8266", "esp32", "esp32s2"]:
764              assert "Unsupported detection protocol" not in output
765          assert f"Detecting chip type... {expected_chip_name}" in output
766          assert f"Chip is {expected_chip_name}" in output
767      @pytest.mark.quick_test
768      def test_auto_detect(self):
769          output = self.run_esptool("chip_id", chip="auto")
770          self._check_output(output)
771  @pytest.mark.flaky(reruns=5)
772  @pytest.mark.skipif(arg_preload_port is not False, reason="USB-to-UART bridge only")
773  @pytest.mark.skipif(os.name == "nt", reason="Linux/MacOS only")
774  class TestVirtualPort(TestAutoDetect):
775      def test_auto_detect_virtual_port(self):
776          with ESPRFC2217Server() as server:
777              output = self.run_esptool(
778                  "chip_id",
779                  chip="auto",
780                  port=f"rfc2217://localhost:{str(server.port)}?ign_set_control",
781              )
782              self._check_output(output)
783      def test_highspeed_flash_virtual_port(self):
784          with ESPRFC2217Server() as server:
785              rfc2217_port = f"rfc2217://localhost:{str(server.port)}?ign_set_control"
786              self.run_esptool(
787                  "write_flash 0x0 images/fifty_kb.bin",
788                  baud=921600,
789                  port=rfc2217_port,
790              )
791          self.verify_readback(0, 50 * 1024, "images/fifty_kb.bin")
792  @pytest.mark.quick_test
793  class TestReadWriteMemory(EsptoolTestCase):
794      def _test_read_write(self, esp):
795          test_addr = None
796          for test_region in [
797              "RTC_DRAM",
798              "RTC_DATA",
799              "DRAM",
800          ]:  # find a probably-unused memory type
801              region = esp.get_memory_region(test_region)
802              if region:
803                  test_addr = region[1] - 8 if arg_chip == "esp32c2" else region[0]
804                  break
805          print(f"Using test address {test_addr:#x}")
806          val = esp.read_reg(test_addr)  # verify we can read this word at all
807          try:
808              esp.write_reg(test_addr, 0x1234567)
809              assert esp.read_reg(test_addr) == 0x1234567
810              esp.write_reg(test_addr, 0, delay_us=100)
811              assert esp.read_reg(test_addr) == 0
812              esp.write_reg(test_addr, 0x555, delay_after_us=100)
813              assert esp.read_reg(test_addr) == 0x555
814          finally:
815              esp.write_reg(test_addr, val)  # write the original value, non-destructive
816              esp._port.close()
817      def test_read_write_memory_rom(self):
818          try:
819              esp = esptool.get_default_connected_device(
820                  [arg_port], arg_port, 10, 115200, arg_chip
821              )
822              self._test_read_write(esp)
823          finally:
824              esp._port.close()
825      def test_read_write_memory_stub(self):
826          try:
827              esp = esptool.get_default_connected_device(
828                  [arg_port], arg_port, 10, 115200, arg_chip
829              )
830              esp = esp.run_stub()
831              self._test_read_write(esp)
832          finally:
833              esp._port.close()
834      @pytest.mark.skipif(
835          arg_chip != "esp32", reason="Could be unsupported by different flash"
836      )
837      def test_read_write_flash_status(self):
838          res = self.run_esptool("read_flash_status")
839          match = re.search(r"Status value: (0x[\d|a-f]*)", res)
840          assert match is not None
841          res = self.run_esptool(f"write_flash_status {match.group(1)}")
842          assert f"Initial flash status: {match.group(1)}" in res
843          assert f"Setting flash status: {match.group(1)}" in res
844          assert f"After flash status:   {match.group(1)}" in res
845      def test_read_chip_description(self):
846          try:
847              esp = esptool.get_default_connected_device(
848                  [arg_port], arg_port, 10, 115200, arg_chip
849              )
850              chip = esp.get_chip_description()
851              assert "unknown" not in chip.lower()
852          finally:
853              esp._port.close()
854  @pytest.mark.skipif(
855      arg_chip != "esp8266", reason="Make image option is supported only on ESP8266"
856  )
857  class TestMakeImage(EsptoolTestCase):
858      def verify_image(self, offset, length, image, compare_to):
859          with open(image, "rb") as f:
860              f.seek(offset)
861              rb = f.read(length)
862          with open(compare_to, "rb") as f:
863              ct = f.read()
864          if len(rb) != len(ct):
865              print(
866                  f"WARNING: Expected length {len(ct)} doesn't match comparison {len(rb)}"
867              )
868          print(f"Readback {len(rb)} bytes")
869          for rb_b, ct_b, offs in zip(rb, ct, range(len(rb))):
870              assert (
871                  rb_b == ct_b
872              ), f"First difference at offset {offs:#x} Expected {ct_b} got {rb_b}"
873      def test_make_image(self):
874          output = self.run_esptool(
875              "make_image test"
876              " -a 0x0 -f images/sector.bin -a 0x1000 -f images/fifty_kb.bin"
877          )
878          try:
879              assert "Successfully created esp8266 image." in output
880              assert os.path.exists("test0x00000.bin")
881              self.verify_image(16, 4096, "test0x00000.bin", "images/sector.bin")
882              self.verify_image(
883                  4096 + 24, 50 * 1024, "test0x00000.bin", "images/fifty_kb.bin"
884              )
885          finally:
886              os.remove("test0x00000.bin")
887  @pytest.mark.skipif(arg_chip != "esp32", reason="Don't need to test multiple times")
888  @pytest.mark.quick_test
889  class TestConfigFile(EsptoolTestCase):
890      class ConfigFile:
891          def __init__(self, file_path, file_content):
892              self.file_path = file_path
893              self.file_content = file_content
894          def __enter__(self):
895              with open(self.file_path, "w") as cfg_file:
896                  cfg_file.write(self.file_content)
897                  return cfg_file
898          def __exit__(self, exc_type, exc_value, exc_tb):
899              os.unlink(self.file_path)
900              assert not os.path.exists(self.file_path)
901      dummy_config = (
902          "[esptool]\n"
903          "connect_attempts = 5\n"
904          "reset_delay = 1\n"
905          "serial_write_timeout = 12"
906      )
907      @pytest.mark.host_test
908      def test_load_config_file(self):
909          config_file_path = os.path.join(os.getcwd(), "esptool.cfg")
910          with self.ConfigFile(config_file_path, self.dummy_config):
911              output = self.run_esptool("version")
912              assert f"Loaded custom configuration from {config_file_path}" in output
913              assert "Ignoring unknown config file option" not in output
914              assert "Ignoring invalid config file" not in output
915          with self.ConfigFile(config_file_path, "[wrong section name]"):
916              output = self.run_esptool("version")
917              assert f"Loaded custom configuration from {config_file_path}" not in output
918          faulty_config = "[esptool]\n" "connect_attempts = 5\n" "connect_attempts = 9\n"
919          with self.ConfigFile(config_file_path, faulty_config):
920              output = self.run_esptool("version")
921              assert f"Ignoring invalid config file {config_file_path}" in output
922              assert (
923                  "option 'connect_attempts' in section 'esptool' already exists"
924                  in output
925              )
926          faulty_config = "[esptool]\n" "connect_attempts = 9\n" "timout = 2\n" "bits = 2"
927          with self.ConfigFile(config_file_path, faulty_config):
928              output = self.run_esptool("version")
929              assert "Ignoring unknown config file options: bits, timout" in output
930          config_file_path = os.path.join(os.getcwd(), "tox.ini")
931          with self.ConfigFile(config_file_path, self.dummy_config):
932              output = self.run_esptool("version")
933              assert f"Loaded custom configuration from {config_file_path}" in output
934      @pytest.mark.host_test
935      def test_load_config_file_with_env_var(self):
936          config_file_path = os.path.join(TEST_DIR, "custom_file.ini")
937          with self.ConfigFile(config_file_path, self.dummy_config):
938              output = self.run_esptool("version")
939              assert f"Loaded custom configuration from {config_file_path}" not in output
940              tmp = os.environ.get("ESPTOOL_CFGFILE")  # Save the env var if it is set
941              os.environ["ESPTOOL_CFGFILE"] = config_file_path
942              output = self.run_esptool("version")
943              assert f"Loaded custom configuration from {config_file_path}" in output
944              assert "(set with ESPTOOL_CFGFILE)" in output
945              if tmp is not None:  # Restore the env var or unset it
946                  os.environ["ESPTOOL_CFGFILE"] = tmp
947              else:
948                  os.environ.pop("ESPTOOL_CFGFILE", None)
949      def test_custom_reset_sequence(self):
950          reset_seq_config = (
951              "[esptool]\n"
952              "custom_reset_sequence = D0|W0.1|R1|R0|W0.1|R1|R0\n"
953              "connect_attempts = 1\n"
954          )
<span onclick='openModal()' class='match'>955          config_file_path = os.path.join(os.getcwd(), "esptool.cfg")
956          with self.ConfigFile(config_file_path, reset_seq_config):
957              output = self.run_esptool_error("flash_id")
</span>958              assert f"Loaded custom configuration from {config_file_path}" in output
959              assert "A fatal error occurred: Failed to connect to" in output
960              assert "Connecting............." not in output
961          invalid_reset_seq_config = "[esptool]\n" "custom_reset_sequence = F0|R1|C0|A5\n"
962          with self.ConfigFile(config_file_path, invalid_reset_seq_config):
963              output = self.run_esptool_error("flash_id")
964              assert f"Loaded custom configuration from {config_file_path}" in output
965              assert 'Invalid "custom_reset_sequence" option format:' in output
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from yolact-MDEwOlJlcG9zaXRvcnkxMzg3OTY2OTk=-flat-multibox_loss.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-test_esptool.py</div>
                </div>
                <div class="column column_space"><pre><code>218          obj_neg_loss = - F.logsigmoid(-obj_data_neg).sum()
219          with torch.no_grad():
220              pos_priors = priors.unsqueeze(0).expand(batch_size, -1, -1).reshape(-1, 4)[pos_mask, :]
</pre></code></div>
                <div class="column column_space"><pre><code>955          config_file_path = os.path.join(os.getcwd(), "esptool.cfg")
956          with self.ConfigFile(config_file_path, reset_seq_config):
957              output = self.run_esptool_error("flash_id")
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    