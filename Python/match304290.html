<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for digitalocean.py &amp; win_lgpo_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for digitalocean.py &amp; win_lgpo_1.py
      </h3>
<h1 align="center">
        0.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>digitalocean.py (0.7528231%)<th>win_lgpo_1.py (0.13489209%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1022-1026)<td><a href="#" name="0">(428-451)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>digitalocean.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import decimal
2 import logging
3 import os
4 import pprint
5 import time
6 import salt.config as config
7 import salt.utils.cloud
8 import salt.utils.files
9 import salt.utils.json
10 import salt.utils.stringutils
11 from salt.exceptions import (
12     SaltCloudConfigError,
13     SaltCloudExecutionFailure,
14     SaltCloudExecutionTimeout,
15     SaltCloudNotFound,
16     SaltCloudSystemExit,
17     SaltInvocationError,
18 )
19 try:
20     import requests
21     HAS_REQUESTS = True
22 except ImportError:
23     HAS_REQUESTS = False
24 log = logging.getLogger(__name__)
25 __virtualname__ = "digitalocean"
26 __virtual_aliases__ = ("digital_ocean", "do")
27 def __virtual__():
28     if get_configured_provider() is False:
29         return False
30     if get_dependencies() is False:
31         return False
32     return __virtualname__
33 def _get_active_provider_name():
34     try:
35         return __active_provider_name__.value()
36     except AttributeError:
37         return __active_provider_name__
38 def get_configured_provider():
39     return config.is_provider_configured(
40         opts=__opts__,
41         provider=_get_active_provider_name() or __virtualname__,
42         aliases=__virtual_aliases__,
43         required_keys=("personal_access_token",),
44     )
45 def get_dependencies():
46     return config.check_driver_dependencies(__virtualname__, {"requests": HAS_REQUESTS})
47 def avail_locations(call=None):
48     if call == "action":
49         raise SaltCloudSystemExit(
50             "The avail_locations function must be called with "
51             "-f or --function, or with the --list-locations option"
52         )
53     items = query(method="regions")
54     ret = {}
55     for region in items["regions"]:
56         ret[region["name"]] = {}
57         for item in region.keys():
58             ret[region["name"]][item] = str(region[item])
59     return ret
60 def avail_images(call=None):
61     if call == "action":
62         raise SaltCloudSystemExit(
63             "The avail_images function must be called with "
64             "-f or --function, or with the --list-images option"
65         )
66     fetch = True
67     page = 1
68     ret = {}
69     while fetch:
70         items = query(method="images", command="?page=" + str(page) + "&amp;per_page=200")
71         for image in items["images"]:
72             ret[image["name"]] = {}
73             for item in image.keys():
74                 ret[image["name"]][item] = image[item]
75         page += 1
76         try:
77             fetch = "next" in items["links"]["pages"]
78         except KeyError:
79             fetch = False
80     return ret
81 def avail_sizes(call=None):
82     if call == "action":
83         raise SaltCloudSystemExit(
84             "The avail_sizes function must be called with "
85             "-f or --function, or with the --list-sizes option"
86         )
87     items = query(method="sizes", command="?per_page=100")
88     ret = {}
89     for size in items["sizes"]:
90         ret[size["slug"]] = {}
91         for item in size.keys():
92             ret[size["slug"]][item] = str(size[item])
93     return ret
94 def list_nodes(call=None):
95     if call == "action":
96         raise SaltCloudSystemExit(
97             "The list_nodes function must be called with -f or --function."
98         )
99     return _list_nodes()
100 def list_nodes_full(call=None, for_output=True):
101     if call == "action":
102         raise SaltCloudSystemExit(
103             "The list_nodes_full function must be called with -f or --function."
104         )
105     return _list_nodes(full=True, for_output=for_output)
106 def list_nodes_select(call=None):
107     return salt.utils.cloud.list_nodes_select(
108         list_nodes_full("function"),
109         __opts__["query.selection"],
110         call,
111     )
112 def get_image(vm_):
113     images = avail_images()
114     vm_image = config.get_cloud_config_value(
115         "image", vm_, __opts__, search_global=False
116     )
117     if not isinstance(vm_image, str):
118         vm_image = str(vm_image)
119     for image in images:
120         if vm_image in (
121             images[image]["name"],
122             images[image]["slug"],
123             images[image]["id"],
124         ):
125             if images[image]["slug"] is not None:
126                 return images[image]["slug"]
127             return int(images[image]["id"])
128     raise SaltCloudNotFound(
129         "The specified image, '{}', could not be found.".format(vm_image)
130     )
131 def get_size(vm_):
132     sizes = avail_sizes()
133     vm_size = str(
134         config.get_cloud_config_value("size", vm_, __opts__, search_global=False)
135     )
136     for size in sizes:
137         if vm_size.lower() == sizes[size]["slug"]:
138             return sizes[size]["slug"]
139     raise SaltCloudNotFound(
140         "The specified size, '{}', could not be found.".format(vm_size)
141     )
142 def get_location(vm_):
143     locations = avail_locations()
144     vm_location = str(
145         config.get_cloud_config_value("location", vm_, __opts__, search_global=False)
146     )
147     for location in locations:
148         if vm_location in (locations[location]["name"], locations[location]["slug"]):
149             return locations[location]["slug"]
150     raise SaltCloudNotFound(
151         "The specified location, '{}', could not be found.".format(vm_location)
152     )
153 def create_node(args):
154     node = query(method="droplets", args=args, http_method="post")
155     return node
156 def create(vm_):
157     try:
158         if (
159             vm_["profile"]
160             and config.is_profile_configured(
161                 __opts__,
162                 _get_active_provider_name() or "digitalocean",
163                 vm_["profile"],
164                 vm_=vm_,
165             )
166             is False
167         ):
168             return False
169     except AttributeError:
170         pass
171     __utils__["cloud.fire_event"](
172         "event",
173         "starting create",
174         "salt/cloud/{}/creating".format(vm_["name"]),
175         args=__utils__["cloud.filter_event"](
176             "creating", vm_, ["name", "profile", "provider", "driver"]
177         ),
178         sock_dir=__opts__["sock_dir"],
179         transport=__opts__["transport"],
180     )
181     log.info("Creating Cloud VM %s", vm_["name"])
182     kwargs = {
183         "name": vm_["name"],
184         "size": get_size(vm_),
185         "image": get_image(vm_),
186         "region": get_location(vm_),
187         "ssh_keys": [],
188         "tags": [],
189     }
190     ssh_key_name = config.get_cloud_config_value(
191         "ssh_key_name", vm_, __opts__, search_global=False
192     )
193     if ssh_key_name:
194         kwargs["ssh_keys"].append(get_keyid(ssh_key_name))
195     ssh_key_names = config.get_cloud_config_value(
196         "ssh_key_names", vm_, __opts__, search_global=False, default=False
197     )
198     if ssh_key_names:
199         for key in ssh_key_names.split(","):
200             kwargs["ssh_keys"].append(get_keyid(key))
201     key_filename = config.get_cloud_config_value(
202         "ssh_key_file", vm_, __opts__, search_global=False, default=None
203     )
204     if key_filename is not None and not os.path.isfile(key_filename):
205         raise SaltCloudConfigError(
206             "The defined key_filename '{}' does not exist".format(key_filename)
207         )
208     if not __opts__.get("ssh_agent", False) and key_filename is None:
209         raise SaltCloudConfigError(
210             "The DigitalOcean driver requires an ssh_key_file and an ssh_key_name "
211             "because it does not supply a root password upon building the server."
212         )
213     ssh_interface = config.get_cloud_config_value(
214         "ssh_interface", vm_, __opts__, search_global=False, default="public"
215     )
216     if ssh_interface in ["private", "public"]:
217         log.info("ssh_interface: Setting interface for ssh to %s", ssh_interface)
218         kwargs["ssh_interface"] = ssh_interface
219     else:
220         raise SaltCloudConfigError(
221             "The DigitalOcean driver requires ssh_interface to be defined as 'public'"
222             " or 'private'."
223         )
224     private_networking = config.get_cloud_config_value(
225         "private_networking",
226         vm_,
227         __opts__,
228         search_global=False,
229         default=None,
230     )
231     if private_networking is not None:
232         if not isinstance(private_networking, bool):
233             raise SaltCloudConfigError(
234                 "'private_networking' should be a boolean value."
235             )
236         kwargs["private_networking"] = private_networking
237     if not private_networking and ssh_interface == "private":
238         raise SaltCloudConfigError(
239             "The DigitalOcean driver requires ssh_interface if defined as 'private' "
240             "then private_networking should be set as 'True'."
241         )
242     backups_enabled = config.get_cloud_config_value(
243         "backups_enabled",
244         vm_,
245         __opts__,
246         search_global=False,
247         default=None,
248     )
249     if backups_enabled is not None:
250         if not isinstance(backups_enabled, bool):
251             raise SaltCloudConfigError("'backups_enabled' should be a boolean value.")
252         kwargs["backups"] = backups_enabled
253     ipv6 = config.get_cloud_config_value(
254         "ipv6",
255         vm_,
256         __opts__,
257         search_global=False,
258         default=None,
259     )
260     if ipv6 is not None:
261         if not isinstance(ipv6, bool):
262             raise SaltCloudConfigError("'ipv6' should be a boolean value.")
263         kwargs["ipv6"] = ipv6
264     monitoring = config.get_cloud_config_value(
265         "monitoring",
266         vm_,
267         __opts__,
268         search_global=False,
269         default=None,
270     )
271     if monitoring is not None:
272         if not isinstance(monitoring, bool):
273             raise SaltCloudConfigError("'monitoring' should be a boolean value.")
274         kwargs["monitoring"] = monitoring
275     kwargs["tags"] = config.get_cloud_config_value(
276         "tags", vm_, __opts__, search_global=False, default=False
277     )
278     userdata_file = config.get_cloud_config_value(
279         "userdata_file", vm_, __opts__, search_global=False, default=None
280     )
281     if userdata_file is not None:
282         try:
283             with salt.utils.files.fopen(userdata_file, "r") as fp_:
284                 kwargs["user_data"] = salt.utils.cloud.userdata_template(
285                     __opts__, vm_, salt.utils.stringutils.to_unicode(fp_.read())
286                 )
287         except Exception as exc:  # pylint: disable=broad-except
288             log.exception("Failed to read userdata from %s: %s", userdata_file, exc)
289     create_dns_record = config.get_cloud_config_value(
290         "create_dns_record",
291         vm_,
292         __opts__,
293         search_global=False,
294         default=None,
295     )
296     if create_dns_record:
297         log.info("create_dns_record: will attempt to write DNS records")
298         default_dns_domain = None
299         dns_domain_name = vm_["name"].split(".")
300         if len(dns_domain_name) &gt; 2:
301             log.debug(
302                 "create_dns_record: inferring default dns_hostname, dns_domain from"
303                 " minion name as FQDN"
304             )
305             default_dns_hostname = ".".join(dns_domain_name[:-2])
306             default_dns_domain = ".".join(dns_domain_name[-2:])
307         else:
308             log.debug("create_dns_record: can't infer dns_domain from %s", vm_["name"])
309             default_dns_hostname = dns_domain_name[0]
310         dns_hostname = config.get_cloud_config_value(
311             "dns_hostname",
312             vm_,
313             __opts__,
314             search_global=False,
315             default=default_dns_hostname,
316         )
317         dns_domain = config.get_cloud_config_value(
318             "dns_domain",
319             vm_,
320             __opts__,
321             search_global=False,
322             default=default_dns_domain,
323         )
324         if dns_hostname and dns_domain:
325             log.info(
326                 'create_dns_record: using dns_hostname="%s", dns_domain="%s"',
327                 dns_hostname,
328                 dns_domain,
329             )
330             __add_dns_addr__ = lambda t, d: post_dns_record(
331                 dns_domain=dns_domain, name=dns_hostname, record_type=t, record_data=d
332             )
333             log.debug("create_dns_record: %s", __add_dns_addr__)
334         else:
335             log.error(
336                 "create_dns_record: could not determine dns_hostname and/or dns_domain"
337             )
338             raise SaltCloudConfigError(
339                 "'create_dns_record' must be a dict specifying \"domain\" "
340                 'and "hostname" or the minion name must be an FQDN.'
341             )
342     __utils__["cloud.fire_event"](
343         "event",
344         "requesting instance",
345         "salt/cloud/{}/requesting".format(vm_["name"]),
346         args=__utils__["cloud.filter_event"]("requesting", kwargs, list(kwargs)),
347         sock_dir=__opts__["sock_dir"],
348         transport=__opts__["transport"],
349     )
350     try:
351         ret = create_node(kwargs)
352     except Exception as exc:  # pylint: disable=broad-except
353         log.error(
354             "Error creating %s on DIGITALOCEAN\n\n"
355             "The following exception was thrown when trying to "
356             "run the initial deployment: %s",
357             vm_["name"],
358             exc,
359             exc_info_on_loglevel=logging.DEBUG,
360         )
361         return False
362     def __query_node_data(vm_name):
363         data = show_instance(vm_name, "action")
364         if not data:
365             return False
366         if data["networks"].get("v4"):
367             for network in data["networks"]["v4"]:
368                 if network["type"] == "public":
369                     return data
370         return False
371     try:
372         data = salt.utils.cloud.wait_for_ip(
373             __query_node_data,
374             update_args=(vm_["name"],),
375             timeout=config.get_cloud_config_value(
376                 "wait_for_ip_timeout", vm_, __opts__, default=10 * 60
377             ),
378             interval=config.get_cloud_config_value(
379                 "wait_for_ip_interval", vm_, __opts__, default=10
380             ),
381         )
382     except (SaltCloudExecutionTimeout, SaltCloudExecutionFailure) as exc:
383         try:
384             destroy(vm_["name"])
385         except SaltCloudSystemExit:
386             pass
387         finally:
388             raise SaltCloudSystemExit(str(exc))
389     if not vm_.get("ssh_host"):
390         vm_["ssh_host"] = None
391     addr_families, dns_arec_types = (("v4", "v6"), ("A", "AAAA"))
392     arec_map = dict(list(zip(addr_families, dns_arec_types)))
393     for facing, addr_family, ip_address in [
394         (net["type"], family, net["ip_address"])
395         for family in addr_families
396         for net in data["networks"][family]
397     ]:
398         log.info('found %s IP%s interface for "%s"', facing, addr_family, ip_address)
399         dns_rec_type = arec_map[addr_family]
400         if facing == "public":
401             if create_dns_record:
402                 __add_dns_addr__(dns_rec_type, ip_address)
403         if facing == ssh_interface:
404             if not vm_["ssh_host"]:
405                 vm_["ssh_host"] = ip_address
406     if vm_["ssh_host"] is None:
407         raise SaltCloudSystemExit(
408             "No suitable IP addresses found for ssh minion bootstrapping: {}".format(
409                 repr(data["networks"])
410             )
411         )
412     log.debug(
413         "Found public IP address to use for ssh minion bootstrapping: %s",
414         vm_["ssh_host"],
415     )
416     vm_["key_filename"] = key_filename
417     ret = __utils__["cloud.bootstrap"](vm_, __opts__)
418     ret.update(data)
419     log.info("Created Cloud VM '%s'", vm_["name"])
420     log.debug("'%s' VM creation details:\n%s", vm_["name"], pprint.pformat(data))
421     __utils__["cloud.fire_event"](
422         "event",
423         "created instance",
424         "salt/cloud/{}/created".format(vm_["name"]),
425         args=__utils__["cloud.filter_event"](
426             "created", vm_, ["name", "profile", "provider", "driver"]
427         ),
428         sock_dir=__opts__["sock_dir"],
429         transport=__opts__["transport"],
430     )
431     return ret
432 def query(
433     method="droplets", droplet_id=None, command=None, args=None, http_method="get"
434 ):
435     base_path = str(
436         config.get_cloud_config_value(
437             "api_root",
438             get_configured_provider(),
439             __opts__,
440             search_global=False,
441             default="https://api.digitalocean.com/v2",
442         )
443     )
444     path = "{}/{}/".format(base_path, method)
445     if droplet_id:
446         path += "{}/".format(droplet_id)
447     if command:
448         path += command
449     if not isinstance(args, dict):
450         args = {}
451     personal_access_token = config.get_cloud_config_value(
452         "personal_access_token",
453         get_configured_provider(),
454         __opts__,
455         search_global=False,
456     )
457     data = salt.utils.json.dumps(args)
458     requester = getattr(requests, http_method)
459     request = requester(
460         path,
461         data=data,
462         headers={
463             "Authorization": "Bearer " + personal_access_token,
464             "Content-Type": "application/json",
465         },
466     )
467     if request.status_code &gt; 299:
468         raise SaltCloudSystemExit(
469             "An error occurred while querying DigitalOcean. HTTP Code: {}  "
470             "Error: '{}'".format(
471                 request.status_code,
472                 request.text,
473             )
474         )
475     log.debug(request.url)
476     if request.status_code == 204:
477         return True
478     content = request.text
479     result = salt.utils.json.loads(content)
480     if result.get("status", "").lower() == "error":
481         raise SaltCloudSystemExit(pprint.pformat(result.get("error_message", {})))
482     return result
483 def script(vm_):
484     deploy_script = salt.utils.cloud.os_script(
485         config.get_cloud_config_value("script", vm_, __opts__),
486         vm_,
487         __opts__,
488         salt.utils.cloud.salt_config_to_yaml(
489             salt.utils.cloud.minion_config(__opts__, vm_)
490         ),
491     )
492     return deploy_script
493 def show_instance(name, call=None):
494     if call != "action":
495         raise SaltCloudSystemExit(
496             "The show_instance action must be called with -a or --action."
497         )
498     node = _get_node(name)
499     __utils__["cloud.cache_node"](node, _get_active_provider_name(), __opts__)
500     return node
501 def _get_node(name):
502     attempts = 10
503     while attempts &gt;= 0:
504         try:
505             return list_nodes_full(for_output=False)[name]
506         except KeyError:
507             attempts -= 1
508             log.debug(
509                 "Failed to get the data for node '%s'. Remaining attempts: %s",
510                 name,
511                 attempts,
512             )
513             time.sleep(0.5)
514     return {}
515 def list_keypairs(call=None):
516     if call != "function":
517         log.error("The list_keypairs function must be called with -f or --function.")
518         return False
519     fetch = True
520     page = 1
521     ret = {}
522     while fetch:
523         items = query(
524             method="account/keys",
525             command="?page=" + str(page) + "&amp;per_page=100",
526         )
527         for key_pair in items["ssh_keys"]:
528             name = key_pair["name"]
529             if name in ret:
530                 raise SaltCloudSystemExit(
531                     "A duplicate key pair name, '{}', was found in DigitalOcean's "
532                     "key pair list. Please change the key name stored by DigitalOcean. "
533                     "Be sure to adjust the value of 'ssh_key_file' in your cloud "
534                     "profile or provider configuration, if necessary.".format(name)
535                 )
536             ret[name] = {}
537             for item in key_pair.keys():
538                 ret[name][item] = str(key_pair[item])
539         page += 1
540         try:
541             fetch = "next" in items["links"]["pages"]
542         except KeyError:
543             fetch = False
544     return ret
545 def show_keypair(kwargs=None, call=None):
546     if call != "function":
547         log.error("The show_keypair function must be called with -f or --function.")
548         return False
549     if not kwargs:
550         kwargs = {}
551     if "keyname" not in kwargs:
552         log.error("A keyname is required.")
553         return False
554     keypairs = list_keypairs(call="function")
555     keyid = keypairs[kwargs["keyname"]]["id"]
556     log.debug("Key ID is %s", keyid)
557     details = query(method="account/keys", command=keyid)
558     return details
559 def import_keypair(kwargs=None, call=None):
560     with salt.utils.files.fopen(kwargs["file"], "r") as public_key_filename:
561         public_key_content = salt.utils.stringutils.to_unicode(
562             public_key_filename.read()
563         )
564     digitalocean_kwargs = {"name": kwargs["keyname"], "public_key": public_key_content}
565     created_result = create_key(digitalocean_kwargs, call=call)
566     return created_result
567 def create_key(kwargs=None, call=None):
568     if call != "function":
569         log.error("The create_key function must be called with -f or --function.")
570         return False
571     try:
572         result = query(
573             method="account",
574             command="keys",
575             args={"name": kwargs["name"], "public_key": kwargs["public_key"]},
576             http_method="post",
577         )
578     except KeyError:
579         log.info("`name` and `public_key` arguments must be specified")
580         return False
581     return result
582 def remove_key(kwargs=None, call=None):
583     if call != "function":
584         log.error("The create_key function must be called with -f or --function.")
585         return False
586     try:
587         result = query(
588             method="account", command="keys/" + kwargs["id"], http_method="delete"
589         )
590     except KeyError:
591         log.info("`id` argument must be specified")
592         return False
593     return result
594 def get_keyid(keyname):
595     if not keyname:
596         return None
597     keypairs = list_keypairs(call="function")
598     keyid = keypairs[keyname]["id"]
599     if keyid:
600         return keyid
601     raise SaltCloudNotFound("The specified ssh key could not be found.")
602 def destroy(name, call=None):
603     if call == "function":
604         raise SaltCloudSystemExit(
605             "The destroy action must be called with -d, --destroy, -a or --action."
606         )
607     __utils__["cloud.fire_event"](
608         "event",
609         "destroying instance",
610         "salt/cloud/{}/destroying".format(name),
611         args={"name": name},
612         sock_dir=__opts__["sock_dir"],
613         transport=__opts__["transport"],
614     )
615     data = show_instance(name, call="action")
616     node = query(method="droplets", droplet_id=data["id"], http_method="delete")
617     delete_dns_record = True
618     if not isinstance(delete_dns_record, bool):
619         raise SaltCloudConfigError("'delete_dns_record' should be a boolean value.")
620     log.debug("Deleting DNS records for %s.", name)
621     destroy_dns_records(name)
622     __utils__["cloud.fire_event"](
623         "event",
624         "destroyed instance",
625         "salt/cloud/{}/destroyed".format(name),
626         args={"name": name},
627         sock_dir=__opts__["sock_dir"],
628         transport=__opts__["transport"],
629     )
630     if __opts__.get("update_cachedir", False) is True:
631         __utils__["cloud.delete_minion_cachedir"](
632             name, _get_active_provider_name().split(":")[0], __opts__
633         )
634     return node
635 def post_dns_record(**kwargs):
636     if "kwargs" in kwargs:  # flatten kwargs if called via salt-cloud -f
637         f_kwargs = kwargs["kwargs"]
638         del kwargs["kwargs"]
639         kwargs.update(f_kwargs)
640     mandatory_kwargs = ("dns_domain", "name", "record_type", "record_data")
641     for i in mandatory_kwargs:
642         if kwargs[i]:
643             pass
644         else:
645             error = '{}="{}" ## all mandatory args must be provided: {}'.format(
646                 i, kwargs[i], mandatory_kwargs
647             )
648             raise SaltInvocationError(error)
649     domain = query(method="domains", droplet_id=kwargs["dns_domain"])
650     if domain:
651         result = query(
652             method="domains",
653             droplet_id=kwargs["dns_domain"],
654             command="records",
655             args={
656                 "type": kwargs["record_type"],
657                 "name": kwargs["name"],
658                 "data": kwargs["record_data"],
659             },
660             http_method="post",
661         )
662         return result
663     return False
664 def destroy_dns_records(fqdn):
665     domain = ".".join(fqdn.split(".")[-2:])
666     hostname = ".".join(fqdn.split(".")[:-2])
667     try:
668         response = query(method="domains", droplet_id=domain, command="records")
669     except SaltCloudSystemExit:
670         log.debug("Failed to find domains.")
671         return False
672     log.debug("found DNS records: %s", pprint.pformat(response))
673     records = response["domain_records"]
674     if records:
675         record_ids = [r["id"] for r in records if r["name"].decode() == hostname]
676         log.debug("deleting DNS record IDs: %s", record_ids)
677         for id_ in record_ids:
678             try:
679                 log.info("deleting DNS record %s", id_)
680                 ret = query(
681                     method="domains",
682                     droplet_id=domain,
683                     command="records/{}".format(id_),
684                     http_method="delete",
685                 )
686             except SaltCloudSystemExit:
687                 log.error(
688                     "failed to delete DNS domain %s record ID %s.", domain, hostname
689                 )
690             log.debug("DNS deletion REST call returned: %s", pprint.pformat(ret))
691     return False
692 def show_pricing(kwargs=None, call=None):
693     profile = __opts__["profiles"].get(kwargs["profile"], {})
694     if not profile:
695         return {"Error": "The requested profile was not found"}
696     provider = profile.get("provider", "0:0")
697     comps = provider.split(":")
698     if len(comps) &lt; 2 or comps[1] != "digitalocean":
699         return {"Error": "The requested profile does not belong to DigitalOcean"}
700     ret = {}
701     sizes = avail_sizes()
702     ret["per_hour"] = decimal.Decimal(sizes<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>[profile["size"]]["price_hourly"])
703     ret["per_day"] = ret["per_hour"] * 24
704     ret["per_week"] = ret["per_day"] * 7
705     ret["per_month"] = decimal.</b></font>Decimal(sizes[profile["size"]]["price_monthly"])
706     ret["per_year"] = ret["per_week"] * 52
707     if kwargs.get("raw", False):
708         ret["_raw"] = raw
709     return {profile["profile"]: ret}
710 def list_floating_ips(call=None):
711     if call == "action":
712         raise SaltCloudSystemExit(
713             "The list_floating_ips function must be called with "
714             "-f or --function, or with the --list-floating-ips option"
715         )
716     fetch = True
717     page = 1
718     ret = {}
719     while fetch:
720         items = query(
721             method="floating_ips",
722             command="?page=" + str(page) + "&amp;per_page=200",
723         )
724         for floating_ip in items["floating_ips"]:
725             ret[floating_ip["ip"]] = {}
726             for item in floating_ip.keys():
727                 ret[floating_ip["ip"]][item] = floating_ip[item]
728         page += 1
729         try:
730             fetch = "next" in items["links"]["pages"]
731         except KeyError:
732             fetch = False
733     return ret
734 def show_floating_ip(kwargs=None, call=None):
735     if call != "function":
736         log.error("The show_floating_ip function must be called with -f or --function.")
737         return False
738     if not kwargs:
739         kwargs = {}
740     if "floating_ip" not in kwargs:
741         log.error("A floating IP is required.")
742         return False
743     floating_ip = kwargs["floating_ip"]
744     log.debug("Floating ip is %s", floating_ip)
745     details = query(method="floating_ips", command=floating_ip)
746     return details
747 def create_floating_ip(kwargs=None, call=None):
748     if call != "function":
749         log.error(
750             "The create_floating_ip function must be called with -f or --function."
751         )
752         return False
753     if not kwargs:
754         kwargs = {}
755     if "droplet_id" in kwargs:
756         result = query(
757             method="floating_ips",
758             args={"droplet_id": kwargs["droplet_id"]},
759             http_method="post",
760         )
761         return result
762     elif "region" in kwargs:
763         result = query(
764             method="floating_ips", args={"region": kwargs["region"]}, http_method="post"
765         )
766         return result
767     else:
768         log.error("A droplet_id or region is required.")
769         return False
770 def delete_floating_ip(kwargs=None, call=None):
771     if call != "function":
772         log.error(
773             "The delete_floating_ip function must be called with -f or --function."
774         )
775         return False
776     if not kwargs:
777         kwargs = {}
778     if "floating_ip" not in kwargs:
779         log.error("A floating IP is required.")
780         return False
781     floating_ip = kwargs["floating_ip"]
782     log.debug("Floating ip is %s", kwargs["floating_ip"])
783     result = query(method="floating_ips", command=floating_ip, http_method="delete")
784     return result
785 def assign_floating_ip(kwargs=None, call=None):
786     if call != "function":
787         log.error(
788             "The assign_floating_ip function must be called with -f or --function."
789         )
790         return False
791     if not kwargs:
792         kwargs = {}
793     if "floating_ip" and "droplet_id" not in kwargs:
794         log.error("A floating IP and droplet_id is required.")
795         return False
796     result = query(
797         method="floating_ips",
798         command=kwargs["floating_ip"] + "/actions",
799         args={"droplet_id": kwargs["droplet_id"], "type": "assign"},
800         http_method="post",
801     )
802     return result
803 def unassign_floating_ip(kwargs=None, call=None):
804     if call != "function":
805         log.error(
806             "The inassign_floating_ip function must be called with -f or --function."
807         )
808         return False
809     if not kwargs:
810         kwargs = {}
811     if "floating_ip" not in kwargs:
812         log.error("A floating IP is required.")
813         return False
814     result = query(
815         method="floating_ips",
816         command=kwargs["floating_ip"] + "/actions",
817         args={"type": "unassign"},
818         http_method="post",
819     )
820     return result
821 def _list_nodes(full=False, for_output=False):
822     fetch = True
823     page = 1
824     ret = {}
825     while fetch:
826         items = query(method="droplets", command="?page=" + str(page) + "&amp;per_page=200")
827         for node in items["droplets"]:
828             name = node["name"]
829             ret[name] = {}
830             if full:
831                 ret[name] = _get_full_output(node, for_output=for_output)
832             else:
833                 public_ips, private_ips = _get_ips(node["networks"])
834                 ret[name] = {
835                     "id": node["id"],
836                     "image": node["image"]["name"],
837                     "name": name,
838                     "private_ips": private_ips,
839                     "public_ips": public_ips,
840                     "size": node["size_slug"],
841                     "state": str(node["status"]),
842                 }
843         page += 1
844         try:
845             fetch = "next" in items["links"]["pages"]
846         except KeyError:
847             fetch = False
848     return ret
849 def reboot(name, call=None):
850     if call != "action":
851         raise SaltCloudSystemExit(
852             "The reboot action must be called with -a or --action."
853         )
854     data = show_instance(name, call="action")
855     if data.get("status") == "off":
856         return {
857             "success": True,
858             "action": "stop",
859             "status": "off",
860             "msg": "Machine is already off.",
861         }
862     ret = query(
863         droplet_id=data["id"],
864         command="actions",
865         args={"type": "reboot"},
866         http_method="post",
867     )
868     return {
869         "success": True,
870         "action": ret["action"]["type"],
871         "state": ret["action"]["status"],
872     }
873 def start(name, call=None):
874     if call != "action":
875         raise SaltCloudSystemExit(
876             "The start action must be called with -a or --action."
877         )
878     data = show_instance(name, call="action")
879     if data.get("status") == "active":
880         return {
881             "success": True,
882             "action": "start",
883             "status": "active",
884             "msg": "Machine is already running.",
885         }
886     ret = query(
887         droplet_id=data["id"],
888         command="actions",
889         args={"type": "power_on"},
890         http_method="post",
891     )
892     return {
893         "success": True,
894         "action": ret["action"]["type"],
895         "state": ret["action"]["status"],
896     }
897 def stop(name, call=None):
898     if call != "action":
899         raise SaltCloudSystemExit("The stop action must be called with -a or --action.")
900     data = show_instance(name, call="action")
901     if data.get("status") == "off":
902         return {
903             "success": True,
904             "action": "stop",
905             "status": "off",
906             "msg": "Machine is already off.",
907         }
908     ret = query(
909         droplet_id=data["id"],
910         command="actions",
911         args={"type": "shutdown"},
912         http_method="post",
913     )
914     return {
915         "success": True,
916         "action": ret["action"]["type"],
917         "state": ret["action"]["status"],
918     }
919 def _get_full_output(node, for_output=False):
920     ret = {}
921     for item in node.keys():
922         value = node[item]
923         if value is not None and for_output:
924             value = str(value)
925         ret[item] = value
926     return ret
927 def _get_ips(networks):
928     v4s = networks.get("v4")
929     v6s = networks.get("v6")
930     public_ips = []
931     private_ips = []
932     if v4s:
933         for item in v4s:
934             ip_type = item.get("type")
935             ip_address = item.get("ip_address")
936             if ip_type == "public":
937                 public_ips.append(ip_address)
938             if ip_type == "private":
939                 private_ips.append(ip_address)
940     if v6s:
941         for item in v6s:
942             ip_type = item.get("type")
943             ip_address = item.get("ip_address")
944             if ip_type == "public":
945                 public_ips.append(ip_address)
946             if ip_type == "private":
947                 private_ips.append(ip_address)
948     return public_ips, private_ips
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>win_lgpo_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import csv
2 import ctypes
3 import glob
4 import io
5 import locale
6 import logging
7 import os
8 import re
9 import tempfile
10 import time
11 import uuid
12 import zlib
13 import salt.utils.dictupdate as dictupdate
14 import salt.utils.files
15 import salt.utils.path
16 import salt.utils.platform
17 import salt.utils.stringutils
18 import salt.utils.win_lgpo_netsh
19 from salt.exceptions import CommandExecutionError, SaltInvocationError
20 from salt.serializers.configparser import deserialize
21 log = logging.getLogger(__name__)
22 __virtualname__ = "lgpo"
23 __func_alias__ = {"set_": "set"}
24 UUID = uuid.uuid4().hex
25 adm_policy_name_map = {True: {}, False: {}}
26 HAS_WINDOWS_MODULES = False
27 TRUE_VALUE_XPATH = None
28 FALSE_VALUE_XPATH = None
29 ELEMENTS_XPATH = None
30 ENABLED_VALUE_XPATH = None
31 DISABLED_VALUE_XPATH = None
32 ENABLED_LIST_XPATH = None
33 DISABLED_LIST_XPATH = None
34 VALUE_XPATH = None
35 TRUE_LIST_XPATH = None
36 FALSE_LIST_XPATH = None
37 REGKEY_XPATH = None
38 POLICY_ANCESTOR_XPATH = None
39 ALL_CLASS_POLICY_XPATH = None
40 ADML_DISPLAY_NAME_XPATH = None
41 VALUE_LIST_XPATH = None
42 ENUM_ITEM_DISPLAY_NAME_XPATH = None
43 ADMX_SEARCH_XPATH = None
44 ADML_SEARCH_XPATH = None
45 ADMX_DISPLAYNAME_SEARCH_XPATH = None
46 PRESENTATION_ANCESTOR_XPATH = None
47 TEXT_ELEMENT_XPATH = None
48 try:
49     import struct
50     import lxml
51     import win32net
52     import win32security
53     from lxml import etree
54     from salt.utils.win_reg import Registry
55     HAS_WINDOWS_MODULES = True
56     TRUE_VALUE_XPATH = etree.XPath('.//*[local-name() = "trueValue"]')
57     FALSE_VALUE_XPATH = etree.XPath('.//*[local-name() = "falseValue"]')
58     ELEMENTS_XPATH = etree.XPath('.//*[local-name() = "elements"]')
59     ENABLED_VALUE_XPATH = etree.XPath('.//*[local-name() = "enabledValue"]')
60     DISABLED_VALUE_XPATH = etree.XPath('.//*[local-name() = "disabledValue"]')
61     ENABLED_LIST_XPATH = etree.XPath('.//*[local-name() = "enabledList"]')
62     DISABLED_LIST_XPATH = etree.XPath('.//*[local-name() = "disabledList"]')
63     VALUE_XPATH = etree.XPath('.//*[local-name() = "value"]')
64     TRUE_LIST_XPATH = etree.XPath('.//*[local-name() = "trueList"]')
65     FALSE_LIST_XPATH = etree.XPath('.//*[local-name() = "falseList"]')
66     REGKEY_XPATH = etree.XPath("//*[@key = $keyvalue]")
67     POLICY_ANCESTOR_XPATH = etree.XPath('ancestor::*[local-name() = "policy"]')
68     ALL_CLASS_POLICY_XPATH = etree.XPath(
69         '//*[local-name() = "policy" and (@*[local-name() = "class"] = "Both" or'
70         ' @*[local-name() = "class"] = $registry_class)]'
71     )
72     ADML_DISPLAY_NAME_XPATH = etree.XPath(
73         '//*[local-name() = $displayNameType and @*[local-name() = "id"] ='
74         " $displayNameId]"
75     )
76     VALUE_LIST_XPATH = etree.XPath('.//*[local-name() = "valueList"]')
77     ENUM_ITEM_DISPLAY_NAME_XPATH = etree.XPath(
78         './/*[local-name() = "item" and @*[local-name() = "displayName" ='
79         " $display_name]]"
80     )
81     ADMX_SEARCH_XPATH = etree.XPath(
82         '//*[local-name() = "policy" and @*[local-name() = "name"] = $policy_name and'
83         ' (@*[local-name() = "class"] = "Both" or @*[local-name() = "class"] ='
84         " $registry_class)]"
85     )
86     ADML_SEARCH_XPATH = etree.XPath(
87         '//*[starts-with(text(), $policy_name) and @*[local-name() = "id"]]'
88     )
89     ADMX_DISPLAYNAME_SEARCH_XPATH = etree.XPath(
90         '//*[local-name() = "policy" and @*[local-name() = "displayName"] ='
91         ' $display_name and (@*[local-name() = "class"] = "Both" or @*[local-name() ='
92         ' "class"] = $registry_class) ]'
93     )
94     PRESENTATION_ANCESTOR_XPATH = etree.XPath(
95         'ancestor::*[local-name() = "presentation"]'
96     )
97     TEXT_ELEMENT_XPATH = etree.XPath('.//*[local-name() = "text"]')
98     windll = ctypes.windll.kernel32
99     INSTALL_LANGUAGE = locale.windows_locale.get(
100         windll.GetSystemDefaultUILanguage(), "en_US"
101     ).replace("_", "-")
102 except ImportError:
103     HAS_WINDOWS_MODULES = False
104 class _policy_info:
105     r"""
106     Policy Helper Class
107     ===================
108     The format of the policy dict is as follows:
109     The top most two key/value pairs in the dict divide the policies object into
110     the two sections of local group policy, using the keys "Machine" and "User".
111     The value make-up of these dicts are described below in "Policy Section
112     Definition"
113     Policy Section Definition
114     -------------------------
115     A policy section dict has two required key/value pairs:
116     ============  ==============================================================
117     Key
118     ============  ==============================================================
119     lgpo_section  String matching how the policy section is displayed in the mmc
120                   snap-in ("Computer Configuration" for "Machine" and "User
121                   Configuration" for "User")
122     policies      a dict containing the non-Administrative template policy
123                   definitions, the key for each item is a short/unique
124                   identifier for the policy, the value is described below in
125                   "Policies Definition"
126     ============  ==============================================================
127     Policies Definition
128     -------------------
129     A policies definition item describes the particular policy. There are three
130     child key/value pairs shared with all policy types:
131     ============  ==============================================================
132     Key           Value
133     ============  ==============================================================
134     lgpo_section  A list containing the hierarchical path to the policy in the
135                   gpedit mmc snap-in.
136     Policy        A string containing the name of the policy in the gpedit mmc
137                   snap-in
138     Settings      An object which describes valid settings for the policy. This
139                   can be None for no validation, a list of possible settings, or
140                   a dict with the following key/value pairs:
141                   - **Function:** The class function to use to validate the
142                     setting
143                   - **Args:** A dict of kwargs to pass to the class function
144     ============  ==============================================================
145     Additionally, each policies definition will contain a key/value pair that
146     defines the mechanism that will be used to configure the policy. The
147     available mechanisms are:  NetUserModal, Registry, Secedit, and LsaRights
148     Registry Mechanism
149     ------------------
150     Some policies simply set values in the Windows registry. The value of this
151     key is a dict with the following make-up:
152     =====  =====================================================================
153     Key    Value
154     =====  =====================================================================
155     Hive   A string containing the Registry hive, such as ``HKEY_LOCAL_MACHINE``
156     Path   A string containing the registry key path, such as
157            ``SYSTEM\\CurrentControlSet\\Control\\Lsa``
158     Value  A string containing the name of the registry value, such as
159            **restrictanonymous**
160     Type   A string containing the registry type of the value, such as
161            ``REG_DWORD``
162     =====  =====================================================================
163     Secedit Mechanism
164     -----------------
165     Some policies are configurable via the "secedit.exe" executable. The value
166     of this key is a dict with the following make-up:
167     =======  ===================================================================
168     Key      Value
169     =======  ===================================================================
170     Option   A string containing the name of the policy as it appears in an
171              export from secedit, such as **PasswordComplexity**
172     Section  A string containing the name of the section in which the "Option"
173              value appears in an export from ``secedit``, such as "System
174              Access"
175     =======  ===================================================================
176     LsaRights Mechanism
177     -------------------
178     LSA Rights policies are configured via the LsaRights mechanism. The value of
179     this key is a dict with the following make-up:
180     ======  ====================================================================
181     Key     Value
182     ======  ====================================================================
183     Option  A string containing the programmatic name of the Lsa Right, such as
184             **SeNetworkLogonRight**
185     ======  ====================================================================
186     NetUserModal Mechanism
187     ----------------------
188     Some policies are configurable by the **NetUserModalGet** and
189     **NetUserModalSet** function from pywin32.  The value of this key is a dict
190     with the following make-up:
191     ======  ====================================================================
192     Key     Value
193     ======  ====================================================================
194     Modal   The modal "level" that the particular option is specified in (0-3),
195             see `here &lt;https://msdn.microsoft.com/en-us/library/windows/desktop/
196             aa370656(v=vs.85).aspx&gt;`_
197     Option  The name of the structure member which contains the data for the
198             policy, for example **max_passwd_age**
199     ======  ====================================================================
200     NetSH Mechanism
201     ---------------
202     The firewall policies are configured by the ``netsh.exe`` executable. The
203     value of this key is a dict with the following make-up:
204     =======  ===================================================================
205     Key      Value
206     =======  ===================================================================
207     Profile  The firewall profile to modify. Can be one of Domain, Private, or
208              Public
209     Section  The section of the firewall to modify. Can be one of state,
210              firewallpolicy, settings, or logging.
211     Option   The setting within that section
212     Value    The value of the setting
213     =======  ===================================================================
214     More information can be found in the advfirewall context in netsh. This can
215     be access by opening a netsh prompt. At a command prompt type the following:
216     c:\&gt;netsh
217     netsh&gt;advfirewall
218     netsh advfirewall&gt;set help
219     netsh advfirewall&gt;set domain help
220     AdvAudit Mechanism
221     ------------------
222     The Advanced Audit Policies are configured using a combination of the
223     auditpol command-line utility and modifying the audit.csv file in two
224     locations. The value of this key is a dict with the following make-up:
225     ======  ===================================
226     Key     Value
227     ======  ===================================
228     Option  The Advanced Audit Policy to modify
229     ======  ===================================
230     Transforms
231     ----------
232     Optionally, each policy definition can contain a "Transform" key. The
233     Transform key is used to handle data that is stored and viewed differently.
234     This key's value is a dict with the following key/value pairs:
235     ===  =======================================================================
236     Key  Value
237     ===  =======================================================================
238     Get  The name of the class function to use to transform the data from the
239          stored value to how the value is displayed in the GUI
240     Put The name of the class function to use to transform the data supplied by
241         the user to the correct value that the policy is stored in
242     ===  =======================================================================
243     For example, "Minimum password age" is stored in seconds, but is displayed
244     in days.  Thus the "Get" and "Put" functions for this policy do these
245     conversions so the user is able to set and view the policy using the same
246     data that is shown in the GUI.
247     """
248                 "lookup": self<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.enabled_one_disabled_zero_strings,
249                 "value_lookup": False,
250             },
251             "PutArgs": {
252                 "lookup": self.enabled_one_disabled_zero_strings,
253                 "value_lookup": True,
254             },
255         }
256         self.security_options_gpedit_path = [
257             "Computer Configuration",
258             "Windows Settings",
259             "Security Settings",
260             "Local Policies",
261             "Security Options",
262         ]
263         self.windows_firewall_gpedit_path = [
264             "Computer Configuration",
265             "Windows Settings",
266             "Security Settings",
267             "Windows Firewall with Advanced Security",
268             "Windows Firewall with Advanced Security - Local Group Policy Object",
269         ]
270         self.password_policy_gpedit_path = [
271             "Computer Configuration"</b></font>,
272             "Windows Settings",
273             "Security Settings",
274             "Account Policies",
275             "Password Policy",
276         ]
277         self.audit_policy_gpedit_path = [
278             "Computer Configuration",
279             "Windows Settings",
280             "Security Settings",
281             "Local Policies",
282             "Audit Policy",
283         ]
284         self.advanced_audit_policy_gpedit_path = [
285             "Computer Configuration",
286             "Windows Settings",
287             "Security Settings",
288             "Advanced Audit Policy Configuration",
289             "System Audit Policies - Local Group Policy Object",
290         ]
291         self.account_lockout_policy_gpedit_path = [
292             "Computer Configuration",
293             "Windows Settings",
294             "Security Settings",
295             "Account Policies",
296             "Account Lockout Policy",
297         ]
298         self.user_rights_assignment_gpedit_path = [
299             "Computer Configuration",
300             "Windows Settings",
301             "Security Settings",
302             "Local Policies",
303             "User Rights Assignment",
304         ]
305         self.block_ms_accounts = {
306             0: "This policy is disabled",
307             1: "Users can't add Microsoft accounts",
308             3: "Users can't add or log on with Microsoft accounts",
309             None: "Not Defined",
310             "(value not set)": "Not Defined",
311         }
312         self.ldap_server_signing_requirements = {
313             1: "None",
314             2: "Require signing",
315             None: "Not Defined",
316             "(value not set)": "Not Defined",
317         }
318         self.smb_server_name_hardening_levels = {
319             0: "Off",
320             1: "Accept if provided by client",
321             2: "Required from client",
322             None: "Not Defined",
323             "(value not set)": "Not Defined",
324         }
325         self.locked_session_user_info = {
326             1: "User display name, domain and user names",
327             2: "User display name only",
328             3: "Do not display user information",
329             None: "Not Defined",
330             "(value not set)": "Not Defined",
331         }
332         self.force_guest = {
333             0: "Classic - local users authenticate as themselves",
334             1: "Guest only - local users authenticate as Guest",
335             None: "Not Defined",
336             "(value not set)": "Not Defined",
337         }
338         self.force_key_protection = {
339             0: "User input is not required when new keys are stored and used",
340             1: "User is prompted when the key is first used",
341             2: "User must enter a password each time they use a key",
342             None: "Not Defined",
343             "(value not set)": "Not Defined",
344         }
345         self.firewall_inbound_connections = {
346             "blockinbound": "Block (default)",
347             "blockinboundalways": "Block all connections",
348             "allowinbound": "Allow",
349             "notconfigured": "Not configured",
350         }
351         self.firewall_outbound_connections = {
352             "blockoutbound": "Block",
353             "allowoutbound": "Allow (default)",
354             "notconfigured": "Not configured",
355         }
356         self.firewall_rule_merging = {
357             "enable": "Yes (default)",
358             "disable": "No",
359             "notconfigured": "Not configured",
360         }
361         self.firewall_log_packets_connections = {
362             "enable": "Yes",
363             "disable": "No (default)",
364             "notconfigured": "Not configured",
365         }
366         self.firewall_notification = {
367             "enable": "Yes",
368             "disable": "No",
369             "notconfigured": "Not configured",
370         }
371         self.firewall_state = {
372             "on": "On (recommended)",
373             "off": "Off",
374             "notconfigured": "Not configured",
375         }
376         self.krb_encryption_types = {
377             0: "No minimum",
378             1: "DES_CBC_CRC",
379             2: "DES_CBD_MD5",
380             4: "RC4_HMAC_MD5",
381             8: "AES128_HMAC_SHA1",
382             16: "AES256_HMAC_SHA1",
383             2147483616: "Future Encryption Types",
384             None: "Not Defined",
385             "(value not set)": "Not Defined",
386         }
387         self.lm_compat_levels = {
388             0: "Send LM &amp; NTLM response",
389             1: "Send LM &amp; NTLM - use NTLMv2 session security if negotiated",
390             2: "Send NTLM response only",
391             3: "Send NTLMv2 response only",
392             4: "Send NTLMv2 response only. Refuse LM",
393             5: "Send NTLMv2 response only. Refuse LM &amp; NTLM",
394             None: "Not Defined",
395             "(value not set)": "Not Defined",
396         }
397         self.ldap_signing_reqs = {
398             0: "None",
399             1: "Negotiate signing",
400             2: "Require signing",
401             None: "Not Defined",
402             "(value not set)": "Not Defined",
403         }
404         self.ntlm_session_security_levels = {
405             0: "No minimum",
406             524288: "Require NTLMv2 session security",
407             536870912: "Require 128-bit encryption",
408             None: "Not Defined",
409             "(value not set)": "Not Defined",
410         }
411         self.ntlm_audit_settings = {
412             0: "Disable",
413             1: "Enable auditing for domain accounts",
414             2: "Enable auditing for all accounts",
415             None: "Not Defined",
416             "(value not set)": "Not Defined",
417         }
418         self.ntlm_domain_audit_settings = {
419             0: "Disable",
420             1: "Enable for domain accounts to domain servers",
421             3: "Enable for domain accounts",
422             5: "Enable for domain servers",
423             7: "Enable all",
424             None: "Not Defined",
425             "(value not set)": "Not Defined",
426         }
427         self.incoming_ntlm_settings = {
428             0: "Allow all",
429             1: "Deny all domain accounts",
430             2: "Deny all accounts",
431             None: "Not Defined",
432             "(value not set)": "Not Defined",
433         }
434         self.ntlm_domain_auth_settings = {
435             0: "Disable",
436             1: "Deny for domain accounts to domain servers",
437             3: "Deny for domain accounts",
438             5: "Deny for domain servers",
439             7: "Deny all",
440             None: "Not Defined",
441             "(value not set)": "Not Defined",
442         }
443         self.outgoing_ntlm_settings = {
444             0: "Allow all",
445             1: "Audit all",
446             2: "Deny all",
447             None: "Not Defined",
448             "(value not set)": "Not Defined",
449         }
450         self.enabled_one_disabled_zero_no_not_defined = {
451             0: "Disabled",
452             1: "Enabled",
453         }
454         self.enabled_one_disabled_zero_no_not_defined_transform = {
455             "Get": "_dict_lookup",
456             "Put": "_dict_lookup",
457             "GetArgs": {
458                 "lookup": self.enabled_one_disabled_zero_no_not_defined,
459                 "value_lookup": False,
460             },
461             "PutArgs": {
462                 "lookup": self.enabled_one_disabled_zero_no_not_defined,
463                 "value_lookup": True,
464             },
465         }
466         self.policies = {
467             "Machine": {
468                 "lgpo_section": "Computer Configuration",
469                 "policies": {
470                     "StartupScripts": {
471                         "Policy": "Startup Scripts",
472                         "lgpo_section": [
473                             "Computer Configuration",
474                             "Windows Settings",
475                             "Scripts (Startup/Shutdown)",
476                             "Startup",
477                         ],
478                         "ScriptIni": {
479                             "Section": "Startup",
480                             "IniPath": os.path.join(
481                                 os.getenv("WINDIR"),
482                                 "System32",
483                                 "GroupPolicy",
484                                 "Machine",
485                                 "Scripts",
486                                 "scripts.ini",
487                             ),
488                         },
489                     },
490                     "StartupPowershellScripts": {
491                         "Policy": "Startup Powershell Scripts",
492                         "lgpo_section": [
493                             "Computer Configuration",
494                             "Windows Settings",
495                             "Scripts (Startup/Shutdown)",
496                             "Startup",
497                         ],
498                         "ScriptIni": {
499                             "Section": "Startup",
500                             "IniPath": os.path.join(
501                                 os.getenv("WINDIR"),
502                                 "System32",
503                                 "GroupPolicy",
504                                 "Machine",
505                                 "Scripts",
506                                 "psscripts.ini",
507                             ),
508                         },
509                     },
510                     "StartupPowershellScriptOrder": {
511                         "Policy": (
512                             "Startup - For this GPO, run scripts in the following order"
513                         ),
514                         "lgpo_section": [
515                             "Computer Configuration",
516                             "Windows Settings",
517                             "Scripts (Startup/Shutdown)",
518                             "Startup",
519                         ],
520                         "ScriptIni": {
521                             "IniPath": os.path.join(
522                                 os.getenv("WINDIR"),
523                                 "System32",
524                                 "GroupPolicy",
525                                 "Machine",
526                                 "Scripts",
527                                 "psscripts.ini",
528                             ),
529                             "Section": "ScriptsConfig",
530                             "SettingName": "StartExecutePSFirst",
531                             "Settings": ["true", "false", None],
532                         },
533                         "Transform": {
534                             "Get": "_powershell_script_order_conversion",
535                             "Put": "_powershell_script_order_reverse_conversion",
536                         },
537                     },
538                     "ShutdownScripts": {
539                         "Policy": "Shutdown Scripts",
540                         "lgpo_section": [
541                             "Computer Configuration",
542                             "Windows Settings",
543                             "Scripts (Startup/Shutdown)",
544                             "Shutdown",
545                         ],
546                         "ScriptIni": {
547                             "Section": "Shutdown",
548                             "IniPath": os.path.join(
549                                 os.getenv("WINDIR"),
550                                 "System32",
551                                 "GroupPolicy",
552                                 "Machine",
553                                 "Scripts",
554                                 "scripts.ini",
555                             ),
556                         },
557                     },
558                     "ShutdownPowershellScripts": {
559                         "Policy": "Shutdown Powershell Scripts",
560                         "lgpo_section": [
561                             "Computer Configuration",
562                             "Windows Settings",
563                             "Scripts (Startup/Shutdown)",
564                             "Shutdown",
565                         ],
566                         "ScriptIni": {
567                             "Section": "Shutdown",
568                             "IniPath": os.path.join(
569                                 os.getenv("WINDIR"),
570                                 "System32",
571                                 "GroupPolicy",
572                                 "Machine",
573                                 "Scripts",
574                                 "psscripts.ini",
575                             ),
576                         },
577                     },
578                     "ShutdownPowershellScriptOrder": {
579                         "Policy": (
580                             "Shutdown - For this GPO, run scripts in the "
581                             "following order"
582                         ),
583                         "lgpo_section": [
584                             "Computer Configuration",
585                             "Windows Settings",
586                             "Scripts (Startup/Shutdown)",
587                             "Shutdown",
588                         ],
589                         "ScriptIni": {
590                             "IniPath": os.path.join(
591                                 os.getenv("WINDIR"),
592                                 "System32",
593                                 "GroupPolicy",
594                                 "Machine",
595                                 "Scripts",
596                                 "psscripts.ini",
597                             ),
598                             "Section": "ScriptsConfig",
599                             "SettingName": "EndExecutePSFirst",
600                             "Settings": ["true", "false", None],
601                         },
602                         "Transform": {
603                             "Get": "_powershell_script_order_conversion",
604                             "Put": "_powershell_script_order_reverse_conversion",
605                         },
606                     },
607                     "LSAAnonymousNameLookup": {
608                         "Policy": (
609                             "Network access: Allow anonymous SID/Name translation"
610                         ),
611                         "lgpo_section": self.password_policy_gpedit_path,
612                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
613                         "Secedit": {
614                             "Option": "LSAAnonymousNameLookup",
615                             "Section": "System Access",
616                         },
617                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
618                     },
619                     "RestrictAnonymousSam": {
620                         "Policy": (
621                             "Network access: Do not allow anonymous "
622                             "enumeration of SAM accounts"
623                         ),
624                         "lgpo_section": self.security_options_gpedit_path,
625                         "Settings": self.enabled_one_disabled_zero.keys(),
626                         "Registry": {
627                             "Hive": "HKEY_LOCAL_MACHINE",
628                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
629                             "Value": "RestrictAnonymousSam",
630                             "Type": "REG_DWORD",
631                         },
632                         "Transform": self.enabled_one_disabled_zero_transform,
633                     },
634                     "RestrictRemoteSAM": {
635                         "Policy": (
636                             "Network access: Restrict clients allowed to "
637                             "make remote calls to SAM"
638                         ),
639                         "lgpo_section": self.security_options_gpedit_path,
640                         "Registry": {
641                             "Hive": "HKEY_LOCAL_MACHINE",
642                             "Path": "System\\CurrentControlSet\\Control\\Lsa",
643                             "Value": "RestrictRemoteSAM",
644                             "Type": "REG_SZ",
645                         },
646                         "Transform": {"Put": "_string_put_transform"},
647                     },
648                     "RestrictAnonymous": {
649                         "Policy": (
650                             "Network access: Do not allow anonymous "
651                             "enumeration of SAM accounts and shares"
652                         ),
653                         "lgpo_section": self.security_options_gpedit_path,
654                         "Settings": self.enabled_one_disabled_zero.keys(),
655                         "Registry": {
656                             "Hive": "HKEY_LOCAL_MACHINE",
657                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
658                             "Value": "RestrictAnonymous",
659                             "Type": "REG_DWORD",
660                         },
661                         "Transform": self.enabled_one_disabled_zero_transform,
662                     },
663                     "DisableDomainCreds": {
664                         "Policy": (
665                             "Network access: Do not allow storage of "
666                             "passwords and credentials for network "
667                             "authentication"
668                         ),
669                         "lgpo_section": self.security_options_gpedit_path,
670                         "Settings": self.enabled_one_disabled_zero.keys(),
671                         "Registry": {
672                             "Hive": "HKEY_LOCAL_MACHINE",
673                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
674                             "Value": "DisableDomainCreds",
675                             "Type": "REG_DWORD",
676                         },
677                         "Transform": self.enabled_one_disabled_zero_transform,
678                     },
679                     "EveryoneIncludesAnonymous": {
680                         "Policy": (
681                             "Network access: Let Everyone permissions "
682                             "apply to anonymous users"
683                         ),
684                         "lgpo_section": self.security_options_gpedit_path,
685                         "Settings": self.enabled_one_disabled_zero.keys(),
686                         "Registry": {
687                             "Hive": "HKEY_LOCAL_MACHINE",
688                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
689                             "Value": "everyoneincludesanonymous",
690                             "Type": "REG_DWORD",
691                         },
692                         "Transform": self.enabled_one_disabled_zero_transform,
693                     },
694                     "NullSessionPipes": {
695                         "Policy": (
696                             "Network access: Named Pipes that can be "
697                             "accessed anonymously"
698                         ),
699                         "lgpo_section": self.security_options_gpedit_path,
700                         "Registry": {
701                             "Hive": "HKEY_LOCAL_MACHINE",
702                             "Path": (
703                                 "SYSTEM\\CurrentControlSet\\Services\\"
704                                 "LanmanServer\\Parameters"
705                             ),
706                             "Value": "NullSessionPipes",
707                             "Type": "REG_MULTI_SZ",
708                         },
709                         "Transform": {
710                             "Put": "_multi_string_put_transform",
711                             "Get": "_multi_string_get_transform",
712                         },
713                     },
714                     "RemoteRegistryExactPaths": {
715                         "Policy": "Network access: Remotely accessible registry paths",
716                         "lgpo_section": self.security_options_gpedit_path,
717                         "Registry": {
718                             "Hive": "HKEY_LOCAL_MACHINE",
719                             "Path": (
720                                 "SYSTEM\\CurrentControlSet\\Control\\"
721                                 "SecurePipeServers\\winreg\\"
722                                 "AllowedExactPaths"
723                             ),
724                             "Value": "Machine",
725                             "Type": "REG_MULTI_SZ",
726                         },
727                         "Transform": {
728                             "Put": "_multi_string_put_transform",
729                             "Get": "_multi_string_get_transform",
730                         },
731                     },
732                     "RemoteRegistryPaths": {
733                         "Policy": (
734                             "Network access: Remotely accessible "
735                             "registry paths and sub-paths"
736                         ),
737                         "lgpo_section": self.security_options_gpedit_path,
738                         "Registry": {
739                             "Hive": "HKEY_LOCAL_MACHINE",
740                             "Path": (
741                                 "SYSTEM\\CurrentControlSet\\Control\\"
742                                 "SecurePipeServers\\winreg\\AllowedPaths"
743                             ),
744                             "Value": "Machine",
745                             "Type": "REG_MULTI_SZ",
746                         },
747                         "Transform": {
748                             "Put": "_multi_string_put_transform",
749                             "Get": "_multi_string_get_transform",
750                         },
751                     },
752                     "RestrictNullSessAccess": {
753                         "Policy": (
754                             "Network access: Restrict anonymous access "
755                             "to Named Pipes and Shares"
756                         ),
757                         "lgpo_section": self.security_options_gpedit_path,
758                         "Settings": self.enabled_one_disabled_zero.keys(),
759                         "Registry": {
760                             "Hive": "HKEY_LOCAL_MACHINE",
761                             "Path": (
762                                 "System\\CurrentControlSet\\Services\\"
763                                 "LanmanServer\\Parameters"
764                             ),
765                             "Value": "RestrictNullSessAccess",
766                             "Type": "REG_DWORD",
767                         },
768                         "Transform": self.enabled_one_disabled_zero_transform,
769                     },
770                     "NullSessionShares": {
771                         "Policy": (
772                             "Network access: Shares that can be accessed anonymously"
773                         ),
774                         "lgpo_section": self.security_options_gpedit_path,
775                         "Registry": {
776                             "Hive": "HKEY_LOCAL_MACHINE",
777                             "Path": (
778                                 "SYSTEM\\CurrentControlSet\\Services\\"
779                                 "LanmanServer\\Parameters"
780                             ),
781                             "Value": "NullSessionShares",
782                             "Type": "REG_MULTI_SZ",
783                         },
784                         "Transform": {
785                             "Put": "_multi_string_put_transform",
786                             "Get": "_multi_string_get_transform",
787                         },
788                     },
789                     "ForceGuest": {
790                         "Policy": (
791                             "Network access: Sharing and security model "
792                             "for local accounts"
793                         ),
794                         "lgpo_section": self.security_options_gpedit_path,
795                         "Settings": self.force_guest.keys(),
796                         "Registry": {
797                             "Hive": "HKEY_LOCAL_MACHINE",
798                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
799                             "Value": "ForceGuest",
800                             "Type": "REG_DWORD",
801                         },
802                         "Transform": {
803                             "Get": "_dict_lookup",
804                             "Put": "_dict_lookup",
805                             "GetArgs": {
806                                 "lookup": self.force_guest,
807                                 "value_lookup": False,
808                             },
809                             "PutArgs": {
810                                 "lookup": self.force_guest,
811                                 "value_lookup": True,
812                             },
813                         },
814                     },
815                     "WfwDomainState": {
816                         "Policy": "Network firewall: Domain: State",
817                         "lgpo_section": self.windows_firewall_gpedit_path,
818                         "Settings": self.firewall_state.keys(),
819                         "NetSH": {
820                             "Profile": "domain",
821                             "Section": "state",
822                             "Option": "State",  # Unused, but needed
823                         },
824                         "Transform": {
825                             "Get": "_dict_lookup",
826                             "Put": "_dict_lookup",
827                             "GetArgs": {
828                                 "lookup": self.firewall_state,
829                                 "value_lookup": False,
830                             },
831                             "PutArgs": {
832                                 "lookup": self.firewall_state,
833                                 "value_lookup": True,
834                             },
835                         },
836                     },
837                     "WfwPrivateState": {
838                         "Policy": "Network firewall: Private: State",
839                         "lgpo_section": self.windows_firewall_gpedit_path,
840                         "Settings": self.firewall_state.keys(),
841                         "NetSH": {
842                             "Profile": "private",
843                             "Section": "state",
844                             "Option": "State",  # Unused, but needed
845                         },
846                         "Transform": {
847                             "Get": "_dict_lookup",
848                             "Put": "_dict_lookup",
849                             "GetArgs": {
850                                 "lookup": self.firewall_state,
851                                 "value_lookup": False,
852                             },
853                             "PutArgs": {
854                                 "lookup": self.firewall_state,
855                                 "value_lookup": True,
856                             },
857                         },
858                     },
859                     "WfwPublicState": {
860                         "Policy": "Network firewall: Public: State",
861                         "lgpo_section": self.windows_firewall_gpedit_path,
862                         "Settings": self.firewall_state.keys(),
863                         "NetSH": {
864                             "Profile": "public",
865                             "Section": "state",
866                             "Option": "State",  # Unused, but needed
867                         },
868                         "Transform": {
869                             "Get": "_dict_lookup",
870                             "Put": "_dict_lookup",
871                             "GetArgs": {
872                                 "lookup": self.firewall_state,
873                                 "value_lookup": False,
874                             },
875                             "PutArgs": {
876                                 "lookup": self.firewall_state,
877                                 "value_lookup": True,
878                             },
879                         },
880                     },
881                     "WfwDomainInboundConnections": {
882                         "Policy": "Network firewall: Domain: Inbound connections",
883                         "lgpo_section": self.windows_firewall_gpedit_path,
884                         "Settings": self.firewall_inbound_connections.keys(),
885                         "NetSH": {
886                             "Profile": "domain",
887                             "Section": "firewallpolicy",
888                             "Option": "Inbound",
889                         },
890                         "Transform": {
891                             "Get": "_dict_lookup",
892                             "Put": "_dict_lookup",
893                             "GetArgs": {
894                                 "lookup": self.firewall_inbound_connections,
895                                 "value_lookup": False,
896                             },
897                             "PutArgs": {
898                                 "lookup": self.firewall_inbound_connections,
899                                 "value_lookup": True,
900                             },
901                         },
902                     },
903                     "WfwPrivateInboundConnections": {
904                         "Policy": "Network firewall: Private: Inbound connections",
905                         "lgpo_section": self.windows_firewall_gpedit_path,
906                         "Settings": self.firewall_inbound_connections.keys(),
907                         "NetSH": {
908                             "Profile": "private",
909                             "Section": "firewallpolicy",
910                             "Option": "Inbound",
911                         },
912                         "Transform": {
913                             "Get": "_dict_lookup",
914                             "Put": "_dict_lookup",
915                             "GetArgs": {
916                                 "lookup": self.firewall_inbound_connections,
917                                 "value_lookup": False,
918                             },
919                             "PutArgs": {
920                                 "lookup": self.firewall_inbound_connections,
921                                 "value_lookup": True,
922                             },
923                         },
924                     },
925                     "WfwPublicInboundConnections": {
926                         "Policy": "Network firewall: Public: Inbound connections",
927                         "lgpo_section": self.windows_firewall_gpedit_path,
928                         "Settings": self.firewall_inbound_connections.keys(),
929                         "NetSH": {
930                             "Profile": "public",
931                             "Section": "firewallpolicy",
932                             "Option": "Inbound",
933                         },
934                         "Transform": {
935                             "Get": "_dict_lookup",
936                             "Put": "_dict_lookup",
937                             "GetArgs": {
938                                 "lookup": self.firewall_inbound_connections,
939                                 "value_lookup": False,
940                             },
941                             "PutArgs": {
942                                 "lookup": self.firewall_inbound_connections,
943                                 "value_lookup": True,
944                             },
945                         },
946                     },
947                     "WfwDomainOutboundConnections": {
948                         "Policy": "Network firewall: Domain: Outbound connections",
949                         "lgpo_section": self.windows_firewall_gpedit_path,
950                         "Settings": self.firewall_outbound_connections.keys(),
951                         "NetSH": {
952                             "Profile": "domain",
953                             "Section": "firewallpolicy",
954                             "Option": "Outbound",
955                         },
956                         "Transform": {
957                             "Get": "_dict_lookup",
958                             "Put": "_dict_lookup",
959                             "GetArgs": {
960                                 "lookup": self.firewall_outbound_connections,
961                                 "value_lookup": False,
962                             },
963                             "PutArgs": {
964                                 "lookup": self.firewall_outbound_connections,
965                                 "value_lookup": True,
966                             },
967                         },
968                     },
969                     "WfwPrivateOutboundConnections": {
970                         "Policy": "Network firewall: Private: Outbound connections",
971                         "lgpo_section": self.windows_firewall_gpedit_path,
972                         "Settings": self.firewall_outbound_connections.keys(),
973                         "NetSH": {
974                             "Profile": "private",
975                             "Section": "firewallpolicy",
976                             "Option": "Outbound",
977                         },
978                         "Transform": {
979                             "Get": "_dict_lookup",
980                             "Put": "_dict_lookup",
981                             "GetArgs": {
982                                 "lookup": self.firewall_outbound_connections,
983                                 "value_lookup": False,
984                             },
985                             "PutArgs": {
986                                 "lookup": self.firewall_outbound_connections,
987                                 "value_lookup": True,
988                             },
989                         },
990                     },
991                     "WfwPublicOutboundConnections": {
992                         "Policy": "Network firewall: Public: Outbound connections",
993                         "lgpo_section": self.windows_firewall_gpedit_path,
994                         "Settings": self.firewall_outbound_connections.keys(),
995                         "NetSH": {
996                             "Profile": "public",
997                             "Section": "firewallpolicy",
998                             "Option": "Outbound",
999                         },
1000                         "Transform": {
1001                             "Get": "_dict_lookup",
1002                             "Put": "_dict_lookup",
1003                             "GetArgs": {
1004                                 "lookup": self.firewall_outbound_connections,
1005                                 "value_lookup": False,
1006                             },
1007                             "PutArgs": {
1008                                 "lookup": self.firewall_outbound_connections,
1009                                 "value_lookup": True,
1010                             },
1011                         },
1012                     },
1013                     "WfwDomainSettingsNotification": {
1014                         "Policy": (
1015                             "Network firewall: Domain: Settings: Display a notification"
1016                         ),
1017                         "lgpo_section": self.windows_firewall_gpedit_path,
1018                         "Settings": self.firewall_notification.keys(),
1019                         "NetSH": {
1020                             "Profile": "domain",
1021                             "Section": "settings",
1022                             "Option": "InboundUserNotification",
1023                         },
1024                         "Transform": {
1025                             "Get": "_dict_lookup",
1026                             "Put": "_dict_lookup",
1027                             "GetArgs": {
1028                                 "lookup": self.firewall_notification,
1029                                 "value_lookup": False,
1030                             },
1031                             "PutArgs": {
1032                                 "lookup": self.firewall_notification,
1033                                 "value_lookup": True,
1034                             },
1035                         },
1036                     },
1037                     "WfwPrivateSettingsNotification": {
1038                         "Policy": (
1039                             "Network firewall: Private: Settings: Display a"
1040                             " notification"
1041                         ),
1042                         "lgpo_section": self.windows_firewall_gpedit_path,
1043                         "Settings": self.firewall_notification.keys(),
1044                         "NetSH": {
1045                             "Profile": "private",
1046                             "Section": "settings",
1047                             "Option": "InboundUserNotification",
1048                         },
1049                         "Transform": {
1050                             "Get": "_dict_lookup",
1051                             "Put": "_dict_lookup",
1052                             "GetArgs": {
1053                                 "lookup": self.firewall_notification,
1054                                 "value_lookup": False,
1055                             },
1056                             "PutArgs": {
1057                                 "lookup": self.firewall_notification,
1058                                 "value_lookup": True,
1059                             },
1060                         },
1061                     },
1062                     "WfwPublicSettingsNotification": {
1063                         "Policy": (
1064                             "Network firewall: Public: Settings: Display a notification"
1065                         ),
1066                         "lgpo_section": self.windows_firewall_gpedit_path,
1067                         "Settings": self.firewall_notification.keys(),
1068                         "NetSH": {
1069                             "Profile": "public",
1070                             "Section": "settings",
1071                             "Option": "InboundUserNotification",
1072                         },
1073                         "Transform": {
1074                             "Get": "_dict_lookup",
1075                             "Put": "_dict_lookup",
1076                             "GetArgs": {
1077                                 "lookup": self.firewall_notification,
1078                                 "value_lookup": False,
1079                             },
1080                             "PutArgs": {
1081                                 "lookup": self.firewall_notification,
1082                                 "value_lookup": True,
1083                             },
1084                         },
1085                     },
1086                     "WfwDomainSettingsLocalFirewallRules": {
1087                         "Policy": (
1088                             "Network firewall: Domain: Settings: Apply "
1089                             "local firewall rules"
1090                         ),
1091                         "lgpo_section": self.windows_firewall_gpedit_path,
1092                         "Settings": self.firewall_rule_merging.keys(),
1093                         "NetSH": {
1094                             "Profile": "domain",
1095                             "Section": "settings",
1096                             "Option": "LocalFirewallRules",
1097                         },
1098                         "Transform": {
1099                             "Get": "_dict_lookup",
1100                             "Put": "_dict_lookup",
1101                             "GetArgs": {
1102                                 "lookup": self.firewall_rule_merging,
1103                                 "value_lookup": False,
1104                             },
1105                             "PutArgs": {
1106                                 "lookup": self.firewall_rule_merging,
1107                                 "value_lookup": True,
1108                             },
1109                         },
1110                     },
1111                     "WfwPrivateSettingsLocalFirewallRules": {
1112                         "Policy": (
1113                             "Network firewall: Private: Settings: Apply "
1114                             "local firewall rules"
1115                         ),
1116                         "lgpo_section": self.windows_firewall_gpedit_path,
1117                         "Settings": self.firewall_rule_merging.keys(),
1118                         "NetSH": {
1119                             "Profile": "private",
1120                             "Section": "settings",
1121                             "Option": "LocalFirewallRules",
1122                         },
1123                         "Transform": {
1124                             "Get": "_dict_lookup",
1125                             "Put": "_dict_lookup",
1126                             "GetArgs": {
1127                                 "lookup": self.firewall_rule_merging,
1128                                 "value_lookup": False,
1129                             },
1130                             "PutArgs": {
1131                                 "lookup": self.firewall_rule_merging,
1132                                 "value_lookup": True,
1133                             },
1134                         },
1135                     },
1136                     "WfwPublicSettingsLocalFirewallRules": {
1137                         "Policy": (
1138                             "Network firewall: Public: Settings: Apply "
1139                             "local firewall rules"
1140                         ),
1141                         "lgpo_section": self.windows_firewall_gpedit_path,
1142                         "Settings": self.firewall_rule_merging.keys(),
1143                         "NetSH": {
1144                             "Profile": "public",
1145                             "Section": "settings",
1146                             "Option": "LocalFirewallRules",
1147                         },
1148                         "Transform": {
1149                             "Get": "_dict_lookup",
1150                             "Put": "_dict_lookup",
1151                             "GetArgs": {
1152                                 "lookup": self.firewall_rule_merging,
1153                                 "value_lookup": False,
1154                             },
1155                             "PutArgs": {
1156                                 "lookup": self.firewall_rule_merging,
1157                                 "value_lookup": True,
1158                             },
1159                         },
1160                     },
1161                     "WfwDomainSettingsLocalConnectionRules": {
1162                         "Policy": (
1163                             "Network firewall: Domain: Settings: Apply "
1164                             "local connection security rules"
1165                         ),
1166                         "lgpo_section": self.windows_firewall_gpedit_path,
1167                         "Settings": self.firewall_rule_merging.keys(),
1168                         "NetSH": {
1169                             "Profile": "domain",
1170                             "Section": "settings",
1171                             "Option": "LocalConSecRules",
1172                         },
1173                         "Transform": {
1174                             "Get": "_dict_lookup",
1175                             "Put": "_dict_lookup",
1176                             "GetArgs": {
1177                                 "lookup": self.firewall_rule_merging,
1178                                 "value_lookup": False,
1179                             },
1180                             "PutArgs": {
1181                                 "lookup": self.firewall_rule_merging,
1182                                 "value_lookup": True,
1183                             },
1184                         },
1185                     },
1186                     "WfwPrivateSettingsLocalConnectionRules": {
1187                         "Policy": (
1188                             "Network firewall: Private: Settings: Apply "
1189                             "local connection security rules"
1190                         ),
1191                         "lgpo_section": self.windows_firewall_gpedit_path,
1192                         "Settings": self.firewall_rule_merging.keys(),
1193                         "NetSH": {
1194                             "Profile": "private",
1195                             "Section": "settings",
1196                             "Option": "LocalConSecRules",
1197                         },
1198                         "Transform": {
1199                             "Get": "_dict_lookup",
1200                             "Put": "_dict_lookup",
1201                             "GetArgs": {
1202                                 "lookup": self.firewall_rule_merging,
1203                                 "value_lookup": False,
1204                             },
1205                             "PutArgs": {
1206                                 "lookup": self.firewall_rule_merging,
1207                                 "value_lookup": True,
1208                             },
1209                         },
1210                     },
1211                     "WfwPublicSettingsLocalConnectionRules": {
1212                         "Policy": (
1213                             "Network firewall: Public: Settings: Apply "
1214                             "local connection security rules"
1215                         ),
1216                         "lgpo_section": self.windows_firewall_gpedit_path,
1217                         "Settings": self.firewall_rule_merging.keys(),
1218                         "NetSH": {
1219                             "Profile": "public",
1220                             "Section": "settings",
1221                             "Option": "LocalConSecRules",
1222                         },
1223                         "Transform": {
1224                             "Get": "_dict_lookup",
1225                             "Put": "_dict_lookup",
1226                             "GetArgs": {
1227                                 "lookup": self.firewall_rule_merging,
1228                                 "value_lookup": False,
1229                             },
1230                             "PutArgs": {
1231                                 "lookup": self.firewall_rule_merging,
1232                                 "value_lookup": True,
1233                             },
1234                         },
1235                     },
1236                     "WfwDomainLoggingName": {
1237                         "Policy": "Network firewall: Domain: Logging: Name",
1238                         "lgpo_section": self.windows_firewall_gpedit_path,
1239                         "Settings": None,
1240                         "NetSH": {
1241                             "Profile": "domain",
1242                             "Section": "logging",
1243                             "Option": "FileName",
1244                         },
1245                     },
1246                     "WfwPrivateLoggingName": {
1247                         "Policy": "Network firewall: Private: Logging: Name",
1248                         "lgpo_section": self.windows_firewall_gpedit_path,
1249                         "Settings": None,
1250                         "NetSH": {
1251                             "Profile": "private",
1252                             "Section": "logging",
1253                             "Option": "FileName",
1254                         },
1255                     },
1256                     "WfwPublicLoggingName": {
1257                         "Policy": "Network firewall: Public: Logging: Name",
1258                         "lgpo_section": self.windows_firewall_gpedit_path,
1259                         "Settings": None,
1260                         "NetSH": {
1261                             "Profile": "public",
1262                             "Section": "logging",
1263                             "Option": "FileName",
1264                         },
1265                     },
1266                     "WfwDomainLoggingMaxFileSize": {
1267                         "Policy": "Network firewall: Domain: Logging: Size limit (KB)",
1268                         "lgpo_section": self.windows_firewall_gpedit_path,
1269                         "Settings": None,
1270                         "NetSH": {
1271                             "Profile": "domain",
1272                             "Section": "logging",
1273                             "Option": "MaxFileSize",
1274                         },
1275                     },
1276                     "WfwPrivateLoggingMaxFileSize": {
1277                         "Policy": "Network firewall: Private: Logging: Size limit (KB)",
1278                         "lgpo_section": self.windows_firewall_gpedit_path,
1279                         "Settings": None,
1280                         "NetSH": {
1281                             "Profile": "private",
1282                             "Section": "logging",
1283                             "Option": "MaxFileSize",
1284                         },
1285                     },
1286                     "WfwPublicLoggingMaxFileSize": {
1287                         "Policy": "Network firewall: Public: Logging: Size limit (KB)",
1288                         "lgpo_section": self.windows_firewall_gpedit_path,
1289                         "Settings": None,
1290                         "NetSH": {
1291                             "Profile": "public",
1292                             "Section": "logging",
1293                             "Option": "MaxFileSize",
1294                         },
1295                     },
1296                     "WfwDomainLoggingAllowedConnections": {
1297                         "Policy": (
1298                             "Network firewall: Domain: Logging: Log successful"
1299                             " connections"
1300                         ),
1301                         "lgpo_section": self.windows_firewall_gpedit_path,
1302                         "Settings": self.firewall_log_packets_connections.keys(),
1303                         "NetSH": {
1304                             "Profile": "domain",
1305                             "Section": "logging",
1306                             "Option": "LogAllowedConnections",
1307                         },
1308                         "Transform": {
1309                             "Get": "_dict_lookup",
1310                             "Put": "_dict_lookup",
1311                             "GetArgs": {
1312                                 "lookup": self.firewall_log_packets_connections,
1313                                 "value_lookup": False,
1314                             },
1315                             "PutArgs": {
1316                                 "lookup": self.firewall_log_packets_connections,
1317                                 "value_lookup": True,
1318                             },
1319                         },
1320                     },
1321                     "WfwPrivateLoggingAllowedConnections": {
1322                         "Policy": (
1323                             "Network firewall: Private: Logging: Log successful"
1324                             " connections"
1325                         ),
1326                         "lgpo_section": self.windows_firewall_gpedit_path,
1327                         "Settings": self.firewall_log_packets_connections.keys(),
1328                         "NetSH": {
1329                             "Profile": "private",
1330                             "Section": "logging",
1331                             "Option": "LogAllowedConnections",
1332                         },
1333                         "Transform": {
1334                             "Get": "_dict_lookup",
1335                             "Put": "_dict_lookup",
1336                             "GetArgs": {
1337                                 "lookup": self.firewall_log_packets_connections,
1338                                 "value_lookup": False,
1339                             },
1340                             "PutArgs": {
1341                                 "lookup": self.firewall_log_packets_connections,
1342                                 "value_lookup": True,
1343                             },
1344                         },
1345                     },
1346                     "WfwPublicLoggingAllowedConnections": {
1347                         "Policy": (
1348                             "Network firewall: Public: Logging: Log successful"
1349                             " connections"
1350                         ),
1351                         "lgpo_section": self.windows_firewall_gpedit_path,
1352                         "Settings": self.firewall_log_packets_connections.keys(),
1353                         "NetSH": {
1354                             "Profile": "public",
1355                             "Section": "logging",
1356                             "Option": "LogAllowedConnections",
1357                         },
1358                         "Transform": {
1359                             "Get": "_dict_lookup",
1360                             "Put": "_dict_lookup",
1361                             "GetArgs": {
1362                                 "lookup": self.firewall_log_packets_connections,
1363                                 "value_lookup": False,
1364                             },
1365                             "PutArgs": {
1366                                 "lookup": self.firewall_log_packets_connections,
1367                                 "value_lookup": True,
1368                             },
1369                         },
1370                     },
1371                     "WfwDomainLoggingDroppedConnections": {
1372                         "Policy": (
1373                             "Network firewall: Domain: Logging: Log dropped packets"
1374                         ),
1375                         "lgpo_section": self.windows_firewall_gpedit_path,
1376                         "Settings": self.firewall_log_packets_connections.keys(),
1377                         "NetSH": {
1378                             "Profile": "domain",
1379                             "Section": "logging",
1380                             "Option": "LogDroppedConnections",
1381                         },
1382                         "Transform": {
1383                             "Get": "_dict_lookup",
1384                             "Put": "_dict_lookup",
1385                             "GetArgs": {
1386                                 "lookup": self.firewall_log_packets_connections,
1387                                 "value_lookup": False,
1388                             },
1389                             "PutArgs": {
1390                                 "lookup": self.firewall_log_packets_connections,
1391                                 "value_lookup": True,
1392                             },
1393                         },
1394                     },
1395                     "WfwPrivateLoggingDroppedConnections": {
1396                         "Policy": (
1397                             "Network firewall: Private: Logging: Log dropped packets"
1398                         ),
1399                         "lgpo_section": self.windows_firewall_gpedit_path,
1400                         "Settings": self.firewall_log_packets_connections.keys(),
1401                         "NetSH": {
1402                             "Profile": "private",
1403                             "Section": "logging",
1404                             "Option": "LogDroppedConnections",
1405                         },
1406                         "Transform": {
1407                             "Get": "_dict_lookup",
1408                             "Put": "_dict_lookup",
1409                             "GetArgs": {
1410                                 "lookup": self.firewall_log_packets_connections,
1411                                 "value_lookup": False,
1412                             },
1413                             "PutArgs": {
1414                                 "lookup": self.firewall_log_packets_connections,
1415                                 "value_lookup": True,
1416                             },
1417                         },
1418                     },
1419                     "WfwPublicLoggingDroppedConnections": {
1420                         "Policy": (
1421                             "Network firewall: Public: Logging: Log dropped packets"
1422                         ),
1423                         "lgpo_section": self.windows_firewall_gpedit_path,
1424                         "Settings": self.firewall_log_packets_connections.keys(),
1425                         "NetSH": {
1426                             "Profile": "public",
1427                             "Section": "logging",
1428                             "Option": "LogDroppedConnections",
1429                         },
1430                         "Transform": {
1431                             "Get": "_dict_lookup",
1432                             "Put": "_dict_lookup",
1433                             "GetArgs": {
1434                                 "lookup": self.firewall_log_packets_connections,
1435                                 "value_lookup": False,
1436                             },
1437                             "PutArgs": {
1438                                 "lookup": self.firewall_log_packets_connections,
1439                                 "value_lookup": True,
1440                             },
1441                         },
1442                     },
1443                     "PasswordHistory": {
1444                         "Policy": "Enforce password history",
1445                         "lgpo_section": self.password_policy_gpedit_path,
1446                         "Settings": {
1447                             "Function": "_in_range_inclusive",
1448                             "Args": {"min": 0, "max": 24},
1449                         },
1450                         "NetUserModal": {"Modal": 0, "Option": "password_hist_len"},
1451                     },
1452                     "MaxPasswordAge": {
1453                         "Policy": "Maximum password age",
1454                         "lgpo_section": self.password_policy_gpedit_path,
1455                         "Settings": {
1456                             "Function": "_in_range_inclusive",
1457                             "Args": {
1458                                 "min": 1,
1459                                 "max": 86313600,
1460                                 "zero_value": 0xFFFFFFFF,
1461                             },
1462                         },
1463                         "NetUserModal": {"Modal": 0, "Option": "max_passwd_age"},
1464                         "Transform": {
1465                             "Get": "_seconds_to_days",
1466                             "Put": "_days_to_seconds",
1467                             "GetArgs": {"zero_value": 0xFFFFFFFF},
1468                             "PutArgs": {"zero_value": 0xFFFFFFFF},
1469                         },
1470                     },
1471                     "MinPasswordAge": {
1472                         "Policy": "Minimum password age",
1473                         "lgpo_section": self.password_policy_gpedit_path,
1474                         "Settings": {
1475                             "Function": "_in_range_inclusive",
1476                             "Args": {"min": 0, "max": 86313600},
1477                         },
1478                         "NetUserModal": {"Modal": 0, "Option": "min_passwd_age"},
1479                         "Transform": {
1480                             "Get": "_seconds_to_days",
1481                             "Put": "_days_to_seconds",
1482                         },
1483                     },
1484                     "MinPasswordLen": {
1485                         "Policy": "Minimum password length",
1486                         "lgpo_section": self.password_policy_gpedit_path,
1487                         "Settings": {
1488                             "Function": "_in_range_inclusive",
1489                             "Args": {"min": 0, "max": 14},
1490                         },
1491                         "NetUserModal": {"Modal": 0, "Option": "min_passwd_len"},
1492                     },
1493                     "PasswordComplexity": {
1494                         "Policy": "Password must meet complexity requirements",
1495                         "lgpo_section": self.password_policy_gpedit_path,
1496                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
1497                         "Secedit": {
1498                             "Option": "PasswordComplexity",
1499                             "Section": "System Access",
1500                         },
1501                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
1502                     },
1503                     "ClearTextPasswords": {
1504                         "Policy": "Store passwords using reversible encryption",
1505                         "lgpo_section": self.password_policy_gpedit_path,
1506                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
1507                         "Secedit": {
1508                             "Option": "ClearTextPassword",
1509                             "Section": "System Access",
1510                         },
1511                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
1512                     },
1513                     "AdminAccountStatus": {
1514                         "Policy": "Accounts: Administrator account status",
1515                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
1516                         "lgpo_section": self.security_options_gpedit_path,
1517                         "Secedit": {
1518                             "Option": "EnableAdminAccount",
1519                             "Section": "System Access",
1520                         },
1521                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
1522                     },
1523                     "NoConnectedUser": {
1524                         "Policy": "Accounts: Block Microsoft accounts",
1525                         "Settings": self.block_ms_accounts.keys(),
1526                         "lgpo_section": self.security_options_gpedit_path,
1527                         "Registry": {
1528                             "Hive": "HKEY_LOCAL_MACHINE",
1529                             "Path": (
1530                                 "SOFTWARE\\Microsoft\\Windows\\"
1531                                 "CurrentVersion\\policies\\system"
1532                             ),
1533                             "Value": "NoConnectedUser",
1534                             "Type": "REG_DWORD",
1535                         },
1536                         "Transform": {
1537                             "Get": "_dict_lookup",
1538                             "Put": "_dict_lookup",
1539                             "GetArgs": {
1540                                 "lookup": self.block_ms_accounts,
1541                                 "value_lookup": False,
1542                             },
1543                             "PutArgs": {
1544                                 "lookup": self.block_ms_accounts,
1545                                 "value_lookup": True,
1546                             },
1547                         },
1548                     },
1549                     "GuestAccountStatus": {
1550                         "Policy": "Accounts: Guest account status",
1551                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
1552                         "lgpo_section": self.security_options_gpedit_path,
1553                         "Secedit": {
1554                             "Option": "EnableGuestAccount",
1555                             "Section": "System Access",
1556                         },
1557                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
1558                     },
1559                     "LimitBlankPasswordUse": {
1560                         "Policy": (
1561                             "Accounts: Limit local account use of blank "
1562                             "passwords to console logon only"
1563                         ),
1564                         "lgpo_section": self.security_options_gpedit_path,
1565                         "Settings": self.enabled_one_disabled_zero.keys(),
1566                         "Registry": {
1567                             "Hive": "HKEY_LOCAL_MACHINE",
1568                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
1569                             "Value": "limitblankpassworduse",
1570                             "Type": "REG_DWORD",
1571                         },
1572                         "Transform": self.enabled_one_disabled_zero_transform,
1573                     },
1574                     "RenameAdministratorAccount": {
1575                         "Policy": "Accounts: Rename administrator account",
1576                         "Settings": None,
1577                         "lgpo_section": self.security_options_gpedit_path,
1578                         "Secedit": {
1579                             "Option": "NewAdministratorName",
1580                             "Section": "System Access",
1581                         },
1582                         "Transform": {"Get": "_strip_quotes", "Put": "_add_quotes"},
1583                     },
1584                     "RenameGuestAccount": {
1585                         "Policy": "Accounts: Rename guest account",
1586                         "Settings": None,
1587                         "lgpo_section": self.security_options_gpedit_path,
1588                         "Secedit": {
1589                             "Option": "NewGuestName",
1590                             "Section": "System Access",
1591                         },
1592                         "Transform": {"Get": "_strip_quotes", "Put": "_add_quotes"},
1593                     },
1594                     "AuditBaseObjects": {
1595                         "Policy": "Audit: Audit the access of global system objects",
1596                         "Settings": self.enabled_one_disabled_zero.keys(),
1597                         "lgpo_section": self.security_options_gpedit_path,
1598                         "Registry": {
1599                             "Hive": "HKEY_LOCAL_MACHINE",
1600                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
1601                             "Value": "AuditBaseObjects",
1602                             "Type": "REG_DWORD",
1603                         },
1604                         "Transform": self.enabled_one_disabled_zero_transform,
1605                     },
1606                     "SceNoApplyLegacyAuditPolicy": {
1607                         "Policy": (
1608                             "Audit: Force audit policy subcategory "
1609                             "settings (Windows Vista or later) to "
1610                             "override audit policy category settings"
1611                         ),
1612                         "Settings": self.enabled_one_disabled_zero.keys(),
1613                         "lgpo_section": self.security_options_gpedit_path,
1614                         "Registry": {
1615                             "Hive": "HKEY_LOCAL_MACHINE",
1616                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
1617                             "Value": "SCENoApplyLegacyAuditPolicy",
1618                             "Type": "REG_DWORD",
1619                         },
1620                         "Transform": self.enabled_one_disabled_zero_transform,
1621                     },
1622                     "DontDisplayLastUserName": {
1623                         "Policy": "Interactive logon: Do not display last user name",
1624                         "Settings": self.enabled_one_disabled_zero.keys(),
1625                         "lgpo_section": self.security_options_gpedit_path,
1626                         "Registry": {
1627                             "Hive": "HKEY_LOCAL_MACHINE",
1628                             "Path": (
1629                                 "Software\\Microsoft\\Windows\\"
1630                                 "CurrentVersion\\Policies\\System"
1631                             ),
1632                             "Value": "DontDisplayLastUserName",
1633                             "Type": "REG_DWORD",
1634                         },
1635                         "Transform": self.enabled_one_disabled_zero_transform,
1636                     },
1637                     "CachedLogonsCount": {
1638                         "Policy": (
1639                             "Interactive logon: Number of previous "
1640                             "logons to cache (in case domain controller "
1641                             "is not available)"
1642                         ),
1643                         "Settings": {
1644                             "Function": "_in_range_inclusive",
1645                             "Args": {"min": 0, "max": 50},
1646                         },
1647                         "lgpo_section": self.security_options_gpedit_path,
1648                         "Registry": {
1649                             "Hive": "HKEY_LOCAL_MACHINE",
1650                             "Path": (
1651                                 "Software\\Microsoft\\Windows NT\\"
1652                                 "CurrentVersion\\Winlogon"
1653                             ),
1654                             "Value": "CachedLogonsCount",
1655                             "Type": "REG_SZ",
1656                         },
1657                     },
1658                     "ForceUnlockLogon": {
1659                         "Policy": (
1660                             "Interactive logon: Require Domain "
1661                             "Controller authentication to unlock "
1662                             "workstation"
1663                         ),
1664                         "Settings": self.enabled_one_disabled_zero.keys(),
1665                         "lgpo_section": self.security_options_gpedit_path,
1666                         "Registry": {
1667                             "Hive": "HKEY_LOCAL_MACHINE",
1668                             "Path": (
1669                                 "Software\\Microsoft\\Windows NT\\"
1670                                 "CurrentVersion\\Winlogon"
1671                             ),
1672                             "Value": "ForceUnlockLogon",
1673                             "Type": "REG_DWORD",
1674                         },
1675                         "Transform": self.enabled_one_disabled_zero_transform,
1676                     },
1677                     "ScRemoveOption": {
1678                         "Policy": "Interactive logon: Smart card removal behavior",
1679                         "Settings": self.sc_removal_lookup.keys(),
1680                         "lgpo_section": self.security_options_gpedit_path,
1681                         "Registry": {
1682                             "Hive": "HKEY_LOCAL_MACHINE",
1683                             "Path": (
1684                                 "Software\\Microsoft\\Windows NT\\"
1685                                 "CurrentVersion\\Winlogon"
1686                             ),
1687                             "Value": "ScRemoveOption",
1688                             "Type": "REG_SZ",
1689                         },
1690                         "Transform": {
1691                             "Get": "_dict_lookup",
1692                             "Put": "_dict_lookup",
1693                             "GetArgs": {
1694                                 "lookup": self.sc_removal_lookup,
1695                                 "value_lookup": False,
1696                             },
1697                             "PutArgs": {
1698                                 "lookup": self.sc_removal_lookup,
1699                                 "value_lookup": True,
1700                             },
1701                         },
1702                     },
1703                     "DisableCAD": {
1704                         "Policy": "Interactive logon: Do not require CTRL+ALT+DEL",
1705                         "Settings": self.enabled_one_disabled_zero.keys(),
1706                         "lgpo_section": self.security_options_gpedit_path,
1707                         "Registry": {
1708                             "Hive": "HKEY_LOCAL_MACHINE",
1709                             "Path": (
1710                                 "Software\\Microsoft\\Windows\\"
1711                                 "CurrentVersion\\Policies\\System"
1712                             ),
1713                             "Value": "DisableCAD",
1714                             "Type": "REG_DWORD",
1715                         },
1716                         "Transform": self.enabled_one_disabled_zero_transform,
1717                     },
1718                     "FilterAdministratorToken": {
1719                         "Policy": (
1720                             "User Account Control: Admin Approval Mode "
1721                             "for the built-in Administrator account"
1722                         ),
1723                         "Settings": self.enabled_one_disabled_zero.keys(),
1724                         "lgpo_section": self.security_options_gpedit_path,
1725                         "Registry": {
1726                             "Hive": "HKEY_LOCAL_MACHINE",
1727                             "Path": (
1728                                 "Software\\Microsoft\\Windows\\"
1729                                 "CurrentVersion\\Policies\\System"
1730                             ),
1731                             "Value": "FilterAdministratorToken",
1732                             "Type": "REG_DWORD",
1733                         },
1734                         "Transform": self.enabled_one_disabled_zero_transform,
1735                     },
1736                     "EnableUIADesktopToggle": {
1737                         "Policy": (
1738                             "User Account Control: Allow UIAccess "
1739                             "applications to prompt for elevation "
1740                             "without using the secure desktop"
1741                         ),
1742                         "Settings": self.enabled_one_disabled_zero.keys(),
1743                         "lgpo_section": self.security_options_gpedit_path,
1744                         "Registry": {
1745                             "Hive": "HKEY_LOCAL_MACHINE",
1746                             "Path": (
1747                                 "Software\\Microsoft\\Windows\\"
1748                                 "CurrentVersion\\Policies\\System"
1749                             ),
1750                             "Value": "EnableUIADesktopToggle",
1751                             "Type": "REG_DWORD",
1752                         },
1753                         "Transform": self.enabled_one_disabled_zero_transform,
1754                     },
1755                     "ConsentPromptBehaviorAdmin": {
1756                         "Policy": (
1757                             "User Account Control: Behavior of the "
1758                             "elevation prompt for administrators in "
1759                             "Admin Approval Mode"
1760                         ),
1761                         "Settings": self.uac_admin_prompt_lookup.keys(),
1762                         "lgpo_section": self.security_options_gpedit_path,
1763                         "Registry": {
1764                             "Hive": "HKEY_LOCAL_MACHINE",
1765                             "Path": (
1766                                 "Software\\Microsoft\\Windows\\"
1767                                 "CurrentVersion\\Policies\\System"
1768                             ),
1769                             "Value": "ConsentPromptBehaviorAdmin",
1770                             "Type": "REG_DWORD",
1771                         },
1772                         "Transform": {
1773                             "Get": "_dict_lookup",
1774                             "Put": "_dict_lookup",
1775                             "GetArgs": {
1776                                 "lookup": self.uac_admin_prompt_lookup,
1777                                 "value_lookup": False,
1778                             },
1779                             "PutArgs": {
1780                                 "lookup": self.uac_admin_prompt_lookup,
1781                                 "value_lookup": True,
1782                             },
1783                         },
1784                     },
1785                     "ConsentPromptBehaviorUser": {
1786                         "Policy": (
1787                             "User Account Control: Behavior of the "
1788                             "elevation prompt for standard users"
1789                         ),
1790                         "Settings": self.uac_user_prompt_lookup.keys(),
1791                         "lgpo_section": self.security_options_gpedit_path,
1792                         "Registry": {
1793                             "Hive": "HKEY_LOCAL_MACHINE",
1794                             "Path": (
1795                                 "Software\\Microsoft\\Windows\\"
1796                                 "CurrentVersion\\Policies\\System"
1797                             ),
1798                             "Value": "ConsentPromptBehaviorUser",
1799                             "Type": "REG_DWORD",
1800                         },
1801                         "Transform": {
1802                             "Get": "_dict_lookup",
1803                             "Put": "_dict_lookup",
1804                             "GetArgs": {
1805                                 "lookup": self.uac_user_prompt_lookup,
1806                                 "value_lookup": False,
1807                             },
1808                             "PutArgs": {
1809                                 "lookup": self.uac_user_prompt_lookup,
1810                                 "value_lookup": True,
1811                             },
1812                         },
1813                     },
1814                     "EnableInstallerDetection": {
1815                         "Policy": (
1816                             "User Account Control: Detect application "
1817                             "installations and prompt for elevation"
1818                         ),
1819                         "Settings": self.enabled_one_disabled_zero.keys(),
1820                         "lgpo_section": self.security_options_gpedit_path,
1821                         "Registry": {
1822                             "Hive": "HKEY_LOCAL_MACHINE",
1823                             "Path": (
1824                                 "Software\\Microsoft\\Windows\\"
1825                                 "CurrentVersion\\Policies\\System"
1826                             ),
1827                             "Value": "EnableInstallerDetection",
1828                             "Type": "REG_DWORD",
1829                         },
1830                         "Transform": self.enabled_one_disabled_zero_transform,
1831                     },
1832                     "ValidateAdminCodeSignatures": {
1833                         "Policy": (
1834                             "User Account Control: Only elevate "
1835                             "executables that are signed and validated"
1836                         ),
1837                         "Settings": self.enabled_one_disabled_zero.keys(),
1838                         "lgpo_section": self.security_options_gpedit_path,
1839                         "Registry": {
1840                             "Hive": "HKEY_LOCAL_MACHINE",
1841                             "Path": (
1842                                 "Software\\Microsoft\\Windows\\"
1843                                 "CurrentVersion\\Policies\\System"
1844                             ),
1845                             "Value": "ValidateAdminCodeSignatures",
1846                             "Type": "REG_DWORD",
1847                         },
1848                         "Transform": self.enabled_one_disabled_zero_transform,
1849                     },
1850                     "EnableSecureUIAPaths": {
1851                         "Policy": (
1852                             "User Account Control: Only elevate UIAccess "
1853                             "applications that are installed in secure "
1854                             "locations"
1855                         ),
1856                         "Settings": self.enabled_one_disabled_zero.keys(),
1857                         "lgpo_section": self.security_options_gpedit_path,
1858                         "Registry": {
1859                             "Hive": "HKEY_LOCAL_MACHINE",
1860                             "Path": (
1861                                 "Software\\Microsoft\\Windows\\"
1862                                 "CurrentVersion\\Policies\\System"
1863                             ),
1864                             "Value": "EnableSecureUIAPaths",
1865                             "Type": "REG_DWORD",
1866                         },
1867                         "Transform": self.enabled_one_disabled_zero_transform,
1868                     },
1869                     "EnableLUA": {
1870                         "Policy": (
1871                             "User Account Control: Run all "
1872                             "administrators in Admin Approval Mode"
1873                         ),
1874                         "Settings": self.enabled_one_disabled_zero.keys(),
1875                         "lgpo_section": self.security_options_gpedit_path,
1876                         "Registry": {
1877                             "Hive": "HKEY_LOCAL_MACHINE",
1878                             "Path": (
1879                                 "Software\\Microsoft\\Windows\\"
1880                                 "CurrentVersion\\Policies\\System"
1881                             ),
1882                             "Value": "EnableLUA",
1883                             "Type": "REG_DWORD",
1884                         },
1885                         "Transform": self.enabled_one_disabled_zero_transform,
1886                     },
1887                     "PromptOnSecureDesktop": {
1888                         "Policy": (
1889                             "User Account Control: Switch to the secure "
1890                             "desktop when prompting for elevation"
1891                         ),
1892                         "Settings": self.enabled_one_disabled_zero.keys(),
1893                         "lgpo_section": self.security_options_gpedit_path,
1894                         "Registry": {
1895                             "Hive": "HKEY_LOCAL_MACHINE",
1896                             "Path": (
1897                                 "Software\\Microsoft\\Windows\\"
1898                                 "CurrentVersion\\Policies\\System"
1899                             ),
1900                             "Value": "PromptOnSecureDesktop",
1901                             "Type": "REG_DWORD",
1902                         },
1903                         "Transform": self.enabled_one_disabled_zero_transform,
1904                     },
1905                     "EnableVirtualization": {
1906                         "Policy": (
1907                             "User Account Control: Virtualize file and "
1908                             "registry write failures to per-user "
1909                             "locations"
1910                         ),
1911                         "Settings": self.enabled_one_disabled_zero.keys(),
1912                         "lgpo_section": self.security_options_gpedit_path,
1913                         "Registry": {
1914                             "Hive": "HKEY_LOCAL_MACHINE",
1915                             "Path": (
1916                                 "Software\\Microsoft\\Windows\\"
1917                                 "CurrentVersion\\Policies\\System"
1918                             ),
1919                             "Value": "EnableVirtualization",
1920                             "Type": "REG_DWORD",
1921                         },
1922                         "Transform": self.enabled_one_disabled_zero_transform,
1923                     },
1924                     "PasswordExpiryWarning": {
1925                         "Policy": (
1926                             "Interactive logon: Prompt user to change "
1927                             "password before expiration"
1928                         ),
1929                         "Settings": {
1930                             "Function": "_in_range_inclusive",
1931                             "Args": {"min": 0, "max": 999},
1932                         },
1933                         "lgpo_section": self.security_options_gpedit_path,
1934                         "Registry": {
1935                             "Hive": "HKEY_LOCAL_MACHINE",
1936                             "Path": (
1937                                 "Software\\Microsoft\\Windows NT\\"
1938                                 "CurrentVersion\\Winlogon"
1939                             ),
1940                             "Value": "PasswordExpiryWarning",
1941                             "Type": "REG_DWORD",
1942                         },
1943                     },
1944                     "MaxDevicePasswordFailedAttempts": {
1945                         "Policy": (
1946                             "Interactive logon: Machine account lockout threshold"
1947                         ),
1948                         "Settings": {
1949                             "Function": "_in_range_inclusive",
1950                             "Args": {"min": 0, "max": 999},
1951                         },
1952                         "lgpo_section": self.security_options_gpedit_path,
1953                         "Registry": {
1954                             "Hive": "HKEY_LOCAL_MACHINE",
1955                             "Path": (
1956                                 "SOFTWARE\\Microsoft\\Windows\\"
1957                                 "CurrentVersion\\policies\\system"
1958                             ),
1959                             "Value": "MaxDevicePasswordFailedAttempts",
1960                             "Type": "REG_DWORD",
1961                         },
1962                     },
1963                     "InactivityTimeoutSecs": {
1964                         "Policy": "Interactive logon: Machine inactivity limit",
1965                         "Settings": {
1966                             "Function": "_in_range_inclusive",
1967                             "Args": {"min": 0, "max": 599940},
1968                         },
1969                         "lgpo_section": self.security_options_gpedit_path,
1970                         "Registry": {
1971                             "Hive": "HKEY_LOCAL_MACHINE",
1972                             "Path": (
1973                                 "SOFTWARE\\Microsoft\\Windows\\"
1974                                 "CurrentVersion\\policies\\system"
1975                             ),
1976                             "Value": "InactivityTimeoutSecs",
1977                             "Type": "REG_DWORD",
1978                         },
1979                     },
1980                     "legalnoticetext": {
1981                         "Policy": (
1982                             "Interactive logon: Message text for users "
1983                             "attempting to log on"
1984                         ),
1985                         "lgpo_section": self.security_options_gpedit_path,
1986                         "Registry": {
1987                             "Hive": "HKEY_LOCAL_MACHINE",
1988                             "Path": (
1989                                 "SOFTWARE\\Microsoft\\Windows\\"
1990                                 "CurrentVersion\\policies\\system"
1991                             ),
1992                             "Value": "legalnoticetext",
1993                             "Type": "REG_SZ",
1994                         },
1995                         "Transform": {"Put": "_string_put_transform"},
1996                     },
1997                     "legalnoticecaption": {
1998                         "Policy": (
1999                             "Interactive logon: Message title for users "
2000                             "attempting to log on"
2001                         ),
2002                         "lgpo_section": self.security_options_gpedit_path,
2003                         "Registry": {
2004                             "Hive": "HKEY_LOCAL_MACHINE",
2005                             "Path": (
2006                                 "SOFTWARE\\Microsoft\\Windows\\"
2007                                 "CurrentVersion\\policies\\system"
2008                             ),
2009                             "Value": "legalnoticecaption",
2010                             "Type": "REG_SZ",
2011                         },
2012                         "Transform": {"Put": "_string_put_transform"},
2013                     },
2014                     "DontDisplayLockedUserId": {
2015                         "Policy": (
2016                             "Interactive logon: Display user information "
2017                             "when the session is locked"
2018                         ),
2019                         "Settings": self.locked_session_user_info.keys(),
2020                         "lgpo_section": self.security_options_gpedit_path,
2021                         "Registry": {
2022                             "Hive": "HKEY_LOCAL_MACHINE",
2023                             "Path": (
2024                                 "SOFTWARE\\Microsoft\\Windows\\"
2025                                 "CurrentVersion\\policies\\system"
2026                             ),
2027                             "Value": "DontDisplayLockedUserId",
2028                             "Type": "REG_DWORD",
2029                         },
2030                         "Transform": {
2031                             "Get": "_dict_lookup",
2032                             "Put": "_dict_lookup",
2033                             "GetArgs": {
2034                                 "lookup": self.locked_session_user_info,
2035                                 "value_lookup": False,
2036                             },
2037                             "PutArgs": {
2038                                 "lookup": self.locked_session_user_info,
2039                                 "value_lookup": True,
2040                             },
2041                         },
2042                     },
2043                     "ScForceOption": {
2044                         "Policy": "Interactive logon: Require smart card",
2045                         "Settings": self.enabled_one_disabled_zero.keys(),
2046                         "lgpo_section": self.security_options_gpedit_path,
2047                         "Registry": {
2048                             "Hive": "HKEY_LOCAL_MACHINE",
2049                             "Path": (
2050                                 "Software\\Microsoft\\Windows\\"
2051                                 "CurrentVersion\\Policies\\System"
2052                             ),
2053                             "Value": "ScForceOption",
2054                             "Type": "REG_DWORD",
2055                         },
2056                         "Transform": self.enabled_one_disabled_zero_transform,
2057                     },
2058                     "Client_RequireSecuritySignature": {
2059                         "Policy": (
2060                             "Microsoft network client: Digitally sign "
2061                             "communications (always)"
2062                         ),
2063                         "Settings": self.enabled_one_disabled_zero.keys(),
2064                         "lgpo_section": self.security_options_gpedit_path,
2065                         "Registry": {
2066                             "Hive": "HKEY_LOCAL_MACHINE",
2067                             "Path": (
2068                                 "SYSTEM\\CurrentControlSet\\Services\\"
2069                                 "LanmanWorkstation\\Parameters"
2070                             ),
2071                             "Value": "RequireSecuritySignature",
2072                             "Type": "REG_DWORD",
2073                         },
2074                         "Transform": self.enabled_one_disabled_zero_transform,
2075                     },
2076                     "Client_EnableSecuritySignature": {
2077                         "Policy": (
2078                             "Microsoft network client: Digitally sign "
2079                             "communications (if server agrees)"
2080                         ),
2081                         "Settings": self.enabled_one_disabled_zero.keys(),
2082                         "lgpo_section": self.security_options_gpedit_path,
2083                         "Registry": {
2084                             "Hive": "HKEY_LOCAL_MACHINE",
2085                             "Path": (
2086                                 "SYSTEM\\CurrentControlSet\\Services\\"
2087                                 "LanmanWorkstation\\Parameters"
2088                             ),
2089                             "Value": "EnableSecuritySignature",
2090                             "Type": "REG_DWORD",
2091                         },
2092                         "Transform": self.enabled_one_disabled_zero_transform,
2093                     },
2094                     "EnablePlainTextPassword": {
2095                         "Policy": (
2096                             "Microsoft network client: Send unencrypted "
2097                             "password to third-party SMB servers"
2098                         ),
2099                         "Settings": self.enabled_one_disabled_zero.keys(),
2100                         "lgpo_section": self.security_options_gpedit_path,
2101                         "Registry": {
2102                             "Hive": "HKEY_LOCAL_MACHINE",
2103                             "Path": (
2104                                 "SYSTEM\\CurrentControlSet\\Services\\"
2105                                 "LanmanWorkstation\\Parameters"
2106                             ),
2107                             "Value": "EnablePlainTextPassword",
2108                             "Type": "REG_DWORD",
2109                         },
2110                         "Transform": self.enabled_one_disabled_zero_transform,
2111                     },
2112                     "AutoDisconnect": {
2113                         "Policy": (
2114                             "Microsoft network server: Amount of idle "
2115                             "time required before suspending session"
2116                         ),
2117                         "Settings": {
2118                             "Function": "_in_range_inclusive",
2119                             "Args": {"min": 0, "max": 99999},
2120                         },
2121                         "lgpo_section": self.security_options_gpedit_path,
2122                         "Registry": {
2123                             "Hive": "HKEY_LOCAL_MACHINE",
2124                             "Path": (
2125                                 "System\\CurrentControlSet\\Services\\"
2126                                 "LanmanServer\\Parameters"
2127                             ),
2128                             "Value": "AutoDisconnect",
2129                             "Type": "REG_DWORD",
2130                         },
2131                     },
2132                     "EnableS4U2SelfForClaims": {
2133                         "Policy": (
2134                             "Microsoft network server: Attempt S4U2Self "
2135                             "to obtain claim information"
2136                         ),
2137                         "Settings": self.s4u2self_options.keys(),
2138                         "lgpo_section": self.security_options_gpedit_path,
2139                         "Registry": {
2140                             "Hive": "HKEY_LOCAL_MACHINE",
2141                             "Path": (
2142                                 "System\\CurrentControlSet\\Services\\"
2143                                 "LanmanServer\\Parameters"
2144                             ),
2145                             "Value": "EnableS4U2SelfForClaims",
2146                             "Type": "REG_DWORD",
2147                         },
2148                         "Transform": {
2149                             "Get": "_dict_lookup",
2150                             "Put": "_dict_lookup",
2151                             "GetArgs": {
2152                                 "lookup": self.s4u2self_options,
2153                                 "value_lookup": False,
2154                             },
2155                             "PutArgs": {
2156                                 "lookup": self.s4u2self_options,
2157                                 "value_lookup": True,
2158                             },
2159                         },
2160                     },
2161                     "Server_RequireSecuritySignature": {
2162                         "Policy": (
2163                             "Microsoft network server: Digitally sign "
2164                             "communications (always)"
2165                         ),
2166                         "Settings": self.enabled_one_disabled_zero.keys(),
2167                         "lgpo_section": self.security_options_gpedit_path,
2168                         "Registry": {
2169                             "Hive": "HKEY_LOCAL_MACHINE",
2170                             "Path": (
2171                                 "SYSTEM\\CurrentControlSet\\Services\\"
2172                                 "LanmanServer\\Parameters"
2173                             ),
2174                             "Value": "RequireSecuritySignature",
2175                             "Type": "REG_DWORD",
2176                         },
2177                         "Transform": self.enabled_one_disabled_zero_transform,
2178                     },
2179                     "Server_EnableSecuritySignature": {
2180                         "Policy": (
2181                             "Microsoft network server: Digitally sign "
2182                             "communications (if client agrees)"
2183                         ),
2184                         "Settings": self.enabled_one_disabled_zero.keys(),
2185                         "lgpo_section": self.security_options_gpedit_path,
2186                         "Registry": {
2187                             "Hive": "HKEY_LOCAL_MACHINE",
2188                             "Path": (
2189                                 "SYSTEM\\CurrentControlSet\\Services\\"
2190                                 "LanmanServer\\Parameters"
2191                             ),
2192                             "Value": "EnableSecuritySignature",
2193                             "Type": "REG_DWORD",
2194                         },
2195                         "Transform": self.enabled_one_disabled_zero_transform,
2196                     },
2197                     "EnableForcedLogoff": {
2198                         "Policy": (
2199                             "Microsoft network server: Disconnect "
2200                             "clients when logon hours expire"
2201                         ),
2202                         "Settings": self.enabled_one_disabled_zero.keys(),
2203                         "lgpo_section": self.security_options_gpedit_path,
2204                         "Registry": {
2205                             "Hive": "HKEY_LOCAL_MACHINE",
2206                             "Path": (
2207                                 "SYSTEM\\CurrentControlSet\\Services\\"
2208                                 "LanmanServer\\Parameters"
2209                             ),
2210                             "Value": "EnableForcedLogoff",
2211                             "Type": "REG_DWORD",
2212                         },
2213                         "Transform": self.enabled_one_disabled_zero_transform,
2214                     },
2215                     "SmbServerNameHardeningLevel": {
2216                         "Policy": (
2217                             "Microsoft network server: Server SPN target "
2218                             "name validation level"
2219                         ),
2220                         "Settings": self.smb_server_name_hardening_levels.keys(),
2221                         "lgpo_section": self.security_options_gpedit_path,
2222                         "Registry": {
2223                             "Hive": "HKEY_LOCAL_MACHINE",
2224                             "Path": (
2225                                 "System\\CurrentControlSet\\Services\\"
2226                                 "LanmanServer\\Parameters"
2227                             ),
2228                             "Value": "SmbServerNameHardeningLevel",
2229                             "Type": "REG_DWORD",
2230                         },
2231                         "Transform": {
2232                             "Get": "_dict_lookup",
2233                             "Put": "_dict_lookup",
2234                             "GetArgs": {
2235                                 "lookup": self.smb_server_name_hardening_levels,
2236                                 "value_lookup": False,
2237                             },
2238                             "PutArgs": {
2239                                 "lookup": self.smb_server_name_hardening_levels,
2240                                 "value_lookup": True,
2241                             },
2242                         },
2243                     },
2244                     "FullPrivilegeAuditing": {
2245                         "Policy": (
2246                             "Audit: Audit the use of Backup and Restore privilege"
2247                         ),
2248                         "Settings": [chr(0), chr(1)],
2249                         "lgpo_section": self.security_options_gpedit_path,
2250                         "Registry": {
2251                             "Hive": "HKEY_LOCAL_MACHINE",
2252                             "Path": "System\\CurrentControlSet\\Control\\Lsa",
2253                             "Value": "FullPrivilegeAuditing",
2254                             "Type": "REG_BINARY",
2255                         },
2256                         "Transform": {
2257                             "Get": "_binary_enable_zero_disable_one_conversion",
2258                             "Put": "_binary_enable_zero_disable_one_reverse_conversion",
2259                         },
2260                     },
2261                     "CrashOnAuditFail": {
2262                         "Policy": (
2263                             "Audit: Shut down system immediately if "
2264                             "unable to log security audits"
2265                         ),
2266                         "Settings": self.enabled_one_disabled_zero.keys(),
2267                         "lgpo_section": self.security_options_gpedit_path,
2268                         "Registry": {
2269                             "Hive": "HKEY_LOCAL_MACHINE",
2270                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
2271                             "Value": "CrashOnAuditFail",
2272                             "Type": "REG_DWORD",
2273                         },
2274                         "Transform": self.enabled_one_disabled_zero_transform,
2275                     },
2276                     "UndockWithoutLogon": {
2277                         "Policy": "Devices: Allow undock without having to log on",
2278                         "Settings": self.enabled_one_disabled_zero.keys(),
2279                         "lgpo_section": self.security_options_gpedit_path,
2280                         "Registry": {
2281                             "Hive": "HKEY_LOCAL_MACHINE",
2282                             "Path": (
2283                                 "Software\\Microsoft\\Windows\\"
2284                                 "CurrentVersion\\Policies\\System"
2285                             ),
2286                             "Value": "UndockWithoutLogon",
2287                             "Type": "REG_DWORD",
2288                         },
2289                         "Transform": self.enabled_one_disabled_zero_transform,
2290                     },
2291                     "AddPrinterDrivers": {
2292                         "Policy": (
2293                             "Devices: Prevent users from installing printer drivers"
2294                         ),
2295                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2296                         "lgpo_section": self.security_options_gpedit_path,
2297                         "Registry": {
2298                             "Hive": "HKEY_LOCAL_MACHINE",
2299                             "Path": (
2300                                 "System\\CurrentControlSet\\Control\\"
2301                                 "Print\\Providers\\LanMan Print Services\\"
2302                                 "Servers"
2303                             ),
2304                             "Value": "AddPrinterDrivers",
2305                             "Type": "REG_DWORD",
2306                         },
2307                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2308                     },
2309                     "AllocateDASD": {
2310                         "Policy": (
2311                             "Devices: Allowed to format and eject removable media"
2312                         ),
2313                         "Settings": ["9999", "0", "1", "2"],
2314                         "lgpo_section": self.security_options_gpedit_path,
2315                         "Registry": {
2316                             "Hive": "HKEY_LOCAL_MACHINE",
2317                             "Path": (
2318                                 "Software\\Microsoft\\Windows NT\\"
2319                                 "CurrentVersion\\Winlogon"
2320                             ),
2321                             "Value": "AllocateDASD",
2322                             "Type": "REG_SZ",
2323                         },
2324                         "Transform": {
2325                             "Get": "_dasd_conversion",
2326                             "Put": "_dasd_reverse_conversion",
2327                         },
2328                     },
2329                     "AllocateCDRoms": {
2330                         "Policy": (
2331                             "Devices: Restrict CD-ROM access to locally "
2332                             "logged-on user only"
2333                         ),
2334                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2335                         "lgpo_section": self.security_options_gpedit_path,
2336                         "Registry": {
2337                             "Hive": "HKEY_LOCAL_MACHINE",
2338                             "Path": (
2339                                 "Software\\Microsoft\\Windows NT\\"
2340                                 "CurrentVersion\\Winlogon"
2341                             ),
2342                             "Value": "AllocateCDRoms",
2343                             "Type": "REG_SZ",
2344                         },
2345                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2346                     },
2347                     "AllocateFloppies": {
2348                         "Policy": (
2349                             "Devices: Restrict floppy access to locally "
2350                             "logged-on user only"
2351                         ),
2352                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2353                         "lgpo_section": self.security_options_gpedit_path,
2354                         "Registry": {
2355                             "Hive": "HKEY_LOCAL_MACHINE",
2356                             "Path": (
2357                                 "Software\\Microsoft\\Windows NT\\"
2358                                 "CurrentVersion\\Winlogon"
2359                             ),
2360                             "Value": "AllocateFloppies",
2361                             "Type": "REG_SZ",
2362                         },
2363                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2364                     },
2365                     "DriverSigningPolicy": {
2366                         "Policy": "Devices: Unsigned driver installation behavior",
2367                         "Settings": ["3,0", "3," + chr(1), "3," + chr(2)],
2368                         "lgpo_section": self.security_options_gpedit_path,
2369                         "Secedit": {
2370                             "Option": (
2371                                 "MACHINE\\Software\\Microsoft\\Driver Signing\\Policy"
2372                             ),
2373                             "Section": "Registry Values",
2374                         },
2375                         "Transform": {
2376                             "Get": "_driver_signing_reg_conversion",
2377                             "Put": "_driver_signing_reg_reverse_conversion",
2378                         },
2379                     },
2380                     "SubmitControl": {
2381                         "Policy": (
2382                             "Domain controller: Allow server operators "
2383                             "to schedule tasks"
2384                         ),
2385                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2386                         "lgpo_section": self.security_options_gpedit_path,
2387                         "Registry": {
2388                             "Hive": "HKEY_LOCAL_MACHINE",
2389                             "Path": "System\\CurrentControlSet\\Control\\Lsa",
2390                             "Value": "SubmitControl",
2391                             "Type": "REG_DWORD",
2392                         },
2393                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2394                     },
2395                     "LDAPServerIntegrity": {
2396                         "Policy": "Domain controller: LDAP server signing requirements",
2397                         "Settings": self.ldap_server_signing_requirements.keys(),
2398                         "lgpo_section": self.security_options_gpedit_path,
2399                         "Registry": {
2400                             "Hive": "HKEY_LOCAL_MACHINE",
2401                             "Path": (
2402                                 "System\\CurrentControlSet\\Services\\NTDS\\Parameters"
2403                             ),
2404                             "Value": "LDAPServerIntegrity",
2405                             "Type": "REG_DWORD",
2406                         },
2407                         "Transform": {
2408                             "Get": "_dict_lookup",
2409                             "Put": "_dict_lookup",
2410                             "GetArgs": {
2411                                 "lookup": self.ldap_server_signing_requirements,
2412                                 "value_lookup": False,
2413                             },
2414                             "PutArgs": {
2415                                 "lookup": self.ldap_server_signing_requirements,
2416                                 "value_lookup": True,
2417                             },
2418                         },
2419                     },
2420                     "RefusePasswordChange": {
2421                         "Policy": (
2422                             "Domain controller: Refuse machine account password changes"
2423                         ),
2424                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2425                         "lgpo_section": self.security_options_gpedit_path,
2426                         "Registry": {
2427                             "Hive": "HKEY_LOCAL_MACHINE",
2428                             "Path": (
2429                                 "SYSTEM\\CurrentControlSet\\Services\\"
2430                                 "Netlogon\\Parameters"
2431                             ),
2432                             "Value": "RefusePasswordChange",
2433                             "Type": "REG_DWORD",
2434                         },
2435                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2436                     },
2437                     "RequireSignOrSeal": {
2438                         "Policy": (
2439                             "Domain member: Digitally encrypt or sign "
2440                             "secure channel data (always)"
2441                         ),
2442                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2443                         "lgpo_section": self.security_options_gpedit_path,
2444                         "Registry": {
2445                             "Hive": "HKEY_LOCAL_MACHINE",
2446                             "Path": (
2447                                 "System\\CurrentControlSet\\Services\\"
2448                                 "Netlogon\\Parameters"
2449                             ),
2450                             "Value": "RequireSignOrSeal",
2451                             "Type": "REG_DWORD",
2452                         },
2453                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2454                     },
2455                     "SealSecureChannel": {
2456                         "Policy": (
2457                             "Domain member: Digitally encrypt secure "
2458                             "channel data (when possible)"
2459                         ),
2460                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2461                         "lgpo_section": self.security_options_gpedit_path,
2462                         "Registry": {
2463                             "Hive": "HKEY_LOCAL_MACHINE",
2464                             "Path": (
2465                                 "System\\CurrentControlSet\\Services\\"
2466                                 "Netlogon\\Parameters"
2467                             ),
2468                             "Value": "SealSecureChannel",
2469                             "Type": "REG_DWORD",
2470                         },
2471                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2472                     },
2473                     "SignSecureChannel": {
2474                         "Policy": (
2475                             "Domain member: Digitally sign secure "
2476                             "channel data (when possible)"
2477                         ),
2478                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2479                         "lgpo_section": self.security_options_gpedit_path,
2480                         "Registry": {
2481                             "Hive": "HKEY_LOCAL_MACHINE",
2482                             "Path": (
2483                                 "System\\CurrentControlSet\\Services\\"
2484                                 "Netlogon\\Parameters"
2485                             ),
2486                             "Value": "SignSecureChannel",
2487                             "Type": "REG_DWORD",
2488                         },
2489                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2490                     },
2491                     "DisablePasswordChange": {
2492                         "Policy": (
2493                             "Domain member: Disable machine account password changes"
2494                         ),
2495                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2496                         "lgpo_section": self.security_options_gpedit_path,
2497                         "Registry": {
2498                             "Hive": "HKEY_LOCAL_MACHINE",
2499                             "Path": (
2500                                 "System\\CurrentControlSet\\Services\\"
2501                                 "Netlogon\\Parameters"
2502                             ),
2503                             "Value": "DisablePasswordChange",
2504                             "Type": "REG_DWORD",
2505                         },
2506                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2507                     },
2508                     "MaximumPasswordAge": {
2509                         "Policy": "Domain member: Maximum machine account password age",
2510                         "Settings": {
2511                             "Function": "_in_range_inclusive",
2512                             "Args": {"min": 0, "max": 999},
2513                         },
2514                         "lgpo_section": self.security_options_gpedit_path,
2515                         "Registry": {
2516                             "Hive": "HKEY_LOCAL_MACHINE",
2517                             "Path": (
2518                                 "System\\CurrentControlSet\\Services\\"
2519                                 "Netlogon\\Parameters"
2520                             ),
2521                             "Value": "MaximumPasswordAge",
2522                             "Type": "REG_DWORD",
2523                         },
2524                     },
2525                     "RequireStrongKey": {
2526                         "Policy": (
2527                             "Domain member: Require strong (Windows 2000 "
2528                             "or later) session key"
2529                         ),
2530                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2531                         "lgpo_section": self.security_options_gpedit_path,
2532                         "Registry": {
2533                             "Hive": "HKEY_LOCAL_MACHINE",
2534                             "Path": (
2535                                 "System\\CurrentControlSet\\Services\\"
2536                                 "Netlogon\\Parameters"
2537                             ),
2538                             "Value": "RequireStrongKey",
2539                             "Type": "REG_DWORD",
2540                         },
2541                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2542                     },
2543                     "LockoutDuration": {
2544                         "Policy": "Account lockout duration",
2545                         "lgpo_section": self.account_lockout_policy_gpedit_path,
2546                         "Settings": {
2547                             "Function": "_in_range_inclusive",
2548                             "Args": {
2549                                 "min": 0,
2550                                 "max": 6000000,
2551                                 "zero_value": 0xFFFFFFFF,
2552                             },
2553                         },
2554                         "NetUserModal": {"Modal": 3, "Option": "lockout_duration"},
2555                         "Transform": {
2556                             "Get": "_seconds_to_minutes",
2557                             "Put": "_minutes_to_seconds",
2558                             "GetArgs": {"zero_value": 0xFFFFFFFF},
2559                             "PutArgs": {"zero_value": 0xFFFFFFFF},
2560                         },
2561                     },
2562                     "LockoutThreshold": {
2563                         "Policy": "Account lockout threshold",
2564                         "lgpo_section": self.account_lockout_policy_gpedit_path,
2565                         "Settings": {
2566                             "Function": "_in_range_inclusive",
2567                             "Args": {"min": 0, "max": 1000},
2568                         },
2569                         "NetUserModal": {"Modal": 3, "Option": "lockout_threshold"},
2570                     },
2571                     "LockoutWindow": {
2572                         "Policy": "Reset account lockout counter after",
2573                         "lgpo_section": self.account_lockout_policy_gpedit_path,
2574                         "Settings": {
2575                             "Function": "_in_range_inclusive",
2576                             "Args": {"min": 0, "max": 6000000},
2577                         },
2578                         "NetUserModal": {
2579                             "Modal": 3,
2580                             "Option": "lockout_observation_window",
2581                         },
2582                         "Transform": {
2583                             "Get": "_seconds_to_minutes",
2584                             "Put": "_minutes_to_seconds",
2585                         },
2586                     },
2587                     "AuditAccountLogon": {
2588                         "Policy": "Audit account logon events",
2589                         "lgpo_section": self.audit_policy_gpedit_path,
2590                         "Settings": self.audit_lookup.keys(),
2591                         "Secedit": {
2592                             "Option": "AuditAccountLogon",
2593                             "Section": "Event Audit",
2594                         },
2595                         "Transform": self.audit_transform,
2596                     },
2597                     "AuditAccountManage": {
2598                         "Policy": "Audit account management",
2599                         "lgpo_section": self.audit_policy_gpedit_path,
2600                         "Settings": self.audit_lookup.keys(),
2601                         "Secedit": {
2602                             "Option": "AuditAccountManage",
2603                             "Section": "Event Audit",
2604                         },
2605                         "Transform": self.audit_transform,
2606                     },
2607                     "AuditDSAccess": {
2608                         "Policy": "Audit directory service access",
2609                         "lgpo_section": self.audit_policy_gpedit_path,
2610                         "Settings": self.audit_lookup.keys(),
2611                         "Secedit": {
2612                             "Option": "AuditDSAccess",
2613                             "Section": "Event Audit",
2614                         },
2615                         "Transform": self.audit_transform,
2616                     },
2617                     "AuditLogonEvents": {
2618                         "Policy": "Audit logon events",
2619                         "lgpo_section": self.audit_policy_gpedit_path,
2620                         "Settings": self.audit_lookup.keys(),
2621                         "Secedit": {
2622                             "Option": "AuditLogonEvents",
2623                             "Section": "Event Audit",
2624                         },
2625                         "Transform": self.audit_transform,
2626                     },
2627                     "AuditObjectAccess": {
2628                         "Policy": "Audit object access",
2629                         "lgpo_section": self.audit_policy_gpedit_path,
2630                         "Settings": self.audit_lookup.keys(),
2631                         "Secedit": {
2632                             "Option": "AuditObjectAccess",
2633                             "Section": "Event Audit",
2634                         },
2635                         "Transform": self.audit_transform,
2636                     },
2637                     "AuditPolicyChange": {
2638                         "Policy": "Audit policy change",
2639                         "lgpo_section": self.audit_policy_gpedit_path,
2640                         "Settings": self.audit_lookup.keys(),
2641                         "Secedit": {
2642                             "Option": "AuditPolicyChange",
2643                             "Section": "Event Audit",
2644                         },
2645                         "Transform": self.audit_transform,
2646                     },
2647                     "AuditPrivilegeUse": {
2648                         "Policy": "Audit privilege use",
2649                         "lgpo_section": self.audit_policy_gpedit_path,
2650                         "Settings": self.audit_lookup.keys(),
2651                         "Secedit": {
2652                             "Option": "AuditPrivilegeUse",
2653                             "Section": "Event Audit",
2654                         },
2655                         "Transform": self.audit_transform,
2656                     },
2657                     "AuditProcessTracking": {
2658                         "Policy": "Audit process tracking",
2659                         "lgpo_section": self.audit_policy_gpedit_path,
2660                         "Settings": self.audit_lookup.keys(),
2661                         "Secedit": {
2662                             "Option": "AuditProcessTracking",
2663                             "Section": "Event Audit",
2664                         },
2665                         "Transform": self.audit_transform,
2666                     },
2667                     "AuditSystemEvents": {
2668                         "Policy": "Audit system events",
2669                         "lgpo_section": self.audit_policy_gpedit_path,
2670                         "Settings": self.audit_lookup.keys(),
2671                         "Secedit": {
2672                             "Option": "AuditSystemEvents",
2673                             "Section": "Event Audit",
2674                         },
2675                         "Transform": self.audit_transform,
2676                     },
2677                     "AuditCredentialValidation": {
2678                         "Policy": "Audit Credential Validation",
2679                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2680                         "Settings": self.advanced_audit_lookup.keys(),
2681                         "AdvAudit": {"Option": "Audit Credential Validation"},
2682                         "Transform": self.advanced_audit_transform,
2683                     },
2684                     "AuditKerberosAuthenticationService": {
2685                         "Policy": "Audit Kerberos Authentication Service",
2686                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2687                         "Settings": self.advanced_audit_lookup.keys(),
2688                         "AdvAudit": {
2689                             "Option": "Audit Kerberos Authentication Service",
2690                         },
2691                         "Transform": self.advanced_audit_transform,
2692                     },
2693                     "AuditKerberosServiceTicketOperations": {
2694                         "Policy": "Audit Kerberos Service Ticket Operations",
2695                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2696                         "Settings": self.advanced_audit_lookup.keys(),
2697                         "AdvAudit": {
2698                             "Option": "Audit Kerberos Service Ticket Operations",
2699                         },
2700                         "Transform": self.advanced_audit_transform,
2701                     },
2702                     "AuditOtherAccountLogonEvents": {
2703                         "Policy": "Audit Other Account Logon Events",
2704                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2705                         "Settings": self.advanced_audit_lookup.keys(),
2706                         "AdvAudit": {"Option": "Audit Other Account Logon Events"},
2707                         "Transform": self.advanced_audit_transform,
2708                     },
2709                     "AuditApplicationGroupManagement": {
2710                         "Policy": "Audit Application Group Management",
2711                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2712                         "Settings": self.advanced_audit_lookup.keys(),
2713                         "AdvAudit": {"Option": "Audit Application Group Management"},
2714                         "Transform": self.advanced_audit_transform,
2715                     },
2716                     "AuditComputerAccountManagement": {
2717                         "Policy": "Audit Computer Account Management",
2718                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2719                         "Settings": self.advanced_audit_lookup.keys(),
2720                         "AdvAudit": {"Option": "Audit Computer Account Management"},
2721                         "Transform": self.advanced_audit_transform,
2722                     },
2723                     "AuditDistributionGroupManagement": {
2724                         "Policy": "Audit Distribution Group Management",
2725                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2726                         "Settings": self.advanced_audit_lookup.keys(),
2727                         "AdvAudit": {"Option": "Audit Distribution Group Management"},
2728                         "Transform": self.advanced_audit_transform,
2729                     },
2730                     "AuditOtherAccountManagementEvents": {
2731                         "Policy": "Audit Other Account Management Events",
2732                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2733                         "Settings": self.advanced_audit_lookup.keys(),
2734                         "AdvAudit": {
2735                             "Option": "Audit Other Account Management Events",
2736                         },
2737                         "Transform": self.advanced_audit_transform,
2738                     },
2739                     "AuditSecurityGroupManagement": {
2740                         "Policy": "Audit Security Group Management",
2741                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2742                         "Settings": self.advanced_audit_lookup.keys(),
2743                         "AdvAudit": {"Option": "Audit Security Group Management"},
2744                         "Transform": self.advanced_audit_transform,
2745                     },
2746                     "AuditUserAccountManagement": {
2747                         "Policy": "Audit User Account Management",
2748                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2749                         "Settings": self.advanced_audit_lookup.keys(),
2750                         "AdvAudit": {"Option": "Audit User Account Management"},
2751                         "Transform": self.advanced_audit_transform,
2752                     },
2753                     "AuditDPAPIActivity": {
2754                         "Policy": "Audit DPAPI Activity",
2755                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2756                         "Settings": self.advanced_audit_lookup.keys(),
2757                         "AdvAudit": {"Option": "Audit DPAPI Activity"},
2758                         "Transform": self.advanced_audit_transform,
2759                     },
2760                     "AuditPNPActivity": {
2761                         "Policy": "Audit PNP Activity",
2762                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2763                         "Settings": self.advanced_audit_lookup.keys(),
2764                         "AdvAudit": {"Option": "Audit PNP Activity"},
2765                         "Transform": self.advanced_audit_transform,
2766                     },
2767                     "AuditProcessCreation": {
2768                         "Policy": "Audit Process Creation",
2769                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2770                         "Settings": self.advanced_audit_lookup.keys(),
2771                         "AdvAudit": {"Option": "Audit Process Creation"},
2772                         "Transform": self.advanced_audit_transform,
2773                     },
2774                     "AuditProcessTermination": {
2775                         "Policy": "Audit Process Termination",
2776                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2777                         "Settings": self.advanced_audit_lookup.keys(),
2778                         "AdvAudit": {"Option": "Audit Process Termination"},
2779                         "Transform": self.advanced_audit_transform,
2780                     },
2781                     "AuditRPCEvents": {
2782                         "Policy": "Audit RPC Events",
2783                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2784                         "Settings": self.advanced_audit_lookup.keys(),
2785                         "AdvAudit": {"Option": "Audit RPC Events"},
2786                         "Transform": self.advanced_audit_transform,
2787                     },
2788                     "AuditTokenRightAdjusted": {
2789                         "Policy": "Audit Token Right Adjusted",
2790                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2791                         "Settings": self.advanced_audit_lookup.keys(),
2792                         "AdvAudit": {"Option": "Audit Token Right Adjusted"},
2793                         "Transform": self.advanced_audit_transform,
2794                     },
2795                     "AuditDetailedDirectoryServiceReplication": {
2796                         "Policy": "Audit Detailed Directory Service Replication",
2797                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2798                         "Settings": self.advanced_audit_lookup.keys(),
2799                         "AdvAudit": {
2800                             "Option": "Audit Detailed Directory Service Replication",
2801                         },
2802                         "Transform": self.advanced_audit_transform,
2803                     },
2804                     "AuditDirectoryServiceAccess": {
2805                         "Policy": "Audit Directory Service Access",
2806                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2807                         "Settings": self.advanced_audit_lookup.keys(),
2808                         "AdvAudit": {"Option": "Audit Directory Service Access"},
2809                         "Transform": self.advanced_audit_transform,
2810                     },
2811                     "AuditDirectoryServiceChanges": {
2812                         "Policy": "Audit Directory Service Changes",
2813                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2814                         "Settings": self.advanced_audit_lookup.keys(),
2815                         "AdvAudit": {"Option": "Audit Directory Service Changes"},
2816                         "Transform": self.advanced_audit_transform,
2817                     },
2818                     "AuditDirectoryServiceReplication": {
2819                         "Policy": "Audit Directory Service Replication",
2820                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2821                         "Settings": self.advanced_audit_lookup.keys(),
2822                         "AdvAudit": {"Option": "Audit Directory Service Replication"},
2823                         "Transform": self.advanced_audit_transform,
2824                     },
2825                     "AuditAccountLockout": {
2826                         "Policy": "Audit Account Lockout",
2827                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2828                         "Settings": self.advanced_audit_lookup.keys(),
2829                         "AdvAudit": {"Option": "Audit Account Lockout"},
2830                         "Transform": self.advanced_audit_transform,
2831                     },
2832                     "AuditUserDeviceClaims": {
2833                         "Policy": "Audit User / Device Claims",
2834                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2835                         "Settings": self.advanced_audit_lookup.keys(),
2836                         "AdvAudit": {"Option": "Audit User / Device Claims"},
2837                         "Transform": self.advanced_audit_transform,
2838                     },
2839                     "AuditGroupMembership": {
2840                         "Policy": "Audit Group Membership",
2841                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2842                         "Settings": self.advanced_audit_lookup.keys(),
2843                         "AdvAudit": {"Option": "Audit Group Membership"},
2844                         "Transform": self.advanced_audit_transform,
2845                     },
2846                     "AuditIPsecExtendedMode": {
2847                         "Policy": "Audit IPsec Extended Mode",
2848                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2849                         "Settings": self.advanced_audit_lookup.keys(),
2850                         "AdvAudit": {"Option": "Audit IPsec Extended Mode"},
2851                         "Transform": self.advanced_audit_transform,
2852                     },
2853                     "AuditIPsecMainMode": {
2854                         "Policy": "Audit IPsec Main Mode",
2855                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2856                         "Settings": self.advanced_audit_lookup.keys(),
2857                         "AdvAudit": {"Option": "Audit IPsec Main Mode"},
2858                         "Transform": self.advanced_audit_transform,
2859                     },
2860                     "AuditIPsecQuickMode": {
2861                         "Policy": "Audit IPsec Quick Mode",
2862                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2863                         "Settings": self.advanced_audit_lookup.keys(),
2864                         "AdvAudit": {"Option": "Audit IPsec Quick Mode"},
2865                         "Transform": self.advanced_audit_transform,
2866                     },
2867                     "AuditLogoff": {
2868                         "Policy": "Audit Logoff",
2869                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2870                         "Settings": self.advanced_audit_lookup.keys(),
2871                         "AdvAudit": {"Option": "Audit Logoff"},
2872                         "Transform": self.advanced_audit_transform,
2873                     },
2874                     "AuditLogon": {
2875                         "Policy": "Audit Logon",
2876                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2877                         "Settings": self.advanced_audit_lookup.keys(),
2878                         "AdvAudit": {"Option": "Audit Logon"},
2879                         "Transform": self.advanced_audit_transform,
2880                     },
2881                     "AuditNetworkPolicyServer": {
2882                         "Policy": "Audit Network Policy Server",
2883                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2884                         "Settings": self.advanced_audit_lookup.keys(),
2885                         "AdvAudit": {"Option": "Audit Network Policy Server"},
2886                         "Transform": self.advanced_audit_transform,
2887                     },
2888                     "AuditOtherLogonLogoffEvents": {
2889                         "Policy": "Audit Other Logon/Logoff Events",
2890                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2891                         "Settings": self.advanced_audit_lookup.keys(),
2892                         "AdvAudit": {"Option": "Audit Other Logon/Logoff Events"},
2893                         "Transform": self.advanced_audit_transform,
2894                     },
2895                     "AuditSpecialLogon": {
2896                         "Policy": "Audit Special Logon",
2897                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2898                         "Settings": self.advanced_audit_lookup.keys(),
2899                         "AdvAudit": {"Option": "Audit Special Logon"},
2900                         "Transform": self.advanced_audit_transform,
2901                     },
2902                     "AuditApplicationGenerated": {
2903                         "Policy": "Audit Application Generated",
2904                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2905                         "Settings": self.advanced_audit_lookup.keys(),
2906                         "AdvAudit": {"Option": "Audit Application Generated"},
2907                         "Transform": self.advanced_audit_transform,
2908                     },
2909                     "AuditCertificationServices": {
2910                         "Policy": "Audit Certification Services",
2911                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2912                         "Settings": self.advanced_audit_lookup.keys(),
2913                         "AdvAudit": {"Option": "Audit Certification Services"},
2914                         "Transform": self.advanced_audit_transform,
2915                     },
2916                     "AuditDetailedFileShare": {
2917                         "Policy": "Audit Detailed File Share",
2918                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2919                         "Settings": self.advanced_audit_lookup.keys(),
2920                         "AdvAudit": {"Option": "Audit Detailed File Share"},
2921                         "Transform": self.advanced_audit_transform,
2922                     },
2923                     "AuditFileShare": {
2924                         "Policy": "Audit File Share",
2925                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2926                         "Settings": self.advanced_audit_lookup.keys(),
2927                         "AdvAudit": {"Option": "Audit File Share"},
2928                         "Transform": self.advanced_audit_transform,
2929                     },
2930                     "AuditFileSystem": {
2931                         "Policy": "Audit File System",
2932                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2933                         "Settings": self.advanced_audit_lookup.keys(),
2934                         "AdvAudit": {"Option": "Audit File System"},
2935                         "Transform": self.advanced_audit_transform,
2936                     },
2937                     "AuditFilteringPlatformConnection": {
2938                         "Policy": "Audit Filtering Platform Connection",
2939                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2940                         "Settings": self.advanced_audit_lookup.keys(),
2941                         "AdvAudit": {"Option": "Audit Filtering Platform Connection"},
2942                         "Transform": self.advanced_audit_transform,
2943                     },
2944                     "AuditFilteringPlatformPacketDrop": {
2945                         "Policy": "Audit Filtering Platform Packet Drop",
2946                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2947                         "Settings": self.advanced_audit_lookup.keys(),
2948                         "AdvAudit": {"Option": "Audit Filtering Platform Packet Drop"},
2949                         "Transform": self.advanced_audit_transform,
2950                     },
2951                     "AuditHandleManipulation": {
2952                         "Policy": "Audit Handle Manipulation",
2953                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2954                         "Settings": self.advanced_audit_lookup.keys(),
2955                         "AdvAudit": {"Option": "Audit Handle Manipulation"},
2956                         "Transform": self.advanced_audit_transform,
2957                     },
2958                     "AuditKernelObject": {
2959                         "Policy": "Audit Kernel Object",
2960                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2961                         "Settings": self.advanced_audit_lookup.keys(),
2962                         "AdvAudit": {"Option": "Audit Kernel Object"},
2963                         "Transform": self.advanced_audit_transform,
2964                     },
2965                     "AuditOtherObjectAccessEvents": {
2966                         "Policy": "Audit Other Object Access Events",
2967                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2968                         "Settings": self.advanced_audit_lookup.keys(),
2969                         "AdvAudit": {"Option": "Audit Other Object Access Events"},
2970                         "Transform": self.advanced_audit_transform,
2971                     },
2972                     "AuditRegistry": {
2973                         "Policy": "Audit Registry",
2974                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2975                         "Settings": self.advanced_audit_lookup.keys(),
2976                         "AdvAudit": {"Option": "Audit Registry"},
2977                         "Transform": self.advanced_audit_transform,
2978                     },
2979                     "AuditRemovableStorage": {
2980                         "Policy": "Audit Removable Storage",
2981                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2982                         "Settings": self.advanced_audit_lookup.keys(),
2983                         "AdvAudit": {"Option": "Audit Removable Storage"},
2984                         "Transform": self.advanced_audit_transform,
2985                     },
2986                     "AuditSAM": {
2987                         "Policy": "Audit SAM",
2988                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2989                         "Settings": self.advanced_audit_lookup.keys(),
2990                         "AdvAudit": {"Option": "Audit SAM"},
2991                         "Transform": self.advanced_audit_transform,
2992                     },
2993                     "AuditCentralAccessPolicyStaging": {
2994                         "Policy": "Audit Central Access Policy Staging",
2995                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2996                         "Settings": self.advanced_audit_lookup.keys(),
2997                         "AdvAudit": {"Option": "Audit Central Access Policy Staging"},
2998                         "Transform": self.advanced_audit_transform,
2999                     },
3000                     "AuditAuditPolicyChange": {
3001                         "Policy": "Audit Audit Policy Change",
3002                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3003                         "Settings": self.advanced_audit_lookup.keys(),
3004                         "AdvAudit": {"Option": "Audit Audit Policy Change"},
3005                         "Transform": self.advanced_audit_transform,
3006                     },
3007                     "AuditAuthenticationPolicyChange": {
3008                         "Policy": "Audit Authentication Policy Change",
3009                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3010                         "Settings": self.advanced_audit_lookup.keys(),
3011                         "AdvAudit": {"Option": "Audit Authentication Policy Change"},
3012                         "Transform": self.advanced_audit_transform,
3013                     },
3014                     "AuditAuthorizationPolicyChange": {
3015                         "Policy": "Audit Authorization Policy Change",
3016                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3017                         "Settings": self.advanced_audit_lookup.keys(),
3018                         "AdvAudit": {"Option": "Audit Authorization Policy Change"},
3019                         "Transform": self.advanced_audit_transform,
3020                     },
3021                     "AuditFilteringPlatformPolicyChange": {
3022                         "Policy": "Audit Filtering Platform Policy Change",
3023                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3024                         "Settings": self.advanced_audit_lookup.keys(),
3025                         "AdvAudit": {
3026                             "Option": "Audit Filtering Platform Policy Change",
3027                         },
3028                         "Transform": self.advanced_audit_transform,
3029                     },
3030                     "AuditMPSSVCRuleLevelPolicyChange": {
3031                         "Policy": "Audit MPSSVC Rule-Level Policy Change",
3032                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3033                         "Settings": self.advanced_audit_lookup.keys(),
3034                         "AdvAudit": {
3035                             "Option": "Audit MPSSVC Rule-Level Policy Change",
3036                         },
3037                         "Transform": self.advanced_audit_transform,
3038                     },
3039                     "AuditOtherPolicyChangeEvents": {
3040                         "Policy": "Audit Other Policy Change Events",
3041                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3042                         "Settings": self.advanced_audit_lookup.keys(),
3043                         "AdvAudit": {"Option": "Audit Other Policy Change Events"},
3044                         "Transform": self.advanced_audit_transform,
3045                     },
3046                     "AuditNonSensitivePrivilegeUse": {
3047                         "Policy": "Audit Non Sensitive Privilege Use",
3048                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3049                         "Settings": self.advanced_audit_lookup.keys(),
3050                         "AdvAudit": {"Option": "Audit Non Sensitive Privilege Use"},
3051                         "Transform": self.advanced_audit_transform,
3052                     },
3053                     "AuditOtherPrivilegeUseEvents": {
3054                         "Policy": "Audit Other Privilege Use Events",
3055                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3056                         "Settings": self.advanced_audit_lookup.keys(),
3057                         "AdvAudit": {"Option": "Audit Other Privilege Use Events"},
3058                         "Transform": self.advanced_audit_transform,
3059                     },
3060                     "AuditSensitivePrivilegeUse": {
3061                         "Policy": "Audit Sensitive Privilege Use",
3062                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3063                         "Settings": self.advanced_audit_lookup.keys(),
3064                         "AdvAudit": {"Option": "Audit Sensitive Privilege Use"},
3065                         "Transform": self.advanced_audit_transform,
3066                     },
3067                     "AuditIPsecDriver": {
3068                         "Policy": "Audit IPsec Driver",
3069                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3070                         "Settings": self.advanced_audit_lookup.keys(),
3071                         "AdvAudit": {"Option": "Audit IPsec Driver"},
3072                         "Transform": self.advanced_audit_transform,
3073                     },
3074                     "AuditOtherSystemEvents": {
3075                         "Policy": "Audit Other System Events",
3076                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3077                         "Settings": self.advanced_audit_lookup.keys(),
3078                         "AdvAudit": {"Option": "Audit Other System Events"},
3079                         "Transform": self.advanced_audit_transform,
3080                     },
3081                     "AuditSecurityStateChange": {
3082                         "Policy": "Audit Security State Change",
3083                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3084                         "Settings": self.advanced_audit_lookup.keys(),
3085                         "AdvAudit": {"Option": "Audit Security State Change"},
3086                         "Transform": self.advanced_audit_transform,
3087                     },
3088                     "AuditSecuritySystemExtension": {
3089                         "Policy": "Audit Security System Extension",
3090                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3091                         "Settings": self.advanced_audit_lookup.keys(),
3092                         "AdvAudit": {"Option": "Audit Security System Extension"},
3093                         "Transform": self.advanced_audit_transform,
3094                     },
3095                     "AuditSystemIntegrity": {
3096                         "Policy": "Audit System Integrity",
3097                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3098                         "Settings": self.advanced_audit_lookup.keys(),
3099                         "AdvAudit": {"Option": "Audit System Integrity"},
3100                         "Transform": self.advanced_audit_transform,
3101                     },
3102                     "SeTrustedCredManAccessPrivilege": {
3103                         "Policy": "Access Credential Manager as a trusted caller",
3104                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3105                         "rights_assignment": True,
3106                         "Settings": None,
3107                         "LsaRights": {"Option": "SeTrustedCredManAccessPrivilege"},
3108                         "Transform": {
3109                             "Get": "_sidConversion",
3110                             "Put": "_usernamesToSidObjects",
3111                         },
3112                     },
3113                     "SeNetworkLogonRight": {
3114                         "Policy": "Access this computer from the network",
3115                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3116                         "rights_assignment": True,
3117                         "Settings": None,
3118                         "LsaRights": {"Option": "SeNetworkLogonRight"},
3119                         "Transform": {
3120                             "Get": "_sidConversion",
3121                             "Put": "_usernamesToSidObjects",
3122                         },
3123                     },
3124                     "SeTcbPrivilege": {
3125                         "Policy": "Act as part of the operating system",
3126                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3127                         "rights_assignment": True,
3128                         "Settings": None,
3129                         "LsaRights": {"Option": "SeTcbPrivilege"},
3130                         "Transform": {
3131                             "Get": "_sidConversion",
3132                             "Put": "_usernamesToSidObjects",
3133                         },
3134                     },
3135                     "SeMachineAccountPrivilege": {
3136                         "Policy": "Add workstations to domain",
3137                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3138                         "rights_assignment": True,
3139                         "Settings": None,
3140                         "LsaRights": {"Option": "SeMachineAccountPrivilege"},
3141                         "Transform": {
3142                             "Get": "_sidConversion",
3143                             "Put": "_usernamesToSidObjects",
3144                         },
3145                     },
3146                     "SeIncreaseQuotaPrivilege": {
3147                         "Policy": "Adjust memory quotas for a process",
3148                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3149                         "rights_assignment": True,
3150                         "Settings": None,
3151                         "LsaRights": {"Option": "SeIncreaseQuotaPrivilege"},
3152                         "Transform": {
3153                             "Get": "_sidConversion",
3154                             "Put": "_usernamesToSidObjects",
3155                         },
3156                     },
3157                     "SeInteractiveLogonRight": {
3158                         "Policy": "Allow log on locally",
3159                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3160                         "rights_assignment": True,
3161                         "Settings": None,
3162                         "LsaRights": {"Option": "SeInteractiveLogonRight"},
3163                         "Transform": {
3164                             "Get": "_sidConversion",
3165                             "Put": "_usernamesToSidObjects",
3166                         },
3167                     },
3168                     "SeRemoteInteractiveLogonRight": {
3169                         "Policy": "Allow log on through Remote Desktop Services",
3170                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3171                         "rights_assignment": True,
3172                         "Settings": None,
3173                         "LsaRights": {"Option": "SeRemoteInteractiveLogonRight"},
3174                         "Transform": {
3175                             "Get": "_sidConversion",
3176                             "Put": "_usernamesToSidObjects",
3177                         },
3178                     },
3179                     "SeBackupPrivilege": {
3180                         "Policy": "Backup files and directories",
3181                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3182                         "rights_assignment": True,
3183                         "Settings": None,
3184                         "LsaRights": {"Option": "SeBackupPrivilege"},
3185                         "Transform": {
3186                             "Get": "_sidConversion",
3187                             "Put": "_usernamesToSidObjects",
3188                         },
3189                     },
3190                     "SeChangeNotifyPrivilege": {
3191                         "Policy": "Bypass traverse checking",
3192                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3193                         "rights_assignment": True,
3194                         "Settings": None,
3195                         "LsaRights": {"Option": "SeChangeNotifyPrivilege"},
3196                         "Transform": {
3197                             "Get": "_sidConversion",
3198                             "Put": "_usernamesToSidObjects",
3199                         },
3200                     },
3201                     "SeSystemtimePrivilege": {
3202                         "Policy": "Change the system time",
3203                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3204                         "rights_assignment": True,
3205                         "Settings": None,
3206                         "LsaRights": {"Option": "SeSystemtimePrivilege"},
3207                         "Transform": {
3208                             "Get": "_sidConversion",
3209                             "Put": "_usernamesToSidObjects",
3210                         },
3211                     },
3212                     "SeTimeZonePrivilege": {
3213                         "Policy": "Change the time zone",
3214                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3215                         "rights_assignment": True,
3216                         "Settings": None,
3217                         "LsaRights": {"Option": "SeTimeZonePrivilege"},
3218                         "Transform": {
3219                             "Get": "_sidConversion",
3220                             "Put": "_usernamesToSidObjects",
3221                         },
3222                     },
3223                     "SeCreatePagefilePrivilege": {
3224                         "Policy": "Create a pagefile",
3225                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3226                         "rights_assignment": True,
3227                         "Settings": None,
3228                         "LsaRights": {"Option": "SeCreatePagefilePrivilege"},
3229                         "Transform": {
3230                             "Get": "_sidConversion",
3231                             "Put": "_usernamesToSidObjects",
3232                         },
3233                     },
3234                     "SeCreateTokenPrivilege": {
3235                         "Policy": "Create a token object",
3236                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3237                         "rights_assignment": True,
3238                         "Settings": None,
3239                         "LsaRights": {"Option": "SeCreateTokenPrivilege"},
3240                         "Transform": {
3241                             "Get": "_sidConversion",
3242                             "Put": "_usernamesToSidObjects",
3243                         },
3244                     },
3245                     "SeCreateGlobalPrivilege": {
3246                         "Policy": "Create global objects",
3247                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3248                         "rights_assignment": True,
3249                         "Settings": None,
3250                         "LsaRights": {"Option": "SeCreateGlobalPrivilege"},
3251                         "Transform": {
3252                             "Get": "_sidConversion",
3253                             "Put": "_usernamesToSidObjects",
3254                         },
3255                     },
3256                     "SeCreatePermanentPrivilege": {
3257                         "Policy": "Create permanent shared objects",
3258                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3259                         "rights_assignment": True,
3260                         "Settings": None,
3261                         "LsaRights": {"Option": "SeCreatePermanentPrivilege"},
3262                         "Transform": {
3263                             "Get": "_sidConversion",
3264                             "Put": "_usernamesToSidObjects",
3265                         },
3266                     },
3267                     "SeCreateSymbolicLinkPrivilege": {
3268                         "Policy": "Create symbolic links",
3269                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3270                         "rights_assignment": True,
3271                         "Settings": None,
3272                         "LsaRights": {"Option": "SeCreateSymbolicLinkPrivilege"},
3273                         "Transform": {
3274                             "Get": "_sidConversion",
3275                             "Put": "_usernamesToSidObjects",
3276                         },
3277                     },
3278                     "SeDebugPrivilege": {
3279                         "Policy": "Debug programs",
3280                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3281                         "rights_assignment": True,
3282                         "Settings": None,
3283                         "LsaRights": {"Option": "SeDebugPrivilege"},
3284                         "Transform": {
3285                             "Get": "_sidConversion",
3286                             "Put": "_usernamesToSidObjects",
3287                         },
3288                     },
3289                     "SeDenyNetworkLogonRight": {
3290                         "Policy": "Deny access to this computer from the network",
3291                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3292                         "rights_assignment": True,
3293                         "Settings": None,
3294                         "LsaRights": {"Option": "SeDenyNetworkLogonRight"},
3295                         "Transform": {
3296                             "Get": "_sidConversion",
3297                             "Put": "_usernamesToSidObjects",
3298                         },
3299                     },
3300                     "SeDenyBatchLogonRight": {
3301                         "Policy": "Deny log on as a batch job",
3302                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3303                         "rights_assignment": True,
3304                         "Settings": None,
3305                         "LsaRights": {"Option": "SeDenyBatchLogonRight"},
3306                         "Transform": {
3307                             "Get": "_sidConversion",
3308                             "Put": "_usernamesToSidObjects",
3309                         },
3310                     },
3311                     "SeDenyServiceLogonRight": {
3312                         "Policy": "Deny log on as a service",
3313                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3314                         "rights_assignment": True,
3315                         "Settings": None,
3316                         "LsaRights": {"Option": "SeDenyServiceLogonRight"},
3317                         "Transform": {
3318                             "Get": "_sidConversion",
3319                             "Put": "_usernamesToSidObjects",
3320                         },
3321                     },
3322                     "SeDenyInteractiveLogonRight": {
3323                         "Policy": "Deny log on locally",
3324                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3325                         "rights_assignment": True,
3326                         "Settings": None,
3327                         "LsaRights": {"Option": "SeDenyInteractiveLogonRight"},
3328                         "Transform": {
3329                             "Get": "_sidConversion",
3330                             "Put": "_usernamesToSidObjects",
3331                         },
3332                     },
3333                     "SeDenyRemoteInteractiveLogonRight": {
3334                         "Policy": "Deny log on through Remote Desktop Services",
3335                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3336                         "rights_assignment": True,
3337                         "Settings": None,
3338                         "LsaRights": {"Option": "SeDenyRemoteInteractiveLogonRight"},
3339                         "Transform": {
3340                             "Get": "_sidConversion",
3341                             "Put": "_usernamesToSidObjects",
3342                         },
3343                     },
3344                     "SeEnableDelegationPrivilege": {
3345                         "Policy": (
3346                             "Enable computer and user accounts to be "
3347                             "trusted for delegation"
3348                         ),
3349                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3350                         "rights_assignment": True,
3351                         "Settings": None,
3352                         "LsaRights": {"Option": "SeEnableDelegationPrivilege"},
3353                         "Transform": {
3354                             "Get": "_sidConversion",
3355                             "Put": "_usernamesToSidObjects",
3356                         },
3357                     },
3358                     "SeRemoteShutdownPrivilege": {
3359                         "Policy": "Force shutdown from a remote system",
3360                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3361                         "rights_assignment": True,
3362                         "Settings": None,
3363                         "LsaRights": {"Option": "SeRemoteShutdownPrivilege"},
3364                         "Transform": {
3365                             "Get": "_sidConversion",
3366                             "Put": "_usernamesToSidObjects",
3367                         },
3368                     },
3369                     "SeAuditPrivilege": {
3370                         "Policy": "Generate security audits",
3371                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3372                         "rights_assignment": True,
3373                         "Settings": None,
3374                         "LsaRights": {"Option": "SeAuditPrivilege"},
3375                         "Transform": {
3376                             "Get": "_sidConversion",
3377                             "Put": "_usernamesToSidObjects",
3378                         },
3379                     },
3380                     "SeImpersonatePrivilege": {
3381                         "Policy": "Impersonate a client after authentication",
3382                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3383                         "rights_assignment": True,
3384                         "Settings": None,
3385                         "LsaRights": {"Option": "SeImpersonatePrivilege"},
3386                         "Transform": {
3387                             "Get": "_sidConversion",
3388                             "Put": "_usernamesToSidObjects",
3389                         },
3390                     },
3391                     "SeIncreaseWorkingSetPrivilege": {
3392                         "Policy": "Increase a process working set",
3393                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3394                         "rights_assignment": True,
3395                         "Settings": None,
3396                         "LsaRights": {"Option": "SeIncreaseWorkingSetPrivilege"},
3397                         "Transform": {
3398                             "Get": "_sidConversion",
3399                             "Put": "_usernamesToSidObjects",
3400                         },
3401                     },
3402                     "SeIncreaseBasePriorityPrivilege": {
3403                         "Policy": "Increase scheduling priority",
3404                         "rights_assignment": True,
3405                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3406                         "Settings": None,
3407                         "LsaRights": {"Option": "SeIncreaseBasePriorityPrivilege"},
3408                         "Transform": {
3409                             "Get": "_sidConversion",
3410                             "Put": "_usernamesToSidObjects",
3411                         },
3412                     },
3413                     "SeLoadDriverPrivilege": {
3414                         "Policy": "Load and unload device drivers",
3415                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3416                         "rights_assignment": True,
3417                         "Settings": None,
3418                         "LsaRights": {"Option": "SeLoadDriverPrivilege"},
3419                         "Transform": {
3420                             "Get": "_sidConversion",
3421                             "Put": "_usernamesToSidObjects",
3422                         },
3423                     },
3424                     "SeLockMemoryPrivilege": {
3425                         "Policy": "Lock pages in memory",
3426                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3427                         "rights_assignment": True,
3428                         "Settings": None,
3429                         "LsaRights": {"Option": "SeLockMemoryPrivilege"},
3430                         "Transform": {
3431                             "Get": "_sidConversion",
3432                             "Put": "_usernamesToSidObjects",
3433                         },
3434                     },
3435                     "SeBatchLogonRight": {
3436                         "Policy": "Log on as a batch job",
3437                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3438                         "rights_assignment": True,
3439                         "Settings": None,
3440                         "LsaRights": {"Option": "SeBatchLogonRight"},
3441                         "Transform": {
3442                             "Get": "_sidConversion",
3443                             "Put": "_usernamesToSidObjects",
3444                         },
3445                     },
3446                     "SeServiceLogonRight": {
3447                         "Policy": "Log on as a service",
3448                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3449                         "rights_assignment": True,
3450                         "Settings": None,
3451                         "LsaRights": {"Option": "SeServiceLogonRight"},
3452                         "Transform": {
3453                             "Get": "_sidConversion",
3454                             "Put": "_usernamesToSidObjects",
3455                         },
3456                     },
3457                     "SeSecurityPrivilege": {
3458                         "Policy": "Manage auditing and security log",
3459                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3460                         "rights_assignment": True,
3461                         "Settings": None,
3462                         "LsaRights": {"Option": "SeSecurityPrivilege"},
3463                         "Transform": {
3464                             "Get": "_sidConversion",
3465                             "Put": "_usernamesToSidObjects",
3466                         },
3467                     },
3468                     "SeRelabelPrivilege": {
3469                         "Policy": "Modify an object label",
3470                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3471                         "rights_assignment": True,
3472                         "Settings": None,
3473                         "LsaRights": {"Option": "SeRelabelPrivilege"},
3474                         "Transform": {
3475                             "Get": "_sidConversion",
3476                             "Put": "_usernamesToSidObjects",
3477                         },
3478                     },
3479                     "SeSystemEnvironmentPrivilege": {
3480                         "Policy": "Modify firmware environment values",
3481                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3482                         "rights_assignment": True,
3483                         "Settings": None,
3484                         "LsaRights": {"Option": "SeSystemEnvironmentPrivilege"},
3485                         "Transform": {
3486                             "Get": "_sidConversion",
3487                             "Put": "_usernamesToSidObjects",
3488                         },
3489                     },
3490                     "SeManageVolumePrivilege": {
3491                         "Policy": "Perform volume maintenance tasks",
3492                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3493                         "rights_assignment": True,
3494                         "Settings": None,
3495                         "LsaRights": {"Option": "SeManageVolumePrivilege"},
3496                         "Transform": {
3497                             "Get": "_sidConversion",
3498                             "Put": "_usernamesToSidObjects",
3499                         },
3500                     },
3501                     "SeProfileSingleProcessPrivilege": {
3502                         "Policy": "Profile single process",
3503                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3504                         "rights_assignment": True,
3505                         "Settings": None,
3506                         "LsaRights": {"Option": "SeProfileSingleProcessPrivilege"},
3507                         "Transform": {
3508                             "Get": "_sidConversion",
3509                             "Put": "_usernamesToSidObjects",
3510                         },
3511                     },
3512                     "SeSystemProfilePrivilege": {
3513                         "Policy": "Profile system performance",
3514                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3515                         "rights_assignment": True,
3516                         "Settings": None,
3517                         "LsaRights": {"Option": "SeSystemProfilePrivilege"},
3518                         "Transform": {
3519                             "Get": "_sidConversion",
3520                             "Put": "_usernamesToSidObjects",
3521                         },
3522                     },
3523                     "SeUndockPrivilege": {
3524                         "Policy": "Remove computer from docking station",
3525                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3526                         "rights_assignment": True,
3527                         "Settings": None,
3528                         "LsaRights": {"Option": "SeUndockPrivilege"},
3529                         "Transform": {
3530                             "Get": "_sidConversion",
3531                             "Put": "_usernamesToSidObjects",
3532                         },
3533                     },
3534                     "SeAssignPrimaryTokenPrivilege": {
3535                         "Policy": "Replace a process level token",
3536                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3537                         "rights_assignment": True,
3538                         "Settings": None,
3539                         "LsaRights": {"Option": "SeAssignPrimaryTokenPrivilege"},
3540                         "Transform": {
3541                             "Get": "_sidConversion",
3542                             "Put": "_usernamesToSidObjects",
3543                         },
3544                     },
3545                     "SeRestorePrivilege": {
3546                         "Policy": "Restore files and directories",
3547                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3548                         "rights_assignment": True,
3549                         "Settings": None,
3550                         "LsaRights": {"Option": "SeRestorePrivilege"},
3551                         "Transform": {
3552                             "Get": "_sidConversion",
3553                             "Put": "_usernamesToSidObjects",
3554                         },
3555                     },
3556                     "SeShutdownPrivilege": {
3557                         "Policy": "Shut down the system",
3558                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3559                         "rights_assignment": True,
3560                         "Settings": None,
3561                         "LsaRights": {"Option": "SeShutdownPrivilege"},
3562                         "Transform": {
3563                             "Get": "_sidConversion",
3564                             "Put": "_usernamesToSidObjects",
3565                         },
3566                     },
3567                     "SeSyncAgentPrivilege": {
3568                         "Policy": "Synchronize directory service data",
3569                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3570                         "rights_assignment": True,
3571                         "Settings": None,
3572                         "LsaRights": {"Option": "SeSyncAgentPrivilege"},
3573                         "Transform": {
3574                             "Get": "_sidConversion",
3575                             "Put": "_usernamesToSidObjects",
3576                         },
3577                     },
3578                     "SeTakeOwnershipPrivilege": {
3579                         "Policy": "Take ownership of files or other objects",
3580                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3581                         "rights_assignment": True,
3582                         "Settings": None,
3583                         "LsaRights": {"Option": "SeTakeOwnershipPrivilege"},
3584                         "Transform": {
3585                             "Get": "_sidConversion",
3586                             "Put": "_usernamesToSidObjects",
3587                         },
3588                     },
3589                     "RecoveryConsoleSecurityLevel": {
3590                         "Policy": (
3591                             "Recovery console: Allow automatic administrative logon"
3592                         ),
3593                         "Settings": self.enabled_one_disabled_zero.keys(),
3594                         "lgpo_section": self.security_options_gpedit_path,
3595                         "Registry": {
3596                             "Hive": "HKEY_LOCAL_MACHINE",
3597                             "Path": (
3598                                 "Software\\Microsoft\\Windows NT\\"
3599                                 "CurrentVersion\\Setup\\RecoveryConsole"
3600                             ),
3601                             "Value": "SecurityLevel",
3602                             "Type": "REG_DWORD",
3603                         },
3604                         "Transform": self.enabled_one_disabled_zero_transform,
3605                     },
3606                     "RecoveryConsoleSetCommand": {
3607                         "Policy": (
3608                             "Recovery console: Allow floppy copy and "
3609                             "access to all drives and all folders"
3610                         ),
3611                         "Settings": self.enabled_one_disabled_zero.keys(),
3612                         "lgpo_section": self.security_options_gpedit_path,
3613                         "Registry": {
3614                             "Hive": "HKEY_LOCAL_MACHINE",
3615                             "Path": (
3616                                 "Software\\Microsoft\\Windows NT\\"
3617                                 "CurrentVersion\\Setup\\RecoveryConsole"
3618                             ),
3619                             "Value": "SetCommand",
3620                             "Type": "REG_DWORD",
3621                         },
3622                         "Transform": self.enabled_one_disabled_zero_transform,
3623                     },
3624                     "ForceKeyProtection": {
3625                         "Policy": (
3626                             "System Cryptography: Force strong key protection for "
3627                             "user keys stored on the computer"
3628                         ),
3629                         "Settings": self.force_key_protection.keys(),
3630                         "lgpo_section": self.security_options_gpedit_path,
3631                         "Registry": {
3632                             "Hive": "HKEY_LOCAL_MACHINE",
3633                             "Path": "Software\\Policies\\Microsoft\\Cryptography",
3634                             "Value": "ForceKeyProtection",
3635                             "Type": "REG_DWORD",
3636                         },
3637                         "Transform": {
3638                             "Get": "_dict_lookup",
3639                             "Put": "_dict_lookup",
3640                             "GetArgs": {
3641                                 "lookup": self.force_key_protection,
3642                                 "value_lookup": False,
3643                             },
3644                             "PutArgs": {
3645                                 "lookup": self.force_key_protection,
3646                                 "value_lookup": True,
3647                             },
3648                         },
3649                     },
3650                     "FIPSAlgorithmPolicy": {
3651                         "Policy": (
3652                             "System Cryptography: Use FIPS compliant algorithms "
3653                             "for encryption, hashing, and signing"
3654                         ),
3655                         "Settings": self.enabled_one_disabled_zero.keys(),
3656                         "lgpo_section": self.security_options_gpedit_path,
3657                         "Registry": {
3658                             "Hive": "HKEY_LOCAL_MACHINE",
3659                             "Path": "System\\CurrentControlSet\\Control\\Lsa\\FIPSAlgorithmPolicy",
3660                             "Value": "Enabled",
3661                             "Type": "REG_DWORD",
3662                         },
3663                         "Transform": self.enabled_one_disabled_zero_transform,
3664                     },
3665                     "MachineAccessRestriction": {
3666                         "Policy": (
3667                             "DCOM: Machine Access Restrictions in Security Descriptor "
3668                             "Definition Language (SDDL) syntax"
3669                         ),
3670                         "Settings": None,
3671                         "lgpo_section": self.security_options_gpedit_path,
3672                         "Registry": {
3673                             "Hive": "HKEY_LOCAL_MACHINE",
3674                             "Path": "Software\\Policies\\Microsoft\\Windows NT\\DCOM",
3675                             "Value": "MachineAccessRestriction",
3676                             "Type": "REG_SZ",
3677                         },
3678                         "Transform": {"Put": "_string_put_transform"},
3679                     },
3680                     "MachineLaunchRestriction": {
3681                         "Policy": (
3682                             "DCOM: Machine Launch Restrictions in Security Descriptor "
3683                             "Definition Language (SDDL) syntax"
3684                         ),
3685                         "Settings": None,
3686                         "lgpo_section": self.security_options_gpedit_path,
3687                         "Registry": {
3688                             "Hive": "HKEY_LOCAL_MACHINE",
3689                             "Path": "Software\\Policies\\Microsoft\\Windows NT\\DCOM",
3690                             "Value": "MachineLaunchRestriction",
3691                             "Type": "REG_SZ",
3692                         },
3693                         "Transform": {"Put": "_string_put_transform"},
3694                     },
3695                     "UseMachineId": {
3696                         "Policy": (
3697                             "Network security: Allow Local System to use computer "
3698                             "identity for NTLM"
3699                         ),
3700                         "Settings": self.enabled_one_disabled_zero.keys(),
3701                         "lgpo_section": self.security_options_gpedit_path,
3702                         "Registry": {
3703                             "Hive": "HKEY_LOCAL_MACHINE",
3704                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
3705                             "Value": "UseMachineId",
3706                             "Type": "REG_DWORD",
3707                         },
3708                         "Transform": self.enabled_one_disabled_zero_transform,
3709                     },
3710                     "allownullsessionfallback": {
3711                         "Policy": (
3712                             "Network security: Allow LocalSystem NULL session fallback"
3713                         ),
3714                         "Settings": self.enabled_one_disabled_zero.keys(),
3715                         "lgpo_section": self.security_options_gpedit_path,
3716                         "Registry": {
3717                             "Hive": "HKEY_LOCAL_MACHINE",
3718                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
3719                             "Value": "allownullsessionfallback",
3720                             "Type": "REG_DWORD",
3721                         },
3722                         "Transform": self.enabled_one_disabled_zero_transform,
3723                     },
3724                     "AllowOnlineID": {
3725                         "Policy": (
3726                             "Network security: Allow PKU2U authentication requests "
3727                             "to this computer to use online identities."
3728                         ),
3729                         "Settings": self.enabled_one_disabled_zero.keys(),
3730                         "lgpo_section": self.security_options_gpedit_path,
3731                         "Registry": {
3732                             "Hive": "HKEY_LOCAL_MACHINE",
3733                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa\\pku2u",
3734                             "Value": "AllowOnlineID",
3735                             "Type": "REG_DWORD",
3736                         },
3737                         "Transform": self.enabled_one_disabled_zero_transform,
3738                     },
3739                     "KrbSupportedEncryptionTypes": {
3740                         "Policy": (
3741                             "Network security: Configure encryption types allowed "
3742                             "for Kerberos"
3743                         ),
3744                         "Settings": None,
3745                         "lgpo_section": self.security_options_gpedit_path,
3746                         "Registry": {
3747                             "Hive": "HKEY_LOCAL_MACHINE",
3748                             "Path": (
3749                                 "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\policies"
3750                                 "\\system\\Kerberos\\Parameters"
3751                             ),
3752                             "Value": "SupportedEncryptionTypes",
3753                             "Type": "REG_DWORD",
3754                         },
3755                         "Transform": {
3756                             "Get": "_dict_lookup_bitwise_add",
3757                             "Put": "_dict_lookup_bitwise_add",
3758                             "GetArgs": {
3759                                 "lookup": self.krb_encryption_types,
3760                                 "value_lookup": False,
3761                             },
3762                             "PutArgs": {
3763                                 "lookup": self.krb_encryption_types,
3764                                 "value_lookup": True,
3765                             },
3766                         },
3767                     },
3768                     "NoLMHash": {
3769                         "Policy": (
3770                             "Network security: Do not store LAN Manager hash value "
3771                             "on next password change"
3772                         ),
3773                         "Settings": self.enabled_one_disabled_zero.keys(),
3774                         "lgpo_section": self.security_options_gpedit_path,
3775                         "Registry": {
3776                             "Hive": "HKEY_LOCAL_MACHINE",
3777                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
3778                             "Value": "NoLMHash",
3779                             "Type": "REG_DWORD",
3780                         },
3781                         "Transform": self.enabled_one_disabled_zero_transform,
3782                     },
3783                     "ForceLogoffWhenHourExpire": {
3784                         "Policy": (
3785                             "Network security: Force logoff when logon hours expire"
3786                         ),
3787                         "lgpo_section": self.security_options_gpedit_path,
3788                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
3789                         "Secedit": {
3790                             "Option": "ForceLogoffWhenHourExpire",
3791                             "Section": "System Access",
3792                         },
3793                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
3794                     },
3795                     "LmCompatibilityLevel": {
3796                         "Policy": "Network security: LAN Manager authentication level",
3797                         "Settings": self.lm_compat_levels.keys(),
3798                         "lgpo_section": self.security_options_gpedit_path,
3799                         "Registry": {
3800                             "Hive": "HKEY_LOCAL_MACHINE",
3801                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
3802                             "Value": "LmCompatibilityLevel",
3803                             "Type": "REG_DWORD",
3804                         },
3805                         "Transform": {
3806                             "Get": "_dict_lookup",
3807                             "Put": "_dict_lookup",
3808                             "GetArgs": {
3809                                 "lookup": self.lm_compat_levels,
3810                                 "value_lookup": False,
3811                             },
3812                             "PutArgs": {
3813                                 "lookup": self.lm_compat_levels,
3814                                 "value_lookup": True,
3815                             },
3816                         },
3817                     },
3818                     "LDAPClientIntegrity": {
3819                         "Policy": "Network security: LDAP client signing requirements",
3820                         "Settings": self.ldap_signing_reqs.keys(),
3821                         "lgpo_section": self.security_options_gpedit_path,
3822                         "Registry": {
3823                             "Hive": "HKEY_LOCAL_MACHINE",
3824                             "Path": "SYSTEM\\CurrentControlSet\\Services\\ldap",
3825                             "Value": "LDAPClientIntegrity",
3826                             "Type": "REG_DWORD",
3827                         },
3828                         "Transform": {
3829                             "Get": "_dict_lookup",
3830                             "Put": "_dict_lookup",
3831                             "GetArgs": {
3832                                 "lookup": self.ldap_signing_reqs,
3833                                 "value_lookup": False,
3834                             },
3835                             "PutArgs": {
3836                                 "lookup": self.ldap_signing_reqs,
3837                                 "value_lookup": True,
3838                             },
3839                         },
3840                     },
3841                     "NTLMMinClientSec": {
3842                         "Policy": (
3843                             "Network security: Minimum session security for NTLM SSP"
3844                             " based (including secure RPC) clients"
3845                         ),
3846                         "Settings": None,
3847                         "lgpo_section": self.security_options_gpedit_path,
3848                         "Registry": {
3849                             "Hive": "HKEY_LOCAL_MACHINE",
3850                             "Path": "System\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
3851                             "Value": "NTLMMinClientSec",
3852                             "Type": "REG_DWORD",
3853                         },
3854                         "Transform": {
3855                             "Get": "_dict_lookup_bitwise_add",
3856                             "Put": "_dict_lookup_bitwise_add",
3857                             "GetArgs": {
3858                                 "lookup": self.ntlm_session_security_levels,
3859                                 "value_lookup": False,
3860                             },
3861                             "PutArgs": {
3862                                 "lookup": self.ntlm_session_security_levels,
3863                                 "value_lookup": True,
3864                             },
3865                         },
3866                     },
3867                     "NTLMMinServerSec": {
3868                         "Policy": (
3869                             "Network security: Minimum session security for NTLM SSP"
3870                             " based (including secure RPC) servers"
3871                         ),
3872                         "Settings": None,
3873                         "lgpo_section": self.security_options_gpedit_path,
3874                         "Registry": {
3875                             "Hive": "HKEY_LOCAL_MACHINE",
3876                             "Path": "System\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
3877                             "Value": "NTLMMinServerSec",
3878                             "Type": "REG_DWORD",
3879                         },
3880                         "Transform": {
3881                             "Get": "_dict_lookup_bitwise_add",
3882                             "Put": "_dict_lookup_bitwise_add",
3883                             "GetArgs": {
3884                                 "lookup": self.ntlm_session_security_levels,
3885                                 "value_lookup": False,
3886                             },
3887                             "PutArgs": {
3888                                 "lookup": self.ntlm_session_security_levels,
3889                                 "value_lookup": True,
3890                             },
3891                         },
3892                     },
3893                     "ClientAllowedNTLMServers": {
3894                         "Policy": (
3895                             "Network security: Restrict NTLM: Add remote server"
3896                             " exceptions for NTLM authentication"
3897                         ),
3898                         "lgpo_section": self.security_options_gpedit_path,
3899                         "Registry": {
3900                             "Hive": "HKEY_LOCAL_MACHINE",
3901                             "Path": "System\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
3902                             "Value": "ClientAllowedNTLMServers",
3903                             "Type": "REG_MULTI_SZ",
3904                         },
3905                         "Transform": {
3906                             "Put": "_multi_string_put_transform",
3907                             "Get": "_multi_string_get_transform",
3908                         },
3909                     },
3910                     "DCAllowedNTLMServers": {
3911                         "Policy": (
3912                             "Network security: Restrict NTLM: Add server exceptions"
3913                             " in this domain"
3914                         ),
3915                         "lgpo_section": self.security_options_gpedit_path,
3916                         "Registry": {
3917                             "Hive": "HKEY_LOCAL_MACHINE",
3918                             "Path": "System\\CurrentControlSet\\Services\\Netlogon\\Parameters",
3919                             "Value": "DCAllowedNTLMServers",
3920                             "Type": "REG_MULTI_SZ",
3921                         },
3922                         "Transform": {
3923                             "Put": "_multi_string_put_transform",
3924                             "Get": "_multi_string_get_transform",
3925                         },
3926                     },
3927                     "AuditReceivingNTLMTraffic": {
3928                         "Policy": (
3929                             "Network security: Restrict NTLM: Audit Incoming NTLM"
3930                             " Traffic"
3931                         ),
3932                         "Settings": self.ntlm_audit_settings.keys(),
3933                         "lgpo_section": self.security_options_gpedit_path,
3934                         "Registry": {
3935                             "Hive": "HKEY_LOCAL_MACHINE",
3936                             "Path": "SYSTEM\\CurrentControlSet\\Control\\LSA\\MSV1_0",
3937                             "Value": "AuditReceivingNTLMTraffic",
3938                             "Type": "REG_DWORD",
3939                         },
3940                         "Transform": {
3941                             "Get": "_dict_lookup",
3942                             "Put": "_dict_lookup",
3943                             "GetArgs": {
3944                                 "lookup": self.ntlm_audit_settings,
3945                                 "value_lookup": False,
3946                             },
3947                             "PutArgs": {
3948                                 "lookup": self.ntlm_audit_settings,
3949                                 "value_lookup": True,
3950                             },
3951                         },
3952                     },
3953                     "AuditNTLMInDomain": {
3954                         "Policy": (
3955                             "Network security: Restrict NTLM: Audit NTLM "
3956                             "authentication in this domain"
3957                         ),
3958                         "Settings": self.ntlm_domain_audit_settings.keys(),
3959                         "lgpo_section": self.security_options_gpedit_path,
3960                         "Registry": {
3961                             "Hive": "HKEY_LOCAL_MACHINE",
3962                             "Path": "SYSTEM\\CurrentControlSet\\Services\\Netlogon\\Parameters",
3963                             "Value": "AuditNTLMInDomain",
3964                             "Type": "REG_DWORD",
3965                         },
3966                         "Transform": {
3967                             "Get": "_dict_lookup",
3968                             "Put": "_dict_lookup",
3969                             "GetArgs": {
3970                                 "lookup": self.ntlm_domain_audit_settings,
3971                                 "value_lookup": False,
3972                             },
3973                             "PutArgs": {
3974                                 "lookup": self.ntlm_domain_audit_settings,
3975                                 "value_lookup": True,
3976                             },
3977                         },
3978                     },
3979                     "RestrictReceivingNTLMTraffic": {
3980                         "Policy": (
3981                             "Network security: Restrict NTLM: Incoming NTLM traffic"
3982                         ),
3983                         "Settings": self.incoming_ntlm_settings.keys(),
3984                         "lgpo_section": self.security_options_gpedit_path,
3985                         "Registry": {
3986                             "Hive": "HKEY_LOCAL_MACHINE",
3987                             "Path": "SYSTEM\\CurrentControlSet\\Control\\LSA\\MSV1_0",
3988                             "Value": "RestrictReceivingNTLMTraffic",
3989                             "Type": "REG_DWORD",
3990                         },
3991                         "Transform": {
3992                             "Get": "_dict_lookup",
3993                             "Put": "_dict_lookup",
3994                             "GetArgs": {
3995                                 "lookup": self.incoming_ntlm_settings,
3996                                 "value_lookup": False,
3997                             },
3998                             "PutArgs": {
3999                                 "lookup": self.incoming_ntlm_settings,
4000                                 "value_lookup": True,
4001                             },
4002                         },
4003                     },
4004                     "RestrictNTLMInDomain": {
4005                         "Policy": (
4006                             "Network security: Restrict NTLM: NTLM "
4007                             "authentication in this domain"
4008                         ),
4009                         "Settings": self.ntlm_domain_auth_settings.keys(),
4010                         "lgpo_section": self.security_options_gpedit_path,
4011                         "Registry": {
4012                             "Hive": "HKEY_LOCAL_MACHINE",
4013                             "Path": "SYSTEM\\CurrentControlSet\\Services\\Netlogon\\Parameters",
4014                             "Value": "RestrictNTLMInDomain",
4015                             "Type": "REG_DWORD",
4016                         },
4017                         "Transform": {
4018                             "Get": "_dict_lookup",
4019                             "Put": "_dict_lookup",
4020                             "GetArgs": {
4021                                 "lookup": self.ntlm_domain_auth_settings,
4022                                 "value_lookup": False,
4023                             },
4024                             "PutArgs": {
4025                                 "lookup": self.ntlm_domain_auth_settings,
4026                                 "value_lookup": True,
4027                             },
4028                         },
4029                     },
4030                     "RestrictSendingNTLMTraffic": {
4031                         "Policy": (
4032                             "Network security: Restrict NTLM: Outgoing NTLM"
4033                             " traffic to remote servers"
4034                         ),
4035                         "Settings": self.outgoing_ntlm_settings.keys(),
4036                         "lgpo_section": self.security_options_gpedit_path,
4037                         "Registry": {
4038                             "Hive": "HKEY_LOCAL_MACHINE",
4039                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
4040                             "Value": "RestrictSendingNTLMTraffic",
4041                             "Type": "REG_DWORD",
4042                         },
4043                         "Transform": {
4044                             "Get": "_dict_lookup",
4045                             "Put": "_dict_lookup",
4046                             "GetArgs": {
4047                                 "lookup": self.outgoing_ntlm_settings,
4048                                 "value_lookup": False,
4049                             },
4050                             "PutArgs": {
4051                                 "lookup": self.outgoing_ntlm_settings,
4052                                 "value_lookup": True,
4053                             },
4054                         },
4055                     },
4056                     "ShutdownWithoutLogon": {
4057                         "Policy": (
4058                             "Shutdown: Allow system to be shut down "
4059                             "without having to log on"
4060                         ),
4061                         "Settings": self.enabled_one_disabled_zero.keys(),
4062                         "lgpo_section": self.security_options_gpedit_path,
4063                         "Registry": {
4064                             "Hive": "HKEY_LOCAL_MACHINE",
4065                             "Path": "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\policies\\system",
4066                             "Value": "ShutdownWithoutLogon",
4067                             "Type": "REG_DWORD",
4068                         },
4069                         "Transform": self.enabled_one_disabled_zero_transform,
4070                     },
4071                     "ClearPageFileAtShutdown": {
4072                         "Policy": "Shutdown: Clear virtual memory pagefile",
4073                         "Settings": self.enabled_one_disabled_zero.keys(),
4074                         "lgpo_section": self.security_options_gpedit_path,
4075                         "Registry": {
4076                             "Hive": "HKEY_LOCAL_MACHINE",
4077                             "Path": (
4078                                 "System\\CurrentControlSet\\Control\\"
4079                                 "SESSION MANAGER\\MEMORY MANAGEMENT"
4080                             ),
4081                             "Value": "ClearPageFileAtShutdown",
4082                             "Type": "REG_DWORD",
4083                         },
4084                         "Transform": self.enabled_one_disabled_zero_transform,
4085                     },
4086                     "ObCaseInsensitive": {
4087                         "Policy": (
4088                             "System objects: Require case insensitivity for "
4089                             "non-Windows subsystems"
4090                         ),
4091                         "Settings": self.enabled_one_disabled_zero.keys(),
4092                         "lgpo_section": self.security_options_gpedit_path,
4093                         "Registry": {
4094                             "Hive": "HKEY_LOCAL_MACHINE",
4095                             "Path": (
4096                                 "System\\CurrentControlSet\\Control\\"
4097                                 "SESSION MANAGER\\Kernel"
4098                             ),
4099                             "Value": "ObCaseInsensitive",
4100                             "Type": "REG_DWORD",
4101                         },
4102                         "Transform": self.enabled_one_disabled_zero_transform,
4103                     },
4104                     "ProtectionMode": {
4105                         "Policy": (
4106                             "System objects: Strengthen default permissions of "
4107                             "internal system objects (e.g. Symbolic Links)"
4108                         ),
4109                         "Settings": self.enabled_one_disabled_zero.keys(),
4110                         "lgpo_section": self.security_options_gpedit_path,
4111                         "Registry": {
4112                             "Hive": "HKEY_LOCAL_MACHINE",
4113                             "Path": (
4114                                 "System\\CurrentControlSet\\Control\\SESSION MANAGER"
4115                             ),
4116                             "Value": "ProtectionMode",
4117                             "Type": "REG_DWORD",
4118                         },
4119                         "Transform": self.enabled_one_disabled_zero_transform,
4120                     },
4121                     "OptionalSubsystems": {
4122                         "Policy": "System settings: Optional subsystems",
4123                         "lgpo_section": self.security_options_gpedit_path,
4124                         "Registry": {
4125                             "Hive": "HKEY_LOCAL_MACHINE",
4126                             "Path": (
4127                                 "System\\CurrentControlSet\\Control\\"
4128                                 "SESSION MANAGER\\SubSystems"
4129                             ),
4130                             "Value": "optional",
4131                             "Type": "REG_MULTI_SZ",
4132                         },
4133                         "Transform": {
4134                             "Put": "_multi_string_put_transform",
4135                             "Get": "_multi_string_get_transform",
4136                         },
4137                     },
4138                     "AuthenticodeEnabled": {
4139                         "Policy": (
4140                             "System settings: Use Certificate Rules on Windows"
4141                             " Executables for Software Restriction Policies"
4142                         ),
4143                         "Settings": self.enabled_one_disabled_zero.keys(),
4144                         "lgpo_section": self.security_options_gpedit_path,
4145                         "Registry": {
4146                             "Hive": "HKEY_LOCAL_MACHINE",
4147                             "Path": "SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers",
4148                             "Value": "AuthenticodeEnabled",
4149                             "Type": "REG_DWORD",
4150                         },
4151                         "Transform": self.enabled_one_disabled_zero_transform,
4152                     },
4153                 },
4154             },
4155             "User": {"lgpo_section": "User Configuration", "policies": {}},
4156         }
4157         self.admx_registry_classes = {
4158             "User": {
4159                 "policy_path": os.path.join(
4160                     os.getenv("WINDIR"),
4161                     "System32",
4162                     "GroupPolicy",
4163                     "User",
4164                     "Registry.pol",
4165                 ),
4166                 "hive": "HKEY_USERS",
4167                 "lgpo_section": "User Configuration",
4168                 "gpt_extension_location": "gPCUserExtensionNames",
4169                 "gpt_extension_guid": "[{35378EAC-683F-11D2-A89A-00C04FBBCFA2}{D02B1F73-3407-48AE-BA88-E8213C6761F1}]",
4170             },
4171             "Machine": {
4172                 "policy_path": os.path.join(
4173                     os.getenv("WINDIR"),
4174                     "System32",
4175                     "GroupPolicy",
4176                     "Machine",
4177                     "Registry.pol",
4178                 ),
4179                 "hive": "HKEY_LOCAL_MACHINE",
4180                 "lgpo_section": "Computer Configuration",
4181                 "gpt_extension_location": "gPCMachineExtensionNames",
4182                 "gpt_extension_guid": "[{35378EAC-683F-11D2-A89A-00C04FBBCFA2}{D02B1F72-3407-48AE-BA88-E8213C6761F1}]",
4183             },
4184         }
4185         self.reg_pol_header = "\u5250\u6765\x01\x00"
4186         self.gpt_ini_path = os.path.join(
4187             os.getenv("WINDIR"), "System32", "GroupPolicy", "gpt.ini"
4188         )
4189     @classmethod
4190     def _notEmpty(cls, val, **kwargs):
4191         """
4192         ensures a value is not empty
4193         """
4194         if val:
4195             return True
4196         else:
4197             return False
4198     @classmethod
4199     def _seconds_to_days(cls, val, **kwargs):
4200         """
4201         converts a number of seconds to days
4202         """
4203         zero_value = kwargs.get("zero_value", 0)
4204         if val is not None:
4205             if val == zero_value:
4206                 return 0
4207             return val / 86400
4208         else:
4209             return "Not Defined"
4210     @classmethod
4211     def _days_to_seconds(cls, val, **kwargs):
4212         """
4213         converts a number of days to seconds
4214         """
4215         zero_value = kwargs.get("zero_value", 0)
4216         if val is not None:
4217             if val == 0:
4218                 return zero_value
4219             return val * 86400
4220         else:
4221             return "Not Defined"
4222     @classmethod
4223     def _seconds_to_minutes(cls, val, **kwargs):
4224         """
4225         converts a number of seconds to minutes
4226         """
4227         zero_value = kwargs.get("zero_value", 0)
4228         if val is not None:
4229             if val == zero_value:
4230                 return 0
4231             return val / 60
4232         else:
4233             return "Not Defined"
4234     @classmethod
4235     def _minutes_to_seconds(cls, val, **kwargs):
4236         """
4237         converts number of minutes to seconds
4238         """
4239         zero_value = kwargs.get("zero_value", 0)
4240         if val is not None:
4241             if val == 0:
4242                 return zero_value
4243             return val * 60
4244         else:
4245             return "Not Defined"
4246     @classmethod
4247     def _strip_quotes(cls, val, **kwargs):
4248         """
4249         strips quotes from a string
4250         """
4251         return val.replace('"', "")
4252     @classmethod
4253     def _add_quotes(cls, val, **kwargs):
4254         """
4255         add quotes around the string
4256         """
4257         return '"{}"'.format(val)
4258     @classmethod
4259     def _binary_enable_zero_disable_one_conversion(cls, val, **kwargs):
4260         """
4261         converts a binary 0/1 to Disabled/Enabled
4262         """
4263         try:
4264             if val is not None:
4265                 if ord(val) == 0:
4266                     return "Disabled"
4267                 elif ord(val) == 1:
4268                     return "Enabled"
4269                 else:
4270                     return "Invalid Value: {!r}".format(val)
4271             else:
4272                 return "Not Defined"
4273         except TypeError:
4274             return "Invalid Value"
4275     @classmethod
4276     def _binary_enable_zero_disable_one_reverse_conversion(cls, val, **kwargs):
4277         """
4278         converts Enabled/Disabled to unicode char to write to a REG_BINARY value
4279         """
4280         if val is not None:
4281             if val.upper() == "DISABLED":
4282                 return chr(0)
4283             elif val.upper() == "ENABLED":
4284                 return chr(1)
4285             else:
4286                 return None
4287         else:
4288             return None
4289     @classmethod
4290     def _dasd_conversion(cls, val, **kwargs):
4291         """
4292         converts 0/1/2 for dasd reg key
4293         """
4294         if val is not None:
4295             if val == "0" or val == 0 or val == "":
4296                 return "Administrators"
4297             elif val == "1" or val == 1:
4298                 return "Administrators and Power Users"
4299             elif val == "2" or val == 2:
4300                 return "Administrators and Interactive Users"
4301             else:
4302                 return "Not Defined"
4303         else:
4304             return "Not Defined"
4305     @classmethod
4306     def _dasd_reverse_conversion(cls, val, **kwargs):
4307         """
4308         converts DASD String values to the reg_sz value
4309         """
4310         if val is not None:
4311             if val.upper() == "ADMINISTRATORS":
4312                 return "0"
4313             elif val.upper() == "ADMINISTRATORS AND POWER USERS":
4314                 return "1"
4315             elif val.upper() == "ADMINISTRATORS AND INTERACTIVE USERS":
4316                 return "2"
4317             elif val.upper() == "NOT DEFINED":
4318                 return "9999"
4319             else:
4320                 return "Invalid Value"
4321         else:
4322             return "Not Defined"
4323     @classmethod
4324     def _in_range_inclusive(cls, val, **kwargs):
4325         """
4326         checks that a value is in an inclusive range
4327         The value for 0 used by Max Password Age is actually 0xffffffff
4328         """
4329         minimum = kwargs.get("min", 0)
4330         maximum = kwargs.get("max", 1)
4331         zero_value = kwargs.get("zero_value", 0)
4332         if isinstance(val, str):
4333             if val.lower() == "not defined":
4334                 return True
4335             else:
4336                 try:
4337                     val = int(val)
4338                 except ValueError:
4339                     return False
4340         if val is not None:
4341             if minimum &lt;= val &lt;= maximum or val == zero_value:
4342                 return True
4343             else:
4344                 return False
4345         else:
4346             return False
4347     @classmethod
4348     def _driver_signing_reg_conversion(cls, val, **kwargs):
4349         """
4350         converts the binary value in the registry for driver signing into the
4351         correct string representation
4352         """
4353         log.trace("we have %s for the driver signing value", val)
4354         if val is not None:
4355             _val = val.split(",")
4356             if len(_val) == 2:
4357                 if _val[1] == "0":
4358                     return "Silently Succeed"
4359                 elif _val[1] == "1":
4360                     return "Warn but allow installation"
4361                 elif _val[1] == "2":
4362                     return "Do not allow installation"
4363                 elif _val[1] == "Not Defined":
4364                     return "Not Defined"
4365                 else:
4366                     return "Invalid Value"
4367             else:
4368                 return "Not Defined"
4369         else:
4370             return "Not Defined"
4371     @classmethod
4372     def _driver_signing_reg_reverse_conversion(cls, val, **kwargs):
4373         """
4374         converts the string value seen in the GUI to the correct registry value
4375         for secedit
4376         """
4377         if val is not None:
4378             if val.upper() == "SILENTLY SUCCEED":
4379                 return ",".join(["3", "0"])
4380             elif val.upper() == "WARN BUT ALLOW INSTALLATION":
4381                 return ",".join(["3", chr(1)])
4382             elif val.upper() == "DO NOT ALLOW INSTALLATION":
4383                 return ",".join(["3", chr(2)])
4384             else:
4385                 return "Invalid Value"
4386         else:
4387             return "Not Defined"
4388     @classmethod
4389     def _sidConversion(cls, val, **kwargs):
4390         """
4391         converts a list of pysid objects to string representations
4392         """
4393         if isinstance(val, str):
4394             val = val.split(",")
4395         usernames = []
4396         for _sid in val:
4397             try:
4398                 userSid = win32security.LookupAccountSid("", _sid)
4399                 if userSid[1]:
4400                     userSid = "{1}\\{0}".format(userSid[0], userSid[1])
4401                 else:
4402                     userSid = "{}".format(userSid[0])
4403             except Exception:  # pylint: disable=broad-except
4404                 userSid = win32security.ConvertSidToStringSid(_sid)
4405                 log.warning(
4406                     "Unable to convert SID '%s' to a friendly name. "
4407                     "The SID will be displayed instead of a user/group name.",
4408                     userSid,
4409                 )
4410             usernames.append(userSid)
4411         return usernames
4412     @classmethod
4413     def _usernamesToSidObjects(cls, val, **kwargs):
4414         """
4415         converts a list of usernames to sid objects
4416         """
4417         if not val:
4418             return val
4419         if isinstance(val, str):
4420             val = val.split(",")
4421         sids = []
4422         for _user in val:
4423             try:
4424                 sid = win32security.LookupAccountName("", _user)[0]
4425                 sids.append(sid)
4426             except Exception as e:  # pylint: disable=broad-except
4427                 log.exception("Handle this explicitly")
4428                 raise CommandExecutionError(
4429                     'There was an error obtaining the SID of user "{}". Error '
4430                     "returned: {}".format(_user, e)
4431                 )
4432         return sids
4433     @classmethod
4434     def _powershell_script_order_conversion(cls, val, **kwargs):
4435         """
4436         converts true/false/None to the GUI representation of the powershell
4437         startup/shutdown script order
4438         """
4439         log.trace("script order value = %s", val)
4440         if val is None or val == "None":
4441             return "Not Configured"
4442         elif val == "true":
4443             return "Run Windows PowerShell scripts first"
4444         elif val == "false":
4445             return "Run Windows PowerShell scripts last"
4446         else:
4447             return "Invalid Value"
4448     @classmethod
4449     def _powershell_script_order_reverse_conversion(cls, val, **kwargs):
4450         """
4451         converts powershell script GUI strings representations to
4452         True/False/None
4453         """
4454         if val.upper() == "Run Windows PowerShell scripts first".upper():
4455             return "true"
4456         elif val.upper() == "Run Windows PowerShell scripts last".upper():
4457             return "false"
4458         elif val == "Not Configured":
4459             return None
4460         else:
4461             return "Invalid Value"
4462     @classmethod
4463     def _dict_lookup(cls, item, **kwargs):
4464         """
4465         Retrieves the key or value from a dict based on the item
4466         kwarg lookup dict to search for item
4467         kwarg value_lookup bool to determine if item should be compared to keys
4468         or values
4469         """
4470         log.trace("item == %s", item)
4471         value_lookup = kwargs.get("value_lookup", False)
4472         if "lookup" in kwargs:
4473             for k, v in kwargs["lookup"].items():
4474                 if value_lookup:
4475                     if str(v).lower() == str(item).lower():
4476                         log.trace("returning key %s", k)
4477                         return k
4478                 else:
4479                     if str(k).lower() == str(item).lower():
4480                         log.trace("returning value %s", v)
4481                         return v
4482         return "Invalid Value"
4483     @classmethod
4484     def _dict_lookup_bitwise_add(cls, item, **kwargs):
4485         """
4486         kwarg value_lookup bool to determine if item_list should be compared to keys
4487         or values
4488         kwarg test_zero is used to determine if 0 should be tested when value_lookup is false
4489         lookup should be a dict with integers for keys
4490         if value_lookup is True, item is expected to be a list
4491             the function will return the sum of the keys whose values are in the item list
4492         if value_lookup is False, item is expected to be an integer
4493             the function will return the values for the keys
4494             which successfully "bitwise and" with item
4495         """
4496         value_lookup = kwargs.get("value_lookup", False)
4497         test_zero = kwargs.get("test_zero", False)
4498         ret_val = None
4499         if str(item).lower() == "not defined":
4500             return None
4501         if value_lookup:
4502             if not isinstance(item, list):
4503                 return "Invalid Value"
4504             ret_val = 0
4505         else:
4506             if not isinstance(item, int):
4507                 return "Invalid Value"
4508             ret_val = []
4509         if "lookup" in kwargs:
4510             for k, v in kwargs["lookup"].items():
4511                 if value_lookup:
4512                     if str(v).lower() in [z.lower() for z in item]:
4513                         ret_val = ret_val + k
4514                 else:
4515                     do_test = True
4516                     if not test_zero:
4517                         if k == 0:
4518                             do_test = False
4519                     if do_test and isinstance(k, int) and item &amp; k == k:
4520                         ret_val.append(v)
4521         else:
4522             return "Invalid Value"
4523         return ret_val
4524     @classmethod
4525     def _multi_string_put_transform(cls, item, **kwargs):
4526         """
4527         transform for setting REG_MULTI_SZ to properly handle "Not Defined"
4528         """
4529         if isinstance(item, list):
4530             return item
4531         elif isinstance(item, str):
4532             if item.lower() == "not defined":
4533                 return None
4534             else:
4535                 return item.split(",")
4536         else:
4537             return "Invalid Value"
4538     @classmethod
4539     def _multi_string_get_transform(cls, item, **kwargs):
4540         """
4541         transform for getting REG_MULTI_SZ to properly handle `None`
4542         """
4543         if isinstance(item, list):
4544             return item
4545         elif item is None:
4546             return "Not Defined"
4547         else:
4548             return "Invalid Value"
4549     @classmethod
4550     def _string_put_transform(cls, item, **kwargs):
4551         """
4552         transform for a REG_SZ to properly handle "Not Defined"
4553         """
4554         if isinstance(item, str):
4555             if item.lower() == "not defined":
4556                 return None
4557             else:
4558                 return item
4559 def __virtual__():
4560     """
4561     Only works on Windows systems
4562     """
4563     if not salt.utils.platform.is_windows():
4564         return False, "win_lgpo: Not a Windows System"
4565     if not HAS_WINDOWS_MODULES:
4566         return False, "win_lgpo: Required modules failed to load"
4567     return __virtualname__
4568 def _updateNamespace(item, new_namespace):
4569     """
4570     helper function to recursively update the namespaces of an item
4571     """
4572     temp_item = ""
4573     i = item.tag.find("}")
4574     if i &gt;= 0:
4575         temp_item = item.tag[i + 1 :]
4576     else:
4577         temp_item = item.tag
4578     item.tag = "{{{0}}}{1}".format(new_namespace, temp_item)
4579     for child in item.getiterator():
4580         if isinstance(child.tag, str):
4581             temp_item = ""
4582             i = child.tag.find("}")
4583             if i &gt;= 0:
4584                 temp_item = child.tag[i + 1 :]
4585             else:
4586                 temp_item = child.tag
4587             child.tag = "{{{0}}}{1}".format(new_namespace, temp_item)
4588     return item
4589 def _updatePolicyElements(policy_item, regkey):
4590     """
4591     helper function to add the reg key to each policies element definitions if
4592     the key attribute is not defined to make xpath searching easier for each
4593     child in the policy &lt;elements&gt; item
4594     """
4595     for child in policy_item.getiterator():
4596         if "valueName" in child.attrib:
4597             if "key" not in child.attrib:
4598                 child.attrib["key"] = regkey
4599     return policy_item
4600 def _remove_unicode_encoding(xml_file):
4601     """
4602     attempts to remove the "encoding='unicode'" from an xml file
4603     as lxml does not support that on a windows node currently
4604     see issue #38100 (Search.adml)
4605     For some reason this file is encoded 'utf-16'
4606     """
4607     with salt.utils.files.fopen(xml_file, "rb") as f:
4608         xml_content = f.read()
4609     modified_xml = re.sub(
4610         r' encoding=[\'"]+unicode[\'"]+', "", xml_content.decode("utf-16"), count=1
4611     )
4612     xml_tree = lxml.etree.parse(io.StringIO(modified_xml))
4613     return xml_tree
4614 def _remove_invalid_xmlns(xml_file):
4615     """
4616     Attempts to remove an invalid xmlns entry in newer versions of
4617     WindowsDefender.adml
4618     xmlns="http://schemas.microsoft.com/GroupPolicy/2006/07/PolicyDefinitions"
4619     For some reason this file is encoded 'utf-8'
4620     """
4621     with salt.utils.files.fopen(xml_file, "rb") as f:
4622         xml_content = f.read()
4623     modified_xml = re.sub(
4624         r' xmlns=[\'"]+.*[\'"]+', "", xml_content.decode("utf-8"), count=1
4625     )
4626     xml_tree = lxml.etree.parse(io.StringIO(modified_xml))
4627     return xml_tree
4628 def _parse_xml(adm_file):
4629     """
4630     Parse the admx/adml file. There are 3 scenarios (so far) that we'll likely
4631     encounter:
4632     1. Valid File
4633     2. invalid encoding (encoding="unicode") which the lxml library doesn't
4634        recognize
4635     3. invalid xmlns entry in the xml header, which the lxml library doesn't
4636        recognize
4637     """
4638     parser = lxml.etree.XMLParser(remove_comments=True)
4639     modified_xml = ""
4640     with salt.utils.files.fopen(adm_file, "rb") as rfh:
4641         file_hash = "{:X}".format(zlib.crc32(rfh.read()) &amp; 0xFFFFFFFF)
4642     name, ext = os.path.splitext(os.path.basename(adm_file))
4643     hashed_filename = "{}-{}{}".format(name, file_hash, ext)
4644     cache_dir = os.path.join(__opts__["cachedir"], "lgpo", "policy_defs")
4645     if not os.path.exists(cache_dir):
4646         os.makedirs(cache_dir)
4647     out_file = os.path.join(cache_dir, hashed_filename)
4648     if not os.path.isfile(out_file):
4649         log.debug("LGPO: Generating policy template cache for %s%s", name, ext)
4650         file_list = glob.glob(os.path.join(cache_dir, "{}*{}".format(name, ext)))
4651         for file_path in file_list:
4652             os.remove(file_path)
4653         with salt.utils.files.fopen(adm_file, "rb") as rfh:
4654             encoding = "utf-8"
4655             raw = rfh.read()
4656             try:
4657                 raw = raw.decode(encoding)
4658             except UnicodeDecodeError:
4659                 log.trace("LGPO: Detecting encoding")
4660                 encoding = "utf-16"
4661                 raw = raw.decode(encoding)
4662             for line in raw.split("\r\n"):
4663                 if 'key="' in line:
4664                     start = line.index('key="')
4665                     q1 = line[start:].index('"') + start
4666                     q2 = line[q1 + 1 :].index('"') + q1 + 1
4667                     line = line.replace(line[start:q2], line[start:q2].lower())
4668                     found_key = True
4669                 modified_xml += line + "\r\n"
4670         modified_xml = modified_xml.replace("\u201c", '"').replace("\u201d", '"')
4671         modified_xml = modified_xml.replace("\u2018", "'").replace("\u2019", "'")
4672         modified_xml = modified_xml.replace("\u2013", "-").replace("\u2014", "-")
4673         with salt.utils.files.fopen(out_file, "wb") as wfh:
4674             wfh.write(modified_xml.encode(encoding))
4675     try:
4676         xml_tree = lxml.etree.parse(out_file, parser=parser)
4677     except lxml.etree.XMLSyntaxError:
4678         try:
4679             xml_tree = _remove_unicode_encoding(out_file)
4680         except lxml.etree.XMLSyntaxError:
4681             xml_tree = _remove_invalid_xmlns(out_file)
4682     return xml_tree
4683 def _load_policy_definitions(path="c:\\Windows\\PolicyDefinitions", language="en-US"):
4684     """
4685     helper function to process all ADMX files in the specified policy_def_path
4686     and build a single XML doc that we can search/use for ADMX policy processing
4687     """
4688     display_language_fallback = INSTALL_LANGUAGE
4689     t_policy_definitions = lxml.etree.Element("policyDefinitions")
4690     t_policy_definitions.append(lxml.etree.Element("categories"))
4691     t_policy_definitions.append(lxml.etree.Element("policies"))
4692     t_policy_definitions.append(lxml.etree.Element("policyNamespaces"))
4693     t_policy_definition_resources = lxml.etree.Element("policyDefinitionResources")
4694     policydefs_policies_xpath = etree.XPath("/policyDefinitions/policies")
4695     policydefs_categories_xpath = etree.XPath("/policyDefinitions/categories")
4696     policydefs_policyns_xpath = etree.XPath("/policyDefinitions/policyNamespaces")
4697     policydefs_resources_localname_xpath = etree.XPath(
4698         '//*[local-name() = "policyDefinitionResources"]/*'
4699     )
4700     policydef_resources_xpath = etree.XPath("/policyDefinitionResources")
4701     for root, dirs, files in salt.utils.path.os_walk(path):
4702         if root == path:
4703             for t_admx_file in files:
4704                 admx_file_name, admx_file_ext = os.path.splitext(t_admx_file)
4705                 if not admx_file_ext == ".admx":
4706                     log.debug("%s is not an ADMX file", t_admx_file)
4707                     continue
4708                 admx_file = os.path.join(root, t_admx_file)
4709                 try:
4710                     xml_tree = _parse_xml(admx_file)
4711                 except lxml.etree.XMLSyntaxError:
4712                     log.error(
4713                         "An error was found while processing admx "
4714                         "file %s, all policies from this file will "
4715                         "be unavailable via this module",
4716                         admx_file,
4717                     )
4718                     continue
4719                 namespaces = xml_tree.getroot().nsmap
4720                 namespace_string = ""
4721                 if None in namespaces:
4722                     namespaces["None"] = namespaces[None]
4723                     namespaces.pop(None)
4724                     namespace_string = "None:"
4725                 this_namespace = xml_tree.xpath(
4726                     "/{0}policyDefinitions/{0}policyNamespaces/{0}target/@namespace".format(
4727                         namespace_string
4728                     ),
4729                     namespaces=namespaces,
4730                 )[0]
4731                 categories = xml_tree.xpath(
4732                     "/{0}policyDefinitions/{0}categories/{0}category".format(
4733                         namespace_string
4734                     ),
4735                     namespaces=namespaces,
4736                 )
4737                 for category in categories:
4738                     temp_cat = category
4739                     temp_cat = _updateNamespace(temp_cat, this_namespace)
4740                     policydefs_categories_xpath(t_policy_definitions)[0].append(
4741                         temp_cat
4742                     )
4743                 policies = xml_tree.xpath(
4744                     "/{0}policyDefinitions/{0}policies/{0}policy".format(
4745                         namespace_string
4746                     ),
4747                     namespaces=namespaces,
4748                 )
4749                 for policy in policies:
4750                     temp_pol = policy
4751                     temp_pol = _updateNamespace(temp_pol, this_namespace)
4752                     if "key" in temp_pol.attrib:
4753                         temp_pol = _updatePolicyElements(
4754                             temp_pol, temp_pol.attrib["key"]
4755                         )
4756                     policydefs_policies_xpath(t_policy_definitions)[0].append(temp_pol)
4757                 policy_namespaces = xml_tree.xpath(
4758                     "/{0}policyDefinitions/{0}policyNamespaces/{0}*".format(
4759                         namespace_string
4760                     ),
4761                     namespaces=namespaces,
4762                 )
4763                 for policy_ns in policy_namespaces:
4764                     temp_ns = policy_ns
4765                     temp_ns = _updateNamespace(temp_ns, this_namespace)
4766                     policydefs_policyns_xpath(t_policy_definitions)[0].append(temp_ns)
4767                 adml_file = os.path.join(root, language, admx_file_name + ".adml")
4768                 if not __salt__["file.file_exists"](adml_file):
4769                     log.info(
4770                         "An ADML file in the specified ADML language "
4771                         '"%s" does not exist for the ADMX "%s", the '
4772                         "the abbreviated language code will be tried.",
4773                         language,
4774                         t_admx_file,
4775                     )
4776                     adml_file = os.path.join(
4777                         root, language.split("-")[0], admx_file_name + ".adml"
4778                     )
4779                     if not __salt__["file.file_exists"](adml_file):
4780                         log.info(
4781                             "An ADML file in the specified ADML language "
4782                             'code %s does not exist for the ADMX "%s", '
4783                             "the fallback language will be tried.",
4784                             language[:2],
4785                             t_admx_file,
4786                         )
4787                         adml_file = os.path.join(
4788                             root, display_language_fallback, admx_file_name + ".adml"
4789                         )
4790                         if not __salt__["file.file_exists"](adml_file):
4791                             log.info(
4792                                 "An ADML file in the specified ADML "
4793                                 'fallback language "%s" '
4794                                 'does not exist for the ADMX "%s" '
4795                                 "the abbreviated fallback language code "
4796                                 "will be tried.",
4797                                 display_language_fallback,
4798                                 t_admx_file,
4799                             )
4800                             adml_file = os.path.join(
4801                                 root,
4802                                 display_language_fallback.split("-")[0],
4803                                 admx_file_name + ".adml",
4804                             )
4805                             if not __salt__["file.file_exists"](adml_file):
4806                                 raise SaltInvocationError(
4807                                     "An ADML file in the specified ADML language "
4808                                     '"{}" and the fallback language "{}" do not '
4809                                     'exist for the ADMX "{}".'.format(
4810                                         language, display_language_fallback, t_admx_file
4811                                     )
4812                                 )
4813                 try:
4814                     xml_tree = _parse_xml(adml_file)
4815                 except lxml.etree.XMLSyntaxError:
4816                     log.error(
4817                         "An error was found while processing adml "
4818                         "file %s, all policies from this file will "
4819                         "be unavailable via this module",
4820                         adml_file,
4821                     )
4822                     continue
4823                 if None in namespaces:
4824                     namespaces["None"] = namespaces[None]
4825                     namespaces.pop(None)
4826                 policydefs_resources = policydefs_resources_localname_xpath(xml_tree)
4827                 for policydefs_resource in policydefs_resources:
4828                     t_poldef = policydefs_resource
4829                     t_poldef = _updateNamespace(t_poldef, this_namespace)
4830                     policydef_resources_xpath(t_policy_definition_resources)[0].append(
4831                         t_poldef
4832                     )
4833     __context__["lgpo.policy_definitions"] = t_policy_definitions
4834     __context__["lgpo.policy_resources"] = t_policy_definition_resources
4835 def _get_policy_definitions(path="c:\\Windows\\PolicyDefinitions", language="en-US"):
4836     if "lgpo.policy_definitions" not in __context__:
4837         log.debug("LGPO: Loading policy definitions")
4838         _load_policy_definitions(path=path, language=language)
4839     return __context__["lgpo.policy_definitions"]
4840 def _get_policy_resources(path="c:\\Windows\\PolicyDefinitions", language="en-US"):
4841     if "lgpo.policy_resources" not in __context__:
4842         log.debug("LGPO: Loading policy resources")
4843         _load_policy_definitions(path=path, language=language)
4844     return __context__["lgpo.policy_resources"]
4845 def _buildElementNsmap(using_elements):
4846     """
4847     build a namespace map for an ADMX element
4848     """
4849     thisMap = {}
4850     for e in using_elements:
4851         thisMap[e.attrib["prefix"]] = e.attrib["namespace"]
4852     return thisMap
4853 def _get_advaudit_defaults(option=None):
4854     """
4855     Loads audit.csv defaults into a dict in __context__ called
4856     'lgpo.audit_defaults'. The dictionary includes fieldnames and all
4857     configurable policies as keys. The values are used to create/modify the
4858     ``audit.csv`` file. The first entry is `fieldnames` used to create the
4859     header for the csv file. The rest of the entries are the audit policy names.
4860     Sample data follows:
4861     {
4862         'fieldnames': ['Machine Name',
4863                        'Policy Target',
4864                        'Subcategory',
4865                        'Subcategory GUID',
4866                        'Inclusion Setting',
4867                        'Exclusion Setting',
4868                        'Setting Value'],
4869         'Audit Sensitive Privilege Use': {'Auditpol Name': 'Sensitive Privilege Use',
4870                                           'Exclusion Setting': '',
4871                                           'Inclusion Setting': 'No Auditing',
4872                                           'Machine Name': 'WIN-8FGT3E045SE',
4873                                           'Policy Target': 'System',
4874                                           'Setting Value': '0',
4875                                           'Subcategory': u'Audit Sensitive Privilege Use',
4876                                           'Subcategory GUID': '{0CCE9228-69AE-11D9-BED3-505054503030}'},
4877         'Audit Special Logon': {'Auditpol Name': 'Special Logon',
4878                                 'Exclusion Setting': '',
4879                                 'Inclusion Setting': 'No Auditing',
4880                                 'Machine Name': 'WIN-8FGT3E045SE',
4881                                 'Policy Target': 'System',
4882                                 'Setting Value': '0',
4883                                 'Subcategory': u'Audit Special Logon',
4884                                 'Subcategory GUID': '{0CCE921B-69AE-11D9-BED3-505054503030}'},
4885         'Audit System Integrity': {'Auditpol Name': 'System Integrity',
4886                                    'Exclusion Setting': '',
4887                                    'Inclusion Setting': 'No Auditing',
4888                                    'Machine Name': 'WIN-8FGT3E045SE',
4889                                    'Policy Target': 'System',
4890                                    'Setting Value': '0',
4891                                    'Subcategory': u'Audit System Integrity',
4892                                    'Subcategory GUID': '{0CCE9212-69AE-11D9-BED3-505054503030}'},
4893         ...
4894     }
4895     .. note::
4896         `Auditpol Name` designates the value to use when setting the value with
4897         the auditpol command
4898     Args:
4899         option (str): The item from the dictionary to return. If ``None`` the
4900             entire dictionary is returned. Default is ``None``
4901     Returns:
4902         dict: If ``None`` or one of the audit settings is passed
4903         list: If ``fieldnames`` is passed
4904     """
4905     if "lgpo.audit_defaults" not in __context__:
4906         log.debug("Loading auditpol defaults into __context__")
4907         dump = __utils__["auditpol.get_auditpol_dump"]()
4908         reader = csv.DictReader(dump)
4909         audit_defaults = {"fieldnames": reader.fieldnames}
4910         for row in reader:
4911             row["Machine Name"] = ""
4912             row["Auditpol Name"] = row["Subcategory"]
4913             if row["Subcategory"] == "Central Policy Staging":
4914                 row["Subcategory"] = "Audit Central Access Policy Staging"
4915             elif row["Subcategory"] == "Plug and Play Events":
4916                 row["Subcategory"] = "Audit PNP Activity"
4917             elif row["Subcategory"] == "Token Right Adjusted Events":
4918                 row["Subcategory"] = "Audit Token Right Adjusted"
4919             else:
4920                 row["Subcategory"] = "Audit {}".format(row["Subcategory"])
4921             audit_defaults[row["Subcategory"]] = row
4922         __context__["lgpo.audit_defaults"] = audit_defaults
4923     if option:
4924         return __context__["lgpo.audit_defaults"][option]
4925     else:
4926         return __context__["lgpo.audit_defaults"]
4927 def _advaudit_check_csv():
4928     """
4929     This function checks for the existence of the `audit.csv` file here:
4930     `C:\\Windows\\security\\audit`
4931     If the file does not exist, then it copies the `audit.csv` file from the
4932     Group Policy location:
4933     `C:\\Windows\\System32\\GroupPolicy\\Machine\\Microsoft\\Windows NT\\Audit`
4934     If there is no `audit.csv` in either location, then a default `audit.csv`
4935     file is created.
4936     """
4937     system_root = os.environ.get("SystemRoot", "C:\\Windows")
4938     f_audit = os.path.join(system_root, "security", "audit", "audit.csv")
4939     f_audit_gpo = os.path.join(
4940         system_root,
4941         "System32",
4942         "GroupPolicy",
4943         "Machine",
4944         "Microsoft",
4945         "Windows NT",
4946         "Audit",
4947         "audit.csv",
4948     )
4949     if not __salt__["file.file_exists"](f_audit):
4950         if __salt__["file.file_exists"](f_audit_gpo):
4951             __salt__["file.copy"](f_audit_gpo, f_audit)
4952         else:
4953             field_names = _get_advaudit_defaults("fieldnames")
4954             __salt__["file.makedirs"](f_audit)
4955             __salt__["file.write"](f_audit, ",".join(field_names))
4956 def _get_advaudit_value(option, refresh=False):
4957     """
4958     Get the Advanced Auditing policy as configured in
4959     ``C:\\Windows\\Security\\Audit\\audit.csv``
4960     Args:
4961         option (str):
4962             The name of the setting as it appears in audit.csv
4963         refresh (bool):
4964             Refresh secedit data stored in __context__. This is needed for
4965             testing where the state is setting the value, but the module that
4966             is checking the value has its own __context__.
4967     Returns:
4968         bool: ``True`` if successful, otherwise ``False``
4969     """
4970     if "lgpo.adv_audit_data" not in __context__ or refresh is True:
4971         system_root = os.environ.get("SystemRoot", "C:\\Windows")
4972         f_audit = os.path.join(system_root, "security", "audit", "audit.csv")
4973         _advaudit_check_csv()
4974         audit_settings = {}
4975         with salt.utils.files.fopen(f_audit, mode="r") as csv_file:
4976             reader = csv.DictReader(csv_file)
4977             for row in reader:
4978                 audit_settings.update({row["Subcategory"]: row["Setting Value"]})
4979         __context__["lgpo.adv_audit_data"] = audit_settings
4980     return __context__["lgpo.adv_audit_data"].get(option, None)
4981 def _set_advaudit_file_data(option, value):
4982     """
4983     Helper function that sets the Advanced Audit settings in the two .csv files
4984     on Windows. Those files are located at:
4985     C:\\Windows\\Security\\Audit\\audit.csv
4986     C:\\Windows\\System32\\GroupPolicy\\Machine\\Microsoft\\Windows NT\\Audit\\audit.csv
4987     Args:
4988         option (str): The name of the option to set
4989         value (str): The value to set. ['None', '0', '1', '2', '3']
4990     Returns:
4991         bool: ``True`` if successful, otherwise ``False``
4992     """
4993     system_root = os.environ.get("SystemRoot", "C:\\Windows")
4994     f_audit = os.path.join(system_root, "security", "audit", "audit.csv")
4995     f_audit_gpo = os.path.join(
4996         system_root,
4997         "System32",
4998         "GroupPolicy",
4999         "Machine",
5000         "Microsoft",
5001         "Windows NT",
5002         "Audit",
5003         "audit.csv",
5004     )
5005     f_temp = tempfile.NamedTemporaryFile(
5006         mode="w", delete=False, suffix=".csv", prefix="audit"
5007     )
5008     auditpol_values = {
5009         "None": "No Auditing",
5010         "0": "No Auditing",
5011         "1": "Success",
5012         "2": "Failure",
5013         "3": "Success and Failure",
5014     }
5015     _advaudit_check_csv()
5016     try:
5017         with salt.utils.files.fopen(f_audit, mode="r") as csv_file:
5018             reader = csv.DictReader(csv_file)
5019             with salt.utils.files.fopen(f_temp.name, mode="w") as tmp_file:
5020                 writer = csv.DictWriter(tmp_file, fieldnames=reader.fieldnames)
5021                 writer.writeheader()
5022                 value_written = False
5023                 for row in reader:
5024                     if row["Subcategory"] == option:
5025                         if not value == "None":
5026                             row["Inclusion Setting"] = auditpol_values[value]
5027                             row["Setting Value"] = value
5028                             log.trace("LGPO: Setting %s to %s", option, value)
5029                             writer.writerow(row)
5030                         else:
5031                             log.trace("LGPO: Removing %s", option)
5032                         value_written = True
5033                     else:
5034                         writer.writerow(row)
5035                 if not value_written:
5036                     if not value == "None":
5037                         log.trace("LGPO: Setting %s to %s", option, value)
5038                         defaults = _get_advaudit_defaults(option)
5039                         writer.writerow(
5040                             {
5041                                 "Machine Name": defaults["Machine Name"],
5042                                 "Policy Target": defaults["Policy Target"],
5043                                 "Subcategory": defaults["Subcategory"],
5044                                 "Subcategory GUID": defaults["Subcategory GUID"],
5045                                 "Inclusion Setting": auditpol_values[value],
5046                                 "Exclusion Setting": defaults["Exclusion Setting"],
5047                                 "Setting Value": value,
5048                             }
5049                         )
5050                     value_written = True
5051         if value_written:
5052             __salt__["file.copy"](f_temp.name, f_audit, remove_existing=True)
5053             __salt__["file.makedirs"](f_audit_gpo)
5054             __salt__["file.copy"](f_temp.name, f_audit_gpo, remove_existing=True)
5055     finally:
5056         f_temp.close()
5057         __salt__["file.remove"](f_temp.name)
5058     return value_written
5059 def _set_advaudit_pol_data(option, value):
5060     """
5061     Helper function that updates the current applied settings to match what has
5062     just been set in the audit.csv files. We're doing it this way instead of
5063     running `gpupdate`
5064     Args:
5065         option (str): The name of the option to set
5066         value (str): The value to set. ['None', '0', '1', '2', '3']
5067     Returns:
5068         bool: ``True`` if successful, otherwise ``False``
5069     """
5070     auditpol_values = {
5071         "None": "No Auditing",
5072         "0": "No Auditing",
5073         "1": "Success",
5074         "2": "Failure",
5075         "3": "Success and Failure",
5076     }
5077     defaults = _get_advaudit_defaults(option)
5078     return __utils__["auditpol.set_setting"](
5079         name=defaults["Auditpol Name"], value=auditpol_values[value]
5080     )
5081 def _set_advaudit_value(option, value):
5082     """
5083     Helper function to update the Advanced Audit policy on the machine. This
5084     function modifies the two ``audit.csv`` files in the following locations:
5085     C:\\Windows\\Security\\Audit\\audit.csv
5086     C:\\Windows\\System32\\GroupPolicy\\Machine\\Microsoft\\Windows NT\\Audit\\audit.csv
5087     Then it applies those settings using ``auditpol``
5088     After that, it updates ``__context__`` with the new setting
5089     Args:
5090         option (str): The name of the option to set
5091         value (str): The value to set. ['None', '0', '1', '2', '3']
5092     Returns:
5093         bool: ``True`` if successful, otherwise ``False``
5094     """
5095     if not _set_advaudit_file_data(option=option, value=value):
5096         raise CommandExecutionError("Failed to set audit.csv option: {}".format(option))
5097     if not _set_advaudit_pol_data(option=option, value=value):
5098         log.error(
5099             "Failed to apply audit setting: %s\n"
5100             "Policy will take effect on next GPO update",
5101             option,
5102         )
5103     if "lgpo.adv_audit_data" not in __context__:
5104         _get_advaudit_value(option)
5105     if value is None:
5106         log.debug("LGPO: Removing Advanced Audit data: %s", option)
5107         __context__["lgpo.adv_audit_data"].pop(option)
5108     else:
5109         log.debug("LGPO: Updating Advanced Audit data: %s: %s", option, value)
5110         __context__["lgpo.adv_audit_data"][option] = value
5111     return True
5112 def _get_netsh_value(profile, option):
5113     if "lgpo.netsh_data" not in __context__:
5114         __context__["lgpo.netsh_data"] = {}
5115     if profile not in __context__["lgpo.netsh_data"]:
5116         log.debug("LGPO: Loading netsh data for %s profile", profile)
5117         settings = salt.utils.win_lgpo_netsh.get_all_settings(
5118             profile=profile, store="lgpo"
5119         )
5120         __context__["lgpo.netsh_data"].update({profile: settings})
5121     log.trace(
5122         "LGPO: netsh returning value: %s",
5123         __context__["lgpo.netsh_data"][profile][option],
5124     )
5125     return __context__["lgpo.netsh_data"][profile][option]
5126 def _set_netsh_value(profile, section, option, value):
5127     if section not in ("firewallpolicy", "settings", "logging", "state"):
5128         raise ValueError("LGPO: Invalid section: {}".format(section))
5129     log.trace(
5130         "LGPO: Setting the following\nProfile: %s\nSection: %s\nOption: %s\nValue: %s",
5131         profile,
5132         section,
5133         option,
5134         value,
5135     )
5136     if section == "firewallpolicy":
5137         salt.utils.win_lgpo_netsh.set_firewall_settings(
5138             profile=profile,
5139             inbound=value if option == "Inbound" else None,
5140             outbound=value if option == "Outbound" else None,
5141             store="lgpo",
5142         )
5143     if section == "settings":
5144         salt.utils.win_lgpo_netsh.set_settings(
5145             profile=profile, setting=option, value=value, store="lgpo"
5146         )
5147     if section == "state":
5148         salt.utils.win_lgpo_netsh.set_state(profile=profile, state=value, store="lgpo")
5149     if section == "logging":
5150         if option in ("FileName", "MaxFileSize"):
5151             if value == "Not configured":
5152                 value = "notconfigured"
5153         if option.startswith("Log"):
5154             option = option[3:]
5155         salt.utils.win_lgpo_netsh.set_logging_settings(
5156             profile=profile, setting=option, value=value, store="lgpo"
5157         )
5158     log.trace("LGPO: Clearing netsh data for %s profile", profile)
5159     __context__["lgpo.netsh_data"].pop(profile)
5160     return True
5161 def _load_secedit_data():
5162     """
5163     Helper function that loads secedit data. It runs `secedit /export /cfg
5164     &lt;file_name&gt;` which creates a file that contains the secedit data.
5165     Returns:
5166         str: The contents of the file generated by the secedit command
5167     """
5168     f_exp = os.path.join(__opts__["cachedir"], "secedit-{}.txt".format(UUID))
5169     try:
5170         __salt__["cmd.run"](["secedit", "/export", "/cfg", f_exp])
5171         with salt.utils.files.fopen(f_exp, encoding="utf-16") as fp:
5172             secedit_data = fp.readlines()
5173         return secedit_data
5174     finally:
5175         if __salt__["file.file_exists"](f_exp):
5176             __salt__["file.remove"](f_exp)
5177 def _get_secedit_data(refresh=False):
5178     """
5179     Helper function that returns the secedit data in __context__ if it exists
5180     and puts the secedit data in __context__ if it does not.
5181     Args:
5182         refresh (bool):
5183             Refresh secedit data stored in __context__. This is needed for
5184             testing where the state is setting the value, but the module that
5185             is checking the value has its own __context__.
5186     Returns:
5187         str: secedit data from __context__
5188     """
5189     if "lgpo.secedit_data" not in __context__ or refresh is True:
5190         log.debug("LGPO: Loading secedit data")
5191         __context__["lgpo.secedit_data"] = _load_secedit_data()
5192     return __context__["lgpo.secedit_data"]
5193 def _get_secedit_value(option):
5194     """
5195     Helper function that looks for the passed option in the secedit data
5196     """
5197     secedit_data = _get_secedit_data()
5198     for _line in secedit_data:
5199         if _line.startswith(option):
5200             return _line.split("=")[1].strip()
5201     return "Not Defined"
5202 def _write_secedit_data(inf_data):
5203     """
5204     Helper function to write secedit data to the database
5205     """
5206     f_sdb = os.path.join(os.getenv("WINDIR"), "security", "database", "salt.sdb")
5207     f_inf = os.path.join(__opts__["cachedir"], "secedit-{}.inf".format(UUID))
5208     try:
5209         with salt.utils.files.fopen(f_inf, "w", encoding="utf-16") as fp:
5210             fp.write(inf_data)
5211         cmd = ["secedit", "/import", "/db", f_sdb, "/cfg", f_inf]
5212         retcode = __salt__["cmd.retcode"](cmd)
5213         if not retcode == 0:
5214             log.debug("Secedit failed to import template data")
5215             return False
5216         cmd = ["secedit", "/configure", "/db", f_sdb]
5217         retcode = __salt__["cmd.retcode"](cmd)
5218         if not retcode == 0:
5219             log.debug("Secedit failed to apply security database")
5220             return False
5221         __context__.pop("lgpo.secedit_data", None)
5222         return True
5223     finally:
5224         if __salt__["file.file_exists"](f_inf):
5225             __salt__["file.remove"](f_inf)
5226 def _transform_value(value, policy, transform_type):
5227     """
5228     helper function to transform the policy value into something that more
5229     closely matches how the policy is displayed in the gpedit GUI
5230     """
5231     t_kwargs = {}
5232     if "Transform" in policy:
5233         if transform_type in policy["Transform"]:
5234             _policydata = _policy_info()
5235             if transform_type + "Args" in policy["Transform"]:
5236                 t_kwargs = policy["Transform"][transform_type + "Args"]
5237             return getattr(_policydata, policy["Transform"][transform_type])(
5238                 value, **t_kwargs
5239             )
5240         else:
5241             return value
5242     else:
5243         if "Registry" in policy:
5244             if value == "(value not set)":
5245                 return "Not Defined"
5246         return value
5247 def _validateSetting(value, policy):
5248     """
5249     helper function to validate specified value is appropriate for the policy
5250     if the 'Settings' key is a list, the value will check that it is in the list
5251     if the 'Settings' key is a dict we will try to execute the function name
5252         from the 'Function' key, passing the value and additional arguments from
5253         the 'Args' dict
5254     if the 'Settings' key is None, we won't do any validation and just return
5255         True
5256     if the Policy has 'Children', we'll validate their settings too
5257     """
5258     log.debug("validating %s for policy %s", value, policy)
5259     if "Settings" in policy:
5260         if policy["Settings"]:
5261             if isinstance(policy["Settings"], list):
5262                 if value not in policy["Settings"]:
5263                     return False
5264             elif isinstance(policy["Settings"], dict):
5265                 _policydata = _policy_info()
5266                 if not getattr(_policydata, policy["Settings"]["Function"])(
5267                     value, **policy["Settings"]["Args"]
5268                 ):
5269                     return False
5270     else:
5271         return True
5272     return True
5273 def _addAccountRights(sidObject, user_right):
5274     """
5275     helper function to add an account right to a user
5276     """
5277     try:
5278         if sidObject:
5279             _polHandle = win32security.LsaOpenPolicy(
5280                 None, win32security.POLICY_ALL_ACCESS
5281             )
5282             user_rights_list = [user_right]
5283             _ret = win32security.LsaAddAccountRights(
5284                 _polHandle, sidObject, user_rights_list
5285             )
5286         return True
5287     except Exception as e:  # pylint: disable=broad-except
5288         log.exception("Error attempting to add account right, exception was %s", e)
5289         return False
5290 def _delAccountRights(sidObject, user_right):
5291     """
5292     helper function to remove an account right from a user
5293     """
5294     try:
5295         _polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS)
5296         user_rights_list = [user_right]
5297         _ret = win32security.LsaRemoveAccountRights(
5298             _polHandle, sidObject, False, user_rights_list
5299         )
5300         return True
5301     except Exception as e:  # pylint: disable=broad-except
5302         log.exception("Error attempting to delete account right")
5303         return False
5304 def _getRightsAssignments(user_right):
5305     """
5306     helper function to return all the user rights assignments/users
5307     """
5308     sids = []
5309     polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS)
5310     sids = win32security.LsaEnumerateAccountsWithUserRight(polHandle, user_right)
5311     return sids
5312 def _getAdmlDisplayName(adml_xml_data, display_name):
5313     """
5314     helper function to take the 'displayName' attribute of an element and find
5315     the value from the ADML data
5316     adml_xml_data :: XML data of all ADML files to search
5317     display_name :: the value of the displayName attribute from the ADMX entry
5318                     to search the ADML data for
5319     """
5320     if display_name.startswith("$(") and display_name.endswith(")"):
5321         display_name = re.sub(r"(^\$\(|\)$)", "", display_name)
5322         display_name = display_name.split(".")
5323         displayname_type = display_name[0]
5324         displayname_id = display_name[1]
5325         search_results = ADML_DISPLAY_NAME_XPATH(
5326             adml_xml_data,
5327             displayNameType=displayname_type,
5328             displayNameId=displayname_id,
5329         )
5330         if search_results:
5331             for result in search_results:
5332                 return result.text.strip()
5333     return None
5334 def _getAdmlPresentationRefId(adml_data, ref_id):
5335     """
5336     helper function to check for a presentation label for a policy element
5337     """
5338     search_results = adml_data.xpath(
5339         '//*[@*[local-name() = "refId"] = "{}"]'.format(ref_id)
5340     )
5341     alternate_label = ""
5342     if search_results:
5343         for result in search_results:
5344             the_localname = etree.QName(result.tag).localname
5345             if result.text is None:
5346                 presentation_element = PRESENTATION_ANCESTOR_XPATH(result)
5347                 if presentation_element:
5348                     presentation_element = presentation_element[0]
5349                     if TEXT_ELEMENT_XPATH(presentation_element):
5350                         for p_item in presentation_element:
5351                             if p_item == result:
5352                                 break
5353                             if etree.QName(p_item.tag).localname == "text":
5354                                 if getattr(p_item, "text"):
5355                                     alternate_label = getattr(p_item, "text").rstrip()
5356                         if alternate_label.endswith("."):
5357                             alternate_label = ""
5358             if the_localname in ["textBox", "comboBox"]:
5359                 label_items = result.xpath('.//*[local-name() = "label"]')
5360                 for label_item in label_items:
5361                     if label_item.text:
5362                         return label_item.text.rstrip().rstrip(":")
5363             elif the_localname in [
5364                 "decimalTextBox",
5365                 "longDecimalTextBox",
5366                 "dropdownList",
5367                 "listBox",
5368                 "checkBox",
5369                 "text",
5370                 "multiTextBox",
5371             ]:
5372                 if result.text:
5373                     return result.text.rstrip().rstrip(":")
5374                 else:
5375                     return alternate_label.rstrip(":")
5376     return None
5377 def _getFullPolicyName(
5378     policy_item, policy_name, return_full_policy_names, adml_language
5379 ):
5380     """
5381     helper function to retrieve the full policy name if needed
5382     """
5383     if policy_name in adm_policy_name_map[return_full_policy_names]:
5384         return adm_policy_name_map[return_full_policy_names][policy_name]
5385     adml_data = _get_policy_resources(language=adml_language)
5386     if return_full_policy_names and "displayName" in policy_item.attrib:
5387         fullPolicyName = _getAdmlDisplayName(
5388             adml_data, policy_item.attrib["displayName"]
5389         )
5390         if fullPolicyName:
5391             adm_policy_name_map[return_full_policy_names][policy_name] = fullPolicyName
5392             policy_name = fullPolicyName
5393     elif return_full_policy_names and "id" in policy_item.attrib:
5394         fullPolicyName = _getAdmlPresentationRefId(adml_data, policy_item.attrib["id"])
5395         if fullPolicyName:
5396             adm_policy_name_map[return_full_policy_names][policy_name] = fullPolicyName
5397             policy_name = fullPolicyName
5398     policy_name = policy_name.rstrip(":").rstrip()
5399     return policy_name
5400 def _regexSearchRegPolData(search_string, policy_data):
5401     """
5402     Helper function to do a regex search of a string value in policy_data.
5403     This is used to search the policy data from a registry.pol file or from
5404     gpt.ini
5405     Args:
5406         search_string (str): The string to search for
5407         policy_data (str): The data to be searched
5408     Returns:
5409         bool: ``True`` if the regex search_string is found, otherwise ``False``
5410     """
5411     if policy_data:
5412         if search_string:
5413             match = re.search(search_string, policy_data, re.IGNORECASE)
5414             if match:
5415                 return True
5416     return False
5417 def _getDataFromRegPolData(search_string, policy_data, return_value_name=False):
5418     """
5419     helper function to do a search of Policy data from a registry.pol file
5420     returns the "data" field
5421     https://msdn.microsoft.com/en-us/library/aa374407(VS.85).aspx
5422     [key;value;type;size;data]
5423     """
5424     value = None
5425     values = []
5426     encoded_semicolon = ";".encode("utf-16-le")
5427     if return_value_name:
5428         values = {}
5429     if search_string:
5430         registry = Registry()
5431         if len(search_string.split(encoded_semicolon)) &gt;= 3:
5432             vtype = registry.vtype_reverse[
5433                 ord(search_string.split(encoded_semicolon)[2].decode("utf-32-le"))
5434             ]
5435         else:
5436             vtype = None
5437         search_string = re.escape(search_string)
5438         matches = re.finditer(search_string, policy_data, re.IGNORECASE)
5439         matches = [m for m in matches]
5440         if matches:
5441             for match in matches:
5442                 pol_entry = policy_data[
5443                     match.start() : (
5444                         policy_data.index("]".encode("utf-16-le"), match.end())
5445                     )
5446                 ].split(encoded_semicolon, 4)
5447                 if len(pol_entry) &gt;= 2:
5448                     valueName = pol_entry[1].decode("utf-16-le").rstrip(chr(0))
5449                 if len(pol_entry) &gt;= 5:
5450                     value = encoded_semicolon.join(pol_entry[4:])
5451                     if vtype == "REG_DWORD" or vtype == "REG_QWORD":
5452                         if value:
5453                             if vtype == "REG_DWORD":
5454                                 for v in struct.unpack(b"I", value):
5455                                     value = v
5456                             elif vtype == "REG_QWORD":
5457                                 for v in struct.unpack(b"Q", value):
5458                                     value = v
5459                         else:
5460                             value = 0
5461                     elif vtype == "REG_MULTI_SZ":
5462                         value = value.decode("utf-16-le").rstrip(chr(0)).split(chr(0))
5463                     else:
5464                         value = value.decode("utf-16-le").rstrip(chr(0))
5465                 if return_value_name:
5466                     log.trace("we want value names and the value")
5467                     values[valueName] = value
5468                 elif len(matches) &gt; 1:
5469                     log.trace("we have multiple matches, we will return a list")
5470                     values.append(value)
5471     if values:
5472         value = values
5473     return value
5474 def _checkListItem(
5475     policy_element,
5476     policy_name,
5477     policy_key,
5478     xpath_object,
5479     policy_file_data,
5480     test_items=True,
5481 ):
5482     """
5483     helper function to process an enabled/disabled/true/falseList set
5484     if test_items is True, it will determine if the policy is enabled or
5485     disabled returning True if all items are configured in the registry.pol file
5486     and false if they are not
5487     if test_items is False, the expected strings for the items will be returned
5488     as a list
5489     returns True if the enabled/disabledList is 100% configured in the
5490     registry.pol file, otherwise returns False
5491     """
5492     xpath_string = (
5493         './/*[local-name() = "decimal" or local-name() = "delete"'
5494         ' or local-name() = "longDecimal" or local-name() = "string"]'
5495     )
5496     value_item_child_xpath = etree.XPath(xpath_string)
5497     expected_strings = []
5498     for list_element in xpath_object(policy_element):
5499         configured_items = 0
5500         required_items = 0
5501         for item in list_element:
5502             required_items = required_items + 1
5503             if "key" in item.attrib:
5504                 item_key = item.attrib["key"]
5505             else:
5506                 item_key = policy_key
5507             if "valueName" in item.attrib:
5508                 item_valuename = item.attrib["valueName"]
5509             else:
5510                 log.error(
5511                     "%s item with attributes %s in policy %s does not "
5512                     'have the required "valueName" attribute',
5513                     etree.QName(list_element).localname,
5514                     item.attrib,
5515                     policy_element.attrib,
5516                 )
5517                 break
5518             for value_item in value_item_child_xpath(item):
5519                 search_string = _processValueItem(
5520                     value_item, item_key, item_valuename, policy_element, item
5521                 )
5522                 if test_items:
5523                     if _regexSearchRegPolData(
5524                         re.escape(search_string), policy_file_data
5525                     ):
5526                         configured_items = configured_items + 1
5527                         log.trace(
5528                             "found the search string in the pol file,"
5529                             "%s of %s items for policy %s are "
5530                             "configured in registry.pol",
5531                             configured_items,
5532                             required_items,
5533                             policy_name,
5534                         )
5535                 else:
5536                     expected_strings.append(search_string)
5537         if test_items:
5538             if required_items &gt; 0 and required_items == configured_items:
5539                 log.trace("%s all items are set", policy_name)
5540                 return True
5541     if test_items:
5542         return False
5543     else:
5544         return expected_strings
5545 def _checkValueItemParent(
5546     policy_element,
5547     policy_name,
5548     policy_key,
5549     policy_valueName,
5550     xpath_object,
5551     policy_file_data,
5552     check_deleted=False,
5553     test_item=True,
5554 ):
5555     """
5556     helper function to process the parent of a value item object
5557     if test_item is True, it will determine if the policy is enabled/disabled
5558     returns True if the value is configured in the registry.pol file, otherwise returns False
5559     if test_item is False, the expected search string will be returned
5560     value type parents:
5561         boolean: https://msdn.microsoft.com/en-us/library/dn606009(v=vs.85).aspx
5562         enabledValue: https://msdn.microsoft.com/en-us/library/dn606006(v=vs.85).aspx
5563         disabledValue: https://msdn.microsoft.com/en-us/library/dn606001(v=vs.85).aspx
5564     """
5565     for element in xpath_object(policy_element):
5566         for value_item in element:
5567             search_string = _processValueItem(
5568                 value_item,
5569                 policy_key,
5570                 policy_valueName,
5571                 policy_element,
5572                 element,
5573                 check_deleted=check_deleted,
5574             )
5575             if not test_item:
5576                 return search_string
5577             if _regexSearchRegPolData(re.escape(search_string), policy_file_data):
5578                 log.trace(
5579                     "found the search string in the pol file, %s is configured",
5580                     policy_name,
5581                 )
5582                 return True
5583     return False
5584 def _encode_string(value):
5585     encoded_null = chr(0).encode("utf-16-le")
5586     if value is None:
5587         return encoded_null
5588     elif not isinstance(value, str):
5589         raise TypeError(
5590             "Value {} is not a string type\nType: {}".format(repr(value), type(value))
5591         )
5592     return b"".join([value.encode("utf-16-le"), encoded_null])
5593 def _buildKnownDataSearchString(
5594     reg_key, reg_valueName, reg_vtype, reg_data, check_deleted=False
5595 ):
5596     """
5597     helper function similar to _processValueItem to build a search string for a
5598     known key/value/type/data
5599     """
5600     registry = Registry()
5601     this_element_value = None
5602     expected_string = b""
5603     encoded_semicolon = ";".encode("utf-16-le")
5604     encoded_null = chr(0).encode("utf-16-le")
5605     if reg_key:
5606         reg_key = reg_key.encode("utf-16-le")
5607     if reg_valueName:
5608         reg_valueName = reg_valueName.encode("utf-16-le")
5609     if reg_data and not check_deleted:
5610         if reg_vtype == "REG_DWORD":
5611             this_element_value = struct.pack(b"I", int(reg_data))
5612         elif reg_vtype == "REG_QWORD":
5613             this_element_value = struct.pack(b"Q", int(reg_data))
5614         elif reg_vtype == "REG_SZ":
5615             this_element_value = _encode_string(reg_data)
5616     if check_deleted:
5617         reg_vtype = "REG_SZ"
5618         expected_string = b"".join(
5619             [
5620                 "[".encode("utf-16-le"),
5621                 reg_key,
5622                 encoded_null,
5623                 encoded_semicolon,
5624                 "**del.".encode("utf-16-le"),
5625                 reg_valueName,
5626                 encoded_null,
5627                 encoded_semicolon,
5628                 chr(registry.vtype[reg_vtype]).encode("utf-32-le"),
5629                 encoded_semicolon,
5630                 chr(len(" {}".format(chr(0)).encode("utf-16-le"))).encode("utf-32-le"),
5631                 encoded_semicolon,
5632                 " ".encode("utf-16-le"),
5633                 encoded_null,
5634                 "]".encode("utf-16-le"),
5635             ]
5636         )
5637     else:
5638         expected_string = b"".join(
5639             [
5640                 "[".encode("utf-16-le"),
5641                 reg_key,
5642                 encoded_null,
5643                 encoded_semicolon,
5644                 reg_valueName,
5645                 encoded_null,
5646                 encoded_semicolon,
5647                 chr(registry.vtype[reg_vtype]).encode("utf-32-le"),
5648                 encoded_semicolon,
5649                 chr(len(this_element_value)).encode("utf-32-le"),
5650                 encoded_semicolon,
5651                 this_element_value,
5652                 "]".encode("utf-16-le"),
5653             ]
5654         )
5655     return expected_string
5656 def _processValueItem(
5657     element,
5658     reg_key,
5659     reg_valuename,
5660     policy,
5661     parent_element,
5662     check_deleted=False,
5663     this_element_value=None,
5664 ):
5665     """
5666     helper function to process a value type item and generate the expected
5667     string in the Registry.pol file
5668     element - the element to process
5669     reg_key - the registry key associated with the element (some inherit from
5670               their parent policy)
5671     reg_valuename - the registry valueName associated with the element (some
5672                     inherit from their parent policy)
5673     policy - the parent policy element
5674     parent_element - the parent element (primarily passed in to differentiate
5675                      children of "elements" objects
5676     check_deleted - if the returned expected string should be for a deleted
5677                     value
5678     this_element_value - a specific value to place into the expected string
5679                          returned for "elements" children whose values are
5680                          specified by the user
5681     """
5682     registry = Registry()
5683     expected_string = None
5684     this_vtype = "REG_SZ"
5685     encoded_semicolon = ";".encode("utf-16-le")
5686     encoded_null = chr(0).encode("utf-16-le")
5687     if reg_key:
5688         reg_key = reg_key.encode("utf-16-le")
5689     if reg_valuename:
5690         reg_valuename = reg_valuename.encode("utf-16-le")
5691     if (
5692         etree.QName(element).localname == "decimal"
5693         and etree.QName(parent_element).localname != "elements"
5694     ):
5695         this_vtype = "REG_DWORD"
5696         if "value" in element.attrib:
5697             this_element_value = struct.pack(b"I", int(element.attrib["value"]))
5698         else:
5699             log.error(
5700                 "The %s child %s element for the policy with "
5701                 'attributes: %s does not have the required "value" '
5702                 "attribute. The element attributes are: %s",
5703                 etree.QName(parent_element).localname,
5704                 etree.QName(element).localname,
5705                 policy.attrib,
5706                 element.attrib,
5707             )
5708             return None
5709     elif (
5710         etree.QName(element).localname == "longDecimal"
5711         and etree.QName(parent_element).localname != "elements"
5712     ):
5713         this_vtype = "REG_QWORD"
5714         if "value" in element.attrib:
5715             this_element_value = struct.pack(b"Q", int(element.attrib["value"]))
5716         else:
5717             log.error(
5718                 "The %s child %s element for the policy with "
5719                 'attributes: %s does not have the required "value" '
5720                 "attribute. The element attributes are: %s",
5721                 etree.QName(parent_element).localname,
5722                 etree.QName(element).localname,
5723                 policy.attrib,
5724                 element.attrib,
5725             )
5726             return None
5727     elif etree.QName(element).localname == "string":
5728         this_vtype = "REG_SZ"
5729         this_element_value = _encode_string(element.text)
5730     elif etree.QName(parent_element).localname == "elements":
5731         standard_element_expected_string = True
5732         if etree.QName(element).localname == "boolean":
5733             if this_element_value is False:
5734                 check_deleted = True
5735             if not check_deleted:
5736                 this_vtype = "REG_DWORD"
5737             this_element_value = struct.pack("I", 1)
5738             standard_element_expected_string = False
5739         elif etree.QName(element).localname == "decimal":
5740             this_vtype = "REG_DWORD"
5741             requested_val = this_element_value
5742             if this_element_value is not None:
5743                 this_element_value = struct.pack(b"I", int(this_element_value))
5744             if "storeAsText" in element.attrib:
5745                 if element.attrib["storeAsText"].lower() == "true":
5746                     this_vtype = "REG_SZ"
5747                     if requested_val is not None:
5748                         this_element_value = str(requested_val).encode("utf-16-le")
5749             if check_deleted:
5750                 this_vtype = "REG_SZ"
5751         elif etree.QName(element).localname == "longDecimal":
5752             this_vtype = "REG_QWORD"
5753             requested_val = this_element_value
5754             if this_element_value is not None:
5755                 this_element_value = struct.pack(b"Q", int(this_element_value))
5756             if "storeAsText" in element.attrib:
5757                 if element.attrib["storeAsText"].lower() == "true":
5758                     this_vtype = "REG_SZ"
5759                     if requested_val is not None:
5760                         this_element_value = str(requested_val).encode("utf-16-le")
5761         elif etree.QName(element).localname == "text":
5762             this_vtype = "REG_SZ"
5763             if "expandable" in element.attrib:
5764                 if element.attrib["expandable"].lower() == "true":
5765                     this_vtype = "REG_EXPAND_SZ"
5766             if this_element_value is not None:
5767                 this_element_value = _encode_string(this_element_value)
5768         elif etree.QName(element).localname == "multiText":
5769             this_vtype = "REG_MULTI_SZ" if not check_deleted else "REG_SZ"
5770             if this_element_value is not None:
5771                 this_element_value = "{0}{1}{1}".format(
5772                     chr(0).join(this_element_value), chr(0)
5773                 )
5774         elif etree.QName(element).localname == "list":
5775             standard_element_expected_string = False
5776             del_keys = b""
5777             element_valuenames = []
5778             element_values = this_element_value
5779             if this_element_value is not None:
5780                 element_valuenames = [
5781                     str(z) for z in range(1, len(this_element_value) + 1)
5782                 ]
5783             if "additive" in element.attrib:
5784                 if element.attrib["additive"].lower() == "false":
5785                     del_keys = b"".join(
5786                         [
5787                             "[".encode("utf-16-le"),
5788                             reg_key,
5789                             encoded_null,
5790                             encoded_semicolon,
5791                             "**delvals.".encode("utf-16-le"),
5792                             encoded_null,
5793                             encoded_semicolon,
5794                             chr(registry.vtype[this_vtype]).encode("utf-32-le"),
5795                             encoded_semicolon,
5796                             chr(len(" {}".format(chr(0)).encode("utf-16-le"))).encode(
5797                                 "utf-32-le"
5798                             ),
5799                             encoded_semicolon,
5800                             " ".encode("utf-16-le"),
5801                             encoded_null,
5802                             "]".encode("utf-16-le"),
5803                         ]
5804                     )
5805             if "expandable" in element.attrib:
5806                 this_vtype = "REG_EXPAND_SZ"
5807             if element.attrib.get("explicitValue", "false").lower() == "true":
5808                 if this_element_value is not None:
5809                     element_valuenames = [str(k) for k in this_element_value.keys()]
5810                     element_values = [str(v) for v in this_element_value.values()]
5811             elif "valuePrefix" in element.attrib:
5812                 if element.attrib["valuePrefix"] != "":
5813                     if this_element_value is not None:
5814                         element_valuenames = [
5815                             "{}{}".format(element.attrib["valuePrefix"], k)
5816                             for k in element_valuenames
5817                         ]
5818             else:
5819                 if element_values is not None:
5820                     element_valuenames = [str(z) for z in element_values]
5821             if not check_deleted:
5822                 if this_element_value is not None:
5823                     log.trace(
5824                         "_processValueItem has an explicit element_value of %s",
5825                         this_element_value,
5826                     )
5827                     expected_string = del_keys
5828                     log.trace(
5829                         "element_valuenames == %s and element_values == %s",
5830                         element_valuenames,
5831                         element_values,
5832                     )
5833                     for i, item in enumerate(element_valuenames):
5834                         expected_string = expected_string + b"".join(
5835                             [
5836                                 "[".encode("utf-16-le"),
5837                                 reg_key,
5838                                 encoded_null,
5839                                 encoded_semicolon,
5840                                 element_valuenames[i].encode("utf-16-le"),
5841                                 encoded_null,
5842                                 encoded_semicolon,
5843                                 chr(registry.vtype[this_vtype]).encode("utf-32-le"),
5844                                 encoded_semicolon,
5845                                 chr(
5846                                     len(
5847                                         "{}{}".format(element_values[i], chr(0)).encode(
5848                                             "utf-16-le"
5849                                         )
5850                                     )
5851                                 ).encode("utf-32-le"),
5852                                 encoded_semicolon,
5853                                 _encode_string(element_values[i]),
5854                                 "]".encode("utf-16-le"),
5855                             ]
5856                         )
5857                 else:
5858                     expected_string = del_keys + b"".join(
5859                         [
5860                             "[".encode("utf-16-le"),
5861                             reg_key,
5862                             encoded_null,
5863                             encoded_semicolon,
5864                         ]
5865                     )
5866             else:
5867                 expected_string = b"".join(
5868                     [
5869                         "[".encode("utf-16-le"),
5870                         reg_key,
5871                         encoded_null,
5872                         encoded_semicolon,
5873                         "**delvals.".encode("utf-16-le"),
5874                         encoded_null,
5875                         encoded_semicolon,
5876                         chr(registry.vtype[this_vtype]).encode("utf-32-le"),
5877                         encoded_semicolon,
5878                         chr(len(" {}".format(chr(0)).encode("utf-16-le"))).encode(
5879                             "utf-32-le"
5880                         ),
5881                         encoded_semicolon,
5882                         " ".encode("utf-16-le"),
5883                         encoded_null,
5884                         "]".encode("utf-16-le"),
5885                     ]
5886                 )
5887         elif etree.QName(element).localname == "enum":
5888             if this_element_value is not None:
5889                 pass
5890         if standard_element_expected_string and not check_deleted:
5891             if this_element_value is not None:
5892                 if isinstance(this_element_value, str):
5893                     log.debug("Converting %s to bytes", this_element_value)
5894                     this_element_value = this_element_value.encode("utf-32-le")
5895                 expected_string = b"".join(
5896                     [
5897                         "[".encode("utf-16-le"),
5898                         reg_key,
5899                         encoded_null,
5900                         encoded_semicolon,
5901                         reg_valuename,
5902                         encoded_null,
5903                         encoded_semicolon,
5904                         chr(registry.vtype[this_vtype]).encode("utf-32-le"),
5905                         encoded_semicolon,
5906                         chr(len(this_element_value)).encode("utf-32-le"),
5907                         encoded_semicolon,
5908                         this_element_value,
5909                         "]".encode("utf-16-le"),
5910                     ]
5911                 )
5912             else:
5913                 expected_string = b"".join(
5914                     [
5915                         "[".encode("utf-16-le"),
5916                         reg_key,
5917                         encoded_null,
5918                         encoded_semicolon,
5919                         reg_valuename,
5920                         encoded_null,
5921                         encoded_semicolon,
5922                         chr(registry.vtype[this_vtype]).encode("utf-32-le"),
5923                         encoded_semicolon,
5924                     ]
5925                 )
5926     if not expected_string:
5927         if etree.QName(element).localname == "delete" or check_deleted:
5928             expected_string = b"".join(
5929                 [
5930                     "[".encode("utf-16-le"),
5931                     reg_key,
5932                     encoded_null,
5933                     encoded_semicolon,
5934                     "**del.".encode("utf-16-le"),
5935                     reg_valuename,
5936                     encoded_null,
5937                     encoded_semicolon,
5938                     chr(registry.vtype[this_vtype]).encode("utf-32-le"),
5939                     encoded_semicolon,
5940                     chr(len(" {}".format(chr(0)).encode("utf-16-le"))).encode(
5941                         "utf-32-le"
5942                     ),
5943                     encoded_semicolon,
5944                     " ".encode("utf-16-le"),
5945                     encoded_null,
5946                     "]".encode("utf-16-le"),
5947                 ]
5948             )
5949         else:
5950             expected_string = b"".join(
5951                 [
5952                     "[".encode("utf-16-le"),
5953                     reg_key,
5954                     encoded_null,
5955                     encoded_semicolon,
5956                     reg_valuename,
5957                     encoded_null,
5958                     encoded_semicolon,
5959                     chr(registry.vtype[this_vtype]).encode("utf-32-le"),
5960                     encoded_semicolon,
5961                     chr(len(this_element_value)).encode("utf-32-le"),
5962                     encoded_semicolon,
5963                     this_element_value,
5964                     "]".encode("utf-16-le"),
5965                 ]
5966             )
5967     return expected_string
5968 def _checkAllAdmxPolicies(
5969     policy_class,
5970     adml_language="en-US",
5971     return_full_policy_names=False,
5972     hierarchical_return=False,
5973     return_not_configured=False,
5974 ):
5975     """
5976     rewrite of _getAllAdminTemplateSettingsFromRegPolFile where instead of
5977     looking only at the contents of the file, we're going to loop through every
5978     policy and look in the registry.pol file to determine if it is
5979     enabled/disabled/not configured
5980     """
5981     log.trace("POLICY CLASS == %s", policy_class)
5982     module_policy_data = _policy_info()
5983     policy_file_data = _read_regpol_file(
5984         module_policy_data.admx_registry_classes[policy_class]["policy_path"]
5985     )
5986     admx_policies = []
5987     policy_vals = {}
5988     hierarchy = {}
5989     full_names = {}
5990     admx_policy_definitions = _get_policy_definitions(language=adml_language)
5991     adml_policy_resources = _get_policy_resources(language=adml_language)
5992     if policy_file_data:
5993         log.trace("POLICY CLASS %s has file data", policy_class)
5994         policy_filedata_split = re.sub(
5995             salt.utils.stringutils.to_bytes(r"\]{}$".format(chr(0))),
5996             b"",
5997             re.sub(
5998                 salt.utils.stringutils.to_bytes(r"^\[{}".format(chr(0))),
5999                 b"",
6000                 re.sub(
6001                     re.escape(module_policy_data.reg_pol_header.encode("utf-16-le")),
6002                     b"",
6003                     policy_file_data,
6004                 ),
6005             ),
6006         ).split("][".encode("utf-16-le"))
6007         log.trace("Searching %s policies...", len(policy_filedata_split))
6008         start_time = time.time()
6009         for policy_item in policy_filedata_split:
6010             policy_item_key = (
6011                 policy_item.split("{};".format(chr(0)).encode("utf-16-le"))[0]
6012                 .decode("utf-16-le")
6013                 .lower()
6014             )
6015             if policy_item_key:
6016                 admx_items = REGKEY_XPATH(
6017                     admx_policy_definitions, keyvalue=policy_item_key
6018                 )
6019                 log.trace("Found %s policies for %s", len(admx_items), policy_item_key)
6020                 for admx_item in admx_items:
6021                     if etree.QName(admx_item).localname == "policy":
6022                         if admx_item not in admx_policies:
6023                             admx_policies.append(admx_item)
6024                     else:
6025                         for policy_item in POLICY_ANCESTOR_XPATH(admx_item):
6026                             if policy_item not in admx_policies:
6027                                 admx_policies.append(policy_item)
6028         log.trace("Search complete: %s seconds", time.time() - start_time)
6029         if return_not_configured:
6030             log.trace("Gathering non configured policies")
6031             start_time = time.time()
6032             not_configured_policies = ALL_CLASS_POLICY_XPATH(
6033                 admx_policy_definitions, registry_class=policy_class
6034             )
6035             for policy_item in admx_policies:
6036                 if policy_item in not_configured_policies:
6037                     not_configured_policies.remove(policy_item)
6038             for not_configured_policy in not_configured_policies:
6039                 not_configured_policy_namespace = not_configured_policy.nsmap[
6040                     not_configured_policy.prefix
6041                 ]
6042                 if not_configured_policy_namespace not in policy_vals:
6043                     policy_vals[not_configured_policy_namespace] = {}
6044                 policy_vals[not_configured_policy_namespace][
6045                     not_configured_policy.attrib["name"]
6046                 ] = "Not Configured"
6047                 if return_full_policy_names:
6048                     if not_configured_policy_namespace not in full_names:
6049                         full_names[not_configured_policy_namespace] = {}
6050                     full_names[not_configured_policy_namespace][
6051                         not_configured_policy.attrib["name"]
6052                     ] = _getFullPolicyName(
6053                         policy_item=not_configured_policy,
6054                         policy_name=not_configured_policy.attrib["name"],
6055                         return_full_policy_names=return_full_policy_names,
6056                         adml_language=adml_language,
6057                     )
6058                 log.trace(
6059                     "building hierarchy for non-configured item %s",
6060                     not_configured_policy.attrib["name"],
6061                 )
6062                 if not_configured_policy_namespace not in hierarchy:
6063                     hierarchy[not_configured_policy_namespace] = {}
6064                 hierarchy[not_configured_policy_namespace][
6065                     not_configured_policy.attrib["name"]
6066                 ] = _build_parent_list(
6067                     policy_definition=not_configured_policy,
6068                     return_full_policy_names=return_full_policy_names,
6069                     adml_language=adml_language,
6070                 )
6071             log.trace("Gathering complete: %s seconds", time.time() - start_time)
6072         log.trace("Examining %s policies...", len(admx_policies))
6073         start_time = time.time()
6074         for admx_policy in admx_policies:
6075             this_valuename = None
6076             this_policy_setting = "Not Configured"
6077             element_only_enabled_disabled = True
6078             explicit_enable_disable_value_setting = False
6079             if "key" in admx_policy.attrib:
6080                 this_key = admx_policy.attrib["key"]
6081             else:
6082                 log.error(
6083                     'policy item %s does not have the required "key" attribute',
6084                     admx_policy.attrib,
6085                 )
6086                 break
6087             if "valueName" in admx_policy.attrib:
6088                 this_valuename = admx_policy.attrib["valueName"]
6089             if "name" in admx_policy.attrib:
6090                 this_policyname = admx_policy.attrib["name"]
6091             else:
6092                 log.error(
6093                     'policy item %s does not have the required "name" attribute',
6094                     admx_policy.attrib,
6095                 )
6096                 break
6097             this_policynamespace = admx_policy.nsmap[admx_policy.prefix]
6098             if (
6099                 ENABLED_VALUE_XPATH(admx_policy)
6100                 and this_policy_setting == "Not Configured"
6101             ):
6102                 if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(
6103                     admx_policy
6104                 ):
6105                     element_only_enabled_disabled = False
6106                     explicit_enable_disable_value_setting = True
6107                 if _checkValueItemParent(
6108                     admx_policy,
6109                     this_policyname,
6110                     this_key,
6111                     this_valuename,
6112                     ENABLED_VALUE_XPATH,
6113                     policy_file_data,
6114                 ):
6115                     this_policy_setting = "Enabled"
6116                     log.trace(
6117                         "%s is enabled by detected ENABLED_VALUE_XPATH", this_policyname
6118                     )
6119                     if this_policynamespace not in policy_vals:
6120                         policy_vals[this_policynamespace] = {}
6121                     policy_vals[this_policynamespace][
6122                         this_policyname
6123                     ] = this_policy_setting
6124             if (
6125                 DISABLED_VALUE_XPATH(admx_policy)
6126                 and this_policy_setting == "Not Configured"
6127             ):
6128                 if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):
6129                     element_only_enabled_disabled = False
6130                     explicit_enable_disable_value_setting = True
6131                 if _checkValueItemParent(
6132                     admx_policy,
6133                     this_policyname,
6134                     this_key,
6135                     this_valuename,
6136                     DISABLED_VALUE_XPATH,
6137                     policy_file_data,
6138                 ):
6139                     this_policy_setting = "Disabled"
6140                     log.trace(
6141                         "%s is disabled by detected DISABLED_VALUE_XPATH",
6142                         this_policyname,
6143                     )
6144                     if this_policynamespace not in policy_vals:
6145                         policy_vals[this_policynamespace] = {}
6146                     policy_vals[this_policynamespace][
6147                         this_policyname
6148                     ] = this_policy_setting
6149             if (
6150                 ENABLED_LIST_XPATH(admx_policy)
6151                 and this_policy_setting == "Not Configured"
6152             ):
6153                 if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(
6154                     admx_policy
6155                 ):
6156                     element_only_enabled_disabled = False
6157                     explicit_enable_disable_value_setting = True
6158                 if _checkListItem(
6159                     admx_policy,
6160                     this_policyname,
6161                     this_key,
6162                     ENABLED_LIST_XPATH,
6163                     policy_file_data,
6164                 ):
6165                     this_policy_setting = "Enabled"
6166                     log.trace(
6167                         "%s is enabled by detected ENABLED_LIST_XPATH", this_policyname
6168                     )
6169                     if this_policynamespace not in policy_vals:
6170                         policy_vals[this_policynamespace] = {}
6171                     policy_vals[this_policynamespace][
6172                         this_policyname
6173                     ] = this_policy_setting
6174             if (
6175                 DISABLED_LIST_XPATH(admx_policy)
6176                 and this_policy_setting == "Not Configured"
6177             ):
6178                 if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):
6179                     element_only_enabled_disabled = False
6180                     explicit_enable_disable_value_setting = True
6181                 if _checkListItem(
6182                     admx_policy,
6183                     this_policyname,
6184                     this_key,
6185                     DISABLED_LIST_XPATH,
6186                     policy_file_data,
6187                 ):
6188                     this_policy_setting = "Disabled"
6189                     log.trace(
6190                         "%s is disabled by detected DISABLED_LIST_XPATH",
6191                         this_policyname,
6192                     )
6193                     if this_policynamespace not in policy_vals:
6194                         policy_vals[this_policynamespace] = {}
6195                     policy_vals[this_policynamespace][
6196                         this_policyname
6197                     ] = this_policy_setting
6198             if not explicit_enable_disable_value_setting and this_valuename:
6199                 if _regexSearchRegPolData(
6200                     re.escape(
6201                         _buildKnownDataSearchString(
6202                             this_key, this_valuename, "REG_DWORD", "1"
6203                         )
6204                     ),
6205                     policy_file_data,
6206                 ):
6207                     this_policy_setting = "Enabled"
6208                     log.trace(
6209                         "%s is enabled by no explicit enable/disable list or value",
6210                         this_policyname,
6211                     )
6212                     if this_policynamespace not in policy_vals:
6213                         policy_vals[this_policynamespace] = {}
6214                     policy_vals[this_policynamespace][
6215                         this_policyname
6216                     ] = this_policy_setting
6217                 elif _regexSearchRegPolData(
6218                     re.escape(
6219                         _buildKnownDataSearchString(
6220                             this_key,
6221                             this_valuename,
6222                             "REG_DWORD",
6223                             None,
6224                             check_deleted=True,
6225                         )
6226                     ),
6227                     policy_file_data,
6228                 ):
6229                     this_policy_setting = "Disabled"
6230                     log.trace(
6231                         "%s is disabled by no explicit enable/disable list or value",
6232                         this_policyname,
6233                     )
6234                     if this_policynamespace not in policy_vals:
6235                         policy_vals[this_policynamespace] = {}
6236                     policy_vals[this_policynamespace][
6237                         this_policyname
6238                     ] = this_policy_setting
6239             if ELEMENTS_XPATH(admx_policy):
6240                 if element_only_enabled_disabled or this_policy_setting == "Enabled":
6241                     required_elements = {}
6242                     configured_elements = {}
6243                     policy_disabled_elements = 0
6244                     for elements_item in ELEMENTS_XPATH(admx_policy):
6245                         for child_item in elements_item:
6246                             this_element_name = _getFullPolicyName(
6247                                 policy_item=child_item,
6248                                 policy_name=child_item.attrib["id"],
6249                                 return_full_policy_names=return_full_policy_names,
6250                                 adml_language=adml_language,
6251                             )
6252                             required_elements[this_element_name] = None
6253                             child_key = child_item.attrib.get("key", this_key)
6254                             child_valuename = child_item.attrib.get(
6255                                 "valueName", this_valuename
6256                             )
6257                             if etree.QName(child_item).localname == "boolean":
6258                                 if child_item is not None:
6259                                     if (
6260                                         TRUE_VALUE_XPATH(child_item)
6261                                         and this_element_name not in configured_elements
6262                                     ):
6263                                         if _checkValueItemParent(
6264                                             child_item,
6265                                             this_policyname,
6266                                             child_key,
6267                                             child_valuename,
6268                                             TRUE_VALUE_XPATH,
6269                                             policy_file_data,
6270                                         ):
6271                                             configured_elements[
6272                                                 this_element_name
6273                                             ] = True
6274                                             log.trace(
6275                                                 "element %s is configured true",
6276                                                 child_item.attrib["id"],
6277                                             )
6278                                     if (
6279                                         FALSE_VALUE_XPATH(child_item)
6280                                         and this_element_name not in configured_elements
6281                                     ):
6282                                         if _checkValueItemParent(
6283                                             child_item,
6284                                             this_policyname,
6285                                             child_key,
6286                                             child_valuename,
6287                                             FALSE_VALUE_XPATH,
6288                                             policy_file_data,
6289                                         ):
6290                                             configured_elements[
6291                                                 this_element_name
6292                                             ] = False
6293                                             policy_disabled_elements = (
6294                                                 policy_disabled_elements + 1
6295                                             )
6296                                             log.trace(
6297                                                 "element %s is configured false",
6298                                                 child_item.attrib["id"],
6299                                             )
6300                                     if (
6301                                         TRUE_LIST_XPATH(child_item)
6302                                         and this_element_name not in configured_elements
6303                                     ):
6304                                         log.trace("checking trueList")
6305                                         if _checkListItem(
6306                                             child_item,
6307                                             this_policyname,
6308                                             this_key,
6309                                             TRUE_LIST_XPATH,
6310                                             policy_file_data,
6311                                         ):
6312                                             configured_elements[
6313                                                 this_element_name
6314                                             ] = True
6315                                             log.trace(
6316                                                 "element %s is configured true",
6317                                                 child_item.attrib["id"],
6318                                             )
6319                                     if (
6320                                         FALSE_LIST_XPATH(child_item)
6321                                         and this_element_name not in configured_elements
6322                                     ):
6323                                         log.trace("checking falseList")
6324                                         if _checkListItem(
6325                                             child_item,
6326                                             this_policyname,
6327                                             this_key,
6328                                             FALSE_LIST_XPATH,
6329                                             policy_file_data,
6330                                         ):
6331                                             configured_elements[
6332                                                 this_element_name
6333                                             ] = False
6334                                             policy_disabled_elements = (
6335                                                 policy_disabled_elements + 1
6336                                             )
6337                                             log.trace(
6338                                                 "element %s is configured false",
6339                                                 child_item.attrib["id"],
6340                                             )
6341                                 else:
6342                                     if _regexSearchRegPolData(
6343                                         re.escape(
6344                                             _processValueItem(
6345                                                 child_item,
6346                                                 child_key,
6347                                                 child_valuename,
6348                                                 admx_policy,
6349                                                 elements_item,
6350                                                 check_deleted=True,
6351                                             )
6352                                         ),
6353                                         policy_file_data,
6354                                     ):
6355                                         configured_elements[this_element_name] = False
6356                                         policy_disabled_elements = (
6357                                             policy_disabled_elements + 1
6358                                         )
6359                                         log.trace(
6360                                             "element %s is configured false",
6361                                             child_item.attrib["id"],
6362                                         )
6363                                     elif _regexSearchRegPolData(
6364                                         re.escape(
6365                                             _processValueItem(
6366                                                 child_item,
6367                                                 child_key,
6368                                                 child_valuename,
6369                                                 admx_policy,
6370                                                 elements_item,
6371                                                 check_deleted=False,
6372                                             )
6373                                         ),
6374                                         policy_file_data,
6375                                     ):
6376                                         configured_elements[this_element_name] = True
6377                                         log.trace(
6378                                             "element %s is configured true",
6379                                             child_item.attrib["id"],
6380                                         )
6381                             elif (
6382                                 etree.QName(child_item).localname == "decimal"
6383                                 or etree.QName(child_item).localname == "text"
6384                                 or etree.QName(child_item).localname == "longDecimal"
6385                                 or etree.QName(child_item).localname == "multiText"
6386                             ):
6387                                 if _regexSearchRegPolData(
6388                                     re.escape(
6389                                         _processValueItem(
6390                                             child_item,
6391                                             child_key,
6392                                             child_valuename,
6393                                             admx_policy,
6394                                             elements_item,
6395                                             check_deleted=True,
6396                                         )
6397                                     ),
6398                                     policy_file_data,
6399                                 ):
6400                                     configured_elements[this_element_name] = "Disabled"
6401                                     policy_disabled_elements = (
6402                                         policy_disabled_elements + 1
6403                                     )
6404                                     log.trace(
6405                                         "element %s is disabled",
6406                                         child_item.attrib["id"],
6407                                     )
6408                                 elif _regexSearchRegPolData(
6409                                     re.escape(
6410                                         _processValueItem(
6411                                             child_item,
6412                                             child_key,
6413                                             child_valuename,
6414                                             admx_policy,
6415                                             elements_item,
6416                                             check_deleted=False,
6417                                         )
6418                                     ),
6419                                     policy_file_data,
6420                                 ):
6421                                     configured_value = _getDataFromRegPolData(
6422                                         _processValueItem(
6423                                             child_item,
6424                                             child_key,
6425                                             child_valuename,
6426                                             admx_policy,
6427                                             elements_item,
6428                                             check_deleted=False,
6429                                         ),
6430                                         policy_file_data,
6431                                     )
6432                                     configured_elements[
6433                                         this_element_name
6434                                     ] = configured_value
6435                                     log.trace(
6436                                         "element %s is enabled, value == %s",
6437                                         child_item.attrib["id"],
6438                                         configured_value,
6439                                     )
6440                             elif etree.QName(child_item).localname == "enum":
6441                                 if _regexSearchRegPolData(
6442                                     re.escape(
6443                                         _processValueItem(
6444                                             child_item,
6445                                             child_key,
6446                                             child_valuename,
6447                                             admx_policy,
6448                                             elements_item,
6449                                             check_deleted=True,
6450                                         )
6451                                     ),
6452                                     policy_file_data,
6453                                 ):
6454                                     log.trace(
6455                                         "enum element %s is disabled",
6456                                         child_item.attrib["id"],
6457                                     )
6458                                     configured_elements[this_element_name] = "Disabled"
6459                                     policy_disabled_elements = (
6460                                         policy_disabled_elements + 1
6461                                     )
6462                                 else:
6463                                     for enum_item in child_item:
6464                                         if _checkValueItemParent(
6465                                             enum_item,
6466                                             child_item.attrib["id"],
6467                                             child_key,
6468                                             child_valuename,
6469                                             VALUE_XPATH,
6470                                             policy_file_data,
6471                                         ):
6472                                             if VALUE_LIST_XPATH(enum_item):
6473                                                 log.trace("enum item has a valueList")
6474                                                 if _checkListItem(
6475                                                     enum_item,
6476                                                     this_policyname,
6477                                                     child_key,
6478                                                     VALUE_LIST_XPATH,
6479                                                     policy_file_data,
6480                                                 ):
6481                                                     log.trace(
6482                                                         "all valueList items exist in"
6483                                                         " file"
6484                                                     )
6485                                                     configured_elements[
6486                                                         this_element_name
6487                                                     ] = _getAdmlDisplayName(
6488                                                         adml_policy_resources,
6489                                                         enum_item.attrib["displayName"],
6490                                                     )
6491                                                     break
6492                                             else:
6493                                                 configured_elements[
6494                                                     this_element_name
6495                                                 ] = _getAdmlDisplayName(
6496                                                     adml_policy_resources,
6497                                                     enum_item.attrib["displayName"],
6498                                                 )
6499                                                 break
6500                             elif etree.QName(child_item).localname == "list":
6501                                 return_value_name = False
6502                                 if (
6503                                     "explicitValue" in child_item.attrib
6504                                     and child_item.attrib["explicitValue"].lower()
6505                                     == "true"
6506                                 ):
6507                                     log.trace(
6508                                         "explicitValue list, we will return value names"
6509                                     )
6510                                     return_value_name = True
6511                                 regex_str = [
6512                                     r"(?!\*",
6513                                     r"\*",
6514                                     "D",
6515                                     "e",
6516                                     "l",
6517                                     "V",
6518                                     "a",
6519                                     "l",
6520                                     "s",
6521                                     r"\.",
6522                                     ")",
6523                                 ]
6524                                 delvals_regex = "\x00".join(regex_str)
6525                                 delvals_regex = salt.utils.stringutils.to_bytes(
6526                                     delvals_regex
6527                                 )
6528                                 if _regexSearchRegPolData(
6529                                     re.escape(
6530                                         _processValueItem(
6531                                             child_item,
6532                                             child_key,
6533                                             child_valuename,
6534                                             admx_policy,
6535                                             elements_item,
6536                                             check_deleted=False,
6537                                         )
6538                                     )
6539                                     + delvals_regex,
6540                                     policy_file_data,
6541                                 ):
6542                                     configured_value = _getDataFromRegPolData(
6543                                         _processValueItem(
6544                                             child_item,
6545                                             child_key,
6546                                             child_valuename,
6547                                             admx_policy,
6548                                             elements_item,
6549                                             check_deleted=False,
6550                                         ),
6551                                         policy_file_data,
6552                                         return_value_name=return_value_name,
6553                                     )
6554                                     configured_elements[
6555                                         this_element_name
6556                                     ] = configured_value
6557                                     log.trace(
6558                                         "element %s is enabled values: %s",
6559                                         child_item.attrib["id"],
6560                                         configured_value,
6561                                     )
6562                                 elif _regexSearchRegPolData(
6563                                     re.escape(
6564                                         _processValueItem(
6565                                             child_item,
6566                                             child_key,
6567                                             child_valuename,
6568                                             admx_policy,
6569                                             elements_item,
6570                                             check_deleted=True,
6571                                         )
6572                                     ),
6573                                     policy_file_data,
6574                                 ):
6575                                     configured_elements[this_element_name] = "Disabled"
6576                                     policy_disabled_elements = (
6577                                         policy_disabled_elements + 1
6578                                     )
6579                                     log.trace(
6580                                         "element %s is disabled",
6581                                         child_item.attrib["id"],
6582                                     )
6583                     if element_only_enabled_disabled:
6584                         if len(required_elements.keys()) &gt; 0 and len(
6585                             configured_elements.keys()
6586                         ) == len(required_elements.keys()):
6587                             if policy_disabled_elements == len(
6588                                 required_elements.keys()
6589                             ):
6590                                 log.trace(
6591                                     "%s is disabled by all enum elements",
6592                                     this_policyname,
6593                                 )
6594                                 if this_policynamespace not in policy_vals:
6595                                     policy_vals[this_policynamespace] = {}
6596                                 policy_vals[this_policynamespace][
6597                                     this_policyname
6598                                 ] = "Disabled"
6599                             else:
6600                                 if this_policynamespace not in policy_vals:
6601                                     policy_vals[this_policynamespace] = {}
6602                                 policy_vals[this_policynamespace][
6603                                     this_policyname
6604                                 ] = configured_elements
6605                                 log.trace(
6606                                     "%s is enabled by enum elements", this_policyname
6607                                 )
6608                     else:
6609                         if this_policy_setting == "Enabled":
6610                             if this_policynamespace not in policy_vals:
6611                                 policy_vals[this_policynamespace] = {}
6612                             policy_vals[this_policynamespace][
6613                                 this_policyname
6614                             ] = configured_elements
6615             if (
6616                 return_full_policy_names
6617                 and this_policynamespace in policy_vals
6618                 and this_policyname in policy_vals[this_policynamespace]
6619             ):
6620                 if this_policynamespace not in full_names:
6621                     full_names[this_policynamespace] = {}
6622                 full_names[this_policynamespace][this_policyname] = _getFullPolicyName(
6623                     policy_item=admx_policy,
6624                     policy_name=admx_policy.attrib["name"],
6625                     return_full_policy_names=return_full_policy_names,
6626                     adml_language=adml_language,
6627                 )
6628                 if (
6629                     this_policyname
6630                     in policy_vals[this_policynamespace][this_policyname]
6631                 ):
6632                     full_name = full_names[this_policynamespace][this_policyname]
6633                     setting = policy_vals[this_policynamespace][this_policyname].pop(
6634                         this_policyname
6635                     )
6636                     policy_vals[this_policynamespace][this_policyname][
6637                         full_name
6638                     ] = setting
6639             if (
6640                 this_policynamespace in policy_vals
6641                 and this_policyname in policy_vals[this_policynamespace]
6642             ):
6643                 if this_policynamespace not in hierarchy:
6644                     hierarchy[this_policynamespace] = {}
6645                 hierarchy[this_policynamespace][this_policyname] = _build_parent_list(
6646                     policy_definition=admx_policy,
6647                     return_full_policy_names=return_full_policy_names,
6648                     adml_language=adml_language,
6649                 )
6650         log.trace("Examination complete: %s seconds", time.time() - start_time)
6651     if policy_vals and return_full_policy_names and not hierarchical_return:
6652         log.debug("Compiling non hierarchical return...")
6653         start_time = time.time()
6654         unpathed_dict = {}
6655         pathed_dict = {}
6656         for policy_namespace in list(policy_vals):
6657             for policy_item in list(policy_vals[policy_namespace]):
6658                 if (
6659                     full_names[policy_namespace][policy_item]
6660                     in policy_vals[policy_namespace]
6661                 ):
6662                     full_path_list = hierarchy[policy_namespace][policy_item]
6663                     full_path_list.reverse()
6664                     full_path_list.append(full_names[policy_namespace][policy_item])
6665                     policy_vals["\\".join(full_path_list)] = policy_vals[
6666                         policy_namespace
6667                     ].pop(policy_item)
6668                     pathed_dict[full_names[policy_namespace][policy_item]] = True
6669                 else:
6670                     policy_vals[policy_namespace][
6671                         full_names[policy_namespace][policy_item]
6672                     ] = policy_vals[policy_namespace].pop(policy_item)
6673                     if policy_namespace not in unpathed_dict:
6674                         unpathed_dict[policy_namespace] = {}
6675                     unpathed_dict[policy_namespace][
6676                         full_names[policy_namespace][policy_item]
6677                     ] = policy_item
6678             if policy_namespace in unpathed_dict:
6679                 for path_needed in unpathed_dict[policy_namespace]:
6680                     full_path_list = hierarchy[policy_namespace][
6681                         unpathed_dict[policy_namespace][path_needed]
6682                     ]
6683                     full_path_list.reverse()
6684                     full_path_list.append(path_needed)
6685                     log.trace("full_path_list == %s", full_path_list)
6686                     policy_vals["\\".join(full_path_list)] = policy_vals[
6687                         policy_namespace
6688                     ].pop(path_needed)
6689         log.trace("Compilation complete: %s seconds", time.time() - start_time)
6690     for policy_namespace in list(policy_vals):
6691         if policy_vals[policy_namespace] == {}:
6692             policy_vals.pop(policy_namespace)
6693     if policy_vals and hierarchical_return:
6694         if hierarchy:
6695             log.debug("Compiling hierarchical return...")
6696             start_time = time.time()
6697             for policy_namespace in hierarchy:
6698                 for hierarchy_item in hierarchy[policy_namespace]:
6699                     if hierarchy_item in policy_vals[policy_namespace]:
6700                         tdict = {}
6701                         first_item = True
6702                         for item in hierarchy[policy_namespace][hierarchy_item]:
6703                             newdict = {}
6704                             if first_item:
6705                                 h_policy_name = hierarchy_item
6706                                 if return_full_policy_names:
6707                                     h_policy_name = full_names[policy_namespace][
6708                                         hierarchy_item
6709                                     ]
6710                                 newdict[item] = {
6711                                     h_policy_name: policy_vals[policy_namespace].pop(
6712                                         hierarchy_item
6713                                     )
6714                                 }
6715                                 first_item = False
6716                             else:
6717                                 newdict[item] = tdict
6718                             tdict = newdict
6719                         if tdict:
6720                             policy_vals = dictupdate.update(policy_vals, tdict)
6721                 if (
6722                     policy_namespace in policy_vals
6723                     and policy_vals[policy_namespace] == {}
6724                 ):
6725                     policy_vals.pop(policy_namespace)
6726             log.trace("Compilation complete: %s seconds", time.time() - start_time)
6727         policy_vals = {
6728             module_policy_data.admx_registry_classes[policy_class]["lgpo_section"]: {
6729                 "Administrative Templates": policy_vals
6730             }
6731         }
6732     return policy_vals
6733 def _build_parent_list(policy_definition, return_full_policy_names, adml_language):
6734     """
6735     helper function to build a list containing parent elements of the ADMX
6736     policy
6737     """
6738     parent_list = []
6739     policy_namespace = next(iter(policy_definition.nsmap))
6740     parent_category = policy_definition.xpath(
6741         "{}:parentCategory/@ref".format(policy_namespace),
6742         namespaces=policy_definition.nsmap,
6743     )
6744     admx_policy_definitions = _get_policy_definitions(language=adml_language)
6745     if parent_category:
6746         parent_category = parent_category[0]
6747         nsmap_xpath = "/policyDefinitions/policyNamespaces/{}:*".format(
6748             policy_namespace
6749         )
6750         this_namespace_map = _buildElementNsmap(
6751             admx_policy_definitions.xpath(
6752                 nsmap_xpath, namespaces=policy_definition.nsmap
6753             )
6754         )
6755         this_namespace_map = dictupdate.update(
6756             this_namespace_map, policy_definition.nsmap
6757         )
6758         parent_list = _admx_policy_parent_walk(
6759             path=parent_list,
6760             policy_namespace=policy_namespace,
6761             parent_category=parent_category,
6762             policy_nsmap=this_namespace_map,
6763             return_full_policy_names=return_full_policy_names,
6764             adml_language=adml_language,
6765         )
6766     return parent_list
6767 def _admx_policy_parent_walk(
6768     path,
6769     policy_namespace,
6770     parent_category,
6771     policy_nsmap,
6772     return_full_policy_names,
6773     adml_language,
6774 ):
6775     """
6776     helper function to recursively walk up the ADMX namespaces and build the
6777     hierarchy for the policy
6778     """
6779     admx_policy_definitions = _get_policy_definitions(language=adml_language)
6780     category_xpath_string = '/policyDefinitions/categories/{}:category[@name="{}"]'
6781     using_xpath_string = "/policyDefinitions/policyNamespaces/{}:using"
6782     if parent_category.find(":") &gt;= 0:
6783         policy_namespace = parent_category.split(":")[0]
6784         parent_category = parent_category.split(":")[1]
6785         using_xpath_string = using_xpath_string.format(policy_namespace)
6786         policy_nsmap = dictupdate.update(
6787             policy_nsmap,
6788             _buildElementNsmap(
6789                 admx_policy_definitions.xpath(
6790                     using_xpath_string, namespaces=policy_nsmap
6791                 )
6792             ),
6793         )
6794     category_xpath_string = category_xpath_string.format(
6795         policy_namespace, parent_category
6796     )
6797     if admx_policy_definitions.xpath(category_xpath_string, namespaces=policy_nsmap):
6798         tparent_category = admx_policy_definitions.xpath(
6799             category_xpath_string, namespaces=policy_nsmap
6800         )[0]
6801         this_parent_name = _getFullPolicyName(
6802             policy_item=tparent_category,
6803             policy_name=tparent_category.attrib["name"],
6804             return_full_policy_names=return_full_policy_names,
6805             adml_language=adml_language,
6806         )
6807         path.append(this_parent_name)
6808         if tparent_category.xpath(
6809             "{}:parentCategory/@ref".format(policy_namespace), namespaces=policy_nsmap
6810         ):
6811             path = _admx_policy_parent_walk(
6812                 path=path,
6813                 policy_namespace=policy_namespace,
6814                 parent_category=tparent_category.xpath(
6815                     "{}:parentCategory/@ref".format(policy_namespace),
6816                     namespaces=policy_nsmap,
6817                 )[0],
6818                 policy_nsmap=policy_nsmap,
6819                 return_full_policy_names=return_full_policy_names,
6820                 adml_language=adml_language,
6821             )
6822     return path
6823 def _read_regpol_file(reg_pol_path):
6824     """
6825     helper function to read a reg policy file and return decoded data
6826     """
6827     returndata = None
6828     if os.path.exists(reg_pol_path):
6829         with salt.utils.files.fopen(reg_pol_path, "rb") as pol_file:
6830             returndata = pol_file.read()
6831     return returndata
6832 def _regexSearchKeyValueCombo(policy_data, policy_regpath, policy_regkey):
6833     """
6834     helper function to do a search of Policy data from a registry.pol file
6835     for a policy_regpath and policy_regkey combo
6836     """
6837     if policy_data:
6838         regex_str = [
6839             r"(\*",
6840             r"\*",
6841             "D",
6842             "e",
6843             "l",
6844             r"\.",
6845             r"|\*",
6846             r"\*",
6847             "D",
6848             "e",
6849             "l",
6850             "V",
6851             "a",
6852             "l",
6853             "s",
6854             r"\.",
6855             "){0,1}",
6856         ]
6857         specialValueRegex = "\x00".join(regex_str)
6858         specialValueRegex = salt.utils.stringutils.to_bytes(specialValueRegex)
6859         _thisSearch = b"".join(
6860             [
6861                 salt.utils.stringutils.to_bytes(r"\["),
6862                 re.escape(policy_regpath),
6863                 b"\x00;\x00",
6864                 specialValueRegex,
6865                 re.escape(policy_regkey.lstrip(b"\x00")),
6866                 b"\x00;",
6867             ]
6868         )
6869         match = re.search(_thisSearch, policy_data, re.IGNORECASE)
6870         if match:
6871             return policy_data[
6872                 match.start() : (policy_data.index(b"]", match.end())) + 2
6873             ]
6874     return None
6875 def _write_regpol_data(
6876     data_to_write, policy_file_path, gpt_ini_path, gpt_extension, gpt_extension_guid
6877 ):
6878     """
6879     helper function to actually write the data to a Registry.pol file
6880     also updates/edits the gpt.ini file to include the ADM policy extensions
6881     to let the computer know user and/or machine registry policy files need
6882     to be processed
6883     data_to_write: data to write into the user/machine registry.pol file
6884     policy_file_path: path to the registry.pol file
6885     gpt_ini_path: path to gpt.ini file
6886     gpt_extension: gpt extension list name from _policy_info class for this registry class gpt_extension_location
6887     gpt_extension_guid: admx registry extension guid for the class
6888     """
6889     if not os.path.exists(policy_file_path):
6890         __salt__["file.makedirs"](policy_file_path)
6891     try:
6892         with salt.utils.files.fopen(policy_file_path, "wb") as pol_file:
6893             reg_pol_header = "\u5250\u6765\x01\x00".encode("utf-16-le")
6894             if not data_to_write.startswith(reg_pol_header):
6895                 pol_file.write(reg_pol_header)
6896             pol_file.write(data_to_write)
6897     except Exception as e:  # pylint: disable=broad-except
6898         msg = (
6899             "An error occurred attempting to write to {}, the exception was: {}".format(
6900                 policy_file_path, e
6901             )
6902         )
6903         log.exception(msg)
6904         raise CommandExecutionError(msg)
6905     gpt_ini_data = ""
6906     if os.path.exists(gpt_ini_path):
6907         with salt.utils.files.fopen(gpt_ini_path, "r") as gpt_file:
6908             gpt_ini_data = gpt_file.read()
6909         gpt_ini_data = (
6910             gpt_ini_data.replace("\r\n", "_|-")
6911             .replace("\n", "_|-")
6912             .replace("_|-", "\r\n")
6913         )
6914     if not _regexSearchRegPolData(r"\[General\]\r\n", gpt_ini_data):
6915         gpt_ini_data = "[General]\r\n" + gpt_ini_data
6916     if _regexSearchRegPolData(r"{}=".format(re.escape(gpt_extension)), gpt_ini_data):
6917         gpt_ext_loc = re.search(
6918             r"^{}=.*\r\n".format(re.escape(gpt_extension)),
6919             gpt_ini_data,
6920             re.IGNORECASE | re.MULTILINE,
6921         )
6922         gpt_ext_str = gpt_ini_data[gpt_ext_loc.start() : gpt_ext_loc.end()]
6923         if not _regexSearchRegPolData(
6924             r"{}".format(re.escape(gpt_extension_guid)), gpt_ext_str
6925         ):
6926             gpt_ext_str = gpt_ext_str.split("=")
6927             gpt_ext_str[1] = gpt_extension_guid + gpt_ext_str[1]
6928             gpt_ext_str = "=".join(gpt_ext_str)
6929             gpt_ini_data = (
6930                 gpt_ini_data[0 : gpt_ext_loc.start()]
6931                 + gpt_ext_str
6932                 + gpt_ini_data[gpt_ext_loc.end() :]
6933             )
6934     else:
6935         general_location = re.search(
6936             r"^\[General\]\r\n", gpt_ini_data, re.IGNORECASE | re.MULTILINE
6937         )
6938         gpt_ini_data = "{}{}={}\r\n{}".format(
6939             gpt_ini_data[general_location.start() : general_location.end()],
6940             gpt_extension,
6941             gpt_extension_guid,
6942             gpt_ini_data[general_location.end() :],
6943         )
6944     if _regexSearchRegPolData(r"Version=", gpt_ini_data):
6945         version_loc = re.search(
6946             r"^Version=.*\r\n", gpt_ini_data, re.IGNORECASE | re.MULTILINE
6947         )
6948         version_str = gpt_ini_data[version_loc.start() : version_loc.end()]
6949         version_str = version_str.split("=")
6950         version_nums = struct.unpack(b"&gt;2H", struct.pack(b"&gt;I", int(version_str[1])))
6951         if gpt_extension.lower() == "gPCMachineExtensionNames".lower():
6952             version_nums = (version_nums[0], version_nums[1] + 1)
6953         elif gpt_extension.lower() == "gPCUserExtensionNames".lower():
6954             version_nums = (version_nums[0] + 1, version_nums[1])
6955         version_num = struct.unpack(b"&gt;I", struct.pack(b"&gt;2H", *version_nums))[0]
6956         gpt_ini_data = "{}{}={}\r\n{}".format(
6957             gpt_ini_data[0 : version_loc.start()],
6958             "Version",
6959             version_num,
6960             gpt_ini_data[version_loc.end() :],
6961         )
6962     else:
6963         general_location = re.search(
6964             r"^\[General\]\r\n", gpt_ini_data, re.IGNORECASE | re.MULTILINE
6965         )
6966         if gpt_extension.lower() == "gPCMachineExtensionNames".lower():
6967             version_nums = (0, 1)
6968         elif gpt_extension.lower() == "gPCUserExtensionNames".lower():
6969             version_nums = (1, 0)
6970         gpt_ini_data = "{}{}={}\r\n{}".format(
6971             gpt_ini_data[general_location.start() : general_location.end()],
6972             "Version",
6973             int(
6974                 "{}{}".format(
6975                     str(version_nums[0]).zfill(4),
6976                     str(version_nums[1]).zfill(4),
6977                 ),
6978                 16,
6979             ),
6980             gpt_ini_data[general_location.end() :],
6981         )
6982     if gpt_ini_data:
6983         try:
6984             with salt.utils.files.fopen(gpt_ini_path, "w") as gpt_file:
6985                 gpt_file.write(gpt_ini_data)
6986         except Exception as e:  # pylint: disable=broad-except
6987             msg = (
6988                 "An error occurred attempting to write the gpg.ini file.\n"
6989                 "path: {}\n"
6990                 "exception: {}".format(gpt_ini_path, e)
6991             )
6992             log.exception(msg)
6993             raise CommandExecutionError(msg)
6994 def _policyFileReplaceOrAppendList(string_list, policy_data):
6995     """
6996     helper function to take a list of strings for registry.pol file data and
6997     update existing strings or append the strings
6998     """
6999     if not policy_data:
7000         policy_data = b""
7001     specialValueRegex = salt.utils.stringutils.to_bytes(
7002         r"(\*\*Del\.|\*\*DelVals\.){0,1}"
7003     )
7004     for this_string in string_list:
7005         list_item_key = this_string.split(b"\00;")[0].lstrip(b"[")
7006         list_item_value_name = re.sub(
7007             specialValueRegex, b"", this_string.split(b"\00;")[1], flags=re.IGNORECASE
7008         )
7009         log.trace("item value name is %s", list_item_value_name)
7010         data_to_replace = _regexSearchKeyValueCombo(
7011             policy_data, list_item_key, list_item_value_name
7012         )
7013         if data_to_replace:
7014             log.trace("replacing %s with %s", data_to_replace, this_string)
7015             policy_data = policy_data.replace(data_to_replace, this_string)
7016         else:
7017             log.trace("appending %s", this_string)
7018             policy_data = b"".join([policy_data, this_string])
7019     return policy_data
7020 def _policyFileReplaceOrAppend(this_string, policy_data, append_only=False):
7021     """
7022     helper function to take a ADMX policy string for registry.pol file data and
7023     update existing string or append the string to the data
7024     """
7025     if not policy_data:
7026         policy_data = b""
7027     specialValueRegex = salt.utils.stringutils.to_bytes(
7028         r"(\*\*Del\.|\*\*DelVals\.){0,1}"
7029     )
7030     item_key = None
7031     item_value_name = None
7032     data_to_replace = None
7033     if not append_only:
7034         item_key = this_string.split(b"\00;")[0].lstrip(b"[")
7035         item_value_name = re.sub(
7036             specialValueRegex, b"", this_string.split(b"\00;")[1], flags=re.IGNORECASE
7037         )
7038         log.trace("item value name is %s", item_value_name)
7039         data_to_replace = _regexSearchKeyValueCombo(
7040             policy_data, item_key, item_value_name
7041         )
7042     if data_to_replace:
7043         log.trace("replacing %s with %s", data_to_replace, this_string)
7044         policy_data = policy_data.replace(data_to_replace, this_string)
7045     else:
7046         log.trace("appending %s", this_string)
7047         policy_data = b"".join([policy_data, this_string])
7048     return policy_data
7049 def _writeAdminTemplateRegPolFile(
7050     admtemplate_data, adml_language="en-US", registry_class="Machine"
7051 ):
7052     r"""
7053     helper function to prep/write adm template data to the Registry.pol file
7054     each file begins with REGFILE_SIGNATURE (u'\u5250\u6765') and
7055     REGISTRY_FILE_VERSION (u'\x01\00')
7056     https://msdn.microsoft.com/en-us/library/aa374407(VS.85).aspx
7057     +    https://msdn.microsoft.com/en-us/library/cc232696.aspx
7058     [Registry Path&lt;NULL&gt;;Reg Value&lt;NULL&gt;;Reg Type;SizeInBytes;Data&lt;NULL&gt;]
7059     """
7060     existing_data = b""
7061     policy_data = _policy_info()
7062     policySearchXpath = '//ns1:*[@id = "{0}" or @name = "{0}"]'
7063     admx_policy_definitions = _get_policy_definitions(language=adml_language)
7064     adml_policy_resources = _get_policy_resources(language=adml_language)
7065     base_policy_settings = _checkAllAdmxPolicies(
7066         policy_class=registry_class,
7067         adml_language=adml_language,
7068         return_full_policy_names=False,
7069         hierarchical_return=False,
7070         return_not_configured=False,
7071     )
7072     for adm_namespace in admtemplate_data:
7073         for adm_policy in admtemplate_data[adm_namespace]:
7074             if (
7075                 str(admtemplate_data[adm_namespace][adm_policy]).lower()
7076                 == "not configured"
7077             ):
7078                 if (
7079                     base_policy_settings.get(adm_namespace, {}).pop(adm_policy, None)
7080                     is not None
7081                 ):
7082                     log.trace('Policy "%s" removed', adm_policy)
7083             else:
7084                 log.trace("adding %s to base_policy_settings", adm_policy)
7085                 if adm_namespace not in base_policy_settings:
7086                     base_policy_settings[adm_namespace] = {}
7087                 base_policy_settings[adm_namespace][adm_policy] = admtemplate_data[
7088                     adm_namespace
7089                 ][adm_policy]
7090     for adm_namespace in base_policy_settings:
7091         for admPolicy in base_policy_settings[adm_namespace]:
7092             log.trace("working on admPolicy %s", admPolicy)
7093             explicit_enable_disable_value_setting = False
7094             this_key = None
7095             this_valuename = None
7096             if (
7097                 str(base_policy_settings[adm_namespace][admPolicy]).lower()
7098                 == "disabled"
7099             ):
7100                 log.trace("time to disable %s", admPolicy)
7101                 this_policy = admx_policy_definitions.xpath(
7102                     policySearchXpath.format(admPolicy),
7103                     namespaces={"ns1": adm_namespace},
7104                 )
7105                 if this_policy:
7106                     this_policy = this_policy[0]
7107                     if "class" in this_policy.attrib:
7108                         if (
7109                             this_policy.attrib["class"] == registry_class
7110                             or this_policy.attrib["class"] == "Both"
7111                         ):
7112                             if "key" in this_policy.attrib:
7113                                 this_key = this_policy.attrib["key"]
7114                             else:
7115                                 log.error(
7116                                     "policy item %s does not have "
7117                                     'the required "key" attribute',
7118                                     this_policy.attrib,
7119                                 )
7120                                 break
7121                             if "valueName" in this_policy.attrib:
7122                                 this_valuename = this_policy.attrib["valueName"]
7123                             if DISABLED_VALUE_XPATH(this_policy):
7124                                 explicit_enable_disable_value_setting = True
7125                                 disabled_value_string = _checkValueItemParent(
7126                                     this_policy,
7127                                     admPolicy,
7128                                     this_key,
7129                                     this_valuename,
7130                                     DISABLED_VALUE_XPATH,
7131                                     None,
7132                                     check_deleted=False,
7133                                     test_item=False,
7134                                 )
7135                                 existing_data = _policyFileReplaceOrAppend(
7136                                     disabled_value_string, existing_data
7137                                 )
7138                             if DISABLED_LIST_XPATH(this_policy):
7139                                 explicit_enable_disable_value_setting = True
7140                                 disabled_list_strings = _checkListItem(
7141                                     this_policy,
7142                                     admPolicy,
7143                                     this_key,
7144                                     DISABLED_LIST_XPATH,
7145                                     None,
7146                                     test_items=False,
7147                                 )
7148                                 log.trace(
7149                                     "working with disabledList portion of %s",
7150                                     admPolicy,
7151                                 )
7152                                 existing_data = _policyFileReplaceOrAppendList(
7153                                     disabled_list_strings, existing_data
7154                                 )
7155                             if (
7156                                 not explicit_enable_disable_value_setting
7157                                 and this_valuename
7158                             ):
7159                                 disabled_value_string = _buildKnownDataSearchString(
7160                                     this_key,
7161                                     this_valuename,
7162                                     "REG_DWORD",
7163                                     None,
7164                                     check_deleted=True,
7165                                 )
7166                                 existing_data = _policyFileReplaceOrAppend(
7167                                     disabled_value_string, existing_data
7168                                 )
7169                             if ELEMENTS_XPATH(this_policy):
7170                                 log.trace("checking elements of %s", admPolicy)
7171                                 for elements_item in ELEMENTS_XPATH(this_policy):
7172                                     for child_item in elements_item:
7173                                         child_key = this_key
7174                                         child_valuename = this_valuename
7175                                         if "key" in child_item.attrib:
7176                                             child_key = child_item.attrib["key"]
7177                                         if "valueName" in child_item.attrib:
7178                                             child_valuename = child_item.attrib[
7179                                                 "valueName"
7180                                             ]
7181                                         if etree.QName(
7182                                             child_item
7183                                         ).localname == "boolean" and (
7184                                             TRUE_LIST_XPATH(child_item)
7185                                             or FALSE_LIST_XPATH(child_item)
7186                                         ):
7187                                             temp_dict = {
7188                                                 "trueList": TRUE_LIST_XPATH,
7189                                                 "falseList": FALSE_LIST_XPATH,
7190                                             }
7191                                             for this_list in temp_dict:
7192                                                 disabled_list_strings = _checkListItem(
7193                                                     child_item,
7194                                                     admPolicy,
7195                                                     child_key,
7196                                                     temp_dict[this_list],
7197                                                     None,
7198                                                     test_items=False,
7199                                                 )
7200                                                 log.trace(
7201                                                     "working with %s portion of %s",
7202                                                     admPolicy,
7203                                                     this_list,
7204                                                 )
7205                                                 existing_data = (
7206                                                     _policyFileReplaceOrAppendList(
7207                                                         disabled_list_strings,
7208                                                         existing_data,
7209                                                     )
7210                                                 )
7211                                         elif (
7212                                             etree.QName(child_item).localname
7213                                             == "boolean"
7214                                             or etree.QName(child_item).localname
7215                                             == "decimal"
7216                                             or etree.QName(child_item).localname
7217                                             == "text"
7218                                             or etree.QName(child_item).localname
7219                                             == "longDecimal"
7220                                             or etree.QName(child_item).localname
7221                                             == "multiText"
7222                                             or etree.QName(child_item).localname
7223                                             == "enum"
7224                                         ):
7225                                             disabled_value_string = _processValueItem(
7226                                                 child_item,
7227                                                 child_key,
7228                                                 child_valuename,
7229                                                 this_policy,
7230                                                 elements_item,
7231                                                 check_deleted=True,
7232                                             )
7233                                             log.trace(
7234                                                 "I have disabled value string of %s",
7235                                                 disabled_value_string,
7236                                             )
7237                                             existing_data = _policyFileReplaceOrAppend(
7238                                                 disabled_value_string, existing_data
7239                                             )
7240                                         elif (
7241                                             etree.QName(child_item).localname == "list"
7242                                         ):
7243                                             disabled_value_string = _processValueItem(
7244                                                 child_item,
7245                                                 child_key,
7246                                                 child_valuename,
7247                                                 this_policy,
7248                                                 elements_item,
7249                                                 check_deleted=True,
7250                                             )
7251                                             log.trace(
7252                                                 "I have disabled value string of %s",
7253                                                 disabled_value_string,
7254                                             )
7255                                             existing_data = _policyFileReplaceOrAppend(
7256                                                 disabled_value_string, existing_data
7257                                             )
7258                         else:
7259                             log.error(
7260                                 "policy %s was found but it does not appear to be valid"
7261                                 " for the class %s",
7262                                 admPolicy,
7263                                 registry_class,
7264                             )
7265                     else:
7266                         log.error(
7267                             'policy item %s does not have the required "class"'
7268                             " attribute",
7269                             this_policy.attrib,
7270                         )
7271             else:
7272                 log.trace('time to enable and set the policy "%s"', admPolicy)
7273                 this_policy = admx_policy_definitions.xpath(
7274                     policySearchXpath.format(admPolicy),
7275                     namespaces={"ns1": adm_namespace},
7276                 )
7277                 log.trace("found this_policy == %s", this_policy)
7278                 if this_policy:
7279                     this_policy = this_policy[0]
7280                     if "class" in this_policy.attrib:
7281                         if (
7282                             this_policy.attrib["class"] == registry_class
7283                             or this_policy.attrib["class"] == "Both"
7284                         ):
7285                             if "key" in this_policy.attrib:
7286                                 this_key = this_policy.attrib["key"]
7287                             else:
7288                                 log.error(
7289                                     'policy item %s does not have the required "key"'
7290                                     " attribute",
7291                                     this_policy.attrib,
7292                                 )
7293                                 break
7294                             if "valueName" in this_policy.attrib:
7295                                 this_valuename = this_policy.attrib["valueName"]
7296                             if ENABLED_VALUE_XPATH(this_policy):
7297                                 explicit_enable_disable_value_setting = True
7298                                 enabled_value_string = _checkValueItemParent(
7299                                     this_policy,
7300                                     admPolicy,
7301                                     this_key,
7302                                     this_valuename,
7303                                     ENABLED_VALUE_XPATH,
7304                                     None,
7305                                     check_deleted=False,
7306                                     test_item=False,
7307                                 )
7308                                 existing_data = _policyFileReplaceOrAppend(
7309                                     enabled_value_string, existing_data
7310                                 )
7311                             if ENABLED_LIST_XPATH(this_policy):
7312                                 explicit_enable_disable_value_setting = True
7313                                 enabled_list_strings = _checkListItem(
7314                                     this_policy,
7315                                     admPolicy,
7316                                     this_key,
7317                                     ENABLED_LIST_XPATH,
7318                                     None,
7319                                     test_items=False,
7320                                 )
7321                                 log.trace(
7322                                     "working with enabledList portion of %s", admPolicy
7323                                 )
7324                                 existing_data = _policyFileReplaceOrAppendList(
7325                                     enabled_list_strings, existing_data
7326                                 )
7327                             if (
7328                                 not explicit_enable_disable_value_setting
7329                                 and this_valuename
7330                             ):
7331                                 enabled_value_string = _buildKnownDataSearchString(
7332                                     this_key,
7333                                     this_valuename,
7334                                     "REG_DWORD",
7335                                     "1",
7336                                     check_deleted=False,
7337                                 )
7338                                 existing_data = _policyFileReplaceOrAppend(
7339                                     enabled_value_string, existing_data
7340                                 )
7341                             if ELEMENTS_XPATH(this_policy):
7342                                 for elements_item in ELEMENTS_XPATH(this_policy):
7343                                     for child_item in elements_item:
7344                                         child_key = this_key
7345                                         child_valuename = this_valuename
7346                                         if "key" in child_item.attrib:
7347                                             child_key = child_item.attrib["key"]
7348                                         if "valueName" in child_item.attrib:
7349                                             child_valuename = child_item.attrib[
7350                                                 "valueName"
7351                                             ]
7352                                         if (
7353                                             child_item.attrib["id"]
7354                                             in base_policy_settings[adm_namespace][
7355                                                 admPolicy
7356                                             ]
7357                                         ):
7358                                             if etree.QName(
7359                                                 child_item
7360                                             ).localname == "boolean" and (
7361                                                 TRUE_LIST_XPATH(child_item)
7362                                                 or FALSE_LIST_XPATH(child_item)
7363                                             ):
7364                                                 list_strings = []
7365                                                 if base_policy_settings[adm_namespace][
7366                                                     admPolicy
7367                                                 ][child_item.attrib["id"]]:
7368                                                     list_strings = _checkListItem(
7369                                                         child_item,
7370                                                         admPolicy,
7371                                                         child_key,
7372                                                         TRUE_LIST_XPATH,
7373                                                         None,
7374                                                         test_items=False,
7375                                                     )
7376                                                     log.trace(
7377                                                         "working with trueList portion"
7378                                                         " of %s",
7379                                                         admPolicy,
7380                                                     )
7381                                                 else:
7382                                                     list_strings = _checkListItem(
7383                                                         child_item,
7384                                                         admPolicy,
7385                                                         child_key,
7386                                                         FALSE_LIST_XPATH,
7387                                                         None,
7388                                                         test_items=False,
7389                                                     )
7390                                                 existing_data = (
7391                                                     _policyFileReplaceOrAppendList(
7392                                                         list_strings, existing_data
7393                                                     )
7394                                                 )
7395                                             elif etree.QName(
7396                                                 child_item
7397                                             ).localname == "boolean" and (
7398                                                 TRUE_VALUE_XPATH(child_item)
7399                                                 or FALSE_VALUE_XPATH(child_item)
7400                                             ):
7401                                                 value_string = ""
7402                                                 if base_policy_settings[adm_namespace][
7403                                                     admPolicy
7404                                                 ][child_item.attrib["id"]]:
7405                                                     value_string = (
7406                                                         _checkValueItemParent(
7407                                                             child_item,
7408                                                             admPolicy,
7409                                                             child_key,
7410                                                             child_valuename,
7411                                                             TRUE_VALUE_XPATH,
7412                                                             None,
7413                                                             check_deleted=False,
7414                                                             test_item=False,
7415                                                         )
7416                                                     )
7417                                                 else:
7418                                                     value_string = (
7419                                                         _checkValueItemParent(
7420                                                             child_item,
7421                                                             admPolicy,
7422                                                             child_key,
7423                                                             child_valuename,
7424                                                             FALSE_VALUE_XPATH,
7425                                                             None,
7426                                                             check_deleted=False,
7427                                                             test_item=False,
7428                                                         )
7429                                                     )
7430                                                 existing_data = (
7431                                                     _policyFileReplaceOrAppend(
7432                                                         value_string, existing_data
7433                                                     )
7434                                                 )
7435                                             elif (
7436                                                 etree.QName(child_item).localname
7437                                                 == "boolean"
7438                                                 or etree.QName(child_item).localname
7439                                                 == "decimal"
7440                                                 or etree.QName(child_item).localname
7441                                                 == "text"
7442                                                 or etree.QName(child_item).localname
7443                                                 == "longDecimal"
7444                                                 or etree.QName(child_item).localname
7445                                                 == "multiText"
7446                                             ):
7447                                                 enabled_value_string = _processValueItem(
7448                                                     child_item,
7449                                                     child_key,
7450                                                     child_valuename,
7451                                                     this_policy,
7452                                                     elements_item,
7453                                                     check_deleted=False,
7454                                                     this_element_value=base_policy_settings[
7455                                                         adm_namespace
7456                                                     ][
7457                                                         admPolicy
7458                                                     ][
7459                                                         child_item.attrib["id"]
7460                                                     ],
7461                                                 )
7462                                                 log.trace(
7463                                                     "I have enabled value string of %s",
7464                                                     enabled_value_string,
7465                                                 )
7466                                                 existing_data = (
7467                                                     _policyFileReplaceOrAppend(
7468                                                         enabled_value_string,
7469                                                         existing_data,
7470                                                     )
7471                                                 )
7472                                             elif (
7473                                                 etree.QName(child_item).localname
7474                                                 == "enum"
7475                                             ):
7476                                                 for enum_item in child_item:
7477                                                     if (
7478                                                         base_policy_settings[
7479                                                             adm_namespace
7480                                                         ][admPolicy][
7481                                                             child_item.attrib["id"]
7482                                                         ]
7483                                                         == _getAdmlDisplayName(
7484                                                             adml_policy_resources,
7485                                                             enum_item.attrib[
7486                                                                 "displayName"
7487                                                             ],
7488                                                         ).strip()
7489                                                     ):
7490                                                         enabled_value_string = (
7491                                                             _checkValueItemParent(
7492                                                                 enum_item,
7493                                                                 child_item.attrib["id"],
7494                                                                 child_key,
7495                                                                 child_valuename,
7496                                                                 VALUE_XPATH,
7497                                                                 None,
7498                                                                 check_deleted=False,
7499                                                                 test_item=False,
7500                                                             )
7501                                                         )
7502                                                         existing_data = (
7503                                                             _policyFileReplaceOrAppend(
7504                                                                 enabled_value_string,
7505                                                                 existing_data,
7506                                                             )
7507                                                         )
7508                                                         if VALUE_LIST_XPATH(enum_item):
7509                                                             enabled_list_strings = (
7510                                                                 _checkListItem(
7511                                                                     enum_item,
7512                                                                     admPolicy,
7513                                                                     child_key,
7514                                                                     VALUE_LIST_XPATH,
7515                                                                     None,
7516                                                                     test_items=False,
7517                                                                 )
7518                                                             )
7519                                                             log.trace(
7520                                                                 "working with valueList"
7521                                                                 " portion of %s",
7522                                                                 child_item.attrib["id"],
7523                                                             )
7524                                                             existing_data = _policyFileReplaceOrAppendList(
7525                                                                 enabled_list_strings,
7526                                                                 existing_data,
7527                                                             )
7528                                                         break
7529                                             elif (
7530                                                 etree.QName(child_item).localname
7531                                                 == "list"
7532                                             ):
7533                                                 enabled_value_string = _processValueItem(
7534                                                     child_item,
7535                                                     child_key,
7536                                                     child_valuename,
7537                                                     this_policy,
7538                                                     elements_item,
7539                                                     check_deleted=False,
7540                                                     this_element_value=base_policy_settings[
7541                                                         adm_namespace
7542                                                     ][
7543                                                         admPolicy
7544                                                     ][
7545                                                         child_item.attrib["id"]
7546                                                     ],
7547                                                 )
7548                                                 log.trace(
7549                                                     "I have enabled value string of %s",
7550                                                     enabled_value_string,
7551                                                 )
7552                                                 existing_data = (
7553                                                     _policyFileReplaceOrAppend(
7554                                                         enabled_value_string,
7555                                                         existing_data,
7556                                                         append_only=True,
7557                                                     )
7558                                                 )
7559     try:
7560         _write_regpol_data(
7561             existing_data,
7562             policy_data.admx_registry_classes[registry_class]["policy_path"],
7563             policy_data.gpt_ini_path,
7564             policy_data.admx_registry_classes[registry_class]["gpt_extension_location"],
7565             policy_data.admx_registry_classes[registry_class]["gpt_extension_guid"],
7566         )
7567     except CommandExecutionError as exc:  # pylint: disable=broad-except
7568         log.exception(
7569             "Unhandled exception occurred while attempting to "
7570             "write Adm Template Policy File.\nException: %s",
7571             exc,
7572         )
7573         return False
7574     return True
7575 def _getScriptSettingsFromIniFile(policy_info):
7576     """
7577     helper function to parse/read a GPO Startup/Shutdown script file
7578     psscript.ini and script.ini file definitions are here
7579         https://msdn.microsoft.com/en-us/library/ff842529.aspx
7580         https://msdn.microsoft.com/en-us/library/dd303238.aspx
7581     """
7582     _existingData = None
7583     if os.path.isfile(policy_info["ScriptIni"]["IniPath"]):
7584         with salt.utils.files.fopen(policy_info["ScriptIni"]["IniPath"], "rb") as fhr:
7585             _existingData = fhr.read()
7586         if _existingData:
7587             try:
7588                 _existingData = deserialize(
7589                     _existingData.decode("utf-16-le").lstrip("\ufeff")
7590                 )
7591                 log.trace("Have deserialized data %s", _existingData)
7592             except Exception as error:  # pylint: disable=broad-except
7593                 log.exception(
7594                     "An error occurred attempting to deserialize data for %s",
7595                     policy_info["Policy"],
7596                 )
7597                 raise CommandExecutionError(error)
7598             if "Section" in policy_info["ScriptIni"] and policy_info["ScriptIni"][
7599                 "Section"
7600             ].lower() in [z.lower() for z in _existingData.keys()]:
7601                 if "SettingName" in policy_info["ScriptIni"]:
7602                     log.trace(
7603                         "Need to look for %s", policy_info["ScriptIni"]["SettingName"]
7604                     )
7605                     if policy_info["ScriptIni"]["SettingName"].lower() in [
7606                         z.lower()
7607                         for z in _existingData[
7608                             policy_info["ScriptIni"]["Section"]
7609                         ].keys()
7610                     ]:
7611                         return _existingData[policy_info["ScriptIni"]["Section"]][
7612                             policy_info["ScriptIni"]["SettingName"].lower()
7613                         ]
7614                     else:
7615                         return None
7616                 else:
7617                     return _existingData[policy_info["ScriptIni"]["Section"]]
7618             else:
7619                 return None
7620     return None
7621 def _writeGpoScript(psscript=False):
7622     """
7623     helper function to write local GPO startup/shutdown script
7624     scripts are stored in scripts.ini and psscripts.ini files in
7625     ``WINDIR\\System32\\GroupPolicy\\Machine|User\\Scripts``
7626     these files have the hidden attribute set
7627     files have following format:
7628         empty line
7629         [Startup]
7630         0CmdLine=&lt;path to script 0&gt;
7631         0Parameters=&lt;script 0 parameters&gt;
7632         [Shutdown]
7633         0CmdLine=&lt;path to shutdown script 0&gt;
7634         0Parameters=&lt;shutdown script 0 parameters&gt;
7635     Number is incremented for each script added
7636     psscript file also has the option of a [ScriptsConfig] section, which has
7637     the following two parameters:
7638         StartExecutePSFirst
7639         EndExecutePSFirst
7640     these can be set to True/False to denote if the powershell startup/shutdown
7641     scripts execute first (True) or last (False), if the value isn't set, then
7642     it is 'Not Configured' in the GUI
7643     """
7644     _machineScriptPolicyPath = os.path.join(
7645         os.getenv("WINDIR"),
7646         "System32",
7647         "GroupPolicy",
7648         "Machine",
7649         "Scripts",
7650         "scripts.ini",
7651     )
7652     _machinePowershellScriptPolicyPath = os.path.join(
7653         os.getenv("WINDIR"),
7654         "System32",
7655         "GroupPolicy",
7656         "Machine",
7657         "Scripts",
7658         "psscripts.ini",
7659     )
7660     _userScriptPolicyPath = os.path.join(
7661         os.getenv("WINDIR"), "System32", "GroupPolicy", "User", "Scripts", "scripts.ini"
7662     )
7663     _userPowershellScriptPolicyPath = os.path.join(
7664         os.getenv("WINDIR"),
7665         "System32",
7666         "GroupPolicy",
7667         "User",
7668         "Scripts",
7669         "psscripts.ini",
7670     )
7671 def _lookup_admin_template(policy_name, policy_class, adml_language="en-US"):
7672     """
7673     (success_flag, policy_xml_item, policy_name_list, message)
7674     """
7675     policy_aliases = []
7676     admx_policy_definitions = _get_policy_definitions(language=adml_language)
7677     adml_policy_resources = _get_policy_resources(language=adml_language)
7678     admx_search_results = ADMX_SEARCH_XPATH(
7679         admx_policy_definitions, policy_name=policy_name, registry_class=policy_class
7680     )
7681     if admx_search_results:
7682         if len(admx_search_results) == 1:
7683             the_policy = admx_search_results[0]
7684             policy_display_name = _getFullPolicyName(
7685                 policy_item=the_policy,
7686                 policy_name=the_policy.attrib["name"],
7687                 return_full_policy_names=True,
7688                 adml_language=adml_language,
7689             )
7690             policy_aliases.append(policy_display_name)
7691             policy_aliases.append(the_policy.attrib["name"])
7692             full_path_list = _build_parent_list(
7693                 policy_definition=the_policy,
7694                 return_full_policy_names=True,
7695                 adml_language=adml_language,
7696             )
7697             full_path_list.reverse()
7698             full_path_list.append(policy_display_name)
7699             policy_aliases.append("\\".join(full_path_list))
7700             return True, the_policy, policy_aliases, None
7701         else:
7702             msg = 'ADMX policy name/id "{}" is used in multiple ADMX files'
7703             return False, None, [], msg
7704     else:
7705         adml_search_results = ADML_SEARCH_XPATH(
7706             adml_policy_resources, policy_name=policy_name
7707         )
7708         hierarchy = []
7709         hierarchy_policy_name = policy_name
7710         if not adml_search_results:
7711             log.warning("Trying another: %s", policy_name)
7712             if "\\" in policy_name:
7713                 hierarchy = policy_name.split("\\")
7714                 policy_name = hierarchy.pop()
7715                 adml_search_results = ADML_SEARCH_XPATH(
7716                     adml_policy_resources, policy_name=policy_name
7717                 )
7718         if adml_search_results:
7719             multiple_adml_entries = False
7720             suggested_policies = ""
7721             adml_to_remove = []
7722             if len(adml_search_results) &gt; 1:
7723                 log.trace(
7724                     "multiple ADML entries found matching the policy name %s",
7725                     policy_name,
7726                 )
7727                 multiple_adml_entries = True
7728                 for adml_search_result in adml_search_results:
7729                     if (
7730                         not getattr(adml_search_result, "text", "").strip()
7731                         == policy_name
7732                     ):
7733                         adml_to_remove.append(adml_search_result)
7734                     else:
7735                         if hierarchy:
7736                             log.trace("we have hierarchy of %s", hierarchy)
7737                             display_name_searchval = "$({}.{})".format(
7738                                 adml_search_result.tag.split("}")[1],
7739                                 adml_search_result.attrib["id"],
7740                             )
7741                             policy_search_string = (
7742                                 '//{}:policy[@displayName = "{}" and (@class = "Both"'
7743                                 ' or @class = "{}") ]'.format(
7744                                     adml_search_result.prefix,
7745                                     display_name_searchval,
7746                                     policy_class,
7747                                 )
7748                             )
7749                             admx_results = []
7750                             these_admx_search_results = admx_policy_definitions.xpath(
7751                                 policy_search_string,
7752                                 namespaces=adml_search_result.nsmap,
7753                             )
7754                             if not these_admx_search_results:
7755                                 log.trace(
7756                                     "No admx was found for the adml entry %s, it will"
7757                                     " be removed",
7758                                     display_name_searchval,
7759                                 )
7760                                 adml_to_remove.append(adml_search_result)
7761                             for search_result in these_admx_search_results:
7762                                 log.trace("policy_name == %s", policy_name)
7763                                 this_hierarchy = _build_parent_list(
7764                                     policy_definition=search_result,
7765                                     return_full_policy_names=True,
7766                                     adml_language=adml_language,
7767                                 )
7768                                 this_hierarchy.reverse()
7769                                 if hierarchy != this_hierarchy:
7770                                     log.trace(
7771                                         "hierarchy %s does not match this item's"
7772                                         " hierarchy of %s",
7773                                         hierarchy,
7774                                         this_hierarchy,
7775                                     )
7776                                     if len(these_admx_search_results) == 1:
7777                                         log.trace(
7778                                             "only 1 admx was found and it does not "
7779                                             "match this adml, it is safe to remove "
7780                                             "from the list"
7781                                         )
7782                                         adml_to_remove.append(adml_search_result)
7783                                 else:
7784                                     log.trace(
7785                                         "hierarchy %s matches item's hierarchy of %s",
7786                                         hierarchy,
7787                                         this_hierarchy,
7788                                     )
7789                                     log.trace(
7790                                         "search_result %s added to results",
7791                                         search_result,
7792                                     )
7793                                     admx_results.append(search_result)
7794                             if len(admx_results) == 1:
7795                                 admx_search_results.append(admx_results[0])
7796                         else:
7797                             display_name_searchval = "$({}.{})".format(
7798                                 adml_search_result.tag.split("}")[1],
7799                                 adml_search_result.attrib["id"],
7800                             )
7801                             these_admx_search_results = ADMX_DISPLAYNAME_SEARCH_XPATH(
7802                                 admx_policy_definitions,
7803                                 display_name=display_name_searchval,
7804                                 registry_class=policy_class,
7805                             )
7806                             if not these_admx_search_results:
7807                                 adml_to_remove.append(adml_search_result)
7808             for adml in adml_to_remove:
7809                 if adml in adml_search_results:
7810                     adml_search_results.remove(adml)
7811             if len(adml_search_results) == 1 and multiple_adml_entries:
7812                 multiple_adml_entries = False
7813             for adml_search_result in adml_search_results:
7814                 log.trace(
7815                     "found an ADML entry matching the string! %s -- %s",
7816                     adml_search_result.tag,
7817                     adml_search_result.attrib,
7818                 )
7819                 display_name_searchval = "$({}.{})".format(
7820                     adml_search_result.tag.split("}")[1],
7821                     adml_search_result.attrib["id"],
7822                 )
7823                 log.trace("searching for displayName == %s", display_name_searchval)
7824                 if not admx_search_results:
7825                     log.trace(
7826                         "search for an admx entry matching display_name %s and"
7827                         " registry_class %s",
7828                         display_name_searchval,
7829                         policy_class,
7830                     )
7831                     admx_search_results = ADMX_DISPLAYNAME_SEARCH_XPATH(
7832                         admx_policy_definitions,
7833                         display_name=display_name_searchval,
7834                         registry_class=policy_class,
7835                     )
7836                 if admx_search_results:
7837                     log.trace(
7838                         "processing admx_search_results of %s", admx_search_results
7839                     )
7840                     log.trace("multiple_adml_entries is %s", multiple_adml_entries)
7841                     if (
7842                         len(admx_search_results) == 1 or hierarchy
7843                     ) and not multiple_adml_entries:
7844                         found = False
7845                         for search_result in admx_search_results:
7846                             found = False
7847                             if hierarchy:
7848                                 this_hierarchy = _build_parent_list(
7849                                     policy_definition=search_result,
7850                                     return_full_policy_names=True,
7851                                     adml_language=adml_language,
7852                                 )
7853                                 this_hierarchy.reverse()
7854                                 log.trace("testing %s == %s", hierarchy, this_hierarchy)
7855                                 if hierarchy == this_hierarchy:
7856                                     found = True
7857                             else:
7858                                 found = True
7859                             if found:
7860                                 log.trace(
7861                                     "found the ADMX policy matching "
7862                                     "the display name %s -- %s",
7863                                     search_result,
7864                                     policy_name,
7865                                 )
7866                                 if "name" in search_result.attrib:
7867                                     policy_display_name = _getFullPolicyName(
7868                                         policy_item=search_result,
7869                                         policy_name=search_result.attrib["name"],
7870                                         return_full_policy_names=True,
7871                                         adml_language=adml_language,
7872                                     )
7873                                     policy_aliases.append(policy_display_name)
7874                                     policy_aliases.append(search_result.attrib["name"])
7875                                     full_path_list = _build_parent_list(
7876                                         policy_definition=search_result,
7877                                         return_full_policy_names=True,
7878                                         adml_language=adml_language,
7879                                     )
7880                                     full_path_list.reverse()
7881                                     full_path_list.append(policy_display_name)
7882                                     policy_aliases.append("\\".join(full_path_list))
7883                                     return True, search_result, policy_aliases, None
7884                                 else:
7885                                     msg = (
7886                                         "ADMX policy with the display name {} does not"
7887                                         "have the required name attribute"
7888                                     )
7889                                     msg = msg.format(policy_name)
7890                                     return False, None, [], msg
7891                         if not found:
7892                             msg = "Unable to correlate {} to any policy".format(
7893                                 hierarchy_policy_name
7894                             )
7895                             return False, None, [], msg
7896                     else:
7897                         for possible_policy in admx_search_results:
7898                             this_parent_list = _build_parent_list(
7899                                 policy_definition=possible_policy,
7900                                 return_full_policy_names=True,
7901                                 adml_language=adml_language,
7902                             )
7903                             this_parent_list.reverse()
7904                             this_parent_list.append(policy_name)
7905                             if suggested_policies:
7906                                 suggested_policies = ", ".join(
7907                                     [suggested_policies, "\\".join(this_parent_list)]
7908                                 )
7909                             else:
7910                                 suggested_policies = "\\".join(this_parent_list)
7911             if suggested_policies:
7912                 msg = (
7913                     'ADML policy name "{}" is used as the display name for '
7914                     "multiple policies. These policies matched: {}. You can "
7915                     "utilize these long names to specify the correct policy"
7916                 )
7917                 return False, None, [], msg.format(policy_name, suggested_policies)
7918     return (
7919         False,
7920         None,
7921         [],
7922         "Unable to find {} policy {}".format(policy_class, policy_name),
7923     )
7924 def get_policy_info(policy_name, policy_class, adml_language="en-US"):
7925     r"""
7926     Returns information about a specified policy
7927     Args:
7928         policy_name (str):
7929             The name of the policy to lookup
7930         policy_class (str):
7931             The class of policy, i.e. machine, user, both
7932         adml_language (str):
7933             The ADML language to use for Administrative Template data lookup
7934     Returns:
7935         dict: Information about the specified policy
7936     CLI Example:
7937     .. code-block:: bash
7938         salt '*' lgpo.get_policy_info 'Maximum password age' machine
7939     You can use ``lgpo.get_policy_info`` to get all the possible names that
7940     could be used in a state file or from the command line (along with elements
7941     that need to be set/etc). The key is to match the text you see in the
7942     ``gpedit.msc`` gui exactly, including quotes around words or phrases. The
7943     "full path" style is really only needed when there are multiple policies
7944     that use the same base name. For example, ``Access data sources across
7945     domains`` exists in ~10 different paths. If you put that through
7946     ``get_policy_info`` you'll get back a message that it is used for multiple
7947     policies and you need to be more specific.
7948     CLI Example:
7949     .. code-block:: bash
7950         salt-call --local lgpo.get_policy_info ShellRemoveOrderPrints_2 machine
7951         local:
7952             ----------
7953             message:
7954             policy_aliases:
7955                 - Turn off the "Order Prints" picture task
7956                 - ShellRemoveOrderPrints_2
7957                 - System\Internet Communication Management\Internet Communication settings\Turn off the "Order Prints" picture task
7958             policy_class:
7959                 machine
7960             policy_elements:
7961             policy_found:
7962                 True
7963             policy_name:
7964                 ShellRemoveOrderPrints_2
7965             rights_assignment:
7966                 False
7967     Escaping can get tricky in cmd/Powershell. The following is an example of
7968     escaping in Powershell using backquotes:
7969     .. code-block:: bash
7970         PS&gt;salt-call --local lgpo.get_policy_info "Turn off the `\`"Order Prints`\`" picture task" machine
7971         local:
7972             ----------
7973             message:
7974             policy_aliases:
7975                 - Turn off the "Order Prints" picture task
7976                 - ShellRemoveOrderPrints_2
7977                 - System\Internet Communication Management\Internet Communication settings\Turn off the "Order Prints" picture task
7978             policy_class:
7979                 machine
7980             policy_elements:
7981             policy_found:
7982                 True
7983             policy_name:
7984                 Turn off the "Order Prints" picture task
7985             rights_assignment:
7986                 False
7987     This function can then be used to get the options available for specifying
7988     Group Policy Objects to be used in state files. Based on the above any of
7989     these *should* be usable:
7990     .. code-block:: bash
7991         internet_communications_settings:
7992           lgpo.set:
7993             - computer_policy:
7994                 Turn off the "Order Prints" picture task: Enabled
7995     .. code-block:: bash
7996         internet_communications_settings:
7997           lgpo.set:
7998             - computer_policy:
7999                 ShellRemoveOrderPrints_2: Enabled
8000     When using the full path, it might be a good idea to use single quotes
8001     around the path:
8002     .. code-block:: bash
8003         internet_communications_settings:
8004           lgpo.set:
8005             - computer_policy:
8006                 'System\Internet Communication Management\Internet Communication settings\Turn off the "Order Prints" picture task': 'Enabled'
8007     If you struggle to find the policy from ``get_policy_info`` using the name
8008     as you see in ``gpedit.msc``, the names such as "ShellRemoveOrderPrints_2"
8009     come from the ``.admx`` files. If you know nothing about ``.admx/.adml``
8010     relationships (ADML holds what you see in the GUI, ADMX holds the more
8011     technical details), then this may be a little bit too much info, but here is
8012     an example with the above policy using Powershell:
8013     .. code-block:: bash
8014         PS&gt;Get-ChildItem -Path C:\Windows\PolicyDefinitions -Recurse -Filter *.adml | Select-String "Order Prints"
8015         C:\windows\PolicyDefinitions\en-US\ICM.adml:152:      &lt;string id="ShellRemoveOrderPrints"&gt;Turn off the "Order Prints" picture task&lt;/string&gt;
8016         C:\windows\PolicyDefinitions\en-US\ICM.adml:153:      &lt;string id="ShellRemoveOrderPrints_Help"&gt;This policy setting specifies whether the "Order Prints Online" task is available from Picture Tasks in Windows folders.
8017         C:\windows\PolicyDefinitions\en-US\ICM.adml:155:The Order Prints Online Wizard is used to download a list of providers and allow users to order prints online.
8018         C:\windows\PolicyDefinitions\en-US\ICM.adml:157:If you enable this policy setting, the task "Order Prints Online" is removed from Picture Tasks in File Explorer folders.
8019     From this grep, we can see id "ShellRemoveOrderPrints" is the ID of the
8020     string used to describe this policy, then we search for it in the ADMX:
8021     .. code-block:: bash
8022         PS&gt;Get-ChildItem -Path C:\Windows\PolicyDefinitions -Recurse -Filter *.admx | Select-String "ShellRemoveOrderPrints"
8023         C:\windows\PolicyDefinitions\ICM.admx:661:    &lt;policy name="ShellRemoveOrderPrints_1" class="User" displayName="$(string.ShellRemoveOrderPrints)" explainText="$(string.ShellRemoveOrderPrints_Help)" key="Software\Microsoft\Windows\CurrentVersion\Policies\Explorer" valueName="NoOnlinePrintsWizard"&gt;
8024         C:\windows\PolicyDefinitions\ICM.admx:671:    &lt;policy name="ShellRemoveOrderPrints_2" class="Machine" displayName="$(string.ShellRemoveOrderPrints)" explainText="$(string.ShellRemoveOrderPrints_Help)" key="Software\Microsoft\Windows\CurrentVersion\Policies\Explorer" valueName="NoOnlinePrintsWizard"&gt;
8025     Now we have two to pick from. And if you notice the ``class="Machine"`` and
8026     ``class="User"`` (which details if it is a computer policy or user policy
8027     respectively) the ``ShellRemoveOrderPrints_2`` is the "short name" we could
8028     use to pass through ``get_policy_info`` to see what the module itself is
8029     expecting.
8030     """
8031     ret = {
8032         "policy_name": policy_name,
8033         "policy_class": policy_class,
8034         "policy_aliases": [],
8035         "policy_found": False,
8036         "rights_assignment": False,
8037         "policy_elements": [],
8038         "message": "policy not found",
8039     }
8040     policy_class = policy_class.title()
8041     policy_data = _policy_info()
8042     if policy_class not in policy_data.policies.keys():
8043         policy_classes = ", ".join(policy_data.policies.keys())
8044         ret["message"] = (
8045             'The requested policy class "{}" is invalid, '
8046             "policy_class should be one of: {}"
8047             "".format(policy_class, policy_classes)
8048         )
8049         return ret
8050     if policy_name in policy_data.policies[policy_class]["policies"]:
8051         ret["policy_aliases"].append(
8052             policy_data.policies[policy_class]["policies"][policy_name]["Policy"]
8053         )
8054         ret["policy_found"] = True
8055         ret["message"] = ""
8056         if "LsaRights" in policy_data.policies[policy_class]["policies"][policy_name]:
8057             ret["rights_assignment"] = True
8058         return ret
8059     else:
8060         for pol in policy_data.policies[policy_class]["policies"]:
8061             _p = policy_data.policies[policy_class]["policies"][pol]["Policy"]
8062             if _p == policy_name:
8063                 ret["policy_aliases"].append(pol)
8064                 ret["policy_found"] = True
8065                 ret["message"] = ""
8066                 if "LsaRights" in policy_data.policies[policy_class]["policies"][pol]:
8067                     ret["rights_assignment"] = True
8068                 return ret
8069         for pol in policy_data.policies[policy_class]["policies"]:
8070             _p = policy_data.policies[policy_class]["policies"][pol]["Policy"]
8071             if _p.lower() == policy_name.lower():
8072                 ret["policy_aliases"].append(pol)
8073                 ret["policy_found"] = True
8074                 ret["message"] = ""
8075                 if "LsaRights" in policy_data.policies[policy_class]["policies"][pol]:
8076                     ret["rights_assignment"] = True
8077                 return ret
8078     success, policy_xml_item, policy_name_list, message = _lookup_admin_template(
8079         policy_name=policy_name, policy_class=policy_class, adml_language=adml_language
8080     )
8081     if success:
8082         for elements_item in ELEMENTS_XPATH(policy_xml_item):
8083             for child_item in elements_item:
8084                 this_element_name = _getFullPolicyName(
8085                     policy_item=child_item,
8086                     policy_name=child_item.attrib["id"],
8087                     return_full_policy_names=True,
8088                     adml_language=adml_language,
8089                 )
8090                 ret["policy_elements"].append(
8091                     {
8092                         "element_id": child_item.attrib["id"],
8093                         "element_aliases": [child_item.attrib["id"], this_element_name],
8094                     }
8095                 )
8096         ret["policy_aliases"] = policy_name_list
8097         ret["policy_found"] = True
8098         ret["message"] = ""
8099         return ret
8100     else:
8101         ret["message"] = message
8102     return ret
8103 def get(
8104     policy_class=None,
8105     return_full_policy_names=True,
8106     hierarchical_return=False,
8107     adml_language="en-US",
8108     return_not_configured=False,
8109 ):
8110     """
8111     Get a policy value
8112     Args:
8113         policy_class (str):
8114             Some policies are both user and computer, by default all policies
8115             will be pulled, but this can be used to retrieve only a specific
8116             policy class User/USER/user = retrieve user policies
8117             Machine/MACHINE/machine/Computer/COMPUTER/computer = retrieve
8118             machine/computer policies
8119         return_full_policy_names (bool):
8120             True/False to return the policy name as it is seen in the
8121             ``gpedit.msc`` GUI or to only return the policy key/id.
8122         hierarchical_return (bool):
8123             True/False to return the policy data in the hierarchy as seen in the
8124             ``gpedit.msc`` GUI. The default of False will return data split only
8125             into User/Computer configuration sections
8126         adml_language (str):
8127             The ADML language to use for processing display/descriptive names
8128             and enumeration values of ADMX template data, defaults to en-US
8129         return_not_configured (bool):
8130             Include Administrative Template policies that are 'Not Configured'
8131             in the return data
8132     Returns:
8133         dict: A dictionary containing the policy values for the specified class
8134     CLI Example:
8135     .. code-block:: bash
8136         salt '*' lgpo.get machine return_full_policy_names=True
8137     """
8138     vals = {}
8139     _policydata = _policy_info()
8140     if policy_class is None or policy_class.lower() == "both":
8141         policy_class = _policydata.policies.keys()
8142     elif policy_class.lower() not in [z.lower() for z in _policydata.policies]:
8143         msg = (
8144             "The policy_class {} is not an available policy class, please "
8145             "use one of the following: {}, Both"
8146         )
8147         raise SaltInvocationError(
8148             msg.format(policy_class, ", ".join(_policydata.policies.keys()))
8149         )
8150     else:
8151         policy_class = [policy_class.title()]
8152     for p_class in policy_class:
8153         this_class_policy_names = _policydata.policies[p_class]["policies"]
8154         class_vals = {}
8155         for policy_name in this_class_policy_names:
8156             _pol = None
8157             if policy_name in _policydata.policies[p_class]["policies"]:
8158                 _pol = _policydata.policies[p_class]["policies"][policy_name]
8159             else:
8160                 for policy in _policydata.policies[p_class]["policies"]:
8161                     _p = _policydata.policies[p_class]["policies"][policy]["Policy"]
8162                     if _p == policy_name:
8163                         _pol = _policydata.policies[p_class]["policies"][policy]
8164                         policy_name = policy
8165                 if _pol is None:
8166                     for policy in _policydata.policies[p_class]["policies"]:
8167                         _p = _policydata.policies[p_class]["policies"][policy]["Policy"]
8168                         if _p.lower() == policy_name.lower():
8169                             _pol = _policydata.policies[p_class]["policies"][policy]
8170                             policy_name = policy
8171             if _pol:
8172                 vals_key_name = policy_name
8173                 class_vals[policy_name] = _get_policy_info_setting(_pol)
8174                 if return_full_policy_names:
8175                     class_vals[_pol["Policy"]] = class_vals.pop(policy_name)
8176                     vals_key_name = _pol["Policy"]
8177                 if hierarchical_return:
8178                     if "lgpo_section" in _pol:
8179                         firstItem = True
8180                         tdict = {}
8181                         for level in reversed(_pol["lgpo_section"]):
8182                             newdict = {}
8183                             if firstItem:
8184                                 newdict[level] = {
8185                                     vals_key_name: class_vals.pop(vals_key_name)
8186                                 }
8187                                 firstItem = False
8188                             else:
8189                                 newdict[level] = tdict
8190                             tdict = newdict
8191                         if tdict:
8192                             class_vals = dictupdate.update(class_vals, tdict)
8193             else:
8194                 raise CommandExecutionError(
8195                     "The specified policy {} is not currently available "
8196                     "to be configured via this module".format(policy_name)
8197                 )
8198         class_vals = dictupdate.update(
8199             class_vals,
8200             _checkAllAdmxPolicies(
8201                 policy_class=p_class,
8202                 adml_language=adml_language,
8203                 return_full_policy_names=return_full_policy_names,
8204                 hierarchical_return=hierarchical_return,
8205                 return_not_configured=return_not_configured,
8206             ),
8207         )
8208         if _policydata.policies[p_class]["lgpo_section"] not in class_vals:
8209             temp_dict = {_policydata.policies[p_class]["lgpo_section"]: class_vals}
8210             class_vals = temp_dict
8211         vals = dictupdate.update(vals, class_vals)
8212     return vals
8213 def _get_policy_info_setting(policy_definition):
8214     """
8215     Some policies are defined in this module and others by the ADMX/ADML files
8216     on the machine. This function loads the current values for policies defined
8217     in this module.
8218     Args:
8219         policy_definition (dict):
8220             A sub-dict of Policies property of the _policy_info() class.
8221             Basically a dictionary that defines the policy
8222     Returns:
8223         The transformed value. The transform is defined in the policy
8224         definition. It can be a list, a string, a dictionary, depending on how
8225         it's defined
8226     Usage:
8227         policy_data = _policy_info()
8228         policy_name = 'RemoteRegistryExactPaths'
8229         policy_definition = policy_data.policies['Machine']['policies'][policy_name]
8230         policy_value = _get_policy_info_setting(policy_definition)
8231     """
8232     if "Registry" in policy_definition:
8233         value = __utils__["reg.read_value"](
8234             policy_definition["Registry"]["Hive"],
8235             policy_definition["Registry"]["Path"],
8236             policy_definition["Registry"]["Value"],
8237         )["vdata"]
8238         log.trace(
8239             "Value %r found for Regisry policy %s", value, policy_definition["Policy"]
8240         )
8241     elif "Secedit" in policy_definition:
8242         value = _get_secedit_value(option=policy_definition["Secedit"]["Option"])
8243         log.trace(
8244             "Value %r found for Secedit policy %s", value, policy_definition["Policy"]
8245         )
8246     elif "NetSH" in policy_definition:
8247         value = _get_netsh_value(
8248             profile=policy_definition["NetSH"]["Profile"],
8249             option=policy_definition["NetSH"]["Option"],
8250         )
8251         log.trace(
8252             "Value %r found for NetSH policy %s", value, policy_definition["Policy"]
8253         )
8254     elif "AdvAudit" in policy_definition:
8255         value = _get_advaudit_value(option=policy_definition["AdvAudit"]["Option"])
8256         log.trace(
8257             "Value %r found for AuditPol policy %s", value, policy_definition["Policy"]
8258         )
8259     elif "NetUserModal" in policy_definition:
8260         modal_return = win32net.NetUserModalsGet(
8261             None, policy_definition["NetUserModal"]["Modal"]
8262         )
8263         value = modal_return[policy_definition["NetUserModal"]["Option"]]
8264         log.trace(
8265             "Value %r found for NetUserModal policy %s",
8266             value,
8267             policy_definition["Policy"],
8268         )
8269     elif "LsaRights" in policy_definition:
8270         value = _getRightsAssignments(policy_definition["LsaRights"]["Option"])
8271         log.trace(
8272             "Value %r found for LSARights policy %s", value, policy_definition["Policy"]
8273         )
8274     elif "ScriptIni" in policy_definition:
8275         value = _getScriptSettingsFromIniFile(policy_definition)
8276         log.trace(
8277             "Value %r found for ScriptIni policy %s", value, policy_definition["Policy"]
8278         )
8279     else:
8280         raise CommandExecutionError(
8281             "Unknown or missing mechanism in policy_definition\n{}".format(
8282                 policy_definition
8283             )
8284         )
8285     value = _transform_value(
8286         value=value, policy=policy_definition, transform_type="Get"
8287     )
8288     return value
8289 def _get_policy_adm_setting(
8290     admx_policy,
8291     policy_class,
8292     adml_language="en-US",
8293     return_full_policy_names=False,
8294     hierarchical_return=False,
8295 ):
8296     """
8297     Get the current setting for polices set via the policy templates (ADMX/ADML)
8298     files
8299     Args:
8300         admx_policy (obj):
8301             The XPath object as returned by the ``_lookup_admin_template``
8302             function
8303         policy_class (str):
8304             The policy class. Must be one of ``machine`` or ``user``
8305         adml_language (str):
8306             The language code for the adml file to use for localization. The
8307             default is ``en-US``
8308         return_full_policy_names (bool):
8309             Returns the full policy name regardless of what was passed in
8310             ``policy_name``
8311         hierarchical_return (bool):
8312             Returns a hierarchical view of the policy showing its parents
8313     Returns:
8314         dict: A dictionary containing the policy settings
8315     Usage:
8316         policy_name = 'AutoUpdateCfg'
8317         policy_class = 'machine'
8318         adml_language = 'en-US'
8319         success, policy_obj, _, _ = _lookup_admin_template(
8320             policy_name=policy_name,
8321             policy_class=policy_class,
8322             adml_language=adml_language)
8323         if success:
8324             setting = _get_policy_adm_setting(
8325                 admx_policy=policy_obj,
8326                 policy_class=policy_class,
8327                 adml_language=adml_language,
8328                 return_full_policy_names=return_full_policy_names,
8329                 hierarchical_return=hierarchical_return
8330             )
8331     """
8332     this_key = admx_policy.attrib.get("key", None)
8333     this_policy_name = admx_policy.attrib.get("name", None)
8334     if this_key is None or this_policy_name is None:
8335         raise CommandExecutionError(
8336             'Policy is missing the required "key" or "name" attribute:\n{}'.format(
8337                 admx_policy.attrib
8338             )
8339         )
8340     this_value_name = admx_policy.attrib.get("valueName", None)
8341     this_policy_setting = "Not Configured"
8342     this_policy_namespace = admx_policy.nsmap[admx_policy.prefix]
8343     element_only_enabled_disabled = True
8344     explicit_enable_disable_value_setting = False
8345     policy_data = _policy_info()
8346     policy_file_data = _read_regpol_file(
8347         policy_data.admx_registry_classes[policy_class]["policy_path"]
8348     )
8349     adml_policy_resources = _get_policy_resources(language=adml_language)
8350     policy_vals = {}
8351     if ENABLED_VALUE_XPATH(admx_policy) and this_policy_setting == "Not Configured":
8352         if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):
8353             element_only_enabled_disabled = False
8354             explicit_enable_disable_value_setting = True
8355             if _checkValueItemParent(
8356                 policy_element=admx_policy,
8357                 policy_name=this_policy_name,
8358                 policy_key=this_key,
8359                 policy_valueName=this_value_name,
8360                 xpath_object=ENABLED_VALUE_XPATH,
8361                 policy_file_data=policy_file_data,
8362             ):
8363                 log.trace(
8364                     "%s is enabled by detected ENABLED_VALUE_XPATH", this_policy_name
8365                 )
8366                 this_policy_setting = "Enabled"
8367                 policy_vals.setdefault(this_policy_namespace, {})[
8368                     this_policy_name
8369                 ] = this_policy_setting
8370     if DISABLED_VALUE_XPATH(admx_policy) and this_policy_setting == "Not Configured":
8371         if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):
8372             element_only_enabled_disabled = False
8373             explicit_enable_disable_value_setting = True
8374             if _checkValueItemParent(
8375                 policy_element=admx_policy,
8376                 policy_name=this_policy_name,
8377                 policy_key=this_key,
8378                 policy_valueName=this_value_name,
8379                 xpath_object=DISABLED_VALUE_XPATH,
8380                 policy_file_data=policy_file_data,
8381             ):
8382                 log.trace(
8383                     "%s is disabled by detected DISABLED_VALUE_XPATH", this_policy_name
8384                 )
8385                 this_policy_setting = "Disabled"
8386                 policy_vals.setdefault(this_policy_namespace, {})[
8387                     this_policy_name
8388                 ] = this_policy_setting
8389     if ENABLED_LIST_XPATH(admx_policy):
8390         if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):
8391             element_only_enabled_disabled = False
8392             explicit_enable_disable_value_setting = True
8393             if _checkListItem(
8394                 policy_element=admx_policy,
8395                 policy_name=this_policy_name,
8396                 policy_key=this_key,
8397                 xpath_object=ENABLED_LIST_XPATH,
8398                 policy_file_data=policy_file_data,
8399             ):
8400                 log.trace(
8401                     "%s is enabled by detected ENABLED_LIST_XPATH", this_policy_name
8402                 )
8403                 this_policy_setting = "Enabled"
8404                 policy_vals.setdefault(this_policy_namespace, {})[
8405                     this_policy_name
8406                 ] = this_policy_setting
8407     if DISABLED_LIST_XPATH(admx_policy):
8408         if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):
8409             element_only_enabled_disabled = False
8410             explicit_enable_disable_value_setting = True
8411             if _checkListItem(
8412                 policy_element=admx_policy,
8413                 policy_name=this_policy_name,
8414                 policy_key=this_key,
8415                 xpath_object=DISABLED_LIST_XPATH,
8416                 policy_file_data=policy_file_data,
8417             ):
8418                 log.trace(
8419                     "%s is disabled by detected DISABLED_LIST_XPATH", this_policy_name
8420                 )
8421                 this_policy_setting = "Disabled"
8422                 policy_vals.setdefault(this_policy_namespace, {})[
8423                     this_policy_name
8424                 ] = this_policy_setting
8425     if not explicit_enable_disable_value_setting and this_value_name:
8426         if _regexSearchRegPolData(
8427             re.escape(
8428                 _buildKnownDataSearchString(
8429                     reg_key=this_key,
8430                     reg_valueName=this_value_name,
8431                     reg_vtype="REG_DWORD",
8432                     reg_data="1",
8433                 )
8434             ),
8435             policy_file_data,
8436         ):
8437             log.trace(
8438                 "%s is enabled by no explicit enable/disable list or value",
8439                 this_policy_name,
8440             )
8441             this_policy_setting = "Enabled"
8442             policy_vals.setdefault(this_policy_namespace, {})[
8443                 this_policy_name
8444             ] = this_policy_setting
8445         elif _regexSearchRegPolData(
8446             re.escape(
8447                 _buildKnownDataSearchString(
8448                     reg_key=this_key,
8449                     reg_valueName=this_value_name,
8450                     reg_vtype="REG_DWORD",
8451                     reg_data=None,
8452                     check_deleted=True,
8453                 )
8454             ),
8455             policy_file_data,
8456         ):
8457             log.trace(
8458                 "%s is disabled by no explicit enable/disable list or value",
8459                 this_policy_name,
8460             )
8461             this_policy_setting = "Disabled"
8462             policy_vals.setdefault(this_policy_namespace, {})[
8463                 this_policy_name
8464             ] = this_policy_setting
8465     full_names = {}
8466     hierarchy = {}
8467     if ELEMENTS_XPATH(admx_policy):
8468         if element_only_enabled_disabled or this_policy_setting == "Enabled":
8469             required_elements = {}
8470             configured_elements = {}
8471             policy_disabled_elements = 0
8472             for elements_item in ELEMENTS_XPATH(admx_policy):
8473                 for child_item in elements_item:
8474                     this_element_name = _getFullPolicyName(
8475                         policy_item=child_item,
8476                         policy_name=child_item.attrib["id"],
8477                         return_full_policy_names=return_full_policy_names,
8478                         adml_language=adml_language,
8479                     )
8480                     required_elements[this_element_name] = None
8481                     child_key = child_item.attrib.get("key", this_key)
8482                     child_value_name = child_item.attrib.get(
8483                         "valueName", this_value_name
8484                     )
8485                     if etree.QName(child_item).localname == "boolean":
8486                         if child_item is not None:
8487                             if (
8488                                 TRUE_VALUE_XPATH(child_item)
8489                                 and this_element_name not in configured_elements
8490                             ):
8491                                 if _checkValueItemParent(
8492                                     policy_element=child_item,
8493                                     policy_name=this_policy_name,
8494                                     policy_key=child_key,
8495                                     policy_valueName=child_value_name,
8496                                     xpath_object=TRUE_VALUE_XPATH,
8497                                     policy_file_data=policy_file_data,
8498                                 ):
8499                                     configured_elements[this_element_name] = True
8500                                     log.trace(
8501                                         "element %s is configured true",
8502                                         child_item.attrib["id"],
8503                                     )
8504                             if (
8505                                 FALSE_VALUE_XPATH(child_item)
8506                                 and this_element_name not in configured_elements
8507                             ):
8508                                 if _checkValueItemParent(
8509                                     policy_element=child_item,
8510                                     policy_name=this_policy_name,
8511                                     policy_key=child_key,
8512                                     policy_valueName=child_value_name,
8513                                     xpath_object=FALSE_VALUE_XPATH,
8514                                     policy_file_data=policy_file_data,
8515                                 ):
8516                                     configured_elements[this_element_name] = False
8517                                     policy_disabled_elements = (
8518                                         policy_disabled_elements + 1
8519                                     )
8520                                     log.trace(
8521                                         "element %s is configured false",
8522                                         child_item.attrib["id"],
8523                                     )
8524                             if (
8525                                 TRUE_LIST_XPATH(child_item)
8526                                 and this_element_name not in configured_elements
8527                             ):
8528                                 log.trace("checking trueList")
8529                                 if _checkListItem(
8530                                     policy_element=child_item,
8531                                     policy_name=this_policy_name,
8532                                     policy_key=this_key,
8533                                     xpath_object=TRUE_LIST_XPATH,
8534                                     policy_file_data=policy_file_data,
8535                                 ):
8536                                     configured_elements[this_element_name] = True
8537                                     log.trace(
8538                                         "element %s is configured true",
8539                                         child_item.attrib["id"],
8540                                     )
8541                             if (
8542                                 FALSE_LIST_XPATH(child_item)
8543                                 and this_element_name not in configured_elements
8544                             ):
8545                                 log.trace("checking falseList")
8546                                 if _checkListItem(
8547                                     policy_element=child_item,
8548                                     policy_name=this_policy_name,
8549                                     policy_key=this_key,
8550                                     xpath_object=FALSE_LIST_XPATH,
8551                                     policy_file_data=policy_file_data,
8552                                 ):
8553                                     configured_elements[this_element_name] = False
8554                                     policy_disabled_elements = (
8555                                         policy_disabled_elements + 1
8556                                     )
8557                                     log.trace(
8558                                         "element %s is configured false",
8559                                         child_item.attrib["id"],
8560                                     )
8561                         else:
8562                             if _regexSearchRegPolData(
8563                                 re.escape(
8564                                     _processValueItem(
8565                                         element=child_item,
8566                                         reg_key=child_key,
8567                                         reg_valuename=child_value_name,
8568                                         policy=admx_policy,
8569                                         parent_element=elements_item,
8570                                         check_deleted=True,
8571                                     )
8572                                 ),
8573                                 policy_file_data,
8574                             ):
8575                                 configured_elements[this_element_name] = False
8576                                 policy_disabled_elements = policy_disabled_elements + 1
8577                                 log.trace(
8578                                     "element %s is configured false",
8579                                     child_item.attrib["id"],
8580                                 )
8581                             elif _regexSearchRegPolData(
8582                                 re.escape(
8583                                     _processValueItem(
8584                                         element=child_item,
8585                                         reg_key=child_key,
8586                                         reg_valuename=child_value_name,
8587                                         policy=admx_policy,
8588                                         parent_element=elements_item,
8589                                         check_deleted=False,
8590                                     )
8591                                 ),
8592                                 policy_file_data,
8593                             ):
8594                                 configured_elements[this_element_name] = True
8595                                 log.trace(
8596                                     "element %s is configured true",
8597                                     child_item.attrib["id"],
8598                                 )
8599                     elif etree.QName(child_item).localname in [
8600                         "decimal",
8601                         "text",
8602                         "longDecimal",
8603                         "multiText",
8604                     ]:
8605                         if _regexSearchRegPolData(
8606                             re.escape(
8607                                 _processValueItem(
8608                                     element=child_item,
8609                                     reg_key=child_key,
8610                                     reg_valuename=child_value_name,
8611                                     policy=admx_policy,
8612                                     parent_element=elements_item,
8613                                     check_deleted=True,
8614                                 )
8615                             ),
8616                             policy_file_data,
8617                         ):
8618                             configured_elements[this_element_name] = "Disabled"
8619                             policy_disabled_elements = policy_disabled_elements + 1
8620                             log.trace("element %s is disabled", child_item.attrib["id"])
8621                         elif _regexSearchRegPolData(
8622                             re.escape(
8623                                 _processValueItem(
8624                                     element=child_item,
8625                                     reg_key=child_key,
8626                                     reg_valuename=child_value_name,
8627                                     policy=admx_policy,
8628                                     parent_element=elements_item,
8629                                     check_deleted=False,
8630                                 )
8631                             ),
8632                             policy_data=policy_file_data,
8633                         ):
8634                             configured_value = _getDataFromRegPolData(
8635                                 _processValueItem(
8636                                     element=child_item,
8637                                     reg_key=child_key,
8638                                     reg_valuename=child_value_name,
8639                                     policy=admx_policy,
8640                                     parent_element=elements_item,
8641                                     check_deleted=False,
8642                                 ),
8643                                 policy_data=policy_file_data,
8644                             )
8645                             configured_elements[this_element_name] = configured_value
8646                             log.trace(
8647                                 "element %s is enabled, value == %s",
8648                                 child_item.attrib["id"],
8649                                 configured_value,
8650                             )
8651                     elif etree.QName(child_item).localname == "enum":
8652                         if _regexSearchRegPolData(
8653                             re.escape(
8654                                 _processValueItem(
8655                                     element=child_item,
8656                                     reg_key=child_key,
8657                                     reg_valuename=child_value_name,
8658                                     policy=admx_policy,
8659                                     parent_element=elements_item,
8660                                     check_deleted=True,
8661                                 )
8662                             ),
8663                             policy_file_data,
8664                         ):
8665                             log.trace(
8666                                 "enum element %s is disabled", child_item.attrib["id"]
8667                             )
8668                             configured_elements[this_element_name] = "Disabled"
8669                             policy_disabled_elements = policy_disabled_elements + 1
8670                         else:
8671                             for enum_item in child_item:
8672                                 if _checkValueItemParent(
8673                                     policy_element=enum_item,
8674                                     policy_name=child_item.attrib["id"],
8675                                     policy_key=child_key,
8676                                     policy_valueName=child_value_name,
8677                                     xpath_object=VALUE_XPATH,
8678                                     policy_file_data=policy_file_data,
8679                                 ):
8680                                     if VALUE_LIST_XPATH(enum_item):
8681                                         log.trace("enum item has a valueList")
8682                                         if _checkListItem(
8683                                             policy_element=enum_item,
8684                                             policy_name=this_policy_name,
8685                                             policy_key=child_key,
8686                                             xpath_object=VALUE_LIST_XPATH,
8687                                             policy_file_data=policy_file_data,
8688                                         ):
8689                                             log.trace(
8690                                                 "all valueList items exist in file"
8691                                             )
8692                                             configured_elements[
8693                                                 this_element_name
8694                                             ] = _getAdmlDisplayName(
8695                                                 adml_xml_data=adml_policy_resources,
8696                                                 display_name=enum_item.attrib[
8697                                                     "displayName"
8698                                                 ],
8699                                             )
8700                                             break
8701                                     else:
8702                                         configured_elements[
8703                                             this_element_name
8704                                         ] = _getAdmlDisplayName(
8705                                             adml_xml_data=adml_policy_resources,
8706                                             display_name=enum_item.attrib[
8707                                                 "displayName"
8708                                             ],
8709                                         )
8710                                         break
8711                     elif etree.QName(child_item).localname == "list":
8712                         return_value_name = False
8713                         if (
8714                             "explicitValue" in child_item.attrib
8715                             and child_item.attrib["explicitValue"].lower() == "true"
8716                         ):
8717                             log.trace("explicitValue list, we will return value names")
8718                             return_value_name = True
8719                         regex_str = [
8720                             r"(?!\*",
8721                             r"\*",
8722                             "D",
8723                             "e",
8724                             "l",
8725                             "V",
8726                             "a",
8727                             "l",
8728                             "s",
8729                             r"\.",
8730                             ")",
8731                         ]
8732                         delvals_regex = "\x00".join(regex_str)
8733                         delvals_regex = salt.utils.stringutils.to_bytes(delvals_regex)
8734                         if _regexSearchRegPolData(
8735                             re.escape(
8736                                 _processValueItem(
8737                                     element=child_item,
8738                                     reg_key=child_key,
8739                                     reg_valuename=child_value_name,
8740                                     policy=admx_policy,
8741                                     parent_element=elements_item,
8742                                     check_deleted=False,
8743                                 )
8744                             )
8745                             + delvals_regex,
8746                             policy_data=policy_file_data,
8747                         ):
8748                             configured_value = _getDataFromRegPolData(
8749                                 _processValueItem(
8750                                     element=child_item,
8751                                     reg_key=child_key,
8752                                     reg_valuename=child_value_name,
8753                                     policy=admx_policy,
8754                                     parent_element=elements_item,
8755                                     check_deleted=False,
8756                                 ),
8757                                 policy_data=policy_file_data,
8758                                 return_value_name=return_value_name,
8759                             )
8760                             configured_elements[this_element_name] = configured_value
8761                             log.trace(
8762                                 "element %s is enabled values: %s",
8763                                 child_item.attrib["id"],
8764                                 configured_value,
8765                             )
8766                         elif _regexSearchRegPolData(
8767                             re.escape(
8768                                 _processValueItem(
8769                                     element=child_item,
8770                                     reg_key=child_key,
8771                                     reg_valuename=child_value_name,
8772                                     policy=admx_policy,
8773                                     parent_element=elements_item,
8774                                     check_deleted=True,
8775                                 )
8776                             ),
8777                             policy_file_data,
8778                         ):
8779                             configured_elements[this_element_name] = "Disabled"
8780                             policy_disabled_elements = policy_disabled_elements + 1
8781                             log.trace("element %s is disabled", child_item.attrib["id"])
8782             if element_only_enabled_disabled:
8783                 if 0 &lt; len(required_elements.keys()) == len(configured_elements.keys()):
8784                     if policy_disabled_elements == len(required_elements.keys()):
8785                         log.trace(
8786                             "%s is disabled by all enum elements", this_policy_name
8787                         )
8788                         policy_vals.setdefault(this_policy_namespace, {})[
8789                             this_policy_name
8790                         ] = "Disabled"
8791                     else:
8792                         log.trace("%s is enabled by enum elements", this_policy_name)
8793                         policy_vals.setdefault(this_policy_namespace, {})[
8794                             this_policy_name
8795                         ] = configured_elements
8796                 else:
8797                     policy_vals.setdefault(this_policy_namespace, {})[
8798                         this_policy_name
8799                     ] = this_policy_setting
8800             else:
8801                 if this_policy_setting == "Enabled":
8802                     policy_vals.setdefault(this_policy_namespace, {})[
8803                         this_policy_name
8804                     ] = configured_elements
8805         else:
8806             policy_vals.setdefault(this_policy_namespace, {})[
8807                 this_policy_name
8808             ] = this_policy_setting
8809     else:
8810         policy_vals.setdefault(this_policy_namespace, {})[
8811             this_policy_name
8812         ] = this_policy_setting
8813     if (
8814         return_full_policy_names
8815         and this_policy_namespace in policy_vals
8816         and this_policy_name in policy_vals[this_policy_namespace]
8817     ):
8818         full_names.setdefault(this_policy_namespace, {})
8819         full_names[this_policy_namespace][this_policy_name] = _getFullPolicyName(
8820             policy_item=admx_policy,
8821             policy_name=admx_policy.attrib["name"],
8822             return_full_policy_names=return_full_policy_names,
8823             adml_language=adml_language,
8824         )
8825         if this_policy_name in policy_vals[this_policy_namespace][this_policy_name]:
8826             full_name = full_names[this_policy_namespace][this_policy_name]
8827             setting = policy_vals[this_policy_namespace][this_policy_name].pop(
8828                 this_policy_name
8829             )
8830             policy_vals[this_policy_namespace][this_policy_name][full_name] = setting
8831     if (
8832         this_policy_namespace in policy_vals
8833         and this_policy_name in policy_vals[this_policy_namespace]
8834     ):
8835         hierarchy.setdefault(this_policy_namespace, {})[
8836             this_policy_name
8837         ] = _build_parent_list(
8838             policy_definition=admx_policy,
8839             return_full_policy_names=return_full_policy_names,
8840             adml_language=adml_language,
8841         )
8842     if policy_vals and return_full_policy_names and not hierarchical_return:
8843         log.debug("Compiling non hierarchical return...")
8844         unpathed_dict = {}
8845         pathed_dict = {}
8846         for policy_namespace in list(policy_vals):
8847             for policy_item in list(policy_vals[policy_namespace]):
8848                 full_name = full_names[policy_namespace][policy_item]
8849                 if full_name in policy_vals[policy_namespace]:
8850                     full_path_list = hierarchy[policy_namespace][policy_item]
8851                     full_path_list.reverse()
8852                     full_path_list.append(full_names[policy_namespace][policy_item])
8853                     policy_vals["\\".join(full_path_list)] = policy_vals[
8854                         policy_namespace
8855                     ].pop(policy_item)
8856                     pathed_dict[full_name] = True
8857                 else:
8858                     policy_vals[policy_namespace][full_name] = policy_vals[
8859                         policy_namespace
8860                     ].pop(policy_item)
8861                     unpathed_dict.setdefault(policy_namespace, {})[
8862                         full_name
8863                     ] = policy_item
8864             for path_needed in unpathed_dict[policy_namespace]:
8865                 full_path_list = hierarchy[policy_namespace][
8866                     unpathed_dict[policy_namespace][path_needed]
8867                 ]
8868                 full_path_list.reverse()
8869                 full_path_list.append(path_needed)
8870                 log.trace("full_path_list == %s", full_path_list)
8871                 policy_vals["\\".join(full_path_list)] = policy_vals[
8872                     policy_namespace
8873                 ].pop(path_needed)
8874     for policy_namespace in list(policy_vals):
8875         if policy_vals[policy_namespace] == {}:
8876             policy_vals.pop(policy_namespace)
8877         elif isinstance(policy_vals[policy_namespace], dict):
8878             if this_policy_namespace == policy_namespace and not hierarchical_return:
8879                 policy_vals.update(policy_vals[policy_namespace])
8880                 policy_vals.pop(policy_namespace)
8881     if policy_vals and hierarchical_return:
8882         if hierarchy:
8883             log.debug("Compiling hierarchical return...")
8884             for policy_namespace in hierarchy:
8885                 for hierarchy_item in hierarchy[policy_namespace]:
8886                     if hierarchy_item in policy_vals[policy_namespace]:
8887                         t_dict = {}
8888                         first_item = True
8889                         for item in hierarchy[policy_namespace][hierarchy_item]:
8890                             new_dict = {}
8891                             if first_item:
8892                                 h_policy_name = hierarchy_item
8893                                 if return_full_policy_names:
8894                                     h_policy_name = full_names[policy_namespace][
8895                                         hierarchy_item
8896                                     ]
8897                                 new_dict[item] = {
8898                                     h_policy_name: policy_vals[policy_namespace].pop(
8899                                         hierarchy_item
8900                                     )
8901                                 }
8902                                 first_item = False
8903                             else:
8904                                 new_dict[item] = t_dict
8905                             t_dict = new_dict
8906                         if t_dict:
8907                             policy_vals = dictupdate.update(policy_vals, t_dict)
8908                 if (
8909                     policy_namespace in policy_vals
8910                     and policy_vals[policy_namespace] == {}
8911                 ):
8912                     policy_vals.pop(policy_namespace)
8913         policy_vals = {
8914             policy_data.admx_registry_classes[policy_class]["lgpo_section"]: {
8915                 "Administrative Templates": policy_vals
8916             }
8917         }
8918     return policy_vals
8919 def get_policy(
8920     policy_name,
8921     policy_class,
8922     adml_language="en-US",
8923     return_value_only=True,
8924     return_full_policy_names=True,
8925     hierarchical_return=False,
8926 ):
8927     r"""
8928     Get the current settings for a single policy on the machine
8929     Args:
8930         policy_name (str):
8931             The name of the policy to retrieve. Can be the any of the names
8932             or alieses returned by ``lgpo.get_policy_info``
8933         policy_class (str):
8934             The policy class. Must be one of ``machine`` or ``user``
8935         adml_language (str):
8936             The language code for the adml file to use for localization. The
8937             default is ``en-US``
8938         return_value_only (bool):
8939             ``True`` will return only the value for the policy, without the
8940             name of the policy. ``return_full_policy_names`` and
8941             ``hierarchical_return`` will be ignored. Default is ``True``
8942         return_full_policy_names (bool):
8943             Returns the full policy name regardless of what was passed in
8944             ``policy_name``
8945             .. note::
8946                 This setting applies to sub-elements of the policy if they
8947                 exist. The value passed in ``policy_name`` will always be used
8948                 as the policy name when this setting is ``False``
8949         hierarchical_return (bool):
8950             Returns a hierarchical view of the policy showing its parents
8951     Returns:
8952         dict: A dictionary containing the policy settings
8953     CLI Example:
8954     .. code-block:: bash
8955         salt * lgpo.get_policy LockoutDuration machine
8956         salt * lgpo.get_policy AutoUpdateCfg machine
8957         salt * lgpo.get_policy "Account lockout duration" machine
8958         salt * lgpo.get_policy "Configure Automatic Updates" machine
8959         salt * lgpo.get_policy "Windows Components\Windows Update\Configure Automatic Updates" machine
8960     """
8961     if not policy_name:
8962         raise SaltInvocationError("policy_name must be defined")
8963     if not policy_class:
8964         raise SaltInvocationError("policy_class must be defined")
8965     policy_class = policy_class.title()
8966     policy_data = _policy_info()
8967     if policy_class not in policy_data.policies.keys():
8968         policy_classes = ", ".join(policy_data.policies.keys())
8969         raise CommandExecutionError(
8970             'The requested policy class "{}" is invalid, policy_class should '
8971             "be one of: {}".format(policy_class, policy_classes)
8972         )
8973     policy_definition = None
8974     if policy_name in policy_data.policies[policy_class]["policies"]:
8975         policy_definition = policy_data.policies[policy_class]["policies"][policy_name]
8976     else:
8977         for pol in policy_data.policies[policy_class]["policies"]:
8978             _p = policy_data.policies[policy_class]["policies"][pol]["Policy"]
8979             if _p == policy_name:
8980                 policy_definition = policy_data.policies[policy_class]["policies"][pol]
8981                 break
8982         if policy_definition is None:
8983             for pol in policy_data.policies[policy_class]["policies"]:
8984                 _p = policy_data.policies[policy_class]["policies"][pol]["Policy"]
8985                 if _p.lower() == policy_name.lower():
8986                     policy_definition = policy_data.policies[policy_class]["policies"][
8987                         pol
8988                     ]
8989                     break
8990     if policy_definition:
8991         if return_value_only:
8992             return _get_policy_info_setting(policy_definition)
8993         if return_full_policy_names:
8994             key_name = policy_definition["Policy"]
8995         else:
8996             key_name = policy_name
8997         setting = {key_name: _get_policy_info_setting(policy_definition)}
8998         if hierarchical_return:
8999             if "lgpo_section" in policy_definition:
9000                 first_item = True
9001                 t_dict = {}
9002                 for level in reversed(policy_definition["lgpo_section"]):
9003                     new_dict = {}
9004                     if first_item:
9005                         new_dict[level] = {key_name: setting.pop(key_name)}
9006                         first_item = False
9007                     else:
9008                         new_dict[level] = t_dict
9009                     t_dict = new_dict
9010                 if t_dict:
9011                     setting = t_dict
9012         return setting
9013     success, policy_obj, _, _ = _lookup_admin_template(
9014         policy_name=policy_name, policy_class=policy_class, adml_language=adml_language
9015     )
9016     if success:
9017         setting = _get_policy_adm_setting(
9018             admx_policy=policy_obj,
9019             policy_class=policy_class,
9020             adml_language=adml_language,
9021             return_full_policy_names=return_full_policy_names,
9022             hierarchical_return=hierarchical_return,
9023         )
9024         if return_value_only:
9025             for key in setting:
9026                 return setting[key]
9027         return setting
9028 def set_computer_policy(
9029     name, setting, cumulative_rights_assignments=True, adml_language="en-US"
9030 ):
9031     """
9032     Set a single computer policy
9033     Args:
9034         name (str):
9035             The name of the policy to configure
9036         setting (str):
9037             The setting to configure the named policy with
9038         cumulative_rights_assignments (bool): Determine how user rights
9039             assignment policies are configured. If True, user right assignment
9040             specifications are simply added to the existing policy. If False,
9041             only the users specified will get the right (any existing will have
9042             the right revoked)
9043         adml_language (str): The language files to use for looking up
9044             Administrative Template policy data (i.e. how the policy is
9045             displayed in the GUI).  Defaults to 'en-US' (U.S. English).
9046     Returns:
9047         bool: True if successful, otherwise False
9048     CLI Example:
9049     .. code-block:: bash
9050         salt '*' lgpo.set_computer_policy LockoutDuration 1440
9051     """
9052     pol = {}
9053     pol[name] = setting
9054     ret = set_(
9055         computer_policy=pol,
9056         user_policy=None,
9057         cumulative_rights_assignments=cumulative_rights_assignments,
9058         adml_language=adml_language,
9059     )
9060     return ret
9061 def set_user_policy(name, setting, adml_language="en-US"):
9062     """
9063     Set a single user policy
9064     Args:
9065         name (str):
9066             The name of the policy to configure
9067         setting (str):
9068             The setting to configure the named policy with
9069         adml_language (str):
9070             The language files to use for looking up Administrative Template
9071             policy data (i.e. how the policy is displayed in the GUI). Defaults
9072             to 'en-US' (U.S. English).
9073     Returns:
9074         bool: True if successful, Otherwise False
9075     CLI Example:
9076     .. code-block:: bash
9077         salt '*' lgpo.set_user_policy "Control Panel\\Display\\Disable the Display Control Panel" Enabled
9078     """
9079     pol = {}
9080     pol[name] = setting
9081     ret = set_(
9082         user_policy=pol,
9083         computer_policy=None,
9084         cumulative_rights_assignments=True,
9085         adml_language=adml_language,
9086     )
9087     return ret
9088 def set_(
9089     computer_policy=None,
9090     user_policy=None,
9091     cumulative_rights_assignments=True,
9092     adml_language="en-US",
9093 ):
9094     """
9095     Set a local server policy.
9096     Args:
9097         computer_policy (dict):
9098             A dictionary of "policyname: value" pairs of computer policies to
9099             set. 'value' should be how it is displayed in the gpedit GUI, i.e.
9100             if a setting can be 'Enabled'/'Disabled', then that should be passed
9101             Administrative Template data may require dicts within dicts, to
9102             specify each element of the Administrative Template policy.
9103             Administrative Templates policies are always cumulative.
9104             Policy names can be specified in a number of ways based on the type
9105             of policy:
9106                 Windows Settings Policies:
9107                     These policies can be specified using the GUI display name
9108                     or the key name from the _policy_info class in this module.
9109                     The GUI display name is also contained in the _policy_info
9110                     class in this module.
9111                 Administrative Template Policies:
9112                     These can be specified using the policy name as displayed in
9113                     the GUI (case sensitive). Some policies have the same name,
9114                     but a different location (for example, "Access data sources
9115                     across domains"). These can be differentiated by the "path"
9116                     in the GUI (for example, "Windows Components\\Internet
9117                     Explorer\\Internet Control Panel\\Security Page\\Internet
9118                     Zone\\Access data sources across domains").
9119                     Additionally, policies can be specified using the "name" and
9120                     "id" attributes from the ADMX files.
9121                     For Administrative Templates that have policy elements, each
9122                     element can be specified using the text string as seen in
9123                     the GUI or using the ID attribute from the ADMX file. Due to
9124                     the way some of the GUI text is laid out, some policy
9125                     element names could include descriptive text that appears
9126                     lbefore the policy element in the GUI.
9127                     Use the get_policy_info function for the policy name to view
9128                     the element ID/names that the module will accept.
9129         user_policy (dict):
9130             The same setup as the computer_policy, except with data to configure
9131             the local user policy.
9132         cumulative_rights_assignments (bool):
9133             Determine how user rights assignment policies are configured.
9134             If True, user right assignment specifications are simply added to
9135             the existing policy
9136             If False, only the users specified will get the right (any existing
9137             will have the right revoked)
9138         adml_language (str):
9139             The language files to use for looking up Administrative Template
9140             policy data (i.e. how the policy is displayed in the GUI). Defaults
9141             to 'en-US' (U.S. English).
9142     Returns:
9143         bool: True is successful, otherwise False
9144     CLI Example:
9145     .. code-block:: bash
9146         salt '*' lgpo.set computer_policy="{'LockoutDuration': 2, 'RestrictAnonymous': 'Enabled', 'AuditProcessTracking': 'Succes, Failure'}"
9147     """
9148     if computer_policy and not isinstance(computer_policy, dict):
9149         raise SaltInvocationError("computer_policy must be specified as a dict")
9150     if user_policy and not isinstance(user_policy, dict):
9151         raise SaltInvocationError("user_policy must be specified as a dict")
9152     policies = {}
9153     policies["User"] = user_policy
9154     policies["Machine"] = computer_policy
9155     if policies:
9156         adml_policy_resources = _get_policy_resources(language=adml_language)
9157         for p_class in policies:
9158             _secedits = {}
9159             _netshs = {}
9160             _advaudits = {}
9161             _modal_sets = {}
9162             _admTemplateData = {}
9163             _regedits = {}
9164             _lsarights = {}
9165             _policydata = _policy_info()
9166             if policies[p_class]:
9167                 for policy_name in policies[p_class]:
9168                     _pol = None
9169                     policy_key_name = policy_name
9170                     if policy_name in _policydata.policies[p_class]["policies"]:
9171                         _pol = _policydata.policies[p_class]["policies"][policy_name]
9172                     else:
9173                         for policy in _policydata.policies[p_class]["policies"]:
9174                             _p = _policydata.policies[p_class]["policies"][policy][
9175                                 "Policy"
9176                             ]
9177                             if _p == policy_name:
9178                                 _pol = _policydata.policies[p_class]["policies"][policy]
9179                                 policy_key_name = policy
9180                         if _pol is None:
9181                             for policy in _policydata.policies[p_class]["policies"]:
9182                                 _p = _policydata.policies[p_class]["policies"][policy][
9183                                     "Policy"
9184                                 ]
9185                                 if _p.lower() == policy_name.lower():
9186                                     _pol = _policydata.policies[p_class]["policies"][
9187                                         policy
9188                                     ]
9189                                     policy_key_name = policy
9190                     if _pol:
9191                         _value = _transform_value(
9192                             value=policies[p_class][policy_name],
9193                             policy=_policydata.policies[p_class]["policies"][
9194                                 policy_key_name
9195                             ],
9196                             transform_type="Put",
9197                         )
9198                         if not _validateSetting(
9199                             value=_value,
9200                             policy=_policydata.policies[p_class]["policies"][
9201                                 policy_key_name
9202                             ],
9203                         ):
9204                             raise SaltInvocationError(
9205                                 "The specified value {} is not an acceptable setting"
9206                                 " for policy {}.".format(
9207                                     policies[p_class][policy_name], policy_name
9208                                 )
9209                             )
9210                         if "Registry" in _pol:
9211                             log.trace("%s is a registry policy", policy_name)
9212                             _regedits[policy_name] = {"policy": _pol, "value": _value}
9213                         elif "Secedit" in _pol:
9214                             log.trace("%s is a Secedit policy", policy_name)
9215                             if _pol["Secedit"]["Section"] not in _secedits:
9216                                 _secedits[_pol["Secedit"]["Section"]] = []
9217                             _secedits[_pol["Secedit"]["Section"]].append(
9218                                 " ".join([_pol["Secedit"]["Option"], "=", str(_value)])
9219                             )
9220                         elif "NetSH" in _pol:
9221                             log.trace("%s is a NetSH policy", policy_name)
9222                             _netshs.setdefault(
9223                                 policy_name,
9224                                 {
9225                                     "profile": _pol["NetSH"]["Profile"],
9226                                     "section": _pol["NetSH"]["Section"],
9227                                     "option": _pol["NetSH"]["Option"],
9228                                     "value": str(_value),
9229                                 },
9230                             )
9231                         elif "AdvAudit" in _pol:
9232                             _advaudits.setdefault(
9233                                 policy_name,
9234                                 {
9235                                     "option": _pol["AdvAudit"]["Option"],
9236                                     "value": str(_value),
9237                                 },
9238                             )
9239                         elif "NetUserModal" in _pol:
9240                             log.trace("%s is a NetUserModal policy", policy_name)
9241                             if _pol["NetUserModal"]["Modal"] not in _modal_sets:
9242                                 _modal_sets[_pol["NetUserModal"]["Modal"]] = {}
9243                             _modal_sets[_pol["NetUserModal"]["Modal"]][
9244                                 _pol["NetUserModal"]["Option"]
9245                             ] = _value
9246                         elif "LsaRights" in _pol:
9247                             log.trace("%s is a LsaRights policy", policy_name)
9248                             _lsarights[policy_name] = {"policy": _pol, "value": _value}
9249                     else:
9250                         _value = policies[p_class][policy_name]
9251                         log.trace('searching for "%s" in admx data', policy_name)
9252                         (
9253                             success,
9254                             the_policy,
9255                             policy_name_list,
9256                             msg,
9257                         ) = _lookup_admin_template(
9258                             policy_name=policy_name,
9259                             policy_class=p_class,
9260                             adml_language=adml_language,
9261                         )
9262                         if success:
9263                             policy_name = the_policy.attrib["name"]
9264                             policy_namespace = the_policy.nsmap[the_policy.prefix]
9265                             if policy_namespace not in _admTemplateData:
9266                                 _admTemplateData[policy_namespace] = {}
9267                             _admTemplateData[policy_namespace][policy_name] = _value
9268                         else:
9269                             raise SaltInvocationError(msg)
9270                         if (
9271                             policy_namespace
9272                             and policy_name in _admTemplateData[policy_namespace]
9273                             and the_policy is not None
9274                         ):
9275                             log.trace(
9276                                 "setting == %s",
9277                                 str(
9278                                     _admTemplateData[policy_namespace][policy_name]
9279                                 ).lower(),
9280                             )
9281                             log.trace(
9282                                 str(
9283                                     _admTemplateData[policy_namespace][policy_name]
9284                                 ).lower()
9285                             )
9286                             if (
9287                                 str(
9288                                     _admTemplateData[policy_namespace][policy_name]
9289                                 ).lower()
9290                                 != "disabled"
9291                                 and str(
9292                                     _admTemplateData[policy_namespace][policy_name]
9293                                 ).lower()
9294                                 != "not configured"
9295                             ):
9296                                 if ELEMENTS_XPATH(the_policy):
9297                                     if isinstance(
9298                                         _admTemplateData[policy_namespace][policy_name],
9299                                         dict,
9300                                     ):
9301                                         for elements_item in ELEMENTS_XPATH(the_policy):
9302                                             for child_item in elements_item:
9303                                                 log.trace(
9304                                                     "checking element %s",
9305                                                     child_item.attrib["id"],
9306                                                 )
9307                                                 temp_element_name = None
9308                                                 this_element_name = _getFullPolicyName(
9309                                                     policy_item=child_item,
9310                                                     policy_name=child_item.attrib["id"],
9311                                                     return_full_policy_names=True,
9312                                                     adml_language=adml_language,
9313                                                 )
9314                                                 log.trace(
9315                                                     'id attribute == "%s" '
9316                                                     ' this_element_name == "%s"',
9317                                                     child_item.attrib["id"],
9318                                                     this_element_name,
9319                                                 )
9320                                                 if (
9321                                                     this_element_name
9322                                                     in _admTemplateData[
9323                                                         policy_namespace
9324                                                     ][policy_name]
9325                                                 ):
9326                                                     temp_element_name = (
9327                                                         this_element_name
9328                                                     )
9329                                                 elif (
9330                                                     child_item.attrib["id"]
9331                                                     in _admTemplateData[
9332                                                         policy_namespace
9333                                                     ][policy_name]
9334                                                 ):
9335                                                     temp_element_name = (
9336                                                         child_item.attrib["id"]
9337                                                     )
9338                                                 else:
9339                                                     raise SaltInvocationError(
9340                                                         'Element "{}" must be included'
9341                                                         " in the policy configuration"
9342                                                         " for policy {}".format(
9343                                                             this_element_name,
9344                                                             policy_name,
9345                                                         )
9346                                                     )
9347                                                 if (
9348                                                     "required" in child_item.attrib
9349                                                     and child_item.attrib[
9350                                                         "required"
9351                                                     ].lower()
9352                                                     == "true"
9353                                                 ):
9354                                                     if not _admTemplateData[
9355                                                         policy_namespace
9356                                                     ][policy_name][temp_element_name]:
9357                                                         raise SaltInvocationError(
9358                                                             'Element "{}" requires a value '
9359                                                             "to be specified".format(
9360                                                                 temp_element_name
9361                                                             )
9362                                                         )
9363                                                 if (
9364                                                     etree.QName(child_item).localname
9365                                                     == "boolean"
9366                                                 ):
9367                                                     if not isinstance(
9368                                                         _admTemplateData[
9369                                                             policy_namespace
9370                                                         ][policy_name][
9371                                                             temp_element_name
9372                                                         ],
9373                                                         bool,
9374                                                     ):
9375                                                         raise SaltInvocationError(
9376                                                             "Element {} requires a boolean "
9377                                                             "True or False".format(
9378                                                                 temp_element_name
9379                                                             )
9380                                                         )
9381                                                 elif (
9382                                                     etree.QName(child_item).localname
9383                                                     == "decimal"
9384                                                     or etree.QName(child_item).localname
9385                                                     == "longDecimal"
9386                                                 ):
9387                                                     min_val = 0
9388                                                     max_val = 9999
9389                                                     if "minValue" in child_item.attrib:
9390                                                         min_val = int(
9391                                                             child_item.attrib[
9392                                                                 "minValue"
9393                                                             ]
9394                                                         )
9395                                                     if "maxValue" in child_item.attrib:
9396                                                         max_val = int(
9397                                                             child_item.attrib[
9398                                                                 "maxValue"
9399                                                             ]
9400                                                         )
9401                                                     if (
9402                                                         int(
9403                                                             _admTemplateData[
9404                                                                 policy_namespace
9405                                                             ][policy_name][
9406                                                                 temp_element_name
9407                                                             ]
9408                                                         )
9409                                                         &lt; min_val
9410                                                         or int(
9411                                                             _admTemplateData[
9412                                                                 policy_namespace
9413                                                             ][policy_name][
9414                                                                 temp_element_name
9415                                                             ]
9416                                                         )
9417                                                         &gt; max_val
9418                                                     ):
9419                                                         raise SaltInvocationError(
9420                                                             'Element "{}" value must be between '
9421                                                             "{} and {}".format(
9422                                                                 temp_element_name,
9423                                                                 min_val,
9424                                                                 max_val,
9425                                                             )
9426                                                         )
9427                                                 elif (
9428                                                     etree.QName(child_item).localname
9429                                                     == "enum"
9430                                                 ):
9431                                                     found = False
9432                                                     for enum_item in child_item:
9433                                                         if (
9434                                                             _admTemplateData[
9435                                                                 policy_namespace
9436                                                             ][policy_name][
9437                                                                 temp_element_name
9438                                                             ]
9439                                                             == _getAdmlDisplayName(
9440                                                                 adml_policy_resources,
9441                                                                 enum_item.attrib[
9442                                                                     "displayName"
9443                                                                 ],
9444                                                             ).strip()
9445                                                         ):
9446                                                             found = True
9447                                                             break
9448                                                     if not found:
9449                                                         raise SaltInvocationError(
9450                                                             'Element "{}" does not have'
9451                                                             " a valid value".format(
9452                                                                 temp_element_name
9453                                                             )
9454                                                         )
9455                                                 elif (
9456                                                     etree.QName(child_item).localname
9457                                                     == "list"
9458                                                 ):
9459                                                     if (
9460                                                         "explicitValue"
9461                                                         in child_item.attrib
9462                                                         and child_item.attrib[
9463                                                             "explicitValue"
9464                                                         ].lower()
9465                                                         == "true"
9466                                                     ):
9467                                                         if not isinstance(
9468                                                             _admTemplateData[
9469                                                                 policy_namespace
9470                                                             ][policy_name][
9471                                                                 temp_element_name
9472                                                             ],
9473                                                             dict,
9474                                                         ):
9475                                                             raise SaltInvocationError(
9476                                                                 "Each list item of element "
9477                                                                 '"{}" requires a dict '
9478                                                                 "value".format(
9479                                                                     temp_element_name
9480                                                                 )
9481                                                             )
9482                                                     elif not isinstance(
9483                                                         _admTemplateData[
9484                                                             policy_namespace
9485                                                         ][policy_name][
9486                                                             temp_element_name
9487                                                         ],
9488                                                         list,
9489                                                     ):
9490                                                         raise SaltInvocationError(
9491                                                             'Element "{}" requires a'
9492                                                             " list value".format(
9493                                                                 temp_element_name
9494                                                             )
9495                                                         )
9496                                                 elif (
9497                                                     etree.QName(child_item).localname
9498                                                     == "multiText"
9499                                                 ):
9500                                                     if not isinstance(
9501                                                         _admTemplateData[
9502                                                             policy_namespace
9503                                                         ][policy_name][
9504                                                             temp_element_name
9505                                                         ],
9506                                                         list,
9507                                                     ):
9508                                                         raise SaltInvocationError(
9509                                                             'Element "{}" requires a'
9510                                                             " list value".format(
9511                                                                 temp_element_name
9512                                                             )
9513                                                         )
9514                                                 _admTemplateData[policy_namespace][
9515                                                     policy_name
9516                                                 ][
9517                                                     child_item.attrib["id"]
9518                                                 ] = _admTemplateData[
9519                                                     policy_namespace
9520                                                 ][
9521                                                     policy_name
9522                                                 ].pop(
9523                                                     temp_element_name
9524                                                 )
9525                                     else:
9526                                         raise SaltInvocationError(
9527                                             'The policy "{}" has elements which must be'
9528                                             " configured".format(policy_name)
9529                                         )
9530                                 else:
9531                                     if (
9532                                         str(
9533                                             _admTemplateData[policy_namespace][
9534                                                 policy_name
9535                                             ]
9536                                         ).lower()
9537                                         != "enabled"
9538                                     ):
9539                                         raise SaltInvocationError(
9540                                             'The policy {} must either be "Enabled", '
9541                                             '"Disabled", or "Not Configured"'.format(
9542                                                 policy_name
9543                                             )
9544                                         )
9545                 if _regedits:
9546                     for regedit in _regedits:
9547                         log.trace("%s is a Registry policy", regedit)
9548                         if (
9549                             _regedits[regedit]["value"] is not None
9550                             and _regedits[regedit]["value"] != "(value not set)"
9551                         ):
9552                             _ret = __utils__["reg.set_value"](
9553                                 _regedits[regedit]["policy"]["Registry"]["Hive"],
9554                                 _regedits[regedit]["policy"]["Registry"]["Path"],
9555                                 _regedits[regedit]["policy"]["Registry"]["Value"],
9556                                 _regedits[regedit]["value"],
9557                                 _regedits[regedit]["policy"]["Registry"]["Type"],
9558                             )
9559                         else:
9560                             _ret = __utils__["reg.read_value"](
9561                                 _regedits[regedit]["policy"]["Registry"]["Hive"],
9562                                 _regedits[regedit]["policy"]["Registry"]["Path"],
9563                                 _regedits[regedit]["policy"]["Registry"]["Value"],
9564                             )
9565                             if _ret["success"] and _ret["vdata"] != "(value not set)":
9566                                 _ret = __utils__["reg.delete_value"](
9567                                     _regedits[regedit]["policy"]["Registry"]["Hive"],
9568                                     _regedits[regedit]["policy"]["Registry"]["Path"],
9569                                     _regedits[regedit]["policy"]["Registry"]["Value"],
9570                                 )
9571                         if not _ret:
9572                             raise CommandExecutionError(
9573                                 "Error while attempting to set policy {} via the"
9574                                 " registry.  Some changes may not be applied as"
9575                                 " expected".format(regedit)
9576                             )
9577                 if _lsarights:
9578                     for lsaright in _lsarights:
9579                         _existingUsers = None
9580                         if not cumulative_rights_assignments:
9581                             _existingUsers = _getRightsAssignments(
9582                                 _lsarights[lsaright]["policy"]["LsaRights"]["Option"]
9583                             )
9584                         if _lsarights[lsaright]["value"]:
9585                             for acct in _lsarights[lsaright]["value"]:
9586                                 _ret = _addAccountRights(
9587                                     acct,
9588                                     _lsarights[lsaright]["policy"]["LsaRights"][
9589                                         "Option"
9590                                     ],
9591                                 )
9592                                 if not _ret:
9593                                     raise SaltInvocationError(
9594                                         "An error occurred attempting to configure the"
9595                                         " user right {}.".format(lsaright)
9596                                     )
9597                         if _existingUsers:
9598                             for acct in _existingUsers:
9599                                 if acct not in _lsarights[lsaright]["value"]:
9600                                     _ret = _delAccountRights(
9601                                         acct,
9602                                         _lsarights[lsaright]["policy"]["LsaRights"][
9603                                             "Option"
9604                                         ],
9605                                     )
9606                                     if not _ret:
9607                                         raise SaltInvocationError(
9608                                             "An error occurred attempting to remove previously "
9609                                             "configured users with right {}.".format(
9610                                                 lsaright
9611                                             )
9612                                         )
9613                 if _secedits:
9614                     log.trace(_secedits)
9615                     ini_data = "\r\n".join(["[Unicode]", "Unicode=yes"])
9616                     _seceditSections = [
9617                         "System Access",
9618                         "Event Audit",
9619                         "Registry Values",
9620                         "Privilege Rights",
9621                     ]
9622                     for _seceditSection in _seceditSections:
9623                         if _seceditSection in _secedits:
9624                             ini_data = "\r\n".join(
9625                                 [
9626                                     ini_data,
9627                                     "".join(["[", _seceditSection, "]"]),
9628                                     "\r\n".join(_secedits[_seceditSection]),
9629                                 ]
9630                             )
9631                     ini_data = "\r\n".join(
9632                         [ini_data, "[Version]", 'signature="$CHICAGO$"', "Revision=1"]
9633                     )
9634                     log.trace("ini_data == %s", ini_data)
9635                     if not _write_secedit_data(ini_data):
9636                         raise CommandExecutionError(
9637                             "Error while attempting to set policies via "
9638                             "secedit. Some changes may not be applied as "
9639                             "expected"
9640                         )
9641                 if _netshs:
9642                     for setting in _netshs:
9643                         log.trace("Setting firewall policy: %s", setting)
9644                         log.trace(_netshs[setting])
9645                         _set_netsh_value(**_netshs[setting])
9646                 if _advaudits:
9647                     for setting in _advaudits:
9648                         log.trace("Setting Advanced Audit policy: %s", setting)
9649                         log.trace(_advaudits[setting])
9650                         _set_advaudit_value(**_advaudits[setting])
9651                 if _modal_sets:
9652                     log.trace(_modal_sets)
9653                     for _modal_set in _modal_sets:
9654                         try:
9655                             _existingModalData = win32net.NetUserModalsGet(
9656                                 None, _modal_set
9657                             )
9658                             _newModalSetData = dictupdate.update(
9659                                 _existingModalData, _modal_sets[_modal_set]
9660                             )
9661                             log.trace("NEW MODAL SET = %s", _newModalSetData)
9662                             _ret = win32net.NetUserModalsSet(
9663                                 None, _modal_set, _newModalSetData
9664                             )
9665                         except Exception as exc:  # pylint: disable=broad-except
9666                             msg = (
9667                                 "An unhandled exception occurred while "
9668                                 "attempting to set policy via "
9669                                 "NetUserModalSet\n{}".format(exc)
9670                             )
9671                             log.exception(msg)
9672                             raise CommandExecutionError(msg)
9673                 if _admTemplateData:
9674                     _ret = False
9675                     log.trace(
9676                         "going to write some adm template data :: %s", _admTemplateData
9677                     )
9678                     _ret = _writeAdminTemplateRegPolFile(
9679                         _admTemplateData,
9680                         adml_language=adml_language,
9681                         registry_class=p_class,
9682                     )
9683                     if not _ret:
9684                         raise CommandExecutionError(
9685                             "Error while attempting to write Administrative Template"
9686                             " Policy data.  Some changes may not be applied as expected"
9687                         )
9688         return True
9689     else:
9690         raise SaltInvocationError("You have to specify something!")
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
