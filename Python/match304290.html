<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for digitalocean.py &amp; win_lgpo_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for digitalocean.py &amp; win_lgpo_1.py
      </h3>
<h1 align="center">
        0.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>digitalocean.py (0.7528231%)<th>win_lgpo_1.py (0.13489209%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1022-1026)<td><a href="#" name="0">(428-451)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>digitalocean.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import decimal
2 import logging
3 import os
4 import pprint
5 import time
6 import salt.config as config
7 import salt.utils.cloud
8 import salt.utils.files
9 import salt.utils.json
10 import salt.utils.stringutils
11 from salt.exceptions import (
12     SaltCloudConfigError,
13     SaltCloudExecutionFailure,
14     SaltCloudExecutionTimeout,
15     SaltCloudNotFound,
16     SaltCloudSystemExit,
17     SaltInvocationError,
18 )
19 try:
20     import requests
21     HAS_REQUESTS = True
22 except ImportError:
23     HAS_REQUESTS = False
24 log = logging.getLogger(__name__)
25 __virtualname__ = "digitalocean"
26 __virtual_aliases__ = ("digital_ocean", "do")
27 def __virtual__():
28     if get_configured_provider() is False:
29         return False
30     if get_dependencies() is False:
31         return False
32     return __virtualname__
33 def _get_active_provider_name():
34     try:
35         return __active_provider_name__.value()
36     except AttributeError:
37         return __active_provider_name__
38 def get_configured_provider():
39     return config.is_provider_configured(
40         opts=__opts__,
41         provider=_get_active_provider_name() or __virtualname__,
42         aliases=__virtual_aliases__,
43         required_keys=("personal_access_token",),
44     )
45 def get_dependencies():
46     return config.check_driver_dependencies(__virtualname__, {"requests": HAS_REQUESTS})
47 def avail_locations(call=None):
48     if call == "action":
49         raise SaltCloudSystemExit(
50             "The avail_locations function must be called with "
51             "-f or --function, or with the --list-locations option"
52         )
53     items = query(method="regions")
54     ret = {}
55     for region in items["regions"]:
56         ret[region["name"]] = {}
57         for item in region.keys():
58             ret[region["name"]][item] = str(region[item])
59     return ret
60 def avail_images(call=None):
61     if call == "action":
62         raise SaltCloudSystemExit(
63             "The avail_images function must be called with "
64             "-f or --function, or with the --list-images option"
65         )
66     fetch = True
67     page = 1
68     ret = {}
69     while fetch:
70         items = query(method="images", command="?page=" + str(page) + "&amp;per_page=200")
71         for image in items["images"]:
72             ret[image["name"]] = {}
73             for item in image.keys():
74                 ret[image["name"]][item] = image[item]
75         page += 1
76         try:
77             fetch = "next" in items["links"]["pages"]
78         except KeyError:
79             fetch = False
80     return ret
81 def avail_sizes(call=None):
82     if call == "action":
83         raise SaltCloudSystemExit(
84             "The avail_sizes function must be called with "
85             "-f or --function, or with the --list-sizes option"
86         )
87     items = query(method="sizes", command="?per_page=100")
88     ret = {}
89     for size in items["sizes"]:
90         ret[size["slug"]] = {}
91         for item in size.keys():
92             ret[size["slug"]][item] = str(size[item])
93     return ret
94 def list_nodes(call=None):
95     if call == "action":
96         raise SaltCloudSystemExit(
97             "The list_nodes function must be called with -f or --function."
98         )
99     return _list_nodes()
100 def list_nodes_full(call=None, for_output=True):
101     if call == "action":
102         raise SaltCloudSystemExit(
103             "The list_nodes_full function must be called with -f or --function."
104         )
105     return _list_nodes(full=True, for_output=for_output)
106 def list_nodes_select(call=None):
107     return salt.utils.cloud.list_nodes_select(
108         list_nodes_full("function"),
109         __opts__["query.selection"],
110         call,
111     )
112 def get_image(vm_):
113     images = avail_images()
114     vm_image = config.get_cloud_config_value(
115         "image", vm_, __opts__, search_global=False
116     )
117     if not isinstance(vm_image, str):
118         vm_image = str(vm_image)
119     for image in images:
120         if vm_image in (
121             images[image]["name"],
122             images[image]["slug"],
123             images[image]["id"],
124         ):
125             if images[image]["slug"] is not None:
126                 return images[image]["slug"]
127             return int(images[image]["id"])
128     raise SaltCloudNotFound(
129         "The specified image, '{}', could not be found.".format(vm_image)
130     )
131 def get_size(vm_):
132     sizes = avail_sizes()
133     vm_size = str(
134         config.get_cloud_config_value("size", vm_, __opts__, search_global=False)
135     )
136     for size in sizes:
137         if vm_size.lower() == sizes[size]["slug"]:
138             return sizes[size]["slug"]
139     raise SaltCloudNotFound(
140         "The specified size, '{}', could not be found.".format(vm_size)
141     )
142 def get_location(vm_):
143     locations = avail_locations()
144     vm_location = str(
145         config.get_cloud_config_value("location", vm_, __opts__, search_global=False)
146     )
147     for location in locations:
148         if vm_location in (locations[location]["name"], locations[location]["slug"]):
149             return locations[location]["slug"]
150     raise SaltCloudNotFound(
151         "The specified location, '{}', could not be found.".format(vm_location)
152     )
153 def create_node(args):
154     node = query(method="droplets", args=args, http_method="post")
155     return node
156 def create(vm_):
157     try:
158         if (
159             vm_["profile"]
160             and config.is_profile_configured(
161                 __opts__,
162                 _get_active_provider_name() or "digitalocean",
163                 vm_["profile"],
164                 vm_=vm_,
165             )
166             is False
167         ):
168             return False
169     except AttributeError:
170         pass
171     __utils__["cloud.fire_event"](
172         "event",
173         "starting create",
174         "salt/cloud/{}/creating".format(vm_["name"]),
175         args=__utils__["cloud.filter_event"](
176             "creating", vm_, ["name", "profile", "provider", "driver"]
177         ),
178         sock_dir=__opts__["sock_dir"],
179         transport=__opts__["transport"],
180     )
181     log.info("Creating Cloud VM %s", vm_["name"])
182     kwargs = {
183         "name": vm_["name"],
184         "size": get_size(vm_),
185         "image": get_image(vm_),
186         "region": get_location(vm_),
187         "ssh_keys": [],
188         "tags": [],
189     }
190     ssh_key_name = config.get_cloud_config_value(
191         "ssh_key_name", vm_, __opts__, search_global=False
192     )
193     if ssh_key_name:
194         kwargs["ssh_keys"].append(get_keyid(ssh_key_name))
195     ssh_key_names = config.get_cloud_config_value(
196         "ssh_key_names", vm_, __opts__, search_global=False, default=False
197     )
198     if ssh_key_names:
199         for key in ssh_key_names.split(","):
200             kwargs["ssh_keys"].append(get_keyid(key))
201     key_filename = config.get_cloud_config_value(
202         "ssh_key_file", vm_, __opts__, search_global=False, default=None
203     )
204     if key_filename is not None and not os.path.isfile(key_filename):
205         raise SaltCloudConfigError(
206             "The defined key_filename '{}' does not exist".format(key_filename)
207         )
208     if not __opts__.get("ssh_agent", False) and key_filename is None:
209         raise SaltCloudConfigError(
210             "The DigitalOcean driver requires an ssh_key_file and an ssh_key_name "
211             "because it does not supply a root password upon building the server."
212         )
213     ssh_interface = config.get_cloud_config_value(
214         "ssh_interface", vm_, __opts__, search_global=False, default="public"
215     )
216     if ssh_interface in ["private", "public"]:
217         log.info("ssh_interface: Setting interface for ssh to %s", ssh_interface)
218         kwargs["ssh_interface"] = ssh_interface
219     else:
220         raise SaltCloudConfigError(
221             "The DigitalOcean driver requires ssh_interface to be defined as 'public'"
222             " or 'private'."
223         )
224     private_networking = config.get_cloud_config_value(
225         "private_networking",
226         vm_,
227         __opts__,
228         search_global=False,
229         default=None,
230     )
231     if private_networking is not None:
232         if not isinstance(private_networking, bool):
233             raise SaltCloudConfigError(
234                 "'private_networking' should be a boolean value."
235             )
236         kwargs["private_networking"] = private_networking
237     if not private_networking and ssh_interface == "private":
238         raise SaltCloudConfigError(
239             "The DigitalOcean driver requires ssh_interface if defined as 'private' "
240             "then private_networking should be set as 'True'."
241         )
242     backups_enabled = config.get_cloud_config_value(
243         "backups_enabled",
244         vm_,
245         __opts__,
246         search_global=False,
247         default=None,
248     )
249     if backups_enabled is not None:
250         if not isinstance(backups_enabled, bool):
251             raise SaltCloudConfigError("'backups_enabled' should be a boolean value.")
252         kwargs["backups"] = backups_enabled
253     ipv6 = config.get_cloud_config_value(
254         "ipv6",
255         vm_,
256         __opts__,
257         search_global=False,
258         default=None,
259     )
260     if ipv6 is not None:
261         if not isinstance(ipv6, bool):
262             raise SaltCloudConfigError("'ipv6' should be a boolean value.")
263         kwargs["ipv6"] = ipv6
264     monitoring = config.get_cloud_config_value(
265         "monitoring",
266         vm_,
267         __opts__,
268         search_global=False,
269         default=None,
270     )
271     if monitoring is not None:
272         if not isinstance(monitoring, bool):
273             raise SaltCloudConfigError("'monitoring' should be a boolean value.")
274         kwargs["monitoring"] = monitoring
275     kwargs["tags"] = config.get_cloud_config_value(
276         "tags", vm_, __opts__, search_global=False, default=False
277     )
278     userdata_file = config.get_cloud_config_value(
279         "userdata_file", vm_, __opts__, search_global=False, default=None
280     )
281     if userdata_file is not None:
282         try:
283             with salt.utils.files.fopen(userdata_file, "r") as fp_:
284                 kwargs["user_data"] = salt.utils.cloud.userdata_template(
285                     __opts__, vm_, salt.utils.stringutils.to_unicode(fp_.read())
286                 )
287         except Exception as exc:  # pylint: disable=broad-except
288             log.exception("Failed to read userdata from %s: %s", userdata_file, exc)
289     create_dns_record = config.get_cloud_config_value(
290         "create_dns_record",
291         vm_,
292         __opts__,
293         search_global=False,
294         default=None,
295     )
296     if create_dns_record:
297         log.info("create_dns_record: will attempt to write DNS records")
298         default_dns_domain = None
299         dns_domain_name = vm_["name"].split(".")
300         if len(dns_domain_name) &gt; 2:
301             log.debug(
302                 "create_dns_record: inferring default dns_hostname, dns_domain from"
303                 " minion name as FQDN"
304             )
305             default_dns_hostname = ".".join(dns_domain_name[:-2])
306             default_dns_domain = ".".join(dns_domain_name[-2:])
307         else:
308             log.debug("create_dns_record: can't infer dns_domain from %s", vm_["name"])
309             default_dns_hostname = dns_domain_name[0]
310         dns_hostname = config.get_cloud_config_value(
311             "dns_hostname",
312             vm_,
313             __opts__,
314             search_global=False,
315             default=default_dns_hostname,
316         )
317         dns_domain = config.get_cloud_config_value(
318             "dns_domain",
319             vm_,
320             __opts__,
321             search_global=False,
322             default=default_dns_domain,
323         )
324         if dns_hostname and dns_domain:
325             log.info(
326                 'create_dns_record: using dns_hostname="%s", dns_domain="%s"',
327                 dns_hostname,
328                 dns_domain,
329             )
330             __add_dns_addr__ = lambda t, d: post_dns_record(
331                 dns_domain=dns_domain, name=dns_hostname, record_type=t, record_data=d
332             )
333             log.debug("create_dns_record: %s", __add_dns_addr__)
334         else:
335             log.error(
336                 "create_dns_record: could not determine dns_hostname and/or dns_domain"
337             )
338             raise SaltCloudConfigError(
339                 "'create_dns_record' must be a dict specifying \"domain\" "
340                 'and "hostname" or the minion name must be an FQDN.'
341             )
342     __utils__["cloud.fire_event"](
343         "event",
344         "requesting instance",
345         "salt/cloud/{}/requesting".format(vm_["name"]),
346         args=__utils__["cloud.filter_event"]("requesting", kwargs, list(kwargs)),
347         sock_dir=__opts__["sock_dir"],
348         transport=__opts__["transport"],
349     )
350     try:
351         ret = create_node(kwargs)
352     except Exception as exc:  # pylint: disable=broad-except
353         log.error(
354             "Error creating %s on DIGITALOCEAN\n\n"
355             "The following exception was thrown when trying to "
356             "run the initial deployment: %s",
357             vm_["name"],
358             exc,
359             exc_info_on_loglevel=logging.DEBUG,
360         )
361         return False
362     def __query_node_data(vm_name):
363         data = show_instance(vm_name, "action")
364         if not data:
365             return False
366         if data["networks"].get("v4"):
367             for network in data["networks"]["v4"]:
368                 if network["type"] == "public":
369                     return data
370         return False
371     try:
372         data = salt.utils.cloud.wait_for_ip(
373             __query_node_data,
374             update_args=(vm_["name"],),
375             timeout=config.get_cloud_config_value(
376                 "wait_for_ip_timeout", vm_, __opts__, default=10 * 60
377             ),
378             interval=config.get_cloud_config_value(
379                 "wait_for_ip_interval", vm_, __opts__, default=10
380             ),
381         )
382     except (SaltCloudExecutionTimeout, SaltCloudExecutionFailure) as exc:
383         try:
384             destroy(vm_["name"])
385         except SaltCloudSystemExit:
386             pass
387         finally:
388             raise SaltCloudSystemExit(str(exc))
389     if not vm_.get("ssh_host"):
390         vm_["ssh_host"] = None
391     addr_families, dns_arec_types = (("v4", "v6"), ("A", "AAAA"))
392     arec_map = dict(list(zip(addr_families, dns_arec_types)))
393     for facing, addr_family, ip_address in [
394         (net["type"], family, net["ip_address"])
395         for family in addr_families
396         for net in data["networks"][family]
397     ]:
398         log.info('found %s IP%s interface for "%s"', facing, addr_family, ip_address)
399         dns_rec_type = arec_map[addr_family]
400         if facing == "public":
401             if create_dns_record:
402                 __add_dns_addr__(dns_rec_type, ip_address)
403         if facing == ssh_interface:
404             if not vm_["ssh_host"]:
405                 vm_["ssh_host"] = ip_address
406     if vm_["ssh_host"] is None:
407         raise SaltCloudSystemExit(
408             "No suitable IP addresses found for ssh minion bootstrapping: {}".format(
409                 repr(data["networks"])
410             )
411         )
412     log.debug(
413         "Found public IP address to use for ssh minion bootstrapping: %s",
414         vm_["ssh_host"],
415     )
416     vm_["key_filename"] = key_filename
417     ret = __utils__["cloud.bootstrap"](vm_, __opts__)
418     ret.update(data)
419     log.info("Created Cloud VM '%s'", vm_["name"])
420     log.debug("'%s' VM creation details:\n%s", vm_["name"], pprint.pformat(data))
421     __utils__["cloud.fire_event"](
422         "event",
423         "created instance",
424         "salt/cloud/{}/created".format(vm_["name"]),
425         args=__utils__["cloud.filter_event"](
426             "created", vm_, ["name", "profile", "provider", "driver"]
427         ),
428         sock_dir=__opts__["sock_dir"],
429         transport=__opts__["transport"],
430     )
431     return ret
432 def query(
433     method="droplets", droplet_id=None, command=None, args=None, http_method="get"
434 ):
435     base_path = str(
436         config.get_cloud_config_value(
437             "api_root",
438             get_configured_provider(),
439             __opts__,
440             search_global=False,
441             default="https://api.digitalocean.com/v2",
442         )
443     )
444     path = "{}/{}/".format(base_path, method)
445     if droplet_id:
446         path += "{}/".format(droplet_id)
447     if command:
448         path += command
449     if not isinstance(args, dict):
450         args = {}
451     personal_access_token = config.get_cloud_config_value(
452         "personal_access_token",
453         get_configured_provider(),
454         __opts__,
455         search_global=False,
456     )
457     data = salt.utils.json.dumps(args)
458     requester = getattr(requests, http_method)
459     request = requester(
460         path,
461         data=data,
462         headers={
463             "Authorization": "Bearer " + personal_access_token,
464             "Content-Type": "application/json",
465         },
466     )
467     if request.status_code &gt; 299:
468         raise SaltCloudSystemExit(
469             "An error occurred while querying DigitalOcean. HTTP Code: {}  "
470             "Error: '{}'".format(
471                 request.status_code,
472                 request.text,
473             )
474         )
475     log.debug(request.url)
476     if request.status_code == 204:
477         return True
478     content = request.text
479     result = salt.utils.json.loads(content)
480     if result.get("status", "").lower() == "error":
481         raise SaltCloudSystemExit(pprint.pformat(result.get("error_message", {})))
482     return result
483 def script(vm_):
484     deploy_script = salt.utils.cloud.os_script(
485         config.get_cloud_config_value("script", vm_, __opts__),
486         vm_,
487         __opts__,
488         salt.utils.cloud.salt_config_to_yaml(
489             salt.utils.cloud.minion_config(__opts__, vm_)
490         ),
491     )
492     return deploy_script
493 def show_instance(name, call=None):
494     if call != "action":
495         raise SaltCloudSystemExit(
496             "The show_instance action must be called with -a or --action."
497         )
498     node = _get_node(name)
499     __utils__["cloud.cache_node"](node, _get_active_provider_name(), __opts__)
500     return node
501 def _get_node(name):
502     attempts = 10
503     while attempts &gt;= 0:
504         try:
505             return list_nodes_full(for_output=False)[name]
506         except KeyError:
507             attempts -= 1
508             log.debug(
509                 "Failed to get the data for node '%s'. Remaining attempts: %s",
510                 name,
511                 attempts,
512             )
513             time.sleep(0.5)
514     return {}
515 def list_keypairs(call=None):
516     if call != "function":
517         log.error("The list_keypairs function must be called with -f or --function.")
518         return False
519     fetch = True
520     page = 1
521     ret = {}
522     while fetch:
523         items = query(
524             method="account/keys",
525             command="?page=" + str(page) + "&amp;per_page=100",
526         )
527         for key_pair in items["ssh_keys"]:
528             name = key_pair["name"]
529             if name in ret:
530                 raise SaltCloudSystemExit(
531                     "A duplicate key pair name, '{}', was found in DigitalOcean's "
532                     "key pair list. Please change the key name stored by DigitalOcean. "
533                     "Be sure to adjust the value of 'ssh_key_file' in your cloud "
534                     "profile or provider configuration, if necessary.".format(name)
535                 )
536             ret[name] = {}
537             for item in key_pair.keys():
538                 ret[name][item] = str(key_pair[item])
539         page += 1
540         try:
541             fetch = "next" in items["links"]["pages"]
542         except KeyError:
543             fetch = False
544     return ret
545 def show_keypair(kwargs=None, call=None):
546     if call != "function":
547         log.error("The show_keypair function must be called with -f or --function.")
548         return False
549     if not kwargs:
550         kwargs = {}
551     if "keyname" not in kwargs:
552         log.error("A keyname is required.")
553         return False
554     keypairs = list_keypairs(call="function")
555     keyid = keypairs[kwargs["keyname"]]["id"]
556     log.debug("Key ID is %s", keyid)
557     details = query(method="account/keys", command=keyid)
558     return details
559 def import_keypair(kwargs=None, call=None):
560     with salt.utils.files.fopen(kwargs["file"], "r") as public_key_filename:
561         public_key_content = salt.utils.stringutils.to_unicode(
562             public_key_filename.read()
563         )
564     digitalocean_kwargs = {"name": kwargs["keyname"], "public_key": public_key_content}
565     created_result = create_key(digitalocean_kwargs, call=call)
566     return created_result
567 def create_key(kwargs=None, call=None):
568     if call != "function":
569         log.error("The create_key function must be called with -f or --function.")
570         return False
571     try:
572         result = query(
573             method="account",
574             command="keys",
575             args={"name": kwargs["name"], "public_key": kwargs["public_key"]},
576             http_method="post",
577         )
578     except KeyError:
579         log.info("`name` and `public_key` arguments must be specified")
580         return False
581     return result
582 def remove_key(kwargs=None, call=None):
583     if call != "function":
584         log.error("The create_key function must be called with -f or --function.")
585         return False
586     try:
587         result = query(
588             method="account", command="keys/" + kwargs["id"], http_method="delete"
589         )
590     except KeyError:
591         log.info("`id` argument must be specified")
592         return False
593     return result
594 def get_keyid(keyname):
595     if not keyname:
596         return None
597     keypairs = list_keypairs(call="function")
598     keyid = keypairs[keyname]["id"]
599     if keyid:
600         return keyid
601     raise SaltCloudNotFound("The specified ssh key could not be found.")
602 def destroy(name, call=None):
603     if call == "function":
604         raise SaltCloudSystemExit(
605             "The destroy action must be called with -d, --destroy, -a or --action."
606         )
607     __utils__["cloud.fire_event"](
608         "event",
609         "destroying instance",
610         "salt/cloud/{}/destroying".format(name),
611         args={"name": name},
612         sock_dir=__opts__["sock_dir"],
613         transport=__opts__["transport"],
614     )
615     data = show_instance(name, call="action")
616     node = query(method="droplets", droplet_id=data["id"], http_method="delete")
617     delete_dns_record = True
618     if not isinstance(delete_dns_record, bool):
619         raise SaltCloudConfigError("'delete_dns_record' should be a boolean value.")
620     log.debug("Deleting DNS records for %s.", name)
621     destroy_dns_records(name)
622     __utils__["cloud.fire_event"](
623         "event",
624         "destroyed instance",
625         "salt/cloud/{}/destroyed".format(name),
626         args={"name": name},
627         sock_dir=__opts__["sock_dir"],
628         transport=__opts__["transport"],
629     )
630     if __opts__.get("update_cachedir", False) is True:
631         __utils__["cloud.delete_minion_cachedir"](
632             name, _get_active_provider_name().split(":")[0], __opts__
633         )
634     return node
635 def post_dns_record(**kwargs):
636     if "kwargs" in kwargs:  # flatten kwargs if called via salt-cloud -f
637         f_kwargs = kwargs["kwargs"]
638         del kwargs["kwargs"]
639         kwargs.update(f_kwargs)
640     mandatory_kwargs = ("dns_domain", "name", "record_type", "record_data")
641     for i in mandatory_kwargs:
642         if kwargs[i]:
643             pass
644         else:
645             error = '{}="{}" ## all mandatory args must be provided: {}'.format(
646                 i, kwargs[i], mandatory_kwargs
647             )
648             raise SaltInvocationError(error)
649     domain = query(method="domains", droplet_id=kwargs["dns_domain"])
650     if domain:
651         result = query(
652             method="domains",
653             droplet_id=kwargs["dns_domain"],
654             command="records",
655             args={
656                 "type": kwargs["record_type"],
657                 "name": kwargs["name"],
658                 "data": kwargs["record_data"],
659             },
660             http_method="post",
661         )
662         return result
663     return False
664 def destroy_dns_records(fqdn):
665     domain = ".".join(fqdn.split(".")[-2:])
666     hostname = ".".join(fqdn.split(".")[:-2])
667     try:
668         response = query(method="domains", droplet_id=domain, command="records")
669     except SaltCloudSystemExit:
670         log.debug("Failed to find domains.")
671         return False
672     log.debug("found DNS records: %s", pprint.pformat(response))
673     records = response["domain_records"]
674     if records:
675         record_ids = [r["id"] for r in records if r["name"].decode() == hostname]
676         log.debug("deleting DNS record IDs: %s", record_ids)
677         for id_ in record_ids:
678             try:
679                 log.info("deleting DNS record %s", id_)
680                 ret = query(
681                     method="domains",
682                     droplet_id=domain,
683                     command="records/{}".format(id_),
684                     http_method="delete",
685                 )
686             except SaltCloudSystemExit:
687                 log.error(
688                     "failed to delete DNS domain %s record ID %s.", domain, hostname
689                 )
690             log.debug("DNS deletion REST call returned: %s", pprint.pformat(ret))
691     return False
692 def show_pricing(kwargs=None, call=None):
693     profile = __opts__["profiles"].get(kwargs["profile"], {})
694     if not profile:
695         return {"Error": "The requested profile was not found"}
696     provider = profile.get("provider", "0:0")
697     comps = provider.split(":")
698     if len(comps) &lt; 2 or comps[1] != "digitalocean":
699         return {"Error": "The requested profile does not belong to DigitalOcean"}
700 <a name="0"></a>    raw = {}
701     ret = {}
702     sizes = avail_sizes()
703     ret["per_hour"] = decimal.Decimal(sizes<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>[profile["size"]]["price_hourly"])
704     ret["per_day"] = ret["per_hour"] * 24
705     ret["per_week"] = ret["per_day"] * 7
706     ret["per_month"] = decimal.</b></font>Decimal(sizes[profile["size"]]["price_monthly"])
707     ret["per_year"] = ret["per_week"] * 52
708     if kwargs.get("raw", False):
709         ret["_raw"] = raw
710     return {profile["profile"]: ret}
711 def list_floating_ips(call=None):
712     if call == "action":
713         raise SaltCloudSystemExit(
714             "The list_floating_ips function must be called with "
715             "-f or --function, or with the --list-floating-ips option"
716         )
717     fetch = True
718     page = 1
719     ret = {}
720     while fetch:
721         items = query(
722             method="floating_ips",
723             command="?page=" + str(page) + "&amp;per_page=200",
724         )
725         for floating_ip in items["floating_ips"]:
726             ret[floating_ip["ip"]] = {}
727             for item in floating_ip.keys():
728                 ret[floating_ip["ip"]][item] = floating_ip[item]
729         page += 1
730         try:
731             fetch = "next" in items["links"]["pages"]
732         except KeyError:
733             fetch = False
734     return ret
735 def show_floating_ip(kwargs=None, call=None):
736     if call != "function":
737         log.error("The show_floating_ip function must be called with -f or --function.")
738         return False
739     if not kwargs:
740         kwargs = {}
741     if "floating_ip" not in kwargs:
742         log.error("A floating IP is required.")
743         return False
744     floating_ip = kwargs["floating_ip"]
745     log.debug("Floating ip is %s", floating_ip)
746     details = query(method="floating_ips", command=floating_ip)
747     return details
748 def create_floating_ip(kwargs=None, call=None):
749     if call != "function":
750         log.error(
751             "The create_floating_ip function must be called with -f or --function."
752         )
753         return False
754     if not kwargs:
755         kwargs = {}
756     if "droplet_id" in kwargs:
757         result = query(
758             method="floating_ips",
759             args={"droplet_id": kwargs["droplet_id"]},
760             http_method="post",
761         )
762         return result
763     elif "region" in kwargs:
764         result = query(
765             method="floating_ips", args={"region": kwargs["region"]}, http_method="post"
766         )
767         return result
768     else:
769         log.error("A droplet_id or region is required.")
770         return False
771 def delete_floating_ip(kwargs=None, call=None):
772     if call != "function":
773         log.error(
774             "The delete_floating_ip function must be called with -f or --function."
775         )
776         return False
777     if not kwargs:
778         kwargs = {}
779     if "floating_ip" not in kwargs:
780         log.error("A floating IP is required.")
781         return False
782     floating_ip = kwargs["floating_ip"]
783     log.debug("Floating ip is %s", kwargs["floating_ip"])
784     result = query(method="floating_ips", command=floating_ip, http_method="delete")
785     return result
786 def assign_floating_ip(kwargs=None, call=None):
787     if call != "function":
788         log.error(
789             "The assign_floating_ip function must be called with -f or --function."
790         )
791         return False
792     if not kwargs:
793         kwargs = {}
794     if "floating_ip" and "droplet_id" not in kwargs:
795         log.error("A floating IP and droplet_id is required.")
796         return False
797     result = query(
798         method="floating_ips",
799         command=kwargs["floating_ip"] + "/actions",
800         args={"droplet_id": kwargs["droplet_id"], "type": "assign"},
801         http_method="post",
802     )
803     return result
804 def unassign_floating_ip(kwargs=None, call=None):
805     if call != "function":
806         log.error(
807             "The inassign_floating_ip function must be called with -f or --function."
808         )
809         return False
810     if not kwargs:
811         kwargs = {}
812     if "floating_ip" not in kwargs:
813         log.error("A floating IP is required.")
814         return False
815     result = query(
816         method="floating_ips",
817         command=kwargs["floating_ip"] + "/actions",
818         args={"type": "unassign"},
819         http_method="post",
820     )
821     return result
822 def _list_nodes(full=False, for_output=False):
823     fetch = True
824     page = 1
825     ret = {}
826     while fetch:
827         items = query(method="droplets", command="?page=" + str(page) + "&amp;per_page=200")
828         for node in items["droplets"]:
829             name = node["name"]
830             ret[name] = {}
831             if full:
832                 ret[name] = _get_full_output(node, for_output=for_output)
833             else:
834                 public_ips, private_ips = _get_ips(node["networks"])
835                 ret[name] = {
836                     "id": node["id"],
837                     "image": node["image"]["name"],
838                     "name": name,
839                     "private_ips": private_ips,
840                     "public_ips": public_ips,
841                     "size": node["size_slug"],
842                     "state": str(node["status"]),
843                 }
844         page += 1
845         try:
846             fetch = "next" in items["links"]["pages"]
847         except KeyError:
848             fetch = False
849     return ret
850 def reboot(name, call=None):
851     if call != "action":
852         raise SaltCloudSystemExit(
853             "The reboot action must be called with -a or --action."
854         )
855     data = show_instance(name, call="action")
856     if data.get("status") == "off":
857         return {
858             "success": True,
859             "action": "stop",
860             "status": "off",
861             "msg": "Machine is already off.",
862         }
863     ret = query(
864         droplet_id=data["id"],
865         command="actions",
866         args={"type": "reboot"},
867         http_method="post",
868     )
869     return {
870         "success": True,
871         "action": ret["action"]["type"],
872         "state": ret["action"]["status"],
873     }
874 def start(name, call=None):
875     if call != "action":
876         raise SaltCloudSystemExit(
877             "The start action must be called with -a or --action."
878         )
879     data = show_instance(name, call="action")
880     if data.get("status") == "active":
881         return {
882             "success": True,
883             "action": "start",
884             "status": "active",
885             "msg": "Machine is already running.",
886         }
887     ret = query(
888         droplet_id=data["id"],
889         command="actions",
890         args={"type": "power_on"},
891         http_method="post",
892     )
893     return {
894         "success": True,
895         "action": ret["action"]["type"],
896         "state": ret["action"]["status"],
897     }
898 def stop(name, call=None):
899     if call != "action":
900         raise SaltCloudSystemExit("The stop action must be called with -a or --action.")
901     data = show_instance(name, call="action")
902     if data.get("status") == "off":
903         return {
904             "success": True,
905             "action": "stop",
906             "status": "off",
907             "msg": "Machine is already off.",
908         }
909     ret = query(
910         droplet_id=data["id"],
911         command="actions",
912         args={"type": "shutdown"},
913         http_method="post",
914     )
915     return {
916         "success": True,
917         "action": ret["action"]["type"],
918         "state": ret["action"]["status"],
919     }
920 def _get_full_output(node, for_output=False):
921     ret = {}
922     for item in node.keys():
923         value = node[item]
924         if value is not None and for_output:
925             value = str(value)
926         ret[item] = value
927     return ret
928 def _get_ips(networks):
929     v4s = networks.get("v4")
930     v6s = networks.get("v6")
931     public_ips = []
932     private_ips = []
933     if v4s:
934         for item in v4s:
935             ip_type = item.get("type")
936             ip_address = item.get("ip_address")
937             if ip_type == "public":
938                 public_ips.append(ip_address)
939             if ip_type == "private":
940                 private_ips.append(ip_address)
941     if v6s:
942         for item in v6s:
943             ip_type = item.get("type")
944             ip_address = item.get("ip_address")
945             if ip_type == "public":
946                 public_ips.append(ip_address)
947             if ip_type == "private":
948                 private_ips.append(ip_address)
949     return public_ips, private_ips
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>win_lgpo_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import csv
2 import ctypes
3 import glob
4 import io
5 import locale
6 import logging
7 import os
8 import re
9 import tempfile
10 import time
11 import uuid
12 import zlib
13 import salt.utils.dictupdate as dictupdate
14 import salt.utils.files
15 import salt.utils.path
16 import salt.utils.platform
17 import salt.utils.stringutils
18 import salt.utils.win_lgpo_netsh
19 from salt.exceptions import CommandExecutionError, SaltInvocationError
20 from salt.serializers.configparser import deserialize
21 log = logging.getLogger(__name__)
22 __virtualname__ = "lgpo"
23 __func_alias__ = {"set_": "set"}
24 UUID = uuid.uuid4().hex
25 adm_policy_name_map = {True: {}, False: {}}
26 HAS_WINDOWS_MODULES = False
27 TRUE_VALUE_XPATH = None
28 FALSE_VALUE_XPATH = None
29 ELEMENTS_XPATH = None
30 ENABLED_VALUE_XPATH = None
31 DISABLED_VALUE_XPATH = None
32 ENABLED_LIST_XPATH = None
33 DISABLED_LIST_XPATH = None
34 VALUE_XPATH = None
35 TRUE_LIST_XPATH = None
36 FALSE_LIST_XPATH = None
37 REGKEY_XPATH = None
38 POLICY_ANCESTOR_XPATH = None
39 ALL_CLASS_POLICY_XPATH = None
40 ADML_DISPLAY_NAME_XPATH = None
41 VALUE_LIST_XPATH = None
42 ENUM_ITEM_DISPLAY_NAME_XPATH = None
43 ADMX_SEARCH_XPATH = None
44 ADML_SEARCH_XPATH = None
45 ADMX_DISPLAYNAME_SEARCH_XPATH = None
46 PRESENTATION_ANCESTOR_XPATH = None
47 TEXT_ELEMENT_XPATH = None
48 try:
49     import struct
50     import lxml
51     import win32net
52     import win32security
53     from lxml import etree
54     from salt.utils.win_reg import Registry
55     HAS_WINDOWS_MODULES = True
56     TRUE_VALUE_XPATH = etree.XPath('.//*[local-name() = "trueValue"]')
57     FALSE_VALUE_XPATH = etree.XPath('.//*[local-name() = "falseValue"]')
58     ELEMENTS_XPATH = etree.XPath('.//*[local-name() = "elements"]')
59     ENABLED_VALUE_XPATH = etree.XPath('.//*[local-name() = "enabledValue"]')
60     DISABLED_VALUE_XPATH = etree.XPath('.//*[local-name() = "disabledValue"]')
61     ENABLED_LIST_XPATH = etree.XPath('.//*[local-name() = "enabledList"]')
62     DISABLED_LIST_XPATH = etree.XPath('.//*[local-name() = "disabledList"]')
63     VALUE_XPATH = etree.XPath('.//*[local-name() = "value"]')
64     TRUE_LIST_XPATH = etree.XPath('.//*[local-name() = "trueList"]')
65     FALSE_LIST_XPATH = etree.XPath('.//*[local-name() = "falseList"]')
66     REGKEY_XPATH = etree.XPath("//*[@key = $keyvalue]")
67     POLICY_ANCESTOR_XPATH = etree.XPath('ancestor::*[local-name() = "policy"]')
68     ALL_CLASS_POLICY_XPATH = etree.XPath(
69         '//*[local-name() = "policy" and (@*[local-name() = "class"] = "Both" or'
70         ' @*[local-name() = "class"] = $registry_class)]'
71     )
72     ADML_DISPLAY_NAME_XPATH = etree.XPath(
73         '//*[local-name() = $displayNameType and @*[local-name() = "id"] ='
74         " $displayNameId]"
75     )
76     VALUE_LIST_XPATH = etree.XPath('.//*[local-name() = "valueList"]')
77     ENUM_ITEM_DISPLAY_NAME_XPATH = etree.XPath(
78         './/*[local-name() = "item" and @*[local-name() = "displayName" ='
79         " $display_name]]"
80     )
81     ADMX_SEARCH_XPATH = etree.XPath(
82         '//*[local-name() = "policy" and @*[local-name() = "name"] = $policy_name and'
83         ' (@*[local-name() = "class"] = "Both" or @*[local-name() = "class"] ='
84         " $registry_class)]"
85     )
86     ADML_SEARCH_XPATH = etree.XPath(
87         '//*[starts-with(text(), $policy_name) and @*[local-name() = "id"]]'
88     )
89     ADMX_DISPLAYNAME_SEARCH_XPATH = etree.XPath(
90         '//*[local-name() = "policy" and @*[local-name() = "displayName"] ='
91         ' $display_name and (@*[local-name() = "class"] = "Both" or @*[local-name() ='
92         ' "class"] = $registry_class) ]'
93     )
94     PRESENTATION_ANCESTOR_XPATH = etree.XPath(
95         'ancestor::*[local-name() = "presentation"]'
96     )
97     TEXT_ELEMENT_XPATH = etree.XPath('.//*[local-name() = "text"]')
98     windll = ctypes.windll.kernel32
99     INSTALL_LANGUAGE = locale.windows_locale.get(
100         windll.GetSystemDefaultUILanguage(), "en_US"
101     ).replace("_", "-")
102 except ImportError:
103     HAS_WINDOWS_MODULES = False
104 class _policy_info:
105     r"""
106     Policy Helper Class
107     ===================
108     The format of the policy dict is as follows:
109     The top most two key/value pairs in the dict divide the policies object into
110     the two sections of local group policy, using the keys "Machine" and "User".
111     The value make-up of these dicts are described below in "Policy Section
112     Definition"
113     Policy Section Definition
114     -------------------------
115     A policy section dict has two required key/value pairs:
116     ============  ==============================================================
117     Key
118     ============  ==============================================================
119     lgpo_section  String matching how the policy section is displayed in the mmc
120                   snap-in ("Computer Configuration" for "Machine" and "User
121                   Configuration" for "User")
122     policies      a dict containing the non-Administrative template policy
123                   definitions, the key for each item is a short/unique
124                   identifier for the policy, the value is described below in
125                   "Policies Definition"
126     ============  ==============================================================
127     Policies Definition
128     -------------------
129     A policies definition item describes the particular policy. There are three
130     child key/value pairs shared with all policy types:
131     ============  ==============================================================
132     Key           Value
133     ============  ==============================================================
134     lgpo_section  A list containing the hierarchical path to the policy in the
135                   gpedit mmc snap-in.
136     Policy        A string containing the name of the policy in the gpedit mmc
137                   snap-in
138     Settings      An object which describes valid settings for the policy. This
139                   can be None for no validation, a list of possible settings, or
140                   a dict with the following key/value pairs:
141                   - **Function:** The class function to use to validate the
142                     setting
143                   - **Args:** A dict of kwargs to pass to the class function
144     ============  ==============================================================
145     Additionally, each policies definition will contain a key/value pair that
146     defines the mechanism that will be used to configure the policy. The
147     available mechanisms are:  NetUserModal, Registry, Secedit, and LsaRights
148     Registry Mechanism
149     ------------------
150     Some policies simply set values in the Windows registry. The value of this
151     key is a dict with the following make-up:
152     =====  =====================================================================
153     Key    Value
154     =====  =====================================================================
155     Hive   A string containing the Registry hive, such as ``HKEY_LOCAL_MACHINE``
156     Path   A string containing the registry key path, such as
157            ``SYSTEM\\CurrentControlSet\\Control\\Lsa``
158     Value  A string containing the name of the registry value, such as
159            **restrictanonymous**
160     Type   A string containing the registry type of the value, such as
161            ``REG_DWORD``
162     =====  =====================================================================
163     Secedit Mechanism
164     -----------------
165     Some policies are configurable via the "secedit.exe" executable. The value
166     of this key is a dict with the following make-up:
167     =======  ===================================================================
168     Key      Value
169     =======  ===================================================================
170     Option   A string containing the name of the policy as it appears in an
171              export from secedit, such as **PasswordComplexity**
172     Section  A string containing the name of the section in which the "Option"
173              value appears in an export from ``secedit``, such as "System
174              Access"
175     =======  ===================================================================
176     LsaRights Mechanism
177     -------------------
178     LSA Rights policies are configured via the LsaRights mechanism. The value of
179     this key is a dict with the following make-up:
180     ======  ====================================================================
181     Key     Value
182     ======  ====================================================================
183     Option  A string containing the programmatic name of the Lsa Right, such as
184             **SeNetworkLogonRight**
185     ======  ====================================================================
186     NetUserModal Mechanism
187     ----------------------
188     Some policies are configurable by the **NetUserModalGet** and
189     **NetUserModalSet** function from pywin32.  The value of this key is a dict
190     with the following make-up:
191     ======  ====================================================================
192     Key     Value
193     ======  ====================================================================
194     Modal   The modal "level" that the particular option is specified in (0-3),
195             see `here &lt;https://msdn.microsoft.com/en-us/library/windows/desktop/
196             aa370656(v=vs.85).aspx&gt;`_
197     Option  The name of the structure member which contains the data for the
198             policy, for example **max_passwd_age**
199     ======  ====================================================================
200     NetSH Mechanism
201     ---------------
202     The firewall policies are configured by the ``netsh.exe`` executable. The
203     value of this key is a dict with the following make-up:
204     =======  ===================================================================
205     Key      Value
206     =======  ===================================================================
207     Profile  The firewall profile to modify. Can be one of Domain, Private, or
208              Public
209     Section  The section of the firewall to modify. Can be one of state,
210              firewallpolicy, settings, or logging.
211     Option   The setting within that section
212     Value    The value of the setting
213     =======  ===================================================================
214     More information can be found in the advfirewall context in netsh. This can
215     be access by opening a netsh prompt. At a command prompt type the following:
216     c:\&gt;netsh
217     netsh&gt;advfirewall
218     netsh advfirewall&gt;set help
219     netsh advfirewall&gt;set domain help
220     AdvAudit Mechanism
221     ------------------
222     The Advanced Audit Policies are configured using a combination of the
223     auditpol command-line utility and modifying the audit.csv file in two
224     locations. The value of this key is a dict with the following make-up:
225     ======  ===================================
226     Key     Value
227     ======  ===================================
228     Option  The Advanced Audit Policy to modify
229     ======  ===================================
230     Transforms
231     ----------
232     Optionally, each policy definition can contain a "Transform" key. The
233     Transform key is used to handle data that is stored and viewed differently.
234     This key's value is a dict with the following key/value pairs:
235     ===  =======================================================================
236     Key  Value
237     ===  =======================================================================
238     Get  The name of the class function to use to transform the data from the
239          stored value to how the value is displayed in the GUI
240     Put The name of the class function to use to transform the data supplied by
241         the user to the correct value that the policy is stored in
242     ===  =======================================================================
243     For example, "Minimum password age" is stored in seconds, but is displayed
244     in days.  Thus the "Get" and "Put" functions for this policy do these
245     conversions so the user is able to set and view the policy using the same
246     data that is shown in the GUI.
247                 "lookup": self<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.enabled_one_disabled_zero_strings,
248                 "value_lookup": False,
249             },
250             "PutArgs": {
251                 "lookup": self.enabled_one_disabled_zero_strings,
252                 "value_lookup": True,
253             },
254         }
255         self.security_options_gpedit_path = [
256             "Computer Configuration",
257             "Windows Settings",
258             "Security Settings",
259             "Local Policies",
260             "Security Options",
261         ]
262         self.windows_firewall_gpedit_path = [
263             "Computer Configuration",
264             "Windows Settings",
265             "Security Settings",
266             "Windows Firewall with Advanced Security",
267             "Windows Firewall with Advanced Security - Local Group Policy Object",
268         ]
269         self.password_policy_gpedit_path = [
270             "Computer Configuration"</b></font>,
271             "Windows Settings",
272             "Security Settings",
273             "Account Policies",
274             "Password Policy",
275         ]
276         self.audit_policy_gpedit_path = [
277             "Computer Configuration",
278             "Windows Settings",
279             "Security Settings",
280             "Local Policies",
281             "Audit Policy",
282         ]
283         self.advanced_audit_policy_gpedit_path = [
284             "Computer Configuration",
285             "Windows Settings",
286             "Security Settings",
287             "Advanced Audit Policy Configuration",
288             "System Audit Policies - Local Group Policy Object",
289         ]
290         self.account_lockout_policy_gpedit_path = [
291             "Computer Configuration",
292             "Windows Settings",
293             "Security Settings",
294             "Account Policies",
295             "Account Lockout Policy",
296         ]
297         self.user_rights_assignment_gpedit_path = [
298             "Computer Configuration",
299             "Windows Settings",
300             "Security Settings",
301             "Local Policies",
302             "User Rights Assignment",
303         ]
304         self.block_ms_accounts = {
305             0: "This policy is disabled",
306             1: "Users can't add Microsoft accounts",
307             3: "Users can't add or log on with Microsoft accounts",
308             None: "Not Defined",
309             "(value not set)": "Not Defined",
310         }
311         self.ldap_server_signing_requirements = {
312             1: "None",
313             2: "Require signing",
314             None: "Not Defined",
315             "(value not set)": "Not Defined",
316         }
317         self.smb_server_name_hardening_levels = {
318             0: "Off",
319             1: "Accept if provided by client",
320             2: "Required from client",
321             None: "Not Defined",
322             "(value not set)": "Not Defined",
323         }
324         self.locked_session_user_info = {
325             1: "User display name, domain and user names",
326             2: "User display name only",
327             3: "Do not display user information",
328             None: "Not Defined",
329             "(value not set)": "Not Defined",
330         }
331         self.force_guest = {
332             0: "Classic - local users authenticate as themselves",
333             1: "Guest only - local users authenticate as Guest",
334             None: "Not Defined",
335             "(value not set)": "Not Defined",
336         }
337         self.force_key_protection = {
338             0: "User input is not required when new keys are stored and used",
339             1: "User is prompted when the key is first used",
340             2: "User must enter a password each time they use a key",
341             None: "Not Defined",
342             "(value not set)": "Not Defined",
343         }
344         self.firewall_inbound_connections = {
345             "blockinbound": "Block (default)",
346             "blockinboundalways": "Block all connections",
347             "allowinbound": "Allow",
348             "notconfigured": "Not configured",
349         }
350         self.firewall_outbound_connections = {
351             "blockoutbound": "Block",
352             "allowoutbound": "Allow (default)",
353             "notconfigured": "Not configured",
354         }
355         self.firewall_rule_merging = {
356             "enable": "Yes (default)",
357             "disable": "No",
358             "notconfigured": "Not configured",
359         }
360         self.firewall_log_packets_connections = {
361             "enable": "Yes",
362             "disable": "No (default)",
363             "notconfigured": "Not configured",
364         }
365         self.firewall_notification = {
366             "enable": "Yes",
367             "disable": "No",
368             "notconfigured": "Not configured",
369         }
370         self.firewall_state = {
371             "on": "On (recommended)",
372             "off": "Off",
373             "notconfigured": "Not configured",
374         }
375         self.krb_encryption_types = {
376             0: "No minimum",
377             1: "DES_CBC_CRC",
378             2: "DES_CBD_MD5",
379             4: "RC4_HMAC_MD5",
380             8: "AES128_HMAC_SHA1",
381             16: "AES256_HMAC_SHA1",
382             2147483616: "Future Encryption Types",
383             None: "Not Defined",
384             "(value not set)": "Not Defined",
385         }
386         self.lm_compat_levels = {
387             0: "Send LM &amp; NTLM response",
388             1: "Send LM &amp; NTLM - use NTLMv2 session security if negotiated",
389             2: "Send NTLM response only",
390             3: "Send NTLMv2 response only",
391             4: "Send NTLMv2 response only. Refuse LM",
392             5: "Send NTLMv2 response only. Refuse LM &amp; NTLM",
393             None: "Not Defined",
394             "(value not set)": "Not Defined",
395         }
396         self.ldap_signing_reqs = {
397             0: "None",
398             1: "Negotiate signing",
399             2: "Require signing",
400             None: "Not Defined",
401             "(value not set)": "Not Defined",
402         }
403         self.ntlm_session_security_levels = {
404             0: "No minimum",
405             524288: "Require NTLMv2 session security",
406             536870912: "Require 128-bit encryption",
407             None: "Not Defined",
408             "(value not set)": "Not Defined",
409         }
410         self.ntlm_audit_settings = {
411             0: "Disable",
412             1: "Enable auditing for domain accounts",
413             2: "Enable auditing for all accounts",
414             None: "Not Defined",
415             "(value not set)": "Not Defined",
416         }
417         self.ntlm_domain_audit_settings = {
418             0: "Disable",
419             1: "Enable for domain accounts to domain servers",
420             3: "Enable for domain accounts",
421             5: "Enable for domain servers",
422             7: "Enable all",
423             None: "Not Defined",
424             "(value not set)": "Not Defined",
425         }
426         self.incoming_ntlm_settings = {
427             0: "Allow all",
428             1: "Deny all domain accounts",
429             2: "Deny all accounts",
430             None: "Not Defined",
431             "(value not set)": "Not Defined",
432         }
433         self.ntlm_domain_auth_settings = {
434             0: "Disable",
435             1: "Deny for domain accounts to domain servers",
436             3: "Deny for domain accounts",
437             5: "Deny for domain servers",
438             7: "Deny all",
439             None: "Not Defined",
440             "(value not set)": "Not Defined",
441         }
442         self.outgoing_ntlm_settings = {
443             0: "Allow all",
444             1: "Audit all",
445             2: "Deny all",
446             None: "Not Defined",
447             "(value not set)": "Not Defined",
448         }
449         self.enabled_one_disabled_zero_no_not_defined = {
450             0: "Disabled",
451             1: "Enabled",
452         }
453         self.enabled_one_disabled_zero_no_not_defined_transform = {
454             "Get": "_dict_lookup",
455             "Put": "_dict_lookup",
456             "GetArgs": {
457                 "lookup": self.enabled_one_disabled_zero_no_not_defined,
458                 "value_lookup": False,
459             },
460             "PutArgs": {
461                 "lookup": self.enabled_one_disabled_zero_no_not_defined,
462                 "value_lookup": True,
463             },
464         }
465         self.policies = {
466             "Machine": {
467                 "lgpo_section": "Computer Configuration",
468                 "policies": {
469                     "StartupScripts": {
470                         "Policy": "Startup Scripts",
471                         "lgpo_section": [
472                             "Computer Configuration",
473                             "Windows Settings",
474                             "Scripts (Startup/Shutdown)",
475                             "Startup",
476                         ],
477                         "ScriptIni": {
478                             "Section": "Startup",
479                             "IniPath": os.path.join(
480                                 os.getenv("WINDIR"),
481                                 "System32",
482                                 "GroupPolicy",
483                                 "Machine",
484                                 "Scripts",
485                                 "scripts.ini",
486                             ),
487                         },
488                     },
489                     "StartupPowershellScripts": {
490                         "Policy": "Startup Powershell Scripts",
491                         "lgpo_section": [
492                             "Computer Configuration",
493                             "Windows Settings",
494                             "Scripts (Startup/Shutdown)",
495                             "Startup",
496                         ],
497                         "ScriptIni": {
498                             "Section": "Startup",
499                             "IniPath": os.path.join(
500                                 os.getenv("WINDIR"),
501                                 "System32",
502                                 "GroupPolicy",
503                                 "Machine",
504                                 "Scripts",
505                                 "psscripts.ini",
506                             ),
507                         },
508                     },
509                     "StartupPowershellScriptOrder": {
510                         "Policy": (
511                             "Startup - For this GPO, run scripts in the following order"
512                         ),
513                         "lgpo_section": [
514                             "Computer Configuration",
515                             "Windows Settings",
516                             "Scripts (Startup/Shutdown)",
517                             "Startup",
518                         ],
519                         "ScriptIni": {
520                             "IniPath": os.path.join(
521                                 os.getenv("WINDIR"),
522                                 "System32",
523                                 "GroupPolicy",
524                                 "Machine",
525                                 "Scripts",
526                                 "psscripts.ini",
527                             ),
528                             "Section": "ScriptsConfig",
529                             "SettingName": "StartExecutePSFirst",
530                             "Settings": ["true", "false", None],
531                         },
532                         "Transform": {
533                             "Get": "_powershell_script_order_conversion",
534                             "Put": "_powershell_script_order_reverse_conversion",
535                         },
536                     },
537                     "ShutdownScripts": {
538                         "Policy": "Shutdown Scripts",
539                         "lgpo_section": [
540                             "Computer Configuration",
541                             "Windows Settings",
542                             "Scripts (Startup/Shutdown)",
543                             "Shutdown",
544                         ],
545                         "ScriptIni": {
546                             "Section": "Shutdown",
547                             "IniPath": os.path.join(
548                                 os.getenv("WINDIR"),
549                                 "System32",
550                                 "GroupPolicy",
551                                 "Machine",
552                                 "Scripts",
553                                 "scripts.ini",
554                             ),
555                         },
556                     },
557                     "ShutdownPowershellScripts": {
558                         "Policy": "Shutdown Powershell Scripts",
559                         "lgpo_section": [
560                             "Computer Configuration",
561                             "Windows Settings",
562                             "Scripts (Startup/Shutdown)",
563                             "Shutdown",
564                         ],
565                         "ScriptIni": {
566                             "Section": "Shutdown",
567                             "IniPath": os.path.join(
568                                 os.getenv("WINDIR"),
569                                 "System32",
570                                 "GroupPolicy",
571                                 "Machine",
572                                 "Scripts",
573                                 "psscripts.ini",
574                             ),
575                         },
576                     },
577                     "ShutdownPowershellScriptOrder": {
578                         "Policy": (
579                             "Shutdown - For this GPO, run scripts in the "
580                             "following order"
581                         ),
582                         "lgpo_section": [
583                             "Computer Configuration",
584                             "Windows Settings",
585                             "Scripts (Startup/Shutdown)",
586                             "Shutdown",
587                         ],
588                         "ScriptIni": {
589                             "IniPath": os.path.join(
590                                 os.getenv("WINDIR"),
591                                 "System32",
592                                 "GroupPolicy",
593                                 "Machine",
594                                 "Scripts",
595                                 "psscripts.ini",
596                             ),
597                             "Section": "ScriptsConfig",
598                             "SettingName": "EndExecutePSFirst",
599                             "Settings": ["true", "false", None],
600                         },
601                         "Transform": {
602                             "Get": "_powershell_script_order_conversion",
603                             "Put": "_powershell_script_order_reverse_conversion",
604                         },
605                     },
606                     "LSAAnonymousNameLookup": {
607                         "Policy": (
608                             "Network access: Allow anonymous SID/Name translation"
609                         ),
610                         "lgpo_section": self.password_policy_gpedit_path,
611                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
612                         "Secedit": {
613                             "Option": "LSAAnonymousNameLookup",
614                             "Section": "System Access",
615                         },
616                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
617                     },
618                     "RestrictAnonymousSam": {
619                         "Policy": (
620                             "Network access: Do not allow anonymous "
621                             "enumeration of SAM accounts"
622                         ),
623                         "lgpo_section": self.security_options_gpedit_path,
624                         "Settings": self.enabled_one_disabled_zero.keys(),
625                         "Registry": {
626                             "Hive": "HKEY_LOCAL_MACHINE",
627                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
628                             "Value": "RestrictAnonymousSam",
629                             "Type": "REG_DWORD",
630                         },
631                         "Transform": self.enabled_one_disabled_zero_transform,
632                     },
633                     "RestrictRemoteSAM": {
634                         "Policy": (
635                             "Network access: Restrict clients allowed to "
636                             "make remote calls to SAM"
637                         ),
638                         "lgpo_section": self.security_options_gpedit_path,
639                         "Registry": {
640                             "Hive": "HKEY_LOCAL_MACHINE",
641                             "Path": "System\\CurrentControlSet\\Control\\Lsa",
642                             "Value": "RestrictRemoteSAM",
643                             "Type": "REG_SZ",
644                         },
645                         "Transform": {"Put": "_string_put_transform"},
646                     },
647                     "RestrictAnonymous": {
648                         "Policy": (
649                             "Network access: Do not allow anonymous "
650                             "enumeration of SAM accounts and shares"
651                         ),
652                         "lgpo_section": self.security_options_gpedit_path,
653                         "Settings": self.enabled_one_disabled_zero.keys(),
654                         "Registry": {
655                             "Hive": "HKEY_LOCAL_MACHINE",
656                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
657                             "Value": "RestrictAnonymous",
658                             "Type": "REG_DWORD",
659                         },
660                         "Transform": self.enabled_one_disabled_zero_transform,
661                     },
662                     "DisableDomainCreds": {
663                         "Policy": (
664                             "Network access: Do not allow storage of "
665                             "passwords and credentials for network "
666                             "authentication"
667                         ),
668                         "lgpo_section": self.security_options_gpedit_path,
669                         "Settings": self.enabled_one_disabled_zero.keys(),
670                         "Registry": {
671                             "Hive": "HKEY_LOCAL_MACHINE",
672                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
673                             "Value": "DisableDomainCreds",
674                             "Type": "REG_DWORD",
675                         },
676                         "Transform": self.enabled_one_disabled_zero_transform,
677                     },
678                     "EveryoneIncludesAnonymous": {
679                         "Policy": (
680                             "Network access: Let Everyone permissions "
681                             "apply to anonymous users"
682                         ),
683                         "lgpo_section": self.security_options_gpedit_path,
684                         "Settings": self.enabled_one_disabled_zero.keys(),
685                         "Registry": {
686                             "Hive": "HKEY_LOCAL_MACHINE",
687                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
688                             "Value": "everyoneincludesanonymous",
689                             "Type": "REG_DWORD",
690                         },
691                         "Transform": self.enabled_one_disabled_zero_transform,
692                     },
693                     "NullSessionPipes": {
694                         "Policy": (
695                             "Network access: Named Pipes that can be "
696                             "accessed anonymously"
697                         ),
698                         "lgpo_section": self.security_options_gpedit_path,
699                         "Registry": {
700                             "Hive": "HKEY_LOCAL_MACHINE",
701                             "Path": (
702                                 "SYSTEM\\CurrentControlSet\\Services\\"
703                                 "LanmanServer\\Parameters"
704                             ),
705                             "Value": "NullSessionPipes",
706                             "Type": "REG_MULTI_SZ",
707                         },
708                         "Transform": {
709                             "Put": "_multi_string_put_transform",
710                             "Get": "_multi_string_get_transform",
711                         },
712                     },
713                     "RemoteRegistryExactPaths": {
714                         "Policy": "Network access: Remotely accessible registry paths",
715                         "lgpo_section": self.security_options_gpedit_path,
716                         "Registry": {
717                             "Hive": "HKEY_LOCAL_MACHINE",
718                             "Path": (
719                                 "SYSTEM\\CurrentControlSet\\Control\\"
720                                 "SecurePipeServers\\winreg\\"
721                                 "AllowedExactPaths"
722                             ),
723                             "Value": "Machine",
724                             "Type": "REG_MULTI_SZ",
725                         },
726                         "Transform": {
727                             "Put": "_multi_string_put_transform",
728                             "Get": "_multi_string_get_transform",
729                         },
730                     },
731                     "RemoteRegistryPaths": {
732                         "Policy": (
733                             "Network access: Remotely accessible "
734                             "registry paths and sub-paths"
735                         ),
736                         "lgpo_section": self.security_options_gpedit_path,
737                         "Registry": {
738                             "Hive": "HKEY_LOCAL_MACHINE",
739                             "Path": (
740                                 "SYSTEM\\CurrentControlSet\\Control\\"
741                                 "SecurePipeServers\\winreg\\AllowedPaths"
742                             ),
743                             "Value": "Machine",
744                             "Type": "REG_MULTI_SZ",
745                         },
746                         "Transform": {
747                             "Put": "_multi_string_put_transform",
748                             "Get": "_multi_string_get_transform",
749                         },
750                     },
751                     "RestrictNullSessAccess": {
752                         "Policy": (
753                             "Network access: Restrict anonymous access "
754                             "to Named Pipes and Shares"
755                         ),
756                         "lgpo_section": self.security_options_gpedit_path,
757                         "Settings": self.enabled_one_disabled_zero.keys(),
758                         "Registry": {
759                             "Hive": "HKEY_LOCAL_MACHINE",
760                             "Path": (
761                                 "System\\CurrentControlSet\\Services\\"
762                                 "LanmanServer\\Parameters"
763                             ),
764                             "Value": "RestrictNullSessAccess",
765                             "Type": "REG_DWORD",
766                         },
767                         "Transform": self.enabled_one_disabled_zero_transform,
768                     },
769                     "NullSessionShares": {
770                         "Policy": (
771                             "Network access: Shares that can be accessed anonymously"
772                         ),
773                         "lgpo_section": self.security_options_gpedit_path,
774                         "Registry": {
775                             "Hive": "HKEY_LOCAL_MACHINE",
776                             "Path": (
777                                 "SYSTEM\\CurrentControlSet\\Services\\"
778                                 "LanmanServer\\Parameters"
779                             ),
780                             "Value": "NullSessionShares",
781                             "Type": "REG_MULTI_SZ",
782                         },
783                         "Transform": {
784                             "Put": "_multi_string_put_transform",
785                             "Get": "_multi_string_get_transform",
786                         },
787                     },
788                     "ForceGuest": {
789                         "Policy": (
790                             "Network access: Sharing and security model "
791                             "for local accounts"
792                         ),
793                         "lgpo_section": self.security_options_gpedit_path,
794                         "Settings": self.force_guest.keys(),
795                         "Registry": {
796                             "Hive": "HKEY_LOCAL_MACHINE",
797                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
798                             "Value": "ForceGuest",
799                             "Type": "REG_DWORD",
800                         },
801                         "Transform": {
802                             "Get": "_dict_lookup",
803                             "Put": "_dict_lookup",
804                             "GetArgs": {
805                                 "lookup": self.force_guest,
806                                 "value_lookup": False,
807                             },
808                             "PutArgs": {
809                                 "lookup": self.force_guest,
810                                 "value_lookup": True,
811                             },
812                         },
813                     },
814                     "WfwDomainState": {
815                         "Policy": "Network firewall: Domain: State",
816                         "lgpo_section": self.windows_firewall_gpedit_path,
817                         "Settings": self.firewall_state.keys(),
818                         "NetSH": {
819                             "Profile": "domain",
820                             "Section": "state",
821                             "Option": "State",  # Unused, but needed
822                         },
823                         "Transform": {
824                             "Get": "_dict_lookup",
825                             "Put": "_dict_lookup",
826                             "GetArgs": {
827                                 "lookup": self.firewall_state,
828                                 "value_lookup": False,
829                             },
830                             "PutArgs": {
831                                 "lookup": self.firewall_state,
832                                 "value_lookup": True,
833                             },
834                         },
835                     },
836                     "WfwPrivateState": {
837                         "Policy": "Network firewall: Private: State",
838                         "lgpo_section": self.windows_firewall_gpedit_path,
839                         "Settings": self.firewall_state.keys(),
840                         "NetSH": {
841                             "Profile": "private",
842                             "Section": "state",
843                             "Option": "State",  # Unused, but needed
844                         },
845                         "Transform": {
846                             "Get": "_dict_lookup",
847                             "Put": "_dict_lookup",
848                             "GetArgs": {
849                                 "lookup": self.firewall_state,
850                                 "value_lookup": False,
851                             },
852                             "PutArgs": {
853                                 "lookup": self.firewall_state,
854                                 "value_lookup": True,
855                             },
856                         },
857                     },
858                     "WfwPublicState": {
859                         "Policy": "Network firewall: Public: State",
860                         "lgpo_section": self.windows_firewall_gpedit_path,
861                         "Settings": self.firewall_state.keys(),
862                         "NetSH": {
863                             "Profile": "public",
864                             "Section": "state",
865                             "Option": "State",  # Unused, but needed
866                         },
867                         "Transform": {
868                             "Get": "_dict_lookup",
869                             "Put": "_dict_lookup",
870                             "GetArgs": {
871                                 "lookup": self.firewall_state,
872                                 "value_lookup": False,
873                             },
874                             "PutArgs": {
875                                 "lookup": self.firewall_state,
876                                 "value_lookup": True,
877                             },
878                         },
879                     },
880                     "WfwDomainInboundConnections": {
881                         "Policy": "Network firewall: Domain: Inbound connections",
882                         "lgpo_section": self.windows_firewall_gpedit_path,
883                         "Settings": self.firewall_inbound_connections.keys(),
884                         "NetSH": {
885                             "Profile": "domain",
886                             "Section": "firewallpolicy",
887                             "Option": "Inbound",
888                         },
889                         "Transform": {
890                             "Get": "_dict_lookup",
891                             "Put": "_dict_lookup",
892                             "GetArgs": {
893                                 "lookup": self.firewall_inbound_connections,
894                                 "value_lookup": False,
895                             },
896                             "PutArgs": {
897                                 "lookup": self.firewall_inbound_connections,
898                                 "value_lookup": True,
899                             },
900                         },
901                     },
902                     "WfwPrivateInboundConnections": {
903                         "Policy": "Network firewall: Private: Inbound connections",
904                         "lgpo_section": self.windows_firewall_gpedit_path,
905                         "Settings": self.firewall_inbound_connections.keys(),
906                         "NetSH": {
907                             "Profile": "private",
908                             "Section": "firewallpolicy",
909                             "Option": "Inbound",
910                         },
911                         "Transform": {
912                             "Get": "_dict_lookup",
913                             "Put": "_dict_lookup",
914                             "GetArgs": {
915                                 "lookup": self.firewall_inbound_connections,
916                                 "value_lookup": False,
917                             },
918                             "PutArgs": {
919                                 "lookup": self.firewall_inbound_connections,
920                                 "value_lookup": True,
921                             },
922                         },
923                     },
924                     "WfwPublicInboundConnections": {
925                         "Policy": "Network firewall: Public: Inbound connections",
926                         "lgpo_section": self.windows_firewall_gpedit_path,
927                         "Settings": self.firewall_inbound_connections.keys(),
928                         "NetSH": {
929                             "Profile": "public",
930                             "Section": "firewallpolicy",
931                             "Option": "Inbound",
932                         },
933                         "Transform": {
934                             "Get": "_dict_lookup",
935                             "Put": "_dict_lookup",
936                             "GetArgs": {
937                                 "lookup": self.firewall_inbound_connections,
938                                 "value_lookup": False,
939                             },
940                             "PutArgs": {
941                                 "lookup": self.firewall_inbound_connections,
942                                 "value_lookup": True,
943                             },
944                         },
945                     },
946                     "WfwDomainOutboundConnections": {
947                         "Policy": "Network firewall: Domain: Outbound connections",
948                         "lgpo_section": self.windows_firewall_gpedit_path,
949                         "Settings": self.firewall_outbound_connections.keys(),
950                         "NetSH": {
951                             "Profile": "domain",
952                             "Section": "firewallpolicy",
953                             "Option": "Outbound",
954                         },
955                         "Transform": {
956                             "Get": "_dict_lookup",
957                             "Put": "_dict_lookup",
958                             "GetArgs": {
959                                 "lookup": self.firewall_outbound_connections,
960                                 "value_lookup": False,
961                             },
962                             "PutArgs": {
963                                 "lookup": self.firewall_outbound_connections,
964                                 "value_lookup": True,
965                             },
966                         },
967                     },
968                     "WfwPrivateOutboundConnections": {
969                         "Policy": "Network firewall: Private: Outbound connections",
970                         "lgpo_section": self.windows_firewall_gpedit_path,
971                         "Settings": self.firewall_outbound_connections.keys(),
972                         "NetSH": {
973                             "Profile": "private",
974                             "Section": "firewallpolicy",
975                             "Option": "Outbound",
976                         },
977                         "Transform": {
978                             "Get": "_dict_lookup",
979                             "Put": "_dict_lookup",
980                             "GetArgs": {
981                                 "lookup": self.firewall_outbound_connections,
982                                 "value_lookup": False,
983                             },
984                             "PutArgs": {
985                                 "lookup": self.firewall_outbound_connections,
986                                 "value_lookup": True,
987                             },
988                         },
989                     },
990                     "WfwPublicOutboundConnections": {
991                         "Policy": "Network firewall: Public: Outbound connections",
992                         "lgpo_section": self.windows_firewall_gpedit_path,
993                         "Settings": self.firewall_outbound_connections.keys(),
994                         "NetSH": {
995                             "Profile": "public",
996                             "Section": "firewallpolicy",
997                             "Option": "Outbound",
998                         },
999                         "Transform": {
1000                             "Get": "_dict_lookup",
1001                             "Put": "_dict_lookup",
1002                             "GetArgs": {
1003                                 "lookup": self.firewall_outbound_connections,
1004                                 "value_lookup": False,
1005                             },
1006                             "PutArgs": {
1007                                 "lookup": self.firewall_outbound_connections,
1008                                 "value_lookup": True,
1009                             },
1010                         },
1011                     },
1012                     "WfwDomainSettingsNotification": {
1013                         "Policy": (
1014                             "Network firewall: Domain: Settings: Display a notification"
1015                         ),
1016                         "lgpo_section": self.windows_firewall_gpedit_path,
1017                         "Settings": self.firewall_notification.keys(),
1018                         "NetSH": {
1019                             "Profile": "domain",
1020                             "Section": "settings",
1021                             "Option": "InboundUserNotification",
1022                         },
1023                         "Transform": {
1024                             "Get": "_dict_lookup",
1025                             "Put": "_dict_lookup",
1026                             "GetArgs": {
1027                                 "lookup": self.firewall_notification,
1028                                 "value_lookup": False,
1029                             },
1030                             "PutArgs": {
1031                                 "lookup": self.firewall_notification,
1032                                 "value_lookup": True,
1033                             },
1034                         },
1035                     },
1036                     "WfwPrivateSettingsNotification": {
1037                         "Policy": (
1038                             "Network firewall: Private: Settings: Display a"
1039                             " notification"
1040                         ),
1041                         "lgpo_section": self.windows_firewall_gpedit_path,
1042                         "Settings": self.firewall_notification.keys(),
1043                         "NetSH": {
1044                             "Profile": "private",
1045                             "Section": "settings",
1046                             "Option": "InboundUserNotification",
1047                         },
1048                         "Transform": {
1049                             "Get": "_dict_lookup",
1050                             "Put": "_dict_lookup",
1051                             "GetArgs": {
1052                                 "lookup": self.firewall_notification,
1053                                 "value_lookup": False,
1054                             },
1055                             "PutArgs": {
1056                                 "lookup": self.firewall_notification,
1057                                 "value_lookup": True,
1058                             },
1059                         },
1060                     },
1061                     "WfwPublicSettingsNotification": {
1062                         "Policy": (
1063                             "Network firewall: Public: Settings: Display a notification"
1064                         ),
1065                         "lgpo_section": self.windows_firewall_gpedit_path,
1066                         "Settings": self.firewall_notification.keys(),
1067                         "NetSH": {
1068                             "Profile": "public",
1069                             "Section": "settings",
1070                             "Option": "InboundUserNotification",
1071                         },
1072                         "Transform": {
1073                             "Get": "_dict_lookup",
1074                             "Put": "_dict_lookup",
1075                             "GetArgs": {
1076                                 "lookup": self.firewall_notification,
1077                                 "value_lookup": False,
1078                             },
1079                             "PutArgs": {
1080                                 "lookup": self.firewall_notification,
1081                                 "value_lookup": True,
1082                             },
1083                         },
1084                     },
1085                     "WfwDomainSettingsLocalFirewallRules": {
1086                         "Policy": (
1087                             "Network firewall: Domain: Settings: Apply "
1088                             "local firewall rules"
1089                         ),
1090                         "lgpo_section": self.windows_firewall_gpedit_path,
1091                         "Settings": self.firewall_rule_merging.keys(),
1092                         "NetSH": {
1093                             "Profile": "domain",
1094                             "Section": "settings",
1095                             "Option": "LocalFirewallRules",
1096                         },
1097                         "Transform": {
1098                             "Get": "_dict_lookup",
1099                             "Put": "_dict_lookup",
1100                             "GetArgs": {
1101                                 "lookup": self.firewall_rule_merging,
1102                                 "value_lookup": False,
1103                             },
1104                             "PutArgs": {
1105                                 "lookup": self.firewall_rule_merging,
1106                                 "value_lookup": True,
1107                             },
1108                         },
1109                     },
1110                     "WfwPrivateSettingsLocalFirewallRules": {
1111                         "Policy": (
1112                             "Network firewall: Private: Settings: Apply "
1113                             "local firewall rules"
1114                         ),
1115                         "lgpo_section": self.windows_firewall_gpedit_path,
1116                         "Settings": self.firewall_rule_merging.keys(),
1117                         "NetSH": {
1118                             "Profile": "private",
1119                             "Section": "settings",
1120                             "Option": "LocalFirewallRules",
1121                         },
1122                         "Transform": {
1123                             "Get": "_dict_lookup",
1124                             "Put": "_dict_lookup",
1125                             "GetArgs": {
1126                                 "lookup": self.firewall_rule_merging,
1127                                 "value_lookup": False,
1128                             },
1129                             "PutArgs": {
1130                                 "lookup": self.firewall_rule_merging,
1131                                 "value_lookup": True,
1132                             },
1133                         },
1134                     },
1135                     "WfwPublicSettingsLocalFirewallRules": {
1136                         "Policy": (
1137                             "Network firewall: Public: Settings: Apply "
1138                             "local firewall rules"
1139                         ),
1140                         "lgpo_section": self.windows_firewall_gpedit_path,
1141                         "Settings": self.firewall_rule_merging.keys(),
1142                         "NetSH": {
1143                             "Profile": "public",
1144                             "Section": "settings",
1145                             "Option": "LocalFirewallRules",
1146                         },
1147                         "Transform": {
1148                             "Get": "_dict_lookup",
1149                             "Put": "_dict_lookup",
1150                             "GetArgs": {
1151                                 "lookup": self.firewall_rule_merging,
1152                                 "value_lookup": False,
1153                             },
1154                             "PutArgs": {
1155                                 "lookup": self.firewall_rule_merging,
1156                                 "value_lookup": True,
1157                             },
1158                         },
1159                     },
1160                     "WfwDomainSettingsLocalConnectionRules": {
1161                         "Policy": (
1162                             "Network firewall: Domain: Settings: Apply "
1163                             "local connection security rules"
1164                         ),
1165                         "lgpo_section": self.windows_firewall_gpedit_path,
1166                         "Settings": self.firewall_rule_merging.keys(),
1167                         "NetSH": {
1168                             "Profile": "domain",
1169                             "Section": "settings",
1170                             "Option": "LocalConSecRules",
1171                         },
1172                         "Transform": {
1173                             "Get": "_dict_lookup",
1174                             "Put": "_dict_lookup",
1175                             "GetArgs": {
1176                                 "lookup": self.firewall_rule_merging,
1177                                 "value_lookup": False,
1178                             },
1179                             "PutArgs": {
1180                                 "lookup": self.firewall_rule_merging,
1181                                 "value_lookup": True,
1182                             },
1183                         },
1184                     },
1185                     "WfwPrivateSettingsLocalConnectionRules": {
1186                         "Policy": (
1187                             "Network firewall: Private: Settings: Apply "
1188                             "local connection security rules"
1189                         ),
1190                         "lgpo_section": self.windows_firewall_gpedit_path,
1191                         "Settings": self.firewall_rule_merging.keys(),
1192                         "NetSH": {
1193                             "Profile": "private",
1194                             "Section": "settings",
1195                             "Option": "LocalConSecRules",
1196                         },
1197                         "Transform": {
1198                             "Get": "_dict_lookup",
1199                             "Put": "_dict_lookup",
1200                             "GetArgs": {
1201                                 "lookup": self.firewall_rule_merging,
1202                                 "value_lookup": False,
1203                             },
1204                             "PutArgs": {
1205                                 "lookup": self.firewall_rule_merging,
1206                                 "value_lookup": True,
1207                             },
1208                         },
1209                     },
1210                     "WfwPublicSettingsLocalConnectionRules": {
1211                         "Policy": (
1212                             "Network firewall: Public: Settings: Apply "
1213                             "local connection security rules"
1214                         ),
1215                         "lgpo_section": self.windows_firewall_gpedit_path,
1216                         "Settings": self.firewall_rule_merging.keys(),
1217                         "NetSH": {
1218                             "Profile": "public",
1219                             "Section": "settings",
1220                             "Option": "LocalConSecRules",
1221                         },
1222                         "Transform": {
1223                             "Get": "_dict_lookup",
1224                             "Put": "_dict_lookup",
1225                             "GetArgs": {
1226                                 "lookup": self.firewall_rule_merging,
1227                                 "value_lookup": False,
1228                             },
1229                             "PutArgs": {
1230                                 "lookup": self.firewall_rule_merging,
1231                                 "value_lookup": True,
1232                             },
1233                         },
1234                     },
1235                     "WfwDomainLoggingName": {
1236                         "Policy": "Network firewall: Domain: Logging: Name",
1237                         "lgpo_section": self.windows_firewall_gpedit_path,
1238                         "Settings": None,
1239                         "NetSH": {
1240                             "Profile": "domain",
1241                             "Section": "logging",
1242                             "Option": "FileName",
1243                         },
1244                     },
1245                     "WfwPrivateLoggingName": {
1246                         "Policy": "Network firewall: Private: Logging: Name",
1247                         "lgpo_section": self.windows_firewall_gpedit_path,
1248                         "Settings": None,
1249                         "NetSH": {
1250                             "Profile": "private",
1251                             "Section": "logging",
1252                             "Option": "FileName",
1253                         },
1254                     },
1255                     "WfwPublicLoggingName": {
1256                         "Policy": "Network firewall: Public: Logging: Name",
1257                         "lgpo_section": self.windows_firewall_gpedit_path,
1258                         "Settings": None,
1259                         "NetSH": {
1260                             "Profile": "public",
1261                             "Section": "logging",
1262                             "Option": "FileName",
1263                         },
1264                     },
1265                     "WfwDomainLoggingMaxFileSize": {
1266                         "Policy": "Network firewall: Domain: Logging: Size limit (KB)",
1267                         "lgpo_section": self.windows_firewall_gpedit_path,
1268                         "Settings": None,
1269                         "NetSH": {
1270                             "Profile": "domain",
1271                             "Section": "logging",
1272                             "Option": "MaxFileSize",
1273                         },
1274                     },
1275                     "WfwPrivateLoggingMaxFileSize": {
1276                         "Policy": "Network firewall: Private: Logging: Size limit (KB)",
1277                         "lgpo_section": self.windows_firewall_gpedit_path,
1278                         "Settings": None,
1279                         "NetSH": {
1280                             "Profile": "private",
1281                             "Section": "logging",
1282                             "Option": "MaxFileSize",
1283                         },
1284                     },
1285                     "WfwPublicLoggingMaxFileSize": {
1286                         "Policy": "Network firewall: Public: Logging: Size limit (KB)",
1287                         "lgpo_section": self.windows_firewall_gpedit_path,
1288                         "Settings": None,
1289                         "NetSH": {
1290                             "Profile": "public",
1291                             "Section": "logging",
1292                             "Option": "MaxFileSize",
1293                         },
1294                     },
1295                     "WfwDomainLoggingAllowedConnections": {
1296                         "Policy": (
1297                             "Network firewall: Domain: Logging: Log successful"
1298                             " connections"
1299                         ),
1300                         "lgpo_section": self.windows_firewall_gpedit_path,
1301                         "Settings": self.firewall_log_packets_connections.keys(),
1302                         "NetSH": {
1303                             "Profile": "domain",
1304                             "Section": "logging",
1305                             "Option": "LogAllowedConnections",
1306                         },
1307                         "Transform": {
1308                             "Get": "_dict_lookup",
1309                             "Put": "_dict_lookup",
1310                             "GetArgs": {
1311                                 "lookup": self.firewall_log_packets_connections,
1312                                 "value_lookup": False,
1313                             },
1314                             "PutArgs": {
1315                                 "lookup": self.firewall_log_packets_connections,
1316                                 "value_lookup": True,
1317                             },
1318                         },
1319                     },
1320                     "WfwPrivateLoggingAllowedConnections": {
1321                         "Policy": (
1322                             "Network firewall: Private: Logging: Log successful"
1323                             " connections"
1324                         ),
1325                         "lgpo_section": self.windows_firewall_gpedit_path,
1326                         "Settings": self.firewall_log_packets_connections.keys(),
1327                         "NetSH": {
1328                             "Profile": "private",
1329                             "Section": "logging",
1330                             "Option": "LogAllowedConnections",
1331                         },
1332                         "Transform": {
1333                             "Get": "_dict_lookup",
1334                             "Put": "_dict_lookup",
1335                             "GetArgs": {
1336                                 "lookup": self.firewall_log_packets_connections,
1337                                 "value_lookup": False,
1338                             },
1339                             "PutArgs": {
1340                                 "lookup": self.firewall_log_packets_connections,
1341                                 "value_lookup": True,
1342                             },
1343                         },
1344                     },
1345                     "WfwPublicLoggingAllowedConnections": {
1346                         "Policy": (
1347                             "Network firewall: Public: Logging: Log successful"
1348                             " connections"
1349                         ),
1350                         "lgpo_section": self.windows_firewall_gpedit_path,
1351                         "Settings": self.firewall_log_packets_connections.keys(),
1352                         "NetSH": {
1353                             "Profile": "public",
1354                             "Section": "logging",
1355                             "Option": "LogAllowedConnections",
1356                         },
1357                         "Transform": {
1358                             "Get": "_dict_lookup",
1359                             "Put": "_dict_lookup",
1360                             "GetArgs": {
1361                                 "lookup": self.firewall_log_packets_connections,
1362                                 "value_lookup": False,
1363                             },
1364                             "PutArgs": {
1365                                 "lookup": self.firewall_log_packets_connections,
1366                                 "value_lookup": True,
1367                             },
1368                         },
1369                     },
1370                     "WfwDomainLoggingDroppedConnections": {
1371                         "Policy": (
1372                             "Network firewall: Domain: Logging: Log dropped packets"
1373                         ),
1374                         "lgpo_section": self.windows_firewall_gpedit_path,
1375                         "Settings": self.firewall_log_packets_connections.keys(),
1376                         "NetSH": {
1377                             "Profile": "domain",
1378                             "Section": "logging",
1379                             "Option": "LogDroppedConnections",
1380                         },
1381                         "Transform": {
1382                             "Get": "_dict_lookup",
1383                             "Put": "_dict_lookup",
1384                             "GetArgs": {
1385                                 "lookup": self.firewall_log_packets_connections,
1386                                 "value_lookup": False,
1387                             },
1388                             "PutArgs": {
1389                                 "lookup": self.firewall_log_packets_connections,
1390                                 "value_lookup": True,
1391                             },
1392                         },
1393                     },
1394                     "WfwPrivateLoggingDroppedConnections": {
1395                         "Policy": (
1396                             "Network firewall: Private: Logging: Log dropped packets"
1397                         ),
1398                         "lgpo_section": self.windows_firewall_gpedit_path,
1399                         "Settings": self.firewall_log_packets_connections.keys(),
1400                         "NetSH": {
1401                             "Profile": "private",
1402                             "Section": "logging",
1403                             "Option": "LogDroppedConnections",
1404                         },
1405                         "Transform": {
1406                             "Get": "_dict_lookup",
1407                             "Put": "_dict_lookup",
1408                             "GetArgs": {
1409                                 "lookup": self.firewall_log_packets_connections,
1410                                 "value_lookup": False,
1411                             },
1412                             "PutArgs": {
1413                                 "lookup": self.firewall_log_packets_connections,
1414                                 "value_lookup": True,
1415                             },
1416                         },
1417                     },
1418                     "WfwPublicLoggingDroppedConnections": {
1419                         "Policy": (
1420                             "Network firewall: Public: Logging: Log dropped packets"
1421                         ),
1422                         "lgpo_section": self.windows_firewall_gpedit_path,
1423                         "Settings": self.firewall_log_packets_connections.keys(),
1424                         "NetSH": {
1425                             "Profile": "public",
1426                             "Section": "logging",
1427                             "Option": "LogDroppedConnections",
1428                         },
1429                         "Transform": {
1430                             "Get": "_dict_lookup",
1431                             "Put": "_dict_lookup",
1432                             "GetArgs": {
1433                                 "lookup": self.firewall_log_packets_connections,
1434                                 "value_lookup": False,
1435                             },
1436                             "PutArgs": {
1437                                 "lookup": self.firewall_log_packets_connections,
1438                                 "value_lookup": True,
1439                             },
1440                         },
1441                     },
1442                     "PasswordHistory": {
1443                         "Policy": "Enforce password history",
1444                         "lgpo_section": self.password_policy_gpedit_path,
1445                         "Settings": {
1446                             "Function": "_in_range_inclusive",
1447                             "Args": {"min": 0, "max": 24},
1448                         },
1449                         "NetUserModal": {"Modal": 0, "Option": "password_hist_len"},
1450                     },
1451                     "MaxPasswordAge": {
1452                         "Policy": "Maximum password age",
1453                         "lgpo_section": self.password_policy_gpedit_path,
1454                         "Settings": {
1455                             "Function": "_in_range_inclusive",
1456                             "Args": {
1457                                 "min": 1,
1458                                 "max": 86313600,
1459                                 "zero_value": 0xFFFFFFFF,
1460                             },
1461                         },
1462                         "NetUserModal": {"Modal": 0, "Option": "max_passwd_age"},
1463                         "Transform": {
1464                             "Get": "_seconds_to_days",
1465                             "Put": "_days_to_seconds",
1466                             "GetArgs": {"zero_value": 0xFFFFFFFF},
1467                             "PutArgs": {"zero_value": 0xFFFFFFFF},
1468                         },
1469                     },
1470                     "MinPasswordAge": {
1471                         "Policy": "Minimum password age",
1472                         "lgpo_section": self.password_policy_gpedit_path,
1473                         "Settings": {
1474                             "Function": "_in_range_inclusive",
1475                             "Args": {"min": 0, "max": 86313600},
1476                         },
1477                         "NetUserModal": {"Modal": 0, "Option": "min_passwd_age"},
1478                         "Transform": {
1479                             "Get": "_seconds_to_days",
1480                             "Put": "_days_to_seconds",
1481                         },
1482                     },
1483                     "MinPasswordLen": {
1484                         "Policy": "Minimum password length",
1485                         "lgpo_section": self.password_policy_gpedit_path,
1486                         "Settings": {
1487                             "Function": "_in_range_inclusive",
1488                             "Args": {"min": 0, "max": 14},
1489                         },
1490                         "NetUserModal": {"Modal": 0, "Option": "min_passwd_len"},
1491                     },
1492                     "PasswordComplexity": {
1493                         "Policy": "Password must meet complexity requirements",
1494                         "lgpo_section": self.password_policy_gpedit_path,
1495                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
1496                         "Secedit": {
1497                             "Option": "PasswordComplexity",
1498                             "Section": "System Access",
1499                         },
1500                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
1501                     },
1502                     "ClearTextPasswords": {
1503                         "Policy": "Store passwords using reversible encryption",
1504                         "lgpo_section": self.password_policy_gpedit_path,
1505                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
1506                         "Secedit": {
1507                             "Option": "ClearTextPassword",
1508                             "Section": "System Access",
1509                         },
1510                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
1511                     },
1512                     "AdminAccountStatus": {
1513                         "Policy": "Accounts: Administrator account status",
1514                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
1515                         "lgpo_section": self.security_options_gpedit_path,
1516                         "Secedit": {
1517                             "Option": "EnableAdminAccount",
1518                             "Section": "System Access",
1519                         },
1520                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
1521                     },
1522                     "NoConnectedUser": {
1523                         "Policy": "Accounts: Block Microsoft accounts",
1524                         "Settings": self.block_ms_accounts.keys(),
1525                         "lgpo_section": self.security_options_gpedit_path,
1526                         "Registry": {
1527                             "Hive": "HKEY_LOCAL_MACHINE",
1528                             "Path": (
1529                                 "SOFTWARE\\Microsoft\\Windows\\"
1530                                 "CurrentVersion\\policies\\system"
1531                             ),
1532                             "Value": "NoConnectedUser",
1533                             "Type": "REG_DWORD",
1534                         },
1535                         "Transform": {
1536                             "Get": "_dict_lookup",
1537                             "Put": "_dict_lookup",
1538                             "GetArgs": {
1539                                 "lookup": self.block_ms_accounts,
1540                                 "value_lookup": False,
1541                             },
1542                             "PutArgs": {
1543                                 "lookup": self.block_ms_accounts,
1544                                 "value_lookup": True,
1545                             },
1546                         },
1547                     },
1548                     "GuestAccountStatus": {
1549                         "Policy": "Accounts: Guest account status",
1550                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
1551                         "lgpo_section": self.security_options_gpedit_path,
1552                         "Secedit": {
1553                             "Option": "EnableGuestAccount",
1554                             "Section": "System Access",
1555                         },
1556                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
1557                     },
1558                     "LimitBlankPasswordUse": {
1559                         "Policy": (
1560                             "Accounts: Limit local account use of blank "
1561                             "passwords to console logon only"
1562                         ),
1563                         "lgpo_section": self.security_options_gpedit_path,
1564                         "Settings": self.enabled_one_disabled_zero.keys(),
1565                         "Registry": {
1566                             "Hive": "HKEY_LOCAL_MACHINE",
1567                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
1568                             "Value": "limitblankpassworduse",
1569                             "Type": "REG_DWORD",
1570                         },
1571                         "Transform": self.enabled_one_disabled_zero_transform,
1572                     },
1573                     "RenameAdministratorAccount": {
1574                         "Policy": "Accounts: Rename administrator account",
1575                         "Settings": None,
1576                         "lgpo_section": self.security_options_gpedit_path,
1577                         "Secedit": {
1578                             "Option": "NewAdministratorName",
1579                             "Section": "System Access",
1580                         },
1581                         "Transform": {"Get": "_strip_quotes", "Put": "_add_quotes"},
1582                     },
1583                     "RenameGuestAccount": {
1584                         "Policy": "Accounts: Rename guest account",
1585                         "Settings": None,
1586                         "lgpo_section": self.security_options_gpedit_path,
1587                         "Secedit": {
1588                             "Option": "NewGuestName",
1589                             "Section": "System Access",
1590                         },
1591                         "Transform": {"Get": "_strip_quotes", "Put": "_add_quotes"},
1592                     },
1593                     "AuditBaseObjects": {
1594                         "Policy": "Audit: Audit the access of global system objects",
1595                         "Settings": self.enabled_one_disabled_zero.keys(),
1596                         "lgpo_section": self.security_options_gpedit_path,
1597                         "Registry": {
1598                             "Hive": "HKEY_LOCAL_MACHINE",
1599                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
1600                             "Value": "AuditBaseObjects",
1601                             "Type": "REG_DWORD",
1602                         },
1603                         "Transform": self.enabled_one_disabled_zero_transform,
1604                     },
1605                     "SceNoApplyLegacyAuditPolicy": {
1606                         "Policy": (
1607                             "Audit: Force audit policy subcategory "
1608                             "settings (Windows Vista or later) to "
1609                             "override audit policy category settings"
1610                         ),
1611                         "Settings": self.enabled_one_disabled_zero.keys(),
1612                         "lgpo_section": self.security_options_gpedit_path,
1613                         "Registry": {
1614                             "Hive": "HKEY_LOCAL_MACHINE",
1615                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
1616                             "Value": "SCENoApplyLegacyAuditPolicy",
1617                             "Type": "REG_DWORD",
1618                         },
1619                         "Transform": self.enabled_one_disabled_zero_transform,
1620                     },
1621                     "DontDisplayLastUserName": {
1622                         "Policy": "Interactive logon: Do not display last user name",
1623                         "Settings": self.enabled_one_disabled_zero.keys(),
1624                         "lgpo_section": self.security_options_gpedit_path,
1625                         "Registry": {
1626                             "Hive": "HKEY_LOCAL_MACHINE",
1627                             "Path": (
1628                                 "Software\\Microsoft\\Windows\\"
1629                                 "CurrentVersion\\Policies\\System"
1630                             ),
1631                             "Value": "DontDisplayLastUserName",
1632                             "Type": "REG_DWORD",
1633                         },
1634                         "Transform": self.enabled_one_disabled_zero_transform,
1635                     },
1636                     "CachedLogonsCount": {
1637                         "Policy": (
1638                             "Interactive logon: Number of previous "
1639                             "logons to cache (in case domain controller "
1640                             "is not available)"
1641                         ),
1642                         "Settings": {
1643                             "Function": "_in_range_inclusive",
1644                             "Args": {"min": 0, "max": 50},
1645                         },
1646                         "lgpo_section": self.security_options_gpedit_path,
1647                         "Registry": {
1648                             "Hive": "HKEY_LOCAL_MACHINE",
1649                             "Path": (
1650                                 "Software\\Microsoft\\Windows NT\\"
1651                                 "CurrentVersion\\Winlogon"
1652                             ),
1653                             "Value": "CachedLogonsCount",
1654                             "Type": "REG_SZ",
1655                         },
1656                     },
1657                     "ForceUnlockLogon": {
1658                         "Policy": (
1659                             "Interactive logon: Require Domain "
1660                             "Controller authentication to unlock "
1661                             "workstation"
1662                         ),
1663                         "Settings": self.enabled_one_disabled_zero.keys(),
1664                         "lgpo_section": self.security_options_gpedit_path,
1665                         "Registry": {
1666                             "Hive": "HKEY_LOCAL_MACHINE",
1667                             "Path": (
1668                                 "Software\\Microsoft\\Windows NT\\"
1669                                 "CurrentVersion\\Winlogon"
1670                             ),
1671                             "Value": "ForceUnlockLogon",
1672                             "Type": "REG_DWORD",
1673                         },
1674                         "Transform": self.enabled_one_disabled_zero_transform,
1675                     },
1676                     "ScRemoveOption": {
1677                         "Policy": "Interactive logon: Smart card removal behavior",
1678                         "Settings": self.sc_removal_lookup.keys(),
1679                         "lgpo_section": self.security_options_gpedit_path,
1680                         "Registry": {
1681                             "Hive": "HKEY_LOCAL_MACHINE",
1682                             "Path": (
1683                                 "Software\\Microsoft\\Windows NT\\"
1684                                 "CurrentVersion\\Winlogon"
1685                             ),
1686                             "Value": "ScRemoveOption",
1687                             "Type": "REG_SZ",
1688                         },
1689                         "Transform": {
1690                             "Get": "_dict_lookup",
1691                             "Put": "_dict_lookup",
1692                             "GetArgs": {
1693                                 "lookup": self.sc_removal_lookup,
1694                                 "value_lookup": False,
1695                             },
1696                             "PutArgs": {
1697                                 "lookup": self.sc_removal_lookup,
1698                                 "value_lookup": True,
1699                             },
1700                         },
1701                     },
1702                     "DisableCAD": {
1703                         "Policy": "Interactive logon: Do not require CTRL+ALT+DEL",
1704                         "Settings": self.enabled_one_disabled_zero.keys(),
1705                         "lgpo_section": self.security_options_gpedit_path,
1706                         "Registry": {
1707                             "Hive": "HKEY_LOCAL_MACHINE",
1708                             "Path": (
1709                                 "Software\\Microsoft\\Windows\\"
1710                                 "CurrentVersion\\Policies\\System"
1711                             ),
1712                             "Value": "DisableCAD",
1713                             "Type": "REG_DWORD",
1714                         },
1715                         "Transform": self.enabled_one_disabled_zero_transform,
1716                     },
1717                     "FilterAdministratorToken": {
1718                         "Policy": (
1719                             "User Account Control: Admin Approval Mode "
1720                             "for the built-in Administrator account"
1721                         ),
1722                         "Settings": self.enabled_one_disabled_zero.keys(),
1723                         "lgpo_section": self.security_options_gpedit_path,
1724                         "Registry": {
1725                             "Hive": "HKEY_LOCAL_MACHINE",
1726                             "Path": (
1727                                 "Software\\Microsoft\\Windows\\"
1728                                 "CurrentVersion\\Policies\\System"
1729                             ),
1730                             "Value": "FilterAdministratorToken",
1731                             "Type": "REG_DWORD",
1732                         },
1733                         "Transform": self.enabled_one_disabled_zero_transform,
1734                     },
1735                     "EnableUIADesktopToggle": {
1736                         "Policy": (
1737                             "User Account Control: Allow UIAccess "
1738                             "applications to prompt for elevation "
1739                             "without using the secure desktop"
1740                         ),
1741                         "Settings": self.enabled_one_disabled_zero.keys(),
1742                         "lgpo_section": self.security_options_gpedit_path,
1743                         "Registry": {
1744                             "Hive": "HKEY_LOCAL_MACHINE",
1745                             "Path": (
1746                                 "Software\\Microsoft\\Windows\\"
1747                                 "CurrentVersion\\Policies\\System"
1748                             ),
1749                             "Value": "EnableUIADesktopToggle",
1750                             "Type": "REG_DWORD",
1751                         },
1752                         "Transform": self.enabled_one_disabled_zero_transform,
1753                     },
1754                     "ConsentPromptBehaviorAdmin": {
1755                         "Policy": (
1756                             "User Account Control: Behavior of the "
1757                             "elevation prompt for administrators in "
1758                             "Admin Approval Mode"
1759                         ),
1760                         "Settings": self.uac_admin_prompt_lookup.keys(),
1761                         "lgpo_section": self.security_options_gpedit_path,
1762                         "Registry": {
1763                             "Hive": "HKEY_LOCAL_MACHINE",
1764                             "Path": (
1765                                 "Software\\Microsoft\\Windows\\"
1766                                 "CurrentVersion\\Policies\\System"
1767                             ),
1768                             "Value": "ConsentPromptBehaviorAdmin",
1769                             "Type": "REG_DWORD",
1770                         },
1771                         "Transform": {
1772                             "Get": "_dict_lookup",
1773                             "Put": "_dict_lookup",
1774                             "GetArgs": {
1775                                 "lookup": self.uac_admin_prompt_lookup,
1776                                 "value_lookup": False,
1777                             },
1778                             "PutArgs": {
1779                                 "lookup": self.uac_admin_prompt_lookup,
1780                                 "value_lookup": True,
1781                             },
1782                         },
1783                     },
1784                     "ConsentPromptBehaviorUser": {
1785                         "Policy": (
1786                             "User Account Control: Behavior of the "
1787                             "elevation prompt for standard users"
1788                         ),
1789                         "Settings": self.uac_user_prompt_lookup.keys(),
1790                         "lgpo_section": self.security_options_gpedit_path,
1791                         "Registry": {
1792                             "Hive": "HKEY_LOCAL_MACHINE",
1793                             "Path": (
1794                                 "Software\\Microsoft\\Windows\\"
1795                                 "CurrentVersion\\Policies\\System"
1796                             ),
1797                             "Value": "ConsentPromptBehaviorUser",
1798                             "Type": "REG_DWORD",
1799                         },
1800                         "Transform": {
1801                             "Get": "_dict_lookup",
1802                             "Put": "_dict_lookup",
1803                             "GetArgs": {
1804                                 "lookup": self.uac_user_prompt_lookup,
1805                                 "value_lookup": False,
1806                             },
1807                             "PutArgs": {
1808                                 "lookup": self.uac_user_prompt_lookup,
1809                                 "value_lookup": True,
1810                             },
1811                         },
1812                     },
1813                     "EnableInstallerDetection": {
1814                         "Policy": (
1815                             "User Account Control: Detect application "
1816                             "installations and prompt for elevation"
1817                         ),
1818                         "Settings": self.enabled_one_disabled_zero.keys(),
1819                         "lgpo_section": self.security_options_gpedit_path,
1820                         "Registry": {
1821                             "Hive": "HKEY_LOCAL_MACHINE",
1822                             "Path": (
1823                                 "Software\\Microsoft\\Windows\\"
1824                                 "CurrentVersion\\Policies\\System"
1825                             ),
1826                             "Value": "EnableInstallerDetection",
1827                             "Type": "REG_DWORD",
1828                         },
1829                         "Transform": self.enabled_one_disabled_zero_transform,
1830                     },
1831                     "ValidateAdminCodeSignatures": {
1832                         "Policy": (
1833                             "User Account Control: Only elevate "
1834                             "executables that are signed and validated"
1835                         ),
1836                         "Settings": self.enabled_one_disabled_zero.keys(),
1837                         "lgpo_section": self.security_options_gpedit_path,
1838                         "Registry": {
1839                             "Hive": "HKEY_LOCAL_MACHINE",
1840                             "Path": (
1841                                 "Software\\Microsoft\\Windows\\"
1842                                 "CurrentVersion\\Policies\\System"
1843                             ),
1844                             "Value": "ValidateAdminCodeSignatures",
1845                             "Type": "REG_DWORD",
1846                         },
1847                         "Transform": self.enabled_one_disabled_zero_transform,
1848                     },
1849                     "EnableSecureUIAPaths": {
1850                         "Policy": (
1851                             "User Account Control: Only elevate UIAccess "
1852                             "applications that are installed in secure "
1853                             "locations"
1854                         ),
1855                         "Settings": self.enabled_one_disabled_zero.keys(),
1856                         "lgpo_section": self.security_options_gpedit_path,
1857                         "Registry": {
1858                             "Hive": "HKEY_LOCAL_MACHINE",
1859                             "Path": (
1860                                 "Software\\Microsoft\\Windows\\"
1861                                 "CurrentVersion\\Policies\\System"
1862                             ),
1863                             "Value": "EnableSecureUIAPaths",
1864                             "Type": "REG_DWORD",
1865                         },
1866                         "Transform": self.enabled_one_disabled_zero_transform,
1867                     },
1868                     "EnableLUA": {
1869                         "Policy": (
1870                             "User Account Control: Run all "
1871                             "administrators in Admin Approval Mode"
1872                         ),
1873                         "Settings": self.enabled_one_disabled_zero.keys(),
1874                         "lgpo_section": self.security_options_gpedit_path,
1875                         "Registry": {
1876                             "Hive": "HKEY_LOCAL_MACHINE",
1877                             "Path": (
1878                                 "Software\\Microsoft\\Windows\\"
1879                                 "CurrentVersion\\Policies\\System"
1880                             ),
1881                             "Value": "EnableLUA",
1882                             "Type": "REG_DWORD",
1883                         },
1884                         "Transform": self.enabled_one_disabled_zero_transform,
1885                     },
1886                     "PromptOnSecureDesktop": {
1887                         "Policy": (
1888                             "User Account Control: Switch to the secure "
1889                             "desktop when prompting for elevation"
1890                         ),
1891                         "Settings": self.enabled_one_disabled_zero.keys(),
1892                         "lgpo_section": self.security_options_gpedit_path,
1893                         "Registry": {
1894                             "Hive": "HKEY_LOCAL_MACHINE",
1895                             "Path": (
1896                                 "Software\\Microsoft\\Windows\\"
1897                                 "CurrentVersion\\Policies\\System"
1898                             ),
1899                             "Value": "PromptOnSecureDesktop",
1900                             "Type": "REG_DWORD",
1901                         },
1902                         "Transform": self.enabled_one_disabled_zero_transform,
1903                     },
1904                     "EnableVirtualization": {
1905                         "Policy": (
1906                             "User Account Control: Virtualize file and "
1907                             "registry write failures to per-user "
1908                             "locations"
1909                         ),
1910                         "Settings": self.enabled_one_disabled_zero.keys(),
1911                         "lgpo_section": self.security_options_gpedit_path,
1912                         "Registry": {
1913                             "Hive": "HKEY_LOCAL_MACHINE",
1914                             "Path": (
1915                                 "Software\\Microsoft\\Windows\\"
1916                                 "CurrentVersion\\Policies\\System"
1917                             ),
1918                             "Value": "EnableVirtualization",
1919                             "Type": "REG_DWORD",
1920                         },
1921                         "Transform": self.enabled_one_disabled_zero_transform,
1922                     },
1923                     "PasswordExpiryWarning": {
1924                         "Policy": (
1925                             "Interactive logon: Prompt user to change "
1926                             "password before expiration"
1927                         ),
1928                         "Settings": {
1929                             "Function": "_in_range_inclusive",
1930                             "Args": {"min": 0, "max": 999},
1931                         },
1932                         "lgpo_section": self.security_options_gpedit_path,
1933                         "Registry": {
1934                             "Hive": "HKEY_LOCAL_MACHINE",
1935                             "Path": (
1936                                 "Software\\Microsoft\\Windows NT\\"
1937                                 "CurrentVersion\\Winlogon"
1938                             ),
1939                             "Value": "PasswordExpiryWarning",
1940                             "Type": "REG_DWORD",
1941                         },
1942                     },
1943                     "MaxDevicePasswordFailedAttempts": {
1944                         "Policy": (
1945                             "Interactive logon: Machine account lockout threshold"
1946                         ),
1947                         "Settings": {
1948                             "Function": "_in_range_inclusive",
1949                             "Args": {"min": 0, "max": 999},
1950                         },
1951                         "lgpo_section": self.security_options_gpedit_path,
1952                         "Registry": {
1953                             "Hive": "HKEY_LOCAL_MACHINE",
1954                             "Path": (
1955                                 "SOFTWARE\\Microsoft\\Windows\\"
1956                                 "CurrentVersion\\policies\\system"
1957                             ),
1958                             "Value": "MaxDevicePasswordFailedAttempts",
1959                             "Type": "REG_DWORD",
1960                         },
1961                     },
1962                     "InactivityTimeoutSecs": {
1963                         "Policy": "Interactive logon: Machine inactivity limit",
1964                         "Settings": {
1965                             "Function": "_in_range_inclusive",
1966                             "Args": {"min": 0, "max": 599940},
1967                         },
1968                         "lgpo_section": self.security_options_gpedit_path,
1969                         "Registry": {
1970                             "Hive": "HKEY_LOCAL_MACHINE",
1971                             "Path": (
1972                                 "SOFTWARE\\Microsoft\\Windows\\"
1973                                 "CurrentVersion\\policies\\system"
1974                             ),
1975                             "Value": "InactivityTimeoutSecs",
1976                             "Type": "REG_DWORD",
1977                         },
1978                     },
1979                     "legalnoticetext": {
1980                         "Policy": (
1981                             "Interactive logon: Message text for users "
1982                             "attempting to log on"
1983                         ),
1984                         "lgpo_section": self.security_options_gpedit_path,
1985                         "Registry": {
1986                             "Hive": "HKEY_LOCAL_MACHINE",
1987                             "Path": (
1988                                 "SOFTWARE\\Microsoft\\Windows\\"
1989                                 "CurrentVersion\\policies\\system"
1990                             ),
1991                             "Value": "legalnoticetext",
1992                             "Type": "REG_SZ",
1993                         },
1994                         "Transform": {"Put": "_string_put_transform"},
1995                     },
1996                     "legalnoticecaption": {
1997                         "Policy": (
1998                             "Interactive logon: Message title for users "
1999                             "attempting to log on"
2000                         ),
2001                         "lgpo_section": self.security_options_gpedit_path,
2002                         "Registry": {
2003                             "Hive": "HKEY_LOCAL_MACHINE",
2004                             "Path": (
2005                                 "SOFTWARE\\Microsoft\\Windows\\"
2006                                 "CurrentVersion\\policies\\system"
2007                             ),
2008                             "Value": "legalnoticecaption",
2009                             "Type": "REG_SZ",
2010                         },
2011                         "Transform": {"Put": "_string_put_transform"},
2012                     },
2013                     "DontDisplayLockedUserId": {
2014                         "Policy": (
2015                             "Interactive logon: Display user information "
2016                             "when the session is locked"
2017                         ),
2018                         "Settings": self.locked_session_user_info.keys(),
2019                         "lgpo_section": self.security_options_gpedit_path,
2020                         "Registry": {
2021                             "Hive": "HKEY_LOCAL_MACHINE",
2022                             "Path": (
2023                                 "SOFTWARE\\Microsoft\\Windows\\"
2024                                 "CurrentVersion\\policies\\system"
2025                             ),
2026                             "Value": "DontDisplayLockedUserId",
2027                             "Type": "REG_DWORD",
2028                         },
2029                         "Transform": {
2030                             "Get": "_dict_lookup",
2031                             "Put": "_dict_lookup",
2032                             "GetArgs": {
2033                                 "lookup": self.locked_session_user_info,
2034                                 "value_lookup": False,
2035                             },
2036                             "PutArgs": {
2037                                 "lookup": self.locked_session_user_info,
2038                                 "value_lookup": True,
2039                             },
2040                         },
2041                     },
2042                     "ScForceOption": {
2043                         "Policy": "Interactive logon: Require smart card",
2044                         "Settings": self.enabled_one_disabled_zero.keys(),
2045                         "lgpo_section": self.security_options_gpedit_path,
2046                         "Registry": {
2047                             "Hive": "HKEY_LOCAL_MACHINE",
2048                             "Path": (
2049                                 "Software\\Microsoft\\Windows\\"
2050                                 "CurrentVersion\\Policies\\System"
2051                             ),
2052                             "Value": "ScForceOption",
2053                             "Type": "REG_DWORD",
2054                         },
2055                         "Transform": self.enabled_one_disabled_zero_transform,
2056                     },
2057                     "Client_RequireSecuritySignature": {
2058                         "Policy": (
2059                             "Microsoft network client: Digitally sign "
2060                             "communications (always)"
2061                         ),
2062                         "Settings": self.enabled_one_disabled_zero.keys(),
2063                         "lgpo_section": self.security_options_gpedit_path,
2064                         "Registry": {
2065                             "Hive": "HKEY_LOCAL_MACHINE",
2066                             "Path": (
2067                                 "SYSTEM\\CurrentControlSet\\Services\\"
2068                                 "LanmanWorkstation\\Parameters"
2069                             ),
2070                             "Value": "RequireSecuritySignature",
2071                             "Type": "REG_DWORD",
2072                         },
2073                         "Transform": self.enabled_one_disabled_zero_transform,
2074                     },
2075                     "Client_EnableSecuritySignature": {
2076                         "Policy": (
2077                             "Microsoft network client: Digitally sign "
2078                             "communications (if server agrees)"
2079                         ),
2080                         "Settings": self.enabled_one_disabled_zero.keys(),
2081                         "lgpo_section": self.security_options_gpedit_path,
2082                         "Registry": {
2083                             "Hive": "HKEY_LOCAL_MACHINE",
2084                             "Path": (
2085                                 "SYSTEM\\CurrentControlSet\\Services\\"
2086                                 "LanmanWorkstation\\Parameters"
2087                             ),
2088                             "Value": "EnableSecuritySignature",
2089                             "Type": "REG_DWORD",
2090                         },
2091                         "Transform": self.enabled_one_disabled_zero_transform,
2092                     },
2093                     "EnablePlainTextPassword": {
2094                         "Policy": (
2095                             "Microsoft network client: Send unencrypted "
2096                             "password to third-party SMB servers"
2097                         ),
2098                         "Settings": self.enabled_one_disabled_zero.keys(),
2099                         "lgpo_section": self.security_options_gpedit_path,
2100                         "Registry": {
2101                             "Hive": "HKEY_LOCAL_MACHINE",
2102                             "Path": (
2103                                 "SYSTEM\\CurrentControlSet\\Services\\"
2104                                 "LanmanWorkstation\\Parameters"
2105                             ),
2106                             "Value": "EnablePlainTextPassword",
2107                             "Type": "REG_DWORD",
2108                         },
2109                         "Transform": self.enabled_one_disabled_zero_transform,
2110                     },
2111                     "AutoDisconnect": {
2112                         "Policy": (
2113                             "Microsoft network server: Amount of idle "
2114                             "time required before suspending session"
2115                         ),
2116                         "Settings": {
2117                             "Function": "_in_range_inclusive",
2118                             "Args": {"min": 0, "max": 99999},
2119                         },
2120                         "lgpo_section": self.security_options_gpedit_path,
2121                         "Registry": {
2122                             "Hive": "HKEY_LOCAL_MACHINE",
2123                             "Path": (
2124                                 "System\\CurrentControlSet\\Services\\"
2125                                 "LanmanServer\\Parameters"
2126                             ),
2127                             "Value": "AutoDisconnect",
2128                             "Type": "REG_DWORD",
2129                         },
2130                     },
2131                     "EnableS4U2SelfForClaims": {
2132                         "Policy": (
2133                             "Microsoft network server: Attempt S4U2Self "
2134                             "to obtain claim information"
2135                         ),
2136                         "Settings": self.s4u2self_options.keys(),
2137                         "lgpo_section": self.security_options_gpedit_path,
2138                         "Registry": {
2139                             "Hive": "HKEY_LOCAL_MACHINE",
2140                             "Path": (
2141                                 "System\\CurrentControlSet\\Services\\"
2142                                 "LanmanServer\\Parameters"
2143                             ),
2144                             "Value": "EnableS4U2SelfForClaims",
2145                             "Type": "REG_DWORD",
2146                         },
2147                         "Transform": {
2148                             "Get": "_dict_lookup",
2149                             "Put": "_dict_lookup",
2150                             "GetArgs": {
2151                                 "lookup": self.s4u2self_options,
2152                                 "value_lookup": False,
2153                             },
2154                             "PutArgs": {
2155                                 "lookup": self.s4u2self_options,
2156                                 "value_lookup": True,
2157                             },
2158                         },
2159                     },
2160                     "Server_RequireSecuritySignature": {
2161                         "Policy": (
2162                             "Microsoft network server: Digitally sign "
2163                             "communications (always)"
2164                         ),
2165                         "Settings": self.enabled_one_disabled_zero.keys(),
2166                         "lgpo_section": self.security_options_gpedit_path,
2167                         "Registry": {
2168                             "Hive": "HKEY_LOCAL_MACHINE",
2169                             "Path": (
2170                                 "SYSTEM\\CurrentControlSet\\Services\\"
2171                                 "LanmanServer\\Parameters"
2172                             ),
2173                             "Value": "RequireSecuritySignature",
2174                             "Type": "REG_DWORD",
2175                         },
2176                         "Transform": self.enabled_one_disabled_zero_transform,
2177                     },
2178                     "Server_EnableSecuritySignature": {
2179                         "Policy": (
2180                             "Microsoft network server: Digitally sign "
2181                             "communications (if client agrees)"
2182                         ),
2183                         "Settings": self.enabled_one_disabled_zero.keys(),
2184                         "lgpo_section": self.security_options_gpedit_path,
2185                         "Registry": {
2186                             "Hive": "HKEY_LOCAL_MACHINE",
2187                             "Path": (
2188                                 "SYSTEM\\CurrentControlSet\\Services\\"
2189                                 "LanmanServer\\Parameters"
2190                             ),
2191                             "Value": "EnableSecuritySignature",
2192                             "Type": "REG_DWORD",
2193                         },
2194                         "Transform": self.enabled_one_disabled_zero_transform,
2195                     },
2196                     "EnableForcedLogoff": {
2197                         "Policy": (
2198                             "Microsoft network server: Disconnect "
2199                             "clients when logon hours expire"
2200                         ),
2201                         "Settings": self.enabled_one_disabled_zero.keys(),
2202                         "lgpo_section": self.security_options_gpedit_path,
2203                         "Registry": {
2204                             "Hive": "HKEY_LOCAL_MACHINE",
2205                             "Path": (
2206                                 "SYSTEM\\CurrentControlSet\\Services\\"
2207                                 "LanmanServer\\Parameters"
2208                             ),
2209                             "Value": "EnableForcedLogoff",
2210                             "Type": "REG_DWORD",
2211                         },
2212                         "Transform": self.enabled_one_disabled_zero_transform,
2213                     },
2214                     "SmbServerNameHardeningLevel": {
2215                         "Policy": (
2216                             "Microsoft network server: Server SPN target "
2217                             "name validation level"
2218                         ),
2219                         "Settings": self.smb_server_name_hardening_levels.keys(),
2220                         "lgpo_section": self.security_options_gpedit_path,
2221                         "Registry": {
2222                             "Hive": "HKEY_LOCAL_MACHINE",
2223                             "Path": (
2224                                 "System\\CurrentControlSet\\Services\\"
2225                                 "LanmanServer\\Parameters"
2226                             ),
2227                             "Value": "SmbServerNameHardeningLevel",
2228                             "Type": "REG_DWORD",
2229                         },
2230                         "Transform": {
2231                             "Get": "_dict_lookup",
2232                             "Put": "_dict_lookup",
2233                             "GetArgs": {
2234                                 "lookup": self.smb_server_name_hardening_levels,
2235                                 "value_lookup": False,
2236                             },
2237                             "PutArgs": {
2238                                 "lookup": self.smb_server_name_hardening_levels,
2239                                 "value_lookup": True,
2240                             },
2241                         },
2242                     },
2243                     "FullPrivilegeAuditing": {
2244                         "Policy": (
2245                             "Audit: Audit the use of Backup and Restore privilege"
2246                         ),
2247                         "Settings": [chr(0), chr(1)],
2248                         "lgpo_section": self.security_options_gpedit_path,
2249                         "Registry": {
2250                             "Hive": "HKEY_LOCAL_MACHINE",
2251                             "Path": "System\\CurrentControlSet\\Control\\Lsa",
2252                             "Value": "FullPrivilegeAuditing",
2253                             "Type": "REG_BINARY",
2254                         },
2255                         "Transform": {
2256                             "Get": "_binary_enable_zero_disable_one_conversion",
2257                             "Put": "_binary_enable_zero_disable_one_reverse_conversion",
2258                         },
2259                     },
2260                     "CrashOnAuditFail": {
2261                         "Policy": (
2262                             "Audit: Shut down system immediately if "
2263                             "unable to log security audits"
2264                         ),
2265                         "Settings": self.enabled_one_disabled_zero.keys(),
2266                         "lgpo_section": self.security_options_gpedit_path,
2267                         "Registry": {
2268                             "Hive": "HKEY_LOCAL_MACHINE",
2269                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
2270                             "Value": "CrashOnAuditFail",
2271                             "Type": "REG_DWORD",
2272                         },
2273                         "Transform": self.enabled_one_disabled_zero_transform,
2274                     },
2275                     "UndockWithoutLogon": {
2276                         "Policy": "Devices: Allow undock without having to log on",
2277                         "Settings": self.enabled_one_disabled_zero.keys(),
2278                         "lgpo_section": self.security_options_gpedit_path,
2279                         "Registry": {
2280                             "Hive": "HKEY_LOCAL_MACHINE",
2281                             "Path": (
2282                                 "Software\\Microsoft\\Windows\\"
2283                                 "CurrentVersion\\Policies\\System"
2284                             ),
2285                             "Value": "UndockWithoutLogon",
2286                             "Type": "REG_DWORD",
2287                         },
2288                         "Transform": self.enabled_one_disabled_zero_transform,
2289                     },
2290                     "AddPrinterDrivers": {
2291                         "Policy": (
2292                             "Devices: Prevent users from installing printer drivers"
2293                         ),
2294                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2295                         "lgpo_section": self.security_options_gpedit_path,
2296                         "Registry": {
2297                             "Hive": "HKEY_LOCAL_MACHINE",
2298                             "Path": (
2299                                 "System\\CurrentControlSet\\Control\\"
2300                                 "Print\\Providers\\LanMan Print Services\\"
2301                                 "Servers"
2302                             ),
2303                             "Value": "AddPrinterDrivers",
2304                             "Type": "REG_DWORD",
2305                         },
2306                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2307                     },
2308                     "AllocateDASD": {
2309                         "Policy": (
2310                             "Devices: Allowed to format and eject removable media"
2311                         ),
2312                         "Settings": ["9999", "0", "1", "2"],
2313                         "lgpo_section": self.security_options_gpedit_path,
2314                         "Registry": {
2315                             "Hive": "HKEY_LOCAL_MACHINE",
2316                             "Path": (
2317                                 "Software\\Microsoft\\Windows NT\\"
2318                                 "CurrentVersion\\Winlogon"
2319                             ),
2320                             "Value": "AllocateDASD",
2321                             "Type": "REG_SZ",
2322                         },
2323                         "Transform": {
2324                             "Get": "_dasd_conversion",
2325                             "Put": "_dasd_reverse_conversion",
2326                         },
2327                     },
2328                     "AllocateCDRoms": {
2329                         "Policy": (
2330                             "Devices: Restrict CD-ROM access to locally "
2331                             "logged-on user only"
2332                         ),
2333                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2334                         "lgpo_section": self.security_options_gpedit_path,
2335                         "Registry": {
2336                             "Hive": "HKEY_LOCAL_MACHINE",
2337                             "Path": (
2338                                 "Software\\Microsoft\\Windows NT\\"
2339                                 "CurrentVersion\\Winlogon"
2340                             ),
2341                             "Value": "AllocateCDRoms",
2342                             "Type": "REG_SZ",
2343                         },
2344                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2345                     },
2346                     "AllocateFloppies": {
2347                         "Policy": (
2348                             "Devices: Restrict floppy access to locally "
2349                             "logged-on user only"
2350                         ),
2351                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2352                         "lgpo_section": self.security_options_gpedit_path,
2353                         "Registry": {
2354                             "Hive": "HKEY_LOCAL_MACHINE",
2355                             "Path": (
2356                                 "Software\\Microsoft\\Windows NT\\"
2357                                 "CurrentVersion\\Winlogon"
2358                             ),
2359                             "Value": "AllocateFloppies",
2360                             "Type": "REG_SZ",
2361                         },
2362                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2363                     },
2364                     "DriverSigningPolicy": {
2365                         "Policy": "Devices: Unsigned driver installation behavior",
2366                         "Settings": ["3,0", "3," + chr(1), "3," + chr(2)],
2367                         "lgpo_section": self.security_options_gpedit_path,
2368                         "Secedit": {
2369                             "Option": (
2370                                 "MACHINE\\Software\\Microsoft\\Driver Signing\\Policy"
2371                             ),
2372                             "Section": "Registry Values",
2373                         },
2374                         "Transform": {
2375                             "Get": "_driver_signing_reg_conversion",
2376                             "Put": "_driver_signing_reg_reverse_conversion",
2377                         },
2378                     },
2379                     "SubmitControl": {
2380                         "Policy": (
2381                             "Domain controller: Allow server operators "
2382                             "to schedule tasks"
2383                         ),
2384                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2385                         "lgpo_section": self.security_options_gpedit_path,
2386                         "Registry": {
2387                             "Hive": "HKEY_LOCAL_MACHINE",
2388                             "Path": "System\\CurrentControlSet\\Control\\Lsa",
2389                             "Value": "SubmitControl",
2390                             "Type": "REG_DWORD",
2391                         },
2392                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2393                     },
2394                     "LDAPServerIntegrity": {
2395                         "Policy": "Domain controller: LDAP server signing requirements",
2396                         "Settings": self.ldap_server_signing_requirements.keys(),
2397                         "lgpo_section": self.security_options_gpedit_path,
2398                         "Registry": {
2399                             "Hive": "HKEY_LOCAL_MACHINE",
2400                             "Path": (
2401                                 "System\\CurrentControlSet\\Services\\NTDS\\Parameters"
2402                             ),
2403                             "Value": "LDAPServerIntegrity",
2404                             "Type": "REG_DWORD",
2405                         },
2406                         "Transform": {
2407                             "Get": "_dict_lookup",
2408                             "Put": "_dict_lookup",
2409                             "GetArgs": {
2410                                 "lookup": self.ldap_server_signing_requirements,
2411                                 "value_lookup": False,
2412                             },
2413                             "PutArgs": {
2414                                 "lookup": self.ldap_server_signing_requirements,
2415                                 "value_lookup": True,
2416                             },
2417                         },
2418                     },
2419                     "RefusePasswordChange": {
2420                         "Policy": (
2421                             "Domain controller: Refuse machine account password changes"
2422                         ),
2423                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2424                         "lgpo_section": self.security_options_gpedit_path,
2425                         "Registry": {
2426                             "Hive": "HKEY_LOCAL_MACHINE",
2427                             "Path": (
2428                                 "SYSTEM\\CurrentControlSet\\Services\\"
2429                                 "Netlogon\\Parameters"
2430                             ),
2431                             "Value": "RefusePasswordChange",
2432                             "Type": "REG_DWORD",
2433                         },
2434                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2435                     },
2436                     "RequireSignOrSeal": {
2437                         "Policy": (
2438                             "Domain member: Digitally encrypt or sign "
2439                             "secure channel data (always)"
2440                         ),
2441                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2442                         "lgpo_section": self.security_options_gpedit_path,
2443                         "Registry": {
2444                             "Hive": "HKEY_LOCAL_MACHINE",
2445                             "Path": (
2446                                 "System\\CurrentControlSet\\Services\\"
2447                                 "Netlogon\\Parameters"
2448                             ),
2449                             "Value": "RequireSignOrSeal",
2450                             "Type": "REG_DWORD",
2451                         },
2452                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2453                     },
2454                     "SealSecureChannel": {
2455                         "Policy": (
2456                             "Domain member: Digitally encrypt secure "
2457                             "channel data (when possible)"
2458                         ),
2459                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2460                         "lgpo_section": self.security_options_gpedit_path,
2461                         "Registry": {
2462                             "Hive": "HKEY_LOCAL_MACHINE",
2463                             "Path": (
2464                                 "System\\CurrentControlSet\\Services\\"
2465                                 "Netlogon\\Parameters"
2466                             ),
2467                             "Value": "SealSecureChannel",
2468                             "Type": "REG_DWORD",
2469                         },
2470                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2471                     },
2472                     "SignSecureChannel": {
2473                         "Policy": (
2474                             "Domain member: Digitally sign secure "
2475                             "channel data (when possible)"
2476                         ),
2477                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2478                         "lgpo_section": self.security_options_gpedit_path,
2479                         "Registry": {
2480                             "Hive": "HKEY_LOCAL_MACHINE",
2481                             "Path": (
2482                                 "System\\CurrentControlSet\\Services\\"
2483                                 "Netlogon\\Parameters"
2484                             ),
2485                             "Value": "SignSecureChannel",
2486                             "Type": "REG_DWORD",
2487                         },
2488                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2489                     },
2490                     "DisablePasswordChange": {
2491                         "Policy": (
2492                             "Domain member: Disable machine account password changes"
2493                         ),
2494                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2495                         "lgpo_section": self.security_options_gpedit_path,
2496                         "Registry": {
2497                             "Hive": "HKEY_LOCAL_MACHINE",
2498                             "Path": (
2499                                 "System\\CurrentControlSet\\Services\\"
2500                                 "Netlogon\\Parameters"
2501                             ),
2502                             "Value": "DisablePasswordChange",
2503                             "Type": "REG_DWORD",
2504                         },
2505                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2506                     },
2507                     "MaximumPasswordAge": {
2508                         "Policy": "Domain member: Maximum machine account password age",
2509                         "Settings": {
2510                             "Function": "_in_range_inclusive",
2511                             "Args": {"min": 0, "max": 999},
2512                         },
2513                         "lgpo_section": self.security_options_gpedit_path,
2514                         "Registry": {
2515                             "Hive": "HKEY_LOCAL_MACHINE",
2516                             "Path": (
2517                                 "System\\CurrentControlSet\\Services\\"
2518                                 "Netlogon\\Parameters"
2519                             ),
2520                             "Value": "MaximumPasswordAge",
2521                             "Type": "REG_DWORD",
2522                         },
2523                     },
2524                     "RequireStrongKey": {
2525                         "Policy": (
2526                             "Domain member: Require strong (Windows 2000 "
2527                             "or later) session key"
2528                         ),
2529                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2530                         "lgpo_section": self.security_options_gpedit_path,
2531                         "Registry": {
2532                             "Hive": "HKEY_LOCAL_MACHINE",
2533                             "Path": (
2534                                 "System\\CurrentControlSet\\Services\\"
2535                                 "Netlogon\\Parameters"
2536                             ),
2537                             "Value": "RequireStrongKey",
2538                             "Type": "REG_DWORD",
2539                         },
2540                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2541                     },
2542                     "LockoutDuration": {
2543                         "Policy": "Account lockout duration",
2544                         "lgpo_section": self.account_lockout_policy_gpedit_path,
2545                         "Settings": {
2546                             "Function": "_in_range_inclusive",
2547                             "Args": {
2548                                 "min": 0,
2549                                 "max": 6000000,
2550                                 "zero_value": 0xFFFFFFFF,
2551                             },
2552                         },
2553                         "NetUserModal": {"Modal": 3, "Option": "lockout_duration"},
2554                         "Transform": {
2555                             "Get": "_seconds_to_minutes",
2556                             "Put": "_minutes_to_seconds",
2557                             "GetArgs": {"zero_value": 0xFFFFFFFF},
2558                             "PutArgs": {"zero_value": 0xFFFFFFFF},
2559                         },
2560                     },
2561                     "LockoutThreshold": {
2562                         "Policy": "Account lockout threshold",
2563                         "lgpo_section": self.account_lockout_policy_gpedit_path,
2564                         "Settings": {
2565                             "Function": "_in_range_inclusive",
2566                             "Args": {"min": 0, "max": 1000},
2567                         },
2568                         "NetUserModal": {"Modal": 3, "Option": "lockout_threshold"},
2569                     },
2570                     "LockoutWindow": {
2571                         "Policy": "Reset account lockout counter after",
2572                         "lgpo_section": self.account_lockout_policy_gpedit_path,
2573                         "Settings": {
2574                             "Function": "_in_range_inclusive",
2575                             "Args": {"min": 0, "max": 6000000},
2576                         },
2577                         "NetUserModal": {
2578                             "Modal": 3,
2579                             "Option": "lockout_observation_window",
2580                         },
2581                         "Transform": {
2582                             "Get": "_seconds_to_minutes",
2583                             "Put": "_minutes_to_seconds",
2584                         },
2585                     },
2586                     "AuditAccountLogon": {
2587                         "Policy": "Audit account logon events",
2588                         "lgpo_section": self.audit_policy_gpedit_path,
2589                         "Settings": self.audit_lookup.keys(),
2590                         "Secedit": {
2591                             "Option": "AuditAccountLogon",
2592                             "Section": "Event Audit",
2593                         },
2594                         "Transform": self.audit_transform,
2595                     },
2596                     "AuditAccountManage": {
2597                         "Policy": "Audit account management",
2598                         "lgpo_section": self.audit_policy_gpedit_path,
2599                         "Settings": self.audit_lookup.keys(),
2600                         "Secedit": {
2601                             "Option": "AuditAccountManage",
2602                             "Section": "Event Audit",
2603                         },
2604                         "Transform": self.audit_transform,
2605                     },
2606                     "AuditDSAccess": {
2607                         "Policy": "Audit directory service access",
2608                         "lgpo_section": self.audit_policy_gpedit_path,
2609                         "Settings": self.audit_lookup.keys(),
2610                         "Secedit": {
2611                             "Option": "AuditDSAccess",
2612                             "Section": "Event Audit",
2613                         },
2614                         "Transform": self.audit_transform,
2615                     },
2616                     "AuditLogonEvents": {
2617                         "Policy": "Audit logon events",
2618                         "lgpo_section": self.audit_policy_gpedit_path,
2619                         "Settings": self.audit_lookup.keys(),
2620                         "Secedit": {
2621                             "Option": "AuditLogonEvents",
2622                             "Section": "Event Audit",
2623                         },
2624                         "Transform": self.audit_transform,
2625                     },
2626                     "AuditObjectAccess": {
2627                         "Policy": "Audit object access",
2628                         "lgpo_section": self.audit_policy_gpedit_path,
2629                         "Settings": self.audit_lookup.keys(),
2630                         "Secedit": {
2631                             "Option": "AuditObjectAccess",
2632                             "Section": "Event Audit",
2633                         },
2634                         "Transform": self.audit_transform,
2635                     },
2636                     "AuditPolicyChange": {
2637                         "Policy": "Audit policy change",
2638                         "lgpo_section": self.audit_policy_gpedit_path,
2639                         "Settings": self.audit_lookup.keys(),
2640                         "Secedit": {
2641                             "Option": "AuditPolicyChange",
2642                             "Section": "Event Audit",
2643                         },
2644                         "Transform": self.audit_transform,
2645                     },
2646                     "AuditPrivilegeUse": {
2647                         "Policy": "Audit privilege use",
2648                         "lgpo_section": self.audit_policy_gpedit_path,
2649                         "Settings": self.audit_lookup.keys(),
2650                         "Secedit": {
2651                             "Option": "AuditPrivilegeUse",
2652                             "Section": "Event Audit",
2653                         },
2654                         "Transform": self.audit_transform,
2655                     },
2656                     "AuditProcessTracking": {
2657                         "Policy": "Audit process tracking",
2658                         "lgpo_section": self.audit_policy_gpedit_path,
2659                         "Settings": self.audit_lookup.keys(),
2660                         "Secedit": {
2661                             "Option": "AuditProcessTracking",
2662                             "Section": "Event Audit",
2663                         },
2664                         "Transform": self.audit_transform,
2665                     },
2666                     "AuditSystemEvents": {
2667                         "Policy": "Audit system events",
2668                         "lgpo_section": self.audit_policy_gpedit_path,
2669                         "Settings": self.audit_lookup.keys(),
2670                         "Secedit": {
2671                             "Option": "AuditSystemEvents",
2672                             "Section": "Event Audit",
2673                         },
2674                         "Transform": self.audit_transform,
2675                     },
2676                     "AuditCredentialValidation": {
2677                         "Policy": "Audit Credential Validation",
2678                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2679                         "Settings": self.advanced_audit_lookup.keys(),
2680                         "AdvAudit": {"Option": "Audit Credential Validation"},
2681                         "Transform": self.advanced_audit_transform,
2682                     },
2683                     "AuditKerberosAuthenticationService": {
2684                         "Policy": "Audit Kerberos Authentication Service",
2685                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2686                         "Settings": self.advanced_audit_lookup.keys(),
2687                         "AdvAudit": {
2688                             "Option": "Audit Kerberos Authentication Service",
2689                         },
2690                         "Transform": self.advanced_audit_transform,
2691                     },
2692                     "AuditKerberosServiceTicketOperations": {
2693                         "Policy": "Audit Kerberos Service Ticket Operations",
2694                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2695                         "Settings": self.advanced_audit_lookup.keys(),
2696                         "AdvAudit": {
2697                             "Option": "Audit Kerberos Service Ticket Operations",
2698                         },
2699                         "Transform": self.advanced_audit_transform,
2700                     },
2701                     "AuditOtherAccountLogonEvents": {
2702                         "Policy": "Audit Other Account Logon Events",
2703                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2704                         "Settings": self.advanced_audit_lookup.keys(),
2705                         "AdvAudit": {"Option": "Audit Other Account Logon Events"},
2706                         "Transform": self.advanced_audit_transform,
2707                     },
2708                     "AuditApplicationGroupManagement": {
2709                         "Policy": "Audit Application Group Management",
2710                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2711                         "Settings": self.advanced_audit_lookup.keys(),
2712                         "AdvAudit": {"Option": "Audit Application Group Management"},
2713                         "Transform": self.advanced_audit_transform,
2714                     },
2715                     "AuditComputerAccountManagement": {
2716                         "Policy": "Audit Computer Account Management",
2717                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2718                         "Settings": self.advanced_audit_lookup.keys(),
2719                         "AdvAudit": {"Option": "Audit Computer Account Management"},
2720                         "Transform": self.advanced_audit_transform,
2721                     },
2722                     "AuditDistributionGroupManagement": {
2723                         "Policy": "Audit Distribution Group Management",
2724                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2725                         "Settings": self.advanced_audit_lookup.keys(),
2726                         "AdvAudit": {"Option": "Audit Distribution Group Management"},
2727                         "Transform": self.advanced_audit_transform,
2728                     },
2729                     "AuditOtherAccountManagementEvents": {
2730                         "Policy": "Audit Other Account Management Events",
2731                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2732                         "Settings": self.advanced_audit_lookup.keys(),
2733                         "AdvAudit": {
2734                             "Option": "Audit Other Account Management Events",
2735                         },
2736                         "Transform": self.advanced_audit_transform,
2737                     },
2738                     "AuditSecurityGroupManagement": {
2739                         "Policy": "Audit Security Group Management",
2740                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2741                         "Settings": self.advanced_audit_lookup.keys(),
2742                         "AdvAudit": {"Option": "Audit Security Group Management"},
2743                         "Transform": self.advanced_audit_transform,
2744                     },
2745                     "AuditUserAccountManagement": {
2746                         "Policy": "Audit User Account Management",
2747                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2748                         "Settings": self.advanced_audit_lookup.keys(),
2749                         "AdvAudit": {"Option": "Audit User Account Management"},
2750                         "Transform": self.advanced_audit_transform,
2751                     },
2752                     "AuditDPAPIActivity": {
2753                         "Policy": "Audit DPAPI Activity",
2754                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2755                         "Settings": self.advanced_audit_lookup.keys(),
2756                         "AdvAudit": {"Option": "Audit DPAPI Activity"},
2757                         "Transform": self.advanced_audit_transform,
2758                     },
2759                     "AuditPNPActivity": {
2760                         "Policy": "Audit PNP Activity",
2761                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2762                         "Settings": self.advanced_audit_lookup.keys(),
2763                         "AdvAudit": {"Option": "Audit PNP Activity"},
2764                         "Transform": self.advanced_audit_transform,
2765                     },
2766                     "AuditProcessCreation": {
2767                         "Policy": "Audit Process Creation",
2768                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2769                         "Settings": self.advanced_audit_lookup.keys(),
2770                         "AdvAudit": {"Option": "Audit Process Creation"},
2771                         "Transform": self.advanced_audit_transform,
2772                     },
2773                     "AuditProcessTermination": {
2774                         "Policy": "Audit Process Termination",
2775                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2776                         "Settings": self.advanced_audit_lookup.keys(),
2777                         "AdvAudit": {"Option": "Audit Process Termination"},
2778                         "Transform": self.advanced_audit_transform,
2779                     },
2780                     "AuditRPCEvents": {
2781                         "Policy": "Audit RPC Events",
2782                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2783                         "Settings": self.advanced_audit_lookup.keys(),
2784                         "AdvAudit": {"Option": "Audit RPC Events"},
2785                         "Transform": self.advanced_audit_transform,
2786                     },
2787                     "AuditTokenRightAdjusted": {
2788                         "Policy": "Audit Token Right Adjusted",
2789                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2790                         "Settings": self.advanced_audit_lookup.keys(),
2791                         "AdvAudit": {"Option": "Audit Token Right Adjusted"},
2792                         "Transform": self.advanced_audit_transform,
2793                     },
2794                     "AuditDetailedDirectoryServiceReplication": {
2795                         "Policy": "Audit Detailed Directory Service Replication",
2796                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2797                         "Settings": self.advanced_audit_lookup.keys(),
2798                         "AdvAudit": {
2799                             "Option": "Audit Detailed Directory Service Replication",
2800                         },
2801                         "Transform": self.advanced_audit_transform,
2802                     },
2803                     "AuditDirectoryServiceAccess": {
2804                         "Policy": "Audit Directory Service Access",
2805                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2806                         "Settings": self.advanced_audit_lookup.keys(),
2807                         "AdvAudit": {"Option": "Audit Directory Service Access"},
2808                         "Transform": self.advanced_audit_transform,
2809                     },
2810                     "AuditDirectoryServiceChanges": {
2811                         "Policy": "Audit Directory Service Changes",
2812                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2813                         "Settings": self.advanced_audit_lookup.keys(),
2814                         "AdvAudit": {"Option": "Audit Directory Service Changes"},
2815                         "Transform": self.advanced_audit_transform,
2816                     },
2817                     "AuditDirectoryServiceReplication": {
2818                         "Policy": "Audit Directory Service Replication",
2819                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2820                         "Settings": self.advanced_audit_lookup.keys(),
2821                         "AdvAudit": {"Option": "Audit Directory Service Replication"},
2822                         "Transform": self.advanced_audit_transform,
2823                     },
2824                     "AuditAccountLockout": {
2825                         "Policy": "Audit Account Lockout",
2826                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2827                         "Settings": self.advanced_audit_lookup.keys(),
2828                         "AdvAudit": {"Option": "Audit Account Lockout"},
2829                         "Transform": self.advanced_audit_transform,
2830                     },
2831                     "AuditUserDeviceClaims": {
2832                         "Policy": "Audit User / Device Claims",
2833                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2834                         "Settings": self.advanced_audit_lookup.keys(),
2835                         "AdvAudit": {"Option": "Audit User / Device Claims"},
2836                         "Transform": self.advanced_audit_transform,
2837                     },
2838                     "AuditGroupMembership": {
2839                         "Policy": "Audit Group Membership",
2840                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2841                         "Settings": self.advanced_audit_lookup.keys(),
2842                         "AdvAudit": {"Option": "Audit Group Membership"},
2843                         "Transform": self.advanced_audit_transform,
2844                     },
2845                     "AuditIPsecExtendedMode": {
2846                         "Policy": "Audit IPsec Extended Mode",
2847                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2848                         "Settings": self.advanced_audit_lookup.keys(),
2849                         "AdvAudit": {"Option": "Audit IPsec Extended Mode"},
2850                         "Transform": self.advanced_audit_transform,
2851                     },
2852                     "AuditIPsecMainMode": {
2853                         "Policy": "Audit IPsec Main Mode",
2854                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2855                         "Settings": self.advanced_audit_lookup.keys(),
2856                         "AdvAudit": {"Option": "Audit IPsec Main Mode"},
2857                         "Transform": self.advanced_audit_transform,
2858                     },
2859                     "AuditIPsecQuickMode": {
2860                         "Policy": "Audit IPsec Quick Mode",
2861                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2862                         "Settings": self.advanced_audit_lookup.keys(),
2863                         "AdvAudit": {"Option": "Audit IPsec Quick Mode"},
2864                         "Transform": self.advanced_audit_transform,
2865                     },
2866                     "AuditLogoff": {
2867                         "Policy": "Audit Logoff",
2868                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2869                         "Settings": self.advanced_audit_lookup.keys(),
2870                         "AdvAudit": {"Option": "Audit Logoff"},
2871                         "Transform": self.advanced_audit_transform,
2872                     },
2873                     "AuditLogon": {
2874                         "Policy": "Audit Logon",
2875                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2876                         "Settings": self.advanced_audit_lookup.keys(),
2877                         "AdvAudit": {"Option": "Audit Logon"},
2878                         "Transform": self.advanced_audit_transform,
2879                     },
2880                     "AuditNetworkPolicyServer": {
2881                         "Policy": "Audit Network Policy Server",
2882                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2883                         "Settings": self.advanced_audit_lookup.keys(),
2884                         "AdvAudit": {"Option": "Audit Network Policy Server"},
2885                         "Transform": self.advanced_audit_transform,
2886                     },
2887                     "AuditOtherLogonLogoffEvents": {
2888                         "Policy": "Audit Other Logon/Logoff Events",
2889                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2890                         "Settings": self.advanced_audit_lookup.keys(),
2891                         "AdvAudit": {"Option": "Audit Other Logon/Logoff Events"},
2892                         "Transform": self.advanced_audit_transform,
2893                     },
2894                     "AuditSpecialLogon": {
2895                         "Policy": "Audit Special Logon",
2896                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2897                         "Settings": self.advanced_audit_lookup.keys(),
2898                         "AdvAudit": {"Option": "Audit Special Logon"},
2899                         "Transform": self.advanced_audit_transform,
2900                     },
2901                     "AuditApplicationGenerated": {
2902                         "Policy": "Audit Application Generated",
2903                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2904                         "Settings": self.advanced_audit_lookup.keys(),
2905                         "AdvAudit": {"Option": "Audit Application Generated"},
2906                         "Transform": self.advanced_audit_transform,
2907                     },
2908                     "AuditCertificationServices": {
2909                         "Policy": "Audit Certification Services",
2910                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2911                         "Settings": self.advanced_audit_lookup.keys(),
2912                         "AdvAudit": {"Option": "Audit Certification Services"},
2913                         "Transform": self.advanced_audit_transform,
2914                     },
2915                     "AuditDetailedFileShare": {
2916                         "Policy": "Audit Detailed File Share",
2917                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2918                         "Settings": self.advanced_audit_lookup.keys(),
2919                         "AdvAudit": {"Option": "Audit Detailed File Share"},
2920                         "Transform": self.advanced_audit_transform,
2921                     },
2922                     "AuditFileShare": {
2923                         "Policy": "Audit File Share",
2924                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2925                         "Settings": self.advanced_audit_lookup.keys(),
2926                         "AdvAudit": {"Option": "Audit File Share"},
2927                         "Transform": self.advanced_audit_transform,
2928                     },
2929                     "AuditFileSystem": {
2930                         "Policy": "Audit File System",
2931                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2932                         "Settings": self.advanced_audit_lookup.keys(),
2933                         "AdvAudit": {"Option": "Audit File System"},
2934                         "Transform": self.advanced_audit_transform,
2935                     },
2936                     "AuditFilteringPlatformConnection": {
2937                         "Policy": "Audit Filtering Platform Connection",
2938                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2939                         "Settings": self.advanced_audit_lookup.keys(),
2940                         "AdvAudit": {"Option": "Audit Filtering Platform Connection"},
2941                         "Transform": self.advanced_audit_transform,
2942                     },
2943                     "AuditFilteringPlatformPacketDrop": {
2944                         "Policy": "Audit Filtering Platform Packet Drop",
2945                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2946                         "Settings": self.advanced_audit_lookup.keys(),
2947                         "AdvAudit": {"Option": "Audit Filtering Platform Packet Drop"},
2948                         "Transform": self.advanced_audit_transform,
2949                     },
2950                     "AuditHandleManipulation": {
2951                         "Policy": "Audit Handle Manipulation",
2952                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2953                         "Settings": self.advanced_audit_lookup.keys(),
2954                         "AdvAudit": {"Option": "Audit Handle Manipulation"},
2955                         "Transform": self.advanced_audit_transform,
2956                     },
2957                     "AuditKernelObject": {
2958                         "Policy": "Audit Kernel Object",
2959                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2960                         "Settings": self.advanced_audit_lookup.keys(),
2961                         "AdvAudit": {"Option": "Audit Kernel Object"},
2962                         "Transform": self.advanced_audit_transform,
2963                     },
2964                     "AuditOtherObjectAccessEvents": {
2965                         "Policy": "Audit Other Object Access Events",
2966                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2967                         "Settings": self.advanced_audit_lookup.keys(),
2968                         "AdvAudit": {"Option": "Audit Other Object Access Events"},
2969                         "Transform": self.advanced_audit_transform,
2970                     },
2971                     "AuditRegistry": {
2972                         "Policy": "Audit Registry",
2973                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2974                         "Settings": self.advanced_audit_lookup.keys(),
2975                         "AdvAudit": {"Option": "Audit Registry"},
2976                         "Transform": self.advanced_audit_transform,
2977                     },
2978                     "AuditRemovableStorage": {
2979                         "Policy": "Audit Removable Storage",
2980                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2981                         "Settings": self.advanced_audit_lookup.keys(),
2982                         "AdvAudit": {"Option": "Audit Removable Storage"},
2983                         "Transform": self.advanced_audit_transform,
2984                     },
2985                     "AuditSAM": {
2986                         "Policy": "Audit SAM",
2987                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2988                         "Settings": self.advanced_audit_lookup.keys(),
2989                         "AdvAudit": {"Option": "Audit SAM"},
2990                         "Transform": self.advanced_audit_transform,
2991                     },
2992                     "AuditCentralAccessPolicyStaging": {
2993                         "Policy": "Audit Central Access Policy Staging",
2994                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2995                         "Settings": self.advanced_audit_lookup.keys(),
2996                         "AdvAudit": {"Option": "Audit Central Access Policy Staging"},
2997                         "Transform": self.advanced_audit_transform,
2998                     },
2999                     "AuditAuditPolicyChange": {
3000                         "Policy": "Audit Audit Policy Change",
3001                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3002                         "Settings": self.advanced_audit_lookup.keys(),
3003                         "AdvAudit": {"Option": "Audit Audit Policy Change"},
3004                         "Transform": self.advanced_audit_transform,
3005                     },
3006                     "AuditAuthenticationPolicyChange": {
3007                         "Policy": "Audit Authentication Policy Change",
3008                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3009                         "Settings": self.advanced_audit_lookup.keys(),
3010                         "AdvAudit": {"Option": "Audit Authentication Policy Change"},
3011                         "Transform": self.advanced_audit_transform,
3012                     },
3013                     "AuditAuthorizationPolicyChange": {
3014                         "Policy": "Audit Authorization Policy Change",
3015                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3016                         "Settings": self.advanced_audit_lookup.keys(),
3017                         "AdvAudit": {"Option": "Audit Authorization Policy Change"},
3018                         "Transform": self.advanced_audit_transform,
3019                     },
3020                     "AuditFilteringPlatformPolicyChange": {
3021                         "Policy": "Audit Filtering Platform Policy Change",
3022                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3023                         "Settings": self.advanced_audit_lookup.keys(),
3024                         "AdvAudit": {
3025                             "Option": "Audit Filtering Platform Policy Change",
3026                         },
3027                         "Transform": self.advanced_audit_transform,
3028                     },
3029                     "AuditMPSSVCRuleLevelPolicyChange": {
3030                         "Policy": "Audit MPSSVC Rule-Level Policy Change",
3031                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3032                         "Settings": self.advanced_audit_lookup.keys(),
3033                         "AdvAudit": {
3034                             "Option": "Audit MPSSVC Rule-Level Policy Change",
3035                         },
3036                         "Transform": self.advanced_audit_transform,
3037                     },
3038                     "AuditOtherPolicyChangeEvents": {
3039                         "Policy": "Audit Other Policy Change Events",
3040                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3041                         "Settings": self.advanced_audit_lookup.keys(),
3042                         "AdvAudit": {"Option": "Audit Other Policy Change Events"},
3043                         "Transform": self.advanced_audit_transform,
3044                     },
3045                     "AuditNonSensitivePrivilegeUse": {
3046                         "Policy": "Audit Non Sensitive Privilege Use",
3047                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3048                         "Settings": self.advanced_audit_lookup.keys(),
3049                         "AdvAudit": {"Option": "Audit Non Sensitive Privilege Use"},
3050                         "Transform": self.advanced_audit_transform,
3051                     },
3052                     "AuditOtherPrivilegeUseEvents": {
3053                         "Policy": "Audit Other Privilege Use Events",
3054                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3055                         "Settings": self.advanced_audit_lookup.keys(),
3056                         "AdvAudit": {"Option": "Audit Other Privilege Use Events"},
3057                         "Transform": self.advanced_audit_transform,
3058                     },
3059                     "AuditSensitivePrivilegeUse": {
3060                         "Policy": "Audit Sensitive Privilege Use",
3061                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3062                         "Settings": self.advanced_audit_lookup.keys(),
3063                         "AdvAudit": {"Option": "Audit Sensitive Privilege Use"},
3064                         "Transform": self.advanced_audit_transform,
3065                     },
3066                     "AuditIPsecDriver": {
3067                         "Policy": "Audit IPsec Driver",
3068                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3069                         "Settings": self.advanced_audit_lookup.keys(),
3070                         "AdvAudit": {"Option": "Audit IPsec Driver"},
3071                         "Transform": self.advanced_audit_transform,
3072                     },
3073                     "AuditOtherSystemEvents": {
3074                         "Policy": "Audit Other System Events",
3075                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3076                         "Settings": self.advanced_audit_lookup.keys(),
3077                         "AdvAudit": {"Option": "Audit Other System Events"},
3078                         "Transform": self.advanced_audit_transform,
3079                     },
3080                     "AuditSecurityStateChange": {
3081                         "Policy": "Audit Security State Change",
3082                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3083                         "Settings": self.advanced_audit_lookup.keys(),
3084                         "AdvAudit": {"Option": "Audit Security State Change"},
3085                         "Transform": self.advanced_audit_transform,
3086                     },
3087                     "AuditSecuritySystemExtension": {
3088                         "Policy": "Audit Security System Extension",
3089                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3090                         "Settings": self.advanced_audit_lookup.keys(),
3091                         "AdvAudit": {"Option": "Audit Security System Extension"},
3092                         "Transform": self.advanced_audit_transform,
3093                     },
3094                     "AuditSystemIntegrity": {
3095                         "Policy": "Audit System Integrity",
3096                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3097                         "Settings": self.advanced_audit_lookup.keys(),
3098                         "AdvAudit": {"Option": "Audit System Integrity"},
3099                         "Transform": self.advanced_audit_transform,
3100                     },
3101                     "SeTrustedCredManAccessPrivilege": {
3102                         "Policy": "Access Credential Manager as a trusted caller",
3103                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3104                         "rights_assignment": True,
3105                         "Settings": None,
3106                         "LsaRights": {"Option": "SeTrustedCredManAccessPrivilege"},
3107                         "Transform": {
3108                             "Get": "_sidConversion",
3109                             "Put": "_usernamesToSidObjects",
3110                         },
3111                     },
3112                     "SeNetworkLogonRight": {
3113                         "Policy": "Access this computer from the network",
3114                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3115                         "rights_assignment": True,
3116                         "Settings": None,
3117                         "LsaRights": {"Option": "SeNetworkLogonRight"},
3118                         "Transform": {
3119                             "Get": "_sidConversion",
3120                             "Put": "_usernamesToSidObjects",
3121                         },
3122                     },
3123                     "SeTcbPrivilege": {
3124                         "Policy": "Act as part of the operating system",
3125                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3126                         "rights_assignment": True,
3127                         "Settings": None,
3128                         "LsaRights": {"Option": "SeTcbPrivilege"},
3129                         "Transform": {
3130                             "Get": "_sidConversion",
3131                             "Put": "_usernamesToSidObjects",
3132                         },
3133                     },
3134                     "SeMachineAccountPrivilege": {
3135                         "Policy": "Add workstations to domain",
3136                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3137                         "rights_assignment": True,
3138                         "Settings": None,
3139                         "LsaRights": {"Option": "SeMachineAccountPrivilege"},
3140                         "Transform": {
3141                             "Get": "_sidConversion",
3142                             "Put": "_usernamesToSidObjects",
3143                         },
3144                     },
3145                     "SeIncreaseQuotaPrivilege": {
3146                         "Policy": "Adjust memory quotas for a process",
3147                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3148                         "rights_assignment": True,
3149                         "Settings": None,
3150                         "LsaRights": {"Option": "SeIncreaseQuotaPrivilege"},
3151                         "Transform": {
3152                             "Get": "_sidConversion",
3153                             "Put": "_usernamesToSidObjects",
3154                         },
3155                     },
3156                     "SeInteractiveLogonRight": {
3157                         "Policy": "Allow log on locally",
3158                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3159                         "rights_assignment": True,
3160                         "Settings": None,
3161                         "LsaRights": {"Option": "SeInteractiveLogonRight"},
3162                         "Transform": {
3163                             "Get": "_sidConversion",
3164                             "Put": "_usernamesToSidObjects",
3165                         },
3166                     },
3167                     "SeRemoteInteractiveLogonRight": {
3168                         "Policy": "Allow log on through Remote Desktop Services",
3169                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3170                         "rights_assignment": True,
3171                         "Settings": None,
3172                         "LsaRights": {"Option": "SeRemoteInteractiveLogonRight"},
3173                         "Transform": {
3174                             "Get": "_sidConversion",
3175                             "Put": "_usernamesToSidObjects",
3176                         },
3177                     },
3178                     "SeBackupPrivilege": {
3179                         "Policy": "Backup files and directories",
3180                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3181                         "rights_assignment": True,
3182                         "Settings": None,
3183                         "LsaRights": {"Option": "SeBackupPrivilege"},
3184                         "Transform": {
3185                             "Get": "_sidConversion",
3186                             "Put": "_usernamesToSidObjects",
3187                         },
3188                     },
3189                     "SeChangeNotifyPrivilege": {
3190                         "Policy": "Bypass traverse checking",
3191                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3192                         "rights_assignment": True,
3193                         "Settings": None,
3194                         "LsaRights": {"Option": "SeChangeNotifyPrivilege"},
3195                         "Transform": {
3196                             "Get": "_sidConversion",
3197                             "Put": "_usernamesToSidObjects",
3198                         },
3199                     },
3200                     "SeSystemtimePrivilege": {
3201                         "Policy": "Change the system time",
3202                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3203                         "rights_assignment": True,
3204                         "Settings": None,
3205                         "LsaRights": {"Option": "SeSystemtimePrivilege"},
3206                         "Transform": {
3207                             "Get": "_sidConversion",
3208                             "Put": "_usernamesToSidObjects",
3209                         },
3210                     },
3211                     "SeTimeZonePrivilege": {
3212                         "Policy": "Change the time zone",
3213                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3214                         "rights_assignment": True,
3215                         "Settings": None,
3216                         "LsaRights": {"Option": "SeTimeZonePrivilege"},
3217                         "Transform": {
3218                             "Get": "_sidConversion",
3219                             "Put": "_usernamesToSidObjects",
3220                         },
3221                     },
3222                     "SeCreatePagefilePrivilege": {
3223                         "Policy": "Create a pagefile",
3224                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3225                         "rights_assignment": True,
3226                         "Settings": None,
3227                         "LsaRights": {"Option": "SeCreatePagefilePrivilege"},
3228                         "Transform": {
3229                             "Get": "_sidConversion",
3230                             "Put": "_usernamesToSidObjects",
3231                         },
3232                     },
3233                     "SeCreateTokenPrivilege": {
3234                         "Policy": "Create a token object",
3235                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3236                         "rights_assignment": True,
3237                         "Settings": None,
3238                         "LsaRights": {"Option": "SeCreateTokenPrivilege"},
3239                         "Transform": {
3240                             "Get": "_sidConversion",
3241                             "Put": "_usernamesToSidObjects",
3242                         },
3243                     },
3244                     "SeCreateGlobalPrivilege": {
3245                         "Policy": "Create global objects",
3246                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3247                         "rights_assignment": True,
3248                         "Settings": None,
3249                         "LsaRights": {"Option": "SeCreateGlobalPrivilege"},
3250                         "Transform": {
3251                             "Get": "_sidConversion",
3252                             "Put": "_usernamesToSidObjects",
3253                         },
3254                     },
3255                     "SeCreatePermanentPrivilege": {
3256                         "Policy": "Create permanent shared objects",
3257                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3258                         "rights_assignment": True,
3259                         "Settings": None,
3260                         "LsaRights": {"Option": "SeCreatePermanentPrivilege"},
3261                         "Transform": {
3262                             "Get": "_sidConversion",
3263                             "Put": "_usernamesToSidObjects",
3264                         },
3265                     },
3266                     "SeCreateSymbolicLinkPrivilege": {
3267                         "Policy": "Create symbolic links",
3268                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3269                         "rights_assignment": True,
3270                         "Settings": None,
3271                         "LsaRights": {"Option": "SeCreateSymbolicLinkPrivilege"},
3272                         "Transform": {
3273                             "Get": "_sidConversion",
3274                             "Put": "_usernamesToSidObjects",
3275                         },
3276                     },
3277                     "SeDebugPrivilege": {
3278                         "Policy": "Debug programs",
3279                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3280                         "rights_assignment": True,
3281                         "Settings": None,
3282                         "LsaRights": {"Option": "SeDebugPrivilege"},
3283                         "Transform": {
3284                             "Get": "_sidConversion",
3285                             "Put": "_usernamesToSidObjects",
3286                         },
3287                     },
3288                     "SeDenyNetworkLogonRight": {
3289                         "Policy": "Deny access to this computer from the network",
3290                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3291                         "rights_assignment": True,
3292                         "Settings": None,
3293                         "LsaRights": {"Option": "SeDenyNetworkLogonRight"},
3294                         "Transform": {
3295                             "Get": "_sidConversion",
3296                             "Put": "_usernamesToSidObjects",
3297                         },
3298                     },
3299                     "SeDenyBatchLogonRight": {
3300                         "Policy": "Deny log on as a batch job",
3301                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3302                         "rights_assignment": True,
3303                         "Settings": None,
3304                         "LsaRights": {"Option": "SeDenyBatchLogonRight"},
3305                         "Transform": {
3306                             "Get": "_sidConversion",
3307                             "Put": "_usernamesToSidObjects",
3308                         },
3309                     },
3310                     "SeDenyServiceLogonRight": {
3311                         "Policy": "Deny log on as a service",
3312                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3313                         "rights_assignment": True,
3314                         "Settings": None,
3315                         "LsaRights": {"Option": "SeDenyServiceLogonRight"},
3316                         "Transform": {
3317                             "Get": "_sidConversion",
3318                             "Put": "_usernamesToSidObjects",
3319                         },
3320                     },
3321                     "SeDenyInteractiveLogonRight": {
3322                         "Policy": "Deny log on locally",
3323                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3324                         "rights_assignment": True,
3325                         "Settings": None,
3326                         "LsaRights": {"Option": "SeDenyInteractiveLogonRight"},
3327                         "Transform": {
3328                             "Get": "_sidConversion",
3329                             "Put": "_usernamesToSidObjects",
3330                         },
3331                     },
3332                     "SeDenyRemoteInteractiveLogonRight": {
3333                         "Policy": "Deny log on through Remote Desktop Services",
3334                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3335                         "rights_assignment": True,
3336                         "Settings": None,
3337                         "LsaRights": {"Option": "SeDenyRemoteInteractiveLogonRight"},
3338                         "Transform": {
3339                             "Get": "_sidConversion",
3340                             "Put": "_usernamesToSidObjects",
3341                         },
3342                     },
3343                     "SeEnableDelegationPrivilege": {
3344                         "Policy": (
3345                             "Enable computer and user accounts to be "
3346                             "trusted for delegation"
3347                         ),
3348                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3349                         "rights_assignment": True,
3350                         "Settings": None,
3351                         "LsaRights": {"Option": "SeEnableDelegationPrivilege"},
3352                         "Transform": {
3353                             "Get": "_sidConversion",
3354                             "Put": "_usernamesToSidObjects",
3355                         },
3356                     },
3357                     "SeRemoteShutdownPrivilege": {
3358                         "Policy": "Force shutdown from a remote system",
3359                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3360                         "rights_assignment": True,
3361                         "Settings": None,
3362                         "LsaRights": {"Option": "SeRemoteShutdownPrivilege"},
3363                         "Transform": {
3364                             "Get": "_sidConversion",
3365                             "Put": "_usernamesToSidObjects",
3366                         },
3367                     },
3368                     "SeAuditPrivilege": {
3369                         "Policy": "Generate security audits",
3370                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3371                         "rights_assignment": True,
3372                         "Settings": None,
3373                         "LsaRights": {"Option": "SeAuditPrivilege"},
3374                         "Transform": {
3375                             "Get": "_sidConversion",
3376                             "Put": "_usernamesToSidObjects",
3377                         },
3378                     },
3379                     "SeImpersonatePrivilege": {
3380                         "Policy": "Impersonate a client after authentication",
3381                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3382                         "rights_assignment": True,
3383                         "Settings": None,
3384                         "LsaRights": {"Option": "SeImpersonatePrivilege"},
3385                         "Transform": {
3386                             "Get": "_sidConversion",
3387                             "Put": "_usernamesToSidObjects",
3388                         },
3389                     },
3390                     "SeIncreaseWorkingSetPrivilege": {
3391                         "Policy": "Increase a process working set",
3392                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3393                         "rights_assignment": True,
3394                         "Settings": None,
3395                         "LsaRights": {"Option": "SeIncreaseWorkingSetPrivilege"},
3396                         "Transform": {
3397                             "Get": "_sidConversion",
3398                             "Put": "_usernamesToSidObjects",
3399                         },
3400                     },
3401                     "SeIncreaseBasePriorityPrivilege": {
3402                         "Policy": "Increase scheduling priority",
3403                         "rights_assignment": True,
3404                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3405                         "Settings": None,
3406                         "LsaRights": {"Option": "SeIncreaseBasePriorityPrivilege"},
3407                         "Transform": {
3408                             "Get": "_sidConversion",
3409                             "Put": "_usernamesToSidObjects",
3410                         },
3411                     },
3412                     "SeLoadDriverPrivilege": {
3413                         "Policy": "Load and unload device drivers",
3414                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3415                         "rights_assignment": True,
3416                         "Settings": None,
3417                         "LsaRights": {"Option": "SeLoadDriverPrivilege"},
3418                         "Transform": {
3419                             "Get": "_sidConversion",
3420                             "Put": "_usernamesToSidObjects",
3421                         },
3422                     },
3423                     "SeLockMemoryPrivilege": {
3424                         "Policy": "Lock pages in memory",
3425                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3426                         "rights_assignment": True,
3427                         "Settings": None,
3428                         "LsaRights": {"Option": "SeLockMemoryPrivilege"},
3429                         "Transform": {
3430                             "Get": "_sidConversion",
3431                             "Put": "_usernamesToSidObjects",
3432                         },
3433                     },
3434                     "SeBatchLogonRight": {
3435                         "Policy": "Log on as a batch job",
3436                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3437                         "rights_assignment": True,
3438                         "Settings": None,
3439                         "LsaRights": {"Option": "SeBatchLogonRight"},
3440                         "Transform": {
3441                             "Get": "_sidConversion",
3442                             "Put": "_usernamesToSidObjects",
3443                         },
3444                     },
3445                     "SeServiceLogonRight": {
3446                         "Policy": "Log on as a service",
3447                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3448                         "rights_assignment": True,
3449                         "Settings": None,
3450                         "LsaRights": {"Option": "SeServiceLogonRight"},
3451                         "Transform": {
3452                             "Get": "_sidConversion",
3453                             "Put": "_usernamesToSidObjects",
3454                         },
3455                     },
3456                     "SeSecurityPrivilege": {
3457                         "Policy": "Manage auditing and security log",
3458                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3459                         "rights_assignment": True,
3460                         "Settings": None,
3461                         "LsaRights": {"Option": "SeSecurityPrivilege"},
3462                         "Transform": {
3463                             "Get": "_sidConversion",
3464                             "Put": "_usernamesToSidObjects",
3465                         },
3466                     },
3467                     "SeRelabelPrivilege": {
3468                         "Policy": "Modify an object label",
3469                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3470                         "rights_assignment": True,
3471                         "Settings": None,
3472                         "LsaRights": {"Option": "SeRelabelPrivilege"},
3473                         "Transform": {
3474                             "Get": "_sidConversion",
3475                             "Put": "_usernamesToSidObjects",
3476                         },
3477                     },
3478                     "SeSystemEnvironmentPrivilege": {
3479                         "Policy": "Modify firmware environment values",
3480                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3481                         "rights_assignment": True,
3482                         "Settings": None,
3483                         "LsaRights": {"Option": "SeSystemEnvironmentPrivilege"},
3484                         "Transform": {
3485                             "Get": "_sidConversion",
3486                             "Put": "_usernamesToSidObjects",
3487                         },
3488                     },
3489                     "SeManageVolumePrivilege": {
3490                         "Policy": "Perform volume maintenance tasks",
3491                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3492                         "rights_assignment": True,
3493                         "Settings": None,
3494                         "LsaRights": {"Option": "SeManageVolumePrivilege"},
3495                         "Transform": {
3496                             "Get": "_sidConversion",
3497                             "Put": "_usernamesToSidObjects",
3498                         },
3499                     },
3500                     "SeProfileSingleProcessPrivilege": {
3501                         "Policy": "Profile single process",
3502                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3503                         "rights_assignment": True,
3504                         "Settings": None,
3505                         "LsaRights": {"Option": "SeProfileSingleProcessPrivilege"},
3506                         "Transform": {
3507                             "Get": "_sidConversion",
3508                             "Put": "_usernamesToSidObjects",
3509                         },
3510                     },
3511                     "SeSystemProfilePrivilege": {
3512                         "Policy": "Profile system performance",
3513                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3514                         "rights_assignment": True,
3515                         "Settings": None,
3516                         "LsaRights": {"Option": "SeSystemProfilePrivilege"},
3517                         "Transform": {
3518                             "Get": "_sidConversion",
3519                             "Put": "_usernamesToSidObjects",
3520                         },
3521                     },
3522                     "SeUndockPrivilege": {
3523                         "Policy": "Remove computer from docking station",
3524                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3525                         "rights_assignment": True,
3526                         "Settings": None,
3527                         "LsaRights": {"Option": "SeUndockPrivilege"},
3528                         "Transform": {
3529                             "Get": "_sidConversion",
3530                             "Put": "_usernamesToSidObjects",
3531                         },
3532                     },
3533                     "SeAssignPrimaryTokenPrivilege": {
3534                         "Policy": "Replace a process level token",
3535                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3536                         "rights_assignment": True,
3537                         "Settings": None,
3538                         "LsaRights": {"Option": "SeAssignPrimaryTokenPrivilege"},
3539                         "Transform": {
3540                             "Get": "_sidConversion",
3541                             "Put": "_usernamesToSidObjects",
3542                         },
3543                     },
3544                     "SeRestorePrivilege": {
3545                         "Policy": "Restore files and directories",
3546                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3547                         "rights_assignment": True,
3548                         "Settings": None,
3549                         "LsaRights": {"Option": "SeRestorePrivilege"},
3550                         "Transform": {
3551                             "Get": "_sidConversion",
3552                             "Put": "_usernamesToSidObjects",
3553                         },
3554                     },
3555                     "SeShutdownPrivilege": {
3556                         "Policy": "Shut down the system",
3557                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3558                         "rights_assignment": True,
3559                         "Settings": None,
3560                         "LsaRights": {"Option": "SeShutdownPrivilege"},
3561                         "Transform": {
3562                             "Get": "_sidConversion",
3563                             "Put": "_usernamesToSidObjects",
3564                         },
3565                     },
3566                     "SeSyncAgentPrivilege": {
3567                         "Policy": "Synchronize directory service data",
3568                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3569                         "rights_assignment": True,
3570                         "Settings": None,
3571                         "LsaRights": {"Option": "SeSyncAgentPrivilege"},
3572                         "Transform": {
3573                             "Get": "_sidConversion",
3574                             "Put": "_usernamesToSidObjects",
3575                         },
3576                     },
3577                     "SeTakeOwnershipPrivilege": {
3578                         "Policy": "Take ownership of files or other objects",
3579                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3580                         "rights_assignment": True,
3581                         "Settings": None,
3582                         "LsaRights": {"Option": "SeTakeOwnershipPrivilege"},
3583                         "Transform": {
3584                             "Get": "_sidConversion",
3585                             "Put": "_usernamesToSidObjects",
3586                         },
3587                     },
3588                     "RecoveryConsoleSecurityLevel": {
3589                         "Policy": (
3590                             "Recovery console: Allow automatic administrative logon"
3591                         ),
3592                         "Settings": self.enabled_one_disabled_zero.keys(),
3593                         "lgpo_section": self.security_options_gpedit_path,
3594                         "Registry": {
3595                             "Hive": "HKEY_LOCAL_MACHINE",
3596                             "Path": (
3597                                 "Software\\Microsoft\\Windows NT\\"
3598                                 "CurrentVersion\\Setup\\RecoveryConsole"
3599                             ),
3600                             "Value": "SecurityLevel",
3601                             "Type": "REG_DWORD",
3602                         },
3603                         "Transform": self.enabled_one_disabled_zero_transform,
3604                     },
3605                     "RecoveryConsoleSetCommand": {
3606                         "Policy": (
3607                             "Recovery console: Allow floppy copy and "
3608                             "access to all drives and all folders"
3609                         ),
3610                         "Settings": self.enabled_one_disabled_zero.keys(),
3611                         "lgpo_section": self.security_options_gpedit_path,
3612                         "Registry": {
3613                             "Hive": "HKEY_LOCAL_MACHINE",
3614                             "Path": (
3615                                 "Software\\Microsoft\\Windows NT\\"
3616                                 "CurrentVersion\\Setup\\RecoveryConsole"
3617                             ),
3618                             "Value": "SetCommand",
3619                             "Type": "REG_DWORD",
3620                         },
3621                         "Transform": self.enabled_one_disabled_zero_transform,
3622                     },
3623                     "ForceKeyProtection": {
3624                         "Policy": (
3625                             "System Cryptography: Force strong key protection for "
3626                             "user keys stored on the computer"
3627                         ),
3628                         "Settings": self.force_key_protection.keys(),
3629                         "lgpo_section": self.security_options_gpedit_path,
3630                         "Registry": {
3631                             "Hive": "HKEY_LOCAL_MACHINE",
3632                             "Path": "Software\\Policies\\Microsoft\\Cryptography",
3633                             "Value": "ForceKeyProtection",
3634                             "Type": "REG_DWORD",
3635                         },
3636                         "Transform": {
3637                             "Get": "_dict_lookup",
3638                             "Put": "_dict_lookup",
3639                             "GetArgs": {
3640                                 "lookup": self.force_key_protection,
3641                                 "value_lookup": False,
3642                             },
3643                             "PutArgs": {
3644                                 "lookup": self.force_key_protection,
3645                                 "value_lookup": True,
3646                             },
3647                         },
3648                     },
3649                     "FIPSAlgorithmPolicy": {
3650                         "Policy": (
3651                             "System Cryptography: Use FIPS compliant algorithms "
3652                             "for encryption, hashing, and signing"
3653                         ),
3654                         "Settings": self.enabled_one_disabled_zero.keys(),
3655                         "lgpo_section": self.security_options_gpedit_path,
3656                         "Registry": {
3657                             "Hive": "HKEY_LOCAL_MACHINE",
3658                             "Path": "System\\CurrentControlSet\\Control\\Lsa\\FIPSAlgorithmPolicy",
3659                             "Value": "Enabled",
3660                             "Type": "REG_DWORD",
3661                         },
3662                         "Transform": self.enabled_one_disabled_zero_transform,
3663                     },
3664                     "MachineAccessRestriction": {
3665                         "Policy": (
3666                             "DCOM: Machine Access Restrictions in Security Descriptor "
3667                             "Definition Language (SDDL) syntax"
3668                         ),
3669                         "Settings": None,
3670                         "lgpo_section": self.security_options_gpedit_path,
3671                         "Registry": {
3672                             "Hive": "HKEY_LOCAL_MACHINE",
3673                             "Path": "Software\\Policies\\Microsoft\\Windows NT\\DCOM",
3674                             "Value": "MachineAccessRestriction",
3675                             "Type": "REG_SZ",
3676                         },
3677                         "Transform": {"Put": "_string_put_transform"},
3678                     },
3679                     "MachineLaunchRestriction": {
3680                         "Policy": (
3681                             "DCOM: Machine Launch Restrictions in Security Descriptor "
3682                             "Definition Language (SDDL) syntax"
3683                         ),
3684                         "Settings": None,
3685                         "lgpo_section": self.security_options_gpedit_path,
3686                         "Registry": {
3687                             "Hive": "HKEY_LOCAL_MACHINE",
3688                             "Path": "Software\\Policies\\Microsoft\\Windows NT\\DCOM",
3689                             "Value": "MachineLaunchRestriction",
3690                             "Type": "REG_SZ",
3691                         },
3692                         "Transform": {"Put": "_string_put_transform"},
3693                     },
3694                     "UseMachineId": {
3695                         "Policy": (
3696                             "Network security: Allow Local System to use computer "
3697                             "identity for NTLM"
3698                         ),
3699                         "Settings": self.enabled_one_disabled_zero.keys(),
3700                         "lgpo_section": self.security_options_gpedit_path,
3701                         "Registry": {
3702                             "Hive": "HKEY_LOCAL_MACHINE",
3703                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
3704                             "Value": "UseMachineId",
3705                             "Type": "REG_DWORD",
3706                         },
3707                         "Transform": self.enabled_one_disabled_zero_transform,
3708                     },
3709                     "allownullsessionfallback": {
3710                         "Policy": (
3711                             "Network security: Allow LocalSystem NULL session fallback"
3712                         ),
3713                         "Settings": self.enabled_one_disabled_zero.keys(),
3714                         "lgpo_section": self.security_options_gpedit_path,
3715                         "Registry": {
3716                             "Hive": "HKEY_LOCAL_MACHINE",
3717                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
3718                             "Value": "allownullsessionfallback",
3719                             "Type": "REG_DWORD",
3720                         },
3721                         "Transform": self.enabled_one_disabled_zero_transform,
3722                     },
3723                     "AllowOnlineID": {
3724                         "Policy": (
3725                             "Network security: Allow PKU2U authentication requests "
3726                             "to this computer to use online identities."
3727                         ),
3728                         "Settings": self.enabled_one_disabled_zero.keys(),
3729                         "lgpo_section": self.security_options_gpedit_path,
3730                         "Registry": {
3731                             "Hive": "HKEY_LOCAL_MACHINE",
3732                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa\\pku2u",
3733                             "Value": "AllowOnlineID",
3734                             "Type": "REG_DWORD",
3735                         },
3736                         "Transform": self.enabled_one_disabled_zero_transform,
3737                     },
3738                     "KrbSupportedEncryptionTypes": {
3739                         "Policy": (
3740                             "Network security: Configure encryption types allowed "
3741                             "for Kerberos"
3742                         ),
3743                         "Settings": None,
3744                         "lgpo_section": self.security_options_gpedit_path,
3745                         "Registry": {
3746                             "Hive": "HKEY_LOCAL_MACHINE",
3747                             "Path": (
3748                                 "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\policies"
3749                                 "\\system\\Kerberos\\Parameters"
3750                             ),
3751                             "Value": "SupportedEncryptionTypes",
3752                             "Type": "REG_DWORD",
3753                         },
3754                         "Transform": {
3755                             "Get": "_dict_lookup_bitwise_add",
3756                             "Put": "_dict_lookup_bitwise_add",
3757                             "GetArgs": {
3758                                 "lookup": self.krb_encryption_types,
3759                                 "value_lookup": False,
3760                             },
3761                             "PutArgs": {
3762                                 "lookup": self.krb_encryption_types,
3763                                 "value_lookup": True,
3764                             },
3765                         },
3766                     },
3767                     "NoLMHash": {
3768                         "Policy": (
3769                             "Network security: Do not store LAN Manager hash value "
3770                             "on next password change"
3771                         ),
3772                         "Settings": self.enabled_one_disabled_zero.keys(),
3773                         "lgpo_section": self.security_options_gpedit_path,
3774                         "Registry": {
3775                             "Hive": "HKEY_LOCAL_MACHINE",
3776                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
3777                             "Value": "NoLMHash",
3778                             "Type": "REG_DWORD",
3779                         },
3780                         "Transform": self.enabled_one_disabled_zero_transform,
3781                     },
3782                     "ForceLogoffWhenHourExpire": {
3783                         "Policy": (
3784                             "Network security: Force logoff when logon hours expire"
3785                         ),
3786                         "lgpo_section": self.security_options_gpedit_path,
3787                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
3788                         "Secedit": {
3789                             "Option": "ForceLogoffWhenHourExpire",
3790                             "Section": "System Access",
3791                         },
3792                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
3793                     },
3794                     "LmCompatibilityLevel": {
3795                         "Policy": "Network security: LAN Manager authentication level",
3796                         "Settings": self.lm_compat_levels.keys(),
3797                         "lgpo_section": self.security_options_gpedit_path,
3798                         "Registry": {
3799                             "Hive": "HKEY_LOCAL_MACHINE",
3800                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
3801                             "Value": "LmCompatibilityLevel",
3802                             "Type": "REG_DWORD",
3803                         },
3804                         "Transform": {
3805                             "Get": "_dict_lookup",
3806                             "Put": "_dict_lookup",
3807                             "GetArgs": {
3808                                 "lookup": self.lm_compat_levels,
3809                                 "value_lookup": False,
3810                             },
3811                             "PutArgs": {
3812                                 "lookup": self.lm_compat_levels,
3813                                 "value_lookup": True,
3814                             },
3815                         },
3816                     },
3817                     "LDAPClientIntegrity": {
3818                         "Policy": "Network security: LDAP client signing requirements",
3819                         "Settings": self.ldap_signing_reqs.keys(),
3820                         "lgpo_section": self.security_options_gpedit_path,
3821                         "Registry": {
3822                             "Hive": "HKEY_LOCAL_MACHINE",
3823                             "Path": "SYSTEM\\CurrentControlSet\\Services\\ldap",
3824                             "Value": "LDAPClientIntegrity",
3825                             "Type": "REG_DWORD",
3826                         },
3827                         "Transform": {
3828                             "Get": "_dict_lookup",
3829                             "Put": "_dict_lookup",
3830                             "GetArgs": {
3831                                 "lookup": self.ldap_signing_reqs,
3832                                 "value_lookup": False,
3833                             },
3834                             "PutArgs": {
3835                                 "lookup": self.ldap_signing_reqs,
3836                                 "value_lookup": True,
3837                             },
3838                         },
3839                     },
3840                     "NTLMMinClientSec": {
3841                         "Policy": (
3842                             "Network security: Minimum session security for NTLM SSP"
3843                             " based (including secure RPC) clients"
3844                         ),
3845                         "Settings": None,
3846                         "lgpo_section": self.security_options_gpedit_path,
3847                         "Registry": {
3848                             "Hive": "HKEY_LOCAL_MACHINE",
3849                             "Path": "System\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
3850                             "Value": "NTLMMinClientSec",
3851                             "Type": "REG_DWORD",
3852                         },
3853                         "Transform": {
3854                             "Get": "_dict_lookup_bitwise_add",
3855                             "Put": "_dict_lookup_bitwise_add",
3856                             "GetArgs": {
3857                                 "lookup": self.ntlm_session_security_levels,
3858                                 "value_lookup": False,
3859                             },
3860                             "PutArgs": {
3861                                 "lookup": self.ntlm_session_security_levels,
3862                                 "value_lookup": True,
3863                             },
3864                         },
3865                     },
3866                     "NTLMMinServerSec": {
3867                         "Policy": (
3868                             "Network security: Minimum session security for NTLM SSP"
3869                             " based (including secure RPC) servers"
3870                         ),
3871                         "Settings": None,
3872                         "lgpo_section": self.security_options_gpedit_path,
3873                         "Registry": {
3874                             "Hive": "HKEY_LOCAL_MACHINE",
3875                             "Path": "System\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
3876                             "Value": "NTLMMinServerSec",
3877                             "Type": "REG_DWORD",
3878                         },
3879                         "Transform": {
3880                             "Get": "_dict_lookup_bitwise_add",
3881                             "Put": "_dict_lookup_bitwise_add",
3882                             "GetArgs": {
3883                                 "lookup": self.ntlm_session_security_levels,
3884                                 "value_lookup": False,
3885                             },
3886                             "PutArgs": {
3887                                 "lookup": self.ntlm_session_security_levels,
3888                                 "value_lookup": True,
3889                             },
3890                         },
3891                     },
3892                     "ClientAllowedNTLMServers": {
3893                         "Policy": (
3894                             "Network security: Restrict NTLM: Add remote server"
3895                             " exceptions for NTLM authentication"
3896                         ),
3897                         "lgpo_section": self.security_options_gpedit_path,
3898                         "Registry": {
3899                             "Hive": "HKEY_LOCAL_MACHINE",
3900                             "Path": "System\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
3901                             "Value": "ClientAllowedNTLMServers",
3902                             "Type": "REG_MULTI_SZ",
3903                         },
3904                         "Transform": {
3905                             "Put": "_multi_string_put_transform",
3906                             "Get": "_multi_string_get_transform",
3907                         },
3908                     },
3909                     "DCAllowedNTLMServers": {
3910                         "Policy": (
3911                             "Network security: Restrict NTLM: Add server exceptions"
3912                             " in this domain"
3913                         ),
3914                         "lgpo_section": self.security_options_gpedit_path,
3915                         "Registry": {
3916                             "Hive": "HKEY_LOCAL_MACHINE",
3917                             "Path": "System\\CurrentControlSet\\Services\\Netlogon\\Parameters",
3918                             "Value": "DCAllowedNTLMServers",
3919                             "Type": "REG_MULTI_SZ",
3920                         },
3921                         "Transform": {
3922                             "Put": "_multi_string_put_transform",
3923                             "Get": "_multi_string_get_transform",
3924                         },
3925                     },
3926                     "AuditReceivingNTLMTraffic": {
3927                         "Policy": (
3928                             "Network security: Restrict NTLM: Audit Incoming NTLM"
3929                             " Traffic"
3930                         ),
3931                         "Settings": self.ntlm_audit_settings.keys(),
3932                         "lgpo_section": self.security_options_gpedit_path,
3933                         "Registry": {
3934                             "Hive": "HKEY_LOCAL_MACHINE",
3935                             "Path": "SYSTEM\\CurrentControlSet\\Control\\LSA\\MSV1_0",
3936                             "Value": "AuditReceivingNTLMTraffic",
3937                             "Type": "REG_DWORD",
3938                         },
3939                         "Transform": {
3940                             "Get": "_dict_lookup",
3941                             "Put": "_dict_lookup",
3942                             "GetArgs": {
3943                                 "lookup": self.ntlm_audit_settings,
3944                                 "value_lookup": False,
3945                             },
3946                             "PutArgs": {
3947                                 "lookup": self.ntlm_audit_settings,
3948                                 "value_lookup": True,
3949                             },
3950                         },
3951                     },
3952                     "AuditNTLMInDomain": {
3953                         "Policy": (
3954                             "Network security: Restrict NTLM: Audit NTLM "
3955                             "authentication in this domain"
3956                         ),
3957                         "Settings": self.ntlm_domain_audit_settings.keys(),
3958                         "lgpo_section": self.security_options_gpedit_path,
3959                         "Registry": {
3960                             "Hive": "HKEY_LOCAL_MACHINE",
3961                             "Path": "SYSTEM\\CurrentControlSet\\Services\\Netlogon\\Parameters",
3962                             "Value": "AuditNTLMInDomain",
3963                             "Type": "REG_DWORD",
3964                         },
3965                         "Transform": {
3966                             "Get": "_dict_lookup",
3967                             "Put": "_dict_lookup",
3968                             "GetArgs": {
3969                                 "lookup": self.ntlm_domain_audit_settings,
3970                                 "value_lookup": False,
3971                             },
3972                             "PutArgs": {
3973                                 "lookup": self.ntlm_domain_audit_settings,
3974                                 "value_lookup": True,
3975                             },
3976                         },
3977                     },
3978                     "RestrictReceivingNTLMTraffic": {
3979                         "Policy": (
3980                             "Network security: Restrict NTLM: Incoming NTLM traffic"
3981                         ),
3982                         "Settings": self.incoming_ntlm_settings.keys(),
3983                         "lgpo_section": self.security_options_gpedit_path,
3984                         "Registry": {
3985                             "Hive": "HKEY_LOCAL_MACHINE",
3986                             "Path": "SYSTEM\\CurrentControlSet\\Control\\LSA\\MSV1_0",
3987                             "Value": "RestrictReceivingNTLMTraffic",
3988                             "Type": "REG_DWORD",
3989                         },
3990                         "Transform": {
3991                             "Get": "_dict_lookup",
3992                             "Put": "_dict_lookup",
3993                             "GetArgs": {
3994                                 "lookup": self.incoming_ntlm_settings,
3995                                 "value_lookup": False,
3996                             },
3997                             "PutArgs": {
3998                                 "lookup": self.incoming_ntlm_settings,
3999                                 "value_lookup": True,
4000                             },
4001                         },
4002                     },
4003                     "RestrictNTLMInDomain": {
4004                         "Policy": (
4005                             "Network security: Restrict NTLM: NTLM "
4006                             "authentication in this domain"
4007                         ),
4008                         "Settings": self.ntlm_domain_auth_settings.keys(),
4009                         "lgpo_section": self.security_options_gpedit_path,
4010                         "Registry": {
4011                             "Hive": "HKEY_LOCAL_MACHINE",
4012                             "Path": "SYSTEM\\CurrentControlSet\\Services\\Netlogon\\Parameters",
4013                             "Value": "RestrictNTLMInDomain",
4014                             "Type": "REG_DWORD",
4015                         },
4016                         "Transform": {
4017                             "Get": "_dict_lookup",
4018                             "Put": "_dict_lookup",
4019                             "GetArgs": {
4020                                 "lookup": self.ntlm_domain_auth_settings,
4021                                 "value_lookup": False,
4022                             },
4023                             "PutArgs": {
4024                                 "lookup": self.ntlm_domain_auth_settings,
4025                                 "value_lookup": True,
4026                             },
4027                         },
4028                     },
4029                     "RestrictSendingNTLMTraffic": {
4030                         "Policy": (
4031                             "Network security: Restrict NTLM: Outgoing NTLM"
4032                             " traffic to remote servers"
4033                         ),
4034                         "Settings": self.outgoing_ntlm_settings.keys(),
4035                         "lgpo_section": self.security_options_gpedit_path,
4036                         "Registry": {
4037                             "Hive": "HKEY_LOCAL_MACHINE",
4038                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
4039                             "Value": "RestrictSendingNTLMTraffic",
4040                             "Type": "REG_DWORD",
4041                         },
4042                         "Transform": {
4043                             "Get": "_dict_lookup",
4044                             "Put": "_dict_lookup",
4045                             "GetArgs": {
4046                                 "lookup": self.outgoing_ntlm_settings,
4047                                 "value_lookup": False,
4048                             },
4049                             "PutArgs": {
4050                                 "lookup": self.outgoing_ntlm_settings,
4051                                 "value_lookup": True,
4052                             },
4053                         },
4054                     },
4055                     "ShutdownWithoutLogon": {
4056                         "Policy": (
4057                             "Shutdown: Allow system to be shut down "
4058                             "without having to log on"
4059                         ),
4060                         "Settings": self.enabled_one_disabled_zero.keys(),
4061                         "lgpo_section": self.security_options_gpedit_path,
4062                         "Registry": {
4063                             "Hive": "HKEY_LOCAL_MACHINE",
4064                             "Path": "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\policies\\system",
4065                             "Value": "ShutdownWithoutLogon",
4066                             "Type": "REG_DWORD",
4067                         },
4068                         "Transform": self.enabled_one_disabled_zero_transform,
4069                     },
4070                     "ClearPageFileAtShutdown": {
4071                         "Policy": "Shutdown: Clear virtual memory pagefile",
4072                         "Settings": self.enabled_one_disabled_zero.keys(),
4073                         "lgpo_section": self.security_options_gpedit_path,
4074                         "Registry": {
4075                             "Hive": "HKEY_LOCAL_MACHINE",
4076                             "Path": (
4077                                 "System\\CurrentControlSet\\Control\\"
4078                                 "SESSION MANAGER\\MEMORY MANAGEMENT"
4079                             ),
4080                             "Value": "ClearPageFileAtShutdown",
4081                             "Type": "REG_DWORD",
4082                         },
4083                         "Transform": self.enabled_one_disabled_zero_transform,
4084                     },
4085                     "ObCaseInsensitive": {
4086                         "Policy": (
4087                             "System objects: Require case insensitivity for "
4088                             "non-Windows subsystems"
4089                         ),
4090                         "Settings": self.enabled_one_disabled_zero.keys(),
4091                         "lgpo_section": self.security_options_gpedit_path,
4092                         "Registry": {
4093                             "Hive": "HKEY_LOCAL_MACHINE",
4094                             "Path": (
4095                                 "System\\CurrentControlSet\\Control\\"
4096                                 "SESSION MANAGER\\Kernel"
4097                             ),
4098                             "Value": "ObCaseInsensitive",
4099                             "Type": "REG_DWORD",
4100                         },
4101                         "Transform": self.enabled_one_disabled_zero_transform,
4102                     },
4103                     "ProtectionMode": {
4104                         "Policy": (
4105                             "System objects: Strengthen default permissions of "
4106                             "internal system objects (e.g. Symbolic Links)"
4107                         ),
4108                         "Settings": self.enabled_one_disabled_zero.keys(),
4109                         "lgpo_section": self.security_options_gpedit_path,
4110                         "Registry": {
4111                             "Hive": "HKEY_LOCAL_MACHINE",
4112                             "Path": (
4113                                 "System\\CurrentControlSet\\Control\\SESSION MANAGER"
4114                             ),
4115                             "Value": "ProtectionMode",
4116                             "Type": "REG_DWORD",
4117                         },
4118                         "Transform": self.enabled_one_disabled_zero_transform,
4119                     },
4120                     "OptionalSubsystems": {
4121                         "Policy": "System settings: Optional subsystems",
4122                         "lgpo_section": self.security_options_gpedit_path,
4123                         "Registry": {
4124                             "Hive": "HKEY_LOCAL_MACHINE",
4125                             "Path": (
4126                                 "System\\CurrentControlSet\\Control\\"
4127                                 "SESSION MANAGER\\SubSystems"
4128                             ),
4129                             "Value": "optional",
4130                             "Type": "REG_MULTI_SZ",
4131                         },
4132                         "Transform": {
4133                             "Put": "_multi_string_put_transform",
4134                             "Get": "_multi_string_get_transform",
4135                         },
4136                     },
4137                     "AuthenticodeEnabled": {
4138                         "Policy": (
4139                             "System settings: Use Certificate Rules on Windows"
4140                             " Executables for Software Restriction Policies"
4141                         ),
4142                         "Settings": self.enabled_one_disabled_zero.keys(),
4143                         "lgpo_section": self.security_options_gpedit_path,
4144                         "Registry": {
4145                             "Hive": "HKEY_LOCAL_MACHINE",
4146                             "Path": "SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers",
4147                             "Value": "AuthenticodeEnabled",
4148                             "Type": "REG_DWORD",
4149                         },
4150                         "Transform": self.enabled_one_disabled_zero_transform,
4151                     },
4152                 },
4153             },
4154             "User": {"lgpo_section": "User Configuration", "policies": {}},
4155         }
4156         self.admx_registry_classes = {
4157             "User": {
4158                 "policy_path": os.path.join(
4159                     os.getenv("WINDIR"),
4160                     "System32",
4161                     "GroupPolicy",
4162                     "User",
4163                     "Registry.pol",
4164                 ),
4165                 "hive": "HKEY_USERS",
4166                 "lgpo_section": "User Configuration",
4167                 "gpt_extension_location": "gPCUserExtensionNames",
4168                 "gpt_extension_guid": "[{35378EAC-683F-11D2-A89A-00C04FBBCFA2}{D02B1F73-3407-48AE-BA88-E8213C6761F1}]",
4169             },
4170             "Machine": {
4171                 "policy_path": os.path.join(
4172                     os.getenv("WINDIR"),
4173                     "System32",
4174                     "GroupPolicy",
4175                     "Machine",
4176                     "Registry.pol",
4177                 ),
4178                 "hive": "HKEY_LOCAL_MACHINE",
4179                 "lgpo_section": "Computer Configuration",
4180                 "gpt_extension_location": "gPCMachineExtensionNames",
4181                 "gpt_extension_guid": "[{35378EAC-683F-11D2-A89A-00C04FBBCFA2}{D02B1F72-3407-48AE-BA88-E8213C6761F1}]",
4182             },
4183         }
4184         self.reg_pol_header = "\u5250\u6765\x01\x00"
4185         self.gpt_ini_path = os.path.join(
4186             os.getenv("WINDIR"), "System32", "GroupPolicy", "gpt.ini"
4187         )
4188     @classmethod
4189     def _notEmpty(cls, val, **kwargs):
4190         if val:
4191             return True
4192         else:
4193             return False
4194     @classmethod
4195     def _seconds_to_days(cls, val, **kwargs):
4196         zero_value = kwargs.get("zero_value", 0)
4197         if val is not None:
4198             if val == zero_value:
4199                 return 0
4200             return val / 86400
4201         else:
4202             return "Not Defined"
4203     @classmethod
4204     def _days_to_seconds(cls, val, **kwargs):
4205         zero_value = kwargs.get("zero_value", 0)
4206         if val is not None:
4207             if val == 0:
4208                 return zero_value
4209             return val * 86400
4210         else:
4211             return "Not Defined"
4212     @classmethod
4213     def _seconds_to_minutes(cls, val, **kwargs):
4214         zero_value = kwargs.get("zero_value", 0)
4215         if val is not None:
4216             if val == zero_value:
4217                 return 0
4218             return val / 60
4219         else:
4220             return "Not Defined"
4221     @classmethod
4222     def _minutes_to_seconds(cls, val, **kwargs):
4223         zero_value = kwargs.get("zero_value", 0)
4224         if val is not None:
4225             if val == 0:
4226                 return zero_value
4227             return val * 60
4228         else:
4229             return "Not Defined"
4230     @classmethod
4231     def _strip_quotes(cls, val, **kwargs):
4232         return val.replace('"', "")
4233     @classmethod
4234     def _add_quotes(cls, val, **kwargs):
4235         return '"{}"'.format(val)
4236     @classmethod
4237     def _binary_enable_zero_disable_one_conversion(cls, val, **kwargs):
4238         try:
4239             if val is not None:
4240                 if ord(val) == 0:
4241                     return "Disabled"
4242                 elif ord(val) == 1:
4243                     return "Enabled"
4244                 else:
4245                     return "Invalid Value: {!r}".format(val)
4246             else:
4247                 return "Not Defined"
4248         except TypeError:
4249             return "Invalid Value"
4250     @classmethod
4251     def _binary_enable_zero_disable_one_reverse_conversion(cls, val, **kwargs):
4252         if val is not None:
4253             if val.upper() == "DISABLED":
4254                 return chr(0)
4255             elif val.upper() == "ENABLED":
4256                 return chr(1)
4257             else:
4258                 return None
4259         else:
4260             return None
4261     @classmethod
4262     def _dasd_conversion(cls, val, **kwargs):
4263         if val is not None:
4264             if val == "0" or val == 0 or val == "":
4265                 return "Administrators"
4266             elif val == "1" or val == 1:
4267                 return "Administrators and Power Users"
4268             elif val == "2" or val == 2:
4269                 return "Administrators and Interactive Users"
4270             else:
4271                 return "Not Defined"
4272         else:
4273             return "Not Defined"
4274     @classmethod
4275     def _dasd_reverse_conversion(cls, val, **kwargs):
4276         if val is not None:
4277             if val.upper() == "ADMINISTRATORS":
4278                 return "0"
4279             elif val.upper() == "ADMINISTRATORS AND POWER USERS":
4280                 return "1"
4281             elif val.upper() == "ADMINISTRATORS AND INTERACTIVE USERS":
4282                 return "2"
4283             elif val.upper() == "NOT DEFINED":
4284                 return "9999"
4285             else:
4286                 return "Invalid Value"
4287         else:
4288             return "Not Defined"
4289     @classmethod
4290     def _in_range_inclusive(cls, val, **kwargs):
4291         minimum = kwargs.get("min", 0)
4292         maximum = kwargs.get("max", 1)
4293         zero_value = kwargs.get("zero_value", 0)
4294         if isinstance(val, str):
4295             if val.lower() == "not defined":
4296                 return True
4297             else:
4298                 try:
4299                     val = int(val)
4300                 except ValueError:
4301                     return False
4302         if val is not None:
4303             if minimum &lt;= val &lt;= maximum or val == zero_value:
4304                 return True
4305             else:
4306                 return False
4307         else:
4308             return False
4309     @classmethod
4310     def _driver_signing_reg_conversion(cls, val, **kwargs):
4311         log.trace("we have %s for the driver signing value", val)
4312         if val is not None:
4313             _val = val.split(",")
4314             if len(_val) == 2:
4315                 if _val[1] == "0":
4316                     return "Silently Succeed"
4317                 elif _val[1] == "1":
4318                     return "Warn but allow installation"
4319                 elif _val[1] == "2":
4320                     return "Do not allow installation"
4321                 elif _val[1] == "Not Defined":
4322                     return "Not Defined"
4323                 else:
4324                     return "Invalid Value"
4325             else:
4326                 return "Not Defined"
4327         else:
4328             return "Not Defined"
4329     @classmethod
4330     def _driver_signing_reg_reverse_conversion(cls, val, **kwargs):
4331         if val is not None:
4332             if val.upper() == "SILENTLY SUCCEED":
4333                 return ",".join(["3", "0"])
4334             elif val.upper() == "WARN BUT ALLOW INSTALLATION":
4335                 return ",".join(["3", chr(1)])
4336             elif val.upper() == "DO NOT ALLOW INSTALLATION":
4337                 return ",".join(["3", chr(2)])
4338             else:
4339                 return "Invalid Value"
4340         else:
4341             return "Not Defined"
4342     @classmethod
4343     def _sidConversion(cls, val, **kwargs):
4344         if isinstance(val, str):
4345             val = val.split(",")
4346         usernames = []
4347         for _sid in val:
4348             try:
4349                 userSid = win32security.LookupAccountSid("", _sid)
4350                 if userSid[1]:
4351                     userSid = "{1}\\{0}".format(userSid[0], userSid[1])
4352                 else:
4353                     userSid = "{}".format(userSid[0])
4354             except Exception:  # pylint: disable=broad-except
4355                 userSid = win32security.ConvertSidToStringSid(_sid)
4356                 log.warning(
4357                     "Unable to convert SID '%s' to a friendly name. "
4358                     "The SID will be displayed instead of a user/group name.",
4359                     userSid,
4360                 )
4361             usernames.append(userSid)
4362         return usernames
4363     @classmethod
4364     def _usernamesToSidObjects(cls, val, **kwargs):
4365         if not val:
4366             return val
4367         if isinstance(val, str):
4368             val = val.split(",")
4369         sids = []
4370         for _user in val:
4371             try:
4372                 sid = win32security.LookupAccountName("", _user)[0]
4373                 sids.append(sid)
4374             except Exception as e:  # pylint: disable=broad-except
4375                 log.exception("Handle this explicitly")
4376                 raise CommandExecutionError(
4377                     'There was an error obtaining the SID of user "{}". Error '
4378                     "returned: {}".format(_user, e)
4379                 )
4380         return sids
4381     @classmethod
4382     def _powershell_script_order_conversion(cls, val, **kwargs):
4383         log.trace("script order value = %s", val)
4384         if val is None or val == "None":
4385             return "Not Configured"
4386         elif val == "true":
4387             return "Run Windows PowerShell scripts first"
4388         elif val == "false":
4389             return "Run Windows PowerShell scripts last"
4390         else:
4391             return "Invalid Value"
4392     @classmethod
4393     def _powershell_script_order_reverse_conversion(cls, val, **kwargs):
4394         if val.upper() == "Run Windows PowerShell scripts first".upper():
4395             return "true"
4396         elif val.upper() == "Run Windows PowerShell scripts last".upper():
4397             return "false"
4398         elif val == "Not Configured":
4399             return None
4400         else:
4401             return "Invalid Value"
4402     @classmethod
4403     def _dict_lookup(cls, item, **kwargs):
4404         log.trace("item == %s", item)
4405         value_lookup = kwargs.get("value_lookup", False)
4406         if "lookup" in kwargs:
4407             for k, v in kwargs["lookup"].items():
4408                 if value_lookup:
4409                     if str(v).lower() == str(item).lower():
4410                         log.trace("returning key %s", k)
4411                         return k
4412                 else:
4413                     if str(k).lower() == str(item).lower():
4414                         log.trace("returning value %s", v)
4415                         return v
4416         return "Invalid Value"
4417     @classmethod
4418     def _dict_lookup_bitwise_add(cls, item, **kwargs):
4419         value_lookup = kwargs.get("value_lookup", False)
4420         test_zero = kwargs.get("test_zero", False)
4421         ret_val = None
4422         if str(item).lower() == "not defined":
4423             return None
4424         if value_lookup:
4425             if not isinstance(item, list):
4426                 return "Invalid Value"
4427             ret_val = 0
4428         else:
4429             if not isinstance(item, int):
4430                 return "Invalid Value"
4431             ret_val = []
4432         if "lookup" in kwargs:
4433             for k, v in kwargs["lookup"].items():
4434                 if value_lookup:
4435                     if str(v).lower() in [z.lower() for z in item]:
4436                         ret_val = ret_val + k
4437                 else:
4438                     do_test = True
4439                     if not test_zero:
4440                         if k == 0:
4441                             do_test = False
4442                     if do_test and isinstance(k, int) and item &amp; k == k:
4443                         ret_val.append(v)
4444         else:
4445             return "Invalid Value"
4446         return ret_val
4447     @classmethod
4448     def _multi_string_put_transform(cls, item, **kwargs):
4449         if isinstance(item, list):
4450             return item
4451         elif isinstance(item, str):
4452             if item.lower() == "not defined":
4453                 return None
4454             else:
4455                 return item.split(",")
4456         else:
4457             return "Invalid Value"
4458     @classmethod
4459     def _multi_string_get_transform(cls, item, **kwargs):
4460         if isinstance(item, list):
4461             return item
4462         elif item is None:
4463             return "Not Defined"
4464         else:
4465             return "Invalid Value"
4466     @classmethod
4467     def _string_put_transform(cls, item, **kwargs):
4468         if isinstance(item, str):
4469             if item.lower() == "not defined":
4470                 return None
4471             else:
4472                 return item
4473 def __virtual__():
4474     if not salt.utils.platform.is_windows():
4475         return False, "win_lgpo: Not a Windows System"
4476     if not HAS_WINDOWS_MODULES:
4477         return False, "win_lgpo: Required modules failed to load"
4478     return __virtualname__
4479 def _updateNamespace(item, new_namespace):
4480     temp_item = ""
4481     i = item.tag.find("}")
4482     if i &gt;= 0:
4483         temp_item = item.tag[i + 1 :]
4484     else:
4485         temp_item = item.tag
4486     item.tag = "{{{0}}}{1}".format(new_namespace, temp_item)
4487     for child in item.getiterator():
4488         if isinstance(child.tag, str):
4489             temp_item = ""
4490             i = child.tag.find("}")
4491             if i &gt;= 0:
4492                 temp_item = child.tag[i + 1 :]
4493             else:
4494                 temp_item = child.tag
4495             child.tag = "{{{0}}}{1}".format(new_namespace, temp_item)
4496     return item
4497 def _updatePolicyElements(policy_item, regkey):
4498     for child in policy_item.getiterator():
4499         if "valueName" in child.attrib:
4500             if "key" not in child.attrib:
4501                 child.attrib["key"] = regkey
4502     return policy_item
4503 def _remove_unicode_encoding(xml_file):
4504     with salt.utils.files.fopen(xml_file, "rb") as f:
4505         xml_content = f.read()
4506     modified_xml = re.sub(
4507         r' encoding=[\'"]+unicode[\'"]+', "", xml_content.decode("utf-16"), count=1
4508     )
4509     xml_tree = lxml.etree.parse(io.StringIO(modified_xml))
4510     return xml_tree
4511 def _remove_invalid_xmlns(xml_file):
4512     with salt.utils.files.fopen(xml_file, "rb") as f:
4513         xml_content = f.read()
4514     modified_xml = re.sub(
4515         r' xmlns=[\'"]+.*[\'"]+', "", xml_content.decode("utf-8"), count=1
4516     )
4517     xml_tree = lxml.etree.parse(io.StringIO(modified_xml))
4518     return xml_tree
4519 def _parse_xml(adm_file):
4520     parser = lxml.etree.XMLParser(remove_comments=True)
4521     modified_xml = ""
4522     with salt.utils.files.fopen(adm_file, "rb") as rfh:
4523         file_hash = "{:X}".format(zlib.crc32(rfh.read()) &amp; 0xFFFFFFFF)
4524     name, ext = os.path.splitext(os.path.basename(adm_file))
4525     hashed_filename = "{}-{}{}".format(name, file_hash, ext)
4526     cache_dir = os.path.join(__opts__["cachedir"], "lgpo", "policy_defs")
4527     if not os.path.exists(cache_dir):
4528         os.makedirs(cache_dir)
4529     out_file = os.path.join(cache_dir, hashed_filename)
4530     if not os.path.isfile(out_file):
4531         log.debug("LGPO: Generating policy template cache for %s%s", name, ext)
4532         file_list = glob.glob(os.path.join(cache_dir, "{}*{}".format(name, ext)))
4533         for file_path in file_list:
4534             os.remove(file_path)
4535         with salt.utils.files.fopen(adm_file, "rb") as rfh:
4536             encoding = "utf-8"
4537             raw = rfh.read()
4538             try:
4539                 raw = raw.decode(encoding)
4540             except UnicodeDecodeError:
4541                 log.trace("LGPO: Detecting encoding")
4542                 encoding = "utf-16"
4543                 raw = raw.decode(encoding)
4544             for line in raw.split("\r\n"):
4545                 if 'key="' in line:
4546                     start = line.index('key="')
4547                     q1 = line[start:].index('"') + start
4548                     q2 = line[q1 + 1 :].index('"') + q1 + 1
4549                     line = line.replace(line[start:q2], line[start:q2].lower())
4550                     found_key = True
4551                 modified_xml += line + "\r\n"
4552         modified_xml = modified_xml.replace("\u201c", '"').replace("\u201d", '"')
4553         modified_xml = modified_xml.replace("\u2018", "'").replace("\u2019", "'")
4554         modified_xml = modified_xml.replace("\u2013", "-").replace("\u2014", "-")
4555         with salt.utils.files.fopen(out_file, "wb") as wfh:
4556             wfh.write(modified_xml.encode(encoding))
4557     try:
4558         xml_tree = lxml.etree.parse(out_file, parser=parser)
4559     except lxml.etree.XMLSyntaxError:
4560         try:
4561             xml_tree = _remove_unicode_encoding(out_file)
4562         except lxml.etree.XMLSyntaxError:
4563             xml_tree = _remove_invalid_xmlns(out_file)
4564     return xml_tree
4565 def _load_policy_definitions(path="c:\\Windows\\PolicyDefinitions", language="en-US"):
4566     display_language_fallback = INSTALL_LANGUAGE
4567     t_policy_definitions = lxml.etree.Element("policyDefinitions")
4568     t_policy_definitions.append(lxml.etree.Element("categories"))
4569     t_policy_definitions.append(lxml.etree.Element("policies"))
4570     t_policy_definitions.append(lxml.etree.Element("policyNamespaces"))
4571     t_policy_definition_resources = lxml.etree.Element("policyDefinitionResources")
4572     policydefs_policies_xpath = etree.XPath("/policyDefinitions/policies")
4573     policydefs_categories_xpath = etree.XPath("/policyDefinitions/categories")
4574     policydefs_policyns_xpath = etree.XPath("/policyDefinitions/policyNamespaces")
4575     policydefs_resources_localname_xpath = etree.XPath(
4576         '//*[local-name() = "policyDefinitionResources"]/*'
4577     )
4578     policydef_resources_xpath = etree.XPath("/policyDefinitionResources")
4579     for root, dirs, files in salt.utils.path.os_walk(path):
4580         if root == path:
4581             for t_admx_file in files:
4582                 admx_file_name, admx_file_ext = os.path.splitext(t_admx_file)
4583                 if not admx_file_ext == ".admx":
4584                     log.debug("%s is not an ADMX file", t_admx_file)
4585                     continue
4586                 admx_file = os.path.join(root, t_admx_file)
4587                 try:
4588                     xml_tree = _parse_xml(admx_file)
4589                 except lxml.etree.XMLSyntaxError:
4590                     log.error(
4591                         "An error was found while processing admx "
4592                         "file %s, all policies from this file will "
4593                         "be unavailable via this module",
4594                         admx_file,
4595                     )
4596                     continue
4597                 namespaces = xml_tree.getroot().nsmap
4598                 namespace_string = ""
4599                 if None in namespaces:
4600                     namespaces["None"] = namespaces[None]
4601                     namespaces.pop(None)
4602                     namespace_string = "None:"
4603                 this_namespace = xml_tree.xpath(
4604                     "/{0}policyDefinitions/{0}policyNamespaces/{0}target/@namespace".format(
4605                         namespace_string
4606                     ),
4607                     namespaces=namespaces,
4608                 )[0]
4609                 categories = xml_tree.xpath(
4610                     "/{0}policyDefinitions/{0}categories/{0}category".format(
4611                         namespace_string
4612                     ),
4613                     namespaces=namespaces,
4614                 )
4615                 for category in categories:
4616                     temp_cat = category
4617                     temp_cat = _updateNamespace(temp_cat, this_namespace)
4618                     policydefs_categories_xpath(t_policy_definitions)[0].append(
4619                         temp_cat
4620                     )
4621                 policies = xml_tree.xpath(
4622                     "/{0}policyDefinitions/{0}policies/{0}policy".format(
4623                         namespace_string
4624                     ),
4625                     namespaces=namespaces,
4626                 )
4627                 for policy in policies:
4628                     temp_pol = policy
4629                     temp_pol = _updateNamespace(temp_pol, this_namespace)
4630                     if "key" in temp_pol.attrib:
4631                         temp_pol = _updatePolicyElements(
4632                             temp_pol, temp_pol.attrib["key"]
4633                         )
4634                     policydefs_policies_xpath(t_policy_definitions)[0].append(temp_pol)
4635                 policy_namespaces = xml_tree.xpath(
4636                     "/{0}policyDefinitions/{0}policyNamespaces/{0}*".format(
4637                         namespace_string
4638                     ),
4639                     namespaces=namespaces,
4640                 )
4641                 for policy_ns in policy_namespaces:
4642                     temp_ns = policy_ns
4643                     temp_ns = _updateNamespace(temp_ns, this_namespace)
4644                     policydefs_policyns_xpath(t_policy_definitions)[0].append(temp_ns)
4645                 adml_file = os.path.join(root, language, admx_file_name + ".adml")
4646                 if not __salt__["file.file_exists"](adml_file):
4647                     log.info(
4648                         "An ADML file in the specified ADML language "
4649                         '"%s" does not exist for the ADMX "%s", the '
4650                         "the abbreviated language code will be tried.",
4651                         language,
4652                         t_admx_file,
4653                     )
4654                     adml_file = os.path.join(
4655                         root, language.split("-")[0], admx_file_name + ".adml"
4656                     )
4657                     if not __salt__["file.file_exists"](adml_file):
4658                         log.info(
4659                             "An ADML file in the specified ADML language "
4660                             'code %s does not exist for the ADMX "%s", '
4661                             "the fallback language will be tried.",
4662                             language[:2],
4663                             t_admx_file,
4664                         )
4665                         adml_file = os.path.join(
4666                             root, display_language_fallback, admx_file_name + ".adml"
4667                         )
4668                         if not __salt__["file.file_exists"](adml_file):
4669                             log.info(
4670                                 "An ADML file in the specified ADML "
4671                                 'fallback language "%s" '
4672                                 'does not exist for the ADMX "%s" '
4673                                 "the abbreviated fallback language code "
4674                                 "will be tried.",
4675                                 display_language_fallback,
4676                                 t_admx_file,
4677                             )
4678                             adml_file = os.path.join(
4679                                 root,
4680                                 display_language_fallback.split("-")[0],
4681                                 admx_file_name + ".adml",
4682                             )
4683                             if not __salt__["file.file_exists"](adml_file):
4684                                 raise SaltInvocationError(
4685                                     "An ADML file in the specified ADML language "
4686                                     '"{}" and the fallback language "{}" do not '
4687                                     'exist for the ADMX "{}".'.format(
4688                                         language, display_language_fallback, t_admx_file
4689                                     )
4690                                 )
4691                 try:
4692                     xml_tree = _parse_xml(adml_file)
4693                 except lxml.etree.XMLSyntaxError:
4694                     log.error(
4695                         "An error was found while processing adml "
4696                         "file %s, all policies from this file will "
4697                         "be unavailable via this module",
4698                         adml_file,
4699                     )
4700                     continue
4701                 if None in namespaces:
4702                     namespaces["None"] = namespaces[None]
4703                     namespaces.pop(None)
4704                 policydefs_resources = policydefs_resources_localname_xpath(xml_tree)
4705                 for policydefs_resource in policydefs_resources:
4706                     t_poldef = policydefs_resource
4707                     t_poldef = _updateNamespace(t_poldef, this_namespace)
4708                     policydef_resources_xpath(t_policy_definition_resources)[0].append(
4709                         t_poldef
4710                     )
4711     __context__["lgpo.policy_definitions"] = t_policy_definitions
4712     __context__["lgpo.policy_resources"] = t_policy_definition_resources
4713 def _get_policy_definitions(path="c:\\Windows\\PolicyDefinitions", language="en-US"):
4714     if "lgpo.policy_definitions" not in __context__:
4715         log.debug("LGPO: Loading policy definitions")
4716         _load_policy_definitions(path=path, language=language)
4717     return __context__["lgpo.policy_definitions"]
4718 def _get_policy_resources(path="c:\\Windows\\PolicyDefinitions", language="en-US"):
4719     if "lgpo.policy_resources" not in __context__:
4720         log.debug("LGPO: Loading policy resources")
4721         _load_policy_definitions(path=path, language=language)
4722     return __context__["lgpo.policy_resources"]
4723 def _buildElementNsmap(using_elements):
4724     thisMap = {}
4725     for e in using_elements:
4726         thisMap[e.attrib["prefix"]] = e.attrib["namespace"]
4727     return thisMap
4728 def _get_advaudit_defaults(option=None):
4729     if "lgpo.audit_defaults" not in __context__:
4730         log.debug("Loading auditpol defaults into __context__")
4731         dump = __utils__["auditpol.get_auditpol_dump"]()
4732         reader = csv.DictReader(dump)
4733         audit_defaults = {"fieldnames": reader.fieldnames}
4734         for row in reader:
4735             row["Machine Name"] = ""
4736             row["Auditpol Name"] = row["Subcategory"]
4737             if row["Subcategory"] == "Central Policy Staging":
4738                 row["Subcategory"] = "Audit Central Access Policy Staging"
4739             elif row["Subcategory"] == "Plug and Play Events":
4740                 row["Subcategory"] = "Audit PNP Activity"
4741             elif row["Subcategory"] == "Token Right Adjusted Events":
4742                 row["Subcategory"] = "Audit Token Right Adjusted"
4743             else:
4744                 row["Subcategory"] = "Audit {}".format(row["Subcategory"])
4745             audit_defaults[row["Subcategory"]] = row
4746         __context__["lgpo.audit_defaults"] = audit_defaults
4747     if option:
4748         return __context__["lgpo.audit_defaults"][option]
4749     else:
4750         return __context__["lgpo.audit_defaults"]
4751 def _advaudit_check_csv():
4752     system_root = os.environ.get("SystemRoot", "C:\\Windows")
4753     f_audit = os.path.join(system_root, "security", "audit", "audit.csv")
4754     f_audit_gpo = os.path.join(
4755         system_root,
4756         "System32",
4757         "GroupPolicy",
4758         "Machine",
4759         "Microsoft",
4760         "Windows NT",
4761         "Audit",
4762         "audit.csv",
4763     )
4764     if not __salt__["file.file_exists"](f_audit):
4765         if __salt__["file.file_exists"](f_audit_gpo):
4766             __salt__["file.copy"](f_audit_gpo, f_audit)
4767         else:
4768             field_names = _get_advaudit_defaults("fieldnames")
4769             __salt__["file.makedirs"](f_audit)
4770             __salt__["file.write"](f_audit, ",".join(field_names))
4771 def _get_advaudit_value(option, refresh=False):
4772     if "lgpo.adv_audit_data" not in __context__ or refresh is True:
4773         system_root = os.environ.get("SystemRoot", "C:\\Windows")
4774         f_audit = os.path.join(system_root, "security", "audit", "audit.csv")
4775         _advaudit_check_csv()
4776         audit_settings = {}
4777         with salt.utils.files.fopen(f_audit, mode="r") as csv_file:
4778             reader = csv.DictReader(csv_file)
4779             for row in reader:
4780                 audit_settings.update({row["Subcategory"]: row["Setting Value"]})
4781         __context__["lgpo.adv_audit_data"] = audit_settings
4782     return __context__["lgpo.adv_audit_data"].get(option, None)
4783 def _set_advaudit_file_data(option, value):
4784     system_root = os.environ.get("SystemRoot", "C:\\Windows")
4785     f_audit = os.path.join(system_root, "security", "audit", "audit.csv")
4786     f_audit_gpo = os.path.join(
4787         system_root,
4788         "System32",
4789         "GroupPolicy",
4790         "Machine",
4791         "Microsoft",
4792         "Windows NT",
4793         "Audit",
4794         "audit.csv",
4795     )
4796     f_temp = tempfile.NamedTemporaryFile(
4797         mode="w", delete=False, suffix=".csv", prefix="audit"
4798     )
4799     auditpol_values = {
4800         "None": "No Auditing",
4801         "0": "No Auditing",
4802         "1": "Success",
4803         "2": "Failure",
4804         "3": "Success and Failure",
4805     }
4806     _advaudit_check_csv()
4807     try:
4808         with salt.utils.files.fopen(f_audit, mode="r") as csv_file:
4809             reader = csv.DictReader(csv_file)
4810             with salt.utils.files.fopen(f_temp.name, mode="w") as tmp_file:
4811                 writer = csv.DictWriter(tmp_file, fieldnames=reader.fieldnames)
4812                 writer.writeheader()
4813                 value_written = False
4814                 for row in reader:
4815                     if row["Subcategory"] == option:
4816                         if not value == "None":
4817                             row["Inclusion Setting"] = auditpol_values[value]
4818                             row["Setting Value"] = value
4819                             log.trace("LGPO: Setting %s to %s", option, value)
4820                             writer.writerow(row)
4821                         else:
4822                             log.trace("LGPO: Removing %s", option)
4823                         value_written = True
4824                     else:
4825                         writer.writerow(row)
4826                 if not value_written:
4827                     if not value == "None":
4828                         log.trace("LGPO: Setting %s to %s", option, value)
4829                         defaults = _get_advaudit_defaults(option)
4830                         writer.writerow(
4831                             {
4832                                 "Machine Name": defaults["Machine Name"],
4833                                 "Policy Target": defaults["Policy Target"],
4834                                 "Subcategory": defaults["Subcategory"],
4835                                 "Subcategory GUID": defaults["Subcategory GUID"],
4836                                 "Inclusion Setting": auditpol_values[value],
4837                                 "Exclusion Setting": defaults["Exclusion Setting"],
4838                                 "Setting Value": value,
4839                             }
4840                         )
4841                     value_written = True
4842         if value_written:
4843             __salt__["file.copy"](f_temp.name, f_audit, remove_existing=True)
4844             __salt__["file.makedirs"](f_audit_gpo)
4845             __salt__["file.copy"](f_temp.name, f_audit_gpo, remove_existing=True)
4846     finally:
4847         f_temp.close()
4848         __salt__["file.remove"](f_temp.name)
4849     return value_written
4850 def _set_advaudit_pol_data(option, value):
4851     auditpol_values = {
4852         "None": "No Auditing",
4853         "0": "No Auditing",
4854         "1": "Success",
4855         "2": "Failure",
4856         "3": "Success and Failure",
4857     }
4858     defaults = _get_advaudit_defaults(option)
4859     return __utils__["auditpol.set_setting"](
4860         name=defaults["Auditpol Name"], value=auditpol_values[value]
4861     )
4862 def _set_advaudit_value(option, value):
4863     if not _set_advaudit_file_data(option=option, value=value):
4864         raise CommandExecutionError("Failed to set audit.csv option: {}".format(option))
4865     if not _set_advaudit_pol_data(option=option, value=value):
4866         log.error(
4867             "Failed to apply audit setting: %s\n"
4868             "Policy will take effect on next GPO update",
4869             option,
4870         )
4871     if "lgpo.adv_audit_data" not in __context__:
4872         _get_advaudit_value(option)
4873     if value is None:
4874         log.debug("LGPO: Removing Advanced Audit data: %s", option)
4875         __context__["lgpo.adv_audit_data"].pop(option)
4876     else:
4877         log.debug("LGPO: Updating Advanced Audit data: %s: %s", option, value)
4878         __context__["lgpo.adv_audit_data"][option] = value
4879     return True
4880 def _get_netsh_value(profile, option):
4881     if "lgpo.netsh_data" not in __context__:
4882         __context__["lgpo.netsh_data"] = {}
4883     if profile not in __context__["lgpo.netsh_data"]:
4884         log.debug("LGPO: Loading netsh data for %s profile", profile)
4885         settings = salt.utils.win_lgpo_netsh.get_all_settings(
4886             profile=profile, store="lgpo"
4887         )
4888         __context__["lgpo.netsh_data"].update({profile: settings})
4889     log.trace(
4890         "LGPO: netsh returning value: %s",
4891         __context__["lgpo.netsh_data"][profile][option],
4892     )
4893     return __context__["lgpo.netsh_data"][profile][option]
4894 def _set_netsh_value(profile, section, option, value):
4895     if section not in ("firewallpolicy", "settings", "logging", "state"):
4896         raise ValueError("LGPO: Invalid section: {}".format(section))
4897     log.trace(
4898         "LGPO: Setting the following\nProfile: %s\nSection: %s\nOption: %s\nValue: %s",
4899         profile,
4900         section,
4901         option,
4902         value,
4903     )
4904     if section == "firewallpolicy":
4905         salt.utils.win_lgpo_netsh.set_firewall_settings(
4906             profile=profile,
4907             inbound=value if option == "Inbound" else None,
4908             outbound=value if option == "Outbound" else None,
4909             store="lgpo",
4910         )
4911     if section == "settings":
4912         salt.utils.win_lgpo_netsh.set_settings(
4913             profile=profile, setting=option, value=value, store="lgpo"
4914         )
4915     if section == "state":
4916         salt.utils.win_lgpo_netsh.set_state(profile=profile, state=value, store="lgpo")
4917     if section == "logging":
4918         if option in ("FileName", "MaxFileSize"):
4919             if value == "Not configured":
4920                 value = "notconfigured"
4921         if option.startswith("Log"):
4922             option = option[3:]
4923         salt.utils.win_lgpo_netsh.set_logging_settings(
4924             profile=profile, setting=option, value=value, store="lgpo"
4925         )
4926     log.trace("LGPO: Clearing netsh data for %s profile", profile)
4927     __context__["lgpo.netsh_data"].pop(profile)
4928     return True
4929 def _load_secedit_data():
4930     f_exp = os.path.join(__opts__["cachedir"], "secedit-{}.txt".format(UUID))
4931     try:
4932         __salt__["cmd.run"](["secedit", "/export", "/cfg", f_exp])
4933         with salt.utils.files.fopen(f_exp, encoding="utf-16") as fp:
4934             secedit_data = fp.readlines()
4935         return secedit_data
4936     finally:
4937         if __salt__["file.file_exists"](f_exp):
4938             __salt__["file.remove"](f_exp)
4939 def _get_secedit_data(refresh=False):
4940     if "lgpo.secedit_data" not in __context__ or refresh is True:
4941         log.debug("LGPO: Loading secedit data")
4942         __context__["lgpo.secedit_data"] = _load_secedit_data()
4943     return __context__["lgpo.secedit_data"]
4944 def _get_secedit_value(option):
4945     secedit_data = _get_secedit_data()
4946     for _line in secedit_data:
4947         if _line.startswith(option):
4948             return _line.split("=")[1].strip()
4949     return "Not Defined"
4950 def _write_secedit_data(inf_data):
4951     f_sdb = os.path.join(os.getenv("WINDIR"), "security", "database", "salt.sdb")
4952     f_inf = os.path.join(__opts__["cachedir"], "secedit-{}.inf".format(UUID))
4953     try:
4954         with salt.utils.files.fopen(f_inf, "w", encoding="utf-16") as fp:
4955             fp.write(inf_data)
4956         cmd = ["secedit", "/import", "/db", f_sdb, "/cfg", f_inf]
4957         retcode = __salt__["cmd.retcode"](cmd)
4958         if not retcode == 0:
4959             log.debug("Secedit failed to import template data")
4960             return False
4961         cmd = ["secedit", "/configure", "/db", f_sdb]
4962         retcode = __salt__["cmd.retcode"](cmd)
4963         if not retcode == 0:
4964             log.debug("Secedit failed to apply security database")
4965             return False
4966         __context__.pop("lgpo.secedit_data", None)
4967         return True
4968     finally:
4969         if __salt__["file.file_exists"](f_inf):
4970             __salt__["file.remove"](f_inf)
4971 def _transform_value(value, policy, transform_type):
4972     t_kwargs = {}
4973     if "Transform" in policy:
4974         if transform_type in policy["Transform"]:
4975             _policydata = _policy_info()
4976             if transform_type + "Args" in policy["Transform"]:
4977                 t_kwargs = policy["Transform"][transform_type + "Args"]
4978             return getattr(_policydata, policy["Transform"][transform_type])(
4979                 value, **t_kwargs
4980             )
4981         else:
4982             return value
4983     else:
4984         if "Registry" in policy:
4985             if value == "(value not set)":
4986                 return "Not Defined"
4987         return value
4988 def _validateSetting(value, policy):
4989     log.debug("validating %s for policy %s", value, policy)
4990     if "Settings" in policy:
4991         if policy["Settings"]:
4992             if isinstance(policy["Settings"], list):
4993                 if value not in policy["Settings"]:
4994                     return False
4995             elif isinstance(policy["Settings"], dict):
4996                 _policydata = _policy_info()
4997                 if not getattr(_policydata, policy["Settings"]["Function"])(
4998                     value, **policy["Settings"]["Args"]
4999                 ):
5000                     return False
5001     else:
5002         return True
5003     return True
5004 def _addAccountRights(sidObject, user_right):
5005     try:
5006         if sidObject:
5007             _polHandle = win32security.LsaOpenPolicy(
5008                 None, win32security.POLICY_ALL_ACCESS
5009             )
5010             user_rights_list = [user_right]
5011             _ret = win32security.LsaAddAccountRights(
5012                 _polHandle, sidObject, user_rights_list
5013             )
5014         return True
5015     except Exception as e:  # pylint: disable=broad-except
5016         log.exception("Error attempting to add account right, exception was %s", e)
5017         return False
5018 def _delAccountRights(sidObject, user_right):
5019     try:
5020         _polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS)
5021         user_rights_list = [user_right]
5022         _ret = win32security.LsaRemoveAccountRights(
5023             _polHandle, sidObject, False, user_rights_list
5024         )
5025         return True
5026     except Exception as e:  # pylint: disable=broad-except
5027         log.exception("Error attempting to delete account right")
5028         return False
5029 def _getRightsAssignments(user_right):
5030     sids = []
5031     polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS)
5032     sids = win32security.LsaEnumerateAccountsWithUserRight(polHandle, user_right)
5033     return sids
5034 def _getAdmlDisplayName(adml_xml_data, display_name):
5035     if display_name.startswith("$(") and display_name.endswith(")"):
5036         display_name = re.sub(r"(^\$\(|\)$)", "", display_name)
5037         display_name = display_name.split(".")
5038         displayname_type = display_name[0]
5039         displayname_id = display_name[1]
5040         search_results = ADML_DISPLAY_NAME_XPATH(
5041             adml_xml_data,
5042             displayNameType=displayname_type,
5043             displayNameId=displayname_id,
5044         )
5045         if search_results:
5046             for result in search_results:
5047                 return result.text.strip()
5048     return None
5049 def _getAdmlPresentationRefId(adml_data, ref_id):
5050     search_results = adml_data.xpath(
5051         '//*[@*[local-name() = "refId"] = "{}"]'.format(ref_id)
5052     )
5053     alternate_label = ""
5054     if search_results:
5055         for result in search_results:
5056             the_localname = etree.QName(result.tag).localname
5057             if result.text is None:
5058                 presentation_element = PRESENTATION_ANCESTOR_XPATH(result)
5059                 if presentation_element:
5060                     presentation_element = presentation_element[0]
5061                     if TEXT_ELEMENT_XPATH(presentation_element):
5062                         for p_item in presentation_element:
5063                             if p_item == result:
5064                                 break
5065                             if etree.QName(p_item.tag).localname == "text":
5066                                 if getattr(p_item, "text"):
5067                                     alternate_label = getattr(p_item, "text").rstrip()
5068                         if alternate_label.endswith("."):
5069                             alternate_label = ""
5070             if the_localname in ["textBox", "comboBox"]:
5071                 label_items = result.xpath('.//*[local-name() = "label"]')
5072                 for label_item in label_items:
5073                     if label_item.text:
5074                         return label_item.text.rstrip().rstrip(":")
5075             elif the_localname in [
5076                 "decimalTextBox",
5077                 "longDecimalTextBox",
5078                 "dropdownList",
5079                 "listBox",
5080                 "checkBox",
5081                 "text",
5082                 "multiTextBox",
5083             ]:
5084                 if result.text:
5085                     return result.text.rstrip().rstrip(":")
5086                 else:
5087                     return alternate_label.rstrip(":")
5088     return None
5089 def _getFullPolicyName(
5090     policy_item, policy_name, return_full_policy_names, adml_language
5091 ):
5092     if policy_name in adm_policy_name_map[return_full_policy_names]:
5093         return adm_policy_name_map[return_full_policy_names][policy_name]
5094     adml_data = _get_policy_resources(language=adml_language)
5095     if return_full_policy_names and "displayName" in policy_item.attrib:
5096         fullPolicyName = _getAdmlDisplayName(
5097             adml_data, policy_item.attrib["displayName"]
5098         )
5099         if fullPolicyName:
5100             adm_policy_name_map[return_full_policy_names][policy_name] = fullPolicyName
5101             policy_name = fullPolicyName
5102     elif return_full_policy_names and "id" in policy_item.attrib:
5103         fullPolicyName = _getAdmlPresentationRefId(adml_data, policy_item.attrib["id"])
5104         if fullPolicyName:
5105             adm_policy_name_map[return_full_policy_names][policy_name] = fullPolicyName
5106             policy_name = fullPolicyName
5107     policy_name = policy_name.rstrip(":").rstrip()
5108     return policy_name
5109 def _regexSearchRegPolData(search_string, policy_data):
5110     if policy_data:
5111         if search_string:
5112             match = re.search(search_string, policy_data, re.IGNORECASE)
5113             if match:
5114                 return True
5115     return False
5116 def _getDataFromRegPolData(search_string, policy_data, return_value_name=False):
5117     value = None
5118     values = []
5119     encoded_semicolon = ";".encode("utf-16-le")
5120     if return_value_name:
5121         values = {}
5122     if search_string:
5123         registry = Registry()
5124         if len(search_string.split(encoded_semicolon)) &gt;= 3:
5125             vtype = registry.vtype_reverse[
5126                 ord(search_string.split(encoded_semicolon)[2].decode("utf-32-le"))
5127             ]
5128         else:
5129             vtype = None
5130         search_string = re.escape(search_string)
5131         matches = re.finditer(search_string, policy_data, re.IGNORECASE)
5132         matches = [m for m in matches]
5133         if matches:
5134             for match in matches:
5135                 pol_entry = policy_data[
5136                     match.start() : (
5137                         policy_data.index("]".encode("utf-16-le"), match.end())
5138                     )
5139                 ].split(encoded_semicolon, 4)
5140                 if len(pol_entry) &gt;= 2:
5141                     valueName = pol_entry[1].decode("utf-16-le").rstrip(chr(0))
5142                 if len(pol_entry) &gt;= 5:
5143                     value = encoded_semicolon.join(pol_entry[4:])
5144                     if vtype == "REG_DWORD" or vtype == "REG_QWORD":
5145                         if value:
5146                             if vtype == "REG_DWORD":
5147                                 for v in struct.unpack(b"I", value):
5148                                     value = v
5149                             elif vtype == "REG_QWORD":
5150                                 for v in struct.unpack(b"Q", value):
5151                                     value = v
5152                         else:
5153                             value = 0
5154                     elif vtype == "REG_MULTI_SZ":
5155                         value = value.decode("utf-16-le").rstrip(chr(0)).split(chr(0))
5156                     else:
5157                         value = value.decode("utf-16-le").rstrip(chr(0))
5158                 if return_value_name:
5159                     log.trace("we want value names and the value")
5160                     values[valueName] = value
5161                 elif len(matches) &gt; 1:
5162                     log.trace("we have multiple matches, we will return a list")
5163                     values.append(value)
5164     if values:
5165         value = values
5166     return value
5167 def _checkListItem(
5168     policy_element,
5169     policy_name,
5170     policy_key,
5171     xpath_object,
5172     policy_file_data,
5173     test_items=True,
5174 ):
5175     xpath_string = (
5176         './/*[local-name() = "decimal" or local-name() = "delete"'
5177         ' or local-name() = "longDecimal" or local-name() = "string"]'
5178     )
5179     value_item_child_xpath = etree.XPath(xpath_string)
5180     expected_strings = []
5181     for list_element in xpath_object(policy_element):
5182         configured_items = 0
5183         required_items = 0
5184         for item in list_element:
5185             required_items = required_items + 1
5186             if "key" in item.attrib:
5187                 item_key = item.attrib["key"]
5188             else:
5189                 item_key = policy_key
5190             if "valueName" in item.attrib:
5191                 item_valuename = item.attrib["valueName"]
5192             else:
5193                 log.error(
5194                     "%s item with attributes %s in policy %s does not "
5195                     'have the required "valueName" attribute',
5196                     etree.QName(list_element).localname,
5197                     item.attrib,
5198                     policy_element.attrib,
5199                 )
5200                 break
5201             for value_item in value_item_child_xpath(item):
5202                 search_string = _processValueItem(
5203                     value_item, item_key, item_valuename, policy_element, item
5204                 )
5205                 if test_items:
5206                     if _regexSearchRegPolData(
5207                         re.escape(search_string), policy_file_data
5208                     ):
5209                         configured_items = configured_items + 1
5210                         log.trace(
5211                             "found the search string in the pol file,"
5212                             "%s of %s items for policy %s are "
5213                             "configured in registry.pol",
5214                             configured_items,
5215                             required_items,
5216                             policy_name,
5217                         )
5218                 else:
5219                     expected_strings.append(search_string)
5220         if test_items:
5221             if required_items &gt; 0 and required_items == configured_items:
5222                 log.trace("%s all items are set", policy_name)
5223                 return True
5224     if test_items:
5225         return False
5226     else:
5227         return expected_strings
5228 def _checkValueItemParent(
5229     policy_element,
5230     policy_name,
5231     policy_key,
5232     policy_valueName,
5233     xpath_object,
5234     policy_file_data,
5235     check_deleted=False,
5236     test_item=True,
5237 ):
5238     for element in xpath_object(policy_element):
5239         for value_item in element:
5240             search_string = _processValueItem(
5241                 value_item,
5242                 policy_key,
5243                 policy_valueName,
5244                 policy_element,
5245                 element,
5246                 check_deleted=check_deleted,
5247             )
5248             if not test_item:
5249                 return search_string
5250             if _regexSearchRegPolData(re.escape(search_string), policy_file_data):
5251                 log.trace(
5252                     "found the search string in the pol file, %s is configured",
5253                     policy_name,
5254                 )
5255                 return True
5256     return False
5257 def _encode_string(value):
5258     encoded_null = chr(0).encode("utf-16-le")
5259     if value is None:
5260         return encoded_null
5261     elif not isinstance(value, str):
5262         raise TypeError(
5263             "Value {} is not a string type\nType: {}".format(repr(value), type(value))
5264         )
5265     return b"".join([value.encode("utf-16-le"), encoded_null])
5266 def _buildKnownDataSearchString(
5267     reg_key, reg_valueName, reg_vtype, reg_data, check_deleted=False
5268 ):
5269     registry = Registry()
5270     this_element_value = None
5271     expected_string = b""
5272     encoded_semicolon = ";".encode("utf-16-le")
5273     encoded_null = chr(0).encode("utf-16-le")
5274     if reg_key:
5275         reg_key = reg_key.encode("utf-16-le")
5276     if reg_valueName:
5277         reg_valueName = reg_valueName.encode("utf-16-le")
5278     if reg_data and not check_deleted:
5279         if reg_vtype == "REG_DWORD":
5280             this_element_value = struct.pack(b"I", int(reg_data))
5281         elif reg_vtype == "REG_QWORD":
5282             this_element_value = struct.pack(b"Q", int(reg_data))
5283         elif reg_vtype == "REG_SZ":
5284             this_element_value = _encode_string(reg_data)
5285     if check_deleted:
5286         reg_vtype = "REG_SZ"
5287         expected_string = b"".join(
5288             [
5289                 "[".encode("utf-16-le"),
5290                 reg_key,
5291                 encoded_null,
5292                 encoded_semicolon,
5293                 "**del.".encode("utf-16-le"),
5294                 reg_valueName,
5295                 encoded_null,
5296                 encoded_semicolon,
5297                 chr(registry.vtype[reg_vtype]).encode("utf-32-le"),
5298                 encoded_semicolon,
5299                 chr(len(" {}".format(chr(0)).encode("utf-16-le"))).encode("utf-32-le"),
5300                 encoded_semicolon,
5301                 " ".encode("utf-16-le"),
5302                 encoded_null,
5303                 "]".encode("utf-16-le"),
5304             ]
5305         )
5306     else:
5307         expected_string = b"".join(
5308             [
5309                 "[".encode("utf-16-le"),
5310                 reg_key,
5311                 encoded_null,
5312                 encoded_semicolon,
5313                 reg_valueName,
5314                 encoded_null,
5315                 encoded_semicolon,
5316                 chr(registry.vtype[reg_vtype]).encode("utf-32-le"),
5317                 encoded_semicolon,
5318                 chr(len(this_element_value)).encode("utf-32-le"),
5319                 encoded_semicolon,
5320                 this_element_value,
5321                 "]".encode("utf-16-le"),
5322             ]
5323         )
5324     return expected_string
5325 def _processValueItem(
5326     element,
5327     reg_key,
5328     reg_valuename,
5329     policy,
5330     parent_element,
5331     check_deleted=False,
5332     this_element_value=None,
5333 ):
5334     registry = Registry()
5335     expected_string = None
5336     this_vtype = "REG_SZ"
5337     encoded_semicolon = ";".encode("utf-16-le")
5338     encoded_null = chr(0).encode("utf-16-le")
5339     if reg_key:
5340         reg_key = reg_key.encode("utf-16-le")
5341     if reg_valuename:
5342         reg_valuename = reg_valuename.encode("utf-16-le")
5343     if (
5344         etree.QName(element).localname == "decimal"
5345         and etree.QName(parent_element).localname != "elements"
5346     ):
5347         this_vtype = "REG_DWORD"
5348         if "value" in element.attrib:
5349             this_element_value = struct.pack(b"I", int(element.attrib["value"]))
5350         else:
5351             log.error(
5352                 "The %s child %s element for the policy with "
5353                 'attributes: %s does not have the required "value" '
5354                 "attribute. The element attributes are: %s",
5355                 etree.QName(parent_element).localname,
5356                 etree.QName(element).localname,
5357                 policy.attrib,
5358                 element.attrib,
5359             )
5360             return None
5361     elif (
5362         etree.QName(element).localname == "longDecimal"
5363         and etree.QName(parent_element).localname != "elements"
5364     ):
5365         this_vtype = "REG_QWORD"
5366         if "value" in element.attrib:
5367             this_element_value = struct.pack(b"Q", int(element.attrib["value"]))
5368         else:
5369             log.error(
5370                 "The %s child %s element for the policy with "
5371                 'attributes: %s does not have the required "value" '
5372                 "attribute. The element attributes are: %s",
5373                 etree.QName(parent_element).localname,
5374                 etree.QName(element).localname,
5375                 policy.attrib,
5376                 element.attrib,
5377             )
5378             return None
5379     elif etree.QName(element).localname == "string":
5380         this_vtype = "REG_SZ"
5381         this_element_value = _encode_string(element.text)
5382     elif etree.QName(parent_element).localname == "elements":
5383         standard_element_expected_string = True
5384         if etree.QName(element).localname == "boolean":
5385             if this_element_value is False:
5386                 check_deleted = True
5387             if not check_deleted:
5388                 this_vtype = "REG_DWORD"
5389             this_element_value = struct.pack("I", 1)
5390             standard_element_expected_string = False
5391         elif etree.QName(element).localname == "decimal":
5392             this_vtype = "REG_DWORD"
5393             requested_val = this_element_value
5394             if this_element_value is not None:
5395                 this_element_value = struct.pack(b"I", int(this_element_value))
5396             if "storeAsText" in element.attrib:
5397                 if element.attrib["storeAsText"].lower() == "true":
5398                     this_vtype = "REG_SZ"
5399                     if requested_val is not None:
5400                         this_element_value = str(requested_val).encode("utf-16-le")
5401             if check_deleted:
5402                 this_vtype = "REG_SZ"
5403         elif etree.QName(element).localname == "longDecimal":
5404             this_vtype = "REG_QWORD"
5405             requested_val = this_element_value
5406             if this_element_value is not None:
5407                 this_element_value = struct.pack(b"Q", int(this_element_value))
5408             if "storeAsText" in element.attrib:
5409                 if element.attrib["storeAsText"].lower() == "true":
5410                     this_vtype = "REG_SZ"
5411                     if requested_val is not None:
5412                         this_element_value = str(requested_val).encode("utf-16-le")
5413         elif etree.QName(element).localname == "text":
5414             this_vtype = "REG_SZ"
5415             if "expandable" in element.attrib:
5416                 if element.attrib["expandable"].lower() == "true":
5417                     this_vtype = "REG_EXPAND_SZ"
5418             if this_element_value is not None:
5419                 this_element_value = _encode_string(this_element_value)
5420         elif etree.QName(element).localname == "multiText":
5421             this_vtype = "REG_MULTI_SZ" if not check_deleted else "REG_SZ"
5422             if this_element_value is not None:
5423                 this_element_value = "{0}{1}{1}".format(
5424                     chr(0).join(this_element_value), chr(0)
5425                 )
5426         elif etree.QName(element).localname == "list":
5427             standard_element_expected_string = False
5428             del_keys = b""
5429             element_valuenames = []
5430             element_values = this_element_value
5431             if this_element_value is not None:
5432                 element_valuenames = [
5433                     str(z) for z in range(1, len(this_element_value) + 1)
5434                 ]
5435             if "additive" in element.attrib:
5436                 if element.attrib["additive"].lower() == "false":
5437                     del_keys = b"".join(
5438                         [
5439                             "[".encode("utf-16-le"),
5440                             reg_key,
5441                             encoded_null,
5442                             encoded_semicolon,
5443                             "**delvals.".encode("utf-16-le"),
5444                             encoded_null,
5445                             encoded_semicolon,
5446                             chr(registry.vtype[this_vtype]).encode("utf-32-le"),
5447                             encoded_semicolon,
5448                             chr(len(" {}".format(chr(0)).encode("utf-16-le"))).encode(
5449                                 "utf-32-le"
5450                             ),
5451                             encoded_semicolon,
5452                             " ".encode("utf-16-le"),
5453                             encoded_null,
5454                             "]".encode("utf-16-le"),
5455                         ]
5456                     )
5457             if "expandable" in element.attrib:
5458                 this_vtype = "REG_EXPAND_SZ"
5459             if element.attrib.get("explicitValue", "false").lower() == "true":
5460                 if this_element_value is not None:
5461                     element_valuenames = [str(k) for k in this_element_value.keys()]
5462                     element_values = [str(v) for v in this_element_value.values()]
5463             elif "valuePrefix" in element.attrib:
5464                 if element.attrib["valuePrefix"] != "":
5465                     if this_element_value is not None:
5466                         element_valuenames = [
5467                             "{}{}".format(element.attrib["valuePrefix"], k)
5468                             for k in element_valuenames
5469                         ]
5470             else:
5471                 if element_values is not None:
5472                     element_valuenames = [str(z) for z in element_values]
5473             if not check_deleted:
5474                 if this_element_value is not None:
5475                     log.trace(
5476                         "_processValueItem has an explicit element_value of %s",
5477                         this_element_value,
5478                     )
5479                     expected_string = del_keys
5480                     log.trace(
5481                         "element_valuenames == %s and element_values == %s",
5482                         element_valuenames,
5483                         element_values,
5484                     )
5485                     for i, item in enumerate(element_valuenames):
5486                         expected_string = expected_string + b"".join(
5487                             [
5488                                 "[".encode("utf-16-le"),
5489                                 reg_key,
5490                                 encoded_null,
5491                                 encoded_semicolon,
5492                                 element_valuenames[i].encode("utf-16-le"),
5493                                 encoded_null,
5494                                 encoded_semicolon,
5495                                 chr(registry.vtype[this_vtype]).encode("utf-32-le"),
5496                                 encoded_semicolon,
5497                                 chr(
5498                                     len(
5499                                         "{}{}".format(element_values[i], chr(0)).encode(
5500                                             "utf-16-le"
5501                                         )
5502                                     )
5503                                 ).encode("utf-32-le"),
5504                                 encoded_semicolon,
5505                                 _encode_string(element_values[i]),
5506                                 "]".encode("utf-16-le"),
5507                             ]
5508                         )
5509                 else:
5510                     expected_string = del_keys + b"".join(
5511                         [
5512                             "[".encode("utf-16-le"),
5513                             reg_key,
5514                             encoded_null,
5515                             encoded_semicolon,
5516                         ]
5517                     )
5518             else:
5519                 expected_string = b"".join(
5520                     [
5521                         "[".encode("utf-16-le"),
5522                         reg_key,
5523                         encoded_null,
5524                         encoded_semicolon,
5525                         "**delvals.".encode("utf-16-le"),
5526                         encoded_null,
5527                         encoded_semicolon,
5528                         chr(registry.vtype[this_vtype]).encode("utf-32-le"),
5529                         encoded_semicolon,
5530                         chr(len(" {}".format(chr(0)).encode("utf-16-le"))).encode(
5531                             "utf-32-le"
5532                         ),
5533                         encoded_semicolon,
5534                         " ".encode("utf-16-le"),
5535                         encoded_null,
5536                         "]".encode("utf-16-le"),
5537                     ]
5538                 )
5539         elif etree.QName(element).localname == "enum":
5540             if this_element_value is not None:
5541                 pass
5542         if standard_element_expected_string and not check_deleted:
5543             if this_element_value is not None:
5544                 if isinstance(this_element_value, str):
5545                     log.debug("Converting %s to bytes", this_element_value)
5546                     this_element_value = this_element_value.encode("utf-32-le")
5547                 expected_string = b"".join(
5548                     [
5549                         "[".encode("utf-16-le"),
5550                         reg_key,
5551                         encoded_null,
5552                         encoded_semicolon,
5553                         reg_valuename,
5554                         encoded_null,
5555                         encoded_semicolon,
5556                         chr(registry.vtype[this_vtype]).encode("utf-32-le"),
5557                         encoded_semicolon,
5558                         chr(len(this_element_value)).encode("utf-32-le"),
5559                         encoded_semicolon,
5560                         this_element_value,
5561                         "]".encode("utf-16-le"),
5562                     ]
5563                 )
5564             else:
5565                 expected_string = b"".join(
5566                     [
5567                         "[".encode("utf-16-le"),
5568                         reg_key,
5569                         encoded_null,
5570                         encoded_semicolon,
5571                         reg_valuename,
5572                         encoded_null,
5573                         encoded_semicolon,
5574                         chr(registry.vtype[this_vtype]).encode("utf-32-le"),
5575                         encoded_semicolon,
5576                     ]
5577                 )
5578     if not expected_string:
5579         if etree.QName(element).localname == "delete" or check_deleted:
5580             expected_string = b"".join(
5581                 [
5582                     "[".encode("utf-16-le"),
5583                     reg_key,
5584                     encoded_null,
5585                     encoded_semicolon,
5586                     "**del.".encode("utf-16-le"),
5587                     reg_valuename,
5588                     encoded_null,
5589                     encoded_semicolon,
5590                     chr(registry.vtype[this_vtype]).encode("utf-32-le"),
5591                     encoded_semicolon,
5592                     chr(len(" {}".format(chr(0)).encode("utf-16-le"))).encode(
5593                         "utf-32-le"
5594                     ),
5595                     encoded_semicolon,
5596                     " ".encode("utf-16-le"),
5597                     encoded_null,
5598                     "]".encode("utf-16-le"),
5599                 ]
5600             )
5601         else:
5602             expected_string = b"".join(
5603                 [
5604                     "[".encode("utf-16-le"),
5605                     reg_key,
5606                     encoded_null,
5607                     encoded_semicolon,
5608                     reg_valuename,
5609                     encoded_null,
5610                     encoded_semicolon,
5611                     chr(registry.vtype[this_vtype]).encode("utf-32-le"),
5612                     encoded_semicolon,
5613                     chr(len(this_element_value)).encode("utf-32-le"),
5614                     encoded_semicolon,
5615                     this_element_value,
5616                     "]".encode("utf-16-le"),
5617                 ]
5618             )
5619     return expected_string
5620 def _checkAllAdmxPolicies(
5621     policy_class,
5622     adml_language="en-US",
5623     return_full_policy_names=False,
5624     hierarchical_return=False,
5625     return_not_configured=False,
5626 ):
5627     log.trace("POLICY CLASS == %s", policy_class)
5628     module_policy_data = _policy_info()
5629     policy_file_data = _read_regpol_file(
5630         module_policy_data.admx_registry_classes[policy_class]["policy_path"]
5631     )
5632     admx_policies = []
5633     policy_vals = {}
5634     hierarchy = {}
5635     full_names = {}
5636     admx_policy_definitions = _get_policy_definitions(language=adml_language)
5637     adml_policy_resources = _get_policy_resources(language=adml_language)
5638     if policy_file_data:
5639         log.trace("POLICY CLASS %s has file data", policy_class)
5640         policy_filedata_split = re.sub(
5641             salt.utils.stringutils.to_bytes(r"\]{}$".format(chr(0))),
5642             b"",
5643             re.sub(
5644                 salt.utils.stringutils.to_bytes(r"^\[{}".format(chr(0))),
5645                 b"",
5646                 re.sub(
5647                     re.escape(module_policy_data.reg_pol_header.encode("utf-16-le")),
5648                     b"",
5649                     policy_file_data,
5650                 ),
5651             ),
5652         ).split("][".encode("utf-16-le"))
5653         log.trace("Searching %s policies...", len(policy_filedata_split))
5654         start_time = time.time()
5655         for policy_item in policy_filedata_split:
5656             policy_item_key = (
5657                 policy_item.split("{};".format(chr(0)).encode("utf-16-le"))[0]
5658                 .decode("utf-16-le")
5659                 .lower()
5660             )
5661             if policy_item_key:
5662                 admx_items = REGKEY_XPATH(
5663                     admx_policy_definitions, keyvalue=policy_item_key
5664                 )
5665                 log.trace("Found %s policies for %s", len(admx_items), policy_item_key)
5666                 for admx_item in admx_items:
5667                     if etree.QName(admx_item).localname == "policy":
5668                         if admx_item not in admx_policies:
5669                             admx_policies.append(admx_item)
5670                     else:
5671                         for policy_item in POLICY_ANCESTOR_XPATH(admx_item):
5672                             if policy_item not in admx_policies:
5673                                 admx_policies.append(policy_item)
5674         log.trace("Search complete: %s seconds", time.time() - start_time)
5675         if return_not_configured:
5676             log.trace("Gathering non configured policies")
5677             start_time = time.time()
5678             not_configured_policies = ALL_CLASS_POLICY_XPATH(
5679                 admx_policy_definitions, registry_class=policy_class
5680             )
5681             for policy_item in admx_policies:
5682                 if policy_item in not_configured_policies:
5683                     not_configured_policies.remove(policy_item)
5684             for not_configured_policy in not_configured_policies:
5685                 not_configured_policy_namespace = not_configured_policy.nsmap[
5686                     not_configured_policy.prefix
5687                 ]
5688                 if not_configured_policy_namespace not in policy_vals:
5689                     policy_vals[not_configured_policy_namespace] = {}
5690                 policy_vals[not_configured_policy_namespace][
5691                     not_configured_policy.attrib["name"]
5692                 ] = "Not Configured"
5693                 if return_full_policy_names:
5694                     if not_configured_policy_namespace not in full_names:
5695                         full_names[not_configured_policy_namespace] = {}
5696                     full_names[not_configured_policy_namespace][
5697                         not_configured_policy.attrib["name"]
5698                     ] = _getFullPolicyName(
5699                         policy_item=not_configured_policy,
5700                         policy_name=not_configured_policy.attrib["name"],
5701                         return_full_policy_names=return_full_policy_names,
5702                         adml_language=adml_language,
5703                     )
5704                 log.trace(
5705                     "building hierarchy for non-configured item %s",
5706                     not_configured_policy.attrib["name"],
5707                 )
5708                 if not_configured_policy_namespace not in hierarchy:
5709                     hierarchy[not_configured_policy_namespace] = {}
5710                 hierarchy[not_configured_policy_namespace][
5711                     not_configured_policy.attrib["name"]
5712                 ] = _build_parent_list(
5713                     policy_definition=not_configured_policy,
5714                     return_full_policy_names=return_full_policy_names,
5715                     adml_language=adml_language,
5716                 )
5717             log.trace("Gathering complete: %s seconds", time.time() - start_time)
5718         log.trace("Examining %s policies...", len(admx_policies))
5719         start_time = time.time()
5720         for admx_policy in admx_policies:
5721             this_valuename = None
5722             this_policy_setting = "Not Configured"
5723             element_only_enabled_disabled = True
5724             explicit_enable_disable_value_setting = False
5725             if "key" in admx_policy.attrib:
5726                 this_key = admx_policy.attrib["key"]
5727             else:
5728                 log.error(
5729                     'policy item %s does not have the required "key" attribute',
5730                     admx_policy.attrib,
5731                 )
5732                 break
5733             if "valueName" in admx_policy.attrib:
5734                 this_valuename = admx_policy.attrib["valueName"]
5735             if "name" in admx_policy.attrib:
5736                 this_policyname = admx_policy.attrib["name"]
5737             else:
5738                 log.error(
5739                     'policy item %s does not have the required "name" attribute',
5740                     admx_policy.attrib,
5741                 )
5742                 break
5743             this_policynamespace = admx_policy.nsmap[admx_policy.prefix]
5744             if (
5745                 ENABLED_VALUE_XPATH(admx_policy)
5746                 and this_policy_setting == "Not Configured"
5747             ):
5748                 if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(
5749                     admx_policy
5750                 ):
5751                     element_only_enabled_disabled = False
5752                     explicit_enable_disable_value_setting = True
5753                 if _checkValueItemParent(
5754                     admx_policy,
5755                     this_policyname,
5756                     this_key,
5757                     this_valuename,
5758                     ENABLED_VALUE_XPATH,
5759                     policy_file_data,
5760                 ):
5761                     this_policy_setting = "Enabled"
5762                     log.trace(
5763                         "%s is enabled by detected ENABLED_VALUE_XPATH", this_policyname
5764                     )
5765                     if this_policynamespace not in policy_vals:
5766                         policy_vals[this_policynamespace] = {}
5767                     policy_vals[this_policynamespace][
5768                         this_policyname
5769                     ] = this_policy_setting
5770             if (
5771                 DISABLED_VALUE_XPATH(admx_policy)
5772                 and this_policy_setting == "Not Configured"
5773             ):
5774                 if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):
5775                     element_only_enabled_disabled = False
5776                     explicit_enable_disable_value_setting = True
5777                 if _checkValueItemParent(
5778                     admx_policy,
5779                     this_policyname,
5780                     this_key,
5781                     this_valuename,
5782                     DISABLED_VALUE_XPATH,
5783                     policy_file_data,
5784                 ):
5785                     this_policy_setting = "Disabled"
5786                     log.trace(
5787                         "%s is disabled by detected DISABLED_VALUE_XPATH",
5788                         this_policyname,
5789                     )
5790                     if this_policynamespace not in policy_vals:
5791                         policy_vals[this_policynamespace] = {}
5792                     policy_vals[this_policynamespace][
5793                         this_policyname
5794                     ] = this_policy_setting
5795             if (
5796                 ENABLED_LIST_XPATH(admx_policy)
5797                 and this_policy_setting == "Not Configured"
5798             ):
5799                 if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(
5800                     admx_policy
5801                 ):
5802                     element_only_enabled_disabled = False
5803                     explicit_enable_disable_value_setting = True
5804                 if _checkListItem(
5805                     admx_policy,
5806                     this_policyname,
5807                     this_key,
5808                     ENABLED_LIST_XPATH,
5809                     policy_file_data,
5810                 ):
5811                     this_policy_setting = "Enabled"
5812                     log.trace(
5813                         "%s is enabled by detected ENABLED_LIST_XPATH", this_policyname
5814                     )
5815                     if this_policynamespace not in policy_vals:
5816                         policy_vals[this_policynamespace] = {}
5817                     policy_vals[this_policynamespace][
5818                         this_policyname
5819                     ] = this_policy_setting
5820             if (
5821                 DISABLED_LIST_XPATH(admx_policy)
5822                 and this_policy_setting == "Not Configured"
5823             ):
5824                 if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):
5825                     element_only_enabled_disabled = False
5826                     explicit_enable_disable_value_setting = True
5827                 if _checkListItem(
5828                     admx_policy,
5829                     this_policyname,
5830                     this_key,
5831                     DISABLED_LIST_XPATH,
5832                     policy_file_data,
5833                 ):
5834                     this_policy_setting = "Disabled"
5835                     log.trace(
5836                         "%s is disabled by detected DISABLED_LIST_XPATH",
5837                         this_policyname,
5838                     )
5839                     if this_policynamespace not in policy_vals:
5840                         policy_vals[this_policynamespace] = {}
5841                     policy_vals[this_policynamespace][
5842                         this_policyname
5843                     ] = this_policy_setting
5844             if not explicit_enable_disable_value_setting and this_valuename:
5845                 if _regexSearchRegPolData(
5846                     re.escape(
5847                         _buildKnownDataSearchString(
5848                             this_key, this_valuename, "REG_DWORD", "1"
5849                         )
5850                     ),
5851                     policy_file_data,
5852                 ):
5853                     this_policy_setting = "Enabled"
5854                     log.trace(
5855                         "%s is enabled by no explicit enable/disable list or value",
5856                         this_policyname,
5857                     )
5858                     if this_policynamespace not in policy_vals:
5859                         policy_vals[this_policynamespace] = {}
5860                     policy_vals[this_policynamespace][
5861                         this_policyname
5862                     ] = this_policy_setting
5863                 elif _regexSearchRegPolData(
5864                     re.escape(
5865                         _buildKnownDataSearchString(
5866                             this_key,
5867                             this_valuename,
5868                             "REG_DWORD",
5869                             None,
5870                             check_deleted=True,
5871                         )
5872                     ),
5873                     policy_file_data,
5874                 ):
5875                     this_policy_setting = "Disabled"
5876                     log.trace(
5877                         "%s is disabled by no explicit enable/disable list or value",
5878                         this_policyname,
5879                     )
5880                     if this_policynamespace not in policy_vals:
5881                         policy_vals[this_policynamespace] = {}
5882                     policy_vals[this_policynamespace][
5883                         this_policyname
5884                     ] = this_policy_setting
5885             if ELEMENTS_XPATH(admx_policy):
5886                 if element_only_enabled_disabled or this_policy_setting == "Enabled":
5887                     required_elements = {}
5888                     configured_elements = {}
5889                     policy_disabled_elements = 0
5890                     for elements_item in ELEMENTS_XPATH(admx_policy):
5891                         for child_item in elements_item:
5892                             this_element_name = _getFullPolicyName(
5893                                 policy_item=child_item,
5894                                 policy_name=child_item.attrib["id"],
5895                                 return_full_policy_names=return_full_policy_names,
5896                                 adml_language=adml_language,
5897                             )
5898                             required_elements[this_element_name] = None
5899                             child_key = child_item.attrib.get("key", this_key)
5900                             child_valuename = child_item.attrib.get(
5901                                 "valueName", this_valuename
5902                             )
5903                             if etree.QName(child_item).localname == "boolean":
5904                                 if child_item is not None:
5905                                     if (
5906                                         TRUE_VALUE_XPATH(child_item)
5907                                         and this_element_name not in configured_elements
5908                                     ):
5909                                         if _checkValueItemParent(
5910                                             child_item,
5911                                             this_policyname,
5912                                             child_key,
5913                                             child_valuename,
5914                                             TRUE_VALUE_XPATH,
5915                                             policy_file_data,
5916                                         ):
5917                                             configured_elements[
5918                                                 this_element_name
5919                                             ] = True
5920                                             log.trace(
5921                                                 "element %s is configured true",
5922                                                 child_item.attrib["id"],
5923                                             )
5924                                     if (
5925                                         FALSE_VALUE_XPATH(child_item)
5926                                         and this_element_name not in configured_elements
5927                                     ):
5928                                         if _checkValueItemParent(
5929                                             child_item,
5930                                             this_policyname,
5931                                             child_key,
5932                                             child_valuename,
5933                                             FALSE_VALUE_XPATH,
5934                                             policy_file_data,
5935                                         ):
5936                                             configured_elements[
5937                                                 this_element_name
5938                                             ] = False
5939                                             policy_disabled_elements = (
5940                                                 policy_disabled_elements + 1
5941                                             )
5942                                             log.trace(
5943                                                 "element %s is configured false",
5944                                                 child_item.attrib["id"],
5945                                             )
5946                                     if (
5947                                         TRUE_LIST_XPATH(child_item)
5948                                         and this_element_name not in configured_elements
5949                                     ):
5950                                         log.trace("checking trueList")
5951                                         if _checkListItem(
5952                                             child_item,
5953                                             this_policyname,
5954                                             this_key,
5955                                             TRUE_LIST_XPATH,
5956                                             policy_file_data,
5957                                         ):
5958                                             configured_elements[
5959                                                 this_element_name
5960                                             ] = True
5961                                             log.trace(
5962                                                 "element %s is configured true",
5963                                                 child_item.attrib["id"],
5964                                             )
5965                                     if (
5966                                         FALSE_LIST_XPATH(child_item)
5967                                         and this_element_name not in configured_elements
5968                                     ):
5969                                         log.trace("checking falseList")
5970                                         if _checkListItem(
5971                                             child_item,
5972                                             this_policyname,
5973                                             this_key,
5974                                             FALSE_LIST_XPATH,
5975                                             policy_file_data,
5976                                         ):
5977                                             configured_elements[
5978                                                 this_element_name
5979                                             ] = False
5980                                             policy_disabled_elements = (
5981                                                 policy_disabled_elements + 1
5982                                             )
5983                                             log.trace(
5984                                                 "element %s is configured false",
5985                                                 child_item.attrib["id"],
5986                                             )
5987                                 else:
5988                                     if _regexSearchRegPolData(
5989                                         re.escape(
5990                                             _processValueItem(
5991                                                 child_item,
5992                                                 child_key,
5993                                                 child_valuename,
5994                                                 admx_policy,
5995                                                 elements_item,
5996                                                 check_deleted=True,
5997                                             )
5998                                         ),
5999                                         policy_file_data,
6000                                     ):
6001                                         configured_elements[this_element_name] = False
6002                                         policy_disabled_elements = (
6003                                             policy_disabled_elements + 1
6004                                         )
6005                                         log.trace(
6006                                             "element %s is configured false",
6007                                             child_item.attrib["id"],
6008                                         )
6009                                     elif _regexSearchRegPolData(
6010                                         re.escape(
6011                                             _processValueItem(
6012                                                 child_item,
6013                                                 child_key,
6014                                                 child_valuename,
6015                                                 admx_policy,
6016                                                 elements_item,
6017                                                 check_deleted=False,
6018                                             )
6019                                         ),
6020                                         policy_file_data,
6021                                     ):
6022                                         configured_elements[this_element_name] = True
6023                                         log.trace(
6024                                             "element %s is configured true",
6025                                             child_item.attrib["id"],
6026                                         )
6027                             elif (
6028                                 etree.QName(child_item).localname == "decimal"
6029                                 or etree.QName(child_item).localname == "text"
6030                                 or etree.QName(child_item).localname == "longDecimal"
6031                                 or etree.QName(child_item).localname == "multiText"
6032                             ):
6033                                 if _regexSearchRegPolData(
6034                                     re.escape(
6035                                         _processValueItem(
6036                                             child_item,
6037                                             child_key,
6038                                             child_valuename,
6039                                             admx_policy,
6040                                             elements_item,
6041                                             check_deleted=True,
6042                                         )
6043                                     ),
6044                                     policy_file_data,
6045                                 ):
6046                                     configured_elements[this_element_name] = "Disabled"
6047                                     policy_disabled_elements = (
6048                                         policy_disabled_elements + 1
6049                                     )
6050                                     log.trace(
6051                                         "element %s is disabled",
6052                                         child_item.attrib["id"],
6053                                     )
6054                                 elif _regexSearchRegPolData(
6055                                     re.escape(
6056                                         _processValueItem(
6057                                             child_item,
6058                                             child_key,
6059                                             child_valuename,
6060                                             admx_policy,
6061                                             elements_item,
6062                                             check_deleted=False,
6063                                         )
6064                                     ),
6065                                     policy_file_data,
6066                                 ):
6067                                     configured_value = _getDataFromRegPolData(
6068                                         _processValueItem(
6069                                             child_item,
6070                                             child_key,
6071                                             child_valuename,
6072                                             admx_policy,
6073                                             elements_item,
6074                                             check_deleted=False,
6075                                         ),
6076                                         policy_file_data,
6077                                     )
6078                                     configured_elements[
6079                                         this_element_name
6080                                     ] = configured_value
6081                                     log.trace(
6082                                         "element %s is enabled, value == %s",
6083                                         child_item.attrib["id"],
6084                                         configured_value,
6085                                     )
6086                             elif etree.QName(child_item).localname == "enum":
6087                                 if _regexSearchRegPolData(
6088                                     re.escape(
6089                                         _processValueItem(
6090                                             child_item,
6091                                             child_key,
6092                                             child_valuename,
6093                                             admx_policy,
6094                                             elements_item,
6095                                             check_deleted=True,
6096                                         )
6097                                     ),
6098                                     policy_file_data,
6099                                 ):
6100                                     log.trace(
6101                                         "enum element %s is disabled",
6102                                         child_item.attrib["id"],
6103                                     )
6104                                     configured_elements[this_element_name] = "Disabled"
6105                                     policy_disabled_elements = (
6106                                         policy_disabled_elements + 1
6107                                     )
6108                                 else:
6109                                     for enum_item in child_item:
6110                                         if _checkValueItemParent(
6111                                             enum_item,
6112                                             child_item.attrib["id"],
6113                                             child_key,
6114                                             child_valuename,
6115                                             VALUE_XPATH,
6116                                             policy_file_data,
6117                                         ):
6118                                             if VALUE_LIST_XPATH(enum_item):
6119                                                 log.trace("enum item has a valueList")
6120                                                 if _checkListItem(
6121                                                     enum_item,
6122                                                     this_policyname,
6123                                                     child_key,
6124                                                     VALUE_LIST_XPATH,
6125                                                     policy_file_data,
6126                                                 ):
6127                                                     log.trace(
6128                                                         "all valueList items exist in"
6129                                                         " file"
6130                                                     )
6131                                                     configured_elements[
6132                                                         this_element_name
6133                                                     ] = _getAdmlDisplayName(
6134                                                         adml_policy_resources,
6135                                                         enum_item.attrib["displayName"],
6136                                                     )
6137                                                     break
6138                                             else:
6139                                                 configured_elements[
6140                                                     this_element_name
6141                                                 ] = _getAdmlDisplayName(
6142                                                     adml_policy_resources,
6143                                                     enum_item.attrib["displayName"],
6144                                                 )
6145                                                 break
6146                             elif etree.QName(child_item).localname == "list":
6147                                 return_value_name = False
6148                                 if (
6149                                     "explicitValue" in child_item.attrib
6150                                     and child_item.attrib["explicitValue"].lower()
6151                                     == "true"
6152                                 ):
6153                                     log.trace(
6154                                         "explicitValue list, we will return value names"
6155                                     )
6156                                     return_value_name = True
6157                                 regex_str = [
6158                                     r"(?!\*",
6159                                     r"\*",
6160                                     "D",
6161                                     "e",
6162                                     "l",
6163                                     "V",
6164                                     "a",
6165                                     "l",
6166                                     "s",
6167                                     r"\.",
6168                                     ")",
6169                                 ]
6170                                 delvals_regex = "\x00".join(regex_str)
6171                                 delvals_regex = salt.utils.stringutils.to_bytes(
6172                                     delvals_regex
6173                                 )
6174                                 if _regexSearchRegPolData(
6175                                     re.escape(
6176                                         _processValueItem(
6177                                             child_item,
6178                                             child_key,
6179                                             child_valuename,
6180                                             admx_policy,
6181                                             elements_item,
6182                                             check_deleted=False,
6183                                         )
6184                                     )
6185                                     + delvals_regex,
6186                                     policy_file_data,
6187                                 ):
6188                                     configured_value = _getDataFromRegPolData(
6189                                         _processValueItem(
6190                                             child_item,
6191                                             child_key,
6192                                             child_valuename,
6193                                             admx_policy,
6194                                             elements_item,
6195                                             check_deleted=False,
6196                                         ),
6197                                         policy_file_data,
6198                                         return_value_name=return_value_name,
6199                                     )
6200                                     configured_elements[
6201                                         this_element_name
6202                                     ] = configured_value
6203                                     log.trace(
6204                                         "element %s is enabled values: %s",
6205                                         child_item.attrib["id"],
6206                                         configured_value,
6207                                     )
6208                                 elif _regexSearchRegPolData(
6209                                     re.escape(
6210                                         _processValueItem(
6211                                             child_item,
6212                                             child_key,
6213                                             child_valuename,
6214                                             admx_policy,
6215                                             elements_item,
6216                                             check_deleted=True,
6217                                         )
6218                                     ),
6219                                     policy_file_data,
6220                                 ):
6221                                     configured_elements[this_element_name] = "Disabled"
6222                                     policy_disabled_elements = (
6223                                         policy_disabled_elements + 1
6224                                     )
6225                                     log.trace(
6226                                         "element %s is disabled",
6227                                         child_item.attrib["id"],
6228                                     )
6229                     if element_only_enabled_disabled:
6230                         if len(required_elements.keys()) &gt; 0 and len(
6231                             configured_elements.keys()
6232                         ) == len(required_elements.keys()):
6233                             if policy_disabled_elements == len(
6234                                 required_elements.keys()
6235                             ):
6236                                 log.trace(
6237                                     "%s is disabled by all enum elements",
6238                                     this_policyname,
6239                                 )
6240                                 if this_policynamespace not in policy_vals:
6241                                     policy_vals[this_policynamespace] = {}
6242                                 policy_vals[this_policynamespace][
6243                                     this_policyname
6244                                 ] = "Disabled"
6245                             else:
6246                                 if this_policynamespace not in policy_vals:
6247                                     policy_vals[this_policynamespace] = {}
6248                                 policy_vals[this_policynamespace][
6249                                     this_policyname
6250                                 ] = configured_elements
6251                                 log.trace(
6252                                     "%s is enabled by enum elements", this_policyname
6253                                 )
6254                     else:
6255                         if this_policy_setting == "Enabled":
6256                             if this_policynamespace not in policy_vals:
6257                                 policy_vals[this_policynamespace] = {}
6258                             policy_vals[this_policynamespace][
6259                                 this_policyname
6260                             ] = configured_elements
6261             if (
6262                 return_full_policy_names
6263                 and this_policynamespace in policy_vals
6264                 and this_policyname in policy_vals[this_policynamespace]
6265             ):
6266                 if this_policynamespace not in full_names:
6267                     full_names[this_policynamespace] = {}
6268                 full_names[this_policynamespace][this_policyname] = _getFullPolicyName(
6269                     policy_item=admx_policy,
6270                     policy_name=admx_policy.attrib["name"],
6271                     return_full_policy_names=return_full_policy_names,
6272                     adml_language=adml_language,
6273                 )
6274                 if (
6275                     this_policyname
6276                     in policy_vals[this_policynamespace][this_policyname]
6277                 ):
6278                     full_name = full_names[this_policynamespace][this_policyname]
6279                     setting = policy_vals[this_policynamespace][this_policyname].pop(
6280                         this_policyname
6281                     )
6282                     policy_vals[this_policynamespace][this_policyname][
6283                         full_name
6284                     ] = setting
6285             if (
6286                 this_policynamespace in policy_vals
6287                 and this_policyname in policy_vals[this_policynamespace]
6288             ):
6289                 if this_policynamespace not in hierarchy:
6290                     hierarchy[this_policynamespace] = {}
6291                 hierarchy[this_policynamespace][this_policyname] = _build_parent_list(
6292                     policy_definition=admx_policy,
6293                     return_full_policy_names=return_full_policy_names,
6294                     adml_language=adml_language,
6295                 )
6296         log.trace("Examination complete: %s seconds", time.time() - start_time)
6297     if policy_vals and return_full_policy_names and not hierarchical_return:
6298         log.debug("Compiling non hierarchical return...")
6299         start_time = time.time()
6300         unpathed_dict = {}
6301         pathed_dict = {}
6302         for policy_namespace in list(policy_vals):
6303             for policy_item in list(policy_vals[policy_namespace]):
6304                 if (
6305                     full_names[policy_namespace][policy_item]
6306                     in policy_vals[policy_namespace]
6307                 ):
6308                     full_path_list = hierarchy[policy_namespace][policy_item]
6309                     full_path_list.reverse()
6310                     full_path_list.append(full_names[policy_namespace][policy_item])
6311                     policy_vals["\\".join(full_path_list)] = policy_vals[
6312                         policy_namespace
6313                     ].pop(policy_item)
6314                     pathed_dict[full_names[policy_namespace][policy_item]] = True
6315                 else:
6316                     policy_vals[policy_namespace][
6317                         full_names[policy_namespace][policy_item]
6318                     ] = policy_vals[policy_namespace].pop(policy_item)
6319                     if policy_namespace not in unpathed_dict:
6320                         unpathed_dict[policy_namespace] = {}
6321                     unpathed_dict[policy_namespace][
6322                         full_names[policy_namespace][policy_item]
6323                     ] = policy_item
6324             if policy_namespace in unpathed_dict:
6325                 for path_needed in unpathed_dict[policy_namespace]:
6326                     full_path_list = hierarchy[policy_namespace][
6327                         unpathed_dict[policy_namespace][path_needed]
6328                     ]
6329                     full_path_list.reverse()
6330                     full_path_list.append(path_needed)
6331                     log.trace("full_path_list == %s", full_path_list)
6332                     policy_vals["\\".join(full_path_list)] = policy_vals[
6333                         policy_namespace
6334                     ].pop(path_needed)
6335         log.trace("Compilation complete: %s seconds", time.time() - start_time)
6336     for policy_namespace in list(policy_vals):
6337         if policy_vals[policy_namespace] == {}:
6338             policy_vals.pop(policy_namespace)
6339     if policy_vals and hierarchical_return:
6340         if hierarchy:
6341             log.debug("Compiling hierarchical return...")
6342             start_time = time.time()
6343             for policy_namespace in hierarchy:
6344                 for hierarchy_item in hierarchy[policy_namespace]:
6345                     if hierarchy_item in policy_vals[policy_namespace]:
6346                         tdict = {}
6347                         first_item = True
6348                         for item in hierarchy[policy_namespace][hierarchy_item]:
6349                             newdict = {}
6350                             if first_item:
6351                                 h_policy_name = hierarchy_item
6352                                 if return_full_policy_names:
6353                                     h_policy_name = full_names[policy_namespace][
6354                                         hierarchy_item
6355                                     ]
6356                                 newdict[item] = {
6357                                     h_policy_name: policy_vals[policy_namespace].pop(
6358                                         hierarchy_item
6359                                     )
6360                                 }
6361                                 first_item = False
6362                             else:
6363                                 newdict[item] = tdict
6364                             tdict = newdict
6365                         if tdict:
6366                             policy_vals = dictupdate.update(policy_vals, tdict)
6367                 if (
6368                     policy_namespace in policy_vals
6369                     and policy_vals[policy_namespace] == {}
6370                 ):
6371                     policy_vals.pop(policy_namespace)
6372             log.trace("Compilation complete: %s seconds", time.time() - start_time)
6373         policy_vals = {
6374             module_policy_data.admx_registry_classes[policy_class]["lgpo_section"]: {
6375                 "Administrative Templates": policy_vals
6376             }
6377         }
6378     return policy_vals
6379 def _build_parent_list(policy_definition, return_full_policy_names, adml_language):
6380     parent_list = []
6381     policy_namespace = next(iter(policy_definition.nsmap))
6382     parent_category = policy_definition.xpath(
6383         "{}:parentCategory/@ref".format(policy_namespace),
6384         namespaces=policy_definition.nsmap,
6385     )
6386     admx_policy_definitions = _get_policy_definitions(language=adml_language)
6387     if parent_category:
6388         parent_category = parent_category[0]
6389         nsmap_xpath = "/policyDefinitions/policyNamespaces/{}:*".format(
6390             policy_namespace
6391         )
6392         this_namespace_map = _buildElementNsmap(
6393             admx_policy_definitions.xpath(
6394                 nsmap_xpath, namespaces=policy_definition.nsmap
6395             )
6396         )
6397         this_namespace_map = dictupdate.update(
6398             this_namespace_map, policy_definition.nsmap
6399         )
6400         parent_list = _admx_policy_parent_walk(
6401             path=parent_list,
6402             policy_namespace=policy_namespace,
6403             parent_category=parent_category,
6404             policy_nsmap=this_namespace_map,
6405             return_full_policy_names=return_full_policy_names,
6406             adml_language=adml_language,
6407         )
6408     return parent_list
6409 def _admx_policy_parent_walk(
6410     path,
6411     policy_namespace,
6412     parent_category,
6413     policy_nsmap,
6414     return_full_policy_names,
6415     adml_language,
6416 ):
6417     admx_policy_definitions = _get_policy_definitions(language=adml_language)
6418     category_xpath_string = '/policyDefinitions/categories/{}:category[@name="{}"]'
6419     using_xpath_string = "/policyDefinitions/policyNamespaces/{}:using"
6420     if parent_category.find(":") &gt;= 0:
6421         policy_namespace = parent_category.split(":")[0]
6422         parent_category = parent_category.split(":")[1]
6423         using_xpath_string = using_xpath_string.format(policy_namespace)
6424         policy_nsmap = dictupdate.update(
6425             policy_nsmap,
6426             _buildElementNsmap(
6427                 admx_policy_definitions.xpath(
6428                     using_xpath_string, namespaces=policy_nsmap
6429                 )
6430             ),
6431         )
6432     category_xpath_string = category_xpath_string.format(
6433         policy_namespace, parent_category
6434     )
6435     if admx_policy_definitions.xpath(category_xpath_string, namespaces=policy_nsmap):
6436         tparent_category = admx_policy_definitions.xpath(
6437             category_xpath_string, namespaces=policy_nsmap
6438         )[0]
6439         this_parent_name = _getFullPolicyName(
6440             policy_item=tparent_category,
6441             policy_name=tparent_category.attrib["name"],
6442             return_full_policy_names=return_full_policy_names,
6443             adml_language=adml_language,
6444         )
6445         path.append(this_parent_name)
6446         if tparent_category.xpath(
6447             "{}:parentCategory/@ref".format(policy_namespace), namespaces=policy_nsmap
6448         ):
6449             path = _admx_policy_parent_walk(
6450                 path=path,
6451                 policy_namespace=policy_namespace,
6452                 parent_category=tparent_category.xpath(
6453                     "{}:parentCategory/@ref".format(policy_namespace),
6454                     namespaces=policy_nsmap,
6455                 )[0],
6456                 policy_nsmap=policy_nsmap,
6457                 return_full_policy_names=return_full_policy_names,
6458                 adml_language=adml_language,
6459             )
6460     return path
6461 def _read_regpol_file(reg_pol_path):
6462     returndata = None
6463     if os.path.exists(reg_pol_path):
6464         with salt.utils.files.fopen(reg_pol_path, "rb") as pol_file:
6465             returndata = pol_file.read()
6466     return returndata
6467 def _regexSearchKeyValueCombo(policy_data, policy_regpath, policy_regkey):
6468     if policy_data:
6469         regex_str = [
6470             r"(\*",
6471             r"\*",
6472             "D",
6473             "e",
6474             "l",
6475             r"\.",
6476             r"|\*",
6477             r"\*",
6478             "D",
6479             "e",
6480             "l",
6481             "V",
6482             "a",
6483             "l",
6484             "s",
6485             r"\.",
6486             "){0,1}",
6487         ]
6488         specialValueRegex = "\x00".join(regex_str)
6489         specialValueRegex = salt.utils.stringutils.to_bytes(specialValueRegex)
6490         _thisSearch = b"".join(
6491             [
6492                 salt.utils.stringutils.to_bytes(r"\["),
6493                 re.escape(policy_regpath),
6494                 b"\x00;\x00",
6495                 specialValueRegex,
6496                 re.escape(policy_regkey.lstrip(b"\x00")),
6497                 b"\x00;",
6498             ]
6499         )
6500         match = re.search(_thisSearch, policy_data, re.IGNORECASE)
6501         if match:
6502             return policy_data[
6503                 match.start() : (policy_data.index(b"]", match.end())) + 2
6504             ]
6505     return None
6506 def _write_regpol_data(
6507     data_to_write, policy_file_path, gpt_ini_path, gpt_extension, gpt_extension_guid
6508 ):
6509     if not os.path.exists(policy_file_path):
6510         __salt__["file.makedirs"](policy_file_path)
6511     try:
6512         with salt.utils.files.fopen(policy_file_path, "wb") as pol_file:
6513             reg_pol_header = "\u5250\u6765\x01\x00".encode("utf-16-le")
6514             if not data_to_write.startswith(reg_pol_header):
6515                 pol_file.write(reg_pol_header)
6516             pol_file.write(data_to_write)
6517     except Exception as e:  # pylint: disable=broad-except
6518         msg = (
6519             "An error occurred attempting to write to {}, the exception was: {}".format(
6520                 policy_file_path, e
6521             )
6522         )
6523         log.exception(msg)
6524         raise CommandExecutionError(msg)
6525     gpt_ini_data = ""
6526     if os.path.exists(gpt_ini_path):
6527         with salt.utils.files.fopen(gpt_ini_path, "r") as gpt_file:
6528             gpt_ini_data = gpt_file.read()
6529         gpt_ini_data = (
6530             gpt_ini_data.replace("\r\n", "_|-")
6531             .replace("\n", "_|-")
6532             .replace("_|-", "\r\n")
6533         )
6534     if not _regexSearchRegPolData(r"\[General\]\r\n", gpt_ini_data):
6535         gpt_ini_data = "[General]\r\n" + gpt_ini_data
6536     if _regexSearchRegPolData(r"{}=".format(re.escape(gpt_extension)), gpt_ini_data):
6537         gpt_ext_loc = re.search(
6538             r"^{}=.*\r\n".format(re.escape(gpt_extension)),
6539             gpt_ini_data,
6540             re.IGNORECASE | re.MULTILINE,
6541         )
6542         gpt_ext_str = gpt_ini_data[gpt_ext_loc.start() : gpt_ext_loc.end()]
6543         if not _regexSearchRegPolData(
6544             r"{}".format(re.escape(gpt_extension_guid)), gpt_ext_str
6545         ):
6546             gpt_ext_str = gpt_ext_str.split("=")
6547             gpt_ext_str[1] = gpt_extension_guid + gpt_ext_str[1]
6548             gpt_ext_str = "=".join(gpt_ext_str)
6549             gpt_ini_data = (
6550                 gpt_ini_data[0 : gpt_ext_loc.start()]
6551                 + gpt_ext_str
6552                 + gpt_ini_data[gpt_ext_loc.end() :]
6553             )
6554     else:
6555         general_location = re.search(
6556             r"^\[General\]\r\n", gpt_ini_data, re.IGNORECASE | re.MULTILINE
6557         )
6558         gpt_ini_data = "{}{}={}\r\n{}".format(
6559             gpt_ini_data[general_location.start() : general_location.end()],
6560             gpt_extension,
6561             gpt_extension_guid,
6562             gpt_ini_data[general_location.end() :],
6563         )
6564     if _regexSearchRegPolData(r"Version=", gpt_ini_data):
6565         version_loc = re.search(
6566             r"^Version=.*\r\n", gpt_ini_data, re.IGNORECASE | re.MULTILINE
6567         )
6568         version_str = gpt_ini_data[version_loc.start() : version_loc.end()]
6569         version_str = version_str.split("=")
6570         version_nums = struct.unpack(b"&gt;2H", struct.pack(b"&gt;I", int(version_str[1])))
6571         if gpt_extension.lower() == "gPCMachineExtensionNames".lower():
6572             version_nums = (version_nums[0], version_nums[1] + 1)
6573         elif gpt_extension.lower() == "gPCUserExtensionNames".lower():
6574             version_nums = (version_nums[0] + 1, version_nums[1])
6575         version_num = struct.unpack(b"&gt;I", struct.pack(b"&gt;2H", *version_nums))[0]
6576         gpt_ini_data = "{}{}={}\r\n{}".format(
6577             gpt_ini_data[0 : version_loc.start()],
6578             "Version",
6579             version_num,
6580             gpt_ini_data[version_loc.end() :],
6581         )
6582     else:
6583         general_location = re.search(
6584             r"^\[General\]\r\n", gpt_ini_data, re.IGNORECASE | re.MULTILINE
6585         )
6586         if gpt_extension.lower() == "gPCMachineExtensionNames".lower():
6587             version_nums = (0, 1)
6588         elif gpt_extension.lower() == "gPCUserExtensionNames".lower():
6589             version_nums = (1, 0)
6590         gpt_ini_data = "{}{}={}\r\n{}".format(
6591             gpt_ini_data[general_location.start() : general_location.end()],
6592             "Version",
6593             int(
6594                 "{}{}".format(
6595                     str(version_nums[0]).zfill(4),
6596                     str(version_nums[1]).zfill(4),
6597                 ),
6598                 16,
6599             ),
6600             gpt_ini_data[general_location.end() :],
6601         )
6602     if gpt_ini_data:
6603         try:
6604             with salt.utils.files.fopen(gpt_ini_path, "w") as gpt_file:
6605                 gpt_file.write(gpt_ini_data)
6606         except Exception as e:  # pylint: disable=broad-except
6607             msg = (
6608                 "An error occurred attempting to write the gpg.ini file.\n"
6609                 "path: {}\n"
6610                 "exception: {}".format(gpt_ini_path, e)
6611             )
6612             log.exception(msg)
6613             raise CommandExecutionError(msg)
6614 def _policyFileReplaceOrAppendList(string_list, policy_data):
6615     if not policy_data:
6616         policy_data = b""
6617     specialValueRegex = salt.utils.stringutils.to_bytes(
6618         r"(\*\*Del\.|\*\*DelVals\.){0,1}"
6619     )
6620     for this_string in string_list:
6621         list_item_key = this_string.split(b"\00;")[0].lstrip(b"[")
6622         list_item_value_name = re.sub(
6623             specialValueRegex, b"", this_string.split(b"\00;")[1], flags=re.IGNORECASE
6624         )
6625         log.trace("item value name is %s", list_item_value_name)
6626         data_to_replace = _regexSearchKeyValueCombo(
6627             policy_data, list_item_key, list_item_value_name
6628         )
6629         if data_to_replace:
6630             log.trace("replacing %s with %s", data_to_replace, this_string)
6631             policy_data = policy_data.replace(data_to_replace, this_string)
6632         else:
6633             log.trace("appending %s", this_string)
6634             policy_data = b"".join([policy_data, this_string])
6635     return policy_data
6636 def _policyFileReplaceOrAppend(this_string, policy_data, append_only=False):
6637     if not policy_data:
6638         policy_data = b""
6639     specialValueRegex = salt.utils.stringutils.to_bytes(
6640         r"(\*\*Del\.|\*\*DelVals\.){0,1}"
6641     )
6642     item_key = None
6643     item_value_name = None
6644     data_to_replace = None
6645     if not append_only:
6646         item_key = this_string.split(b"\00;")[0].lstrip(b"[")
6647         item_value_name = re.sub(
6648             specialValueRegex, b"", this_string.split(b"\00;")[1], flags=re.IGNORECASE
6649         )
6650         log.trace("item value name is %s", item_value_name)
6651         data_to_replace = _regexSearchKeyValueCombo(
6652             policy_data, item_key, item_value_name
6653         )
6654     if data_to_replace:
6655         log.trace("replacing %s with %s", data_to_replace, this_string)
6656         policy_data = policy_data.replace(data_to_replace, this_string)
6657     else:
6658         log.trace("appending %s", this_string)
6659         policy_data = b"".join([policy_data, this_string])
6660     return policy_data
6661 def _writeAdminTemplateRegPolFile(
6662     admtemplate_data, adml_language="en-US", registry_class="Machine"
6663 ):
6664     r"""
6665     helper function to prep/write adm template data to the Registry.pol file
6666     each file begins with REGFILE_SIGNATURE (u'\u5250\u6765') and
6667     REGISTRY_FILE_VERSION (u'\x01\00')
6668     https://msdn.microsoft.com/en-us/library/aa374407(VS.85).aspx
6669     +    https://msdn.microsoft.com/en-us/library/cc232696.aspx
6670     [Registry Path&lt;NULL&gt;;Reg Value&lt;NULL&gt;;Reg Type;SizeInBytes;Data&lt;NULL&gt;]
6671     """
6672     existing_data = b""
6673     policy_data = _policy_info()
6674     policySearchXpath = '//ns1:*[@id = "{0}" or @name = "{0}"]'
6675     admx_policy_definitions = _get_policy_definitions(language=adml_language)
6676     adml_policy_resources = _get_policy_resources(language=adml_language)
6677     base_policy_settings = _checkAllAdmxPolicies(
6678         policy_class=registry_class,
6679         adml_language=adml_language,
6680         return_full_policy_names=False,
6681         hierarchical_return=False,
6682         return_not_configured=False,
6683     )
6684     for adm_namespace in admtemplate_data:
6685         for adm_policy in admtemplate_data[adm_namespace]:
6686             if (
6687                 str(admtemplate_data[adm_namespace][adm_policy]).lower()
6688                 == "not configured"
6689             ):
6690                 if (
6691                     base_policy_settings.get(adm_namespace, {}).pop(adm_policy, None)
6692                     is not None
6693                 ):
6694                     log.trace('Policy "%s" removed', adm_policy)
6695             else:
6696                 log.trace("adding %s to base_policy_settings", adm_policy)
6697                 if adm_namespace not in base_policy_settings:
6698                     base_policy_settings[adm_namespace] = {}
6699                 base_policy_settings[adm_namespace][adm_policy] = admtemplate_data[
6700                     adm_namespace
6701                 ][adm_policy]
6702     for adm_namespace in base_policy_settings:
6703         for admPolicy in base_policy_settings[adm_namespace]:
6704             log.trace("working on admPolicy %s", admPolicy)
6705             explicit_enable_disable_value_setting = False
6706             this_key = None
6707             this_valuename = None
6708             if (
6709                 str(base_policy_settings[adm_namespace][admPolicy]).lower()
6710                 == "disabled"
6711             ):
6712                 log.trace("time to disable %s", admPolicy)
6713                 this_policy = admx_policy_definitions.xpath(
6714                     policySearchXpath.format(admPolicy),
6715                     namespaces={"ns1": adm_namespace},
6716                 )
6717                 if this_policy:
6718                     this_policy = this_policy[0]
6719                     if "class" in this_policy.attrib:
6720                         if (
6721                             this_policy.attrib["class"] == registry_class
6722                             or this_policy.attrib["class"] == "Both"
6723                         ):
6724                             if "key" in this_policy.attrib:
6725                                 this_key = this_policy.attrib["key"]
6726                             else:
6727                                 log.error(
6728                                     "policy item %s does not have "
6729                                     'the required "key" attribute',
6730                                     this_policy.attrib,
6731                                 )
6732                                 break
6733                             if "valueName" in this_policy.attrib:
6734                                 this_valuename = this_policy.attrib["valueName"]
6735                             if DISABLED_VALUE_XPATH(this_policy):
6736                                 explicit_enable_disable_value_setting = True
6737                                 disabled_value_string = _checkValueItemParent(
6738                                     this_policy,
6739                                     admPolicy,
6740                                     this_key,
6741                                     this_valuename,
6742                                     DISABLED_VALUE_XPATH,
6743                                     None,
6744                                     check_deleted=False,
6745                                     test_item=False,
6746                                 )
6747                                 existing_data = _policyFileReplaceOrAppend(
6748                                     disabled_value_string, existing_data
6749                                 )
6750                             if DISABLED_LIST_XPATH(this_policy):
6751                                 explicit_enable_disable_value_setting = True
6752                                 disabled_list_strings = _checkListItem(
6753                                     this_policy,
6754                                     admPolicy,
6755                                     this_key,
6756                                     DISABLED_LIST_XPATH,
6757                                     None,
6758                                     test_items=False,
6759                                 )
6760                                 log.trace(
6761                                     "working with disabledList portion of %s",
6762                                     admPolicy,
6763                                 )
6764                                 existing_data = _policyFileReplaceOrAppendList(
6765                                     disabled_list_strings, existing_data
6766                                 )
6767                             if (
6768                                 not explicit_enable_disable_value_setting
6769                                 and this_valuename
6770                             ):
6771                                 disabled_value_string = _buildKnownDataSearchString(
6772                                     this_key,
6773                                     this_valuename,
6774                                     "REG_DWORD",
6775                                     None,
6776                                     check_deleted=True,
6777                                 )
6778                                 existing_data = _policyFileReplaceOrAppend(
6779                                     disabled_value_string, existing_data
6780                                 )
6781                             if ELEMENTS_XPATH(this_policy):
6782                                 log.trace("checking elements of %s", admPolicy)
6783                                 for elements_item in ELEMENTS_XPATH(this_policy):
6784                                     for child_item in elements_item:
6785                                         child_key = this_key
6786                                         child_valuename = this_valuename
6787                                         if "key" in child_item.attrib:
6788                                             child_key = child_item.attrib["key"]
6789                                         if "valueName" in child_item.attrib:
6790                                             child_valuename = child_item.attrib[
6791                                                 "valueName"
6792                                             ]
6793                                         if etree.QName(
6794                                             child_item
6795                                         ).localname == "boolean" and (
6796                                             TRUE_LIST_XPATH(child_item)
6797                                             or FALSE_LIST_XPATH(child_item)
6798                                         ):
6799                                             temp_dict = {
6800                                                 "trueList": TRUE_LIST_XPATH,
6801                                                 "falseList": FALSE_LIST_XPATH,
6802                                             }
6803                                             for this_list in temp_dict:
6804                                                 disabled_list_strings = _checkListItem(
6805                                                     child_item,
6806                                                     admPolicy,
6807                                                     child_key,
6808                                                     temp_dict[this_list],
6809                                                     None,
6810                                                     test_items=False,
6811                                                 )
6812                                                 log.trace(
6813                                                     "working with %s portion of %s",
6814                                                     admPolicy,
6815                                                     this_list,
6816                                                 )
6817                                                 existing_data = (
6818                                                     _policyFileReplaceOrAppendList(
6819                                                         disabled_list_strings,
6820                                                         existing_data,
6821                                                     )
6822                                                 )
6823                                         elif (
6824                                             etree.QName(child_item).localname
6825                                             == "boolean"
6826                                             or etree.QName(child_item).localname
6827                                             == "decimal"
6828                                             or etree.QName(child_item).localname
6829                                             == "text"
6830                                             or etree.QName(child_item).localname
6831                                             == "longDecimal"
6832                                             or etree.QName(child_item).localname
6833                                             == "multiText"
6834                                             or etree.QName(child_item).localname
6835                                             == "enum"
6836                                         ):
6837                                             disabled_value_string = _processValueItem(
6838                                                 child_item,
6839                                                 child_key,
6840                                                 child_valuename,
6841                                                 this_policy,
6842                                                 elements_item,
6843                                                 check_deleted=True,
6844                                             )
6845                                             log.trace(
6846                                                 "I have disabled value string of %s",
6847                                                 disabled_value_string,
6848                                             )
6849                                             existing_data = _policyFileReplaceOrAppend(
6850                                                 disabled_value_string, existing_data
6851                                             )
6852                                         elif (
6853                                             etree.QName(child_item).localname == "list"
6854                                         ):
6855                                             disabled_value_string = _processValueItem(
6856                                                 child_item,
6857                                                 child_key,
6858                                                 child_valuename,
6859                                                 this_policy,
6860                                                 elements_item,
6861                                                 check_deleted=True,
6862                                             )
6863                                             log.trace(
6864                                                 "I have disabled value string of %s",
6865                                                 disabled_value_string,
6866                                             )
6867                                             existing_data = _policyFileReplaceOrAppend(
6868                                                 disabled_value_string, existing_data
6869                                             )
6870                         else:
6871                             log.error(
6872                                 "policy %s was found but it does not appear to be valid"
6873                                 " for the class %s",
6874                                 admPolicy,
6875                                 registry_class,
6876                             )
6877                     else:
6878                         log.error(
6879                             'policy item %s does not have the required "class"'
6880                             " attribute",
6881                             this_policy.attrib,
6882                         )
6883             else:
6884                 log.trace('time to enable and set the policy "%s"', admPolicy)
6885                 this_policy = admx_policy_definitions.xpath(
6886                     policySearchXpath.format(admPolicy),
6887                     namespaces={"ns1": adm_namespace},
6888                 )
6889                 log.trace("found this_policy == %s", this_policy)
6890                 if this_policy:
6891                     this_policy = this_policy[0]
6892                     if "class" in this_policy.attrib:
6893                         if (
6894                             this_policy.attrib["class"] == registry_class
6895                             or this_policy.attrib["class"] == "Both"
6896                         ):
6897                             if "key" in this_policy.attrib:
6898                                 this_key = this_policy.attrib["key"]
6899                             else:
6900                                 log.error(
6901                                     'policy item %s does not have the required "key"'
6902                                     " attribute",
6903                                     this_policy.attrib,
6904                                 )
6905                                 break
6906                             if "valueName" in this_policy.attrib:
6907                                 this_valuename = this_policy.attrib["valueName"]
6908                             if ENABLED_VALUE_XPATH(this_policy):
6909                                 explicit_enable_disable_value_setting = True
6910                                 enabled_value_string = _checkValueItemParent(
6911                                     this_policy,
6912                                     admPolicy,
6913                                     this_key,
6914                                     this_valuename,
6915                                     ENABLED_VALUE_XPATH,
6916                                     None,
6917                                     check_deleted=False,
6918                                     test_item=False,
6919                                 )
6920                                 existing_data = _policyFileReplaceOrAppend(
6921                                     enabled_value_string, existing_data
6922                                 )
6923                             if ENABLED_LIST_XPATH(this_policy):
6924                                 explicit_enable_disable_value_setting = True
6925                                 enabled_list_strings = _checkListItem(
6926                                     this_policy,
6927                                     admPolicy,
6928                                     this_key,
6929                                     ENABLED_LIST_XPATH,
6930                                     None,
6931                                     test_items=False,
6932                                 )
6933                                 log.trace(
6934                                     "working with enabledList portion of %s", admPolicy
6935                                 )
6936                                 existing_data = _policyFileReplaceOrAppendList(
6937                                     enabled_list_strings, existing_data
6938                                 )
6939                             if (
6940                                 not explicit_enable_disable_value_setting
6941                                 and this_valuename
6942                             ):
6943                                 enabled_value_string = _buildKnownDataSearchString(
6944                                     this_key,
6945                                     this_valuename,
6946                                     "REG_DWORD",
6947                                     "1",
6948                                     check_deleted=False,
6949                                 )
6950                                 existing_data = _policyFileReplaceOrAppend(
6951                                     enabled_value_string, existing_data
6952                                 )
6953                             if ELEMENTS_XPATH(this_policy):
6954                                 for elements_item in ELEMENTS_XPATH(this_policy):
6955                                     for child_item in elements_item:
6956                                         child_key = this_key
6957                                         child_valuename = this_valuename
6958                                         if "key" in child_item.attrib:
6959                                             child_key = child_item.attrib["key"]
6960                                         if "valueName" in child_item.attrib:
6961                                             child_valuename = child_item.attrib[
6962                                                 "valueName"
6963                                             ]
6964                                         if (
6965                                             child_item.attrib["id"]
6966                                             in base_policy_settings[adm_namespace][
6967                                                 admPolicy
6968                                             ]
6969                                         ):
6970                                             if etree.QName(
6971                                                 child_item
6972                                             ).localname == "boolean" and (
6973                                                 TRUE_LIST_XPATH(child_item)
6974                                                 or FALSE_LIST_XPATH(child_item)
6975                                             ):
6976                                                 list_strings = []
6977                                                 if base_policy_settings[adm_namespace][
6978                                                     admPolicy
6979                                                 ][child_item.attrib["id"]]:
6980                                                     list_strings = _checkListItem(
6981                                                         child_item,
6982                                                         admPolicy,
6983                                                         child_key,
6984                                                         TRUE_LIST_XPATH,
6985                                                         None,
6986                                                         test_items=False,
6987                                                     )
6988                                                     log.trace(
6989                                                         "working with trueList portion"
6990                                                         " of %s",
6991                                                         admPolicy,
6992                                                     )
6993                                                 else:
6994                                                     list_strings = _checkListItem(
6995                                                         child_item,
6996                                                         admPolicy,
6997                                                         child_key,
6998                                                         FALSE_LIST_XPATH,
6999                                                         None,
7000                                                         test_items=False,
7001                                                     )
7002                                                 existing_data = (
7003                                                     _policyFileReplaceOrAppendList(
7004                                                         list_strings, existing_data
7005                                                     )
7006                                                 )
7007                                             elif etree.QName(
7008                                                 child_item
7009                                             ).localname == "boolean" and (
7010                                                 TRUE_VALUE_XPATH(child_item)
7011                                                 or FALSE_VALUE_XPATH(child_item)
7012                                             ):
7013                                                 value_string = ""
7014                                                 if base_policy_settings[adm_namespace][
7015                                                     admPolicy
7016                                                 ][child_item.attrib["id"]]:
7017                                                     value_string = (
7018                                                         _checkValueItemParent(
7019                                                             child_item,
7020                                                             admPolicy,
7021                                                             child_key,
7022                                                             child_valuename,
7023                                                             TRUE_VALUE_XPATH,
7024                                                             None,
7025                                                             check_deleted=False,
7026                                                             test_item=False,
7027                                                         )
7028                                                     )
7029                                                 else:
7030                                                     value_string = (
7031                                                         _checkValueItemParent(
7032                                                             child_item,
7033                                                             admPolicy,
7034                                                             child_key,
7035                                                             child_valuename,
7036                                                             FALSE_VALUE_XPATH,
7037                                                             None,
7038                                                             check_deleted=False,
7039                                                             test_item=False,
7040                                                         )
7041                                                     )
7042                                                 existing_data = (
7043                                                     _policyFileReplaceOrAppend(
7044                                                         value_string, existing_data
7045                                                     )
7046                                                 )
7047                                             elif (
7048                                                 etree.QName(child_item).localname
7049                                                 == "boolean"
7050                                                 or etree.QName(child_item).localname
7051                                                 == "decimal"
7052                                                 or etree.QName(child_item).localname
7053                                                 == "text"
7054                                                 or etree.QName(child_item).localname
7055                                                 == "longDecimal"
7056                                                 or etree.QName(child_item).localname
7057                                                 == "multiText"
7058                                             ):
7059                                                 enabled_value_string = _processValueItem(
7060                                                     child_item,
7061                                                     child_key,
7062                                                     child_valuename,
7063                                                     this_policy,
7064                                                     elements_item,
7065                                                     check_deleted=False,
7066                                                     this_element_value=base_policy_settings[
7067                                                         adm_namespace
7068                                                     ][
7069                                                         admPolicy
7070                                                     ][
7071                                                         child_item.attrib["id"]
7072                                                     ],
7073                                                 )
7074                                                 log.trace(
7075                                                     "I have enabled value string of %s",
7076                                                     enabled_value_string,
7077                                                 )
7078                                                 existing_data = (
7079                                                     _policyFileReplaceOrAppend(
7080                                                         enabled_value_string,
7081                                                         existing_data,
7082                                                     )
7083                                                 )
7084                                             elif (
7085                                                 etree.QName(child_item).localname
7086                                                 == "enum"
7087                                             ):
7088                                                 for enum_item in child_item:
7089                                                     if (
7090                                                         base_policy_settings[
7091                                                             adm_namespace
7092                                                         ][admPolicy][
7093                                                             child_item.attrib["id"]
7094                                                         ]
7095                                                         == _getAdmlDisplayName(
7096                                                             adml_policy_resources,
7097                                                             enum_item.attrib[
7098                                                                 "displayName"
7099                                                             ],
7100                                                         ).strip()
7101                                                     ):
7102                                                         enabled_value_string = (
7103                                                             _checkValueItemParent(
7104                                                                 enum_item,
7105                                                                 child_item.attrib["id"],
7106                                                                 child_key,
7107                                                                 child_valuename,
7108                                                                 VALUE_XPATH,
7109                                                                 None,
7110                                                                 check_deleted=False,
7111                                                                 test_item=False,
7112                                                             )
7113                                                         )
7114                                                         existing_data = (
7115                                                             _policyFileReplaceOrAppend(
7116                                                                 enabled_value_string,
7117                                                                 existing_data,
7118                                                             )
7119                                                         )
7120                                                         if VALUE_LIST_XPATH(enum_item):
7121                                                             enabled_list_strings = (
7122                                                                 _checkListItem(
7123                                                                     enum_item,
7124                                                                     admPolicy,
7125                                                                     child_key,
7126                                                                     VALUE_LIST_XPATH,
7127                                                                     None,
7128                                                                     test_items=False,
7129                                                                 )
7130                                                             )
7131                                                             log.trace(
7132                                                                 "working with valueList"
7133                                                                 " portion of %s",
7134                                                                 child_item.attrib["id"],
7135                                                             )
7136                                                             existing_data = _policyFileReplaceOrAppendList(
7137                                                                 enabled_list_strings,
7138                                                                 existing_data,
7139                                                             )
7140                                                         break
7141                                             elif (
7142                                                 etree.QName(child_item).localname
7143                                                 == "list"
7144                                             ):
7145                                                 enabled_value_string = _processValueItem(
7146                                                     child_item,
7147                                                     child_key,
7148                                                     child_valuename,
7149                                                     this_policy,
7150                                                     elements_item,
7151                                                     check_deleted=False,
7152                                                     this_element_value=base_policy_settings[
7153                                                         adm_namespace
7154                                                     ][
7155                                                         admPolicy
7156                                                     ][
7157                                                         child_item.attrib["id"]
7158                                                     ],
7159                                                 )
7160                                                 log.trace(
7161                                                     "I have enabled value string of %s",
7162                                                     enabled_value_string,
7163                                                 )
7164                                                 existing_data = (
7165                                                     _policyFileReplaceOrAppend(
7166                                                         enabled_value_string,
7167                                                         existing_data,
7168                                                         append_only=True,
7169                                                     )
7170                                                 )
7171     try:
7172         _write_regpol_data(
7173             existing_data,
7174             policy_data.admx_registry_classes[registry_class]["policy_path"],
7175             policy_data.gpt_ini_path,
7176             policy_data.admx_registry_classes[registry_class]["gpt_extension_location"],
7177             policy_data.admx_registry_classes[registry_class]["gpt_extension_guid"],
7178         )
7179     except CommandExecutionError as exc:  # pylint: disable=broad-except
7180         log.exception(
7181             "Unhandled exception occurred while attempting to "
7182             "write Adm Template Policy File.\nException: %s",
7183             exc,
7184         )
7185         return False
7186     return True
7187 def _getScriptSettingsFromIniFile(policy_info):
7188     _existingData = None
7189     if os.path.isfile(policy_info["ScriptIni"]["IniPath"]):
7190         with salt.utils.files.fopen(policy_info["ScriptIni"]["IniPath"], "rb") as fhr:
7191             _existingData = fhr.read()
7192         if _existingData:
7193             try:
7194                 _existingData = deserialize(
7195                     _existingData.decode("utf-16-le").lstrip("\ufeff")
7196                 )
7197                 log.trace("Have deserialized data %s", _existingData)
7198             except Exception as error:  # pylint: disable=broad-except
7199                 log.exception(
7200                     "An error occurred attempting to deserialize data for %s",
7201                     policy_info["Policy"],
7202                 )
7203                 raise CommandExecutionError(error)
7204             if "Section" in policy_info["ScriptIni"] and policy_info["ScriptIni"][
7205                 "Section"
7206             ].lower() in [z.lower() for z in _existingData.keys()]:
7207                 if "SettingName" in policy_info["ScriptIni"]:
7208                     log.trace(
7209                         "Need to look for %s", policy_info["ScriptIni"]["SettingName"]
7210                     )
7211                     if policy_info["ScriptIni"]["SettingName"].lower() in [
7212                         z.lower()
7213                         for z in _existingData[
7214                             policy_info["ScriptIni"]["Section"]
7215                         ].keys()
7216                     ]:
7217                         return _existingData[policy_info["ScriptIni"]["Section"]][
7218                             policy_info["ScriptIni"]["SettingName"].lower()
7219                         ]
7220                     else:
7221                         return None
7222                 else:
7223                     return _existingData[policy_info["ScriptIni"]["Section"]]
7224             else:
7225                 return None
7226     return None
7227 def _writeGpoScript(psscript=False):
7228     _machineScriptPolicyPath = os.path.join(
7229         os.getenv("WINDIR"),
7230         "System32",
7231         "GroupPolicy",
7232         "Machine",
7233         "Scripts",
7234         "scripts.ini",
7235     )
7236     _machinePowershellScriptPolicyPath = os.path.join(
7237         os.getenv("WINDIR"),
7238         "System32",
7239         "GroupPolicy",
7240         "Machine",
7241         "Scripts",
7242         "psscripts.ini",
7243     )
7244     _userScriptPolicyPath = os.path.join(
7245         os.getenv("WINDIR"), "System32", "GroupPolicy", "User", "Scripts", "scripts.ini"
7246     )
7247     _userPowershellScriptPolicyPath = os.path.join(
7248         os.getenv("WINDIR"),
7249         "System32",
7250         "GroupPolicy",
7251         "User",
7252         "Scripts",
7253         "psscripts.ini",
7254     )
7255 def _lookup_admin_template(policy_name, policy_class, adml_language="en-US"):
7256     policy_aliases = []
7257     admx_policy_definitions = _get_policy_definitions(language=adml_language)
7258     adml_policy_resources = _get_policy_resources(language=adml_language)
7259     admx_search_results = ADMX_SEARCH_XPATH(
7260         admx_policy_definitions, policy_name=policy_name, registry_class=policy_class
7261     )
7262     if admx_search_results:
7263         if len(admx_search_results) == 1:
7264             the_policy = admx_search_results[0]
7265             policy_display_name = _getFullPolicyName(
7266                 policy_item=the_policy,
7267                 policy_name=the_policy.attrib["name"],
7268                 return_full_policy_names=True,
7269                 adml_language=adml_language,
7270             )
7271             policy_aliases.append(policy_display_name)
7272             policy_aliases.append(the_policy.attrib["name"])
7273             full_path_list = _build_parent_list(
7274                 policy_definition=the_policy,
7275                 return_full_policy_names=True,
7276                 adml_language=adml_language,
7277             )
7278             full_path_list.reverse()
7279             full_path_list.append(policy_display_name)
7280             policy_aliases.append("\\".join(full_path_list))
7281             return True, the_policy, policy_aliases, None
7282         else:
7283             msg = 'ADMX policy name/id "{}" is used in multiple ADMX files'
7284             return False, None, [], msg
7285     else:
7286         adml_search_results = ADML_SEARCH_XPATH(
7287             adml_policy_resources, policy_name=policy_name
7288         )
7289         hierarchy = []
7290         hierarchy_policy_name = policy_name
7291         if not adml_search_results:
7292             log.warning("Trying another: %s", policy_name)
7293             if "\\" in policy_name:
7294                 hierarchy = policy_name.split("\\")
7295                 policy_name = hierarchy.pop()
7296                 adml_search_results = ADML_SEARCH_XPATH(
7297                     adml_policy_resources, policy_name=policy_name
7298                 )
7299         if adml_search_results:
7300             multiple_adml_entries = False
7301             suggested_policies = ""
7302             adml_to_remove = []
7303             if len(adml_search_results) &gt; 1:
7304                 log.trace(
7305                     "multiple ADML entries found matching the policy name %s",
7306                     policy_name,
7307                 )
7308                 multiple_adml_entries = True
7309                 for adml_search_result in adml_search_results:
7310                     if (
7311                         not getattr(adml_search_result, "text", "").strip()
7312                         == policy_name
7313                     ):
7314                         adml_to_remove.append(adml_search_result)
7315                     else:
7316                         if hierarchy:
7317                             log.trace("we have hierarchy of %s", hierarchy)
7318                             display_name_searchval = "$({}.{})".format(
7319                                 adml_search_result.tag.split("}")[1],
7320                                 adml_search_result.attrib["id"],
7321                             )
7322                             policy_search_string = (
7323                                 '//{}:policy[@displayName = "{}" and (@class = "Both"'
7324                                 ' or @class = "{}") ]'.format(
7325                                     adml_search_result.prefix,
7326                                     display_name_searchval,
7327                                     policy_class,
7328                                 )
7329                             )
7330                             admx_results = []
7331                             these_admx_search_results = admx_policy_definitions.xpath(
7332                                 policy_search_string,
7333                                 namespaces=adml_search_result.nsmap,
7334                             )
7335                             if not these_admx_search_results:
7336                                 log.trace(
7337                                     "No admx was found for the adml entry %s, it will"
7338                                     " be removed",
7339                                     display_name_searchval,
7340                                 )
7341                                 adml_to_remove.append(adml_search_result)
7342                             for search_result in these_admx_search_results:
7343                                 log.trace("policy_name == %s", policy_name)
7344                                 this_hierarchy = _build_parent_list(
7345                                     policy_definition=search_result,
7346                                     return_full_policy_names=True,
7347                                     adml_language=adml_language,
7348                                 )
7349                                 this_hierarchy.reverse()
7350                                 if hierarchy != this_hierarchy:
7351                                     log.trace(
7352                                         "hierarchy %s does not match this item's"
7353                                         " hierarchy of %s",
7354                                         hierarchy,
7355                                         this_hierarchy,
7356                                     )
7357                                     if len(these_admx_search_results) == 1:
7358                                         log.trace(
7359                                             "only 1 admx was found and it does not "
7360                                             "match this adml, it is safe to remove "
7361                                             "from the list"
7362                                         )
7363                                         adml_to_remove.append(adml_search_result)
7364                                 else:
7365                                     log.trace(
7366                                         "hierarchy %s matches item's hierarchy of %s",
7367                                         hierarchy,
7368                                         this_hierarchy,
7369                                     )
7370                                     log.trace(
7371                                         "search_result %s added to results",
7372                                         search_result,
7373                                     )
7374                                     admx_results.append(search_result)
7375                             if len(admx_results) == 1:
7376                                 admx_search_results.append(admx_results[0])
7377                         else:
7378                             display_name_searchval = "$({}.{})".format(
7379                                 adml_search_result.tag.split("}")[1],
7380                                 adml_search_result.attrib["id"],
7381                             )
7382                             these_admx_search_results = ADMX_DISPLAYNAME_SEARCH_XPATH(
7383                                 admx_policy_definitions,
7384                                 display_name=display_name_searchval,
7385                                 registry_class=policy_class,
7386                             )
7387                             if not these_admx_search_results:
7388                                 adml_to_remove.append(adml_search_result)
7389             for adml in adml_to_remove:
7390                 if adml in adml_search_results:
7391                     adml_search_results.remove(adml)
7392             if len(adml_search_results) == 1 and multiple_adml_entries:
7393                 multiple_adml_entries = False
7394             for adml_search_result in adml_search_results:
7395                 log.trace(
7396                     "found an ADML entry matching the string! %s -- %s",
7397                     adml_search_result.tag,
7398                     adml_search_result.attrib,
7399                 )
7400                 display_name_searchval = "$({}.{})".format(
7401                     adml_search_result.tag.split("}")[1],
7402                     adml_search_result.attrib["id"],
7403                 )
7404                 log.trace("searching for displayName == %s", display_name_searchval)
7405                 if not admx_search_results:
7406                     log.trace(
7407                         "search for an admx entry matching display_name %s and"
7408                         " registry_class %s",
7409                         display_name_searchval,
7410                         policy_class,
7411                     )
7412                     admx_search_results = ADMX_DISPLAYNAME_SEARCH_XPATH(
7413                         admx_policy_definitions,
7414                         display_name=display_name_searchval,
7415                         registry_class=policy_class,
7416                     )
7417                 if admx_search_results:
7418                     log.trace(
7419                         "processing admx_search_results of %s", admx_search_results
7420                     )
7421                     log.trace("multiple_adml_entries is %s", multiple_adml_entries)
7422                     if (
7423                         len(admx_search_results) == 1 or hierarchy
7424                     ) and not multiple_adml_entries:
7425                         found = False
7426                         for search_result in admx_search_results:
7427                             found = False
7428                             if hierarchy:
7429                                 this_hierarchy = _build_parent_list(
7430                                     policy_definition=search_result,
7431                                     return_full_policy_names=True,
7432                                     adml_language=adml_language,
7433                                 )
7434                                 this_hierarchy.reverse()
7435                                 log.trace("testing %s == %s", hierarchy, this_hierarchy)
7436                                 if hierarchy == this_hierarchy:
7437                                     found = True
7438                             else:
7439                                 found = True
7440                             if found:
7441                                 log.trace(
7442                                     "found the ADMX policy matching "
7443                                     "the display name %s -- %s",
7444                                     search_result,
7445                                     policy_name,
7446                                 )
7447                                 if "name" in search_result.attrib:
7448                                     policy_display_name = _getFullPolicyName(
7449                                         policy_item=search_result,
7450                                         policy_name=search_result.attrib["name"],
7451                                         return_full_policy_names=True,
7452                                         adml_language=adml_language,
7453                                     )
7454                                     policy_aliases.append(policy_display_name)
7455                                     policy_aliases.append(search_result.attrib["name"])
7456                                     full_path_list = _build_parent_list(
7457                                         policy_definition=search_result,
7458                                         return_full_policy_names=True,
7459                                         adml_language=adml_language,
7460                                     )
7461                                     full_path_list.reverse()
7462                                     full_path_list.append(policy_display_name)
7463                                     policy_aliases.append("\\".join(full_path_list))
7464                                     return True, search_result, policy_aliases, None
7465                                 else:
7466                                     msg = (
7467                                         "ADMX policy with the display name {} does not"
7468                                         "have the required name attribute"
7469                                     )
7470                                     msg = msg.format(policy_name)
7471                                     return False, None, [], msg
7472                         if not found:
7473                             msg = "Unable to correlate {} to any policy".format(
7474                                 hierarchy_policy_name
7475                             )
7476                             return False, None, [], msg
7477                     else:
7478                         for possible_policy in admx_search_results:
7479                             this_parent_list = _build_parent_list(
7480                                 policy_definition=possible_policy,
7481                                 return_full_policy_names=True,
7482                                 adml_language=adml_language,
7483                             )
7484                             this_parent_list.reverse()
7485                             this_parent_list.append(policy_name)
7486                             if suggested_policies:
7487                                 suggested_policies = ", ".join(
7488                                     [suggested_policies, "\\".join(this_parent_list)]
7489                                 )
7490                             else:
7491                                 suggested_policies = "\\".join(this_parent_list)
7492             if suggested_policies:
7493                 msg = (
7494                     'ADML policy name "{}" is used as the display name for '
7495                     "multiple policies. These policies matched: {}. You can "
7496                     "utilize these long names to specify the correct policy"
7497                 )
7498                 return False, None, [], msg.format(policy_name, suggested_policies)
7499     return (
7500         False,
7501         None,
7502         [],
7503         "Unable to find {} policy {}".format(policy_class, policy_name),
7504     )
7505 def get_policy_info(policy_name, policy_class, adml_language="en-US"):
7506     r"""
7507     Returns information about a specified policy
7508     Args:
7509         policy_name (str):
7510             The name of the policy to lookup
7511         policy_class (str):
7512             The class of policy, i.e. machine, user, both
7513         adml_language (str):
7514             The ADML language to use for Administrative Template data lookup
7515     Returns:
7516         dict: Information about the specified policy
7517     CLI Example:
7518     .. code-block:: bash
7519         salt '*' lgpo.get_policy_info 'Maximum password age' machine
7520     You can use ``lgpo.get_policy_info`` to get all the possible names that
7521     could be used in a state file or from the command line (along with elements
7522     that need to be set/etc). The key is to match the text you see in the
7523     ``gpedit.msc`` gui exactly, including quotes around words or phrases. The
7524     "full path" style is really only needed when there are multiple policies
7525     that use the same base name. For example, ``Access data sources across
7526     domains`` exists in ~10 different paths. If you put that through
7527     ``get_policy_info`` you'll get back a message that it is used for multiple
7528     policies and you need to be more specific.
7529     CLI Example:
7530     .. code-block:: bash
7531         salt-call --local lgpo.get_policy_info ShellRemoveOrderPrints_2 machine
7532         local:
7533             ----------
7534             message:
7535             policy_aliases:
7536                 - Turn off the "Order Prints" picture task
7537                 - ShellRemoveOrderPrints_2
7538                 - System\Internet Communication Management\Internet Communication settings\Turn off the "Order Prints" picture task
7539             policy_class:
7540                 machine
7541             policy_elements:
7542             policy_found:
7543                 True
7544             policy_name:
7545                 ShellRemoveOrderPrints_2
7546             rights_assignment:
7547                 False
7548     Escaping can get tricky in cmd/Powershell. The following is an example of
7549     escaping in Powershell using backquotes:
7550     .. code-block:: bash
7551         PS&gt;salt-call --local lgpo.get_policy_info "Turn off the `\`"Order Prints`\`" picture task" machine
7552         local:
7553             ----------
7554             message:
7555             policy_aliases:
7556                 - Turn off the "Order Prints" picture task
7557                 - ShellRemoveOrderPrints_2
7558                 - System\Internet Communication Management\Internet Communication settings\Turn off the "Order Prints" picture task
7559             policy_class:
7560                 machine
7561             policy_elements:
7562             policy_found:
7563                 True
7564             policy_name:
7565                 Turn off the "Order Prints" picture task
7566             rights_assignment:
7567                 False
7568     This function can then be used to get the options available for specifying
7569     Group Policy Objects to be used in state files. Based on the above any of
7570     these *should* be usable:
7571     .. code-block:: bash
7572         internet_communications_settings:
7573           lgpo.set:
7574             - computer_policy:
7575                 Turn off the "Order Prints" picture task: Enabled
7576     .. code-block:: bash
7577         internet_communications_settings:
7578           lgpo.set:
7579             - computer_policy:
7580                 ShellRemoveOrderPrints_2: Enabled
7581     When using the full path, it might be a good idea to use single quotes
7582     around the path:
7583     .. code-block:: bash
7584         internet_communications_settings:
7585           lgpo.set:
7586             - computer_policy:
7587                 'System\Internet Communication Management\Internet Communication settings\Turn off the "Order Prints" picture task': 'Enabled'
7588     If you struggle to find the policy from ``get_policy_info`` using the name
7589     as you see in ``gpedit.msc``, the names such as "ShellRemoveOrderPrints_2"
7590     come from the ``.admx`` files. If you know nothing about ``.admx/.adml``
7591     relationships (ADML holds what you see in the GUI, ADMX holds the more
7592     technical details), then this may be a little bit too much info, but here is
7593     an example with the above policy using Powershell:
7594     .. code-block:: bash
7595         PS&gt;Get-ChildItem -Path C:\Windows\PolicyDefinitions -Recurse -Filter *.adml | Select-String "Order Prints"
7596         C:\windows\PolicyDefinitions\en-US\ICM.adml:152:      &lt;string id="ShellRemoveOrderPrints"&gt;Turn off the "Order Prints" picture task&lt;/string&gt;
7597         C:\windows\PolicyDefinitions\en-US\ICM.adml:153:      &lt;string id="ShellRemoveOrderPrints_Help"&gt;This policy setting specifies whether the "Order Prints Online" task is available from Picture Tasks in Windows folders.
7598         C:\windows\PolicyDefinitions\en-US\ICM.adml:155:The Order Prints Online Wizard is used to download a list of providers and allow users to order prints online.
7599         C:\windows\PolicyDefinitions\en-US\ICM.adml:157:If you enable this policy setting, the task "Order Prints Online" is removed from Picture Tasks in File Explorer folders.
7600     From this grep, we can see id "ShellRemoveOrderPrints" is the ID of the
7601     string used to describe this policy, then we search for it in the ADMX:
7602     .. code-block:: bash
7603         PS&gt;Get-ChildItem -Path C:\Windows\PolicyDefinitions -Recurse -Filter *.admx | Select-String "ShellRemoveOrderPrints"
7604         C:\windows\PolicyDefinitions\ICM.admx:661:    &lt;policy name="ShellRemoveOrderPrints_1" class="User" displayName="$(string.ShellRemoveOrderPrints)" explainText="$(string.ShellRemoveOrderPrints_Help)" key="Software\Microsoft\Windows\CurrentVersion\Policies\Explorer" valueName="NoOnlinePrintsWizard"&gt;
7605         C:\windows\PolicyDefinitions\ICM.admx:671:    &lt;policy name="ShellRemoveOrderPrints_2" class="Machine" displayName="$(string.ShellRemoveOrderPrints)" explainText="$(string.ShellRemoveOrderPrints_Help)" key="Software\Microsoft\Windows\CurrentVersion\Policies\Explorer" valueName="NoOnlinePrintsWizard"&gt;
7606     Now we have two to pick from. And if you notice the ``class="Machine"`` and
7607     ``class="User"`` (which details if it is a computer policy or user policy
7608     respectively) the ``ShellRemoveOrderPrints_2`` is the "short name" we could
7609     use to pass through ``get_policy_info`` to see what the module itself is
7610     expecting.
7611     Get a policy value
7612     Args:
7613         policy_class (str):
7614             Some policies are both user and computer, by default all policies
7615             will be pulled, but this can be used to retrieve only a specific
7616             policy class User/USER/user = retrieve user policies
7617             Machine/MACHINE/machine/Computer/COMPUTER/computer = retrieve
7618             machine/computer policies
7619         return_full_policy_names (bool):
7620             True/False to return the policy name as it is seen in the
7621             ``gpedit.msc`` GUI or to only return the policy key/id.
7622         hierarchical_return (bool):
7623             True/False to return the policy data in the hierarchy as seen in the
7624             ``gpedit.msc`` GUI. The default of False will return data split only
7625             into User/Computer configuration sections
7626         adml_language (str):
7627             The ADML language to use for processing display/descriptive names
7628             and enumeration values of ADMX template data, defaults to en-US
7629         return_not_configured (bool):
7630             Include Administrative Template policies that are 'Not Configured'
7631             in the return data
7632     Returns:
7633         dict: A dictionary containing the policy values for the specified class
7634     CLI Example:
7635     .. code-block:: bash
7636         salt '*' lgpo.get machine return_full_policy_names=True
7637     Some policies are defined in this module and others by the ADMX/ADML files
7638     on the machine. This function loads the current values for policies defined
7639     in this module.
7640     Args:
7641         policy_definition (dict):
7642             A sub-dict of Policies property of the _policy_info() class.
7643             Basically a dictionary that defines the policy
7644     Returns:
7645         The transformed value. The transform is defined in the policy
7646         definition. It can be a list, a string, a dictionary, depending on how
7647         it's defined
7648     Usage:
7649         policy_data = _policy_info()
7650         policy_name = 'RemoteRegistryExactPaths'
7651         policy_definition = policy_data.policies['Machine']['policies'][policy_name]
7652         policy_value = _get_policy_info_setting(policy_definition)
7653     Get the current setting for polices set via the policy templates (ADMX/ADML)
7654     files
7655     Args:
7656         admx_policy (obj):
7657             The XPath object as returned by the ``_lookup_admin_template``
7658             function
7659         policy_class (str):
7660             The policy class. Must be one of ``machine`` or ``user``
7661         adml_language (str):
7662             The language code for the adml file to use for localization. The
7663             default is ``en-US``
7664         return_full_policy_names (bool):
7665             Returns the full policy name regardless of what was passed in
7666             ``policy_name``
7667         hierarchical_return (bool):
7668             Returns a hierarchical view of the policy showing its parents
7669     Returns:
7670         dict: A dictionary containing the policy settings
7671     Usage:
7672         policy_name = 'AutoUpdateCfg'
7673         policy_class = 'machine'
7674         adml_language = 'en-US'
7675         success, policy_obj, _, _ = _lookup_admin_template(
7676             policy_name=policy_name,
7677             policy_class=policy_class,
7678             adml_language=adml_language)
7679         if success:
7680             setting = _get_policy_adm_setting(
7681                 admx_policy=policy_obj,
7682                 policy_class=policy_class,
7683                 adml_language=adml_language,
7684                 return_full_policy_names=return_full_policy_names,
7685                 hierarchical_return=hierarchical_return
7686             )
7687     if not policy_name:
7688         raise SaltInvocationError("policy_name must be defined")
7689     if not policy_class:
7690         raise SaltInvocationError("policy_class must be defined")
7691     policy_class = policy_class.title()
7692     policy_data = _policy_info()
7693     if policy_class not in policy_data.policies.keys():
7694         policy_classes = ", ".join(policy_data.policies.keys())
7695         raise CommandExecutionError(
7696             'The requested policy class "{}" is invalid, policy_class should '
7697             "be one of: {}".format(policy_class, policy_classes)
7698         )
7699     policy_definition = None
7700     if policy_name in policy_data.policies[policy_class]["policies"]:
7701         policy_definition = policy_data.policies[policy_class]["policies"][policy_name]
7702     else:
7703         for pol in policy_data.policies[policy_class]["policies"]:
7704             _p = policy_data.policies[policy_class]["policies"][pol]["Policy"]
7705             if _p == policy_name:
7706                 policy_definition = policy_data.policies[policy_class]["policies"][pol]
7707                 break
7708         if policy_definition is None:
7709             for pol in policy_data.policies[policy_class]["policies"]:
7710                 _p = policy_data.policies[policy_class]["policies"][pol]["Policy"]
7711                 if _p.lower() == policy_name.lower():
7712                     policy_definition = policy_data.policies[policy_class]["policies"][
7713                         pol
7714                     ]
7715                     break
7716     if policy_definition:
7717         if return_value_only:
7718             return _get_policy_info_setting(policy_definition)
7719         if return_full_policy_names:
7720             key_name = policy_definition["Policy"]
7721         else:
7722             key_name = policy_name
7723         setting = {key_name: _get_policy_info_setting(policy_definition)}
7724         if hierarchical_return:
7725             if "lgpo_section" in policy_definition:
7726                 first_item = True
7727                 t_dict = {}
7728                 for level in reversed(policy_definition["lgpo_section"]):
7729                     new_dict = {}
7730                     if first_item:
7731                         new_dict[level] = {key_name: setting.pop(key_name)}
7732                         first_item = False
7733                     else:
7734                         new_dict[level] = t_dict
7735                     t_dict = new_dict
7736                 if t_dict:
7737                     setting = t_dict
7738         return setting
7739     success, policy_obj, _, _ = _lookup_admin_template(
7740         policy_name=policy_name, policy_class=policy_class, adml_language=adml_language
7741     )
7742     if success:
7743         setting = _get_policy_adm_setting(
7744             admx_policy=policy_obj,
7745             policy_class=policy_class,
7746             adml_language=adml_language,
7747             return_full_policy_names=return_full_policy_names,
7748             hierarchical_return=hierarchical_return,
7749         )
7750         if return_value_only:
7751             for key in setting:
7752                 return setting[key]
7753         return setting
7754 def set_computer_policy(
7755     name, setting, cumulative_rights_assignments=True, adml_language="en-US"
7756 ):
7757     pol = {}
7758     pol[name] = setting
7759     ret = set_(
7760         computer_policy=pol,
7761         user_policy=None,
7762         cumulative_rights_assignments=cumulative_rights_assignments,
7763         adml_language=adml_language,
7764     )
7765     return ret
7766 def set_user_policy(name, setting, adml_language="en-US"):
7767     pol = {}
7768     pol[name] = setting
7769     ret = set_(
7770         user_policy=pol,
7771         computer_policy=None,
7772         cumulative_rights_assignments=True,
7773         adml_language=adml_language,
7774     )
7775     return ret
7776 def set_(
7777     computer_policy=None,
7778     user_policy=None,
7779     cumulative_rights_assignments=True,
7780     adml_language="en-US",
7781 ):
7782     if computer_policy and not isinstance(computer_policy, dict):
7783         raise SaltInvocationError("computer_policy must be specified as a dict")
7784     if user_policy and not isinstance(user_policy, dict):
7785         raise SaltInvocationError("user_policy must be specified as a dict")
7786     policies = {}
7787     policies["User"] = user_policy
7788     policies["Machine"] = computer_policy
7789     if policies:
7790         adml_policy_resources = _get_policy_resources(language=adml_language)
7791         for p_class in policies:
7792             _secedits = {}
7793             _netshs = {}
7794             _advaudits = {}
7795             _modal_sets = {}
7796             _admTemplateData = {}
7797             _regedits = {}
7798             _lsarights = {}
7799             _policydata = _policy_info()
7800             if policies[p_class]:
7801                 for policy_name in policies[p_class]:
7802                     _pol = None
7803                     policy_key_name = policy_name
7804                     if policy_name in _policydata.policies[p_class]["policies"]:
7805                         _pol = _policydata.policies[p_class]["policies"][policy_name]
7806                     else:
7807                         for policy in _policydata.policies[p_class]["policies"]:
7808                             _p = _policydata.policies[p_class]["policies"][policy][
7809                                 "Policy"
7810                             ]
7811                             if _p == policy_name:
7812                                 _pol = _policydata.policies[p_class]["policies"][policy]
7813                                 policy_key_name = policy
7814                         if _pol is None:
7815                             for policy in _policydata.policies[p_class]["policies"]:
7816                                 _p = _policydata.policies[p_class]["policies"][policy][
7817                                     "Policy"
7818                                 ]
7819                                 if _p.lower() == policy_name.lower():
7820                                     _pol = _policydata.policies[p_class]["policies"][
7821                                         policy
7822                                     ]
7823                                     policy_key_name = policy
7824                     if _pol:
7825                         _value = _transform_value(
7826                             value=policies[p_class][policy_name],
7827                             policy=_policydata.policies[p_class]["policies"][
7828                                 policy_key_name
7829                             ],
7830                             transform_type="Put",
7831                         )
7832                         if not _validateSetting(
7833                             value=_value,
7834                             policy=_policydata.policies[p_class]["policies"][
7835                                 policy_key_name
7836                             ],
7837                         ):
7838                             raise SaltInvocationError(
7839                                 "The specified value {} is not an acceptable setting"
7840                                 " for policy {}.".format(
7841                                     policies[p_class][policy_name], policy_name
7842                                 )
7843                             )
7844                         if "Registry" in _pol:
7845                             log.trace("%s is a registry policy", policy_name)
7846                             _regedits[policy_name] = {"policy": _pol, "value": _value}
7847                         elif "Secedit" in _pol:
7848                             log.trace("%s is a Secedit policy", policy_name)
7849                             if _pol["Secedit"]["Section"] not in _secedits:
7850                                 _secedits[_pol["Secedit"]["Section"]] = []
7851                             _secedits[_pol["Secedit"]["Section"]].append(
7852                                 " ".join([_pol["Secedit"]["Option"], "=", str(_value)])
7853                             )
7854                         elif "NetSH" in _pol:
7855                             log.trace("%s is a NetSH policy", policy_name)
7856                             _netshs.setdefault(
7857                                 policy_name,
7858                                 {
7859                                     "profile": _pol["NetSH"]["Profile"],
7860                                     "section": _pol["NetSH"]["Section"],
7861                                     "option": _pol["NetSH"]["Option"],
7862                                     "value": str(_value),
7863                                 },
7864                             )
7865                         elif "AdvAudit" in _pol:
7866                             _advaudits.setdefault(
7867                                 policy_name,
7868                                 {
7869                                     "option": _pol["AdvAudit"]["Option"],
7870                                     "value": str(_value),
7871                                 },
7872                             )
7873                         elif "NetUserModal" in _pol:
7874                             log.trace("%s is a NetUserModal policy", policy_name)
7875                             if _pol["NetUserModal"]["Modal"] not in _modal_sets:
7876                                 _modal_sets[_pol["NetUserModal"]["Modal"]] = {}
7877                             _modal_sets[_pol["NetUserModal"]["Modal"]][
7878                                 _pol["NetUserModal"]["Option"]
7879                             ] = _value
7880                         elif "LsaRights" in _pol:
7881                             log.trace("%s is a LsaRights policy", policy_name)
7882                             _lsarights[policy_name] = {"policy": _pol, "value": _value}
7883                     else:
7884                         _value = policies[p_class][policy_name]
7885                         log.trace('searching for "%s" in admx data', policy_name)
7886                         (
7887                             success,
7888                             the_policy,
7889                             policy_name_list,
7890                             msg,
7891                         ) = _lookup_admin_template(
7892                             policy_name=policy_name,
7893                             policy_class=p_class,
7894                             adml_language=adml_language,
7895                         )
7896                         if success:
7897                             policy_name = the_policy.attrib["name"]
7898                             policy_namespace = the_policy.nsmap[the_policy.prefix]
7899                             if policy_namespace not in _admTemplateData:
7900                                 _admTemplateData[policy_namespace] = {}
7901                             _admTemplateData[policy_namespace][policy_name] = _value
7902                         else:
7903                             raise SaltInvocationError(msg)
7904                         if (
7905                             policy_namespace
7906                             and policy_name in _admTemplateData[policy_namespace]
7907                             and the_policy is not None
7908                         ):
7909                             log.trace(
7910                                 "setting == %s",
7911                                 str(
7912                                     _admTemplateData[policy_namespace][policy_name]
7913                                 ).lower(),
7914                             )
7915                             log.trace(
7916                                 str(
7917                                     _admTemplateData[policy_namespace][policy_name]
7918                                 ).lower()
7919                             )
7920                             if (
7921                                 str(
7922                                     _admTemplateData[policy_namespace][policy_name]
7923                                 ).lower()
7924                                 != "disabled"
7925                                 and str(
7926                                     _admTemplateData[policy_namespace][policy_name]
7927                                 ).lower()
7928                                 != "not configured"
7929                             ):
7930                                 if ELEMENTS_XPATH(the_policy):
7931                                     if isinstance(
7932                                         _admTemplateData[policy_namespace][policy_name],
7933                                         dict,
7934                                     ):
7935                                         for elements_item in ELEMENTS_XPATH(the_policy):
7936                                             for child_item in elements_item:
7937                                                 log.trace(
7938                                                     "checking element %s",
7939                                                     child_item.attrib["id"],
7940                                                 )
7941                                                 temp_element_name = None
7942                                                 this_element_name = _getFullPolicyName(
7943                                                     policy_item=child_item,
7944                                                     policy_name=child_item.attrib["id"],
7945                                                     return_full_policy_names=True,
7946                                                     adml_language=adml_language,
7947                                                 )
7948                                                 log.trace(
7949                                                     'id attribute == "%s" '
7950                                                     ' this_element_name == "%s"',
7951                                                     child_item.attrib["id"],
7952                                                     this_element_name,
7953                                                 )
7954                                                 if (
7955                                                     this_element_name
7956                                                     in _admTemplateData[
7957                                                         policy_namespace
7958                                                     ][policy_name]
7959                                                 ):
7960                                                     temp_element_name = (
7961                                                         this_element_name
7962                                                     )
7963                                                 elif (
7964                                                     child_item.attrib["id"]
7965                                                     in _admTemplateData[
7966                                                         policy_namespace
7967                                                     ][policy_name]
7968                                                 ):
7969                                                     temp_element_name = (
7970                                                         child_item.attrib["id"]
7971                                                     )
7972                                                 else:
7973                                                     raise SaltInvocationError(
7974                                                         'Element "{}" must be included'
7975                                                         " in the policy configuration"
7976                                                         " for policy {}".format(
7977                                                             this_element_name,
7978                                                             policy_name,
7979                                                         )
7980                                                     )
7981                                                 if (
7982                                                     "required" in child_item.attrib
7983                                                     and child_item.attrib[
7984                                                         "required"
7985                                                     ].lower()
7986                                                     == "true"
7987                                                 ):
7988                                                     if not _admTemplateData[
7989                                                         policy_namespace
7990                                                     ][policy_name][temp_element_name]:
7991                                                         raise SaltInvocationError(
7992                                                             'Element "{}" requires a value '
7993                                                             "to be specified".format(
7994                                                                 temp_element_name
7995                                                             )
7996                                                         )
7997                                                 if (
7998                                                     etree.QName(child_item).localname
7999                                                     == "boolean"
8000                                                 ):
8001                                                     if not isinstance(
8002                                                         _admTemplateData[
8003                                                             policy_namespace
8004                                                         ][policy_name][
8005                                                             temp_element_name
8006                                                         ],
8007                                                         bool,
8008                                                     ):
8009                                                         raise SaltInvocationError(
8010                                                             "Element {} requires a boolean "
8011                                                             "True or False".format(
8012                                                                 temp_element_name
8013                                                             )
8014                                                         )
8015                                                 elif (
8016                                                     etree.QName(child_item).localname
8017                                                     == "decimal"
8018                                                     or etree.QName(child_item).localname
8019                                                     == "longDecimal"
8020                                                 ):
8021                                                     min_val = 0
8022                                                     max_val = 9999
8023                                                     if "minValue" in child_item.attrib:
8024                                                         min_val = int(
8025                                                             child_item.attrib[
8026                                                                 "minValue"
8027                                                             ]
8028                                                         )
8029                                                     if "maxValue" in child_item.attrib:
8030                                                         max_val = int(
8031                                                             child_item.attrib[
8032                                                                 "maxValue"
8033                                                             ]
8034                                                         )
8035                                                     if (
8036                                                         int(
8037                                                             _admTemplateData[
8038                                                                 policy_namespace
8039                                                             ][policy_name][
8040                                                                 temp_element_name
8041                                                             ]
8042                                                         )
8043                                                         &lt; min_val
8044                                                         or int(
8045                                                             _admTemplateData[
8046                                                                 policy_namespace
8047                                                             ][policy_name][
8048                                                                 temp_element_name
8049                                                             ]
8050                                                         )
8051                                                         &gt; max_val
8052                                                     ):
8053                                                         raise SaltInvocationError(
8054                                                             'Element "{}" value must be between '
8055                                                             "{} and {}".format(
8056                                                                 temp_element_name,
8057                                                                 min_val,
8058                                                                 max_val,
8059                                                             )
8060                                                         )
8061                                                 elif (
8062                                                     etree.QName(child_item).localname
8063                                                     == "enum"
8064                                                 ):
8065                                                     found = False
8066                                                     for enum_item in child_item:
8067                                                         if (
8068                                                             _admTemplateData[
8069                                                                 policy_namespace
8070                                                             ][policy_name][
8071                                                                 temp_element_name
8072                                                             ]
8073                                                             == _getAdmlDisplayName(
8074                                                                 adml_policy_resources,
8075                                                                 enum_item.attrib[
8076                                                                     "displayName"
8077                                                                 ],
8078                                                             ).strip()
8079                                                         ):
8080                                                             found = True
8081                                                             break
8082                                                     if not found:
8083                                                         raise SaltInvocationError(
8084                                                             'Element "{}" does not have'
8085                                                             " a valid value".format(
8086                                                                 temp_element_name
8087                                                             )
8088                                                         )
8089                                                 elif (
8090                                                     etree.QName(child_item).localname
8091                                                     == "list"
8092                                                 ):
8093                                                     if (
8094                                                         "explicitValue"
8095                                                         in child_item.attrib
8096                                                         and child_item.attrib[
8097                                                             "explicitValue"
8098                                                         ].lower()
8099                                                         == "true"
8100                                                     ):
8101                                                         if not isinstance(
8102                                                             _admTemplateData[
8103                                                                 policy_namespace
8104                                                             ][policy_name][
8105                                                                 temp_element_name
8106                                                             ],
8107                                                             dict,
8108                                                         ):
8109                                                             raise SaltInvocationError(
8110                                                                 "Each list item of element "
8111                                                                 '"{}" requires a dict '
8112                                                                 "value".format(
8113                                                                     temp_element_name
8114                                                                 )
8115                                                             )
8116                                                     elif not isinstance(
8117                                                         _admTemplateData[
8118                                                             policy_namespace
8119                                                         ][policy_name][
8120                                                             temp_element_name
8121                                                         ],
8122                                                         list,
8123                                                     ):
8124                                                         raise SaltInvocationError(
8125                                                             'Element "{}" requires a'
8126                                                             " list value".format(
8127                                                                 temp_element_name
8128                                                             )
8129                                                         )
8130                                                 elif (
8131                                                     etree.QName(child_item).localname
8132                                                     == "multiText"
8133                                                 ):
8134                                                     if not isinstance(
8135                                                         _admTemplateData[
8136                                                             policy_namespace
8137                                                         ][policy_name][
8138                                                             temp_element_name
8139                                                         ],
8140                                                         list,
8141                                                     ):
8142                                                         raise SaltInvocationError(
8143                                                             'Element "{}" requires a'
8144                                                             " list value".format(
8145                                                                 temp_element_name
8146                                                             )
8147                                                         )
8148                                                 _admTemplateData[policy_namespace][
8149                                                     policy_name
8150                                                 ][
8151                                                     child_item.attrib["id"]
8152                                                 ] = _admTemplateData[
8153                                                     policy_namespace
8154                                                 ][
8155                                                     policy_name
8156                                                 ].pop(
8157                                                     temp_element_name
8158                                                 )
8159                                     else:
8160                                         raise SaltInvocationError(
8161                                             'The policy "{}" has elements which must be'
8162                                             " configured".format(policy_name)
8163                                         )
8164                                 else:
8165                                     if (
8166                                         str(
8167                                             _admTemplateData[policy_namespace][
8168                                                 policy_name
8169                                             ]
8170                                         ).lower()
8171                                         != "enabled"
8172                                     ):
8173                                         raise SaltInvocationError(
8174                                             'The policy {} must either be "Enabled", '
8175                                             '"Disabled", or "Not Configured"'.format(
8176                                                 policy_name
8177                                             )
8178                                         )
8179                 if _regedits:
8180                     for regedit in _regedits:
8181                         log.trace("%s is a Registry policy", regedit)
8182                         if (
8183                             _regedits[regedit]["value"] is not None
8184                             and _regedits[regedit]["value"] != "(value not set)"
8185                         ):
8186                             _ret = __utils__["reg.set_value"](
8187                                 _regedits[regedit]["policy"]["Registry"]["Hive"],
8188                                 _regedits[regedit]["policy"]["Registry"]["Path"],
8189                                 _regedits[regedit]["policy"]["Registry"]["Value"],
8190                                 _regedits[regedit]["value"],
8191                                 _regedits[regedit]["policy"]["Registry"]["Type"],
8192                             )
8193                         else:
8194                             _ret = __utils__["reg.read_value"](
8195                                 _regedits[regedit]["policy"]["Registry"]["Hive"],
8196                                 _regedits[regedit]["policy"]["Registry"]["Path"],
8197                                 _regedits[regedit]["policy"]["Registry"]["Value"],
8198                             )
8199                             if _ret["success"] and _ret["vdata"] != "(value not set)":
8200                                 _ret = __utils__["reg.delete_value"](
8201                                     _regedits[regedit]["policy"]["Registry"]["Hive"],
8202                                     _regedits[regedit]["policy"]["Registry"]["Path"],
8203                                     _regedits[regedit]["policy"]["Registry"]["Value"],
8204                                 )
8205                         if not _ret:
8206                             raise CommandExecutionError(
8207                                 "Error while attempting to set policy {} via the"
8208                                 " registry.  Some changes may not be applied as"
8209                                 " expected".format(regedit)
8210                             )
8211                 if _lsarights:
8212                     for lsaright in _lsarights:
8213                         _existingUsers = None
8214                         if not cumulative_rights_assignments:
8215                             _existingUsers = _getRightsAssignments(
8216                                 _lsarights[lsaright]["policy"]["LsaRights"]["Option"]
8217                             )
8218                         if _lsarights[lsaright]["value"]:
8219                             for acct in _lsarights[lsaright]["value"]:
8220                                 _ret = _addAccountRights(
8221                                     acct,
8222                                     _lsarights[lsaright]["policy"]["LsaRights"][
8223                                         "Option"
8224                                     ],
8225                                 )
8226                                 if not _ret:
8227                                     raise SaltInvocationError(
8228                                         "An error occurred attempting to configure the"
8229                                         " user right {}.".format(lsaright)
8230                                     )
8231                         if _existingUsers:
8232                             for acct in _existingUsers:
8233                                 if acct not in _lsarights[lsaright]["value"]:
8234                                     _ret = _delAccountRights(
8235                                         acct,
8236                                         _lsarights[lsaright]["policy"]["LsaRights"][
8237                                             "Option"
8238                                         ],
8239                                     )
8240                                     if not _ret:
8241                                         raise SaltInvocationError(
8242                                             "An error occurred attempting to remove previously "
8243                                             "configured users with right {}.".format(
8244                                                 lsaright
8245                                             )
8246                                         )
8247                 if _secedits:
8248                     log.trace(_secedits)
8249                     ini_data = "\r\n".join(["[Unicode]", "Unicode=yes"])
8250                     _seceditSections = [
8251                         "System Access",
8252                         "Event Audit",
8253                         "Registry Values",
8254                         "Privilege Rights",
8255                     ]
8256                     for _seceditSection in _seceditSections:
8257                         if _seceditSection in _secedits:
8258                             ini_data = "\r\n".join(
8259                                 [
8260                                     ini_data,
8261                                     "".join(["[", _seceditSection, "]"]),
8262                                     "\r\n".join(_secedits[_seceditSection]),
8263                                 ]
8264                             )
8265                     ini_data = "\r\n".join(
8266                         [ini_data, "[Version]", 'signature="$CHICAGO$"', "Revision=1"]
8267                     )
8268                     log.trace("ini_data == %s", ini_data)
8269                     if not _write_secedit_data(ini_data):
8270                         raise CommandExecutionError(
8271                             "Error while attempting to set policies via "
8272                             "secedit. Some changes may not be applied as "
8273                             "expected"
8274                         )
8275                 if _netshs:
8276                     for setting in _netshs:
8277                         log.trace("Setting firewall policy: %s", setting)
8278                         log.trace(_netshs[setting])
8279                         _set_netsh_value(**_netshs[setting])
8280                 if _advaudits:
8281                     for setting in _advaudits:
8282                         log.trace("Setting Advanced Audit policy: %s", setting)
8283                         log.trace(_advaudits[setting])
8284                         _set_advaudit_value(**_advaudits[setting])
8285                 if _modal_sets:
8286                     log.trace(_modal_sets)
8287                     for _modal_set in _modal_sets:
8288                         try:
8289                             _existingModalData = win32net.NetUserModalsGet(
8290                                 None, _modal_set
8291                             )
8292                             _newModalSetData = dictupdate.update(
8293                                 _existingModalData, _modal_sets[_modal_set]
8294                             )
8295                             log.trace("NEW MODAL SET = %s", _newModalSetData)
8296                             _ret = win32net.NetUserModalsSet(
8297                                 None, _modal_set, _newModalSetData
8298                             )
8299                         except Exception as exc:  # pylint: disable=broad-except
8300                             msg = (
8301                                 "An unhandled exception occurred while "
8302                                 "attempting to set policy via "
8303                                 "NetUserModalSet\n{}".format(exc)
8304                             )
8305                             log.exception(msg)
8306                             raise CommandExecutionError(msg)
8307                 if _admTemplateData:
8308                     _ret = False
8309                     log.trace(
8310                         "going to write some adm template data :: %s", _admTemplateData
8311                     )
8312                     _ret = _writeAdminTemplateRegPolFile(
8313                         _admTemplateData,
8314                         adml_language=adml_language,
8315                         registry_class=p_class,
8316                     )
8317                     if not _ret:
8318                         raise CommandExecutionError(
8319                             "Error while attempting to write Administrative Template"
8320                             " Policy data.  Some changes may not be applied as expected"
8321                         )
8322         return True
8323     else:
8324         raise SaltInvocationError("You have to specify something!")
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
