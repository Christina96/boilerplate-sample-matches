<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_ipc_1.py & test_saltmod_1.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_ipc_1.py & test_saltmod_1.py
      </h3>
      <h1 align="center">
        3.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_ipc_1.py (4.9792533%)<TH>test_saltmod_1.py (2.6258206%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match99286-0.html#0',2,'match99286-1.html#0',3)" NAME="0">(6-18)<TD><A HREF="javascript:ZweiFrames('match99286-0.html#0',2,'match99286-1.html#0',3)" NAME="0">(5-17)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_ipc_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
    :codeauthor: Mike Place &lt;mp@saltstack.com&gt;
<A NAME="0"></A>&quot;&quot;&quot;


<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match99286-1.html#0',3,'match99286-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import errno
import logging
import os
import threading

import pytest
import salt.config
import salt.exceptions
import salt.ext.tornado.gen
import salt.ext.tornado.ioloop
import salt.ext.tornado.testing
import salt.transport.ipc
import</B></FONT> salt.utils.platform
from salt.ext.tornado.iostream import StreamClosedError
from tests.support.runtests import RUNTIME_VARS
from tests.support.unit import skipIf

pytestmark = [
    pytest.mark.skip_on_darwin,
    pytest.mark.skip_on_freebsd,
    pytest.mark.skip_on_windows,
]

log = logging.getLogger(__name__)


@skipIf(salt.utils.platform.is_windows(), &quot;Windows does not support Posix IPC&quot;)
class IPCMessagePubSubCase(salt.ext.tornado.testing.AsyncTestCase):
    &quot;&quot;&quot;
    Test all of the clear msg stuff
    &quot;&quot;&quot;

    def setUp(self):
        super().setUp()
        self.opts = {&quot;ipc_write_buffer&quot;: 0}
        self.socket_path = os.path.join(RUNTIME_VARS.TMP, &quot;ipc_test.ipc&quot;)
        self.pub_channel = self._get_pub_channel()
        self.sub_channel = self._get_sub_channel()

    def _get_pub_channel(self):
        pub_channel = salt.transport.ipc.IPCMessagePublisher(
            self.opts,
            self.socket_path,
        )
        pub_channel.start()
        return pub_channel

    def _get_sub_channel(self):
        sub_channel = salt.transport.ipc.IPCMessageSubscriber(
            socket_path=self.socket_path,
            io_loop=self.io_loop,
        )
        sub_channel.connect(callback=self.stop)
        self.wait()
        return sub_channel

    def tearDown(self):
        super().tearDown()
        try:
            self.pub_channel.close()
        except OSError as exc:
            if exc.errno != errno.EBADF:
                # If its not a bad file descriptor error, raise
                raise
        try:
            self.sub_channel.close()
        except OSError as exc:
            if exc.errno != errno.EBADF:
                # If its not a bad file descriptor error, raise
                raise
        os.unlink(self.socket_path)
        del self.pub_channel
        del self.sub_channel

    def test_multi_client_reading(self):
        # To be completely fair let's create 2 clients.
        client1 = self.sub_channel
        client2 = self._get_sub_channel()
        call_cnt = []

        # Create a watchdog to be safe from hanging in sync loops (what old code did)
        evt = threading.Event()

        def close_server():
            if evt.wait(1):
                return
            client2.close()
            self.stop()

        watchdog = threading.Thread(target=close_server)
        watchdog.start()

        # Runs in ioloop thread so we're safe from race conditions here
        def handler(raw):
            call_cnt.append(raw)
            if len(call_cnt) &gt;= 2:
                evt.set()
                self.stop()

        # Now let both waiting data at once
        client1.read_async(handler)
        client2.read_async(handler)
        self.pub_channel.publish(&quot;TEST&quot;)
        self.wait()
        self.assertEqual(len(call_cnt), 2)
        self.assertEqual(call_cnt[0], &quot;TEST&quot;)
        self.assertEqual(call_cnt[1], &quot;TEST&quot;)

    def test_sync_reading(self):
        # To be completely fair let's create 2 clients.
        client1 = self.sub_channel
        client2 = self._get_sub_channel()
        call_cnt = []

        # Now let both waiting data at once
        self.pub_channel.publish(&quot;TEST&quot;)
        ret1 = client1.read_sync()
        ret2 = client2.read_sync()
        self.assertEqual(ret1, &quot;TEST&quot;)
        self.assertEqual(ret2, &quot;TEST&quot;)

    @salt.ext.tornado.testing.gen_test
    def test_async_reading_streamclosederror(self):
        client1 = self.sub_channel
        call_cnt = []

        # Create a watchdog to be safe from hanging in sync loops (what old code did)
        evt = threading.Event()

        def close_server():
            if evt.wait(0.001):
                return
            client1.close()
            self.stop()

        watchdog = threading.Thread(target=close_server)
        watchdog.start()

        # Runs in ioloop thread so we're safe from race conditions here
        def handler(raw):
            pass

        try:
            ret1 = yield client1.read_async(handler)
            self.wait()
        except StreamClosedError as ex:
            assert False, &quot;StreamClosedError was raised inside the Future&quot;
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_saltmod_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
<A NAME="0"></A>    :codeauthor: Jayesh Kariya &lt;jayeshk@saltstack.com&gt;
&quot;&quot;&quot;

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match99286-0.html#0',2,'match99286-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import os
import tempfile

import pytest
import salt.config
import salt.loader
import salt.states.saltmod as saltmod
import salt.utils.event
import salt.utils.jid
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import MagicMock, patch
from tests.support.runtests import RUNTIME_VARS
from</B></FONT> tests.support.unit import TestCase


class SaltmodTestCase(TestCase, LoaderModuleMockMixin):
    &quot;&quot;&quot;
    Test cases for salt.states.saltmod
    &quot;&quot;&quot;

    def setup_loader_modules(self):
        utils = salt.loader.utils(
            salt.config.DEFAULT_MINION_OPTS.copy(), whitelist=[&quot;state&quot;]
        )
        return {
            saltmod: {
                &quot;__env__&quot;: &quot;base&quot;,
                &quot;__opts__&quot;: {
                    &quot;__role&quot;: &quot;master&quot;,
                    &quot;file_client&quot;: &quot;remote&quot;,
                    &quot;sock_dir&quot;: tempfile.mkdtemp(dir=RUNTIME_VARS.TMP),
                    &quot;transport&quot;: &quot;tcp&quot;,
                },
                &quot;__salt__&quot;: {&quot;saltutil.cmd&quot;: MagicMock()},
                &quot;__orchestration_jid__&quot;: salt.utils.jid.gen_jid({}),
                &quot;__utils__&quot;: utils,
            }
        }

    # 'state' function tests: 1

    @pytest.mark.slow_test
    def test_state(self):
        &quot;&quot;&quot;
        Test to invoke a state run on a given target
        &quot;&quot;&quot;
        name = &quot;state&quot;
        tgt = &quot;minion1&quot;

        comt = &quot;Passed invalid value for 'allow_fail', must be an int&quot;

        ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: comt}

        test_ret = {
            &quot;name&quot;: name,
            &quot;changes&quot;: {},
            &quot;result&quot;: True,
            &quot;comment&quot;: &quot;States ran successfully.&quot;,
        }

        test_batch_return = {
            &quot;minion1&quot;: {
                &quot;ret&quot;: {
                    &quot;test_|-notify_me_|-this is a name_|-show_notification&quot;: {
                        &quot;comment&quot;: &quot;Notify me&quot;,
                        &quot;name&quot;: &quot;this is a name&quot;,
                        &quot;start_time&quot;: &quot;10:43:41.487565&quot;,
                        &quot;result&quot;: True,
                        &quot;duration&quot;: 0.35,
                        &quot;__run_num__&quot;: 0,
                        &quot;__sls__&quot;: &quot;demo&quot;,
                        &quot;changes&quot;: {},
                        &quot;__id__&quot;: &quot;notify_me&quot;,
                    },
                    &quot;retcode&quot;: 0,
                },
                &quot;out&quot;: &quot;highstate&quot;,
            },
            &quot;minion2&quot;: {
                &quot;ret&quot;: {
                    &quot;test_|-notify_me_|-this is a name_|-show_notification&quot;: {
                        &quot;comment&quot;: &quot;Notify me&quot;,
                        &quot;name&quot;: &quot;this is a name&quot;,
                        &quot;start_time&quot;: &quot;10:43:41.487565&quot;,
                        &quot;result&quot;: True,
                        &quot;duration&quot;: 0.35,
                        &quot;__run_num__&quot;: 0,
                        &quot;__sls__&quot;: &quot;demo&quot;,
                        &quot;changes&quot;: {},
                        &quot;__id__&quot;: &quot;notify_me&quot;,
                    },
                    &quot;retcode&quot;: 0,
                },
                &quot;out&quot;: &quot;highstate&quot;,
            },
            &quot;minion3&quot;: {
                &quot;ret&quot;: {
                    &quot;test_|-notify_me_|-this is a name_|-show_notification&quot;: {
                        &quot;comment&quot;: &quot;Notify me&quot;,
                        &quot;name&quot;: &quot;this is a name&quot;,
                        &quot;start_time&quot;: &quot;10:43:41.487565&quot;,
                        &quot;result&quot;: True,
                        &quot;duration&quot;: 0.35,
                        &quot;__run_num__&quot;: 0,
                        &quot;__sls__&quot;: &quot;demo&quot;,
                        &quot;changes&quot;: {},
                        &quot;__id__&quot;: &quot;notify_me&quot;,
                    },
                    &quot;retcode&quot;: 0,
                },
                &quot;out&quot;: &quot;highstate&quot;,
            },
        }

        self.assertDictEqual(saltmod.state(name, tgt, allow_fail=&quot;a&quot;), ret)

        comt = &quot;No highstate or sls specified, no execution made&quot;
        ret.update({&quot;comment&quot;: comt})
        self.assertDictEqual(saltmod.state(name, tgt), ret)

        comt = &quot;Must pass in boolean for value of 'concurrent'&quot;
        ret.update({&quot;comment&quot;: comt})
        self.assertDictEqual(
            saltmod.state(name, tgt, highstate=True, concurrent=&quot;a&quot;), ret
        )

        ret.update({&quot;comment&quot;: comt, &quot;result&quot;: None})
        with patch.dict(saltmod.__opts__, {&quot;test&quot;: True}):
            self.assertDictEqual(saltmod.state(name, tgt, highstate=True), test_ret)

        ret.update(
            {
                &quot;comment&quot;: &quot;States ran successfully. No changes made to silver.&quot;,
                &quot;result&quot;: True,
                &quot;__jid__&quot;: &quot;20170406104341210934&quot;,
            }
        )
        with patch.dict(saltmod.__opts__, {&quot;test&quot;: False}):
            mock = MagicMock(
                return_value={
                    &quot;silver&quot;: {
                        &quot;jid&quot;: &quot;20170406104341210934&quot;,
                        &quot;retcode&quot;: 0,
                        &quot;ret&quot;: {
                            &quot;test_|-notify_me_|-this is a name_|-show_notification&quot;: {
                                &quot;comment&quot;: &quot;Notify me&quot;,
                                &quot;name&quot;: &quot;this is a name&quot;,
                                &quot;start_time&quot;: &quot;10:43:41.487565&quot;,
                                &quot;result&quot;: True,
                                &quot;duration&quot;: 0.35,
                                &quot;__run_num__&quot;: 0,
                                &quot;__sls__&quot;: &quot;demo&quot;,
                                &quot;changes&quot;: {},
                                &quot;__id__&quot;: &quot;notify_me&quot;,
                            }
                        },
                        &quot;out&quot;: &quot;highstate&quot;,
                    }
                }
            )
            with patch.dict(saltmod.__salt__, {&quot;saltutil.cmd&quot;: mock}):
                self.assertDictEqual(saltmod.state(name, tgt, highstate=True), ret)

        ret.update(
            {
                &quot;comment&quot;: (
                    &quot;States ran successfully. No changes made to minion1, minion3,&quot;
                    &quot; minion2.&quot;
                )
            }
        )
        del ret[&quot;__jid__&quot;]
        with patch.dict(saltmod.__opts__, {&quot;test&quot;: False}):
            with patch.dict(
                saltmod.__salt__,
                {&quot;saltutil.cmd&quot;: MagicMock(return_value=test_batch_return)},
            ):
                state_run = saltmod.state(name, tgt, highstate=True)

                # Test return without checking the comment contents. Comments are tested later.
                comment = state_run.pop(&quot;comment&quot;)
                ret.pop(&quot;comment&quot;)
                self.assertDictEqual(state_run, ret)

                # Check the comment contents in a non-order specific way (ordering fails sometimes on PY3)
                self.assertIn(&quot;States ran successfully. No changes made to&quot;, comment)
                for minion in [&quot;minion1&quot;, &quot;minion2&quot;, &quot;minion3&quot;]:
                    self.assertIn(minion, comment)

    # 'function' function tests: 1

    @pytest.mark.slow_test
    def test_function(self):
        &quot;&quot;&quot;
        Test to execute a single module function on a remote
        minion via salt or salt-ssh
        &quot;&quot;&quot;
        name = &quot;state&quot;
        tgt = &quot;larry&quot;

        ret = {
            &quot;name&quot;: name,
            &quot;changes&quot;: {},
            &quot;result&quot;: None,
            &quot;comment&quot;: &quot;Function state would be executed on target {}&quot;.format(tgt),
        }

        with patch.dict(saltmod.__opts__, {&quot;test&quot;: True}):
            self.assertDictEqual(saltmod.function(name, tgt), ret)

        ret.update(
            {
                &quot;result&quot;: True,
                &quot;changes&quot;: {&quot;ret&quot;: {tgt: &quot;&quot;}},
                &quot;comment&quot;: (
                    &quot;Function ran successfully. Function state ran on {}.&quot;.format(tgt)
                ),
            }
        )
        with patch.dict(saltmod.__opts__, {&quot;test&quot;: False}):
            mock_ret = {&quot;larry&quot;: {&quot;ret&quot;: &quot;&quot;, &quot;retcode&quot;: 0, &quot;failed&quot;: False}}
            mock_cmd = MagicMock(return_value=mock_ret)
            with patch.dict(saltmod.__salt__, {&quot;saltutil.cmd&quot;: mock_cmd}):
                self.assertDictEqual(saltmod.function(name, tgt), ret)

    @pytest.mark.slow_test
    def test_function_when_no_minions_match(self):
        &quot;&quot;&quot;
        Test to execute a single module function on a remote
        minion via salt or salt-ssh
        &quot;&quot;&quot;
        name = &quot;state&quot;
        tgt = &quot;larry&quot;
        mock_ret = {}
        mock_cmd = MagicMock(return_value=mock_ret)

        ret = {
            &quot;name&quot;: name,
            &quot;changes&quot;: {},
            &quot;result&quot;: False,
            &quot;comment&quot;: &quot;No minions responded&quot;,
        }

        with patch.dict(saltmod.__opts__, {&quot;test&quot;: False}):
            with patch.dict(saltmod.__salt__, {&quot;saltutil.cmd&quot;: mock_cmd}):
                self.assertDictEqual(saltmod.function(name, tgt), ret)

    # 'wait_for_event' function tests: 1

    def test_wait_for_event(self):
        &quot;&quot;&quot;
        Test to watch Salt's event bus and block until a condition is met
        &quot;&quot;&quot;
        name = &quot;state&quot;
        tgt = &quot;minion1&quot;

        comt = &quot;Timeout value reached.&quot;

        ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: comt}

        class Mockevent:
            &quot;&quot;&quot;
            Mock event class
            &quot;&quot;&quot;

            flag = None

            def __init__(self):
                self.full = None

            def get_event(self, full):
                &quot;&quot;&quot;
                Mock get_event method
                &quot;&quot;&quot;
                self.full = full
                if self.flag:
                    return {&quot;tag&quot;: name, &quot;data&quot;: {}}
                return None

            def __enter__(self):
                return self

            def __exit__(self, *args):
                pass

        with patch.object(
            salt.utils.event, &quot;get_event&quot;, MagicMock(return_value=Mockevent())
        ):
            with patch.dict(saltmod.__opts__, {&quot;sock_dir&quot;: True, &quot;transport&quot;: True}):
                with patch(
                    &quot;salt.states.saltmod.time.time&quot;, MagicMock(return_value=1.0)
                ):
                    self.assertDictEqual(
                        saltmod.wait_for_event(name, &quot;salt&quot;, timeout=-1.0), ret
                    )

                    Mockevent.flag = True
                    ret.update(
                        {&quot;comment&quot;: &quot;All events seen in 0.0 seconds.&quot;, &quot;result&quot;: True}
                    )
                    self.assertDictEqual(saltmod.wait_for_event(name, &quot;&quot;), ret)

                    ret.update({&quot;comment&quot;: &quot;Timeout value reached.&quot;, &quot;result&quot;: False})
                    self.assertDictEqual(
                        saltmod.wait_for_event(name, tgt, timeout=-1.0), ret
                    )

    # 'runner' function tests: 1

    def test_runner(self):
        &quot;&quot;&quot;
        Test to execute a runner module on the master
        &quot;&quot;&quot;
        name = &quot;state&quot;

        ret = {
            &quot;changes&quot;: {&quot;return&quot;: True},
            &quot;name&quot;: &quot;state&quot;,
            &quot;result&quot;: True,
            &quot;comment&quot;: &quot;Runner function 'state' executed.&quot;,
            &quot;__orchestration__&quot;: True,
        }
        runner_mock = MagicMock(return_value={&quot;return&quot;: True})

        with patch.dict(saltmod.__salt__, {&quot;saltutil.runner&quot;: runner_mock}):
            self.assertDictEqual(saltmod.runner(name), ret)

    # 'wheel' function tests: 1

    def test_wheel(self):
        &quot;&quot;&quot;
        Test to execute a wheel module on the master
        &quot;&quot;&quot;
        name = &quot;state&quot;

        ret = {
            &quot;changes&quot;: {&quot;return&quot;: True},
            &quot;name&quot;: &quot;state&quot;,
            &quot;result&quot;: True,
            &quot;comment&quot;: &quot;Wheel function 'state' executed.&quot;,
            &quot;__orchestration__&quot;: True,
        }
        wheel_mock = MagicMock(return_value={&quot;return&quot;: True})

        with patch.dict(saltmod.__salt__, {&quot;saltutil.wheel&quot;: wheel_mock}):
            self.assertDictEqual(saltmod.wheel(name), ret)

    @pytest.mark.slow_test
    def test_state_ssh(self):
        &quot;&quot;&quot;
        Test saltmod state passes roster to saltutil.cmd
        &quot;&quot;&quot;
        origcmd = saltmod.__salt__[&quot;saltutil.cmd&quot;]
        cmd_kwargs = {}
        cmd_args = []

        def cmd_mock(*args, **kwargs):
            cmd_args.extend(args)
            cmd_kwargs.update(kwargs)
            return origcmd(*args, **kwargs)

        with patch.dict(saltmod.__salt__, {&quot;saltutil.cmd&quot;: cmd_mock}):
            ret = saltmod.state(
                &quot;state.sls&quot;, tgt=&quot;*&quot;, ssh=True, highstate=True, roster=&quot;my_roster&quot;
            )
        assert &quot;roster&quot; in cmd_kwargs
        assert cmd_kwargs[&quot;roster&quot;] == &quot;my_roster&quot;

    @pytest.mark.slow_test
    def test_function_ssh(self):
        &quot;&quot;&quot;
        Test saltmod function passes roster to saltutil.cmd
        &quot;&quot;&quot;
        origcmd = saltmod.__salt__[&quot;saltutil.cmd&quot;]
        cmd_kwargs = {}
        cmd_args = []

        def cmd_mock(*args, **kwargs):
            cmd_args.extend(args)
            cmd_kwargs.update(kwargs)
            return origcmd(*args, **kwargs)

        with patch.dict(saltmod.__opts__, {&quot;test&quot;: False}), patch.dict(
            saltmod.__salt__, {&quot;saltutil.cmd&quot;: cmd_mock}
        ):
            saltmod.function(&quot;state&quot;, tgt=&quot;*&quot;, ssh=True, roster=&quot;my_roster&quot;)
        assert &quot;roster&quot; in cmd_kwargs
        assert cmd_kwargs[&quot;roster&quot;] == &quot;my_roster&quot;


class StatemodTests(TestCase, LoaderModuleMockMixin):
    def setup_loader_modules(self):
        self.tmp_cachedir = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
        return {
            saltmod: {
                &quot;__env__&quot;: &quot;base&quot;,
                &quot;__opts__&quot;: {
                    &quot;id&quot;: &quot;webserver2&quot;,
                    &quot;argv&quot;: [],
                    &quot;__role&quot;: &quot;master&quot;,
                    &quot;cachedir&quot;: self.tmp_cachedir,
                    &quot;extension_modules&quot;: os.path.join(self.tmp_cachedir, &quot;extmods&quot;),
                },
                &quot;__salt__&quot;: {&quot;saltutil.cmd&quot;: MagicMock()},
                &quot;__orchestration_jid__&quot;: salt.utils.jid.gen_jid({}),
            }
        }

    def test_statemod_state(self):
        &quot;&quot;&quot;Smoke test for for salt.states.statemod.state().  Ensures that we
        don't take an exception if optional parameters are not specified in
        __opts__ or __env__.
        &quot;&quot;&quot;
        args = (&quot;webserver_setup&quot;, &quot;webserver2&quot;)
        kwargs = {
            &quot;tgt_type&quot;: &quot;glob&quot;,
            &quot;fail_minions&quot;: None,
            &quot;pillar&quot;: None,
            &quot;top&quot;: None,
            &quot;batch&quot;: None,
            &quot;orchestration_jid&quot;: None,
            &quot;sls&quot;: &quot;vroom&quot;,
            &quot;queue&quot;: False,
            &quot;concurrent&quot;: False,
            &quot;highstate&quot;: None,
            &quot;expr_form&quot;: None,
            &quot;ret&quot;: &quot;&quot;,
            &quot;ssh&quot;: False,
            &quot;timeout&quot;: None,
            &quot;test&quot;: False,
            &quot;allow_fail&quot;: 0,
            &quot;saltenv&quot;: None,
            &quot;expect_minions&quot;: False,
        }
        ret = saltmod.state(*args, **kwargs)
        expected = {
            &quot;comment&quot;: &quot;States ran successfully.&quot;,
            &quot;changes&quot;: {},
            &quot;name&quot;: &quot;webserver_setup&quot;,
            &quot;result&quot;: True,
        }
        self.assertEqual(ret, expected)
</PRE>
</div>
  </div>
</body>
</html>
