<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_ipc_1.py &amp; test_saltmod_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_ipc_1.py &amp; test_saltmod_1.py
      </h3>
<h1 align="center">
        3.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_ipc_1.py (4.9792533%)<th>test_saltmod_1.py (2.6258206%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(6-18)<td><a href="#" name="0">(5-17)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_ipc_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import errno
2 import logging
3 import os
4 import threading
5 import pytest
6 import salt.config
7 import salt.exceptions
8 import salt.ext.tornado.gen
9 import salt.ext.tornado.ioloop
10 import salt.ext.tornado.testing
11 import salt.transport.ipc
12 import</b></font> salt.utils.platform
13 from salt.ext.tornado.iostream import StreamClosedError
14 from tests.support.runtests import RUNTIME_VARS
15 from tests.support.unit import skipIf
16 pytestmark = [
17     pytest.mark.skip_on_darwin,
18     pytest.mark.skip_on_freebsd,
19     pytest.mark.skip_on_windows,
20 ]
21 log = logging.getLogger(__name__)
22 @skipIf(salt.utils.platform.is_windows(), "Windows does not support Posix IPC")
23 class IPCMessagePubSubCase(salt.ext.tornado.testing.AsyncTestCase):
24     def setUp(self):
25         super().setUp()
26         self.opts = {"ipc_write_buffer": 0}
27         self.socket_path = os.path.join(RUNTIME_VARS.TMP, "ipc_test.ipc")
28         self.pub_channel = self._get_pub_channel()
29         self.sub_channel = self._get_sub_channel()
30     def _get_pub_channel(self):
31         pub_channel = salt.transport.ipc.IPCMessagePublisher(
32             self.opts,
33             self.socket_path,
34         )
35         pub_channel.start()
36         return pub_channel
37     def _get_sub_channel(self):
38         sub_channel = salt.transport.ipc.IPCMessageSubscriber(
39             socket_path=self.socket_path,
40             io_loop=self.io_loop,
41         )
42         sub_channel.connect(callback=self.stop)
43         self.wait()
44         return sub_channel
45     def tearDown(self):
46         super().tearDown()
47         try:
48             self.pub_channel.close()
49         except OSError as exc:
50             if exc.errno != errno.EBADF:
51                 raise
52         try:
53             self.sub_channel.close()
54         except OSError as exc:
55             if exc.errno != errno.EBADF:
56                 raise
57         os.unlink(self.socket_path)
58         del self.pub_channel
59         del self.sub_channel
60     def test_multi_client_reading(self):
61         client1 = self.sub_channel
62         client2 = self._get_sub_channel()
63         call_cnt = []
64         evt = threading.Event()
65         def close_server():
66             if evt.wait(1):
67                 return
68             client2.close()
69             self.stop()
70         watchdog = threading.Thread(target=close_server)
71         watchdog.start()
72         def handler(raw):
73             call_cnt.append(raw)
74             if len(call_cnt) &gt;= 2:
75                 evt.set()
76                 self.stop()
77         client1.read_async(handler)
78         client2.read_async(handler)
79         self.pub_channel.publish("TEST")
80         self.wait()
81         self.assertEqual(len(call_cnt), 2)
82         self.assertEqual(call_cnt[0], "TEST")
83         self.assertEqual(call_cnt[1], "TEST")
84     def test_sync_reading(self):
85         client1 = self.sub_channel
86         client2 = self._get_sub_channel()
87         call_cnt = []
88         self.pub_channel.publish("TEST")
89         ret1 = client1.read_sync()
90         ret2 = client2.read_sync()
91         self.assertEqual(ret1, "TEST")
92         self.assertEqual(ret2, "TEST")
93     @salt.ext.tornado.testing.gen_test
94     def test_async_reading_streamclosederror(self):
95         client1 = self.sub_channel
96         call_cnt = []
97         evt = threading.Event()
98         def close_server():
99             if evt.wait(0.001):
100                 return
101             client1.close()
102             self.stop()
103         watchdog = threading.Thread(target=close_server)
104         watchdog.start()
105         def handler(raw):
106             pass
107         try:
108             ret1 = yield client1.read_async(handler)
109             self.wait()
110         except StreamClosedError as ex:
111             assert False, "StreamClosedError was raised inside the Future"
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_saltmod_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import os
2 import tempfile
3 import pytest
4 import salt.config
5 import salt.loader
6 import salt.states.saltmod as saltmod
7 import salt.utils.event
8 import salt.utils.jid
9 from tests.support.mixins import LoaderModuleMockMixin
10 from tests.support.mock import MagicMock, patch
11 from tests.support.runtests import RUNTIME_VARS
12 from</b></font> tests.support.unit import TestCase
13 class SaltmodTestCase(TestCase, LoaderModuleMockMixin):
14     def setup_loader_modules(self):
15         utils = salt.loader.utils(
16             salt.config.DEFAULT_MINION_OPTS.copy(), whitelist=["state"]
17         )
18         return {
19             saltmod: {
20                 "__env__": "base",
21                 "__opts__": {
22                     "__role": "master",
23                     "file_client": "remote",
24                     "sock_dir": tempfile.mkdtemp(dir=RUNTIME_VARS.TMP),
25                     "transport": "tcp",
26                 },
27                 "__salt__": {"saltutil.cmd": MagicMock()},
28                 "__orchestration_jid__": salt.utils.jid.gen_jid({}),
29                 "__utils__": utils,
30             }
31         }
32     @pytest.mark.slow_test
33     def test_state(self):
34         name = "state"
35         tgt = "minion1"
36         comt = "Passed invalid value for 'allow_fail', must be an int"
37         ret = {"name": name, "changes": {}, "result": False, "comment": comt}
38         test_ret = {
39             "name": name,
40             "changes": {},
41             "result": True,
42             "comment": "States ran successfully.",
43         }
44         test_batch_return = {
45             "minion1": {
46                 "ret": {
47                     "test_|-notify_me_|-this is a name_|-show_notification": {
48                         "comment": "Notify me",
49                         "name": "this is a name",
50                         "start_time": "10:43:41.487565",
51                         "result": True,
52                         "duration": 0.35,
53                         "__run_num__": 0,
54                         "__sls__": "demo",
55                         "changes": {},
56                         "__id__": "notify_me",
57                     },
58                     "retcode": 0,
59                 },
60                 "out": "highstate",
61             },
62             "minion2": {
63                 "ret": {
64                     "test_|-notify_me_|-this is a name_|-show_notification": {
65                         "comment": "Notify me",
66                         "name": "this is a name",
67                         "start_time": "10:43:41.487565",
68                         "result": True,
69                         "duration": 0.35,
70                         "__run_num__": 0,
71                         "__sls__": "demo",
72                         "changes": {},
73                         "__id__": "notify_me",
74                     },
75                     "retcode": 0,
76                 },
77                 "out": "highstate",
78             },
79             "minion3": {
80                 "ret": {
81                     "test_|-notify_me_|-this is a name_|-show_notification": {
82                         "comment": "Notify me",
83                         "name": "this is a name",
84                         "start_time": "10:43:41.487565",
85                         "result": True,
86                         "duration": 0.35,
87                         "__run_num__": 0,
88                         "__sls__": "demo",
89                         "changes": {},
90                         "__id__": "notify_me",
91                     },
92                     "retcode": 0,
93                 },
94                 "out": "highstate",
95             },
96         }
97         self.assertDictEqual(saltmod.state(name, tgt, allow_fail="a"), ret)
98         comt = "No highstate or sls specified, no execution made"
99         ret.update({"comment": comt})
100         self.assertDictEqual(saltmod.state(name, tgt), ret)
101         comt = "Must pass in boolean for value of 'concurrent'"
102         ret.update({"comment": comt})
103         self.assertDictEqual(
104             saltmod.state(name, tgt, highstate=True, concurrent="a"), ret
105         )
106         ret.update({"comment": comt, "result": None})
107         with patch.dict(saltmod.__opts__, {"test": True}):
108             self.assertDictEqual(saltmod.state(name, tgt, highstate=True), test_ret)
109         ret.update(
110             {
111                 "comment": "States ran successfully. No changes made to silver.",
112                 "result": True,
113                 "__jid__": "20170406104341210934",
114             }
115         )
116         with patch.dict(saltmod.__opts__, {"test": False}):
117             mock = MagicMock(
118                 return_value={
119                     "silver": {
120                         "jid": "20170406104341210934",
121                         "retcode": 0,
122                         "ret": {
123                             "test_|-notify_me_|-this is a name_|-show_notification": {
124                                 "comment": "Notify me",
125                                 "name": "this is a name",
126                                 "start_time": "10:43:41.487565",
127                                 "result": True,
128                                 "duration": 0.35,
129                                 "__run_num__": 0,
130                                 "__sls__": "demo",
131                                 "changes": {},
132                                 "__id__": "notify_me",
133                             }
134                         },
135                         "out": "highstate",
136                     }
137                 }
138             )
139             with patch.dict(saltmod.__salt__, {"saltutil.cmd": mock}):
140                 self.assertDictEqual(saltmod.state(name, tgt, highstate=True), ret)
141         ret.update(
142             {
143                 "comment": (
144                     "States ran successfully. No changes made to minion1, minion3,"
145                     " minion2."
146                 )
147             }
148         )
149         del ret["__jid__"]
150         with patch.dict(saltmod.__opts__, {"test": False}):
151             with patch.dict(
152                 saltmod.__salt__,
153                 {"saltutil.cmd": MagicMock(return_value=test_batch_return)},
154             ):
155                 state_run = saltmod.state(name, tgt, highstate=True)
156                 comment = state_run.pop("comment")
157                 ret.pop("comment")
158                 self.assertDictEqual(state_run, ret)
159                 self.assertIn("States ran successfully. No changes made to", comment)
160                 for minion in ["minion1", "minion2", "minion3"]:
161                     self.assertIn(minion, comment)
162     @pytest.mark.slow_test
163     def test_function(self):
164         name = "state"
165         tgt = "larry"
166         ret = {
167             "name": name,
168             "changes": {},
169             "result": None,
170             "comment": "Function state would be executed on target {}".format(tgt),
171         }
172         with patch.dict(saltmod.__opts__, {"test": True}):
173             self.assertDictEqual(saltmod.function(name, tgt), ret)
174         ret.update(
175             {
176                 "result": True,
177                 "changes": {"ret": {tgt: ""}},
178                 "comment": (
179                     "Function ran successfully. Function state ran on {}.".format(tgt)
180                 ),
181             }
182         )
183         with patch.dict(saltmod.__opts__, {"test": False}):
184             mock_ret = {"larry": {"ret": "", "retcode": 0, "failed": False}}
185             mock_cmd = MagicMock(return_value=mock_ret)
186             with patch.dict(saltmod.__salt__, {"saltutil.cmd": mock_cmd}):
187                 self.assertDictEqual(saltmod.function(name, tgt), ret)
188     @pytest.mark.slow_test
189     def test_function_when_no_minions_match(self):
190         name = "state"
191         tgt = "larry"
192         mock_ret = {}
193         mock_cmd = MagicMock(return_value=mock_ret)
194         ret = {
195             "name": name,
196             "changes": {},
197             "result": False,
198             "comment": "No minions responded",
199         }
200         with patch.dict(saltmod.__opts__, {"test": False}):
201             with patch.dict(saltmod.__salt__, {"saltutil.cmd": mock_cmd}):
202                 self.assertDictEqual(saltmod.function(name, tgt), ret)
203     def test_wait_for_event(self):
204         name = "state"
205         tgt = "minion1"
206         comt = "Timeout value reached."
207         ret = {"name": name, "changes": {}, "result": False, "comment": comt}
208         class Mockevent:
209             flag = None
210             def __init__(self):
211                 self.full = None
212             def get_event(self, full):
213                 self.full = full
214                 if self.flag:
215                     return {"tag": name, "data": {}}
216                 return None
217             def __enter__(self):
218                 return self
219             def __exit__(self, *args):
220                 pass
221         with patch.object(
222             salt.utils.event, "get_event", MagicMock(return_value=Mockevent())
223         ):
224             with patch.dict(saltmod.__opts__, {"sock_dir": True, "transport": True}):
225                 with patch(
226                     "salt.states.saltmod.time.time", MagicMock(return_value=1.0)
227                 ):
228                     self.assertDictEqual(
229                         saltmod.wait_for_event(name, "salt", timeout=-1.0), ret
230                     )
231                     Mockevent.flag = True
232                     ret.update(
233                         {"comment": "All events seen in 0.0 seconds.", "result": True}
234                     )
235                     self.assertDictEqual(saltmod.wait_for_event(name, ""), ret)
236                     ret.update({"comment": "Timeout value reached.", "result": False})
237                     self.assertDictEqual(
238                         saltmod.wait_for_event(name, tgt, timeout=-1.0), ret
239                     )
240     def test_runner(self):
241         name = "state"
242         ret = {
243             "changes": {"return": True},
244             "name": "state",
245             "result": True,
246             "comment": "Runner function 'state' executed.",
247             "__orchestration__": True,
248         }
249         runner_mock = MagicMock(return_value={"return": True})
250         with patch.dict(saltmod.__salt__, {"saltutil.runner": runner_mock}):
251             self.assertDictEqual(saltmod.runner(name), ret)
252     def test_wheel(self):
253         name = "state"
254         ret = {
255             "changes": {"return": True},
256             "name": "state",
257             "result": True,
258             "comment": "Wheel function 'state' executed.",
259             "__orchestration__": True,
260         }
261         wheel_mock = MagicMock(return_value={"return": True})
262         with patch.dict(saltmod.__salt__, {"saltutil.wheel": wheel_mock}):
263             self.assertDictEqual(saltmod.wheel(name), ret)
264     @pytest.mark.slow_test
265     def test_state_ssh(self):
266         origcmd = saltmod.__salt__["saltutil.cmd"]
267         cmd_kwargs = {}
268         cmd_args = []
269         def cmd_mock(*args, **kwargs):
270             cmd_args.extend(args)
271             cmd_kwargs.update(kwargs)
272             return origcmd(*args, **kwargs)
273         with patch.dict(saltmod.__salt__, {"saltutil.cmd": cmd_mock}):
274             ret = saltmod.state(
275                 "state.sls", tgt="*", ssh=True, highstate=True, roster="my_roster"
276             )
277         assert "roster" in cmd_kwargs
278         assert cmd_kwargs["roster"] == "my_roster"
279     @pytest.mark.slow_test
280     def test_function_ssh(self):
281         origcmd = saltmod.__salt__["saltutil.cmd"]
282         cmd_kwargs = {}
283         cmd_args = []
284         def cmd_mock(*args, **kwargs):
285             cmd_args.extend(args)
286             cmd_kwargs.update(kwargs)
287             return origcmd(*args, **kwargs)
288         with patch.dict(saltmod.__opts__, {"test": False}), patch.dict(
289             saltmod.__salt__, {"saltutil.cmd": cmd_mock}
290         ):
291             saltmod.function("state", tgt="*", ssh=True, roster="my_roster")
292         assert "roster" in cmd_kwargs
293         assert cmd_kwargs["roster"] == "my_roster"
294 class StatemodTests(TestCase, LoaderModuleMockMixin):
295     def setup_loader_modules(self):
296         self.tmp_cachedir = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
297         return {
298             saltmod: {
299                 "__env__": "base",
300                 "__opts__": {
301                     "id": "webserver2",
302                     "argv": [],
303                     "__role": "master",
304                     "cachedir": self.tmp_cachedir,
305                     "extension_modules": os.path.join(self.tmp_cachedir, "extmods"),
306                 },
307                 "__salt__": {"saltutil.cmd": MagicMock()},
308                 "__orchestration_jid__": salt.utils.jid.gen_jid({}),
309             }
310         }
311     def test_statemod_state(self):
312         args = ("webserver_setup", "webserver2")
313         kwargs = {
314             "tgt_type": "glob",
315             "fail_minions": None,
316             "pillar": None,
317             "top": None,
318             "batch": None,
319             "orchestration_jid": None,
320             "sls": "vroom",
321             "queue": False,
322             "concurrent": False,
323             "highstate": None,
324             "expr_form": None,
325             "ret": "",
326             "ssh": False,
327             "timeout": None,
328             "test": False,
329             "allow_fail": 0,
330             "saltenv": None,
331             "expect_minions": False,
332         }
333         ret = saltmod.state(*args, **kwargs)
334         expected = {
335             "comment": "States ran successfully.",
336             "changes": {},
337             "name": "webserver_setup",
338             "result": True,
339         }
340         self.assertEqual(ret, expected)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
