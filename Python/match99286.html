<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_ipc_1.py &amp; test_saltmod_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_ipc_1.py &amp; test_saltmod_1.py
      </h3>
<h1 align="center">
        3.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_ipc_1.py (4.9792533%)<th>test_saltmod_1.py (2.6258206%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(6-18)<td><a href="#" name="0">(5-17)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_ipc_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import errno
3 import logging
4 import os
5 import threading
6 import pytest
7 import salt.config
8 import salt.exceptions
9 import salt.ext.tornado.gen
10 import salt.ext.tornado.ioloop
11 import salt.ext.tornado.testing
12 import salt.transport.ipc
13 import</b></font> salt.utils.platform
14 from salt.ext.tornado.iostream import StreamClosedError
15 from tests.support.runtests import RUNTIME_VARS
16 from tests.support.unit import skipIf
17 pytestmark = [
18     pytest.mark.skip_on_darwin,
19     pytest.mark.skip_on_freebsd,
20     pytest.mark.skip_on_windows,
21 ]
22 log = logging.getLogger(__name__)
23 @skipIf(salt.utils.platform.is_windows(), "Windows does not support Posix IPC")
24 class IPCMessagePubSubCase(salt.ext.tornado.testing.AsyncTestCase):
25     """
26     Test all of the clear msg stuff
27     """
28     def setUp(self):
29         super().setUp()
30         self.opts = {"ipc_write_buffer": 0}
31         self.socket_path = os.path.join(RUNTIME_VARS.TMP, "ipc_test.ipc")
32         self.pub_channel = self._get_pub_channel()
33         self.sub_channel = self._get_sub_channel()
34     def _get_pub_channel(self):
35         pub_channel = salt.transport.ipc.IPCMessagePublisher(
36             self.opts,
37             self.socket_path,
38         )
39         pub_channel.start()
40         return pub_channel
41     def _get_sub_channel(self):
42         sub_channel = salt.transport.ipc.IPCMessageSubscriber(
43             socket_path=self.socket_path,
44             io_loop=self.io_loop,
45         )
46         sub_channel.connect(callback=self.stop)
47         self.wait()
48         return sub_channel
49     def tearDown(self):
50         super().tearDown()
51         try:
52             self.pub_channel.close()
53         except OSError as exc:
54             if exc.errno != errno.EBADF:
55                 raise
56         try:
57             self.sub_channel.close()
58         except OSError as exc:
59             if exc.errno != errno.EBADF:
60                 raise
61         os.unlink(self.socket_path)
62         del self.pub_channel
63         del self.sub_channel
64     def test_multi_client_reading(self):
65         client1 = self.sub_channel
66         client2 = self._get_sub_channel()
67         call_cnt = []
68         evt = threading.Event()
69         def close_server():
70             if evt.wait(1):
71                 return
72             client2.close()
73             self.stop()
74         watchdog = threading.Thread(target=close_server)
75         watchdog.start()
76         def handler(raw):
77             call_cnt.append(raw)
78             if len(call_cnt) &gt;= 2:
79                 evt.set()
80                 self.stop()
81         client1.read_async(handler)
82         client2.read_async(handler)
83         self.pub_channel.publish("TEST")
84         self.wait()
85         self.assertEqual(len(call_cnt), 2)
86         self.assertEqual(call_cnt[0], "TEST")
87         self.assertEqual(call_cnt[1], "TEST")
88     def test_sync_reading(self):
89         client1 = self.sub_channel
90         client2 = self._get_sub_channel()
91         call_cnt = []
92         self.pub_channel.publish("TEST")
93         ret1 = client1.read_sync()
94         ret2 = client2.read_sync()
95         self.assertEqual(ret1, "TEST")
96         self.assertEqual(ret2, "TEST")
97     @salt.ext.tornado.testing.gen_test
98     def test_async_reading_streamclosederror(self):
99         client1 = self.sub_channel
100         call_cnt = []
101         evt = threading.Event()
102         def close_server():
103             if evt.wait(0.001):
104                 return
105             client1.close()
106             self.stop()
107         watchdog = threading.Thread(target=close_server)
108         watchdog.start()
109         def handler(raw):
110             pass
111         try:
112             ret1 = yield client1.read_async(handler)
113             self.wait()
114         except StreamClosedError as ex:
115             assert False, "StreamClosedError was raised inside the Future"
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_saltmod_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 """
3 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import os
4 import tempfile
5 import pytest
6 import salt.config
7 import salt.loader
8 import salt.states.saltmod as saltmod
9 import salt.utils.event
10 import salt.utils.jid
11 from tests.support.mixins import LoaderModuleMockMixin
12 from tests.support.mock import MagicMock, patch
13 from tests.support.runtests import RUNTIME_VARS
14 from</b></font> tests.support.unit import TestCase
15 class SaltmodTestCase(TestCase, LoaderModuleMockMixin):
16     """
17     Test cases for salt.states.saltmod
18     """
19     def setup_loader_modules(self):
20         utils = salt.loader.utils(
21             salt.config.DEFAULT_MINION_OPTS.copy(), whitelist=["state"]
22         )
23         return {
24             saltmod: {
25                 "__env__": "base",
26                 "__opts__": {
27                     "__role": "master",
28                     "file_client": "remote",
29                     "sock_dir": tempfile.mkdtemp(dir=RUNTIME_VARS.TMP),
30                     "transport": "tcp",
31                 },
32                 "__salt__": {"saltutil.cmd": MagicMock()},
33                 "__orchestration_jid__": salt.utils.jid.gen_jid({}),
34                 "__utils__": utils,
35             }
36         }
37     @pytest.mark.slow_test
38     def test_state(self):
39         """
40         Test to invoke a state run on a given target
41         """
42         name = "state"
43         tgt = "minion1"
44         comt = "Passed invalid value for 'allow_fail', must be an int"
45         ret = {"name": name, "changes": {}, "result": False, "comment": comt}
46         test_ret = {
47             "name": name,
48             "changes": {},
49             "result": True,
50             "comment": "States ran successfully.",
51         }
52         test_batch_return = {
53             "minion1": {
54                 "ret": {
55                     "test_|-notify_me_|-this is a name_|-show_notification": {
56                         "comment": "Notify me",
57                         "name": "this is a name",
58                         "start_time": "10:43:41.487565",
59                         "result": True,
60                         "duration": 0.35,
61                         "__run_num__": 0,
62                         "__sls__": "demo",
63                         "changes": {},
64                         "__id__": "notify_me",
65                     },
66                     "retcode": 0,
67                 },
68                 "out": "highstate",
69             },
70             "minion2": {
71                 "ret": {
72                     "test_|-notify_me_|-this is a name_|-show_notification": {
73                         "comment": "Notify me",
74                         "name": "this is a name",
75                         "start_time": "10:43:41.487565",
76                         "result": True,
77                         "duration": 0.35,
78                         "__run_num__": 0,
79                         "__sls__": "demo",
80                         "changes": {},
81                         "__id__": "notify_me",
82                     },
83                     "retcode": 0,
84                 },
85                 "out": "highstate",
86             },
87             "minion3": {
88                 "ret": {
89                     "test_|-notify_me_|-this is a name_|-show_notification": {
90                         "comment": "Notify me",
91                         "name": "this is a name",
92                         "start_time": "10:43:41.487565",
93                         "result": True,
94                         "duration": 0.35,
95                         "__run_num__": 0,
96                         "__sls__": "demo",
97                         "changes": {},
98                         "__id__": "notify_me",
99                     },
100                     "retcode": 0,
101                 },
102                 "out": "highstate",
103             },
104         }
105         self.assertDictEqual(saltmod.state(name, tgt, allow_fail="a"), ret)
106         comt = "No highstate or sls specified, no execution made"
107         ret.update({"comment": comt})
108         self.assertDictEqual(saltmod.state(name, tgt), ret)
109         comt = "Must pass in boolean for value of 'concurrent'"
110         ret.update({"comment": comt})
111         self.assertDictEqual(
112             saltmod.state(name, tgt, highstate=True, concurrent="a"), ret
113         )
114         ret.update({"comment": comt, "result": None})
115         with patch.dict(saltmod.__opts__, {"test": True}):
116             self.assertDictEqual(saltmod.state(name, tgt, highstate=True), test_ret)
117         ret.update(
118             {
119                 "comment": "States ran successfully. No changes made to silver.",
120                 "result": True,
121                 "__jid__": "20170406104341210934",
122             }
123         )
124         with patch.dict(saltmod.__opts__, {"test": False}):
125             mock = MagicMock(
126                 return_value={
127                     "silver": {
128                         "jid": "20170406104341210934",
129                         "retcode": 0,
130                         "ret": {
131                             "test_|-notify_me_|-this is a name_|-show_notification": {
132                                 "comment": "Notify me",
133                                 "name": "this is a name",
134                                 "start_time": "10:43:41.487565",
135                                 "result": True,
136                                 "duration": 0.35,
137                                 "__run_num__": 0,
138                                 "__sls__": "demo",
139                                 "changes": {},
140                                 "__id__": "notify_me",
141                             }
142                         },
143                         "out": "highstate",
144                     }
145                 }
146             )
147             with patch.dict(saltmod.__salt__, {"saltutil.cmd": mock}):
148                 self.assertDictEqual(saltmod.state(name, tgt, highstate=True), ret)
149         ret.update(
150             {
151                 "comment": (
152                     "States ran successfully. No changes made to minion1, minion3,"
153                     " minion2."
154                 )
155             }
156         )
157         del ret["__jid__"]
158         with patch.dict(saltmod.__opts__, {"test": False}):
159             with patch.dict(
160                 saltmod.__salt__,
161                 {"saltutil.cmd": MagicMock(return_value=test_batch_return)},
162             ):
163                 state_run = saltmod.state(name, tgt, highstate=True)
164                 comment = state_run.pop("comment")
165                 ret.pop("comment")
166                 self.assertDictEqual(state_run, ret)
167                 self.assertIn("States ran successfully. No changes made to", comment)
168                 for minion in ["minion1", "minion2", "minion3"]:
169                     self.assertIn(minion, comment)
170     @pytest.mark.slow_test
171     def test_function(self):
172         """
173         Test to execute a single module function on a remote
174         minion via salt or salt-ssh
175         """
176         name = "state"
177         tgt = "larry"
178         ret = {
179             "name": name,
180             "changes": {},
181             "result": None,
182             "comment": "Function state would be executed on target {}".format(tgt),
183         }
184         with patch.dict(saltmod.__opts__, {"test": True}):
185             self.assertDictEqual(saltmod.function(name, tgt), ret)
186         ret.update(
187             {
188                 "result": True,
189                 "changes": {"ret": {tgt: ""}},
190                 "comment": (
191                     "Function ran successfully. Function state ran on {}.".format(tgt)
192                 ),
193             }
194         )
195         with patch.dict(saltmod.__opts__, {"test": False}):
196             mock_ret = {"larry": {"ret": "", "retcode": 0, "failed": False}}
197             mock_cmd = MagicMock(return_value=mock_ret)
198             with patch.dict(saltmod.__salt__, {"saltutil.cmd": mock_cmd}):
199                 self.assertDictEqual(saltmod.function(name, tgt), ret)
200     @pytest.mark.slow_test
201     def test_function_when_no_minions_match(self):
202         """
203         Test to execute a single module function on a remote
204         minion via salt or salt-ssh
205         """
206         name = "state"
207         tgt = "larry"
208         mock_ret = {}
209         mock_cmd = MagicMock(return_value=mock_ret)
210         ret = {
211             "name": name,
212             "changes": {},
213             "result": False,
214             "comment": "No minions responded",
215         }
216         with patch.dict(saltmod.__opts__, {"test": False}):
217             with patch.dict(saltmod.__salt__, {"saltutil.cmd": mock_cmd}):
218                 self.assertDictEqual(saltmod.function(name, tgt), ret)
219     def test_wait_for_event(self):
220         """
221         Test to watch Salt's event bus and block until a condition is met
222         """
223         name = "state"
224         tgt = "minion1"
225         comt = "Timeout value reached."
226         ret = {"name": name, "changes": {}, "result": False, "comment": comt}
227         class Mockevent:
228             """
229             Mock event class
230             """
231             flag = None
232             def __init__(self):
233                 self.full = None
234             def get_event(self, full):
235                 """
236                 Mock get_event method
237                 """
238                 self.full = full
239                 if self.flag:
240                     return {"tag": name, "data": {}}
241                 return None
242             def __enter__(self):
243                 return self
244             def __exit__(self, *args):
245                 pass
246         with patch.object(
247             salt.utils.event, "get_event", MagicMock(return_value=Mockevent())
248         ):
249             with patch.dict(saltmod.__opts__, {"sock_dir": True, "transport": True}):
250                 with patch(
251                     "salt.states.saltmod.time.time", MagicMock(return_value=1.0)
252                 ):
253                     self.assertDictEqual(
254                         saltmod.wait_for_event(name, "salt", timeout=-1.0), ret
255                     )
256                     Mockevent.flag = True
257                     ret.update(
258                         {"comment": "All events seen in 0.0 seconds.", "result": True}
259                     )
260                     self.assertDictEqual(saltmod.wait_for_event(name, ""), ret)
261                     ret.update({"comment": "Timeout value reached.", "result": False})
262                     self.assertDictEqual(
263                         saltmod.wait_for_event(name, tgt, timeout=-1.0), ret
264                     )
265     def test_runner(self):
266         """
267         Test to execute a runner module on the master
268         """
269         name = "state"
270         ret = {
271             "changes": {"return": True},
272             "name": "state",
273             "result": True,
274             "comment": "Runner function 'state' executed.",
275             "__orchestration__": True,
276         }
277         runner_mock = MagicMock(return_value={"return": True})
278         with patch.dict(saltmod.__salt__, {"saltutil.runner": runner_mock}):
279             self.assertDictEqual(saltmod.runner(name), ret)
280     def test_wheel(self):
281         """
282         Test to execute a wheel module on the master
283         """
284         name = "state"
285         ret = {
286             "changes": {"return": True},
287             "name": "state",
288             "result": True,
289             "comment": "Wheel function 'state' executed.",
290             "__orchestration__": True,
291         }
292         wheel_mock = MagicMock(return_value={"return": True})
293         with patch.dict(saltmod.__salt__, {"saltutil.wheel": wheel_mock}):
294             self.assertDictEqual(saltmod.wheel(name), ret)
295     @pytest.mark.slow_test
296     def test_state_ssh(self):
297         """
298         Test saltmod state passes roster to saltutil.cmd
299         """
300         origcmd = saltmod.__salt__["saltutil.cmd"]
301         cmd_kwargs = {}
302         cmd_args = []
303         def cmd_mock(*args, **kwargs):
304             cmd_args.extend(args)
305             cmd_kwargs.update(kwargs)
306             return origcmd(*args, **kwargs)
307         with patch.dict(saltmod.__salt__, {"saltutil.cmd": cmd_mock}):
308             ret = saltmod.state(
309                 "state.sls", tgt="*", ssh=True, highstate=True, roster="my_roster"
310             )
311         assert "roster" in cmd_kwargs
312         assert cmd_kwargs["roster"] == "my_roster"
313     @pytest.mark.slow_test
314     def test_function_ssh(self):
315         """
316         Test saltmod function passes roster to saltutil.cmd
317         """
318         origcmd = saltmod.__salt__["saltutil.cmd"]
319         cmd_kwargs = {}
320         cmd_args = []
321         def cmd_mock(*args, **kwargs):
322             cmd_args.extend(args)
323             cmd_kwargs.update(kwargs)
324             return origcmd(*args, **kwargs)
325         with patch.dict(saltmod.__opts__, {"test": False}), patch.dict(
326             saltmod.__salt__, {"saltutil.cmd": cmd_mock}
327         ):
328             saltmod.function("state", tgt="*", ssh=True, roster="my_roster")
329         assert "roster" in cmd_kwargs
330         assert cmd_kwargs["roster"] == "my_roster"
331 class StatemodTests(TestCase, LoaderModuleMockMixin):
332     def setup_loader_modules(self):
333         self.tmp_cachedir = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
334         return {
335             saltmod: {
336                 "__env__": "base",
337                 "__opts__": {
338                     "id": "webserver2",
339                     "argv": [],
340                     "__role": "master",
341                     "cachedir": self.tmp_cachedir,
342                     "extension_modules": os.path.join(self.tmp_cachedir, "extmods"),
343                 },
344                 "__salt__": {"saltutil.cmd": MagicMock()},
345                 "__orchestration_jid__": salt.utils.jid.gen_jid({}),
346             }
347         }
348     def test_statemod_state(self):
349         """Smoke test for for salt.states.statemod.state().  Ensures that we
350         don't take an exception if optional parameters are not specified in
351         __opts__ or __env__.
352         """
353         args = ("webserver_setup", "webserver2")
354         kwargs = {
355             "tgt_type": "glob",
356             "fail_minions": None,
357             "pillar": None,
358             "top": None,
359             "batch": None,
360             "orchestration_jid": None,
361             "sls": "vroom",
362             "queue": False,
363             "concurrent": False,
364             "highstate": None,
365             "expr_form": None,
366             "ret": "",
367             "ssh": False,
368             "timeout": None,
369             "test": False,
370             "allow_fail": 0,
371             "saltenv": None,
372             "expect_minions": False,
373         }
374         ret = saltmod.state(*args, **kwargs)
375         expected = {
376             "comment": "States ran successfully.",
377             "changes": {},
378             "name": "webserver_setup",
379             "result": True,
380         }
381         self.assertEqual(ret, expected)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
