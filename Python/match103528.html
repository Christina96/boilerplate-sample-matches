<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for kickstart.py &amp; test_ipaddress.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for kickstart.py &amp; test_ipaddress.py
      </h3>
<h1 align="center">
        3.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>kickstart.py (5.574468%)<th>test_ipaddress.py (2.363341%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(951-958)<td><a href="#" name="0">(1128-1133)</a><td align="center"><font color="#ff0000">16</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(554-565)<td><a href="#" name="1">(2794-2800)</a><td align="center"><font color="#df0000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(414-425)<td><a href="#" name="2">(2788-2794)</a><td align="center"><font color="#df0000">14</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(1127-1133)<td><a href="#" name="3">(1073-1075)</a><td align="center"><font color="#cf0000">13</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(1077-1083)<td><a href="#" name="4">(134-137)</a><td align="center"><font color="#cf0000">13</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(770-780)<td><a href="#" name="5">(2779-2786)</a><td align="center"><font color="#cf0000">13</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(1013-1018)<td><a href="#" name="6">(1133-1138)</a><td align="center"><font color="#bf0000">12</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(218-222)<td><a href="#" name="7">(202-206)</a><td align="center"><font color="#bf0000">12</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(133-143)<td><a href="#" name="8">(1209-1217)</a><td align="center"><font color="#bf0000">12</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(115-125)<td><a href="#" name="9">(1151-1159)</a><td align="center"><font color="#bf0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>kickstart.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
Utilities for managing kickstart
.. versionadded:: 2015.8.0
"""
import argparse
import shlex
import salt.utils.files
import salt.utils.yaml
def clean_args(args):
    """
    Cleans up the args that weren't passed in
    """
    for arg in list(args):
        if not args[arg]:
            del args[arg]
    return args
def parse_auth(rule):
    """
    Parses the auth/authconfig line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    noargs = (
        "back",
        "test",
        "nostart",
        "kickstart",
        "probe",
        "enablecache",
        "disablecache",
        "disablenis",
        "enableshadow",
        "disableshadow",
        "enablemd5",
        "disablemd5",
        "enableldap",
        "enableldapauth",
        "enableldaptls",
        "disableldap",
        "disableldapauth",
        "enablekrb5kdcdns",
        "disablekrb5kdcdns",
        "enablekrb5realmdns",
        "disablekrb5realmdns",
        "disablekrb5",
        "disablehe-siod",
        "enablesmbauth",
        "disablesmbauth",
        "enablewinbind",
        "enablewinbindauth",
        "disablewinbind",
        "disablewinbindauth",
        "enablewinbindusedefaultdomain",
        "disablewinbindusedefaultdomain",
        "enablewins",
        "disablewins",
    )
    for arg in noargs:
        parser.add_argument("--{}".format(arg), dest=arg, action="store_true")
    parser.add_argument("--enablenis", dest="enablenis", action="store")
    parser.add_argument("--hesiodrhs", dest="hesiodrhs", action="store")
    parser.add_argument("--krb5adminserver", dest="krb5adminserver", action="append")
    parser.add_argument("--krb5kdc", dest="krb5kdc", action="append")
    parser.add_argument("--ldapbasedn", dest="ldapbasedn", action="store")
    parser.add_argument("--ldapserver", dest="ldapserver", action="append")
    parser.add_argument("--nisserver", dest="nisserver", action="append")
    parser.add_argument("--passalgo", dest="passalgo", action="store")
    parser.add_argument("--smbidmapgid", dest="smbidmapgid", action="store")
    parser.add_argument("--smbidmapuid", dest="smbidmapuid", action="store")
    parser.add_argument("--smbrealm", dest="smbrealm", action="store")
    parser.add_argument(
        "--smbsecurity",
        dest="smbsecurity",
        action="store",
        choices=["user", "server", "domain", "dns"],
    )
    parser.add_argument("--smbservers", dest="smbservers", action="store")
    parser.add_argument("--smbworkgroup", dest="smbworkgroup", action="store")
    parser.add_argument("--winbindjoin", dest="winbindjoin", action="store")
    parser.add_argument("--winbindseparator", dest="winbindseparator", action="store")
    parser.add_argument(
        "--winbindtemplatehomedir", dest="winbindtemplatehomedir", action="store"
    )
    parser.add_argument(
        "--winbindtemplateprimarygroup",
        dest="winbindtemplateprimarygroup",
        action="store",
    )
    parser.add_argument(
        "--winbindtemplateshell", dest="winbindtemplateshell", action="store"
    )
    parser.add_argument("--enablekrb5", dest="enablekrb5", action="store_true")
    if "--enablekrb5" in rules:
        parser.add_argument(
            "--krb5realm", dest="krb5realm", action="store", required=True
        )
    parser.add_argument("--enablehesiod", dest="enablehesiod", action="store_true")
    if "--enablehesiod" in rules:
        parser.add_argument(
            "--hesiodlhs", dest="hesiodlhs", action="store", required=True
        )
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    r<font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>eturn args
def parse_autopart(rule):
    """
    Parse the autopart line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(</b></font>"--type", dest="type", action="store")
    parser.add_argument("--encrypted", dest="encrypted", action="store_true")
    parser.add_argument("--passphrase", dest="passphrase", action="store")
    parser.add_argument("--escrowcert", dest="escrowcert", action="store")
    parser.add_argument("--backuppassphrase", dest="backuppassphrase", action="store")
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    r<font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>eturn args
def parse_autostep(rule):
    """
    Parse the autostep line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(</b></font>"--autoscreenshot", dest="autoscreenshot", action="store")
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args
def parse_bootloader(rule):
    """
    Parse the bootloader line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument("--append", dest="append", action="store")
    parser.add_argument("--driveorder", dest="driveorder", action="store")
    parser.add_argument("--location", dest="location", action="store")
    parser.add_argument("--password", dest="password", action="store")
    parser.add_argument("--md5pass", dest="md5pass", action="store")
    parser.add_argument("--upgrade", dest="upgrade", action="store_true")
    parser.add_argument("--timeout", dest="timeout", action="store")
    parser.add_argument("--boot-drive", dest="bootdrive", action="store")
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args
def parse_btrfs(rule):
    """
    Parse the btrfs line
    TODO: finish up the weird parsing on this one
    http://fedoraproject.org/wiki/Anaconda/Kickstart#btrfs
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument("--name", dest="name", action="store")
    parser.add_argument("--data", dest="data", action="store")
    parser.add_argument("--metadata", dest="metadata", action="store")
    parser.add_argument("--label", dest="label", action="store")
    parser.add_argument("--noformat", dest="noformat", action="store_true")
    parser.add_argument("--useexisting", dest="useexisting", action="store_true")
    parser.add_argument("--subvol", dest="subvol", action="store_true")
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args
def parse_clearpart(rule):
    """
    Parse the clearpart line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument("--all", dest="all", action="store_true")
    parser.add_argument("--drives", dest="drives", action="store")
    parser.add_argument("--init_label", dest="init_label", action="store_true")
    parser.add_argument("--linux", dest="linux", action="store_true")
    parser.add_argument("--none", dest="none", action="store_true")
    parser.add_argument("--initlabel", dest="init_label", action="store_true")
    parser.add_argument("--list", dest="list", action="store")
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args
def parse_device(rule):
    Parse the device line
    """
    parser = argparse<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    modulename = rules.pop(0)
    parser.add_argument(</b></font>"--opts", dest="opts", action="store")
    args = clean_args(vars(parser.parse_args(rules)))
    args["modulename"] = modulename
    parser = None
    return args
def parse_dmraid(rule):
    """
    Parse the dmraid line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument("--name", dest="name", action="store")
    parser.add_argument("--dev", dest="dev", action="store")
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args
def parse_driverdisk(rule):
    """
    Parse the driverdisk line
    """
    if "--" not in rule:
        return {"partition": rule}
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument("--source", dest="source", action="store")
    parser.add_argument("--biospart", dest="biospart", action="store")
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args
def parse_firewall(rule):
    """
    Parse the firewall line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument("--enable", "--enabled", dest="enable", action="store_true")
    parser.add_argument("--disable", "--disabled", dest="disable", action="store_true")
    parser.add_argument("--port", dest="port", action="store")
    parser.add_argument("--service", dest="service", action="store")
    parser.add_argument("--ssh", dest="ssh", action="store_true")
    parser.add_argument("--smtp", dest="smtp", action="store_true")
    parser.add_argument("--http", dest="http", action="store_true")
    parser.add_argument("--ftp", dest="ftp", action="store_true")
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args
def parse_firstboot(rule):
    """
    Parse the firstboot line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument("--enable", "--enabled", dest="enable", action="store_true")
    parser.add_argument("--disable", "--disabled", dest="disable", action="store_true")
    parser.add_argument("--reconfig", dest="reconfig", action="store_true")
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args
def parse_group(rule):
    """
    Parse the group line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument("--name", dest="name", action="store")
    parser.add_argument("--gid", dest="gid", action="store")
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args
def parse_harddrive(rule):
    """
    Parse the harddrive line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument("--biospart", dest="biospart", action="store")
    parser.add_argument("--partition", dest="partition", action="store")
    parser.add_argument("--dir", dest="dir", action="store")
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args
def parse_ignoredisk(rule):
    """
    Parse the ignoredisk line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument("--drives", dest="drives", action="store")
    parser.add_argument("--only-use", dest="only-use", action="store")
    parser.add_argument("--interactive", dest="interactive", action="store_true")
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args
def parse_iscsi(rule):
    """
    Parse the iscsi line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument("--ipaddr", dest="ipaddr", action="store")
    parser.add_argument("--port", dest="port", action="store")
    parser.add_argument("--target", dest="target", action="store")
    parser.add_argument("--iface", dest="iface", action="store")
    parser.add_argument("--user", dest="user", action="store")
    parser.add_argument("--password", dest="password", action="store")
    parser.add_argument("--reverse-user", dest="reverse-user", action="store")
    parser.add_argument("--reverse-password", dest="reverse-password", action="store")
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args
def parse_iscsiname(rule):
    """
    Parse the iscsiname line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args
def parse_keyboard(rule):
    """
    Parse the keyboard line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument("--vckeymap", dest="vckeymap", action="store")
    parser.add_argument("--xlayouts", dest="xlayouts", action="store")
    parser.add_argument("--switch", dest="switch", action="store")
    parser.add_argument("keyboard")
    args = clean_args(vars(parser.parse_args(rules)))
    if "keyboard" in args and "xlayouts" not in args:
        args["xlayouts"] = args["keyboard"]
    parser = None
    return args
def parse_lang(rule):
    """
    Parse the lang line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument("lang")
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    r<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>eturn args
def parse_logvol(rule):
    """
    Parse the logvol line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument("mntpoint")
    parser.add_argument(</b></font>"--noformat", dest="noformat", action="store_true")
    parser.add_argument("--useexisting", dest="useexisting", action="store_true")
    parser.add_argument("--fstype", dest="fstype", action="store")
    parser.add_argument("--fsoptions", dest="fsoptions", action="store")
    parser.add_argument("--grow", dest="grow", action="store_true")
    parser.add_argument("--maxsize", dest="maxsize", action="store")
    parser.add_argument("--recommended", dest="recommended", action="store_true")
    parser.add_argument("--percent", dest="percent", action="store_true")
    parser.add_argument("--encrypted", dest="encrypted", action="store_true")
    parser.add_argument("--passphrase", dest="passphrase", action="store")
    parser.add_argument("--escrowcert", dest="escrowcert", action="store")
    parser.add_argument(
        "--backuppassphrase", dest="backuppassphrase", action="store_true"
    )
    parser.add_argument("--name", dest="name", action="store")
    parser.add_argument("--vgname", dest="vgname", action="store")
    parser.add_argument("--size", dest="size", action="store")
    parser.add_argument("--label", dest="label", action="store")
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args
def parse_logging(rule):
    """
    Parse the logging line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument("--host", dest="host", action="store")
    parser.add_argument("--port", dest="port", action="store")
    parser.add_argument(
        "--level",
        dest="level",
        action="store",
        choices=["debug", "info", "warning", "error", "critical"],
    )
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args
def parse_monitor(rule):
    """
    Parse the monitor line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument("--hsync", dest="hsync", action="store")
    parser.add_argument("--monitor", dest="monitor", action="store")
    parser.add_argument("--noprobe", dest="noprobe", action="store_true")
    parser.add_argument("--vsync", dest="vsync", action="store")
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args
def parse_multipath(rule):
    """
    Parse the multipath line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument("--name", dest="name", action="store")
    parser.add_argument("--device", dest="device", action="store")
    parser.add_argument("--rule", dest="rule", action="store")
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args
def parse_network(rule):
    """
    Parse the network line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(
        "--bootproto",
        dest="bootproto",
        action="store",
        choices=["dhcp", "bootp", "static", "ibft"],
    )
    parser.add_argument("--device", dest="device", action="store")
    parser.add_argument("--ip", dest="ip", action="store")
    parser.add_argument("--ipv6", dest="ipv6", action="store")
    parser.add_argument("--gateway", dest="gateway", action="store")
    parser.add_argument("--nodefroute", dest="nodefroute", action="store_true")
    parser.add_argument("--nameserver", dest="nameserver", action="store")
    parser.add_argument("--nodns", dest="nodns", action="store_true")
    parser.add_argument("--netmask", dest="netmask", action="store")
    parser.add_argument("--hostname", dest="hostname", action="store")
    parser.add_argument("--ethtool", dest="ethtool", action="store")
    parser.add_argument("--essid", dest="essid", action="store")
    parser.add_argument("--wepkey", dest="wepkey", action="store")
    parser.add_argument("--wpakey", dest="wpakey", action="store")
    parser.add_argument("--onboot", dest="onboot", action="store")
    parser.add_argument("--dhcpclass", dest="dhcpclass", action="store")
    parser.add_argument("--mtu", dest="mtu", action="store")
    parser.add_argument("--noipv4", dest="noipv4", action="store_true")
    parser.add_argument("--noipv6", dest="noipv6", action="store_true")
    parser.add_argument("--activate", dest="activate", action="store_true")
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args
def parse_nfs(rule):
    """
    Parse the nfs line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument("--server", dest="server", action="store")
    parser.add_argument("--dir", dest="dir", action="store")
    parser.add_argument("--opts", dest="opts", action="store")
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    r<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>eturn args
def parse_partition(rule):
    """
    Parse the partition line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument("mntpoint")
    parser.add_argument(</b></font>"--size", dest="size", action="store")
    parser.add_argument("--grow", dest="grow", action="store_true")
    parser.add_argument("--maxsize", dest="maxsize", action="store")
    parser.add_argument("--noformat", dest="noformat", action="store_true")
    parser.add_argument("--onpart", "--usepart", dest="onpart", action="store")
    parser.add_argument("--ondisk", "--ondrive", dest="ondisk", action="store")
    parser.add_argument("--asprimary", dest="asprimary", action="store_true")
    parser.add_argument("--fsprofile", dest="fsprofile", action="store")
    parser.add_argument("--fstype", dest="fstype", action="store")
    parser.add_argument("--fsoptions", dest="fsoptions", action="store")
    parser.add_argument("--label", dest="label", action="store")
    parser.add_argument("--recommended", dest="recommended", action="store_true")
    parser.add_argument("--onbiosdisk", dest="onbiosdisk", action="store")
    parser.add_argument("--encrypted", dest="encrypted", action="store_true")
    parser.add_argument("--passphrase", dest="passphrase", action="store")
    parser.add_argument("--escrowcert", dest="escrowcert", action="store")
    parser.add_argument("--backupphrase", dest="backupphrase", action="store")
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args
def parse_raid(rule):
    """
    Parse the raid line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    partitions = []
    newrules = []
    for count, rule in enumerate(rules):
        if count == 0:
            newrules.append(rule)
            continue
        elif rule.startswith("--"):
            newrules.append(rule)
            continue
        else:
            partitions.append(rule)
    rules = newrules
    parser.add_argument("mntpoint")
    parser.add_argument("--level", dest="level", action="store")
    parser.add_argument("--device", dest="device", action="store")
    parser.add_argument("--spares", dest="spares", action="store")
    parser.add_argument("--fstype", dest="fstype", action="store")
    parser.add_argument("--fsoptions", dest="fsoptions", action="store")
    parser.add_argument("--label", dest="label", action="store")
    parser.add_argument("--noformat", dest="noformat", action="store_true")
    parser.add_argument("--useexisting", dest="useexisting", action="store_true")
    parser.add_argument("--encrypted", dest="encrypted", action="store_true")
    parser.add_argument("--passphrase", dest="passphrase", action="store")
    parser.add_argument("--escrowcert", dest="escrowcert", action="store")
    parser.add_argument("--backuppassphrase", dest="backuppassphrase", action="store")
    args = clean_args(vars(parser.parse_args(rules)))
    if partitions:
        args["partitions"] = partitions
    parser = None
    return args
def parse_reboot(rule):
    """
    Parse the reboot line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument("--eject", dest="eject", action="store_true")
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args
def parse_repo(rule):
    """
    Parse the repo line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument("--name", dest="name", action="store")
    parser.add_argument("--baseurl", dest="baseurl", action="store")
    parser.add_argument("--mirrorlist", dest="mirrorlist", action="store")
    parser.add_argument("--cost", dest="cost", action="store")
    parser.add_argument("--excludepkgs", dest="excludepkgs", action="store")
    parser.add_argument("--includepkgs", dest="includepkgs", action="store")
    parser.add_argument("--proxy", dest="proxy", action="store")
    parser.add_argument("--ignoregroups", dest="ignoregroups", action="store")
    parser.add_argument("--noverifyssl", dest="noverifyssl", action="store_true")
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args
def parse_rescue(rule):
    """
    Parse the rescue line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument("--nomount", dest="nomount", action="store_true")
    parser.add_argument("--romount", dest="romount", action="store_true")
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args
def parse_rootpw(rule):
    """
    Parse the rootpw line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument("--iscrypted", dest="iscrypted", action="store_true")
    parser.add_argument("--plaintext", dest="plaintext", action="store_true")
    parser.add_argument("--lock", dest="lock", action="store_true")
    parser.add_argument("password")
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args
def parse_selinux(rule):
    """
    Parse the selinux line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument("--disabled", dest="disabled", action="store_true")
    parser.add_argument("--enforcing", dest="enforcing", action="store_true")
    parser.add_argument("--permissive", dest="permissive", action="store_true")
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args
def parse_services(rule):
    """
    Parse the services line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument("--disabled", dest="disabled", action="store")
    parser.add_argument("--enabled", dest="enabled", action="store")
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args
def parse_sshpw(rule):
    """
    Parse the sshpw line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument("--username", dest="username", action="store")
    parser.add_argument("--iscrypted", dest="iscrypted", action="store_true")
    parser.add_argument("--plaintext", dest="plaintext", action="store_true")
    parser.add_argument("--lock", dest="lock", action="store_true")
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args
def parse_timezone(rule):
    """
    Parse the timezone line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument("--utc", dest="utc", action="store_true")
    parser.add_argument("--nontp", dest="nontp", action="store_true")
    parser.add_argument("--ntpservers", dest="ntpservers", action="store")
    parser.add_argument("--isUtc", dest="isutc", action="store_true")
    parser.add_argument("timezone")
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args
def parse_updates(rule):
    """
    Parse the updates line
    rules = shlex.split(rule)
    rules.pop(0)
    return {"url": rules<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>[0]} if rules else True
def parse_upgrade(rule):
    """
    Parse the upgrade line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(</b></font>"--root-device", dest="root-device", action="store")
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    if args:
        return args
    return True
def parse_url(rule):
    """
    Parse the url line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument("--url", dest="url", action="store")
    parser.add_argument("--proxy", dest="proxy", action="store")
    parser.add_argument("--noverifyssl", dest="noverifyssl", action="store_true")
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args
def parse_user(rule):
    """
    Parse the user line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument("--name", dest="name", action="store")
    parser.add_argument("--gecos", dest="gecos", action="store")
    parser.add_argument("--groups", dest="groups", action="store")
    parser.add_argument("--homedir", dest="homedir", action="store")
    parser.add_argument("--lock", dest="lock", action="store_true")
    parser.add_argument("--password", dest="password", action="store")
    parser.add_argument("--iscrypted", dest="iscrypted", action="store_true")
    parser.add_argument("--plaintext", dest="plaintext", action="store_true")
    parser.add_argument("--shell", dest="shell", action="store")
    parser.add_argument("--uid", dest="uid", action="store")
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args
def parse_vnc(rule):
    """
    Parse the vnc line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument("--host", dest="host", action="store")
    parser.add_argument("--port", dest="port", action="store")
    parser.add_argument("--password", dest="password", action="store")
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args
def parse_volgroup(rule):
    """
    Parse the volgroup line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    partitions = []
    newrules = []
    for count, rule in enumerate(rules):
        if count == 0:
            newrules.append(rule)
            continue
        elif rule.startswith("--"):
            newrules.append(rule)
            continue
        else:
            partitions.append(rule)
    rules = newrules
    parser.add_argument("name")
    parser.add_argument("--noformat", dest="noformat", action="store_true")
    parser.add_argument("--useexisting", dest="useexisting", action="store_true")
    parser.add_argument("--pesize", dest="pesize", action="store")
    parser.add_argument("--reserved-space", dest="reserved-space", action="store")
    parser.add_argument("--reserved-percent", dest="reserved-percent", action="store")
    args = clean_args(vars(parser.parse_args(rules)))
    if partitions:
        args["partitions"] = partitions
    parser = None
    return args
def parse_xconfig(rule):
    """
    Parse the xconfig line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument("--defaultdesktop", dest="defaultdesktop", action="store")
    parser.add_argument("--startxonboot", dest="startxonboot", action="store_true")
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args
def parse_zfcp(rule):
    """
    Parse the zfcp line
    """
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument("--devnum", dest="devnum", action="store")
    parser.add_argument("--fcplun", dest="fcplun", action="store")
    parser.add_argument("--wwpn", dest="wwpn", action="store")
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args
def mksls(src, dst=None):
    """
    Convert a kickstart file to an SLS file
    """
    mode = "command"
    sls = {}
    ks_opts = {}
    with salt.utils.files.fopen(src, "r") as fh_:
        for line in fh_:
            if line.startswith("#"):
                continue
            if mode == "command":
                if line.startswith("auth ") or line.startswith("authconfig "):
                    ks_opts["auth"] = parse_auth(line)
                elif line.startswith("autopart"):
                    ks_opts["autopath"] = parse_autopart(line)
                elif line.startswith("autostep"):
                    ks_opts["autostep"] = parse_autostep(line)
                elif line.startswith("bootloader"):
                    ks_opts["bootloader"] = parse_bootloader(line)
                elif line.startswith("btrfs"):
                    ks_opts["btrfs"] = parse_btrfs(line)
                elif line.startswith("cdrom"):
                    ks_opts["cdrom"] = True
                elif line.startswith("clearpart"):
                    ks_opts["clearpart"] = parse_clearpart(line)
                elif line.startswith("cmdline"):
                    ks_opts["cmdline"] = True
                elif line.startswith("device"):
                    ks_opts["device"] = parse_device(line)
                elif line.startswith("dmraid"):
                    ks_opts["dmraid"] = parse_dmraid(line)
                elif line.startswith("driverdisk"):
                    ks_opts["driverdisk"] = parse_driverdisk(line)
                elif line.startswith("firewall"):
                    ks_opts["firewall"] = parse_firewall(line)
                elif line.startswith("firstboot"):
                elif line.startswith("group"):
                    ks_opts["group"] = parse_group(line)
                elif line<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.startswith("graphical"):
                    ks_opts["graphical"] = True
                elif line.startswith("halt"):
                    ks_opts["halt"] = True
                elif line.startswith("harddrive"):
                    ks_opts["harddrive"] = True
                elif line.startswith("ignoredisk"):
                    ks_opts["ignoredisk"] =</b></font> parse_ignoredisk(line)
                elif line.startswith("install"):
                    ks_opts["install"] = True
                elif line.startswith("iscsi"):
                    ks_opts["iscsi"] = parse_iscsi(line)
                elif line.startswith("iscsiname"):
                    ks_opts["iscsiname"] = parse_iscsiname(line)
                elif line.startswith("keyboard"):
                    ks_opts["keyboard"] = parse_keyboard(line)
                elif line.startswith("lang"):
                    ks_opts["lang"] = parse_lang(line)
                elif line.startswith("logvol"):
                    if "logvol" not in ks_opts:
                        ks_opts["logvol"] = []
                    ks_opts["logvol"].append(parse_logvol(line))
                elif line.startswith("logging"):
                    ks_opts["logging"] = parse_logging(line)
                elif line.startswith("mediacheck"):
                    ks_opts["mediacheck"] = True
                elif line.startswith("monitor"):
                    ks_opts["monitor"] = parse_monitor(line)
                elif line.startswith("multipath"):
                    ks_opts["multipath"] = parse_multipath(line)
                elif line.startswith("network"):
                    if "network" not in ks_opts:
                        ks_opts["network"] = []
                    ks_opts["network"].append(parse_network(line))
                elif line.startswith("nfs"):
                    ks_opts["nfs"] = True
                elif line.startswith("part ") or line.startswith("partition"):
                    if "part" not in ks_opts:
                        ks_opts["part"] = []
                    ks_opts["part"].append(parse_partition(line))
                elif line.startswith("poweroff"):
                    ks_opts["poweroff"] = True
                elif line.startswith("raid"):
                    if "raid" not in ks_opts:
                        ks_opts["raid"] = []
                    ks_opts["raid"].append(parse_raid(line))
                elif line.startswith("reboot"):
                    ks_opts["reboot"] = parse_reboot(line)
                elif line.startswith("repo"):
                    ks_opts["repo"] = parse_repo(line)
                elif line.startswith("rescue"):
                    ks_opts["rescue"] = parse_rescue(line)
                elif line.startswith("rootpw"):
                    ks_opts["rootpw"] = parse_rootpw(line)
                elif line.startswith("selinux"):
                    ks_opts["selinux"] = parse_selinux(line)
                elif line.startswith("services"):
                    ks_opts["services"] = parse_services(line)
                elif line.startswith("shutdown"):
                elif line.startswith("sshpw"):
                    ks_opts["sshpw"] = parse_sshpw(line)
                elif line<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.startswith("skipx"):
                    ks_opts["skipx"] = True
                elif line.startswith("text"):
                    ks_opts["text"] = True
                elif line.startswith("timezone"):
                    ks_opts["timezone"] =</b></font> parse_timezone(line)
                elif line.startswith("updates"):
                    ks_opts["updates"] = parse_updates(line)
                elif line.startswith("upgrade"):
                    ks_opts["upgrade"] = parse_upgrade(line)
                elif line.startswith("url"):
                    ks_opts["url"] = True
                elif line.startswith("user"):
                    ks_opts["user"] = parse_user(line)
                elif line.startswith("vnc"):
                    ks_opts["vnc"] = parse_vnc(line)
                elif line.startswith("volgroup"):
                    ks_opts["volgroup"] = parse_volgroup(line)
                elif line.startswith("xconfig"):
                    ks_opts["xconfig"] = parse_xconfig(line)
                elif line.startswith("zerombr"):
                    ks_opts["zerombr"] = True
                elif line.startswith("zfcp"):
                    ks_opts["zfcp"] = parse_zfcp(line)
            if line.startswith("%include"):
                rules = shlex.split(line)
                if not ks_opts["include"]:
                    ks_opts["include"] = []
                ks_opts["include"].append(rules[1])
            if line.startswith("%ksappend"):
                rules = shlex.split(line)
                if not ks_opts["ksappend"]:
                    ks_opts["ksappend"] = []
                ks_opts["ksappend"].append(rules[1])
            if line.startswith("%packages"):
                mode = "packages"
                if "packages" not in ks_opts:
                    ks_opts["packages"] = {"packages": {}}
                parser = argparse.ArgumentParser()
                opts = shlex.split(line)
                opts.pop(0)
                parser.add_argument("--default", dest="default", action="store_true")
                parser.add_argument(
                    "--excludedocs", dest="excludedocs", action="store_true"
                )
                parser.add_argument(
                    "--ignoremissing", dest="ignoremissing", action="store_true"
                )
                parser.add_argument("--instLangs", dest="instLangs", action="store")
                parser.add_argument("--multilib", dest="multilib", action="store_true")
                parser.add_argument(
                    "--nodefaults", dest="nodefaults", action="store_true"
                )
                parser.add_argument("--optional", dest="optional", action="store_true")
                parser.add_argument("--nobase", dest="nobase", action="store_true")
                args = clean_args(vars(parser.parse_args(opts)))
                ks_opts["packages"]["options"] = args
                continue
            if line<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.startswith("%pre"):
                mode = "pre"
                parser = argparse.ArgumentParser()
                opts = shlex.split(line)
                opts.pop(0)
                parser.add_argument(</b></font>"--interpreter", dest="interpreter", action="store")
                parser.add_argument(
                    "--erroronfail", dest="erroronfail", action="store_true"
                )
                parser.add_argument("--log", dest="log", action="store")
                args = clean_args(vars(parser.parse_args(opts)))
                ks_opts["pre"] = {"options": args, "script": ""}
                continue
            if line.startswith("%post"):
                mode = "post"
                parser = argparse.ArgumentParser()
                opts = shlex.split(line)
                opts.pop(0)
                parser.add_argument("--nochroot", dest="nochroot", action="store_true")
                parser.add_argument("--interpreter", dest="interpreter", action="store")
                parser.add_argument(
                    "--erroronfail", dest="erroronfail", action="store_true"
                )
                parser.add_argument("--log", dest="log", action="store")
                args = clean_args(vars(parser.parse_args(opts)))
                ks_opts["post"] = {"options": args, "script": ""}
                continue
            if line.startswith("%end"):
                mode = None
            if mode == "packages":
                if line.startswith("-"):
                    package = line.replace("-", "", 1).strip()
                    ks_opts["packages"]["packages"][package] = False
                else:
                    ks_opts["packages"]["packages"][line.strip()] = True
            if mode == "pre":
                ks_opts["pre"]["script"] += line
            if mode == "post":
    sls<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>[ks_opts["lang"]["lang"]] = {"locale": ["system"]}
    sls[ks_opts["keyboard"]["xlayouts"]] = {"keyboard": ["system"]}
    sls[ks_opts["timezone"][</b></font>"timezone"]] = {"timezone": ["system"]}
    if "utc" in ks_opts["timezone"]:
        sls[ks_opts["timezone"]["timezone"]]["timezone"].append("utc")
    if "network" in ks_opts:
        for interface in ks_opts["network"]:
            device = interface.get("device", None)
            if device is not None:
                del interface["device"]
                sls[device] = {"proto": interface["bootproto"]}
                del interface["bootproto"]
                if "onboot" in interface:
                    if "no" in interface["onboot"]:
                        sls[device]["enabled"] = False
                    else:
                        sls[device]["enabled"] = True
                    del interface["onboot"]
                if "noipv4" in interface:
                    sls[device]["ipv4"] = {"enabled": False}
                    del interface["noipv4"]
                if "noipv6" in interface:
                    sls[device]["ipv6"] = {"enabled": False}
                    del interface["noipv6"]
                for option in interface:
                    if type(interface[option]) is bool:
                        sls[device][option] = {"enabled": [interface[option]]}
                    else:
                        sls[device][option] = interface[option]
            if "hostname" in interface:
                sls["system"] = {
                    "network.system": {
                        "enabled": True,
                        "hostname": interface["hostname"],
                        "apply_hostname": True,
                    }
                }
    if "selinux" in ks_opts:
        for mode in ks_opts["selinux"]:
            sls[mode] = {"selinux": ["mode"]}
    if "nobase" not in ks_opts["packages"]["options"]:
        sls["base"] = {"pkg_group": ["installed"]}
    packages = ks_opts["packages"]["packages"]
    for package in packages:
        if not packages[package]:
            continue
        if package and packages[package] is True:
            if package.startswith("@"):
                pkg_group = package.replace("@", "", 1)
                sls[pkg_group] = {"pkg_group": ["installed"]}
            else:
                sls[package] = {"pkg": ["installed"]}
        elif packages[package] is False:
            sls[package] = {"pkg": ["absent"]}
    if dst:
        with salt.utils.files.fopen(dst, "w") as fp_:
            salt.utils.yaml.safe_dump(sls, fp_, default_flow_style=False)
    else:
        return salt.utils.yaml.safe_dump(sls, default_flow_style=False)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_ipaddress.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import contextlib
import functools
import operator
import pickle
import re
import sys
import weakref
import pytest
from salt._compat import ipaddress
from tests.support.unit import TestCase, skipIf
@functools.total_ordering
class _LARGEST:
    """
    Object that is greater than anything (except itself).
    """
    def __eq__(self, other):
        return isinstance(other, _LARGEST)
    def __lt__(self, other):
        return False
LARGEST = _LARGEST()
@functools.total_ordering
class _SMALLEST:
    """
    Object that is less than anything (except itself).
    """
    def __eq__(self, other):
        return isinstance(other, _SMALLEST)
    def __gt__(self, other):
        return False
SMALLEST = _SMALLEST()
class BaseTestCase(TestCase):
    @property
    def factory(self):
        raise NotImplementedError
    @contextlib.contextmanager
    def assertCleanError(self, exc_type, details, *args):
        """
        Ensure exception does not display a context by default
        Wraps unittest.TestCase.assertRaisesRegex
        """
        if args:
            details = details % args
        cm = self.assertRaisesRegex(exc_type, details)
        with cm as exc:
            yield exc
        if exc.exception.__context__ is not None:
            self.assertTrue(exc.exception.__suppress_context__)
    def assertAddressError(self, details, *args):
        return self.assertCleanError(ipaddress.AddressValueError, details, *args)
    def assertNetmaskError(self, details, *args):
        return self.assertCleanError(ipaddress.NetmaskValueError, details, *args)
    def assertInstancesEqual(self, lhs, rhs):
        self.assertEqual(self.factory(lhs), self.factory(rhs))
@skipIf(sys.version_info &gt;= (3, 9, 5), "We use builtin ipaddress on Python &gt;= 3.9.5")
class CommonTestMixin:
    def test_empty_address(self):
        with self.assertAddressError("Address cannot be empty"):
            self.factory("")
    def test_floats_rejected(self):
        with self.assertAddressError(re.escape(repr("1.0"))):
            self.factory(1.0)
    def test_not_an_index_issue15559(self):
        self.assertRaises(TypeError, operator.index, self.factory(1))
        self.assertRaises(TypeError, hex, self.factory(1))
        self.assertRaises(TypeError, bytes, self.factory(1))
    def pickle_test(self, addr):
        for proto in range(pickle.HIGHEST_PROTOCOL + 1):
            with self<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.subTest(proto=proto):
                x = self.factory(addr)
                y = pickle.loads(pickle.dumps(x, proto))
                self.assertEqual(</b></font>y, x)
@skipIf(sys.version_info &gt;= (3, 9, 5), "We use builtin ipaddress on Python &gt;= 3.9.5")
class CommonTestMixin_v4(CommonTestMixin):
    def test_leading_zeros(self):
        msg = r"Leading zeros are not permitted in '\d+'"
        addresses = [
            "000.000.000.000",
            "192.168.000.001",
            "016.016.016.016",
            "192.168.000.001",
            "001.000.008.016",
            "01.2.3.40",
            "1.02.3.40",
            "1.2.03.40",
            "1.2.3.040",
        ]
        for address in addresses:
            with self.subTest(address=address):
                with self.assertAddressError(msg):
                    self.factory(address)
    def test_int(self):
        self.assertInstancesEqual(0, "0.0.0.0")
        self.assertInstancesEqual(3232235521, "192.168.0.1")
    def test_packed(self):
        self.assertInstancesEqual(bytes.fromhex("00000000"), "0.0.0.0")
        self.assertInstancesEqual(bytes.fromhex("c0a80001"), "192.168.0.1")
    def test_negative_ints_rejected(self):
        msg = "-1 (&lt; 0) is not permitted as an IPv4 address"
        with self.assertAddressError(re.escape(msg)):
            self.factory(-1)
    def test_large_ints_rejected(self):
        msg = "%d (&gt;= 2**32) is not permitted as an IPv4 address"
        with self.assertAddressError(re.escape(msg % 2 ** 32)):
            self.factory(2 ** 32)
    def test_bad_packed_length(self):
        def assertBadLength(length):
            addr = b"\0" * length
            msg = "%r (len %d != 4) is not permitted as an IPv4 address"
            with self.assertAddressError(re.escape(msg % (addr, length))):
                self.factory(addr)
        assertBadLength(3)
        assertBadLength(5)
@skipIf(sys.version_info &gt;= (3, 9, 5), "We use builtin ipaddress on Python &gt;= 3.9.5")
class CommonTestMixin_v6(CommonTestMixin):
    def test_leading_zeros(self):
        self.assertInstancesEqual("0000::0000", "::")
        self.assertInstancesEqual("000::c0a8:0001", "::c0a8:1")
    def test_int(self):
        self.assertInstancesEqual(0, "::")
        self.assertInstancesEqual(3232235521, "::c0a8:1")
    def test_packed(self):
        addr = b"\0" * 12 + bytes.fromhex("00000000")
        self<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertInstancesEqual(addr, "::")
        addr = b"\0" * 12 + bytes.fromhex("c0a80001")
        self.assertInstancesEqual(addr, "::c0a8:1")
        addr = bytes.fromhex("c0a80001") + b"\0" * 12
        self.assertInstancesEqual(</b></font>addr, "c0a8:1::")
    def test_negative_ints_rejected(self):
        msg = "-1 (&lt; 0) is not permitted as an IPv6 address"
        with self.assertAddressError(re.escape(msg)):
            self.factory(-1)
    def test_large_ints_rejected(self):
        msg = "%d (&gt;= 2**128) is not permitted as an IPv6 address"
        with self.assertAddressError(re.escape(msg % 2 ** 128)):
            self.factory(2 ** 128)
    def test_bad_packed_length(self):
        def assertBadLength(length):
            addr = b"\0" * length
            msg = "%r (len %d != 16) is not permitted as an IPv6 address"
            with self.assertAddressError(re.escape(msg % (addr, length))):
                self.factory(addr)
                self.factory(addr)
        assertBadLength(15)
        assertBadLength(17)
    def test_blank_scope_id(self):
        address = "::1%"
        with self.assertAddressError('Invalid IPv6 address: "%r"', address):
            self.factory(address)
    def test_invalid_scope_id_with_percent(self):
        address = "::1%scope%"
        with self.assertAddressError('Invalid IPv6 address: "%r"', address):
            self.factory(address)
@skipIf(sys.version_info &gt;= (3, 9, 5), "We use builtin ipaddress on Python &gt;= 3.9.5")
class AddressTestCase_v4(BaseTestCase, CommonTestMixin_v4):
    factory = ipaddress.IPv4Address
    @pytest.mark.skipif(sys.version_info &lt; (3, 6), reason="Don't run on Py3.5")
    def test_format(self):
        v4 = ipaddress.IPv4Address("1.2.3.42")
        v4_pairs = [
            ("b", "00000001000000100000001100101010"),
            ("n", "00000001000000100000001100101010"),
            ("x", "0102032a"),
            ("X", "0102032A"),
            ("_b", "0000_0001_0000_0010_0000_0011_0010_1010"),
            ("_n", "0000_0001_0000_0010_0000_0011_0010_1010"),
            ("_x", "0102_032a"),
            ("_X", "0102_032A"),
            ("#b", "0b00000001000000100000001100101010"),
            ("#n", "0b00000001000000100000001100101010"),
            ("#x", "0x0102032a"),
            ("#X", "0X0102032A"),
            ("#_b", "0b0000_0001_0000_0010_0000_0011_0010_1010"),
            ("#_n", "0b0000_0001_0000_0010_0000_0011_0010_1010"),
            ("#_x", "0x0102_032a"),
            ("#_X", "0X0102_032A"),
            ("s", "1.2.3.42"),
            ("", "1.2.3.42"),
        ]
        for (fmt, txt) in v4_pairs:
            self.assertEqual(txt, format(v4, fmt))
    def test_network_passed_as_address(self):
        addr = "127.0.0.1/24"
        with self.assertAddressError("Unexpected '/' in %r", addr):
            ipaddress.IPv4Address(addr)
    def test_bad_address_split(self):
        def assertBadSplit(addr):
            with self.assertAddressError("Expected 4 octets in %r", addr):
                ipaddress.IPv4Address(addr)
        assertBadSplit("127.0.1")
        assertBadSplit("42.42.42.42.42")
        assertBadSplit("42.42.42")
        assertBadSplit("42.42")
        assertBadSplit("42")
        assertBadSplit("42..42.42.42")
        assertBadSplit("42.42.42.42.")
        assertBadSplit("42.42.42.42...")
        assertBadSplit(".42.42.42.42")
        assertBadSplit("...42.42.42.42")
        assertBadSplit("016.016.016")
        assertBadSplit("016.016")
        assertBadSplit("016")
        assertBadSplit("000")
        assertBadSplit("0x0a.0x0a.0x0a")
        assertBadSplit("0x0a.0x0a")
        assertBadSplit("0x0a")
        assertBadSplit(".")
        assertBadSplit("bogus")
        assertBadSplit("bogus.com")
        assertBadSplit("1000")
        assertBadSplit("1000000000000000")
        assertBadSplit("192.168.0.1.com")
    def test_empty_octet(self):
        def assertBadOctet(addr):
            with self.assertAddressError("Empty octet not permitted in %r", addr):
                ipaddress.IPv4Address(addr)
        assertBadOctet("42..42.42")
        assertBadOctet("...")
    def test_invalid_characters(self):
        def assertBadOctet(addr, octet):
            msg = "Only decimal digits permitted in {!r} in {!r}".format(octet, addr)
            with self.assertAddressError(re.escape(msg)):
                ipaddress.IPv4Address(addr)
        assertBadOctet("0x0a.0x0a.0x0a.0x0a", "0x0a")
        assertBadOctet("0xa.0x0a.0x0a.0x0a", "0xa")
        assertBadOctet("42.42.42.-0", "-0")
        assertBadOctet("42.42.42.+0", "+0")
        assertBadOctet("42.42.42.-42", "-42")
        assertBadOctet("+1.+2.+3.4", "+1")
        assertBadOctet("1.2.3.4e0", "4e0")
        assertBadOctet("1.2.3.4::", "4::")
        assertBadOctet("1.a.2.3", "a")
    def test_octet_length(self):
        def assertBadOctet(addr, octet):
            msg = "At most 3 characters permitted in %r in %r"
            with self.assertAddressError(re.escape(msg % (octet, addr))):
                ipaddress.IPv4Address(addr)
        assertBadOctet("0000.000.000.000", "0000")
        assertBadOctet("12345.67899.-54321.-98765", "12345")
    def test_octet_limit(self):
        def assertBadOctet(addr, octet):
            msg = "Octet %d (&gt; 255) not permitted in %r" % (octet, addr)
            with self.assertAddressError(re.escape(msg)):
                ipaddress.IPv4Address(addr)
        assertBadOctet("257.0.0.0", 257)
        assertBadOctet("192.168.0.999", 999)
    def test_pickle(self):
        self.pickle_test("192.0.2.1")
    def test_weakref(self):
        weakref.ref(self.factory("192.0.2.1"))
@skipIf(sys.version_info &gt;= (3, 9, 5), "We use builtin ipaddress on Python &gt;= 3.9.5")
class AddressTestCase_v6(BaseTestCase, CommonTestMixin_v6):
    factory = ipaddress.IPv6Address
    @pytest.mark.skipif(sys.version_info &lt; (3, 6), reason="Don't run on Py3.5")
    def test_format(self):
        v6 = ipaddress.IPv6Address("::1.2.3.42")
        v6_pairs = [
            (
                "b",
                "000000000000000000000000000000000000000000000000000000"
                "000000000000000000000000000000000000000000000000010000"
                "00100000001100101010",
            ),
            ("n", "0000000000000000000000000102032a"),
            ("x", "0000000000000000000000000102032a"),
            ("X", "0000000000000000000000000102032A"),
            (
                "_b",
                "0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000"
                "_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000"
                "_0000_0000_0000_0000_0001_0000_0010_0000_0011_0010"
                "_1010",
            ),
            ("_n", "0000_0000_0000_0000_0000_0000_0102_032a"),
            ("_x", "0000_0000_0000_0000_0000_0000_0102_032a"),
            ("_X", "0000_0000_0000_0000_0000_0000_0102_032A"),
            (
                "#b",
                "0b0000000000000000000000000000000000000000000000000000"
                "000000000000000000000000000000000000000000000000000100"
                "0000100000001100101010",
            ),
            ("#n", "0x0000000000000000000000000102032a"),
            ("#x", "0x0000000000000000000000000102032a"),
            ("#X", "0X0000000000000000000000000102032A"),
            (
                "#_b",
                "0b0000_0000_0000_0000_0000_0000_0000_0000_0000_0000"
                "_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000"
                "_0000_0000_0000_0000_0000_0001_0000_0010_0000_0011"
                "_0010_1010",
            ),
            ("#_n", "0x0000_0000_0000_0000_0000_0000_0102_032a"),
            ("#_x", "0x0000_0000_0000_0000_0000_0000_0102_032a"),
            ("#_X", "0X0000_0000_0000_0000_0000_0000_0102_032A"),
            ("s", "::102:32a"),
            ("", "::102:32a"),
        ]
        for (fmt, txt) in v6_pairs:
            self.assertEqual(txt, format(v6, fmt))
    def test_network_passed_as_address(self):
        def assertBadSplit(addr):
            msg = "Unexpected '/' in %r"
            with self.assertAddressError(msg, addr):
                ipaddress.IPv6Address(addr)
        assertBadSplit("::1/24")
        assertBadSplit("::1%scope_id/24")
    def test_bad_address_split_v6_not_enough_parts(self):
        def assertBadSplit(addr):
            msg = "At least 3 parts expected in %r"
            with self.assertAddressError(msg, addr.split("%")[0]):
                ipaddress.IPv6Address(addr)
        assertBadSplit(":")
        assertBadSplit(":1")
        assertBadSplit("FEDC:9878")
        assertBadSplit(":%scope")
        assertBadSplit(":1%scope")
        assertBadSplit("FEDC:9878%scope")
    def test_bad_address_split_v6_too_many_colons(self):
        def assertBadSplit(addr):
            msg = "At most 8 colons permitted in %r"
            with self.assertAddressError(msg, addr.split("%")[0]):
                ipaddress.IPv6Address(addr)
        assertBadSplit("9:8:7:6:5:4:3::2:1")
        assertBadSplit("10:9:8:7:6:5:4:3:2:1")
        assertBadSplit("::8:7:6:5:4:3:2:1")
        assertBadSplit("8:7:6:5:4:3:2:1::")
        assertBadSplit("10:9:8:7:6:5:4:3:42.42.42.42")
        assertBadSplit("9:8:7:6:5:4:3::2:1%scope")
        assertBadSplit("10:9:8:7:6:5:4:3:2:1%scope")
        assertBadSplit("::8:7:6:5:4:3:2:1%scope")
        assertBadSplit("8:7:6:5:4:3:2:1::%scope")
        assertBadSplit("10:9:8:7:6:5:4:3:42.42.42.42%scope")
    def test_bad_address_split_v6_too_many_parts(self):
        def assertBadSplit(addr):
            msg = "Exactly 8 parts expected without '::' in %r"
            with self.assertAddressError(msg, addr.split("%")[0]):
                ipaddress.IPv6Address(addr)
        assertBadSplit("3ffe:0:0:0:0:0:0:0:1")
        assertBadSplit("9:8:7:6:5:4:3:2:1")
        assertBadSplit("7:6:5:4:3:2:1")
        assertBadSplit("9:8:7:6:5:4:3:42.42.42.42")
        assertBadSplit("7:6:5:4:3:42.42.42.42")
        assertBadSplit("3ffe:0:0:0:0:0:0:0:1%scope")
        assertBadSplit("9:8:7:6:5:4:3:2:1%scope")
        assertBadSplit("7:6:5:4:3:2:1%scope")
        assertBadSplit("9:8:7:6:5:4:3:42.42.42.42%scope")
        assertBadSplit("7:6:5:4:3:42.42.42.42%scope")
    def test_bad_address_split_v6_too_many_parts_with_double_colon(self):
        def assertBadSplit(addr):
            msg = "Expected at most 7 other parts with '::' in %r"
            with self.assertAddressError(msg, addr.split("%")[0]):
                ipaddress.IPv6Address(addr)
        assertBadSplit("1:2:3:4::5:6:7:8")
        assertBadSplit("1:2:3:4::5:6:7:8%scope")
    def test_bad_address_split_v6_repeated_double_colon(self):
        def assertBadSplit(addr):
            msg = "At most one '::' permitted in %r"
            with self.assertAddressError(msg, addr.split("%")[0]):
                ipaddress.IPv6Address(addr)
        assertBadSplit("3ffe::1::1")
        assertBadSplit("1::2::3::4:5")
        assertBadSplit("2001::db:::1")
        assertBadSplit("3ffe::1::")
        assertBadSplit("::3ffe::1")
        assertBadSplit(":3ffe::1::1")
        assertBadSplit("3ffe::1::1:")
        assertBadSplit(":3ffe::1::1:")
        assertBadSplit(":::")
        assertBadSplit("2001:db8:::1")
        assertBadSplit("3ffe::1::1%scope")
        assertBadSplit("1::2::3::4:5%scope")
        assertBadSplit("2001::db:::1%scope")
        assertBadSplit("3ffe::1::%scope")
        assertBadSplit("::3ffe::1%scope")
        assertBadSplit(":3ffe::1::1%scope")
        assertBadSplit("3ffe::1::1:%scope")
        assertBadSplit(":3ffe::1::1:%scope")
        assertBadSplit(":::%scope")
        assertBadSplit("2001:db8:::1%scope")
    def test_bad_address_split_v6_leading_colon(self):
        def assertBadSplit(addr):
            msg = "Leading ':' only permitted as part of '::' in %r"
            with self.assertAddressError(msg, addr.split("%")[0]):
                ipaddress.IPv6Address(addr)
        assertBadSplit(":2001:db8::1")
        assertBadSplit(":1:2:3:4:5:6:7")
        assertBadSplit(":1:2:3:4:5:6:")
        assertBadSplit(":6:5:4:3:2:1::")
        assertBadSplit(":2001:db8::1%scope")
        assertBadSplit(":1:2:3:4:5:6:7%scope")
        assertBadSplit(":1:2:3:4:5:6:%scope")
        assertBadSplit(":6:5:4:3:2:1::%scope")
    def test_bad_address_split_v6_trailing_colon(self):
        def assertBadSplit(addr):
            msg = "Trailing ':' only permitted as part of '::' in %r"
            with self.assertAddressError(msg, addr.split("%")[0]):
                ipaddress.IPv6Address(addr)
        assertBadSplit("2001:db8::1:")
        assertBadSplit("1:2:3:4:5:6:7:")
        assertBadSplit("::1.2.3.4:")
        assertBadSplit("::7:6:5:4:3:2:")
        assertBadSplit("2001:db8::1:%scope")
        assertBadSplit("1:2:3:4:5:6:7:%scope")
        assertBadSplit("::1.2.3.4:%scope")
        assertBadSplit("::7:6:5:4:3:2:%scope")
    def test_bad_v4_part_in(self):
        def assertBadAddressPart(addr, v4_error):
            with self.assertAddressError("%s in %r", v4_error, addr.split("%")[0]):
                ipaddress.IPv6Address(addr)
        assertBadAddressPart("3ffe::1.net", "Expected 4 octets in '1.net'")
        assertBadAddressPart("3ffe::127.0.1", "Expected 4 octets in '127.0.1'")
        assertBadAddressPart("::1.2.3", "Expected 4 octets in '1.2.3'")
        assertBadAddressPart("::1.2.3.4.5", "Expected 4 octets in '1.2.3.4.5'")
        assertBadAddressPart(
            "3ffe::1.1.1.net",
            "Only decimal digits permitted in 'net' in '1.1.1.net'",
        )
        assertBadAddressPart("3ffe::1.net%scope", "Expected 4 octets in '1.net'")
        assertBadAddressPart("3ffe::127.0.1%scope", "Expected 4 octets in '127.0.1'")
        assertBadAddressPart("::1.2.3%scope", "Expected 4 octets in '1.2.3'")
        assertBadAddressPart("::1.2.3.4.5%scope", "Expected 4 octets in '1.2.3.4.5'")
        assertBadAddressPart(
            "3ffe::1.1.1.net%scope",
            "Only decimal digits permitted in 'net' in '1.1.1.net'",
        )
    def test_invalid_characters(self):
        def assertBadPart(addr, part):
            msg = "Only hex digits permitted in {!r} in {!r}".format(
                part, addr.split("%")[0]
            )
            with self.assertAddressError(re.escape(msg)):
                ipaddress.IPv6Address(addr)
        assertBadPart("3ffe::goog", "goog")
        assertBadPart("3ffe::-0", "-0")
        assertBadPart("3ffe::+0", "+0")
        assertBadPart("3ffe::-1", "-1")
        assertBadPart("1.2.3.4::", "1.2.3.4")
        assertBadPart("1234:axy::b", "axy")
        assertBadPart("3ffe::goog%scope", "goog")
        assertBadPart("3ffe::-0%scope", "-0")
        assertBadPart("3ffe::+0%scope", "+0")
        assertBadPart("3ffe::-1%scope", "-1")
        assertBadPart("1.2.3.4::%scope", "1.2.3.4")
        assertBadPart("1234:axy::b%scope", "axy")
    def test_part_length(self):
        def assertBadPart(addr, part):
            msg = "At most 4 characters permitted in %r in %r"
            with self.assertAddressError(msg, part, addr.split("%")[0]):
                ipaddress.IPv6Address(addr)
        assertBadPart("::00000", "00000")
        assertBadPart("3ffe::10000", "10000")
        assertBadPart("02001:db8::", "02001")
        assertBadPart("2001:888888::1", "888888")
        assertBadPart("::00000%scope", "00000")
        assertBadPart("3ffe::10000%scope", "10000")
        assertBadPart("02001:db8::%scope", "02001")
        assertBadPart("2001:888888::1%scope", "888888")
    def test_pickle(self):
        self.pickle_test("2001:db8::")
    def test_weakref(self):
        weakref.ref(self.factory("2001:db8::"))
        weakref.ref(self.factory("2001:db8::%scope"))
@skipIf(sys.version_info &gt;= (3, 9, 5), "We use builtin ipaddress on Python &gt;= 3.9.5")
class NetmaskTestMixin_v4(CommonTestMixin_v4):
    def test_no_mask(self):
        for address in ("1.2.3.4", 0x01020304, b"\x01\x02\x03\x04"):
            net = self.factory(address)
            self.assertEqual(str(net), "1.2.3.4/32")
            self.assertEqual(str(net.netmask), "255.255.255.255")
            self.assertEqual(str(net.hostmask), "0.0.0.0")
    def test_split_netmask(self):
        addr = "1.2.3.4/32/24"
        with self.assertAddressError("Only one '/' permitted in %r" % addr):
            self.factory(addr)
    def test_address_errors(self):
        def assertBadAddress(addr, details):
            with self.assertAddressError(details):
                self.factory(addr)
        assertBadAddress("/", "Address cannot be empty")
        assertBadAddress("/8", "Address cannot be empty")
        assertBadAddress("bogus", "Expected 4 octets")
        assertBadAddress("google.com", "Expected 4 octets")
        assertBadAddress("10/8", "Expected 4 octets")
        assertBadAddress("::1.2.3.4", "Only decimal digits")
        assertBadAddress("1.2.3.256", re.escape("256 (&gt; 255)"))
    def test_valid_netmask(self):
        self.assertEqual(str(self.factory("192.0.2.0/255.255.255.0")), "192.0.2.0/24")
        for i in range(0, 33):
            net_str = "0.0.0.0/%d" % i
            net = self.factory(net_str)
            self.assertEqual(str(net), net_str)
            self.assertEqual(str(self.factory("0.0.0.0/%s" % net.netmask)), net_str)
            self.assertEqual(str(self.factory("0.0.0.0/0%d" % i)), net_str)
            if i in (32, 0):
                net_str = "0.0.0.0/%d" % (32 - i)
            self.assertEqual(str(self.factory("0.0.0.0/%s" % net.hostmask)), net_str)
    def test_netmask_errors(self):
        def assertBadNetmask(addr, netmask):
            msg = "%r is not a valid netmask" % netmask
            with self.assertNetmaskError(re.escape(msg)):
                self.factory("{}/{}".format(addr, netmask))
        assertBadNetmask("1.2.3.4", "")
        assertBadNetmask("1.2.3.4", "-1")
        assertBadNetmask("1.2.3.4", "+1")
        assertBadNetmask("1.2.3.4", " 1 ")
        assertBadNetmask("1.2.3.4", "0x1")
        assertBadNetmask("1.2.3.4", "33")
        assertBadNetmask("1.2.3.4", "254.254.255.256")
        assertBadNetmask("1.2.3.4", "1.a.2.3")
        assertBadNetmask("1.1.1.1", "254.xyz.2.3")
        assertBadNetmask("1.1.1.1", "240.255.0.0")
        assertBadNetmask("1.1.1.1", "255.254.128.0")
        assertBadNetmask("1.1.1.1", "0.1.127.255")
        assertBadNetmask("1.1.1.1", "pudding")
        assertBadNetmask("1.1.1.1", "::")
    def test_netmask_in_tuple_errors(self):
        def assertBadNetmask(addr, netmask):
            msg = "%r is not a valid netmask" % netmask
            with self.assertNetmaskError(re.escape(msg)):
                self.factory((addr, netmask))
        assertBadNetmask("1.1.1.1", -1)
        assertBadNetmask("1.1.1.1", 33)
    def test_pickle(self):
        self.pickle_test("192.0.2.0/27")
        self.pickle_test("192.0.2.0/31")  # IPV4LENGTH - 1
        self.pickle_test("192.0.2.0")  # IPV4LENGTH
class InterfaceTestCase_v4(BaseTestCase, NetmaskTestMixin_v4):
    factory = ipaddress.IPv4Interface
@skipIf(sys.version_info &gt;= (3, 9, 5), "We use builtin ipaddress on Python &gt;= 3.9.5")
class NetworkTestCase_v4(BaseTestCase, NetmaskTestMixin_v4):
    factory = ipaddress.IPv4Network
    def test_subnet_of(self):
        self.assertFalse(
            self.factory("10.0.0.0/30").subnet_of(self.factory("10.0.1.0/24"))
        )
        self.assertTrue(
            self.factory("10.0.0.0/30").subnet_of(self.factory("10.0.0.0/24"))
        )
        self.assertFalse(
            self.factory("10.0.0.0/30").subnet_of(self.factory("10.0.1.0/24"))
        )
        self.assertFalse(
            self.factory("10.0.1.0/24").subnet_of(self.factory("10.0.0.0/30"))
        )
    def test_supernet_of(self):
        self.assertFalse(
            self.factory("10.0.0.0/30").supernet_of(self.factory("10.0.1.0/24"))
        )
        self.assertFalse(
            self.factory("10.0.0.0/30").supernet_of(self.factory("10.0.0.0/24"))
        )
        self.assertFalse(
            self.factory("10.0.0.0/30").supernet_of(self.factory("10.0.1.0/24"))
        )
        self.assertTrue(
            self.factory("10.0.0.0/24").supernet_of(self.factory("10.0.0.0/30"))
        )
    def test_subnet_of_mixed_types(self):
        with self.assertRaises(TypeError):
            ipaddress.IPv4Network("10.0.0.0/30").supernet_of(
                ipaddress.IPv6Network("::1/128")
            )
        with self.assertRaises(TypeError):
            ipaddress.IPv6Network("::1/128").supernet_of(
                ipaddress.IPv4Network("10.0.0.0/30")
            )
        with self.assertRaises(TypeError):
            ipaddress.IPv4Network("10.0.0.0/30").subnet_of(
                ipaddress.IPv6Network("::1/128")
            )
        with self.assertRaises(TypeError):
            ipaddress.IPv6Network("::1/128").subnet_of(
                ipaddress.IPv4Network("10.0.0.0/30")
            )
@skipIf(sys.version_info &gt;= (3, 9, 5), "We use builtin ipaddress on Python &gt;= 3.9.5")
class NetmaskTestMixin_v6(CommonTestMixin_v6):
    def test_no_mask(self):
        for address in ("::1", 1, b"\x00" * 15 + b"\x01"):
            net = self.factory(address)
            self.assertEqual(str(net), "::1/128")
            self.assertEqual(
                str(net.netmask), "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff"
            )
            self.assertEqual(str(net.hostmask), "::")
        scoped_net = self.factory("::1%scope")
        self.assertEqual(str(scoped_net), "::1%scope/128")
        self.assertEqual(
            str(scoped_net.netmask), "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff"
        )
        self.assertEqual(str(scoped_net.hostmask), "::")
    def test_split_netmask(self):
        addr = "cafe:cafe::/128/190"
        with self.assertAddressError("Only one '/' permitted in %r" % addr):
            self.factory(addr)
        scoped_addr = "cafe:cafe::%scope/128/190"
        with self.assertAddressError("Only one '/' permitted in %r" % scoped_addr):
            self.factory(scoped_addr)
    def test_address_errors(self):
        def assertBadAddress(addr, details):
            with self.assertAddressError(details):
                self.factory(addr)
        assertBadAddress("/", "Address cannot be empty")
        assertBadAddress("/8", "Address cannot be empty")
        assertBadAddress("google.com", "At least 3 parts")
        assertBadAddress("1.2.3.4", "At least 3 parts")
        assertBadAddress("10/8", "At least 3 parts")
        assertBadAddress("1234:axy::b", "Only hex digits")
        assertBadAddress("/%scope", "Address cannot be empty")
        assertBadAddress("/%scope8", "Address cannot be empty")
        assertBadAddress("google.com%scope", "At least 3 parts")
        assertBadAddress("1.2.3.4%scope", "At least 3 parts")
        assertBadAddress("10%scope/8", "At least 3 parts")
        assertBadAddress("1234:axy::b%scope", "Only hex digits")
    def test_valid_netmask(self):
        self.assertEqual(str(self.factory("2001:db8::/32")), "2001:db8::/32")
        for i in range(0, 129):
            net_str = "::/%d" % i
            self.assertEqual(str(self.factory(net_str)), net_str)
            self.assertEqual(str(self.factory("::/0%d" % i)), net_str)
        self.assertEqual(
            str(self.factory("2001:db8::%scope/32")), "2001:db8::%scope/32"
        )
        for i in range(0, 129):
            net_str = "::/%d" % i
            self.assertEqual(str(self.factory(net_str)), net_str)
            self.assertEqual(str(self.factory("::/0%d" % i)), net_str)
    def test_netmask_errors(self):
        def assertBadNetmask(addr, netmask):
            msg = "%r is not a valid netmask" % netmask
            with self.assertNetmaskError(re.escape(msg)):
                self.factory("{}/{}".format(addr, netmask))
        assertBadNetmask("::1", "")
        assertBadNetmask("::1", "::1")
        assertBadNetmask("::1", "1::")
        assertBadNetmask("::1", "-1")
        assertBadNetmask("::1", "+1")
        assertBadNetmask("::1", " 1 ")
        assertBadNetmask("::1", "0x1")
        assertBadNetmask("::1", "129")
        assertBadNetmask("::1", "1.2.3.4")
        assertBadNetmask("::1", "pudding")
        assertBadNetmask("::", "::")
        assertBadNetmask("::1%scope", "pudding")
    def test_netmask_in_tuple_errors(self):
        def assertBadNetmask(addr, netmask):
            msg = "%r is not a valid netmask" % netmask
            with self.assertNetmaskError(re.escape(msg)):
                self.factory((addr, netmask))
        assertBadNetmask("::1", -1)
        assertBadNetmask("::1", 129)
        assertBadNetmask("::1%scope", 129)
    def test_pickle(self):
        self.pickle_test("2001:db8::1000/124")
        self.pickle_test("2001:db8::1000/127")  # IPV6LENGTH - 1
        self.pickle_test("2001:db8::1000")  # IPV6LENGTH
        self.pickle_test("2001:db8::1000%scope")  # IPV6LENGTH
class InterfaceTestCase_v6(BaseTestCase, NetmaskTestMixin_v6):
    factory = ipaddress.IPv6Interface
@skipIf(sys.version_info &gt;= (3, 9, 5), "We use builtin ipaddress on Python &gt;= 3.9.5")
class NetworkTestCase_v6(BaseTestCase, NetmaskTestMixin_v6):
    factory = ipaddress.IPv6Network
    def test_subnet_of(self):
        self.assertFalse(
            self.factory("2000:999::/56").subnet_of(self.factory("2000:aaa::/48"))
        )
        self.assertTrue(
            self.factory("2000:aaa::/56").subnet_of(self.factory("2000:aaa::/48"))
        )
        self.assertFalse(
            self.factory("2000:bbb::/56").subnet_of(self.factory("2000:aaa::/48"))
        )
        self.assertFalse(
            self.factory("2000:aaa::/48").subnet_of(self.factory("2000:aaa::/56"))
        )
        self.assertFalse(
            self.factory("2000:999::%scope/56").subnet_of(
                self.factory("2000:aaa::%scope/48")
            )
        )
        self.assertTrue(
            self.factory("2000:aaa::%scope/56").subnet_of(
                self.factory("2000:aaa::%scope/48")
            )
        )
    def test_supernet_of(self):
        self.assertFalse(
            self.factory("2000:999::/56").supernet_of(self.factory("2000:aaa::/48"))
        )
        self.assertFalse(
            self.factory("2000:aaa::/56").supernet_of(self.factory("2000:aaa::/48"))
        )
        self.assertFalse(
            self.factory("2000:bbb::/56").supernet_of(self.factory("2000:aaa::/48"))
        )
        self.assertTrue(
            self.factory("2000:aaa::/48").supernet_of(self.factory("2000:aaa::/56"))
        )
@skipIf(sys.version_info &gt;= (3, 9, 5), "We use builtin ipaddress on Python &gt;= 3.9.5")
class FactoryFunctionErrors(BaseTestCase):
    def assertFactoryError(self, factory, kind):
        addr = "camelot"
        msg = "%r does not appear to be an IPv4 or IPv6 %s"
        with self.assertCleanError(ValueError, msg, addr, kind):
            factory(addr)
    def test_ip_address(self):
        self.assertFactoryError(ipaddress.ip_address, "address")
    def test_ip_interface(self):
        self.assertFactoryError(ipaddress.ip_interface, "interface")
    def test_ip_network(self):
        self.assertFactoryError(ipaddress.ip_network, "network")
@skipIf(sys.version_info &gt;= (3, 9, 5), "We use builtin ipaddress on Python &gt;= 3.9.5")
class ComparisonTests(TestCase):
    v4addr = ipaddress.IPv4Address(1)
    v4net = ipaddress.IPv4Network(1)
    v4intf = ipaddress.IPv4Interface(1)
    v6addr = ipaddress.IPv6Address(1)
    v6net = ipaddress.IPv6Network(1)
    v6intf = ipaddress.IPv6Interface(1)
    v6addr_scoped = ipaddress.IPv6Address("::1%scope")
    v6net_scoped = ipaddress.IPv6Network("::1%scope")
    v6intf_scoped = ipaddress.IPv6Interface("::1%scope")
    v4_addresses = [v4addr, v4intf]
    v4_objects = v4_addresses + [v4net]
    v6_addresses = [v6addr, v6intf]
    v6_objects = v6_addresses + [v6net]
    v6_scoped_addresses = [v6addr_scoped, v6intf_scoped]
    v6_scoped_objects = v6_scoped_addresses + [v6net_scoped]
    objects = v4_objects + v6_objects
    objects_with_scoped = objects + v6_scoped_objects
    v4addr2 = ipaddress.IPv4Address(2)
    v4net2 = ipaddress.IPv4Network(2)
    v4intf2 = ipaddress.IPv4Interface(2)
    v6addr2 = ipaddress.IPv6Address(2)
    v6net2 = ipaddress.IPv6Network(2)
    v6intf2 = ipaddress.IPv6Interface(2)
    v6addr2_scoped = ipaddress.IPv6Address("::2%scope")
    v6net2_scoped = ipaddress.IPv6Network("::2%scope")
    v6intf2_scoped = ipaddress.IPv6Interface("::2%scope")
    def test_foreign_type_equality(self):
        other = object()
        for obj in self.objects_with_scoped:
            self.assertNotEqual(obj, other)
            self.assertFalse(obj == other)
            self.assertEqual(obj.__eq__(other), NotImplemented)
            self.assertEqual(obj.__ne__(other), NotImplemented)
    def test_mixed_type_equality(self):
        for lhs in self.objects:
            for rhs in self.objects:
                if lhs is rhs:
                    continue
                self.assertNotEqual(lhs, rhs)
    def test_scoped_ipv6_equality(self):
        for lhs, rhs in zip(self.v6_objects, self.v6_scoped_objects):
            self.assertNotEqual(lhs, rhs)
    def test_v4_with_v6_scoped_equality(self):
        for lhs in self.v4_objects:
            for rhs in self.v6_scoped_objects:
                self.assertNotEqual(lhs, rhs)
    def test_same_type_equality(self):
        for obj in self.objects_with_scoped:
            self.assertEqual(obj, obj)
            self.assertLessEqual(obj, obj)
            self.assertGreaterEqual(obj, obj)
    def test_same_type_ordering(self):
        for lhs, rhs in (
            (self.v4addr, self.v4addr2),
            (self.v4net, self.v4net2),
            (self.v4intf, self.v4intf2),
            (self.v6addr, self.v6addr2),
            (self.v6net, self.v6net2),
            (self.v6intf, self.v6intf2),
            (self.v6addr_scoped, self.v6addr2_scoped),
            (self.v6net_scoped, self.v6net2_scoped),
            (self.v6intf_scoped, self.v6intf2_scoped),
        ):
            self.assertNotEqual(lhs, rhs)
            self.assertLess(lhs, rhs)
            self.assertLessEqual(lhs, rhs)
            self.assertGreater(rhs, lhs)
            self.assertGreaterEqual(rhs, lhs)
            self.assertFalse(lhs &gt; rhs)
            self.assertFalse(rhs &lt; lhs)
            self.assertFalse(lhs &gt;= rhs)
            self.assertFalse(rhs &lt;= lhs)
    def test_containment(self):
        for obj in self.v4_addresses:
            self.assertIn(obj, self.v4net)
        for obj in self.v6_addresses + self.v6_scoped_addresses:
            self.assertIn(obj, self.v6net)
        for obj in self.v6_addresses + self.v6_scoped_addresses:
            self.assertIn(obj, self.v6net_scoped)
        for obj in self.v4_objects + [self.v6net, self.v6net_scoped]:
            self.assertNotIn(obj, self.v6net)
        for obj in self.v4_objects + [self.v6net, self.v6net_scoped]:
            self.assertNotIn(obj, self.v6net_scoped)
        for obj in self.v6_objects + self.v6_scoped_objects + [self.v4net]:
            self.assertNotIn(obj, self.v4net)
    def test_mixed_type_ordering(self):
        for lhs in self.objects_with_scoped:
            for rhs in self.objects_with_scoped:
                if isinstance(lhs, type(rhs)) or isinstance(rhs, type(lhs)):
                    continue
                self.assertRaises(TypeError, lambda: lhs &lt; rhs)
                self.assertRaises(TypeError, lambda: lhs &gt; rhs)
                self.assertRaises(TypeError, lambda: lhs &lt;= rhs)
                self.assertRaises(TypeError, lambda: lhs &gt;= rhs)
    def test_foreign_type_ordering(self):
        other = object()
        for obj in self.objects_with_scoped:
            with self.assertRaises(TypeError):
                obj &lt; other
            with self.assertRaises(TypeError):
                obj &gt; other
            with self.assertRaises(TypeError):
                obj &lt;= other
            with self.assertRaises(TypeError):
                obj &gt;= other
            self.assertTrue(obj &lt; LARGEST)
            self.assertFalse(obj &gt; LARGEST)
            self.assertTrue(obj &lt;= LARGEST)
            self.assertFalse(obj &gt;= LARGEST)
            self.assertFalse(obj &lt; SMALLEST)
            self.assertTrue(obj &gt; SMALLEST)
            self.assertFalse(obj &lt;= SMALLEST)
            self.assertTrue(obj &gt;= SMALLEST)
    def test_mixed_type_key(self):
        v4_ordered = [self<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.v4addr, self.v4net, self.v4intf]
        v6_ordered = [self.v6addr, self.v6net, self.v6intf]
        v6_scoped_ordered = [self.v6addr_scoped, self.v6net_scoped, self.</b></font>v6intf_scoped]
        self.assertEqual(
            v4_ordered, sorted(self.v4_objects, key=ipaddress.get_mixed_type_key)
        )
        self.assertEqual(
            v6_ordered, sorted(self.v6_objects, key=ipaddress.get_mixed_type_key)
        )
        self.assertEqual(
            v6_scoped_ordered,
            sorted(self.v6_scoped_objects, key=ipaddress.get_mixed_type_key),
        )
        self.assertEqual(
            v4_ordered + v6_scoped_ordered,
            sorted(
                self.v4_objects + self.v6_scoped_objects,
                key=ipaddress.get_mixed_type_key,
            ),
        )
        self.assertEqual(NotImplemented, ipaddress.get_mixed_type_key(object))
    def test_incompatible_versions(self):
        v4addr = ipaddress.ip_address("1.1.1.1")
        v4net = ipaddress.ip_network("1.1.1.1")
        v6addr = ipaddress.ip_address("::1")
        v6net = ipaddress.ip_network("::1")
        v6addr_scoped = ipaddress.ip_address("::1%scope")
        v6net_scoped = ipaddress.ip_network("::1%scope")
        self.assertRaises(TypeError, v4addr.__lt__, v6addr)
        self.assertRaises(TypeError, v4addr.__gt__, v6addr)
        self.assertRaises(TypeError, v4net.__lt__, v6net)
        self.assertRaises(TypeError, v4net.__gt__, v6net)
        self.assertRaises(TypeError, v6addr.__lt__, v4addr)
        self.assertRaises(TypeError, v6addr.__gt__, v4addr)
        self.assertRaises(TypeError, v6net.__lt__, v4net)
        self.assertRaises(TypeError, v6net.__gt__, v4net)
        self.assertRaises(TypeError, v4addr.__lt__, v6addr_scoped)
        self.assertRaises(TypeError, v4addr.__gt__, v6addr_scoped)
        self.assertRaises(TypeError, v4net.__lt__, v6net_scoped)
        self.assertRaises(TypeError, v4net.__gt__, v6net_scoped)
        self.assertRaises(TypeError, v6addr_scoped.__lt__, v4addr)
        self.assertRaises(TypeError, v6addr_scoped.__gt__, v4addr)
        self.assertRaises(TypeError, v6net_scoped.__lt__, v4net)
        self.assertRaises(TypeError, v6net_scoped.__gt__, v4net)
class IpaddrUnitTest(TestCase):
    def setUp(self):
        self.ipv4_address = ipaddress<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.IPv4Address("1.2.3.4")
        self.ipv4_interface = ipaddress.IPv4Interface("1.2.3.4/24")
        self.ipv6_address = ipaddress.IPv6Interface("2001:658:22a:cafe:200:0:0:1")
        self.ipv6_interface =</b></font> ipaddress<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.IPv6Interface("2001:658:22a:cafe:200:0:0:1/64")
        self.ipv6_network = ipaddress.IPv6Network("2001:658:22a:cafe::/64")
        self.ipv6_scoped_address = ipaddress.IPv6Interface(
            "2001:658:22a:cafe:200:0:0:1%scope"
        )
        self.ipv6_scoped_interface =</b></font> ipaddress.IPv6Interface(
            "2001:658:22a:cafe:200:0:0:1%scope/64"
        )
        self.ipv6_scoped_network = ipaddress.IPv6Network("2001:658:22a:cafe::%scope/64")
    def testRepr(self):
        self.assertEqual(
            "IPv4Interface('1.2.3.4/32')", repr(ipaddress.IPv4Interface("1.2.3.4"))
        )
        self.assertEqual(
        )
        self.assertEqual(
            "IPv6Interface('::1%scope/128')", repr(ipaddress.IPv6Interface(<font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"::1%scope"))
        )
    def testIPv4Tuple(self):
        ip = ipaddress.IPv4Address("192.0.2.1")
        net = ipaddress.IPv4Network("192.0.2.1/32")
        self.assertEqual(ipaddress.IPv4Network(</b></font>("192.0.2.1", 32)), net)
        self.assertEqual(ipaddress.IPv4Network((ip, 32)), net)
        self.assertEqual(ipaddress.IPv4Network((3221225985, 32)), net)
        self.assertEqual(ipaddress.IPv4Network(("192.0.2.1", "255.255.255.255")), net)
        self.assertEqual(ipaddress.IPv4Network((ip, "255.255.255.255")), net)
        self.assertEqual(ipaddress.IPv4Network((3221225985, "255.255.255.255")), net)
        with self.assertRaises(ValueError):
            ipaddress.IPv4Network(("192.0.2.1", 24))
        with self.assertRaises(ValueError):
            ipaddress.IPv4Network((ip, 24))
        with self.assertRaises(ValueError):
            ipaddress.IPv4Network((3221225985, 24))
        with self.assertRaises(ValueError):
            ipaddress.IPv4Network(("192.0.2.1", "255.255.255.0"))
        with self.assertRaises(ValueError):
            ipaddress.IPv4Network((ip, "255.255.255.0"))
        with self.assertRaises(ValueError):
            ipaddress.IPv4Network((3221225985, "255.255.255.0"))
        net = ipaddress.IPv4Network("192.0.2.0/24")
        self.assertEqual(ipaddress.IPv4Network(("192.0.2.1", 24), strict=False), net)
        self.assertEqual(ipaddress.IPv4Network((ip, 24), strict=False), net)
        self.assertEqual(ipaddress.IPv4Network((3221225985, 24), strict=False), net)
        self.assertEqual(
            ipaddress.IPv4Network(("192.0.2.1", "255.255.255.0"), strict=False), net
        )
        self.assertEqual(
            ipaddress.IPv4Network((ip, "255.255.255.0"), strict=False), net
        )
        self.assertEqual(
            ipaddress.IPv4Network((3221225985, "255.255.255.0"), strict=False), net
        )
        ip = ipaddress.IPv4Address("192.0.2.0")
        net = ipaddress.IPv4Network("192.0.2.0/24")
        self.assertEqual(ipaddress.IPv4Network(("192.0.2.0", "255.255.255.0")), net)
        self.assertEqual(ipaddress.IPv4Network((ip, "255.255.255.0")), net)
        self.assertEqual(ipaddress.IPv4Network((3221225984, "255.255.255.0")), net)
        self.assertEqual(ipaddress.IPv4Network(("192.0.2.0", 24)), net)
        self.assertEqual(ipaddress.IPv4Network((ip, 24)), net)
        self.assertEqual(ipaddress.IPv4Network((3221225984, 24)), net)
        self.assertEqual(
            ipaddress.IPv4Interface(("192.0.2.1", 24)),
            ipaddress.IPv4Interface("192.0.2.1/24"),
        self.assertEqual(
            ipaddress.IPv4Interface((3221225985, 24)),
            ipaddress.IPv4Interface(<font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"192.0.2.1/24"),
        )
    def testIPv6Tuple(self):
        ip = ipaddress.IPv6Address("2001:db8::")
        net = ipaddress.IPv6Network("2001:db8::/128")
        self.assertEqual(ipaddress.IPv6Network(</b></font>("2001:db8::", "128")), net)
        self.assertEqual(
            ipaddress.IPv6Network((42540766411282592856903984951653826560, 128)), net
        )
        self.assertEqual(ipaddress.IPv6Network((ip, "128")), net)
        ip = ipaddress.IPv6Address("2001:db8::")
        net = ipaddress.IPv6Network("2001:db8::/96")
        self.assertEqual(ipaddress.IPv6Network(("2001:db8::", "96")), net)
        self.assertEqual(
            ipaddress.IPv6Network((42540766411282592856903984951653826560, 96)), net
        )
        self.assertEqual(ipaddress.IPv6Network((ip, "96")), net)
        ip_scoped = ipaddress.IPv6Address("2001:db8::%scope")
        ip = ipaddress.IPv6Address("2001:db8::1")
        with self.assertRaises(ValueError):
            ipaddress.IPv6Network(("2001:db8::1", 96))
        with self.assertRaises(ValueError):
            ipaddress.IPv6Network((42540766411282592856903984951653826561, 96))
        with self.assertRaises(ValueError):
            ipaddress.IPv6Network((ip, 96))
        net = ipaddress.IPv6Network("2001:db8::/96")
        self.assertEqual(ipaddress.IPv6Network(("2001:db8::1", 96), strict=False), net)
        self.assertEqual(
            ipaddress.IPv6Network(
                (42540766411282592856903984951653826561, 96), strict=False
            ),
            net,
        )
        self.assertEqual(ipaddress.IPv6Network((ip, 96), strict=False), net)
        self.assertEqual(
            ipaddress.IPv6Interface(("2001:db8::1", "96")),
            ipaddress.IPv6Interface("2001:db8::1/96"),
        )
        self.assertEqual(
            ipaddress.IPv6Interface((42540766411282592856903984951653826561, "96")),
            ipaddress.IPv6Interface("2001:db8::1/96"),
        )
        ip_scoped = ipaddress.IPv6Address("2001:db8::1%scope")
        with self.assertRaises(ValueError):
            ipaddress.IPv6Network(("2001:db8::1%scope", 96))
        with self.assertRaises(ValueError):
            ipaddress.IPv6Network((ip_scoped, 96))
    def testAddressIntMath(self):
        self.assertEqual(
            ipaddress.IPv4Address("1.1.1.1") + 255, ipaddress.IPv4Address("1.1.2.0")
        )
        self.assertEqual(
            ipaddress.IPv4Address("1.1.1.1") - 256, ipaddress.IPv4Address("1.1.0.1")
        )
        self.assertEqual(
            ipaddress.IPv6Address("::1") + (2 ** 16 - 2),
            ipaddress.IPv6Address("::ffff"),
        )
        self.assertEqual(
            ipaddress.IPv6Address("::ffff") - (2 ** 16 - 2),
            ipaddress.IPv6Address("::1"),
        )
        self.assertNotEqual(
            ipaddress.IPv6Address("::1%scope") + (2 ** 16 - 2),
            ipaddress.IPv6Address("::ffff%scope"),
        )
        self.assertNotEqual(
            ipaddress.IPv6Address("::ffff%scope") - (2 ** 16 - 2),
            ipaddress.IPv6Address("::1%scope"),
        )
    def testInvalidIntToBytes(self):
        self.assertRaises(ValueError, ipaddress.v4_int_to_packed, -1)
        self.assertRaises(
            ValueError, ipaddress.v4_int_to_packed, 2 ** ipaddress.IPV4LENGTH
        )
        self.assertRaises(ValueError, ipaddress.v6_int_to_packed, -1)
        self.assertRaises(
            ValueError, ipaddress.v6_int_to_packed, 2 ** ipaddress.IPV6LENGTH
        )
    def testInternals(self):
        ip1 = ipaddress.IPv4Address("10.10.10.10")
        ip2 = ipaddress.IPv4Address("10.10.10.11")
        ip3 = ipaddress.IPv4Address("10.10.10.12")
        self.assertEqual(list(ipaddress._find_address_range([ip1])), [(ip1, ip1)])
        self.assertEqual(
            list(ipaddress._find_address_range([ip1, ip3])), [(ip1, ip1), (ip3, ip3)]
        )
        self.assertEqual(
            list(ipaddress._find_address_range([ip1, ip2, ip3])), [(ip1, ip3)]
        )
        self.assertEqual(128, ipaddress._count_righthand_zero_bits(0, 128))
        self.assertEqual("IPv4Network('1.2.3.0/24')", repr(self.ipv4_network))
    def testGetNetwork(self):
        self.assertEqual(int(self.ipv4_network.network_address), 16909056)
        self.assertEqual(str(self.ipv4_network.network_address), "1.2.3.0")
        self.assertEqual(
            int(self.ipv6_network.network_address),
            42540616829182469433403647294022090752,
        )
        self.assertEqual(str(self.ipv6_network.network_address), "2001:658:22a:cafe::")
        self.assertEqual(str(self.ipv6_network.hostmask), "::ffff:ffff:ffff:ffff")
        self.assertEqual(
            int(self.ipv6_scoped_network.network_address),
            42540616829182469433403647294022090752,
        )
        self.assertEqual(
            str(self.ipv6_scoped_network.network_address), "2001:658:22a:cafe::%scope"
        )
        self.assertEqual(
            str(self.ipv6_scoped_network.hostmask), "::ffff:ffff:ffff:ffff"
        )
    def testIpFromInt(self):
        self.assertEqual(self.ipv4_interface._ip, ipaddress.IPv4Interface(16909060)._ip)
        ipv4 = ipaddress.ip_network("1.2.3.4")
        ipv6 = ipaddress.ip_network("2001:658:22a:cafe:200:0:0:1")
        ipv6_scoped = ipaddress.ip_network("2001:658:22a:cafe:200:0:0:1%scope")
        self.assertEqual(ipv4, ipaddress.ip_network(int(ipv4.network_address)))
        self.assertEqual(ipv6, ipaddress.ip_network(int(ipv6.network_address)))
        self.assertNotEqual(
            ipv6_scoped, ipaddress.ip_network(int(ipv6_scoped.network_address))
        )
        v6_int = 42540616829182469433547762482097946625
        self.assertEqual(self.ipv6_interface._ip, ipaddress.IPv6Interface(v6_int)._ip)
        self.assertEqual(
            self.ipv6_scoped_interface._ip, ipaddress.IPv6Interface(v6_int)._ip
        )
        self.assertEqual(ipaddress.ip_network(self.ipv4_address._ip).version, 4)
        self.assertEqual(ipaddress.ip_network(self.ipv6_address._ip).version, 6)
        self.assertEqual(ipaddress.ip_network(self.ipv6_scoped_address._ip).version, 6)
    def testIpFromPacked(self):
        address = ipaddress.ip_address
        self.assertEqual(
            self.ipv4_interface._ip, ipaddress.ip_interface(b"\x01\x02\x03\x04")._ip
        )
        self.assertEqual(address("255.254.253.252"), address(b"\xff\xfe\xfd\xfc"))
        self.assertEqual(
            self.ipv6_interface.ip,
            ipaddress.ip_interface(
                b"\x20\x01\x06\x58\x02\x2a\xca\xfe\x02\x00\x00\x00\x00\x00\x00\x01"
            ).ip,
        )
        self.assertEqual(
            address("ffff:2:3:4:ffff::"),
            address(b"\xff\xff\x00\x02\x00\x03\x00\x04" + b"\xff\xff" + b"\x00" * 6),
        )
        self.assertEqual(address("::"), address(b"\x00" * 16))
    def testGetIp(self):
        self.assertEqual(int(self.ipv4_interface.ip), 16909060)
        self.assertEqual(str(self.ipv4_interface.ip), "1.2.3.4")
        self.assertEqual(
            int(self.ipv6_interface.ip), 42540616829182469433547762482097946625
        )
        self.assertEqual(str(self.ipv6_interface.ip), "2001:658:22a:cafe:200::1")
        self.assertEqual(
            int(self.ipv6_scoped_interface.ip), 42540616829182469433547762482097946625
        )
        self.assertEqual(str(self.ipv6_scoped_interface.ip), "2001:658:22a:cafe:200::1")
    def testGetScopeId(self):
        self.assertEqual(self.ipv6_address.scope_id, None)
        self.assertEqual(str(self.ipv6_scoped_address.scope_id), "scope")
        self.assertEqual(self.ipv6_interface.scope_id, None)
        self.assertEqual(str(self.ipv6_scoped_interface.scope_id), "scope")
        self.assertEqual(self.ipv6_network.network_address.scope_id, None)
        self.assertEqual(
            str(self.ipv6_scoped_network.network_address.scope_id), "scope"
        )
    def testGetNetmask(self):
        self.assertEqual(int(self.ipv4_network.netmask), 4294967040)
        self.assertEqual(str(self.ipv4_network.netmask), "255.255.255.0")
        self.assertEqual(
            int(self.ipv6_network.netmask), 340282366920938463444927863358058659840
        )
        self.assertEqual(self.ipv6_network.prefixlen, 64)
        self.assertEqual(
            int(self.ipv6_scoped_network.netmask),
            340282366920938463444927863358058659840,
        )
        self.assertEqual(self.ipv6_scoped_network.prefixlen, 64)
    def testZeroNetmask(self):
        ipv4_zero_netmask = ipaddress.IPv4Interface("1.2.3.4/0")
        self.assertEqual(int(ipv4_zero_netmask.network.netmask), 0)
        self.assertEqual(ipv4_zero_netmask._prefix_from_prefix_string("0"), 0)
        ipv6_zero_netmask = ipaddress.IPv6Interface("::1/0")
        self.assertEqual(int(ipv6_zero_netmask.network.netmask), 0)
        self.assertEqual(ipv6_zero_netmask._prefix_from_prefix_string("0"), 0)
        ipv6_scoped_zero_netmask = ipaddress.IPv6Interface("::1%scope/0")
        self.assertEqual(int(ipv6_scoped_zero_netmask.network.netmask), 0)
        self.assertEqual(ipv6_scoped_zero_netmask._prefix_from_prefix_string("0"), 0)
    def testIPv4Net(self):
        net = ipaddress.IPv4Network("127.0.0.0/0.0.0.255")
        self.assertEqual(net.prefixlen, 24)
    def testGetBroadcast(self):
        self.assertEqual(int(self.ipv4_network.broadcast_address), 16909311)
        self.assertEqual(str(self.ipv4_network.broadcast_address), "1.2.3.255")
        self.assertEqual(
            int(self.ipv6_network.broadcast_address),
            42540616829182469451850391367731642367,
        )
        self.assertEqual(
            str(self.ipv6_network.broadcast_address),
            "2001:658:22a:cafe:ffff:ffff:ffff:ffff",
        )
        self.assertEqual(
            int(self.ipv6_scoped_network.broadcast_address),
            42540616829182469451850391367731642367,
        )
        self.assertEqual(
            str(self.ipv6_scoped_network.broadcast_address),
            "2001:658:22a:cafe:ffff:ffff:ffff:ffff",
        )
    def testGetPrefixlen(self):
        self.assertEqual(self.ipv4_interface.network.prefixlen, 24)
        self.assertEqual(self.ipv6_interface.network.prefixlen, 64)
        self.assertEqual(self.ipv6_scoped_interface.network.prefixlen, 64)
    def testGetSupernet(self):
        self.assertEqual(self.ipv4_network.supernet().prefixlen, 23)
        self.assertEqual(str(self.ipv4_network.supernet().network_address), "1.2.2.0")
        self.assertEqual(
            ipaddress.IPv4Interface("0.0.0.0/0").network.supernet(),
            ipaddress.IPv4Network("0.0.0.0/0"),
        )
        self.assertEqual(self.ipv6_network.supernet().prefixlen, 63)
        self.assertEqual(
            str(self.ipv6_network.supernet().network_address), "2001:658:22a:cafe::"
        )
        self.assertEqual(
            ipaddress.IPv6Interface("::0/0").network.supernet(),
            ipaddress.IPv6Network("::0/0"),
        )
        self.assertEqual(self.ipv6_scoped_network.supernet().prefixlen, 63)
        self.assertEqual(
            str(self.ipv6_scoped_network.supernet().network_address),
            "2001:658:22a:cafe::",
        )
    def testGetSupernet3(self):
        self.assertEqual(self.ipv4_network.supernet(3).prefixlen, 21)
        self.assertEqual(str(self.ipv4_network.supernet(3).network_address), "1.2.0.0")
        self.assertEqual(self.ipv6_network.supernet(3).prefixlen, 61)
        self.assertEqual(
            str(self.ipv6_network.supernet(3).network_address), "2001:658:22a:caf8::"
        )
        self.assertEqual(self.ipv6_scoped_network.supernet(3).prefixlen, 61)
        self.assertEqual(
            str(self.ipv6_scoped_network.supernet(3).network_address),
            "2001:658:22a:caf8::",
        )
    def testGetSupernet4(self):
        self.assertRaises(
            ValueError, self.ipv4_network.supernet, prefixlen_diff=2, new_prefix=1
        )
        self.assertRaises(ValueError, self.ipv4_network.supernet, new_prefix=25)
        self.assertEqual(
            self.ipv4_network.supernet(prefixlen_diff=2),
            self.ipv4_network.supernet(new_prefix=22),
        )
        self.assertRaises(
            ValueError, self.ipv6_network.supernet, prefixlen_diff=2, new_prefix=1
        )
        self.assertRaises(ValueError, self.ipv6_network.supernet, new_prefix=65)
        self.assertEqual(
            self.ipv6_network.supernet(prefixlen_diff=2),
            self.ipv6_network.supernet(new_prefix=62),
        )
        self.assertRaises(
            ValueError,
            self.ipv6_scoped_network.supernet,
            prefixlen_diff=2,
            new_prefix=1,
        )
        self.assertRaises(ValueError, self.ipv6_scoped_network.supernet, new_prefix=65)
        self.assertEqual(
            self.ipv6_scoped_network.supernet(prefixlen_diff=2),
            self.ipv6_scoped_network.supernet(new_prefix=62),
        )
    def testHosts(self):
        hosts = list(self.ipv4_network.hosts())
        self.assertEqual(254, len(hosts))
        self.assertEqual(ipaddress.IPv4Address("1.2.3.1"), hosts[0])
        self.assertEqual(ipaddress.IPv4Address("1.2.3.254"), hosts[-1])
        ipv6_network = ipaddress.IPv6Network("2001:658:22a:cafe::/120")
        hosts = list(ipv6_network.hosts())
        self.assertEqual(255, len(hosts))
        self.assertEqual(ipaddress.IPv6Address("2001:658:22a:cafe::1"), hosts[0])
        self.assertEqual(ipaddress.IPv6Address("2001:658:22a:cafe::ff"), hosts[-1])
        ipv6_scoped_network = ipaddress.IPv6Network("2001:658:22a:cafe::%scope/120")
        hosts = list(ipv6_scoped_network.hosts())
        self.assertEqual(255, len(hosts))
        self.assertEqual(ipaddress.IPv6Address("2001:658:22a:cafe::1"), hosts[0])
        self.assertEqual(ipaddress.IPv6Address("2001:658:22a:cafe::ff"), hosts[-1])
        addrs = [ipaddress.IPv4Address("2.0.0.0"), ipaddress.IPv4Address("2.0.0.1")]
        str_args = "2.0.0.0/31"
        tpl_args = ("2.0.0.0", 31)
        self.assertEqual(addrs, list(ipaddress.ip_network(str_args).hosts()))
        self.assertEqual(addrs, list(ipaddress.ip_network(tpl_args).hosts()))
        self.assertEqual(
            list(ipaddress.ip_network(str_args).hosts()),
            list(ipaddress.ip_network(tpl_args).hosts()),
        )
        addrs = [ipaddress.IPv4Address("1.2.3.4")]
        str_args = "1.2.3.4/32"
        tpl_args = ("1.2.3.4", 32)
        self.assertEqual(addrs, list(ipaddress.ip_network(str_args).hosts()))
        self.assertEqual(addrs, list(ipaddress.ip_network(tpl_args).hosts()))
        self.assertEqual(
            list(ipaddress.ip_network(str_args).hosts()),
            list(ipaddress.ip_network(tpl_args).hosts()),
        )
        addrs = [
            ipaddress.IPv6Address("2001:658:22a:cafe::"),
            ipaddress.IPv6Address("2001:658:22a:cafe::1"),
        ]
        str_args = "2001:658:22a:cafe::/127"
        tpl_args = ("2001:658:22a:cafe::", 127)
        self.assertEqual(addrs, list(ipaddress.ip_network(str_args).hosts()))
        self.assertEqual(addrs, list(ipaddress.ip_network(tpl_args).hosts()))
        self.assertEqual(
            list(ipaddress.ip_network(str_args).hosts()),
            list(ipaddress.ip_network(tpl_args).hosts()),
        )
        addrs = [
            ipaddress.IPv6Address("2001:658:22a:cafe::1"),
        ]
        str_args = "2001:658:22a:cafe::1/128"
        tpl_args = ("2001:658:22a:cafe::1", 128)
        self.assertEqual(addrs, list(ipaddress.ip_network(str_args).hosts()))
        self.assertEqual(addrs, list(ipaddress.ip_network(tpl_args).hosts()))
        self.assertEqual(
            list(ipaddress.ip_network(str_args).hosts()),
            list(ipaddress.ip_network(tpl_args).hosts()),
        )
    def testFancySubnetting(self):
        self.assertEqual(
            sorted(self.ipv4_network.subnets(prefixlen_diff=3)),
            sorted(self.ipv4_network.subnets(new_prefix=27)),
        )
        self.assertRaises(ValueError, list, self.ipv4_network.subnets(new_prefix=23))
        self.assertRaises(
            ValueError, list, self.ipv4_network.subnets(prefixlen_diff=3, new_prefix=27)
        )
        self.assertEqual(
            sorted(self.ipv6_network.subnets(prefixlen_diff=4)),
            sorted(self.ipv6_network.subnets(new_prefix=68)),
        )
        self.assertRaises(ValueError, list, self.ipv6_network.subnets(new_prefix=63))
        self.assertRaises(
            ValueError, list, self.ipv6_network.subnets(prefixlen_diff=4, new_prefix=68)
        )
        self.assertEqual(
            sorted(self.ipv6_scoped_network.subnets(prefixlen_diff=4)),
            sorted(self.ipv6_scoped_network.subnets(new_prefix=68)),
        )
        self.assertRaises(
            ValueError, list, self.ipv6_scoped_network.subnets(new_prefix=63)
        )
        self.assertRaises(
            ValueError,
            list,
            self.ipv6_scoped_network.subnets(prefixlen_diff=4, new_prefix=68),
        )
    def testGetSubnets(self):
        self.assertEqual(list(self.ipv4_network.subnets())[0].prefixlen, 25)
        self.assertEqual(
            str(list(self.ipv4_network.subnets())[0].network_address), "1.2.3.0"
        )
        self.assertEqual(
            str(list(self.ipv4_network.subnets())[1].network_address), "1.2.3.128"
        )
        self.assertEqual(list(self.ipv6_network.subnets())[0].prefixlen, 65)
        self.assertEqual(list(self.ipv6_scoped_network.subnets())[0].prefixlen, 65)
    def testGetSubnetForSingle32(self):
        ip = ipaddress.IPv4Network("1.2.3.4/32")
        subnets1 = [str(x) for x in ip.subnets()]
        subnets2 = [str(x) for x in ip.subnets(2)]
        self.assertEqual(subnets1, ["1.2.3.4/32"])
        self.assertEqual(subnets1, subnets2)
    def testGetSubnetForSingle128(self):
        ip = ipaddress.IPv6Network("::1/128")
        subnets1 = [str(x) for x in ip.subnets()]
        subnets2 = [str(x) for x in ip.subnets(2)]
        self.assertEqual(subnets1, ["::1/128"])
        self.assertEqual(subnets1, subnets2)
        ip_scoped = ipaddress.IPv6Network("::1%scope/128")
        subnets1 = [str(x) for x in ip_scoped.subnets()]
        subnets2 = [str(x) for x in ip_scoped.subnets(2)]
        self.assertEqual(subnets1, ["::1%scope/128"])
        self.assertEqual(subnets1, subnets2)
    def testSubnet2(self):
        ips = [str(x) for x in self.ipv4_network.subnets(2)]
        self.assertEqual(
            ips, ["1.2.3.0/26", "1.2.3.64/26", "1.2.3.128/26", "1.2.3.192/26"]
        )
        ipsv6 = [str(x) for x in self.ipv6_network.subnets(2)]
        self.assertEqual(
            ipsv6,
            [
                "2001:658:22a:cafe::/66",
                "2001:658:22a:cafe:4000::/66",
                "2001:658:22a:cafe:8000::/66",
                "2001:658:22a:cafe:c000::/66",
            ],
        )
    def testGetSubnets3(self):
        subnets = [str(x) for x in self.ipv4_network.subnets(8)]
        self.assertEqual(subnets[:3], ["1.2.3.0/32", "1.2.3.1/32", "1.2.3.2/32"])
        self.assertEqual(subnets[-3:], ["1.2.3.253/32", "1.2.3.254/32", "1.2.3.255/32"])
        self.assertEqual(len(subnets), 256)
        ipv6_network = ipaddress.IPv6Network("2001:658:22a:cafe::/120")
        subnets = [str(x) for x in ipv6_network.subnets(8)]
        self.assertEqual(
            subnets[:3],
            [
                "2001:658:22a:cafe::/128",
                "2001:658:22a:cafe::1/128",
                "2001:658:22a:cafe::2/128",
            ],
        )
        self.assertEqual(
            subnets[-3:],
            [
                "2001:658:22a:cafe::fd/128",
                "2001:658:22a:cafe::fe/128",
                "2001:658:22a:cafe::ff/128",
            ],
        )
        self.assertEqual(len(subnets), 256)
    def testSubnetFailsForLargeCidrDiff(self):
        self.assertRaises(ValueError, list, self.ipv4_interface.network.subnets(9))
        self.assertRaises(ValueError, list, self.ipv4_network.subnets(9))
        self.assertRaises(ValueError, list, self.ipv6_interface.network.subnets(65))
        self.assertRaises(ValueError, list, self.ipv6_network.subnets(65))
        self.assertRaises(
            ValueError, list, self.ipv6_scoped_interface.network.subnets(65)
        )
        self.assertRaises(ValueError, list, self.ipv6_scoped_network.subnets(65))
    def testSupernetFailsForLargeCidrDiff(self):
        self.assertRaises(ValueError, self.ipv4_interface.network.supernet, 25)
        self.assertRaises(ValueError, self.ipv6_interface.network.supernet, 65)
        self.assertRaises(ValueError, self.ipv6_scoped_interface.network.supernet, 65)
    def testSubnetFailsForNegativeCidrDiff(self):
        self.assertRaises(ValueError, list, self.ipv4_interface.network.subnets(-1))
        self.assertRaises(ValueError, list, self.ipv4_network.subnets(-1))
        self.assertRaises(ValueError, list, self.ipv6_interface.network.subnets(-1))
        self.assertRaises(ValueError, list, self.ipv6_network.subnets(-1))
        self.assertRaises(
            ValueError, list, self.ipv6_scoped_interface.network.subnets(-1)
        )
        self.assertRaises(ValueError, list, self.ipv6_scoped_network.subnets(-1))
    def testGetNum_Addresses(self):
        self.assertEqual(self.ipv4_network.num_addresses, 256)
        self.assertEqual(list(self.ipv4_network.subnets())[0].num_addresses, 128)
        self.assertEqual(self.ipv4_network.supernet().num_addresses, 512)
        self.assertEqual(self.ipv6_network.num_addresses, 18446744073709551616)
        self.assertEqual(
            list(self.ipv6_network.subnets())[0].num_addresses, 9223372036854775808
        )
        self.assertEqual(
            self.ipv6_network.supernet().num_addresses, 36893488147419103232
        )
        self.assertEqual(self.ipv6_scoped_network.num_addresses, 18446744073709551616)
        self.assertEqual(
            list(self.ipv6_scoped_network.subnets())[0].num_addresses,
            9223372036854775808,
        )
        self.assertEqual(
            self.ipv6_scoped_network.supernet().num_addresses, 36893488147419103232
        )
    def testContains(self):
        self.assertIn(ipaddress.IPv4Interface("1.2.3.128/25"), self.ipv4_network)
        self.assertNotIn(ipaddress.IPv4Interface("1.2.4.1/24"), self.ipv4_network)
        addr1 = ipaddress.IPv4Address("1.2.3.37")
        self.assertIn(addr1, self.ipv4_network)
        self.assertFalse(
            ipaddress.IPv4Network("1.1.0.0/16").__contains__(
                ipaddress.IPv4Network("1.0.0.0/15")
            )
        )
    def testNth(self):
        self.assertEqual(str(self.ipv4_network[5]), "1.2.3.5")
        self.assertRaises(IndexError, self.ipv4_network.__getitem__, 256)
        self.assertEqual(str(self.ipv6_network[5]), "2001:658:22a:cafe::5")
        self.assertRaises(IndexError, self.ipv6_network.__getitem__, 1 &lt;&lt; 64)
        self.assertEqual(str(self.ipv6_scoped_network[5]), "2001:658:22a:cafe::5")
        self.assertRaises(IndexError, self.ipv6_scoped_network.__getitem__, 1 &lt;&lt; 64)
    def testGetitem(self):
        addr = ipaddress.IPv4Network("172.31.255.128/255.255.255.240")
        self.assertEqual(28, addr.prefixlen)
        addr_list = list(addr)
        self.assertEqual("172.31.255.128", str(addr_list[0]))
        self.assertEqual("172.31.255.128", str(addr[0]))
        self.assertEqual("172.31.255.143", str(addr_list[-1]))
        self.assertEqual("172.31.255.143", str(addr[-1]))
        self.assertEqual(addr_list[-1], addr[-1])
    def testEqual(self):
        self.assertTrue(self.ipv4_interface == ipaddress.IPv4Interface("1.2.3.4/24"))
        self.assertFalse(self.ipv4_interface == ipaddress.IPv4Interface("1.2.3.4/23"))
        self.assertFalse(self.ipv4_interface == ipaddress.IPv6Interface("::1.2.3.4/24"))
        self.assertFalse(
            self.ipv4_interface == ipaddress.IPv6Interface("::1.2.3.4%scope/24")
        )
        self.assertFalse(self.ipv4_interface == "")
        self.assertFalse(self.ipv4_interface == [])
        self.assertFalse(self.ipv4_interface == 2)
        self.assertTrue(
            self.ipv6_interface
            == ipaddress.IPv6Interface("2001:658:22a:cafe:200::1/64")
        )
        self.assertFalse(
            self.ipv6_interface
            == ipaddress.IPv6Interface("2001:658:22a:cafe:200::1/63")
        )
        self.assertFalse(self.ipv6_interface == ipaddress.IPv4Interface("1.2.3.4/23"))
        self.assertFalse(self.ipv6_interface == "")
        self.assertFalse(self.ipv6_interface == [])
        self.assertFalse(self.ipv6_interface == 2)
        self.assertTrue(
            self.ipv6_scoped_interface
            == ipaddress.IPv6Interface("2001:658:22a:cafe:200::1%scope/64")
        )
        self.assertFalse(
            self.ipv6_scoped_interface
            == ipaddress.IPv6Interface("2001:658:22a:cafe:200::1%scope/63")
        )
        self.assertFalse(
            self.ipv6_scoped_interface
            == ipaddress.IPv6Interface("2001:658:22a:cafe:200::1/64")
        )
        self.assertFalse(
            self.ipv6_scoped_interface
            == ipaddress.IPv6Interface("2001:658:22a:cafe:200::1/63")
        )
        self.assertFalse(
            self.ipv6_scoped_interface == ipaddress.IPv4Interface("1.2.3.4/23")
        )
        self.assertFalse(self.ipv6_scoped_interface == "")
        self.assertFalse(self.ipv6_scoped_interface == [])
        self.assertFalse(self.ipv6_scoped_interface == 2)
    def testNotEqual(self):
        self.assertFalse(self.ipv4_interface != ipaddress.IPv4Interface("1.2.3.4/24"))
        self.assertTrue(self.ipv4_interface != ipaddress.IPv4Interface("1.2.3.4/23"))
        self.assertTrue(self.ipv4_interface != ipaddress.IPv6Interface("::1.2.3.4/24"))
        self.assertTrue(
            self.ipv4_interface != ipaddress.IPv6Interface("::1.2.3.4%scope/24")
        )
        self.assertTrue(self.ipv4_interface != "")
        self.assertTrue(self.ipv4_interface != [])
        self.assertTrue(self.ipv4_interface != 2)
        self.assertTrue(self.ipv4_address != ipaddress.IPv4Address("1.2.3.5"))
        self.assertTrue(self.ipv4_address != "")
        self.assertTrue(self.ipv4_address != [])
        self.assertTrue(self.ipv4_address != 2)
        self.assertFalse(
            self.ipv6_interface
            != ipaddress.IPv6Interface("2001:658:22a:cafe:200::1/64")
        )
        self.assertTrue(
            self.ipv6_interface
            != ipaddress.IPv6Interface("2001:658:22a:cafe:200::1/63")
        )
        self.assertTrue(self.ipv6_interface != ipaddress.IPv4Interface("1.2.3.4/23"))
        self.assertTrue(self.ipv6_interface != "")
        self.assertTrue(self.ipv6_interface != [])
        self.assertTrue(self.ipv6_interface != 2)
        self.assertTrue(self.ipv6_address != ipaddress.IPv4Address("1.2.3.4"))
        self.assertTrue(self.ipv6_address != "")
        self.assertTrue(self.ipv6_address != [])
        self.assertTrue(self.ipv6_address != 2)
        self.assertFalse(
            self.ipv6_scoped_interface
            != ipaddress.IPv6Interface("2001:658:22a:cafe:200::1%scope/64")
        )
        self.assertTrue(
            self.ipv6_scoped_interface
            != ipaddress.IPv6Interface("2001:658:22a:cafe:200::1%scope/63")
        )
        self.assertTrue(
            self.ipv6_scoped_interface
            != ipaddress.IPv6Interface("2001:658:22a:cafe:200::1/64")
        )
        self.assertTrue(
            self.ipv6_scoped_interface
            != ipaddress.IPv6Interface("2001:658:22a:cafe:200::1/63")
        )
        self.assertTrue(
            self.ipv6_scoped_interface != ipaddress.IPv4Interface("1.2.3.4/23")
        )
        self.assertTrue(self.ipv6_scoped_interface != "")
        self.assertTrue(self.ipv6_scoped_interface != [])
        self.assertTrue(self.ipv6_scoped_interface != 2)
        self.assertTrue(self.ipv6_scoped_address != ipaddress.IPv4Address("1.2.3.4"))
        self.assertTrue(self.ipv6_scoped_address != "")
        self.assertTrue(self.ipv6_scoped_address != [])
        self.assertTrue(self.ipv6_scoped_address != 2)
    def testSlash32Constructor(self):
        self.assertEqual(
            str(ipaddress.IPv4Interface("1.2.3.4/255.255.255.255")), "1.2.3.4/32"
        )
    def testSlash128Constructor(self):
        self.assertEqual(str(ipaddress.IPv6Interface("::1/128")), "::1/128")
        self.assertEqual(str(ipaddress.IPv6Interface("::1%scope/128")), "::1%scope/128")
    def testSlash0Constructor(self):
        self.assertEqual(str(ipaddress.IPv4Interface("1.2.3.4/0.0.0.0")), "1.2.3.4/0")
    def testCollapsing(self):
        ip1 = ipaddress.IPv4Address("1.1.1.0")
        ip2 = ipaddress.IPv4Address("1.1.1.1")
        ip3 = ipaddress.IPv4Address("1.1.1.2")
        ip4 = ipaddress.IPv4Address("1.1.1.3")
        ip5 = ipaddress.IPv4Address("1.1.1.4")
        ip6 = ipaddress.IPv4Address("1.1.1.0")
        collapsed = ipaddress.collapse_addresses([ip1, ip2, ip3, ip4, ip5, ip6])
        self.assertEqual(
            list(collapsed),
            [ipaddress.IPv4Network("1.1.1.0/30"), ipaddress.IPv4Network("1.1.1.4/32")],
        )
        ip1 = ipaddress.IPv4Address("1.1.1.0")
        ip2 = ipaddress.IPv4Address("1.1.1.1")
        ip3 = ipaddress.IPv4Address("1.1.1.2")
        ip4 = ipaddress.IPv4Address("1.1.1.3")
        collapsed = ipaddress.collapse_addresses([ip1, ip2, ip3, ip4])
        self.assertEqual(list(collapsed), [ipaddress.IPv4Network("1.1.1.0/30")])
        ip1 = ipaddress.IPv4Network("1.1.0.0/24")
        ip2 = ipaddress.IPv4Network("1.1.1.0/24")
        ip3 = ipaddress.IPv4Network("1.1.2.0/24")
        ip4 = ipaddress.IPv4Network("1.1.3.0/24")
        ip5 = ipaddress.IPv4Network("1.1.4.0/24")
        ip6 = ipaddress.IPv4Network("1.1.0.0/22")
        collapsed = ipaddress.collapse_addresses([ip1, ip2, ip3, ip4, ip5, ip6])
        self.assertEqual(
            list(collapsed),
            [ipaddress.IPv4Network("1.1.0.0/22"), ipaddress.IPv4Network("1.1.4.0/24")],
        )
        collapsed = ipaddress.collapse_addresses([ip1, ip2])
        self.assertEqual(list(collapsed), [ipaddress.IPv4Network("1.1.0.0/23")])
        ip_same1 = ip_same2 = ipaddress.IPv4Network("1.1.1.1/32")
        self.assertEqual(
            list(ipaddress.collapse_addresses([ip_same1, ip_same2])), [ip_same1]
        )
        ip_same1 = ip_same2 = ipaddress.IPv4Address("1.1.1.1")
        self.assertEqual(
            list(ipaddress.collapse_addresses([ip_same1, ip_same2])),
            [ipaddress.ip_network("1.1.1.1/32")],
        )
        ip1 = ipaddress.IPv6Network("2001::/100")
        ip2 = ipaddress.IPv6Network("2001::/120")
        ip3 = ipaddress.IPv6Network("2001::/96")
        collapsed = ipaddress.collapse_addresses([ip1, ip2, ip3])
        self.assertEqual(list(collapsed), [ip3])
        ip1 = ipaddress.IPv6Network("2001::%scope/100")
        ip2 = ipaddress.IPv6Network("2001::%scope/120")
        ip3 = ipaddress.IPv6Network("2001::%scope/96")
        collapsed = ipaddress.collapse_addresses([ip1, ip2, ip3])
        self.assertEqual(list(collapsed), [ip3])
        addr_tuples = [
            (ipaddress.ip_address("1.1.1.1"), ipaddress.ip_address("::1")),
            (ipaddress.IPv4Network("1.1.0.0/24"), ipaddress.IPv6Network("2001::/120")),
            (ipaddress.IPv4Network("1.1.0.0/32"), ipaddress.IPv6Network("2001::/128")),
        ]
        for ip1, ip2 in addr_tuples:
            self.assertRaises(TypeError, ipaddress.collapse_addresses, [ip1, ip2])
        addr_tuples = [
            (ipaddress.ip_address("1.1.1.1"), ipaddress.ip_address("::1%scope")),
            (
                ipaddress.IPv4Network("1.1.0.0/24"),
                ipaddress.IPv6Network("2001::%scope/120"),
            ),
            (
                ipaddress.IPv4Network("1.1.0.0/32"),
                ipaddress.IPv6Network("2001::%scope/128"),
            ),
        ]
        for ip1, ip2 in addr_tuples:
            self.assertRaises(TypeError, ipaddress.collapse_addresses, [ip1, ip2])
    def testSummarizing(self):
        summarize = ipaddress.summarize_address_range
        ip1 = ipaddress.ip_address("1.1.1.0")
        ip2 = ipaddress.ip_address("1.1.1.255")
        class IPv7Address(ipaddress.IPv6Address):
            @property
            def version(self):
                return 7
        ip_invalid1 = IPv7Address("::1")
        ip_invalid2 = IPv7Address("::1")
        self.assertRaises(ValueError, list, summarize(ip_invalid1, ip_invalid2))
        self.assertRaises(TypeError, list, summarize(ip1, ipaddress.IPv6Address("::1")))
        self.assertRaises(
            TypeError, list, summarize(ip1, ipaddress.IPv6Address("::1%scope"))
        )
        self.assertEqual(
            list(summarize(ip1, ip2))[0], ipaddress.ip_network("1.1.1.0/24")
        )
        ip2 = ipaddress.ip_address("1.1.1.8")
        self.assertEqual(
            list(summarize(ip1, ip2)),
            [ipaddress.ip_network("1.1.1.0/29"), ipaddress.ip_network("1.1.1.8")],
        )
        ip1 = ipaddress.IPv4Address(0)
        ip2 = ipaddress.IPv4Address(ipaddress.IPv4Address._ALL_ONES)
        self.assertEqual(
            [ipaddress.IPv4Network("0.0.0.0/0")], list(summarize(ip1, ip2))
        )
        ip1 = ipaddress.ip_address("1::")
        ip2 = ipaddress.ip_address("1:ffff:ffff:ffff:ffff:ffff:ffff:ffff")
        self.assertEqual(list(summarize(ip1, ip2))[0], ipaddress.ip_network("1::/16"))
        ip2 = ipaddress.ip_address("2::")
        self.assertEqual(
            list(summarize(ip1, ip2)),
            [ipaddress.ip_network("1::/16"), ipaddress.ip_network("2::/128")],
        )
        ip1 = ipaddress.ip_address("1::%scope")
        ip2 = ipaddress.ip_address("1:ffff:ffff:ffff:ffff:ffff:ffff:ffff%scope")
        self.assertEqual(list(summarize(ip1, ip2))[0], ipaddress.ip_network("1::/16"))
        ip2 = ipaddress.ip_address("2::%scope")
        self.assertEqual(
            list(summarize(ip1, ip2)),
            [ipaddress.ip_network("1::/16"), ipaddress.ip_network("2::/128")],
        )
        self.assertRaises(
            ValueError,
            list,
            summarize(ipaddress.ip_address("1.1.1.0"), ipaddress.ip_address("1.1.0.0")),
        )
        self.assertRaises(
            TypeError,
            list,
            summarize(ipaddress.ip_network("1.1.1.0"), ipaddress.ip_network("1.1.0.0")),
        )
        self.assertRaises(
            TypeError,
            list,
            summarize(ipaddress.ip_network("1.1.1.0"), ipaddress.ip_network("1.1.0.0")),
        )
        self.assertRaises(
            TypeError,
            list,
            summarize(ipaddress.ip_address("::"), ipaddress.ip_network("1.1.0.0")),
        )
    def testAddressComparison(self):
        self.assertTrue(
            ipaddress.ip_address("1.1.1.1") &lt;= ipaddress.ip_address("1.1.1.1")
        )
        self.assertTrue(
            ipaddress.ip_address("1.1.1.1") &lt;= ipaddress.ip_address("1.1.1.2")
        )
        self.assertTrue(ipaddress.ip_address("::1") &lt;= ipaddress.ip_address("::1"))
        self.assertTrue(ipaddress.ip_address("::1") &lt;= ipaddress.ip_address("::2"))
        self.assertTrue(
            ipaddress.ip_address("::1%scope") &lt;= ipaddress.ip_address("::1%scope")
        )
        self.assertTrue(
            ipaddress.ip_address("::1%scope") &lt;= ipaddress.ip_address("::2%scope")
        )
    def testInterfaceComparison(self):
        self.assertTrue(
            ipaddress.ip_interface("1.1.1.1/24") == ipaddress.ip_interface("1.1.1.1/24")
        )
        self.assertTrue(
            ipaddress.ip_interface("1.1.1.1/16") &lt; ipaddress.ip_interface("1.1.1.1/24")
        )
        self.assertTrue(
            ipaddress.ip_interface("1.1.1.1/24") &lt; ipaddress.ip_interface("1.1.1.2/24")
        )
        self.assertTrue(
            ipaddress.ip_interface("1.1.1.2/16") &lt; ipaddress.ip_interface("1.1.1.1/24")
        )
        self.assertTrue(
            ipaddress.ip_interface("1.1.1.1/24") &gt; ipaddress.ip_interface("1.1.1.1/16")
        )
        self.assertTrue(
            ipaddress.ip_interface("1.1.1.2/24") &gt; ipaddress.ip_interface("1.1.1.1/24")
        )
        self.assertTrue(
            ipaddress.ip_interface("1.1.1.1/24") &gt; ipaddress.ip_interface("1.1.1.2/16")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1/64") == ipaddress.ip_interface("::1/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1/64") &lt; ipaddress.ip_interface("::1/80")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1/64") &lt; ipaddress.ip_interface("::2/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::2/48") &lt; ipaddress.ip_interface("::1/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1/80") &gt; ipaddress.ip_interface("::1/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::2/64") &gt; ipaddress.ip_interface("::1/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1/64") &gt; ipaddress.ip_interface("::2/48")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1%scope/64")
            == ipaddress.ip_interface("::1%scope/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1%scope/64")
            &lt; ipaddress.ip_interface("::1%scope/80")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1%scope/64")
            &lt; ipaddress.ip_interface("::2%scope/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::2%scope/48")
            &lt; ipaddress.ip_interface("::1%scope/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1%scope/80")
            &gt; ipaddress.ip_interface("::1%scope/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::2%scope/64")
            &gt; ipaddress.ip_interface("::1%scope/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1%scope/64")
            &gt; ipaddress.ip_interface("::2%scope/48")
        )
        self.assertFalse(
            ipaddress.ip_interface("::1%scope/64") == ipaddress.ip_interface("::1/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1%scope/64") &lt; ipaddress.ip_interface("::1/80")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1%scope/64") &lt; ipaddress.ip_interface("::2/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::2%scope/48") &lt; ipaddress.ip_interface("::1/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1%scope/80") &gt; ipaddress.ip_interface("::1/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::2%scope/64") &gt; ipaddress.ip_interface("::1/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1%scope/64") &gt; ipaddress.ip_interface("::2/48")
        )
        self.assertFalse(
            ipaddress.ip_interface("::1/64") == ipaddress.ip_interface("::1%scope/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1/64") &lt; ipaddress.ip_interface("::1%scope/80")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1/64") &lt; ipaddress.ip_interface("::2%scope/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::2/48") &lt; ipaddress.ip_interface("::1%scope/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1/80") &gt; ipaddress.ip_interface("::1%scope/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::2/64") &gt; ipaddress.ip_interface("::1%scope/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1/64") &gt; ipaddress.ip_interface("::2%scope/48")
        )
    def testNetworkComparison(self):
        ip1 = ipaddress.IPv4Network("1.1.1.0/24")
        ip2 = ipaddress.IPv4Network("1.1.1.0/32")
        ip3 = ipaddress.IPv4Network("1.1.2.0/24")
        self.assertTrue(ip1 &lt; ip3)
        self.assertTrue(ip3 &gt; ip2)
        self.assertEqual(ip1.compare_networks(ip1), 0)
        self.assertEqual(ip1.compare_networks(ip2), -1)
        self.assertEqual(ip2.compare_networks(ip1), 1)
        self.assertEqual(ip1.compare_networks(ip3), -1)
        self.assertEqual(ip3.compare_networks(ip1), 1)
        self.assertTrue(ip1._get_networks_key() &lt; ip3._get_networks_key())
        ip1 = ipaddress.IPv6Network("2001:2000::/96")
        ip2 = ipaddress.IPv6Network("2001:2001::/96")
        ip3 = ipaddress.IPv6Network("2001:ffff:2000::/96")
        self.assertTrue(ip1 &lt; ip3)
        self.assertTrue(ip3 &gt; ip2)
        self.assertEqual(ip1.compare_networks(ip3), -1)
        self.assertTrue(ip1._get_networks_key() &lt; ip3._get_networks_key())
        self.assertRaises(
            TypeError, self.ipv4_network.compare_networks, self.ipv6_network
        )
        ipv6 = ipaddress.IPv6Interface("::/0")
        ipv4 = ipaddress.IPv4Interface("0.0.0.0/0")
        self.assertRaises(TypeError, ipv4.__lt__, ipv6)
        self.assertRaises(TypeError, ipv4.__gt__, ipv6)
        self.assertRaises(TypeError, ipv6.__lt__, ipv4)
        self.assertRaises(TypeError, ipv6.__gt__, ipv4)
        ip1 = ipaddress.ip_network("10.1.2.128/25")
        self.assertFalse(ip1 &lt; ip1)
        self.assertFalse(ip1 &gt; ip1)
        ip2 = ipaddress.ip_network("10.1.3.0/24")
        self.assertTrue(ip1 &lt; ip2)
        self.assertFalse(ip2 &lt; ip1)
        self.assertFalse(ip1 &gt; ip2)
        self.assertTrue(ip2 &gt; ip1)
        ip3 = ipaddress.ip_network("10.1.3.0/25")
        self.assertTrue(ip2 &lt; ip3)
        self.assertFalse(ip3 &lt; ip2)
        self.assertFalse(ip2 &gt; ip3)
        self.assertTrue(ip3 &gt; ip2)
        ip1 = ipaddress.ip_network("10.10.10.0/31")
        ip2 = ipaddress.ip_network("10.10.10.0")
        ip3 = ipaddress.ip_network("10.10.10.2/31")
        ip4 = ipaddress.ip_network("10.10.10.2")
        sorted = [ip1, ip2, ip3, ip4]
        unsorted = [ip2, ip4, ip1, ip3]
        unsorted.sort()
        self.assertEqual(sorted, unsorted)
        unsorted = [ip4, ip1, ip3, ip2]
        unsorted.sort()
        self.assertEqual(sorted, unsorted)
        self.assertIs(ip1.__lt__(ipaddress.ip_address("10.10.10.0")), NotImplemented)
        self.assertIs(ip2.__lt__(ipaddress.ip_address("10.10.10.0")), NotImplemented)
        self.assertTrue(
            ipaddress.ip_network("1.1.1.1") &lt;= ipaddress.ip_network("1.1.1.1")
        )
        self.assertTrue(
            ipaddress.ip_network("1.1.1.1") &lt;= ipaddress.ip_network("1.1.1.2")
        )
        self.assertFalse(
            ipaddress.ip_network("1.1.1.2") &lt;= ipaddress.ip_network("1.1.1.1")
        )
        self.assertTrue(ipaddress.ip_network("::1") &lt;= ipaddress.ip_network("::1"))
        self.assertTrue(ipaddress.ip_network("::1") &lt;= ipaddress.ip_network("::2"))
        self.assertFalse(ipaddress.ip_network("::2") &lt;= ipaddress.ip_network("::1"))
    def testStrictNetworks(self):
        self.assertRaises(ValueError, ipaddress.ip_network, "192.168.1.1/24")
        self.assertRaises(ValueError, ipaddress.ip_network, "::1/120")
        self.assertRaises(ValueError, ipaddress.ip_network, "::1%scope/120")
    def testOverlaps(self):
        other = ipaddress.IPv4Network("1.2.3.0/30")
        other2 = ipaddress.IPv4Network("1.2.2.0/24")
        other3 = ipaddress.IPv4Network("1.2.2.64/26")
        self.assertTrue(self.ipv4_network.overlaps(other))
        self.assertFalse(self.ipv4_network.overlaps(other2))
        self.assertTrue(other2.overlaps(other3))
    def testEmbeddedIpv4(self):
        ipv4_string = "192.168.0.1"
        ipv4 = ipaddress.IPv4Interface(ipv4_string)
        v4compat_ipv6 = ipaddress.IPv6Interface("::%s" % ipv4_string)
        self.assertEqual(int(v4compat_ipv6.ip), int(ipv4.ip))
        v4mapped_ipv6 = ipaddress.IPv6Interface("::ffff:%s" % ipv4_string)
        self.assertNotEqual(v4mapped_ipv6.ip, ipv4.ip)
        self.assertRaises(
            ipaddress.AddressValueError, ipaddress.IPv6Interface, "2001:1.1.1.1:1.1.1.1"
        )
    def testIPv6AddressTooLarge(self):
        self.assertEqual(
            ipaddress.ip_address("::FFFF:192.0.2.1"),
            ipaddress.ip_address("::FFFF:c000:201"),
        )
        self.assertEqual(
            ipaddress.ip_address("FFFF::192.0.2.1"),
            ipaddress.ip_address("FFFF::c000:201"),
        )
        self.assertEqual(
            ipaddress.ip_address("::FFFF:192.0.2.1%scope"),
            ipaddress.ip_address("::FFFF:c000:201%scope"),
        )
        self.assertEqual(
            ipaddress.ip_address("FFFF::192.0.2.1%scope"),
            ipaddress.ip_address("FFFF::c000:201%scope"),
        )
        self.assertNotEqual(
            ipaddress.ip_address("::FFFF:192.0.2.1%scope"),
            ipaddress.ip_address("::FFFF:c000:201"),
        )
        self.assertNotEqual(
            ipaddress.ip_address("FFFF::192.0.2.1%scope"),
            ipaddress.ip_address("FFFF::c000:201"),
        )
        self.assertNotEqual(
            ipaddress.ip_address("::FFFF:192.0.2.1"),
            ipaddress.ip_address("::FFFF:c000:201%scope"),
        )
        self.assertNotEqual(
            ipaddress.ip_address("FFFF::192.0.2.1"),
            ipaddress.ip_address("FFFF::c000:201%scope"),
        )
    def testIPVersion(self):
        self.assertEqual(self.ipv4_address.version, 4)
        self.assertEqual(self.ipv6_address.version, 6)
        self.assertEqual(self.ipv6_scoped_address.version, 6)
    def testMaxPrefixLength(self):
        self.assertEqual(self.ipv4_interface.max_prefixlen, 32)
        self.assertEqual(self.ipv6_interface.max_prefixlen, 128)
        self.assertEqual(self.ipv6_scoped_interface.max_prefixlen, 128)
    def testPacked(self):
        self.assertEqual(self.ipv4_address.packed, b"\x01\x02\x03\x04")
        self.assertEqual(
            ipaddress.IPv4Interface("255.254.253.252").packed, b"\xff\xfe\xfd\xfc"
        )
        self.assertEqual(
            self.ipv6_address.packed,
            b"\x20\x01\x06\x58\x02\x2a\xca\xfe\x02\x00\x00\x00\x00\x00\x00\x01",
        )
        self.assertEqual(
            ipaddress.IPv6Interface("ffff:2:3:4:ffff::").packed,
            b"\xff\xff\x00\x02\x00\x03\x00\x04\xff\xff" + b"\x00" * 6,
        )
        self.assertEqual(
            ipaddress.IPv6Interface("::1:0:0:0:0").packed,
            b"\x00" * 6 + b"\x00\x01" + b"\x00" * 8,
        )
        self.assertEqual(
            self.ipv6_scoped_address.packed,
            b"\x20\x01\x06\x58\x02\x2a\xca\xfe\x02\x00\x00\x00\x00\x00\x00\x01",
        )
        self.assertEqual(
            ipaddress.IPv6Interface("ffff:2:3:4:ffff::%scope").packed,
            b"\xff\xff\x00\x02\x00\x03\x00\x04\xff\xff" + b"\x00" * 6,
        )
        self.assertEqual(
            ipaddress.IPv6Interface("::1:0:0:0:0%scope").packed,
            b"\x00" * 6 + b"\x00\x01" + b"\x00" * 8,
        )
    def testIpType(self):
        ipv4net = ipaddress.ip_network("1.2.3.4")
        ipv4addr = ipaddress.ip_address("1.2.3.4")
        ipv6net = ipaddress.ip_network("::1.2.3.4")
        ipv6addr = ipaddress.ip_address("::1.2.3.4")
        self.assertEqual(ipaddress.IPv4Network, type(ipv4net))
        self.assertEqual(ipaddress.IPv4Address, type(ipv4addr))
        self.assertEqual(ipaddress.IPv6Network, type(ipv6net))
        self.assertEqual(ipaddress.IPv6Address, type(ipv6addr))
    def testReservedIpv4(self):
        self.assertEqual(True, ipaddress.ip_interface("224.1.1.1/31").is_multicast)
        self.assertEqual(False, ipaddress.ip_network("240.0.0.0").is_multicast)
        self.assertEqual(True, ipaddress.ip_network("240.0.0.0").is_reserved)
        self.assertEqual(True, ipaddress.ip_interface("192.168.1.1/17").is_private)
        self.assertEqual(False, ipaddress.ip_network("192.169.0.0").is_private)
        self.assertEqual(True, ipaddress.ip_network("10.255.255.255").is_private)
        self.assertEqual(False, ipaddress.ip_network("11.0.0.0").is_private)
        self.assertEqual(False, ipaddress.ip_network("11.0.0.0").is_reserved)
        self.assertEqual(True, ipaddress.ip_network("172.31.255.255").is_private)
        self.assertEqual(False, ipaddress.ip_network("172.32.0.0").is_private)
        self.assertEqual(True, ipaddress.ip_network("169.254.1.0/24").is_link_local)
        self.assertEqual(
            True, ipaddress.ip_interface("169.254.100.200/24").is_link_local
        )
        self.assertEqual(
            False, ipaddress.ip_interface("169.255.100.200/24").is_link_local
        )
        self.assertEqual(True, ipaddress.ip_network("127.100.200.254/32").is_loopback)
        self.assertEqual(True, ipaddress.ip_network("127.42.0.0/16").is_loopback)
        self.assertEqual(False, ipaddress.ip_network("128.0.0.0").is_loopback)
        self.assertEqual(False, ipaddress.ip_network("100.64.0.0/10").is_private)
        self.assertEqual(False, ipaddress.ip_network("100.64.0.0/10").is_global)
        self.assertEqual(True, ipaddress.ip_network("192.0.2.128/25").is_private)
        self.assertEqual(True, ipaddress.ip_network("192.0.3.0/24").is_global)
        self.assertEqual(True, ipaddress.ip_address("0.0.0.0").is_unspecified)
        self.assertEqual(True, ipaddress.ip_address("224.1.1.1").is_multicast)
        self.assertEqual(False, ipaddress.ip_address("240.0.0.0").is_multicast)
        self.assertEqual(True, ipaddress.ip_address("240.0.0.1").is_reserved)
        self.assertEqual(False, ipaddress.ip_address("239.255.255.255").is_reserved)
        self.assertEqual(True, ipaddress.ip_address("192.168.1.1").is_private)
        self.assertEqual(False, ipaddress.ip_address("192.169.0.0").is_private)
        self.assertEqual(True, ipaddress.ip_address("10.255.255.255").is_private)
        self.assertEqual(False, ipaddress.ip_address("11.0.0.0").is_private)
        self.assertEqual(True, ipaddress.ip_address("172.31.255.255").is_private)
        self.assertEqual(False, ipaddress.ip_address("172.32.0.0").is_private)
        self.assertEqual(True, ipaddress.ip_address("169.254.100.200").is_link_local)
        self.assertEqual(False, ipaddress.ip_address("169.255.100.200").is_link_local)
        self.assertTrue(ipaddress.ip_address("192.0.7.1").is_global)
        self.assertFalse(ipaddress.ip_address("203.0.113.1").is_global)
        self.assertEqual(True, ipaddress.ip_address("127.100.200.254").is_loopback)
        self.assertEqual(True, ipaddress.ip_address("127.42.0.0").is_loopback)
        self.assertEqual(False, ipaddress.ip_address("128.0.0.0").is_loopback)
        self.assertEqual(True, ipaddress.ip_network("0.0.0.0").is_unspecified)
    def testReservedIpv6(self):
        self.assertEqual(True, ipaddress.ip_network("ffff::").is_multicast)
        self.assertEqual(True, ipaddress.ip_network(2 ** 128 - 1).is_multicast)
        self.assertEqual(True, ipaddress.ip_network("ff00::").is_multicast)
        self.assertEqual(False, ipaddress.ip_network("fdff::").is_multicast)
        self.assertEqual(True, ipaddress.ip_network("fecf::").is_site_local)
        self.assertEqual(
            True, ipaddress.ip_network("feff:ffff:ffff:ffff::").is_site_local
        )
        self.assertEqual(False, ipaddress.ip_network("fbf:ffff::").is_site_local)
        self.assertEqual(False, ipaddress.ip_network("ff00::").is_site_local)
        self.assertEqual(True, ipaddress.ip_network("fc00::").is_private)
        self.assertEqual(True, ipaddress.ip_network("fc00:ffff:ffff:ffff::").is_private)
        self.assertEqual(False, ipaddress.ip_network("fbff:ffff::").is_private)
        self.assertEqual(False, ipaddress.ip_network("fe00::").is_private)
        self.assertEqual(True, ipaddress.ip_network("fea0::").is_link_local)
        self.assertEqual(True, ipaddress.ip_network("febf:ffff::").is_link_local)
        self.assertEqual(False, ipaddress.ip_network("fe7f:ffff::").is_link_local)
        self.assertEqual(False, ipaddress.ip_network("fec0::").is_link_local)
        self.assertEqual(True, ipaddress.ip_interface("0:0::0:01").is_loopback)
        self.assertEqual(False, ipaddress.ip_interface("::1/127").is_loopback)
        self.assertEqual(False, ipaddress.ip_network("::").is_loopback)
        self.assertEqual(False, ipaddress.ip_network("::2").is_loopback)
        self.assertEqual(True, ipaddress.ip_network("0::0").is_unspecified)
        self.assertEqual(False, ipaddress.ip_network("::1").is_unspecified)
        self.assertEqual(False, ipaddress.ip_network("::/127").is_unspecified)
        self.assertEqual(True, ipaddress.ip_network("2001::1/128").is_private)
        self.assertEqual(True, ipaddress.ip_network("200::1/128").is_global)
        self.assertEqual(True, ipaddress.ip_address("ffff::").is_multicast)
        self.assertEqual(True, ipaddress.ip_address(2 ** 128 - 1).is_multicast)
        self.assertEqual(True, ipaddress.ip_address("ff00::").is_multicast)
        self.assertEqual(False, ipaddress.ip_address("fdff::").is_multicast)
        self.assertEqual(True, ipaddress.ip_address("fecf::").is_site_local)
        self.assertEqual(
            True, ipaddress.ip_address("feff:ffff:ffff:ffff::").is_site_local
        )
        self.assertEqual(False, ipaddress.ip_address("fbf:ffff::").is_site_local)
        self.assertEqual(False, ipaddress.ip_address("ff00::").is_site_local)
        self.assertEqual(True, ipaddress.ip_address("fc00::").is_private)
        self.assertEqual(True, ipaddress.ip_address("fc00:ffff:ffff:ffff::").is_private)
        self.assertEqual(False, ipaddress.ip_address("fbff:ffff::").is_private)
        self.assertEqual(False, ipaddress.ip_address("fe00::").is_private)
        self.assertEqual(True, ipaddress.ip_address("fea0::").is_link_local)
        self.assertEqual(True, ipaddress.ip_address("febf:ffff::").is_link_local)
        self.assertEqual(False, ipaddress.ip_address("fe7f:ffff::").is_link_local)
        self.assertEqual(False, ipaddress.ip_address("fec0::").is_link_local)
        self.assertEqual(True, ipaddress.ip_address("0:0::0:01").is_loopback)
        self.assertEqual(True, ipaddress.ip_address("::1").is_loopback)
        self.assertEqual(False, ipaddress.ip_address("::2").is_loopback)
        self.assertEqual(True, ipaddress.ip_address("0::0").is_unspecified)
        self.assertEqual(False, ipaddress.ip_address("::1").is_unspecified)
        self.assertEqual(True, ipaddress.ip_address("100::").is_reserved)
        self.assertEqual(True, ipaddress.ip_network("4000::1/128").is_reserved)
    def testIpv4Mapped(self):
        self.assertEqual(
            ipaddress.ip_address("::ffff:192.168.1.1").ipv4_mapped,
            ipaddress.ip_address("192.168.1.1"),
        )
        self.assertEqual(ipaddress.ip_address("::c0a8:101").ipv4_mapped, None)
        self.assertEqual(
            ipaddress.ip_address("::ffff:c0a8:101").ipv4_mapped,
            ipaddress.ip_address("192.168.1.1"),
        )
    def testAddrExclude(self):
        addr1 = ipaddress.ip_network("10.1.1.0/24")
        addr2 = ipaddress.ip_network("10.1.1.0/26")
        addr3 = ipaddress.ip_network("10.2.1.0/24")
        addr4 = ipaddress.ip_address("10.1.1.0")
        addr5 = ipaddress.ip_network("2001:db8::0/32")
        addr6 = ipaddress.ip_network("10.1.1.5/32")
        self.assertEqual(
            sorted(list(addr1.address_exclude(addr2))),
            [
                ipaddress.ip_network("10.1.1.64/26"),
                ipaddress.ip_network("10.1.1.128/25"),
            ],
        )
        self.assertRaises(ValueError, list, addr1.address_exclude(addr3))
        self.assertRaises(TypeError, list, addr1.address_exclude(addr4))
        self.assertRaises(TypeError, list, addr1.address_exclude(addr5))
        self.assertEqual(list(addr1.address_exclude(addr1)), [])
        self.assertEqual(
            sorted(list(addr1.address_exclude(addr6))),
            [
                ipaddress.ip_network("10.1.1.0/30"),
                ipaddress.ip_network("10.1.1.4/32"),
                ipaddress.ip_network("10.1.1.6/31"),
                ipaddress.ip_network("10.1.1.8/29"),
                ipaddress.ip_network("10.1.1.16/28"),
                ipaddress.ip_network("10.1.1.32/27"),
                ipaddress.ip_network("10.1.1.64/26"),
                ipaddress.ip_network("10.1.1.128/25"),
            ],
        )
    def testHash(self):
        self.assertEqual(
            hash(ipaddress.ip_interface("10.1.1.0/24")),
            hash(ipaddress.ip_interface("10.1.1.0/24")),
        )
        self.assertEqual(
            hash(ipaddress.ip_network("10.1.1.0/24")),
            hash(ipaddress.ip_network("10.1.1.0/24")),
        )
        self.assertEqual(
            hash(ipaddress.ip_address("10.1.1.0")),
            hash(ipaddress.ip_address("10.1.1.0")),
        )
        self.assertEqual(
            hash(ipaddress.ip_address("1.2.3.4")),
            hash(ipaddress.ip_address(int(ipaddress.ip_address("1.2.3.4")._ip))),
        )
        ip1 = ipaddress.ip_address("10.1.1.0")
        ip2 = ipaddress.ip_address("1::")
        dummy = {}
        dummy[self.ipv4_address] = None
        dummy[self.ipv6_address] = None
        dummy[ip1] = None
        dummy[ip2] = None
        self.assertIn(self.ipv4_address, dummy)
        self.assertIn(ip2, dummy)
    def testIPBases(self):
        net = self.ipv4_network
        self.assertEqual("1.2.3.0/24", net.compressed)
        net = self.ipv6_network
        self.assertRaises(ValueError, net._string_from_ip_int, 2 ** 128 + 1)
    def testIPv6NetworkHelpers(self):
        net = self.ipv6_network
        self.assertEqual("2001:658:22a:cafe::/64", net.with_prefixlen)
        self.assertEqual("2001:658:22a:cafe::/ffff:ffff:ffff:ffff::", net.with_netmask)
        self.assertEqual("2001:658:22a:cafe::/::ffff:ffff:ffff:ffff", net.with_hostmask)
        self.assertEqual("2001:658:22a:cafe::/64", str(net))
    def testIPv4NetworkHelpers(self):
        net = self.ipv4_network
        self.assertEqual("1.2.3.0/24", net.with_prefixlen)
        self.assertEqual("1.2.3.0/255.255.255.0", net.with_netmask)
        self.assertEqual("1.2.3.0/0.0.0.255", net.with_hostmask)
        self.assertEqual("1.2.3.0/24", str(net))
    def testCopyConstructor(self):
        addr1 = ipaddress.ip_network("10.1.1.0/24")
        addr2 = ipaddress.ip_network(addr1)
        addr3 = ipaddress.ip_interface("2001:658:22a:cafe:200::1/64")
        addr4 = ipaddress.ip_interface(addr3)
        addr5 = ipaddress.IPv4Address("1.1.1.1")
        addr6 = ipaddress.IPv6Address("2001:658:22a:cafe:200::1")
        self.assertEqual(addr1, addr2)
        self.assertEqual(addr3, addr4)
        self.assertEqual(addr5, ipaddress.IPv4Address(addr5))
        self.assertEqual(addr6, ipaddress.IPv6Address(addr6))
    def testCompressIPv6Address(self):
        test_addresses = {
            "1:2:3:4:5:6:7:8": "1:2:3:4:5:6:7:8/128",
            "2001:0:0:4:0:0:0:8": "2001:0:0:4::8/128",
            "2001:0:0:4:5:6:7:8": "2001::4:5:6:7:8/128",
            "2001:0:3:4:5:6:7:8": "2001:0:3:4:5:6:7:8/128",
            "0:0:3:0:0:0:0:ffff": "0:0:3::ffff/128",
            "0:0:0:4:0:0:0:ffff": "::4:0:0:0:ffff/128",
            "0:0:0:0:5:0:0:ffff": "::5:0:0:ffff/128",
            "1:0:0:4:0:0:7:8": "1::4:0:0:7:8/128",
            "0:0:0:0:0:0:0:0": "::/128",
            "0:0:0:0:0:0:0:0/0": "::/0",
            "0:0:0:0:0:0:0:1": "::1/128",
            "2001:0658:022a:cafe:0000:0000:0000:0000/66": "2001:658:22a:cafe::/66",
            "::1.2.3.4": "::102:304/128",
            "1:2:3:4:5:ffff:1.2.3.4": "1:2:3:4:5:ffff:102:304/128",
            "::7:6:5:4:3:2:1": "0:7:6:5:4:3:2:1/128",
            "::7:6:5:4:3:2:0": "0:7:6:5:4:3:2:0/128",
            "7:6:5:4:3:2:1::": "7:6:5:4:3:2:1:0/128",
            "0:6:5:4:3:2:1::": "0:6:5:4:3:2:1:0/128",
        }
        for uncompressed, compressed in list(test_addresses.items()):
            self.assertEqual(compressed, str(ipaddress.IPv6Interface(uncompressed)))
    def testExplodeShortHandIpStr(self):
        addr1 = ipaddress.IPv6Interface("2001::1")
        addr2 = ipaddress.IPv6Address("2001:0:5ef5:79fd:0:59d:a0e5:ba1")
        addr3 = ipaddress.IPv6Network("2001::/96")
        addr4 = ipaddress.IPv4Address("192.168.178.1")
        self.assertEqual("2001:0000:0000:0000:0000:0000:0000:0001/128", addr1.exploded)
        self.assertEqual(
            "0000:0000:0000:0000:0000:0000:0000:0001/128",
            ipaddress.IPv6Interface("::1/128").exploded,
        )
        self.assertEqual("2001:0000:5ef5:79fd:0000:059d:a0e5:0ba1", addr2.exploded)
        self.assertEqual("2001:0000:0000:0000:0000:0000:0000:0000/96", addr3.exploded)
        self.assertEqual("192.168.178.1", addr4.exploded)
    def testReversePointer(self):
        addr1 = ipaddress.IPv4Address("127.0.0.1")
        addr2 = ipaddress.IPv6Address("2001:db8::1")
        self.assertEqual("1.0.0.127.in-addr.arpa", addr1.reverse_pointer)
        self.assertEqual(
            "1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8."
            + "b.d.0.1.0.0.2.ip6.arpa",
            addr2.reverse_pointer,
        )
    def testIntRepresentation(self):
        self.assertEqual(16909060, int(self.ipv4_address))
        self.assertEqual(42540616829182469433547762482097946625, int(self.ipv6_address))
    def testForceVersion(self):
        self.assertEqual(ipaddress.ip_network(1).version, 4)
        self.assertEqual(ipaddress.IPv6Network(1).version, 6)
    def testWithStar(self):
        self.assertEqual(self.ipv4_interface.with_prefixlen, "1.2.3.4/24")
        self.assertEqual(self.ipv4_interface.with_netmask, "1.2.3.4/255.255.255.0")
        self.assertEqual(self.ipv4_interface.with_hostmask, "1.2.3.4/0.0.0.255")
        self.assertEqual(
            self.ipv6_interface.with_prefixlen, "2001:658:22a:cafe:200::1/64"
        )
        self.assertEqual(
            self.ipv6_interface.with_netmask,
            "2001:658:22a:cafe:200::1/ffff:ffff:ffff:ffff::",
        )
        self.assertEqual(
            self.ipv6_interface.with_hostmask,
            "2001:658:22a:cafe:200::1/::ffff:ffff:ffff:ffff",
        )
    def testNetworkElementCaching(self):
        self.assertNotIn("broadcast_address", self.ipv4_network._cache)
        self.assertNotIn("hostmask", self.ipv4_network._cache)
        self.assertEqual(
            self.ipv4_network.broadcast_address, ipaddress.IPv4Address("1.2.3.255")
        )
        self.assertEqual(self.ipv4_network.hostmask, ipaddress.IPv4Address("0.0.0.255"))
        self.assertIn("broadcast_address", self.ipv4_network._cache)
        self.assertIn("hostmask", self.ipv4_network._cache)
        self.assertNotIn("broadcast_address", self.ipv6_network._cache)
        self.assertNotIn("hostmask", self.ipv6_network._cache)
        self.assertEqual(
            self.ipv6_network.network_address,
            ipaddress.IPv6Address("2001:658:22a:cafe::"),
        )
        self.assertEqual(
            self.ipv6_interface.network.network_address,
            ipaddress.IPv6Address("2001:658:22a:cafe::"),
        )
        self.assertEqual(
            self.ipv6_network.broadcast_address,
            ipaddress.IPv6Address("2001:658:22a:cafe:ffff:ffff:ffff:ffff"),
        )
        self.assertEqual(
            self.ipv6_network.hostmask, ipaddress.IPv6Address("::ffff:ffff:ffff:ffff")
        )
        self.assertEqual(
            self.ipv6_interface.network.broadcast_address,
            ipaddress.IPv6Address("2001:658:22a:cafe:ffff:ffff:ffff:ffff"),
        )
        self.assertEqual(
            self.ipv6_interface.network.hostmask,
            ipaddress.IPv6Address("::ffff:ffff:ffff:ffff"),
        )
        self.assertIn("broadcast_address", self.ipv6_network._cache)
        self.assertIn("hostmask", self.ipv6_network._cache)
        self.assertIn("broadcast_address", self.ipv6_interface.network._cache)
        self.assertIn("hostmask", self.ipv6_interface.network._cache)
    def testTeredo(self):
        server = ipaddress.IPv4Address("65.54.227.120")
        client = ipaddress.IPv4Address("192.0.2.45")
        teredo_addr = "2001:0000:4136:e378:8000:63bf:3fff:fdd2"
        self.assertEqual((server, client), ipaddress.ip_address(teredo_addr).teredo)
        bad_addr = "2000::4136:e378:8000:63bf:3fff:fdd2"
        self.assertFalse(ipaddress.ip_address(bad_addr).teredo)
        bad_addr = "2001:0001:4136:e378:8000:63bf:3fff:fdd2"
        self.assertFalse(ipaddress.ip_address(bad_addr).teredo)
        teredo_addr = ipaddress.IPv6Address("2001:0:5ef5:79fd:0:59d:a0e5:ba1")
        self.assertEqual(
            (
                ipaddress.IPv4Address("95.26.244.94"),
            ),
            teredo_addr<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.teredo,
        )
    def testsixtofour(self):
        sixtofouraddr = ipaddress.ip_address("2002:ac1d:2d64::1")
        bad_addr = ipaddress.ip_address("2000:ac1d:2d64::1")
            ipaddress.IPv4Address(</b></font>"172.29.45.100"), sixtofouraddr.sixtofour
        )
        self.assertFalse(bad_addr.<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>sixtofour)
        ipv4_address1 = ipaddress.IPv4Interface("1.2.3.4")
        ipv4_address2 = ipaddress.IPv4Interface("2.3.4.5")
        self.assertNotEqual(ipv4_address1.__hash__(), ipv4_address2.__hash__(</b></font><font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>))
    def testV6HashIsNotConstant(self):
        ipv6_address1 = ipaddress.IPv6Interface("2001:658:22a:cafe:200:0:0:1")
        ipv6_address2 = ipaddress.IPv6Interface("2001:658:22a:cafe:200:0:0:2")
        self.assertNotEqual(ipv6_address1.__hash__(), ipv6_address2.__hash__(</b></font>))
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
