<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for kickstart.py & test_ipaddress.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for kickstart.py & test_ipaddress.py
      </h3>
      <h1 align="center">
        3.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>kickstart.py (5.574468%)<TH>test_ipaddress.py (2.363341%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match103528-0.html#0',2,'match103528-1.html#0',3)" NAME="0">(951-958)<TD><A HREF="javascript:ZweiFrames('match103528-0.html#0',2,'match103528-1.html#0',3)" NAME="0">(1128-1133)</A><TD ALIGN=center><FONT COLOR="#ff0000">16</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match103528-0.html#1',2,'match103528-1.html#1',3)" NAME="1">(554-565)<TD><A HREF="javascript:ZweiFrames('match103528-0.html#1',2,'match103528-1.html#1',3)" NAME="1">(2794-2800)</A><TD ALIGN=center><FONT COLOR="#df0000">14</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match103528-0.html#2',2,'match103528-1.html#2',3)" NAME="2">(414-425)<TD><A HREF="javascript:ZweiFrames('match103528-0.html#2',2,'match103528-1.html#2',3)" NAME="2">(2788-2794)</A><TD ALIGN=center><FONT COLOR="#df0000">14</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match103528-0.html#3',2,'match103528-1.html#3',3)" NAME="3">(1127-1133)<TD><A HREF="javascript:ZweiFrames('match103528-0.html#3',2,'match103528-1.html#3',3)" NAME="3">(1073-1075)</A><TD ALIGN=center><FONT COLOR="#cf0000">13</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match103528-0.html#4',2,'match103528-1.html#4',3)" NAME="4">(1077-1083)<TD><A HREF="javascript:ZweiFrames('match103528-0.html#4',2,'match103528-1.html#4',3)" NAME="4">(134-137)</A><TD ALIGN=center><FONT COLOR="#cf0000">13</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match103528-0.html#5',2,'match103528-1.html#5',3)" NAME="5">(770-780)<TD><A HREF="javascript:ZweiFrames('match103528-0.html#5',2,'match103528-1.html#5',3)" NAME="5">(2779-2786)</A><TD ALIGN=center><FONT COLOR="#cf0000">13</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match103528-0.html#6',2,'match103528-1.html#6',3)" NAME="6">(1013-1018)<TD><A HREF="javascript:ZweiFrames('match103528-0.html#6',2,'match103528-1.html#6',3)" NAME="6">(1133-1138)</A><TD ALIGN=center><FONT COLOR="#bf0000">12</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match103528-0.html#7',2,'match103528-1.html#7',3)" NAME="7">(218-222)<TD><A HREF="javascript:ZweiFrames('match103528-0.html#7',2,'match103528-1.html#7',3)" NAME="7">(202-206)</A><TD ALIGN=center><FONT COLOR="#bf0000">12</FONT>
<TR><TD BGCOLOR="#c58917"><FONT COLOR="#c58917">-</FONT><TD><A HREF="javascript:ZweiFrames('match103528-0.html#8',2,'match103528-1.html#8',3)" NAME="8">(133-143)<TD><A HREF="javascript:ZweiFrames('match103528-0.html#8',2,'match103528-1.html#8',3)" NAME="8">(1209-1217)</A><TD ALIGN=center><FONT COLOR="#bf0000">12</FONT>
<TR><TD BGCOLOR="#83a33a"><FONT COLOR="#83a33a">-</FONT><TD><A HREF="javascript:ZweiFrames('match103528-0.html#9',2,'match103528-1.html#9',3)" NAME="9">(115-125)<TD><A HREF="javascript:ZweiFrames('match103528-0.html#9',2,'match103528-1.html#9',3)" NAME="9">(1151-1159)</A><TD ALIGN=center><FONT COLOR="#bf0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>kickstart.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Utilities for managing kickstart

.. versionadded:: 2015.8.0
&quot;&quot;&quot;

import argparse
import shlex

import salt.utils.files
import salt.utils.yaml


def clean_args(args):
    &quot;&quot;&quot;
    Cleans up the args that weren't passed in
    &quot;&quot;&quot;
    for arg in list(args):
        if not args[arg]:
            del args[arg]
    return args


def parse_auth(rule):
    &quot;&quot;&quot;
    Parses the auth/authconfig line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    noargs = (
        &quot;back&quot;,
        &quot;test&quot;,
        &quot;nostart&quot;,
        &quot;kickstart&quot;,
        &quot;probe&quot;,
        &quot;enablecache&quot;,
        &quot;disablecache&quot;,
        &quot;disablenis&quot;,
        &quot;enableshadow&quot;,
        &quot;disableshadow&quot;,
        &quot;enablemd5&quot;,
        &quot;disablemd5&quot;,
        &quot;enableldap&quot;,
        &quot;enableldapauth&quot;,
        &quot;enableldaptls&quot;,
        &quot;disableldap&quot;,
        &quot;disableldapauth&quot;,
        &quot;enablekrb5kdcdns&quot;,
        &quot;disablekrb5kdcdns&quot;,
        &quot;enablekrb5realmdns&quot;,
        &quot;disablekrb5realmdns&quot;,
        &quot;disablekrb5&quot;,
        &quot;disablehe-siod&quot;,
        &quot;enablesmbauth&quot;,
        &quot;disablesmbauth&quot;,
        &quot;enablewinbind&quot;,
        &quot;enablewinbindauth&quot;,
        &quot;disablewinbind&quot;,
        &quot;disablewinbindauth&quot;,
        &quot;enablewinbindusedefaultdomain&quot;,
        &quot;disablewinbindusedefaultdomain&quot;,
        &quot;enablewins&quot;,
        &quot;disablewins&quot;,
    )
    for arg in noargs:
        parser.add_argument(&quot;--{}&quot;.format(arg), dest=arg, action=&quot;store_true&quot;)

    parser.add_argument(&quot;--enablenis&quot;, dest=&quot;enablenis&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--hesiodrhs&quot;, dest=&quot;hesiodrhs&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--krb5adminserver&quot;, dest=&quot;krb5adminserver&quot;, action=&quot;append&quot;)
    parser.add_argument(&quot;--krb5kdc&quot;, dest=&quot;krb5kdc&quot;, action=&quot;append&quot;)
    parser.add_argument(&quot;--ldapbasedn&quot;, dest=&quot;ldapbasedn&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--ldapserver&quot;, dest=&quot;ldapserver&quot;, action=&quot;append&quot;)
    parser.add_argument(&quot;--nisserver&quot;, dest=&quot;nisserver&quot;, action=&quot;append&quot;)
    parser.add_argument(&quot;--passalgo&quot;, dest=&quot;passalgo&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--smbidmapgid&quot;, dest=&quot;smbidmapgid&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--smbidmapuid&quot;, dest=&quot;smbidmapuid&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--smbrealm&quot;, dest=&quot;smbrealm&quot;, action=&quot;store&quot;)
    parser.add_argument(
        &quot;--smbsecurity&quot;,
        dest=&quot;smbsecurity&quot;,
        action=&quot;store&quot;,
        choices=[&quot;user&quot;, &quot;server&quot;, &quot;domain&quot;, &quot;dns&quot;],
    )
    parser.add_argument(&quot;--smbservers&quot;, dest=&quot;smbservers&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--smbworkgroup&quot;, dest=&quot;smbworkgroup&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--winbindjoin&quot;, dest=&quot;winbindjoin&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--winbindseparator&quot;, dest=&quot;winbindseparator&quot;, action=&quot;store&quot;)
    parser.add_argument(
        &quot;--winbindtemplatehomedir&quot;, dest=&quot;winbindtemplatehomedir&quot;, action=&quot;store&quot;
    )
    parser.add_argument(
        &quot;--winbindtemplateprimarygroup&quot;,
        dest=&quot;winbindtemplateprimarygroup&quot;,
        action=&quot;store&quot;,
    )
    parser.add_argument(
        &quot;--winbindtemplateshell&quot;, dest=&quot;winbindtemplateshell&quot;, action=&quot;store&quot;
    )

    parser.add_argument(&quot;--enablekrb5&quot;, dest=&quot;enablekrb5&quot;, action=&quot;store_true&quot;)
    if &quot;--enablekrb5&quot; in rules:
        parser.add_argument(
            &quot;--krb5realm&quot;, dest=&quot;krb5realm&quot;, action=&quot;store&quot;, required=True
        )
    parser.add_argument(&quot;--enablehesiod&quot;, dest=&quot;enablehesiod&quot;, action=&quot;store_true&quot;)
    if &quot;--enablehesiod&quot; in rules:
        parser.add_argument(
            &quot;--hesiodlhs&quot;, dest=&quot;hesiodlhs&quot;, action=&quot;store&quot;, required=True
        )
<A NAME="9"></A>
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    r<FONT color="#83a33a"><A HREF="javascript:ZweiFrames('match103528-1.html#9',3,'match103528-top.html#9',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>eturn args


def parse_autopart(rule):
    &quot;&quot;&quot;
    Parse the autopart line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(</B></FONT>&quot;--type&quot;, dest=&quot;type&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--encrypted&quot;, dest=&quot;encrypted&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--passphrase&quot;, dest=&quot;passphrase&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--escrowcert&quot;, dest=&quot;escrowcert&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--backuppassphrase&quot;, dest=&quot;backuppassphrase&quot;, action=&quot;store&quot;)
<A NAME="8"></A>
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    r<FONT color="#c58917"><A HREF="javascript:ZweiFrames('match103528-1.html#8',3,'match103528-top.html#8',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>eturn args


def parse_autostep(rule):
    &quot;&quot;&quot;
    Parse the autostep line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(</B></FONT>&quot;--autoscreenshot&quot;, dest=&quot;autoscreenshot&quot;, action=&quot;store&quot;)

    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args


def parse_bootloader(rule):
    &quot;&quot;&quot;
    Parse the bootloader line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(&quot;--append&quot;, dest=&quot;append&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--driveorder&quot;, dest=&quot;driveorder&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--location&quot;, dest=&quot;location&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--password&quot;, dest=&quot;password&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--md5pass&quot;, dest=&quot;md5pass&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--upgrade&quot;, dest=&quot;upgrade&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--timeout&quot;, dest=&quot;timeout&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--boot-drive&quot;, dest=&quot;bootdrive&quot;, action=&quot;store&quot;)

    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args


def parse_btrfs(rule):
    &quot;&quot;&quot;
    Parse the btrfs line

    TODO: finish up the weird parsing on this one
    http://fedoraproject.org/wiki/Anaconda/Kickstart#btrfs
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(&quot;--name&quot;, dest=&quot;name&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--data&quot;, dest=&quot;data&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--metadata&quot;, dest=&quot;metadata&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--label&quot;, dest=&quot;label&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--noformat&quot;, dest=&quot;noformat&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--useexisting&quot;, dest=&quot;useexisting&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--subvol&quot;, dest=&quot;subvol&quot;, action=&quot;store_true&quot;)

    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args


def parse_clearpart(rule):
    &quot;&quot;&quot;
    Parse the clearpart line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(&quot;--all&quot;, dest=&quot;all&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--drives&quot;, dest=&quot;drives&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--init_label&quot;, dest=&quot;init_label&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--linux&quot;, dest=&quot;linux&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--none&quot;, dest=&quot;none&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--initlabel&quot;, dest=&quot;init_label&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--list&quot;, dest=&quot;list&quot;, action=&quot;store&quot;)

    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args


def parse_device(rule):
<A NAME="7"></A>    &quot;&quot;&quot;
    Parse the device line
    &quot;&quot;&quot;
    parser = argparse<FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match103528-1.html#7',3,'match103528-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    modulename = rules.pop(0)
    parser.add_argument(</B></FONT>&quot;--opts&quot;, dest=&quot;opts&quot;, action=&quot;store&quot;)

    args = clean_args(vars(parser.parse_args(rules)))
    args[&quot;modulename&quot;] = modulename
    parser = None
    return args


def parse_dmraid(rule):
    &quot;&quot;&quot;
    Parse the dmraid line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(&quot;--name&quot;, dest=&quot;name&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--dev&quot;, dest=&quot;dev&quot;, action=&quot;store&quot;)

    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args


def parse_driverdisk(rule):
    &quot;&quot;&quot;
    Parse the driverdisk line
    &quot;&quot;&quot;
    if &quot;--&quot; not in rule:
        return {&quot;partition&quot;: rule}

    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(&quot;--source&quot;, dest=&quot;source&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--biospart&quot;, dest=&quot;biospart&quot;, action=&quot;store&quot;)

    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args


def parse_firewall(rule):
    &quot;&quot;&quot;
    Parse the firewall line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(&quot;--enable&quot;, &quot;--enabled&quot;, dest=&quot;enable&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--disable&quot;, &quot;--disabled&quot;, dest=&quot;disable&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--port&quot;, dest=&quot;port&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--service&quot;, dest=&quot;service&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--ssh&quot;, dest=&quot;ssh&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--smtp&quot;, dest=&quot;smtp&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--http&quot;, dest=&quot;http&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--ftp&quot;, dest=&quot;ftp&quot;, action=&quot;store_true&quot;)

    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args


def parse_firstboot(rule):
    &quot;&quot;&quot;
    Parse the firstboot line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(&quot;--enable&quot;, &quot;--enabled&quot;, dest=&quot;enable&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--disable&quot;, &quot;--disabled&quot;, dest=&quot;disable&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--reconfig&quot;, dest=&quot;reconfig&quot;, action=&quot;store_true&quot;)

    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args


def parse_group(rule):
    &quot;&quot;&quot;
    Parse the group line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(&quot;--name&quot;, dest=&quot;name&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--gid&quot;, dest=&quot;gid&quot;, action=&quot;store&quot;)

    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args


def parse_harddrive(rule):
    &quot;&quot;&quot;
    Parse the harddrive line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(&quot;--biospart&quot;, dest=&quot;biospart&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--partition&quot;, dest=&quot;partition&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--dir&quot;, dest=&quot;dir&quot;, action=&quot;store&quot;)

    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args


def parse_ignoredisk(rule):
    &quot;&quot;&quot;
    Parse the ignoredisk line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(&quot;--drives&quot;, dest=&quot;drives&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--only-use&quot;, dest=&quot;only-use&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--interactive&quot;, dest=&quot;interactive&quot;, action=&quot;store_true&quot;)

    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args


def parse_iscsi(rule):
    &quot;&quot;&quot;
    Parse the iscsi line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(&quot;--ipaddr&quot;, dest=&quot;ipaddr&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--port&quot;, dest=&quot;port&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--target&quot;, dest=&quot;target&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--iface&quot;, dest=&quot;iface&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--user&quot;, dest=&quot;user&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--password&quot;, dest=&quot;password&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--reverse-user&quot;, dest=&quot;reverse-user&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--reverse-password&quot;, dest=&quot;reverse-password&quot;, action=&quot;store&quot;)

    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args


def parse_iscsiname(rule):
    &quot;&quot;&quot;
    Parse the iscsiname line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    # parser.add_argument('iqn')

    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args


def parse_keyboard(rule):
    &quot;&quot;&quot;
    Parse the keyboard line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(&quot;--vckeymap&quot;, dest=&quot;vckeymap&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--xlayouts&quot;, dest=&quot;xlayouts&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--switch&quot;, dest=&quot;switch&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;keyboard&quot;)

    args = clean_args(vars(parser.parse_args(rules)))

    if &quot;keyboard&quot; in args and &quot;xlayouts&quot; not in args:
        args[&quot;xlayouts&quot;] = args[&quot;keyboard&quot;]

    parser = None
    return args


def parse_lang(rule):
    &quot;&quot;&quot;
    Parse the lang line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(&quot;lang&quot;)
<A NAME="2"></A>
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    r<FONT color="#980517"><A HREF="javascript:ZweiFrames('match103528-1.html#2',3,'match103528-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>eturn args


def parse_logvol(rule):
    &quot;&quot;&quot;
    Parse the logvol line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(&quot;mntpoint&quot;)
    parser.add_argument(</B></FONT>&quot;--noformat&quot;, dest=&quot;noformat&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--useexisting&quot;, dest=&quot;useexisting&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--fstype&quot;, dest=&quot;fstype&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--fsoptions&quot;, dest=&quot;fsoptions&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--grow&quot;, dest=&quot;grow&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--maxsize&quot;, dest=&quot;maxsize&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--recommended&quot;, dest=&quot;recommended&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--percent&quot;, dest=&quot;percent&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--encrypted&quot;, dest=&quot;encrypted&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--passphrase&quot;, dest=&quot;passphrase&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--escrowcert&quot;, dest=&quot;escrowcert&quot;, action=&quot;store&quot;)
    parser.add_argument(
        &quot;--backuppassphrase&quot;, dest=&quot;backuppassphrase&quot;, action=&quot;store_true&quot;
    )
    parser.add_argument(&quot;--name&quot;, dest=&quot;name&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--vgname&quot;, dest=&quot;vgname&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--size&quot;, dest=&quot;size&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--label&quot;, dest=&quot;label&quot;, action=&quot;store&quot;)

    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args


def parse_logging(rule):
    &quot;&quot;&quot;
    Parse the logging line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(&quot;--host&quot;, dest=&quot;host&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--port&quot;, dest=&quot;port&quot;, action=&quot;store&quot;)
    parser.add_argument(
        &quot;--level&quot;,
        dest=&quot;level&quot;,
        action=&quot;store&quot;,
        choices=[&quot;debug&quot;, &quot;info&quot;, &quot;warning&quot;, &quot;error&quot;, &quot;critical&quot;],
    )

    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args


def parse_monitor(rule):
    &quot;&quot;&quot;
    Parse the monitor line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(&quot;--hsync&quot;, dest=&quot;hsync&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--monitor&quot;, dest=&quot;monitor&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--noprobe&quot;, dest=&quot;noprobe&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--vsync&quot;, dest=&quot;vsync&quot;, action=&quot;store&quot;)

    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args


def parse_multipath(rule):
    &quot;&quot;&quot;
    Parse the multipath line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(&quot;--name&quot;, dest=&quot;name&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--device&quot;, dest=&quot;device&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--rule&quot;, dest=&quot;rule&quot;, action=&quot;store&quot;)

    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args


def parse_network(rule):
    &quot;&quot;&quot;
    Parse the network line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(
        &quot;--bootproto&quot;,
        dest=&quot;bootproto&quot;,
        action=&quot;store&quot;,
        choices=[&quot;dhcp&quot;, &quot;bootp&quot;, &quot;static&quot;, &quot;ibft&quot;],
    )
    parser.add_argument(&quot;--device&quot;, dest=&quot;device&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--ip&quot;, dest=&quot;ip&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--ipv6&quot;, dest=&quot;ipv6&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--gateway&quot;, dest=&quot;gateway&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--nodefroute&quot;, dest=&quot;nodefroute&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--nameserver&quot;, dest=&quot;nameserver&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--nodns&quot;, dest=&quot;nodns&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--netmask&quot;, dest=&quot;netmask&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--hostname&quot;, dest=&quot;hostname&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--ethtool&quot;, dest=&quot;ethtool&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--essid&quot;, dest=&quot;essid&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--wepkey&quot;, dest=&quot;wepkey&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--wpakey&quot;, dest=&quot;wpakey&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--onboot&quot;, dest=&quot;onboot&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--dhcpclass&quot;, dest=&quot;dhcpclass&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--mtu&quot;, dest=&quot;mtu&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--noipv4&quot;, dest=&quot;noipv4&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--noipv6&quot;, dest=&quot;noipv6&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--activate&quot;, dest=&quot;activate&quot;, action=&quot;store_true&quot;)

    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args


def parse_nfs(rule):
    &quot;&quot;&quot;
    Parse the nfs line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(&quot;--server&quot;, dest=&quot;server&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--dir&quot;, dest=&quot;dir&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--opts&quot;, dest=&quot;opts&quot;, action=&quot;store&quot;)
<A NAME="1"></A>
    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    r<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match103528-1.html#1',3,'match103528-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>eturn args


def parse_partition(rule):
    &quot;&quot;&quot;
    Parse the partition line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(&quot;mntpoint&quot;)
    parser.add_argument(</B></FONT>&quot;--size&quot;, dest=&quot;size&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--grow&quot;, dest=&quot;grow&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--maxsize&quot;, dest=&quot;maxsize&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--noformat&quot;, dest=&quot;noformat&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--onpart&quot;, &quot;--usepart&quot;, dest=&quot;onpart&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--ondisk&quot;, &quot;--ondrive&quot;, dest=&quot;ondisk&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--asprimary&quot;, dest=&quot;asprimary&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--fsprofile&quot;, dest=&quot;fsprofile&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--fstype&quot;, dest=&quot;fstype&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--fsoptions&quot;, dest=&quot;fsoptions&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--label&quot;, dest=&quot;label&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--recommended&quot;, dest=&quot;recommended&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--onbiosdisk&quot;, dest=&quot;onbiosdisk&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--encrypted&quot;, dest=&quot;encrypted&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--passphrase&quot;, dest=&quot;passphrase&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--escrowcert&quot;, dest=&quot;escrowcert&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--backupphrase&quot;, dest=&quot;backupphrase&quot;, action=&quot;store&quot;)

    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args


def parse_raid(rule):
    &quot;&quot;&quot;
    Parse the raid line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)

    partitions = []
    newrules = []
    for count, rule in enumerate(rules):
        if count == 0:
            newrules.append(rule)
            continue
        elif rule.startswith(&quot;--&quot;):
            newrules.append(rule)
            continue
        else:
            partitions.append(rule)
    rules = newrules

    parser.add_argument(&quot;mntpoint&quot;)
    parser.add_argument(&quot;--level&quot;, dest=&quot;level&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--device&quot;, dest=&quot;device&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--spares&quot;, dest=&quot;spares&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--fstype&quot;, dest=&quot;fstype&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--fsoptions&quot;, dest=&quot;fsoptions&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--label&quot;, dest=&quot;label&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--noformat&quot;, dest=&quot;noformat&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--useexisting&quot;, dest=&quot;useexisting&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--encrypted&quot;, dest=&quot;encrypted&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--passphrase&quot;, dest=&quot;passphrase&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--escrowcert&quot;, dest=&quot;escrowcert&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--backuppassphrase&quot;, dest=&quot;backuppassphrase&quot;, action=&quot;store&quot;)

    args = clean_args(vars(parser.parse_args(rules)))
    if partitions:
        args[&quot;partitions&quot;] = partitions
    parser = None
    return args


def parse_reboot(rule):
    &quot;&quot;&quot;
    Parse the reboot line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(&quot;--eject&quot;, dest=&quot;eject&quot;, action=&quot;store_true&quot;)

    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args


def parse_repo(rule):
    &quot;&quot;&quot;
    Parse the repo line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(&quot;--name&quot;, dest=&quot;name&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--baseurl&quot;, dest=&quot;baseurl&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--mirrorlist&quot;, dest=&quot;mirrorlist&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--cost&quot;, dest=&quot;cost&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--excludepkgs&quot;, dest=&quot;excludepkgs&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--includepkgs&quot;, dest=&quot;includepkgs&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--proxy&quot;, dest=&quot;proxy&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--ignoregroups&quot;, dest=&quot;ignoregroups&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--noverifyssl&quot;, dest=&quot;noverifyssl&quot;, action=&quot;store_true&quot;)

    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args


def parse_rescue(rule):
    &quot;&quot;&quot;
    Parse the rescue line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(&quot;--nomount&quot;, dest=&quot;nomount&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--romount&quot;, dest=&quot;romount&quot;, action=&quot;store_true&quot;)

    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args


def parse_rootpw(rule):
    &quot;&quot;&quot;
    Parse the rootpw line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(&quot;--iscrypted&quot;, dest=&quot;iscrypted&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--plaintext&quot;, dest=&quot;plaintext&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--lock&quot;, dest=&quot;lock&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;password&quot;)

    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args


def parse_selinux(rule):
    &quot;&quot;&quot;
    Parse the selinux line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(&quot;--disabled&quot;, dest=&quot;disabled&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--enforcing&quot;, dest=&quot;enforcing&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--permissive&quot;, dest=&quot;permissive&quot;, action=&quot;store_true&quot;)

    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args


def parse_services(rule):
    &quot;&quot;&quot;
    Parse the services line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(&quot;--disabled&quot;, dest=&quot;disabled&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--enabled&quot;, dest=&quot;enabled&quot;, action=&quot;store&quot;)

    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args


def parse_sshpw(rule):
    &quot;&quot;&quot;
    Parse the sshpw line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(&quot;--username&quot;, dest=&quot;username&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--iscrypted&quot;, dest=&quot;iscrypted&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--plaintext&quot;, dest=&quot;plaintext&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--lock&quot;, dest=&quot;lock&quot;, action=&quot;store_true&quot;)

    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args


def parse_timezone(rule):
    &quot;&quot;&quot;
    Parse the timezone line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(&quot;--utc&quot;, dest=&quot;utc&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--nontp&quot;, dest=&quot;nontp&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--ntpservers&quot;, dest=&quot;ntpservers&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--isUtc&quot;, dest=&quot;isutc&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;timezone&quot;)

    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args


def parse_updates(rule):
    &quot;&quot;&quot;
    Parse the updates line
<A NAME="5"></A>    &quot;&quot;&quot;
    rules = shlex.split(rule)
    rules.pop(0)
    return {&quot;url&quot;: rules<FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match103528-1.html#5',3,'match103528-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>[0]} if rules else True


def parse_upgrade(rule):
    &quot;&quot;&quot;
    Parse the upgrade line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(</B></FONT>&quot;--root-device&quot;, dest=&quot;root-device&quot;, action=&quot;store&quot;)

    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    if args:
        return args
    return True


def parse_url(rule):
    &quot;&quot;&quot;
    Parse the url line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(&quot;--url&quot;, dest=&quot;url&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--proxy&quot;, dest=&quot;proxy&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--noverifyssl&quot;, dest=&quot;noverifyssl&quot;, action=&quot;store_true&quot;)

    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args


def parse_user(rule):
    &quot;&quot;&quot;
    Parse the user line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(&quot;--name&quot;, dest=&quot;name&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--gecos&quot;, dest=&quot;gecos&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--groups&quot;, dest=&quot;groups&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--homedir&quot;, dest=&quot;homedir&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--lock&quot;, dest=&quot;lock&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--password&quot;, dest=&quot;password&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--iscrypted&quot;, dest=&quot;iscrypted&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--plaintext&quot;, dest=&quot;plaintext&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--shell&quot;, dest=&quot;shell&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--uid&quot;, dest=&quot;uid&quot;, action=&quot;store&quot;)

    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args


def parse_vnc(rule):
    &quot;&quot;&quot;
    Parse the vnc line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(&quot;--host&quot;, dest=&quot;host&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--port&quot;, dest=&quot;port&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--password&quot;, dest=&quot;password&quot;, action=&quot;store&quot;)

    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args


def parse_volgroup(rule):
    &quot;&quot;&quot;
    Parse the volgroup line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)

    partitions = []
    newrules = []
    for count, rule in enumerate(rules):
        if count == 0:
            newrules.append(rule)
            continue
        elif rule.startswith(&quot;--&quot;):
            newrules.append(rule)
            continue
        else:
            partitions.append(rule)
    rules = newrules

    parser.add_argument(&quot;name&quot;)
    parser.add_argument(&quot;--noformat&quot;, dest=&quot;noformat&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--useexisting&quot;, dest=&quot;useexisting&quot;, action=&quot;store_true&quot;)
    parser.add_argument(&quot;--pesize&quot;, dest=&quot;pesize&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--reserved-space&quot;, dest=&quot;reserved-space&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--reserved-percent&quot;, dest=&quot;reserved-percent&quot;, action=&quot;store&quot;)

    args = clean_args(vars(parser.parse_args(rules)))
    if partitions:
        args[&quot;partitions&quot;] = partitions
    parser = None
    return args


def parse_xconfig(rule):
    &quot;&quot;&quot;
    Parse the xconfig line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(&quot;--defaultdesktop&quot;, dest=&quot;defaultdesktop&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--startxonboot&quot;, dest=&quot;startxonboot&quot;, action=&quot;store_true&quot;)

    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args


def parse_zfcp(rule):
    &quot;&quot;&quot;
    Parse the zfcp line
    &quot;&quot;&quot;
    parser = argparse.ArgumentParser()
    rules = shlex.split(rule)
    rules.pop(0)
    parser.add_argument(&quot;--devnum&quot;, dest=&quot;devnum&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--fcplun&quot;, dest=&quot;fcplun&quot;, action=&quot;store&quot;)
    parser.add_argument(&quot;--wwpn&quot;, dest=&quot;wwpn&quot;, action=&quot;store&quot;)

    args = clean_args(vars(parser.parse_args(rules)))
    parser = None
    return args


def mksls(src, dst=None):
    &quot;&quot;&quot;
    Convert a kickstart file to an SLS file
    &quot;&quot;&quot;
    mode = &quot;command&quot;
    sls = {}
    ks_opts = {}
    with salt.utils.files.fopen(src, &quot;r&quot;) as fh_:
        for line in fh_:
            if line.startswith(&quot;#&quot;):
                continue

            if mode == &quot;command&quot;:
                if line.startswith(&quot;auth &quot;) or line.startswith(&quot;authconfig &quot;):
                    ks_opts[&quot;auth&quot;] = parse_auth(line)
                elif line.startswith(&quot;autopart&quot;):
                    ks_opts[&quot;autopath&quot;] = parse_autopart(line)
                elif line.startswith(&quot;autostep&quot;):
                    ks_opts[&quot;autostep&quot;] = parse_autostep(line)
                elif line.startswith(&quot;bootloader&quot;):
                    ks_opts[&quot;bootloader&quot;] = parse_bootloader(line)
                elif line.startswith(&quot;btrfs&quot;):
                    ks_opts[&quot;btrfs&quot;] = parse_btrfs(line)
                elif line.startswith(&quot;cdrom&quot;):
                    ks_opts[&quot;cdrom&quot;] = True
                elif line.startswith(&quot;clearpart&quot;):
                    ks_opts[&quot;clearpart&quot;] = parse_clearpart(line)
                elif line.startswith(&quot;cmdline&quot;):
                    ks_opts[&quot;cmdline&quot;] = True
                elif line.startswith(&quot;device&quot;):
                    ks_opts[&quot;device&quot;] = parse_device(line)
                elif line.startswith(&quot;dmraid&quot;):
                    ks_opts[&quot;dmraid&quot;] = parse_dmraid(line)
                elif line.startswith(&quot;driverdisk&quot;):
                    ks_opts[&quot;driverdisk&quot;] = parse_driverdisk(line)
                elif line.startswith(&quot;firewall&quot;):
                    ks_opts[&quot;firewall&quot;] = parse_firewall(line)
                elif line.startswith(&quot;firstboot&quot;):
<A NAME="0"></A>                    ks_opts[&quot;firstboot&quot;] = parse_firstboot(line)
                elif line.startswith(&quot;group&quot;):
                    ks_opts[&quot;group&quot;] = parse_group(line)
                elif line<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match103528-1.html#0',3,'match103528-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.startswith(&quot;graphical&quot;):
                    ks_opts[&quot;graphical&quot;] = True
                elif line.startswith(&quot;halt&quot;):
                    ks_opts[&quot;halt&quot;] = True
                elif line.startswith(&quot;harddrive&quot;):
                    ks_opts[&quot;harddrive&quot;] = True
                elif line.startswith(&quot;ignoredisk&quot;):
                    ks_opts[&quot;ignoredisk&quot;] =</B></FONT> parse_ignoredisk(line)
                elif line.startswith(&quot;install&quot;):
                    ks_opts[&quot;install&quot;] = True
                elif line.startswith(&quot;iscsi&quot;):
                    ks_opts[&quot;iscsi&quot;] = parse_iscsi(line)
                elif line.startswith(&quot;iscsiname&quot;):
                    ks_opts[&quot;iscsiname&quot;] = parse_iscsiname(line)
                elif line.startswith(&quot;keyboard&quot;):
                    ks_opts[&quot;keyboard&quot;] = parse_keyboard(line)
                elif line.startswith(&quot;lang&quot;):
                    ks_opts[&quot;lang&quot;] = parse_lang(line)
                elif line.startswith(&quot;logvol&quot;):
                    if &quot;logvol&quot; not in ks_opts:
                        ks_opts[&quot;logvol&quot;] = []
                    ks_opts[&quot;logvol&quot;].append(parse_logvol(line))
                elif line.startswith(&quot;logging&quot;):
                    ks_opts[&quot;logging&quot;] = parse_logging(line)
                elif line.startswith(&quot;mediacheck&quot;):
                    ks_opts[&quot;mediacheck&quot;] = True
                elif line.startswith(&quot;monitor&quot;):
                    ks_opts[&quot;monitor&quot;] = parse_monitor(line)
                elif line.startswith(&quot;multipath&quot;):
                    ks_opts[&quot;multipath&quot;] = parse_multipath(line)
                elif line.startswith(&quot;network&quot;):
                    if &quot;network&quot; not in ks_opts:
                        ks_opts[&quot;network&quot;] = []
                    ks_opts[&quot;network&quot;].append(parse_network(line))
                elif line.startswith(&quot;nfs&quot;):
                    ks_opts[&quot;nfs&quot;] = True
                elif line.startswith(&quot;part &quot;) or line.startswith(&quot;partition&quot;):
                    if &quot;part&quot; not in ks_opts:
                        ks_opts[&quot;part&quot;] = []
                    ks_opts[&quot;part&quot;].append(parse_partition(line))
                elif line.startswith(&quot;poweroff&quot;):
                    ks_opts[&quot;poweroff&quot;] = True
                elif line.startswith(&quot;raid&quot;):
                    if &quot;raid&quot; not in ks_opts:
                        ks_opts[&quot;raid&quot;] = []
                    ks_opts[&quot;raid&quot;].append(parse_raid(line))
                elif line.startswith(&quot;reboot&quot;):
                    ks_opts[&quot;reboot&quot;] = parse_reboot(line)
                elif line.startswith(&quot;repo&quot;):
                    ks_opts[&quot;repo&quot;] = parse_repo(line)
                elif line.startswith(&quot;rescue&quot;):
                    ks_opts[&quot;rescue&quot;] = parse_rescue(line)
                elif line.startswith(&quot;rootpw&quot;):
                    ks_opts[&quot;rootpw&quot;] = parse_rootpw(line)
                elif line.startswith(&quot;selinux&quot;):
                    ks_opts[&quot;selinux&quot;] = parse_selinux(line)
                elif line.startswith(&quot;services&quot;):
                    ks_opts[&quot;services&quot;] = parse_services(line)
                elif line.startswith(&quot;shutdown&quot;):
<A NAME="6"></A>                    ks_opts[&quot;shutdown&quot;] = True
                elif line.startswith(&quot;sshpw&quot;):
                    ks_opts[&quot;sshpw&quot;] = parse_sshpw(line)
                elif line<FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match103528-1.html#6',3,'match103528-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.startswith(&quot;skipx&quot;):
                    ks_opts[&quot;skipx&quot;] = True
                elif line.startswith(&quot;text&quot;):
                    ks_opts[&quot;text&quot;] = True
                elif line.startswith(&quot;timezone&quot;):
                    ks_opts[&quot;timezone&quot;] =</B></FONT> parse_timezone(line)
                elif line.startswith(&quot;updates&quot;):
                    ks_opts[&quot;updates&quot;] = parse_updates(line)
                elif line.startswith(&quot;upgrade&quot;):
                    ks_opts[&quot;upgrade&quot;] = parse_upgrade(line)
                elif line.startswith(&quot;url&quot;):
                    ks_opts[&quot;url&quot;] = True
                elif line.startswith(&quot;user&quot;):
                    ks_opts[&quot;user&quot;] = parse_user(line)
                elif line.startswith(&quot;vnc&quot;):
                    ks_opts[&quot;vnc&quot;] = parse_vnc(line)
                elif line.startswith(&quot;volgroup&quot;):
                    ks_opts[&quot;volgroup&quot;] = parse_volgroup(line)
                elif line.startswith(&quot;xconfig&quot;):
                    ks_opts[&quot;xconfig&quot;] = parse_xconfig(line)
                elif line.startswith(&quot;zerombr&quot;):
                    ks_opts[&quot;zerombr&quot;] = True
                elif line.startswith(&quot;zfcp&quot;):
                    ks_opts[&quot;zfcp&quot;] = parse_zfcp(line)

            if line.startswith(&quot;%include&quot;):
                rules = shlex.split(line)
                if not ks_opts[&quot;include&quot;]:
                    ks_opts[&quot;include&quot;] = []
                ks_opts[&quot;include&quot;].append(rules[1])

            if line.startswith(&quot;%ksappend&quot;):
                rules = shlex.split(line)
                if not ks_opts[&quot;ksappend&quot;]:
                    ks_opts[&quot;ksappend&quot;] = []
                ks_opts[&quot;ksappend&quot;].append(rules[1])

            if line.startswith(&quot;%packages&quot;):
                mode = &quot;packages&quot;
                if &quot;packages&quot; not in ks_opts:
                    ks_opts[&quot;packages&quot;] = {&quot;packages&quot;: {}}

                parser = argparse.ArgumentParser()
                opts = shlex.split(line)
                opts.pop(0)
                parser.add_argument(&quot;--default&quot;, dest=&quot;default&quot;, action=&quot;store_true&quot;)
                parser.add_argument(
                    &quot;--excludedocs&quot;, dest=&quot;excludedocs&quot;, action=&quot;store_true&quot;
                )
                parser.add_argument(
                    &quot;--ignoremissing&quot;, dest=&quot;ignoremissing&quot;, action=&quot;store_true&quot;
                )
                parser.add_argument(&quot;--instLangs&quot;, dest=&quot;instLangs&quot;, action=&quot;store&quot;)
                parser.add_argument(&quot;--multilib&quot;, dest=&quot;multilib&quot;, action=&quot;store_true&quot;)
                parser.add_argument(
                    &quot;--nodefaults&quot;, dest=&quot;nodefaults&quot;, action=&quot;store_true&quot;
                )
                parser.add_argument(&quot;--optional&quot;, dest=&quot;optional&quot;, action=&quot;store_true&quot;)
                parser.add_argument(&quot;--nobase&quot;, dest=&quot;nobase&quot;, action=&quot;store_true&quot;)
                args = clean_args(vars(parser.parse_args(opts)))
                ks_opts[&quot;packages&quot;][&quot;options&quot;] = args
<A NAME="4"></A>
                continue

            if line<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match103528-1.html#4',3,'match103528-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.startswith(&quot;%pre&quot;):
                mode = &quot;pre&quot;

                parser = argparse.ArgumentParser()
                opts = shlex.split(line)
                opts.pop(0)
                parser.add_argument(</B></FONT>&quot;--interpreter&quot;, dest=&quot;interpreter&quot;, action=&quot;store&quot;)
                parser.add_argument(
                    &quot;--erroronfail&quot;, dest=&quot;erroronfail&quot;, action=&quot;store_true&quot;
                )
                parser.add_argument(&quot;--log&quot;, dest=&quot;log&quot;, action=&quot;store&quot;)
                args = clean_args(vars(parser.parse_args(opts)))
                ks_opts[&quot;pre&quot;] = {&quot;options&quot;: args, &quot;script&quot;: &quot;&quot;}

                continue

            if line.startswith(&quot;%post&quot;):
                mode = &quot;post&quot;

                parser = argparse.ArgumentParser()
                opts = shlex.split(line)
                opts.pop(0)
                parser.add_argument(&quot;--nochroot&quot;, dest=&quot;nochroot&quot;, action=&quot;store_true&quot;)
                parser.add_argument(&quot;--interpreter&quot;, dest=&quot;interpreter&quot;, action=&quot;store&quot;)
                parser.add_argument(
                    &quot;--erroronfail&quot;, dest=&quot;erroronfail&quot;, action=&quot;store_true&quot;
                )
                parser.add_argument(&quot;--log&quot;, dest=&quot;log&quot;, action=&quot;store&quot;)
                args = clean_args(vars(parser.parse_args(opts)))
                ks_opts[&quot;post&quot;] = {&quot;options&quot;: args, &quot;script&quot;: &quot;&quot;}

                continue

            if line.startswith(&quot;%end&quot;):
                mode = None

            if mode == &quot;packages&quot;:
                if line.startswith(&quot;-&quot;):
                    package = line.replace(&quot;-&quot;, &quot;&quot;, 1).strip()
                    ks_opts[&quot;packages&quot;][&quot;packages&quot;][package] = False
                else:
                    ks_opts[&quot;packages&quot;][&quot;packages&quot;][line.strip()] = True

            if mode == &quot;pre&quot;:
                ks_opts[&quot;pre&quot;][&quot;script&quot;] += line

            if mode == &quot;post&quot;:
<A NAME="3"></A>                ks_opts[&quot;post&quot;][&quot;script&quot;] += line

    # Set language
    sls<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match103528-1.html#3',3,'match103528-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>[ks_opts[&quot;lang&quot;][&quot;lang&quot;]] = {&quot;locale&quot;: [&quot;system&quot;]}

    # Set keyboard
    sls[ks_opts[&quot;keyboard&quot;][&quot;xlayouts&quot;]] = {&quot;keyboard&quot;: [&quot;system&quot;]}

    # Set timezone
    sls[ks_opts[&quot;timezone&quot;][</B></FONT>&quot;timezone&quot;]] = {&quot;timezone&quot;: [&quot;system&quot;]}
    if &quot;utc&quot; in ks_opts[&quot;timezone&quot;]:
        sls[ks_opts[&quot;timezone&quot;][&quot;timezone&quot;]][&quot;timezone&quot;].append(&quot;utc&quot;)

    # Set network
    if &quot;network&quot; in ks_opts:
        for interface in ks_opts[&quot;network&quot;]:
            device = interface.get(&quot;device&quot;, None)
            if device is not None:
                del interface[&quot;device&quot;]
                sls[device] = {&quot;proto&quot;: interface[&quot;bootproto&quot;]}
                del interface[&quot;bootproto&quot;]

                if &quot;onboot&quot; in interface:
                    if &quot;no&quot; in interface[&quot;onboot&quot;]:
                        sls[device][&quot;enabled&quot;] = False
                    else:
                        sls[device][&quot;enabled&quot;] = True
                    del interface[&quot;onboot&quot;]

                if &quot;noipv4&quot; in interface:
                    sls[device][&quot;ipv4&quot;] = {&quot;enabled&quot;: False}
                    del interface[&quot;noipv4&quot;]
                if &quot;noipv6&quot; in interface:
                    sls[device][&quot;ipv6&quot;] = {&quot;enabled&quot;: False}
                    del interface[&quot;noipv6&quot;]

                for option in interface:
                    if type(interface[option]) is bool:
                        sls[device][option] = {&quot;enabled&quot;: [interface[option]]}
                    else:
                        sls[device][option] = interface[option]
            if &quot;hostname&quot; in interface:
                sls[&quot;system&quot;] = {
                    &quot;network.system&quot;: {
                        &quot;enabled&quot;: True,
                        &quot;hostname&quot;: interface[&quot;hostname&quot;],
                        &quot;apply_hostname&quot;: True,
                    }
                }

    # Set selinux
    if &quot;selinux&quot; in ks_opts:
        for mode in ks_opts[&quot;selinux&quot;]:
            sls[mode] = {&quot;selinux&quot;: [&quot;mode&quot;]}

    # Get package data together
    if &quot;nobase&quot; not in ks_opts[&quot;packages&quot;][&quot;options&quot;]:
        sls[&quot;base&quot;] = {&quot;pkg_group&quot;: [&quot;installed&quot;]}

    packages = ks_opts[&quot;packages&quot;][&quot;packages&quot;]
    for package in packages:
        if not packages[package]:
            continue
        if package and packages[package] is True:
            if package.startswith(&quot;@&quot;):
                pkg_group = package.replace(&quot;@&quot;, &quot;&quot;, 1)
                sls[pkg_group] = {&quot;pkg_group&quot;: [&quot;installed&quot;]}
            else:
                sls[package] = {&quot;pkg&quot;: [&quot;installed&quot;]}
        elif packages[package] is False:
            sls[package] = {&quot;pkg&quot;: [&quot;absent&quot;]}

    if dst:
        with salt.utils.files.fopen(dst, &quot;w&quot;) as fp_:
            salt.utils.yaml.safe_dump(sls, fp_, default_flow_style=False)
    else:
        return salt.utils.yaml.safe_dump(sls, default_flow_style=False)
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_ipaddress.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
# Copyright 2007 Google Inc.
#  Licensed to PSF under a Contributor Agreement.
#
#

# This is test_ipaddress.py from Python 3.9.5, verbatim, with minor compatility changes
#    https://github.com/python/cpython/blob/v3.9.5/Lib/test/test_ipaddress.py
#
# Modifications:
#  - Switch the ipaddress import to salt._compat
#  - Copy the `LARGEST` and `SMALLEST` implementation, from 3.9.1
#  - Adjust IpaddrUnitTest.testNetworkElementCaching because we're not using cached_property

&quot;&quot;&quot;Unittest for ipaddress module.&quot;&quot;&quot;

# pylint: disable=string-substitution-usage-error,pointless-statement,abstract-method,cell-var-from-loop

import contextlib
import functools
import operator
import pickle
import re
import sys
import weakref

import pytest
from salt._compat import ipaddress
from tests.support.unit import TestCase, skipIf


@functools.total_ordering
class _LARGEST:
    &quot;&quot;&quot;
    Object that is greater than anything (except itself).
    &quot;&quot;&quot;

    def __eq__(self, other):
        return isinstance(other, _LARGEST)

    def __lt__(self, other):
        return False


LARGEST = _LARGEST()


@functools.total_ordering
class _SMALLEST:
    &quot;&quot;&quot;
    Object that is less than anything (except itself).
    &quot;&quot;&quot;

    def __eq__(self, other):
        return isinstance(other, _SMALLEST)

    def __gt__(self, other):
        return False


SMALLEST = _SMALLEST()


class BaseTestCase(TestCase):
    # One big change in ipaddress over the original ipaddr module is
    # error reporting that tries to assume users *don't know the rules*
    # for what constitutes an RFC compliant IP address

    # Ensuring these errors are emitted correctly in all relevant cases
    # meant moving to a more systematic test structure that allows the
    # test structure to map more directly to the module structure

    # Note that if the constructors are refactored so that addresses with
    # multiple problems get classified differently, that's OK - just
    # move the affected examples to the newly appropriate test case.

    # There is some duplication between the original relatively ad hoc
    # test suite and the new systematic tests. While some redundancy in
    # testing is considered preferable to accidentally deleting a valid
    # test, the original test suite will likely be reduced over time as
    # redundant tests are identified.

    @property
    def factory(self):
        raise NotImplementedError

    @contextlib.contextmanager
    def assertCleanError(self, exc_type, details, *args):
        &quot;&quot;&quot;
        Ensure exception does not display a context by default

        Wraps unittest.TestCase.assertRaisesRegex
        &quot;&quot;&quot;
        if args:
            details = details % args
        cm = self.assertRaisesRegex(exc_type, details)
        with cm as exc:
            yield exc
        # Ensure we produce clean tracebacks on failure
        if exc.exception.__context__ is not None:
            self.assertTrue(exc.exception.__suppress_context__)

    def assertAddressError(self, details, *args):
        &quot;&quot;&quot;Ensure a clean AddressValueError&quot;&quot;&quot;
        return self.assertCleanError(ipaddress.AddressValueError, details, *args)

    def assertNetmaskError(self, details, *args):
        &quot;&quot;&quot;Ensure a clean NetmaskValueError&quot;&quot;&quot;
        return self.assertCleanError(ipaddress.NetmaskValueError, details, *args)

    def assertInstancesEqual(self, lhs, rhs):
        &quot;&quot;&quot;Check constructor arguments produce equivalent instances&quot;&quot;&quot;
        self.assertEqual(self.factory(lhs), self.factory(rhs))


@skipIf(sys.version_info &gt;= (3, 9, 5), &quot;We use builtin ipaddress on Python &gt;= 3.9.5&quot;)
class CommonTestMixin:
    def test_empty_address(self):
        with self.assertAddressError(&quot;Address cannot be empty&quot;):
            self.factory(&quot;&quot;)

    def test_floats_rejected(self):
        with self.assertAddressError(re.escape(repr(&quot;1.0&quot;))):
            self.factory(1.0)

    def test_not_an_index_issue15559(self):
        # Implementing __index__ makes for a very nasty interaction with the
        # bytes constructor. Thus, we disallow implicit use as an integer
        self.assertRaises(TypeError, operator.index, self.factory(1))
        self.assertRaises(TypeError, hex, self.factory(1))
        self.assertRaises(TypeError, bytes, self.factory(1))
<A NAME="4"></A>
    def pickle_test(self, addr):
        for proto in range(pickle.HIGHEST_PROTOCOL + 1):
            with self<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match103528-0.html#4',2,'match103528-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.subTest(proto=proto):
                x = self.factory(addr)
                y = pickle.loads(pickle.dumps(x, proto))
                self.assertEqual(</B></FONT>y, x)


@skipIf(sys.version_info &gt;= (3, 9, 5), &quot;We use builtin ipaddress on Python &gt;= 3.9.5&quot;)
class CommonTestMixin_v4(CommonTestMixin):
    def test_leading_zeros(self):
        # bpo-36384: no leading zeros to avoid ambiguity with octal notation
        msg = r&quot;Leading zeros are not permitted in '\d+'&quot;
        addresses = [
            &quot;000.000.000.000&quot;,
            &quot;192.168.000.001&quot;,
            &quot;016.016.016.016&quot;,
            &quot;192.168.000.001&quot;,
            &quot;001.000.008.016&quot;,
            &quot;01.2.3.40&quot;,
            &quot;1.02.3.40&quot;,
            &quot;1.2.03.40&quot;,
            &quot;1.2.3.040&quot;,
        ]
        for address in addresses:
            with self.subTest(address=address):
                with self.assertAddressError(msg):
                    self.factory(address)

    def test_int(self):
        self.assertInstancesEqual(0, &quot;0.0.0.0&quot;)
        self.assertInstancesEqual(3232235521, &quot;192.168.0.1&quot;)

    def test_packed(self):
        self.assertInstancesEqual(bytes.fromhex(&quot;00000000&quot;), &quot;0.0.0.0&quot;)
        self.assertInstancesEqual(bytes.fromhex(&quot;c0a80001&quot;), &quot;192.168.0.1&quot;)

    def test_negative_ints_rejected(self):
        msg = &quot;-1 (&lt; 0) is not permitted as an IPv4 address&quot;
        with self.assertAddressError(re.escape(msg)):
            self.factory(-1)

    def test_large_ints_rejected(self):
        msg = &quot;%d (&gt;= 2**32) is not permitted as an IPv4 address&quot;
        with self.assertAddressError(re.escape(msg % 2 ** 32)):
            self.factory(2 ** 32)

    def test_bad_packed_length(self):
        def assertBadLength(length):
            addr = b&quot;\0&quot; * length
            msg = &quot;%r (len %d != 4) is not permitted as an IPv4 address&quot;
            with self.assertAddressError(re.escape(msg % (addr, length))):
                self.factory(addr)

        assertBadLength(3)
        assertBadLength(5)


@skipIf(sys.version_info &gt;= (3, 9, 5), &quot;We use builtin ipaddress on Python &gt;= 3.9.5&quot;)
class CommonTestMixin_v6(CommonTestMixin):
    def test_leading_zeros(self):
        self.assertInstancesEqual(&quot;0000::0000&quot;, &quot;::&quot;)
        self.assertInstancesEqual(&quot;000::c0a8:0001&quot;, &quot;::c0a8:1&quot;)

    def test_int(self):
        self.assertInstancesEqual(0, &quot;::&quot;)
        self.assertInstancesEqual(3232235521, &quot;::c0a8:1&quot;)
<A NAME="7"></A>
    def test_packed(self):
        addr = b&quot;\0&quot; * 12 + bytes.fromhex(&quot;00000000&quot;)
        self<FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match103528-0.html#7',2,'match103528-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.assertInstancesEqual(addr, &quot;::&quot;)
        addr = b&quot;\0&quot; * 12 + bytes.fromhex(&quot;c0a80001&quot;)
        self.assertInstancesEqual(addr, &quot;::c0a8:1&quot;)
        addr = bytes.fromhex(&quot;c0a80001&quot;) + b&quot;\0&quot; * 12
        self.assertInstancesEqual(</B></FONT>addr, &quot;c0a8:1::&quot;)

    def test_negative_ints_rejected(self):
        msg = &quot;-1 (&lt; 0) is not permitted as an IPv6 address&quot;
        with self.assertAddressError(re.escape(msg)):
            self.factory(-1)

    def test_large_ints_rejected(self):
        msg = &quot;%d (&gt;= 2**128) is not permitted as an IPv6 address&quot;
        with self.assertAddressError(re.escape(msg % 2 ** 128)):
            self.factory(2 ** 128)

    def test_bad_packed_length(self):
        def assertBadLength(length):
            addr = b&quot;\0&quot; * length
            msg = &quot;%r (len %d != 16) is not permitted as an IPv6 address&quot;
            with self.assertAddressError(re.escape(msg % (addr, length))):
                self.factory(addr)
                self.factory(addr)

        assertBadLength(15)
        assertBadLength(17)

    def test_blank_scope_id(self):
        address = &quot;::1%&quot;
        with self.assertAddressError('Invalid IPv6 address: &quot;%r&quot;', address):
            self.factory(address)

    def test_invalid_scope_id_with_percent(self):
        address = &quot;::1%scope%&quot;
        with self.assertAddressError('Invalid IPv6 address: &quot;%r&quot;', address):
            self.factory(address)


@skipIf(sys.version_info &gt;= (3, 9, 5), &quot;We use builtin ipaddress on Python &gt;= 3.9.5&quot;)
class AddressTestCase_v4(BaseTestCase, CommonTestMixin_v4):
    factory = ipaddress.IPv4Address

    @pytest.mark.skipif(sys.version_info &lt; (3, 6), reason=&quot;Don't run on Py3.5&quot;)
    def test_format(self):
        v4 = ipaddress.IPv4Address(&quot;1.2.3.42&quot;)
        v4_pairs = [
            (&quot;b&quot;, &quot;00000001000000100000001100101010&quot;),
            (&quot;n&quot;, &quot;00000001000000100000001100101010&quot;),
            (&quot;x&quot;, &quot;0102032a&quot;),
            (&quot;X&quot;, &quot;0102032A&quot;),
            (&quot;_b&quot;, &quot;0000_0001_0000_0010_0000_0011_0010_1010&quot;),
            (&quot;_n&quot;, &quot;0000_0001_0000_0010_0000_0011_0010_1010&quot;),
            (&quot;_x&quot;, &quot;0102_032a&quot;),
            (&quot;_X&quot;, &quot;0102_032A&quot;),
            (&quot;#b&quot;, &quot;0b00000001000000100000001100101010&quot;),
            (&quot;#n&quot;, &quot;0b00000001000000100000001100101010&quot;),
            (&quot;#x&quot;, &quot;0x0102032a&quot;),
            (&quot;#X&quot;, &quot;0X0102032A&quot;),
            (&quot;#_b&quot;, &quot;0b0000_0001_0000_0010_0000_0011_0010_1010&quot;),
            (&quot;#_n&quot;, &quot;0b0000_0001_0000_0010_0000_0011_0010_1010&quot;),
            (&quot;#_x&quot;, &quot;0x0102_032a&quot;),
            (&quot;#_X&quot;, &quot;0X0102_032A&quot;),
            (&quot;s&quot;, &quot;1.2.3.42&quot;),
            (&quot;&quot;, &quot;1.2.3.42&quot;),
        ]
        for (fmt, txt) in v4_pairs:
            self.assertEqual(txt, format(v4, fmt))

    def test_network_passed_as_address(self):
        addr = &quot;127.0.0.1/24&quot;
        with self.assertAddressError(&quot;Unexpected '/' in %r&quot;, addr):
            ipaddress.IPv4Address(addr)

    def test_bad_address_split(self):
        def assertBadSplit(addr):
            with self.assertAddressError(&quot;Expected 4 octets in %r&quot;, addr):
                ipaddress.IPv4Address(addr)

        assertBadSplit(&quot;127.0.1&quot;)
        assertBadSplit(&quot;42.42.42.42.42&quot;)
        assertBadSplit(&quot;42.42.42&quot;)
        assertBadSplit(&quot;42.42&quot;)
        assertBadSplit(&quot;42&quot;)
        assertBadSplit(&quot;42..42.42.42&quot;)
        assertBadSplit(&quot;42.42.42.42.&quot;)
        assertBadSplit(&quot;42.42.42.42...&quot;)
        assertBadSplit(&quot;.42.42.42.42&quot;)
        assertBadSplit(&quot;...42.42.42.42&quot;)
        assertBadSplit(&quot;016.016.016&quot;)
        assertBadSplit(&quot;016.016&quot;)
        assertBadSplit(&quot;016&quot;)
        assertBadSplit(&quot;000&quot;)
        assertBadSplit(&quot;0x0a.0x0a.0x0a&quot;)
        assertBadSplit(&quot;0x0a.0x0a&quot;)
        assertBadSplit(&quot;0x0a&quot;)
        assertBadSplit(&quot;.&quot;)
        assertBadSplit(&quot;bogus&quot;)
        assertBadSplit(&quot;bogus.com&quot;)
        assertBadSplit(&quot;1000&quot;)
        assertBadSplit(&quot;1000000000000000&quot;)
        assertBadSplit(&quot;192.168.0.1.com&quot;)

    def test_empty_octet(self):
        def assertBadOctet(addr):
            with self.assertAddressError(&quot;Empty octet not permitted in %r&quot;, addr):
                ipaddress.IPv4Address(addr)

        assertBadOctet(&quot;42..42.42&quot;)
        assertBadOctet(&quot;...&quot;)

    def test_invalid_characters(self):
        def assertBadOctet(addr, octet):
            msg = &quot;Only decimal digits permitted in {!r} in {!r}&quot;.format(octet, addr)
            with self.assertAddressError(re.escape(msg)):
                ipaddress.IPv4Address(addr)

        assertBadOctet(&quot;0x0a.0x0a.0x0a.0x0a&quot;, &quot;0x0a&quot;)
        assertBadOctet(&quot;0xa.0x0a.0x0a.0x0a&quot;, &quot;0xa&quot;)
        assertBadOctet(&quot;42.42.42.-0&quot;, &quot;-0&quot;)
        assertBadOctet(&quot;42.42.42.+0&quot;, &quot;+0&quot;)
        assertBadOctet(&quot;42.42.42.-42&quot;, &quot;-42&quot;)
        assertBadOctet(&quot;+1.+2.+3.4&quot;, &quot;+1&quot;)
        assertBadOctet(&quot;1.2.3.4e0&quot;, &quot;4e0&quot;)
        assertBadOctet(&quot;1.2.3.4::&quot;, &quot;4::&quot;)
        assertBadOctet(&quot;1.a.2.3&quot;, &quot;a&quot;)

    def test_octet_length(self):
        def assertBadOctet(addr, octet):
            msg = &quot;At most 3 characters permitted in %r in %r&quot;
            with self.assertAddressError(re.escape(msg % (octet, addr))):
                ipaddress.IPv4Address(addr)

        assertBadOctet(&quot;0000.000.000.000&quot;, &quot;0000&quot;)
        assertBadOctet(&quot;12345.67899.-54321.-98765&quot;, &quot;12345&quot;)

    def test_octet_limit(self):
        def assertBadOctet(addr, octet):
            msg = &quot;Octet %d (&gt; 255) not permitted in %r&quot; % (octet, addr)
            with self.assertAddressError(re.escape(msg)):
                ipaddress.IPv4Address(addr)

        assertBadOctet(&quot;257.0.0.0&quot;, 257)
        assertBadOctet(&quot;192.168.0.999&quot;, 999)

    def test_pickle(self):
        self.pickle_test(&quot;192.0.2.1&quot;)

    def test_weakref(self):
        weakref.ref(self.factory(&quot;192.0.2.1&quot;))


@skipIf(sys.version_info &gt;= (3, 9, 5), &quot;We use builtin ipaddress on Python &gt;= 3.9.5&quot;)
class AddressTestCase_v6(BaseTestCase, CommonTestMixin_v6):
    factory = ipaddress.IPv6Address

    @pytest.mark.skipif(sys.version_info &lt; (3, 6), reason=&quot;Don't run on Py3.5&quot;)
    def test_format(self):

        v6 = ipaddress.IPv6Address(&quot;::1.2.3.42&quot;)
        v6_pairs = [
            (
                &quot;b&quot;,
                &quot;000000000000000000000000000000000000000000000000000000&quot;
                &quot;000000000000000000000000000000000000000000000000010000&quot;
                &quot;00100000001100101010&quot;,
            ),
            (&quot;n&quot;, &quot;0000000000000000000000000102032a&quot;),
            (&quot;x&quot;, &quot;0000000000000000000000000102032a&quot;),
            (&quot;X&quot;, &quot;0000000000000000000000000102032A&quot;),
            (
                &quot;_b&quot;,
                &quot;0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000&quot;
                &quot;_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000&quot;
                &quot;_0000_0000_0000_0000_0001_0000_0010_0000_0011_0010&quot;
                &quot;_1010&quot;,
            ),
            (&quot;_n&quot;, &quot;0000_0000_0000_0000_0000_0000_0102_032a&quot;),
            (&quot;_x&quot;, &quot;0000_0000_0000_0000_0000_0000_0102_032a&quot;),
            (&quot;_X&quot;, &quot;0000_0000_0000_0000_0000_0000_0102_032A&quot;),
            (
                &quot;#b&quot;,
                &quot;0b0000000000000000000000000000000000000000000000000000&quot;
                &quot;000000000000000000000000000000000000000000000000000100&quot;
                &quot;0000100000001100101010&quot;,
            ),
            (&quot;#n&quot;, &quot;0x0000000000000000000000000102032a&quot;),
            (&quot;#x&quot;, &quot;0x0000000000000000000000000102032a&quot;),
            (&quot;#X&quot;, &quot;0X0000000000000000000000000102032A&quot;),
            (
                &quot;#_b&quot;,
                &quot;0b0000_0000_0000_0000_0000_0000_0000_0000_0000_0000&quot;
                &quot;_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000&quot;
                &quot;_0000_0000_0000_0000_0000_0001_0000_0010_0000_0011&quot;
                &quot;_0010_1010&quot;,
            ),
            (&quot;#_n&quot;, &quot;0x0000_0000_0000_0000_0000_0000_0102_032a&quot;),
            (&quot;#_x&quot;, &quot;0x0000_0000_0000_0000_0000_0000_0102_032a&quot;),
            (&quot;#_X&quot;, &quot;0X0000_0000_0000_0000_0000_0000_0102_032A&quot;),
            (&quot;s&quot;, &quot;::102:32a&quot;),
            (&quot;&quot;, &quot;::102:32a&quot;),
        ]

        for (fmt, txt) in v6_pairs:
            self.assertEqual(txt, format(v6, fmt))

    def test_network_passed_as_address(self):
        def assertBadSplit(addr):
            msg = &quot;Unexpected '/' in %r&quot;
            with self.assertAddressError(msg, addr):
                ipaddress.IPv6Address(addr)

        assertBadSplit(&quot;::1/24&quot;)
        assertBadSplit(&quot;::1%scope_id/24&quot;)

    def test_bad_address_split_v6_not_enough_parts(self):
        def assertBadSplit(addr):
            msg = &quot;At least 3 parts expected in %r&quot;
            with self.assertAddressError(msg, addr.split(&quot;%&quot;)[0]):
                ipaddress.IPv6Address(addr)

        assertBadSplit(&quot;:&quot;)
        assertBadSplit(&quot;:1&quot;)
        assertBadSplit(&quot;FEDC:9878&quot;)
        assertBadSplit(&quot;:%scope&quot;)
        assertBadSplit(&quot;:1%scope&quot;)
        assertBadSplit(&quot;FEDC:9878%scope&quot;)

    def test_bad_address_split_v6_too_many_colons(self):
        def assertBadSplit(addr):
            msg = &quot;At most 8 colons permitted in %r&quot;
            with self.assertAddressError(msg, addr.split(&quot;%&quot;)[0]):
                ipaddress.IPv6Address(addr)

        assertBadSplit(&quot;9:8:7:6:5:4:3::2:1&quot;)
        assertBadSplit(&quot;10:9:8:7:6:5:4:3:2:1&quot;)
        assertBadSplit(&quot;::8:7:6:5:4:3:2:1&quot;)
        assertBadSplit(&quot;8:7:6:5:4:3:2:1::&quot;)
        # A trailing IPv4 address is two parts
        assertBadSplit(&quot;10:9:8:7:6:5:4:3:42.42.42.42&quot;)

        assertBadSplit(&quot;9:8:7:6:5:4:3::2:1%scope&quot;)
        assertBadSplit(&quot;10:9:8:7:6:5:4:3:2:1%scope&quot;)
        assertBadSplit(&quot;::8:7:6:5:4:3:2:1%scope&quot;)
        assertBadSplit(&quot;8:7:6:5:4:3:2:1::%scope&quot;)
        # A trailing IPv4 address is two parts
        assertBadSplit(&quot;10:9:8:7:6:5:4:3:42.42.42.42%scope&quot;)

    def test_bad_address_split_v6_too_many_parts(self):
        def assertBadSplit(addr):
            msg = &quot;Exactly 8 parts expected without '::' in %r&quot;
            with self.assertAddressError(msg, addr.split(&quot;%&quot;)[0]):
                ipaddress.IPv6Address(addr)

        assertBadSplit(&quot;3ffe:0:0:0:0:0:0:0:1&quot;)
        assertBadSplit(&quot;9:8:7:6:5:4:3:2:1&quot;)
        assertBadSplit(&quot;7:6:5:4:3:2:1&quot;)
        # A trailing IPv4 address is two parts
        assertBadSplit(&quot;9:8:7:6:5:4:3:42.42.42.42&quot;)
        assertBadSplit(&quot;7:6:5:4:3:42.42.42.42&quot;)

        assertBadSplit(&quot;3ffe:0:0:0:0:0:0:0:1%scope&quot;)
        assertBadSplit(&quot;9:8:7:6:5:4:3:2:1%scope&quot;)
        assertBadSplit(&quot;7:6:5:4:3:2:1%scope&quot;)
        # A trailing IPv4 address is two parts
        assertBadSplit(&quot;9:8:7:6:5:4:3:42.42.42.42%scope&quot;)
        assertBadSplit(&quot;7:6:5:4:3:42.42.42.42%scope&quot;)

    def test_bad_address_split_v6_too_many_parts_with_double_colon(self):
        def assertBadSplit(addr):
            msg = &quot;Expected at most 7 other parts with '::' in %r&quot;
            with self.assertAddressError(msg, addr.split(&quot;%&quot;)[0]):
                ipaddress.IPv6Address(addr)

        assertBadSplit(&quot;1:2:3:4::5:6:7:8&quot;)
        assertBadSplit(&quot;1:2:3:4::5:6:7:8%scope&quot;)

    def test_bad_address_split_v6_repeated_double_colon(self):
        def assertBadSplit(addr):
            msg = &quot;At most one '::' permitted in %r&quot;
            with self.assertAddressError(msg, addr.split(&quot;%&quot;)[0]):
                ipaddress.IPv6Address(addr)

        assertBadSplit(&quot;3ffe::1::1&quot;)
        assertBadSplit(&quot;1::2::3::4:5&quot;)
        assertBadSplit(&quot;2001::db:::1&quot;)
        assertBadSplit(&quot;3ffe::1::&quot;)
        assertBadSplit(&quot;::3ffe::1&quot;)
        assertBadSplit(&quot;:3ffe::1::1&quot;)
        assertBadSplit(&quot;3ffe::1::1:&quot;)
        assertBadSplit(&quot;:3ffe::1::1:&quot;)
        assertBadSplit(&quot;:::&quot;)
        assertBadSplit(&quot;2001:db8:::1&quot;)

        assertBadSplit(&quot;3ffe::1::1%scope&quot;)
        assertBadSplit(&quot;1::2::3::4:5%scope&quot;)
        assertBadSplit(&quot;2001::db:::1%scope&quot;)
        assertBadSplit(&quot;3ffe::1::%scope&quot;)
        assertBadSplit(&quot;::3ffe::1%scope&quot;)
        assertBadSplit(&quot;:3ffe::1::1%scope&quot;)
        assertBadSplit(&quot;3ffe::1::1:%scope&quot;)
        assertBadSplit(&quot;:3ffe::1::1:%scope&quot;)
        assertBadSplit(&quot;:::%scope&quot;)
        assertBadSplit(&quot;2001:db8:::1%scope&quot;)

    def test_bad_address_split_v6_leading_colon(self):
        def assertBadSplit(addr):
            msg = &quot;Leading ':' only permitted as part of '::' in %r&quot;
            with self.assertAddressError(msg, addr.split(&quot;%&quot;)[0]):
                ipaddress.IPv6Address(addr)

        assertBadSplit(&quot;:2001:db8::1&quot;)
        assertBadSplit(&quot;:1:2:3:4:5:6:7&quot;)
        assertBadSplit(&quot;:1:2:3:4:5:6:&quot;)
        assertBadSplit(&quot;:6:5:4:3:2:1::&quot;)

        assertBadSplit(&quot;:2001:db8::1%scope&quot;)
        assertBadSplit(&quot;:1:2:3:4:5:6:7%scope&quot;)
        assertBadSplit(&quot;:1:2:3:4:5:6:%scope&quot;)
        assertBadSplit(&quot;:6:5:4:3:2:1::%scope&quot;)

    def test_bad_address_split_v6_trailing_colon(self):
        def assertBadSplit(addr):
            msg = &quot;Trailing ':' only permitted as part of '::' in %r&quot;
            with self.assertAddressError(msg, addr.split(&quot;%&quot;)[0]):
                ipaddress.IPv6Address(addr)

        assertBadSplit(&quot;2001:db8::1:&quot;)
        assertBadSplit(&quot;1:2:3:4:5:6:7:&quot;)
        assertBadSplit(&quot;::1.2.3.4:&quot;)
        assertBadSplit(&quot;::7:6:5:4:3:2:&quot;)

        assertBadSplit(&quot;2001:db8::1:%scope&quot;)
        assertBadSplit(&quot;1:2:3:4:5:6:7:%scope&quot;)
        assertBadSplit(&quot;::1.2.3.4:%scope&quot;)
        assertBadSplit(&quot;::7:6:5:4:3:2:%scope&quot;)

    def test_bad_v4_part_in(self):
        def assertBadAddressPart(addr, v4_error):
            with self.assertAddressError(&quot;%s in %r&quot;, v4_error, addr.split(&quot;%&quot;)[0]):
                ipaddress.IPv6Address(addr)

        assertBadAddressPart(&quot;3ffe::1.net&quot;, &quot;Expected 4 octets in '1.net'&quot;)
        assertBadAddressPart(&quot;3ffe::127.0.1&quot;, &quot;Expected 4 octets in '127.0.1'&quot;)
        assertBadAddressPart(&quot;::1.2.3&quot;, &quot;Expected 4 octets in '1.2.3'&quot;)
        assertBadAddressPart(&quot;::1.2.3.4.5&quot;, &quot;Expected 4 octets in '1.2.3.4.5'&quot;)
        assertBadAddressPart(
            &quot;3ffe::1.1.1.net&quot;,
            &quot;Only decimal digits permitted in 'net' in '1.1.1.net'&quot;,
        )

        assertBadAddressPart(&quot;3ffe::1.net%scope&quot;, &quot;Expected 4 octets in '1.net'&quot;)
        assertBadAddressPart(&quot;3ffe::127.0.1%scope&quot;, &quot;Expected 4 octets in '127.0.1'&quot;)
        assertBadAddressPart(&quot;::1.2.3%scope&quot;, &quot;Expected 4 octets in '1.2.3'&quot;)
        assertBadAddressPart(&quot;::1.2.3.4.5%scope&quot;, &quot;Expected 4 octets in '1.2.3.4.5'&quot;)
        assertBadAddressPart(
            &quot;3ffe::1.1.1.net%scope&quot;,
            &quot;Only decimal digits permitted in 'net' in '1.1.1.net'&quot;,
        )

    def test_invalid_characters(self):
        def assertBadPart(addr, part):
            msg = &quot;Only hex digits permitted in {!r} in {!r}&quot;.format(
                part, addr.split(&quot;%&quot;)[0]
            )
            with self.assertAddressError(re.escape(msg)):
                ipaddress.IPv6Address(addr)

        assertBadPart(&quot;3ffe::goog&quot;, &quot;goog&quot;)
        assertBadPart(&quot;3ffe::-0&quot;, &quot;-0&quot;)
        assertBadPart(&quot;3ffe::+0&quot;, &quot;+0&quot;)
        assertBadPart(&quot;3ffe::-1&quot;, &quot;-1&quot;)
        assertBadPart(&quot;1.2.3.4::&quot;, &quot;1.2.3.4&quot;)
        assertBadPart(&quot;1234:axy::b&quot;, &quot;axy&quot;)

        assertBadPart(&quot;3ffe::goog%scope&quot;, &quot;goog&quot;)
        assertBadPart(&quot;3ffe::-0%scope&quot;, &quot;-0&quot;)
        assertBadPart(&quot;3ffe::+0%scope&quot;, &quot;+0&quot;)
        assertBadPart(&quot;3ffe::-1%scope&quot;, &quot;-1&quot;)
        assertBadPart(&quot;1.2.3.4::%scope&quot;, &quot;1.2.3.4&quot;)
        assertBadPart(&quot;1234:axy::b%scope&quot;, &quot;axy&quot;)

    def test_part_length(self):
        def assertBadPart(addr, part):
            msg = &quot;At most 4 characters permitted in %r in %r&quot;
            with self.assertAddressError(msg, part, addr.split(&quot;%&quot;)[0]):
                ipaddress.IPv6Address(addr)

        assertBadPart(&quot;::00000&quot;, &quot;00000&quot;)
        assertBadPart(&quot;3ffe::10000&quot;, &quot;10000&quot;)
        assertBadPart(&quot;02001:db8::&quot;, &quot;02001&quot;)
        assertBadPart(&quot;2001:888888::1&quot;, &quot;888888&quot;)

        assertBadPart(&quot;::00000%scope&quot;, &quot;00000&quot;)
        assertBadPart(&quot;3ffe::10000%scope&quot;, &quot;10000&quot;)
        assertBadPart(&quot;02001:db8::%scope&quot;, &quot;02001&quot;)
        assertBadPart(&quot;2001:888888::1%scope&quot;, &quot;888888&quot;)

    def test_pickle(self):
        self.pickle_test(&quot;2001:db8::&quot;)

    def test_weakref(self):
        weakref.ref(self.factory(&quot;2001:db8::&quot;))
        weakref.ref(self.factory(&quot;2001:db8::%scope&quot;))


@skipIf(sys.version_info &gt;= (3, 9, 5), &quot;We use builtin ipaddress on Python &gt;= 3.9.5&quot;)
class NetmaskTestMixin_v4(CommonTestMixin_v4):
    &quot;&quot;&quot;Input validation on interfaces and networks is very similar&quot;&quot;&quot;

    def test_no_mask(self):
        for address in (&quot;1.2.3.4&quot;, 0x01020304, b&quot;\x01\x02\x03\x04&quot;):
            net = self.factory(address)
            self.assertEqual(str(net), &quot;1.2.3.4/32&quot;)
            self.assertEqual(str(net.netmask), &quot;255.255.255.255&quot;)
            self.assertEqual(str(net.hostmask), &quot;0.0.0.0&quot;)
            # IPv4Network has prefixlen, but IPv4Interface doesn't.
            # Should we add it to IPv4Interface too? (bpo-36392)

    def test_split_netmask(self):
        addr = &quot;1.2.3.4/32/24&quot;
        with self.assertAddressError(&quot;Only one '/' permitted in %r&quot; % addr):
            self.factory(addr)

    def test_address_errors(self):
        def assertBadAddress(addr, details):
            with self.assertAddressError(details):
                self.factory(addr)

        assertBadAddress(&quot;/&quot;, &quot;Address cannot be empty&quot;)
        assertBadAddress(&quot;/8&quot;, &quot;Address cannot be empty&quot;)
        assertBadAddress(&quot;bogus&quot;, &quot;Expected 4 octets&quot;)
        assertBadAddress(&quot;google.com&quot;, &quot;Expected 4 octets&quot;)
        assertBadAddress(&quot;10/8&quot;, &quot;Expected 4 octets&quot;)
        assertBadAddress(&quot;::1.2.3.4&quot;, &quot;Only decimal digits&quot;)
        assertBadAddress(&quot;1.2.3.256&quot;, re.escape(&quot;256 (&gt; 255)&quot;))

    def test_valid_netmask(self):
        self.assertEqual(str(self.factory(&quot;192.0.2.0/255.255.255.0&quot;)), &quot;192.0.2.0/24&quot;)
        for i in range(0, 33):
            # Generate and re-parse the CIDR format (trivial).
            net_str = &quot;0.0.0.0/%d&quot; % i
            net = self.factory(net_str)
            self.assertEqual(str(net), net_str)
            # Generate and re-parse the expanded netmask.
            self.assertEqual(str(self.factory(&quot;0.0.0.0/%s&quot; % net.netmask)), net_str)
            # Zero prefix is treated as decimal.
            self.assertEqual(str(self.factory(&quot;0.0.0.0/0%d&quot; % i)), net_str)
            # Generate and re-parse the expanded hostmask.  The ambiguous
            # cases (/0 and /32) are treated as netmasks.
            if i in (32, 0):
                net_str = &quot;0.0.0.0/%d&quot; % (32 - i)
            self.assertEqual(str(self.factory(&quot;0.0.0.0/%s&quot; % net.hostmask)), net_str)

    def test_netmask_errors(self):
        def assertBadNetmask(addr, netmask):
            msg = &quot;%r is not a valid netmask&quot; % netmask
            with self.assertNetmaskError(re.escape(msg)):
                self.factory(&quot;{}/{}&quot;.format(addr, netmask))

        assertBadNetmask(&quot;1.2.3.4&quot;, &quot;&quot;)
        assertBadNetmask(&quot;1.2.3.4&quot;, &quot;-1&quot;)
        assertBadNetmask(&quot;1.2.3.4&quot;, &quot;+1&quot;)
        assertBadNetmask(&quot;1.2.3.4&quot;, &quot; 1 &quot;)
        assertBadNetmask(&quot;1.2.3.4&quot;, &quot;0x1&quot;)
        assertBadNetmask(&quot;1.2.3.4&quot;, &quot;33&quot;)
        assertBadNetmask(&quot;1.2.3.4&quot;, &quot;254.254.255.256&quot;)
        assertBadNetmask(&quot;1.2.3.4&quot;, &quot;1.a.2.3&quot;)
        assertBadNetmask(&quot;1.1.1.1&quot;, &quot;254.xyz.2.3&quot;)
        assertBadNetmask(&quot;1.1.1.1&quot;, &quot;240.255.0.0&quot;)
        assertBadNetmask(&quot;1.1.1.1&quot;, &quot;255.254.128.0&quot;)
        assertBadNetmask(&quot;1.1.1.1&quot;, &quot;0.1.127.255&quot;)
        assertBadNetmask(&quot;1.1.1.1&quot;, &quot;pudding&quot;)
        assertBadNetmask(&quot;1.1.1.1&quot;, &quot;::&quot;)

    def test_netmask_in_tuple_errors(self):
        def assertBadNetmask(addr, netmask):
            msg = &quot;%r is not a valid netmask&quot; % netmask
            with self.assertNetmaskError(re.escape(msg)):
                self.factory((addr, netmask))

        assertBadNetmask(&quot;1.1.1.1&quot;, -1)
        assertBadNetmask(&quot;1.1.1.1&quot;, 33)

    def test_pickle(self):
        self.pickle_test(&quot;192.0.2.0/27&quot;)
        self.pickle_test(&quot;192.0.2.0/31&quot;)  # IPV4LENGTH - 1
        self.pickle_test(&quot;192.0.2.0&quot;)  # IPV4LENGTH


class InterfaceTestCase_v4(BaseTestCase, NetmaskTestMixin_v4):
    factory = ipaddress.IPv4Interface


@skipIf(sys.version_info &gt;= (3, 9, 5), &quot;We use builtin ipaddress on Python &gt;= 3.9.5&quot;)
class NetworkTestCase_v4(BaseTestCase, NetmaskTestMixin_v4):
    factory = ipaddress.IPv4Network

    def test_subnet_of(self):
        # containee left of container
        self.assertFalse(
            self.factory(&quot;10.0.0.0/30&quot;).subnet_of(self.factory(&quot;10.0.1.0/24&quot;))
        )
        # containee inside container
        self.assertTrue(
            self.factory(&quot;10.0.0.0/30&quot;).subnet_of(self.factory(&quot;10.0.0.0/24&quot;))
        )
        # containee right of container
        self.assertFalse(
            self.factory(&quot;10.0.0.0/30&quot;).subnet_of(self.factory(&quot;10.0.1.0/24&quot;))
        )
        # containee larger than container
        self.assertFalse(
            self.factory(&quot;10.0.1.0/24&quot;).subnet_of(self.factory(&quot;10.0.0.0/30&quot;))
        )

    def test_supernet_of(self):
        # containee left of container
        self.assertFalse(
            self.factory(&quot;10.0.0.0/30&quot;).supernet_of(self.factory(&quot;10.0.1.0/24&quot;))
        )
        # containee inside container
        self.assertFalse(
            self.factory(&quot;10.0.0.0/30&quot;).supernet_of(self.factory(&quot;10.0.0.0/24&quot;))
        )
        # containee right of container
        self.assertFalse(
            self.factory(&quot;10.0.0.0/30&quot;).supernet_of(self.factory(&quot;10.0.1.0/24&quot;))
        )
        # containee larger than container
        self.assertTrue(
            self.factory(&quot;10.0.0.0/24&quot;).supernet_of(self.factory(&quot;10.0.0.0/30&quot;))
        )

    def test_subnet_of_mixed_types(self):
        with self.assertRaises(TypeError):
            ipaddress.IPv4Network(&quot;10.0.0.0/30&quot;).supernet_of(
                ipaddress.IPv6Network(&quot;::1/128&quot;)
            )
        with self.assertRaises(TypeError):
            ipaddress.IPv6Network(&quot;::1/128&quot;).supernet_of(
                ipaddress.IPv4Network(&quot;10.0.0.0/30&quot;)
            )
        with self.assertRaises(TypeError):
            ipaddress.IPv4Network(&quot;10.0.0.0/30&quot;).subnet_of(
                ipaddress.IPv6Network(&quot;::1/128&quot;)
            )
        with self.assertRaises(TypeError):
            ipaddress.IPv6Network(&quot;::1/128&quot;).subnet_of(
                ipaddress.IPv4Network(&quot;10.0.0.0/30&quot;)
            )


@skipIf(sys.version_info &gt;= (3, 9, 5), &quot;We use builtin ipaddress on Python &gt;= 3.9.5&quot;)
class NetmaskTestMixin_v6(CommonTestMixin_v6):
    &quot;&quot;&quot;Input validation on interfaces and networks is very similar&quot;&quot;&quot;

    def test_no_mask(self):
        for address in (&quot;::1&quot;, 1, b&quot;\x00&quot; * 15 + b&quot;\x01&quot;):
            net = self.factory(address)
            self.assertEqual(str(net), &quot;::1/128&quot;)
            self.assertEqual(
                str(net.netmask), &quot;ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff&quot;
            )
            self.assertEqual(str(net.hostmask), &quot;::&quot;)
            # IPv6Network has prefixlen, but IPv6Interface doesn't.
            # Should we add it to IPv4Interface too? (bpo-36392)

        scoped_net = self.factory(&quot;::1%scope&quot;)
        self.assertEqual(str(scoped_net), &quot;::1%scope/128&quot;)
        self.assertEqual(
            str(scoped_net.netmask), &quot;ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff&quot;
        )
        self.assertEqual(str(scoped_net.hostmask), &quot;::&quot;)

    def test_split_netmask(self):
        addr = &quot;cafe:cafe::/128/190&quot;
        with self.assertAddressError(&quot;Only one '/' permitted in %r&quot; % addr):
            self.factory(addr)

        scoped_addr = &quot;cafe:cafe::%scope/128/190&quot;
        with self.assertAddressError(&quot;Only one '/' permitted in %r&quot; % scoped_addr):
            self.factory(scoped_addr)

    def test_address_errors(self):
        def assertBadAddress(addr, details):
            with self.assertAddressError(details):
                self.factory(addr)

        assertBadAddress(&quot;/&quot;, &quot;Address cannot be empty&quot;)
        assertBadAddress(&quot;/8&quot;, &quot;Address cannot be empty&quot;)
        assertBadAddress(&quot;google.com&quot;, &quot;At least 3 parts&quot;)
        assertBadAddress(&quot;1.2.3.4&quot;, &quot;At least 3 parts&quot;)
        assertBadAddress(&quot;10/8&quot;, &quot;At least 3 parts&quot;)
        assertBadAddress(&quot;1234:axy::b&quot;, &quot;Only hex digits&quot;)

        assertBadAddress(&quot;/%scope&quot;, &quot;Address cannot be empty&quot;)
        assertBadAddress(&quot;/%scope8&quot;, &quot;Address cannot be empty&quot;)
        assertBadAddress(&quot;google.com%scope&quot;, &quot;At least 3 parts&quot;)
        assertBadAddress(&quot;1.2.3.4%scope&quot;, &quot;At least 3 parts&quot;)
        assertBadAddress(&quot;10%scope/8&quot;, &quot;At least 3 parts&quot;)
        assertBadAddress(&quot;1234:axy::b%scope&quot;, &quot;Only hex digits&quot;)

    def test_valid_netmask(self):
        # We only support CIDR for IPv6, because expanded netmasks are not
        # standard notation.
        self.assertEqual(str(self.factory(&quot;2001:db8::/32&quot;)), &quot;2001:db8::/32&quot;)
        for i in range(0, 129):
            # Generate and re-parse the CIDR format (trivial).
            net_str = &quot;::/%d&quot; % i
            self.assertEqual(str(self.factory(net_str)), net_str)
            # Zero prefix is treated as decimal.
            self.assertEqual(str(self.factory(&quot;::/0%d&quot; % i)), net_str)

        self.assertEqual(
            str(self.factory(&quot;2001:db8::%scope/32&quot;)), &quot;2001:db8::%scope/32&quot;
        )
        for i in range(0, 129):
            # Generate and re-parse the CIDR format (trivial).
            net_str = &quot;::/%d&quot; % i
            self.assertEqual(str(self.factory(net_str)), net_str)
            # Zero prefix is treated as decimal.
            self.assertEqual(str(self.factory(&quot;::/0%d&quot; % i)), net_str)

    def test_netmask_errors(self):
        def assertBadNetmask(addr, netmask):
            msg = &quot;%r is not a valid netmask&quot; % netmask
            with self.assertNetmaskError(re.escape(msg)):
                self.factory(&quot;{}/{}&quot;.format(addr, netmask))

        assertBadNetmask(&quot;::1&quot;, &quot;&quot;)
        assertBadNetmask(&quot;::1&quot;, &quot;::1&quot;)
        assertBadNetmask(&quot;::1&quot;, &quot;1::&quot;)
        assertBadNetmask(&quot;::1&quot;, &quot;-1&quot;)
        assertBadNetmask(&quot;::1&quot;, &quot;+1&quot;)
        assertBadNetmask(&quot;::1&quot;, &quot; 1 &quot;)
        assertBadNetmask(&quot;::1&quot;, &quot;0x1&quot;)
        assertBadNetmask(&quot;::1&quot;, &quot;129&quot;)
        assertBadNetmask(&quot;::1&quot;, &quot;1.2.3.4&quot;)
        assertBadNetmask(&quot;::1&quot;, &quot;pudding&quot;)
        assertBadNetmask(&quot;::&quot;, &quot;::&quot;)

        assertBadNetmask(&quot;::1%scope&quot;, &quot;pudding&quot;)

    def test_netmask_in_tuple_errors(self):
        def assertBadNetmask(addr, netmask):
            msg = &quot;%r is not a valid netmask&quot; % netmask
            with self.assertNetmaskError(re.escape(msg)):
                self.factory((addr, netmask))

        assertBadNetmask(&quot;::1&quot;, -1)
        assertBadNetmask(&quot;::1&quot;, 129)
        assertBadNetmask(&quot;::1%scope&quot;, 129)

    def test_pickle(self):
        self.pickle_test(&quot;2001:db8::1000/124&quot;)
        self.pickle_test(&quot;2001:db8::1000/127&quot;)  # IPV6LENGTH - 1
        self.pickle_test(&quot;2001:db8::1000&quot;)  # IPV6LENGTH

        self.pickle_test(&quot;2001:db8::1000%scope&quot;)  # IPV6LENGTH


class InterfaceTestCase_v6(BaseTestCase, NetmaskTestMixin_v6):
    factory = ipaddress.IPv6Interface


@skipIf(sys.version_info &gt;= (3, 9, 5), &quot;We use builtin ipaddress on Python &gt;= 3.9.5&quot;)
class NetworkTestCase_v6(BaseTestCase, NetmaskTestMixin_v6):
    factory = ipaddress.IPv6Network

    def test_subnet_of(self):
        # containee left of container
        self.assertFalse(
            self.factory(&quot;2000:999::/56&quot;).subnet_of(self.factory(&quot;2000:aaa::/48&quot;))
        )
        # containee inside container
        self.assertTrue(
            self.factory(&quot;2000:aaa::/56&quot;).subnet_of(self.factory(&quot;2000:aaa::/48&quot;))
        )
        # containee right of container
        self.assertFalse(
            self.factory(&quot;2000:bbb::/56&quot;).subnet_of(self.factory(&quot;2000:aaa::/48&quot;))
        )
        # containee larger than container
        self.assertFalse(
            self.factory(&quot;2000:aaa::/48&quot;).subnet_of(self.factory(&quot;2000:aaa::/56&quot;))
        )

        self.assertFalse(
            self.factory(&quot;2000:999::%scope/56&quot;).subnet_of(
                self.factory(&quot;2000:aaa::%scope/48&quot;)
            )
        )
        self.assertTrue(
            self.factory(&quot;2000:aaa::%scope/56&quot;).subnet_of(
                self.factory(&quot;2000:aaa::%scope/48&quot;)
            )
        )

    def test_supernet_of(self):
        # containee left of container
        self.assertFalse(
            self.factory(&quot;2000:999::/56&quot;).supernet_of(self.factory(&quot;2000:aaa::/48&quot;))
        )
        # containee inside container
        self.assertFalse(
            self.factory(&quot;2000:aaa::/56&quot;).supernet_of(self.factory(&quot;2000:aaa::/48&quot;))
        )
        # containee right of container
        self.assertFalse(
            self.factory(&quot;2000:bbb::/56&quot;).supernet_of(self.factory(&quot;2000:aaa::/48&quot;))
        )
        # containee larger than container
        self.assertTrue(
            self.factory(&quot;2000:aaa::/48&quot;).supernet_of(self.factory(&quot;2000:aaa::/56&quot;))
        )


@skipIf(sys.version_info &gt;= (3, 9, 5), &quot;We use builtin ipaddress on Python &gt;= 3.9.5&quot;)
class FactoryFunctionErrors(BaseTestCase):
    def assertFactoryError(self, factory, kind):
        &quot;&quot;&quot;Ensure a clean ValueError with the expected message&quot;&quot;&quot;
        addr = &quot;camelot&quot;
        msg = &quot;%r does not appear to be an IPv4 or IPv6 %s&quot;
        with self.assertCleanError(ValueError, msg, addr, kind):
            factory(addr)

    def test_ip_address(self):
        self.assertFactoryError(ipaddress.ip_address, &quot;address&quot;)

    def test_ip_interface(self):
        self.assertFactoryError(ipaddress.ip_interface, &quot;interface&quot;)

    def test_ip_network(self):
        self.assertFactoryError(ipaddress.ip_network, &quot;network&quot;)


@skipIf(sys.version_info &gt;= (3, 9, 5), &quot;We use builtin ipaddress on Python &gt;= 3.9.5&quot;)
class ComparisonTests(TestCase):

    v4addr = ipaddress.IPv4Address(1)
    v4net = ipaddress.IPv4Network(1)
    v4intf = ipaddress.IPv4Interface(1)
    v6addr = ipaddress.IPv6Address(1)
    v6net = ipaddress.IPv6Network(1)
    v6intf = ipaddress.IPv6Interface(1)
    v6addr_scoped = ipaddress.IPv6Address(&quot;::1%scope&quot;)
    v6net_scoped = ipaddress.IPv6Network(&quot;::1%scope&quot;)
    v6intf_scoped = ipaddress.IPv6Interface(&quot;::1%scope&quot;)

    v4_addresses = [v4addr, v4intf]
    v4_objects = v4_addresses + [v4net]
    v6_addresses = [v6addr, v6intf]
    v6_objects = v6_addresses + [v6net]
    v6_scoped_addresses = [v6addr_scoped, v6intf_scoped]
    v6_scoped_objects = v6_scoped_addresses + [v6net_scoped]

    objects = v4_objects + v6_objects
    objects_with_scoped = objects + v6_scoped_objects

    v4addr2 = ipaddress.IPv4Address(2)
    v4net2 = ipaddress.IPv4Network(2)
    v4intf2 = ipaddress.IPv4Interface(2)
    v6addr2 = ipaddress.IPv6Address(2)
    v6net2 = ipaddress.IPv6Network(2)
    v6intf2 = ipaddress.IPv6Interface(2)
    v6addr2_scoped = ipaddress.IPv6Address(&quot;::2%scope&quot;)
    v6net2_scoped = ipaddress.IPv6Network(&quot;::2%scope&quot;)
    v6intf2_scoped = ipaddress.IPv6Interface(&quot;::2%scope&quot;)

    def test_foreign_type_equality(self):
        # __eq__ should never raise TypeError directly
        other = object()
        for obj in self.objects_with_scoped:
            self.assertNotEqual(obj, other)
            self.assertFalse(obj == other)
            self.assertEqual(obj.__eq__(other), NotImplemented)
            self.assertEqual(obj.__ne__(other), NotImplemented)

    def test_mixed_type_equality(self):
        # Ensure none of the internal objects accidentally
        # expose the right set of attributes to become &quot;equal&quot;
        for lhs in self.objects:
            for rhs in self.objects:
                if lhs is rhs:
                    continue
                self.assertNotEqual(lhs, rhs)

    def test_scoped_ipv6_equality(self):
        for lhs, rhs in zip(self.v6_objects, self.v6_scoped_objects):
            self.assertNotEqual(lhs, rhs)

    def test_v4_with_v6_scoped_equality(self):
        for lhs in self.v4_objects:
            for rhs in self.v6_scoped_objects:
                self.assertNotEqual(lhs, rhs)

    def test_same_type_equality(self):
        for obj in self.objects_with_scoped:
            self.assertEqual(obj, obj)
            self.assertLessEqual(obj, obj)
            self.assertGreaterEqual(obj, obj)

    def test_same_type_ordering(self):
        for lhs, rhs in (
            (self.v4addr, self.v4addr2),
            (self.v4net, self.v4net2),
            (self.v4intf, self.v4intf2),
            (self.v6addr, self.v6addr2),
            (self.v6net, self.v6net2),
            (self.v6intf, self.v6intf2),
            (self.v6addr_scoped, self.v6addr2_scoped),
            (self.v6net_scoped, self.v6net2_scoped),
            (self.v6intf_scoped, self.v6intf2_scoped),
        ):
            self.assertNotEqual(lhs, rhs)
            self.assertLess(lhs, rhs)
            self.assertLessEqual(lhs, rhs)
            self.assertGreater(rhs, lhs)
            self.assertGreaterEqual(rhs, lhs)
            self.assertFalse(lhs &gt; rhs)
            self.assertFalse(rhs &lt; lhs)
            self.assertFalse(lhs &gt;= rhs)
            self.assertFalse(rhs &lt;= lhs)

    def test_containment(self):
        for obj in self.v4_addresses:
            self.assertIn(obj, self.v4net)
        for obj in self.v6_addresses + self.v6_scoped_addresses:
            self.assertIn(obj, self.v6net)
        for obj in self.v6_addresses + self.v6_scoped_addresses:
            self.assertIn(obj, self.v6net_scoped)

        for obj in self.v4_objects + [self.v6net, self.v6net_scoped]:
            self.assertNotIn(obj, self.v6net)
        for obj in self.v4_objects + [self.v6net, self.v6net_scoped]:
            self.assertNotIn(obj, self.v6net_scoped)
        for obj in self.v6_objects + self.v6_scoped_objects + [self.v4net]:
            self.assertNotIn(obj, self.v4net)

    def test_mixed_type_ordering(self):
        for lhs in self.objects_with_scoped:
            for rhs in self.objects_with_scoped:
                if isinstance(lhs, type(rhs)) or isinstance(rhs, type(lhs)):
                    continue
                self.assertRaises(TypeError, lambda: lhs &lt; rhs)
                self.assertRaises(TypeError, lambda: lhs &gt; rhs)
                self.assertRaises(TypeError, lambda: lhs &lt;= rhs)
                self.assertRaises(TypeError, lambda: lhs &gt;= rhs)

    def test_foreign_type_ordering(self):
        other = object()
        for obj in self.objects_with_scoped:
            with self.assertRaises(TypeError):
                obj &lt; other
            with self.assertRaises(TypeError):
                obj &gt; other
            with self.assertRaises(TypeError):
                obj &lt;= other
            with self.assertRaises(TypeError):
                obj &gt;= other
            self.assertTrue(obj &lt; LARGEST)
            self.assertFalse(obj &gt; LARGEST)
            self.assertTrue(obj &lt;= LARGEST)
            self.assertFalse(obj &gt;= LARGEST)
            self.assertFalse(obj &lt; SMALLEST)
            self.assertTrue(obj &gt; SMALLEST)
            self.assertFalse(obj &lt;= SMALLEST)
            self.assertTrue(obj &gt;= SMALLEST)
<A NAME="3"></A>
    def test_mixed_type_key(self):
        # with get_mixed_type_key, you can sort addresses and network.
        v4_ordered = [self<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match103528-0.html#3',2,'match103528-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.v4addr, self.v4net, self.v4intf]
        v6_ordered = [self.v6addr, self.v6net, self.v6intf]
        v6_scoped_ordered = [self.v6addr_scoped, self.v6net_scoped, self.</B></FONT>v6intf_scoped]
        self.assertEqual(
            v4_ordered, sorted(self.v4_objects, key=ipaddress.get_mixed_type_key)
        )
        self.assertEqual(
            v6_ordered, sorted(self.v6_objects, key=ipaddress.get_mixed_type_key)
        )
        self.assertEqual(
            v6_scoped_ordered,
            sorted(self.v6_scoped_objects, key=ipaddress.get_mixed_type_key),
        )
        self.assertEqual(
            v4_ordered + v6_scoped_ordered,
            sorted(
                self.v4_objects + self.v6_scoped_objects,
                key=ipaddress.get_mixed_type_key,
            ),
        )
        self.assertEqual(NotImplemented, ipaddress.get_mixed_type_key(object))

    def test_incompatible_versions(self):
        # These should always raise TypeError
        v4addr = ipaddress.ip_address(&quot;1.1.1.1&quot;)
        v4net = ipaddress.ip_network(&quot;1.1.1.1&quot;)
        v6addr = ipaddress.ip_address(&quot;::1&quot;)
        v6net = ipaddress.ip_network(&quot;::1&quot;)
        v6addr_scoped = ipaddress.ip_address(&quot;::1%scope&quot;)
        v6net_scoped = ipaddress.ip_network(&quot;::1%scope&quot;)

        self.assertRaises(TypeError, v4addr.__lt__, v6addr)
        self.assertRaises(TypeError, v4addr.__gt__, v6addr)
        self.assertRaises(TypeError, v4net.__lt__, v6net)
        self.assertRaises(TypeError, v4net.__gt__, v6net)

        self.assertRaises(TypeError, v6addr.__lt__, v4addr)
        self.assertRaises(TypeError, v6addr.__gt__, v4addr)
        self.assertRaises(TypeError, v6net.__lt__, v4net)
        self.assertRaises(TypeError, v6net.__gt__, v4net)

        self.assertRaises(TypeError, v4addr.__lt__, v6addr_scoped)
        self.assertRaises(TypeError, v4addr.__gt__, v6addr_scoped)
        self.assertRaises(TypeError, v4net.__lt__, v6net_scoped)
        self.assertRaises(TypeError, v4net.__gt__, v6net_scoped)

        self.assertRaises(TypeError, v6addr_scoped.__lt__, v4addr)
        self.assertRaises(TypeError, v6addr_scoped.__gt__, v4addr)
        self.assertRaises(TypeError, v6net_scoped.__lt__, v4net)
        self.assertRaises(TypeError, v6net_scoped.__gt__, v4net)


<A NAME="0"></A>@skipIf(sys.version_info &gt;= (3, 9, 5), &quot;We use builtin ipaddress on Python &gt;= 3.9.5&quot;)
class IpaddrUnitTest(TestCase):
    def setUp(self):
        self.ipv4_address = ipaddress<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match103528-0.html#0',2,'match103528-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.IPv4Address(&quot;1.2.3.4&quot;)
        self.ipv4_interface = ipaddress.IPv4Interface(&quot;1.2.3.4/24&quot;)
<A NAME="6"></A>        self.ipv4_network = ipaddress.IPv4Network(&quot;1.2.3.0/24&quot;)
        # self.ipv4_hostmask = ipaddress.IPv4Interface('10.0.0.1/0.255.255.255')
        self.ipv6_address = ipaddress.IPv6Interface(&quot;2001:658:22a:cafe:200:0:0:1&quot;)
        self.ipv6_interface =</B></FONT> ipaddress<FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match103528-0.html#6',2,'match103528-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.IPv6Interface(&quot;2001:658:22a:cafe:200:0:0:1/64&quot;)
        self.ipv6_network = ipaddress.IPv6Network(&quot;2001:658:22a:cafe::/64&quot;)
        self.ipv6_scoped_address = ipaddress.IPv6Interface(
            &quot;2001:658:22a:cafe:200:0:0:1%scope&quot;
        )
        self.ipv6_scoped_interface =</B></FONT> ipaddress.IPv6Interface(
            &quot;2001:658:22a:cafe:200:0:0:1%scope/64&quot;
        )
        self.ipv6_scoped_network = ipaddress.IPv6Network(&quot;2001:658:22a:cafe::%scope/64&quot;)

    def testRepr(self):
        self.assertEqual(
            &quot;IPv4Interface('1.2.3.4/32')&quot;, repr(ipaddress.IPv4Interface(&quot;1.2.3.4&quot;))
        )
        self.assertEqual(
<A NAME="9"></A>            &quot;IPv6Interface('::1/128')&quot;, repr(ipaddress.IPv6Interface(&quot;::1&quot;))
        )
        self.assertEqual(
            &quot;IPv6Interface('::1%scope/128')&quot;, repr(ipaddress.IPv6Interface(<FONT color="#83a33a"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match103528-0.html#9',2,'match103528-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>&quot;::1%scope&quot;))
        )

    # issue #16531: constructing IPv4Network from an (address, mask) tuple
    def testIPv4Tuple(self):
        # /32
        ip = ipaddress.IPv4Address(&quot;192.0.2.1&quot;)
        net = ipaddress.IPv4Network(&quot;192.0.2.1/32&quot;)
        self.assertEqual(ipaddress.IPv4Network(</B></FONT>(&quot;192.0.2.1&quot;, 32)), net)
        self.assertEqual(ipaddress.IPv4Network((ip, 32)), net)
        self.assertEqual(ipaddress.IPv4Network((3221225985, 32)), net)
        self.assertEqual(ipaddress.IPv4Network((&quot;192.0.2.1&quot;, &quot;255.255.255.255&quot;)), net)
        self.assertEqual(ipaddress.IPv4Network((ip, &quot;255.255.255.255&quot;)), net)
        self.assertEqual(ipaddress.IPv4Network((3221225985, &quot;255.255.255.255&quot;)), net)
        # strict=True and host bits set
        with self.assertRaises(ValueError):
            ipaddress.IPv4Network((&quot;192.0.2.1&quot;, 24))
        with self.assertRaises(ValueError):
            ipaddress.IPv4Network((ip, 24))
        with self.assertRaises(ValueError):
            ipaddress.IPv4Network((3221225985, 24))
        with self.assertRaises(ValueError):
            ipaddress.IPv4Network((&quot;192.0.2.1&quot;, &quot;255.255.255.0&quot;))
        with self.assertRaises(ValueError):
            ipaddress.IPv4Network((ip, &quot;255.255.255.0&quot;))
        with self.assertRaises(ValueError):
            ipaddress.IPv4Network((3221225985, &quot;255.255.255.0&quot;))
        # strict=False and host bits set
        net = ipaddress.IPv4Network(&quot;192.0.2.0/24&quot;)
        self.assertEqual(ipaddress.IPv4Network((&quot;192.0.2.1&quot;, 24), strict=False), net)
        self.assertEqual(ipaddress.IPv4Network((ip, 24), strict=False), net)
        self.assertEqual(ipaddress.IPv4Network((3221225985, 24), strict=False), net)
        self.assertEqual(
            ipaddress.IPv4Network((&quot;192.0.2.1&quot;, &quot;255.255.255.0&quot;), strict=False), net
        )
        self.assertEqual(
            ipaddress.IPv4Network((ip, &quot;255.255.255.0&quot;), strict=False), net
        )
        self.assertEqual(
            ipaddress.IPv4Network((3221225985, &quot;255.255.255.0&quot;), strict=False), net
        )

        # /24
        ip = ipaddress.IPv4Address(&quot;192.0.2.0&quot;)
        net = ipaddress.IPv4Network(&quot;192.0.2.0/24&quot;)
        self.assertEqual(ipaddress.IPv4Network((&quot;192.0.2.0&quot;, &quot;255.255.255.0&quot;)), net)
        self.assertEqual(ipaddress.IPv4Network((ip, &quot;255.255.255.0&quot;)), net)
        self.assertEqual(ipaddress.IPv4Network((3221225984, &quot;255.255.255.0&quot;)), net)
        self.assertEqual(ipaddress.IPv4Network((&quot;192.0.2.0&quot;, 24)), net)
        self.assertEqual(ipaddress.IPv4Network((ip, 24)), net)
        self.assertEqual(ipaddress.IPv4Network((3221225984, 24)), net)

        self.assertEqual(
            ipaddress.IPv4Interface((&quot;192.0.2.1&quot;, 24)),
            ipaddress.IPv4Interface(&quot;192.0.2.1/24&quot;),
<A NAME="8"></A>        )
        self.assertEqual(
            ipaddress.IPv4Interface((3221225985, 24)),
            ipaddress.IPv4Interface(<FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match103528-0.html#8',2,'match103528-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>&quot;192.0.2.1/24&quot;),
        )

    # issue #16531: constructing IPv6Network from an (address, mask) tuple
    def testIPv6Tuple(self):
        # /128
        ip = ipaddress.IPv6Address(&quot;2001:db8::&quot;)
        net = ipaddress.IPv6Network(&quot;2001:db8::/128&quot;)
        self.assertEqual(ipaddress.IPv6Network(</B></FONT>(&quot;2001:db8::&quot;, &quot;128&quot;)), net)
        self.assertEqual(
            ipaddress.IPv6Network((42540766411282592856903984951653826560, 128)), net
        )
        self.assertEqual(ipaddress.IPv6Network((ip, &quot;128&quot;)), net)
        ip = ipaddress.IPv6Address(&quot;2001:db8::&quot;)
        net = ipaddress.IPv6Network(&quot;2001:db8::/96&quot;)
        self.assertEqual(ipaddress.IPv6Network((&quot;2001:db8::&quot;, &quot;96&quot;)), net)
        self.assertEqual(
            ipaddress.IPv6Network((42540766411282592856903984951653826560, 96)), net
        )
        self.assertEqual(ipaddress.IPv6Network((ip, &quot;96&quot;)), net)

        ip_scoped = ipaddress.IPv6Address(&quot;2001:db8::%scope&quot;)

        # strict=True and host bits set
        ip = ipaddress.IPv6Address(&quot;2001:db8::1&quot;)
        with self.assertRaises(ValueError):
            ipaddress.IPv6Network((&quot;2001:db8::1&quot;, 96))
        with self.assertRaises(ValueError):
            ipaddress.IPv6Network((42540766411282592856903984951653826561, 96))
        with self.assertRaises(ValueError):
            ipaddress.IPv6Network((ip, 96))
        # strict=False and host bits set
        net = ipaddress.IPv6Network(&quot;2001:db8::/96&quot;)
        self.assertEqual(ipaddress.IPv6Network((&quot;2001:db8::1&quot;, 96), strict=False), net)
        self.assertEqual(
            ipaddress.IPv6Network(
                (42540766411282592856903984951653826561, 96), strict=False
            ),
            net,
        )
        self.assertEqual(ipaddress.IPv6Network((ip, 96), strict=False), net)

        # /96
        self.assertEqual(
            ipaddress.IPv6Interface((&quot;2001:db8::1&quot;, &quot;96&quot;)),
            ipaddress.IPv6Interface(&quot;2001:db8::1/96&quot;),
        )
        self.assertEqual(
            ipaddress.IPv6Interface((42540766411282592856903984951653826561, &quot;96&quot;)),
            ipaddress.IPv6Interface(&quot;2001:db8::1/96&quot;),
        )

        ip_scoped = ipaddress.IPv6Address(&quot;2001:db8::1%scope&quot;)
        with self.assertRaises(ValueError):
            ipaddress.IPv6Network((&quot;2001:db8::1%scope&quot;, 96))
        with self.assertRaises(ValueError):
            ipaddress.IPv6Network((ip_scoped, 96))
        # strict=False and host bits set

    # issue57
    def testAddressIntMath(self):
        self.assertEqual(
            ipaddress.IPv4Address(&quot;1.1.1.1&quot;) + 255, ipaddress.IPv4Address(&quot;1.1.2.0&quot;)
        )
        self.assertEqual(
            ipaddress.IPv4Address(&quot;1.1.1.1&quot;) - 256, ipaddress.IPv4Address(&quot;1.1.0.1&quot;)
        )
        self.assertEqual(
            ipaddress.IPv6Address(&quot;::1&quot;) + (2 ** 16 - 2),
            ipaddress.IPv6Address(&quot;::ffff&quot;),
        )
        self.assertEqual(
            ipaddress.IPv6Address(&quot;::ffff&quot;) - (2 ** 16 - 2),
            ipaddress.IPv6Address(&quot;::1&quot;),
        )
        self.assertNotEqual(
            ipaddress.IPv6Address(&quot;::1%scope&quot;) + (2 ** 16 - 2),
            ipaddress.IPv6Address(&quot;::ffff%scope&quot;),
        )
        self.assertNotEqual(
            ipaddress.IPv6Address(&quot;::ffff%scope&quot;) - (2 ** 16 - 2),
            ipaddress.IPv6Address(&quot;::1%scope&quot;),
        )

    def testInvalidIntToBytes(self):
        self.assertRaises(ValueError, ipaddress.v4_int_to_packed, -1)
        self.assertRaises(
            ValueError, ipaddress.v4_int_to_packed, 2 ** ipaddress.IPV4LENGTH
        )
        self.assertRaises(ValueError, ipaddress.v6_int_to_packed, -1)
        self.assertRaises(
            ValueError, ipaddress.v6_int_to_packed, 2 ** ipaddress.IPV6LENGTH
        )

    def testInternals(self):
        ip1 = ipaddress.IPv4Address(&quot;10.10.10.10&quot;)
        ip2 = ipaddress.IPv4Address(&quot;10.10.10.11&quot;)
        ip3 = ipaddress.IPv4Address(&quot;10.10.10.12&quot;)
        self.assertEqual(list(ipaddress._find_address_range([ip1])), [(ip1, ip1)])
        self.assertEqual(
            list(ipaddress._find_address_range([ip1, ip3])), [(ip1, ip1), (ip3, ip3)]
        )
        self.assertEqual(
            list(ipaddress._find_address_range([ip1, ip2, ip3])), [(ip1, ip3)]
        )
        self.assertEqual(128, ipaddress._count_righthand_zero_bits(0, 128))
        self.assertEqual(&quot;IPv4Network('1.2.3.0/24')&quot;, repr(self.ipv4_network))

    def testGetNetwork(self):
        self.assertEqual(int(self.ipv4_network.network_address), 16909056)
        self.assertEqual(str(self.ipv4_network.network_address), &quot;1.2.3.0&quot;)

        self.assertEqual(
            int(self.ipv6_network.network_address),
            42540616829182469433403647294022090752,
        )
        self.assertEqual(str(self.ipv6_network.network_address), &quot;2001:658:22a:cafe::&quot;)
        self.assertEqual(str(self.ipv6_network.hostmask), &quot;::ffff:ffff:ffff:ffff&quot;)
        self.assertEqual(
            int(self.ipv6_scoped_network.network_address),
            42540616829182469433403647294022090752,
        )
        self.assertEqual(
            str(self.ipv6_scoped_network.network_address), &quot;2001:658:22a:cafe::%scope&quot;
        )
        self.assertEqual(
            str(self.ipv6_scoped_network.hostmask), &quot;::ffff:ffff:ffff:ffff&quot;
        )

    def testIpFromInt(self):
        self.assertEqual(self.ipv4_interface._ip, ipaddress.IPv4Interface(16909060)._ip)

        ipv4 = ipaddress.ip_network(&quot;1.2.3.4&quot;)
        ipv6 = ipaddress.ip_network(&quot;2001:658:22a:cafe:200:0:0:1&quot;)
        ipv6_scoped = ipaddress.ip_network(&quot;2001:658:22a:cafe:200:0:0:1%scope&quot;)
        self.assertEqual(ipv4, ipaddress.ip_network(int(ipv4.network_address)))
        self.assertEqual(ipv6, ipaddress.ip_network(int(ipv6.network_address)))
        self.assertNotEqual(
            ipv6_scoped, ipaddress.ip_network(int(ipv6_scoped.network_address))
        )

        v6_int = 42540616829182469433547762482097946625
        self.assertEqual(self.ipv6_interface._ip, ipaddress.IPv6Interface(v6_int)._ip)
        self.assertEqual(
            self.ipv6_scoped_interface._ip, ipaddress.IPv6Interface(v6_int)._ip
        )

        self.assertEqual(ipaddress.ip_network(self.ipv4_address._ip).version, 4)
        self.assertEqual(ipaddress.ip_network(self.ipv6_address._ip).version, 6)
        self.assertEqual(ipaddress.ip_network(self.ipv6_scoped_address._ip).version, 6)

    def testIpFromPacked(self):
        address = ipaddress.ip_address
        self.assertEqual(
            self.ipv4_interface._ip, ipaddress.ip_interface(b&quot;\x01\x02\x03\x04&quot;)._ip
        )
        self.assertEqual(address(&quot;255.254.253.252&quot;), address(b&quot;\xff\xfe\xfd\xfc&quot;))
        self.assertEqual(
            self.ipv6_interface.ip,
            ipaddress.ip_interface(
                b&quot;\x20\x01\x06\x58\x02\x2a\xca\xfe\x02\x00\x00\x00\x00\x00\x00\x01&quot;
            ).ip,
        )
        self.assertEqual(
            address(&quot;ffff:2:3:4:ffff::&quot;),
            address(b&quot;\xff\xff\x00\x02\x00\x03\x00\x04&quot; + b&quot;\xff\xff&quot; + b&quot;\x00&quot; * 6),
        )
        self.assertEqual(address(&quot;::&quot;), address(b&quot;\x00&quot; * 16))

    def testGetIp(self):
        self.assertEqual(int(self.ipv4_interface.ip), 16909060)
        self.assertEqual(str(self.ipv4_interface.ip), &quot;1.2.3.4&quot;)

        self.assertEqual(
            int(self.ipv6_interface.ip), 42540616829182469433547762482097946625
        )
        self.assertEqual(str(self.ipv6_interface.ip), &quot;2001:658:22a:cafe:200::1&quot;)
        self.assertEqual(
            int(self.ipv6_scoped_interface.ip), 42540616829182469433547762482097946625
        )
        self.assertEqual(str(self.ipv6_scoped_interface.ip), &quot;2001:658:22a:cafe:200::1&quot;)

    def testGetScopeId(self):
        self.assertEqual(self.ipv6_address.scope_id, None)
        self.assertEqual(str(self.ipv6_scoped_address.scope_id), &quot;scope&quot;)
        self.assertEqual(self.ipv6_interface.scope_id, None)
        self.assertEqual(str(self.ipv6_scoped_interface.scope_id), &quot;scope&quot;)
        self.assertEqual(self.ipv6_network.network_address.scope_id, None)
        self.assertEqual(
            str(self.ipv6_scoped_network.network_address.scope_id), &quot;scope&quot;
        )

    def testGetNetmask(self):
        self.assertEqual(int(self.ipv4_network.netmask), 4294967040)
        self.assertEqual(str(self.ipv4_network.netmask), &quot;255.255.255.0&quot;)
        self.assertEqual(
            int(self.ipv6_network.netmask), 340282366920938463444927863358058659840
        )
        self.assertEqual(self.ipv6_network.prefixlen, 64)
        self.assertEqual(
            int(self.ipv6_scoped_network.netmask),
            340282366920938463444927863358058659840,
        )
        self.assertEqual(self.ipv6_scoped_network.prefixlen, 64)

    def testZeroNetmask(self):
        ipv4_zero_netmask = ipaddress.IPv4Interface(&quot;1.2.3.4/0&quot;)
        self.assertEqual(int(ipv4_zero_netmask.network.netmask), 0)
        self.assertEqual(ipv4_zero_netmask._prefix_from_prefix_string(&quot;0&quot;), 0)

        ipv6_zero_netmask = ipaddress.IPv6Interface(&quot;::1/0&quot;)
        self.assertEqual(int(ipv6_zero_netmask.network.netmask), 0)
        self.assertEqual(ipv6_zero_netmask._prefix_from_prefix_string(&quot;0&quot;), 0)

        ipv6_scoped_zero_netmask = ipaddress.IPv6Interface(&quot;::1%scope/0&quot;)
        self.assertEqual(int(ipv6_scoped_zero_netmask.network.netmask), 0)
        self.assertEqual(ipv6_scoped_zero_netmask._prefix_from_prefix_string(&quot;0&quot;), 0)

    def testIPv4Net(self):
        net = ipaddress.IPv4Network(&quot;127.0.0.0/0.0.0.255&quot;)
        self.assertEqual(net.prefixlen, 24)

    def testGetBroadcast(self):
        self.assertEqual(int(self.ipv4_network.broadcast_address), 16909311)
        self.assertEqual(str(self.ipv4_network.broadcast_address), &quot;1.2.3.255&quot;)

        self.assertEqual(
            int(self.ipv6_network.broadcast_address),
            42540616829182469451850391367731642367,
        )
        self.assertEqual(
            str(self.ipv6_network.broadcast_address),
            &quot;2001:658:22a:cafe:ffff:ffff:ffff:ffff&quot;,
        )

        self.assertEqual(
            int(self.ipv6_scoped_network.broadcast_address),
            42540616829182469451850391367731642367,
        )
        self.assertEqual(
            str(self.ipv6_scoped_network.broadcast_address),
            &quot;2001:658:22a:cafe:ffff:ffff:ffff:ffff&quot;,
        )

    def testGetPrefixlen(self):
        self.assertEqual(self.ipv4_interface.network.prefixlen, 24)
        self.assertEqual(self.ipv6_interface.network.prefixlen, 64)
        self.assertEqual(self.ipv6_scoped_interface.network.prefixlen, 64)

    def testGetSupernet(self):
        self.assertEqual(self.ipv4_network.supernet().prefixlen, 23)
        self.assertEqual(str(self.ipv4_network.supernet().network_address), &quot;1.2.2.0&quot;)
        self.assertEqual(
            ipaddress.IPv4Interface(&quot;0.0.0.0/0&quot;).network.supernet(),
            ipaddress.IPv4Network(&quot;0.0.0.0/0&quot;),
        )

        self.assertEqual(self.ipv6_network.supernet().prefixlen, 63)
        self.assertEqual(
            str(self.ipv6_network.supernet().network_address), &quot;2001:658:22a:cafe::&quot;
        )
        self.assertEqual(
            ipaddress.IPv6Interface(&quot;::0/0&quot;).network.supernet(),
            ipaddress.IPv6Network(&quot;::0/0&quot;),
        )
        self.assertEqual(self.ipv6_scoped_network.supernet().prefixlen, 63)
        self.assertEqual(
            str(self.ipv6_scoped_network.supernet().network_address),
            &quot;2001:658:22a:cafe::&quot;,
        )

    def testGetSupernet3(self):
        self.assertEqual(self.ipv4_network.supernet(3).prefixlen, 21)
        self.assertEqual(str(self.ipv4_network.supernet(3).network_address), &quot;1.2.0.0&quot;)

        self.assertEqual(self.ipv6_network.supernet(3).prefixlen, 61)
        self.assertEqual(
            str(self.ipv6_network.supernet(3).network_address), &quot;2001:658:22a:caf8::&quot;
        )
        self.assertEqual(self.ipv6_scoped_network.supernet(3).prefixlen, 61)
        self.assertEqual(
            str(self.ipv6_scoped_network.supernet(3).network_address),
            &quot;2001:658:22a:caf8::&quot;,
        )

    def testGetSupernet4(self):
        self.assertRaises(
            ValueError, self.ipv4_network.supernet, prefixlen_diff=2, new_prefix=1
        )
        self.assertRaises(ValueError, self.ipv4_network.supernet, new_prefix=25)
        self.assertEqual(
            self.ipv4_network.supernet(prefixlen_diff=2),
            self.ipv4_network.supernet(new_prefix=22),
        )

        self.assertRaises(
            ValueError, self.ipv6_network.supernet, prefixlen_diff=2, new_prefix=1
        )
        self.assertRaises(ValueError, self.ipv6_network.supernet, new_prefix=65)
        self.assertEqual(
            self.ipv6_network.supernet(prefixlen_diff=2),
            self.ipv6_network.supernet(new_prefix=62),
        )
        self.assertRaises(
            ValueError,
            self.ipv6_scoped_network.supernet,
            prefixlen_diff=2,
            new_prefix=1,
        )
        self.assertRaises(ValueError, self.ipv6_scoped_network.supernet, new_prefix=65)
        self.assertEqual(
            self.ipv6_scoped_network.supernet(prefixlen_diff=2),
            self.ipv6_scoped_network.supernet(new_prefix=62),
        )

    def testHosts(self):
        hosts = list(self.ipv4_network.hosts())
        self.assertEqual(254, len(hosts))
        self.assertEqual(ipaddress.IPv4Address(&quot;1.2.3.1&quot;), hosts[0])
        self.assertEqual(ipaddress.IPv4Address(&quot;1.2.3.254&quot;), hosts[-1])

        ipv6_network = ipaddress.IPv6Network(&quot;2001:658:22a:cafe::/120&quot;)
        hosts = list(ipv6_network.hosts())
        self.assertEqual(255, len(hosts))
        self.assertEqual(ipaddress.IPv6Address(&quot;2001:658:22a:cafe::1&quot;), hosts[0])
        self.assertEqual(ipaddress.IPv6Address(&quot;2001:658:22a:cafe::ff&quot;), hosts[-1])

        ipv6_scoped_network = ipaddress.IPv6Network(&quot;2001:658:22a:cafe::%scope/120&quot;)
        hosts = list(ipv6_scoped_network.hosts())
        self.assertEqual(255, len(hosts))
        self.assertEqual(ipaddress.IPv6Address(&quot;2001:658:22a:cafe::1&quot;), hosts[0])
        self.assertEqual(ipaddress.IPv6Address(&quot;2001:658:22a:cafe::ff&quot;), hosts[-1])

        # special case where only 1 bit is left for address
        addrs = [ipaddress.IPv4Address(&quot;2.0.0.0&quot;), ipaddress.IPv4Address(&quot;2.0.0.1&quot;)]
        str_args = &quot;2.0.0.0/31&quot;
        tpl_args = (&quot;2.0.0.0&quot;, 31)
        self.assertEqual(addrs, list(ipaddress.ip_network(str_args).hosts()))
        self.assertEqual(addrs, list(ipaddress.ip_network(tpl_args).hosts()))
        self.assertEqual(
            list(ipaddress.ip_network(str_args).hosts()),
            list(ipaddress.ip_network(tpl_args).hosts()),
        )

        # special case where the network is a /32
        addrs = [ipaddress.IPv4Address(&quot;1.2.3.4&quot;)]
        str_args = &quot;1.2.3.4/32&quot;
        tpl_args = (&quot;1.2.3.4&quot;, 32)
        self.assertEqual(addrs, list(ipaddress.ip_network(str_args).hosts()))
        self.assertEqual(addrs, list(ipaddress.ip_network(tpl_args).hosts()))
        self.assertEqual(
            list(ipaddress.ip_network(str_args).hosts()),
            list(ipaddress.ip_network(tpl_args).hosts()),
        )

        addrs = [
            ipaddress.IPv6Address(&quot;2001:658:22a:cafe::&quot;),
            ipaddress.IPv6Address(&quot;2001:658:22a:cafe::1&quot;),
        ]
        str_args = &quot;2001:658:22a:cafe::/127&quot;
        tpl_args = (&quot;2001:658:22a:cafe::&quot;, 127)
        self.assertEqual(addrs, list(ipaddress.ip_network(str_args).hosts()))
        self.assertEqual(addrs, list(ipaddress.ip_network(tpl_args).hosts()))
        self.assertEqual(
            list(ipaddress.ip_network(str_args).hosts()),
            list(ipaddress.ip_network(tpl_args).hosts()),
        )

        addrs = [
            ipaddress.IPv6Address(&quot;2001:658:22a:cafe::1&quot;),
        ]
        str_args = &quot;2001:658:22a:cafe::1/128&quot;
        tpl_args = (&quot;2001:658:22a:cafe::1&quot;, 128)
        self.assertEqual(addrs, list(ipaddress.ip_network(str_args).hosts()))
        self.assertEqual(addrs, list(ipaddress.ip_network(tpl_args).hosts()))
        self.assertEqual(
            list(ipaddress.ip_network(str_args).hosts()),
            list(ipaddress.ip_network(tpl_args).hosts()),
        )

    def testFancySubnetting(self):
        self.assertEqual(
            sorted(self.ipv4_network.subnets(prefixlen_diff=3)),
            sorted(self.ipv4_network.subnets(new_prefix=27)),
        )
        self.assertRaises(ValueError, list, self.ipv4_network.subnets(new_prefix=23))
        self.assertRaises(
            ValueError, list, self.ipv4_network.subnets(prefixlen_diff=3, new_prefix=27)
        )
        self.assertEqual(
            sorted(self.ipv6_network.subnets(prefixlen_diff=4)),
            sorted(self.ipv6_network.subnets(new_prefix=68)),
        )
        self.assertRaises(ValueError, list, self.ipv6_network.subnets(new_prefix=63))
        self.assertRaises(
            ValueError, list, self.ipv6_network.subnets(prefixlen_diff=4, new_prefix=68)
        )
        self.assertEqual(
            sorted(self.ipv6_scoped_network.subnets(prefixlen_diff=4)),
            sorted(self.ipv6_scoped_network.subnets(new_prefix=68)),
        )
        self.assertRaises(
            ValueError, list, self.ipv6_scoped_network.subnets(new_prefix=63)
        )
        self.assertRaises(
            ValueError,
            list,
            self.ipv6_scoped_network.subnets(prefixlen_diff=4, new_prefix=68),
        )

    def testGetSubnets(self):
        self.assertEqual(list(self.ipv4_network.subnets())[0].prefixlen, 25)
        self.assertEqual(
            str(list(self.ipv4_network.subnets())[0].network_address), &quot;1.2.3.0&quot;
        )
        self.assertEqual(
            str(list(self.ipv4_network.subnets())[1].network_address), &quot;1.2.3.128&quot;
        )

        self.assertEqual(list(self.ipv6_network.subnets())[0].prefixlen, 65)
        self.assertEqual(list(self.ipv6_scoped_network.subnets())[0].prefixlen, 65)

    def testGetSubnetForSingle32(self):
        ip = ipaddress.IPv4Network(&quot;1.2.3.4/32&quot;)
        subnets1 = [str(x) for x in ip.subnets()]
        subnets2 = [str(x) for x in ip.subnets(2)]
        self.assertEqual(subnets1, [&quot;1.2.3.4/32&quot;])
        self.assertEqual(subnets1, subnets2)

    def testGetSubnetForSingle128(self):
        ip = ipaddress.IPv6Network(&quot;::1/128&quot;)
        subnets1 = [str(x) for x in ip.subnets()]
        subnets2 = [str(x) for x in ip.subnets(2)]
        self.assertEqual(subnets1, [&quot;::1/128&quot;])
        self.assertEqual(subnets1, subnets2)

        ip_scoped = ipaddress.IPv6Network(&quot;::1%scope/128&quot;)
        subnets1 = [str(x) for x in ip_scoped.subnets()]
        subnets2 = [str(x) for x in ip_scoped.subnets(2)]
        self.assertEqual(subnets1, [&quot;::1%scope/128&quot;])
        self.assertEqual(subnets1, subnets2)

    def testSubnet2(self):
        ips = [str(x) for x in self.ipv4_network.subnets(2)]
        self.assertEqual(
            ips, [&quot;1.2.3.0/26&quot;, &quot;1.2.3.64/26&quot;, &quot;1.2.3.128/26&quot;, &quot;1.2.3.192/26&quot;]
        )

        ipsv6 = [str(x) for x in self.ipv6_network.subnets(2)]
        self.assertEqual(
            ipsv6,
            [
                &quot;2001:658:22a:cafe::/66&quot;,
                &quot;2001:658:22a:cafe:4000::/66&quot;,
                &quot;2001:658:22a:cafe:8000::/66&quot;,
                &quot;2001:658:22a:cafe:c000::/66&quot;,
            ],
        )

    def testGetSubnets3(self):
        subnets = [str(x) for x in self.ipv4_network.subnets(8)]
        self.assertEqual(subnets[:3], [&quot;1.2.3.0/32&quot;, &quot;1.2.3.1/32&quot;, &quot;1.2.3.2/32&quot;])
        self.assertEqual(subnets[-3:], [&quot;1.2.3.253/32&quot;, &quot;1.2.3.254/32&quot;, &quot;1.2.3.255/32&quot;])
        self.assertEqual(len(subnets), 256)

        ipv6_network = ipaddress.IPv6Network(&quot;2001:658:22a:cafe::/120&quot;)
        subnets = [str(x) for x in ipv6_network.subnets(8)]
        self.assertEqual(
            subnets[:3],
            [
                &quot;2001:658:22a:cafe::/128&quot;,
                &quot;2001:658:22a:cafe::1/128&quot;,
                &quot;2001:658:22a:cafe::2/128&quot;,
            ],
        )
        self.assertEqual(
            subnets[-3:],
            [
                &quot;2001:658:22a:cafe::fd/128&quot;,
                &quot;2001:658:22a:cafe::fe/128&quot;,
                &quot;2001:658:22a:cafe::ff/128&quot;,
            ],
        )
        self.assertEqual(len(subnets), 256)

    def testSubnetFailsForLargeCidrDiff(self):
        self.assertRaises(ValueError, list, self.ipv4_interface.network.subnets(9))
        self.assertRaises(ValueError, list, self.ipv4_network.subnets(9))
        self.assertRaises(ValueError, list, self.ipv6_interface.network.subnets(65))
        self.assertRaises(ValueError, list, self.ipv6_network.subnets(65))
        self.assertRaises(
            ValueError, list, self.ipv6_scoped_interface.network.subnets(65)
        )
        self.assertRaises(ValueError, list, self.ipv6_scoped_network.subnets(65))

    def testSupernetFailsForLargeCidrDiff(self):
        self.assertRaises(ValueError, self.ipv4_interface.network.supernet, 25)
        self.assertRaises(ValueError, self.ipv6_interface.network.supernet, 65)
        self.assertRaises(ValueError, self.ipv6_scoped_interface.network.supernet, 65)

    def testSubnetFailsForNegativeCidrDiff(self):
        self.assertRaises(ValueError, list, self.ipv4_interface.network.subnets(-1))
        self.assertRaises(ValueError, list, self.ipv4_network.subnets(-1))
        self.assertRaises(ValueError, list, self.ipv6_interface.network.subnets(-1))
        self.assertRaises(ValueError, list, self.ipv6_network.subnets(-1))
        self.assertRaises(
            ValueError, list, self.ipv6_scoped_interface.network.subnets(-1)
        )
        self.assertRaises(ValueError, list, self.ipv6_scoped_network.subnets(-1))

    def testGetNum_Addresses(self):
        self.assertEqual(self.ipv4_network.num_addresses, 256)
        self.assertEqual(list(self.ipv4_network.subnets())[0].num_addresses, 128)
        self.assertEqual(self.ipv4_network.supernet().num_addresses, 512)

        self.assertEqual(self.ipv6_network.num_addresses, 18446744073709551616)
        self.assertEqual(
            list(self.ipv6_network.subnets())[0].num_addresses, 9223372036854775808
        )
        self.assertEqual(
            self.ipv6_network.supernet().num_addresses, 36893488147419103232
        )
        self.assertEqual(self.ipv6_scoped_network.num_addresses, 18446744073709551616)
        self.assertEqual(
            list(self.ipv6_scoped_network.subnets())[0].num_addresses,
            9223372036854775808,
        )
        self.assertEqual(
            self.ipv6_scoped_network.supernet().num_addresses, 36893488147419103232
        )

    def testContains(self):
        self.assertIn(ipaddress.IPv4Interface(&quot;1.2.3.128/25&quot;), self.ipv4_network)
        self.assertNotIn(ipaddress.IPv4Interface(&quot;1.2.4.1/24&quot;), self.ipv4_network)
        # We can test addresses and string as well.
        addr1 = ipaddress.IPv4Address(&quot;1.2.3.37&quot;)
        self.assertIn(addr1, self.ipv4_network)
        # issue 61, bad network comparison on like-ip'd network objects
        # with identical broadcast addresses.
        self.assertFalse(
            ipaddress.IPv4Network(&quot;1.1.0.0/16&quot;).__contains__(
                ipaddress.IPv4Network(&quot;1.0.0.0/15&quot;)
            )
        )

    def testNth(self):
        self.assertEqual(str(self.ipv4_network[5]), &quot;1.2.3.5&quot;)
        self.assertRaises(IndexError, self.ipv4_network.__getitem__, 256)

        self.assertEqual(str(self.ipv6_network[5]), &quot;2001:658:22a:cafe::5&quot;)
        self.assertRaises(IndexError, self.ipv6_network.__getitem__, 1 &lt;&lt; 64)
        self.assertEqual(str(self.ipv6_scoped_network[5]), &quot;2001:658:22a:cafe::5&quot;)
        self.assertRaises(IndexError, self.ipv6_scoped_network.__getitem__, 1 &lt;&lt; 64)

    def testGetitem(self):
        # http://code.google.com/p/ipaddr-py/issues/detail?id=15
        addr = ipaddress.IPv4Network(&quot;172.31.255.128/255.255.255.240&quot;)
        self.assertEqual(28, addr.prefixlen)
        addr_list = list(addr)
        self.assertEqual(&quot;172.31.255.128&quot;, str(addr_list[0]))
        self.assertEqual(&quot;172.31.255.128&quot;, str(addr[0]))
        self.assertEqual(&quot;172.31.255.143&quot;, str(addr_list[-1]))
        self.assertEqual(&quot;172.31.255.143&quot;, str(addr[-1]))
        self.assertEqual(addr_list[-1], addr[-1])

    def testEqual(self):
        self.assertTrue(self.ipv4_interface == ipaddress.IPv4Interface(&quot;1.2.3.4/24&quot;))
        self.assertFalse(self.ipv4_interface == ipaddress.IPv4Interface(&quot;1.2.3.4/23&quot;))
        self.assertFalse(self.ipv4_interface == ipaddress.IPv6Interface(&quot;::1.2.3.4/24&quot;))
        self.assertFalse(
            self.ipv4_interface == ipaddress.IPv6Interface(&quot;::1.2.3.4%scope/24&quot;)
        )
        self.assertFalse(self.ipv4_interface == &quot;&quot;)
        self.assertFalse(self.ipv4_interface == [])
        self.assertFalse(self.ipv4_interface == 2)

        self.assertTrue(
            self.ipv6_interface
            == ipaddress.IPv6Interface(&quot;2001:658:22a:cafe:200::1/64&quot;)
        )
        self.assertFalse(
            self.ipv6_interface
            == ipaddress.IPv6Interface(&quot;2001:658:22a:cafe:200::1/63&quot;)
        )
        self.assertFalse(self.ipv6_interface == ipaddress.IPv4Interface(&quot;1.2.3.4/23&quot;))
        self.assertFalse(self.ipv6_interface == &quot;&quot;)
        self.assertFalse(self.ipv6_interface == [])
        self.assertFalse(self.ipv6_interface == 2)

        self.assertTrue(
            self.ipv6_scoped_interface
            == ipaddress.IPv6Interface(&quot;2001:658:22a:cafe:200::1%scope/64&quot;)
        )
        self.assertFalse(
            self.ipv6_scoped_interface
            == ipaddress.IPv6Interface(&quot;2001:658:22a:cafe:200::1%scope/63&quot;)
        )
        self.assertFalse(
            self.ipv6_scoped_interface
            == ipaddress.IPv6Interface(&quot;2001:658:22a:cafe:200::1/64&quot;)
        )
        self.assertFalse(
            self.ipv6_scoped_interface
            == ipaddress.IPv6Interface(&quot;2001:658:22a:cafe:200::1/63&quot;)
        )
        self.assertFalse(
            self.ipv6_scoped_interface == ipaddress.IPv4Interface(&quot;1.2.3.4/23&quot;)
        )
        self.assertFalse(self.ipv6_scoped_interface == &quot;&quot;)
        self.assertFalse(self.ipv6_scoped_interface == [])
        self.assertFalse(self.ipv6_scoped_interface == 2)

    def testNotEqual(self):
        self.assertFalse(self.ipv4_interface != ipaddress.IPv4Interface(&quot;1.2.3.4/24&quot;))
        self.assertTrue(self.ipv4_interface != ipaddress.IPv4Interface(&quot;1.2.3.4/23&quot;))
        self.assertTrue(self.ipv4_interface != ipaddress.IPv6Interface(&quot;::1.2.3.4/24&quot;))
        self.assertTrue(
            self.ipv4_interface != ipaddress.IPv6Interface(&quot;::1.2.3.4%scope/24&quot;)
        )
        self.assertTrue(self.ipv4_interface != &quot;&quot;)
        self.assertTrue(self.ipv4_interface != [])
        self.assertTrue(self.ipv4_interface != 2)

        self.assertTrue(self.ipv4_address != ipaddress.IPv4Address(&quot;1.2.3.5&quot;))
        self.assertTrue(self.ipv4_address != &quot;&quot;)
        self.assertTrue(self.ipv4_address != [])
        self.assertTrue(self.ipv4_address != 2)

        self.assertFalse(
            self.ipv6_interface
            != ipaddress.IPv6Interface(&quot;2001:658:22a:cafe:200::1/64&quot;)
        )
        self.assertTrue(
            self.ipv6_interface
            != ipaddress.IPv6Interface(&quot;2001:658:22a:cafe:200::1/63&quot;)
        )
        self.assertTrue(self.ipv6_interface != ipaddress.IPv4Interface(&quot;1.2.3.4/23&quot;))
        self.assertTrue(self.ipv6_interface != &quot;&quot;)
        self.assertTrue(self.ipv6_interface != [])
        self.assertTrue(self.ipv6_interface != 2)

        self.assertTrue(self.ipv6_address != ipaddress.IPv4Address(&quot;1.2.3.4&quot;))
        self.assertTrue(self.ipv6_address != &quot;&quot;)
        self.assertTrue(self.ipv6_address != [])
        self.assertTrue(self.ipv6_address != 2)

        self.assertFalse(
            self.ipv6_scoped_interface
            != ipaddress.IPv6Interface(&quot;2001:658:22a:cafe:200::1%scope/64&quot;)
        )
        self.assertTrue(
            self.ipv6_scoped_interface
            != ipaddress.IPv6Interface(&quot;2001:658:22a:cafe:200::1%scope/63&quot;)
        )
        self.assertTrue(
            self.ipv6_scoped_interface
            != ipaddress.IPv6Interface(&quot;2001:658:22a:cafe:200::1/64&quot;)
        )
        self.assertTrue(
            self.ipv6_scoped_interface
            != ipaddress.IPv6Interface(&quot;2001:658:22a:cafe:200::1/63&quot;)
        )
        self.assertTrue(
            self.ipv6_scoped_interface != ipaddress.IPv4Interface(&quot;1.2.3.4/23&quot;)
        )
        self.assertTrue(self.ipv6_scoped_interface != &quot;&quot;)
        self.assertTrue(self.ipv6_scoped_interface != [])
        self.assertTrue(self.ipv6_scoped_interface != 2)

        self.assertTrue(self.ipv6_scoped_address != ipaddress.IPv4Address(&quot;1.2.3.4&quot;))
        self.assertTrue(self.ipv6_scoped_address != &quot;&quot;)
        self.assertTrue(self.ipv6_scoped_address != [])
        self.assertTrue(self.ipv6_scoped_address != 2)

    def testSlash32Constructor(self):
        self.assertEqual(
            str(ipaddress.IPv4Interface(&quot;1.2.3.4/255.255.255.255&quot;)), &quot;1.2.3.4/32&quot;
        )

    def testSlash128Constructor(self):
        self.assertEqual(str(ipaddress.IPv6Interface(&quot;::1/128&quot;)), &quot;::1/128&quot;)
        self.assertEqual(str(ipaddress.IPv6Interface(&quot;::1%scope/128&quot;)), &quot;::1%scope/128&quot;)

    def testSlash0Constructor(self):
        self.assertEqual(str(ipaddress.IPv4Interface(&quot;1.2.3.4/0.0.0.0&quot;)), &quot;1.2.3.4/0&quot;)

    def testCollapsing(self):
        # test only IP addresses including some duplicates
        ip1 = ipaddress.IPv4Address(&quot;1.1.1.0&quot;)
        ip2 = ipaddress.IPv4Address(&quot;1.1.1.1&quot;)
        ip3 = ipaddress.IPv4Address(&quot;1.1.1.2&quot;)
        ip4 = ipaddress.IPv4Address(&quot;1.1.1.3&quot;)
        ip5 = ipaddress.IPv4Address(&quot;1.1.1.4&quot;)
        ip6 = ipaddress.IPv4Address(&quot;1.1.1.0&quot;)
        # check that addresses are subsumed properly.
        collapsed = ipaddress.collapse_addresses([ip1, ip2, ip3, ip4, ip5, ip6])
        self.assertEqual(
            list(collapsed),
            [ipaddress.IPv4Network(&quot;1.1.1.0/30&quot;), ipaddress.IPv4Network(&quot;1.1.1.4/32&quot;)],
        )

        # test a mix of IP addresses and networks including some duplicates
        ip1 = ipaddress.IPv4Address(&quot;1.1.1.0&quot;)
        ip2 = ipaddress.IPv4Address(&quot;1.1.1.1&quot;)
        ip3 = ipaddress.IPv4Address(&quot;1.1.1.2&quot;)
        ip4 = ipaddress.IPv4Address(&quot;1.1.1.3&quot;)
        # ip5 = ipaddress.IPv4Interface('1.1.1.4/30')
        # ip6 = ipaddress.IPv4Interface('1.1.1.4/30')
        # check that addresses are subsumed properly.
        collapsed = ipaddress.collapse_addresses([ip1, ip2, ip3, ip4])
        self.assertEqual(list(collapsed), [ipaddress.IPv4Network(&quot;1.1.1.0/30&quot;)])

        # test only IP networks
        ip1 = ipaddress.IPv4Network(&quot;1.1.0.0/24&quot;)
        ip2 = ipaddress.IPv4Network(&quot;1.1.1.0/24&quot;)
        ip3 = ipaddress.IPv4Network(&quot;1.1.2.0/24&quot;)
        ip4 = ipaddress.IPv4Network(&quot;1.1.3.0/24&quot;)
        ip5 = ipaddress.IPv4Network(&quot;1.1.4.0/24&quot;)
        # stored in no particular order b/c we want CollapseAddr to call
        # [].sort
        ip6 = ipaddress.IPv4Network(&quot;1.1.0.0/22&quot;)
        # check that addresses are subsumed properly.
        collapsed = ipaddress.collapse_addresses([ip1, ip2, ip3, ip4, ip5, ip6])
        self.assertEqual(
            list(collapsed),
            [ipaddress.IPv4Network(&quot;1.1.0.0/22&quot;), ipaddress.IPv4Network(&quot;1.1.4.0/24&quot;)],
        )

        # test that two addresses are supernet'ed properly
        collapsed = ipaddress.collapse_addresses([ip1, ip2])
        self.assertEqual(list(collapsed), [ipaddress.IPv4Network(&quot;1.1.0.0/23&quot;)])

        # test same IP networks
        ip_same1 = ip_same2 = ipaddress.IPv4Network(&quot;1.1.1.1/32&quot;)
        self.assertEqual(
            list(ipaddress.collapse_addresses([ip_same1, ip_same2])), [ip_same1]
        )

        # test same IP addresses
        ip_same1 = ip_same2 = ipaddress.IPv4Address(&quot;1.1.1.1&quot;)
        self.assertEqual(
            list(ipaddress.collapse_addresses([ip_same1, ip_same2])),
            [ipaddress.ip_network(&quot;1.1.1.1/32&quot;)],
        )
        ip1 = ipaddress.IPv6Network(&quot;2001::/100&quot;)
        ip2 = ipaddress.IPv6Network(&quot;2001::/120&quot;)
        ip3 = ipaddress.IPv6Network(&quot;2001::/96&quot;)
        # test that ipv6 addresses are subsumed properly.
        collapsed = ipaddress.collapse_addresses([ip1, ip2, ip3])
        self.assertEqual(list(collapsed), [ip3])

        ip1 = ipaddress.IPv6Network(&quot;2001::%scope/100&quot;)
        ip2 = ipaddress.IPv6Network(&quot;2001::%scope/120&quot;)
        ip3 = ipaddress.IPv6Network(&quot;2001::%scope/96&quot;)
        # test that ipv6 addresses are subsumed properly.
        collapsed = ipaddress.collapse_addresses([ip1, ip2, ip3])
        self.assertEqual(list(collapsed), [ip3])

        # the toejam test
        addr_tuples = [
            (ipaddress.ip_address(&quot;1.1.1.1&quot;), ipaddress.ip_address(&quot;::1&quot;)),
            (ipaddress.IPv4Network(&quot;1.1.0.0/24&quot;), ipaddress.IPv6Network(&quot;2001::/120&quot;)),
            (ipaddress.IPv4Network(&quot;1.1.0.0/32&quot;), ipaddress.IPv6Network(&quot;2001::/128&quot;)),
        ]
        for ip1, ip2 in addr_tuples:
            self.assertRaises(TypeError, ipaddress.collapse_addresses, [ip1, ip2])

        addr_tuples = [
            (ipaddress.ip_address(&quot;1.1.1.1&quot;), ipaddress.ip_address(&quot;::1%scope&quot;)),
            (
                ipaddress.IPv4Network(&quot;1.1.0.0/24&quot;),
                ipaddress.IPv6Network(&quot;2001::%scope/120&quot;),
            ),
            (
                ipaddress.IPv4Network(&quot;1.1.0.0/32&quot;),
                ipaddress.IPv6Network(&quot;2001::%scope/128&quot;),
            ),
        ]
        for ip1, ip2 in addr_tuples:
            self.assertRaises(TypeError, ipaddress.collapse_addresses, [ip1, ip2])

    def testSummarizing(self):
        # ip = ipaddress.ip_address
        # ipnet = ipaddress.ip_network
        summarize = ipaddress.summarize_address_range
        ip1 = ipaddress.ip_address(&quot;1.1.1.0&quot;)
        ip2 = ipaddress.ip_address(&quot;1.1.1.255&quot;)

        # summarize works only for IPv4 &amp; IPv6
        class IPv7Address(ipaddress.IPv6Address):
            @property
            def version(self):
                return 7

        ip_invalid1 = IPv7Address(&quot;::1&quot;)
        ip_invalid2 = IPv7Address(&quot;::1&quot;)
        self.assertRaises(ValueError, list, summarize(ip_invalid1, ip_invalid2))
        # test that a summary over ip4 &amp; ip6 fails
        self.assertRaises(TypeError, list, summarize(ip1, ipaddress.IPv6Address(&quot;::1&quot;)))
        self.assertRaises(
            TypeError, list, summarize(ip1, ipaddress.IPv6Address(&quot;::1%scope&quot;))
        )
        # test a /24 is summarized properly
        self.assertEqual(
            list(summarize(ip1, ip2))[0], ipaddress.ip_network(&quot;1.1.1.0/24&quot;)
        )
        # test an IPv4 range that isn't on a network byte boundary
        ip2 = ipaddress.ip_address(&quot;1.1.1.8&quot;)
        self.assertEqual(
            list(summarize(ip1, ip2)),
            [ipaddress.ip_network(&quot;1.1.1.0/29&quot;), ipaddress.ip_network(&quot;1.1.1.8&quot;)],
        )
        # all!
        ip1 = ipaddress.IPv4Address(0)
        ip2 = ipaddress.IPv4Address(ipaddress.IPv4Address._ALL_ONES)
        self.assertEqual(
            [ipaddress.IPv4Network(&quot;0.0.0.0/0&quot;)], list(summarize(ip1, ip2))
        )

        ip1 = ipaddress.ip_address(&quot;1::&quot;)
        ip2 = ipaddress.ip_address(&quot;1:ffff:ffff:ffff:ffff:ffff:ffff:ffff&quot;)
        # test an IPv6 is summarized properly
        self.assertEqual(list(summarize(ip1, ip2))[0], ipaddress.ip_network(&quot;1::/16&quot;))
        # test an IPv6 range that isn't on a network byte boundary
        ip2 = ipaddress.ip_address(&quot;2::&quot;)
        self.assertEqual(
            list(summarize(ip1, ip2)),
            [ipaddress.ip_network(&quot;1::/16&quot;), ipaddress.ip_network(&quot;2::/128&quot;)],
        )

        ip1 = ipaddress.ip_address(&quot;1::%scope&quot;)
        ip2 = ipaddress.ip_address(&quot;1:ffff:ffff:ffff:ffff:ffff:ffff:ffff%scope&quot;)
        # test an IPv6 is summarized properly
        self.assertEqual(list(summarize(ip1, ip2))[0], ipaddress.ip_network(&quot;1::/16&quot;))
        # test an IPv6 range that isn't on a network byte boundary
        ip2 = ipaddress.ip_address(&quot;2::%scope&quot;)
        self.assertEqual(
            list(summarize(ip1, ip2)),
            [ipaddress.ip_network(&quot;1::/16&quot;), ipaddress.ip_network(&quot;2::/128&quot;)],
        )

        # test exception raised when first is greater than last
        self.assertRaises(
            ValueError,
            list,
            summarize(ipaddress.ip_address(&quot;1.1.1.0&quot;), ipaddress.ip_address(&quot;1.1.0.0&quot;)),
        )
        # test exception raised when first and last aren't IP addresses
        self.assertRaises(
            TypeError,
            list,
            summarize(ipaddress.ip_network(&quot;1.1.1.0&quot;), ipaddress.ip_network(&quot;1.1.0.0&quot;)),
        )
        self.assertRaises(
            TypeError,
            list,
            summarize(ipaddress.ip_network(&quot;1.1.1.0&quot;), ipaddress.ip_network(&quot;1.1.0.0&quot;)),
        )
        # test exception raised when first and last are not same version
        self.assertRaises(
            TypeError,
            list,
            summarize(ipaddress.ip_address(&quot;::&quot;), ipaddress.ip_network(&quot;1.1.0.0&quot;)),
        )

    def testAddressComparison(self):
        self.assertTrue(
            ipaddress.ip_address(&quot;1.1.1.1&quot;) &lt;= ipaddress.ip_address(&quot;1.1.1.1&quot;)
        )
        self.assertTrue(
            ipaddress.ip_address(&quot;1.1.1.1&quot;) &lt;= ipaddress.ip_address(&quot;1.1.1.2&quot;)
        )
        self.assertTrue(ipaddress.ip_address(&quot;::1&quot;) &lt;= ipaddress.ip_address(&quot;::1&quot;))
        self.assertTrue(ipaddress.ip_address(&quot;::1&quot;) &lt;= ipaddress.ip_address(&quot;::2&quot;))
        self.assertTrue(
            ipaddress.ip_address(&quot;::1%scope&quot;) &lt;= ipaddress.ip_address(&quot;::1%scope&quot;)
        )
        self.assertTrue(
            ipaddress.ip_address(&quot;::1%scope&quot;) &lt;= ipaddress.ip_address(&quot;::2%scope&quot;)
        )

    def testInterfaceComparison(self):
        self.assertTrue(
            ipaddress.ip_interface(&quot;1.1.1.1/24&quot;) == ipaddress.ip_interface(&quot;1.1.1.1/24&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;1.1.1.1/16&quot;) &lt; ipaddress.ip_interface(&quot;1.1.1.1/24&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;1.1.1.1/24&quot;) &lt; ipaddress.ip_interface(&quot;1.1.1.2/24&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;1.1.1.2/16&quot;) &lt; ipaddress.ip_interface(&quot;1.1.1.1/24&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;1.1.1.1/24&quot;) &gt; ipaddress.ip_interface(&quot;1.1.1.1/16&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;1.1.1.2/24&quot;) &gt; ipaddress.ip_interface(&quot;1.1.1.1/24&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;1.1.1.1/24&quot;) &gt; ipaddress.ip_interface(&quot;1.1.1.2/16&quot;)
        )

        self.assertTrue(
            ipaddress.ip_interface(&quot;::1/64&quot;) == ipaddress.ip_interface(&quot;::1/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::1/64&quot;) &lt; ipaddress.ip_interface(&quot;::1/80&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::1/64&quot;) &lt; ipaddress.ip_interface(&quot;::2/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::2/48&quot;) &lt; ipaddress.ip_interface(&quot;::1/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::1/80&quot;) &gt; ipaddress.ip_interface(&quot;::1/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::2/64&quot;) &gt; ipaddress.ip_interface(&quot;::1/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::1/64&quot;) &gt; ipaddress.ip_interface(&quot;::2/48&quot;)
        )

        self.assertTrue(
            ipaddress.ip_interface(&quot;::1%scope/64&quot;)
            == ipaddress.ip_interface(&quot;::1%scope/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::1%scope/64&quot;)
            &lt; ipaddress.ip_interface(&quot;::1%scope/80&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::1%scope/64&quot;)
            &lt; ipaddress.ip_interface(&quot;::2%scope/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::2%scope/48&quot;)
            &lt; ipaddress.ip_interface(&quot;::1%scope/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::1%scope/80&quot;)
            &gt; ipaddress.ip_interface(&quot;::1%scope/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::2%scope/64&quot;)
            &gt; ipaddress.ip_interface(&quot;::1%scope/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::1%scope/64&quot;)
            &gt; ipaddress.ip_interface(&quot;::2%scope/48&quot;)
        )

        self.assertFalse(
            ipaddress.ip_interface(&quot;::1%scope/64&quot;) == ipaddress.ip_interface(&quot;::1/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::1%scope/64&quot;) &lt; ipaddress.ip_interface(&quot;::1/80&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::1%scope/64&quot;) &lt; ipaddress.ip_interface(&quot;::2/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::2%scope/48&quot;) &lt; ipaddress.ip_interface(&quot;::1/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::1%scope/80&quot;) &gt; ipaddress.ip_interface(&quot;::1/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::2%scope/64&quot;) &gt; ipaddress.ip_interface(&quot;::1/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::1%scope/64&quot;) &gt; ipaddress.ip_interface(&quot;::2/48&quot;)
        )

        self.assertFalse(
            ipaddress.ip_interface(&quot;::1/64&quot;) == ipaddress.ip_interface(&quot;::1%scope/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::1/64&quot;) &lt; ipaddress.ip_interface(&quot;::1%scope/80&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::1/64&quot;) &lt; ipaddress.ip_interface(&quot;::2%scope/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::2/48&quot;) &lt; ipaddress.ip_interface(&quot;::1%scope/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::1/80&quot;) &gt; ipaddress.ip_interface(&quot;::1%scope/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::2/64&quot;) &gt; ipaddress.ip_interface(&quot;::1%scope/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::1/64&quot;) &gt; ipaddress.ip_interface(&quot;::2%scope/48&quot;)
        )

    def testNetworkComparison(self):
        # ip1 and ip2 have the same network address
        ip1 = ipaddress.IPv4Network(&quot;1.1.1.0/24&quot;)
        ip2 = ipaddress.IPv4Network(&quot;1.1.1.0/32&quot;)
        ip3 = ipaddress.IPv4Network(&quot;1.1.2.0/24&quot;)

        self.assertTrue(ip1 &lt; ip3)
        self.assertTrue(ip3 &gt; ip2)

        self.assertEqual(ip1.compare_networks(ip1), 0)

        # if addresses are the same, sort by netmask
        self.assertEqual(ip1.compare_networks(ip2), -1)
        self.assertEqual(ip2.compare_networks(ip1), 1)

        self.assertEqual(ip1.compare_networks(ip3), -1)
        self.assertEqual(ip3.compare_networks(ip1), 1)
        self.assertTrue(ip1._get_networks_key() &lt; ip3._get_networks_key())

        ip1 = ipaddress.IPv6Network(&quot;2001:2000::/96&quot;)
        ip2 = ipaddress.IPv6Network(&quot;2001:2001::/96&quot;)
        ip3 = ipaddress.IPv6Network(&quot;2001:ffff:2000::/96&quot;)

        self.assertTrue(ip1 &lt; ip3)
        self.assertTrue(ip3 &gt; ip2)
        self.assertEqual(ip1.compare_networks(ip3), -1)
        self.assertTrue(ip1._get_networks_key() &lt; ip3._get_networks_key())

        # Test comparing different protocols.
        # Should always raise a TypeError.
        self.assertRaises(
            TypeError, self.ipv4_network.compare_networks, self.ipv6_network
        )
        ipv6 = ipaddress.IPv6Interface(&quot;::/0&quot;)
        ipv4 = ipaddress.IPv4Interface(&quot;0.0.0.0/0&quot;)
        self.assertRaises(TypeError, ipv4.__lt__, ipv6)
        self.assertRaises(TypeError, ipv4.__gt__, ipv6)
        self.assertRaises(TypeError, ipv6.__lt__, ipv4)
        self.assertRaises(TypeError, ipv6.__gt__, ipv4)

        # Regression test for issue 19.
        ip1 = ipaddress.ip_network(&quot;10.1.2.128/25&quot;)
        self.assertFalse(ip1 &lt; ip1)
        self.assertFalse(ip1 &gt; ip1)
        ip2 = ipaddress.ip_network(&quot;10.1.3.0/24&quot;)
        self.assertTrue(ip1 &lt; ip2)
        self.assertFalse(ip2 &lt; ip1)
        self.assertFalse(ip1 &gt; ip2)
        self.assertTrue(ip2 &gt; ip1)
        ip3 = ipaddress.ip_network(&quot;10.1.3.0/25&quot;)
        self.assertTrue(ip2 &lt; ip3)
        self.assertFalse(ip3 &lt; ip2)
        self.assertFalse(ip2 &gt; ip3)
        self.assertTrue(ip3 &gt; ip2)

        # Regression test for issue 28.
        ip1 = ipaddress.ip_network(&quot;10.10.10.0/31&quot;)
        ip2 = ipaddress.ip_network(&quot;10.10.10.0&quot;)
        ip3 = ipaddress.ip_network(&quot;10.10.10.2/31&quot;)
        ip4 = ipaddress.ip_network(&quot;10.10.10.2&quot;)
        sorted = [ip1, ip2, ip3, ip4]
        unsorted = [ip2, ip4, ip1, ip3]
        unsorted.sort()
        self.assertEqual(sorted, unsorted)
        unsorted = [ip4, ip1, ip3, ip2]
        unsorted.sort()
        self.assertEqual(sorted, unsorted)
        self.assertIs(ip1.__lt__(ipaddress.ip_address(&quot;10.10.10.0&quot;)), NotImplemented)
        self.assertIs(ip2.__lt__(ipaddress.ip_address(&quot;10.10.10.0&quot;)), NotImplemented)

        # &lt;=, &gt;=
        self.assertTrue(
            ipaddress.ip_network(&quot;1.1.1.1&quot;) &lt;= ipaddress.ip_network(&quot;1.1.1.1&quot;)
        )
        self.assertTrue(
            ipaddress.ip_network(&quot;1.1.1.1&quot;) &lt;= ipaddress.ip_network(&quot;1.1.1.2&quot;)
        )
        self.assertFalse(
            ipaddress.ip_network(&quot;1.1.1.2&quot;) &lt;= ipaddress.ip_network(&quot;1.1.1.1&quot;)
        )

        self.assertTrue(ipaddress.ip_network(&quot;::1&quot;) &lt;= ipaddress.ip_network(&quot;::1&quot;))
        self.assertTrue(ipaddress.ip_network(&quot;::1&quot;) &lt;= ipaddress.ip_network(&quot;::2&quot;))
        self.assertFalse(ipaddress.ip_network(&quot;::2&quot;) &lt;= ipaddress.ip_network(&quot;::1&quot;))

    def testStrictNetworks(self):
        self.assertRaises(ValueError, ipaddress.ip_network, &quot;192.168.1.1/24&quot;)
        self.assertRaises(ValueError, ipaddress.ip_network, &quot;::1/120&quot;)
        self.assertRaises(ValueError, ipaddress.ip_network, &quot;::1%scope/120&quot;)

    def testOverlaps(self):
        other = ipaddress.IPv4Network(&quot;1.2.3.0/30&quot;)
        other2 = ipaddress.IPv4Network(&quot;1.2.2.0/24&quot;)
        other3 = ipaddress.IPv4Network(&quot;1.2.2.64/26&quot;)
        self.assertTrue(self.ipv4_network.overlaps(other))
        self.assertFalse(self.ipv4_network.overlaps(other2))
        self.assertTrue(other2.overlaps(other3))

    def testEmbeddedIpv4(self):
        ipv4_string = &quot;192.168.0.1&quot;
        ipv4 = ipaddress.IPv4Interface(ipv4_string)
        v4compat_ipv6 = ipaddress.IPv6Interface(&quot;::%s&quot; % ipv4_string)
        self.assertEqual(int(v4compat_ipv6.ip), int(ipv4.ip))
        v4mapped_ipv6 = ipaddress.IPv6Interface(&quot;::ffff:%s&quot; % ipv4_string)
        self.assertNotEqual(v4mapped_ipv6.ip, ipv4.ip)
        self.assertRaises(
            ipaddress.AddressValueError, ipaddress.IPv6Interface, &quot;2001:1.1.1.1:1.1.1.1&quot;
        )

    # Issue 67: IPv6 with embedded IPv4 address not recognized.
    def testIPv6AddressTooLarge(self):
        # RFC4291 2.5.5.2
        self.assertEqual(
            ipaddress.ip_address(&quot;::FFFF:192.0.2.1&quot;),
            ipaddress.ip_address(&quot;::FFFF:c000:201&quot;),
        )
        # RFC4291 2.2 (part 3) x::d.d.d.d
        self.assertEqual(
            ipaddress.ip_address(&quot;FFFF::192.0.2.1&quot;),
            ipaddress.ip_address(&quot;FFFF::c000:201&quot;),
        )

        self.assertEqual(
            ipaddress.ip_address(&quot;::FFFF:192.0.2.1%scope&quot;),
            ipaddress.ip_address(&quot;::FFFF:c000:201%scope&quot;),
        )
        self.assertEqual(
            ipaddress.ip_address(&quot;FFFF::192.0.2.1%scope&quot;),
            ipaddress.ip_address(&quot;FFFF::c000:201%scope&quot;),
        )
        self.assertNotEqual(
            ipaddress.ip_address(&quot;::FFFF:192.0.2.1%scope&quot;),
            ipaddress.ip_address(&quot;::FFFF:c000:201&quot;),
        )
        self.assertNotEqual(
            ipaddress.ip_address(&quot;FFFF::192.0.2.1%scope&quot;),
            ipaddress.ip_address(&quot;FFFF::c000:201&quot;),
        )
        self.assertNotEqual(
            ipaddress.ip_address(&quot;::FFFF:192.0.2.1&quot;),
            ipaddress.ip_address(&quot;::FFFF:c000:201%scope&quot;),
        )
        self.assertNotEqual(
            ipaddress.ip_address(&quot;FFFF::192.0.2.1&quot;),
            ipaddress.ip_address(&quot;FFFF::c000:201%scope&quot;),
        )

    def testIPVersion(self):
        self.assertEqual(self.ipv4_address.version, 4)
        self.assertEqual(self.ipv6_address.version, 6)
        self.assertEqual(self.ipv6_scoped_address.version, 6)

    def testMaxPrefixLength(self):
        self.assertEqual(self.ipv4_interface.max_prefixlen, 32)
        self.assertEqual(self.ipv6_interface.max_prefixlen, 128)
        self.assertEqual(self.ipv6_scoped_interface.max_prefixlen, 128)

    def testPacked(self):
        self.assertEqual(self.ipv4_address.packed, b&quot;\x01\x02\x03\x04&quot;)
        self.assertEqual(
            ipaddress.IPv4Interface(&quot;255.254.253.252&quot;).packed, b&quot;\xff\xfe\xfd\xfc&quot;
        )
        self.assertEqual(
            self.ipv6_address.packed,
            b&quot;\x20\x01\x06\x58\x02\x2a\xca\xfe\x02\x00\x00\x00\x00\x00\x00\x01&quot;,
        )
        self.assertEqual(
            ipaddress.IPv6Interface(&quot;ffff:2:3:4:ffff::&quot;).packed,
            b&quot;\xff\xff\x00\x02\x00\x03\x00\x04\xff\xff&quot; + b&quot;\x00&quot; * 6,
        )
        self.assertEqual(
            ipaddress.IPv6Interface(&quot;::1:0:0:0:0&quot;).packed,
            b&quot;\x00&quot; * 6 + b&quot;\x00\x01&quot; + b&quot;\x00&quot; * 8,
        )
        self.assertEqual(
            self.ipv6_scoped_address.packed,
            b&quot;\x20\x01\x06\x58\x02\x2a\xca\xfe\x02\x00\x00\x00\x00\x00\x00\x01&quot;,
        )
        self.assertEqual(
            ipaddress.IPv6Interface(&quot;ffff:2:3:4:ffff::%scope&quot;).packed,
            b&quot;\xff\xff\x00\x02\x00\x03\x00\x04\xff\xff&quot; + b&quot;\x00&quot; * 6,
        )
        self.assertEqual(
            ipaddress.IPv6Interface(&quot;::1:0:0:0:0%scope&quot;).packed,
            b&quot;\x00&quot; * 6 + b&quot;\x00\x01&quot; + b&quot;\x00&quot; * 8,
        )

    def testIpType(self):
        ipv4net = ipaddress.ip_network(&quot;1.2.3.4&quot;)
        ipv4addr = ipaddress.ip_address(&quot;1.2.3.4&quot;)
        ipv6net = ipaddress.ip_network(&quot;::1.2.3.4&quot;)
        ipv6addr = ipaddress.ip_address(&quot;::1.2.3.4&quot;)
        self.assertEqual(ipaddress.IPv4Network, type(ipv4net))
        self.assertEqual(ipaddress.IPv4Address, type(ipv4addr))
        self.assertEqual(ipaddress.IPv6Network, type(ipv6net))
        self.assertEqual(ipaddress.IPv6Address, type(ipv6addr))

    def testReservedIpv4(self):
        # test networks
        self.assertEqual(True, ipaddress.ip_interface(&quot;224.1.1.1/31&quot;).is_multicast)
        self.assertEqual(False, ipaddress.ip_network(&quot;240.0.0.0&quot;).is_multicast)
        self.assertEqual(True, ipaddress.ip_network(&quot;240.0.0.0&quot;).is_reserved)

        self.assertEqual(True, ipaddress.ip_interface(&quot;192.168.1.1/17&quot;).is_private)
        self.assertEqual(False, ipaddress.ip_network(&quot;192.169.0.0&quot;).is_private)
        self.assertEqual(True, ipaddress.ip_network(&quot;10.255.255.255&quot;).is_private)
        self.assertEqual(False, ipaddress.ip_network(&quot;11.0.0.0&quot;).is_private)
        self.assertEqual(False, ipaddress.ip_network(&quot;11.0.0.0&quot;).is_reserved)
        self.assertEqual(True, ipaddress.ip_network(&quot;172.31.255.255&quot;).is_private)
        self.assertEqual(False, ipaddress.ip_network(&quot;172.32.0.0&quot;).is_private)
        self.assertEqual(True, ipaddress.ip_network(&quot;169.254.1.0/24&quot;).is_link_local)

        self.assertEqual(
            True, ipaddress.ip_interface(&quot;169.254.100.200/24&quot;).is_link_local
        )
        self.assertEqual(
            False, ipaddress.ip_interface(&quot;169.255.100.200/24&quot;).is_link_local
        )

        self.assertEqual(True, ipaddress.ip_network(&quot;127.100.200.254/32&quot;).is_loopback)
        self.assertEqual(True, ipaddress.ip_network(&quot;127.42.0.0/16&quot;).is_loopback)
        self.assertEqual(False, ipaddress.ip_network(&quot;128.0.0.0&quot;).is_loopback)
        self.assertEqual(False, ipaddress.ip_network(&quot;100.64.0.0/10&quot;).is_private)
        self.assertEqual(False, ipaddress.ip_network(&quot;100.64.0.0/10&quot;).is_global)

        self.assertEqual(True, ipaddress.ip_network(&quot;192.0.2.128/25&quot;).is_private)
        self.assertEqual(True, ipaddress.ip_network(&quot;192.0.3.0/24&quot;).is_global)

        # test addresses
        self.assertEqual(True, ipaddress.ip_address(&quot;0.0.0.0&quot;).is_unspecified)
        self.assertEqual(True, ipaddress.ip_address(&quot;224.1.1.1&quot;).is_multicast)
        self.assertEqual(False, ipaddress.ip_address(&quot;240.0.0.0&quot;).is_multicast)
        self.assertEqual(True, ipaddress.ip_address(&quot;240.0.0.1&quot;).is_reserved)
        self.assertEqual(False, ipaddress.ip_address(&quot;239.255.255.255&quot;).is_reserved)

        self.assertEqual(True, ipaddress.ip_address(&quot;192.168.1.1&quot;).is_private)
        self.assertEqual(False, ipaddress.ip_address(&quot;192.169.0.0&quot;).is_private)
        self.assertEqual(True, ipaddress.ip_address(&quot;10.255.255.255&quot;).is_private)
        self.assertEqual(False, ipaddress.ip_address(&quot;11.0.0.0&quot;).is_private)
        self.assertEqual(True, ipaddress.ip_address(&quot;172.31.255.255&quot;).is_private)
        self.assertEqual(False, ipaddress.ip_address(&quot;172.32.0.0&quot;).is_private)

        self.assertEqual(True, ipaddress.ip_address(&quot;169.254.100.200&quot;).is_link_local)
        self.assertEqual(False, ipaddress.ip_address(&quot;169.255.100.200&quot;).is_link_local)

        self.assertTrue(ipaddress.ip_address(&quot;192.0.7.1&quot;).is_global)
        self.assertFalse(ipaddress.ip_address(&quot;203.0.113.1&quot;).is_global)

        self.assertEqual(True, ipaddress.ip_address(&quot;127.100.200.254&quot;).is_loopback)
        self.assertEqual(True, ipaddress.ip_address(&quot;127.42.0.0&quot;).is_loopback)
        self.assertEqual(False, ipaddress.ip_address(&quot;128.0.0.0&quot;).is_loopback)
        self.assertEqual(True, ipaddress.ip_network(&quot;0.0.0.0&quot;).is_unspecified)

    def testReservedIpv6(self):

        self.assertEqual(True, ipaddress.ip_network(&quot;ffff::&quot;).is_multicast)
        self.assertEqual(True, ipaddress.ip_network(2 ** 128 - 1).is_multicast)
        self.assertEqual(True, ipaddress.ip_network(&quot;ff00::&quot;).is_multicast)
        self.assertEqual(False, ipaddress.ip_network(&quot;fdff::&quot;).is_multicast)

        self.assertEqual(True, ipaddress.ip_network(&quot;fecf::&quot;).is_site_local)
        self.assertEqual(
            True, ipaddress.ip_network(&quot;feff:ffff:ffff:ffff::&quot;).is_site_local
        )
        self.assertEqual(False, ipaddress.ip_network(&quot;fbf:ffff::&quot;).is_site_local)
        self.assertEqual(False, ipaddress.ip_network(&quot;ff00::&quot;).is_site_local)

        self.assertEqual(True, ipaddress.ip_network(&quot;fc00::&quot;).is_private)
        self.assertEqual(True, ipaddress.ip_network(&quot;fc00:ffff:ffff:ffff::&quot;).is_private)
        self.assertEqual(False, ipaddress.ip_network(&quot;fbff:ffff::&quot;).is_private)
        self.assertEqual(False, ipaddress.ip_network(&quot;fe00::&quot;).is_private)

        self.assertEqual(True, ipaddress.ip_network(&quot;fea0::&quot;).is_link_local)
        self.assertEqual(True, ipaddress.ip_network(&quot;febf:ffff::&quot;).is_link_local)
        self.assertEqual(False, ipaddress.ip_network(&quot;fe7f:ffff::&quot;).is_link_local)
        self.assertEqual(False, ipaddress.ip_network(&quot;fec0::&quot;).is_link_local)

        self.assertEqual(True, ipaddress.ip_interface(&quot;0:0::0:01&quot;).is_loopback)
        self.assertEqual(False, ipaddress.ip_interface(&quot;::1/127&quot;).is_loopback)
        self.assertEqual(False, ipaddress.ip_network(&quot;::&quot;).is_loopback)
        self.assertEqual(False, ipaddress.ip_network(&quot;::2&quot;).is_loopback)

        self.assertEqual(True, ipaddress.ip_network(&quot;0::0&quot;).is_unspecified)
        self.assertEqual(False, ipaddress.ip_network(&quot;::1&quot;).is_unspecified)
        self.assertEqual(False, ipaddress.ip_network(&quot;::/127&quot;).is_unspecified)

        self.assertEqual(True, ipaddress.ip_network(&quot;2001::1/128&quot;).is_private)
        self.assertEqual(True, ipaddress.ip_network(&quot;200::1/128&quot;).is_global)
        # test addresses
        self.assertEqual(True, ipaddress.ip_address(&quot;ffff::&quot;).is_multicast)
        self.assertEqual(True, ipaddress.ip_address(2 ** 128 - 1).is_multicast)
        self.assertEqual(True, ipaddress.ip_address(&quot;ff00::&quot;).is_multicast)
        self.assertEqual(False, ipaddress.ip_address(&quot;fdff::&quot;).is_multicast)

        self.assertEqual(True, ipaddress.ip_address(&quot;fecf::&quot;).is_site_local)
        self.assertEqual(
            True, ipaddress.ip_address(&quot;feff:ffff:ffff:ffff::&quot;).is_site_local
        )
        self.assertEqual(False, ipaddress.ip_address(&quot;fbf:ffff::&quot;).is_site_local)
        self.assertEqual(False, ipaddress.ip_address(&quot;ff00::&quot;).is_site_local)

        self.assertEqual(True, ipaddress.ip_address(&quot;fc00::&quot;).is_private)
        self.assertEqual(True, ipaddress.ip_address(&quot;fc00:ffff:ffff:ffff::&quot;).is_private)
        self.assertEqual(False, ipaddress.ip_address(&quot;fbff:ffff::&quot;).is_private)
        self.assertEqual(False, ipaddress.ip_address(&quot;fe00::&quot;).is_private)

        self.assertEqual(True, ipaddress.ip_address(&quot;fea0::&quot;).is_link_local)
        self.assertEqual(True, ipaddress.ip_address(&quot;febf:ffff::&quot;).is_link_local)
        self.assertEqual(False, ipaddress.ip_address(&quot;fe7f:ffff::&quot;).is_link_local)
        self.assertEqual(False, ipaddress.ip_address(&quot;fec0::&quot;).is_link_local)

        self.assertEqual(True, ipaddress.ip_address(&quot;0:0::0:01&quot;).is_loopback)
        self.assertEqual(True, ipaddress.ip_address(&quot;::1&quot;).is_loopback)
        self.assertEqual(False, ipaddress.ip_address(&quot;::2&quot;).is_loopback)

        self.assertEqual(True, ipaddress.ip_address(&quot;0::0&quot;).is_unspecified)
        self.assertEqual(False, ipaddress.ip_address(&quot;::1&quot;).is_unspecified)

        # some generic IETF reserved addresses
        self.assertEqual(True, ipaddress.ip_address(&quot;100::&quot;).is_reserved)
        self.assertEqual(True, ipaddress.ip_network(&quot;4000::1/128&quot;).is_reserved)

    def testIpv4Mapped(self):
        self.assertEqual(
            ipaddress.ip_address(&quot;::ffff:192.168.1.1&quot;).ipv4_mapped,
            ipaddress.ip_address(&quot;192.168.1.1&quot;),
        )
        self.assertEqual(ipaddress.ip_address(&quot;::c0a8:101&quot;).ipv4_mapped, None)
        self.assertEqual(
            ipaddress.ip_address(&quot;::ffff:c0a8:101&quot;).ipv4_mapped,
            ipaddress.ip_address(&quot;192.168.1.1&quot;),
        )

    def testAddrExclude(self):
        addr1 = ipaddress.ip_network(&quot;10.1.1.0/24&quot;)
        addr2 = ipaddress.ip_network(&quot;10.1.1.0/26&quot;)
        addr3 = ipaddress.ip_network(&quot;10.2.1.0/24&quot;)
        addr4 = ipaddress.ip_address(&quot;10.1.1.0&quot;)
        addr5 = ipaddress.ip_network(&quot;2001:db8::0/32&quot;)
        addr6 = ipaddress.ip_network(&quot;10.1.1.5/32&quot;)
        self.assertEqual(
            sorted(list(addr1.address_exclude(addr2))),
            [
                ipaddress.ip_network(&quot;10.1.1.64/26&quot;),
                ipaddress.ip_network(&quot;10.1.1.128/25&quot;),
            ],
        )
        self.assertRaises(ValueError, list, addr1.address_exclude(addr3))
        self.assertRaises(TypeError, list, addr1.address_exclude(addr4))
        self.assertRaises(TypeError, list, addr1.address_exclude(addr5))
        self.assertEqual(list(addr1.address_exclude(addr1)), [])
        self.assertEqual(
            sorted(list(addr1.address_exclude(addr6))),
            [
                ipaddress.ip_network(&quot;10.1.1.0/30&quot;),
                ipaddress.ip_network(&quot;10.1.1.4/32&quot;),
                ipaddress.ip_network(&quot;10.1.1.6/31&quot;),
                ipaddress.ip_network(&quot;10.1.1.8/29&quot;),
                ipaddress.ip_network(&quot;10.1.1.16/28&quot;),
                ipaddress.ip_network(&quot;10.1.1.32/27&quot;),
                ipaddress.ip_network(&quot;10.1.1.64/26&quot;),
                ipaddress.ip_network(&quot;10.1.1.128/25&quot;),
            ],
        )

    def testHash(self):
        self.assertEqual(
            hash(ipaddress.ip_interface(&quot;10.1.1.0/24&quot;)),
            hash(ipaddress.ip_interface(&quot;10.1.1.0/24&quot;)),
        )
        self.assertEqual(
            hash(ipaddress.ip_network(&quot;10.1.1.0/24&quot;)),
            hash(ipaddress.ip_network(&quot;10.1.1.0/24&quot;)),
        )
        self.assertEqual(
            hash(ipaddress.ip_address(&quot;10.1.1.0&quot;)),
            hash(ipaddress.ip_address(&quot;10.1.1.0&quot;)),
        )
        # i70
        self.assertEqual(
            hash(ipaddress.ip_address(&quot;1.2.3.4&quot;)),
            hash(ipaddress.ip_address(int(ipaddress.ip_address(&quot;1.2.3.4&quot;)._ip))),
        )
        ip1 = ipaddress.ip_address(&quot;10.1.1.0&quot;)
        ip2 = ipaddress.ip_address(&quot;1::&quot;)
        dummy = {}
        dummy[self.ipv4_address] = None
        dummy[self.ipv6_address] = None
        dummy[ip1] = None
        dummy[ip2] = None
        self.assertIn(self.ipv4_address, dummy)
        self.assertIn(ip2, dummy)

    def testIPBases(self):
        net = self.ipv4_network
        self.assertEqual(&quot;1.2.3.0/24&quot;, net.compressed)
        net = self.ipv6_network
        self.assertRaises(ValueError, net._string_from_ip_int, 2 ** 128 + 1)

    def testIPv6NetworkHelpers(self):
        net = self.ipv6_network
        self.assertEqual(&quot;2001:658:22a:cafe::/64&quot;, net.with_prefixlen)
        self.assertEqual(&quot;2001:658:22a:cafe::/ffff:ffff:ffff:ffff::&quot;, net.with_netmask)
        self.assertEqual(&quot;2001:658:22a:cafe::/::ffff:ffff:ffff:ffff&quot;, net.with_hostmask)
        self.assertEqual(&quot;2001:658:22a:cafe::/64&quot;, str(net))

    def testIPv4NetworkHelpers(self):
        net = self.ipv4_network
        self.assertEqual(&quot;1.2.3.0/24&quot;, net.with_prefixlen)
        self.assertEqual(&quot;1.2.3.0/255.255.255.0&quot;, net.with_netmask)
        self.assertEqual(&quot;1.2.3.0/0.0.0.255&quot;, net.with_hostmask)
        self.assertEqual(&quot;1.2.3.0/24&quot;, str(net))

    def testCopyConstructor(self):
        addr1 = ipaddress.ip_network(&quot;10.1.1.0/24&quot;)
        addr2 = ipaddress.ip_network(addr1)
        addr3 = ipaddress.ip_interface(&quot;2001:658:22a:cafe:200::1/64&quot;)
        addr4 = ipaddress.ip_interface(addr3)
        addr5 = ipaddress.IPv4Address(&quot;1.1.1.1&quot;)
        addr6 = ipaddress.IPv6Address(&quot;2001:658:22a:cafe:200::1&quot;)

        self.assertEqual(addr1, addr2)
        self.assertEqual(addr3, addr4)
        self.assertEqual(addr5, ipaddress.IPv4Address(addr5))
        self.assertEqual(addr6, ipaddress.IPv6Address(addr6))

    def testCompressIPv6Address(self):
        test_addresses = {
            &quot;1:2:3:4:5:6:7:8&quot;: &quot;1:2:3:4:5:6:7:8/128&quot;,
            &quot;2001:0:0:4:0:0:0:8&quot;: &quot;2001:0:0:4::8/128&quot;,
            &quot;2001:0:0:4:5:6:7:8&quot;: &quot;2001::4:5:6:7:8/128&quot;,
            &quot;2001:0:3:4:5:6:7:8&quot;: &quot;2001:0:3:4:5:6:7:8/128&quot;,
            &quot;0:0:3:0:0:0:0:ffff&quot;: &quot;0:0:3::ffff/128&quot;,
            &quot;0:0:0:4:0:0:0:ffff&quot;: &quot;::4:0:0:0:ffff/128&quot;,
            &quot;0:0:0:0:5:0:0:ffff&quot;: &quot;::5:0:0:ffff/128&quot;,
            &quot;1:0:0:4:0:0:7:8&quot;: &quot;1::4:0:0:7:8/128&quot;,
            &quot;0:0:0:0:0:0:0:0&quot;: &quot;::/128&quot;,
            &quot;0:0:0:0:0:0:0:0/0&quot;: &quot;::/0&quot;,
            &quot;0:0:0:0:0:0:0:1&quot;: &quot;::1/128&quot;,
            &quot;2001:0658:022a:cafe:0000:0000:0000:0000/66&quot;: &quot;2001:658:22a:cafe::/66&quot;,
            &quot;::1.2.3.4&quot;: &quot;::102:304/128&quot;,
            &quot;1:2:3:4:5:ffff:1.2.3.4&quot;: &quot;1:2:3:4:5:ffff:102:304/128&quot;,
            &quot;::7:6:5:4:3:2:1&quot;: &quot;0:7:6:5:4:3:2:1/128&quot;,
            &quot;::7:6:5:4:3:2:0&quot;: &quot;0:7:6:5:4:3:2:0/128&quot;,
            &quot;7:6:5:4:3:2:1::&quot;: &quot;7:6:5:4:3:2:1:0/128&quot;,
            &quot;0:6:5:4:3:2:1::&quot;: &quot;0:6:5:4:3:2:1:0/128&quot;,
        }
        for uncompressed, compressed in list(test_addresses.items()):
            self.assertEqual(compressed, str(ipaddress.IPv6Interface(uncompressed)))

    def testExplodeShortHandIpStr(self):
        addr1 = ipaddress.IPv6Interface(&quot;2001::1&quot;)
        addr2 = ipaddress.IPv6Address(&quot;2001:0:5ef5:79fd:0:59d:a0e5:ba1&quot;)
        addr3 = ipaddress.IPv6Network(&quot;2001::/96&quot;)
        addr4 = ipaddress.IPv4Address(&quot;192.168.178.1&quot;)
        self.assertEqual(&quot;2001:0000:0000:0000:0000:0000:0000:0001/128&quot;, addr1.exploded)
        self.assertEqual(
            &quot;0000:0000:0000:0000:0000:0000:0000:0001/128&quot;,
            ipaddress.IPv6Interface(&quot;::1/128&quot;).exploded,
        )
        # issue 77
        self.assertEqual(&quot;2001:0000:5ef5:79fd:0000:059d:a0e5:0ba1&quot;, addr2.exploded)
        self.assertEqual(&quot;2001:0000:0000:0000:0000:0000:0000:0000/96&quot;, addr3.exploded)
        self.assertEqual(&quot;192.168.178.1&quot;, addr4.exploded)

    def testReversePointer(self):
        addr1 = ipaddress.IPv4Address(&quot;127.0.0.1&quot;)
        addr2 = ipaddress.IPv6Address(&quot;2001:db8::1&quot;)
        self.assertEqual(&quot;1.0.0.127.in-addr.arpa&quot;, addr1.reverse_pointer)
        self.assertEqual(
            &quot;1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.&quot;
            + &quot;b.d.0.1.0.0.2.ip6.arpa&quot;,
            addr2.reverse_pointer,
        )

    def testIntRepresentation(self):
        self.assertEqual(16909060, int(self.ipv4_address))
        self.assertEqual(42540616829182469433547762482097946625, int(self.ipv6_address))

    def testForceVersion(self):
        self.assertEqual(ipaddress.ip_network(1).version, 4)
        self.assertEqual(ipaddress.IPv6Network(1).version, 6)

    def testWithStar(self):
        self.assertEqual(self.ipv4_interface.with_prefixlen, &quot;1.2.3.4/24&quot;)
        self.assertEqual(self.ipv4_interface.with_netmask, &quot;1.2.3.4/255.255.255.0&quot;)
        self.assertEqual(self.ipv4_interface.with_hostmask, &quot;1.2.3.4/0.0.0.255&quot;)

        self.assertEqual(
            self.ipv6_interface.with_prefixlen, &quot;2001:658:22a:cafe:200::1/64&quot;
        )
        self.assertEqual(
            self.ipv6_interface.with_netmask,
            &quot;2001:658:22a:cafe:200::1/ffff:ffff:ffff:ffff::&quot;,
        )
        # this probably don't make much sense, but it's included for
        # compatibility with ipv4
        self.assertEqual(
            self.ipv6_interface.with_hostmask,
            &quot;2001:658:22a:cafe:200::1/::ffff:ffff:ffff:ffff&quot;,
        )

    def testNetworkElementCaching(self):
        # V4 - make sure we're empty
        self.assertNotIn(&quot;broadcast_address&quot;, self.ipv4_network._cache)
        self.assertNotIn(&quot;hostmask&quot;, self.ipv4_network._cache)

        # V4 - populate and test
        self.assertEqual(
            self.ipv4_network.broadcast_address, ipaddress.IPv4Address(&quot;1.2.3.255&quot;)
        )
        self.assertEqual(self.ipv4_network.hostmask, ipaddress.IPv4Address(&quot;0.0.0.255&quot;))

        # V4 - check we're cached
        self.assertIn(&quot;broadcast_address&quot;, self.ipv4_network._cache)
        self.assertIn(&quot;hostmask&quot;, self.ipv4_network._cache)

        # V6 - make sure we're empty
        self.assertNotIn(&quot;broadcast_address&quot;, self.ipv6_network._cache)
        self.assertNotIn(&quot;hostmask&quot;, self.ipv6_network._cache)

        # V6 - populate and test
        self.assertEqual(
            self.ipv6_network.network_address,
            ipaddress.IPv6Address(&quot;2001:658:22a:cafe::&quot;),
        )
        self.assertEqual(
            self.ipv6_interface.network.network_address,
            ipaddress.IPv6Address(&quot;2001:658:22a:cafe::&quot;),
        )

        self.assertEqual(
            self.ipv6_network.broadcast_address,
            ipaddress.IPv6Address(&quot;2001:658:22a:cafe:ffff:ffff:ffff:ffff&quot;),
        )
        self.assertEqual(
            self.ipv6_network.hostmask, ipaddress.IPv6Address(&quot;::ffff:ffff:ffff:ffff&quot;)
        )
        self.assertEqual(
            self.ipv6_interface.network.broadcast_address,
            ipaddress.IPv6Address(&quot;2001:658:22a:cafe:ffff:ffff:ffff:ffff&quot;),
        )
        self.assertEqual(
            self.ipv6_interface.network.hostmask,
            ipaddress.IPv6Address(&quot;::ffff:ffff:ffff:ffff&quot;),
        )

        # V6 - check we're cached
        self.assertIn(&quot;broadcast_address&quot;, self.ipv6_network._cache)
        self.assertIn(&quot;hostmask&quot;, self.ipv6_network._cache)
        self.assertIn(&quot;broadcast_address&quot;, self.ipv6_interface.network._cache)
        self.assertIn(&quot;hostmask&quot;, self.ipv6_interface.network._cache)

    def testTeredo(self):
        # stolen from wikipedia
        server = ipaddress.IPv4Address(&quot;65.54.227.120&quot;)
        client = ipaddress.IPv4Address(&quot;192.0.2.45&quot;)
        teredo_addr = &quot;2001:0000:4136:e378:8000:63bf:3fff:fdd2&quot;
        self.assertEqual((server, client), ipaddress.ip_address(teredo_addr).teredo)
        bad_addr = &quot;2000::4136:e378:8000:63bf:3fff:fdd2&quot;
        self.assertFalse(ipaddress.ip_address(bad_addr).teredo)
        bad_addr = &quot;2001:0001:4136:e378:8000:63bf:3fff:fdd2&quot;
        self.assertFalse(ipaddress.ip_address(bad_addr).teredo)

        # i77
        teredo_addr = ipaddress.IPv6Address(&quot;2001:0:5ef5:79fd:0:59d:a0e5:ba1&quot;)
        self.assertEqual(
            (
<A NAME="5"></A>                ipaddress.IPv4Address(&quot;94.245.121.253&quot;),
                ipaddress.IPv4Address(&quot;95.26.244.94&quot;),
            ),
            teredo_addr<FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match103528-0.html#5',2,'match103528-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.teredo,
        )

    def testsixtofour(self):
        sixtofouraddr = ipaddress.ip_address(&quot;2002:ac1d:2d64::1&quot;)
        bad_addr = ipaddress.ip_address(&quot;2000:ac1d:2d64::1&quot;)
<A NAME="2"></A>        self.assertEqual(
            ipaddress.IPv4Address(</B></FONT>&quot;172.29.45.100&quot;), sixtofouraddr.sixtofour
        )
        self.assertFalse(bad_addr.<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match103528-0.html#2',2,'match103528-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>sixtofour)

    # issue41004 Hash collisions in IPv4Interface and IPv6Interface
<A NAME="1"></A>    def testV4HashIsNotConstant(self):
        ipv4_address1 = ipaddress.IPv4Interface(&quot;1.2.3.4&quot;)
        ipv4_address2 = ipaddress.IPv4Interface(&quot;2.3.4.5&quot;)
        self.assertNotEqual(ipv4_address1.__hash__(), ipv4_address2.__hash__(</B></FONT><FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match103528-0.html#1',2,'match103528-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>))

    # issue41004 Hash collisions in IPv4Interface and IPv6Interface
    def testV6HashIsNotConstant(self):
        ipv6_address1 = ipaddress.IPv6Interface(&quot;2001:658:22a:cafe:200:0:0:1&quot;)
        ipv6_address2 = ipaddress.IPv6Interface(&quot;2001:658:22a:cafe:200:0:0:2&quot;)
        self.assertNotEqual(ipv6_address1.__hash__(), ipv6_address2.__hash__(</B></FONT>))
</PRE>
</div>
  </div>
</body>
</html>
