<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_grains_1.py &amp; test_boto_apigateway.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_grains_1.py &amp; test_boto_apigateway.py
      </h3>
<h1 align="center">
        2.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_grains_1.py (3.0318344%)<th>test_boto_apigateway.py (2.2744503%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(117-122)<td><a href="#" name="0">(1559-1568)</a><td align="center"><font color="#ff0000">16</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(48-52)<td><a href="#" name="1">(468-478)</a><td align="center"><font color="#ff0000">16</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(148-153)<td><a href="#" name="2">(1516-1520)</a><td align="center"><font color="#df0000">14</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(29-42)<td><a href="#" name="3">(1528-1544)</a><td align="center"><font color="#df0000">14</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_grains_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import contextlib
2 import os
3 import salt.modules.grains as grainsmod
4 import salt.states.grains as grains
5 import salt.utils.files
6 import salt.utils.stringutils
7 import salt.utils.yaml
8 from tests.support.mixins import LoaderModuleMockMixin
9 from tests.support.mock import MagicMock, patch
10 from tests.support.runtests import RUNTIME_VARS
11 from tests.support.unit import TestCase
12 class GrainsTestCase(TestCase, LoaderModuleMockMixin):
13     def setup_loader_modules(self):
14         grains_test_dir = "__salt_test_state_grains"
15         if not os.path.exists(os.path.join(RUNTIME_VARS.TMP, grains_test_dir)):
16             os.makedirs(os.path.join(RUNTIME_VARS.TMP, grains_test_dir))
17         loader_globals = {
18                 "test": False,
19                 "conf_file": os.path.join(RUNTIME_VARS.TMP, grains_test_dir, "minion"),
20                 "cachedir": os.path<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.join(RUNTIME_VARS.TMP, grains_test_dir),
21                 "local": True,
22             },
23             "__salt__": {
24                 "cmd.run_all": MagicMock(
25                     return_value={"pid": 5, "retcode": 0, "stderr": "", "stdout": ""}
26                 ),
27                 "grains.get": grainsmod.get,
28                 "grains.set": grainsmod.set,
29                 "grains.setval": grainsmod.setval,
30                 "grains.delval": grainsmod.delval,
31                 "grains.append": grainsmod.append,
32                 "grains.remove": grainsmod.remove,
33                 "saltutil.sync_grains": MagicMock(</b></font>),
34             },
35         }
36     def assertGrainFileContent(self, grains_string):
37         if os<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.path.isdir(grains.__opts__["conf_file"]):
38             grains_file = os.path.join(grains.__opts__["conf_file"], "grains")
39         else:
40             grains_file = os.path.join(
41                 os.</b></font>path.dirname(grains.__opts__["conf_file"]), "grains"
42             )
43         with salt.utils.files.fopen(grains_file, "r") as grf:
44             grains_data = salt.utils.stringutils.to_unicode(grf.read())
45         self.assertMultiLineEqual(grains_string, grains_data)
46     @contextlib.contextmanager
47     def setGrains(self, grains_data):
48         with patch.dict(grains.__grains__, grains_data):
49             with patch.dict(grainsmod.__grains__, grains_data):
50                 if os.path.isdir(grains.__opts__["conf_file"]):
51                     grains_file = os.path.join(grains.__opts__["conf_file"], "grains")
52                 else:
53                     grains_file = os.path.join(
54                         os.path.dirname(grains.__opts__["conf_file"]), "grains"
55                     )
56                 with salt.utils.files.fopen(grains_file, "w+") as grf:
57                     salt.utils.yaml.safe_dump(
58                         grains_data, grf, default_flow_style=False
59                     )
60                 yield
61     def test_exists_missing(self):
62         with self.setGrains({"a": "aval"}):
63             ret = grains.exists(name="foo")
64             self.assertEqual(ret["result"], False)
65             self.assertEqual(ret["comment"], "Grain does not exist")
66             self.assertEqual(ret["changes"], {})
67     def test_exists_found(self):
68         with self.setGrains({"a": "aval", "foo": "bar"}):
69             ret = grains.exists(name="foo")
70             self.assertEqual(ret["result"], True)
71             self.assertEqual(ret["comment"], "Grain exists")
72             self.assertEqual(ret["changes"], {})
73     def test_make_hashable(self):
74         with self.setGrains({"cmplx_lst_grain": [{"a": "aval"}, {"foo": "bar"}]}):
75             hashable_list = {"cmplx_lst_grain": [{"a": "aval"}, {"foo": "bar"}]}
76             self.assertEqual(
77                 grains.make_hashable(grains.__grains__).issubset(
78                     grains.make_hashable(hashable_list)
79                 ),
80                 True,
81             )
82     def test_present_add(self):
83         with self.setGrains({"a": "aval"}):
84             ret = grains.present(name="foo", value="bar")
85             self.assertEqual(ret["result"], True)
86             self.assertEqual(ret["changes"], {"foo": "bar"})
87             self.assertEqual(grains.__grains__, {"a": "aval", "foo": "bar"})
88             self.assertGrainFileContent("a: aval\nfoo: bar\n")
89         with self.setGrains({"a": "aval"}):
90             ret = grains.present(name="foo:is:nested", value="bar")
91             self<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertEqual(ret["result"], True)
92             self.assertEqual(ret["changes"], {"foo": {"is": {"nested": "bar"}}})
93             self.assertEqual(
94                 grains.__grains__, {"a": "aval", "foo": {"is": {"nested": "bar"}}}
95             )
96             self.</b></font>assertGrainFileContent("a: aval\nfoo:\n  is:\n    nested: bar\n")
97         with self.setGrains({"a": "aval"}):
98             ret = grains.present(name="foo:is:nested", value={"bar": "is a dict"})
99             self.assertEqual(ret["result"], True)
100             self.assertEqual(
101                 ret["changes"], {"foo": {"is": {"nested": {"bar": "is a dict"}}}}
102             )
103             self.assertEqual(
104                 grains.__grains__,
105                 {"a": "aval", "foo": {"is": {"nested": {"bar": "is a dict"}}}},
106             )
107             self.assertGrainFileContent(
108                 "a: aval\n"
109                 + "foo:\n"
110                 + "  is:\n"
111                 + "    nested:\n"
112                 + "      bar: is a dict\n"
113             )
114     def test_present_add_key_to_existing(self):
115         with self.setGrains({"a": "aval", "foo": {"k1": "v1"}}):
116             ret = grains.present(name="foo:k2", value="v2")
117             self.assertEqual(ret["result"], True)
118             self<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertEqual(ret["comment"], "Set grain foo:k2 to v2")
119             self.assertEqual(ret["changes"], {"foo": {"k2": "v2", "k1": "v1"}})
120             self.assertEqual(
121                 grains.__grains__, {"a": "aval", "foo": {"k1": "v1", "k2": "v2"}}
122             )
123             self.</b></font>assertGrainFileContent(
124                 "a: aval\n" + "foo:\n" + "  k1: v1\n" + "  k2: v2\n"
125             )
126     def test_present_already_set(self):
127         with self.setGrains({"a": "aval", "foo": "bar"}):
128             ret = grains.present(name="foo", value="bar")
129             self.assertEqual(ret["result"], True)
130             self.assertEqual(ret["comment"], "Grain is already set")
131             self.assertEqual(ret["changes"], {})
132             self.assertEqual(grains.__grains__, {"a": "aval", "foo": "bar"})
133         with self.setGrains({"a": "aval", "foo": {"is": {"nested": "bar"}}}):
134             ret = grains.present(name="foo:is:nested", value="bar")
135             self.assertEqual(ret["result"], True)
136             self.assertEqual(ret["comment"], "Grain is already set")
137             self.assertEqual(ret["changes"], {})
138             self.assertEqual(
139                 grains.__grains__, {"a": "aval", "foo": {"is": {"nested": "bar"}}}
140             )
141         with self.setGrains({"a": "aval", "foo": {"is": {"nested": "bar"}}}):
142             ret = grains.present(name="foo:is", value={"nested": "bar"})
143             self.assertEqual(ret["result"], True)
144             self.assertEqual(ret["comment"], "Grain is already set")
145             self.assertEqual(ret["changes"], {})
146             self.assertEqual(
147                 grains.__grains__, {"a": "aval", "foo": {"is": {"nested": "bar"}}}
148             )
149     def test_present_overwrite(self):
150         with self.setGrains({"a": "aval", "foo": "bar"}):
151             ret = grains.present(name="foo", value="newbar")
152             self.assertEqual(ret["result"], True)
153             self.assertEqual(ret["changes"], {"foo": "newbar"})
154             self.assertEqual(grains.__grains__, {"a": "aval", "foo": "newbar"})
155             self.assertGrainFileContent("a: aval\n" + "foo: newbar\n")
156         with self.setGrains({"a": "aval", "foo": "bar"}):
157             ret = grains.present(name="foo", value=None)
158             self.assertEqual(ret["result"], True)
159             self.assertEqual(ret["changes"], {"foo": None})
160             self.assertEqual(grains.__grains__, {"a": "aval", "foo": None})
161             self.assertGrainFileContent("a: aval\n" + "foo: null\n")
162         with self.setGrains({"a": "aval", "foo": {"is": {"nested": "bar"}}}):
163             ret = grains.present(name="foo:is:nested", value="newbar")
164             self.assertEqual(ret["result"], True)
165             self.assertEqual(ret["changes"], {"foo": {"is": {"nested": "newbar"}}})
166             self.assertEqual(
167                 grains.__grains__, {"a": "aval", "foo": {"is": {"nested": "newbar"}}}
168             )
169             self.assertGrainFileContent(
170                 "a: aval\n" + "foo:\n" + "  is:\n" + "    nested: newbar\n"
171             )
172         with self.setGrains({"a": "aval", "foo": {"is": {"nested": "bar"}}}):
173             ret = grains.present(name="foo:is:nested", value=None)
174             self.assertEqual(ret["result"], True)
175             self.assertEqual(ret["changes"], {"foo": {"is": {"nested": None}}})
176             self.assertEqual(
177                 grains.__grains__, {"a": "aval", "foo": {"is": {"nested": None}}}
178             )
179             self.assertGrainFileContent(
180                 "a: aval\n" + "foo:\n" + "  is:\n" + "    nested: null\n"
181             )
182     def test_present_fail_overwrite(self):
183         with self.setGrains({"a": "aval", "foo": {"is": {"nested": "val"}}}):
184             ret = grains.present(name="foo:is", value="newbar")
185             self.assertEqual(ret["result"], False)
186             self.assertEqual(ret["changes"], {})
187             self.assertEqual(
188                 ret["comment"],
189                 "The key 'foo:is' exists but is a dict or a list. Use 'force=True' to"
190                 " overwrite.",
191             )
192             self.assertEqual(
193                 grains.__grains__, {"a": "aval", "foo": {"is": {"nested": "val"}}}
194             )
195         with self.setGrains({"a": "aval", "foo": {"is": {"nested": "val"}}}):
196             ret = grains.present(name="foo:is", value=None)
197             self.assertEqual(ret["result"], False)
198             self.assertEqual(ret["changes"], {})
199             self.assertEqual(
200                 ret["comment"],
201                 "The key 'foo:is' exists but is a dict or a list. Use 'force=True' to"
202                 " overwrite.",
203             )
204             self.assertEqual(
205                 grains.__grains__, {"a": "aval", "foo": {"is": {"nested": "val"}}}
206             )
207     def test_present_fails_to_set_dict_or_list(self):
208         with self.setGrains({"a": "aval", "foo": "bar"}):
209             ret = grains.present(name="foo", value=["l1", "l2"])
210             self.assertEqual(ret["result"], False)
211             self.assertEqual(
212                 ret["comment"],
213                 "The key 'foo' exists and the "
214                 + "given value is a dict or a list. "
215                 + "Use 'force=True' to overwrite.",
216             )
217             self.assertEqual(ret["changes"], {})
218             self.assertEqual(grains.__grains__, {"a": "aval", "foo": "bar"})
219         with self.setGrains({"a": "aval", "foo": "bar"}):
220             ret = grains.present(name="foo", value={"k1": "v1"})
221             self.assertEqual(ret["result"], False)
222             self.assertEqual(
223                 ret["comment"],
224                 "The key 'foo' exists and the given "
225                 + "value is a dict or a list. Use "
226                 + "'force=True' to overwrite.",
227             )
228             self.assertEqual(ret["changes"], {})
229             self.assertEqual(grains.__grains__, {"a": "aval", "foo": "bar"})
230         with self.setGrains({"a": "aval", "foo": {"is": {"nested": "bar"}}}):
231             ret = grains.present(
232                 name="foo,is,nested", value=["l1", "l2"], delimiter=","
233             )
234             self.assertEqual(ret["result"], False)
235             self.assertEqual(ret["changes"], {})
236             self.assertEqual(
237                 ret["comment"],
238                 "The key 'foo:is:nested' exists and the "
239                 + "given value is a dict or a list. "
240                 + "Use 'force=True' to overwrite.",
241             )
242             self.assertEqual(
243                 grains.__grains__, {"a": "aval", "foo": {"is": {"nested": "bar"}}}
244             )
245         with self.setGrains({"a": "aval", "foo": {"is": {"nested": "bar"}}}):
246             ret = grains.present(name="foo:is:nested", value={"k1": "v1"})
247             self.assertEqual(ret["result"], False)
248             self.assertEqual(
249                 ret["comment"],
250                 "The key 'foo:is:nested' exists and the "
251                 + "given value is a dict or a list. "
252                 + "Use 'force=True' to overwrite.",
253             )
254             self.assertEqual(ret["changes"], {})
255             self.assertEqual(
256                 grains.__grains__, {"a": "aval", "foo": {"is": {"nested": "bar"}}}
257             )
258     def test_present_fail_merge_dict(self):
259         with self.setGrains({"a": "aval", "foo": {"k1": "v1"}}):
260             ret = grains.present(name="foo", value={"k2": "v2"})
261             self.assertEqual(ret["result"], False)
262             self.assertEqual(
263                 ret["comment"],
264                 "The key 'foo' exists but "
265                 + "is a dict or a list. "
266                 + "Use 'force=True' to overwrite.",
267             )
268             self.assertEqual(grains.__grains__, {"a": "aval", "foo": {"k1": "v1"}})
269             self.assertGrainFileContent("a: aval\n" + "foo:\n" + "  k1: v1\n")
270     def test_present_force_to_set_dict_or_list(self):
271         with self.setGrains({"a": "aval", "foo": "bar"}):
272             ret = grains.present(name="foo", value=["l1", "l2"], force=True)
273             self.assertEqual(ret["result"], True)
274             self.assertEqual(ret["comment"], "Set grain foo to ['l1', 'l2']")
275             self.assertEqual(ret["changes"], {"foo": ["l1", "l2"]})
276             self.assertEqual(grains.__grains__, {"a": "aval", "foo": ["l1", "l2"]})
277             self.assertGrainFileContent("a: aval\n" + "foo:\n" + "- l1\n" + "- l2\n")
278         with self.setGrains({"a": "aval", "foo": "bar"}):
279             ret = grains.present(name="foo", value={"k1": "v1"}, force=True)
280             self.assertEqual(ret["result"], True)
281             self.assertEqual(ret["comment"], "Set grain foo to {'k1': 'v1'}")
282             self.assertEqual(ret["changes"], {"foo": {"k1": "v1"}})
283             self.assertEqual(grains.__grains__, {"a": "aval", "foo": {"k1": "v1"}})
284             self.assertGrainFileContent("a: aval\n" + "foo:\n" + "  k1: v1\n")
285         with self.setGrains({"a": "aval", "foo": {"is": {"nested": "bar"}}}):
286             ret = grains.present(
287                 name="foo,is,nested", value=["l1", "l2"], delimiter=",", force=True
288             )
289             self.assertEqual(ret["result"], True)
290             self.assertEqual(ret["changes"], {"foo": {"is": {"nested": ["l1", "l2"]}}})
291             self.assertEqual(ret["comment"], "Set grain foo:is:nested to ['l1', 'l2']")
292             self.assertEqual(
293                 grains.__grains__,
294                 {"a": "aval", "foo": {"is": {"nested": ["l1", "l2"]}}},
295             )
296             self.assertGrainFileContent(
297                 "a: aval\n"
298                 + "foo:\n"
299                 + "  is:\n"
300                 + "    nested:\n"
301                 + "    - l1\n"
302                 + "    - l2\n"
303             )
304         with self.setGrains(
305             {"a": "aval", "foo": {"is": {"nested": "bar"}, "and": "other"}}
306         ):
307             ret = grains.present(name="foo:is:nested", value={"k1": "v1"}, force=True)
308             self.assertEqual(ret["result"], True)
309             self.assertEqual(ret["comment"], "Set grain foo:is:nested to {'k1': 'v1'}")
310             self.assertEqual(
311                 ret["changes"],
312                 {"foo": {"is": {"nested": {"k1": "v1"}}, "and": "other"}},
313             )
314             self.assertEqual(
315                 grains.__grains__,
316                 {"a": "aval", "foo": {"is": {"nested": {"k1": "v1"}}, "and": "other"}},
317             )
318             self.assertGrainFileContent(
319                 "a: aval\n"
320                 + "foo:\n"
321                 + "  and: other\n"
322                 + "  is:\n"
323                 + "    nested:\n"
324                 + "      k1: v1\n"
325             )
326     def test_present_fails_to_convert_value_to_key(self):
327         with self.setGrains({"a": "aval", "foo": "bar"}):
328             ret = grains.present(name="foo:is:nested", value={"k1": "v1"})
329             self.assertEqual(ret["result"], False)
330             self.assertEqual(
331                 ret["comment"],
332                 "The key 'foo' value is 'bar', "
333                 + "which is different from the provided "
334                 + "key 'is'. Use 'force=True' to overwrite.",
335             )
336             self.assertEqual(ret["changes"], {})
337     def test_present_overwrite_test(self):
338         with patch.dict(grains.__opts__, {"test": True}):
339             with self.setGrains({"a": "aval", "foo": "bar"}):
340                 ret = grains.present(name="foo", value="newbar")
341                 self.assertEqual(ret["result"], None)
342                 self.assertEqual(ret["changes"], {"changed": {"foo": "newbar"}})
343                 self.assertEqual(grains.__grains__, {"a": "aval", "foo": "bar"})
344                 self.assertGrainFileContent("a: aval\n" + "foo: bar\n")
345     def test_present_convert_value_to_key(self):
346         with self.setGrains({"a": "aval", "foo": "is"}):
347             ret = grains.present(name="foo:is:nested", value={"k1": "v1"})
348             self.assertEqual(ret["result"], True)
349             self.assertEqual(ret["comment"], "Set grain foo:is:nested to {'k1': 'v1'}")
350             self.assertEqual(ret["changes"], {"foo": {"is": {"nested": {"k1": "v1"}}}})
351             self.assertEqual(
352                 grains.__grains__,
353                 {"a": "aval", "foo": {"is": {"nested": {"k1": "v1"}}}},
354             )
355             self.assertGrainFileContent(
356                 "a: aval\n" + "foo:\n" + "  is:\n" + "    nested:\n" + "      k1: v1\n"
357             )
358         with self.setGrains({"a": "aval", "foo": ["one", "is", "correct"]}):
359             ret = grains.present(name="foo:is:nested", value={"k1": "v1"})
360             self.assertEqual(ret["result"], True)
361             self.assertEqual(ret["comment"], "Set grain foo:is:nested to {'k1': 'v1'}")
362             self.assertEqual(
363                 ret["changes"],
364                 {"foo": ["one", {"is": {"nested": {"k1": "v1"}}}, "correct"]},
365             )
366             self.assertEqual(
367                 grains.__grains__,
368                 {
369                     "a": "aval",
370                     "foo": ["one", {"is": {"nested": {"k1": "v1"}}}, "correct"],
371                 },
372             )
373             self.assertGrainFileContent(
374                 "a: aval\n"
375                 + "foo:\n"
376                 + "- one\n"
377                 + "- is:\n"
378                 + "    nested:\n"
379                 + "      k1: v1\n"
380                 + "- correct\n"
381             )
382     def test_present_unknown_failure(self):
383         with patch("salt.modules.grains.setval") as mocked_setval:
384             mocked_setval.return_value = "Failed to set grain foo"
385             with self.setGrains({"a": "aval", "foo": "bar"}):
386                 ret = grains.present(name="foo", value="baz")
387                 self.assertEqual(ret["result"], False)
388                 self.assertEqual(ret["comment"], "Failed to set grain foo")
389                 self.assertEqual(ret["changes"], {})
390                 self.assertEqual(grains.__grains__, {"a": "aval", "foo": "bar"})
391                 self.assertGrainFileContent("a: aval\n" + "foo: bar\n")
392     def test_absent_already(self):
393         with self.setGrains({"a": "aval"}):
394             ret = grains.absent(name="foo")
395             self.assertEqual(ret["result"], True)
396             self.assertEqual(ret["comment"], "Grain foo does not exist")
397             self.assertEqual(ret["changes"], {})
398             self.assertEqual(grains.__grains__, {"a": "aval"})
399             self.assertGrainFileContent("a: aval\n")
400         with self.setGrains({"a": "aval"}):
401             ret = grains.absent(name="foo:is:nested")
402             self.assertEqual(ret["result"], True)
403             self.assertEqual(ret["comment"], "Grain foo:is:nested does not exist")
404             self.assertEqual(ret["changes"], {})
405             self.assertEqual(grains.__grains__, {"a": "aval"})
406             self.assertGrainFileContent("a: aval\n")
407     def test_absent_unset(self):
408         with self.setGrains({"a": "aval", "foo": "bar"}):
409             ret = grains.absent(name="foo")
410             self.assertEqual(ret["result"], True)
411             self.assertEqual(ret["comment"], "Value for grain foo was set to None")
412             self.assertEqual(ret["changes"], {"grain": "foo", "value": None})
413             self.assertEqual(grains.__grains__, {"a": "aval", "foo": None})
414             self.assertGrainFileContent("a: aval\n" + "foo: null\n")
415         with self.setGrains({"a": "aval", "foo": False}):
416             ret = grains.absent(name="foo")
417             self.assertEqual(ret["result"], True)
418             self.assertEqual(ret["comment"], "Value for grain foo was set to None")
419             self.assertEqual(ret["changes"], {"grain": "foo", "value": None})
420             self.assertEqual(grains.__grains__, {"a": "aval", "foo": None})
421             self.assertGrainFileContent("a: aval\n" + "foo: null\n")
422         with self.setGrains(
423             {"a": "aval", "foo": ["order", {"is": {"nested": "bar"}}, "correct"]}
424         ):
425             ret = grains.absent(name="foo,is,nested", delimiter=",")
426             self.assertEqual(ret["result"], True)
427             self.assertEqual(
428                 ret["comment"], "Value for grain foo:is:nested was set to None"
429             )
430             self.assertEqual(ret["changes"], {"grain": "foo:is:nested", "value": None})
431             self.assertEqual(
432                 grains.__grains__,
433                 {"a": "aval", "foo": ["order", {"is": {"nested": None}}, "correct"]},
434             )
435             self.assertGrainFileContent(
436                 "a: aval\n"
437                 + "foo:\n"
438                 + "- order\n"
439                 + "- is:\n"
440                 + "    nested: null\n"
441                 + "- correct\n"
442             )
443         with self.setGrains(
444             {"a": "aval", "foo": ["order", {"is": "nested"}, "correct"]}
445         ):
446             ret = grains.absent(name="foo:is:nested")
447             self.assertEqual(ret["result"], True)
448             self.assertEqual(ret["comment"], "Grain foo:is:nested does not exist")
449             self.assertEqual(ret["changes"], {})
450             self.assertEqual(
451                 grains.__grains__,
452                 {"a": "aval", "foo": ["order", {"is": "nested"}, "correct"]},
453             )
454             self.assertGrainFileContent(
455                 "a: aval\n" + "foo:\n" + "- order\n" + "- is: nested\n" + "- correct\n"
456             )
457     def test_absent_unset_test(self):
458         with patch.dict(grains.__opts__, {"test": True}):
459             with self.setGrains({"a": "aval", "foo": "bar"}):
460                 ret = grains.absent(name="foo")
461                 self.assertEqual(ret["result"], None)
462                 self.assertEqual(ret["changes"], {"grain": "foo", "value": None})
463                 self.assertEqual(grains.__grains__, {"a": "aval", "foo": "bar"})
464                 self.assertGrainFileContent("a: aval\n" + "foo: bar\n")
465     def test_absent_fails_nested_complex_grain(self):
466         with self.setGrains(
467             {"a": "aval", "foo": ["order", {"is": {"nested": "bar"}}, "correct"]}
468         ):
469             ret = grains.absent(name="foo:is")
470             self.assertEqual(ret["result"], False)
471             self.assertEqual(
472                 ret["comment"],
473                 "The key 'foo:is' exists but is a dict or a list. Use 'force=True' to"
474                 " overwrite.",
475             )
476             self.assertEqual(ret["changes"], {})
477             self.assertEqual(
478                 grains.__grains__,
479                 {"a": "aval", "foo": ["order", {"is": {"nested": "bar"}}, "correct"]},
480             )
481             self.assertGrainFileContent(
482                 "a: aval\n"
483                 + "foo:\n"
484                 + "- order\n"
485                 + "- is:\n"
486                 + "    nested: bar\n"
487                 + "- correct\n"
488             )
489     def test_absent_force_nested_complex_grain(self):
490         with self.setGrains(
491             {"a": "aval", "foo": ["order", {"is": {"nested": "bar"}}, "correct"]}
492         ):
493             ret = grains.absent(name="foo:is", force=True)
494             self.assertEqual(ret["result"], True)
495             self.assertEqual(ret["comment"], "Value for grain foo:is was set to None")
496             self.assertEqual(ret["changes"], {"grain": "foo:is", "value": None})
497             self.assertEqual(
498                 grains.__grains__,
499                 {"a": "aval", "foo": ["order", {"is": None}, "correct"]},
500             )
501             self.assertGrainFileContent(
502                 "a: aval\n" + "foo:\n" + "- order\n" + "- is: null\n" + "- correct\n"
503             )
504     def test_absent_delete(self):
505         with self.setGrains({"a": "aval", "foo": "bar"}):
506             ret = grains.absent(name="foo", destructive=True)
507             self.assertEqual(ret["result"], True)
508             self.assertEqual(ret["comment"], "Grain foo was deleted")
509             self.assertEqual(ret["changes"], {"deleted": "foo"})
510             self.assertEqual(grains.__grains__, {"a": "aval"})
511             self.assertGrainFileContent("a: aval\n")
512         with self.setGrains({"a": "aval", "foo": None}):
513             ret = grains.absent(name="foo", destructive=True)
514             self.assertEqual(ret["result"], True)
515             self.assertEqual(ret["comment"], "Grain foo was deleted")
516             self.assertEqual(ret["changes"], {"deleted": "foo"})
517             self.assertEqual(grains.__grains__, {"a": "aval"})
518             self.assertGrainFileContent("a: aval\n")
519         with self.setGrains(
520             {
521                 "a": "aval",
522                 "foo": [
523                     "order",
524                     {"is": {"nested": "bar", "other": "value"}},
525                     "correct",
526                 ],
527             }
528         ):
529             ret = grains.absent(name="foo:is:nested", destructive=True)
530             self.assertEqual(ret["result"], True)
531             self.assertEqual(ret["comment"], "Grain foo:is:nested was deleted")
532             self.assertEqual(ret["changes"], {"deleted": "foo:is:nested"})
533             self.assertEqual(
534                 grains.__grains__,
535                 {"a": "aval", "foo": ["order", {"is": {"other": "value"}}, "correct"]},
536             )
537             self.assertGrainFileContent(
538                 "a: aval\n"
539                 + "foo:\n"
540                 + "- order\n"
541                 + "- is:\n"
542                 + "    other: value\n"
543                 + "- correct\n"
544             )
545     def test_append(self):
546         with self.setGrains({"a": "aval", "foo": ["bar"]}):
547             ret = grains.append(name="foo", value="baz")
548             self.assertEqual(ret["result"], True)
549             self.assertEqual(ret["comment"], "Value baz was added to grain foo")
550             self.assertEqual(ret["changes"], {"added": "baz"})
551             self.assertEqual(grains.__grains__, {"a": "aval", "foo": ["bar", "baz"]})
552             self.assertGrainFileContent("a: aval\n" + "foo:\n" + "- bar\n" + "- baz\n")
553     def test_append_nested(self):
554         with self.setGrains({"a": "aval", "foo": {"list": ["bar"]}}):
555             ret = grains.append(name="foo,list", value="baz", delimiter=",")
556             self.assertEqual(ret["result"], True)
557             self.assertEqual(ret["comment"], "Value baz was added to grain foo:list")
558             self.assertEqual(ret["changes"], {"added": "baz"})
559             self.assertEqual(
560                 grains.__grains__, {"a": "aval", "foo": {"list": ["bar", "baz"]}}
561             )
562             self.assertGrainFileContent(
563                 "a: aval\n" + "foo:\n" + "  list:\n" + "  - bar\n" + "  - baz\n"
564             )
565     def test_append_already(self):
566         with self.setGrains({"a": "aval", "foo": ["bar"]}):
567             ret = grains.append(name="foo", value="bar")
568             self.assertEqual(ret["result"], True)
569             self.assertEqual(
570                 ret["comment"], "Value bar is already in the list " + "for grain foo"
571             )
572             self.assertEqual(ret["changes"], {})
573             self.assertEqual(grains.__grains__, {"a": "aval", "foo": ["bar"]})
574             self.assertGrainFileContent("a: aval\n" + "foo:\n" + "- bar\n")
575     def test_append_fails_not_a_list(self):
576         with self.setGrains({"a": "aval", "foo": {"bar": "val"}}):
577             ret = grains.append(name="foo", value="baz")
578             self.assertEqual(ret["result"], False)
579             self.assertEqual(ret["comment"], "Grain foo is not a valid list")
580             self.assertEqual(ret["changes"], {})
581             self.assertEqual(grains.__grains__, {"a": "aval", "foo": {"bar": "val"}})
582     def test_append_convert_to_list(self):
583         with self.setGrains({"a": "aval", "foo": {"bar": "val"}}):
584             self.assertGrainFileContent("a: aval\n" + "foo:\n" + "  bar: val\n")
585             ret = grains.append(name="foo", value="baz", convert=True)
586             self.assertEqual(ret["result"], True)
587             self.assertEqual(ret["comment"], "Value baz was added to grain foo")
588             self.assertEqual(ret["changes"], {"added": "baz"})
589             self.assertEqual(
590                 grains.__grains__, {"a": "aval", "foo": [{"bar": "val"}, "baz"]}
591             )
592             self.assertGrainFileContent(
593                 "a: aval\n" + "foo:\n" + "- bar: val\n" + "- baz\n"
594             )
595         with self.setGrains({"a": "aval", "foo": {"bar": "val", "other": "value"}}):
596             self.assertGrainFileContent(
597                 "a: aval\n" + "foo:\n" + "  bar: val\n" + "  other: value\n"
598             )
599             ret = grains.append(name="foo", value="baz", convert=True)
600             self.assertEqual(ret["result"], True)
601             self.assertEqual(ret["comment"], "Value baz was added to grain foo")
602             self.assertEqual(ret["changes"], {"added": "baz"})
603             self.assertEqual(
604                 grains.__grains__,
605                 {"a": "aval", "foo": [{"bar": "val", "other": "value"}, "baz"]},
606             )
607             self.assertGrainFileContent(
608                 "a: aval\n" + "foo:\n" + "- bar: val\n" + "  other: value\n" + "- baz\n"
609             )
610     def test_append_fails_inexistent(self):
611         with self.setGrains({"a": "aval"}):
612             ret = grains.append(name="foo", value="bar")
613             self.assertEqual(ret["result"], False)
614             self.assertEqual(ret["comment"], "Grain foo does not exist")
615             self.assertEqual(ret["changes"], {})
616             self.assertEqual(grains.__grains__, {"a": "aval"})
617     def test_append_convert_to_list_empty(self):
618         with self.setGrains({"foo": None}):
619             ret = grains.append(name="foo", value="baz", convert=True)
620             self.assertEqual(ret["result"], True)
621             self.assertEqual(ret["comment"], "Value baz was added to grain foo")
622             self.assertEqual(ret["changes"], {"added": "baz"})
623             self.assertEqual(grains.__grains__, {"foo": ["baz"]})
624             self.assertGrainFileContent("foo:\n" + "- baz\n")
625     def test_list_present(self):
626         with self.setGrains({"a": "aval", "foo": ["bar"]}):
627             ret = grains.list_present(name="foo", value="baz")
628             self.assertEqual(ret["result"], True)
629             self.assertEqual(ret["comment"], "Append value baz to grain foo")
630             self.assertEqual(ret["changes"], {"new": {"foo": ["bar", "baz"]}})
631             self.assertEqual(grains.__grains__, {"a": "aval", "foo": ["bar", "baz"]})
632             self.assertGrainFileContent("a: aval\n" + "foo:\n" + "- bar\n" + "- baz\n")
633     def test_list_present_nested(self):
634         with self.setGrains({"a": "aval", "foo": {"is": {"nested": ["bar"]}}}):
635             ret = grains.list_present(name="foo,is,nested", value="baz", delimiter=",")
636             self.assertEqual(ret["result"], True)
637             self.assertEqual(ret["comment"], "Append value baz to grain foo:is:nested")
638             self.assertEqual(
639                 ret["changes"], {"new": {"foo": {"is": {"nested": ["bar", "baz"]}}}}
640             )
641             self.assertEqual(
642                 grains.__grains__,
643                 {"a": "aval", "foo": {"is": {"nested": ["bar", "baz"]}}},
644             )
645             self.assertGrainFileContent(
646                 "a: aval\n"
647                 + "foo:\n"
648                 + "  is:\n"
649                 + "    nested:\n"
650                 + "    - bar\n"
651                 + "    - baz\n"
652             )
653     def test_list_present_inexistent(self):
654         with self.setGrains({"a": "aval"}):
655             ret = grains.list_present(name="foo", value="baz")
656             self.assertEqual(ret["result"], True)
657             self.assertEqual(ret["comment"], "Append value baz to grain foo")
658             self.assertEqual(ret["changes"], {"new": {"foo": ["baz"]}})
659             self.assertEqual(grains.__grains__, {"a": "aval", "foo": ["baz"]})
660             self.assertGrainFileContent("a: aval\n" + "foo:\n" + "- baz\n")
661     def test_list_present_inexistent_nested(self):
662         with self.setGrains({"a": "aval"}):
663             ret = grains.list_present(name="foo:is:nested", value="baz")
664             self.assertEqual(ret["result"], True)
665             self.assertEqual(ret["comment"], "Append value baz to grain foo:is:nested")
666             self.assertEqual(
667                 ret["changes"], {"new": {"foo": {"is": {"nested": ["baz"]}}}}
668             )
669             self.assertEqual(
670                 grains.__grains__, {"a": "aval", "foo": {"is": {"nested": ["baz"]}}}
671             )
672             self.assertGrainFileContent(
673                 "a: aval\n" + "foo:\n" + "  is:\n" + "    nested:\n" + "    - baz\n"
674             )
675     def test_list_present_not_a_list(self):
676         with self.setGrains({"a": "aval", "foo": "bar"}):
677             ret = grains.list_present(name="foo", value="baz")
678             self.assertEqual(ret["result"], False)
679             self.assertEqual(ret["comment"], "Grain foo is not a valid list")
680             self.assertEqual(ret["changes"], {})
681             self.assertEqual(grains.__grains__, {"a": "aval", "foo": "bar"})
682             self.assertGrainFileContent("a: aval\n" + "foo: bar\n")
683     def test_list_present_nested_already(self):
684         with self.setGrains({"a": "aval", "b": {"foo": ["bar"]}}):
685             ret = grains.list_present(name="b:foo", value="bar")
686             self.assertEqual(ret["result"], True)
687             self.assertEqual(ret["comment"], "Value bar is already in grain b:foo")
688             self.assertEqual(ret["changes"], {})
689             self.assertEqual(grains.__grains__, {"a": "aval", "b": {"foo": ["bar"]}})
690             self.assertGrainFileContent("a: aval\n" + "b:\n" + "  foo:\n" + "  - bar\n")
691     def test_list_present_already(self):
692         with self.setGrains({"a": "aval", "foo": ["bar"]}):
693             ret = grains.list_present(name="foo", value="bar")
694             self.assertEqual(ret["result"], True)
695             self.assertEqual(ret["comment"], "Value bar is already in grain foo")
696             self.assertEqual(ret["changes"], {})
697             self.assertEqual(grains.__grains__, {"a": "aval", "foo": ["bar"]})
698             self.assertGrainFileContent("a: aval\n" + "foo:\n" + "- bar\n")
699     def test_list_present_unknown_failure(self):
700         with self.setGrains({"a": "aval", "foo": ["bar"]}):
701             with patch.dict(grainsmod.__salt__, {"grains.append": MagicMock()}):
702                 ret = grains.list_present(name="foo", value="baz")
703                 self.assertEqual(ret["result"], False)
704                 self.assertEqual(ret["comment"], "Failed append value baz to grain foo")
705                 self.assertEqual(ret["changes"], {})
706                 self.assertEqual(grains.__grains__, {"a": "aval", "foo": ["bar"]})
707                 self.assertGrainFileContent("a: aval\n" + "foo:\n" + "- bar\n")
708     def test_list_absent(self):
709         with self.setGrains({"a": "aval", "foo": ["bar"]}):
710             ret = grains.list_absent(name="foo", value="bar")
711             self.assertEqual(ret["result"], True)
712             self.assertEqual(ret["comment"], "Value bar was deleted from grain foo")
713             self.assertEqual(ret["changes"], {"deleted": ["bar"]})
714             self.assertEqual(grains.__grains__, {"a": "aval", "foo": []})
715             self.assertGrainFileContent("a: aval\n" + "foo: []\n")
716     def test_list_absent_nested(self):
717         with self.setGrains({"a": "aval", "foo": {"list": ["bar"]}}):
718             ret = grains.list_absent(name="foo:list", value="bar")
719             self.assertEqual(ret["result"], True)
720             self.assertEqual(
721                 ret["comment"], "Value bar was deleted from grain foo:list"
722             )
723             self.assertEqual(ret["changes"], {"deleted": ["bar"]})
724             self.assertEqual(grains.__grains__, {"a": "aval", "foo": {"list": []}})
725             self.assertGrainFileContent("a: aval\n" + "foo:\n" + "  list: []\n")
726     def test_list_absent_inexistent(self):
727         with self.setGrains({"a": "aval"}):
728             ret = grains.list_absent(name="foo", value="baz")
729             self.assertEqual(ret["result"], True)
730             self.assertEqual(ret["comment"], "Grain foo does not exist")
731             self.assertEqual(ret["changes"], {})
732             self.assertEqual(grains.__grains__, {"a": "aval"})
733             self.assertGrainFileContent("a: aval\n")
734     def test_list_absent_inexistent_nested(self):
735         with self.setGrains({"a": "aval"}):
736             ret = grains.list_absent(name="foo:list", value="baz")
737             self.assertEqual(ret["result"], True)
738             self.assertEqual(ret["comment"], "Grain foo:list does not exist")
739             self.assertEqual(ret["changes"], {})
740             self.assertEqual(grains.__grains__, {"a": "aval"})
741             self.assertGrainFileContent("a: aval\n")
742     def test_list_absent_not_a_list(self):
743         with self.setGrains({"a": "aval", "foo": "bar"}):
744             ret = grains.list_absent(name="foo", value="bar")
745             self.assertEqual(ret["result"], False)
746             self.assertEqual(ret["comment"], "Grain foo is not a valid list")
747             self.assertEqual(ret["changes"], {})
748             self.assertEqual(grains.__grains__, {"a": "aval", "foo": "bar"})
749             self.assertGrainFileContent("a: aval\n" + "foo: bar\n")
750     def test_list_absent_already(self):
751         with self.setGrains({"a": "aval", "foo": ["bar"]}):
752             ret = grains.list_absent(name="foo", value="baz")
753             self.assertEqual(ret["result"], True)
754             self.assertEqual(ret["comment"], "Value baz is absent from grain foo")
755             self.assertEqual(ret["changes"], {})
756             self.assertEqual(grains.__grains__, {"a": "aval", "foo": ["bar"]})
757             self.assertGrainFileContent("a: aval\n" + "foo:\n" + "- bar\n")
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_boto_apigateway.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import datetime
2 import logging
3 import os
4 import random
5 import string
6 import pytest
7 import salt.config
8 import salt.loader
9 import salt.states.boto_apigateway as boto_apigateway
10 import salt.utils.files
11 import salt.utils.yaml
12 from salt.utils.versions import LooseVersion
13 from tests.support.mixins import LoaderModuleMockMixin
14 from tests.support.mock import MagicMock, patch
15 from tests.support.unit import TestCase, skipIf
16 from tests.unit.modules.test_boto_apigateway import BotoApiGatewayTestCaseMixin
17 try:
18     import boto3
19     import botocore
20     from botocore.exceptions import ClientError
21     HAS_BOTO = True
22 except ImportError:
23     HAS_BOTO = False
24 required_boto3_version = "1.2.1"
25 required_botocore_version = "1.4.49"
26 region = "us-east-1"
27 access_key = "GKTADJGHEIQSXMKKRBJ08H"
28 secret_key = "askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs"
29 conn_parameters = {
30     "region": region,
31     "key": access_key,
32     "keyid": secret_key,
33     "profile": {},
34 }
35 error_message = (
36     "An error occurred (101) when calling the {0} operation: Test-defined error"
37 )
38 error_content = {"Error": {"Code": 101, "Message": "Test-defined error"}}
39 api_ret = dict(
40     description=(
41         '{\n    "context": "See deployment or stage description",\n   '
42         ' "provisioned_by": "Salt boto_apigateway.present State"\n}'
43     ),
44     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
45     id="vni0vq8wzi",
46     name="unit test api",
47 )
48 no_apis_ret = {"items": []}
49 apis_ret = {"items": [api_ret]}
50 mock_model_ret = dict(
51     contentType="application/json",
52     description="mock model",
53     id="123abc",
54     name="mock model",
55     schema=(
56         "{\n"
57         '    "$schema": "http://json-schema.org/draft-04/schema#",\n'
58         '    "properties": {\n'
59         '        "field": {\n'
60         '            "type": "string"\n'
61         "        }\n"
62         "    }\n"
63         "}"
64     ),
65 )
66 models_ret = {
67     "items": [
68         dict(
69             contentType="application/json",
70             description="Error",
71             id="50nw8r",
72             name="Error",
73             schema=(
74                 "{\n"
75                 '    "$schema": "http://json-schema.org/draft-04/schema#",\n'
76                 '    "properties": {\n'
77                 '        "code": {\n'
78                 '            "format": "int32",\n'
79                 '            "type": "integer"\n'
80                 "        },\n"
81                 '        "fields": {\n'
82                 '            "type": "string"\n'
83                 "        },\n"
84                 '        "message": {\n'
85                 '            "type": "string"\n'
86                 "        }\n"
87                 "    },\n"
88                 '    "title": "Error Schema",\n'
89                 '    "type": "object"\n'
90                 "}"
91             ),
92         ),
93         dict(
94             contentType="application/json",
95             description="User",
96             id="terlnw",
97             name="User",
98             schema=(
99                 "{\n"
100                 '    "$schema": "http://json-schema.org/draft-04/schema#",\n'
101                 '    "properties": {\n'
102                 '        "password": {\n'
103                 '            "description": "A password for the new user",\n'
104                 '            "type": "string"\n'
105                 "        },\n"
106                 '        "username": {\n'
107                 '            "description": "A unique username for the user",\n'
108                 '            "type": "string"\n'
109                 "        }\n"
110                 "    },\n"
111                 '    "title": "User Schema",\n'
112                 '    "type": "object"\n'
113                 "}"
114             ),
115         ),
116     ]
117 }
118 root_resources_ret = {"items": [dict(id="bgk0rk8rqb", path="/")]}
119 resources_ret = {
120     "items": [
121         dict(id="bgk0rk8rqb", path="/"),
122         dict(
123             id="9waiaz",
124             parentId="bgk0rk8rqb",
125             path="/users",
126             pathPart="users",
127             resourceMethods={"POST": {}},
128         ),
129     ]
130 }
131 no_resources_ret = {"items": []}
132 stage1_deployment1_ret = dict(
133     cacheClusterEnabled=False,
134     cacheClusterSize=0.5,
135     cacheClusterStatus="NOT_AVAILABLE",
136     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
137     deploymentId="kobnrb",
138     description=(
139         "{\n"
140         '    "current_deployment_label": {\n'
141         '        "api_name": "unit test api",\n'
142         '        "swagger_file": "temp-swagger-sample.yaml",\n'
143         '        "swagger_file_md5sum": "4fb17e43bab3a96e7f2410a1597cd0a5",\n'
144         '        "swagger_info_object": {\n'
145         '            "description": "salt boto apigateway unit test service",\n'
146         '            "title": "salt boto apigateway unit test service",\n'
147         '            "version": "0.0.0"\n'
148         "        }\n"
149         "    }\n"
150         "}"
151     ),
152     lastUpdatedDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
153     methodSettings=dict(),
154     stageName="test",
155     variables=dict(),
156 )
157 stage1_deployment1_vars_ret = dict(
158     cacheClusterEnabled=False,
159     cacheClusterSize=0.5,
160     cacheClusterStatus="NOT_AVAILABLE",
161     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
162     deploymentId="kobnrb",
163     description=(
164         "{\n"
165         '    "current_deployment_label": {\n'
166         '        "api_name": "unit test api",\n'
167         '        "swagger_file": "temp-swagger-sample.yaml",\n'
168         '        "swagger_file_md5sum": "4fb17e43bab3a96e7f2410a1597cd0a5",\n'
169         '        "swagger_info_object": {\n'
170         '            "description": "salt boto apigateway unit test service",\n'
171         '            "title": "salt boto apigateway unit test service",\n'
172         '            "version": "0.0.0"\n'
173         "        }\n"
174         "    }\n"
175         "}"
176     ),
177     lastUpdatedDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
178     methodSettings=dict(),
179     stageName="test",
180     variables={"var1": "val1"},
181 )
182 stage1_deployment2_ret = dict(
183     cacheClusterEnabled=False,
184     cacheClusterSize=0.5,
185     cacheClusterStatus="NOT_AVAILABLE",
186     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
187     deploymentId="kobnrc",
188     description=(
189         "{\n"
190         '    "current_deployment_label": {\n'
191         '        "api_name": "unit test api",\n'
192         '        "swagger_file": "temp-swagger-sample.yaml",\n'
193         '        "swagger_file_md5sum": "5fd538c4336ed5c54b4bf39ddf97c661",\n'
194         '        "swagger_info_object": {\n'
195         '            "description": "salt boto apigateway unit test service",\n'
196         '            "title": "salt boto apigateway unit test service",\n'
197         '            "version": "0.0.2"\n'
198         "        }\n"
199         "    }\n"
200         "}"
201     ),
202     lastUpdatedDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
203     methodSettings=dict(),
204     stageName="test",
205     variables=dict(),
206 )
207 stage2_ret = dict(
208     cacheClusterEnabled=False,
209     cacheClusterSize=0.5,
210     cacheClusterStatus="NOT_AVAILABLE",
211     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
212     deploymentId="kobnrb",
213     description=(
214         "{\n"
215         '    "current_deployment_label": {\n'
216         '        "api_name": "unit test api",\n'
217         '        "swagger_file": "temp-swagger-sample.yaml",\n'
218         '        "swagger_file_md5sum": "4fb17e43bab3a96e7f2410a1597cd0a5",\n'
219         '        "swagger_info_object": {\n'
220         '            "description": "salt boto apigateway unit test service",\n'
221         '            "title": "salt boto apigateway unit test service",\n'
222         '            "version": "0.0.0"\n'
223         "        }\n"
224         "    }\n"
225         "}"
226     ),
227     lastUpdatedDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
228     methodSettings=dict(),
229     stageName="dev",
230     variables=dict(),
231 )
232 stages_stage2_ret = {"item": [stage2_ret]}
233 no_stages_ret = {"item": []}
234 deployment1_ret = dict(
235     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
236     description=(
237         "{\n"
238         '    "api_name": "unit test api",\n'
239         '    "swagger_file": "temp-swagger-sample.yaml",\n'
240         '    "swagger_file_md5sum": "55a948ff90ad80ff747ec91657c7a299",\n'
241         '    "swagger_info_object": {\n'
242         '        "description": "salt boto apigateway unit test service",\n'
243         '        "title": "salt boto apigateway unit test service",\n'
244         '        "version": "0.0.0"\n'
245         "    }\n"
246         "}"
247     ),
248     id="kobnrb",
249 )
250 deployment2_ret = dict(
251     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
252     description=(
253         "{\n"
254         '    "api_name": "unit test api",\n'
255         '    "swagger_file": "temp-swagger-sample.yaml",\n'
256         '    "swagger_file_md5sum": "5fd538c4336ed5c54b4bf39ddf97c661",\n'
257         '    "swagger_info_object": {\n'
258         '        "description": "salt boto apigateway unit test service",\n'
259         '        "title": "salt boto apigateway unit test service",\n'
260         '        "version": "0.0.2"\n'
261         "    }\n"
262         "}"
263     ),
264     id="kobnrc",
265 )
266 deployments_ret = {"items": [deployment1_ret, deployment2_ret]}
267 function_ret = dict(
268     FunctionName="unit_test_api_users_post",
269     Runtime="python2.7",
270     Role=None,
271     Handler="handler",
272     Description="abcdefg",
273     Timeout=5,
274     MemorySize=128,
275     CodeSha256="abcdef",
276     CodeSize=199,
277     FunctionArn="arn:lambda:us-east-1:1234:Something",
278     LastModified="yes",
279 )
280 method_integration_response_200_ret = dict(
281     responseParameters={"method.response.header.Access-Control-Allow-Origin": "*"},
282     responseTemplates={},
283     selectionPattern=".*",
284     statusCode="200",
285 )
286 method_integration_ret = dict(
287     cacheKeyParameters={},
288     cacheNamespace="9waiaz",
289     credentials="arn:aws:iam::1234:role/apigatewayrole",
290     httpMethod="POST",
291     integrationResponses={"200": method_integration_response_200_ret},
292     requestParameters={},
293     requestTemplates={
294         "application/json": (
295             "#set($inputRoot = $input.path('$')){\"header-params\" : {#set ($map ="
296             ' $input.params().header)#foreach( $param in $map.entrySet() )"$param.key"'
297             ' : "$param.value" #if( $foreach.hasNext ), #end#end},"query-params" :'
298             " {#set ($map = $input.params().querystring)#foreach( $param in"
299             ' $map.entrySet() )"$param.key" : "$param.value" #if( $foreach.hasNext ),'
300             ' #end#end},"path-params" : {#set ($map = $input.params().path)#foreach('
301             ' $param in $map.entrySet() )"$param.key" : "$param.value" #if('
302             " $foreach.hasNext ), #end#end},\"body-params\" : $input.json('$')}"
303         )
304     },
305     type="AWS",
306     uri=(
307         "arn:aws:apigateway:us-west-2:"
308         "lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:1234567:"
309         "function:unit_test_api_api_users_post/invocations"
310     ),
311 )
312 method_response_200_ret = dict(
313     responseModels={"application/json": "User"},
314     responseParameters={"method.response.header.Access-Control-Allow-Origin": False},
315     statusCode="200",
316 )
317 method_ret = dict(
318     apiKeyRequired=False,
319     authorizationType="None",
320     httpMethod="POST",
321     methodIntegration=method_integration_ret,
322     methodResponses={"200": method_response_200_ret},
323     requestModels={"application/json": "User"},
324     requestParameters={},
325 )
326 throttle_rateLimit = 10.0
327 association_stage_1 = {"apiId": "apiId1", "stage": "stage1"}
328 association_stage_2 = {"apiId": "apiId1", "stage": "stage2"}
329 log = logging.getLogger(__name__)
330 def _has_required_boto():
331     if not HAS_BOTO:
332         return False
333     elif LooseVersion(boto3.__version__) &lt; LooseVersion(required_boto3_version):
334         return False
335     else:
336         return True
337 def _has_required_botocore():
338     if not HAS_BOTO:
339         return False
340     elif LooseVersion(botocore.__version__) &lt; LooseVersion(required_botocore_version):
341         return False
342     else:
343         return True
344 class TempSwaggerFile:
345     _tmp_swagger_dict = {
346         "info": {
347             "version": "0.0.0",
348             "description": "salt boto apigateway unit test service",
349             "title": "salt boto apigateway unit test service",
350         },
351         "paths": {
352             "/users": {
353                 "post": {
354                     "responses": {
355                         "200": {
356                             "headers": {
357                                 "Access-Control-Allow-Origin": {"type": "string"}
358                             },
359                             "description": "The username of the new user",
360                             "schema": {"$ref": "#/definitions/User"},
361                         }
362                     },
363                     "parameters": [
364                         {
365                             "in": "body",
366                             "description": "New user details.",
367                             "name": "NewUser",
368                             "schema": {"$ref": "#/definitions/User"},
369                         }
370                     ],
371                     "produces": ["application/json"],
372                     "description": "Creates a new user.",
373                     "tags": ["Auth"],
374                     "consumes": ["application/json"],
375                     "summary": "Registers a new user",
376                 }
377             }
378         },
379         "schemes": ["https"],
380         "produces": ["application/json"],
381         "basePath": "/api",
382         "host": "rm06h9oac4.execute-api.us-west-2.amazonaws.com",
383         "definitions": {
384             "User": {
385                 "properties": {
386                     "username": {
387                         "type": "string",
388                         "description": "A unique username for the user",
389                     },
390                     "password": {
391                         "type": "string",
392                         "description": "A password for the new user",
393                     },
394                 }
395             },
396             "Error": {
397                 "properties": {
398                     "fields": {"type": "string"},
399                     "message": {"type": "string"},
400                     "code": {"type": "integer", "format": "int32"},
401                 }
402             },
403         },
404         "swagger": "2.0",
405     }
406     def __enter__(self):
407         self.swaggerfile = "temp-swagger-sample.yaml"
408         with salt.utils.files.fopen(self.swaggerfile, "w") as fp_:
409             salt.utils.yaml.safe_dump(self.swaggerdict, fp_, default_flow_style=False)
410         return self.swaggerfile
411     def __exit__(self, objtype, value, traceback):
412         os.remove(self.swaggerfile)
413     def __init__(self, create_invalid_file=False):
414         if create_invalid_file:
415             self.swaggerdict = TempSwaggerFile<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>._tmp_swagger_dict.copy()
416             self.swaggerdict["invalid_key"] = "invalid"
417             self.swaggerdict.pop("schemes", None)
418             self.swaggerdict["swagger"] = "3.0"
419             self.swaggerdict.pop("info", None)
420         else:
421             self.</b></font>swaggerdict = TempSwaggerFile._tmp_swagger_dict
422 class BotoApiGatewayStateTestCaseBase(TestCase, LoaderModuleMockMixin):
423     conn = None
424     @classmethod
425     def setUpClass(cls):
426         cls.opts = salt.config.DEFAULT_MINION_OPTS.copy()
427         cls.opts["grains"] = salt.loader.grains(cls.opts)
428     @classmethod
429     def tearDownClass(cls):
430         del cls.opts
431     def setup_loader_modules(self):
432         context = {}
433         utils = salt.loader.utils(
434             self.opts,
435             whitelist=["boto", "boto3", "args", "systemd", "path", "platform", "reg"],
436             context=context,
437         )
438         serializers = salt.loader.serializers(self.opts)
439         self.funcs = salt.loader.minion_mods(
440             self.opts, context=context, utils=utils, whitelist=["boto_apigateway"]
441         )
442         self.salt_states = salt.loader.states(
443             opts=self.opts,
444             functions=self.funcs,
445             utils=utils,
446             whitelist=["boto_apigateway"],
447             serializers=serializers,
448         )
449         return {
450             boto_apigateway: {
451                 "__opts__": self.opts,
452                 "__utils__": utils,
453                 "__salt__": self.funcs,
454                 "__states__": self.salt_states,
455                 "__serializers__": serializers,
456             }
457         }
458     def setUp(self):
459         self.addCleanup(delattr, self, "funcs")
460         self.addCleanup(delattr, self, "salt_states")
461         conn_parameters["key"] = "".join(
462             random.choice(string.ascii_lowercase + string.digits) for _ in range(50)
463         )
464         patcher = patch("boto3.session.Session")
465         self.addCleanup(patcher.stop)
466         mock_session = patcher.start()
467         session_instance = mock_session.return_value
468         self.conn = MagicMock()
469         self.addCleanup(delattr, self, "conn")
470         session_instance.client.return_value = self.conn
471 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
472 @skipIf(
473     _has_required_boto() is False,
474     "The boto3 module must be greater than or equal to version {}".format(
475         required_boto3_version
476     ),
477 )
478 class BotoApiGatewayTestCase(
479     BotoApiGatewayStateTestCaseBase, BotoApiGatewayTestCaseMixin
480 ):
481     def test_present_when_swagger_file_is_invalid(self):
482         result = {}
483         with TempSwaggerFile(create_invalid_file=True) as swagger_file:
484             result = self.salt_states["boto_apigateway.present"](
485                 "api present",
486                 "unit test api",
487                 swagger_file,
488                 "test",
489                 False,
490                 "arn:aws:iam::1234:role/apigatewayrole",
491                 **conn_parameters
492             )
493         self.assertFalse(result.get("result", True))
494     def test_present_when_stage_is_already_at_desired_deployment(self):
495         self.conn.get_rest_apis.return_value = apis_ret
496         self.conn.get_deployment.return_value = deployment1_ret
497         self.conn.get_stage.return_value = stage1_deployment1_ret
498         self.conn.update_stage.side_effect = ClientError(
499             error_content, "update_stage should not be called"
500         )
501         result = {}
502         with TempSwaggerFile() as swagger_file:
503             result = self.salt_states["boto_apigateway.present"](
504                 "api present",
505                 "unit test api",
506                 swagger_file,
507                 "test",
508                 False,
509                 "arn:aws:iam::1234:role/apigatewayrole",
510                 **conn_parameters
511             )
512         self.assertFalse(result.get("abort"))
513         self.assertTrue(result.get("current"))
514         self.assertIs(result.get("result"), True)
515         self.assertNotIn("update_stage should not be called", result.get("comment", ""))
516     def test_present_when_stage_is_already_at_desired_deployment_and_needs_stage_variables_update(
517         self,
518     ):
519         self.conn.get_rest_apis.return_value = apis_ret
520         self.conn.get_deployment.return_value = deployment1_ret
521         self.conn.get_stage.return_value = stage1_deployment1_ret
522         self.conn.update_stage.return_value = stage1_deployment1_vars_ret
523         result = {}
524         with TempSwaggerFile() as swagger_file:
525             result = self.salt_states["boto_apigateway.present"](
526                 "api present",
527                 "unit test api",
528                 swagger_file,
529                 "test",
530                 False,
531                 "arn:aws:iam::1234:role/apigatewayrole",
532                 stage_variables={"var1": "val1"},
533                 **conn_parameters
534             )
535         self.assertFalse(result.get("abort"))
536         self.assertTrue(result.get("current"))
537         self.assertIs(result.get("result"), True)
538     def test_present_when_stage_exists_and_is_to_associate_to_existing_deployment(self):
539         self.conn.get_rest_apis.return_value = apis_ret
540         self.conn.get_deployment.return_value = deployment2_ret
541         self.conn.get_deployments.return_value = deployments_ret
542         self.conn.get_stage.return_value = stage1_deployment2_ret
543         self.conn.update_stage.return_value = stage1_deployment1_ret
544         self.conn.create_stage.side_effect = ClientError(error_content, "create_stage")
545         self.conn.create_deployment.side_effect = ClientError(
546             error_content, "create_deployment"
547         )
548         result = {}
549         with TempSwaggerFile() as swagger_file:
550             result = self.salt_states["boto_apigateway.present"](
551                 "api present",
552                 "unit test api",
553                 swagger_file,
554                 "test",
555                 False,
556                 "arn:aws:iam::1234:role/apigatewayrole",
557                 **conn_parameters
558             )
559         self.assertTrue(result.get("publish"))
560         self.assertIs(result.get("result"), True)
561         self.assertFalse(result.get("abort"))
562         self.assertTrue(result.get("changes", {}).get("new", [{}])[0])
563     @pytest.mark.slow_test
564     def test_present_when_stage_is_to_associate_to_new_deployment(self):
565         self.conn.get_rest_apis.return_value = no_apis_ret
566         self.conn.create_rest_api.return_value = api_ret
567         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
568         self.conn.create_model.return_value = mock_model_ret
569         self.conn.get_resources.return_value = resources_ret
570         self.conn.create_resource.side_effect = ClientError(
571             error_content, "create_resource"
572         )
573         self.conn.put_method.return_value = method_ret
574         self.conn.put_integration.return_value = method_integration_ret
575         self.conn.put_method_response.return_value = method_response_200_ret
576         self.conn.put_intgration_response.return_value = (
577             method_integration_response_200_ret
578         )
579         result = {}
580         with patch.dict(
581             self.funcs,
582             {
583                 "boto_lambda.describe_function": MagicMock(
584                     return_value={"function": function_ret}
585                 )
586             },
587         ):
588             with TempSwaggerFile() as swagger_file:
589                 result = self.salt_states["boto_apigateway.present"](
590                     "api present",
591                     "unit test api",
592                     swagger_file,
593                     "test",
594                     False,
595                     "arn:aws:iam::1234:role/apigatewayrole",
596                     **conn_parameters
597                 )
598         self.assertIs(result.get("result"), True)
599         self.assertIs(result.get("abort"), None)
600     def test_present_when_stage_associating_to_new_deployment_errored_on_api_creation(
601         self,
602     ):
603         self.conn.get_rest_apis.return_value = no_apis_ret
604         self.conn.create_rest_api.side_effect = ClientError(
605             error_content, "create_rest_api"
606         )
607         result = {}
608         with TempSwaggerFile() as swagger_file:
609             result = self.salt_states["boto_apigateway.present"](
610                 "api present",
611                 "unit test api",
612                 swagger_file,
613                 "test",
614                 False,
615                 "arn:aws:iam::1234:role/apigatewayrole",
616                 **conn_parameters
617             )
618         self.assertIs(result.get("abort"), True)
619         self.assertIs(result.get("result"), False)
620         self.assertIn("create_rest_api", result.get("comment", ""))
621     def test_present_when_stage_associating_to_new_deployment_errored_on_model_creation(
622         self,
623     ):
624         self.conn.get_rest_apis.return_value = no_apis_ret
625         self.conn.create_rest_api.return_value = api_ret
626         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
627         self.conn.create_model.side_effect = ClientError(error_content, "create_model")
628         result = {}
629         with TempSwaggerFile() as swagger_file:
630             result = self.salt_states["boto_apigateway.present"](
631                 "api present",
632                 "unit test api",
633                 swagger_file,
634                 "test",
635                 False,
636                 "arn:aws:iam::1234:role/apigatewayrole",
637                 **conn_parameters
638             )
639         self.assertIs(result.get("abort"), True)
640         self.assertIs(result.get("result"), False)
641         self.assertIn("create_model", result.get("comment", ""))
642     def test_present_when_stage_associating_to_new_deployment_errored_on_resource_creation(
643         self,
644     ):
645         self.conn.get_rest_apis.return_value = no_apis_ret
646         self.conn.create_rest_api.return_value = api_ret
647         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
648         self.conn.create_model.return_value = mock_model_ret
649         self.conn.get_resources.return_value = root_resources_ret
650         self.conn.create_resource.side_effect = ClientError(
651             error_content, "create_resource"
652         )
653         result = {}
654         with TempSwaggerFile() as swagger_file:
655             result = self.salt_states["boto_apigateway.present"](
656                 "api present",
657                 "unit test api",
658                 swagger_file,
659                 "test",
660                 False,
661                 "arn:aws:iam::1234:role/apigatewayrole",
662                 **conn_parameters
663             )
664         self.assertIs(result.get("abort"), True)
665         self.assertIs(result.get("result"), False)
666         self.assertIn("create_resource", result.get("comment", ""))
667     @pytest.mark.slow_test
668     def test_present_when_stage_associating_to_new_deployment_errored_on_put_method(
669         self,
670     ):
671         self.conn.get_rest_apis.return_value = no_apis_ret
672         self.conn.create_rest_api.return_value = api_ret
673         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
674         self.conn.create_model.return_value = mock_model_ret
675         self.conn.get_resources.return_value = resources_ret
676         self.conn.create_resource.side_effect = ClientError(
677             error_content, "create_resource"
678         )
679         self.conn.put_method.side_effect = ClientError(error_content, "put_method")
680         result = {}
681         with patch.dict(
682             self.funcs,
683             {
684                 "boto_lambda.describe_function": MagicMock(
685                     return_value={"function": function_ret}
686                 )
687             },
688         ):
689             with TempSwaggerFile() as swagger_file:
690                 result = self.salt_states["boto_apigateway.present"](
691                     "api present",
692                     "unit test api",
693                     swagger_file,
694                     "test",
695                     False,
696                     "arn:aws:iam::1234:role/apigatewayrole",
697                     **conn_parameters
698                 )
699         self.assertIs(result.get("abort"), True)
700         self.assertIs(result.get("result"), False)
701         self.assertIn("put_method", result.get("comment", ""))
702     @pytest.mark.slow_test
703     def test_present_when_stage_associating_to_new_deployment_errored_on_lambda_function_lookup(
704         self,
705     ):
706         self.conn.get_rest_apis.return_value = no_apis_ret
707         self.conn.create_rest_api.return_value = api_ret
708         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
709         self.conn.create_model.return_value = mock_model_ret
710         self.conn.get_resources.return_value = resources_ret
711         self.conn.create_resource.side_effect = ClientError(
712             error_content, "create_resource"
713         )
714         self.conn.put_method.return_value = method_ret
715         self.conn.put_integration.side_effect = ClientError(
716             error_content, "put_integration should not be invoked"
717         )
718         result = {}
719         with patch.dict(
720             self.funcs,
721             {
722                 "boto_lambda.describe_function": MagicMock(
723                     return_value={"error": "no such lambda"}
724                 )
725             },
726         ):
727             with TempSwaggerFile() as swagger_file:
728                 result = self.salt_states["boto_apigateway.present"](
729                     "api present",
730                     "unit test api",
731                     swagger_file,
732                     "test",
733                     False,
734                     "arn:aws:iam::1234:role/apigatewayrole",
735                     **conn_parameters
736                 )
737         self.assertIs(result.get("result"), False)
738         self.assertNotIn(
739             "put_integration should not be invoked", result.get("comment", "")
740         )
741         self.assertIn("not find lambda function", result.get("comment", ""))
742     @pytest.mark.slow_test
743     def test_present_when_stage_associating_to_new_deployment_errored_on_put_integration(
744         self,
745     ):
746         self.conn.get_rest_apis.return_value = no_apis_ret
747         self.conn.create_rest_api.return_value = api_ret
748         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
749         self.conn.create_model.return_value = mock_model_ret
750         self.conn.get_resources.return_value = resources_ret
751         self.conn.create_resource.side_effect = ClientError(
752             error_content, "create_resource"
753         )
754         self.conn.put_method.return_value = method_ret
755         self.conn.put_integration.side_effect = ClientError(
756             error_content, "put_integration"
757         )
758         result = {}
759         with patch.dict(
760             self.funcs,
761             {
762                 "boto_lambda.describe_function": MagicMock(
763                     return_value={"function": function_ret}
764                 )
765             },
766         ):
767             with TempSwaggerFile() as swagger_file:
768                 result = self.salt_states["boto_apigateway.present"](
769                     "api present",
770                     "unit test api",
771                     swagger_file,
772                     "test",
773                     False,
774                     "arn:aws:iam::1234:role/apigatewayrole",
775                     **conn_parameters
776                 )
777         self.assertIs(result.get("abort"), True)
778         self.assertIs(result.get("result"), False)
779         self.assertIn("put_integration", result.get("comment", ""))
780     @pytest.mark.slow_test
781     def test_present_when_stage_associating_to_new_deployment_errored_on_put_method_response(
782         self,
783     ):
784         self.conn.get_rest_apis.return_value = no_apis_ret
785         self.conn.create_rest_api.return_value = api_ret
786         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
787         self.conn.create_model.return_value = mock_model_ret
788         self.conn.get_resources.return_value = resources_ret
789         self.conn.create_resource.side_effect = ClientError(
790             error_content, "create_resource"
791         )
792         self.conn.put_method.return_value = method_ret
793         self.conn.put_integration.return_value = method_integration_ret
794         self.conn.put_method_response.side_effect = ClientError(
795             error_content, "put_method_response"
796         )
797         result = {}
798         with patch.dict(
799             self.funcs,
800             {
801                 "boto_lambda.describe_function": MagicMock(
802                     return_value={"function": function_ret}
803                 )
804             },
805         ):
806             with TempSwaggerFile() as swagger_file:
807                 result = self.salt_states["boto_apigateway.present"](
808                     "api present",
809                     "unit test api",
810                     swagger_file,
811                     "test",
812                     False,
813                     "arn:aws:iam::1234:role/apigatewayrole",
814                     **conn_parameters
815                 )
816         self.assertIs(result.get("abort"), True)
817         self.assertIs(result.get("result"), False)
818         self.assertIn("put_method_response", result.get("comment", ""))
819     @pytest.mark.slow_test
820     def test_present_when_stage_associating_to_new_deployment_errored_on_put_integration_response(
821         self,
822     ):
823         self.conn.get_rest_apis.return_value = no_apis_ret
824         self.conn.create_rest_api.return_value = api_ret
825         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
826         self.conn.create_model.return_value = mock_model_ret
827         self.conn.get_resources.return_value = resources_ret
828         self.conn.create_resource.side_effect = ClientError(
829             error_content, "create_resource"
830         )
831         self.conn.put_method.return_value = method_ret
832         self.conn.put_integration.return_value = method_integration_ret
833         self.conn.put_method_response.return_value = method_response_200_ret
834         self.conn.put_integration_response.side_effect = ClientError(
835             error_content, "put_integration_response"
836         )
837         result = {}
838         with patch.dict(
839             self.funcs,
840             {
841                 "boto_lambda.describe_function": MagicMock(
842                     return_value={"function": function_ret}
843                 )
844             },
845         ):
846             with TempSwaggerFile() as swagger_file:
847                 result = self.salt_states["boto_apigateway.present"](
848                     "api present",
849                     "unit test api",
850                     swagger_file,
851                     "test",
852                     False,
853                     "arn:aws:iam::1234:role/apigatewayrole",
854                     **conn_parameters
855                 )
856         self.assertIs(result.get("abort"), True)
857         self.assertIs(result.get("result"), False)
858         self.assertIn("put_integration_response", result.get("comment", ""))
859     def test_absent_when_rest_api_does_not_exist(self):
860         self.conn.get_rest_apis.return_value = apis_ret
861         self.conn.get_stage.side_effect = ClientError(
862             error_content, "get_stage should not be called"
863         )
864         result = self.salt_states["boto_apigateway.absent"](
865             "api present",
866             "no_such_rest_api",
867             "no_such_stage",
868             nuke_api=False,
869             **conn_parameters
870         )
871         self.assertIs(result.get("result"), True)
872         self.assertNotIn("get_stage should not be called", result.get("comment", ""))
873         self.assertEqual(result.get("changes"), {})
874     def test_absent_when_stage_is_invalid(self):
875         self.conn.get_rest_apis.return_value = apis_ret
876         self.conn.get_stage.return_value = stage1_deployment1_ret
877         self.conn.delete_stage.side_effect = ClientError(error_content, "delete_stage")
878         result = self.salt_states["boto_apigateway.absent"](
879             "api present",
880             "unit test api",
881             "no_such_stage",
882             nuke_api=False,
883             **conn_parameters
884         )
885         self.assertTrue(result.get("abort", False))
886     def test_absent_when_stage_is_valid_and_only_one_stage_is_associated_to_deployment(
887         self,
888     ):
889         self.conn.get_rest_apis.return_value = apis_ret
890         self.conn.get_stage.return_value = stage1_deployment1_ret
891         self.conn.delete_stage.return_value = {
892             "ResponseMetadata": {
893                 "HTTPStatusCode": 200,
894                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
895             }
896         }
897         self.conn.get_stages.return_value = no_stages_ret
898         self.conn.delete_deployment.return_value = {
899             "ResponseMetadata": {
900                 "HTTPStatusCode": 200,
901                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
902             }
903         }
904         result = self.salt_states["boto_apigateway.absent"](
905             "api present", "unit test api", "test", nuke_api=False, **conn_parameters
906         )
907         self.assertTrue(result.get("result", False))
908     def test_absent_when_stage_is_valid_and_two_stages_are_associated_to_deployment(
909         self,
910     ):
911         self.conn.get_rest_apis.return_value = apis_ret
912         self.conn.get_stage.return_value = stage1_deployment1_ret
913         self.conn.delete_stage.return_value = {
914             "ResponseMetadata": {
915                 "HTTPStatusCode": 200,
916                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
917             }
918         }
919         self.conn.get_stages.return_value = stages_stage2_ret
920         result = self.salt_states["boto_apigateway.absent"](
921             "api present", "unit test api", "test", nuke_api=False, **conn_parameters
922         )
923         self.assertTrue(result.get("result", False))
924     def test_absent_when_failing_to_delete_a_deployment_no_longer_associated_with_any_stages(
925         self,
926     ):
927         self.conn.get_rest_apis.return_value = apis_ret
928         self.conn.get_stage.return_value = stage1_deployment1_ret
929         self.conn.delete_stage.return_value = {
930             "ResponseMetadata": {
931                 "HTTPStatusCode": 200,
932                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
933             }
934         }
935         self.conn.get_stages.return_value = no_stages_ret
936         self.conn.delete_deployment.side_effect = ClientError(
937             error_content, "delete_deployment"
938         )
939         result = self.salt_states["boto_apigateway.absent"](
940             "api present", "unit test api", "test", nuke_api=False, **conn_parameters
941         )
942         self.assertTrue(result.get("abort", False))
943     def test_absent_when_nuke_api_and_no_more_stages_deployments_remain(self):
944         self.conn.get_rest_apis.return_value = apis_ret
945         self.conn.get_stage.return_value = stage1_deployment1_ret
946         self.conn.delete_stage.return_value = {
947             "ResponseMetadata": {
948                 "HTTPStatusCode": 200,
949                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
950             }
951         }
952         self.conn.get_stages.return_value = no_stages_ret
953         self.conn.get_deployments.return_value = deployments_ret
954         self.conn.delete_rest_api.return_value = {
955             "ResponseMetadata": {
956                 "HTTPStatusCode": 200,
957                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
958             }
959         }
960         result = self.salt_states["boto_apigateway.absent"](
961             "api present", "unit test api", "test", nuke_api=True, **conn_parameters
962         )
963         self.assertIs(result.get("result"), True)
964         self.assertIsNot(result.get("abort"), True)
965         self.assertIs(
966             result.get("changes", {})
967             .get("new", [{}])[0]
968             .get("delete_api", {})
969             .get("deleted"),
970             True,
971         )
972     def test_absent_when_nuke_api_and_other_stages_deployments_exist(self):
973         self.conn.get_rest_apis.return_value = apis_ret
974         self.conn.get_stage.return_value = stage1_deployment1_ret
975         self.conn.delete_stage.return_value = {
976             "ResponseMetadata": {
977                 "HTTPStatusCode": 200,
978                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
979             }
980         }
981         self.conn.get_stages.return_value = stages_stage2_ret
982         self.conn.get_deployments.return_value = deployments_ret
983         self.conn.delete_rest_api.side_effect = ClientError(
984             error_content, "unexpected_api_delete"
985         )
986         result = self.salt_states["boto_apigateway.absent"](
987             "api present", "unit test api", "test", nuke_api=True, **conn_parameters
988         )
989         self.assertIs(result.get("result"), True)
990         self.assertIsNot(result.get("abort"), True)
991 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
992 @skipIf(
993     _has_required_boto() is False,
994     "The boto3 module must be greater than or equal to version {}".format(
995         required_boto3_version
996     ),
997 )
998 @skipIf(
999     _has_required_botocore() is False,
1000     "The botocore module must be greater than or equal to version {}".format(
1001         required_botocore_version
1002     ),
1003 )
1004 class BotoApiGatewayUsagePlanTestCase(
1005     BotoApiGatewayStateTestCaseBase, BotoApiGatewayTestCaseMixin
1006 ):
1007     @pytest.mark.slow_test
1008     def test_usage_plan_present_if_describe_fails(self, *args):
1009         with patch.dict(
1010             boto_apigateway.__salt__,
1011             {
1012                 "boto_apigateway.describe_usage_plans": MagicMock(
1013                     return_value={"error": "error"}
1014                 )
1015             },
1016         ):
1017             result = boto_apigateway.usage_plan_present(
1018                 "name", "plan_name", **conn_parameters
1019             )
1020             self.assertIn("result", result)
1021             self.assertEqual(result["result"], False)
1022             self.assertIn("comment", result)
1023             self.assertEqual(
1024                 result["comment"], "Failed to describe existing usage plans"
1025             )
1026             self.assertIn("changes", result)
1027             self.assertEqual(result["changes"], {})
1028     @pytest.mark.slow_test
1029     def test_usage_plan_present_if_there_is_no_such_plan_and_test_option_is_set(
1030         self, *args
1031     ):
1032         with patch.dict(boto_apigateway.__opts__, {"test": True}):
1033             with patch.dict(
1034                 boto_apigateway.__salt__,
1035                 {
1036                     "boto_apigateway.describe_usage_plans": MagicMock(
1037                         return_value={"plans": []}
1038                     )
1039                 },
1040             ):
1041                 result = boto_apigateway.usage_plan_present(
1042                     "name", "plan_name", **conn_parameters
1043                 )
1044                 self.assertIn("comment", result)
1045                 self.assertEqual(
1046                     result["comment"], "a new usage plan plan_name would be created"
1047                 )
1048                 self.assertIn("result", result)
1049                 self.assertEqual(result["result"], None)
1050     @pytest.mark.slow_test
1051     def test_usage_plan_present_if_create_usage_plan_fails(self, *args):
1052         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1053             with patch.dict(
1054                 boto_apigateway.__salt__,
1055                 {
1056                     "boto_apigateway.describe_usage_plans": MagicMock(
1057                         return_value={"plans": []}
1058                     ),
1059                     "boto_apigateway.create_usage_plan": MagicMock(
1060                         return_value={"error": "error"}
1061                     ),
1062                 },
1063             ):
1064                 result = boto_apigateway.usage_plan_present(
1065                     "name", "plan_name", **conn_parameters
1066                 )
1067                 self.assertIn("result", result)
1068                 self.assertEqual(result["result"], False)
1069                 self.assertIn("comment", result)
1070                 self.assertEqual(
1071                     result["comment"], "Failed to create a usage plan plan_name, error"
1072                 )
1073                 self.assertIn("changes", result)
1074                 self.assertEqual(result["changes"], {})
1075     @pytest.mark.slow_test
1076     def test_usage_plan_present_if_plan_is_there_and_needs_no_updates(self, *args):
1077         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1078             with patch.dict(
1079                 boto_apigateway.__salt__,
1080                 {
1081                     "boto_apigateway.describe_usage_plans": MagicMock(
1082                         return_value={"plans": [{"id": "planid", "name": "planname"}]}
1083                     ),
1084                     "boto_apigateway.update_usage_plan": MagicMock(),
1085                 },
1086             ):
1087                 result = boto_apigateway.usage_plan_present(
1088                     "name", "plan_name", **conn_parameters
1089                 )
1090                 self.assertIn("result", result)
1091                 self.assertEqual(result["result"], True)
1092                 self.assertIn("comment", result)
1093                 self.assertEqual(
1094                     result["comment"],
1095                     "usage plan plan_name is already in a correct state",
1096                 )
1097                 self.assertIn("changes", result)
1098                 self.assertEqual(result["changes"], {})
1099                 self.assertTrue(
1100                     boto_apigateway.__salt__[
1101                         "boto_apigateway.update_usage_plan"
1102                     ].call_count
1103                     == 0
1104                 )
1105     @pytest.mark.slow_test
1106     def test_usage_plan_present_if_plan_is_there_and_needs_updates_but_test_is_set(
1107         self, *args
1108     ):
1109         with patch.dict(boto_apigateway.__opts__, {"test": True}):
1110             with patch.dict(
1111                 boto_apigateway.__salt__,
1112                 {
1113                     "boto_apigateway.describe_usage_plans": MagicMock(
1114                         return_value={
1115                             "plans": [
1116                                 {
1117                                     "id": "planid",
1118                                     "name": "planname",
1119                                     "throttle": {"rateLimit": 10.0},
1120                                 }
1121                             ]
1122                         }
1123                     ),
1124                     "boto_apigateway.update_usage_plan": MagicMock(),
1125                 },
1126             ):
1127                 result = boto_apigateway.usage_plan_present(
1128                     "name", "plan_name", **conn_parameters
1129                 )
1130                 self.assertIn("comment", result)
1131                 self.assertEqual(
1132                     result["comment"], "a new usage plan plan_name would be updated"
1133                 )
1134                 self.assertIn("result", result)
1135                 self.assertEqual(result["result"], None)
1136                 self.assertTrue(
1137                     boto_apigateway.__salt__[
1138                         "boto_apigateway.update_usage_plan"
1139                     ].call_count
1140                     == 0
1141                 )
1142     @pytest.mark.slow_test
1143     def test_usage_plan_present_if_plan_is_there_and_needs_updates_but_update_fails(
1144         self, *args
1145     ):
1146         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1147             with patch.dict(
1148                 boto_apigateway.__salt__,
1149                 {
1150                     "boto_apigateway.describe_usage_plans": MagicMock(
1151                         return_value={
1152                             "plans": [
1153                                 {
1154                                     "id": "planid",
1155                                     "name": "planname",
1156                                     "throttle": {"rateLimit": 10.0},
1157                                 }
1158                             ]
1159                         }
1160                     ),
1161                     "boto_apigateway.update_usage_plan": MagicMock(
1162                         return_value={"error": "error"}
1163                     ),
1164                 },
1165             ):
1166                 result = boto_apigateway.usage_plan_present(
1167                     "name", "plan_name", **conn_parameters
1168                 )
1169                 self.assertIn("result", result)
1170                 self.assertEqual(result["result"], False)
1171                 self.assertIn("comment", result)
1172                 self.assertEqual(
1173                     result["comment"], "Failed to update a usage plan plan_name, error"
1174                 )
1175     @pytest.mark.slow_test
1176     def test_usage_plan_present_if_plan_has_been_created(self, *args):
1177         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1178             with patch.dict(
1179                 boto_apigateway.__salt__,
1180                 {
1181                     "boto_apigateway.describe_usage_plans": MagicMock(
1182                         side_effect=[{"plans": []}, {"plans": [{"id": "id"}]}]
1183                     ),
1184                     "boto_apigateway.create_usage_plan": MagicMock(
1185                         return_value={"created": True}
1186                     ),
1187                 },
1188             ):
1189                 result = boto_apigateway.usage_plan_present(
1190                     "name", "plan_name", **conn_parameters
1191                 )
1192                 self.assertEqual(result["result"], True)
1193                 self.assertIn("comment", result)
1194                 self<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertEqual(
1195                     result["comment"], "A new usage plan plan_name has been created"
1196                 )
1197                 self.assertEqual(result["changes"]["old"], {"plan": None})
1198                 self.assertEqual(result["changes"]["new"], {"plan": {"id"</b></font>: "id"}})
1199     @pytest.mark.slow_test
1200     def test_usage_plan_present_if_plan_has_been_updated(self, *args):
1201         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1202             with patch<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.dict(
1203                 boto_apigateway.__salt__,
1204                 {
1205                     "boto_apigateway.describe_usage_plans": MagicMock(
1206                         side_effect=[
1207                             {"plans": [{"id": "id"}]},
1208                             {
1209                                 "plans": [
1210                                     {
1211                                         "id": "id",
1212                                         "throttle": {"rateLimit": throttle_rateLimit},
1213                                     }
1214                                 ]
1215                             },
1216                         ]
1217                     ),
1218                     "boto_apigateway.update_usage_plan": MagicMock(</b></font>
1219                         return_value={"updated": True}
1220                     ),
1221                 },
1222             ):
1223                 result = boto_apigateway.usage_plan_present(
1224                     "name",
1225                     "plan_name",
1226                     throttle={"rateLimit": throttle_rateLimit},
1227                     **conn_parameters
1228                 )
1229                 self.assertEqual(result["result"], True)
1230                 self.assertIn("comment", result)
1231                 self<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertEqual(
1232                     result["comment"], "usage plan plan_name has been updated"
1233                 )
1234                 self.assertEqual(result["changes"]["old"], {"plan": {"id": "id"}})
1235                 self.assertEqual(
1236                     result["changes"]["new"],
1237                     {
1238                         "plan": {
1239                             "id": "id",
1240                             "throttle": {"rateLimit"</b></font>: throttle_rateLimit},
1241                         }
1242                     },
1243                 )
1244     @pytest.mark.slow_test
1245     def test_usage_plan_present_if_ValueError_is_raised(self, *args):
1246         with patch.dict(
1247             boto_apigateway.__salt__,
1248             {
1249                 "boto_apigateway.describe_usage_plans": MagicMock(
1250                     side_effect=ValueError("error")
1251                 )
1252             },
1253         ):
1254             result = boto_apigateway.usage_plan_present(
1255                 "name",
1256                 "plan_name",
1257                 throttle={"rateLimit": throttle_rateLimit},
1258                 **conn_parameters
1259             )
1260             self.assertIn("result", result)
1261             self.assertEqual(result["result"], False)
1262             self.assertIn("comment", result)
1263             self.assertEqual(result["comment"], repr(("error",)))
1264     @pytest.mark.slow_test
1265     def test_usage_plan_present_if_IOError_is_raised(self, *args):
1266         with patch.dict(
1267             boto_apigateway.__salt__,
1268             {
1269                 "boto_apigateway.describe_usage_plans": MagicMock(
1270                     side_effect=IOError("error")
1271                 )
1272             },
1273         ):
1274             result = boto_apigateway.usage_plan_present(
1275                 "name",
1276                 "plan_name",
1277                 throttle={"rateLimit": throttle_rateLimit},
1278                 **conn_parameters
1279             )
1280             self.assertIn("result", result)
1281             self.assertEqual(result["result"], False)
1282             self.assertIn("comment", result)
1283             self.assertEqual(result["comment"], repr(("error",)))
1284     @pytest.mark.slow_test
1285     def test_usage_plan_absent_if_describe_fails(self, *args):
1286         with patch.dict(
1287             boto_apigateway.__salt__,
1288             {
1289                 "boto_apigateway.describe_usage_plans": MagicMock(
1290                     return_value={"error": "error"}
1291                 )
1292             },
1293         ):
1294             result = {}
1295             result = boto_apigateway.usage_plan_absent(
1296                 "name", "plan_name", **conn_parameters
1297             )
1298             self.assertIn("result", result)
1299             self.assertEqual(result["result"], False)
1300             self.assertIn("comment", result)
1301             self.assertEqual(
1302                 result["comment"], "Failed to describe existing usage plans"
1303             )
1304             self.assertIn("changes", result)
1305             self.assertEqual(result["changes"], {})
1306     @pytest.mark.slow_test
1307     def test_usage_plan_absent_if_plan_is_not_present(self, *args):
1308         with patch.dict(
1309             boto_apigateway.__salt__,
1310             {
1311                 "boto_apigateway.describe_usage_plans": MagicMock(
1312                     return_value={"plans": []}
1313                 )
1314             },
1315         ):
1316             result = {}
1317             result = boto_apigateway.usage_plan_absent(
1318                 "name", "plan_name", **conn_parameters
1319             )
1320             self.assertIn("result", result)
1321             self.assertEqual(result["result"], True)
1322             self.assertIn("comment", result)
1323             self.assertEqual(
1324                 result["comment"], "Usage plan plan_name does not exist already"
1325             )
1326             self.assertIn("changes", result)
1327             self.assertEqual(result["changes"], {})
1328     @pytest.mark.slow_test
1329     def test_usage_plan_absent_if_plan_is_present_but_test_option_is_set(self, *args):
1330         with patch.dict(boto_apigateway.__opts__, {"test": True}):
1331             with patch.dict(
1332                 boto_apigateway.__salt__,
1333                 {
1334                     "boto_apigateway.describe_usage_plans": MagicMock(
1335                         return_value={"plans": [{"id": "id"}]}
1336                     )
1337                 },
1338             ):
1339                 result = {}
1340                 result = boto_apigateway.usage_plan_absent(
1341                     "name", "plan_name", **conn_parameters
1342                 )
1343                 self.assertIn("result", result)
1344                 self.assertEqual(result["result"], None)
1345                 self.assertIn("comment", result)
1346                 self.assertEqual(
1347                     result["comment"],
1348                     "Usage plan plan_name exists and would be deleted",
1349                 )
1350                 self.assertIn("changes", result)
1351                 self.assertEqual(result["changes"], {})
1352     @pytest.mark.slow_test
1353     def test_usage_plan_absent_if_plan_is_present_but_delete_fails(self, *args):
1354         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1355             with patch.dict(
1356                 boto_apigateway.__salt__,
1357                 {
1358                     "boto_apigateway.describe_usage_plans": MagicMock(
1359                         return_value={"plans": [{"id": "id"}]}
1360                     ),
1361                     "boto_apigateway.delete_usage_plan": MagicMock(
1362                         return_value={"error": "error"}
1363                     ),
1364                 },
1365             ):
1366                 result = boto_apigateway.usage_plan_absent(
1367                     "name", "plan_name", **conn_parameters
1368                 )
1369                 self.assertIn("result", result)
1370                 self.assertEqual(result["result"], False)
1371                 self.assertIn("comment", result)
1372                 self.assertEqual(
1373                     result["comment"],
1374                     "Failed to delete usage plan plan_name, "
1375                     + repr({"error": "error"}),
1376                 )
1377                 self.assertIn("changes", result)
1378                 self.assertEqual(result["changes"], {})
1379     @pytest.mark.slow_test
1380     def test_usage_plan_absent_if_plan_has_been_deleted(self, *args):
1381         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1382             with patch.dict(
1383                 boto_apigateway.__salt__,
1384                 {
1385                     "boto_apigateway.describe_usage_plans": MagicMock(
1386                         return_value={"plans": [{"id": "id"}]}
1387                     ),
1388                     "boto_apigateway.delete_usage_plan": MagicMock(
1389                         return_value={"deleted": True}
1390                     ),
1391                 },
1392             ):
1393                 result = boto_apigateway.usage_plan_absent(
1394                     "name", "plan_name", **conn_parameters
1395                 )
1396                 self.assertIn("result", result)
1397                 self.assertEqual(result["result"], True)
1398                 self.assertIn("comment", result)
1399                 self.assertEqual(
1400                     result["comment"], "Usage plan plan_name has been deleted"
1401                 )
1402                 self.assertIn("changes", result)
1403                 self.assertEqual(
1404                     result["changes"],
1405                     {"new": {"plan": None}, "old": {"plan": {"id": "id"}}},
1406                 )
1407     @pytest.mark.slow_test
1408     def test_usage_plan_absent_if_ValueError_is_raised(self, *args):
1409         with patch.dict(
1410             boto_apigateway.__salt__,
1411             {
1412                 "boto_apigateway.describe_usage_plans": MagicMock(
1413                     side_effect=ValueError("error")
1414                 )
1415             },
1416         ):
1417             result = boto_apigateway.usage_plan_absent(
1418                 "name", "plan_name", **conn_parameters
1419             )
1420             self.assertIn("result", result)
1421             self.assertEqual(result["result"], False)
1422             self.assertIn("comment", result)
1423             self.assertEqual(result["comment"], repr(("error",)))
1424     @pytest.mark.slow_test
1425     def test_usage_plan_absent_if_IOError_is_raised(self, *args):
1426         with patch.dict(
1427             boto_apigateway.__salt__,
1428             {
1429                 "boto_apigateway.describe_usage_plans": MagicMock(
1430                     side_effect=IOError("error")
1431                 )
1432             },
1433         ):
1434             result = boto_apigateway.usage_plan_absent(
1435                 "name", "plan_name", **conn_parameters
1436             )
1437             self.assertIn("result", result)
1438             self.assertEqual(result["result"], False)
1439             self.assertIn("comment", result)
1440             self.assertEqual(result["comment"], repr(("error",)))
1441 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
1442 @skipIf(
1443     _has_required_boto() is False,
1444     "The boto3 module must be greater than or equal to version {}".format(
1445         required_boto3_version
1446     ),
1447 )
1448 @skipIf(
1449     _has_required_botocore() is False,
1450     "The botocore module must be greater than or equal to version {}".format(
1451         required_botocore_version
1452     ),
1453 )
1454 class BotoApiGatewayUsagePlanAssociationTestCase(
1455     BotoApiGatewayStateTestCaseBase, BotoApiGatewayTestCaseMixin
1456 ):
1457     @pytest.mark.slow_test
1458     def test_usage_plan_association_present_if_describe_fails(self, *args):
1459         with patch.dict(
1460             boto_apigateway.__salt__,
1461             {
1462                 "boto_apigateway.describe_usage_plans": MagicMock(
1463                     return_value={"error": "error"}
1464                 )
1465             },
1466         ):
1467             result = boto_apigateway.usage_plan_association_present(
1468                 "name", "plan_name", [association_stage_1], **conn_parameters
1469             )
1470             self.assertIn("result", result)
1471             self.assertEqual(result["result"], False)
1472             self.assertIn("comment", result)
1473             self.assertEqual(
1474                 result["comment"], "Failed to describe existing usage plans"
1475             )
1476             self.assertIn("changes", result)
1477             self.assertEqual(result["changes"], {})
1478     @pytest.mark.slow_test
1479     def test_usage_plan_association_present_if_plan_is_not_present(self, *args):
1480         with patch.dict(
1481             boto_apigateway.__salt__,
1482             {
1483                 "boto_apigateway.describe_usage_plans": MagicMock(
1484                     return_value={"plans": []}
1485                 )
1486             },
1487         ):
1488             result = boto_apigateway.usage_plan_association_present(
1489                 "name", "plan_name", [association_stage_1], **conn_parameters
1490             )
1491             self.assertIn("result", result)
1492             self.assertEqual(result["result"], False)
1493             self.assertIn("comment", result)
1494             self.assertEqual(result["comment"], "Usage plan plan_name does not exist")
1495             self.assertIn("changes", result)
1496             self.assertEqual(result["changes"], {})
1497     @pytest.mark.slow_test
1498     def test_usage_plan_association_present_if_multiple_plans_with_the_same_name_exist(
1499         self, *args
1500     ):
1501         with patch.dict(
1502             boto_apigateway.__salt__,
1503             {
1504                 "boto_apigateway.describe_usage_plans": MagicMock(
1505                     return_value={"plans": [{"id": "id1"}, {"id": "id2"}]}
1506                 )
1507             },
1508         ):
1509             result = boto_apigateway.usage_plan_association_present(
1510                 "name", "plan_name", [association_stage_1], **conn_parameters
1511             )
1512             self.assertIn("result", result)
1513             self.assertEqual(result["result"], False)
1514             self.assertIn("comment", result)
1515             self.assertEqual(
1516                 result["comment"],
1517                 "There are multiple usage plans with the same name - it is not"
1518                 " supported",
1519             )
1520             self.assertIn("changes", result)
1521             self.assertEqual(result["changes"], {})
1522     @pytest.mark.slow_test
1523     def test_usage_plan_association_present_if_association_already_exists(self, *args):
1524         with patch.dict(
1525             boto_apigateway.__salt__,
1526             {
1527                 "boto_apigateway.describe_usage_plans": MagicMock(
1528                     return_value={
1529                         "plans": [{"id": "id1", "apiStages": [association_stage_1]}]
1530                     }
1531                 )
1532             },
1533         ):
1534             result = boto_apigateway.usage_plan_association_present(
1535                 "name", "plan_name", [association_stage_1], **conn_parameters
1536             )
1537             self.assertIn("result", result)
1538             self.assertEqual(result["result"], True)
1539             self.assertIn("comment", result)
1540             self.assertEqual(
1541                 result["comment"], "Usage plan is already asssociated to all api stages"
1542             )
1543             self.assertIn("changes", result)
1544             self.assertEqual(result["changes"], {})
1545     @pytest.mark.slow_test
1546     def test_usage_plan_association_present_if_update_fails(self, *args):
1547         with patch.dict(
1548             boto_apigateway.__salt__,
1549             {
1550                 "boto_apigateway.describe_usage_plans": MagicMock(
1551                     return_value={
1552                         "plans": [{"id": "id1", "apiStages": [association_stage_1]}]
1553                     }
1554                 ),
1555                 "boto_apigateway.attach_usage_plan_to_apis": MagicMock(
1556                     return_value={"error": "error"}
1557                 ),
1558             },
1559         ):
1560             result = boto_apigateway.usage_plan_association_present(
1561                 "name", "plan_name", [association_stage_2], **conn_parameters
1562             )
1563             self.assertIn("result", result)
1564             self.assertEqual(result["result"], False)
1565             self.assertIn("comment", result)
1566             self.assertTrue(
1567                 result["comment"].startswith("Failed to associate a usage plan")
1568             )
1569             self.assertIn("changes", result)
1570             self.assertEqual(result["changes"], {})
1571     @pytest.mark.slow_test
1572     def test_usage_plan_association_present_success(self, *args):
1573         with patch.dict(
1574             boto_apigateway.__salt__,
1575             {
1576                 "boto_apigateway.describe_usage_plans": MagicMock(
1577                     return_value={
1578                         "plans": [{"id": "id1", "apiStages": [association_stage_1]}]
1579                     }
1580                 ),
1581                 "boto_apigateway.attach_usage_plan_to_apis": MagicMock(
1582                     return_value={
1583                         "result": {
1584                             "apiStages": [association_stage_1, association_stage_2]
1585                         }
1586                     }
1587                 ),
1588             },
1589         ):
1590             result = boto_apigateway.usage_plan_association_present(
1591                 "name", "plan_name", [association_stage_2], **conn_parameters
1592             )
1593             self.assertIn("result", result)
1594             self.assertEqual(result["result"], True)
1595             self.assertIn("comment", result)
1596             self.assertEqual(
1597                 result["comment"], "successfully associated usage plan to apis"
1598             )
1599             self.assertIn("changes", result)
1600             self.assertEqual(
1601                 result["changes"],
1602                 {
1603                     "new": [association_stage_1, association_stage_2],
1604                     "old": [association_stage_1],
1605                 },
1606             )
1607     @pytest.mark.slow_test
1608     def test_usage_plan_association_present_if_value_error_is_thrown(self, *args):
1609         with patch.dict(
1610             boto_apigateway.__salt__,
1611             {
1612                 "boto_apigateway.describe_usage_plans": MagicMock(
1613                     side_effect=ValueError("error")
1614                 )
1615             },
1616         ):
1617             result = boto_apigateway.usage_plan_association_present(
1618                 "name", "plan_name", [], **conn_parameters
1619             )
1620             self.assertIn("result", result)
1621             self.assertEqual(result["result"], False)
1622             self.assertIn("comment", result)
1623             self.assertEqual(result["comment"], repr(("error",)))
1624             self.assertIn("changes", result)
1625             self.assertEqual(result["changes"], {})
1626     @pytest.mark.slow_test
1627     def test_usage_plan_association_present_if_io_error_is_thrown(self, *args):
1628         with patch.dict(
1629             boto_apigateway.__salt__,
1630             {
1631                 "boto_apigateway.describe_usage_plans": MagicMock(
1632                     side_effect=IOError("error")
1633                 )
1634             },
1635         ):
1636             result = boto_apigateway.usage_plan_association_present(
1637                 "name", "plan_name", [], **conn_parameters
1638             )
1639             self.assertIn("result", result)
1640             self.assertEqual(result["result"], False)
1641             self.assertIn("comment", result)
1642             self.assertEqual(result["comment"], repr(("error",)))
1643             self.assertIn("changes", result)
1644             self.assertEqual(result["changes"], {})
1645     @pytest.mark.slow_test
1646     def test_usage_plan_association_absent_if_describe_fails(self, *args):
1647         with patch.dict(
1648             boto_apigateway.__salt__,
1649             {
1650                 "boto_apigateway.describe_usage_plans": MagicMock(
1651                     return_value={"error": "error"}
1652                 )
1653             },
1654         ):
1655             result = boto_apigateway.usage_plan_association_absent(
1656                 "name", "plan_name", [association_stage_1], **conn_parameters
1657             )
1658             self.assertIn("result", result)
1659             self.assertEqual(result["result"], False)
1660             self.assertIn("comment", result)
1661             self.assertEqual(
1662                 result["comment"], "Failed to describe existing usage plans"
1663             )
1664             self.assertIn("changes", result)
1665             self.assertEqual(result["changes"], {})
1666     @pytest.mark.slow_test
1667     def test_usage_plan_association_absent_if_plan_is_not_present(self, *args):
1668         with patch.dict(
1669             boto_apigateway.__salt__,
1670             {
1671                 "boto_apigateway.describe_usage_plans": MagicMock(
1672                     return_value={"plans": []}
1673                 )
1674             },
1675         ):
1676             result = boto_apigateway.usage_plan_association_absent(
1677                 "name", "plan_name", [association_stage_1], **conn_parameters
1678             )
1679             self.assertIn("result", result)
1680             self.assertEqual(result["result"], False)
1681             self.assertIn("comment", result)
1682             self.assertEqual(result["comment"], "Usage plan plan_name does not exist")
1683             self.assertIn("changes", result)
1684             self.assertEqual(result["changes"], {})
1685     @pytest.mark.slow_test
1686     def test_usage_plan_association_absent_if_multiple_plans_with_the_same_name_exist(
1687         self, *args
1688     ):
1689         with patch.dict(
1690             boto_apigateway.__salt__,
1691             {
1692                 "boto_apigateway.describe_usage_plans": MagicMock(
1693                     return_value={"plans": [{"id": "id1"}, {"id": "id2"}]}
1694                 )
1695             },
1696         ):
1697             result = boto_apigateway.usage_plan_association_absent(
1698                 "name", "plan_name", [association_stage_1], **conn_parameters
1699             )
1700             self.assertIn("result", result)
1701             self.assertEqual(result["result"], False)
1702             self.assertIn("comment", result)
1703             self.assertEqual(
1704                 result["comment"],
1705                 "There are multiple usage plans with the same name - it is not"
1706                 " supported",
1707             )
1708             self.assertIn("changes", result)
1709             self.assertEqual(result["changes"], {})
1710     @pytest.mark.slow_test
1711     def test_usage_plan_association_absent_if_plan_has_no_associations(self, *args):
1712         with patch.dict(
1713             boto_apigateway.__salt__,
1714             {
1715                 "boto_apigateway.describe_usage_plans": MagicMock(
1716                     return_value={"plans": [{"id": "id1", "apiStages": []}]}
1717                 )
1718             },
1719         ):
1720             result = boto_apigateway.usage_plan_association_absent(
1721                 "name", "plan_name", [association_stage_1], **conn_parameters
1722             )
1723             self.assertIn("result", result)
1724             self.assertEqual(result["result"], True)
1725             self.assertIn("comment", result)
1726             self.assertEqual(
1727                 result["comment"],
1728                 "Usage plan plan_name has no associated stages already",
1729             )
1730             self.assertIn("changes", result)
1731             self.assertEqual(result["changes"], {})
1732     @pytest.mark.slow_test
1733     def test_usage_plan_association_absent_if_plan_has_no_specific_association(
1734         self, *args
1735     ):
1736         with patch.dict(
1737             boto_apigateway.__salt__,
1738             {
1739                 "boto_apigateway.describe_usage_plans": MagicMock(
1740                     return_value={
1741                         "plans": [{"id": "id1", "apiStages": [association_stage_1]}]
1742                     }
1743                 )
1744             },
1745         ):
1746             result = boto_apigateway.usage_plan_association_absent(
1747                 "name", "plan_name", [association_stage_2], **conn_parameters
1748             )
1749             self.assertIn("result", result)
1750             self.assertEqual(result["result"], True)
1751             self.assertIn("comment", result)
1752             self.assertEqual(
1753                 result["comment"],
1754                 "Usage plan is already not asssociated to any api stages",
1755             )
1756             self.assertIn("changes", result)
1757             self.assertEqual(result["changes"], {})
1758     @pytest.mark.slow_test
1759     def test_usage_plan_association_absent_if_detaching_association_fails(self, *args):
1760         with patch.dict(
1761             boto_apigateway.__salt__,
1762             {
1763                 "boto_apigateway.describe_usage_plans": MagicMock(
1764                     return_value={
1765                         "plans": [
1766                             {
1767                                 "id": "id1",
1768                                 "apiStages": [association_stage_1, association_stage_2],
1769                             }
1770                         ]
1771                     }
1772                 ),
1773                 "boto_apigateway.detach_usage_plan_from_apis": MagicMock(
1774                     return_value={"error": "error"}
1775                 ),
1776             },
1777         ):
1778             result = boto_apigateway.usage_plan_association_absent(
1779                 "name", "plan_name", [association_stage_2], **conn_parameters
1780             )
1781             self.assertIn("result", result)
1782             self.assertEqual(result["result"], False)
1783             self.assertIn("comment", result)
1784             self.assertTrue(
1785                 result["comment"].startswith(
1786                     "Failed to disassociate a usage plan plan_name from the apis"
1787                 )
1788             )
1789             self.assertIn("changes", result)
1790             self.assertEqual(result["changes"], {})
1791     @pytest.mark.slow_test
1792     def test_usage_plan_association_absent_success(self, *args):
1793         with patch.dict(
1794             boto_apigateway.__salt__,
1795             {
1796                 "boto_apigateway.describe_usage_plans": MagicMock(
1797                     return_value={
1798                         "plans": [
1799                             {
1800                                 "id": "id1",
1801                                 "apiStages": [association_stage_1, association_stage_2],
1802                             }
1803                         ]
1804                     }
1805                 ),
1806                 "boto_apigateway.detach_usage_plan_from_apis": MagicMock(
1807                     return_value={"result": {"apiStages": [association_stage_1]}}
1808                 ),
1809             },
1810         ):
1811             result = boto_apigateway.usage_plan_association_absent(
1812                 "name", "plan_name", [association_stage_2], **conn_parameters
1813             )
1814             self.assertIn("result", result)
1815             self.assertEqual(result["result"], True)
1816             self.assertIn("comment", result)
1817             self.assertEqual(
1818                 result["comment"], "successfully disassociated usage plan from apis"
1819             )
1820             self.assertIn("changes", result)
1821             self.assertEqual(
1822                 result["changes"],
1823                 {
1824                     "new": [association_stage_1],
1825                     "old": [association_stage_1, association_stage_2],
1826                 },
1827             )
1828     @pytest.mark.slow_test
1829     def test_usage_plan_association_absent_if_ValueError_is_raised(self, *args):
1830         with patch.dict(
1831             boto_apigateway.__salt__,
1832             {
1833                 "boto_apigateway.describe_usage_plans": MagicMock(
1834                     side_effect=ValueError("error")
1835                 )
1836             },
1837         ):
1838             result = boto_apigateway.usage_plan_association_absent(
1839                 "name", "plan_name", [association_stage_1], **conn_parameters
1840             )
1841             self.assertIn("result", result)
1842             self.assertEqual(result["result"], False)
1843             self.assertIn("comment", result)
1844             self.assertEqual(result["comment"], repr(("error",)))
1845             self.assertIn("changes", result)
1846             self.assertEqual(result["changes"], {})
1847     @pytest.mark.slow_test
1848     def test_usage_plan_association_absent_if_IOError_is_raised(self, *args):
1849         with patch.dict(
1850             boto_apigateway.__salt__,
1851             {
1852                 "boto_apigateway.describe_usage_plans": MagicMock(
1853                     side_effect=IOError("error")
1854                 )
1855             },
1856         ):
1857             result = boto_apigateway.usage_plan_association_absent(
1858                 "name", "plan_name", [association_stage_1], **conn_parameters
1859             )
1860             self.assertIn("result", result)
1861             self.assertEqual(result["result"], False)
1862             self.assertIn("comment", result)
1863             self.assertEqual(result["comment"], repr(("error",)))
1864             self.assertIn("changes", result)
1865             self.assertEqual(result["changes"], {})
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
