<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_grains_1.py &amp; test_boto_apigateway.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_grains_1.py &amp; test_boto_apigateway.py
      </h3>
<h1 align="center">
        2.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_grains_1.py (3.0318344%)<th>test_boto_apigateway.py (2.2744503%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(117-122)<td><a href="#" name="0">(1559-1568)</a><td align="center"><font color="#ff0000">16</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(48-52)<td><a href="#" name="1">(468-478)</a><td align="center"><font color="#ff0000">16</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(148-153)<td><a href="#" name="2">(1516-1520)</a><td align="center"><font color="#df0000">14</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(29-42)<td><a href="#" name="3">(1528-1544)</a><td align="center"><font color="#df0000">14</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_grains_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import contextlib
2 import os
3 import salt.modules.grains as grainsmod
4 import salt.states.grains as grains
5 import salt.utils.files
6 import salt.utils.stringutils
7 import salt.utils.yaml
8 from tests.support.mixins import LoaderModuleMockMixin
9 from tests.support.mock import MagicMock, patch
10 from tests.support.runtests import RUNTIME_VARS
11 from tests.support.unit import TestCase
12 class GrainsTestCase(TestCase, LoaderModuleMockMixin):
13     def setup_loader_modules(self):
14         grains_test_dir = "__salt_test_state_grains"
15         if not os.path.exists(os.path.join(RUNTIME_VARS.TMP, grains_test_dir)):
16             os.makedirs(os.path.join(RUNTIME_VARS.TMP, grains_test_dir))
17         loader_globals = {
18 <a name="3"></a>            "__opts__": {
19                 "test": False,
20                 "conf_file": os.path.join(RUNTIME_VARS.TMP, grains_test_dir, "minion"),
21                 "cachedir": os.path<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.join(RUNTIME_VARS.TMP, grains_test_dir),
22                 "local": True,
23             },
24             "__salt__": {
25                 "cmd.run_all": MagicMock(
26                     return_value={"pid": 5, "retcode": 0, "stderr": "", "stdout": ""}
27                 ),
28                 "grains.get": grainsmod.get,
29                 "grains.set": grainsmod.set,
30                 "grains.setval": grainsmod.setval,
31                 "grains.delval": grainsmod.delval,
32                 "grains.append": grainsmod.append,
33                 "grains.remove": grainsmod.remove,
34                 "saltutil.sync_grains": MagicMock(</b></font>),
35             },
36         }
37 <a name="1"></a>        return {grains: loader_globals, grainsmod: loader_globals}
38     def assertGrainFileContent(self, grains_string):
39         if os<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.path.isdir(grains.__opts__["conf_file"]):
40             grains_file = os.path.join(grains.__opts__["conf_file"], "grains")
41         else:
42             grains_file = os.path.join(
43                 os.</b></font>path.dirname(grains.__opts__["conf_file"]), "grains"
44             )
45         with salt.utils.files.fopen(grains_file, "r") as grf:
46             grains_data = salt.utils.stringutils.to_unicode(grf.read())
47         self.assertMultiLineEqual(grains_string, grains_data)
48     @contextlib.contextmanager
49     def setGrains(self, grains_data):
50         with patch.dict(grains.__grains__, grains_data):
51             with patch.dict(grainsmod.__grains__, grains_data):
52                 if os.path.isdir(grains.__opts__["conf_file"]):
53                     grains_file = os.path.join(grains.__opts__["conf_file"], "grains")
54                 else:
55                     grains_file = os.path.join(
56                         os.path.dirname(grains.__opts__["conf_file"]), "grains"
57                     )
58                 with salt.utils.files.fopen(grains_file, "w+") as grf:
59                     salt.utils.yaml.safe_dump(
60                         grains_data, grf, default_flow_style=False
61                     )
62                 yield
63     def test_exists_missing(self):
64         with self.setGrains({"a": "aval"}):
65             ret = grains.exists(name="foo")
66             self.assertEqual(ret["result"], False)
67             self.assertEqual(ret["comment"], "Grain does not exist")
68             self.assertEqual(ret["changes"], {})
69     def test_exists_found(self):
70         with self.setGrains({"a": "aval", "foo": "bar"}):
71             ret = grains.exists(name="foo")
72             self.assertEqual(ret["result"], True)
73             self.assertEqual(ret["comment"], "Grain exists")
74             self.assertEqual(ret["changes"], {})
75     def test_make_hashable(self):
76         with self.setGrains({"cmplx_lst_grain": [{"a": "aval"}, {"foo": "bar"}]}):
77             hashable_list = {"cmplx_lst_grain": [{"a": "aval"}, {"foo": "bar"}]}
78             self.assertEqual(
79                 grains.make_hashable(grains.__grains__).issubset(
80                     grains.make_hashable(hashable_list)
81                 ),
82                 True,
83             )
84     def test_present_add(self):
85         with self.setGrains({"a": "aval"}):
86             ret = grains.present(name="foo", value="bar")
87             self.assertEqual(ret["result"], True)
88             self.assertEqual(ret["changes"], {"foo": "bar"})
89             self.assertEqual(grains.__grains__, {"a": "aval", "foo": "bar"})
90             self.assertGrainFileContent("a: aval\nfoo: bar\n")
91         with self.setGrains({"a": "aval"}):
92             ret = grains.present(name="foo:is:nested", value="bar")
93             self<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertEqual(ret["result"], True)
94             self.assertEqual(ret["changes"], {"foo": {"is": {"nested": "bar"}}})
95             self.assertEqual(
96                 grains.__grains__, {"a": "aval", "foo": {"is": {"nested": "bar"}}}
97             )
98             self.</b></font>assertGrainFileContent("a: aval\nfoo:\n  is:\n    nested: bar\n")
99         with self.setGrains({"a": "aval"}):
100             ret = grains.present(name="foo:is:nested", value={"bar": "is a dict"})
101             self.assertEqual(ret["result"], True)
102             self.assertEqual(
103                 ret["changes"], {"foo": {"is": {"nested": {"bar": "is a dict"}}}}
104             )
105             self.assertEqual(
106                 grains.__grains__,
107                 {"a": "aval", "foo": {"is": {"nested": {"bar": "is a dict"}}}},
108             )
109             self.assertGrainFileContent(
110                 "a: aval\n"
111                 + "foo:\n"
112                 + "  is:\n"
113                 + "    nested:\n"
114                 + "      bar: is a dict\n"
115             )
116     def test_present_add_key_to_existing(self):
117         with self.setGrains({"a": "aval", "foo": {"k1": "v1"}}):
118             ret = grains.present(name="foo:k2", value="v2")
119             self.assertEqual(ret["result"], True)
120             self<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.assertEqual(ret["comment"], "Set grain foo:k2 to v2")
121             self.assertEqual(ret["changes"], {"foo": {"k2": "v2", "k1": "v1"}})
122             self.assertEqual(
123                 grains.__grains__, {"a": "aval", "foo": {"k1": "v1", "k2": "v2"}}
124             )
125             self.</b></font>assertGrainFileContent(
126                 "a: aval\n" + "foo:\n" + "  k1: v1\n" + "  k2: v2\n"
127             )
128     def test_present_already_set(self):
129         with self.setGrains({"a": "aval", "foo": "bar"}):
130             ret = grains.present(name="foo", value="bar")
131             self.assertEqual(ret["result"], True)
132             self.assertEqual(ret["comment"], "Grain is already set")
133             self.assertEqual(ret["changes"], {})
134             self.assertEqual(grains.__grains__, {"a": "aval", "foo": "bar"})
135         with self.setGrains({"a": "aval", "foo": {"is": {"nested": "bar"}}}):
136             ret = grains.present(name="foo:is:nested", value="bar")
137             self.assertEqual(ret["result"], True)
138             self.assertEqual(ret["comment"], "Grain is already set")
139             self.assertEqual(ret["changes"], {})
140             self.assertEqual(
141                 grains.__grains__, {"a": "aval", "foo": {"is": {"nested": "bar"}}}
142             )
143         with self.setGrains({"a": "aval", "foo": {"is": {"nested": "bar"}}}):
144             ret = grains.present(name="foo:is", value={"nested": "bar"})
145             self.assertEqual(ret["result"], True)
146             self.assertEqual(ret["comment"], "Grain is already set")
147             self.assertEqual(ret["changes"], {})
148             self.assertEqual(
149                 grains.__grains__, {"a": "aval", "foo": {"is": {"nested": "bar"}}}
150             )
151     def test_present_overwrite(self):
152         with self.setGrains({"a": "aval", "foo": "bar"}):
153             ret = grains.present(name="foo", value="newbar")
154             self.assertEqual(ret["result"], True)
155             self.assertEqual(ret["changes"], {"foo": "newbar"})
156             self.assertEqual(grains.__grains__, {"a": "aval", "foo": "newbar"})
157             self.assertGrainFileContent("a: aval\n" + "foo: newbar\n")
158         with self.setGrains({"a": "aval", "foo": "bar"}):
159             ret = grains.present(name="foo", value=None)
160             self.assertEqual(ret["result"], True)
161             self.assertEqual(ret["changes"], {"foo": None})
162             self.assertEqual(grains.__grains__, {"a": "aval", "foo": None})
163             self.assertGrainFileContent("a: aval\n" + "foo: null\n")
164         with self.setGrains({"a": "aval", "foo": {"is": {"nested": "bar"}}}):
165             ret = grains.present(name="foo:is:nested", value="newbar")
166             self.assertEqual(ret["result"], True)
167             self.assertEqual(ret["changes"], {"foo": {"is": {"nested": "newbar"}}})
168             self.assertEqual(
169                 grains.__grains__, {"a": "aval", "foo": {"is": {"nested": "newbar"}}}
170             )
171             self.assertGrainFileContent(
172                 "a: aval\n" + "foo:\n" + "  is:\n" + "    nested: newbar\n"
173             )
174         with self.setGrains({"a": "aval", "foo": {"is": {"nested": "bar"}}}):
175             ret = grains.present(name="foo:is:nested", value=None)
176             self.assertEqual(ret["result"], True)
177             self.assertEqual(ret["changes"], {"foo": {"is": {"nested": None}}})
178             self.assertEqual(
179                 grains.__grains__, {"a": "aval", "foo": {"is": {"nested": None}}}
180             )
181             self.assertGrainFileContent(
182                 "a: aval\n" + "foo:\n" + "  is:\n" + "    nested: null\n"
183             )
184     def test_present_fail_overwrite(self):
185         with self.setGrains({"a": "aval", "foo": {"is": {"nested": "val"}}}):
186             ret = grains.present(name="foo:is", value="newbar")
187             self.assertEqual(ret["result"], False)
188             self.assertEqual(ret["changes"], {})
189             self.assertEqual(
190                 ret["comment"],
191                 "The key 'foo:is' exists but is a dict or a list. Use 'force=True' to"
192                 " overwrite.",
193             )
194             self.assertEqual(
195                 grains.__grains__, {"a": "aval", "foo": {"is": {"nested": "val"}}}
196             )
197         with self.setGrains({"a": "aval", "foo": {"is": {"nested": "val"}}}):
198             ret = grains.present(name="foo:is", value=None)
199             self.assertEqual(ret["result"], False)
200             self.assertEqual(ret["changes"], {})
201             self.assertEqual(
202                 ret["comment"],
203                 "The key 'foo:is' exists but is a dict or a list. Use 'force=True' to"
204                 " overwrite.",
205             )
206             self.assertEqual(
207                 grains.__grains__, {"a": "aval", "foo": {"is": {"nested": "val"}}}
208             )
209     def test_present_fails_to_set_dict_or_list(self):
210         with self.setGrains({"a": "aval", "foo": "bar"}):
211             ret = grains.present(name="foo", value=["l1", "l2"])
212             self.assertEqual(ret["result"], False)
213             self.assertEqual(
214                 ret["comment"],
215                 "The key 'foo' exists and the "
216                 + "given value is a dict or a list. "
217                 + "Use 'force=True' to overwrite.",
218             )
219             self.assertEqual(ret["changes"], {})
220             self.assertEqual(grains.__grains__, {"a": "aval", "foo": "bar"})
221         with self.setGrains({"a": "aval", "foo": "bar"}):
222             ret = grains.present(name="foo", value={"k1": "v1"})
223             self.assertEqual(ret["result"], False)
224             self.assertEqual(
225                 ret["comment"],
226                 "The key 'foo' exists and the given "
227                 + "value is a dict or a list. Use "
228                 + "'force=True' to overwrite.",
229             )
230             self.assertEqual(ret["changes"], {})
231             self.assertEqual(grains.__grains__, {"a": "aval", "foo": "bar"})
232         with self.setGrains({"a": "aval", "foo": {"is": {"nested": "bar"}}}):
233             ret = grains.present(
234                 name="foo,is,nested", value=["l1", "l2"], delimiter=","
235             )
236             self.assertEqual(ret["result"], False)
237             self.assertEqual(ret["changes"], {})
238             self.assertEqual(
239                 ret["comment"],
240                 "The key 'foo:is:nested' exists and the "
241                 + "given value is a dict or a list. "
242                 + "Use 'force=True' to overwrite.",
243             )
244             self.assertEqual(
245                 grains.__grains__, {"a": "aval", "foo": {"is": {"nested": "bar"}}}
246             )
247         with self.setGrains({"a": "aval", "foo": {"is": {"nested": "bar"}}}):
248             ret = grains.present(name="foo:is:nested", value={"k1": "v1"})
249             self.assertEqual(ret["result"], False)
250             self.assertEqual(
251                 ret["comment"],
252                 "The key 'foo:is:nested' exists and the "
253                 + "given value is a dict or a list. "
254                 + "Use 'force=True' to overwrite.",
255             )
256             self.assertEqual(ret["changes"], {})
257             self.assertEqual(
258                 grains.__grains__, {"a": "aval", "foo": {"is": {"nested": "bar"}}}
259             )
260     def test_present_fail_merge_dict(self):
261         with self.setGrains({"a": "aval", "foo": {"k1": "v1"}}):
262             ret = grains.present(name="foo", value={"k2": "v2"})
263             self.assertEqual(ret["result"], False)
264             self.assertEqual(
265                 ret["comment"],
266                 "The key 'foo' exists but "
267                 + "is a dict or a list. "
268                 + "Use 'force=True' to overwrite.",
269             )
270             self.assertEqual(grains.__grains__, {"a": "aval", "foo": {"k1": "v1"}})
271             self.assertGrainFileContent("a: aval\n" + "foo:\n" + "  k1: v1\n")
272     def test_present_force_to_set_dict_or_list(self):
273         with self.setGrains({"a": "aval", "foo": "bar"}):
274             ret = grains.present(name="foo", value=["l1", "l2"], force=True)
275             self.assertEqual(ret["result"], True)
276             self.assertEqual(ret["comment"], "Set grain foo to ['l1', 'l2']")
277             self.assertEqual(ret["changes"], {"foo": ["l1", "l2"]})
278             self.assertEqual(grains.__grains__, {"a": "aval", "foo": ["l1", "l2"]})
279             self.assertGrainFileContent("a: aval\n" + "foo:\n" + "- l1\n" + "- l2\n")
280         with self.setGrains({"a": "aval", "foo": "bar"}):
281             ret = grains.present(name="foo", value={"k1": "v1"}, force=True)
282             self.assertEqual(ret["result"], True)
283             self.assertEqual(ret["comment"], "Set grain foo to {'k1': 'v1'}")
284             self.assertEqual(ret["changes"], {"foo": {"k1": "v1"}})
285             self.assertEqual(grains.__grains__, {"a": "aval", "foo": {"k1": "v1"}})
286             self.assertGrainFileContent("a: aval\n" + "foo:\n" + "  k1: v1\n")
287         with self.setGrains({"a": "aval", "foo": {"is": {"nested": "bar"}}}):
288             ret = grains.present(
289                 name="foo,is,nested", value=["l1", "l2"], delimiter=",", force=True
290             )
291             self.assertEqual(ret["result"], True)
292             self.assertEqual(ret["changes"], {"foo": {"is": {"nested": ["l1", "l2"]}}})
293             self.assertEqual(ret["comment"], "Set grain foo:is:nested to ['l1', 'l2']")
294             self.assertEqual(
295                 grains.__grains__,
296                 {"a": "aval", "foo": {"is": {"nested": ["l1", "l2"]}}},
297             )
298             self.assertGrainFileContent(
299                 "a: aval\n"
300                 + "foo:\n"
301                 + "  is:\n"
302                 + "    nested:\n"
303                 + "    - l1\n"
304                 + "    - l2\n"
305             )
306         with self.setGrains(
307             {"a": "aval", "foo": {"is": {"nested": "bar"}, "and": "other"}}
308         ):
309             ret = grains.present(name="foo:is:nested", value={"k1": "v1"}, force=True)
310             self.assertEqual(ret["result"], True)
311             self.assertEqual(ret["comment"], "Set grain foo:is:nested to {'k1': 'v1'}")
312             self.assertEqual(
313                 ret["changes"],
314                 {"foo": {"is": {"nested": {"k1": "v1"}}, "and": "other"}},
315             )
316             self.assertEqual(
317                 grains.__grains__,
318                 {"a": "aval", "foo": {"is": {"nested": {"k1": "v1"}}, "and": "other"}},
319             )
320             self.assertGrainFileContent(
321                 "a: aval\n"
322                 + "foo:\n"
323                 + "  and: other\n"
324                 + "  is:\n"
325                 + "    nested:\n"
326                 + "      k1: v1\n"
327             )
328     def test_present_fails_to_convert_value_to_key(self):
329         with self.setGrains({"a": "aval", "foo": "bar"}):
330             ret = grains.present(name="foo:is:nested", value={"k1": "v1"})
331             self.assertEqual(ret["result"], False)
332             self.assertEqual(
333                 ret["comment"],
334                 "The key 'foo' value is 'bar', "
335                 + "which is different from the provided "
336                 + "key 'is'. Use 'force=True' to overwrite.",
337             )
338             self.assertEqual(ret["changes"], {})
339     def test_present_overwrite_test(self):
340         with patch.dict(grains.__opts__, {"test": True}):
341             with self.setGrains({"a": "aval", "foo": "bar"}):
342                 ret = grains.present(name="foo", value="newbar")
343                 self.assertEqual(ret["result"], None)
344                 self.assertEqual(ret["changes"], {"changed": {"foo": "newbar"}})
345                 self.assertEqual(grains.__grains__, {"a": "aval", "foo": "bar"})
346                 self.assertGrainFileContent("a: aval\n" + "foo: bar\n")
347     def test_present_convert_value_to_key(self):
348         with self.setGrains({"a": "aval", "foo": "is"}):
349             ret = grains.present(name="foo:is:nested", value={"k1": "v1"})
350             self.assertEqual(ret["result"], True)
351             self.assertEqual(ret["comment"], "Set grain foo:is:nested to {'k1': 'v1'}")
352             self.assertEqual(ret["changes"], {"foo": {"is": {"nested": {"k1": "v1"}}}})
353             self.assertEqual(
354                 grains.__grains__,
355                 {"a": "aval", "foo": {"is": {"nested": {"k1": "v1"}}}},
356             )
357             self.assertGrainFileContent(
358                 "a: aval\n" + "foo:\n" + "  is:\n" + "    nested:\n" + "      k1: v1\n"
359             )
360         with self.setGrains({"a": "aval", "foo": ["one", "is", "correct"]}):
361             ret = grains.present(name="foo:is:nested", value={"k1": "v1"})
362             self.assertEqual(ret["result"], True)
363             self.assertEqual(ret["comment"], "Set grain foo:is:nested to {'k1': 'v1'}")
364             self.assertEqual(
365                 ret["changes"],
366                 {"foo": ["one", {"is": {"nested": {"k1": "v1"}}}, "correct"]},
367             )
368             self.assertEqual(
369                 grains.__grains__,
370                 {
371                     "a": "aval",
372                     "foo": ["one", {"is": {"nested": {"k1": "v1"}}}, "correct"],
373                 },
374             )
375             self.assertGrainFileContent(
376                 "a: aval\n"
377                 + "foo:\n"
378                 + "- one\n"
379                 + "- is:\n"
380                 + "    nested:\n"
381                 + "      k1: v1\n"
382                 + "- correct\n"
383             )
384     def test_present_unknown_failure(self):
385         with patch("salt.modules.grains.setval") as mocked_setval:
386             mocked_setval.return_value = "Failed to set grain foo"
387             with self.setGrains({"a": "aval", "foo": "bar"}):
388                 ret = grains.present(name="foo", value="baz")
389                 self.assertEqual(ret["result"], False)
390                 self.assertEqual(ret["comment"], "Failed to set grain foo")
391                 self.assertEqual(ret["changes"], {})
392                 self.assertEqual(grains.__grains__, {"a": "aval", "foo": "bar"})
393                 self.assertGrainFileContent("a: aval\n" + "foo: bar\n")
394     def test_absent_already(self):
395         with self.setGrains({"a": "aval"}):
396             ret = grains.absent(name="foo")
397             self.assertEqual(ret["result"], True)
398             self.assertEqual(ret["comment"], "Grain foo does not exist")
399             self.assertEqual(ret["changes"], {})
400             self.assertEqual(grains.__grains__, {"a": "aval"})
401             self.assertGrainFileContent("a: aval\n")
402         with self.setGrains({"a": "aval"}):
403             ret = grains.absent(name="foo:is:nested")
404             self.assertEqual(ret["result"], True)
405             self.assertEqual(ret["comment"], "Grain foo:is:nested does not exist")
406             self.assertEqual(ret["changes"], {})
407             self.assertEqual(grains.__grains__, {"a": "aval"})
408             self.assertGrainFileContent("a: aval\n")
409     def test_absent_unset(self):
410         with self.setGrains({"a": "aval", "foo": "bar"}):
411             ret = grains.absent(name="foo")
412             self.assertEqual(ret["result"], True)
413             self.assertEqual(ret["comment"], "Value for grain foo was set to None")
414             self.assertEqual(ret["changes"], {"grain": "foo", "value": None})
415             self.assertEqual(grains.__grains__, {"a": "aval", "foo": None})
416             self.assertGrainFileContent("a: aval\n" + "foo: null\n")
417         with self.setGrains({"a": "aval", "foo": False}):
418             ret = grains.absent(name="foo")
419             self.assertEqual(ret["result"], True)
420             self.assertEqual(ret["comment"], "Value for grain foo was set to None")
421             self.assertEqual(ret["changes"], {"grain": "foo", "value": None})
422             self.assertEqual(grains.__grains__, {"a": "aval", "foo": None})
423             self.assertGrainFileContent("a: aval\n" + "foo: null\n")
424         with self.setGrains(
425             {"a": "aval", "foo": ["order", {"is": {"nested": "bar"}}, "correct"]}
426         ):
427             ret = grains.absent(name="foo,is,nested", delimiter=",")
428             self.assertEqual(ret["result"], True)
429             self.assertEqual(
430                 ret["comment"], "Value for grain foo:is:nested was set to None"
431             )
432             self.assertEqual(ret["changes"], {"grain": "foo:is:nested", "value": None})
433             self.assertEqual(
434                 grains.__grains__,
435                 {"a": "aval", "foo": ["order", {"is": {"nested": None}}, "correct"]},
436             )
437             self.assertGrainFileContent(
438                 "a: aval\n"
439                 + "foo:\n"
440                 + "- order\n"
441                 + "- is:\n"
442                 + "    nested: null\n"
443                 + "- correct\n"
444             )
445         with self.setGrains(
446             {"a": "aval", "foo": ["order", {"is": "nested"}, "correct"]}
447         ):
448             ret = grains.absent(name="foo:is:nested")
449             self.assertEqual(ret["result"], True)
450             self.assertEqual(ret["comment"], "Grain foo:is:nested does not exist")
451             self.assertEqual(ret["changes"], {})
452             self.assertEqual(
453                 grains.__grains__,
454                 {"a": "aval", "foo": ["order", {"is": "nested"}, "correct"]},
455             )
456             self.assertGrainFileContent(
457                 "a: aval\n" + "foo:\n" + "- order\n" + "- is: nested\n" + "- correct\n"
458             )
459     def test_absent_unset_test(self):
460         with patch.dict(grains.__opts__, {"test": True}):
461             with self.setGrains({"a": "aval", "foo": "bar"}):
462                 ret = grains.absent(name="foo")
463                 self.assertEqual(ret["result"], None)
464                 self.assertEqual(ret["changes"], {"grain": "foo", "value": None})
465                 self.assertEqual(grains.__grains__, {"a": "aval", "foo": "bar"})
466                 self.assertGrainFileContent("a: aval\n" + "foo: bar\n")
467     def test_absent_fails_nested_complex_grain(self):
468         with self.setGrains(
469             {"a": "aval", "foo": ["order", {"is": {"nested": "bar"}}, "correct"]}
470         ):
471             ret = grains.absent(name="foo:is")
472             self.assertEqual(ret["result"], False)
473             self.assertEqual(
474                 ret["comment"],
475                 "The key 'foo:is' exists but is a dict or a list. Use 'force=True' to"
476                 " overwrite.",
477             )
478             self.assertEqual(ret["changes"], {})
479             self.assertEqual(
480                 grains.__grains__,
481                 {"a": "aval", "foo": ["order", {"is": {"nested": "bar"}}, "correct"]},
482             )
483             self.assertGrainFileContent(
484                 "a: aval\n"
485                 + "foo:\n"
486                 + "- order\n"
487                 + "- is:\n"
488                 + "    nested: bar\n"
489                 + "- correct\n"
490             )
491     def test_absent_force_nested_complex_grain(self):
492         with self.setGrains(
493             {"a": "aval", "foo": ["order", {"is": {"nested": "bar"}}, "correct"]}
494         ):
495             ret = grains.absent(name="foo:is", force=True)
496             self.assertEqual(ret["result"], True)
497             self.assertEqual(ret["comment"], "Value for grain foo:is was set to None")
498             self.assertEqual(ret["changes"], {"grain": "foo:is", "value": None})
499             self.assertEqual(
500                 grains.__grains__,
501                 {"a": "aval", "foo": ["order", {"is": None}, "correct"]},
502             )
503             self.assertGrainFileContent(
504                 "a: aval\n" + "foo:\n" + "- order\n" + "- is: null\n" + "- correct\n"
505             )
506     def test_absent_delete(self):
507         with self.setGrains({"a": "aval", "foo": "bar"}):
508             ret = grains.absent(name="foo", destructive=True)
509             self.assertEqual(ret["result"], True)
510             self.assertEqual(ret["comment"], "Grain foo was deleted")
511             self.assertEqual(ret["changes"], {"deleted": "foo"})
512             self.assertEqual(grains.__grains__, {"a": "aval"})
513             self.assertGrainFileContent("a: aval\n")
514         with self.setGrains({"a": "aval", "foo": None}):
515             ret = grains.absent(name="foo", destructive=True)
516             self.assertEqual(ret["result"], True)
517             self.assertEqual(ret["comment"], "Grain foo was deleted")
518             self.assertEqual(ret["changes"], {"deleted": "foo"})
519             self.assertEqual(grains.__grains__, {"a": "aval"})
520             self.assertGrainFileContent("a: aval\n")
521         with self.setGrains(
522             {
523                 "a": "aval",
524                 "foo": [
525                     "order",
526                     {"is": {"nested": "bar", "other": "value"}},
527                     "correct",
528                 ],
529             }
530         ):
531             ret = grains.absent(name="foo:is:nested", destructive=True)
532             self.assertEqual(ret["result"], True)
533             self.assertEqual(ret["comment"], "Grain foo:is:nested was deleted")
534             self.assertEqual(ret["changes"], {"deleted": "foo:is:nested"})
535             self.assertEqual(
536                 grains.__grains__,
537                 {"a": "aval", "foo": ["order", {"is": {"other": "value"}}, "correct"]},
538             )
539             self.assertGrainFileContent(
540                 "a: aval\n"
541                 + "foo:\n"
542                 + "- order\n"
543                 + "- is:\n"
544                 + "    other: value\n"
545                 + "- correct\n"
546             )
547     def test_append(self):
548         with self.setGrains({"a": "aval", "foo": ["bar"]}):
549             ret = grains.append(name="foo", value="baz")
550             self.assertEqual(ret["result"], True)
551             self.assertEqual(ret["comment"], "Value baz was added to grain foo")
552             self.assertEqual(ret["changes"], {"added": "baz"})
553             self.assertEqual(grains.__grains__, {"a": "aval", "foo": ["bar", "baz"]})
554             self.assertGrainFileContent("a: aval\n" + "foo:\n" + "- bar\n" + "- baz\n")
555     def test_append_nested(self):
556         with self.setGrains({"a": "aval", "foo": {"list": ["bar"]}}):
557             ret = grains.append(name="foo,list", value="baz", delimiter=",")
558             self.assertEqual(ret["result"], True)
559             self.assertEqual(ret["comment"], "Value baz was added to grain foo:list")
560             self.assertEqual(ret["changes"], {"added": "baz"})
561             self.assertEqual(
562                 grains.__grains__, {"a": "aval", "foo": {"list": ["bar", "baz"]}}
563             )
564             self.assertGrainFileContent(
565                 "a: aval\n" + "foo:\n" + "  list:\n" + "  - bar\n" + "  - baz\n"
566             )
567     def test_append_already(self):
568         with self.setGrains({"a": "aval", "foo": ["bar"]}):
569             ret = grains.append(name="foo", value="bar")
570             self.assertEqual(ret["result"], True)
571             self.assertEqual(
572                 ret["comment"], "Value bar is already in the list " + "for grain foo"
573             )
574             self.assertEqual(ret["changes"], {})
575             self.assertEqual(grains.__grains__, {"a": "aval", "foo": ["bar"]})
576             self.assertGrainFileContent("a: aval\n" + "foo:\n" + "- bar\n")
577     def test_append_fails_not_a_list(self):
578         with self.setGrains({"a": "aval", "foo": {"bar": "val"}}):
579             ret = grains.append(name="foo", value="baz")
580             self.assertEqual(ret["result"], False)
581             self.assertEqual(ret["comment"], "Grain foo is not a valid list")
582             self.assertEqual(ret["changes"], {})
583             self.assertEqual(grains.__grains__, {"a": "aval", "foo": {"bar": "val"}})
584     def test_append_convert_to_list(self):
585         with self.setGrains({"a": "aval", "foo": {"bar": "val"}}):
586             self.assertGrainFileContent("a: aval\n" + "foo:\n" + "  bar: val\n")
587             ret = grains.append(name="foo", value="baz", convert=True)
588             self.assertEqual(ret["result"], True)
589             self.assertEqual(ret["comment"], "Value baz was added to grain foo")
590             self.assertEqual(ret["changes"], {"added": "baz"})
591             self.assertEqual(
592                 grains.__grains__, {"a": "aval", "foo": [{"bar": "val"}, "baz"]}
593             )
594             self.assertGrainFileContent(
595                 "a: aval\n" + "foo:\n" + "- bar: val\n" + "- baz\n"
596             )
597         with self.setGrains({"a": "aval", "foo": {"bar": "val", "other": "value"}}):
598             self.assertGrainFileContent(
599                 "a: aval\n" + "foo:\n" + "  bar: val\n" + "  other: value\n"
600             )
601             ret = grains.append(name="foo", value="baz", convert=True)
602             self.assertEqual(ret["result"], True)
603             self.assertEqual(ret["comment"], "Value baz was added to grain foo")
604             self.assertEqual(ret["changes"], {"added": "baz"})
605             self.assertEqual(
606                 grains.__grains__,
607                 {"a": "aval", "foo": [{"bar": "val", "other": "value"}, "baz"]},
608             )
609             self.assertGrainFileContent(
610                 "a: aval\n" + "foo:\n" + "- bar: val\n" + "  other: value\n" + "- baz\n"
611             )
612     def test_append_fails_inexistent(self):
613         with self.setGrains({"a": "aval"}):
614             ret = grains.append(name="foo", value="bar")
615             self.assertEqual(ret["result"], False)
616             self.assertEqual(ret["comment"], "Grain foo does not exist")
617             self.assertEqual(ret["changes"], {})
618             self.assertEqual(grains.__grains__, {"a": "aval"})
619     def test_append_convert_to_list_empty(self):
620         with self.setGrains({"foo": None}):
621             ret = grains.append(name="foo", value="baz", convert=True)
622             self.assertEqual(ret["result"], True)
623             self.assertEqual(ret["comment"], "Value baz was added to grain foo")
624             self.assertEqual(ret["changes"], {"added": "baz"})
625             self.assertEqual(grains.__grains__, {"foo": ["baz"]})
626             self.assertGrainFileContent("foo:\n" + "- baz\n")
627     def test_list_present(self):
628         with self.setGrains({"a": "aval", "foo": ["bar"]}):
629             ret = grains.list_present(name="foo", value="baz")
630             self.assertEqual(ret["result"], True)
631             self.assertEqual(ret["comment"], "Append value baz to grain foo")
632             self.assertEqual(ret["changes"], {"new": {"foo": ["bar", "baz"]}})
633             self.assertEqual(grains.__grains__, {"a": "aval", "foo": ["bar", "baz"]})
634             self.assertGrainFileContent("a: aval\n" + "foo:\n" + "- bar\n" + "- baz\n")
635     def test_list_present_nested(self):
636         with self.setGrains({"a": "aval", "foo": {"is": {"nested": ["bar"]}}}):
637             ret = grains.list_present(name="foo,is,nested", value="baz", delimiter=",")
638             self.assertEqual(ret["result"], True)
639             self.assertEqual(ret["comment"], "Append value baz to grain foo:is:nested")
640             self.assertEqual(
641                 ret["changes"], {"new": {"foo": {"is": {"nested": ["bar", "baz"]}}}}
642             )
643             self.assertEqual(
644                 grains.__grains__,
645                 {"a": "aval", "foo": {"is": {"nested": ["bar", "baz"]}}},
646             )
647             self.assertGrainFileContent(
648                 "a: aval\n"
649                 + "foo:\n"
650                 + "  is:\n"
651                 + "    nested:\n"
652                 + "    - bar\n"
653                 + "    - baz\n"
654             )
655     def test_list_present_inexistent(self):
656         with self.setGrains({"a": "aval"}):
657             ret = grains.list_present(name="foo", value="baz")
658             self.assertEqual(ret["result"], True)
659             self.assertEqual(ret["comment"], "Append value baz to grain foo")
660             self.assertEqual(ret["changes"], {"new": {"foo": ["baz"]}})
661             self.assertEqual(grains.__grains__, {"a": "aval", "foo": ["baz"]})
662             self.assertGrainFileContent("a: aval\n" + "foo:\n" + "- baz\n")
663     def test_list_present_inexistent_nested(self):
664         with self.setGrains({"a": "aval"}):
665             ret = grains.list_present(name="foo:is:nested", value="baz")
666             self.assertEqual(ret["result"], True)
667             self.assertEqual(ret["comment"], "Append value baz to grain foo:is:nested")
668             self.assertEqual(
669                 ret["changes"], {"new": {"foo": {"is": {"nested": ["baz"]}}}}
670             )
671             self.assertEqual(
672                 grains.__grains__, {"a": "aval", "foo": {"is": {"nested": ["baz"]}}}
673             )
674             self.assertGrainFileContent(
675                 "a: aval\n" + "foo:\n" + "  is:\n" + "    nested:\n" + "    - baz\n"
676             )
677     def test_list_present_not_a_list(self):
678         with self.setGrains({"a": "aval", "foo": "bar"}):
679             ret = grains.list_present(name="foo", value="baz")
680             self.assertEqual(ret["result"], False)
681             self.assertEqual(ret["comment"], "Grain foo is not a valid list")
682             self.assertEqual(ret["changes"], {})
683             self.assertEqual(grains.__grains__, {"a": "aval", "foo": "bar"})
684             self.assertGrainFileContent("a: aval\n" + "foo: bar\n")
685     def test_list_present_nested_already(self):
686         with self.setGrains({"a": "aval", "b": {"foo": ["bar"]}}):
687             ret = grains.list_present(name="b:foo", value="bar")
688             self.assertEqual(ret["result"], True)
689             self.assertEqual(ret["comment"], "Value bar is already in grain b:foo")
690             self.assertEqual(ret["changes"], {})
691             self.assertEqual(grains.__grains__, {"a": "aval", "b": {"foo": ["bar"]}})
692             self.assertGrainFileContent("a: aval\n" + "b:\n" + "  foo:\n" + "  - bar\n")
693     def test_list_present_already(self):
694         with self.setGrains({"a": "aval", "foo": ["bar"]}):
695             ret = grains.list_present(name="foo", value="bar")
696             self.assertEqual(ret["result"], True)
697             self.assertEqual(ret["comment"], "Value bar is already in grain foo")
698             self.assertEqual(ret["changes"], {})
699             self.assertEqual(grains.__grains__, {"a": "aval", "foo": ["bar"]})
700             self.assertGrainFileContent("a: aval\n" + "foo:\n" + "- bar\n")
701     def test_list_present_unknown_failure(self):
702         with self.setGrains({"a": "aval", "foo": ["bar"]}):
703             with patch.dict(grainsmod.__salt__, {"grains.append": MagicMock()}):
704                 ret = grains.list_present(name="foo", value="baz")
705                 self.assertEqual(ret["result"], False)
706                 self.assertEqual(ret["comment"], "Failed append value baz to grain foo")
707                 self.assertEqual(ret["changes"], {})
708                 self.assertEqual(grains.__grains__, {"a": "aval", "foo": ["bar"]})
709                 self.assertGrainFileContent("a: aval\n" + "foo:\n" + "- bar\n")
710     def test_list_absent(self):
711         with self.setGrains({"a": "aval", "foo": ["bar"]}):
712             ret = grains.list_absent(name="foo", value="bar")
713             self.assertEqual(ret["result"], True)
714             self.assertEqual(ret["comment"], "Value bar was deleted from grain foo")
715             self.assertEqual(ret["changes"], {"deleted": ["bar"]})
716             self.assertEqual(grains.__grains__, {"a": "aval", "foo": []})
717             self.assertGrainFileContent("a: aval\n" + "foo: []\n")
718     def test_list_absent_nested(self):
719         with self.setGrains({"a": "aval", "foo": {"list": ["bar"]}}):
720             ret = grains.list_absent(name="foo:list", value="bar")
721             self.assertEqual(ret["result"], True)
722             self.assertEqual(
723                 ret["comment"], "Value bar was deleted from grain foo:list"
724             )
725             self.assertEqual(ret["changes"], {"deleted": ["bar"]})
726             self.assertEqual(grains.__grains__, {"a": "aval", "foo": {"list": []}})
727             self.assertGrainFileContent("a: aval\n" + "foo:\n" + "  list: []\n")
728     def test_list_absent_inexistent(self):
729         with self.setGrains({"a": "aval"}):
730             ret = grains.list_absent(name="foo", value="baz")
731             self.assertEqual(ret["result"], True)
732             self.assertEqual(ret["comment"], "Grain foo does not exist")
733             self.assertEqual(ret["changes"], {})
734             self.assertEqual(grains.__grains__, {"a": "aval"})
735             self.assertGrainFileContent("a: aval\n")
736     def test_list_absent_inexistent_nested(self):
737         with self.setGrains({"a": "aval"}):
738             ret = grains.list_absent(name="foo:list", value="baz")
739             self.assertEqual(ret["result"], True)
740             self.assertEqual(ret["comment"], "Grain foo:list does not exist")
741             self.assertEqual(ret["changes"], {})
742             self.assertEqual(grains.__grains__, {"a": "aval"})
743             self.assertGrainFileContent("a: aval\n")
744     def test_list_absent_not_a_list(self):
745         with self.setGrains({"a": "aval", "foo": "bar"}):
746             ret = grains.list_absent(name="foo", value="bar")
747             self.assertEqual(ret["result"], False)
748             self.assertEqual(ret["comment"], "Grain foo is not a valid list")
749             self.assertEqual(ret["changes"], {})
750             self.assertEqual(grains.__grains__, {"a": "aval", "foo": "bar"})
751             self.assertGrainFileContent("a: aval\n" + "foo: bar\n")
752     def test_list_absent_already(self):
753         with self.setGrains({"a": "aval", "foo": ["bar"]}):
754             ret = grains.list_absent(name="foo", value="baz")
755             self.assertEqual(ret["result"], True)
756             self.assertEqual(ret["comment"], "Value baz is absent from grain foo")
757             self.assertEqual(ret["changes"], {})
758             self.assertEqual(grains.__grains__, {"a": "aval", "foo": ["bar"]})
759             self.assertGrainFileContent("a: aval\n" + "foo:\n" + "- bar\n")
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_boto_apigateway.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import datetime
2 import logging
3 import os
4 import random
5 import string
6 import pytest
7 import salt.config
8 import salt.loader
9 import salt.states.boto_apigateway as boto_apigateway
10 import salt.utils.files
11 import salt.utils.yaml
12 from salt.utils.versions import LooseVersion
13 from tests.support.mixins import LoaderModuleMockMixin
14 from tests.support.mock import MagicMock, patch
15 from tests.support.unit import TestCase, skipIf
16 from tests.unit.modules.test_boto_apigateway import BotoApiGatewayTestCaseMixin
17 try:
18     import boto3
19     import botocore
20     from botocore.exceptions import ClientError
21     HAS_BOTO = True
22 except ImportError:
23     HAS_BOTO = False
24 required_boto3_version = "1.2.1"
25 required_botocore_version = "1.4.49"
26 region = "us-east-1"
27 access_key = "GKTADJGHEIQSXMKKRBJ08H"
28 secret_key = "askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs"
29 conn_parameters = {
30     "region": region,
31     "key": access_key,
32     "keyid": secret_key,
33     "profile": {},
34 }
35 error_message = (
36     "An error occurred (101) when calling the {0} operation: Test-defined error"
37 )
38 error_content = {"Error": {"Code": 101, "Message": "Test-defined error"}}
39 api_ret = dict(
40     description=(
41         '{\n    "context": "See deployment or stage description",\n   '
42         ' "provisioned_by": "Salt boto_apigateway.present State"\n}'
43     ),
44     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
45     id="vni0vq8wzi",
46     name="unit test api",
47 )
48 no_apis_ret = {"items": []}
49 apis_ret = {"items": [api_ret]}
50 mock_model_ret = dict(
51     contentType="application/json",
52     description="mock model",
53     id="123abc",
54     name="mock model",
55     schema=(
56         "{\n"
57         '    "$schema": "http://json-schema.org/draft-04/schema#",\n'
58         '    "properties": {\n'
59         '        "field": {\n'
60         '            "type": "string"\n'
61         "        }\n"
62         "    }\n"
63         "}"
64     ),
65 )
66 models_ret = {
67     "items": [
68         dict(
69             contentType="application/json",
70             description="Error",
71             id="50nw8r",
72             name="Error",
73             schema=(
74                 "{\n"
75                 '    "$schema": "http://json-schema.org/draft-04/schema#",\n'
76                 '    "properties": {\n'
77                 '        "code": {\n'
78                 '            "format": "int32",\n'
79                 '            "type": "integer"\n'
80                 "        },\n"
81                 '        "fields": {\n'
82                 '            "type": "string"\n'
83                 "        },\n"
84                 '        "message": {\n'
85                 '            "type": "string"\n'
86                 "        }\n"
87                 "    },\n"
88                 '    "title": "Error Schema",\n'
89                 '    "type": "object"\n'
90                 "}"
91             ),
92         ),
93         dict(
94             contentType="application/json",
95             description="User",
96             id="terlnw",
97             name="User",
98             schema=(
99                 "{\n"
100                 '    "$schema": "http://json-schema.org/draft-04/schema#",\n'
101                 '    "properties": {\n'
102                 '        "password": {\n'
103                 '            "description": "A password for the new user",\n'
104                 '            "type": "string"\n'
105                 "        },\n"
106                 '        "username": {\n'
107                 '            "description": "A unique username for the user",\n'
108                 '            "type": "string"\n'
109                 "        }\n"
110                 "    },\n"
111                 '    "title": "User Schema",\n'
112                 '    "type": "object"\n'
113                 "}"
114             ),
115         ),
116     ]
117 }
118 root_resources_ret = {"items": [dict(id="bgk0rk8rqb", path="/")]}
119 resources_ret = {
120     "items": [
121         dict(id="bgk0rk8rqb", path="/"),
122         dict(
123             id="9waiaz",
124             parentId="bgk0rk8rqb",
125             path="/users",
126             pathPart="users",
127             resourceMethods={"POST": {}},
128         ),
129     ]
130 }
131 no_resources_ret = {"items": []}
132 stage1_deployment1_ret = dict(
133     cacheClusterEnabled=False,
134     cacheClusterSize=0.5,
135     cacheClusterStatus="NOT_AVAILABLE",
136     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
137     deploymentId="kobnrb",
138     description=(
139         "{\n"
140         '    "current_deployment_label": {\n'
141         '        "api_name": "unit test api",\n'
142         '        "swagger_file": "temp-swagger-sample.yaml",\n'
143         '        "swagger_file_md5sum": "4fb17e43bab3a96e7f2410a1597cd0a5",\n'
144         '        "swagger_info_object": {\n'
145         '            "description": "salt boto apigateway unit test service",\n'
146         '            "title": "salt boto apigateway unit test service",\n'
147         '            "version": "0.0.0"\n'
148         "        }\n"
149         "    }\n"
150         "}"
151     ),
152     lastUpdatedDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
153     methodSettings=dict(),
154     stageName="test",
155     variables=dict(),
156 )
157 stage1_deployment1_vars_ret = dict(
158     cacheClusterEnabled=False,
159     cacheClusterSize=0.5,
160     cacheClusterStatus="NOT_AVAILABLE",
161     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
162     deploymentId="kobnrb",
163     description=(
164         "{\n"
165         '    "current_deployment_label": {\n'
166         '        "api_name": "unit test api",\n'
167         '        "swagger_file": "temp-swagger-sample.yaml",\n'
168         '        "swagger_file_md5sum": "4fb17e43bab3a96e7f2410a1597cd0a5",\n'
169         '        "swagger_info_object": {\n'
170         '            "description": "salt boto apigateway unit test service",\n'
171         '            "title": "salt boto apigateway unit test service",\n'
172         '            "version": "0.0.0"\n'
173         "        }\n"
174         "    }\n"
175         "}"
176     ),
177     lastUpdatedDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
178     methodSettings=dict(),
179     stageName="test",
180     variables={"var1": "val1"},
181 )
182 stage1_deployment2_ret = dict(
183     cacheClusterEnabled=False,
184     cacheClusterSize=0.5,
185     cacheClusterStatus="NOT_AVAILABLE",
186     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
187     deploymentId="kobnrc",
188     description=(
189         "{\n"
190         '    "current_deployment_label": {\n'
191         '        "api_name": "unit test api",\n'
192         '        "swagger_file": "temp-swagger-sample.yaml",\n'
193         '        "swagger_file_md5sum": "5fd538c4336ed5c54b4bf39ddf97c661",\n'
194         '        "swagger_info_object": {\n'
195         '            "description": "salt boto apigateway unit test service",\n'
196         '            "title": "salt boto apigateway unit test service",\n'
197         '            "version": "0.0.2"\n'
198         "        }\n"
199         "    }\n"
200         "}"
201     ),
202     lastUpdatedDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
203     methodSettings=dict(),
204     stageName="test",
205     variables=dict(),
206 )
207 stage2_ret = dict(
208     cacheClusterEnabled=False,
209     cacheClusterSize=0.5,
210     cacheClusterStatus="NOT_AVAILABLE",
211     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
212     deploymentId="kobnrb",
213     description=(
214         "{\n"
215         '    "current_deployment_label": {\n'
216         '        "api_name": "unit test api",\n'
217         '        "swagger_file": "temp-swagger-sample.yaml",\n'
218         '        "swagger_file_md5sum": "4fb17e43bab3a96e7f2410a1597cd0a5",\n'
219         '        "swagger_info_object": {\n'
220         '            "description": "salt boto apigateway unit test service",\n'
221         '            "title": "salt boto apigateway unit test service",\n'
222         '            "version": "0.0.0"\n'
223         "        }\n"
224         "    }\n"
225         "}"
226     ),
227     lastUpdatedDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
228     methodSettings=dict(),
229     stageName="dev",
230     variables=dict(),
231 )
232 stages_stage2_ret = {"item": [stage2_ret]}
233 no_stages_ret = {"item": []}
234 deployment1_ret = dict(
235     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
236     description=(
237         "{\n"
238         '    "api_name": "unit test api",\n'
239         '    "swagger_file": "temp-swagger-sample.yaml",\n'
240         '    "swagger_file_md5sum": "55a948ff90ad80ff747ec91657c7a299",\n'
241         '    "swagger_info_object": {\n'
242         '        "description": "salt boto apigateway unit test service",\n'
243         '        "title": "salt boto apigateway unit test service",\n'
244         '        "version": "0.0.0"\n'
245         "    }\n"
246         "}"
247     ),
248     id="kobnrb",
249 )
250 deployment2_ret = dict(
251     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
252     description=(
253         "{\n"
254         '    "api_name": "unit test api",\n'
255         '    "swagger_file": "temp-swagger-sample.yaml",\n'
256         '    "swagger_file_md5sum": "5fd538c4336ed5c54b4bf39ddf97c661",\n'
257         '    "swagger_info_object": {\n'
258         '        "description": "salt boto apigateway unit test service",\n'
259         '        "title": "salt boto apigateway unit test service",\n'
260         '        "version": "0.0.2"\n'
261         "    }\n"
262         "}"
263     ),
264     id="kobnrc",
265 )
266 deployments_ret = {"items": [deployment1_ret, deployment2_ret]}
267 function_ret = dict(
268     FunctionName="unit_test_api_users_post",
269     Runtime="python2.7",
270     Role=None,
271     Handler="handler",
272     Description="abcdefg",
273     Timeout=5,
274     MemorySize=128,
275     CodeSha256="abcdef",
276     CodeSize=199,
277     FunctionArn="arn:lambda:us-east-1:1234:Something",
278     LastModified="yes",
279 )
280 method_integration_response_200_ret = dict(
281     responseParameters={"method.response.header.Access-Control-Allow-Origin": "*"},
282     responseTemplates={},
283     selectionPattern=".*",
284     statusCode="200",
285 )
286 method_integration_ret = dict(
287     cacheKeyParameters={},
288     cacheNamespace="9waiaz",
289     credentials="arn:aws:iam::1234:role/apigatewayrole",
290     httpMethod="POST",
291     integrationResponses={"200": method_integration_response_200_ret},
292     requestParameters={},
293     requestTemplates={
294         "application/json": (
295             "#set($inputRoot = $input.path('$')){\"header-params\" : {#set ($map ="
296             ' $input.params().header)#foreach( $param in $map.entrySet() )"$param.key"'
297             ' : "$param.value" #if( $foreach.hasNext ), #end#end},"query-params" :'
298             " {#set ($map = $input.params().querystring)#foreach( $param in"
299             ' $map.entrySet() )"$param.key" : "$param.value" #if( $foreach.hasNext ),'
300             ' #end#end},"path-params" : {#set ($map = $input.params().path)#foreach('
301             ' $param in $map.entrySet() )"$param.key" : "$param.value" #if('
302             " $foreach.hasNext ), #end#end},\"body-params\" : $input.json('$')}"
303         )
304     },
305     type="AWS",
306     uri=(
307         "arn:aws:apigateway:us-west-2:"
308         "lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:1234567:"
309         "function:unit_test_api_api_users_post/invocations"
310     ),
311 )
312 method_response_200_ret = dict(
313     responseModels={"application/json": "User"},
314     responseParameters={"method.response.header.Access-Control-Allow-Origin": False},
315     statusCode="200",
316 )
317 method_ret = dict(
318     apiKeyRequired=False,
319     authorizationType="None",
320     httpMethod="POST",
321     methodIntegration=method_integration_ret,
322     methodResponses={"200": method_response_200_ret},
323     requestModels={"application/json": "User"},
324     requestParameters={},
325 )
326 throttle_rateLimit = 10.0
327 association_stage_1 = {"apiId": "apiId1", "stage": "stage1"}
328 association_stage_2 = {"apiId": "apiId1", "stage": "stage2"}
329 log = logging.getLogger(__name__)
330 def _has_required_boto():
331     if not HAS_BOTO:
332         return False
333     elif LooseVersion(boto3.__version__) &lt; LooseVersion(required_boto3_version):
334         return False
335     else:
336         return True
337 def _has_required_botocore():
338     if not HAS_BOTO:
339         return False
340     elif LooseVersion(botocore.__version__) &lt; LooseVersion(required_botocore_version):
341         return False
342     else:
343         return True
344 class TempSwaggerFile:
345     _tmp_swagger_dict = {
346         "info": {
347             "version": "0.0.0",
348             "description": "salt boto apigateway unit test service",
349             "title": "salt boto apigateway unit test service",
350         },
351         "paths": {
352             "/users": {
353                 "post": {
354                     "responses": {
355                         "200": {
356                             "headers": {
357                                 "Access-Control-Allow-Origin": {"type": "string"}
358                             },
359                             "description": "The username of the new user",
360                             "schema": {"$ref": "#/definitions/User"},
361                         }
362                     },
363                     "parameters": [
364                         {
365                             "in": "body",
366                             "description": "New user details.",
367                             "name": "NewUser",
368                             "schema": {"$ref": "#/definitions/User"},
369                         }
370                     ],
371                     "produces": ["application/json"],
372                     "description": "Creates a new user.",
373                     "tags": ["Auth"],
374                     "consumes": ["application/json"],
375                     "summary": "Registers a new user",
376                 }
377             }
378         },
379         "schemes": ["https"],
380         "produces": ["application/json"],
381         "basePath": "/api",
382         "host": "rm06h9oac4.execute-api.us-west-2.amazonaws.com",
383         "definitions": {
384             "User": {
385                 "properties": {
386                     "username": {
387                         "type": "string",
388                         "description": "A unique username for the user",
389                     },
390                     "password": {
391                         "type": "string",
392                         "description": "A password for the new user",
393                     },
394                 }
395             },
396             "Error": {
397                 "properties": {
398                     "fields": {"type": "string"},
399                     "message": {"type": "string"},
400                     "code": {"type": "integer", "format": "int32"},
401                 }
402             },
403         },
404         "swagger": "2.0",
405     }
406     def __enter__(self):
407         self.swaggerfile = "temp-swagger-sample.yaml"
408         with salt.utils.files.fopen(self.swaggerfile, "w") as fp_:
409             salt.utils.yaml.safe_dump(self.swaggerdict, fp_, default_flow_style=False)
410         return self.swaggerfile
411     def __exit__(self, objtype, value, traceback):
412         os.remove(self.swaggerfile)
413 <a name="1"></a>
414     def __init__(self, create_invalid_file=False):
415         if create_invalid_file:
416             self.swaggerdict = TempSwaggerFile<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>._tmp_swagger_dict.copy()
417             self.swaggerdict["invalid_key"] = "invalid"
418             self.swaggerdict.pop("schemes", None)
419             self.swaggerdict["swagger"] = "3.0"
420             self.swaggerdict.pop("info", None)
421         else:
422             self.</b></font>swaggerdict = TempSwaggerFile._tmp_swagger_dict
423 class BotoApiGatewayStateTestCaseBase(TestCase, LoaderModuleMockMixin):
424     conn = None
425     @classmethod
426     def setUpClass(cls):
427         cls.opts = salt.config.DEFAULT_MINION_OPTS.copy()
428         cls.opts["grains"] = salt.loader.grains(cls.opts)
429     @classmethod
430     def tearDownClass(cls):
431         del cls.opts
432     def setup_loader_modules(self):
433         context = {}
434         utils = salt.loader.utils(
435             self.opts,
436             whitelist=["boto", "boto3", "args", "systemd", "path", "platform", "reg"],
437             context=context,
438         )
439         serializers = salt.loader.serializers(self.opts)
440         self.funcs = salt.loader.minion_mods(
441             self.opts, context=context, utils=utils, whitelist=["boto_apigateway"]
442         )
443         self.salt_states = salt.loader.states(
444             opts=self.opts,
445             functions=self.funcs,
446             utils=utils,
447             whitelist=["boto_apigateway"],
448             serializers=serializers,
449         )
450         return {
451             boto_apigateway: {
452                 "__opts__": self.opts,
453                 "__utils__": utils,
454                 "__salt__": self.funcs,
455                 "__states__": self.salt_states,
456                 "__serializers__": serializers,
457             }
458         }
459     def setUp(self):
460         self.addCleanup(delattr, self, "funcs")
461         self.addCleanup(delattr, self, "salt_states")
462         conn_parameters["key"] = "".join(
463             random.choice(string.ascii_lowercase + string.digits) for _ in range(50)
464         )
465         patcher = patch("boto3.session.Session")
466         self.addCleanup(patcher.stop)
467         mock_session = patcher.start()
468         session_instance = mock_session.return_value
469         self.conn = MagicMock()
470         self.addCleanup(delattr, self, "conn")
471         session_instance.client.return_value = self.conn
472 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
473 @skipIf(
474     _has_required_boto() is False,
475     "The boto3 module must be greater than or equal to version {}".format(
476         required_boto3_version
477     ),
478 )
479 class BotoApiGatewayTestCase(
480     BotoApiGatewayStateTestCaseBase, BotoApiGatewayTestCaseMixin
481 ):
482     def test_present_when_swagger_file_is_invalid(self):
483         result = {}
484         with TempSwaggerFile(create_invalid_file=True) as swagger_file:
485             result = self.salt_states["boto_apigateway.present"](
486                 "api present",
487                 "unit test api",
488                 swagger_file,
489                 "test",
490                 False,
491                 "arn:aws:iam::1234:role/apigatewayrole",
492                 **conn_parameters
493             )
494         self.assertFalse(result.get("result", True))
495     def test_present_when_stage_is_already_at_desired_deployment(self):
496         self.conn.get_rest_apis.return_value = apis_ret
497         self.conn.get_deployment.return_value = deployment1_ret
498         self.conn.get_stage.return_value = stage1_deployment1_ret
499         self.conn.update_stage.side_effect = ClientError(
500             error_content, "update_stage should not be called"
501         )
502         result = {}
503         with TempSwaggerFile() as swagger_file:
504             result = self.salt_states["boto_apigateway.present"](
505                 "api present",
506                 "unit test api",
507                 swagger_file,
508                 "test",
509                 False,
510                 "arn:aws:iam::1234:role/apigatewayrole",
511                 **conn_parameters
512             )
513         self.assertFalse(result.get("abort"))
514         self.assertTrue(result.get("current"))
515         self.assertIs(result.get("result"), True)
516         self.assertNotIn("update_stage should not be called", result.get("comment", ""))
517     def test_present_when_stage_is_already_at_desired_deployment_and_needs_stage_variables_update(
518         self,
519     ):
520         self.conn.get_rest_apis.return_value = apis_ret
521         self.conn.get_deployment.return_value = deployment1_ret
522         self.conn.get_stage.return_value = stage1_deployment1_ret
523         self.conn.update_stage.return_value = stage1_deployment1_vars_ret
524         result = {}
525         with TempSwaggerFile() as swagger_file:
526             result = self.salt_states["boto_apigateway.present"](
527                 "api present",
528                 "unit test api",
529                 swagger_file,
530                 "test",
531                 False,
532                 "arn:aws:iam::1234:role/apigatewayrole",
533                 stage_variables={"var1": "val1"},
534                 **conn_parameters
535             )
536         self.assertFalse(result.get("abort"))
537         self.assertTrue(result.get("current"))
538         self.assertIs(result.get("result"), True)
539     def test_present_when_stage_exists_and_is_to_associate_to_existing_deployment(self):
540         self.conn.get_rest_apis.return_value = apis_ret
541         self.conn.get_deployment.return_value = deployment2_ret
542         self.conn.get_deployments.return_value = deployments_ret
543         self.conn.get_stage.return_value = stage1_deployment2_ret
544         self.conn.update_stage.return_value = stage1_deployment1_ret
545         self.conn.create_stage.side_effect = ClientError(error_content, "create_stage")
546         self.conn.create_deployment.side_effect = ClientError(
547             error_content, "create_deployment"
548         )
549         result = {}
550         with TempSwaggerFile() as swagger_file:
551             result = self.salt_states["boto_apigateway.present"](
552                 "api present",
553                 "unit test api",
554                 swagger_file,
555                 "test",
556                 False,
557                 "arn:aws:iam::1234:role/apigatewayrole",
558                 **conn_parameters
559             )
560         self.assertTrue(result.get("publish"))
561         self.assertIs(result.get("result"), True)
562         self.assertFalse(result.get("abort"))
563         self.assertTrue(result.get("changes", {}).get("new", [{}])[0])
564     @pytest.mark.slow_test
565     def test_present_when_stage_is_to_associate_to_new_deployment(self):
566         self.conn.get_rest_apis.return_value = no_apis_ret
567         self.conn.create_rest_api.return_value = api_ret
568         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
569         self.conn.create_model.return_value = mock_model_ret
570         self.conn.get_resources.return_value = resources_ret
571         self.conn.create_resource.side_effect = ClientError(
572             error_content, "create_resource"
573         )
574         self.conn.put_method.return_value = method_ret
575         self.conn.put_integration.return_value = method_integration_ret
576         self.conn.put_method_response.return_value = method_response_200_ret
577         self.conn.put_intgration_response.return_value = (
578             method_integration_response_200_ret
579         )
580         result = {}
581         with patch.dict(
582             self.funcs,
583             {
584                 "boto_lambda.describe_function": MagicMock(
585                     return_value={"function": function_ret}
586                 )
587             },
588         ):
589             with TempSwaggerFile() as swagger_file:
590                 result = self.salt_states["boto_apigateway.present"](
591                     "api present",
592                     "unit test api",
593                     swagger_file,
594                     "test",
595                     False,
596                     "arn:aws:iam::1234:role/apigatewayrole",
597                     **conn_parameters
598                 )
599         self.assertIs(result.get("result"), True)
600         self.assertIs(result.get("abort"), None)
601     def test_present_when_stage_associating_to_new_deployment_errored_on_api_creation(
602         self,
603     ):
604         self.conn.get_rest_apis.return_value = no_apis_ret
605         self.conn.create_rest_api.side_effect = ClientError(
606             error_content, "create_rest_api"
607         )
608         result = {}
609         with TempSwaggerFile() as swagger_file:
610             result = self.salt_states["boto_apigateway.present"](
611                 "api present",
612                 "unit test api",
613                 swagger_file,
614                 "test",
615                 False,
616                 "arn:aws:iam::1234:role/apigatewayrole",
617                 **conn_parameters
618             )
619         self.assertIs(result.get("abort"), True)
620         self.assertIs(result.get("result"), False)
621         self.assertIn("create_rest_api", result.get("comment", ""))
622     def test_present_when_stage_associating_to_new_deployment_errored_on_model_creation(
623         self,
624     ):
625         self.conn.get_rest_apis.return_value = no_apis_ret
626         self.conn.create_rest_api.return_value = api_ret
627         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
628         self.conn.create_model.side_effect = ClientError(error_content, "create_model")
629         result = {}
630         with TempSwaggerFile() as swagger_file:
631             result = self.salt_states["boto_apigateway.present"](
632                 "api present",
633                 "unit test api",
634                 swagger_file,
635                 "test",
636                 False,
637                 "arn:aws:iam::1234:role/apigatewayrole",
638                 **conn_parameters
639             )
640         self.assertIs(result.get("abort"), True)
641         self.assertIs(result.get("result"), False)
642         self.assertIn("create_model", result.get("comment", ""))
643     def test_present_when_stage_associating_to_new_deployment_errored_on_resource_creation(
644         self,
645     ):
646         self.conn.get_rest_apis.return_value = no_apis_ret
647         self.conn.create_rest_api.return_value = api_ret
648         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
649         self.conn.create_model.return_value = mock_model_ret
650         self.conn.get_resources.return_value = root_resources_ret
651         self.conn.create_resource.side_effect = ClientError(
652             error_content, "create_resource"
653         )
654         result = {}
655         with TempSwaggerFile() as swagger_file:
656             result = self.salt_states["boto_apigateway.present"](
657                 "api present",
658                 "unit test api",
659                 swagger_file,
660                 "test",
661                 False,
662                 "arn:aws:iam::1234:role/apigatewayrole",
663                 **conn_parameters
664             )
665         self.assertIs(result.get("abort"), True)
666         self.assertIs(result.get("result"), False)
667         self.assertIn("create_resource", result.get("comment", ""))
668     @pytest.mark.slow_test
669     def test_present_when_stage_associating_to_new_deployment_errored_on_put_method(
670         self,
671     ):
672         self.conn.get_rest_apis.return_value = no_apis_ret
673         self.conn.create_rest_api.return_value = api_ret
674         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
675         self.conn.create_model.return_value = mock_model_ret
676         self.conn.get_resources.return_value = resources_ret
677         self.conn.create_resource.side_effect = ClientError(
678             error_content, "create_resource"
679         )
680         self.conn.put_method.side_effect = ClientError(error_content, "put_method")
681         result = {}
682         with patch.dict(
683             self.funcs,
684             {
685                 "boto_lambda.describe_function": MagicMock(
686                     return_value={"function": function_ret}
687                 )
688             },
689         ):
690             with TempSwaggerFile() as swagger_file:
691                 result = self.salt_states["boto_apigateway.present"](
692                     "api present",
693                     "unit test api",
694                     swagger_file,
695                     "test",
696                     False,
697                     "arn:aws:iam::1234:role/apigatewayrole",
698                     **conn_parameters
699                 )
700         self.assertIs(result.get("abort"), True)
701         self.assertIs(result.get("result"), False)
702         self.assertIn("put_method", result.get("comment", ""))
703     @pytest.mark.slow_test
704     def test_present_when_stage_associating_to_new_deployment_errored_on_lambda_function_lookup(
705         self,
706     ):
707         self.conn.get_rest_apis.return_value = no_apis_ret
708         self.conn.create_rest_api.return_value = api_ret
709         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
710         self.conn.create_model.return_value = mock_model_ret
711         self.conn.get_resources.return_value = resources_ret
712         self.conn.create_resource.side_effect = ClientError(
713             error_content, "create_resource"
714         )
715         self.conn.put_method.return_value = method_ret
716         self.conn.put_integration.side_effect = ClientError(
717             error_content, "put_integration should not be invoked"
718         )
719         result = {}
720         with patch.dict(
721             self.funcs,
722             {
723                 "boto_lambda.describe_function": MagicMock(
724                     return_value={"error": "no such lambda"}
725                 )
726             },
727         ):
728             with TempSwaggerFile() as swagger_file:
729                 result = self.salt_states["boto_apigateway.present"](
730                     "api present",
731                     "unit test api",
732                     swagger_file,
733                     "test",
734                     False,
735                     "arn:aws:iam::1234:role/apigatewayrole",
736                     **conn_parameters
737                 )
738         self.assertIs(result.get("result"), False)
739         self.assertNotIn(
740             "put_integration should not be invoked", result.get("comment", "")
741         )
742         self.assertIn("not find lambda function", result.get("comment", ""))
743     @pytest.mark.slow_test
744     def test_present_when_stage_associating_to_new_deployment_errored_on_put_integration(
745         self,
746     ):
747         self.conn.get_rest_apis.return_value = no_apis_ret
748         self.conn.create_rest_api.return_value = api_ret
749         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
750         self.conn.create_model.return_value = mock_model_ret
751         self.conn.get_resources.return_value = resources_ret
752         self.conn.create_resource.side_effect = ClientError(
753             error_content, "create_resource"
754         )
755         self.conn.put_method.return_value = method_ret
756         self.conn.put_integration.side_effect = ClientError(
757             error_content, "put_integration"
758         )
759         result = {}
760         with patch.dict(
761             self.funcs,
762             {
763                 "boto_lambda.describe_function": MagicMock(
764                     return_value={"function": function_ret}
765                 )
766             },
767         ):
768             with TempSwaggerFile() as swagger_file:
769                 result = self.salt_states["boto_apigateway.present"](
770                     "api present",
771                     "unit test api",
772                     swagger_file,
773                     "test",
774                     False,
775                     "arn:aws:iam::1234:role/apigatewayrole",
776                     **conn_parameters
777                 )
778         self.assertIs(result.get("abort"), True)
779         self.assertIs(result.get("result"), False)
780         self.assertIn("put_integration", result.get("comment", ""))
781     @pytest.mark.slow_test
782     def test_present_when_stage_associating_to_new_deployment_errored_on_put_method_response(
783         self,
784     ):
785         self.conn.get_rest_apis.return_value = no_apis_ret
786         self.conn.create_rest_api.return_value = api_ret
787         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
788         self.conn.create_model.return_value = mock_model_ret
789         self.conn.get_resources.return_value = resources_ret
790         self.conn.create_resource.side_effect = ClientError(
791             error_content, "create_resource"
792         )
793         self.conn.put_method.return_value = method_ret
794         self.conn.put_integration.return_value = method_integration_ret
795         self.conn.put_method_response.side_effect = ClientError(
796             error_content, "put_method_response"
797         )
798         result = {}
799         with patch.dict(
800             self.funcs,
801             {
802                 "boto_lambda.describe_function": MagicMock(
803                     return_value={"function": function_ret}
804                 )
805             },
806         ):
807             with TempSwaggerFile() as swagger_file:
808                 result = self.salt_states["boto_apigateway.present"](
809                     "api present",
810                     "unit test api",
811                     swagger_file,
812                     "test",
813                     False,
814                     "arn:aws:iam::1234:role/apigatewayrole",
815                     **conn_parameters
816                 )
817         self.assertIs(result.get("abort"), True)
818         self.assertIs(result.get("result"), False)
819         self.assertIn("put_method_response", result.get("comment", ""))
820     @pytest.mark.slow_test
821     def test_present_when_stage_associating_to_new_deployment_errored_on_put_integration_response(
822         self,
823     ):
824         self.conn.get_rest_apis.return_value = no_apis_ret
825         self.conn.create_rest_api.return_value = api_ret
826         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
827         self.conn.create_model.return_value = mock_model_ret
828         self.conn.get_resources.return_value = resources_ret
829         self.conn.create_resource.side_effect = ClientError(
830             error_content, "create_resource"
831         )
832         self.conn.put_method.return_value = method_ret
833         self.conn.put_integration.return_value = method_integration_ret
834         self.conn.put_method_response.return_value = method_response_200_ret
835         self.conn.put_integration_response.side_effect = ClientError(
836             error_content, "put_integration_response"
837         )
838         result = {}
839         with patch.dict(
840             self.funcs,
841             {
842                 "boto_lambda.describe_function": MagicMock(
843                     return_value={"function": function_ret}
844                 )
845             },
846         ):
847             with TempSwaggerFile() as swagger_file:
848                 result = self.salt_states["boto_apigateway.present"](
849                     "api present",
850                     "unit test api",
851                     swagger_file,
852                     "test",
853                     False,
854                     "arn:aws:iam::1234:role/apigatewayrole",
855                     **conn_parameters
856                 )
857         self.assertIs(result.get("abort"), True)
858         self.assertIs(result.get("result"), False)
859         self.assertIn("put_integration_response", result.get("comment", ""))
860     def test_absent_when_rest_api_does_not_exist(self):
861         self.conn.get_rest_apis.return_value = apis_ret
862         self.conn.get_stage.side_effect = ClientError(
863             error_content, "get_stage should not be called"
864         )
865         result = self.salt_states["boto_apigateway.absent"](
866             "api present",
867             "no_such_rest_api",
868             "no_such_stage",
869             nuke_api=False,
870             **conn_parameters
871         )
872         self.assertIs(result.get("result"), True)
873         self.assertNotIn("get_stage should not be called", result.get("comment", ""))
874         self.assertEqual(result.get("changes"), {})
875     def test_absent_when_stage_is_invalid(self):
876         self.conn.get_rest_apis.return_value = apis_ret
877         self.conn.get_stage.return_value = stage1_deployment1_ret
878         self.conn.delete_stage.side_effect = ClientError(error_content, "delete_stage")
879         result = self.salt_states["boto_apigateway.absent"](
880             "api present",
881             "unit test api",
882             "no_such_stage",
883             nuke_api=False,
884             **conn_parameters
885         )
886         self.assertTrue(result.get("abort", False))
887     def test_absent_when_stage_is_valid_and_only_one_stage_is_associated_to_deployment(
888         self,
889     ):
890         self.conn.get_rest_apis.return_value = apis_ret
891         self.conn.get_stage.return_value = stage1_deployment1_ret
892         self.conn.delete_stage.return_value = {
893             "ResponseMetadata": {
894                 "HTTPStatusCode": 200,
895                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
896             }
897         }
898         self.conn.get_stages.return_value = no_stages_ret
899         self.conn.delete_deployment.return_value = {
900             "ResponseMetadata": {
901                 "HTTPStatusCode": 200,
902                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
903             }
904         }
905         result = self.salt_states["boto_apigateway.absent"](
906             "api present", "unit test api", "test", nuke_api=False, **conn_parameters
907         )
908         self.assertTrue(result.get("result", False))
909     def test_absent_when_stage_is_valid_and_two_stages_are_associated_to_deployment(
910         self,
911     ):
912         self.conn.get_rest_apis.return_value = apis_ret
913         self.conn.get_stage.return_value = stage1_deployment1_ret
914         self.conn.delete_stage.return_value = {
915             "ResponseMetadata": {
916                 "HTTPStatusCode": 200,
917                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
918             }
919         }
920         self.conn.get_stages.return_value = stages_stage2_ret
921         result = self.salt_states["boto_apigateway.absent"](
922             "api present", "unit test api", "test", nuke_api=False, **conn_parameters
923         )
924         self.assertTrue(result.get("result", False))
925     def test_absent_when_failing_to_delete_a_deployment_no_longer_associated_with_any_stages(
926         self,
927     ):
928         self.conn.get_rest_apis.return_value = apis_ret
929         self.conn.get_stage.return_value = stage1_deployment1_ret
930         self.conn.delete_stage.return_value = {
931             "ResponseMetadata": {
932                 "HTTPStatusCode": 200,
933                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
934             }
935         }
936         self.conn.get_stages.return_value = no_stages_ret
937         self.conn.delete_deployment.side_effect = ClientError(
938             error_content, "delete_deployment"
939         )
940         result = self.salt_states["boto_apigateway.absent"](
941             "api present", "unit test api", "test", nuke_api=False, **conn_parameters
942         )
943         self.assertTrue(result.get("abort", False))
944     def test_absent_when_nuke_api_and_no_more_stages_deployments_remain(self):
945         self.conn.get_rest_apis.return_value = apis_ret
946         self.conn.get_stage.return_value = stage1_deployment1_ret
947         self.conn.delete_stage.return_value = {
948             "ResponseMetadata": {
949                 "HTTPStatusCode": 200,
950                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
951             }
952         }
953         self.conn.get_stages.return_value = no_stages_ret
954         self.conn.get_deployments.return_value = deployments_ret
955         self.conn.delete_rest_api.return_value = {
956             "ResponseMetadata": {
957                 "HTTPStatusCode": 200,
958                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
959             }
960         }
961         result = self.salt_states["boto_apigateway.absent"](
962             "api present", "unit test api", "test", nuke_api=True, **conn_parameters
963         )
964         self.assertIs(result.get("result"), True)
965         self.assertIsNot(result.get("abort"), True)
966         self.assertIs(
967             result.get("changes", {})
968             .get("new", [{}])[0]
969             .get("delete_api", {})
970             .get("deleted"),
971             True,
972         )
973     def test_absent_when_nuke_api_and_other_stages_deployments_exist(self):
974         self.conn.get_rest_apis.return_value = apis_ret
975         self.conn.get_stage.return_value = stage1_deployment1_ret
976         self.conn.delete_stage.return_value = {
977             "ResponseMetadata": {
978                 "HTTPStatusCode": 200,
979                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
980             }
981         }
982         self.conn.get_stages.return_value = stages_stage2_ret
983         self.conn.get_deployments.return_value = deployments_ret
984         self.conn.delete_rest_api.side_effect = ClientError(
985             error_content, "unexpected_api_delete"
986         )
987         result = self.salt_states["boto_apigateway.absent"](
988             "api present", "unit test api", "test", nuke_api=True, **conn_parameters
989         )
990         self.assertIs(result.get("result"), True)
991         self.assertIsNot(result.get("abort"), True)
992 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
993 @skipIf(
994     _has_required_boto() is False,
995     "The boto3 module must be greater than or equal to version {}".format(
996         required_boto3_version
997     ),
998 )
999 @skipIf(
1000     _has_required_botocore() is False,
1001     "The botocore module must be greater than or equal to version {}".format(
1002         required_botocore_version
1003     ),
1004 )
1005 class BotoApiGatewayUsagePlanTestCase(
1006     BotoApiGatewayStateTestCaseBase, BotoApiGatewayTestCaseMixin
1007 ):
1008     @pytest.mark.slow_test
1009     def test_usage_plan_present_if_describe_fails(self, *args):
1010         with patch.dict(
1011             boto_apigateway.__salt__,
1012             {
1013                 "boto_apigateway.describe_usage_plans": MagicMock(
1014                     return_value={"error": "error"}
1015                 )
1016             },
1017         ):
1018             result = boto_apigateway.usage_plan_present(
1019                 "name", "plan_name", **conn_parameters
1020             )
1021             self.assertIn("result", result)
1022             self.assertEqual(result["result"], False)
1023             self.assertIn("comment", result)
1024             self.assertEqual(
1025                 result["comment"], "Failed to describe existing usage plans"
1026             )
1027             self.assertIn("changes", result)
1028             self.assertEqual(result["changes"], {})
1029     @pytest.mark.slow_test
1030     def test_usage_plan_present_if_there_is_no_such_plan_and_test_option_is_set(
1031         self, *args
1032     ):
1033         with patch.dict(boto_apigateway.__opts__, {"test": True}):
1034             with patch.dict(
1035                 boto_apigateway.__salt__,
1036                 {
1037                     "boto_apigateway.describe_usage_plans": MagicMock(
1038                         return_value={"plans": []}
1039                     )
1040                 },
1041             ):
1042                 result = boto_apigateway.usage_plan_present(
1043                     "name", "plan_name", **conn_parameters
1044                 )
1045                 self.assertIn("comment", result)
1046                 self.assertEqual(
1047                     result["comment"], "a new usage plan plan_name would be created"
1048                 )
1049                 self.assertIn("result", result)
1050                 self.assertEqual(result["result"], None)
1051     @pytest.mark.slow_test
1052     def test_usage_plan_present_if_create_usage_plan_fails(self, *args):
1053         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1054             with patch.dict(
1055                 boto_apigateway.__salt__,
1056                 {
1057                     "boto_apigateway.describe_usage_plans": MagicMock(
1058                         return_value={"plans": []}
1059                     ),
1060                     "boto_apigateway.create_usage_plan": MagicMock(
1061                         return_value={"error": "error"}
1062                     ),
1063                 },
1064             ):
1065                 result = boto_apigateway.usage_plan_present(
1066                     "name", "plan_name", **conn_parameters
1067                 )
1068                 self.assertIn("result", result)
1069                 self.assertEqual(result["result"], False)
1070                 self.assertIn("comment", result)
1071                 self.assertEqual(
1072                     result["comment"], "Failed to create a usage plan plan_name, error"
1073                 )
1074                 self.assertIn("changes", result)
1075                 self.assertEqual(result["changes"], {})
1076     @pytest.mark.slow_test
1077     def test_usage_plan_present_if_plan_is_there_and_needs_no_updates(self, *args):
1078         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1079             with patch.dict(
1080                 boto_apigateway.__salt__,
1081                 {
1082                     "boto_apigateway.describe_usage_plans": MagicMock(
1083                         return_value={"plans": [{"id": "planid", "name": "planname"}]}
1084                     ),
1085                     "boto_apigateway.update_usage_plan": MagicMock(),
1086                 },
1087             ):
1088                 result = boto_apigateway.usage_plan_present(
1089                     "name", "plan_name", **conn_parameters
1090                 )
1091                 self.assertIn("result", result)
1092                 self.assertEqual(result["result"], True)
1093                 self.assertIn("comment", result)
1094                 self.assertEqual(
1095                     result["comment"],
1096                     "usage plan plan_name is already in a correct state",
1097                 )
1098                 self.assertIn("changes", result)
1099                 self.assertEqual(result["changes"], {})
1100                 self.assertTrue(
1101                     boto_apigateway.__salt__[
1102                         "boto_apigateway.update_usage_plan"
1103                     ].call_count
1104                     == 0
1105                 )
1106     @pytest.mark.slow_test
1107     def test_usage_plan_present_if_plan_is_there_and_needs_updates_but_test_is_set(
1108         self, *args
1109     ):
1110         with patch.dict(boto_apigateway.__opts__, {"test": True}):
1111             with patch.dict(
1112                 boto_apigateway.__salt__,
1113                 {
1114                     "boto_apigateway.describe_usage_plans": MagicMock(
1115                         return_value={
1116                             "plans": [
1117                                 {
1118                                     "id": "planid",
1119                                     "name": "planname",
1120                                     "throttle": {"rateLimit": 10.0},
1121                                 }
1122                             ]
1123                         }
1124                     ),
1125                     "boto_apigateway.update_usage_plan": MagicMock(),
1126                 },
1127             ):
1128                 result = boto_apigateway.usage_plan_present(
1129                     "name", "plan_name", **conn_parameters
1130                 )
1131                 self.assertIn("comment", result)
1132                 self.assertEqual(
1133                     result["comment"], "a new usage plan plan_name would be updated"
1134                 )
1135                 self.assertIn("result", result)
1136                 self.assertEqual(result["result"], None)
1137                 self.assertTrue(
1138                     boto_apigateway.__salt__[
1139                         "boto_apigateway.update_usage_plan"
1140                     ].call_count
1141                     == 0
1142                 )
1143     @pytest.mark.slow_test
1144     def test_usage_plan_present_if_plan_is_there_and_needs_updates_but_update_fails(
1145         self, *args
1146     ):
1147         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1148             with patch.dict(
1149                 boto_apigateway.__salt__,
1150                 {
1151                     "boto_apigateway.describe_usage_plans": MagicMock(
1152                         return_value={
1153                             "plans": [
1154                                 {
1155                                     "id": "planid",
1156                                     "name": "planname",
1157                                     "throttle": {"rateLimit": 10.0},
1158                                 }
1159                             ]
1160                         }
1161                     ),
1162                     "boto_apigateway.update_usage_plan": MagicMock(
1163                         return_value={"error": "error"}
1164                     ),
1165                 },
1166             ):
1167                 result = boto_apigateway.usage_plan_present(
1168                     "name", "plan_name", **conn_parameters
1169                 )
1170                 self.assertIn("result", result)
1171                 self.assertEqual(result["result"], False)
1172                 self.assertIn("comment", result)
1173                 self.assertEqual(
1174                     result["comment"], "Failed to update a usage plan plan_name, error"
1175                 )
1176     @pytest.mark.slow_test
1177     def test_usage_plan_present_if_plan_has_been_created(self, *args):
1178         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1179             with patch.dict(
1180                 boto_apigateway.__salt__,
1181                 {
1182                     "boto_apigateway.describe_usage_plans": MagicMock(
1183                         side_effect=[{"plans": []}, {"plans": [{"id": "id"}]}]
1184                     ),
1185                     "boto_apigateway.create_usage_plan": MagicMock(
1186                         return_value={"created": True}
1187                     ),
1188                 },
1189             ):
1190                 result = boto_apigateway.usage_plan_present(
1191                     "name", "plan_name", **conn_parameters
1192                 )
1193 <a name="2"></a>                self.assertIn("result", result)
1194                 self.assertEqual(result["result"], True)
1195                 self.assertIn("comment", result)
1196                 self<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertEqual(
1197                     result["comment"], "A new usage plan plan_name has been created"
1198                 )
1199                 self.assertEqual(result["changes"]["old"], {"plan": None})
1200                 self.assertEqual(result["changes"]["new"], {"plan": {"id"</b></font>: "id"}})
1201     @pytest.mark.slow_test
1202     def test_usage_plan_present_if_plan_has_been_updated(self, *args):
1203         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1204             with patch<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.dict(
1205                 boto_apigateway.__salt__,
1206                 {
1207                     "boto_apigateway.describe_usage_plans": MagicMock(
1208                         side_effect=[
1209                             {"plans": [{"id": "id"}]},
1210                             {
1211                                 "plans": [
1212                                     {
1213                                         "id": "id",
1214                                         "throttle": {"rateLimit": throttle_rateLimit},
1215                                     }
1216                                 ]
1217                             },
1218                         ]
1219                     ),
1220                     "boto_apigateway.update_usage_plan": MagicMock(</b></font>
1221                         return_value={"updated": True}
1222                     ),
1223                 },
1224             ):
1225                 result = boto_apigateway.usage_plan_present(
1226                     "name",
1227                     "plan_name",
1228                     throttle={"rateLimit": throttle_rateLimit},
1229                     **conn_parameters
1230                 )
1231 <a name="0"></a>                self.assertIn("result", result)
1232                 self.assertEqual(result["result"], True)
1233                 self.assertIn("comment", result)
1234                 self<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertEqual(
1235                     result["comment"], "usage plan plan_name has been updated"
1236                 )
1237                 self.assertEqual(result["changes"]["old"], {"plan": {"id": "id"}})
1238                 self.assertEqual(
1239                     result["changes"]["new"],
1240                     {
1241                         "plan": {
1242                             "id": "id",
1243                             "throttle": {"rateLimit"</b></font>: throttle_rateLimit},
1244                         }
1245                     },
1246                 )
1247     @pytest.mark.slow_test
1248     def test_usage_plan_present_if_ValueError_is_raised(self, *args):
1249         with patch.dict(
1250             boto_apigateway.__salt__,
1251             {
1252                 "boto_apigateway.describe_usage_plans": MagicMock(
1253                     side_effect=ValueError("error")
1254                 )
1255             },
1256         ):
1257             result = boto_apigateway.usage_plan_present(
1258                 "name",
1259                 "plan_name",
1260                 throttle={"rateLimit": throttle_rateLimit},
1261                 **conn_parameters
1262             )
1263             self.assertIn("result", result)
1264             self.assertEqual(result["result"], False)
1265             self.assertIn("comment", result)
1266             self.assertEqual(result["comment"], repr(("error",)))
1267     @pytest.mark.slow_test
1268     def test_usage_plan_present_if_IOError_is_raised(self, *args):
1269         with patch.dict(
1270             boto_apigateway.__salt__,
1271             {
1272                 "boto_apigateway.describe_usage_plans": MagicMock(
1273                     side_effect=IOError("error")
1274                 )
1275             },
1276         ):
1277             result = boto_apigateway.usage_plan_present(
1278                 "name",
1279                 "plan_name",
1280                 throttle={"rateLimit": throttle_rateLimit},
1281                 **conn_parameters
1282             )
1283             self.assertIn("result", result)
1284             self.assertEqual(result["result"], False)
1285             self.assertIn("comment", result)
1286             self.assertEqual(result["comment"], repr(("error",)))
1287     @pytest.mark.slow_test
1288     def test_usage_plan_absent_if_describe_fails(self, *args):
1289         with patch.dict(
1290             boto_apigateway.__salt__,
1291             {
1292                 "boto_apigateway.describe_usage_plans": MagicMock(
1293                     return_value={"error": "error"}
1294                 )
1295             },
1296         ):
1297             result = {}
1298             result = boto_apigateway.usage_plan_absent(
1299                 "name", "plan_name", **conn_parameters
1300             )
1301             self.assertIn("result", result)
1302             self.assertEqual(result["result"], False)
1303             self.assertIn("comment", result)
1304             self.assertEqual(
1305                 result["comment"], "Failed to describe existing usage plans"
1306             )
1307             self.assertIn("changes", result)
1308             self.assertEqual(result["changes"], {})
1309     @pytest.mark.slow_test
1310     def test_usage_plan_absent_if_plan_is_not_present(self, *args):
1311         with patch.dict(
1312             boto_apigateway.__salt__,
1313             {
1314                 "boto_apigateway.describe_usage_plans": MagicMock(
1315                     return_value={"plans": []}
1316                 )
1317             },
1318         ):
1319             result = {}
1320             result = boto_apigateway.usage_plan_absent(
1321                 "name", "plan_name", **conn_parameters
1322             )
1323             self.assertIn("result", result)
1324             self.assertEqual(result["result"], True)
1325             self.assertIn("comment", result)
1326             self.assertEqual(
1327                 result["comment"], "Usage plan plan_name does not exist already"
1328             )
1329             self.assertIn("changes", result)
1330             self.assertEqual(result["changes"], {})
1331     @pytest.mark.slow_test
1332     def test_usage_plan_absent_if_plan_is_present_but_test_option_is_set(self, *args):
1333         with patch.dict(boto_apigateway.__opts__, {"test": True}):
1334             with patch.dict(
1335                 boto_apigateway.__salt__,
1336                 {
1337                     "boto_apigateway.describe_usage_plans": MagicMock(
1338                         return_value={"plans": [{"id": "id"}]}
1339                     )
1340                 },
1341             ):
1342                 result = {}
1343                 result = boto_apigateway.usage_plan_absent(
1344                     "name", "plan_name", **conn_parameters
1345                 )
1346                 self.assertIn("result", result)
1347                 self.assertEqual(result["result"], None)
1348                 self.assertIn("comment", result)
1349                 self.assertEqual(
1350                     result["comment"],
1351                     "Usage plan plan_name exists and would be deleted",
1352                 )
1353                 self.assertIn("changes", result)
1354                 self.assertEqual(result["changes"], {})
1355     @pytest.mark.slow_test
1356     def test_usage_plan_absent_if_plan_is_present_but_delete_fails(self, *args):
1357         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1358             with patch.dict(
1359                 boto_apigateway.__salt__,
1360                 {
1361                     "boto_apigateway.describe_usage_plans": MagicMock(
1362                         return_value={"plans": [{"id": "id"}]}
1363                     ),
1364                     "boto_apigateway.delete_usage_plan": MagicMock(
1365                         return_value={"error": "error"}
1366                     ),
1367                 },
1368             ):
1369                 result = boto_apigateway.usage_plan_absent(
1370                     "name", "plan_name", **conn_parameters
1371                 )
1372                 self.assertIn("result", result)
1373                 self.assertEqual(result["result"], False)
1374                 self.assertIn("comment", result)
1375                 self.assertEqual(
1376                     result["comment"],
1377                     "Failed to delete usage plan plan_name, "
1378                     + repr({"error": "error"}),
1379                 )
1380                 self.assertIn("changes", result)
1381                 self.assertEqual(result["changes"], {})
1382     @pytest.mark.slow_test
1383     def test_usage_plan_absent_if_plan_has_been_deleted(self, *args):
1384         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1385             with patch.dict(
1386                 boto_apigateway.__salt__,
1387                 {
1388                     "boto_apigateway.describe_usage_plans": MagicMock(
1389                         return_value={"plans": [{"id": "id"}]}
1390                     ),
1391                     "boto_apigateway.delete_usage_plan": MagicMock(
1392                         return_value={"deleted": True}
1393                     ),
1394                 },
1395             ):
1396                 result = boto_apigateway.usage_plan_absent(
1397                     "name", "plan_name", **conn_parameters
1398                 )
1399                 self.assertIn("result", result)
1400                 self.assertEqual(result["result"], True)
1401                 self.assertIn("comment", result)
1402                 self.assertEqual(
1403                     result["comment"], "Usage plan plan_name has been deleted"
1404                 )
1405                 self.assertIn("changes", result)
1406                 self.assertEqual(
1407                     result["changes"],
1408                     {"new": {"plan": None}, "old": {"plan": {"id": "id"}}},
1409                 )
1410     @pytest.mark.slow_test
1411     def test_usage_plan_absent_if_ValueError_is_raised(self, *args):
1412         with patch.dict(
1413             boto_apigateway.__salt__,
1414             {
1415                 "boto_apigateway.describe_usage_plans": MagicMock(
1416                     side_effect=ValueError("error")
1417                 )
1418             },
1419         ):
1420             result = boto_apigateway.usage_plan_absent(
1421                 "name", "plan_name", **conn_parameters
1422             )
1423             self.assertIn("result", result)
1424             self.assertEqual(result["result"], False)
1425             self.assertIn("comment", result)
1426             self.assertEqual(result["comment"], repr(("error",)))
1427     @pytest.mark.slow_test
1428     def test_usage_plan_absent_if_IOError_is_raised(self, *args):
1429         with patch.dict(
1430             boto_apigateway.__salt__,
1431             {
1432                 "boto_apigateway.describe_usage_plans": MagicMock(
1433                     side_effect=IOError("error")
1434                 )
1435             },
1436         ):
1437             result = boto_apigateway.usage_plan_absent(
1438                 "name", "plan_name", **conn_parameters
1439             )
1440             self.assertIn("result", result)
1441             self.assertEqual(result["result"], False)
1442             self.assertIn("comment", result)
1443             self.assertEqual(result["comment"], repr(("error",)))
1444 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
1445 @skipIf(
1446     _has_required_boto() is False,
1447     "The boto3 module must be greater than or equal to version {}".format(
1448         required_boto3_version
1449     ),
1450 )
1451 @skipIf(
1452     _has_required_botocore() is False,
1453     "The botocore module must be greater than or equal to version {}".format(
1454         required_botocore_version
1455     ),
1456 )
1457 class BotoApiGatewayUsagePlanAssociationTestCase(
1458     BotoApiGatewayStateTestCaseBase, BotoApiGatewayTestCaseMixin
1459 ):
1460     @pytest.mark.slow_test
1461     def test_usage_plan_association_present_if_describe_fails(self, *args):
1462         with patch.dict(
1463             boto_apigateway.__salt__,
1464             {
1465                 "boto_apigateway.describe_usage_plans": MagicMock(
1466                     return_value={"error": "error"}
1467                 )
1468             },
1469         ):
1470             result = boto_apigateway.usage_plan_association_present(
1471                 "name", "plan_name", [association_stage_1], **conn_parameters
1472             )
1473             self.assertIn("result", result)
1474             self.assertEqual(result["result"], False)
1475             self.assertIn("comment", result)
1476             self.assertEqual(
1477                 result["comment"], "Failed to describe existing usage plans"
1478             )
1479             self.assertIn("changes", result)
1480             self.assertEqual(result["changes"], {})
1481     @pytest.mark.slow_test
1482     def test_usage_plan_association_present_if_plan_is_not_present(self, *args):
1483         with patch.dict(
1484             boto_apigateway.__salt__,
1485             {
1486                 "boto_apigateway.describe_usage_plans": MagicMock(
1487                     return_value={"plans": []}
1488                 )
1489             },
1490         ):
1491             result = boto_apigateway.usage_plan_association_present(
1492                 "name", "plan_name", [association_stage_1], **conn_parameters
1493             )
1494             self.assertIn("result", result)
1495             self.assertEqual(result["result"], False)
1496             self.assertIn("comment", result)
1497             self.assertEqual(result["comment"], "Usage plan plan_name does not exist")
1498             self.assertIn("changes", result)
1499             self.assertEqual(result["changes"], {})
1500     @pytest.mark.slow_test
1501     def test_usage_plan_association_present_if_multiple_plans_with_the_same_name_exist(
1502         self, *args
1503     ):
1504         with patch.dict(
1505             boto_apigateway.__salt__,
1506             {
1507                 "boto_apigateway.describe_usage_plans": MagicMock(
1508                     return_value={"plans": [{"id": "id1"}, {"id": "id2"}]}
1509                 )
1510             },
1511         ):
1512             result = boto_apigateway.usage_plan_association_present(
1513                 "name", "plan_name", [association_stage_1], **conn_parameters
1514             )
1515             self.assertIn("result", result)
1516             self.assertEqual(result["result"], False)
1517             self.assertIn("comment", result)
1518             self.assertEqual(
1519                 result["comment"],
1520                 "There are multiple usage plans with the same name - it is not"
1521                 " supported",
1522             )
1523             self.assertIn("changes", result)
1524             self.assertEqual(result["changes"], {})
1525     @pytest.mark.slow_test
1526     def test_usage_plan_association_present_if_association_already_exists(self, *args):
1527         with patch.dict(
1528             boto_apigateway.__salt__,
1529             {
1530                 "boto_apigateway.describe_usage_plans": MagicMock(
1531                     return_value={
1532                         "plans": [{"id": "id1", "apiStages": [association_stage_1]}]
1533                     }
1534                 )
1535             },
1536         ):
1537             result = boto_apigateway.usage_plan_association_present(
1538                 "name", "plan_name", [association_stage_1], **conn_parameters
1539             )
1540             self.assertIn("result", result)
1541             self.assertEqual(result["result"], True)
1542             self.assertIn("comment", result)
1543             self.assertEqual(
1544                 result["comment"], "Usage plan is already asssociated to all api stages"
1545             )
1546             self.assertIn("changes", result)
1547             self.assertEqual(result["changes"], {})
1548     @pytest.mark.slow_test
1549     def test_usage_plan_association_present_if_update_fails(self, *args):
1550         with patch.dict(
1551             boto_apigateway.__salt__,
1552             {
1553                 "boto_apigateway.describe_usage_plans": MagicMock(
1554                     return_value={
1555                         "plans": [{"id": "id1", "apiStages": [association_stage_1]}]
1556                     }
1557                 ),
1558                 "boto_apigateway.attach_usage_plan_to_apis": MagicMock(
1559                     return_value={"error": "error"}
1560                 ),
1561             },
1562         ):
1563             result = boto_apigateway.usage_plan_association_present(
1564                 "name", "plan_name", [association_stage_2], **conn_parameters
1565             )
1566             self.assertIn("result", result)
1567             self.assertEqual(result["result"], False)
1568             self.assertIn("comment", result)
1569             self.assertTrue(
1570                 result["comment"].startswith("Failed to associate a usage plan")
1571             )
1572             self.assertIn("changes", result)
1573             self.assertEqual(result["changes"], {})
1574     @pytest.mark.slow_test
1575     def test_usage_plan_association_present_success(self, *args):
1576         with patch.dict(
1577             boto_apigateway.__salt__,
1578             {
1579                 "boto_apigateway.describe_usage_plans": MagicMock(
1580                     return_value={
1581                         "plans": [{"id": "id1", "apiStages": [association_stage_1]}]
1582                     }
1583                 ),
1584                 "boto_apigateway.attach_usage_plan_to_apis": MagicMock(
1585                     return_value={
1586                         "result": {
1587                             "apiStages": [association_stage_1, association_stage_2]
1588                         }
1589                     }
1590                 ),
1591             },
1592         ):
1593             result = boto_apigateway.usage_plan_association_present(
1594                 "name", "plan_name", [association_stage_2], **conn_parameters
1595             )
1596             self.assertIn("result", result)
1597             self.assertEqual(result["result"], True)
1598             self.assertIn("comment", result)
1599             self.assertEqual(
1600                 result["comment"], "successfully associated usage plan to apis"
1601             )
1602             self.assertIn("changes", result)
1603             self.assertEqual(
1604                 result["changes"],
1605                 {
1606                     "new": [association_stage_1, association_stage_2],
1607                     "old": [association_stage_1],
1608                 },
1609             )
1610     @pytest.mark.slow_test
1611     def test_usage_plan_association_present_if_value_error_is_thrown(self, *args):
1612         with patch.dict(
1613             boto_apigateway.__salt__,
1614             {
1615                 "boto_apigateway.describe_usage_plans": MagicMock(
1616                     side_effect=ValueError("error")
1617                 )
1618             },
1619         ):
1620             result = boto_apigateway.usage_plan_association_present(
1621                 "name", "plan_name", [], **conn_parameters
1622             )
1623             self.assertIn("result", result)
1624             self.assertEqual(result["result"], False)
1625             self.assertIn("comment", result)
1626             self.assertEqual(result["comment"], repr(("error",)))
1627             self.assertIn("changes", result)
1628             self.assertEqual(result["changes"], {})
1629     @pytest.mark.slow_test
1630     def test_usage_plan_association_present_if_io_error_is_thrown(self, *args):
1631         with patch.dict(
1632             boto_apigateway.__salt__,
1633             {
1634                 "boto_apigateway.describe_usage_plans": MagicMock(
1635                     side_effect=IOError("error")
1636                 )
1637             },
1638         ):
1639             result = boto_apigateway.usage_plan_association_present(
1640                 "name", "plan_name", [], **conn_parameters
1641             )
1642             self.assertIn("result", result)
1643             self.assertEqual(result["result"], False)
1644             self.assertIn("comment", result)
1645             self.assertEqual(result["comment"], repr(("error",)))
1646             self.assertIn("changes", result)
1647             self.assertEqual(result["changes"], {})
1648     @pytest.mark.slow_test
1649     def test_usage_plan_association_absent_if_describe_fails(self, *args):
1650         with patch.dict(
1651             boto_apigateway.__salt__,
1652             {
1653                 "boto_apigateway.describe_usage_plans": MagicMock(
1654                     return_value={"error": "error"}
1655                 )
1656             },
1657         ):
1658             result = boto_apigateway.usage_plan_association_absent(
1659                 "name", "plan_name", [association_stage_1], **conn_parameters
1660             )
1661             self.assertIn("result", result)
1662             self.assertEqual(result["result"], False)
1663             self.assertIn("comment", result)
1664             self.assertEqual(
1665                 result["comment"], "Failed to describe existing usage plans"
1666             )
1667             self.assertIn("changes", result)
1668             self.assertEqual(result["changes"], {})
1669     @pytest.mark.slow_test
1670     def test_usage_plan_association_absent_if_plan_is_not_present(self, *args):
1671         with patch.dict(
1672             boto_apigateway.__salt__,
1673             {
1674                 "boto_apigateway.describe_usage_plans": MagicMock(
1675                     return_value={"plans": []}
1676                 )
1677             },
1678         ):
1679             result = boto_apigateway.usage_plan_association_absent(
1680                 "name", "plan_name", [association_stage_1], **conn_parameters
1681             )
1682             self.assertIn("result", result)
1683             self.assertEqual(result["result"], False)
1684             self.assertIn("comment", result)
1685             self.assertEqual(result["comment"], "Usage plan plan_name does not exist")
1686             self.assertIn("changes", result)
1687             self.assertEqual(result["changes"], {})
1688     @pytest.mark.slow_test
1689     def test_usage_plan_association_absent_if_multiple_plans_with_the_same_name_exist(
1690         self, *args
1691     ):
1692         with patch.dict(
1693             boto_apigateway.__salt__,
1694             {
1695                 "boto_apigateway.describe_usage_plans": MagicMock(
1696                     return_value={"plans": [{"id": "id1"}, {"id": "id2"}]}
1697                 )
1698             },
1699         ):
1700             result = boto_apigateway.usage_plan_association_absent(
1701                 "name", "plan_name", [association_stage_1], **conn_parameters
1702             )
1703             self.assertIn("result", result)
1704             self.assertEqual(result["result"], False)
1705             self.assertIn("comment", result)
1706             self.assertEqual(
1707                 result["comment"],
1708                 "There are multiple usage plans with the same name - it is not"
1709                 " supported",
1710             )
1711             self.assertIn("changes", result)
1712             self.assertEqual(result["changes"], {})
1713     @pytest.mark.slow_test
1714     def test_usage_plan_association_absent_if_plan_has_no_associations(self, *args):
1715         with patch.dict(
1716             boto_apigateway.__salt__,
1717             {
1718                 "boto_apigateway.describe_usage_plans": MagicMock(
1719                     return_value={"plans": [{"id": "id1", "apiStages": []}]}
1720                 )
1721             },
1722         ):
1723             result = boto_apigateway.usage_plan_association_absent(
1724                 "name", "plan_name", [association_stage_1], **conn_parameters
1725             )
1726             self.assertIn("result", result)
1727             self.assertEqual(result["result"], True)
1728             self.assertIn("comment", result)
1729             self.assertEqual(
1730                 result["comment"],
1731                 "Usage plan plan_name has no associated stages already",
1732             )
1733             self.assertIn("changes", result)
1734             self.assertEqual(result["changes"], {})
1735     @pytest.mark.slow_test
1736     def test_usage_plan_association_absent_if_plan_has_no_specific_association(
1737         self, *args
1738     ):
1739         with patch.dict(
1740             boto_apigateway.__salt__,
1741             {
1742                 "boto_apigateway.describe_usage_plans": MagicMock(
1743                     return_value={
1744                         "plans": [{"id": "id1", "apiStages": [association_stage_1]}]
1745                     }
1746                 )
1747             },
1748         ):
1749             result = boto_apigateway.usage_plan_association_absent(
1750                 "name", "plan_name", [association_stage_2], **conn_parameters
1751             )
1752             self.assertIn("result", result)
1753             self.assertEqual(result["result"], True)
1754             self.assertIn("comment", result)
1755             self.assertEqual(
1756                 result["comment"],
1757                 "Usage plan is already not asssociated to any api stages",
1758             )
1759             self.assertIn("changes", result)
1760             self.assertEqual(result["changes"], {})
1761     @pytest.mark.slow_test
1762     def test_usage_plan_association_absent_if_detaching_association_fails(self, *args):
1763         with patch.dict(
1764             boto_apigateway.__salt__,
1765             {
1766                 "boto_apigateway.describe_usage_plans": MagicMock(
1767                     return_value={
1768                         "plans": [
1769                             {
1770                                 "id": "id1",
1771                                 "apiStages": [association_stage_1, association_stage_2],
1772                             }
1773                         ]
1774                     }
1775                 ),
1776                 "boto_apigateway.detach_usage_plan_from_apis": MagicMock(
1777                     return_value={"error": "error"}
1778                 ),
1779             },
1780         ):
1781             result = boto_apigateway.usage_plan_association_absent(
1782                 "name", "plan_name", [association_stage_2], **conn_parameters
1783             )
1784             self.assertIn("result", result)
1785             self.assertEqual(result["result"], False)
1786             self.assertIn("comment", result)
1787             self.assertTrue(
1788                 result["comment"].startswith(
1789                     "Failed to disassociate a usage plan plan_name from the apis"
1790                 )
1791             )
1792             self.assertIn("changes", result)
1793             self.assertEqual(result["changes"], {})
1794     @pytest.mark.slow_test
1795     def test_usage_plan_association_absent_success(self, *args):
1796         with patch.dict(
1797             boto_apigateway.__salt__,
1798             {
1799                 "boto_apigateway.describe_usage_plans": MagicMock(
1800                     return_value={
1801                         "plans": [
1802                             {
1803                                 "id": "id1",
1804                                 "apiStages": [association_stage_1, association_stage_2],
1805                             }
1806                         ]
1807                     }
1808                 ),
1809                 "boto_apigateway.detach_usage_plan_from_apis": MagicMock(
1810                     return_value={"result": {"apiStages": [association_stage_1]}}
1811                 ),
1812             },
1813         ):
1814             result = boto_apigateway.usage_plan_association_absent(
1815                 "name", "plan_name", [association_stage_2], **conn_parameters
1816             )
1817             self.assertIn("result", result)
1818             self.assertEqual(result["result"], True)
1819             self.assertIn("comment", result)
1820             self.assertEqual(
1821                 result["comment"], "successfully disassociated usage plan from apis"
1822             )
1823             self.assertIn("changes", result)
1824             self.assertEqual(
1825                 result["changes"],
1826                 {
1827                     "new": [association_stage_1],
1828                     "old": [association_stage_1, association_stage_2],
1829                 },
1830             )
1831     @pytest.mark.slow_test
1832     def test_usage_plan_association_absent_if_ValueError_is_raised(self, *args):
1833         with patch.dict(
1834             boto_apigateway.__salt__,
1835             {
1836                 "boto_apigateway.describe_usage_plans": MagicMock(
1837                     side_effect=ValueError("error")
1838                 )
1839             },
1840         ):
1841             result = boto_apigateway.usage_plan_association_absent(
1842                 "name", "plan_name", [association_stage_1], **conn_parameters
1843             )
1844             self.assertIn("result", result)
1845             self.assertEqual(result["result"], False)
1846             self.assertIn("comment", result)
1847             self.assertEqual(result["comment"], repr(("error",)))
1848             self.assertIn("changes", result)
1849             self.assertEqual(result["changes"], {})
1850     @pytest.mark.slow_test
1851     def test_usage_plan_association_absent_if_IOError_is_raised(self, *args):
1852         with patch.dict(
1853             boto_apigateway.__salt__,
1854             {
1855                 "boto_apigateway.describe_usage_plans": MagicMock(
1856                     side_effect=IOError("error")
1857                 )
1858             },
1859         ):
1860             result = boto_apigateway.usage_plan_association_absent(
1861                 "name", "plan_name", [association_stage_1], **conn_parameters
1862             )
1863             self.assertIn("result", result)
1864             self.assertEqual(result["result"], False)
1865             self.assertIn("comment", result)
1866             self.assertEqual(result["comment"], repr(("error",)))
1867             self.assertIn("changes", result)
1868             self.assertEqual(result["changes"], {})
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
