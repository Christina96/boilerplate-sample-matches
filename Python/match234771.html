<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for netutil.py &amp; setup.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for netutil.py &amp; setup.py
      </h3>
<h1 align="center">
        1.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>netutil.py (2.550091%)<th>setup.py (0.84592146%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(20-35)<td><a href="#" name="0">(21-38)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>netutil.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a>"""Miscellaneous network utility code."""
2 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>from __future__ import absolute_import, division, print_function
3 import errno
4 import os
5 import sys
6 import socket
7 import stat
8 from salt.ext.tornado.concurrent import dummy_executor, run_on_executor
9 from salt.ext.tornado.ioloop import IOLoop
10 from salt.ext.tornado.platform.auto import set_close_exec
11 from salt.ext.tornado.util import PY3, Configurable, errno_from_exception
12 try:
13     import ssl
14 e</b></font>xcept ImportError:
15     ssl = None
16 try:
17     import certifi
18 except ImportError:
19     if ssl is None or hasattr(ssl, 'create_default_context'):
20         certifi = None
21     else:
22         raise
23 if PY3:
24     xrange = range
25 if hasattr(ssl, 'match_hostname') and hasattr(ssl, 'CertificateError'):  # python 3.2+
26     ssl_match_hostname = ssl.match_hostname
27     SSLCertificateError = ssl.CertificateError
28 elif ssl is None:
29     ssl_match_hostname = SSLCertificateError = None  # type: ignore
30 else:
31     import backports.ssl_match_hostname
32     ssl_match_hostname = backports.ssl_match_hostname.match_hostname
33     SSLCertificateError = backports.ssl_match_hostname.CertificateError  # type: ignore
34 if hasattr(ssl, 'SSLContext'):
35     if hasattr(ssl, 'create_default_context'):
36         _client_ssl_defaults = ssl.create_default_context(
37             ssl.Purpose.SERVER_AUTH)
38         _server_ssl_defaults = ssl.create_default_context(
39             ssl.Purpose.CLIENT_AUTH)
40     else:
41         _client_ssl_defaults = ssl.SSLContext(ssl.PROTOCOL_SSLv23)
42         _client_ssl_defaults.verify_mode = ssl.CERT_REQUIRED
43         _client_ssl_defaults.load_verify_locations(certifi.where())
44         _server_ssl_defaults = ssl.SSLContext(ssl.PROTOCOL_SSLv23)
45         if hasattr(ssl, 'OP_NO_COMPRESSION'):
46             _client_ssl_defaults.options |= ssl.OP_NO_COMPRESSION
47             _server_ssl_defaults.options |= ssl.OP_NO_COMPRESSION
48 elif ssl:
49     _client_ssl_defaults = dict(cert_reqs=ssl.CERT_REQUIRED,
50                                 ca_certs=certifi.where())
51     _server_ssl_defaults = {}
52 else:
53     _client_ssl_defaults = dict(cert_reqs=None,
54                                 ca_certs=None)
55     _server_ssl_defaults = {}
56 u'foo'.encode('idna')
57 u'foo'.encode('latin1')
58 _ERRNO_WOULDBLOCK = (errno.EWOULDBLOCK, errno.EAGAIN)
59 if hasattr(errno, "WSAEWOULDBLOCK"):
60     _ERRNO_WOULDBLOCK += (errno.WSAEWOULDBLOCK,)  # type: ignore
61 _DEFAULT_BACKLOG = 128
62 def bind_sockets(port, address=None, family=socket.AF_UNSPEC,
63                  backlog=_DEFAULT_BACKLOG, flags=None, reuse_port=False):
64     if reuse_port and not hasattr(socket, "SO_REUSEPORT"):
65         raise ValueError("the platform doesn't support SO_REUSEPORT")
66     sockets = []
67     if address == "":
68         address = None
69     if not socket.has_ipv6 and family == socket.AF_UNSPEC:
70         family = socket.AF_INET
71     if flags is None:
72         flags = socket.AI_PASSIVE
73     bound_port = None
74     for res in set(socket.getaddrinfo(address, port, family, socket.SOCK_STREAM,
75                                       0, flags)):
76         af, socktype, proto, canonname, sockaddr = res
77         if (sys.platform == 'darwin' and address == 'localhost' and
78                 af == socket.AF_INET6 and sockaddr[3] != 0):
79             continue
80         try:
81             sock = socket.socket(af, socktype, proto)
82         except socket.error as e:
83             if errno_from_exception(e) == errno.EAFNOSUPPORT:
84                 continue
85             raise
86         set_close_exec(sock.fileno())
87         if os.name != 'nt':
88             sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
89         if reuse_port:
90             sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)
91         if af == socket.AF_INET6:
92             if hasattr(socket, "IPPROTO_IPV6"):
93                 sock.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_V6ONLY, 1)
94         host, requested_port = sockaddr[:2]
95         if requested_port == 0 and bound_port is not None:
96             sockaddr = tuple([host, bound_port] + list(sockaddr[2:]))
97         sock.setblocking(0)
98         sock.bind(sockaddr)
99         bound_port = sock.getsockname()[1]
100         sock.listen(backlog)
101         sockets.append(sock)
102     return sockets
103 if hasattr(socket, 'AF_UNIX'):
104     def bind_unix_socket(file, mode=0o600, backlog=_DEFAULT_BACKLOG):
105         sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
106         set_close_exec(sock.fileno())
107         sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
108         sock.setblocking(0)
109         try:
110             st = os.stat(file)
111         except OSError as err:
112             if errno_from_exception(err) != errno.ENOENT:
113                 raise
114         else:
115             if stat.S_ISSOCK(st.st_mode):
116                 os.remove(file)
117             else:
118                 raise ValueError("File %s exists and is not a socket", file)
119         sock.bind(file)
120         os.chmod(file, mode)
121         sock.listen(backlog)
122         return sock
123 def add_accept_handler(sock, callback, io_loop=None):
124     if io_loop is None:
125         io_loop = IOLoop.current()
126     def accept_handler(fd, events):
127         for i in xrange(_DEFAULT_BACKLOG):
128             try:
129                 connection, address = sock.accept()
130             except socket.error as e:
131                 if errno_from_exception(e) in _ERRNO_WOULDBLOCK:
132                     return
133                 if errno_from_exception(e) == errno.ECONNABORTED:
134                     continue
135                 raise
136             set_close_exec(connection.fileno())
137             callback(connection, address)
138     io_loop.add_handler(sock, accept_handler, IOLoop.READ)
139 def is_valid_ip(ip):
140     if not ip or '\x00' in ip:
141         return False
142     try:
143         res = socket.getaddrinfo(ip, 0, socket.AF_UNSPEC,
144                                  socket.SOCK_STREAM,
145                                  0, socket.AI_NUMERICHOST)
146         return bool(res)
147     except socket.gaierror as e:
148         if e.args[0] == socket.EAI_NONAME:
149             return False
150         raise
151     return True
152 class Resolver(Configurable):
153     @classmethod
154     def configurable_base(cls):
155         return Resolver
156     @classmethod
157     def configurable_default(cls):
158         return BlockingResolver
159     def resolve(self, host, port, family=socket.AF_UNSPEC, callback=None):
160         raise NotImplementedError()
161     def close(self):
162         pass
163 class ExecutorResolver(Resolver):
164     def initialize(self, io_loop=None, executor=None, close_executor=True):
165         self.io_loop = io_loop or IOLoop.current()
166         if executor is not None:
167             self.executor = executor
168             self.close_executor = close_executor
169         else:
170             self.executor = dummy_executor
171             self.close_executor = False
172     def close(self):
173         if self.close_executor:
174             self.executor.shutdown()
175         self.executor = None
176     @run_on_executor
177     def resolve(self, host, port, family=socket.AF_UNSPEC):
178         addrinfo = socket.getaddrinfo(host, port, family, socket.SOCK_STREAM)
179         results = []
180         for family, socktype, proto, canonname, address in addrinfo:
181             results.append((family, address))
182         return results
183 class BlockingResolver(ExecutorResolver):
184     def initialize(self, io_loop=None):
185         super(BlockingResolver, self).initialize(io_loop=io_loop)
186 class ThreadedResolver(ExecutorResolver):
187     _threadpool = None  # type: ignore
188     _threadpool_pid = None  # type: int
189     def initialize(self, io_loop=None, num_threads=10):
190         threadpool = ThreadedResolver._create_threadpool(num_threads)
191         super(ThreadedResolver, self).initialize(
192             io_loop=io_loop, executor=threadpool, close_executor=False)
193     @classmethod
194     def _create_threadpool(cls, num_threads):
195         pid = os.getpid()
196         if cls._threadpool_pid != pid:
197             cls._threadpool = None
198         if cls._threadpool is None:
199             from concurrent.futures import ThreadPoolExecutor
200             cls._threadpool = ThreadPoolExecutor(num_threads)
201             cls._threadpool_pid = pid
202         return cls._threadpool
203 class OverrideResolver(Resolver):
204     def initialize(self, resolver, mapping):
205         self.resolver = resolver
206         self.mapping = mapping
207     def close(self):
208         self.resolver.close()
209     def resolve(self, host, port, *args, **kwargs):
210         if (host, port) in self.mapping:
211             host, port = self.mapping[(host, port)]
212         elif host in self.mapping:
213             host = self.mapping[host]
214         return self.resolver.resolve(host, port, *args, **kwargs)
215 _SSL_CONTEXT_KEYWORDS = frozenset(['ssl_version', 'certfile', 'keyfile',
216                                    'cert_reqs', 'ca_certs', 'ciphers'])
217 def ssl_options_to_context(ssl_options):
218     if isinstance(ssl_options, dict):
219         assert all(k in _SSL_CONTEXT_KEYWORDS for k in ssl_options), ssl_options
220     if (not hasattr(ssl, 'SSLContext') or
221             isinstance(ssl_options, ssl.SSLContext)):
222         return ssl_options
223     context = ssl.SSLContext(
224         ssl_options.get('ssl_version', ssl.PROTOCOL_SSLv23))
225     if 'certfile' in ssl_options:
226         context.load_cert_chain(ssl_options['certfile'], ssl_options.get('keyfile', None))
227     if 'cert_reqs' in ssl_options:
228         context.verify_mode = ssl_options['cert_reqs']
229     if 'ca_certs' in ssl_options:
230         context.load_verify_locations(ssl_options['ca_certs'])
231     if 'ciphers' in ssl_options:
232         context.set_ciphers(ssl_options['ciphers'])
233     if hasattr(ssl, 'OP_NO_COMPRESSION'):
234         context.options |= ssl.OP_NO_COMPRESSION
235     return context
236 def ssl_wrap_socket(socket, ssl_options, server_hostname=None, **kwargs):
237     context = ssl_options_to_context(ssl_options)
238     if hasattr(ssl, 'SSLContext') and isinstance(context, ssl.SSLContext):
239         if server_hostname is not None and getattr(ssl, 'HAS_SNI'):
240             return context.wrap_socket(socket, server_hostname=server_hostname,
241                                        **kwargs)
242         else:
243             return context.wrap_socket(socket, **kwargs)
244     else:
245         return ssl.wrap_socket(socket, **dict(context, **kwargs))  # type: ignore
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>setup.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import contextlib
2 import distutils.dist
3 import glob
4 import operator
5 import os
6 import platform
7 import sys
8 from ctypes.util import find_library
9 from datetime import datetime
10 <a name="0"></a>from distutils import log
11 from distutils.cmd import Command
12 from distutils.command.build import build
13 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>from distutils.command.clean import clean
14 from distutils.command.install_lib import install_lib
15 from distutils.errors import DistutilsArgError
16 from distutils.version import LooseVersion  # pylint: disable=blacklisted-module
17 import setuptools
18 from setuptools import setup
19 from setuptools.command.bdist_egg import bdist_egg
20 from setuptools.command.develop import develop
21 from setuptools.command.install import install
22 from setuptools.command.sdist import sdist
23 try:
24     from urllib2 import urlopen
25 e</b></font>xcept ImportError:
26     from urllib.request import urlopen  # pylint: disable=no-name-in-module
27 try:
28     from wheel.bdist_wheel import bdist_wheel
29     HAS_BDIST_WHEEL = True
30 except ImportError:
31     HAS_BDIST_WHEEL = False
32 try:
33     import zmq
34     HAS_ZMQ = True
35 except ImportError:
36     HAS_ZMQ = False
37 try:
38     DATE = datetime.utcfromtimestamp(int(os.environ["SOURCE_DATE_EPOCH"]))
39 except (KeyError, ValueError):
40     DATE = datetime.utcnow()
41 try:
42     SETUP_DIRNAME = os.path.dirname(__file__)
43 except NameError:
44     SETUP_DIRNAME = os.path.dirname(sys.argv[0])
45 if SETUP_DIRNAME != "":
46     os.chdir(SETUP_DIRNAME)
47 SETUP_DIRNAME = os.path.abspath(SETUP_DIRNAME)
48 BOOTSTRAP_SCRIPT_DISTRIBUTED_VERSION = os.environ.get(
49     "BOOTSTRAP_SCRIPT_VERSION",
50     "v2014.06.21",
51 )
52 IS_OSX_PLATFORM = sys.platform.startswith("darwin")
53 IS_WINDOWS_PLATFORM = sys.platform.startswith("win")
54 if IS_WINDOWS_PLATFORM or IS_OSX_PLATFORM:
55     IS_SMARTOS_PLATFORM = False
56 else:
57     IS_SMARTOS_PLATFORM = os.uname()[0] == "SunOS" and os.uname()[3].startswith(
58         "joyent_"
59     )
60 USE_STATIC_REQUIREMENTS = os.environ.get("USE_STATIC_REQUIREMENTS")
61 if USE_STATIC_REQUIREMENTS is not None:
62     USE_STATIC_REQUIREMENTS = USE_STATIC_REQUIREMENTS == "1"
63 try:
64     import bbfreeze  # pylint: disable=unused-import
65     from esky import bdist_esky  # pylint: disable=unused-import
66     HAS_ESKY = True
67 except ImportError:
68     HAS_ESKY = False
69 SALT_VERSION = os.path.join(os.path.abspath(SETUP_DIRNAME), "salt", "version.py")
70 SALT_VERSION_HARDCODED = os.path.join(
71     os.path.abspath(SETUP_DIRNAME), "salt", "_version.py"
72 )
73 SALT_SYSPATHS_HARDCODED = os.path.join(
74     os.path.abspath(SETUP_DIRNAME), "salt", "_syspaths.py"
75 )
76 SALT_BASE_REQUIREMENTS = [
77     os.path.join(os.path.abspath(SETUP_DIRNAME), "requirements", "base.txt"),
78     os.path.join(os.path.abspath(SETUP_DIRNAME), "requirements", "zeromq.txt"),
79     os.path.join(os.path.abspath(SETUP_DIRNAME), "requirements", "crypto.txt"),
80 ]
81 SALT_LINUX_LOCKED_REQS = [
82     os.path.join(
83         os.path.abspath(SETUP_DIRNAME),
84         "requirements",
85         "static",
86         "pkg",
87         "py{}.{}".format(*sys.version_info),
88         "linux.txt",
89     )
90 ]
91 SALT_OSX_REQS = SALT_BASE_REQUIREMENTS + [
92     os.path.join(os.path.abspath(SETUP_DIRNAME), "requirements", "darwin.txt")
93 ]
94 SALT_OSX_LOCKED_REQS = [
95     os.path.join(
96         os.path.abspath(SETUP_DIRNAME),
97         "requirements",
98         "static",
99         "pkg",
100         "py{}.{}".format(*sys.version_info),
101         "darwin.txt",
102     )
103 ]
104 SALT_WINDOWS_REQS = SALT_BASE_REQUIREMENTS + [
105     os.path.join(os.path.abspath(SETUP_DIRNAME), "requirements", "windows.txt")
106 ]
107 SALT_WINDOWS_LOCKED_REQS = [
108     os.path.join(
109         os.path.abspath(SETUP_DIRNAME),
110         "requirements",
111         "static",
112         "pkg",
113         "py{}.{}".format(*sys.version_info),
114         "windows.txt",
115     )
116 ]
117 SALT_LONG_DESCRIPTION_FILE = os.path.join(os.path.abspath(SETUP_DIRNAME), "README.rst")
118 PACKAGED_FOR_SALT_SSH_FILE = os.path.join(
119     os.path.abspath(SETUP_DIRNAME), ".salt-ssh-package"
120 )
121 PACKAGED_FOR_SALT_SSH = os.path.isfile(PACKAGED_FOR_SALT_SSH_FILE)
122 exec(compile(open(SALT_VERSION).read(), SALT_VERSION, "exec"))
123 def _parse_op(op):
124     op = op.strip()
125     if "&gt;" in op:
126         if "=" in op:
127             return "ge"
128         else:
129             return "gt"
130     elif "&lt;" in op:
131         if "=" in op:
132             return "le"
133         else:
134             return "lt"
135     elif "!" in op:
136         return "ne"
137     else:
138         return "eq"
139 def _parse_ver(ver):
140     if "#" in ver:
141         ver, _ = ver.split("#", 1)
142         ver = ver.strip()
143     return ver.strip("'").strip('"')
144 def _check_ver(pyver, op, wanted):
145     pyver = distutils.version.LooseVersion(pyver)
146     wanted = distutils.version.LooseVersion(wanted)
147     if not isinstance(pyver, str):
148         pyver = str(pyver)
149     if not isinstance(wanted, str):
150         wanted = str(wanted)
151     return getattr(operator, "__{}__".format(op))(pyver, wanted)
152 def _parse_requirements_file(requirements_file):
153     parsed_requirements = []
154     with open(requirements_file) as rfh:
155         for line in rfh.readlines():
156             line = line.strip()
157             if not line or line.startswith(("#", "-r", "--")):
158                 continue
159             if IS_WINDOWS_PLATFORM:
160                 if "libcloud" in line:
161                     continue
162             try:
163                 pkg, pyverspec = line.rsplit(";", 1)
164             except ValueError:
165                 pkg, pyverspec = line, ""
166             pyverspec = pyverspec.strip()
167             if pyverspec and (
168                 not pkg.startswith("pycrypto") or pkg.startswith("pycryptodome")
169             ):
170                 _, op, ver = pyverspec.split(" ", 2)
171                 if not _check_ver(
172                     platform.python_version(), _parse_op(op), _parse_ver(ver)
173                 ):
174                     continue
175             parsed_requirements.append(line)
176     return parsed_requirements
177 class WriteSaltVersion(Command):
178     description = "Write salt's hardcoded version file"
179     user_options = []
180     def initialize_options(self):
181     def finalize_options(self):
182     def run(self):
183         if (
184             not os.path.exists(SALT_VERSION_HARDCODED)
185             or self.distribution.with_salt_version
186         ):
187             if getattr(self.distribution, "salt_version_hardcoded_path", None) is None:
188                 self.distribution.salt_version_hardcoded_path = SALT_VERSION_HARDCODED
189                 sys.stderr.write("This command is not meant to be called on it's own\n")
190                 sys.stderr.flush()
191             if not self.distribution.with_salt_version:
192                 salt_version = (
193                     __saltstack_version__  # pylint: disable=undefined-variable
194                 )
195             else:
196                 from salt.version import SaltStackVersion
197                 salt_version = SaltStackVersion.parse(
198                     self.distribution.with_salt_version
199                 )
200             open(self.distribution.salt_version_hardcoded_path, "w").write(
201                 INSTALL_VERSION_TEMPLATE.format(
202                     date=DATE, full_version_info=salt_version.full_info_all_versions
203                 )
204             )
205 class GenerateSaltSyspaths(Command):
206     description = "Generate salt's hardcoded syspaths file"
207     def initialize_options(self):
208         pass
209     def finalize_options(self):
210         pass
211     def run(self):
212         if getattr(self.distribution, "salt_syspaths_hardcoded_path", None) is None:
213             print("This command is not meant to be called on it's own")
214             exit(1)
215         open(self.distribution.salt_syspaths_hardcoded_path, "w").write(
216             INSTALL_SYSPATHS_TEMPLATE.format(
217                 date=DATE,
218                 root_dir=self.distribution.salt_root_dir,
219                 share_dir=self.distribution.salt_share_dir,
220                 config_dir=self.distribution.salt_config_dir,
221                 cache_dir=self.distribution.salt_cache_dir,
222                 sock_dir=self.distribution.salt_sock_dir,
223                 srv_root_dir=self.distribution.salt_srv_root_dir,
224                 base_file_roots_dir=self.distribution.salt_base_file_roots_dir,
225                 base_pillar_roots_dir=self.distribution.salt_base_pillar_roots_dir,
226                 base_master_roots_dir=self.distribution.salt_base_master_roots_dir,
227                 base_thorium_roots_dir=self.distribution.salt_base_thorium_roots_dir,
228                 logs_dir=self.distribution.salt_logs_dir,
229                 pidfile_dir=self.distribution.salt_pidfile_dir,
230                 spm_parent_path=self.distribution.salt_spm_parent_dir,
231                 spm_formula_path=self.distribution.salt_spm_formula_dir,
232                 spm_pillar_path=self.distribution.salt_spm_pillar_dir,
233                 spm_reactor_path=self.distribution.salt_spm_reactor_dir,
234                 home_dir=self.distribution.salt_home_dir,
235             )
236         )
237 class WriteSaltSshPackagingFile(Command):
238     description = "Write salt's ssh packaging file"
239     user_options = []
240     def initialize_options(self):
241     def finalize_options(self):
242     def run(self):
243         if not os.path.exists(PACKAGED_FOR_SALT_SSH_FILE):
244             if getattr(self.distribution, "salt_ssh_packaging_file", None) is None:
245                 print("This command is not meant to be called on it's own")
246                 exit(1)
247             open(self.distribution.salt_ssh_packaging_file, "w").write(
248                 "Packaged for Salt-SSH\n"
249             )
250 class Develop(develop):
251     user_options = develop.user_options + [
252         (
253             "write-salt-version",
254             None,
255             "Generate Salt's _version.py file which allows proper version "
256             "reporting. This defaults to False on develop/editable setups. "
257             "If WRITE_SALT_VERSION is found in the environment this flag is "
258             "switched to True.",
259         ),
260         (
261             "generate-salt-syspaths",
262             None,
263             "Generate Salt's _syspaths.py file which allows tweaking some "
264             "common paths that salt uses. This defaults to False on "
265             "develop/editable setups. If GENERATE_SALT_SYSPATHS is found in "
266             "the environment this flag is switched to True.",
267         ),
268         (
269             "mimic-salt-install",
270             None,
271             "Mimmic the install command when running the develop command. "
272             "This will generate salt's _version.py and _syspaths.py files. "
273             "Generate Salt's _syspaths.py file which allows tweaking some "
274             "This defaults to False on develop/editable setups. "
275             "If MIMIC_INSTALL is found in the environment this flag is "
276             "switched to True.",
277         ),
278     ]
279     boolean_options = develop.boolean_options + [
280         "write-salt-version",
281         "generate-salt-syspaths",
282         "mimic-salt-install",
283     ]
284     def initialize_options(self):
285         develop.initialize_options(self)
286         self.write_salt_version = False
287         self.generate_salt_syspaths = False
288         self.mimic_salt_install = False
289     def finalize_options(self):
290         develop.finalize_options(self)
291         if "WRITE_SALT_VERSION" in os.environ:
292             self.write_salt_version = True
293         if "GENERATE_SALT_SYSPATHS" in os.environ:
294             self.generate_salt_syspaths = True
295         if "MIMIC_SALT_INSTALL" in os.environ:
296             self.mimic_salt_install = True
297         if self.mimic_salt_install:
298             self.write_salt_version = True
299             self.generate_salt_syspaths = True
300     def run(self):
301         if IS_WINDOWS_PLATFORM:
302             self.distribution.salt_download_windows_dlls = True
303             self.run_command("download-windows-dlls")
304             self.distribution.salt_download_windows_dlls = None
305         if self.write_salt_version is True:
306             self.distribution.running_salt_install = True
307             self.distribution.salt_version_hardcoded_path = SALT_VERSION_HARDCODED
308             self.run_command("write_salt_version")
309         if self.generate_salt_syspaths:
310             self.distribution.salt_syspaths_hardcoded_path = SALT_SYSPATHS_HARDCODED
311             self.run_command("generate_salt_syspaths")
312         develop.run(self)
313 class DownloadWindowsDlls(Command):
314     description = "Download required DLL's for windows"
315     def initialize_options(self):
316         pass
317     def finalize_options(self):
318         pass
319     def run(self):
320         if getattr(self.distribution, "salt_download_windows_dlls", None) is None:
321             print("This command is not meant to be called on it's own")
322             exit(1)
323         try:
324             import pip
325             if LooseVersion(pip.__version__) &lt; LooseVersion("10.0"):
326                 from pip.utils.logging import indent_log
327             else:
328                 from pip._internal.utils.logging import (  # pylint: disable=no-name-in-module
329                     indent_log,
330                 )
331         except ImportError:
332             @contextlib.contextmanager
333             def indent_log():
334                 yield
335         platform_bits, _ = platform.architecture()
336         url = "https://repo.saltproject.io/windows/dependencies/{bits}/{fname}"
337         dest = os.path.join(os.path.dirname(sys.executable), "{fname}")
338         with indent_log():
339             for fname in (
340                 "openssl/1.1.1k/ssleay32.dll",
341                 "openssl/1.1.1k/libeay32.dll",
342                 "libsodium/1.0.18/libsodium.dll",
343             ):
344                 if find_library(fname):
345                     continue
346                 furl = url.format(bits=platform_bits[:2], fname=fname)
347                 fdest = dest.format(fname=os.path.basename(fname))
348                 if not os.path.exists(fdest):
349                     log.info("Downloading {} to {} from {}".format(fname, fdest, furl))
350                     try:
351                         from contextlib import closing
352                         import requests
353                         with closing(requests.get(furl, stream=True)) as req:
354                             if req.status_code == 200:
355                                 with open(fdest, "wb") as wfh:
356                                     for chunk in req.iter_content(chunk_size=4096):
357                                         if chunk:  # filter out keep-alive new chunks
358                                             wfh.write(chunk)
359                                             wfh.flush()
360                             else:
361                                 log.error(
362                                     "Failed to download {} to {} from {}".format(
363                                         fname, fdest, furl
364                                     )
365                                 )
366                     except ImportError:
367                         req = urlopen(furl)
368                         if req.getcode() == 200:
369                             with open(fdest, "wb") as wfh:
370                                 while True:
371                                     chunk = req.read(4096)
372                                     if not chunk:
373                                         break
374                                     wfh.write(chunk)
375                                     wfh.flush()
376                         else:
377                             log.error(
378                                 "Failed to download {} to {} from {}".format(
379                                     fname, fdest, furl
380                                 )
381                             )
382 class Sdist(sdist):
383     def make_release_tree(self, base_dir, files):
384         if self.distribution.ssh_packaging:
385             self.distribution.salt_ssh_packaging_file = PACKAGED_FOR_SALT_SSH_FILE
386             self.run_command("write_salt_ssh_packaging_file")
387             self.filelist.files.append(os.path.basename(PACKAGED_FOR_SALT_SSH_FILE))
388         sdist.make_release_tree(self, base_dir, files)
389         self.distribution.running_salt_sdist = True
390         self.distribution.salt_version_hardcoded_path = os.path.join(
391             base_dir, "salt", "_version.py"
392         )
393         self.run_command("write_salt_version")
394     def make_distribution(self):
395         sdist.make_distribution(self)
396         if self.distribution.ssh_packaging:
397             os.unlink(PACKAGED_FOR_SALT_SSH_FILE)
398 class BDistEgg(bdist_egg):
399     def finalize_options(self):
400         bdist_egg.finalize_options(self)
401         self.distribution.build_egg = True
402         if not self.skip_build:
403             self.run_command("build")
404 class CloudSdist(Sdist):  # pylint: disable=too-many-ancestors
405     user_options = Sdist.user_options + [
406         (
407             "download-bootstrap-script",
408             None,
409             "Download the latest stable bootstrap-salt.sh script. This "
410             "can also be triggered by having `DOWNLOAD_BOOTSTRAP_SCRIPT=1` as an "
411             "environment variable.",
412         )
413     ]
414     boolean_options = Sdist.boolean_options + ["download-bootstrap-script"]
415     def initialize_options(self):
416         Sdist.initialize_options(self)
417         self.skip_bootstrap_download = True
418         self.download_bootstrap_script = False
419     def finalize_options(self):
420         Sdist.finalize_options(self)
421         if "SKIP_BOOTSTRAP_DOWNLOAD" in os.environ:
422             log(
423                 "Please stop using 'SKIP_BOOTSTRAP_DOWNLOAD' and use "
424                 "'DOWNLOAD_BOOTSTRAP_SCRIPT' instead"
425             )
426         if "DOWNLOAD_BOOTSTRAP_SCRIPT" in os.environ:
427             download_bootstrap_script = os.environ.get("DOWNLOAD_BOOTSTRAP_SCRIPT", "0")
428             self.download_bootstrap_script = download_bootstrap_script == "1"
429     def run(self):
430         if self.download_bootstrap_script is True:
431             url = (
432                 "https://github.com/saltstack/salt-bootstrap/raw/{}"
433                 "/bootstrap-salt.sh".format(BOOTSTRAP_SCRIPT_DISTRIBUTED_VERSION)
434             )
435             deploy_path = os.path.join(
436                 SETUP_DIRNAME, "salt", "cloud", "deploy", "bootstrap-salt.sh"
437             )
438             log.info(
439                 "Updating bootstrap-salt.sh."
440                 "\n\tSource:      {}"
441                 "\n\tDestination: {}".format(url, deploy_path)
442             )
443             try:
444                 import requests
445                 req = requests.get(url)
446                 if req.status_code == 200:
447                     script_contents = req.text.encode(req.encoding)
448                 else:
449                     log.error(
450                         "Failed to update the bootstrap-salt.sh script. HTTP "
451                         "Error code: {}".format(req.status_code)
452                     )
453             except ImportError:
454                 req = urlopen(url)
455                 if req.getcode() == 200:
456                     script_contents = req.read()
457                 else:
458                     log.error(
459                         "Failed to update the bootstrap-salt.sh script. HTTP "
460                         "Error code: {}".format(req.getcode())
461                     )
462             try:
463                 with open(deploy_path, "w") as fp_:
464                     fp_.write(script_contents)
465             except OSError as err:
466                 log.error("Failed to write the updated script: {}".format(err))
467         Sdist.run(self)
468     def write_manifest(self):
469         dist_scripts = self.distribution.scripts
470         for script in self.filelist.files[:]:
471             if not script.startswith("scripts/"):
472                 continue
473             if script not in dist_scripts:
474                 self.filelist.files.remove(script)
475         return Sdist.write_manifest(self)
476 class TestCommand(Command):
477     description = "Run tests"
478     user_options = [
479         ("runtests-opts=", "R", "Command line options to pass to runtests.py")
480     ]
481     def initialize_options(self):
482         self.runtests_opts = None
483     def finalize_options(self):
484     def run(self):
485         import subprocess
486         self.run_command("build")
487         build_cmd = self.get_finalized_command("build_ext")
488         runner = os.path.abspath("tests/runtests.py")
489         test_cmd = [sys.executable, runner]
490         if self.runtests_opts:
491             test_cmd.extend(self.runtests_opts.split())
492         print("running test")
493         ret = subprocess.run(
494             test_cmd,
495             stdout=sys.stdout,
496             stderr=sys.stderr,
497             cwd=build_cmd.build_lib,
498             check=False,
499         )
500         sys.exit(ret.returncode)
501 class Clean(clean):
502     def run(self):
503         clean.run(self)
504         for subdir in ("salt", "tests", "doc"):
505             root = os.path.join(os.path.dirname(__file__), subdir)
506             for dirname, _, _ in os.walk(root):
507                 for to_remove_filename in glob.glob("{}/*.py[oc]".format(dirname)):
508                     os.remove(to_remove_filename)
509 if HAS_BDIST_WHEEL:
510     class BDistWheel(bdist_wheel):
511         def finalize_options(self):
512             bdist_wheel.finalize_options(self)
513             self.distribution.build_wheel = True
514 INSTALL_VERSION_TEMPLATE = """\
515 from salt.version import SaltStackVersion
516 __saltstack_version__ = SaltStackVersion{full_version_info!r}
517 class Build(build):
518     def run(self):
519         build.run(self)
520         salt_build_ver_file = os.path.join(self.build_lib, "salt", "_version.py")
521         if getattr(self.distribution, "with_salt_version", False):
522             self.distribution.salt_version_hardcoded_path = salt_build_ver_file
523             self.run_command("write_salt_version")
524         if getattr(self.distribution, "build_egg", False):
525             self.distribution.salt_version_hardcoded_path = salt_build_ver_file
526             self.run_command("write_salt_version")
527         if getattr(self.distribution, "build_wheel", False):
528             self.distribution.salt_version_hardcoded_path = salt_build_ver_file
529             self.run_command("write_salt_version")
530         if getattr(self.distribution, "running_salt_install", False):
531             self.run_command("write_salt_version")
532             self.distribution.salt_syspaths_hardcoded_path = os.path.join(
533                 self.build_lib, "salt", "_syspaths.py"
534             )
535             self.run_command("generate_salt_syspaths")
536 class Install(install):
537     def initialize_options(self):
538         install.initialize_options(self)
539     def finalize_options(self):
540         install.finalize_options(self)
541     def run(self):
542         if LooseVersion(setuptools.__version__) &lt; LooseVersion("9.1"):
543             sys.stderr.write(
544                 "\n\nInstalling Salt requires setuptools &gt;= 9.1\n"
545                 "Available setuptools version is {}\n\n".format(setuptools.__version__)
546             )
547             sys.stderr.flush()
548             sys.exit(1)
549         self.distribution.running_salt_install = True
550         self.distribution.salt_version_hardcoded_path = os.path.join(
551             self.build_lib, "salt", "_version.py"
552         )
553         if IS_WINDOWS_PLATFORM:
554             self.distribution.salt_download_windows_dlls = True
555             self.run_command("download-windows-dlls")
556             self.distribution.salt_download_windows_dlls = None
557         if not os.path.exists(os.path.join(self.build_lib)):
558             if not self.skip_build:
559                 self.run_command("build")
560         else:
561             self.run_command("write_salt_version")
562         install.run(self)
563     @staticmethod
564     def _called_from_setup(run_frame):
565         if run_frame is None:
566             return install._called_from_setup(run_frame)
567         first_call = install._called_from_setup(run_frame)
568         if first_call:
569             return True
570         second_call = install._called_from_setup(run_frame.f_back)
571         if second_call is None:
572             return first_call
573         return second_call
574 class InstallLib(install_lib):
575     def run(self):
576         executables = [
577             "salt/templates/git/ssh-id-wrapper",
578             "salt/templates/lxc/salt_tarball",
579         ]
580         install_lib.run(self)
581         inp = self.get_inputs()
582         out = self.get_outputs()
583         chmod = []
584         for idx, inputfile in enumerate(inp):
585             for executable in executables:
586                 if inputfile.endswith(executable):
587                     chmod.append(idx)
588         for idx in chmod:
589             filename = out[idx]
590             os.chmod(filename, 0o755)
591 class SaltDistribution(distutils.dist.Distribution):
592     global_options = (
593         distutils.dist.Distribution.global_options
594         + [
595             ("ssh-packaging", None, "Run in SSH packaging mode"),
596             (
597                 "salt-transport=",
598                 None,
599                 "The transport to prepare salt for. Currently, the only choice "
600                 "is 'zeromq'. This may be expanded in the future. Defaults to "
601                 "'zeromq'",
602                 "zeromq",
603             ),
604         ]
605         + [
606             (
607                 "with-salt-version=",
608                 None,
609                 "Set a fixed version for Salt instead calculating it",
610             ),
611             ("salt-root-dir=", None, "Salt's pre-configured root directory"),
612             ("salt-share-dir=", None, "Salt's pre-configured share directory"),
613             ("salt-config-dir=", None, "Salt's pre-configured configuration directory"),
614             ("salt-cache-dir=", None, "Salt's pre-configured cache directory"),
615             ("salt-sock-dir=", None, "Salt's pre-configured socket directory"),
616             ("salt-srv-root-dir=", None, "Salt's pre-configured service directory"),
617             (
618                 "salt-base-file-roots-dir=",
619                 None,
620                 "Salt's pre-configured file roots directory",
621             ),
622             (
623                 "salt-base-pillar-roots-dir=",
624                 None,
625                 "Salt's pre-configured pillar roots directory",
626             ),
627             (
628                 "salt-base-master-roots-dir=",
629                 None,
630                 "Salt's pre-configured master roots directory",
631             ),
632             ("salt-logs-dir=", None, "Salt's pre-configured logs directory"),
633             ("salt-pidfile-dir=", None, "Salt's pre-configured pidfiles directory"),
634             (
635                 "salt-spm-formula-dir=",
636                 None,
637                 "Salt's pre-configured SPM formulas directory",
638             ),
639             (
640                 "salt-spm-pillar-dir=",
641                 None,
642                 "Salt's pre-configured SPM pillar directory",
643             ),
644             (
645                 "salt-spm-reactor-dir=",
646                 None,
647                 "Salt's pre-configured SPM reactor directory",
648             ),
649             ("salt-home-dir=", None, "Salt's pre-configured user home directory"),
650         ]
651     )
652     def __init__(self, attrs=None):
653         distutils.dist.Distribution.__init__(self, attrs)
654         self.ssh_packaging = PACKAGED_FOR_SALT_SSH
655         self.salt_transport = None
656         self.salt_root_dir = None
657         self.salt_share_dir = None
658         self.salt_config_dir = None
659         self.salt_cache_dir = None
660         self.salt_sock_dir = None
661         self.salt_srv_root_dir = None
662         self.salt_base_file_roots_dir = None
663         self.salt_base_thorium_roots_dir = None
664         self.salt_base_pillar_roots_dir = None
665         self.salt_base_master_roots_dir = None
666         self.salt_logs_dir = None
667         self.salt_pidfile_dir = None
668         self.salt_spm_parent_dir = None
669         self.salt_spm_formula_dir = None
670         self.salt_spm_pillar_dir = None
671         self.salt_spm_reactor_dir = None
672         self.salt_home_dir = None
673         self.with_salt_version = None
674         self.name = "salt-ssh" if PACKAGED_FOR_SALT_SSH else "salt"
675         self.salt_version = __version__  # pylint: disable=undefined-variable
676         self.description = (
677             "Portable, distributed, remote execution and configuration management"
678             " system"
679         )
680         with open(SALT_LONG_DESCRIPTION_FILE, encoding="utf-8") as f:
681             self.long_description = f.read()
682         self.long_description_content_type = "text/x-rst"
683         self.python_requires = "&gt;=3.5"
684         self.classifiers = [
685             "Programming Language :: Python",
686             "Programming Language :: Cython",
687             "Programming Language :: Python :: 3",
688             "Programming Language :: Python :: 3 :: Only",
689             "Programming Language :: Python :: 3.5",
690             "Programming Language :: Python :: 3.6",
691             "Programming Language :: Python :: 3.7",
692             "Programming Language :: Python :: 3.8",
693             "Programming Language :: Python :: 3.9",
694             "Development Status :: 5 - Production/Stable",
695             "Environment :: Console",
696             "Intended Audience :: Developers",
697             "Intended Audience :: Information Technology",
698             "Intended Audience :: System Administrators",
699             "License :: OSI Approved :: Apache Software License",
700             "Operating System :: POSIX :: Linux",
701             "Topic :: System :: Clustering",
702             "Topic :: System :: Distributed Computing",
703         ]
704         self.author = "Thomas S Hatch"
705         self.author_email = "thatch45@gmail.com"
706         self.url = "https://saltproject.io"
707         self.cmdclass.update(
708             {
709                 "test": TestCommand,
710                 "clean": Clean,
711                 "build": Build,
712                 "sdist": Sdist,
713                 "bdist_egg": BDistEgg,
714                 "install": Install,
715                 "develop": Develop,
716                 "write_salt_version": WriteSaltVersion,
717                 "generate_salt_syspaths": GenerateSaltSyspaths,
718                 "write_salt_ssh_packaging_file": WriteSaltSshPackagingFile,
719             }
720         )
721         if not IS_WINDOWS_PLATFORM:
722             self.cmdclass.update({"sdist": CloudSdist, "install_lib": InstallLib})
723         if IS_WINDOWS_PLATFORM:
724             self.cmdclass.update({"download-windows-dlls": DownloadWindowsDlls})
725         if HAS_BDIST_WHEEL:
726             self.cmdclass["bdist_wheel"] = BDistWheel
727         self.license = "Apache Software License 2.0"
728         self.packages = self.discover_packages()
729         self.zip_safe = False
730         if HAS_ESKY:
731             self.setup_esky()
732         self.update_metadata()
733     def update_metadata(self):
734         for attrname in dir(self):
735             if attrname.startswith("__"):
736                 continue
737             attrvalue = getattr(self, attrname, None)
738             if attrvalue == 0:
739                 continue
740             if attrname == "salt_version":
741                 attrname = "version"
742             if hasattr(self.metadata, "set_{}".format(attrname)):
743                 getattr(self.metadata, "set_{}".format(attrname))(attrvalue)
744             elif hasattr(self.metadata, attrname):
745                 try:
746                     setattr(self.metadata, attrname, attrvalue)
747                 except AttributeError:
748                     pass
749     def discover_packages(self):
750         modules = []
751         for root, _, files in os.walk(os.path.join(SETUP_DIRNAME, "salt")):
752             if "__init__.py" not in files:
753                 continue
754             modules.append(os.path.relpath(root, SETUP_DIRNAME).replace(os.sep, "."))
755         return modules
756     @property
757     def _property_dependency_links(self):
758         return [
759             "https://github.com/saltstack/salt-testing/tarball/develop#egg=SaltTesting"
760         ]
761     @property
762     def _property_tests_require(self):
763         return ["SaltTesting"]
764     @property
765     def _property_package_data(self):
766         package_data = {
767             "salt.templates": [
768                 "rh_ip/*.jinja",
769                 "debian_ip/*.jinja",
770                 "virt/*.jinja",
771                 "git/*",
772                 "lxc/*",
773             ]
774         }
775         if not IS_WINDOWS_PLATFORM:
776             package_data["salt.cloud"] = ["deploy/*.sh"]
777         if not self.ssh_packaging and not PACKAGED_FOR_SALT_SSH:
778             package_data["salt.daemons.flo"] = ["*.flo"]
779         return package_data
780     @property
781     def _property_data_files(self):
782         data_files = [
783             ("share/man/man1", ["doc/man/salt-call.1", "doc/man/salt-run.1"]),
784             ("share/man/man7", ["doc/man/salt.7"]),
785         ]
786         if self.ssh_packaging or PACKAGED_FOR_SALT_SSH:
787             data_files[0][1].append("doc/man/salt-ssh.1")
788             if IS_WINDOWS_PLATFORM:
789                 return data_files
790             data_files[0][1].append("doc/man/salt-cloud.1")
791             return data_files
792         if IS_WINDOWS_PLATFORM:
793             data_files[0][1].extend(
794                 [
795                     "doc/man/salt-api.1",
796                     "doc/man/salt-cp.1",
797                     "doc/man/salt-key.1",
798                     "doc/man/salt-minion.1",
799                     "doc/man/salt-syndic.1",
800                     "doc/man/spm.1",
801                 ]
802             )
803             return data_files
804         data_files[0][1].extend(
805             [
806                 "doc/man/salt-api.1",
807                 "doc/man/salt-cloud.1",
808                 "doc/man/salt-cp.1",
809                 "doc/man/salt-key.1",
810                 "doc/man/salt-master.1",
811                 "doc/man/salt-minion.1",
812                 "doc/man/salt-proxy.1",
813                 "doc/man/spm.1",
814                 "doc/man/salt.1",
815                 "doc/man/salt-ssh.1",
816                 "doc/man/salt-syndic.1",
817             ]
818         )
819         return data_files
820     @property
821     def _property_install_requires(self):
822         install_requires = []
823         if USE_STATIC_REQUIREMENTS is True:
824             if IS_OSX_PLATFORM:
825                 for reqfile in SALT_OSX_LOCKED_REQS:
826                     install_requires += _parse_requirements_file(reqfile)
827             elif IS_WINDOWS_PLATFORM:
828                 for reqfile in SALT_WINDOWS_LOCKED_REQS:
829                     install_requires += _parse_requirements_file(reqfile)
830             else:
831                 for reqfile in SALT_LINUX_LOCKED_REQS:
832                     install_requires += _parse_requirements_file(reqfile)
833             return install_requires
834         elif USE_STATIC_REQUIREMENTS is False:
835             if IS_OSX_PLATFORM:
836                 for reqfile in SALT_OSX_REQS:
837                     install_requires += _parse_requirements_file(reqfile)
838             elif IS_WINDOWS_PLATFORM:
839                 for reqfile in SALT_WINDOWS_REQS:
840                     install_requires += _parse_requirements_file(reqfile)
841             else:
842                 for reqfile in SALT_BASE_REQUIREMENTS:
843                     install_requires += _parse_requirements_file(reqfile)
844         else:
845             if IS_OSX_PLATFORM:
846                 for reqfile in SALT_OSX_LOCKED_REQS:
847                     install_requires += _parse_requirements_file(reqfile)
848             elif IS_WINDOWS_PLATFORM:
849                 for reqfile in SALT_WINDOWS_LOCKED_REQS:
850                     install_requires += _parse_requirements_file(reqfile)
851             else:
852                 for reqfile in SALT_BASE_REQUIREMENTS:
853                     install_requires += _parse_requirements_file(reqfile)
854         return install_requires
855     @property
856     def _property_scripts(self):
857         scripts = ["scripts/salt-call", "scripts/salt-run"]
858         if self.ssh_packaging or PACKAGED_FOR_SALT_SSH:
859             scripts.append("scripts/salt-ssh")
860             if IS_WINDOWS_PLATFORM:
861                 return scripts
862             scripts.extend(["scripts/salt-cloud", "scripts/spm"])
863             return scripts
864         if IS_WINDOWS_PLATFORM:
865             scripts.extend(
866                 [
867                     "scripts/salt-api",
868                     "scripts/salt-cp",
869                     "scripts/salt-key",
870                     "scripts/salt-minion",
871                     "scripts/salt-syndic",
872                     "scripts/spm",
873                 ]
874             )
875             return scripts
876         scripts.extend(
877             [
878                 "scripts/salt",
879                 "scripts/salt-api",
880                 "scripts/salt-cloud",
881                 "scripts/salt-cp",
882                 "scripts/salt-key",
883                 "scripts/salt-master",
884                 "scripts/salt-minion",
885                 "scripts/salt-proxy",
886                 "scripts/salt-ssh",
887                 "scripts/salt-syndic",
888                 "scripts/spm",
889             ]
890         )
891         return scripts
892     @property
893     def _property_entry_points(self):
894         scripts = [
895             "salt-call = salt.scripts:salt_call",
896             "salt-run = salt.scripts:salt_run",
897         ]
898         if self.ssh_packaging or PACKAGED_FOR_SALT_SSH:
899             scripts.append("salt-ssh = salt.scripts:salt_ssh")
900             if IS_WINDOWS_PLATFORM:
901                 return {"console_scripts": scripts}
902             scripts.append("salt-cloud = salt.scripts:salt_cloud")
903             return {"console_scripts": scripts}
904         if IS_WINDOWS_PLATFORM:
905             scripts.extend(
906                 [
907                     "salt-api = salt.scripts:salt_api",
908                     "salt-cp = salt.scripts:salt_cp",
909                     "salt-key = salt.scripts:salt_key",
910                     "salt-minion = salt.scripts:salt_minion",
911                     "salt-syndic = salt.scripts:salt_syndic",
912                     "spm = salt.scripts:salt_spm",
913                 ]
914             )
915             return {"console_scripts": scripts}
916         scripts.extend(
917             [
918                 "salt = salt.scripts:salt_main",
919                 "salt-api = salt.scripts:salt_api",
920                 "salt-cloud = salt.scripts:salt_cloud",
921                 "salt-cp = salt.scripts:salt_cp",
922                 "salt-key = salt.scripts:salt_key",
923                 "salt-master = salt.scripts:salt_master",
924                 "salt-minion = salt.scripts:salt_minion",
925                 "salt-ssh = salt.scripts:salt_ssh",
926                 "salt-syndic = salt.scripts:salt_syndic",
927                 "spm = salt.scripts:salt_spm",
928             ]
929         )
930         return {"console_scripts": scripts}
931     def setup_esky(self):
932         opt_dict = self.get_option_dict("bdist_esky")
933         opt_dict["freezer_module"] = ("setup script", "bbfreeze")
934         opt_dict["freezer_options"] = (
935             "setup script",
936             {"includes": self.get_esky_freezer_includes()},
937         )
938     @property
939     def _property_freezer_options(self):
940         return {"includes": self.get_esky_freezer_includes()}
941     def get_esky_freezer_includes(self):
942         freezer_includes = [
943             "zmq.core.*",
944             "zmq.utils.*",
945             "ast",
946             "csv",
947             "difflib",
948             "distutils",
949             "distutils.version",
950             "numbers",
951             "json",
952             "M2Crypto",
953             "Cookie",
954             "asyncore",
955             "fileinput",
956             "sqlite3",
957             "email",
958             "email.mime.*",
959             "requests",
960             "sqlite3",
961         ]
962         if HAS_ZMQ and hasattr(zmq, "pyzmq_version_info"):
963             if HAS_ZMQ and zmq.pyzmq_version_info() &gt;= (0, 14):
964                 if "zmq.core.*" in freezer_includes:
965                     freezer_includes.remove("zmq.core.*")
966         if IS_WINDOWS_PLATFORM:
967             freezer_includes.extend(
968                 [
969                     "imp",
970                     "win32api",
971                     "win32file",
972                     "win32con",
973                     "win32com",
974                     "win32net",
975                     "win32netcon",
976                     "win32gui",
977                     "win32security",
978                     "ntsecuritycon",
979                     "pywintypes",
980                     "pythoncom",
981                     "_winreg",
982                     "wmi",
983                     "site",
984                     "psutil",
985                     "pytz",
986                 ]
987             )
988         elif IS_SMARTOS_PLATFORM:
989             freezer_includes.extend(
990                 ["cherrypy", "python-dateutil", "pyghmi", "croniter", "mako", "gnupg"]
991             )
992         elif sys.platform.startswith("linux"):
993             freezer_includes.append("spwd")
994             try:
995                 import yum  # pylint: disable=unused-import
996                 freezer_includes.append("yum")
997             except ImportError:
998                 pass
999         elif sys.platform.startswith("sunos"):
1000             try:
1001                 from bbfreeze.modulegraph.modulegraph import ModuleGraph
1002                 mgraph = ModuleGraph(sys.path[:])
1003                 for arg in glob.glob("salt/modules/*.py"):
1004                     mgraph.run_script(arg)
1005                 for mod in mgraph.flatten():
1006                     if type(mod).__name__ != "Script" and mod.filename:
1007                         freezer_includes.append(str(os.path.basename(mod.identifier)))
1008             except ImportError:
1009                 pass
1010         return freezer_includes
1011     def parse_command_line(self):
1012         args = distutils.dist.Distribution.parse_command_line(self)
1013         if not self.ssh_packaging and PACKAGED_FOR_SALT_SSH:
1014             self.ssh_packaging = 1
1015         if self.ssh_packaging:
1016             self.metadata.name = "salt-ssh"
1017             self.salt_transport = "ssh"
1018         elif self.salt_transport is None:
1019             self.salt_transport = "zeromq"
1020         if self.salt_transport not in ("zeromq", "both", "ssh", "none"):
1021             raise DistutilsArgError(
1022                 "The value of --salt-transport needs be 'zeromq', "
1023                 "'both', 'ssh', or 'none' not '{}'".format(self.salt_transport)
1024             )
1025         for funcname in dir(self):
1026             if not funcname.startswith("_property_"):
1027                 continue
1028             property_name = funcname.split("_property_", 1)[-1]
1029             setattr(self, property_name, getattr(self, funcname))
1030         return args
1031 if __name__ == "__main__":
1032     setup(distclass=SaltDistribution)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
