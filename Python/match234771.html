<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for netutil.py &amp; setup.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for netutil.py &amp; setup.py
      </h3>
<h1 align="center">
        1.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>netutil.py (2.550091%)<th>setup.py (0.84592146%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(20-35)<td><a href="#" name="0">(21-38)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>netutil.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<a name="0"></a>"""Miscellaneous network utility code."""
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>from __future__ import absolute_import, division, print_function
import errno
import os
import sys
import socket
import stat
from salt.ext.tornado.concurrent import dummy_executor, run_on_executor
from salt.ext.tornado.ioloop import IOLoop
from salt.ext.tornado.platform.auto import set_close_exec
from salt.ext.tornado.util import PY3, Configurable, errno_from_exception
try:
    import ssl
e</b></font>xcept ImportError:
    ssl = None
try:
    import certifi
except ImportError:
    if ssl is None or hasattr(ssl, 'create_default_context'):
        certifi = None
    else:
        raise
if PY3:
    xrange = range
if hasattr(ssl, 'match_hostname') and hasattr(ssl, 'CertificateError'):  # python 3.2+
    ssl_match_hostname = ssl.match_hostname
    SSLCertificateError = ssl.CertificateError
elif ssl is None:
    ssl_match_hostname = SSLCertificateError = None  # type: ignore
else:
    import backports.ssl_match_hostname
    ssl_match_hostname = backports.ssl_match_hostname.match_hostname
    SSLCertificateError = backports.ssl_match_hostname.CertificateError  # type: ignore
if hasattr(ssl, 'SSLContext'):
    if hasattr(ssl, 'create_default_context'):
        _client_ssl_defaults = ssl.create_default_context(
            ssl.Purpose.SERVER_AUTH)
        _server_ssl_defaults = ssl.create_default_context(
            ssl.Purpose.CLIENT_AUTH)
    else:
        _client_ssl_defaults = ssl.SSLContext(ssl.PROTOCOL_SSLv23)
        _client_ssl_defaults.verify_mode = ssl.CERT_REQUIRED
        _client_ssl_defaults.load_verify_locations(certifi.where())
        _server_ssl_defaults = ssl.SSLContext(ssl.PROTOCOL_SSLv23)
        if hasattr(ssl, 'OP_NO_COMPRESSION'):
            _client_ssl_defaults.options |= ssl.OP_NO_COMPRESSION
            _server_ssl_defaults.options |= ssl.OP_NO_COMPRESSION
elif ssl:
    _client_ssl_defaults = dict(cert_reqs=ssl.CERT_REQUIRED,
                                ca_certs=certifi.where())
    _server_ssl_defaults = {}
else:
    _client_ssl_defaults = dict(cert_reqs=None,
                                ca_certs=None)
    _server_ssl_defaults = {}
u'foo'.encode('idna')
u'foo'.encode('latin1')
_ERRNO_WOULDBLOCK = (errno.EWOULDBLOCK, errno.EAGAIN)
if hasattr(errno, "WSAEWOULDBLOCK"):
    _ERRNO_WOULDBLOCK += (errno.WSAEWOULDBLOCK,)  # type: ignore
_DEFAULT_BACKLOG = 128
def bind_sockets(port, address=None, family=socket.AF_UNSPEC,
                 backlog=_DEFAULT_BACKLOG, flags=None, reuse_port=False):
    if reuse_port and not hasattr(socket, "SO_REUSEPORT"):
        raise ValueError("the platform doesn't support SO_REUSEPORT")
    sockets = []
    if address == "":
        address = None
    if not socket.has_ipv6 and family == socket.AF_UNSPEC:
        family = socket.AF_INET
    if flags is None:
        flags = socket.AI_PASSIVE
    bound_port = None
    for res in set(socket.getaddrinfo(address, port, family, socket.SOCK_STREAM,
                                      0, flags)):
        af, socktype, proto, canonname, sockaddr = res
        if (sys.platform == 'darwin' and address == 'localhost' and
                af == socket.AF_INET6 and sockaddr[3] != 0):
            continue
        try:
            sock = socket.socket(af, socktype, proto)
        except socket.error as e:
            if errno_from_exception(e) == errno.EAFNOSUPPORT:
                continue
            raise
        set_close_exec(sock.fileno())
        if os.name != 'nt':
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        if reuse_port:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)
        if af == socket.AF_INET6:
            if hasattr(socket, "IPPROTO_IPV6"):
                sock.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_V6ONLY, 1)
        host, requested_port = sockaddr[:2]
        if requested_port == 0 and bound_port is not None:
            sockaddr = tuple([host, bound_port] + list(sockaddr[2:]))
        sock.setblocking(0)
        sock.bind(sockaddr)
        bound_port = sock.getsockname()[1]
        sock.listen(backlog)
        sockets.append(sock)
    return sockets
if hasattr(socket, 'AF_UNIX'):
    def bind_unix_socket(file, mode=0o600, backlog=_DEFAULT_BACKLOG):
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        set_close_exec(sock.fileno())
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.setblocking(0)
        try:
            st = os.stat(file)
        except OSError as err:
            if errno_from_exception(err) != errno.ENOENT:
                raise
        else:
            if stat.S_ISSOCK(st.st_mode):
                os.remove(file)
            else:
                raise ValueError("File %s exists and is not a socket", file)
        sock.bind(file)
        os.chmod(file, mode)
        sock.listen(backlog)
        return sock
def add_accept_handler(sock, callback, io_loop=None):
    if io_loop is None:
        io_loop = IOLoop.current()
    def accept_handler(fd, events):
        for i in xrange(_DEFAULT_BACKLOG):
            try:
                connection, address = sock.accept()
            except socket.error as e:
                if errno_from_exception(e) in _ERRNO_WOULDBLOCK:
                    return
                if errno_from_exception(e) == errno.ECONNABORTED:
                    continue
                raise
            set_close_exec(connection.fileno())
            callback(connection, address)
    io_loop.add_handler(sock, accept_handler, IOLoop.READ)
def is_valid_ip(ip):
    if not ip or '\x00' in ip:
        return False
    try:
        res = socket.getaddrinfo(ip, 0, socket.AF_UNSPEC,
                                 socket.SOCK_STREAM,
                                 0, socket.AI_NUMERICHOST)
        return bool(res)
    except socket.gaierror as e:
        if e.args[0] == socket.EAI_NONAME:
            return False
        raise
    return True
class Resolver(Configurable):
    @classmethod
    def configurable_base(cls):
        return Resolver
    @classmethod
    def configurable_default(cls):
        return BlockingResolver
    def resolve(self, host, port, family=socket.AF_UNSPEC, callback=None):
        raise NotImplementedError()
    def close(self):
        pass
class ExecutorResolver(Resolver):
    def initialize(self, io_loop=None, executor=None, close_executor=True):
        self.io_loop = io_loop or IOLoop.current()
        if executor is not None:
            self.executor = executor
            self.close_executor = close_executor
        else:
            self.executor = dummy_executor
            self.close_executor = False
    def close(self):
        if self.close_executor:
            self.executor.shutdown()
        self.executor = None
    @run_on_executor
    def resolve(self, host, port, family=socket.AF_UNSPEC):
        addrinfo = socket.getaddrinfo(host, port, family, socket.SOCK_STREAM)
        results = []
        for family, socktype, proto, canonname, address in addrinfo:
            results.append((family, address))
        return results
class BlockingResolver(ExecutorResolver):
    def initialize(self, io_loop=None):
        super(BlockingResolver, self).initialize(io_loop=io_loop)
class ThreadedResolver(ExecutorResolver):
    _threadpool = None  # type: ignore
    _threadpool_pid = None  # type: int
    def initialize(self, io_loop=None, num_threads=10):
        threadpool = ThreadedResolver._create_threadpool(num_threads)
        super(ThreadedResolver, self).initialize(
            io_loop=io_loop, executor=threadpool, close_executor=False)
    @classmethod
    def _create_threadpool(cls, num_threads):
        pid = os.getpid()
        if cls._threadpool_pid != pid:
            cls._threadpool = None
        if cls._threadpool is None:
            from concurrent.futures import ThreadPoolExecutor
            cls._threadpool = ThreadPoolExecutor(num_threads)
            cls._threadpool_pid = pid
        return cls._threadpool
class OverrideResolver(Resolver):
    def initialize(self, resolver, mapping):
        self.resolver = resolver
        self.mapping = mapping
    def close(self):
        self.resolver.close()
    def resolve(self, host, port, *args, **kwargs):
        if (host, port) in self.mapping:
            host, port = self.mapping[(host, port)]
        elif host in self.mapping:
            host = self.mapping[host]
        return self.resolver.resolve(host, port, *args, **kwargs)
_SSL_CONTEXT_KEYWORDS = frozenset(['ssl_version', 'certfile', 'keyfile',
                                   'cert_reqs', 'ca_certs', 'ciphers'])
def ssl_options_to_context(ssl_options):
    if isinstance(ssl_options, dict):
        assert all(k in _SSL_CONTEXT_KEYWORDS for k in ssl_options), ssl_options
    if (not hasattr(ssl, 'SSLContext') or
            isinstance(ssl_options, ssl.SSLContext)):
        return ssl_options
    context = ssl.SSLContext(
        ssl_options.get('ssl_version', ssl.PROTOCOL_SSLv23))
    if 'certfile' in ssl_options:
        context.load_cert_chain(ssl_options['certfile'], ssl_options.get('keyfile', None))
    if 'cert_reqs' in ssl_options:
        context.verify_mode = ssl_options['cert_reqs']
    if 'ca_certs' in ssl_options:
        context.load_verify_locations(ssl_options['ca_certs'])
    if 'ciphers' in ssl_options:
        context.set_ciphers(ssl_options['ciphers'])
    if hasattr(ssl, 'OP_NO_COMPRESSION'):
        context.options |= ssl.OP_NO_COMPRESSION
    return context
def ssl_wrap_socket(socket, ssl_options, server_hostname=None, **kwargs):
    context = ssl_options_to_context(ssl_options)
    if hasattr(ssl, 'SSLContext') and isinstance(context, ssl.SSLContext):
        if server_hostname is not None and getattr(ssl, 'HAS_SNI'):
            return context.wrap_socket(socket, server_hostname=server_hostname,
                                       **kwargs)
        else:
            return context.wrap_socket(socket, **kwargs)
    else:
        return ssl.wrap_socket(socket, **dict(context, **kwargs))  # type: ignore
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>setup.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import contextlib
import distutils.dist
import glob
import operator
import os
import platform
import sys
from ctypes.util import find_library
from datetime import datetime
<a name="0"></a>from distutils import log
from distutils.cmd import Command
from distutils.command.build import build
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>from distutils.command.clean import clean
from distutils.command.install_lib import install_lib
from distutils.errors import DistutilsArgError
from distutils.version import LooseVersion  # pylint: disable=blacklisted-module
import setuptools
from setuptools import setup
from setuptools.command.bdist_egg import bdist_egg
from setuptools.command.develop import develop
from setuptools.command.install import install
from setuptools.command.sdist import sdist
try:
    from urllib2 import urlopen
e</b></font>xcept ImportError:
    from urllib.request import urlopen  # pylint: disable=no-name-in-module
try:
    from wheel.bdist_wheel import bdist_wheel
    HAS_BDIST_WHEEL = True
except ImportError:
    HAS_BDIST_WHEEL = False
try:
    import zmq
    HAS_ZMQ = True
except ImportError:
    HAS_ZMQ = False
try:
    DATE = datetime.utcfromtimestamp(int(os.environ["SOURCE_DATE_EPOCH"]))
except (KeyError, ValueError):
    DATE = datetime.utcnow()
try:
    SETUP_DIRNAME = os.path.dirname(__file__)
except NameError:
    SETUP_DIRNAME = os.path.dirname(sys.argv[0])
if SETUP_DIRNAME != "":
    os.chdir(SETUP_DIRNAME)
SETUP_DIRNAME = os.path.abspath(SETUP_DIRNAME)
BOOTSTRAP_SCRIPT_DISTRIBUTED_VERSION = os.environ.get(
    "BOOTSTRAP_SCRIPT_VERSION",
    "v2014.06.21",
)
IS_OSX_PLATFORM = sys.platform.startswith("darwin")
IS_WINDOWS_PLATFORM = sys.platform.startswith("win")
if IS_WINDOWS_PLATFORM or IS_OSX_PLATFORM:
    IS_SMARTOS_PLATFORM = False
else:
    IS_SMARTOS_PLATFORM = os.uname()[0] == "SunOS" and os.uname()[3].startswith(
        "joyent_"
    )
USE_STATIC_REQUIREMENTS = os.environ.get("USE_STATIC_REQUIREMENTS")
if USE_STATIC_REQUIREMENTS is not None:
    USE_STATIC_REQUIREMENTS = USE_STATIC_REQUIREMENTS == "1"
try:
    import bbfreeze  # pylint: disable=unused-import
    from esky import bdist_esky  # pylint: disable=unused-import
    HAS_ESKY = True
except ImportError:
    HAS_ESKY = False
SALT_VERSION = os.path.join(os.path.abspath(SETUP_DIRNAME), "salt", "version.py")
SALT_VERSION_HARDCODED = os.path.join(
    os.path.abspath(SETUP_DIRNAME), "salt", "_version.py"
)
SALT_SYSPATHS_HARDCODED = os.path.join(
    os.path.abspath(SETUP_DIRNAME), "salt", "_syspaths.py"
)
SALT_BASE_REQUIREMENTS = [
    os.path.join(os.path.abspath(SETUP_DIRNAME), "requirements", "base.txt"),
    os.path.join(os.path.abspath(SETUP_DIRNAME), "requirements", "zeromq.txt"),
    os.path.join(os.path.abspath(SETUP_DIRNAME), "requirements", "crypto.txt"),
]
SALT_LINUX_LOCKED_REQS = [
    os.path.join(
        os.path.abspath(SETUP_DIRNAME),
        "requirements",
        "static",
        "pkg",
        "py{}.{}".format(*sys.version_info),
        "linux.txt",
    )
]
SALT_OSX_REQS = SALT_BASE_REQUIREMENTS + [
    os.path.join(os.path.abspath(SETUP_DIRNAME), "requirements", "darwin.txt")
]
SALT_OSX_LOCKED_REQS = [
    os.path.join(
        os.path.abspath(SETUP_DIRNAME),
        "requirements",
        "static",
        "pkg",
        "py{}.{}".format(*sys.version_info),
        "darwin.txt",
    )
]
SALT_WINDOWS_REQS = SALT_BASE_REQUIREMENTS + [
    os.path.join(os.path.abspath(SETUP_DIRNAME), "requirements", "windows.txt")
]
SALT_WINDOWS_LOCKED_REQS = [
    os.path.join(
        os.path.abspath(SETUP_DIRNAME),
        "requirements",
        "static",
        "pkg",
        "py{}.{}".format(*sys.version_info),
        "windows.txt",
    )
]
SALT_LONG_DESCRIPTION_FILE = os.path.join(os.path.abspath(SETUP_DIRNAME), "README.rst")
PACKAGED_FOR_SALT_SSH_FILE = os.path.join(
    os.path.abspath(SETUP_DIRNAME), ".salt-ssh-package"
)
PACKAGED_FOR_SALT_SSH = os.path.isfile(PACKAGED_FOR_SALT_SSH_FILE)
exec(compile(open(SALT_VERSION).read(), SALT_VERSION, "exec"))
def _parse_op(op):
    op = op.strip()
    if "&gt;" in op:
        if "=" in op:
            return "ge"
        else:
            return "gt"
    elif "&lt;" in op:
        if "=" in op:
            return "le"
        else:
            return "lt"
    elif "!" in op:
        return "ne"
    else:
        return "eq"
def _parse_ver(ver):
    if "#" in ver:
        ver, _ = ver.split("#", 1)
        ver = ver.strip()
    return ver.strip("'").strip('"')
def _check_ver(pyver, op, wanted):
    pyver = distutils.version.LooseVersion(pyver)
    wanted = distutils.version.LooseVersion(wanted)
    if not isinstance(pyver, str):
        pyver = str(pyver)
    if not isinstance(wanted, str):
        wanted = str(wanted)
    return getattr(operator, "__{}__".format(op))(pyver, wanted)
def _parse_requirements_file(requirements_file):
    parsed_requirements = []
    with open(requirements_file) as rfh:
        for line in rfh.readlines():
            line = line.strip()
            if not line or line.startswith(("#", "-r", "--")):
                continue
            if IS_WINDOWS_PLATFORM:
                if "libcloud" in line:
                    continue
            try:
                pkg, pyverspec = line.rsplit(";", 1)
            except ValueError:
                pkg, pyverspec = line, ""
            pyverspec = pyverspec.strip()
            if pyverspec and (
                not pkg.startswith("pycrypto") or pkg.startswith("pycryptodome")
            ):
                _, op, ver = pyverspec.split(" ", 2)
                if not _check_ver(
                    platform.python_version(), _parse_op(op), _parse_ver(ver)
                ):
                    continue
            parsed_requirements.append(line)
    return parsed_requirements
class WriteSaltVersion(Command):
    description = "Write salt's hardcoded version file"
    user_options = []
    def initialize_options(self):
    def finalize_options(self):
    def run(self):
        if (
            not os.path.exists(SALT_VERSION_HARDCODED)
            or self.distribution.with_salt_version
        ):
            if getattr(self.distribution, "salt_version_hardcoded_path", None) is None:
                self.distribution.salt_version_hardcoded_path = SALT_VERSION_HARDCODED
                sys.stderr.write("This command is not meant to be called on it's own\n")
                sys.stderr.flush()
            if not self.distribution.with_salt_version:
                salt_version = (
                    __saltstack_version__  # pylint: disable=undefined-variable
                )
            else:
                from salt.version import SaltStackVersion
                salt_version = SaltStackVersion.parse(
                    self.distribution.with_salt_version
                )
            open(self.distribution.salt_version_hardcoded_path, "w").write(
                INSTALL_VERSION_TEMPLATE.format(
                    date=DATE, full_version_info=salt_version.full_info_all_versions
                )
            )
class GenerateSaltSyspaths(Command):
    description = "Generate salt's hardcoded syspaths file"
    def initialize_options(self):
        pass
    def finalize_options(self):
        pass
    def run(self):
        if getattr(self.distribution, "salt_syspaths_hardcoded_path", None) is None:
            print("This command is not meant to be called on it's own")
            exit(1)
        open(self.distribution.salt_syspaths_hardcoded_path, "w").write(
            INSTALL_SYSPATHS_TEMPLATE.format(
                date=DATE,
                root_dir=self.distribution.salt_root_dir,
                share_dir=self.distribution.salt_share_dir,
                config_dir=self.distribution.salt_config_dir,
                cache_dir=self.distribution.salt_cache_dir,
                sock_dir=self.distribution.salt_sock_dir,
                srv_root_dir=self.distribution.salt_srv_root_dir,
                base_file_roots_dir=self.distribution.salt_base_file_roots_dir,
                base_pillar_roots_dir=self.distribution.salt_base_pillar_roots_dir,
                base_master_roots_dir=self.distribution.salt_base_master_roots_dir,
                base_thorium_roots_dir=self.distribution.salt_base_thorium_roots_dir,
                logs_dir=self.distribution.salt_logs_dir,
                pidfile_dir=self.distribution.salt_pidfile_dir,
                spm_parent_path=self.distribution.salt_spm_parent_dir,
                spm_formula_path=self.distribution.salt_spm_formula_dir,
                spm_pillar_path=self.distribution.salt_spm_pillar_dir,
                spm_reactor_path=self.distribution.salt_spm_reactor_dir,
                home_dir=self.distribution.salt_home_dir,
            )
        )
class WriteSaltSshPackagingFile(Command):
    description = "Write salt's ssh packaging file"
    user_options = []
    def initialize_options(self):
    def finalize_options(self):
    def run(self):
        if not os.path.exists(PACKAGED_FOR_SALT_SSH_FILE):
            if getattr(self.distribution, "salt_ssh_packaging_file", None) is None:
                print("This command is not meant to be called on it's own")
                exit(1)
            open(self.distribution.salt_ssh_packaging_file, "w").write(
                "Packaged for Salt-SSH\n"
            )
class Develop(develop):
    user_options = develop.user_options + [
        (
            "write-salt-version",
            None,
            "Generate Salt's _version.py file which allows proper version "
            "reporting. This defaults to False on develop/editable setups. "
            "If WRITE_SALT_VERSION is found in the environment this flag is "
            "switched to True.",
        ),
        (
            "generate-salt-syspaths",
            None,
            "Generate Salt's _syspaths.py file which allows tweaking some "
            "common paths that salt uses. This defaults to False on "
            "develop/editable setups. If GENERATE_SALT_SYSPATHS is found in "
            "the environment this flag is switched to True.",
        ),
        (
            "mimic-salt-install",
            None,
            "Mimmic the install command when running the develop command. "
            "This will generate salt's _version.py and _syspaths.py files. "
            "Generate Salt's _syspaths.py file which allows tweaking some "
            "This defaults to False on develop/editable setups. "
            "If MIMIC_INSTALL is found in the environment this flag is "
            "switched to True.",
        ),
    ]
    boolean_options = develop.boolean_options + [
        "write-salt-version",
        "generate-salt-syspaths",
        "mimic-salt-install",
    ]
    def initialize_options(self):
        develop.initialize_options(self)
        self.write_salt_version = False
        self.generate_salt_syspaths = False
        self.mimic_salt_install = False
    def finalize_options(self):
        develop.finalize_options(self)
        if "WRITE_SALT_VERSION" in os.environ:
            self.write_salt_version = True
        if "GENERATE_SALT_SYSPATHS" in os.environ:
            self.generate_salt_syspaths = True
        if "MIMIC_SALT_INSTALL" in os.environ:
            self.mimic_salt_install = True
        if self.mimic_salt_install:
            self.write_salt_version = True
            self.generate_salt_syspaths = True
    def run(self):
        if IS_WINDOWS_PLATFORM:
            self.distribution.salt_download_windows_dlls = True
            self.run_command("download-windows-dlls")
            self.distribution.salt_download_windows_dlls = None
        if self.write_salt_version is True:
            self.distribution.running_salt_install = True
            self.distribution.salt_version_hardcoded_path = SALT_VERSION_HARDCODED
            self.run_command("write_salt_version")
        if self.generate_salt_syspaths:
            self.distribution.salt_syspaths_hardcoded_path = SALT_SYSPATHS_HARDCODED
            self.run_command("generate_salt_syspaths")
        develop.run(self)
class DownloadWindowsDlls(Command):
    description = "Download required DLL's for windows"
    def initialize_options(self):
        pass
    def finalize_options(self):
        pass
    def run(self):
        if getattr(self.distribution, "salt_download_windows_dlls", None) is None:
            print("This command is not meant to be called on it's own")
            exit(1)
        try:
            import pip
            if LooseVersion(pip.__version__) &lt; LooseVersion("10.0"):
                from pip.utils.logging import indent_log
            else:
                from pip._internal.utils.logging import (  # pylint: disable=no-name-in-module
                    indent_log,
                )
        except ImportError:
            @contextlib.contextmanager
            def indent_log():
                yield
        platform_bits, _ = platform.architecture()
        url = "https://repo.saltproject.io/windows/dependencies/{bits}/{fname}"
        dest = os.path.join(os.path.dirname(sys.executable), "{fname}")
        with indent_log():
            for fname in (
                "openssl/1.1.1k/ssleay32.dll",
                "openssl/1.1.1k/libeay32.dll",
                "libsodium/1.0.18/libsodium.dll",
            ):
                if find_library(fname):
                    continue
                furl = url.format(bits=platform_bits[:2], fname=fname)
                fdest = dest.format(fname=os.path.basename(fname))
                if not os.path.exists(fdest):
                    log.info("Downloading {} to {} from {}".format(fname, fdest, furl))
                    try:
                        from contextlib import closing
                        import requests
                        with closing(requests.get(furl, stream=True)) as req:
                            if req.status_code == 200:
                                with open(fdest, "wb") as wfh:
                                    for chunk in req.iter_content(chunk_size=4096):
                                        if chunk:  # filter out keep-alive new chunks
                                            wfh.write(chunk)
                                            wfh.flush()
                            else:
                                log.error(
                                    "Failed to download {} to {} from {}".format(
                                        fname, fdest, furl
                                    )
                                )
                    except ImportError:
                        req = urlopen(furl)
                        if req.getcode() == 200:
                            with open(fdest, "wb") as wfh:
                                while True:
                                    chunk = req.read(4096)
                                    if not chunk:
                                        break
                                    wfh.write(chunk)
                                    wfh.flush()
                        else:
                            log.error(
                                "Failed to download {} to {} from {}".format(
                                    fname, fdest, furl
                                )
                            )
class Sdist(sdist):
    def make_release_tree(self, base_dir, files):
        if self.distribution.ssh_packaging:
            self.distribution.salt_ssh_packaging_file = PACKAGED_FOR_SALT_SSH_FILE
            self.run_command("write_salt_ssh_packaging_file")
            self.filelist.files.append(os.path.basename(PACKAGED_FOR_SALT_SSH_FILE))
        sdist.make_release_tree(self, base_dir, files)
        self.distribution.running_salt_sdist = True
        self.distribution.salt_version_hardcoded_path = os.path.join(
            base_dir, "salt", "_version.py"
        )
        self.run_command("write_salt_version")
    def make_distribution(self):
        sdist.make_distribution(self)
        if self.distribution.ssh_packaging:
            os.unlink(PACKAGED_FOR_SALT_SSH_FILE)
class BDistEgg(bdist_egg):
    def finalize_options(self):
        bdist_egg.finalize_options(self)
        self.distribution.build_egg = True
        if not self.skip_build:
            self.run_command("build")
class CloudSdist(Sdist):  # pylint: disable=too-many-ancestors
    user_options = Sdist.user_options + [
        (
            "download-bootstrap-script",
            None,
            "Download the latest stable bootstrap-salt.sh script. This "
            "can also be triggered by having `DOWNLOAD_BOOTSTRAP_SCRIPT=1` as an "
            "environment variable.",
        )
    ]
    boolean_options = Sdist.boolean_options + ["download-bootstrap-script"]
    def initialize_options(self):
        Sdist.initialize_options(self)
        self.skip_bootstrap_download = True
        self.download_bootstrap_script = False
    def finalize_options(self):
        Sdist.finalize_options(self)
        if "SKIP_BOOTSTRAP_DOWNLOAD" in os.environ:
            log(
                "Please stop using 'SKIP_BOOTSTRAP_DOWNLOAD' and use "
                "'DOWNLOAD_BOOTSTRAP_SCRIPT' instead"
            )
        if "DOWNLOAD_BOOTSTRAP_SCRIPT" in os.environ:
            download_bootstrap_script = os.environ.get("DOWNLOAD_BOOTSTRAP_SCRIPT", "0")
            self.download_bootstrap_script = download_bootstrap_script == "1"
    def run(self):
        if self.download_bootstrap_script is True:
            url = (
                "https://github.com/saltstack/salt-bootstrap/raw/{}"
                "/bootstrap-salt.sh".format(BOOTSTRAP_SCRIPT_DISTRIBUTED_VERSION)
            )
            deploy_path = os.path.join(
                SETUP_DIRNAME, "salt", "cloud", "deploy", "bootstrap-salt.sh"
            )
            log.info(
                "Updating bootstrap-salt.sh."
                "\n\tSource:      {}"
                "\n\tDestination: {}".format(url, deploy_path)
            )
            try:
                import requests
                req = requests.get(url)
                if req.status_code == 200:
                    script_contents = req.text.encode(req.encoding)
                else:
                    log.error(
                        "Failed to update the bootstrap-salt.sh script. HTTP "
                        "Error code: {}".format(req.status_code)
                    )
            except ImportError:
                req = urlopen(url)
                if req.getcode() == 200:
                    script_contents = req.read()
                else:
                    log.error(
                        "Failed to update the bootstrap-salt.sh script. HTTP "
                        "Error code: {}".format(req.getcode())
                    )
            try:
                with open(deploy_path, "w") as fp_:
                    fp_.write(script_contents)
            except OSError as err:
                log.error("Failed to write the updated script: {}".format(err))
        Sdist.run(self)
    def write_manifest(self):
        dist_scripts = self.distribution.scripts
        for script in self.filelist.files[:]:
            if not script.startswith("scripts/"):
                continue
            if script not in dist_scripts:
                self.filelist.files.remove(script)
        return Sdist.write_manifest(self)
class TestCommand(Command):
    description = "Run tests"
    user_options = [
        ("runtests-opts=", "R", "Command line options to pass to runtests.py")
    ]
    def initialize_options(self):
        self.runtests_opts = None
    def finalize_options(self):
    def run(self):
        import subprocess
        self.run_command("build")
        build_cmd = self.get_finalized_command("build_ext")
        runner = os.path.abspath("tests/runtests.py")
        test_cmd = [sys.executable, runner]
        if self.runtests_opts:
            test_cmd.extend(self.runtests_opts.split())
        print("running test")
        ret = subprocess.run(
            test_cmd,
            stdout=sys.stdout,
            stderr=sys.stderr,
            cwd=build_cmd.build_lib,
            check=False,
        )
        sys.exit(ret.returncode)
class Clean(clean):
    def run(self):
        clean.run(self)
        for subdir in ("salt", "tests", "doc"):
            root = os.path.join(os.path.dirname(__file__), subdir)
            for dirname, _, _ in os.walk(root):
                for to_remove_filename in glob.glob("{}/*.py[oc]".format(dirname)):
                    os.remove(to_remove_filename)
if HAS_BDIST_WHEEL:
    class BDistWheel(bdist_wheel):
        def finalize_options(self):
            bdist_wheel.finalize_options(self)
            self.distribution.build_wheel = True
INSTALL_VERSION_TEMPLATE = """\
from salt.version import SaltStackVersion
__saltstack_version__ = SaltStackVersion{full_version_info!r}
class Build(build):
    def run(self):
        build.run(self)
        salt_build_ver_file = os.path.join(self.build_lib, "salt", "_version.py")
        if getattr(self.distribution, "with_salt_version", False):
            self.distribution.salt_version_hardcoded_path = salt_build_ver_file
            self.run_command("write_salt_version")
        if getattr(self.distribution, "build_egg", False):
            self.distribution.salt_version_hardcoded_path = salt_build_ver_file
            self.run_command("write_salt_version")
        if getattr(self.distribution, "build_wheel", False):
            self.distribution.salt_version_hardcoded_path = salt_build_ver_file
            self.run_command("write_salt_version")
        if getattr(self.distribution, "running_salt_install", False):
            self.run_command("write_salt_version")
            self.distribution.salt_syspaths_hardcoded_path = os.path.join(
                self.build_lib, "salt", "_syspaths.py"
            )
            self.run_command("generate_salt_syspaths")
class Install(install):
    def initialize_options(self):
        install.initialize_options(self)
    def finalize_options(self):
        install.finalize_options(self)
    def run(self):
        if LooseVersion(setuptools.__version__) &lt; LooseVersion("9.1"):
            sys.stderr.write(
                "\n\nInstalling Salt requires setuptools &gt;= 9.1\n"
                "Available setuptools version is {}\n\n".format(setuptools.__version__)
            )
            sys.stderr.flush()
            sys.exit(1)
        self.distribution.running_salt_install = True
        self.distribution.salt_version_hardcoded_path = os.path.join(
            self.build_lib, "salt", "_version.py"
        )
        if IS_WINDOWS_PLATFORM:
            self.distribution.salt_download_windows_dlls = True
            self.run_command("download-windows-dlls")
            self.distribution.salt_download_windows_dlls = None
        if not os.path.exists(os.path.join(self.build_lib)):
            if not self.skip_build:
                self.run_command("build")
        else:
            self.run_command("write_salt_version")
        install.run(self)
    @staticmethod
    def _called_from_setup(run_frame):
        if run_frame is None:
            return install._called_from_setup(run_frame)
        first_call = install._called_from_setup(run_frame)
        if first_call:
            return True
        second_call = install._called_from_setup(run_frame.f_back)
        if second_call is None:
            return first_call
        return second_call
class InstallLib(install_lib):
    def run(self):
        executables = [
            "salt/templates/git/ssh-id-wrapper",
            "salt/templates/lxc/salt_tarball",
        ]
        install_lib.run(self)
        inp = self.get_inputs()
        out = self.get_outputs()
        chmod = []
        for idx, inputfile in enumerate(inp):
            for executable in executables:
                if inputfile.endswith(executable):
                    chmod.append(idx)
        for idx in chmod:
            filename = out[idx]
            os.chmod(filename, 0o755)
class SaltDistribution(distutils.dist.Distribution):
    global_options = (
        distutils.dist.Distribution.global_options
        + [
            ("ssh-packaging", None, "Run in SSH packaging mode"),
            (
                "salt-transport=",
                None,
                "The transport to prepare salt for. Currently, the only choice "
                "is 'zeromq'. This may be expanded in the future. Defaults to "
                "'zeromq'",
                "zeromq",
            ),
        ]
        + [
            (
                "with-salt-version=",
                None,
                "Set a fixed version for Salt instead calculating it",
            ),
            ("salt-root-dir=", None, "Salt's pre-configured root directory"),
            ("salt-share-dir=", None, "Salt's pre-configured share directory"),
            ("salt-config-dir=", None, "Salt's pre-configured configuration directory"),
            ("salt-cache-dir=", None, "Salt's pre-configured cache directory"),
            ("salt-sock-dir=", None, "Salt's pre-configured socket directory"),
            ("salt-srv-root-dir=", None, "Salt's pre-configured service directory"),
            (
                "salt-base-file-roots-dir=",
                None,
                "Salt's pre-configured file roots directory",
            ),
            (
                "salt-base-pillar-roots-dir=",
                None,
                "Salt's pre-configured pillar roots directory",
            ),
            (
                "salt-base-master-roots-dir=",
                None,
                "Salt's pre-configured master roots directory",
            ),
            ("salt-logs-dir=", None, "Salt's pre-configured logs directory"),
            ("salt-pidfile-dir=", None, "Salt's pre-configured pidfiles directory"),
            (
                "salt-spm-formula-dir=",
                None,
                "Salt's pre-configured SPM formulas directory",
            ),
            (
                "salt-spm-pillar-dir=",
                None,
                "Salt's pre-configured SPM pillar directory",
            ),
            (
                "salt-spm-reactor-dir=",
                None,
                "Salt's pre-configured SPM reactor directory",
            ),
            ("salt-home-dir=", None, "Salt's pre-configured user home directory"),
        ]
    )
    def __init__(self, attrs=None):
        distutils.dist.Distribution.__init__(self, attrs)
        self.ssh_packaging = PACKAGED_FOR_SALT_SSH
        self.salt_transport = None
        self.salt_root_dir = None
        self.salt_share_dir = None
        self.salt_config_dir = None
        self.salt_cache_dir = None
        self.salt_sock_dir = None
        self.salt_srv_root_dir = None
        self.salt_base_file_roots_dir = None
        self.salt_base_thorium_roots_dir = None
        self.salt_base_pillar_roots_dir = None
        self.salt_base_master_roots_dir = None
        self.salt_logs_dir = None
        self.salt_pidfile_dir = None
        self.salt_spm_parent_dir = None
        self.salt_spm_formula_dir = None
        self.salt_spm_pillar_dir = None
        self.salt_spm_reactor_dir = None
        self.salt_home_dir = None
        self.with_salt_version = None
        self.name = "salt-ssh" if PACKAGED_FOR_SALT_SSH else "salt"
        self.salt_version = __version__  # pylint: disable=undefined-variable
        self.description = (
            "Portable, distributed, remote execution and configuration management"
            " system"
        )
        with open(SALT_LONG_DESCRIPTION_FILE, encoding="utf-8") as f:
            self.long_description = f.read()
        self.long_description_content_type = "text/x-rst"
        self.python_requires = "&gt;=3.5"
        self.classifiers = [
            "Programming Language :: Python",
            "Programming Language :: Cython",
            "Programming Language :: Python :: 3",
            "Programming Language :: Python :: 3 :: Only",
            "Programming Language :: Python :: 3.5",
            "Programming Language :: Python :: 3.6",
            "Programming Language :: Python :: 3.7",
            "Programming Language :: Python :: 3.8",
            "Programming Language :: Python :: 3.9",
            "Development Status :: 5 - Production/Stable",
            "Environment :: Console",
            "Intended Audience :: Developers",
            "Intended Audience :: Information Technology",
            "Intended Audience :: System Administrators",
            "License :: OSI Approved :: Apache Software License",
            "Operating System :: POSIX :: Linux",
            "Topic :: System :: Clustering",
            "Topic :: System :: Distributed Computing",
        ]
        self.author = "Thomas S Hatch"
        self.author_email = "thatch45@gmail.com"
        self.url = "https://saltproject.io"
        self.cmdclass.update(
            {
                "test": TestCommand,
                "clean": Clean,
                "build": Build,
                "sdist": Sdist,
                "bdist_egg": BDistEgg,
                "install": Install,
                "develop": Develop,
                "write_salt_version": WriteSaltVersion,
                "generate_salt_syspaths": GenerateSaltSyspaths,
                "write_salt_ssh_packaging_file": WriteSaltSshPackagingFile,
            }
        )
        if not IS_WINDOWS_PLATFORM:
            self.cmdclass.update({"sdist": CloudSdist, "install_lib": InstallLib})
        if IS_WINDOWS_PLATFORM:
            self.cmdclass.update({"download-windows-dlls": DownloadWindowsDlls})
        if HAS_BDIST_WHEEL:
            self.cmdclass["bdist_wheel"] = BDistWheel
        self.license = "Apache Software License 2.0"
        self.packages = self.discover_packages()
        self.zip_safe = False
        if HAS_ESKY:
            self.setup_esky()
        self.update_metadata()
    def update_metadata(self):
        for attrname in dir(self):
            if attrname.startswith("__"):
                continue
            attrvalue = getattr(self, attrname, None)
            if attrvalue == 0:
                continue
            if attrname == "salt_version":
                attrname = "version"
            if hasattr(self.metadata, "set_{}".format(attrname)):
                getattr(self.metadata, "set_{}".format(attrname))(attrvalue)
            elif hasattr(self.metadata, attrname):
                try:
                    setattr(self.metadata, attrname, attrvalue)
                except AttributeError:
                    pass
    def discover_packages(self):
        modules = []
        for root, _, files in os.walk(os.path.join(SETUP_DIRNAME, "salt")):
            if "__init__.py" not in files:
                continue
            modules.append(os.path.relpath(root, SETUP_DIRNAME).replace(os.sep, "."))
        return modules
    @property
    def _property_dependency_links(self):
        return [
            "https://github.com/saltstack/salt-testing/tarball/develop#egg=SaltTesting"
        ]
    @property
    def _property_tests_require(self):
        return ["SaltTesting"]
    @property
    def _property_package_data(self):
        package_data = {
            "salt.templates": [
                "rh_ip/*.jinja",
                "debian_ip/*.jinja",
                "virt/*.jinja",
                "git/*",
                "lxc/*",
            ]
        }
        if not IS_WINDOWS_PLATFORM:
            package_data["salt.cloud"] = ["deploy/*.sh"]
        if not self.ssh_packaging and not PACKAGED_FOR_SALT_SSH:
            package_data["salt.daemons.flo"] = ["*.flo"]
        return package_data
    @property
    def _property_data_files(self):
        data_files = [
            ("share/man/man1", ["doc/man/salt-call.1", "doc/man/salt-run.1"]),
            ("share/man/man7", ["doc/man/salt.7"]),
        ]
        if self.ssh_packaging or PACKAGED_FOR_SALT_SSH:
            data_files[0][1].append("doc/man/salt-ssh.1")
            if IS_WINDOWS_PLATFORM:
                return data_files
            data_files[0][1].append("doc/man/salt-cloud.1")
            return data_files
        if IS_WINDOWS_PLATFORM:
            data_files[0][1].extend(
                [
                    "doc/man/salt-api.1",
                    "doc/man/salt-cp.1",
                    "doc/man/salt-key.1",
                    "doc/man/salt-minion.1",
                    "doc/man/salt-syndic.1",
                    "doc/man/spm.1",
                ]
            )
            return data_files
        data_files[0][1].extend(
            [
                "doc/man/salt-api.1",
                "doc/man/salt-cloud.1",
                "doc/man/salt-cp.1",
                "doc/man/salt-key.1",
                "doc/man/salt-master.1",
                "doc/man/salt-minion.1",
                "doc/man/salt-proxy.1",
                "doc/man/spm.1",
                "doc/man/salt.1",
                "doc/man/salt-ssh.1",
                "doc/man/salt-syndic.1",
            ]
        )
        return data_files
    @property
    def _property_install_requires(self):
        install_requires = []
        if USE_STATIC_REQUIREMENTS is True:
            if IS_OSX_PLATFORM:
                for reqfile in SALT_OSX_LOCKED_REQS:
                    install_requires += _parse_requirements_file(reqfile)
            elif IS_WINDOWS_PLATFORM:
                for reqfile in SALT_WINDOWS_LOCKED_REQS:
                    install_requires += _parse_requirements_file(reqfile)
            else:
                for reqfile in SALT_LINUX_LOCKED_REQS:
                    install_requires += _parse_requirements_file(reqfile)
            return install_requires
        elif USE_STATIC_REQUIREMENTS is False:
            if IS_OSX_PLATFORM:
                for reqfile in SALT_OSX_REQS:
                    install_requires += _parse_requirements_file(reqfile)
            elif IS_WINDOWS_PLATFORM:
                for reqfile in SALT_WINDOWS_REQS:
                    install_requires += _parse_requirements_file(reqfile)
            else:
                for reqfile in SALT_BASE_REQUIREMENTS:
                    install_requires += _parse_requirements_file(reqfile)
        else:
            if IS_OSX_PLATFORM:
                for reqfile in SALT_OSX_LOCKED_REQS:
                    install_requires += _parse_requirements_file(reqfile)
            elif IS_WINDOWS_PLATFORM:
                for reqfile in SALT_WINDOWS_LOCKED_REQS:
                    install_requires += _parse_requirements_file(reqfile)
            else:
                for reqfile in SALT_BASE_REQUIREMENTS:
                    install_requires += _parse_requirements_file(reqfile)
        return install_requires
    @property
    def _property_scripts(self):
        scripts = ["scripts/salt-call", "scripts/salt-run"]
        if self.ssh_packaging or PACKAGED_FOR_SALT_SSH:
            scripts.append("scripts/salt-ssh")
            if IS_WINDOWS_PLATFORM:
                return scripts
            scripts.extend(["scripts/salt-cloud", "scripts/spm"])
            return scripts
        if IS_WINDOWS_PLATFORM:
            scripts.extend(
                [
                    "scripts/salt-api",
                    "scripts/salt-cp",
                    "scripts/salt-key",
                    "scripts/salt-minion",
                    "scripts/salt-syndic",
                    "scripts/spm",
                ]
            )
            return scripts
        scripts.extend(
            [
                "scripts/salt",
                "scripts/salt-api",
                "scripts/salt-cloud",
                "scripts/salt-cp",
                "scripts/salt-key",
                "scripts/salt-master",
                "scripts/salt-minion",
                "scripts/salt-proxy",
                "scripts/salt-ssh",
                "scripts/salt-syndic",
                "scripts/spm",
            ]
        )
        return scripts
    @property
    def _property_entry_points(self):
        scripts = [
            "salt-call = salt.scripts:salt_call",
            "salt-run = salt.scripts:salt_run",
        ]
        if self.ssh_packaging or PACKAGED_FOR_SALT_SSH:
            scripts.append("salt-ssh = salt.scripts:salt_ssh")
            if IS_WINDOWS_PLATFORM:
                return {"console_scripts": scripts}
            scripts.append("salt-cloud = salt.scripts:salt_cloud")
            return {"console_scripts": scripts}
        if IS_WINDOWS_PLATFORM:
            scripts.extend(
                [
                    "salt-api = salt.scripts:salt_api",
                    "salt-cp = salt.scripts:salt_cp",
                    "salt-key = salt.scripts:salt_key",
                    "salt-minion = salt.scripts:salt_minion",
                    "salt-syndic = salt.scripts:salt_syndic",
                    "spm = salt.scripts:salt_spm",
                ]
            )
            return {"console_scripts": scripts}
        scripts.extend(
            [
                "salt = salt.scripts:salt_main",
                "salt-api = salt.scripts:salt_api",
                "salt-cloud = salt.scripts:salt_cloud",
                "salt-cp = salt.scripts:salt_cp",
                "salt-key = salt.scripts:salt_key",
                "salt-master = salt.scripts:salt_master",
                "salt-minion = salt.scripts:salt_minion",
                "salt-ssh = salt.scripts:salt_ssh",
                "salt-syndic = salt.scripts:salt_syndic",
                "spm = salt.scripts:salt_spm",
            ]
        )
        return {"console_scripts": scripts}
    def setup_esky(self):
        opt_dict = self.get_option_dict("bdist_esky")
        opt_dict["freezer_module"] = ("setup script", "bbfreeze")
        opt_dict["freezer_options"] = (
            "setup script",
            {"includes": self.get_esky_freezer_includes()},
        )
    @property
    def _property_freezer_options(self):
        return {"includes": self.get_esky_freezer_includes()}
    def get_esky_freezer_includes(self):
        freezer_includes = [
            "zmq.core.*",
            "zmq.utils.*",
            "ast",
            "csv",
            "difflib",
            "distutils",
            "distutils.version",
            "numbers",
            "json",
            "M2Crypto",
            "Cookie",
            "asyncore",
            "fileinput",
            "sqlite3",
            "email",
            "email.mime.*",
            "requests",
            "sqlite3",
        ]
        if HAS_ZMQ and hasattr(zmq, "pyzmq_version_info"):
            if HAS_ZMQ and zmq.pyzmq_version_info() &gt;= (0, 14):
                if "zmq.core.*" in freezer_includes:
                    freezer_includes.remove("zmq.core.*")
        if IS_WINDOWS_PLATFORM:
            freezer_includes.extend(
                [
                    "imp",
                    "win32api",
                    "win32file",
                    "win32con",
                    "win32com",
                    "win32net",
                    "win32netcon",
                    "win32gui",
                    "win32security",
                    "ntsecuritycon",
                    "pywintypes",
                    "pythoncom",
                    "_winreg",
                    "wmi",
                    "site",
                    "psutil",
                    "pytz",
                ]
            )
        elif IS_SMARTOS_PLATFORM:
            freezer_includes.extend(
                ["cherrypy", "python-dateutil", "pyghmi", "croniter", "mako", "gnupg"]
            )
        elif sys.platform.startswith("linux"):
            freezer_includes.append("spwd")
            try:
                import yum  # pylint: disable=unused-import
                freezer_includes.append("yum")
            except ImportError:
                pass
        elif sys.platform.startswith("sunos"):
            try:
                from bbfreeze.modulegraph.modulegraph import ModuleGraph
                mgraph = ModuleGraph(sys.path[:])
                for arg in glob.glob("salt/modules/*.py"):
                    mgraph.run_script(arg)
                for mod in mgraph.flatten():
                    if type(mod).__name__ != "Script" and mod.filename:
                        freezer_includes.append(str(os.path.basename(mod.identifier)))
            except ImportError:
                pass
        return freezer_includes
    def parse_command_line(self):
        args = distutils.dist.Distribution.parse_command_line(self)
        if not self.ssh_packaging and PACKAGED_FOR_SALT_SSH:
            self.ssh_packaging = 1
        if self.ssh_packaging:
            self.metadata.name = "salt-ssh"
            self.salt_transport = "ssh"
        elif self.salt_transport is None:
            self.salt_transport = "zeromq"
        if self.salt_transport not in ("zeromq", "both", "ssh", "none"):
            raise DistutilsArgError(
                "The value of --salt-transport needs be 'zeromq', "
                "'both', 'ssh', or 'none' not '{}'".format(self.salt_transport)
            )
        for funcname in dir(self):
            if not funcname.startswith("_property_"):
                continue
            property_name = funcname.split("_property_", 1)[-1]
            setattr(self, property_name, getattr(self, funcname))
        return args
if __name__ == "__main__":
    setup(distclass=SaltDistribution)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
