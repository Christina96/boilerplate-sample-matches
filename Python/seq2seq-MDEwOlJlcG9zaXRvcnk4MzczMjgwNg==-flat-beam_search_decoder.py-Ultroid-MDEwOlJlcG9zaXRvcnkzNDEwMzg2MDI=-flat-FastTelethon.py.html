
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.21978021978022%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>seq2seq-MDEwOlJlcG9zaXRvcnk4MzczMjgwNg==-flat-beam_search_decoder.py</h3>
            <pre><code>1  from __future__ import absolute_import
2  from __future__ import division
3  from __future__ import print_function
4  from __future__ import unicode_literals
5  from collections import namedtuple
6  import tensorflow as tf
7  from tensorflow.python.util import nest  # pylint: disable=E0611
8  from seq2seq.inference import beam_search
9  from seq2seq.decoders.rnn_decoder import RNNDecoder
10  class FinalBeamDecoderOutput(
11      namedtuple("FinalBeamDecoderOutput",
12                 ["predicted_ids", "beam_search_output"])):
13    pass
14  class BeamDecoderOutput(
15      namedtuple("BeamDecoderOutput", [
16          "logits", "predicted_ids", "log_probs", "scores", "beam_parent_ids",
17          "original_outputs"
18      ])):
19    pass
20  class BeamSearchDecoder(RNNDecoder):
21    def __init__(self, decoder, config):
22      super(BeamSearchDecoder, self).__init__(decoder.params, decoder.mode,
23                                              decoder.name)
24      self.decoder = decoder
25      self.config = config
26    def __call__(self, *args, **kwargs):
27      with self.decoder.variable_scope():
28        return self._build(*args, **kwargs)
29    @property
30    def output_size(self):
31      return BeamDecoderOutput(
<span onclick='openModal()' class='match'>32          logits=self.decoder.vocab_size,
33          predicted_ids=tf.TensorShape([]),
34          log_probs=tf.TensorShape([]),
35          scores=tf.TensorShape([]),
</span>36          beam_parent_ids=tf.TensorShape([]),
37          original_outputs=self.decoder.output_size)
38    @property
39    def output_dtype(self):
40      return BeamDecoderOutput(
41          logits=tf.float32,
42          predicted_ids=tf.int32,
43          log_probs=tf.float32,
44          scores=tf.float32,
45          beam_parent_ids=tf.int32,
46          original_outputs=self.decoder.output_dtype)
47    @property
48    def batch_size(self):
49      return self.config.beam_width
50    def initialize(self, name=None):
51      finished, first_inputs, initial_state = self.decoder.initialize()
52      beam_state = beam_search.create_initial_beam_state(config=self.config)
53      return finished, first_inputs, (initial_state, beam_state)
54    def finalize(self, outputs, final_state):
55      predicted_ids = beam_search.gather_tree(outputs.predicted_ids,
56                                              outputs.beam_parent_ids)
57      outputs = nest.map_structure(lambda x: tf.expand_dims(x, 1), outputs)
58      final_outputs = FinalBeamDecoderOutput(
59          predicted_ids=tf.expand_dims(predicted_ids, 1),
60          beam_search_output=outputs)
61      return final_outputs, final_state
62    def _build(self, initial_state, helper):
63      initial_state = nest.map_structure(
64          lambda x: tf.tile(x, [self.batch_size, 1]), initial_state)
65      self.decoder._setup(initial_state, helper)  #pylint: disable=W0212
66      return super(BeamSearchDecoder, self)._build(self.decoder.initial_state,
67                                                   self.decoder.helper)
68    def step(self, time_, inputs, state, name=None):
69      decoder_state, beam_state = state
70      (decoder_output, decoder_state, _, _) = self.decoder.step(time_, inputs,
71                                                                decoder_state)
72      bs_output, beam_state = beam_search.beam_search_step(
73          time_=time_,
74          logits=decoder_output.logits,
75          beam_state=beam_state,
76          config=self.config)
77      decoder_state = nest.map_structure(
78          lambda x: tf.gather(x, bs_output.beam_parent_ids), decoder_state)
79      decoder_output = nest.map_structure(
80          lambda x: tf.gather(x, bs_output.beam_parent_ids), decoder_output)
81      next_state = (decoder_state, beam_state)
82      outputs = BeamDecoderOutput(
83          logits=tf.zeros([self.config.beam_width, self.config.vocab_size]),
84          predicted_ids=bs_output.predicted_ids,
85          log_probs=beam_state.log_probs,
86          scores=bs_output.scores,
87          beam_parent_ids=bs_output.beam_parent_ids,
88          original_outputs=decoder_output)
89      finished, next_inputs, next_state = self.decoder.helper.next_inputs(
90          time=time_,
91          outputs=decoder_output,
92          state=next_state,
93          sample_ids=bs_output.predicted_ids)
94      next_inputs.set_shape([self.batch_size, None])
95      return (outputs, next_state, next_inputs, finished)
</code></pre>
        </div>
        <div class="column">
            <h3>Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-FastTelethon.py</h3>
            <pre><code>1  import asyncio
2  import hashlib
3  import logging
4  import math
5  import os
6  from collections import defaultdict
7  from typing import (
8      AsyncGenerator,
9      Awaitable,
10      BinaryIO,
11      DefaultDict,
12      List,
13      Optional,
14      Tuple,
15      Union,
16  )
17  from telethon import TelegramClient, helpers, utils
18  from telethon.crypto import AuthKey
19  from telethon.helpers import _maybe_await
20  from telethon.network import MTProtoSender
21  from telethon.tl.alltlobjects import LAYER
22  from telethon.tl.functions import InvokeWithLayerRequest
23  from telethon.tl.functions.auth import (
24      ExportAuthorizationRequest,
25      ImportAuthorizationRequest,
26  )
27  from telethon.tl.functions.upload import (
28      GetFileRequest,
29      SaveBigFilePartRequest,
30      SaveFilePartRequest,
31  )
32  from telethon.tl.types import (
33      Document,
34      InputDocumentFileLocation,
35      InputFile,
36      InputFileBig,
37      InputFileLocation,
38      InputPeerPhotoFileLocation,
39      InputPhotoFileLocation,
40      TypeInputFile,
41  )
42  log: logging.Logger = logging.getLogger("_FastTelethon")
43  TypeLocation = Union[
44      Document,
45      InputDocumentFileLocation,
46      InputPeerPhotoFileLocation,
47      InputFileLocation,
48      InputPhotoFileLocation,
49  ]
50  class DownloadSender:
51      client: TelegramClient
52      sender: MTProtoSender
53      request: GetFileRequest
54      remaining: int
55      stride: int
56      def __init__(
57          self,
58          client: TelegramClient,
59          sender: MTProtoSender,
60          file: TypeLocation,
61          offset: int,
62          limit: int,
63          stride: int,
64          count: int,
65      ) -> None:
66          self.sender = sender
67          self.client = client
68          self.request = GetFileRequest(file, offset=offset, limit=limit)
69          self.stride = stride
70          self.remaining = count
71      async def next(self) -> Optional[bytes]:
72          if not self.remaining:
73              return None
74          result = await self.client._call(self.sender, self.request)
75          self.remaining -= 1
76          self.request.offset += self.stride
77          return result.bytes
78      def disconnect(self) -> Awaitable[None]:
79          return self.sender.disconnect()
80  class UploadSender:
81      client: TelegramClient
82      sender: MTProtoSender
83      request: Union[SaveFilePartRequest, SaveBigFilePartRequest]
84      part_count: int
85      stride: int
86      previous: Optional[asyncio.Task]
87      loop: asyncio.AbstractEventLoop
88      def __init__(
89          self,
90          client: TelegramClient,
91          sender: MTProtoSender,
92          file_id: int,
93          part_count: int,
94          big: bool,
95          index: int,
96          stride: int,
97          loop: asyncio.AbstractEventLoop,
98      ) -> None:
99          self.client = client
100          self.sender = sender
101          self.part_count = part_count
102          if big:
103              self.request = SaveBigFilePartRequest(file_id, index, part_count, b"")
104          else:
105              self.request = SaveFilePartRequest(file_id, index, b"")
106          self.stride = stride
107          self.previous = None
108          self.loop = loop
109      async def next(self, data: bytes) -> None:
110          if self.previous:
111              await self.previous
112          self.previous = self.loop.create_task(self._next(data))
113      async def _next(self, data: bytes) -> None:
114          self.request.bytes = data
115          await self.client._call(self.sender, self.request)
116          self.request.file_part += self.stride
117      async def disconnect(self) -> None:
118          if self.previous:
119              await self.previous
120          return await self.sender.disconnect()
121  class ParallelTransferrer:
122      client: TelegramClient
123      loop: asyncio.AbstractEventLoop
124      dc_id: int
125      senders: Optional[List[Union[DownloadSender, UploadSender]]]
126      auth_key: AuthKey
127      upload_ticker: int
128      def __init__(self, client: TelegramClient, dc_id: Optional[int] = None) -> None:
129          self.client = client
130          try:
131              self.client.refresh_auth(client)
132          except AttributeError:
133              pass
134          self.loop = self.client.loop
135          self.dc_id = dc_id or self.client.session.dc_id
136          self.auth_key = (
137              None
138              if dc_id and self.client.session.dc_id != dc_id
139              else self.client.session.auth_key
140          )
141          self.senders = None
142          self.upload_ticker = 0
143          try:
144              self.client.clear_auth(self.client)
145          except AttributeError:
146              pass
147      async def _cleanup(self) -> None:
148          await asyncio.gather(*[sender.disconnect() for sender in self.senders])
149          self.senders = None
150      @staticmethod
151      def _get_connection_count(
152          file_size: int,
153      ) -> int:
154          full_size = 100 * (1024 ** 2)
155          if file_size > full_size:
156              return 20
157          return math.ceil((file_size / full_size) * 20)
158      async def _init_download(
159          self, connections: int, file: TypeLocation, part_count: int, part_size: int
160      ) -> None:
161          minimum, remainder = divmod(part_count, connections)
162          def get_part_count() -> int:
163              nonlocal remainder
164              if remainder > 0:
165                  remainder -= 1
166                  return minimum + 1
167              return minimum
168          self.senders = [
169              await self._create_download_sender(
170                  file, 0, part_size, connections * part_size, get_part_count()
171              ),
172              *await asyncio.gather(
173                  *[
174                      self._create_download_sender(
175                          file, i, part_size, connections * part_size, get_part_count()
176                      )
177                      for i in range(1, connections)
178                  ]
179              ),
180          ]
181      async def _create_download_sender(
182          self,
183          file: TypeLocation,
184          index: int,
185          part_size: int,
186          stride: int,
187          part_count: int,
188      ) -> DownloadSender:
189          return DownloadSender(
190              self.client,
191              await self._create_sender(),
192              file,
193              index * part_size,
194              part_size,
195              stride,
196              part_count,
197          )
198      async def _init_upload(
199          self, connections: int, file_id: int, part_count: int, big: bool
200      ) -> None:
201          self.senders = [
202              await self._create_upload_sender(file_id, part_count, big, 0, connections),
203              *await asyncio.gather(
204                  *[
205                      self._create_upload_sender(file_id, part_count, big, i, connections)
206                      for i in range(1, connections)
207                  ]
208              ),
209          ]
210      async def _create_upload_sender(
211          self, file_id: int, part_count: int, big: bool, index: int, stride: int
212      ) -> UploadSender:
213          return UploadSender(
214              self.client,
215              await self._create_sender(),
216              file_id,
217              part_count,
218              big,
219              index,
220              stride,
221              loop=self.loop,
222          )
223      async def _create_sender(self) -> MTProtoSender:
224          dc = await self.client._get_dc(self.dc_id)
225          sender = MTProtoSender(self.auth_key, loggers=self.client._log)
226          await sender.connect(
227              self.client._connection(
228                  dc.ip_address,
229                  dc.port,
230                  dc.id,
231                  loggers=self.client._log,
232                  proxy=self.client._proxy,
233              )
234          )
235          if not self.auth_key:
236              auth = await self.client(ExportAuthorizationRequest(self.dc_id))
237              self.client._init_request.query = ImportAuthorizationRequest(
238                  id=auth.id, bytes=auth.bytes
239              )
240              req = InvokeWithLayerRequest(LAYER, self.client._init_request)
241              await sender.send(req)
242              self.auth_key = sender.auth_key
243          return sender
244      async def init_upload(
245          self,
246          file_id: int,
247          file_size: int,
248          part_size_kb: Optional[float] = None,
249          connection_count: Optional[int] = None,
250      ) -> Tuple[int, int, bool]:
251          connection_count = connection_count or self._get_connection_count(file_size)
252          part_size = (part_size_kb or utils.get_appropriated_part_size(file_size)) * 1024
253          part_count = (file_size + part_size - 1) // part_size
254          is_large = file_size > 10 * (1024 ** 2)
255          await self._init_upload(connection_count, file_id, part_count, is_large)
256          return part_size, part_count, is_large
257      async def upload(self, part: bytes) -> None:
258          await self.senders[self.upload_ticker].next(part)
259          self.upload_ticker = (self.upload_ticker + 1) % len(self.senders)
260      async def finish_upload(self) -> None:
261          await self._cleanup()
262      async def download(
263          self,
264          file: TypeLocation,
265          file_size: int,
266          part_size_kb: Optional[float] = None,
267          connection_count: Optional[int] = None,
<span onclick='openModal()' class='match'>268      ) -> AsyncGenerator[bytes, None]:
269          connection_count = connection_count or self._get_connection_count(file_size)
270          part_size = (part_size_kb or utils.get_appropriated_part_size(file_size)) * 1024
271          part_count = math.ceil(file_size / part_size)
</span>272          await self._init_download(connection_count, file, part_count, part_size)
273          part = 0
274          while part < part_count:
275              tasks = [self.loop.create_task(sender.next()) for sender in self.senders]
276              for task in tasks:
277                  data = await task
278                  if not data:
279                      break
280                  yield data
281                  part += 1
282          await self._cleanup()
283  parallel_transfer_locks: DefaultDict[int, asyncio.Lock] = defaultdict(
284      lambda: asyncio.Lock()
285  )
286  def stream_file(file_to_stream: BinaryIO, chunk_size=1024):
287      while True:
288          data_read = file_to_stream.read(chunk_size)
289          if not data_read:
290              break
291          yield data_read
292  async def _internal_transfer_to_telegram(
293      client: TelegramClient,
294      response: BinaryIO,
295      filename: str,
296      progress_callback: callable,
297  ) -> Tuple[TypeInputFile, int]:
298      file_id = helpers.generate_random_long()
299      file_size = os.path.getsize(response.name)
300      hash_md5 = hashlib.md5()
301      uploader = ParallelTransferrer(client)
302      part_size, part_count, is_large = await uploader.init_upload(file_id, file_size)
303      buffer = bytearray()
304      for data in stream_file(response):
305          if progress_callback:
306              try:
307                  await _maybe_await(progress_callback(response.tell(), file_size))
308              except BaseException:
309                  pass
310          if not is_large:
311              hash_md5.update(data)
312          if len(buffer) == 0 and len(data) == part_size:
313              await uploader.upload(data)
314              continue
315          new_len = len(buffer) + len(data)
316          if new_len >= part_size:
317              cutoff = part_size - len(buffer)
318              buffer.extend(data[:cutoff])
319              await uploader.upload(bytes(buffer))
320              buffer.clear()
321              buffer.extend(data[cutoff:])
322          else:
323              buffer.extend(data)
324      if len(buffer) > 0:
325          await uploader.upload(bytes(buffer))
326      await uploader.finish_upload()
327      if is_large:
328          return InputFileBig(file_id, part_count, filename), file_size
329      return InputFile(file_id, part_count, filename, hash_md5.hexdigest()), file_size
330  async def download_file(
331      client: TelegramClient,
332      location: TypeLocation,
333      out: BinaryIO,
334      progress_callback: callable = None,
335  ) -> BinaryIO:
336      size = location.size
337      dc_id, location = utils.get_input_location(location)
338      downloader = ParallelTransferrer(client, dc_id)
339      downloaded = downloader.download(location, size)
340      async for x in downloaded:
341          out.write(x)
342          if progress_callback:
343              try:
344                  await _maybe_await(progress_callback(out.tell(), size))
345              except BaseException:
346                  pass
347      return out
348  async def upload_file(
349      client: TelegramClient,
350      file: BinaryIO,
351      filename: str,
352      progress_callback: callable = None,
353  ) -> TypeInputFile:
354      return (
355          await _internal_transfer_to_telegram(client, file, filename, progress_callback)
356      )[0]
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from seq2seq-MDEwOlJlcG9zaXRvcnk4MzczMjgwNg==-flat-beam_search_decoder.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-FastTelethon.py</div>
                </div>
                <div class="column column_space"><pre><code>32          logits=self.decoder.vocab_size,
33          predicted_ids=tf.TensorShape([]),
34          log_probs=tf.TensorShape([]),
35          scores=tf.TensorShape([]),
</pre></code></div>
                <div class="column column_space"><pre><code>268      ) -> AsyncGenerator[bytes, None]:
269          connection_count = connection_count or self._get_connection_count(file_size)
270          part_size = (part_size_kb or utils.get_appropriated_part_size(file_size)) * 1024
271          part_count = math.ceil(file_size / part_size)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    