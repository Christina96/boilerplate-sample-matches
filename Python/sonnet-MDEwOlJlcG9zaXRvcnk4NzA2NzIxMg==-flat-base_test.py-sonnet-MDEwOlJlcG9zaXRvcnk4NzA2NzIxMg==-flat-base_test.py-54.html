
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 34, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>sonnet-MDEwOlJlcG9zaXRvcnk4NzA2NzIxMg==-flat-base_test.py</h3>
            <pre><code>1  import abc
2  from absl.testing import parameterized
3  import numpy as np
4  from sonnet.src import base
5  from sonnet.src import test_utils
6  import tensorflow as tf
7  import wrapt
8  class BaseTest(test_utils.TestCase):
9    def test_basic(self):
10      m = LambdaModule()
11      self.assertIsNone(m(None))
12    def testWrappedMethod(self):
13      mod = WraptModule()
14      scope_name, y = mod(3)
15      self.assertEqual(scope_name, &quot;wrapt_module/&quot;)
16      self.assertEqual(y, (3**2)**2)
17    def testControlFlow(self):
18      mod = ControlFlowModule()
19      f = tf.function(mod).get_concrete_function(tf.TensorSpec([]))
20      self.assertEqual(f(tf.constant(1.)).numpy(), 1.)
21      self.assertEqual(f(tf.constant(11.)).numpy(), 11.**2)
22  class TestModuleNaming(tf.test.TestCase):
23    def test_single_name(self):
24      mod = base.Module(name=&quot;simple&quot;)
25      self.assertEqual(mod.name, &quot;simple&quot;)
26      self.assertEqual(mod.name_scope.name, &quot;simple/&quot;)
27    def test_construct_in_scope(self):
28      with tf.name_scope(&quot;foo&quot;):
29        mod = base.Module(name=&quot;bar&quot;)
30      self.assertEqual(mod.name, &quot;bar&quot;)
31      self.assertEqual(mod.name_scope.name, &quot;foo/bar/&quot;)
32    def test_enters_name_scope_in_call(self):
33      mod = ReturnsNameScopeModule()
34      for _ in range(3):
35        self.assertEqual(mod(), mod.name_scope.name)
36    def test_enters_name_scope_in_other_method(self):
37      mod = ReturnsNameScopeModule()
38      for _ in range(3):
39        self.assertEqual(mod.alternative_forward(), mod.name_scope.name)
40    def test_subclassed_module(self):
41      mod = SubclassedReturnsNameScopeModule()
42      for _ in range(3):
43        self.assertEqual(mod.alternative_forward(), mod.name_scope.name)
44        self.assertEqual(mod.alternative_alternative_forward(),
45                         mod.name_scope.name)
46    def test_submodule_created_late(self):
47      m = TreeModule()
48      self.assertEqual(m.name, &quot;tree_module&quot;)
49      self.assertEqual(m.name_scope.name, &quot;tree_module/&quot;)
50      leaf1 = m.new_leaf()
51      self.assertEqual(leaf1.name, &quot;tree_module&quot;)
52      self.assertEqual(leaf1.name_scope.name, &quot;tree_module/tree_module/&quot;)
53    def test_does_not_evaluate_property_methods(self):
54      mod = PropertyThrowsWhenCalledModule()
55      with self.assertRaises(AssertionError):
56        mod.raise_assertion_error  # pylint: disable=pointless-statement
57    def test_overridden_name_scope(self):
58      mod = ModuleOverridingNameScope()
59      self.assertEqual(mod(), mod.name_scope.name)
60      self.assertEqual(mod.alternative_forward(), mod.name_scope.name)
61    def test_patched_callable(self):
62      with tf.name_scope(&quot;foo&quot;):
63        mod = base.Module(name=&quot;bar&quot;)
64      mod.foo = get_name_scope
65      self.assertEqual(mod.foo(), &quot;&quot;)
66    def test_property(self):
67      mod = PropertyModule()
68      mod.some_property = None, None  # None, None for the linter.
<span onclick='openModal()' class='match'>69      getter_scope_name, setter_scope_name = mod.some_property
70      self.assertEqual(getter_scope_name, &quot;property_module/&quot;)
71      self.assertEqual(setter_scope_name, &quot;property_module/&quot;)
72    def test_property_no_name_scope(self):
73      mod = PropertyModule()
74      mod.no_name_scope_property = None, None  # None, None for the linter.
</span>75      getter_scope_name, setter_scope_name = mod.no_name_scope_property
76      self.assertEqual(getter_scope_name, &quot;&quot;)
77      self.assertEqual(setter_scope_name, &quot;&quot;)
78    def test_ctor_no_name_scope(self):
79      mod = CtorNoNameScope()
80      self.assertEqual(mod.ctor_name_scope, &quot;&quot;)
81      self.assertEqual(mod.w.name, &quot;w:0&quot;)
82    def test_ctor_no_name_scope_no_super(self):
83      msg = (&quot;Constructing a snt.Module without calling the super constructor is &quot;
84             &quot;not supported&quot;)
85      with self.assertRaisesRegex(ValueError, msg):
86        CtorNoNameScopeNoSuper()
87    def test_invalid_name(self):
88      msg = &quot;.* is not a valid module name&quot;
89      with self.assertRaisesRegex(ValueError, msg):
90        base.Module(name=&quot;$Foo&quot;)
91    def test_modules_not_numbered_in_eager(self):
92      mod = RecursiveModule(2)
93      self.assertEqual(mod.name_scope.name, &quot;badger/&quot;)
94      self.assertEqual(mod.child.name_scope.name, &quot;badger/badger/&quot;)
95      mod = RecursiveModule(2)
96      self.assertEqual(mod.name_scope.name, &quot;badger/&quot;)
97      self.assertEqual(mod.child.name_scope.name, &quot;badger/badger/&quot;)
98    def test_module_numbering_in_graph(self):
99      with tf.Graph().as_default():
100        mod = RecursiveModule(2)
101        self.assertEqual(mod.name_scope.name, &quot;badger/&quot;)
102        self.assertEqual(mod.child.name_scope.name, &quot;badger/badger/&quot;)
103        mod = RecursiveModule(2)
104        self.assertEqual(mod.name_scope.name, &quot;badger_1/&quot;)
105        self.assertEqual(mod.child.name_scope.name, &quot;badger_1/badger/&quot;)
106    def test_ctor_error_closes_name_scope(self):
107      with self.assertRaises(ErrorModuleError):
108        ErrorModule(call_super=True)
109      self.assertEqual(&quot;&quot;, get_name_scope())
110    def test_ctor_error_handles_ctor_not_opening_name_scope(self):
111      with self.assertRaises(ErrorModuleError):
112        ErrorModule(call_super=False)
113      self.assertEqual(&quot;&quot;, get_name_scope())
114    def test_forward_method_closes_name_scope(self):
115      mod = ErrorModule(call_super=True, raise_in_constructor=False)
116      with self.assertRaises(ErrorModuleError):
117        mod()
118      self.assertEqual(&quot;&quot;, get_name_scope())
119    def test_get_attr_doesnt_enter_name_scope(self):
120      scope_names = []
121      class GetAttrModule(base.Module):
122        def __getattr__(self, name):
123          scope_names.append((name, get_name_scope()))
124          return super().__getattr__(name)
125      mod = GetAttrModule()
126      with self.assertRaises(AttributeError):
127        mod.does_not_exist  # pylint: disable=pointless-statement
128      self.assertIn((&quot;does_not_exist&quot;, &quot;&quot;), scope_names)
129    def test_get_attribute_doesnt_enter_name_scope(self):
130      scope_names = []
131      class GetAttributeModule(base.Module):
132        def __getattribute__(self, name):
133          scope_names.append((name, get_name_scope()))
134          return super().__getattribute__(name)
135      mod = GetAttributeModule()
136      with self.assertRaises(AttributeError):
137        mod.does_not_exist  # pylint: disable=pointless-statement
138      self.assertIn((&quot;does_not_exist&quot;, &quot;&quot;), scope_names)
139  class VariableNamingTest(tf.test.TestCase):
140    def test_variable_names(self):
141      mod = RecursiveModule(3)
142      self.assertEqual(mod.w.name, &quot;badger/mushroom:0&quot;)
143      self.assertEqual(mod.child.w.name, &quot;badger/badger/mushroom:0&quot;)
144      self.assertEqual(mod.child.child.w.name, &quot;badger/badger/badger/mushroom:0&quot;)
145  class AutoReprTest(tf.test.TestCase):
146    def test_order_matches_argspec(self):
147      module = RecursiveModule(trainable=False, depth=2)
148      self.assertEqual(repr(module), &quot;RecursiveModule(depth=2, trainable=False)&quot;)
149    def test_defaults_ignored(self):
150      module = RecursiveModule(1)
151      self.assertEqual(repr(module), &quot;RecursiveModule(depth=1)&quot;)
152    def test_does_not_fail_with_hostile_input(self):
153      r = RaisesOnEquality()
154      self.assertFalse(r.equality_checked)
155      module = NoopModule(r)
156      self.assertEqual(repr(module), &quot;NoopModule(a=hostile)&quot;)
157      self.assertTrue(r.equality_checked)
158    def test_args_are_repred(self):
159      module = TreeModule(name=&quot;TreeModule&quot;)
160      self.assertEqual(repr(module), &quot;TreeModule(name=&#x27;TreeModule&#x27;)&quot;)
161      module = TreeModule(&quot;TreeModule&quot;)
162      self.assertEqual(repr(module), &quot;TreeModule(name=&#x27;TreeModule&#x27;)&quot;)
163    def test_long_repr_multi_line(self):
164      module = TakesSubmodules([TreeModule() for _ in range(6)], name=&quot;hai&quot;)
165      self.assertEqual(
166          repr(module), &quot;\n&quot;.join([
167              &quot;TakesSubmodules(&quot;,
168              &quot;    submodules=[TreeModule(),&quot;,
169              &quot;                TreeModule(),&quot;,
170              &quot;                TreeModule(),&quot;,
171              &quot;                TreeModule(),&quot;,
172              &quot;                TreeModule(),&quot;,
173              &quot;                TreeModule()],&quot;,
174              &quot;    name=&#x27;hai&#x27;,&quot;,
175              &quot;)&quot;,
176          ]))
177    def test_repr_wildcard(self):
178      module = WildcardInit(1, 2, 3, foo=&quot;bar&quot;)
179      self.assertEqual(repr(module), &quot;WildcardInit(a=1, b=2, 3, foo=&#x27;bar&#x27;)&quot;)
180    def test_repr_non_bool_equality(self):
181      class FooModule(base.Module):
182        def __init__(self, a=((-1., -1.))):
183          super().__init__()
184      foo = FooModule(a=np.array([[2., 2.]]))
185      self.assertEqual(repr(foo), &quot;FooModule(a=array([[2., 2.]]))&quot;)
186      foo = FooModule(a=np.array([[-1., -1.]]))
187      self.assertEqual(repr(foo), &quot;FooModule(a=array([[-1., -1.]]))&quot;)
188  class ForwardMethodsTest(tf.test.TestCase):
189    def testFunctionType(self):
190      mod = ModuleWithFunctionAnnotatedCall()
191      self.assertIsInstance(mod.forward, base.TFFunctionType)
192      self.assertIsInstance(mod.forward_ag, base.TFFunctionType)
193    def testEntersNameScope_call(self):
194      mod = ModuleWithFunctionAnnotatedCall()
195      self.assertEqual(mod.forward().numpy(),
196                       b&quot;module_with_function_annotated_call/&quot;)
197    def testEntersNameScope_concreteFunction(self):
198      mod = ModuleWithFunctionAnnotatedCall()
199      self.assertEqual(mod.forward.get_concrete_function()().numpy(),
200                       b&quot;module_with_function_annotated_call/&quot;)
201  class AbcTest(tf.test.TestCase):
202    def testAbstract(self):
203      msg = &quot;Can&#x27;t instantiate .* abstract method&quot;
204      with self.assertRaisesRegex(TypeError, msg):
205        AbstractModule()  # pylint: disable=abstract-class-instantiated
206    def testConcrete(self):
207      mod = ConcreteModule()
208      x, scope_name = mod(2.)
209      self.assertEqual(x, 4.)
210      self.assertEqual(scope_name, &quot;concrete_module/&quot;)
211      self.assertEqual(get_name_scope(), &quot;&quot;)
212    def testCallMethodsOnParent(self):
213      mod = ConcreteModule()
214      self.assertEqual(mod.foo(), True)
215  class CustomGradientTest(test_utils.TestCase):
216    def test_custom_gradient(self):
217      if tf.version.GIT_VERSION != &quot;unknown&quot;:
218        self.skipTest(&quot;Requires TF &gt; 2.0.0&quot;)
219      mod = ZeroGradModule()
220      with tf.GradientTape() as tape:
221        y = mod(2.)
222      g = tape.gradient(y, mod.w)
223      self.assertAllEqual(g, tf.zeros([2, 2]))
224  class ZeroGradModule(base.Module):
225    @tf.custom_gradient
226    def __call__(self, x):
227      if not hasattr(self, &quot;w&quot;):
228        self.w = tf.Variable(tf.ones([2, 2]), name=&quot;w&quot;)
229      with tf.GradientTape() as tape:
230        y = tf.reduce_sum(self.w ** x)
231      dw = tape.gradient(y, self.w)
232      def grad(dy, variables=None):
233        assert variables
234        return dy * 0, [dw * 0]
235      return y, grad
236  class LambdaModule(base.Module):
237    def __call__(self, x):
238      return x
239  def get_name_scope():
240    with tf.name_scope(&quot;x&quot;) as scope_name:
241      return scope_name[:-2]
242  @wrapt.decorator
243  def wrapt_decorator(method, instance, args, kwargs):
244    if instance is None:
245      raise ValueError(&quot;Expected instance to be non-null.&quot;)
246    scope_name, y = method(*args, **kwargs)
247    return scope_name, y**2
248  class WraptModule(base.Module):
249    @wrapt_decorator
250    def __call__(self, x):
251      return get_name_scope(), x**2
252  class ControlFlowModule(base.Module):
253    def __call__(self, x):
254      if x &lt; 10:
255        return x
256      else:
257        return x**2
258  class ErrorModuleError(Exception):
259    pass
260  class ErrorModule(base.Module):
261    def __init__(self, call_super, raise_in_constructor=True):
262      if call_super:
263        super().__init__()
264      if raise_in_constructor:
265        raise ErrorModuleError(&quot;Deliberate error!&quot;)
266    def __call__(self):
267      raise ErrorModuleError(&quot;Deliberate error!&quot;)
268  class RecursiveModule(base.Module):
269    def __init__(self, depth, trainable=True):
270      super().__init__(name=&quot;badger&quot;)
271      self.child = None
272      if depth &gt; 1:
273        self.child = RecursiveModule(depth - 1, trainable=trainable)
274      self.w = tf.Variable(1.0, trainable=trainable, name=&quot;mushroom&quot;)
275  class AbstractModule(base.Module, metaclass=abc.ABCMeta):
276    @abc.abstractmethod
277    def __call__(self, x):
278      pass
279    def foo(self):
280      return True
281  class ConcreteModule(AbstractModule):
282    def __call__(self, x):
283      return x**2, get_name_scope()
284  class TreeModule(base.Module):
285    def __init__(self, name=None):
286      super().__init__(name=name)
287      self._leaves = []
288    def new_leaf(self, name=None):
289      leaf = TreeModule(name=name)
290      self._leaves.append(leaf)
291      return leaf
292  class ReturnsNameScopeModule(base.Module):
293    def alternative_forward(self):
294      return get_name_scope()
295    def __call__(self):
296      return get_name_scope()
297  class SubclassedReturnsNameScopeModule(ReturnsNameScopeModule):
298    def alternative_alternative_forward(self):
299      return get_name_scope()
300  class PropertyThrowsWhenCalledModule(base.Module):
301    @property
302    def raise_assertion_error(self):
303      raise AssertionError
304  class ModuleOverridingNameScope(ReturnsNameScopeModule):
305    @property
306    def name_scope(self):
307      return tf.name_scope(&quot;yolo/&quot;)
308  class CommonErrorsTest(test_utils.TestCase, parameterized.TestCase):
309    def test_not_calling_super_constructor(self):
310      msg = (&quot;Constructing a snt.Module without calling the super constructor is &quot;
311             &quot;not supported&quot;)
312      with self.assertRaisesRegex(ValueError, msg):
313        DoesNotCallSuperConstructorModule()
314    def test_calls_method_before_super(self):
315      msg = &quot;super constructor must be called before any other methods&quot;
316      with self.assertRaisesRegex(AttributeError, msg):
317        CallsMethodBeforeSuperConstructorModule(allowed_method=False)
318    def test_annotated_method_is_allowed(self):
319      self.assertIsNotNone(
320          CallsMethodBeforeSuperConstructorModule(allowed_method=True))
321    @parameterized.parameters(&quot;trainable_variables&quot;, &quot;variables&quot;)
322    def test_requests_variables_before_they_exist(self, property_name):
323      class MyModule(base.Module):
324        pass
325      mod = MyModule()
326      err = &quot;MyModule.* does not currently contain any {}&quot;.format(property_name)
327      with self.assertRaisesRegex(ValueError, err):
328        getattr(mod, property_name)
329    @parameterized.parameters(&quot;trainable_variables&quot;, &quot;variables&quot;)
330    def test_allow_empty_variables_instance(self, property_name):
331      mod = base.Module()
332      mod = base.allow_empty_variables(mod)
333      self.assertEmpty(getattr(mod, property_name))
334    @parameterized.parameters(&quot;trainable_variables&quot;, &quot;variables&quot;)
335    def test_allow_empty_variables_class(self, property_name):
336      mod = NeverCreatesVariables()
337      self.assertEmpty(getattr(mod, property_name))
338  class NoopModule(base.Module):
339    def __init__(self, a=None):
340      super().__init__()
341      self.a = a
342  class RaisesOnEquality:
343    equality_checked = False
344    def __repr__(self):
345      return &quot;hostile&quot;
346    def __eq__(self, other):
347      self.equality_checked = True
348      raise ValueError(&quot;== not supported&quot;)
349    def __ne__(self, other):
350      self.equality_checked = True
351      raise ValueError(&quot;!= not supported&quot;)
352  @base.allow_empty_variables
353  class NeverCreatesVariables(base.Module):
354    pass
355  class ModuleWithFunctionAnnotatedCall(base.Module):
356    @tf.function(autograph=False)
357    def forward(self):
358      return get_name_scope()
359    @tf.function(autograph=True)
360    def forward_ag(self):
361      return get_name_scope()
362  class CtorNoNameScope(base.Module):
363    @base.no_name_scope
364    def __init__(self):
365      super().__init__()
366      self.ctor_name_scope = get_name_scope()
367      self.w = tf.Variable(1., name=&quot;w&quot;)
368  class CtorNoNameScopeNoSuper(base.Module):
369    @base.no_name_scope
370    def __init__(self):
371      pass
372  class PropertyModule(base.Module):
373    def __init__(self):
374      super().__init__()
375      self._setter_scope_name = None
376    @property
377    def some_property(self):
378      getter_scope_name = get_name_scope()
379      return getter_scope_name, self._setter_scope_name
380    @some_property.setter
381    def some_property(self, my_property):
382      self._setter_scope_name = get_name_scope()
383    @property
384    @base.no_name_scope
385    def no_name_scope_property(self):
386      getter_scope_name = get_name_scope()
387      return getter_scope_name, self._setter_scope_name
388    @no_name_scope_property.setter
389    @base.no_name_scope
390    def no_name_scope_property(self, my_property):
391      self._setter_scope_name = get_name_scope()
392  class DoesNotCallSuperConstructorModule(base.Module):
393    def __init__(self):
394      pass
395  class CallsMethodBeforeSuperConstructorModule(base.Module):
396    def __init__(self, allowed_method):
397      if allowed_method:
398        self.no_name_scope()
399      else:
400        self.with_name_scope()
401      super().__init__()
402    @base.no_name_scope
403    def no_name_scope(self):
404      pass
405    def with_name_scope(self):
406      pass
407  class CustomMetaclass(type):
408    TAG = &quot;__custom_metaclass__&quot;
409    def __new__(cls, name, bases, clsdict):
410      new_type = super(CustomMetaclass, cls).__new__(cls, name, bases, clsdict)
411      setattr(new_type, CustomMetaclass.TAG, True)
412      return new_type
413  class CombiningMetaclass(base.ModuleMetaclass, CustomMetaclass):
414    TAG = &quot;__combining_metaclass__&quot;
415    def __new__(cls, name, bases, clsdict):
416      new_type = super(CombiningMetaclass, cls).__new__(cls, name, bases, clsdict)  # pylint: disable=too-many-function-args
417      setattr(new_type, CombiningMetaclass.TAG, True)
418      return new_type
419  class ModuleWithCustomMetaclass(base.Module, metaclass=CombiningMetaclass):
420    def __init__(self):
421      super(ModuleWithCustomMetaclass, self).__init__()
422      self.init_name_scope = get_name_scope()
423  class CustomMetaclassTest(tf.test.TestCase):
424    def testSupportsCustomMetaclass(self):
425      m = ModuleWithCustomMetaclass()
426      self.assertEqual(m.init_name_scope, &quot;module_with_custom_metaclass/&quot;)
427      self.assertTrue(getattr(ModuleWithCustomMetaclass, CombiningMetaclass.TAG))
428      self.assertTrue(getattr(ModuleWithCustomMetaclass, CustomMetaclass.TAG))
429  class TakesSubmodules(base.Module):
430    def __init__(self, submodules, name=None):
431      super().__init__(name=name)
432  class WildcardInit(base.Module):
433    def __init__(self, a, b, *args, **kwargs):
434      super().__init__()
435      del args, kwargs
436  if __name__ == &quot;__main__&quot;:
437    tf.test.main()
</code></pre>
        </div>
        <div class="column">
            <h3>sonnet-MDEwOlJlcG9zaXRvcnk4NzA2NzIxMg==-flat-base_test.py</h3>
            <pre><code>1  import abc
2  from absl.testing import parameterized
3  import numpy as np
4  from sonnet.src import base
5  from sonnet.src import test_utils
6  import tensorflow as tf
7  import wrapt
8  class BaseTest(test_utils.TestCase):
9    def test_basic(self):
10      m = LambdaModule()
11      self.assertIsNone(m(None))
12    def testWrappedMethod(self):
13      mod = WraptModule()
14      scope_name, y = mod(3)
15      self.assertEqual(scope_name, &quot;wrapt_module/&quot;)
16      self.assertEqual(y, (3**2)**2)
17    def testControlFlow(self):
18      mod = ControlFlowModule()
19      f = tf.function(mod).get_concrete_function(tf.TensorSpec([]))
20      self.assertEqual(f(tf.constant(1.)).numpy(), 1.)
21      self.assertEqual(f(tf.constant(11.)).numpy(), 11.**2)
22  class TestModuleNaming(tf.test.TestCase):
23    def test_single_name(self):
24      mod = base.Module(name=&quot;simple&quot;)
25      self.assertEqual(mod.name, &quot;simple&quot;)
26      self.assertEqual(mod.name_scope.name, &quot;simple/&quot;)
27    def test_construct_in_scope(self):
28      with tf.name_scope(&quot;foo&quot;):
29        mod = base.Module(name=&quot;bar&quot;)
30      self.assertEqual(mod.name, &quot;bar&quot;)
31      self.assertEqual(mod.name_scope.name, &quot;foo/bar/&quot;)
32    def test_enters_name_scope_in_call(self):
33      mod = ReturnsNameScopeModule()
34      for _ in range(3):
35        self.assertEqual(mod(), mod.name_scope.name)
36    def test_enters_name_scope_in_other_method(self):
37      mod = ReturnsNameScopeModule()
38      for _ in range(3):
39        self.assertEqual(mod.alternative_forward(), mod.name_scope.name)
40    def test_subclassed_module(self):
41      mod = SubclassedReturnsNameScopeModule()
42      for _ in range(3):
43        self.assertEqual(mod.alternative_forward(), mod.name_scope.name)
44        self.assertEqual(mod.alternative_alternative_forward(),
45                         mod.name_scope.name)
46    def test_submodule_created_late(self):
47      m = TreeModule()
48      self.assertEqual(m.name, &quot;tree_module&quot;)
49      self.assertEqual(m.name_scope.name, &quot;tree_module/&quot;)
50      leaf1 = m.new_leaf()
51      self.assertEqual(leaf1.name, &quot;tree_module&quot;)
52      self.assertEqual(leaf1.name_scope.name, &quot;tree_module/tree_module/&quot;)
53    def test_does_not_evaluate_property_methods(self):
54      mod = PropertyThrowsWhenCalledModule()
55      with self.assertRaises(AssertionError):
56        mod.raise_assertion_error  # pylint: disable=pointless-statement
57    def test_overridden_name_scope(self):
58      mod = ModuleOverridingNameScope()
59      self.assertEqual(mod(), mod.name_scope.name)
60      self.assertEqual(mod.alternative_forward(), mod.name_scope.name)
61    def test_patched_callable(self):
62      with tf.name_scope(&quot;foo&quot;):
63        mod = base.Module(name=&quot;bar&quot;)
64      mod.foo = get_name_scope
65      self.assertEqual(mod.foo(), &quot;&quot;)
66    def test_property(self):
67      mod = PropertyModule()
68      mod.some_property = None, None  # None, None for the linter.
69      getter_scope_name, setter_scope_name = mod.some_property
70      self.assertEqual(getter_scope_name, &quot;property_module/&quot;)
71      self.assertEqual(setter_scope_name, &quot;property_module/&quot;)
72    def test_property_no_name_scope(self):
73      mod = PropertyModule()
74      mod.no_name_scope_property = None, None  # None, None for the linter.
<span onclick='openModal()' class='match'>75      getter_scope_name, setter_scope_name = mod.no_name_scope_property
76      self.assertEqual(getter_scope_name, &quot;&quot;)
77      self.assertEqual(setter_scope_name, &quot;&quot;)
78    def test_ctor_no_name_scope(self):
79      mod = CtorNoNameScope()
80      self.assertEqual(mod.ctor_name_scope, &quot;&quot;)
</span>81      self.assertEqual(mod.w.name, &quot;w:0&quot;)
82    def test_ctor_no_name_scope_no_super(self):
83      msg = (&quot;Constructing a snt.Module without calling the super constructor is &quot;
84             &quot;not supported&quot;)
85      with self.assertRaisesRegex(ValueError, msg):
86        CtorNoNameScopeNoSuper()
87    def test_invalid_name(self):
88      msg = &quot;.* is not a valid module name&quot;
89      with self.assertRaisesRegex(ValueError, msg):
90        base.Module(name=&quot;$Foo&quot;)
91    def test_modules_not_numbered_in_eager(self):
92      mod = RecursiveModule(2)
93      self.assertEqual(mod.name_scope.name, &quot;badger/&quot;)
94      self.assertEqual(mod.child.name_scope.name, &quot;badger/badger/&quot;)
95      mod = RecursiveModule(2)
96      self.assertEqual(mod.name_scope.name, &quot;badger/&quot;)
97      self.assertEqual(mod.child.name_scope.name, &quot;badger/badger/&quot;)
98    def test_module_numbering_in_graph(self):
99      with tf.Graph().as_default():
100        mod = RecursiveModule(2)
101        self.assertEqual(mod.name_scope.name, &quot;badger/&quot;)
102        self.assertEqual(mod.child.name_scope.name, &quot;badger/badger/&quot;)
103        mod = RecursiveModule(2)
104        self.assertEqual(mod.name_scope.name, &quot;badger_1/&quot;)
105        self.assertEqual(mod.child.name_scope.name, &quot;badger_1/badger/&quot;)
106    def test_ctor_error_closes_name_scope(self):
107      with self.assertRaises(ErrorModuleError):
108        ErrorModule(call_super=True)
109      self.assertEqual(&quot;&quot;, get_name_scope())
110    def test_ctor_error_handles_ctor_not_opening_name_scope(self):
111      with self.assertRaises(ErrorModuleError):
112        ErrorModule(call_super=False)
113      self.assertEqual(&quot;&quot;, get_name_scope())
114    def test_forward_method_closes_name_scope(self):
115      mod = ErrorModule(call_super=True, raise_in_constructor=False)
116      with self.assertRaises(ErrorModuleError):
117        mod()
118      self.assertEqual(&quot;&quot;, get_name_scope())
119    def test_get_attr_doesnt_enter_name_scope(self):
120      scope_names = []
121      class GetAttrModule(base.Module):
122        def __getattr__(self, name):
123          scope_names.append((name, get_name_scope()))
124          return super().__getattr__(name)
125      mod = GetAttrModule()
126      with self.assertRaises(AttributeError):
127        mod.does_not_exist  # pylint: disable=pointless-statement
128      self.assertIn((&quot;does_not_exist&quot;, &quot;&quot;), scope_names)
129    def test_get_attribute_doesnt_enter_name_scope(self):
130      scope_names = []
131      class GetAttributeModule(base.Module):
132        def __getattribute__(self, name):
133          scope_names.append((name, get_name_scope()))
134          return super().__getattribute__(name)
135      mod = GetAttributeModule()
136      with self.assertRaises(AttributeError):
137        mod.does_not_exist  # pylint: disable=pointless-statement
138      self.assertIn((&quot;does_not_exist&quot;, &quot;&quot;), scope_names)
139  class VariableNamingTest(tf.test.TestCase):
140    def test_variable_names(self):
141      mod = RecursiveModule(3)
142      self.assertEqual(mod.w.name, &quot;badger/mushroom:0&quot;)
143      self.assertEqual(mod.child.w.name, &quot;badger/badger/mushroom:0&quot;)
144      self.assertEqual(mod.child.child.w.name, &quot;badger/badger/badger/mushroom:0&quot;)
145  class AutoReprTest(tf.test.TestCase):
146    def test_order_matches_argspec(self):
147      module = RecursiveModule(trainable=False, depth=2)
148      self.assertEqual(repr(module), &quot;RecursiveModule(depth=2, trainable=False)&quot;)
149    def test_defaults_ignored(self):
150      module = RecursiveModule(1)
151      self.assertEqual(repr(module), &quot;RecursiveModule(depth=1)&quot;)
152    def test_does_not_fail_with_hostile_input(self):
153      r = RaisesOnEquality()
154      self.assertFalse(r.equality_checked)
155      module = NoopModule(r)
156      self.assertEqual(repr(module), &quot;NoopModule(a=hostile)&quot;)
157      self.assertTrue(r.equality_checked)
158    def test_args_are_repred(self):
159      module = TreeModule(name=&quot;TreeModule&quot;)
160      self.assertEqual(repr(module), &quot;TreeModule(name=&#x27;TreeModule&#x27;)&quot;)
161      module = TreeModule(&quot;TreeModule&quot;)
162      self.assertEqual(repr(module), &quot;TreeModule(name=&#x27;TreeModule&#x27;)&quot;)
163    def test_long_repr_multi_line(self):
164      module = TakesSubmodules([TreeModule() for _ in range(6)], name=&quot;hai&quot;)
165      self.assertEqual(
166          repr(module), &quot;\n&quot;.join([
167              &quot;TakesSubmodules(&quot;,
168              &quot;    submodules=[TreeModule(),&quot;,
169              &quot;                TreeModule(),&quot;,
170              &quot;                TreeModule(),&quot;,
171              &quot;                TreeModule(),&quot;,
172              &quot;                TreeModule(),&quot;,
173              &quot;                TreeModule()],&quot;,
174              &quot;    name=&#x27;hai&#x27;,&quot;,
175              &quot;)&quot;,
176          ]))
177    def test_repr_wildcard(self):
178      module = WildcardInit(1, 2, 3, foo=&quot;bar&quot;)
179      self.assertEqual(repr(module), &quot;WildcardInit(a=1, b=2, 3, foo=&#x27;bar&#x27;)&quot;)
180    def test_repr_non_bool_equality(self):
181      class FooModule(base.Module):
182        def __init__(self, a=((-1., -1.))):
183          super().__init__()
184      foo = FooModule(a=np.array([[2., 2.]]))
185      self.assertEqual(repr(foo), &quot;FooModule(a=array([[2., 2.]]))&quot;)
186      foo = FooModule(a=np.array([[-1., -1.]]))
187      self.assertEqual(repr(foo), &quot;FooModule(a=array([[-1., -1.]]))&quot;)
188  class ForwardMethodsTest(tf.test.TestCase):
189    def testFunctionType(self):
190      mod = ModuleWithFunctionAnnotatedCall()
191      self.assertIsInstance(mod.forward, base.TFFunctionType)
192      self.assertIsInstance(mod.forward_ag, base.TFFunctionType)
193    def testEntersNameScope_call(self):
194      mod = ModuleWithFunctionAnnotatedCall()
195      self.assertEqual(mod.forward().numpy(),
196                       b&quot;module_with_function_annotated_call/&quot;)
197    def testEntersNameScope_concreteFunction(self):
198      mod = ModuleWithFunctionAnnotatedCall()
199      self.assertEqual(mod.forward.get_concrete_function()().numpy(),
200                       b&quot;module_with_function_annotated_call/&quot;)
201  class AbcTest(tf.test.TestCase):
202    def testAbstract(self):
203      msg = &quot;Can&#x27;t instantiate .* abstract method&quot;
204      with self.assertRaisesRegex(TypeError, msg):
205        AbstractModule()  # pylint: disable=abstract-class-instantiated
206    def testConcrete(self):
207      mod = ConcreteModule()
208      x, scope_name = mod(2.)
209      self.assertEqual(x, 4.)
210      self.assertEqual(scope_name, &quot;concrete_module/&quot;)
211      self.assertEqual(get_name_scope(), &quot;&quot;)
212    def testCallMethodsOnParent(self):
213      mod = ConcreteModule()
214      self.assertEqual(mod.foo(), True)
215  class CustomGradientTest(test_utils.TestCase):
216    def test_custom_gradient(self):
217      if tf.version.GIT_VERSION != &quot;unknown&quot;:
218        self.skipTest(&quot;Requires TF &gt; 2.0.0&quot;)
219      mod = ZeroGradModule()
220      with tf.GradientTape() as tape:
221        y = mod(2.)
222      g = tape.gradient(y, mod.w)
223      self.assertAllEqual(g, tf.zeros([2, 2]))
224  class ZeroGradModule(base.Module):
225    @tf.custom_gradient
226    def __call__(self, x):
227      if not hasattr(self, &quot;w&quot;):
228        self.w = tf.Variable(tf.ones([2, 2]), name=&quot;w&quot;)
229      with tf.GradientTape() as tape:
230        y = tf.reduce_sum(self.w ** x)
231      dw = tape.gradient(y, self.w)
232      def grad(dy, variables=None):
233        assert variables
234        return dy * 0, [dw * 0]
235      return y, grad
236  class LambdaModule(base.Module):
237    def __call__(self, x):
238      return x
239  def get_name_scope():
240    with tf.name_scope(&quot;x&quot;) as scope_name:
241      return scope_name[:-2]
242  @wrapt.decorator
243  def wrapt_decorator(method, instance, args, kwargs):
244    if instance is None:
245      raise ValueError(&quot;Expected instance to be non-null.&quot;)
246    scope_name, y = method(*args, **kwargs)
247    return scope_name, y**2
248  class WraptModule(base.Module):
249    @wrapt_decorator
250    def __call__(self, x):
251      return get_name_scope(), x**2
252  class ControlFlowModule(base.Module):
253    def __call__(self, x):
254      if x &lt; 10:
255        return x
256      else:
257        return x**2
258  class ErrorModuleError(Exception):
259    pass
260  class ErrorModule(base.Module):
261    def __init__(self, call_super, raise_in_constructor=True):
262      if call_super:
263        super().__init__()
264      if raise_in_constructor:
265        raise ErrorModuleError(&quot;Deliberate error!&quot;)
266    def __call__(self):
267      raise ErrorModuleError(&quot;Deliberate error!&quot;)
268  class RecursiveModule(base.Module):
269    def __init__(self, depth, trainable=True):
270      super().__init__(name=&quot;badger&quot;)
271      self.child = None
272      if depth &gt; 1:
273        self.child = RecursiveModule(depth - 1, trainable=trainable)
274      self.w = tf.Variable(1.0, trainable=trainable, name=&quot;mushroom&quot;)
275  class AbstractModule(base.Module, metaclass=abc.ABCMeta):
276    @abc.abstractmethod
277    def __call__(self, x):
278      pass
279    def foo(self):
280      return True
281  class ConcreteModule(AbstractModule):
282    def __call__(self, x):
283      return x**2, get_name_scope()
284  class TreeModule(base.Module):
285    def __init__(self, name=None):
286      super().__init__(name=name)
287      self._leaves = []
288    def new_leaf(self, name=None):
289      leaf = TreeModule(name=name)
290      self._leaves.append(leaf)
291      return leaf
292  class ReturnsNameScopeModule(base.Module):
293    def alternative_forward(self):
294      return get_name_scope()
295    def __call__(self):
296      return get_name_scope()
297  class SubclassedReturnsNameScopeModule(ReturnsNameScopeModule):
298    def alternative_alternative_forward(self):
299      return get_name_scope()
300  class PropertyThrowsWhenCalledModule(base.Module):
301    @property
302    def raise_assertion_error(self):
303      raise AssertionError
304  class ModuleOverridingNameScope(ReturnsNameScopeModule):
305    @property
306    def name_scope(self):
307      return tf.name_scope(&quot;yolo/&quot;)
308  class CommonErrorsTest(test_utils.TestCase, parameterized.TestCase):
309    def test_not_calling_super_constructor(self):
310      msg = (&quot;Constructing a snt.Module without calling the super constructor is &quot;
311             &quot;not supported&quot;)
312      with self.assertRaisesRegex(ValueError, msg):
313        DoesNotCallSuperConstructorModule()
314    def test_calls_method_before_super(self):
315      msg = &quot;super constructor must be called before any other methods&quot;
316      with self.assertRaisesRegex(AttributeError, msg):
317        CallsMethodBeforeSuperConstructorModule(allowed_method=False)
318    def test_annotated_method_is_allowed(self):
319      self.assertIsNotNone(
320          CallsMethodBeforeSuperConstructorModule(allowed_method=True))
321    @parameterized.parameters(&quot;trainable_variables&quot;, &quot;variables&quot;)
322    def test_requests_variables_before_they_exist(self, property_name):
323      class MyModule(base.Module):
324        pass
325      mod = MyModule()
326      err = &quot;MyModule.* does not currently contain any {}&quot;.format(property_name)
327      with self.assertRaisesRegex(ValueError, err):
328        getattr(mod, property_name)
329    @parameterized.parameters(&quot;trainable_variables&quot;, &quot;variables&quot;)
330    def test_allow_empty_variables_instance(self, property_name):
331      mod = base.Module()
332      mod = base.allow_empty_variables(mod)
333      self.assertEmpty(getattr(mod, property_name))
334    @parameterized.parameters(&quot;trainable_variables&quot;, &quot;variables&quot;)
335    def test_allow_empty_variables_class(self, property_name):
336      mod = NeverCreatesVariables()
337      self.assertEmpty(getattr(mod, property_name))
338  class NoopModule(base.Module):
339    def __init__(self, a=None):
340      super().__init__()
341      self.a = a
342  class RaisesOnEquality:
343    equality_checked = False
344    def __repr__(self):
345      return &quot;hostile&quot;
346    def __eq__(self, other):
347      self.equality_checked = True
348      raise ValueError(&quot;== not supported&quot;)
349    def __ne__(self, other):
350      self.equality_checked = True
351      raise ValueError(&quot;!= not supported&quot;)
352  @base.allow_empty_variables
353  class NeverCreatesVariables(base.Module):
354    pass
355  class ModuleWithFunctionAnnotatedCall(base.Module):
356    @tf.function(autograph=False)
357    def forward(self):
358      return get_name_scope()
359    @tf.function(autograph=True)
360    def forward_ag(self):
361      return get_name_scope()
362  class CtorNoNameScope(base.Module):
363    @base.no_name_scope
364    def __init__(self):
365      super().__init__()
366      self.ctor_name_scope = get_name_scope()
367      self.w = tf.Variable(1., name=&quot;w&quot;)
368  class CtorNoNameScopeNoSuper(base.Module):
369    @base.no_name_scope
370    def __init__(self):
371      pass
372  class PropertyModule(base.Module):
373    def __init__(self):
374      super().__init__()
375      self._setter_scope_name = None
376    @property
377    def some_property(self):
378      getter_scope_name = get_name_scope()
379      return getter_scope_name, self._setter_scope_name
380    @some_property.setter
381    def some_property(self, my_property):
382      self._setter_scope_name = get_name_scope()
383    @property
384    @base.no_name_scope
385    def no_name_scope_property(self):
386      getter_scope_name = get_name_scope()
387      return getter_scope_name, self._setter_scope_name
388    @no_name_scope_property.setter
389    @base.no_name_scope
390    def no_name_scope_property(self, my_property):
391      self._setter_scope_name = get_name_scope()
392  class DoesNotCallSuperConstructorModule(base.Module):
393    def __init__(self):
394      pass
395  class CallsMethodBeforeSuperConstructorModule(base.Module):
396    def __init__(self, allowed_method):
397      if allowed_method:
398        self.no_name_scope()
399      else:
400        self.with_name_scope()
401      super().__init__()
402    @base.no_name_scope
403    def no_name_scope(self):
404      pass
405    def with_name_scope(self):
406      pass
407  class CustomMetaclass(type):
408    TAG = &quot;__custom_metaclass__&quot;
409    def __new__(cls, name, bases, clsdict):
410      new_type = super(CustomMetaclass, cls).__new__(cls, name, bases, clsdict)
411      setattr(new_type, CustomMetaclass.TAG, True)
412      return new_type
413  class CombiningMetaclass(base.ModuleMetaclass, CustomMetaclass):
414    TAG = &quot;__combining_metaclass__&quot;
415    def __new__(cls, name, bases, clsdict):
416      new_type = super(CombiningMetaclass, cls).__new__(cls, name, bases, clsdict)  # pylint: disable=too-many-function-args
417      setattr(new_type, CombiningMetaclass.TAG, True)
418      return new_type
419  class ModuleWithCustomMetaclass(base.Module, metaclass=CombiningMetaclass):
420    def __init__(self):
421      super(ModuleWithCustomMetaclass, self).__init__()
422      self.init_name_scope = get_name_scope()
423  class CustomMetaclassTest(tf.test.TestCase):
424    def testSupportsCustomMetaclass(self):
425      m = ModuleWithCustomMetaclass()
426      self.assertEqual(m.init_name_scope, &quot;module_with_custom_metaclass/&quot;)
427      self.assertTrue(getattr(ModuleWithCustomMetaclass, CombiningMetaclass.TAG))
428      self.assertTrue(getattr(ModuleWithCustomMetaclass, CustomMetaclass.TAG))
429  class TakesSubmodules(base.Module):
430    def __init__(self, submodules, name=None):
431      super().__init__(name=name)
432  class WildcardInit(base.Module):
433    def __init__(self, a, b, *args, **kwargs):
434      super().__init__()
435      del args, kwargs
436  if __name__ == &quot;__main__&quot;:
437    tf.test.main()
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from sonnet-MDEwOlJlcG9zaXRvcnk4NzA2NzIxMg==-flat-base_test.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from sonnet-MDEwOlJlcG9zaXRvcnk4NzA2NzIxMg==-flat-base_test.py</div>
                </div>
                <div class="column column_space"><pre><code>69      getter_scope_name, setter_scope_name = mod.some_property
70      self.assertEqual(getter_scope_name, &quot;property_module/&quot;)
71      self.assertEqual(setter_scope_name, &quot;property_module/&quot;)
72    def test_property_no_name_scope(self):
73      mod = PropertyModule()
74      mod.no_name_scope_property = None, None  # None, None for the linter.
</pre></code></div>
                <div class="column column_space"><pre><code>75      getter_scope_name, setter_scope_name = mod.no_name_scope_property
76      self.assertEqual(getter_scope_name, &quot;&quot;)
77      self.assertEqual(setter_scope_name, &quot;&quot;)
78    def test_ctor_no_name_scope(self):
79      mod = CtorNoNameScope()
80      self.assertEqual(mod.ctor_name_scope, &quot;&quot;)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    