<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_runner_returns.py & test_pip_state_1.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_runner_returns.py & test_pip_state_1.py
      </h3>
      <h1 align="center">
        2.5%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_runner_returns.py (5.5555553%)<TH>test_pip_state_1.py (1.6901408%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match136039-0.html#0',2,'match136039-1.html#0',3)" NAME="0">(5-17)<TD><A HREF="javascript:ZweiFrames('match136039-0.html#0',2,'match136039-1.html#0',3)" NAME="0">(6-18)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_runner_returns.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
<A NAME="0"></A>Tests for runner_returns
&quot;&quot;&quot;

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match136039-1.html#0',3,'match136039-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import errno
import os
import socket
import tempfile

import pytest
import salt.payload
import salt.utils.args
import salt.utils.files
import salt.utils.jid
import salt.utils.yaml
from tests.support.case import ShellCase
from</B></FONT> tests.support.runtests import RUNTIME_VARS


@pytest.mark.windows_whitelisted
class RunnerReturnsTest(ShellCase):
    &quot;&quot;&quot;
    Test the &quot;runner_returns&quot; feature
    &quot;&quot;&quot;

    def setUp(self):
        &quot;&quot;&quot;
        Create the temp file and master.d directory
        &quot;&quot;&quot;
        self.job_dir = os.path.join(self.master_opts[&quot;cachedir&quot;], &quot;jobs&quot;)
        self.hash_type = self.master_opts[&quot;hash_type&quot;]
        self.master_d_dir = os.path.join(self.config_dir, &quot;master.d&quot;)
        try:
            os.makedirs(self.master_d_dir)
        except OSError as exc:
            if exc.errno != errno.EEXIST:
                raise

        self.conf = tempfile.NamedTemporaryFile(
            mode=&quot;w&quot;,
            suffix=&quot;.conf&quot;,
            dir=self.master_d_dir,
            delete=False,
        )

    def tearDown(self):
        &quot;&quot;&quot;
        Close the tempfile.NamedTemporaryFile object, cleaning it up
        &quot;&quot;&quot;
        try:
            self.conf.close()
        except OSError:
            pass
        salt.utils.files.rm_rf(self.master_d_dir)
        # Force a reload of the configuration now that our temp config file has
        # been removed.
        self.run_run_plus(&quot;test.arg&quot;)

    @staticmethod
    def clean_return(data):
        &quot;&quot;&quot;
        Remove kwargs and timestamp (things that are variable) so we have a
        stable value to assert
        &quot;&quot;&quot;
        # Remove pub_kwargs
        data[&quot;fun_args&quot;][1] = salt.utils.args.clean_kwargs(**data[&quot;fun_args&quot;][1])
        data[&quot;return&quot;][&quot;kwargs&quot;] = salt.utils.args.clean_kwargs(
            **data[&quot;return&quot;][&quot;kwargs&quot;]
        )

        # Pop off dynamic keys in the return schema that are impossible to test.
        # Do not supply the default arguments because we want to know if we are
        # missing some aspect of the schema.
        data.pop(&quot;_stamp&quot;)

    def write_conf(self, data):
        &quot;&quot;&quot;
        Dump the config dict to the conf file
        &quot;&quot;&quot;
        self.conf.write(salt.utils.yaml.safe_dump(data, default_flow_style=False))
        self.conf.flush()
        self.conf.close()

    @pytest.mark.slow_test
    def test_runner_returns_disabled(self):
        &quot;&quot;&quot;
        Test with runner_returns disabled
        &quot;&quot;&quot;
        self.write_conf({&quot;runner_returns&quot;: False})
        ret = self.run_run_plus(&quot;test.arg&quot;, &quot;foo&quot;, bar=&quot;hello world!&quot;)

        jid = ret.get(&quot;jid&quot;)
        if jid is None:
            raise Exception(&quot;jid missing from run_run_plus output&quot;)

        serialized_return = os.path.join(
            salt.utils.jid.jid_dir(jid, self.job_dir, self.hash_type),
            &quot;master&quot;,
            &quot;return.p&quot;,
        )
        self.assertFalse(os.path.isfile(serialized_return))

    @pytest.mark.slow_test
    def test_runner_returns_enabled(self):
        &quot;&quot;&quot;
        Test with runner_returns enabled
        &quot;&quot;&quot;
        self.write_conf({&quot;runner_returns&quot;: True})
        ret = self.run_run_plus(&quot;test.arg&quot;, &quot;foo&quot;, bar=&quot;hello world!&quot;)

        jid = ret.get(&quot;jid&quot;)
        if jid is None:
            raise Exception(&quot;jid missing from run_run_plus output&quot;)

        serialized_return = os.path.join(
            salt.utils.jid.jid_dir(jid, self.job_dir, self.hash_type),
            &quot;master&quot;,
            &quot;return.p&quot;,
        )
        with salt.utils.files.fopen(serialized_return, &quot;rb&quot;) as fp_:
            deserialized = salt.payload.loads(fp_.read(), encoding=&quot;utf-8&quot;)

        self.clean_return(deserialized[&quot;return&quot;])

        # Now we have something sane we can reliably compare in an assert.
        if &quot;SUDO_USER&quot; in os.environ:
            user = &quot;sudo_{}&quot;.format(os.environ[&quot;SUDO_USER&quot;])
        else:
            user = RUNTIME_VARS.RUNNING_TESTS_USER
        if salt.utils.platform.is_windows():
            user = &quot;sudo_{}\\{}&quot;.format(socket.gethostname(), user)
        self.assertEqual(
            deserialized,
            {
                &quot;return&quot;: {
                    &quot;fun&quot;: &quot;runner.test.arg&quot;,
                    &quot;fun_args&quot;: [&quot;foo&quot;, {&quot;bar&quot;: &quot;hello world!&quot;}],
                    &quot;jid&quot;: jid,
                    &quot;return&quot;: {&quot;args&quot;: [&quot;foo&quot;], &quot;kwargs&quot;: {&quot;bar&quot;: &quot;hello world!&quot;}},
                    &quot;success&quot;: True,
                    &quot;user&quot;: user,
                }
            },
        )
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_pip_state_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
tests.unit.states.pip_test
<A NAME="0"></A>~~~~~~~~~~~~~~~~~~~~~~~~~~
&quot;&quot;&quot;

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match136039-0.html#0',2,'match136039-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import logging
import os
import subprocess
import sys

import pytest
import salt.states.pip_state as pip_state
import salt.utils.path
import salt.version
from salt.modules.virtualenv_mod import KNOWN_BINARY_NAMES
from tests.support.helpers import VirtualEnv, dedent
from tests.support.mixins import LoaderModuleMockMixin, SaltReturnAssertsMixin
from</B></FONT> tests.support.mock import MagicMock, patch
from tests.support.runtests import RUNTIME_VARS
from tests.support.unit import TestCase, skipIf

try:
    import pip

    HAS_PIP = True
except ImportError:
    HAS_PIP = False


log = logging.getLogger(__name__)


@skipIf(not HAS_PIP, &quot;The 'pip' library is not importable(installed system-wide)&quot;)
class PipStateTest(TestCase, SaltReturnAssertsMixin, LoaderModuleMockMixin):
    def setup_loader_modules(self):
        return {
            pip_state: {
                &quot;__env__&quot;: &quot;base&quot;,
                &quot;__opts__&quot;: {&quot;test&quot;: False},
                &quot;__salt__&quot;: {&quot;cmd.which_bin&quot;: lambda _: &quot;pip&quot;},
            }
        }

    def test_install_requirements_parsing(self):
        log.debug(&quot;Real pip version is %s&quot;, pip.__version__)
        mock = MagicMock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: &quot;&quot;})
        pip_list = MagicMock(return_value={&quot;pep8&quot;: &quot;1.3.3&quot;})
        pip_version = pip.__version__
        mock_pip_version = MagicMock(return_value=pip_version)
        with patch.dict(pip_state.__salt__, {&quot;pip.version&quot;: mock_pip_version}):
            with patch.dict(
                pip_state.__salt__, {&quot;cmd.run_all&quot;: mock, &quot;pip.list&quot;: pip_list}
            ):
                with patch.dict(pip_state.__opts__, {&quot;test&quot;: True}):
                    log.debug(
                        &quot;pip_state._from_line globals: %s&quot;,
                        [name for name in pip_state._from_line.__globals__],
                    )
                    ret = pip_state.installed(&quot;pep8=1.3.2&quot;)
                    self.assertSaltFalseReturn({&quot;test&quot;: ret})
                    self.assertInSaltComment(
                        &quot;Invalid version specification in package pep8=1.3.2. &quot;
                        &quot;'=' is not supported, use '==' instead.&quot;,
                        {&quot;test&quot;: ret},
                    )

            mock = MagicMock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: &quot;&quot;})
            pip_list = MagicMock(return_value={&quot;pep8&quot;: &quot;1.3.3&quot;})
            pip_install = MagicMock(return_value={&quot;retcode&quot;: 0})
            with patch.dict(
                pip_state.__salt__,
                {&quot;cmd.run_all&quot;: mock, &quot;pip.list&quot;: pip_list, &quot;pip.install&quot;: pip_install},
            ):
                with patch.dict(pip_state.__opts__, {&quot;test&quot;: True}):
                    ret = pip_state.installed(&quot;pep8&gt;=1.3.2&quot;)
                    self.assertSaltTrueReturn({&quot;test&quot;: ret})
                    self.assertInSaltComment(
                        &quot;Python package pep8&gt;=1.3.2 was already installed&quot;,
                        {&quot;test&quot;: ret},
                    )

            mock = MagicMock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: &quot;&quot;})
            pip_list = MagicMock(return_value={&quot;pep8&quot;: &quot;1.3.3&quot;})
            with patch.dict(
                pip_state.__salt__, {&quot;cmd.run_all&quot;: mock, &quot;pip.list&quot;: pip_list}
            ):
                with patch.dict(pip_state.__opts__, {&quot;test&quot;: True}):
                    ret = pip_state.installed(&quot;pep8&lt;1.3.2&quot;)
                    self.assertSaltNoneReturn({&quot;test&quot;: ret})
                    self.assertInSaltComment(
                        &quot;Python package pep8&lt;1.3.2 is set to be installed&quot;,
                        {&quot;test&quot;: ret},
                    )

            mock = MagicMock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: &quot;&quot;})
            pip_list = MagicMock(return_value={&quot;pep8&quot;: &quot;1.3.2&quot;})
            pip_install = MagicMock(return_value={&quot;retcode&quot;: 0})
            with patch.dict(
                pip_state.__salt__,
                {&quot;cmd.run_all&quot;: mock, &quot;pip.list&quot;: pip_list, &quot;pip.install&quot;: pip_install},
            ):
                with patch.dict(pip_state.__opts__, {&quot;test&quot;: True}):
                    ret = pip_state.installed(&quot;pep8&gt;1.3.1,&lt;1.3.3&quot;)
                    self.assertSaltTrueReturn({&quot;test&quot;: ret})
                    self.assertInSaltComment(
                        &quot;Python package pep8&gt;1.3.1,&lt;1.3.3 was already installed&quot;,
                        {&quot;test&quot;: ret},
                    )

            mock = MagicMock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: &quot;&quot;})
            pip_list = MagicMock(return_value={&quot;pep8&quot;: &quot;1.3.1&quot;})
            pip_install = MagicMock(return_value={&quot;retcode&quot;: 0})
            with patch.dict(
                pip_state.__salt__,
                {&quot;cmd.run_all&quot;: mock, &quot;pip.list&quot;: pip_list, &quot;pip.install&quot;: pip_install},
            ):
                with patch.dict(pip_state.__opts__, {&quot;test&quot;: True}):
                    ret = pip_state.installed(&quot;pep8&gt;1.3.1,&lt;1.3.3&quot;)
                    self.assertSaltNoneReturn({&quot;test&quot;: ret})
                    self.assertInSaltComment(
                        &quot;Python package pep8&gt;1.3.1,&lt;1.3.3 is set to be installed&quot;,
                        {&quot;test&quot;: ret},
                    )

            mock = MagicMock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: &quot;&quot;})
            pip_list = MagicMock(return_value={&quot;pep8&quot;: &quot;1.3.1&quot;})
            with patch.dict(
                pip_state.__salt__, {&quot;cmd.run_all&quot;: mock, &quot;pip.list&quot;: pip_list}
            ):
                with patch.dict(pip_state.__opts__, {&quot;test&quot;: True}):
                    ret = pip_state.installed(
                        &quot;git+https://github.com/saltstack/salt-testing.git#egg=SaltTesting&gt;=0.5.1&quot;
                    )
                    self.assertSaltNoneReturn({&quot;test&quot;: ret})
                    self.assertInSaltComment(
                        &quot;Python package git+https://github.com/saltstack/&quot;
                        &quot;salt-testing.git#egg=SaltTesting&gt;=0.5.1 is set to be &quot;
                        &quot;installed&quot;,
                        {&quot;test&quot;: ret},
                    )

            mock = MagicMock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: &quot;&quot;})
            pip_list = MagicMock(return_value={&quot;pep8&quot;: &quot;1.3.1&quot;})
            with patch.dict(
                pip_state.__salt__, {&quot;cmd.run_all&quot;: mock, &quot;pip.list&quot;: pip_list}
            ):
                with patch.dict(pip_state.__opts__, {&quot;test&quot;: True}):
                    ret = pip_state.installed(
                        &quot;git+https://github.com/saltstack/salt-testing.git#egg=SaltTesting&quot;
                    )
                    self.assertSaltNoneReturn({&quot;test&quot;: ret})
                    self.assertInSaltComment(
                        &quot;Python package git+https://github.com/saltstack/&quot;
                        &quot;salt-testing.git#egg=SaltTesting is set to be &quot;
                        &quot;installed&quot;,
                        {&quot;test&quot;: ret},
                    )

            mock = MagicMock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: &quot;&quot;})
            pip_list = MagicMock(return_value={&quot;pep8&quot;: &quot;1.3.1&quot;})
            with patch.dict(
                pip_state.__salt__, {&quot;cmd.run_all&quot;: mock, &quot;pip.list&quot;: pip_list}
            ):
                with patch.dict(pip_state.__opts__, {&quot;test&quot;: True}):
                    ret = pip_state.installed(
                        &quot;https://pypi.python.org/packages/source/S/SaltTesting/&quot;
                        &quot;SaltTesting-0.5.0.tar.gz&quot;
                        &quot;#md5=e6760af92b7165f8be53b5763e40bc24&quot;
                    )
                    self.assertSaltNoneReturn({&quot;test&quot;: ret})
                    self.assertInSaltComment(
                        &quot;Python package https://pypi.python.org/packages/source/&quot;
                        &quot;S/SaltTesting/SaltTesting-0.5.0.tar.gz&quot;
                        &quot;#md5=e6760af92b7165f8be53b5763e40bc24 is set to be &quot;
                        &quot;installed&quot;,
                        {&quot;test&quot;: ret},
                    )

            mock = MagicMock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: &quot;&quot;})
            pip_list = MagicMock(return_value={&quot;SaltTesting&quot;: &quot;0.5.0&quot;})
            pip_install = MagicMock(
                return_value={
                    &quot;retcode&quot;: 0,
                    &quot;stderr&quot;: &quot;&quot;,
                    &quot;stdout&quot;: (
                        &quot;Downloading/unpacking https://pypi.python.org/packages&quot;
                        &quot;/source/S/SaltTesting/SaltTesting-0.5.0.tar.gz\n  &quot;
                        &quot;Downloading SaltTesting-0.5.0.tar.gz\n  Running &quot;
                        &quot;setup.py egg_info for package from &quot;
                        &quot;https://pypi.python.org/packages/source/S/SaltTesting/&quot;
                        &quot;SaltTesting-0.5.0.tar.gz\n    \nCleaning up...&quot;
                    ),
                }
            )
            with patch.dict(
                pip_state.__salt__,
                {&quot;cmd.run_all&quot;: mock, &quot;pip.list&quot;: pip_list, &quot;pip.install&quot;: pip_install},
            ):
                ret = pip_state.installed(
                    &quot;https://pypi.python.org/packages/source/S/SaltTesting/&quot;
                    &quot;SaltTesting-0.5.0.tar.gz&quot;
                    &quot;#md5=e6760af92b7165f8be53b5763e40bc24&quot;
                )
                self.assertSaltTrueReturn({&quot;test&quot;: ret})
                self.assertInSaltComment(
                    &quot;All packages were successfully installed&quot;, {&quot;test&quot;: ret}
                )
                self.assertInSaltReturn(
                    &quot;Installed&quot;,
                    {&quot;test&quot;: ret},
                    (
                        &quot;changes&quot;,
                        &quot;https://pypi.python.org/packages/source/S/&quot;
                        &quot;SaltTesting/SaltTesting-0.5.0.tar.gz&quot;
                        &quot;#md5=e6760af92b7165f8be53b5763e40bc24==???&quot;,
                    ),
                )

            mock = MagicMock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: &quot;&quot;})
            pip_list = MagicMock(return_value={&quot;SaltTesting&quot;: &quot;0.5.0&quot;})
            pip_install = MagicMock(
                return_value={&quot;retcode&quot;: 0, &quot;stderr&quot;: &quot;&quot;, &quot;stdout&quot;: &quot;Cloned!&quot;}
            )
            with patch.dict(
                pip_state.__salt__,
                {&quot;cmd.run_all&quot;: mock, &quot;pip.list&quot;: pip_list, &quot;pip.install&quot;: pip_install},
            ):
                with patch.dict(pip_state.__opts__, {&quot;test&quot;: False}):
                    ret = pip_state.installed(
                        &quot;git+https://github.com/saltstack/salt-testing.git#egg=SaltTesting&quot;
                    )
                    self.assertSaltTrueReturn({&quot;test&quot;: ret})
                    self.assertInSaltComment(
                        &quot;packages are already installed&quot;, {&quot;test&quot;: ret}
                    )

            mock = MagicMock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: &quot;&quot;})
            pip_list = MagicMock(return_value={&quot;pep8&quot;: &quot;1.3.1&quot;})
            pip_install = MagicMock(return_value={&quot;retcode&quot;: 0})
            with patch.dict(
                pip_state.__salt__,
                {&quot;cmd.run_all&quot;: mock, &quot;pip.list&quot;: pip_list, &quot;pip.install&quot;: pip_install},
            ):
                with patch.dict(pip_state.__opts__, {&quot;test&quot;: False}):
                    ret = pip_state.installed(
                        &quot;arbitrary ID that should be ignored due to requirements&quot;
                        &quot; specified&quot;,
                        requirements=&quot;/tmp/non-existing-requirements.txt&quot;,
                    )
                    self.assertSaltTrueReturn({&quot;test&quot;: ret})

            # Test VCS installations using git+git://
            mock = MagicMock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: &quot;&quot;})
            pip_list = MagicMock(return_value={&quot;SaltTesting&quot;: &quot;0.5.0&quot;})
            pip_install = MagicMock(
                return_value={&quot;retcode&quot;: 0, &quot;stderr&quot;: &quot;&quot;, &quot;stdout&quot;: &quot;Cloned!&quot;}
            )
            with patch.dict(
                pip_state.__salt__,
                {&quot;cmd.run_all&quot;: mock, &quot;pip.list&quot;: pip_list, &quot;pip.install&quot;: pip_install},
            ):
                with patch.dict(pip_state.__opts__, {&quot;test&quot;: False}):
                    ret = pip_state.installed(
                        &quot;git+git://github.com/saltstack/salt-testing.git#egg=SaltTesting&quot;
                    )
                    self.assertSaltTrueReturn({&quot;test&quot;: ret})
                    self.assertInSaltComment(
                        &quot;packages are already installed&quot;, {&quot;test&quot;: ret}
                    )

    def test_install_requirements_custom_pypi(self):
        &quot;&quot;&quot;
        test requirement parsing for both when a custom
        pypi index-url is set and when it is not and
        the requirement is already installed.
        &quot;&quot;&quot;

        # create requirements file
        req_filename = os.path.join(
            RUNTIME_VARS.TMP_STATE_TREE, &quot;custom-pypi-requirements.txt&quot;
        )
        with salt.utils.files.fopen(req_filename, &quot;wb&quot;) as reqf:
            reqf.write(b&quot;pep8\n&quot;)

        site_pkgs = &quot;/tmp/pip-env/lib/python3.7/site-packages&quot;
        check_stdout = [
            &quot;Looking in indexes: https://custom-pypi-url.org,&quot;
            &quot;https://pypi.org/simple/\nRequirement already satisfied: pep8 in {1}&quot;
            &quot;(from -r /tmp/files/prod/{0} (line 1)) (1.7.1)&quot;.format(
                req_filename, site_pkgs
            ),
            &quot;Requirement already satisfied: pep8 in {1}&quot;
            &quot;(from -r /tmp/files/prod/{0} (line1)) (1.7.1)&quot;.format(
                req_filename, site_pkgs
            ),
        ]
        pip_version = pip.__version__
        mock_pip_version = MagicMock(return_value=pip_version)

        for stdout in check_stdout:
            pip_install = MagicMock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: stdout})
            with patch.dict(pip_state.__salt__, {&quot;pip.version&quot;: mock_pip_version}):
                with patch.dict(pip_state.__salt__, {&quot;pip.install&quot;: pip_install}):
                    ret = pip_state.installed(name=&quot;&quot;, requirements=req_filename)
                    self.assertSaltTrueReturn({&quot;test&quot;: ret})
                    assert &quot;Requirements were already installed.&quot; == ret[&quot;comment&quot;]

    def test_install_requirements_custom_pypi_changes(self):
        &quot;&quot;&quot;
        test requirement parsing for both when a custom
        pypi index-url is set and when it is not and
        the requirement is not installed.
        &quot;&quot;&quot;

        # create requirements file
        req_filename = os.path.join(
            RUNTIME_VARS.TMP_STATE_TREE, &quot;custom-pypi-requirements.txt&quot;
        )
        with salt.utils.files.fopen(req_filename, &quot;wb&quot;) as reqf:
            reqf.write(b&quot;pep8\n&quot;)

        site_pkgs = &quot;/tmp/pip-env/lib/python3.7/site-packages&quot;
        check_stdout = [
            &quot;Looking in indexes:&quot;
            &quot; https://custom-pypi-url.org,https://pypi.org/simple/\nCollecting pep8\n &quot;
            &quot; Using&quot;
            &quot; cachedhttps://custom-pypi-url.org//packages/42/3f/669429cef5acb4/pep8-1.7.1-py2.py3-none-any.whl&quot;
            &quot; (41 kB)\nInstalling collected packages: pep8\nSuccessfully installed&quot;
            &quot; pep8-1.7.1&quot;,
            &quot;Collecting pep8\n  Using&quot;
            &quot; cachedhttps://custom-pypi-url.org//packages/42/3f/669429cef5acb4/pep8-1.7.1-py2.py3-none-any.whl&quot;
            &quot; (41 kB)\nInstalling collected packages: pep8\nSuccessfully installed&quot;
            &quot; pep8-1.7.1&quot;,
        ]

        pip_version = pip.__version__
        mock_pip_version = MagicMock(return_value=pip_version)

        for stdout in check_stdout:
            pip_install = MagicMock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: stdout})
            with patch.dict(pip_state.__salt__, {&quot;pip.version&quot;: mock_pip_version}):
                with patch.dict(pip_state.__salt__, {&quot;pip.install&quot;: pip_install}):
                    ret = pip_state.installed(name=&quot;&quot;, requirements=req_filename)
                    self.assertSaltTrueReturn({&quot;test&quot;: ret})
                    assert (
                        &quot;Successfully processed requirements file {}.&quot;.format(
                            req_filename
                        )
                        == ret[&quot;comment&quot;]
                    )

    def test_install_in_editable_mode(self):
        &quot;&quot;&quot;
        Check that `name` parameter containing bad characters is not parsed by
        pip when package is being installed in editable mode.
        For more information, see issue #21890.
        &quot;&quot;&quot;
        mock = MagicMock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: &quot;&quot;})
        pip_list = MagicMock(return_value={})
        pip_install = MagicMock(
            return_value={&quot;retcode&quot;: 0, &quot;stderr&quot;: &quot;&quot;, &quot;stdout&quot;: &quot;Cloned!&quot;}
        )
        pip_version = MagicMock(return_value=&quot;10.0.1&quot;)
        with patch.dict(
            pip_state.__salt__,
            {
                &quot;cmd.run_all&quot;: mock,
                &quot;pip.list&quot;: pip_list,
                &quot;pip.install&quot;: pip_install,
                &quot;pip.version&quot;: pip_version,
            },
        ):
            ret = pip_state.installed(
                &quot;state@name&quot;, cwd=&quot;/path/to/project&quot;, editable=[&quot;.&quot;]
            )
            self.assertSaltTrueReturn({&quot;test&quot;: ret})
            self.assertInSaltComment(&quot;successfully installed&quot;, {&quot;test&quot;: ret})


class PipStateUtilsTest(TestCase):
    def test_has_internal_exceptions_mod_function(self):
        assert pip_state.pip_has_internal_exceptions_mod(&quot;10.0&quot;)
        assert pip_state.pip_has_internal_exceptions_mod(&quot;18.1&quot;)
        assert not pip_state.pip_has_internal_exceptions_mod(&quot;9.99&quot;)

    def test_has_exceptions_mod_function(self):
        assert pip_state.pip_has_exceptions_mod(&quot;1.0&quot;)
        assert not pip_state.pip_has_exceptions_mod(&quot;0.1&quot;)
        assert not pip_state.pip_has_exceptions_mod(&quot;10.0&quot;)

    def test_pip_purge_method_with_pip(self):
        mock_modules = sys.modules.copy()
        mock_modules.pop(&quot;pip&quot;, None)
        mock_modules[&quot;pip&quot;] = object()
        with patch(&quot;sys.modules&quot;, mock_modules):
            pip_state.purge_pip()
        assert &quot;pip&quot; not in mock_modules

    def test_pip_purge_method_without_pip(self):
        mock_modules = sys.modules.copy()
        mock_modules.pop(&quot;pip&quot;, None)
        with patch(&quot;sys.modules&quot;, mock_modules):
            pip_state.purge_pip()


@skipIf(
    salt.utils.path.which_bin(KNOWN_BINARY_NAMES) is None, &quot;virtualenv not installed&quot;
)
@pytest.mark.requires_network
class PipStateInstallationErrorTest(TestCase):
    @pytest.mark.slow_test
    def test_importable_installation_error(self):
        extra_requirements = []
        for name, version in salt.version.dependency_information():
            if name in [&quot;PyYAML&quot;]:
                extra_requirements.append(&quot;{}=={}&quot;.format(name, version))
        failures = {}
        pip_version_requirements = [
            # Latest pip 18
            &quot;&lt;19.0&quot;,
            # Latest pip 19
            &quot;&lt;20.0&quot;,
            # Latest pip 20
            &quot;&lt;21.0&quot;,
            # Latest pip
            None,
        ]
        code = dedent(
            &quot;&quot;&quot;\
        import sys
        import traceback
        try:
            import salt.states.pip_state
            salt.states.pip_state.InstallationError
        except ImportError as exc:
            traceback.print_exc(file=sys.stdout)
            sys.stdout.flush()
            sys.exit(1)
        except AttributeError as exc:
            traceback.print_exc(file=sys.stdout)
            sys.stdout.flush()
            sys.exit(2)
        except Exception as exc:
            traceback.print_exc(exc, file=sys.stdout)
            sys.stdout.flush()
            sys.exit(3)
        sys.exit(0)
        &quot;&quot;&quot;
        )
        for requirement in list(pip_version_requirements):
            try:
                with VirtualEnv() as venv:
                    venv.install(*extra_requirements)
                    if requirement:
                        venv.install(&quot;pip{}&quot;.format(requirement))
                    try:
                        subprocess.check_output([venv.venv_python, &quot;-c&quot;, code])
                    except subprocess.CalledProcessError as exc:
                        if exc.returncode == 1:
                            failures[requirement] = &quot;Failed to import pip:\n{}&quot;.format(
                                exc.output
                            )
                        elif exc.returncode == 2:
                            failures[
                                requirement
                            ] = &quot;Failed to import InstallationError from pip:\n{}&quot;.format(
                                exc.output
                            )
                        else:
                            failures[requirement] = exc.output
            except Exception as exc:  # pylint: disable=broad-except
                failures[requirement] = str(exc)
        if failures:
            errors = &quot;&quot;
            for requirement, exception in failures.items():
                errors += &quot;pip{}: {}\n\n&quot;.format(requirement or &quot;&quot;, exception)
            self.fail(
                &quot;Failed to get InstallationError exception under at least one pip&quot;
                &quot; version:\n{}&quot;.format(errors)
            )
</PRE>
</div>
  </div>
</body>
</html>
