<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_runner_returns.py &amp; test_pip_state_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_runner_returns.py &amp; test_pip_state_1.py
      </h3>
<h1 align="center">
        2.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_runner_returns.py (5.5555553%)<th>test_pip_state_1.py (1.6901408%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(5-17)<td><a href="#" name="0">(6-18)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_runner_returns.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import errno
2 import os
3 import socket
4 import tempfile
5 import pytest
6 import salt.payload
7 import salt.utils.args
8 import salt.utils.files
9 import salt.utils.jid
10 import salt.utils.yaml
11 from tests.support.case import ShellCase
12 from</b></font> tests.support.runtests import RUNTIME_VARS
13 @pytest.mark.windows_whitelisted
14 class RunnerReturnsTest(ShellCase):
15     def setUp(self):
16         self.job_dir = os.path.join(self.master_opts["cachedir"], "jobs")
17         self.hash_type = self.master_opts["hash_type"]
18         self.master_d_dir = os.path.join(self.config_dir, "master.d")
19         try:
20             os.makedirs(self.master_d_dir)
21         except OSError as exc:
22             if exc.errno != errno.EEXIST:
23                 raise
24         self.conf = tempfile.NamedTemporaryFile(
25             mode="w",
26             suffix=".conf",
27             dir=self.master_d_dir,
28             delete=False,
29         )
30     def tearDown(self):
31         try:
32             self.conf.close()
33         except OSError:
34             pass
35         salt.utils.files.rm_rf(self.master_d_dir)
36         self.run_run_plus("test.arg")
37     @staticmethod
38     def clean_return(data):
39         data["fun_args"][1] = salt.utils.args.clean_kwargs(**data["fun_args"][1])
40         data["return"]["kwargs"] = salt.utils.args.clean_kwargs(
41             **data["return"]["kwargs"]
42         )
43         data.pop("_stamp")
44     def write_conf(self, data):
45         self.conf.write(salt.utils.yaml.safe_dump(data, default_flow_style=False))
46         self.conf.flush()
47         self.conf.close()
48     @pytest.mark.slow_test
49     def test_runner_returns_disabled(self):
50         self.write_conf({"runner_returns": False})
51         ret = self.run_run_plus("test.arg", "foo", bar="hello world!")
52         jid = ret.get("jid")
53         if jid is None:
54             raise Exception("jid missing from run_run_plus output")
55         serialized_return = os.path.join(
56             salt.utils.jid.jid_dir(jid, self.job_dir, self.hash_type),
57             "master",
58             "return.p",
59         )
60         self.assertFalse(os.path.isfile(serialized_return))
61     @pytest.mark.slow_test
62     def test_runner_returns_enabled(self):
63         self.write_conf({"runner_returns": True})
64         ret = self.run_run_plus("test.arg", "foo", bar="hello world!")
65         jid = ret.get("jid")
66         if jid is None:
67             raise Exception("jid missing from run_run_plus output")
68         serialized_return = os.path.join(
69             salt.utils.jid.jid_dir(jid, self.job_dir, self.hash_type),
70             "master",
71             "return.p",
72         )
73         with salt.utils.files.fopen(serialized_return, "rb") as fp_:
74             deserialized = salt.payload.loads(fp_.read(), encoding="utf-8")
75         self.clean_return(deserialized["return"])
76         if "SUDO_USER" in os.environ:
77             user = "sudo_{}".format(os.environ["SUDO_USER"])
78         else:
79             user = RUNTIME_VARS.RUNNING_TESTS_USER
80         if salt.utils.platform.is_windows():
81             user = "sudo_{}\\{}".format(socket.gethostname(), user)
82         self.assertEqual(
83             deserialized,
84             {
85                 "return": {
86                     "fun": "runner.test.arg",
87                     "fun_args": ["foo", {"bar": "hello world!"}],
88                     "jid": jid,
89                     "return": {"args": ["foo"], "kwargs": {"bar": "hello world!"}},
90                     "success": True,
91                     "user": user,
92                 }
93             },
94         )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_pip_state_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import logging
2 import os
3 import subprocess
4 import sys
5 import pytest
6 import salt.states.pip_state as pip_state
7 import salt.utils.path
8 import salt.version
9 from salt.modules.virtualenv_mod import KNOWN_BINARY_NAMES
10 from tests.support.helpers import VirtualEnv, dedent
11 from tests.support.mixins import LoaderModuleMockMixin, SaltReturnAssertsMixin
12 from</b></font> tests.support.mock import MagicMock, patch
13 from tests.support.runtests import RUNTIME_VARS
14 from tests.support.unit import TestCase, skipIf
15 try:
16     import pip
17     HAS_PIP = True
18 except ImportError:
19     HAS_PIP = False
20 log = logging.getLogger(__name__)
21 @skipIf(not HAS_PIP, "The 'pip' library is not importable(installed system-wide)")
22 class PipStateTest(TestCase, SaltReturnAssertsMixin, LoaderModuleMockMixin):
23     def setup_loader_modules(self):
24         return {
25             pip_state: {
26                 "__env__": "base",
27                 "__opts__": {"test": False},
28                 "__salt__": {"cmd.which_bin": lambda _: "pip"},
29             }
30         }
31     def test_install_requirements_parsing(self):
32         log.debug("Real pip version is %s", pip.__version__)
33         mock = MagicMock(return_value={"retcode": 0, "stdout": ""})
34         pip_list = MagicMock(return_value={"pep8": "1.3.3"})
35         pip_version = pip.__version__
36         mock_pip_version = MagicMock(return_value=pip_version)
37         with patch.dict(pip_state.__salt__, {"pip.version": mock_pip_version}):
38             with patch.dict(
39                 pip_state.__salt__, {"cmd.run_all": mock, "pip.list": pip_list}
40             ):
41                 with patch.dict(pip_state.__opts__, {"test": True}):
42                     log.debug(
43                         "pip_state._from_line globals: %s",
44                         [name for name in pip_state._from_line.__globals__],
45                     )
46                     ret = pip_state.installed("pep8=1.3.2")
47                     self.assertSaltFalseReturn({"test": ret})
48                     self.assertInSaltComment(
49                         "Invalid version specification in package pep8=1.3.2. "
50                         "'=' is not supported, use '==' instead.",
51                         {"test": ret},
52                     )
53             mock = MagicMock(return_value={"retcode": 0, "stdout": ""})
54             pip_list = MagicMock(return_value={"pep8": "1.3.3"})
55             pip_install = MagicMock(return_value={"retcode": 0})
56             with patch.dict(
57                 pip_state.__salt__,
58                 {"cmd.run_all": mock, "pip.list": pip_list, "pip.install": pip_install},
59             ):
60                 with patch.dict(pip_state.__opts__, {"test": True}):
61                     ret = pip_state.installed("pep8&gt;=1.3.2")
62                     self.assertSaltTrueReturn({"test": ret})
63                     self.assertInSaltComment(
64                         "Python package pep8&gt;=1.3.2 was already installed",
65                         {"test": ret},
66                     )
67             mock = MagicMock(return_value={"retcode": 0, "stdout": ""})
68             pip_list = MagicMock(return_value={"pep8": "1.3.3"})
69             with patch.dict(
70                 pip_state.__salt__, {"cmd.run_all": mock, "pip.list": pip_list}
71             ):
72                 with patch.dict(pip_state.__opts__, {"test": True}):
73                     ret = pip_state.installed("pep8&lt;1.3.2")
74                     self.assertSaltNoneReturn({"test": ret})
75                     self.assertInSaltComment(
76                         "Python package pep8&lt;1.3.2 is set to be installed",
77                         {"test": ret},
78                     )
79             mock = MagicMock(return_value={"retcode": 0, "stdout": ""})
80             pip_list = MagicMock(return_value={"pep8": "1.3.2"})
81             pip_install = MagicMock(return_value={"retcode": 0})
82             with patch.dict(
83                 pip_state.__salt__,
84                 {"cmd.run_all": mock, "pip.list": pip_list, "pip.install": pip_install},
85             ):
86                 with patch.dict(pip_state.__opts__, {"test": True}):
87                     ret = pip_state.installed("pep8&gt;1.3.1,&lt;1.3.3")
88                     self.assertSaltTrueReturn({"test": ret})
89                     self.assertInSaltComment(
90                         "Python package pep8&gt;1.3.1,&lt;1.3.3 was already installed",
91                         {"test": ret},
92                     )
93             mock = MagicMock(return_value={"retcode": 0, "stdout": ""})
94             pip_list = MagicMock(return_value={"pep8": "1.3.1"})
95             pip_install = MagicMock(return_value={"retcode": 0})
96             with patch.dict(
97                 pip_state.__salt__,
98                 {"cmd.run_all": mock, "pip.list": pip_list, "pip.install": pip_install},
99             ):
100                 with patch.dict(pip_state.__opts__, {"test": True}):
101                     ret = pip_state.installed("pep8&gt;1.3.1,&lt;1.3.3")
102                     self.assertSaltNoneReturn({"test": ret})
103                     self.assertInSaltComment(
104                         "Python package pep8&gt;1.3.1,&lt;1.3.3 is set to be installed",
105                         {"test": ret},
106                     )
107             mock = MagicMock(return_value={"retcode": 0, "stdout": ""})
108             pip_list = MagicMock(return_value={"pep8": "1.3.1"})
109             with patch.dict(
110                 pip_state.__salt__, {"cmd.run_all": mock, "pip.list": pip_list}
111             ):
112                 with patch.dict(pip_state.__opts__, {"test": True}):
113                     ret = pip_state.installed(
114                         "git+https://github.com/saltstack/salt-testing.git#egg=SaltTesting&gt;=0.5.1"
115                     )
116                     self.assertSaltNoneReturn({"test": ret})
117                     self.assertInSaltComment(
118                         "Python package git+https://github.com/saltstack/"
119                         "salt-testing.git#egg=SaltTesting&gt;=0.5.1 is set to be "
120                         "installed",
121                         {"test": ret},
122                     )
123             mock = MagicMock(return_value={"retcode": 0, "stdout": ""})
124             pip_list = MagicMock(return_value={"pep8": "1.3.1"})
125             with patch.dict(
126                 pip_state.__salt__, {"cmd.run_all": mock, "pip.list": pip_list}
127             ):
128                 with patch.dict(pip_state.__opts__, {"test": True}):
129                     ret = pip_state.installed(
130                         "git+https://github.com/saltstack/salt-testing.git#egg=SaltTesting"
131                     )
132                     self.assertSaltNoneReturn({"test": ret})
133                     self.assertInSaltComment(
134                         "Python package git+https://github.com/saltstack/"
135                         "salt-testing.git#egg=SaltTesting is set to be "
136                         "installed",
137                         {"test": ret},
138                     )
139             mock = MagicMock(return_value={"retcode": 0, "stdout": ""})
140             pip_list = MagicMock(return_value={"pep8": "1.3.1"})
141             with patch.dict(
142                 pip_state.__salt__, {"cmd.run_all": mock, "pip.list": pip_list}
143             ):
144                 with patch.dict(pip_state.__opts__, {"test": True}):
145                     ret = pip_state.installed(
146                         "https://pypi.python.org/packages/source/S/SaltTesting/"
147                         "SaltTesting-0.5.0.tar.gz"
148                         "#md5=e6760af92b7165f8be53b5763e40bc24"
149                     )
150                     self.assertSaltNoneReturn({"test": ret})
151                     self.assertInSaltComment(
152                         "Python package https://pypi.python.org/packages/source/"
153                         "S/SaltTesting/SaltTesting-0.5.0.tar.gz"
154                         "#md5=e6760af92b7165f8be53b5763e40bc24 is set to be "
155                         "installed",
156                         {"test": ret},
157                     )
158             mock = MagicMock(return_value={"retcode": 0, "stdout": ""})
159             pip_list = MagicMock(return_value={"SaltTesting": "0.5.0"})
160             pip_install = MagicMock(
161                 return_value={
162                     "retcode": 0,
163                     "stderr": "",
164                     "stdout": (
165                         "Downloading/unpacking https://pypi.python.org/packages"
166                         "/source/S/SaltTesting/SaltTesting-0.5.0.tar.gz\n  "
167                         "Downloading SaltTesting-0.5.0.tar.gz\n  Running "
168                         "setup.py egg_info for package from "
169                         "https://pypi.python.org/packages/source/S/SaltTesting/"
170                         "SaltTesting-0.5.0.tar.gz\n    \nCleaning up..."
171                     ),
172                 }
173             )
174             with patch.dict(
175                 pip_state.__salt__,
176                 {"cmd.run_all": mock, "pip.list": pip_list, "pip.install": pip_install},
177             ):
178                 ret = pip_state.installed(
179                     "https://pypi.python.org/packages/source/S/SaltTesting/"
180                     "SaltTesting-0.5.0.tar.gz"
181                     "#md5=e6760af92b7165f8be53b5763e40bc24"
182                 )
183                 self.assertSaltTrueReturn({"test": ret})
184                 self.assertInSaltComment(
185                     "All packages were successfully installed", {"test": ret}
186                 )
187                 self.assertInSaltReturn(
188                     "Installed",
189                     {"test": ret},
190                     (
191                         "changes",
192                         "https://pypi.python.org/packages/source/S/"
193                         "SaltTesting/SaltTesting-0.5.0.tar.gz"
194                         "#md5=e6760af92b7165f8be53b5763e40bc24==???",
195                     ),
196                 )
197             mock = MagicMock(return_value={"retcode": 0, "stdout": ""})
198             pip_list = MagicMock(return_value={"SaltTesting": "0.5.0"})
199             pip_install = MagicMock(
200                 return_value={"retcode": 0, "stderr": "", "stdout": "Cloned!"}
201             )
202             with patch.dict(
203                 pip_state.__salt__,
204                 {"cmd.run_all": mock, "pip.list": pip_list, "pip.install": pip_install},
205             ):
206                 with patch.dict(pip_state.__opts__, {"test": False}):
207                     ret = pip_state.installed(
208                         "git+https://github.com/saltstack/salt-testing.git#egg=SaltTesting"
209                     )
210                     self.assertSaltTrueReturn({"test": ret})
211                     self.assertInSaltComment(
212                         "packages are already installed", {"test": ret}
213                     )
214             mock = MagicMock(return_value={"retcode": 0, "stdout": ""})
215             pip_list = MagicMock(return_value={"pep8": "1.3.1"})
216             pip_install = MagicMock(return_value={"retcode": 0})
217             with patch.dict(
218                 pip_state.__salt__,
219                 {"cmd.run_all": mock, "pip.list": pip_list, "pip.install": pip_install},
220             ):
221                 with patch.dict(pip_state.__opts__, {"test": False}):
222                     ret = pip_state.installed(
223                         "arbitrary ID that should be ignored due to requirements"
224                         " specified",
225                         requirements="/tmp/non-existing-requirements.txt",
226                     )
227                     self.assertSaltTrueReturn({"test": ret})
228             mock = MagicMock(return_value={"retcode": 0, "stdout": ""})
229             pip_list = MagicMock(return_value={"SaltTesting": "0.5.0"})
230             pip_install = MagicMock(
231                 return_value={"retcode": 0, "stderr": "", "stdout": "Cloned!"}
232             )
233             with patch.dict(
234                 pip_state.__salt__,
235                 {"cmd.run_all": mock, "pip.list": pip_list, "pip.install": pip_install},
236             ):
237                 with patch.dict(pip_state.__opts__, {"test": False}):
238                     ret = pip_state.installed(
239                         "git+git://github.com/saltstack/salt-testing.git#egg=SaltTesting"
240                     )
241                     self.assertSaltTrueReturn({"test": ret})
242                     self.assertInSaltComment(
243                         "packages are already installed", {"test": ret}
244                     )
245     def test_install_requirements_custom_pypi(self):
246         req_filename = os.path.join(
247             RUNTIME_VARS.TMP_STATE_TREE, "custom-pypi-requirements.txt"
248         )
249         with salt.utils.files.fopen(req_filename, "wb") as reqf:
250             reqf.write(b"pep8\n")
251         site_pkgs = "/tmp/pip-env/lib/python3.7/site-packages"
252         check_stdout = [
253             "Looking in indexes: https://custom-pypi-url.org,"
254             "https://pypi.org/simple/\nRequirement already satisfied: pep8 in {1}"
255             "(from -r /tmp/files/prod/{0} (line 1)) (1.7.1)".format(
256                 req_filename, site_pkgs
257             ),
258             "Requirement already satisfied: pep8 in {1}"
259             "(from -r /tmp/files/prod/{0} (line1)) (1.7.1)".format(
260                 req_filename, site_pkgs
261             ),
262         ]
263         pip_version = pip.__version__
264         mock_pip_version = MagicMock(return_value=pip_version)
265         for stdout in check_stdout:
266             pip_install = MagicMock(return_value={"retcode": 0, "stdout": stdout})
267             with patch.dict(pip_state.__salt__, {"pip.version": mock_pip_version}):
268                 with patch.dict(pip_state.__salt__, {"pip.install": pip_install}):
269                     ret = pip_state.installed(name="", requirements=req_filename)
270                     self.assertSaltTrueReturn({"test": ret})
271                     assert "Requirements were already installed." == ret["comment"]
272     def test_install_requirements_custom_pypi_changes(self):
273         req_filename = os.path.join(
274             RUNTIME_VARS.TMP_STATE_TREE, "custom-pypi-requirements.txt"
275         )
276         with salt.utils.files.fopen(req_filename, "wb") as reqf:
277             reqf.write(b"pep8\n")
278         site_pkgs = "/tmp/pip-env/lib/python3.7/site-packages"
279         check_stdout = [
280             "Looking in indexes:"
281             " https://custom-pypi-url.org,https://pypi.org/simple/\nCollecting pep8\n "
282             " Using"
283             " cachedhttps://custom-pypi-url.org//packages/42/3f/669429cef5acb4/pep8-1.7.1-py2.py3-none-any.whl"
284             " (41 kB)\nInstalling collected packages: pep8\nSuccessfully installed"
285             " pep8-1.7.1",
286             "Collecting pep8\n  Using"
287             " cachedhttps://custom-pypi-url.org//packages/42/3f/669429cef5acb4/pep8-1.7.1-py2.py3-none-any.whl"
288             " (41 kB)\nInstalling collected packages: pep8\nSuccessfully installed"
289             " pep8-1.7.1",
290         ]
291         pip_version = pip.__version__
292         mock_pip_version = MagicMock(return_value=pip_version)
293         for stdout in check_stdout:
294             pip_install = MagicMock(return_value={"retcode": 0, "stdout": stdout})
295             with patch.dict(pip_state.__salt__, {"pip.version": mock_pip_version}):
296                 with patch.dict(pip_state.__salt__, {"pip.install": pip_install}):
297                     ret = pip_state.installed(name="", requirements=req_filename)
298                     self.assertSaltTrueReturn({"test": ret})
299                     assert (
300                         "Successfully processed requirements file {}.".format(
301                             req_filename
302                         )
303                         == ret["comment"]
304                     )
305     def test_install_in_editable_mode(self):
306         mock = MagicMock(return_value={"retcode": 0, "stdout": ""})
307         pip_list = MagicMock(return_value={})
308         pip_install = MagicMock(
309             return_value={"retcode": 0, "stderr": "", "stdout": "Cloned!"}
310         )
311         pip_version = MagicMock(return_value="10.0.1")
312         with patch.dict(
313             pip_state.__salt__,
314             {
315                 "cmd.run_all": mock,
316                 "pip.list": pip_list,
317                 "pip.install": pip_install,
318                 "pip.version": pip_version,
319             },
320         ):
321             ret = pip_state.installed(
322                 "state@name", cwd="/path/to/project", editable=["."]
323             )
324             self.assertSaltTrueReturn({"test": ret})
325             self.assertInSaltComment("successfully installed", {"test": ret})
326 class PipStateUtilsTest(TestCase):
327     def test_has_internal_exceptions_mod_function(self):
328         assert pip_state.pip_has_internal_exceptions_mod("10.0")
329         assert pip_state.pip_has_internal_exceptions_mod("18.1")
330         assert not pip_state.pip_has_internal_exceptions_mod("9.99")
331     def test_has_exceptions_mod_function(self):
332         assert pip_state.pip_has_exceptions_mod("1.0")
333         assert not pip_state.pip_has_exceptions_mod("0.1")
334         assert not pip_state.pip_has_exceptions_mod("10.0")
335     def test_pip_purge_method_with_pip(self):
336         mock_modules = sys.modules.copy()
337         mock_modules.pop("pip", None)
338         mock_modules["pip"] = object()
339         with patch("sys.modules", mock_modules):
340             pip_state.purge_pip()
341         assert "pip" not in mock_modules
342     def test_pip_purge_method_without_pip(self):
343         mock_modules = sys.modules.copy()
344         mock_modules.pop("pip", None)
345         with patch("sys.modules", mock_modules):
346             pip_state.purge_pip()
347 @skipIf(
348     salt.utils.path.which_bin(KNOWN_BINARY_NAMES) is None, "virtualenv not installed"
349 )
350 @pytest.mark.requires_network
351 class PipStateInstallationErrorTest(TestCase):
352     @pytest.mark.slow_test
353     def test_importable_installation_error(self):
354         extra_requirements = []
355         for name, version in salt.version.dependency_information():
356             if name in ["PyYAML"]:
357                 extra_requirements.append("{}=={}".format(name, version))
358         failures = {}
359         pip_version_requirements = [
360             "&lt;19.0",
361             "&lt;20.0",
362             "&lt;21.0",
363             None,
364         ]
365         code = dedent(
366         )
367         for requirement in list(pip_version_requirements):
368             try:
369                 with VirtualEnv() as venv:
370                     venv.install(*extra_requirements)
371                     if requirement:
372                         venv.install("pip{}".format(requirement))
373                     try:
374                         subprocess.check_output([venv.venv_python, "-c", code])
375                     except subprocess.CalledProcessError as exc:
376                         if exc.returncode == 1:
377                             failures[requirement] = "Failed to import pip:\n{}".format(
378                                 exc.output
379                             )
380                         elif exc.returncode == 2:
381                             failures[
382                                 requirement
383                             ] = "Failed to import InstallationError from pip:\n{}".format(
384                                 exc.output
385                             )
386                         else:
387                             failures[requirement] = exc.output
388             except Exception as exc:  # pylint: disable=broad-except
389                 failures[requirement] = str(exc)
390         if failures:
391             errors = ""
392             for requirement, exception in failures.items():
393                 errors += "pip{}: {}\n\n".format(requirement or "", exception)
394             self.fail(
395                 "Failed to get InstallationError exception under at least one pip"
396                 " version:\n{}".format(errors)
397             )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
