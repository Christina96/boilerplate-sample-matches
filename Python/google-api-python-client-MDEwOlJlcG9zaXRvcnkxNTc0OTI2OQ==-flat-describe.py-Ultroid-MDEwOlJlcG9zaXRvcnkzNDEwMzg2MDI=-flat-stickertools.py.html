
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 10.028653295128938%, Tokens: 9</h2>
        <div class="column">
            <h3>google-api-python-client-MDEwOlJlcG9zaXRvcnkxNTc0OTI2OQ==-flat-describe.py</h3>
            <pre><code>1  #!/usr/bin/python
2  from __future__ import print_function
3  __author__ = "jcgregorio@google.com (Joe Gregorio)"
4  import argparse
5  import collections
6  import json
7  import pathlib
8  import re
9  import string
10  import sys
11  import uritemplate
12  from googleapiclient.discovery import DISCOVERY_URI, build_from_document
13  from googleapiclient.http import build_http
14  DISCOVERY_DOC_DIR = (
15      pathlib.Path(__file__).resolve().parent
16      / "googleapiclient"
17      / "discovery_cache"
18      / "documents"
19  )
20  CSS = 
21  METHOD_TEMPLATE = 
22  COLLECTION_LINK = 
23  METHOD_LINK = 
24  BASE = pathlib.Path(__file__).resolve().parent / "docs" / "dyn"
25  DIRECTORY_URI = "https://www.googleapis.com/discovery/v1/apis"
26  parser = argparse.ArgumentParser(description=__doc__)
27  parser.add_argument(
28      "--discovery_uri_template",
29      default=DISCOVERY_URI,
30      help="URI Template for discovery.",
31  )
32  parser.add_argument(
33      "--discovery_uri",
34      default="",
35      help=(
36          "URI of discovery document. If supplied then only "
37          "this API will be documented."
38      ),
39  )
40  parser.add_argument(
41      "--directory_uri",
42      default=DIRECTORY_URI,
43      help=("URI of directory document. Unused if --discovery_uri" " is supplied."),
44  )
45  parser.add_argument(
46      "--dest", default=BASE, help="Directory name to write documents into."
47  )
48  def safe_version(version):
49      return version.replace(".", "_")
50  def unsafe_version(version):
51      return version.replace("_", ".")
52  def method_params(doc):
53      doclines = doc.splitlines()
54      if "Args:" in doclines:
55          begin = doclines.index("Args:")
56          if "Returns:" in doclines[begin + 1 :]:
57              end = doclines.index("Returns:", begin)
58              args = doclines[begin + 1 : end]
59          else:
60              args = doclines[begin + 1 :]
61          parameters = []
62          sorted_parameters = []
63          pname = None
64          desc = ""
65          def add_param(pname, desc):
66              if pname is None:
67                  return
68              if "(required)" not in desc:
69                  pname = pname + "=None"
70                  parameters.append(pname)
71              else:
72                  sorted_parameters.append(pname)
73          for line in args:
74              m = re.search(r"^\s+([a-zA-Z0-9_]+): (.*)", line)
75              if m is None:
76                  desc += line
77                  continue
78              add_param(pname, desc)
79              pname = m.group(1)
80              desc = m.group(2)
81          add_param(pname, desc)
82          sorted_parameters.extend(sorted(parameters))
83          sorted_parameters = ", ".join(sorted_parameters)
84      else:
85          sorted_parameters = ""
86      return sorted_parameters
87  def method(name, doc):
88      import html
89      params = method_params(doc)
90      doc = html.escape(doc)
91      return string.Template(METHOD_TEMPLATE).substitute(
92          name=name, params=params, doc=doc
93      )
94  def breadcrumbs(path, root_discovery):
95      parts = path.split(".")
96      crumbs = []
97      accumulated = []
98      for i, p in enumerate(parts):
99          prefix = ".".join(accumulated)
100          if prefix:
101              prefix += "."
102          display = p
103          if i == 0:
104              display = root_discovery.get("title", display)
105          crumbs.append('<a href="{}.html">{}</a>'.format(prefix + p, display))
106          accumulated.append(p)
107      return " . ".join(crumbs)
108  def document_collection(resource, path, root_discovery, discovery, css=CSS):
109      collections = []
110      methods = []
111      resource_name = path.split(".")[-2]
112      html = [
113          "<html><body>",
114          css,
115          "<h1>%s</h1>" % breadcrumbs(path[:-1], root_discovery),
116          "<h2>Instance Methods</h2>",
117      ]
118      for name in dir(resource):
119          if not name.startswith("_") and callable(getattr(resource, name)):
120              if hasattr(getattr(resource, name), "__is_resource__"):
121                  collections.append(name)
122              else:
123                  methods.append(name)
124      if collections:
125          for name in collections:
126              if not name.startswith("_") and callable(getattr(resource, name)):
127                  href = path + name + ".html"
128                  html.append(
129                      string.Template(COLLECTION_LINK).substitute(href=href, name=name)
130                  )
131      if methods:
132          for name in methods:
133              if not name.startswith("_") and callable(getattr(resource, name)):
134                  doc = getattr(resource, name).__doc__
135                  params = method_params(doc)
136                  firstline = doc.splitlines()[0]
137                  html.append(
138                      string.Template(METHOD_LINK).substitute(
139                          name=name, params=params, firstline=firstline
140                      )
141                  )
142      if methods:
143          html.append("<h3>Method Details</h3>")
144          for name in methods:
145              dname = name.rsplit("_")[0]
146              html.append(method(name, getattr(resource, name).__doc__))
147      html.append("</body></html>")
148      return "\n".join(html)
149  def document_collection_recursive(
150      resource,
151      path,
152      root_discovery,
153      discovery,
154      doc_destination_dir,
155      artifact_destination_dir=DISCOVERY_DOC_DIR,
156  ):
157      html = document_collection(resource, path, root_discovery, discovery)
158      f = open(pathlib.Path(doc_destination_dir).joinpath(path + "html"), "w")
159      f.write(html)
160      f.close()
161      for name in dir(resource):
162          if (
163              not name.startswith("_")
164              and callable(getattr(resource, name))
165              and hasattr(getattr(resource, name), "__is_resource__")
166              and discovery != {}
167          ):
168              dname = name.rsplit("_")[0]
169              collection = getattr(resource, name)()
170              document_collection_recursive(
171                  collection,
172                  path + name + ".",
173                  root_discovery,
174                  discovery["resources"].get(dname, {}),
175                  doc_destination_dir,
176                  artifact_destination_dir,
177              )
178  def document_api(
179      name, version, uri, doc_destination_dir, artifact_destination_dir=DISCOVERY_DOC_DIR
180  ):
181      http = build_http()
182      resp, content = http.request(
183          uri
184          or uritemplate.expand(
185              FLAGS.discovery_uri_template, {"api": name, "apiVersion": version}
186          )
187      )
188      if resp.status == 200:
189          discovery = json.loads(content)
190          service = build_from_document(discovery)
<span onclick='openModal()' class='match'>191          doc_name = "{}.{}.json".format(name, version)
192          discovery_file_path = artifact_destination_dir / doc_name
193          revision = None
194          pathlib.Path(discovery_file_path).touch(exist_ok=True)
</span>195          with open(discovery_file_path, "r+") as f:
196              try:
197                  json_data = json.load(f)
198                  revision = json_data["revision"]
199              except json.JSONDecodeError:
200                  revision = None
201              if revision is None or discovery["revision"] >= revision:
202                  f.seek(0)
203                  json.dump(discovery, f, indent=2, sort_keys=True)
204                  f.truncate()
205      elif resp.status == 404:
206          print(
207              "Warning: {} {} not found. HTTP Code: {}".format(name, version, resp.status)
208          )
209          return
210      else:
211          print(
212              "Warning: {} {} could not be built. HTTP Code: {}".format(
213                  name, version, resp.status
214              )
215          )
216          return
217      document_collection_recursive(
218          service,
219          "{}_{}.".format(name, safe_version(version)),
220          discovery,
221          discovery,
222          doc_destination_dir,
223          artifact_destination_dir,
224      )
225  def document_api_from_discovery_document(
226      discovery_url, doc_destination_dir, artifact_destination_dir=DISCOVERY_DOC_DIR
227  ):
228      http = build_http()
229      response, content = http.request(discovery_url)
230      discovery = json.loads(content)
231      service = build_from_document(discovery)
232      name = discovery["version"]
233      version = safe_version(discovery["version"])
234      document_collection_recursive(
235          service,
236          "{}_{}.".format(name, version),
237          discovery,
238          discovery,
239          doc_destination_dir,
240          artifact_destination_dir,
241      )
242  def generate_all_api_documents(
243      directory_uri=DIRECTORY_URI,
244      doc_destination_dir=BASE,
245      artifact_destination_dir=DISCOVERY_DOC_DIR,
246  ):
247      api_directory = collections.defaultdict(list)
248      http = build_http()
249      resp, content = http.request(directory_uri)
250      if resp.status == 200:
251          directory = json.loads(content)["items"]
252          for api in directory:
253              document_api(
254                  api["name"],
255                  api["version"],
256                  api["discoveryRestUrl"],
257                  doc_destination_dir,
258                  artifact_destination_dir,
259              )
260              api_directory[api["name"]].append(api["version"])
261          for api in api_directory:
262              api_directory[api] = sorted(api_directory[api])
263          api_directory = collections.OrderedDict(
264              sorted(api_directory.items(), key=lambda x: x[0])
265          )
266          markdown = []
267          for api, versions in api_directory.items():
268              markdown.append("## %s" % api)
269              for version in versions:
270                  markdown.append(
271                      "* [%s](http://googleapis.github.io/google-api-python-client/docs/dyn/%s_%s.html)"
272                      % (version, api, safe_version(version))
273                  )
274              markdown.append("\n")
275          with open(doc_destination_dir / "index.md", "w") as f:
276              markdown = "\n".join(markdown)
277              f.write(markdown)
278      else:
279          sys.exit("Failed to load the discovery document.")
280  if __name__ == "__main__":
281      FLAGS = parser.parse_args(sys.argv[1:])
282      if FLAGS.discovery_uri:
283          document_api_from_discovery_document(
284              discovery_url=FLAGS.discovery_uri,
285              doc_destination_dir=FLAGS.dest,
286          )
287      else:
288          generate_all_api_documents(
289              directory_uri=FLAGS.directory_uri,
290              doc_destination_dir=FLAGS.dest,
291          )
</code></pre>
        </div>
        <div class="column">
            <h3>Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-stickertools.py</h3>
            <pre><code>1  import glob
2  import io
3  import os
4  import random
5  from os import remove
6  try:
7      import cv2
8  except ImportError:
9      cv2 = None
10  try:
11      import numpy as np
12  except ImportError:
13      np = None
14  try:
15      from PIL import Image, ImageDraw
16  except ImportError:
17      pass
18  from telethon.errors import PeerIdInvalidError, YouBlockedUserError
19  from telethon.tl.functions.messages import UploadMediaRequest
20  from telethon.tl.types import (
21      DocumentAttributeFilename,
22      DocumentAttributeSticker,
23      InputPeerSelf,
24  )
25  from telethon.utils import get_input_document
26  from . import (
27      KANGING_STR,
28      LOGS,
29      asst,
30      async_searcher,
31      bash,
32      con,
33      functions,
34      get_string,
35      inline_mention,
36      mediainfo,
37      quotly,
38      types,
39      udB,
40      ultroid_cmd,
41  )
42  @ultroid_cmd(pattern="packkang")
43  async def pack_kangish(_):
44      _e = await _.get_reply_message()
45      local = None
46      try:
47          cmdtext = _.text.split(maxsplit=1)[1]
48      except IndexError:
49          cmdtext = None
50      if cmdtext and os.path.isdir(cmdtext):
51          local = True
52      elif not (_e and _e.sticker and _e.file.mime_type == "image/webp"):
53          return await _.eor(get_string("sts_4"))
54      msg = await _.eor(get_string("com_1"))
55      _packname = cmdtext or f"Ultroid Kang Pack By {_.sender_id}"
56      typee = None
57      if not local:
58          _id = _e.media.document.attributes[1].stickerset.id
59          _hash = _e.media.document.attributes[1].stickerset.access_hash
60          _get_stiks = await _.client(
61              functions.messages.GetStickerSetRequest(
62                  stickerset=types.InputStickerSetID(id=_id, access_hash=_hash), hash=0
63              )
64          )
65          docs = _get_stiks.documents
66      else:
67          docs = []
68          exte = files[-1]
69          if exte.endswith(".tgs"):
70              typee = "anim"
71          elif exte.endswith(".webm"):
72              typee = "vid"
73          count = 0
74          for file in files:
75              if file.endswith((".tgs", ".webm")):
76                  count += 1
77                  upl = await asst.upload_file(file)
78                  docs.append(await asst(UploadMediaRequest(InputPeerSelf(), upl)))
79                  if count % 5 == 0:
80                      await msg.edit(f"`Uploaded {count} files.`")
81      stiks = []
82      for i in docs:
83          x = get_input_document(i)
84          stiks.append(
85              types.InputStickerSetItem(
86                  document=x,
87                  emoji=random.choice(["😐", "👍", "😂"])
88                  if local
89                  else (i.attributes[1]).alt,
90              )
91          )
92      try:
93          short_name = "ult_" + _packname.replace(" ", "_") + str(_.id)
94          _r_e_s = await asst(
95              functions.stickers.CreateStickerSetRequest(
96                  user_id=_.sender_id,
97                  title=_packname,
98                  short_name=f"{short_name}_by_{asst.me.username}",
99                  animated=typee == "anim",
100                  videos=typee == "vid",
101                  stickers=stiks,
102              )
103          )
104      except PeerIdInvalidError:
105          return await msg.eor(
106              f"Hey {inline_mention(_.sender)} send `/start` to @{asst.me.username} and later try this command again.."
107          )
108      except BaseException as er:
109          LOGS.exception(er)
110          return await msg.eor(str(er))
111      await msg.eor(
112          get_string("sts_5").format(f"https://t.me/addstickers/{_r_e_s.set.short_name}"),
113      )
114  @ultroid_cmd(
115      pattern="kang",
116  )
117  async def hehe(args):
118      ultroid_bot = args.client
119      xx = await args.eor(get_string("com_1"))
120      user = ultroid_bot.me
121      username = user.username
122      username = f"@{username}" if username else user.first_name
123      message = await args.get_reply_message()
124      photo = None
125      is_anim, is_vid = False, False
126      emoji = None
127      if not message:
128          return await xx.eor(get_string("sts_6"))
129      if message.photo:
130          photo = io.BytesIO()
131          photo = await ultroid_bot.download_media(message.photo, photo)
132      elif message.file and "image" in message.file.mime_type.split("/"):
133          photo = io.BytesIO()
134          await ultroid_bot.download_file(message.media.document, photo)
135          if (
136              DocumentAttributeFilename(file_name="sticker.webp")
137              in message.media.document.attributes
138          ):
139              emoji = message.media.document.attributes[1].alt
140      elif message.file and "video" in message.file.mime_type.split("/"):
141          xy = await message.download_media()
142          if (message.file.duration or 0) <= 10:
143              is_vid = True
144              photo = await con.create_webm(xy)
145          else:
146              y = cv2.VideoCapture(xy)
147              heh, lol = y.read()
148              cv2.imwrite("ult.webp", lol)
149              photo = "ult.webp"
150      elif message.file and "tgsticker" in message.file.mime_type:
151          await ultroid_bot.download_file(
152              message.media.document,
153              "AnimatedSticker.tgs",
154          )
155          attributes = message.media.document.attributes
156          for attribute in attributes:
157              if isinstance(attribute, DocumentAttributeSticker):
158                  emoji = attribute.alt
159          is_anim = True
160          photo = 1
161      elif message.message:
162          photo = await quotly.create_quotly(message)
163      else:
164          return await xx.edit(get_string("com_4"))
165      if not udB.get_key("language") or udB.get_key("language") == "en":
166          ra = random.choice(KANGING_STR)
167      else:
168          ra = get_string("sts_11")
169      await xx.edit(f"`{ra}`")
170      if photo:
171          splat = args.text.split()
172          pack = 1
173          if not emoji:
174              emoji = "🏵"
175          if len(splat) == 3:
176              pack = splat[2]  # User sent ultroid_both
177              emoji = splat[1]
178          elif len(splat) == 2:
179              if splat[1].isnumeric():
180                  pack = int(splat[1])
181              else:
182                  emoji = splat[1]
183          packname = f"ult_{user.id}_{pack}"
184          packnick = f"{username}'s Pack {pack}"
185          cmd = "/newpack"
186          file = io.BytesIO()
187          if is_vid:
188              packname += "_vid"
189              packnick += " (Video)"
190              cmd = "/newvideo"
191          elif is_anim:
192              packname += "_anim"
193              packnick += " (Animated)"
194              cmd = "/newanimated"
195          else:
196              image = con.resize_photo_sticker(photo)
197              file.name = "sticker.png"
198              image.save(file, "PNG")
199          response = await async_searcher(f"http://t.me/addstickers/{packname}")
200          htmlstr = response.split("\n")
201          if (
202              "  A <strong>Telegram</strong> user has created the <strong>Sticker&nbsp;Set</strong>."
203              not in htmlstr
204          ):
205              async with ultroid_bot.conversation("@Stickers") as conv:
206                  try:
207                      await conv.send_message("/addsticker")
208                  except YouBlockedUserError:
209                      LOGS.info("Unblocking @Stickers for kang...")
210                      await ultroid_bot(functions.contacts.UnblockRequest("stickers"))
211                      await conv.send_message("/addsticker")
212                  await conv.get_response()
213                  await conv.send_message(packname)
214                  x = await conv.get_response()
215                  if x.text.startswith("Alright! Now send me the video sticker."):
216                      await conv.send_file(photo, force_document=True)
217                      x = await conv.get_response()
218                  t = "50" if (is_anim or is_vid) else "120"
219                  while t in x.message:
220                      pack += 1
221                      packname = f"ult_{user.id}_{pack}"
222                      packnick = f"{username}'s Pack {pack}"
223                      if is_anim:
224                          packname += "_anim"
225                          packnick += " (Animated)"
226                      elif is_vid:
227                          packnick += " (Video)"
228                          packname += "_vid"
229                      await xx.edit(get_string("sts_13").format(pack))
230                      await conv.send_message("/addsticker")
231                      await conv.get_response()
232                      await conv.send_message(packname)
233                      x = await conv.get_response()
234                      if x.text.startswith("Alright! Now send me the video sticker."):
235                          await conv.send_file(photo, force_document=True)
236                          x = await conv.get_response()
237                      if x.text in ["Invalid pack selected.", "Invalid set selected."]:
238                          await conv.send_message(cmd)
239                          await conv.get_response()
240                          await conv.send_message(packnick)
241                          await conv.get_response()
242                          if is_anim:
243                              await conv.send_file("AnimatedSticker.tgs")
244                              remove("AnimatedSticker.tgs")
245                          else:
246                              if is_vid:
247                                  file = photo
248                              else:
249                                  file.seek(0)
250                              await conv.send_file(file, force_document=True)
251                          await conv.get_response()
252                          await conv.send_message(emoji)
253                          await conv.get_response()
254                          await conv.send_message("/publish")
255                          if is_anim:
256                              await conv.get_response()
257                              await conv.send_message(f"<{packnick}>")
258                          await conv.get_response()
259                          await conv.send_message("/skip")
260                          await conv.get_response()
261                          await conv.send_message(packname)
262                          await conv.get_response()
263                          await xx.edit(
264                              get_string("sts_7").format(packname),
265                              parse_mode="md",
266                          )
267                          return
268                  if is_anim:
269                      await conv.send_file("AnimatedSticker.tgs")
270                      remove("AnimatedSticker.tgs")
271                  elif "send me an emoji" not in x.message:
272                      if is_vid:
273                          file = photo
274                      else:
275                          file.seek(0)
276                      await conv.send_file(file, force_document=True)
277                      rsp = await conv.get_response()
278                      if "Sorry, the file type is invalid." in rsp.text:
279                          await xx.edit(
280                              get_string("sts_8"),
281                          )
282                          return
283                  await conv.send_message(emoji)
284                  await conv.get_response()
285                  await conv.send_message("/done")
286                  await conv.get_response()
287                  await ultroid_bot.send_read_acknowledge(conv.chat_id)
288          else:
289              await xx.edit("`Brewing a new Pack...`")
290              async with ultroid_bot.conversation("Stickers") as conv:
291                  await conv.send_message(cmd)
292                  await conv.get_response()
293                  await conv.send_message(packnick)
294                  await conv.get_response()
295                  if is_anim:
296                      await conv.send_file("AnimatedSticker.tgs")
297                      remove("AnimatedSticker.tgs")
298                  else:
299                      if is_vid:
300                          file = photo
301                      else:
302                          file.seek(0)
303                      await conv.send_file(file, force_document=True)
304                  rsp = await conv.get_response()
305                  if "Sorry, the file type is invalid." in rsp.text:
306                      await xx.edit(
307                          get_string("sts_8"),
308                      )
309                      return
310                  await conv.send_message(emoji)
311                  await conv.get_response()
312                  await conv.send_message("/publish")
313                  if is_anim:
314                      await conv.get_response()
315                      await conv.send_message(f"<{packnick}>")
316                  await conv.get_response()
317                  await conv.send_message("/skip")
318                  await conv.get_response()
319                  await conv.send_message(packname)
320                  await conv.get_response()
321                  await ultroid_bot.send_read_acknowledge(conv.chat_id)
322          await xx.edit(
323              get_string("sts_12").format(emoji, packname),
324              parse_mode="md",
325          )
326          try:
327              os.remove(photo)
328          except BaseException:
329              pass
330  @ultroid_cmd(
331      pattern="round$",
332  )
333  async def ultdround(event):
334      ureply = await event.get_reply_message()
335      xx = await event.eor(get_string("com_1"))
336      if not (ureply and (ureply.media)):
337          await xx.edit(get_string("sts_10"))
338          return
339      ultt = await ureply.download_media()
340      file = await con.convert(
341          ultt,
342          convert_to="png",
343          allowed_formats=["jpg", "jpeg", "png"],
344          outname="round",
345          remove_old=True,
346      )
347      img = Image.open(file).convert("RGB")
348      npImage = np.array(img)
349      h, w = img.size
350      alpha = Image.new("L", img.size, 0)
351      draw = ImageDraw.Draw(alpha)
352      draw.pieslice([0, 0, h, w], 0, 360, fill=255)
353      npAlpha = np.array(alpha)
354      npImage = np.dstack((npImage, npAlpha))
355      Image.fromarray(npImage).save("ult.webp")
356      await event.client.send_file(
357          event.chat_id,
358          "ult.webp",
359          force_document=False,
360          reply_to=event.reply_to_msg_id,
361      )
362      await xx.delete()
363      os.remove(file)
364      os.remove("ult.webp")
365  @ultroid_cmd(
366      pattern="destroy$",
367  )
368  async def ultdestroy(event):
369      ult = await event.get_reply_message()
370      if not (ult and ult.media and "animated" in mediainfo(ult.media)):
371          return await event.eor(get_string("sts_2"))
372      await event.client.download_media(ult, "ultroid.tgs")
373      xx = await event.eor(get_string("com_1"))
374      await bash("lottie_convert.py ultroid.tgs json.json")
375      with open("json.json") as json:
376          jsn = json.read()
377      jsn = (
378          jsn.replace("[100]", "[200]")
379          .replace("[10]", "[40]")
380          .replace("[-1]", "[-10]")
381          .replace("[0]", "[15]")
382          .replace("[1]", "[20]")
383          .replace("[2]", "[17]")
384          .replace("[3]", "[40]")
385          .replace("[4]", "[37]")
386          .replace("[5]", "[60]")
387          .replace("[6]", "[70]")
388          .replace("[7]", "[40]")
389          .replace("[8]", "[37]")
390          .replace("[9]", "[110]")
391      )
392      open("json.json", "w").write(jsn)
393      file = await con.animated_sticker("json.json", "ultroid.tgs")
394      if file:
395          await event.client.send_file(
396              event.chat_id,
397              file="ultroid.tgs",
398              force_document=False,
399              reply_to=event.reply_to_msg_id,
400          )
401      await xx.delete()
402      os.remove("json.json")
403  @ultroid_cmd(
404      pattern="tiny$",
405  )
406  async def ultiny(event):
407      reply = await event.get_reply_message()
408      if not (reply and (reply.media)):
409          await event.eor(get_string("sts_10"))
410          return
411      xx = await event.eor(get_string("com_1"))
412      ik = await reply.download_media()
413      im1 = Image.open("resources/extras/ultroid_blank.png")
414      if ik.endswith(".tgs"):
415          await con.animated_sticker(ik, "json.json")
416          with open("json.json") as json:
417              jsn = json.read()
418          jsn = jsn.replace("512", "2000")
419          open("json.json", "w").write(jsn)
420          await con.animated_sticker("json.json", "ult.tgs")
421          file = "ult.tgs"
422          os.remove("json.json")
423      elif ik.endswith((".gif", ".webm", ".mp4")):
424          iik = cv2.VideoCapture(ik)
425          dani, busy = iik.read()
426          cv2.imwrite("i.png", busy)
427          fil = "i.png"
428          im = Image.open(fil)
429          z, d = im.size
430          if z == d:
431              xxx, yyy = 200, 200
432          else:
433              t = z + d
434              a = z / t
435              b = d / t
436              aa = (a * 100) - 50
437              bb = (b * 100) - 50
438              xxx = 200 + 5 * aa
439              yyy = 200 + 5 * bb
440          k = im.resize((int(xxx), int(yyy)))
441          k.save("k.png", format="PNG", optimize=True)
442          im2 = Image.open("k.png")
443          back_im = im1.copy()
444          back_im.paste(im2, (150, 0))
<span onclick='openModal()' class='match'>445          back_im.save("o.webp", "WEBP", quality=95)
446          file = "o.webp"
447          os.remove(fil)
448          os.remove("k.png")
449      else:
450          im = Image.open(ik)
</span>451          z, d = im.size
452          if z == d:
453              xxx, yyy = 200, 200
454          else:
455              t = z + d
456              a = z / t
457              b = d / t
458              aa = (a * 100) - 50
459              bb = (b * 100) - 50
460              xxx = 200 + 5 * aa
461              yyy = 200 + 5 * bb
462          k = im.resize((int(xxx), int(yyy)))
463          k.save("k.png", format="PNG", optimize=True)
464          im2 = Image.open("k.png")
465          back_im = im1.copy()
466          back_im.paste(im2, (150, 0))
467          back_im.save("o.webp", "WEBP", quality=95)
468          file = "o.webp"
469          os.remove("k.png")
470      if os.path.exists(file):
471          await event.client.send_file(
472              event.chat_id, file, reply_to=event.reply_to_msg_id
473          )
474          os.remove(file)
475      await xx.delete()
476      os.remove(ik)
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from google-api-python-client-MDEwOlJlcG9zaXRvcnkxNTc0OTI2OQ==-flat-describe.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-stickertools.py</div>
                </div>
                <div class="column column_space"><pre><code>191          doc_name = "{}.{}.json".format(name, version)
192          discovery_file_path = artifact_destination_dir / doc_name
193          revision = None
194          pathlib.Path(discovery_file_path).touch(exist_ok=True)
</pre></code></div>
                <div class="column column_space"><pre><code>445          back_im.save("o.webp", "WEBP", quality=95)
446          file = "o.webp"
447          os.remove(fil)
448          os.remove("k.png")
449      else:
450          im = Image.open(ik)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    