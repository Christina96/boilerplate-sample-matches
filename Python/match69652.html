<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_service_3.py &amp; test_mount.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_service_3.py &amp; test_mount.py
      </h3>
<h1 align="center">
        4.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_service_3.py (6.56682%)<th>test_mount.py (3.4905083%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(421-432)<td><a href="#" name="0">(785-788)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(398-409)<td><a href="#" name="1">(766-769)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(548-557)<td><a href="#" name="2">(105-109)</a><td align="center"><font color="#ee0000">14</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(186-191)<td><a href="#" name="3">(693-695)</a><td align="center"><font color="#dd0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_service_3.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
    :codeauthor: Gareth J. Greenaway &lt;ggreenaway@vmware.com&gt;
"""
import logging
import pytest
import salt.modules.beacons as beaconmod
import salt.states.beacon as beaconstate
import salt.states.service as service
import salt.utils.platform
from salt.utils.event import SaltEvent
from tests.support.mock import MagicMock, patch
log = logging.getLogger(__name__)
def func(name):
    """
    Mock func method
    """
    return name
@pytest.fixture
def configure_loader_modules():
    return {
        service: {
            "__env__": "base",
            "__salt__": {},
            "__opts__": {"test": False, "cachedir": ""},
            "__instance_id__": "",
            "__low__": {},
            "__utils__": {},
            "__context__": {},
        },
        beaconstate: {"__salt__": {}, "__opts__": {}},
        beaconmod: {"__salt__": {}, "__opts__": {}},
    }
def test_get_systemd_only():
    """
    Test the _get_system_only function
    """
    def test_func(cats, dogs, no_block):
        pass
    with patch.object(service._get_systemd_only, "HAS_SYSTEMD", True, create=True):
        ret, warnings = service._get_systemd_only(
            test_func, {"cats": 1, "no_block": 2, "unmask": 3}
        )
        assert len(warnings) == 0
        assert ret == {"no_block": 2}
        ret, warnings = service._get_systemd_only(test_func, {"cats": 1, "unmask": 3})
        assert len(warnings) == 0
        assert ret == {}
def test_get_systemd_only_platform():
    """
    Test the _get_system_only function on unsupported platforms
    """
    def test_func(cats, dogs, no_block):
        pass
    with patch.object(service._get_systemd_only, "HAS_SYSTEMD", False, create=True):
        ret, warnings = service._get_systemd_only(
            test_func, {"cats": 1, "no_block": 2, "unmask": 3}
        )
        assert warnings == ["The 'no_block' argument is not supported by this platform"]
        assert ret == {}
        ret, warnings = service._get_systemd_only(test_func, {"cats": 1, "unmask": 3})
        assert len(warnings) == 0
        assert ret == {}
def test_get_systemd_only_no_mock():
    """
    Test the _get_system_only without mocking
    """
    def test_func(cats, dogs, no_block):
        pass
    ret, warnings = service._get_systemd_only(
        test_func, {"cats": 1, "no_block": 2, "unmask": 3}
    )
    assert isinstance(ret, dict)
    assert isinstance(warnings, list)
def test_running():
    """
    Test to verify that the service is running
    """
    ret = [
        {"comment": "", "changes": {}, "name": "salt", "result": True},
        {
            "changes": {},
            "comment": "The service salt is already running",
            "name": "salt",
            "result": True,
        },
        {
            "changes": "saltstack",
            "comment": "The service salt is already running",
            "name": "salt",
            "result": True,
        },
        {
            "changes": {},
            "comment": "Service salt is set to start",
            "name": "salt",
            "result": None,
        },
        {
            "changes": "saltstack",
            "comment": "Started service salt",
            "name": "salt",
            "result": True,
        },
        {
            "changes": {},
            "comment": "The service salt is already running",
            "name": "salt",
            "result": True,
        },
        {
            "changes": "saltstack",
            "comment": "Service salt failed to start",
            "name": "salt",
            "result": False,
        },
        {
            "changes": "saltstack",
            "comment": (
                "Started service salt\nService masking not available on this minion"
            ),
            "name": "salt",
            "result": True,
        },
        {
            "changes": "saltstack",
            "comment": (
                "Started service salt\nService masking not available on this minion"
            ),
            "name": "salt",
            "result": True,
        },
        {
            "changes": {},
            "comment": (
                "The service salt is disabled but enable is not True. Set enable to"
                " True to successfully start the service."
            ),
            "name": "salt",
            "result": False,
        },
        {
            "changes": {},
            "comment": "The service salt is set to restart",
            "name": "salt",
            "result": None,
        },
    ]
    tmock = MagicMock(return_value=True)
    fmock = MagicMock(return_value=False)
    vmock = MagicMock(return_value="salt")
    with patch.object(service, "_enabled_used_error", vmock):
        assert service.running("salt", enabled=1) == "salt"
    with patch.object(service, "_available", fmock):
    with patch.object(service, "_available", tmock):
        <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>with patch.dict(service.__opts__, {"test": False}):
            with patch.dict(
                service.__salt__,
                {"service.enabled": tmock, "service.status": tmock},
            ):
                assert service.running(</b></font>"salt") == ret[1]
            mock = MagicMock(return_value={"changes": "saltstack"})
            with patch.dict(
                service.__salt__,
                {
                    "service.enabled": MagicMock(side_effect=[False, True]),
                    "service.status": tmock,
                },
            ):
                with patch.object(service, "_enable", mock):
                    assert service.running("salt", True) == ret[2]
            with patch.dict(
                service.__salt__,
                {
                    "service.enabled": MagicMock(side_effect=[True, False]),
                    "service.status": tmock,
                },
            ):
                with patch.object(service, "_disable", mock):
                    assert service.running("salt", False) == ret[2]
            with patch.dict(
                service.__salt__,
                {
                    "service.status": MagicMock(side_effect=[False, True]),
                    "service.enabled": MagicMock(side_effect=[False, True]),
                    "service.start": MagicMock(return_value="stack"),
                },
            ):
                with patch.object(
                    service,
                    "_enable",
                    MagicMock(return_value={"changes": "saltstack"}),
                ):
                    assert service.running("salt", True) == ret[4]
            with patch.dict(
                service.__salt__,
                {
                    "service.status": MagicMock(side_effect=[False, True]),
                    "service.enabled": MagicMock(side_effect=[False, True]),
                    "service.unmask": MagicMock(side_effect=[False, True]),
                    "service.start": MagicMock(return_value="stack"),
                },
            ):
                with patch.object(
                    service,
                    "_enable",
                    MagicMock(return_value={"changes": "saltstack"}),
                ):
                    assert service.running("salt", True, unmask=True) == ret[7]
        with patch.dict(service.__opts__, {"test": True}):
            with patch.dict(service.__salt__, {"service.status": tmock}):
                assert service.running("salt") == ret[5]
            with patch.dict(service.__salt__, {"service.status": fmock}):
                assert service.running("salt") == ret[3]
        with patch.dict(service.__opts__, {"test": False}):
            with patch.dict(
                service.__salt__,
                {
                    "service.status": MagicMock(side_effect=[False, False]),
                    "service.enabled": MagicMock(side_effect=[True, True]),
                    "service.start": MagicMock(return_value="stack"),
                },
            ):
                with patch.object(
                    service,
                    "_enable",
                    MagicMock(return_value={"changes": "saltstack"}),
                ):
                    assert service.running("salt", True) == ret[6]
            with patch.object(salt.utils.platform, "is_windows", tmock):
                with patch.dict(
                    service.__salt__,
                    {
                        "service.status": fmock,
                        "service.enabled": fmock,
                        "service.start": tmock,
                    },
                ):
                    assert service.running("salt", None) == ret[9]
                    assert service.__context__ == {"service.state": "running"}
            with patch.object(salt.utils.platform, "is_darwin", tmock):
                with patch.dict(
                    service.__salt__,
                    {
                        "service.status": fmock,
                        "service.enabled": fmock,
                        "service.start": tmock,
                    },
                ):
                    assert service.running("salt", None) == ret[9]
                    assert service.__context__ == {"service.state": "running"}
                with patch.dict(
                    service.__salt__,
                    {
                        "service.status": MagicMock(side_effect=[False, "loaded"]),
                        "service.enabled": MagicMock(side_effect=[False, True]),
                        "service.start": tmock,
                    },
                ):
                    with patch.object(
                        service,
                        "_enable",
                        MagicMock(return_value={"changes": "saltstack"}),
                    ):
                        assert service.running("salt", True) == ret[4]
                        assert service.__context__ == {"service.state": "running"}
                with patch.dict(
                    service.__salt__,
                    {
                        "service.status": fmock,
                        "service.enabled": fmock,
                        "service.start": fmock,
                    },
                ):
                    with patch.object(
                        service,
                        "_enable",
                        MagicMock(
                            return_value={"changes": "saltstack", "result": False}
                        ),
                    ):
                        assert service.running("salt", True) == ret[6]
                        assert service.__context__ == {"service.state": "running"}
def test_running_in_offline_mode():
    """
    Tests the case in which a service.running state is executed on an offline environemnt
    """
    name = "thisisnotarealservice"
    with patch.object(service, "_offline", MagicMock(return_value=True)):
        ret = service.running(name=name)
        assert ret == {
            "changes": {},
            "comment": "Running in OFFLINE mode. Nothing to do",
            "result": True,
            "name": name,
        }
def test_dead():
    """
    Test to ensure that the named service is dead
    """
    ret = [
        {"changes": {}, "comment": "", "name": "salt", "result": True},
        {
            "changes": "saltstack",
            "comment": "The service salt is already dead",
            "name": "salt",
            "result": True,
        },
        {
            "changes": {},
            "comment": "Service salt is set to be killed",
            "name": "salt",
            "result": None,
        },
        {
            "changes": "saltstack",
            "comment": "Service salt was killed",
            "name": "salt",
            "result": True,
        },
        {
            "changes": {},
            "comment": "Service salt failed to die",
            "name": "salt",
            "result": False,
        },
        {
            "changes": "saltstack",
            "comment": "The service salt is already dead",
            "name": "salt",
            "result": True,
        },
    ]
    info_mock = MagicMock(return_value={"StartType": ""})
    mock = MagicMock(return_value="salt")
    with patch.object(service, "_enabled_used_error", mock):
        assert service.dead("salt", enabled=1) == "salt"
    tmock = MagicMock(return_value=True)
    fmock = MagicMock(return_value=False)
    with patch.object(service, "_available", fmock):
        assert service.dead("salt") == ret[0]
    with patch.object(service, "_available", tmock):
        mock = MagicMock(return_value={"changes": "saltstack"})
        with patch.dict(service.__opts__, {<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"test": True}):
            with patch.dict(
                service.__salt__,
                {
                    "service.enabled": fmock,
                    "service.stop": tmock,
                    "service.status": fmock,
                    "service.info": info_mock,
                },
            ):
                with patch.object(service, "_enable", mock):
                    assert service.dead("salt", True) == ret[5</b></font>]
            with patch.dict(
                service.__salt__,
                {
                    "service.enabled": tmock,
                    "service.status": tmock,
                    "service.info": info_mock,
                },
                assert service.dead("salt") == ret[2]
        with patch.dict(service.__opts__, {<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"test": False}):
            with patch.dict(
                service.__salt__,
                {
                    "service.enabled": fmock,
                    "service.stop": tmock,
                    "service.status": fmock,
                    "service.info": info_mock,
                },
            ):
                with patch.object(service, "_enable", mock):
                    assert service.dead("salt", True) == ret[1</b></font>]
            with patch.dict(
                service.__salt__,
                {
                    "service.enabled": MagicMock(side_effect=[True, True, False]),
                    "service.status": MagicMock(side_effect=[True, False, False]),
                    "service.stop": MagicMock(return_value="stack"),
                    "service.info": info_mock,
                },
            ):
                with patch.object(
                    service,
                    "_enable",
                    MagicMock(return_value={"changes": "saltstack"}),
                ):
                    assert service.dead("salt", True) == ret[3]
            with patch.dict(
                service.__salt__,
                {
                    "service.enabled": MagicMock(side_effect=[False, False, False]),
                    "service.status": MagicMock(side_effect=[True, True, True]),
                    "service.stop": MagicMock(return_value="stack"),
                    "service.info": info_mock,
                },
            ):
                with patch.object(service, "_disable", MagicMock(return_value={})):
                    assert service.dead("salt", False) == ret[4]
        assert service.__context__ == {"service.state": "dead"}
def test_dead_with_missing_service():
    """
    Tests the case in which a service.dead state is executed on a state
    which does not exist.
    See https://github.com/saltstack/salt/issues/37511
    """
    name = "thisisnotarealservice"
    with patch.dict(
        service.__salt__, {"service.available": MagicMock(return_value=False)}
    ):
        ret = service.dead(name=name)
        assert ret == {
            "changes": {},
            "comment": "The named service {} is not available".format(name),
            "result": True,
            "name": name,
        }
def test_dead_in_offline_mode():
    """
    Tests the case in which a service.dead state is executed on an offline environemnt
    """
    name = "thisisnotarealservice"
    with patch.object(service, "_offline", MagicMock(return_value=True)):
        ret = service.dead(name=name)
        assert ret == {
            "changes": {},
            "comment": "Running in OFFLINE mode. Nothing to do",
            "result": True,
            "name": name,
        }
def test_enabled():
    """
    Test to verify that the service is enabled
    """
    ret = {"changes": "saltstack", "comment": "", "name": "salt", "result": True}
    mock = MagicMock(return_value={"changes": "saltstack"})
    with patch.object(service, "_enable", mock):
        assert service.enabled("salt") == ret
        assert service.__context__ == {"service.state": "enabled"}
def test_disabled():
    """
    Test to verify that the service is disabled
    """
    ret = {"changes": "saltstack", "comment": "", "name": "salt", "result": True}
    mock = MagicMock(return_value={"changes": "saltstack"})
    with patch.object(service, "_disable", mock):
        assert service.disabled("salt") == ret
        assert service.__context__ == {"service.state": "disabled"}
def test_mod_watch():
    """
    Test to the service watcher, called to invoke the watch command.
    """
    ret = [
        {
            "changes": {},
            "comment": "Service is already stopped",
            "name": "salt",
            "result": True,
        },
        {
            "changes": {},
            "comment": "Unable to trigger watch for service.stack",
            "name": "salt",
            "result": False,
        },
        {
            "changes": {},
            "comment": "Service is set to be started",
            "name": "salt",
        },
        {
            <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"changes": {"salt": "salt"},
            "comment": "Service started",
            "name": "salt",
            "result": "salt",
        },
    ]
    mock = MagicMock(return_value=False)
    with patch.dict(service.__salt__, {"service.status": mock}):
        assert service.mod_watch("salt", "dead") == ret[</b></font>0]
        with patch.dict(service.__salt__, {"service.start": func}):
            with patch.dict(service.__opts__, {"test": True}):
                assert service.mod_watch("salt", "running") == ret[2]
            with patch.dict(service.__opts__, {"test": False}):
                assert service.mod_watch("salt", "running") == ret[3]
        assert service.mod_watch("salt", "stack") == ret[1]
def test_mod_beacon(tmp_path):
    """
    Test to create a beacon based on a service
    """
    name = "sshd"
    with patch.dict(service.__salt__, {"beacons.list": MagicMock(return_value={})}):
        with patch.dict(service.__states__, {"beacon.present": beaconstate.present}):
            ret = service.mod_beacon(name, sfun="copy")
            expected = {
                "name": name,
                "changes": {},
                "result": False,
                "comment": "service.copy does not work with the beacon state function",
            }
            assert ret == expected
    event_returns = [
        {
            "complete": True,
            "tag": "/salt/minion/minion_beacons_list_complete",
            "beacons": {},
        },
        {
            "complete": True,
            "tag": "/salt/minion/minion_beacons_list_complete",
            "beacons": {},
        },
        {
            "complete": True,
            "tag": "/salt/minion/minion_beacons_list_available_complete",
            "beacons": ["service"],
        },
        {
            "valid": True,
            "tag": "/salt/minion/minion_beacon_validation_complete",
            "vcomment": "Valid beacon configuration",
        },
        {
            "complete": True,
            "tag": "/salt/minion/minion_beacon_add_complete",
            "beacons": {
                "beacon_service_sshd": [
                    {
                        "services": {
                            "sshd": {
                                "onchangeonly": True,
                                "delay": 0,
                                "uncleanshutdown": None,
                                "emitatstartup": False,
                            },
                        }
                    },
                    {"interval": 60},
                    {"beacon_module": "service"},
                ]
            },
        },
    ]
    mock = MagicMock(return_value=True)
    beacon_state_mocks = {
        "beacons.list": beaconmod.list_,
        "beacons.add": beaconmod.add,
        "beacons.list_available": beaconmod.list_available,
        "event.fire": mock,
    }
    beacon_mod_mocks = {"event.fire": mock}
    sock_dir = str(tmp_path / "test-socks")
    with patch.dict(service.__states__, {"beacon.present": beaconstate.present}):
        with patch.dict(beaconstate.__salt__, beacon_state_mocks):
            with patch.dict(beaconmod.__salt__, beacon_mod_mocks):
                with patch.dict(
                    beaconmod.__opts__, {"beacons": {}, "sock_dir": sock_dir}
                ):
                    with patch.object(
                        SaltEvent, "get_event", side_effect=event_returns
                    ):
                        ret = service.mod_beacon(name, sfun="running", beacon="True")
                        expected = {
                            "name": "beacon_service_sshd",
                            "changes": {},
                            "result": True,
                            "comment": "Adding beacon_service_sshd to beacons",
                        }
                        assert ret == expected
@pytest.mark.skip_on_darwin(reason="service.running is currently failing on OSX")
@pytest.mark.destructive_test
@pytest.mark.slow_test
def test_running_with_reload():
    """
    Test that a running service is properly reloaded
    """
    opts = salt.config.DEFAULT_MINION_OPTS.copy()
    opts["grains"] = salt.loader.grains(opts)
    utils = salt.loader.utils(opts)
    modules = salt.loader.minion_mods(opts, utils=utils)
    service_name = "cron"
    cmd_name = "crontab"
    os_family = opts["grains"]["os_family"]
    os_release = opts["grains"]["osrelease"]
    if os_family == "RedHat":
        service_name = "crond"
    elif os_family == "Arch":
        service_name = "sshd"
        cmd_name = "systemctl"
    elif os_family == "MacOS":
        service_name = "org.ntp.ntpd"
        if int(os_release.split(".")[1]) &gt;= 13:
            service_name = "com.openssh.sshd"
    elif os_family == "Windows":
        service_name = "Spooler"
    if os_family != "Windows" and salt.utils.path.which(cmd_name) is None:
        pytest.skip("{} is not installed".format(cmd_name))
    pre_srv_enabled = (
        True if service_name in modules["service.get_enabled"]() else False
    )
    post_srv_disable = False
    if not pre_srv_enabled:
        modules["service.enable"](service_name)
        post_srv_disable = True
    try:
        with patch.dict(service.__grains__, opts["grains"]), patch.dict(
            service.__opts__, opts
        ), patch.dict(service.__salt__, modules), patch.dict(
            service.__utils__, utils
        ), patch.dict(
            service.__opts__, {"test": False}
        ), patch(
            "salt.utils.systemd.offline", MagicMock(return_value=False)
        ):
            service.dead(service_name, enable=False)
            result = service.running(name=service_name, enable=True, reload=False)
        if salt.utils.platform.is_windows():
            comment = "Started service {}".format(service_name)
        else:
            comment = "Service {} has been enabled, and is running".format(service_name)
        expected = {
            "changes": {service_name: True},
            "comment": comment,
            "name": service_name,
            "result": True,
        }
        assert result == expected
    finally:
        if post_srv_disable:
            modules["service.disable"](service_name)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_mount.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
    :codeauthor: Rupesh Tare &lt;rupesht@saltstack.com&gt;
"""
import logging
import os
import shutil
import sys
import textwrap
import pytest
import salt.modules.mount as mount
import salt.utils.files
import salt.utils.path
from salt.exceptions import CommandExecutionError
from tests.support.mock import MagicMock, mock_open, patch
log = logging.getLogger(__name__)
@pytest.fixture
def mock_shell_file():
    return "A B C D F G\n"
@pytest.fixture
def config_initial_file():
    inital_fsystem = [
        "/:\n",
        "\tdev\t\t= /dev/hd4\n",
        "\tvfs\t\t= jfs2\n",
        "\tlog\t\t= /dev/hd8\n",
        "\tmount \t\t= automatic\n",
        "\tcheck\t\t= false\n",
        "\ttype\t\t= bootfs\n",
        "\tvol\t\t= root\n",
        "\tfree\t\t= true\n",
        "\n",
        "/home:\n",
        "\tdev\t\t= /dev/hd1\n",
        "\tvfs\t\t= jfs2\n",
        "\tlog\t\t= /dev/hd8\n",
        "\tmount\t\t= true\n",
        "\tcheck\t\t= true\n",
        "\tvol\t\t= /home\n",
        "\tfree\t\t= false\n",
        "\n",
    ]
    return inital_fsystem
@pytest.fixture
def configure_loader_modules():
    return {mount: {}}
@pytest.fixture
def tmp_sub_dir(tmp_path):
    directory = tmp_path / "filesystems-dir"
    directory.mkdir()
    yield directory
    shutil.rmtree(str(directory))
@pytest.fixture
def config_file(tmp_sub_dir, config_initial_file):
    filename = str(tmp_sub_dir / "filesystems")
    with salt.utils.files.fopen(filename, "wb") as fp:
        fp.writelines(salt.utils.data.encode(config_initial_file))
    yield filename
    os.remove(filename)
def test_active():
    """
    List the active mounts.
    """
    with patch.dict(mount.__grains__, {"os": "FreeBSD", "kernel": "FreeBSD"}):
        mock = MagicMock(return_value="A B C D,E,F,uid=user1,gid=grp1")
        mock_user = MagicMock(return_value={"uid": "100"})
        mock_group = MagicMock(return_value={"gid": "100"})
        with patch.dict(
            mount.__salt__,
            {
                "cmd.run_stdout": mock,
                "user.info": mock_user,
                "group.info": mock_group,
            },
        ):
            assert mount.active() == {
                "B": {
                    "device": "A",
                    "opts": ["D", "E", "F", "uid=100", "gid=100"],
                    "fstype": "C",
            }
    with patch.dict(mount<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.__grains__, {"os": "Solaris", "kernel": "SunOS"}):
        mock = MagicMock(return_value="A * B * C D/E/F")
        with patch.dict(mount.__salt__, {"cmd.run_stdout": mock}):
            assert mount.active() == {
                "B"</b></font>: {"device": "A", "opts": ["D", "E", "F"], "fstype": "C"}
            }
    with patch.dict(mount.__grains__, {"os": "AIX", "kernel": "AIX"}):
        mock = MagicMock(return_value="A * B * C D/E/F")
        with patch.dict(mount.__salt__, {"cmd.run_stdout": mock}):
            assert mount.active() == {"B": {"node": "A", "device": "*", "fstype": "*"}}
    with patch.dict(mount.__grains__, {"os": "OpenBSD", "kernel": "OpenBSD"}):
        mock = MagicMock(return_value={})
        with patch.object(mount, "_active_mounts_openbsd", mock):
            assert mount.active() == {}
    with patch.dict(mount.__grains__, {"os": "MacOS", "kernel": "Darwin"}):
        mock = MagicMock(return_value={})
        with patch.object(mount, "_active_mounts_darwin", mock):
            assert mount.active() == {}
    with patch.dict(mount.__grains__, {"os": "MacOS", "kernel": "Darwin"}):
        mock = MagicMock(return_value={})
        with patch.object(mount, "_active_mountinfo", mock):
            with patch.object(mount, "_active_mounts_darwin", mock):
                assert mount.active(extended=True) == {}
    with patch.dict(mount.__grains__, {"os": "AIX", "kernel": "AIX"}):
        mock = MagicMock(return_value={})
        with patch.object(mount, "_active_mounts_aix", mock):
            assert mount.active() == {}
def test_fstab():
    """
    List the content of the fstab
    """
    mock = MagicMock(return_value=False)
    with patch.object(os.path, "isfile", mock):
        assert mount.fstab() == {}
    file_data = "\n".join(["#", "A B C D,E,F G H"])
    mock = MagicMock(return_value=True)
    with patch.dict(mount.__grains__, {"kernel": ""}), patch.object(
        os.path, "isfile", mock
    ), patch("salt.utils.files.fopen", mock_open(read_data=file_data)):
        fstab = mount.fstab()
        assert fstab == {
            "B": {
                "device": "A",
                "dump": "G",
                "fstype": "C",
                "opts": ["D", "E", "F"],
                "pass": "H",
            }
        }, fstab
def test_vfstab():
    """
    List the content of the vfstab
    """
    mock = MagicMock(return_value=False)
    with patch.object(os.path, "isfile", mock):
        assert mount.vfstab() == {}
    file_data = textwrap.dedent(
        """\
        swap        -   /tmp                tmpfs    -   yes    size=2048m
        """
    )
    mock = MagicMock(return_value=True)
    with patch.dict(mount.__grains__, {"kernel": "SunOS"}), patch.object(
        os.path, "isfile", mock
    ), patch("salt.utils.files.fopen", mock_open(read_data=file_data)):
        vfstab = mount.vfstab()
        assert vfstab == {
            "/tmp": {
                "device": "swap",
                "device_fsck": "-",
                "fstype": "tmpfs",
                "mount_at_boot": "yes",
                "opts": ["size=2048m"],
                "pass_fsck": "-",
            }
        }, vfstab
def test_filesystems():
    """
    List the content of the filesystems
    """
    file_data = textwrap.dedent(
        """\
        """
    )
    mock = MagicMock(return_value=True)
    with patch.dict(mount.__grains__, {"os": "AIX", "kernel": "AIX"}), patch.object(
        os.path, "isfile", mock
    ), patch("salt.utils.files.fopen", mock_open(read_data=file_data)):
        assert mount.filesystems() == {}
    file_data = textwrap.dedent(
        """\
        /home:
                dev             = /dev/hd1
                vfs             = jfs2
                log             = /dev/hd8
                mount           = true
                check           = true
                vol             = /home
                free            = false
                quota           = no
        """
    )
    mock = MagicMock(return_value=True)
    with patch.dict(mount.__grains__, {"os": "AIX", "kernel": "AIX"}), patch.object(
        os.path, "isfile", mock
    ), patch("salt.utils.files.fopen", mock_open(read_data=file_data)):
        fsyst = mount.filesystems()
        test_fsyst = {
            "/home": {
                "dev": "/dev/hd1",
                "vfs": "jfs2",
                "log": "/dev/hd8",
                "mount": "true",
                "check": "true",
                "vol": "/home",
                "free": "false",
                "quota": "no",
            }
        }
        assert test_fsyst == fsyst
def test_rm_fstab():
    """
    Remove the mount point from the fstab
    """
    mock_fstab = MagicMock(return_value={})
    with patch.dict(mount.__grains__, {"kernel": ""}):
        with patch.object(mount, "fstab", mock_fstab):
            with patch("salt.utils.files.fopen", mock_open()):
                assert mount.rm_fstab("name", "device")
def test_set_fstab(mock_shell_file):
    """
    Tests to verify that this mount is represented in the fstab,
    change the mount to match the data passed, or add the mount
    if it is not present.
    """
    mock = MagicMock(return_value=False)
    with patch.object(os.path, "isfile", mock):
        pytest.raises(CommandExecutionError, mount.set_fstab, "A", "B", "C")
    mock = MagicMock(return_value=True)
    mock_read = MagicMock(side_effect=OSError)
    with patch.object(os.path, "isfile", mock):
        with patch.object(salt.utils.files, "fopen", mock_read):
            pytest.raises(CommandExecutionError, mount.set_fstab, "A", "B", "C")
    mock = MagicMock(return_value=True)
    with patch.object(os.path, "isfile", mock):
        with patch("salt.utils.files.fopen", mock_open(read_data=mock_shell_file)):
            assert mount.set_fstab("A", "B", "C") == "new"
    mock = MagicMock(return_value=True)
    with patch.object(os.path, "isfile", mock):
        with patch("salt.utils.files.fopen", mock_open(read_data=mock_shell_file)):
            assert mount.set_fstab("B", "A", "C", "D", "F", "G") == "present"
    mock = MagicMock(return_value=True)
    with patch.object(os.path, "isfile", mock):
        with patch("salt.utils.files.fopen", mock_open(read_data=mock_shell_file)):
            assert mount.set_fstab("B", "A", "C", not_change=True) == "present"
def test_rm_automaster():
    """
    Remove the mount point from the auto_master
    """
    mock = MagicMock(return_value={})
    with patch.object(mount, "automaster", mock):
        assert mount.rm_automaster("name", "device")
    mock = MagicMock(return_value={"name": "name"})
    with patch.object(mount, "fstab", mock):
        assert mount.rm_automaster("name", "device")
def test_set_automaster(mock_shell_file):
    """
    Verify that this mount is represented in the auto_salt, change the mount
    to match the data passed, or add the mount if it is not present.
    """
    mock = MagicMock(return_value=True)
    with patch.object(os.path, "isfile", mock):
        pytest.raises(CommandExecutionError, mount.set_automaster, "A", "B", "C")
    mock = MagicMock(return_value=True)
    mock_read = MagicMock(side_effect=OSError)
    with patch.object(os.path, "isfile", mock):
        with patch.object(salt.utils.files, "fopen", mock_read):
            pytest.raises(CommandExecutionError, mount.set_automaster, "A", "B", "C")
    mock = MagicMock(return_value=True)
    with patch.object(os.path, "isfile", mock):
        with patch("salt.utils.files.fopen", mock_open(read_data=mock_shell_file)):
            assert mount.set_automaster("A", "B", "C") == "new"
    mock = MagicMock(return_value=True)
    with patch.object(os.path, "isfile", mock):
        with patch(
            "salt.utils.files.fopen", mock_open(read_data="/..A -fstype=C,D C:B")
        ):
            assert mount.set_automaster("A", "B", "C", "D") == "present"
    mock = MagicMock(return_value=True)
    with patch.object(os.path, "isfile", mock):
        with patch(
            "salt.utils.files.fopen", mock_open(read_data="/..A -fstype=XX C:B")
        ):
            assert (
                mount.set_automaster("A", "B", "C", "D", not_change=True) == "present"
            )
def test_automaster():
    """
    Test the list the contents of the fstab
    """
    assert mount.automaster() == {}
def test_rm_filesystems():
    """
    Remove the mount point from the filesystems
    """
    file_data = textwrap.dedent(
        """\
        """
    )
    mock = MagicMock(return_value=True)
    with patch.dict(mount.__grains__, {"os": "AIX", "kernel": "AIX"}), patch.object(
        os.path, "isfile", mock
    ), patch("salt.utils.files.fopen", mock_open(read_data=file_data)):
        assert not mount.rm_filesystems("name", "device")
    file_data = textwrap.dedent(
        """\
        /name:
                dev             = device
                vol             = /name
        """
    )
    mock = MagicMock(return_value=True)
    mock_fsyst = MagicMock(return_value=True)
    with patch.dict(mount.__grains__, {"os": "AIX", "kernel": "AIX"}), patch.object(
        os.path, "isfile", mock
    ), patch("salt.utils.files.fopen", mock_open(read_data=file_data)):
        assert mount.rm_filesystems("/name", "device")
def test_set_filesystems():
    """
    Tests to verify that this mount is represented in the filesystems,
    change the mount to match the data passed, or add the mount
    if it is not present.
    """
    mock = MagicMock(return_value=False)
    with patch.dict(mount.__grains__, {"os": "AIX", "kernel": "AIX"}):
        with patch.object(os.path, "isfile", mock):
            pytest.raises(CommandExecutionError, mount.set_filesystems, "A", "B", "C")
        mock_read = MagicMock(side_effect=OSError)
        with patch.object(os.path, "isfile", mock):
            with patch.object(salt.utils.files, "fopen", mock_read):
                pytest.raises(
                    CommandExecutionError, mount.set_filesystems, "A", "B", "C"
                )
@pytest.mark.skipif(
    sys.version_info[0] == 3 and sys.version_info[1] &lt;= 5,
    reason="run on Python 3.6 or greater where OrderedDict is default",
)
@pytest.mark.skip_on_windows(
    reason="Not supported on Windows, does not handle tabs well"
)
def test_set_filesystems_with_data(tmp_sub_dir, config_file):
    """
    Tests to verify set_filesystems reads and adjusts file /etc/filesystems correctly
    """
    config_filepath = str(tmp_sub_dir / "filesystems")
    with patch.dict(mount.__grains__, {"os": "AIX", "kernel": "AIX"}):
        mount.set_filesystems(
            "/test_mount", "/dev/hd3", "jsf2", "-", "true", config_filepath
        )
        with salt.utils.files.fopen(config_filepath, "r") as fp:
            fsys_content = fp.read()
        test_fsyst = """/:
	dev		= /dev/hd4
	vfs		= jfs2
	log		= /dev/hd8
	mount		= automatic
	check		= false
	type		= bootfs
	vol		= root
	free		= true
/home:
	dev		= /dev/hd1
	vfs		= jfs2
	log		= /dev/hd8
	mount		= true
	check		= true
	vol		= /home
	free		= false
/test_mount:
	dev		= /dev/hd3
	vfstype		= jsf2
	opts		= -
	mount		= true
"""
    assert test_fsyst == fsys_content
def test_mount():
    """
    Mount a device
    """
    with patch.dict(mount.__grains__, {"os": "MacOS"}):
        mock = MagicMock(return_value=True)
        with patch.object(os.path, "exists", mock):
            mock = MagicMock(return_value=None)
            with patch.dict(mount.__salt__, {"file.mkdir": None}):
                mock = MagicMock(return_value={"retcode": True, "stderr": True})
                with patch.dict(mount.__salt__, {"cmd.run_all": mock}):
                    assert mount.mount("name", "device")
                    mock.assert_called_with(
                        "mount  device name ", python_shell=False, runas=None
                    )
                with patch.dict(mount.__salt__, {"cmd.run_all": mock}):
                    assert mount.mount("name", "device", fstype="fstype")
                    mock.assert_called_with(
                        "mount  -t fstype device name ",
                        python_shell=False,
                        runas=None,
                    )
                mock = MagicMock(return_value={"retcode": False, "stderr": False})
                with patch.dict(mount.__salt__, {"cmd.run_all": mock}):
                    assert mount.mount("name", "device")
    with patch.dict(mount.__grains__, {"os": "AIX"}):
        mock = MagicMock(return_value=True)
        with patch.object(os.path, "exists", mock):
            mock = MagicMock(return_value=None)
            with patch.dict(mount.__salt__, {"file.mkdir": None}):
                mock = MagicMock(return_value={"retcode": True, "stderr": True})
                with patch.dict(mount.__salt__, {"cmd.run_all": mock}):
                    assert mount.mount("name", "device")
                    mock.assert_called_with(
                        "mount  device name ", python_shell=False, runas=None
                    )
                with patch.dict(mount.__salt__, {"cmd.run_all": mock}):
                    assert mount.mount("name", "device", fstype="fstype")
                    mock.assert_called_with(
                        "mount  -v fstype device name ",
                        python_shell=False,
                        runas=None,
                    )
                mock = MagicMock(return_value={"retcode": False, "stderr": False})
                with patch.dict(mount.__salt__, {"cmd.run_all": mock}):
                    assert mount.mount("name", "device")
    with patch.dict(mount.__grains__, {"os": "Linux"}):
        mock = MagicMock(return_value=True)
        with patch.object(os.path, "exists", mock):
            mock = MagicMock(return_value=None)
            with patch.dict(mount.__salt__, {"file.mkdir": None}):
                mock = MagicMock(return_value={"retcode": True, "stderr": True})
                with patch.dict(mount.__salt__, {"cmd.run_all": mock}):
                    assert mount.mount("name", "device")
                    mock.assert_called_with(
                        "mount -o defaults device name ",
                        python_shell=False,
                        runas=None,
                    )
                with patch.dict(mount.__salt__, {"cmd.run_all": mock}):
                    assert mount.mount("name", "device", fstype="fstype")
                    mock.assert_called_with(
                        "mount -o defaults -t fstype device name ",
                        python_shell=False,
                        runas=None,
                    )
                mock = MagicMock(return_value={"retcode": False, "stderr": False})
                with patch.dict(mount.__salt__, {"cmd.run_all": mock}):
                    assert mount.mount("name", "device")
def test_remount_non_mounted():
    """
    Attempt to remount a device, if the device is not already mounted, mount
    is called
    """
    with patch.dict(mount.__grains__, {"os": "MacOS"}):
        mock = MagicMock(return_value=[])
        with patch.object(mount, "active", mock):
            mock = MagicMock(return_value=True)
            with patch.object(mount, "mount", mock):
                assert mount.remount("name", "device")
    with patch.dict(mount.__grains__, {"os": "AIX"}):
        mock = MagicMock(return_value=[])
        with patch.object(mount, "active", mock):
            mock = MagicMock(return_value=True)
            with patch.object(mount, "mount", mock):
                assert mount.remount("name", "device")
    with patch.dict(mount.__grains__, {"os": "Linux"}):
        mock = MagicMock(return_value=[])
        with patch.object(mount, "active", mock):
            mock = MagicMock(return_value=True)
            with patch.object(mount, "mount", mock):
                assert mount.remount("name", "device")
def test_remount_already_mounted_no_fstype():
    """
    Attempt to remount a device already mounted that do not provides
    fstype
    """
    with patch.dict(mount.__grains__, {"os": "MacOS"}):
        mock = MagicMock(return_value=["name"])
        with patch.object(mount, "active", mock):
            mock = MagicMock(return_value={"retcode": 0})
            with patch.dict(mount.__salt__, {"cmd.run_all": mock}):
                assert mount.remount("name", "device")
                mock.assert_called_with(
                    "mount -u -o noowners device name ",
                    python_shell=False,
                    runas=None,
                )
    with patch.dict(mount.__grains__, {"os": "AIX"}):
        mock = MagicMock(return_value=["name"])
        with patch.object(mount, "active", mock):
            mock = MagicMock(return_value={"retcode": 0})
            with patch.dict(mount.__salt__, {"cmd.run_all": mock}):
                assert mount.remount("name", "device")
                mock.assert_called_with(
                    "mount -o remount device name ", python_shell=False, runas=None
                )
    with patch.dict(mount.__grains__, {"os": "Linux"}):
        mock = MagicMock(return_value=["name"])
        with patch.object(mount, "active", mock):
            mock = MagicMock(return_value={"retcode": 0})
            with patch.dict(mount.__salt__, {"cmd.run_all": mock}):
                assert mount.remount("name", "device")
                mock.assert_called_with(
                    "mount -o defaults,remount device name ",
                    python_shell=False,
                    runas=None,
                )
def test_remount_already_mounted_with_fstype():
    """
    Attempt to remount a device already mounted that do not provides
    fstype
    """
    with patch.dict(mount.__grains__, {"os": "MacOS"}):
        mock = MagicMock(return_value=["name"])
        with patch.object(mount, "active", mock):
            mock = MagicMock(return_value={"retcode": 0})
            with patch.dict(mount.__salt__, {"cmd.run_all": mock}):
                assert mount.remount("name", "device", fstype="type")
                mock.assert_called_with(
                    "mount -u -o noowners -t type device name ",
                    python_shell=False,
                    runas=None,
                )
    with patch.dict(mount.__grains__, {"os": "AIX"}):
        mock = MagicMock(return_value=["name"])
        with patch.object(mount, "active", mock):
            mock = MagicMock(return_value={"retcode": 0})
            with patch.dict(mount.__salt__, {"cmd.run_all": mock}):
                assert mount.remount("name", "device", fstype="type")
                mock.assert_called_with(
                    "mount -o remount -v type device name ",
                    python_shell=False,
                    runas=None,
                )
    with patch.dict(mount.__grains__, {"os": "Linux"}):
        mock = MagicMock(return_value=["name"])
        with patch.object(mount, "active", mock):
            mock = MagicMock(return_value={"retcode": 0})
            with patch.dict(mount.__salt__, {"cmd.run_all": mock}):
                assert mount.remount("name", "device", fstype="type")
                mock.assert_called_with(
                    "mount -o defaults,remount -t type device name ",
                    python_shell=False,
                    runas=None,
                )
def test_umount():
    """
    Attempt to unmount a device by specifying the directory it is
    mounted on
    """
    mock = MagicMock(return_value={})
    with patch.object(mount, "active", mock):
        assert mount.umount("name") == "name does not have anything mounted"
    mock = MagicMock(return_value={"name": "name"})
    with patch.object(mount, "active", mock):
        mock = MagicMock(return_value={"retcode": True, "stderr": True})
        with patch.dict(mount.__salt__, {"cmd.run_all": mock}):
            assert mount.umount("name")
        mock = MagicMock(return_value={"retcode": False})
        with patch.dict(mount.__salt__, {"cmd.run_all": mock}):
            assert mount.umount("name")
    mock = MagicMock()
    with patch.dict(mount.__salt__, {"guestfs.umount": mock}):
        mount.umount("/mountpoint", device="/path/to/my.qcow", util="guestfs")
        mock.assert_called_once_with("/mountpoint", disk="/path/to/my.qcow")
def test_is_fuse_exec():
    """
    Returns true if the command passed is a fuse mountable application
    """
    with patch.object(salt.utils.path, "which", return_value=None):
        assert not mount.is_fuse_exec("cmd")
    def _ldd_side_effect(cmd, *args, **kwargs):
        """
        Neither of these are full ldd output, but what is_fuse_exec is
        looking for is 'libfuse' in the ldd output, so these examples
        should be sufficient enough to test both the True and False cases.
        """
        return {
            "ldd cmd1": textwrap.dedent(
                """\
                linux-vdso.so.1 (0x00007ffeaf5fb000)
                libfuse3.so.3 =&gt; /usr/lib/libfuse3.so.3 (0x00007f91e66ac000)
                """
            ),
            "ldd cmd2": textwrap.dedent(
                """\
                linux-vdso.so.1 (0x00007ffeaf5fb000)
                """
            ),
        }[cmd]
    which_mock = MagicMock(side_effect=lambda x: x)
    ldd_mock = MagicMock(side_effect=_ldd_side_effect)
    <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>with patch.object(salt.utils.path, "which", which_mock):
        with patch.dict(mount.__salt__, {"cmd.run": _ldd_side_effect}):
            assert mount.is_fuse_exec(</b></font>"cmd1")
            assert not mount.is_fuse_exec("cmd2")
def test_swaps():
    """
    Return a dict containing information on active swap
    """
    file_data = textwrap.dedent(
        """\
        Filename Type Size Used Priority
        /dev/sda1 partition 31249404 4100 -1
        """
    )
    with patch.dict(mount.__grains__, {"os": "", "kernel": ""}):
        with patch("salt.utils.files.fopen", mock_open(read_data=file_data)):
            swaps = mount.swaps()
            assert swaps == {
                "/dev/sda1": {
                    "priority": "-1",
                    "size": "31249404",
                    "type": "partition",
                    "used": "4100",
                }
            }, swaps
    file_data = textwrap.dedent(
        """\
        Device Size Used Unknown Unknown Priority
        /dev/sda1 31249404 4100 unknown unknown -1
        """
    )
    mock = MagicMock(return_value=file_data)
    with patch.dict(
        mount.__grains__, {"os": "OpenBSD", "kernel": "OpenBSD"}
    ), patch.dict(mount.__salt__, {"cmd.run_stdout": mock}):
        swaps = mount.swaps()
        assert swaps == {
            "/dev/sda1": {
                "priority": "-1",
                "size": "31249404",
                "type": "partition",
                "used": "4100",
            }
        }, swaps
    file_data = textwrap.dedent(
        """\
        device              maj,min        total       free
        /dev/hd6              10,  2     11776MB     11765MB
        """
    )
    mock = MagicMock(return_value=file_data)
    with patch.dict(mount.__grains__, {"os": "AIX", "kernel": "AIX"}), patch.dict(
        mount.__salt__, {"cmd.run_stdout": mock}
    ):
        swaps = mount.swaps()
        assert swaps == {
            "/dev/hd6": {
                "priority": "-",
                "size": 12058624,
                "type": "device",
                "used": 11264,
            }
        }, swaps
def test_swapon():
    Activate a swap disk
    """
    mock = MagicMock(return_value={<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"name": "name"})
    with patch.dict(mount.__grains__, {"kernel": ""}):
        with patch.object(mount, "swaps", mock):
            assert mount.swapon("name") == {"s</b></font>tats": "name", "new": False}
    mock = MagicMock(return_value={})
    with patch.dict(mount.__grains__, {"kernel": ""}):
        with patch.object(mount, "swaps", mock):
            mock = MagicMock(return_value=None)
            with patch.dict(mount.__salt__, {"cmd.run": mock}):
                assert mount.swapon("name", False) == {}
    mock = MagicMock(side_effect=[{}, {"name": "name"}])
    with patch.dict(mount.__grains__, {"kernel": ""}):
        with patch.object(mount, "swaps", mock):
            mock = MagicMock(return_value=None)
                assert mount.swapon("name") == {"stats": "name", "new": True}
    mock = MagicMock(return_value={<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"name": "name"})
    with patch.dict(mount.__grains__, {"kernel": "AIX"}):
        with patch.object(mount, "swaps", mock):
            assert mount.swapon("name") == {"s</b></font>tats": "name", "new": False}
    mock = MagicMock(return_value={})
    with patch.dict(mount.__grains__, {"kernel": "AIX"}):
        with patch.object(mount, "swaps", mock):
            mock = MagicMock(return_value=None)
            with patch.dict(mount.__salt__, {"cmd.run": mock}):
                assert mount.swapon("name", False) == {}
    mock = MagicMock(side_effect=[{}, {"name": "name"}])
    with patch.dict(mount.__grains__, {"kernel": "AIX"}):
        with patch.object(mount, "swaps", mock):
            mock = MagicMock(return_value=None)
            with patch.dict(mount.__salt__, {"cmd.run": mock}):
                assert mount.swapon("name") == {"stats": "name", "new": True}
def test_swapoff():
    """
    Deactivate a named swap mount
    """
    mock = MagicMock(return_value={})
    with patch.dict(mount.__grains__, {"kernel": ""}):
        with patch.object(mount, "swaps", mock):
            assert mount.swapoff("name") is None
    mock = MagicMock(return_value={"name": "name"})
    with patch.dict(mount.__grains__, {"kernel": ""}):
        with patch.object(mount, "swaps", mock):
            with patch.dict(mount.__grains__, {"os": "test"}):
                mock = MagicMock(return_value=None)
                with patch.dict(mount.__salt__, {"cmd.run": mock}):
                    assert not mount.swapoff("name")
    mock = MagicMock(side_effect=[{"name": "name"}, {}])
    with patch.dict(mount.__grains__, {"kernel": ""}):
        with patch.object(mount, "swaps", mock):
            with patch.dict(mount.__grains__, {"os": "test"}):
                mock = MagicMock(return_value=None)
                with patch.dict(mount.__salt__, {"cmd.run": mock}):
                    assert mount.swapoff("name")
    mock = MagicMock(return_value={})
    with patch.dict(mount.__grains__, {"kernel": "AIX"}):
        with patch.object(mount, "swaps", mock):
            assert mount.swapoff("name") is None
    mock = MagicMock(return_value={"name": "name"})
    with patch.dict(mount.__grains__, {"kernel": "AIX"}):
        with patch.object(mount, "swaps", mock):
            with patch.dict(mount.__grains__, {"os": "test"}):
                mock = MagicMock(return_value=None)
                with patch.dict(mount.__salt__, {"cmd.run": mock}):
                    assert not mount.swapoff("name")
    mock = MagicMock(side_effect=[{"name": "name"}, {}])
    with patch.dict(mount.__grains__, {"kernel": "AIX"}):
        with patch.object(mount, "swaps", mock):
            with patch.dict(mount.__grains__, {"os": "test"}):
                mock = MagicMock(return_value=None)
                with patch.dict(mount.__salt__, {"cmd.run": mock}):
                    assert mount.swapoff("name")
def test_is_mounted():
    """
    Provide information if the path is mounted
    """
    mock = MagicMock(return_value={})
    with patch.object(mount, "active", mock), patch.dict(
        mount.__grains__, {"kernel": ""}
    ):
        assert not mount.is_mounted("name")
    mock = MagicMock(return_value={"name": "name"})
    with patch.object(mount, "active", mock), patch.dict(
        mount.__grains__, {"kernel": ""}
    ):
        assert mount.is_mounted("name")
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
