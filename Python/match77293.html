<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_pycrypto.py &amp; test_boto_apigateway.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_pycrypto.py &amp; test_boto_apigateway.py
      </h3>
<h1 align="center">
        4.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_pycrypto.py (14.508928%)<th>test_boto_apigateway.py (2.4639878%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(235-241)<td><a href="#" name="0">(1385-1397)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(166-171)<td><a href="#" name="1">(1426-1445)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(85-87)<td><a href="#" name="2">(1532-1549)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(95-102)<td><a href="#" name="3">(418-457)</a><td align="center"><font color="#cc0000">12</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(44-52)<td><a href="#" name="4">(395-414)</a><td align="center"><font color="#cc0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_pycrypto.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import contextlib
2 import logging
3 import re
4 import string
5 import pytest
6 import salt.utils.platform
7 import salt.utils.pycrypto
8 from salt.exceptions import SaltInvocationError
9 from tests.support.mock import patch
10 passwd = "test_password"
11 invalid_salt = "thissaltistoolong" * 10
12 expecteds = {
13     "sha512": {
14         "hashed": "$6$rounds=65601$goodsalt$lZFhiN5M8RTLd9WKDin50H4lF4F8HGMIdwvKs.nTG7f8F0Y4P447Zb9/E8SkUWjY.K10QT3NuHZNDgc/P/NjT1",
15         "salt": "rounds=65601$goodsalt",
16         "badsalt": "badsalt",
17     },
18     "sha256": {
19         "hashed": "$5$rounds=53501$goodsalt$W.uoco0wMfGLDOlsbW52E6raFS1Nhj0McfUTj2vORt7",
20         "salt": "rounds=53501$goodsalt",
21         "badsalt": "badsalt",
22     },
23     "blowfish": {
24         "hashed": "$2b$10$goodsaltgoodsaltgoodsObFfGrJwfV.13QddrZIh2w1ccESmvj8K",
25         "salt": "10$goodsaltgoodsaltgoodsa",
26         "badsalt": "badsaltbadsaltbadsaltb",
27     },
28     "md5": {
29         "hashed": "$1$goodsalt$4XQMx4a4e1MpBB8xzz.TQ0",
30         "salt": "goodsalt",
31         "badsalt": "badsalt",
32     },
33     "crypt": {"hashed": "goVHulDpuGA7w", "salt": "go", "badsalt": "ba"},
34 }
35 @pytest.fixture(params=["sha512", "sha256", "blowfish", "md5", "crypt"])
36 def algorithm(request):
37 <a name="4"></a>    return request.param
38 @pytest.mark.skipif(not salt.utils.pycrypto.HAS_CRYPT, reason<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>="crypt not available")
39 @pytest.mark.parametrize(
40     "algorithm, expected",
41     [
42         ("sha512", expecteds["sha512"]),
43         ("sha256", expecteds["sha256"]),
44         ("blowfish", expecteds["blowfish"]),
45         ("md5", expecteds["md5"]),
46         ("crypt", expecteds[</b></font>"crypt"]),
47     ],
48 )
49 def test_gen_hash_crypt(algorithm, expected):
50     with patch("salt.utils.pycrypto.methods", {}):
51         ret = salt.utils.pycrypto.gen_hash(
52             crypt_salt=expected["salt"], password=passwd, algorithm=algorithm
53         )
54         assert ret == expected["hashed"]
55         ret = salt.utils.pycrypto.gen_hash(
56             crypt_salt=expected["badsalt"], password=passwd, algorithm=algorithm
57         )
58         assert ret != expected["hashed"]
59         ret = salt.utils.pycrypto.gen_hash(
60             crypt_salt=None, password=passwd, algorithm=algorithm
61         )
62         assert ret != expected["hashed"]
63 @pytest.mark.skipif(not salt.utils.pycrypto.HAS_CRYPT, reason="crypt not available")
64 def test_gen_hash_crypt_no_arguments():
65     assert salt.utils.pycrypto.gen_hash() is not None
66 <a name="2"></a>@pytest.mark.skipif(not salt.utils.pycrypto.HAS_CRYPT, reason="crypt not available")
67 def test_gen_hash_crypt_default_algorithm():
68     default_algorithm <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= salt.utils.pycrypto.crypt.methods[0].name.lower()
69     expected = expecteds[default_algorithm]
70     ret = salt.</b></font>utils.pycrypto.gen_hash(crypt_salt=expected["salt"], password=passwd)
71     assert ret == expected["hashed"]
72 @pytest.mark.skipif(not salt.utils.pycrypto.HAS_PASSLIB, reason="passlib not available")
73 <a name="3"></a>@pytest.mark.parametrize(
74     "algorithm, expected",
75     [
76         <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("sha512", expecteds["sha512"]),
77         ("sha256", expecteds["sha256"]),
78         ("blowfish", expecteds["blowfish"]),
79         ("md5", expecteds["md5"]),
80         ("crypt", expecteds["crypt"]),
81     ],
82 )
83 def</b></font> test_gen_hash_passlib(algorithm, expected):
84     with patch("salt.utils.pycrypto.methods", {}):
85         with patch("salt.utils.pycrypto.HAS_CRYPT", False):
86             ret = salt.utils.pycrypto.gen_hash(
87                 crypt_salt=expected["salt"], password=passwd, algorithm=algorithm
88             )
89             assert ret == expected["hashed"]
90             ret = salt.utils.pycrypto.gen_hash(
91                 crypt_salt=expected["badsalt"], password=passwd, algorithm=algorithm
92             )
93             assert ret != expected["hashed"]
94             ret = salt.utils.pycrypto.gen_hash(
95                 crypt_salt=None, password=passwd, algorithm=algorithm
96             )
97             assert ret != expected["hashed"]
98 @pytest.mark.skipif(not salt.utils.pycrypto.HAS_PASSLIB, reason="passlib not available")
99 def test_gen_hash_passlib_no_arguments():
100     assert salt.utils.pycrypto.gen_hash() is not None
101 def test_gen_hash_passlib_default_algorithm():
102     default_algorithm = salt.utils.pycrypto.known_methods[0]
103     expected = expecteds[default_algorithm]
104     if default_algorithm in expected:
105         ret = salt.utils.pycrypto.gen_hash(crypt_salt=expected["salt"], password=passwd)
106         assert ret == expected["hashed"]
107 def test_gen_hash_no_lib():
108     with patch("salt.utils.pycrypto.HAS_CRYPT", False):
109         with patch("salt.utils.pycrypto.HAS_PASSLIB", False):
110             with pytest.raises(SaltInvocationError):
111                 salt.utils.pycrypto.gen_hash()
112 def test_gen_hash_selection():
113     with patch("salt.utils.pycrypto.HAS_CRYPT", True):
114         with patch("salt.utils.pycrypto.methods", {"crypt": None}):
115             with patch("salt.utils.pycrypto.HAS_PASSLIB", True):
116                 with patch(
117                     "salt.utils.pycrypto._gen_hash_crypt", autospec=True
118                 ) as gh_crypt:
119                     with patch(
120                         "salt.utils.pycrypto._gen_hash_passlib", autospec=True
121                     ) as gh_passlib:
122 <a name="1"></a>                        with pytest.raises(SaltInvocationError):
123                             salt.utils.pycrypto.gen_hash(algorithm="doesntexist")
124                         salt<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.utils.pycrypto.gen_hash(algorithm="crypt")
125                         gh_crypt.assert_called_once()
126                         gh_passlib.assert_not_called()
127                         gh_crypt.reset_mock()
128                         salt.utils.</b></font>pycrypto.gen_hash(algorithm="sha512")
129                         gh_crypt.assert_not_called()
130                         gh_passlib.assert_called_once()
131 def test_gen_hash_crypt_warning(caplog):
132     with caplog.at_level(logging.WARNING):
133         with contextlib.suppress(Exception):
134             salt.utils.pycrypto.gen_hash(
135                 crypt_salt="toolong", password=passwd, algorithm="crypt"
136             )
137     assert "Hash salt is too long for 'crypt' hash." in caplog.text
138 def test_secure_password():
139     with patch("salt.utils.pycrypto.HAS_RANDOM", True):
140         ret = salt.utils.pycrypto.secure_password()
141         check = re.compile(r"[!@#$%^&amp;*()_=+]")
142         check_printable = re.compile(
143             r"[^{}]".format(
144                 re.escape(
145                     string.ascii_lowercase
146                     + string.ascii_uppercase
147                     + string.digits
148                     + string.punctuation
149                 )
150             )
151         )
152         check_whitespace = re.compile(r"[{}]".format(string.whitespace))
153         assert check_printable.search(ret) is None
154         assert check_whitespace.search(ret) is None
155         assert ret
156         assert salt.utils.pycrypto.secure_password(length=1, chars="A") == "A"
157         assert len(salt.utils.pycrypto.secure_password(length=64)) == 64
158 def test_secure_password_all_chars():
159     with patch("salt.utils.pycrypto.HAS_RANDOM", True):
160         ret = salt.utils.pycrypto.secure_password(
161             lowercase=True,
162             uppercase=True,
163             digits=True,
164             punctuation=True,
165             whitespace=True,
166             printable=True,
167         )
168         check = re.compile(r"[^{}]".format(re.escape(string.printable)))
169         assert check.search(ret) is None
170         assert ret
171 def test_secure_password_no_has_random():
172 <a name="0"></a>    """
173     test secure_password
174     with patch<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("salt.utils.pycrypto.HAS_RANDOM", False):
175         ret = salt.utils.pycrypto.secure_password()
176         check_printable = re.compile(
177             r"[^{}]".format(
178                 re.escape(
179                     string.ascii_lowercase
180                     + string.</b></font>ascii_uppercase
181                     + string.digits
182                     + string.punctuation
183                 )
184             )
185         )
186         check_whitespace = re.compile(r"[{}]".format(string.whitespace))
187         assert check_printable.search(ret) is None
188         assert check_whitespace.search(ret) is None
189         assert ret
190         assert salt.utils.pycrypto.secure_password(length=1, chars="A") == "A"
191         assert len(salt.utils.pycrypto.secure_password(length=64)) == 64
192 def test_secure_password_all_chars_no_has_random():
193     with patch("salt.utils.pycrypto.HAS_RANDOM", False):
194         ret = salt.utils.pycrypto.secure_password(printable=True)
195         check = re.compile("[^{}]".format(re.escape(string.printable)))
196         assert check.search(ret) is None
197         assert ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_boto_apigateway.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import datetime
2 import logging
3 import os
4 import random
5 import string
6 import pytest
7 import salt.config
8 import salt.loader
9 import salt.states.boto_apigateway as boto_apigateway
10 import salt.utils.files
11 import salt.utils.yaml
12 from salt.utils.versions import LooseVersion
13 from tests.support.mixins import LoaderModuleMockMixin
14 from tests.support.mock import MagicMock, patch
15 from tests.support.unit import TestCase, skipIf
16 from tests.unit.modules.test_boto_apigateway import BotoApiGatewayTestCaseMixin
17 try:
18     import boto3
19     import botocore
20     from botocore.exceptions import ClientError
21     HAS_BOTO = True
22 except ImportError:
23     HAS_BOTO = False
24 required_boto3_version = "1.2.1"
25 required_botocore_version = "1.4.49"
26 region = "us-east-1"
27 access_key = "GKTADJGHEIQSXMKKRBJ08H"
28 secret_key = "askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs"
29 conn_parameters = {
30     "region": region,
31     "key": access_key,
32     "keyid": secret_key,
33     "profile": {},
34 }
35 error_message = (
36     "An error occurred (101) when calling the {0} operation: Test-defined error"
37 )
38 error_content = {"Error": {"Code": 101, "Message": "Test-defined error"}}
39 api_ret = dict(
40     description=(
41         '{\n    "context": "See deployment or stage description",\n   '
42         ' "provisioned_by": "Salt boto_apigateway.present State"\n}'
43     ),
44     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
45     id="vni0vq8wzi",
46     name="unit test api",
47 )
48 no_apis_ret = {"items": []}
49 apis_ret = {"items": [api_ret]}
50 mock_model_ret = dict(
51     contentType="application/json",
52     description="mock model",
53     id="123abc",
54     name="mock model",
55     schema=(
56         "{\n"
57         '    "$schema": "http://json-schema.org/draft-04/schema#",\n'
58         '    "properties": {\n'
59         '        "field": {\n'
60         '            "type": "string"\n'
61         "        }\n"
62         "    }\n"
63         "}"
64     ),
65 )
66 models_ret = {
67     "items": [
68         dict(
69             contentType="application/json",
70             description="Error",
71             id="50nw8r",
72             name="Error",
73             schema=(
74                 "{\n"
75                 '    "$schema": "http://json-schema.org/draft-04/schema#",\n'
76                 '    "properties": {\n'
77                 '        "code": {\n'
78                 '            "format": "int32",\n'
79                 '            "type": "integer"\n'
80                 "        },\n"
81                 '        "fields": {\n'
82                 '            "type": "string"\n'
83                 "        },\n"
84                 '        "message": {\n'
85                 '            "type": "string"\n'
86                 "        }\n"
87                 "    },\n"
88                 '    "title": "Error Schema",\n'
89                 '    "type": "object"\n'
90                 "}"
91             ),
92         ),
93         dict(
94             contentType="application/json",
95             description="User",
96             id="terlnw",
97             name="User",
98             schema=(
99                 "{\n"
100                 '    "$schema": "http://json-schema.org/draft-04/schema#",\n'
101                 '    "properties": {\n'
102                 '        "password": {\n'
103                 '            "description": "A password for the new user",\n'
104                 '            "type": "string"\n'
105                 "        },\n"
106                 '        "username": {\n'
107                 '            "description": "A unique username for the user",\n'
108                 '            "type": "string"\n'
109                 "        }\n"
110                 "    },\n"
111                 '    "title": "User Schema",\n'
112                 '    "type": "object"\n'
113                 "}"
114             ),
115         ),
116     ]
117 }
118 root_resources_ret = {"items": [dict(id="bgk0rk8rqb", path="/")]}
119 resources_ret = {
120     "items": [
121         dict(id="bgk0rk8rqb", path="/"),
122         dict(
123             id="9waiaz",
124             parentId="bgk0rk8rqb",
125             path="/users",
126             pathPart="users",
127             resourceMethods={"POST": {}},
128         ),
129     ]
130 }
131 no_resources_ret = {"items": []}
132 stage1_deployment1_ret = dict(
133     cacheClusterEnabled=False,
134     cacheClusterSize=0.5,
135     cacheClusterStatus="NOT_AVAILABLE",
136     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
137     deploymentId="kobnrb",
138     description=(
139         "{\n"
140         '    "current_deployment_label": {\n'
141         '        "api_name": "unit test api",\n'
142         '        "swagger_file": "temp-swagger-sample.yaml",\n'
143         '        "swagger_file_md5sum": "4fb17e43bab3a96e7f2410a1597cd0a5",\n'
144         '        "swagger_info_object": {\n'
145         '            "description": "salt boto apigateway unit test service",\n'
146         '            "title": "salt boto apigateway unit test service",\n'
147         '            "version": "0.0.0"\n'
148         "        }\n"
149         "    }\n"
150         "}"
151     ),
152     lastUpdatedDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
153     methodSettings=dict(),
154     stageName="test",
155     variables=dict(),
156 )
157 stage1_deployment1_vars_ret = dict(
158     cacheClusterEnabled=False,
159     cacheClusterSize=0.5,
160     cacheClusterStatus="NOT_AVAILABLE",
161     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
162     deploymentId="kobnrb",
163     description=(
164         "{\n"
165         '    "current_deployment_label": {\n'
166         '        "api_name": "unit test api",\n'
167         '        "swagger_file": "temp-swagger-sample.yaml",\n'
168         '        "swagger_file_md5sum": "4fb17e43bab3a96e7f2410a1597cd0a5",\n'
169         '        "swagger_info_object": {\n'
170         '            "description": "salt boto apigateway unit test service",\n'
171         '            "title": "salt boto apigateway unit test service",\n'
172         '            "version": "0.0.0"\n'
173         "        }\n"
174         "    }\n"
175         "}"
176     ),
177     lastUpdatedDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
178     methodSettings=dict(),
179     stageName="test",
180     variables={"var1": "val1"},
181 )
182 stage1_deployment2_ret = dict(
183     cacheClusterEnabled=False,
184     cacheClusterSize=0.5,
185     cacheClusterStatus="NOT_AVAILABLE",
186     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
187     deploymentId="kobnrc",
188     description=(
189         "{\n"
190         '    "current_deployment_label": {\n'
191         '        "api_name": "unit test api",\n'
192         '        "swagger_file": "temp-swagger-sample.yaml",\n'
193         '        "swagger_file_md5sum": "5fd538c4336ed5c54b4bf39ddf97c661",\n'
194         '        "swagger_info_object": {\n'
195         '            "description": "salt boto apigateway unit test service",\n'
196         '            "title": "salt boto apigateway unit test service",\n'
197         '            "version": "0.0.2"\n'
198         "        }\n"
199         "    }\n"
200         "}"
201     ),
202     lastUpdatedDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
203     methodSettings=dict(),
204     stageName="test",
205     variables=dict(),
206 )
207 stage2_ret = dict(
208     cacheClusterEnabled=False,
209     cacheClusterSize=0.5,
210     cacheClusterStatus="NOT_AVAILABLE",
211     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
212     deploymentId="kobnrb",
213     description=(
214         "{\n"
215         '    "current_deployment_label": {\n'
216         '        "api_name": "unit test api",\n'
217         '        "swagger_file": "temp-swagger-sample.yaml",\n'
218         '        "swagger_file_md5sum": "4fb17e43bab3a96e7f2410a1597cd0a5",\n'
219         '        "swagger_info_object": {\n'
220         '            "description": "salt boto apigateway unit test service",\n'
221         '            "title": "salt boto apigateway unit test service",\n'
222         '            "version": "0.0.0"\n'
223         "        }\n"
224         "    }\n"
225         "}"
226     ),
227     lastUpdatedDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
228     methodSettings=dict(),
229     stageName="dev",
230     variables=dict(),
231 )
232 stages_stage2_ret = {"item": [stage2_ret]}
233 no_stages_ret = {"item": []}
234 deployment1_ret = dict(
235     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
236     description=(
237         "{\n"
238         '    "api_name": "unit test api",\n'
239         '    "swagger_file": "temp-swagger-sample.yaml",\n'
240         '    "swagger_file_md5sum": "55a948ff90ad80ff747ec91657c7a299",\n'
241         '    "swagger_info_object": {\n'
242         '        "description": "salt boto apigateway unit test service",\n'
243         '        "title": "salt boto apigateway unit test service",\n'
244         '        "version": "0.0.0"\n'
245         "    }\n"
246         "}"
247     ),
248     id="kobnrb",
249 )
250 deployment2_ret = dict(
251     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
252     description=(
253         "{\n"
254         '    "api_name": "unit test api",\n'
255         '    "swagger_file": "temp-swagger-sample.yaml",\n'
256         '    "swagger_file_md5sum": "5fd538c4336ed5c54b4bf39ddf97c661",\n'
257         '    "swagger_info_object": {\n'
258         '        "description": "salt boto apigateway unit test service",\n'
259         '        "title": "salt boto apigateway unit test service",\n'
260         '        "version": "0.0.2"\n'
261         "    }\n"
262         "}"
263     ),
264     id="kobnrc",
265 )
266 deployments_ret = {"items": [deployment1_ret, deployment2_ret]}
267 function_ret = dict(
268     FunctionName="unit_test_api_users_post",
269     Runtime="python2.7",
270     Role=None,
271     Handler="handler",
272     Description="abcdefg",
273     Timeout=5,
274     MemorySize=128,
275     CodeSha256="abcdef",
276     CodeSize=199,
277     FunctionArn="arn:lambda:us-east-1:1234:Something",
278     LastModified="yes",
279 )
280 method_integration_response_200_ret = dict(
281     responseParameters={"method.response.header.Access-Control-Allow-Origin": "*"},
282     responseTemplates={},
283     selectionPattern=".*",
284     statusCode="200",
285 )
286 method_integration_ret = dict(
287     cacheKeyParameters={},
288     cacheNamespace="9waiaz",
289     credentials="arn:aws:iam::1234:role/apigatewayrole",
290     httpMethod="POST",
291     integrationResponses={"200": method_integration_response_200_ret},
292     requestParameters={},
293     requestTemplates={
294         "application/json": (
295             "#set($inputRoot = $input.path('$')){\"header-params\" : {#set ($map ="
296             ' $input.params().header)#foreach( $param in $map.entrySet() )"$param.key"'
297             ' : "$param.value" #if( $foreach.hasNext ), #end#end},"query-params" :'
298             " {#set ($map = $input.params().querystring)#foreach( $param in"
299             ' $map.entrySet() )"$param.key" : "$param.value" #if( $foreach.hasNext ),'
300             ' #end#end},"path-params" : {#set ($map = $input.params().path)#foreach('
301             ' $param in $map.entrySet() )"$param.key" : "$param.value" #if('
302             " $foreach.hasNext ), #end#end},\"body-params\" : $input.json('$')}"
303         )
304     },
305     type="AWS",
306     uri=(
307         "arn:aws:apigateway:us-west-2:"
308         "lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:1234567:"
309         "function:unit_test_api_api_users_post/invocations"
310     ),
311 )
312 method_response_200_ret = dict(
313     responseModels={"application/json": "User"},
314     responseParameters={"method.response.header.Access-Control-Allow-Origin": False},
315     statusCode="200",
316 )
317 method_ret = dict(
318     apiKeyRequired=False,
319     authorizationType="None",
320     httpMethod="POST",
321     methodIntegration=method_integration_ret,
322     methodResponses={"200": method_response_200_ret},
323     requestModels={"application/json": "User"},
324     requestParameters={},
325 )
326 throttle_rateLimit = 10.0
327 association_stage_1 = {"apiId": "apiId1", "stage": "stage1"}
328 association_stage_2 = {"apiId": "apiId1", "stage": "stage2"}
329 log = logging.getLogger(__name__)
330 def _has_required_boto():
331     if not HAS_BOTO:
332         return False
333     elif LooseVersion(boto3.__version__) &lt; LooseVersion(required_boto3_version):
334         return False
335     else:
336         return True
337 def _has_required_botocore():
338     if not HAS_BOTO:
339         return False
340     elif LooseVersion(botocore.__version__) &lt; LooseVersion(required_botocore_version):
341         return False
342     else:
343         return True
344 <a name="4"></a>
345 class TempSwaggerFile:
346     _tmp_swagger_dict <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= {
347         "info": {
348             "version": "0.0.0",
349             "description": "salt boto apigateway unit test service",
350             "title": "salt boto apigateway unit test service",
351         },
352         "paths": {
353             "/users": {
354                 "post": {
355                     "responses": {
356                         "200": {
357                             "headers": {
358                                 "Access-Control-Allow-Origin": {"type": "string"}
359                             },
360                             "description": "The username of the new user",
361                             "schema": {"$ref": "#/definitions/User"},
362                         }
363                     },
364                     "parameters": [
365                         {</b></font>
366 <a name="3"></a>                            "in": "body",
367                             "description": "New user details.",
368                             "name": "NewUser",
369                             "schema": {<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"$ref": "#/definitions/User"},
370                         }
371                     ],
372                     "produces": ["application/json"],
373                     "description": "Creates a new user.",
374                     "tags": ["Auth"],
375                     "consumes": ["application/json"],
376                     "summary": "Registers a new user",
377                 }
378             }
379         },
380         "schemes": ["https"],
381         "produces": ["application/json"],
382         "basePath": "/api",
383         "host": "rm06h9oac4.execute-api.us-west-2.amazonaws.com",
384         "definitions": {
385             "User": {
386                 "properties": {
387                     "username": {
388                         "type": "string",
389                         "description": "A unique username for the user",
390                     },
391                     "password": {
392                         "type": "string",
393                         "description": "A password for the new user",
394                     },
395                 }
396             },
397             "Error": {
398                 "properties": {
399                     "fields": {"type": "string"},
400                     "message": {"type": "string"},
401                     "code": {"type": "integer", "format": "int32"},
402                 }
403             },
404         },
405         "swagger": "2.0",
406     }
407     def</b></font> __enter__(self):
408         self.swaggerfile = "temp-swagger-sample.yaml"
409         with salt.utils.files.fopen(self.swaggerfile, "w") as fp_:
410             salt.utils.yaml.safe_dump(self.swaggerdict, fp_, default_flow_style=False)
411         return self.swaggerfile
412     def __exit__(self, objtype, value, traceback):
413         os.remove(self.swaggerfile)
414     def __init__(self, create_invalid_file=False):
415         if create_invalid_file:
416             self.swaggerdict = TempSwaggerFile._tmp_swagger_dict.copy()
417             self.swaggerdict["invalid_key"] = "invalid"
418             self.swaggerdict.pop("schemes", None)
419             self.swaggerdict["swagger"] = "3.0"
420             self.swaggerdict.pop("info", None)
421         else:
422             self.swaggerdict = TempSwaggerFile._tmp_swagger_dict
423 class BotoApiGatewayStateTestCaseBase(TestCase, LoaderModuleMockMixin):
424     conn = None
425     @classmethod
426     def setUpClass(cls):
427         cls.opts = salt.config.DEFAULT_MINION_OPTS.copy()
428         cls.opts["grains"] = salt.loader.grains(cls.opts)
429     @classmethod
430     def tearDownClass(cls):
431         del cls.opts
432     def setup_loader_modules(self):
433         context = {}
434         utils = salt.loader.utils(
435             self.opts,
436             whitelist=["boto", "boto3", "args", "systemd", "path", "platform", "reg"],
437             context=context,
438         )
439         serializers = salt.loader.serializers(self.opts)
440         self.funcs = salt.loader.minion_mods(
441             self.opts, context=context, utils=utils, whitelist=["boto_apigateway"]
442         )
443         self.salt_states = salt.loader.states(
444             opts=self.opts,
445             functions=self.funcs,
446             utils=utils,
447             whitelist=["boto_apigateway"],
448             serializers=serializers,
449         )
450         return {
451             boto_apigateway: {
452                 "__opts__": self.opts,
453                 "__utils__": utils,
454                 "__salt__": self.funcs,
455                 "__states__": self.salt_states,
456                 "__serializers__": serializers,
457             }
458         }
459     def setUp(self):
460         self.addCleanup(delattr, self, "funcs")
461         self.addCleanup(delattr, self, "salt_states")
462         conn_parameters["key"] = "".join(
463             random.choice(string.ascii_lowercase + string.digits) for _ in range(50)
464         )
465         patcher = patch("boto3.session.Session")
466         self.addCleanup(patcher.stop)
467         mock_session = patcher.start()
468         session_instance = mock_session.return_value
469         self.conn = MagicMock()
470         self.addCleanup(delattr, self, "conn")
471         session_instance.client.return_value = self.conn
472 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
473 @skipIf(
474     _has_required_boto() is False,
475     "The boto3 module must be greater than or equal to version {}".format(
476         required_boto3_version
477     ),
478 )
479 class BotoApiGatewayTestCase(
480     BotoApiGatewayStateTestCaseBase, BotoApiGatewayTestCaseMixin
481 ):
482     def test_present_when_swagger_file_is_invalid(self):
483         result = {}
484         with TempSwaggerFile(create_invalid_file=True) as swagger_file:
485             result = self.salt_states["boto_apigateway.present"](
486                 "api present",
487                 "unit test api",
488                 swagger_file,
489                 "test",
490                 False,
491                 "arn:aws:iam::1234:role/apigatewayrole",
492                 **conn_parameters
493             )
494         self.assertFalse(result.get("result", True))
495     def test_present_when_stage_is_already_at_desired_deployment(self):
496         self.conn.get_rest_apis.return_value = apis_ret
497         self.conn.get_deployment.return_value = deployment1_ret
498         self.conn.get_stage.return_value = stage1_deployment1_ret
499         self.conn.update_stage.side_effect = ClientError(
500             error_content, "update_stage should not be called"
501         )
502         result = {}
503         with TempSwaggerFile() as swagger_file:
504             result = self.salt_states["boto_apigateway.present"](
505                 "api present",
506                 "unit test api",
507                 swagger_file,
508                 "test",
509                 False,
510                 "arn:aws:iam::1234:role/apigatewayrole",
511                 **conn_parameters
512             )
513         self.assertFalse(result.get("abort"))
514         self.assertTrue(result.get("current"))
515         self.assertIs(result.get("result"), True)
516         self.assertNotIn("update_stage should not be called", result.get("comment", ""))
517     def test_present_when_stage_is_already_at_desired_deployment_and_needs_stage_variables_update(
518         self,
519     ):
520         self.conn.get_rest_apis.return_value = apis_ret
521         self.conn.get_deployment.return_value = deployment1_ret
522         self.conn.get_stage.return_value = stage1_deployment1_ret
523         self.conn.update_stage.return_value = stage1_deployment1_vars_ret
524         result = {}
525         with TempSwaggerFile() as swagger_file:
526             result = self.salt_states["boto_apigateway.present"](
527                 "api present",
528                 "unit test api",
529                 swagger_file,
530                 "test",
531                 False,
532                 "arn:aws:iam::1234:role/apigatewayrole",
533                 stage_variables={"var1": "val1"},
534                 **conn_parameters
535             )
536         self.assertFalse(result.get("abort"))
537         self.assertTrue(result.get("current"))
538         self.assertIs(result.get("result"), True)
539     def test_present_when_stage_exists_and_is_to_associate_to_existing_deployment(self):
540         self.conn.get_rest_apis.return_value = apis_ret
541         self.conn.get_deployment.return_value = deployment2_ret
542         self.conn.get_deployments.return_value = deployments_ret
543         self.conn.get_stage.return_value = stage1_deployment2_ret
544         self.conn.update_stage.return_value = stage1_deployment1_ret
545         self.conn.create_stage.side_effect = ClientError(error_content, "create_stage")
546         self.conn.create_deployment.side_effect = ClientError(
547             error_content, "create_deployment"
548         )
549         result = {}
550         with TempSwaggerFile() as swagger_file:
551             result = self.salt_states["boto_apigateway.present"](
552                 "api present",
553                 "unit test api",
554                 swagger_file,
555                 "test",
556                 False,
557                 "arn:aws:iam::1234:role/apigatewayrole",
558                 **conn_parameters
559             )
560         self.assertTrue(result.get("publish"))
561         self.assertIs(result.get("result"), True)
562         self.assertFalse(result.get("abort"))
563         self.assertTrue(result.get("changes", {}).get("new", [{}])[0])
564     @pytest.mark.slow_test
565     def test_present_when_stage_is_to_associate_to_new_deployment(self):
566         self.conn.get_rest_apis.return_value = no_apis_ret
567         self.conn.create_rest_api.return_value = api_ret
568         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
569         self.conn.create_model.return_value = mock_model_ret
570         self.conn.get_resources.return_value = resources_ret
571         self.conn.create_resource.side_effect = ClientError(
572             error_content, "create_resource"
573         )
574         self.conn.put_method.return_value = method_ret
575         self.conn.put_integration.return_value = method_integration_ret
576         self.conn.put_method_response.return_value = method_response_200_ret
577         self.conn.put_intgration_response.return_value = (
578             method_integration_response_200_ret
579         )
580         result = {}
581         with patch.dict(
582             self.funcs,
583             {
584                 "boto_lambda.describe_function": MagicMock(
585                     return_value={"function": function_ret}
586                 )
587             },
588         ):
589             with TempSwaggerFile() as swagger_file:
590                 result = self.salt_states["boto_apigateway.present"](
591                     "api present",
592                     "unit test api",
593                     swagger_file,
594                     "test",
595                     False,
596                     "arn:aws:iam::1234:role/apigatewayrole",
597                     **conn_parameters
598                 )
599         self.assertIs(result.get("result"), True)
600         self.assertIs(result.get("abort"), None)
601     def test_present_when_stage_associating_to_new_deployment_errored_on_api_creation(
602         self,
603     ):
604         self.conn.get_rest_apis.return_value = no_apis_ret
605         self.conn.create_rest_api.side_effect = ClientError(
606             error_content, "create_rest_api"
607         )
608         result = {}
609         with TempSwaggerFile() as swagger_file:
610             result = self.salt_states["boto_apigateway.present"](
611                 "api present",
612                 "unit test api",
613                 swagger_file,
614                 "test",
615                 False,
616                 "arn:aws:iam::1234:role/apigatewayrole",
617                 **conn_parameters
618             )
619         self.assertIs(result.get("abort"), True)
620         self.assertIs(result.get("result"), False)
621         self.assertIn("create_rest_api", result.get("comment", ""))
622     def test_present_when_stage_associating_to_new_deployment_errored_on_model_creation(
623         self,
624     ):
625         self.conn.get_rest_apis.return_value = no_apis_ret
626         self.conn.create_rest_api.return_value = api_ret
627         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
628         self.conn.create_model.side_effect = ClientError(error_content, "create_model")
629         result = {}
630         with TempSwaggerFile() as swagger_file:
631             result = self.salt_states["boto_apigateway.present"](
632                 "api present",
633                 "unit test api",
634                 swagger_file,
635                 "test",
636                 False,
637                 "arn:aws:iam::1234:role/apigatewayrole",
638                 **conn_parameters
639             )
640         self.assertIs(result.get("abort"), True)
641         self.assertIs(result.get("result"), False)
642         self.assertIn("create_model", result.get("comment", ""))
643     def test_present_when_stage_associating_to_new_deployment_errored_on_resource_creation(
644         self,
645     ):
646         self.conn.get_rest_apis.return_value = no_apis_ret
647         self.conn.create_rest_api.return_value = api_ret
648         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
649         self.conn.create_model.return_value = mock_model_ret
650         self.conn.get_resources.return_value = root_resources_ret
651         self.conn.create_resource.side_effect = ClientError(
652             error_content, "create_resource"
653         )
654         result = {}
655         with TempSwaggerFile() as swagger_file:
656             result = self.salt_states["boto_apigateway.present"](
657                 "api present",
658                 "unit test api",
659                 swagger_file,
660                 "test",
661                 False,
662                 "arn:aws:iam::1234:role/apigatewayrole",
663                 **conn_parameters
664             )
665         self.assertIs(result.get("abort"), True)
666         self.assertIs(result.get("result"), False)
667         self.assertIn("create_resource", result.get("comment", ""))
668     @pytest.mark.slow_test
669     def test_present_when_stage_associating_to_new_deployment_errored_on_put_method(
670         self,
671     ):
672         self.conn.get_rest_apis.return_value = no_apis_ret
673         self.conn.create_rest_api.return_value = api_ret
674         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
675         self.conn.create_model.return_value = mock_model_ret
676         self.conn.get_resources.return_value = resources_ret
677         self.conn.create_resource.side_effect = ClientError(
678             error_content, "create_resource"
679         )
680         self.conn.put_method.side_effect = ClientError(error_content, "put_method")
681         result = {}
682         with patch.dict(
683             self.funcs,
684             {
685                 "boto_lambda.describe_function": MagicMock(
686                     return_value={"function": function_ret}
687                 )
688             },
689         ):
690             with TempSwaggerFile() as swagger_file:
691                 result = self.salt_states["boto_apigateway.present"](
692                     "api present",
693                     "unit test api",
694                     swagger_file,
695                     "test",
696                     False,
697                     "arn:aws:iam::1234:role/apigatewayrole",
698                     **conn_parameters
699                 )
700         self.assertIs(result.get("abort"), True)
701         self.assertIs(result.get("result"), False)
702         self.assertIn("put_method", result.get("comment", ""))
703     @pytest.mark.slow_test
704     def test_present_when_stage_associating_to_new_deployment_errored_on_lambda_function_lookup(
705         self,
706     ):
707         self.conn.get_rest_apis.return_value = no_apis_ret
708         self.conn.create_rest_api.return_value = api_ret
709         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
710         self.conn.create_model.return_value = mock_model_ret
711         self.conn.get_resources.return_value = resources_ret
712         self.conn.create_resource.side_effect = ClientError(
713             error_content, "create_resource"
714         )
715         self.conn.put_method.return_value = method_ret
716         self.conn.put_integration.side_effect = ClientError(
717             error_content, "put_integration should not be invoked"
718         )
719         result = {}
720         with patch.dict(
721             self.funcs,
722             {
723                 "boto_lambda.describe_function": MagicMock(
724                     return_value={"error": "no such lambda"}
725                 )
726             },
727         ):
728             with TempSwaggerFile() as swagger_file:
729                 result = self.salt_states["boto_apigateway.present"](
730                     "api present",
731                     "unit test api",
732                     swagger_file,
733                     "test",
734                     False,
735                     "arn:aws:iam::1234:role/apigatewayrole",
736                     **conn_parameters
737                 )
738         self.assertIs(result.get("result"), False)
739         self.assertNotIn(
740             "put_integration should not be invoked", result.get("comment", "")
741         )
742         self.assertIn("not find lambda function", result.get("comment", ""))
743     @pytest.mark.slow_test
744     def test_present_when_stage_associating_to_new_deployment_errored_on_put_integration(
745         self,
746     ):
747         self.conn.get_rest_apis.return_value = no_apis_ret
748         self.conn.create_rest_api.return_value = api_ret
749         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
750         self.conn.create_model.return_value = mock_model_ret
751         self.conn.get_resources.return_value = resources_ret
752         self.conn.create_resource.side_effect = ClientError(
753             error_content, "create_resource"
754         )
755         self.conn.put_method.return_value = method_ret
756         self.conn.put_integration.side_effect = ClientError(
757             error_content, "put_integration"
758         )
759         result = {}
760         with patch.dict(
761             self.funcs,
762             {
763                 "boto_lambda.describe_function": MagicMock(
764                     return_value={"function": function_ret}
765                 )
766             },
767         ):
768             with TempSwaggerFile() as swagger_file:
769                 result = self.salt_states["boto_apigateway.present"](
770                     "api present",
771                     "unit test api",
772                     swagger_file,
773                     "test",
774                     False,
775                     "arn:aws:iam::1234:role/apigatewayrole",
776                     **conn_parameters
777                 )
778         self.assertIs(result.get("abort"), True)
779         self.assertIs(result.get("result"), False)
780         self.assertIn("put_integration", result.get("comment", ""))
781     @pytest.mark.slow_test
782     def test_present_when_stage_associating_to_new_deployment_errored_on_put_method_response(
783         self,
784     ):
785         self.conn.get_rest_apis.return_value = no_apis_ret
786         self.conn.create_rest_api.return_value = api_ret
787         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
788         self.conn.create_model.return_value = mock_model_ret
789         self.conn.get_resources.return_value = resources_ret
790         self.conn.create_resource.side_effect = ClientError(
791             error_content, "create_resource"
792         )
793         self.conn.put_method.return_value = method_ret
794         self.conn.put_integration.return_value = method_integration_ret
795         self.conn.put_method_response.side_effect = ClientError(
796             error_content, "put_method_response"
797         )
798         result = {}
799         with patch.dict(
800             self.funcs,
801             {
802                 "boto_lambda.describe_function": MagicMock(
803                     return_value={"function": function_ret}
804                 )
805             },
806         ):
807             with TempSwaggerFile() as swagger_file:
808                 result = self.salt_states["boto_apigateway.present"](
809                     "api present",
810                     "unit test api",
811                     swagger_file,
812                     "test",
813                     False,
814                     "arn:aws:iam::1234:role/apigatewayrole",
815                     **conn_parameters
816                 )
817         self.assertIs(result.get("abort"), True)
818         self.assertIs(result.get("result"), False)
819         self.assertIn("put_method_response", result.get("comment", ""))
820     @pytest.mark.slow_test
821     def test_present_when_stage_associating_to_new_deployment_errored_on_put_integration_response(
822         self,
823     ):
824         self.conn.get_rest_apis.return_value = no_apis_ret
825         self.conn.create_rest_api.return_value = api_ret
826         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
827         self.conn.create_model.return_value = mock_model_ret
828         self.conn.get_resources.return_value = resources_ret
829         self.conn.create_resource.side_effect = ClientError(
830             error_content, "create_resource"
831         )
832         self.conn.put_method.return_value = method_ret
833         self.conn.put_integration.return_value = method_integration_ret
834         self.conn.put_method_response.return_value = method_response_200_ret
835         self.conn.put_integration_response.side_effect = ClientError(
836             error_content, "put_integration_response"
837         )
838         result = {}
839         with patch.dict(
840             self.funcs,
841             {
842                 "boto_lambda.describe_function": MagicMock(
843                     return_value={"function": function_ret}
844                 )
845             },
846         ):
847             with TempSwaggerFile() as swagger_file:
848                 result = self.salt_states["boto_apigateway.present"](
849                     "api present",
850                     "unit test api",
851                     swagger_file,
852                     "test",
853                     False,
854                     "arn:aws:iam::1234:role/apigatewayrole",
855                     **conn_parameters
856                 )
857         self.assertIs(result.get("abort"), True)
858         self.assertIs(result.get("result"), False)
859         self.assertIn("put_integration_response", result.get("comment", ""))
860     def test_absent_when_rest_api_does_not_exist(self):
861         self.conn.get_rest_apis.return_value = apis_ret
862         self.conn.get_stage.side_effect = ClientError(
863             error_content, "get_stage should not be called"
864         )
865         result = self.salt_states["boto_apigateway.absent"](
866             "api present",
867             "no_such_rest_api",
868             "no_such_stage",
869             nuke_api=False,
870             **conn_parameters
871         )
872         self.assertIs(result.get("result"), True)
873         self.assertNotIn("get_stage should not be called", result.get("comment", ""))
874         self.assertEqual(result.get("changes"), {})
875     def test_absent_when_stage_is_invalid(self):
876         self.conn.get_rest_apis.return_value = apis_ret
877         self.conn.get_stage.return_value = stage1_deployment1_ret
878         self.conn.delete_stage.side_effect = ClientError(error_content, "delete_stage")
879         result = self.salt_states["boto_apigateway.absent"](
880             "api present",
881             "unit test api",
882             "no_such_stage",
883             nuke_api=False,
884             **conn_parameters
885         )
886         self.assertTrue(result.get("abort", False))
887     def test_absent_when_stage_is_valid_and_only_one_stage_is_associated_to_deployment(
888         self,
889     ):
890         self.conn.get_rest_apis.return_value = apis_ret
891         self.conn.get_stage.return_value = stage1_deployment1_ret
892         self.conn.delete_stage.return_value = {
893             "ResponseMetadata": {
894                 "HTTPStatusCode": 200,
895                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
896             }
897         }
898         self.conn.get_stages.return_value = no_stages_ret
899         self.conn.delete_deployment.return_value = {
900             "ResponseMetadata": {
901                 "HTTPStatusCode": 200,
902                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
903             }
904         }
905         result = self.salt_states["boto_apigateway.absent"](
906             "api present", "unit test api", "test", nuke_api=False, **conn_parameters
907         )
908         self.assertTrue(result.get("result", False))
909     def test_absent_when_stage_is_valid_and_two_stages_are_associated_to_deployment(
910         self,
911     ):
912         self.conn.get_rest_apis.return_value = apis_ret
913         self.conn.get_stage.return_value = stage1_deployment1_ret
914         self.conn.delete_stage.return_value = {
915             "ResponseMetadata": {
916                 "HTTPStatusCode": 200,
917                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
918             }
919         }
920         self.conn.get_stages.return_value = stages_stage2_ret
921         result = self.salt_states["boto_apigateway.absent"](
922             "api present", "unit test api", "test", nuke_api=False, **conn_parameters
923         )
924         self.assertTrue(result.get("result", False))
925     def test_absent_when_failing_to_delete_a_deployment_no_longer_associated_with_any_stages(
926         self,
927     ):
928         self.conn.get_rest_apis.return_value = apis_ret
929         self.conn.get_stage.return_value = stage1_deployment1_ret
930         self.conn.delete_stage.return_value = {
931             "ResponseMetadata": {
932                 "HTTPStatusCode": 200,
933                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
934             }
935         }
936         self.conn.get_stages.return_value = no_stages_ret
937         self.conn.delete_deployment.side_effect = ClientError(
938             error_content, "delete_deployment"
939         )
940         result = self.salt_states["boto_apigateway.absent"](
941             "api present", "unit test api", "test", nuke_api=False, **conn_parameters
942         )
943         self.assertTrue(result.get("abort", False))
944     def test_absent_when_nuke_api_and_no_more_stages_deployments_remain(self):
945         self.conn.get_rest_apis.return_value = apis_ret
946         self.conn.get_stage.return_value = stage1_deployment1_ret
947         self.conn.delete_stage.return_value = {
948             "ResponseMetadata": {
949                 "HTTPStatusCode": 200,
950                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
951             }
952         }
953         self.conn.get_stages.return_value = no_stages_ret
954         self.conn.get_deployments.return_value = deployments_ret
955         self.conn.delete_rest_api.return_value = {
956             "ResponseMetadata": {
957                 "HTTPStatusCode": 200,
958                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
959             }
960         }
961         result = self.salt_states["boto_apigateway.absent"](
962             "api present", "unit test api", "test", nuke_api=True, **conn_parameters
963         )
964         self.assertIs(result.get("result"), True)
965         self.assertIsNot(result.get("abort"), True)
966         self.assertIs(
967             result.get("changes", {})
968             .get("new", [{}])[0]
969             .get("delete_api", {})
970             .get("deleted"),
971             True,
972         )
973     def test_absent_when_nuke_api_and_other_stages_deployments_exist(self):
974         self.conn.get_rest_apis.return_value = apis_ret
975         self.conn.get_stage.return_value = stage1_deployment1_ret
976         self.conn.delete_stage.return_value = {
977             "ResponseMetadata": {
978                 "HTTPStatusCode": 200,
979                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
980             }
981         }
982         self.conn.get_stages.return_value = stages_stage2_ret
983         self.conn.get_deployments.return_value = deployments_ret
984         self.conn.delete_rest_api.side_effect = ClientError(
985             error_content, "unexpected_api_delete"
986         )
987         result = self.salt_states["boto_apigateway.absent"](
988             "api present", "unit test api", "test", nuke_api=True, **conn_parameters
989         )
990         self.assertIs(result.get("result"), True)
991         self.assertIsNot(result.get("abort"), True)
992 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
993 @skipIf(
994     _has_required_boto() is False,
995     "The boto3 module must be greater than or equal to version {}".format(
996         required_boto3_version
997     ),
998 )
999 @skipIf(
1000     _has_required_botocore() is False,
1001     "The botocore module must be greater than or equal to version {}".format(
1002         required_botocore_version
1003     ),
1004 )
1005 class BotoApiGatewayUsagePlanTestCase(
1006     BotoApiGatewayStateTestCaseBase, BotoApiGatewayTestCaseMixin
1007 ):
1008     @pytest.mark.slow_test
1009     def test_usage_plan_present_if_describe_fails(self, *args):
1010         with patch.dict(
1011             boto_apigateway.__salt__,
1012             {
1013                 "boto_apigateway.describe_usage_plans": MagicMock(
1014                     return_value={"error": "error"}
1015                 )
1016             },
1017         ):
1018             result = boto_apigateway.usage_plan_present(
1019                 "name", "plan_name", **conn_parameters
1020             )
1021             self.assertIn("result", result)
1022             self.assertEqual(result["result"], False)
1023             self.assertIn("comment", result)
1024             self.assertEqual(
1025                 result["comment"], "Failed to describe existing usage plans"
1026             )
1027             self.assertIn("changes", result)
1028             self.assertEqual(result["changes"], {})
1029     @pytest.mark.slow_test
1030     def test_usage_plan_present_if_there_is_no_such_plan_and_test_option_is_set(
1031         self, *args
1032     ):
1033         with patch.dict(boto_apigateway.__opts__, {"test": True}):
1034             with patch.dict(
1035                 boto_apigateway.__salt__,
1036                 {
1037                     "boto_apigateway.describe_usage_plans": MagicMock(
1038                         return_value={"plans": []}
1039                     )
1040                 },
1041             ):
1042                 result = boto_apigateway.usage_plan_present(
1043                     "name", "plan_name", **conn_parameters
1044                 )
1045                 self.assertIn("comment", result)
1046                 self.assertEqual(
1047                     result["comment"], "a new usage plan plan_name would be created"
1048                 )
1049                 self.assertIn("result", result)
1050                 self.assertEqual(result["result"], None)
1051     @pytest.mark.slow_test
1052     def test_usage_plan_present_if_create_usage_plan_fails(self, *args):
1053         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1054             with patch.dict(
1055                 boto_apigateway.__salt__,
1056                 {
1057                     "boto_apigateway.describe_usage_plans": MagicMock(
1058                         return_value={"plans": []}
1059                     ),
1060                     "boto_apigateway.create_usage_plan": MagicMock(
1061                         return_value={"error": "error"}
1062                     ),
1063                 },
1064             ):
1065                 result = boto_apigateway.usage_plan_present(
1066                     "name", "plan_name", **conn_parameters
1067                 )
1068                 self.assertIn("result", result)
1069                 self.assertEqual(result["result"], False)
1070                 self.assertIn("comment", result)
1071                 self.assertEqual(
1072                     result["comment"], "Failed to create a usage plan plan_name, error"
1073                 )
1074                 self.assertIn("changes", result)
1075                 self.assertEqual(result["changes"], {})
1076     @pytest.mark.slow_test
1077     def test_usage_plan_present_if_plan_is_there_and_needs_no_updates(self, *args):
1078         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1079 <a name="0"></a>            with patch.dict(
1080                 boto_apigateway.__salt__,
1081                 {
1082                     "boto_apigateway.describe_usage_plans": MagicMock<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(
1083                         return_value={"plans": [{"id": "planid", "name": "planname"}]}
1084                     ),
1085                     "boto_apigateway.update_usage_plan": MagicMock(),
1086                 },
1087             ):
1088                 result = boto_apigateway.usage_plan_present(
1089                     "name", "plan_name", **conn_parameters
1090                 )
1091                 self.assertIn("result", result)
1092                 self.assertEqual(result["result"], True)
1093                 self.</b></font>assertIn("comment", result)
1094                 self.assertEqual(
1095                     result["comment"],
1096                     "usage plan plan_name is already in a correct state",
1097                 )
1098                 self.assertIn("changes", result)
1099                 self.assertEqual(result["changes"], {})
1100                 self.assertTrue(
1101                     boto_apigateway.__salt__[
1102                         "boto_apigateway.update_usage_plan"
1103                     ].call_count
1104                     == 0
1105                 )
1106     @pytest.mark.slow_test
1107     def test_usage_plan_present_if_plan_is_there_and_needs_updates_but_test_is_set(
1108         self, *args
1109     ):
1110         with patch.dict(boto_apigateway.__opts__, {"test": True}):
1111             with patch.dict(
1112                 boto_apigateway.__salt__,
1113                 {
1114 <a name="1"></a>                    "boto_apigateway.describe_usage_plans": MagicMock(
1115                         return_value={
1116                             "plans": [
1117                                 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
1118                                     "id": "planid",
1119                                     "name": "planname",
1120                                     "throttle": {"rateLimit": 10.0},
1121                                 }
1122                             ]
1123                         }
1124                     ),
1125                     "boto_apigateway.update_usage_plan": MagicMock(),
1126                 },
1127             ):
1128                 result = boto_apigateway.usage_plan_present(
1129                     "name", "plan_name", **conn_parameters
1130                 )
1131                 self.assertIn("comment", result)
1132                 self.assertEqual(
1133                     result["comment"], "a new usage plan plan_name would be updated"
1134                 )
1135                 self.</b></font>assertIn("result", result)
1136                 self.assertEqual(result["result"], None)
1137                 self.assertTrue(
1138                     boto_apigateway.__salt__[
1139                         "boto_apigateway.update_usage_plan"
1140                     ].call_count
1141                     == 0
1142                 )
1143     @pytest.mark.slow_test
1144     def test_usage_plan_present_if_plan_is_there_and_needs_updates_but_update_fails(
1145         self, *args
1146     ):
1147         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1148             with patch.dict(
1149                 boto_apigateway.__salt__,
1150                 {
1151                     "boto_apigateway.describe_usage_plans": MagicMock(
1152                         return_value={
1153                             "plans": [
1154                                 {
1155                                     "id": "planid",
1156                                     "name": "planname",
1157                                     "throttle": {"rateLimit": 10.0},
1158                                 }
1159                             ]
1160                         }
1161                     ),
1162                     "boto_apigateway.update_usage_plan": MagicMock(
1163                         return_value={"error": "error"}
1164                     ),
1165                 },
1166             ):
1167                 result = boto_apigateway.usage_plan_present(
1168                     "name", "plan_name", **conn_parameters
1169                 )
1170                 self.assertIn("result", result)
1171                 self.assertEqual(result["result"], False)
1172                 self.assertIn("comment", result)
1173                 self.assertEqual(
1174                     result["comment"], "Failed to update a usage plan plan_name, error"
1175                 )
1176     @pytest.mark.slow_test
1177     def test_usage_plan_present_if_plan_has_been_created(self, *args):
1178         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1179             with patch.dict(
1180                 boto_apigateway.__salt__,
1181                 {
1182                     "boto_apigateway.describe_usage_plans": MagicMock(
1183                         side_effect=[{"plans": []}, {"plans": [{"id": "id"}]}]
1184                     ),
1185                     "boto_apigateway.create_usage_plan": MagicMock(
1186                         return_value={"created": True}
1187                     ),
1188                 },
1189             ):
1190                 result = boto_apigateway.usage_plan_present(
1191                     "name", "plan_name", **conn_parameters
1192                 )
1193                 self.assertIn("result", result)
1194                 self.assertEqual(result["result"], True)
1195                 self.assertIn("comment", result)
1196                 self.assertEqual(
1197                     result["comment"], "A new usage plan plan_name has been created"
1198                 )
1199                 self.assertEqual(result["changes"]["old"], {"plan": None})
1200                 self.assertEqual(result["changes"]["new"], {"plan": {"id": "id"}})
1201     @pytest.mark.slow_test
1202     def test_usage_plan_present_if_plan_has_been_updated(self, *args):
1203         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1204             with patch.dict(
1205 <a name="2"></a>                boto_apigateway.__salt__,
1206                 {
1207                     "boto_apigateway.describe_usage_plans": MagicMock(
1208                         side_effect<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=[
1209                             {"plans": [{"id": "id"}]},
1210                             {
1211                                 "plans": [
1212                                     {
1213                                         "id": "id",
1214                                         "throttle": {"rateLimit": throttle_rateLimit},
1215                                     }
1216                                 ]
1217                             },
1218                         ]
1219                     ),
1220                     "boto_apigateway.update_usage_plan": MagicMock(
1221                         return_value={"updated": True}
1222                     ),
1223                 },
1224             ):
1225                 result = boto_apigateway.</b></font>usage_plan_present(
1226                     "name",
1227                     "plan_name",
1228                     throttle={"rateLimit": throttle_rateLimit},
1229                     **conn_parameters
1230                 )
1231                 self.assertIn("result", result)
1232                 self.assertEqual(result["result"], True)
1233                 self.assertIn("comment", result)
1234                 self.assertEqual(
1235                     result["comment"], "usage plan plan_name has been updated"
1236                 )
1237                 self.assertEqual(result["changes"]["old"], {"plan": {"id": "id"}})
1238                 self.assertEqual(
1239                     result["changes"]["new"],
1240                     {
1241                         "plan": {
1242                             "id": "id",
1243                             "throttle": {"rateLimit": throttle_rateLimit},
1244                         }
1245                     },
1246                 )
1247     @pytest.mark.slow_test
1248     def test_usage_plan_present_if_ValueError_is_raised(self, *args):
1249         with patch.dict(
1250             boto_apigateway.__salt__,
1251             {
1252                 "boto_apigateway.describe_usage_plans": MagicMock(
1253                     side_effect=ValueError("error")
1254                 )
1255             },
1256         ):
1257             result = boto_apigateway.usage_plan_present(
1258                 "name",
1259                 "plan_name",
1260                 throttle={"rateLimit": throttle_rateLimit},
1261                 **conn_parameters
1262             )
1263             self.assertIn("result", result)
1264             self.assertEqual(result["result"], False)
1265             self.assertIn("comment", result)
1266             self.assertEqual(result["comment"], repr(("error",)))
1267     @pytest.mark.slow_test
1268     def test_usage_plan_present_if_IOError_is_raised(self, *args):
1269         with patch.dict(
1270             boto_apigateway.__salt__,
1271             {
1272                 "boto_apigateway.describe_usage_plans": MagicMock(
1273                     side_effect=IOError("error")
1274                 )
1275             },
1276         ):
1277             result = boto_apigateway.usage_plan_present(
1278                 "name",
1279                 "plan_name",
1280                 throttle={"rateLimit": throttle_rateLimit},
1281                 **conn_parameters
1282             )
1283             self.assertIn("result", result)
1284             self.assertEqual(result["result"], False)
1285             self.assertIn("comment", result)
1286             self.assertEqual(result["comment"], repr(("error",)))
1287     @pytest.mark.slow_test
1288     def test_usage_plan_absent_if_describe_fails(self, *args):
1289         with patch.dict(
1290             boto_apigateway.__salt__,
1291             {
1292                 "boto_apigateway.describe_usage_plans": MagicMock(
1293                     return_value={"error": "error"}
1294                 )
1295             },
1296         ):
1297             result = {}
1298             result = boto_apigateway.usage_plan_absent(
1299                 "name", "plan_name", **conn_parameters
1300             )
1301             self.assertIn("result", result)
1302             self.assertEqual(result["result"], False)
1303             self.assertIn("comment", result)
1304             self.assertEqual(
1305                 result["comment"], "Failed to describe existing usage plans"
1306             )
1307             self.assertIn("changes", result)
1308             self.assertEqual(result["changes"], {})
1309     @pytest.mark.slow_test
1310     def test_usage_plan_absent_if_plan_is_not_present(self, *args):
1311         with patch.dict(
1312             boto_apigateway.__salt__,
1313             {
1314                 "boto_apigateway.describe_usage_plans": MagicMock(
1315                     return_value={"plans": []}
1316                 )
1317             },
1318         ):
1319             result = {}
1320             result = boto_apigateway.usage_plan_absent(
1321                 "name", "plan_name", **conn_parameters
1322             )
1323             self.assertIn("result", result)
1324             self.assertEqual(result["result"], True)
1325             self.assertIn("comment", result)
1326             self.assertEqual(
1327                 result["comment"], "Usage plan plan_name does not exist already"
1328             )
1329             self.assertIn("changes", result)
1330             self.assertEqual(result["changes"], {})
1331     @pytest.mark.slow_test
1332     def test_usage_plan_absent_if_plan_is_present_but_test_option_is_set(self, *args):
1333         with patch.dict(boto_apigateway.__opts__, {"test": True}):
1334             with patch.dict(
1335                 boto_apigateway.__salt__,
1336                 {
1337                     "boto_apigateway.describe_usage_plans": MagicMock(
1338                         return_value={"plans": [{"id": "id"}]}
1339                     )
1340                 },
1341             ):
1342                 result = {}
1343                 result = boto_apigateway.usage_plan_absent(
1344                     "name", "plan_name", **conn_parameters
1345                 )
1346                 self.assertIn("result", result)
1347                 self.assertEqual(result["result"], None)
1348                 self.assertIn("comment", result)
1349                 self.assertEqual(
1350                     result["comment"],
1351                     "Usage plan plan_name exists and would be deleted",
1352                 )
1353                 self.assertIn("changes", result)
1354                 self.assertEqual(result["changes"], {})
1355     @pytest.mark.slow_test
1356     def test_usage_plan_absent_if_plan_is_present_but_delete_fails(self, *args):
1357         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1358             with patch.dict(
1359                 boto_apigateway.__salt__,
1360                 {
1361                     "boto_apigateway.describe_usage_plans": MagicMock(
1362                         return_value={"plans": [{"id": "id"}]}
1363                     ),
1364                     "boto_apigateway.delete_usage_plan": MagicMock(
1365                         return_value={"error": "error"}
1366                     ),
1367                 },
1368             ):
1369                 result = boto_apigateway.usage_plan_absent(
1370                     "name", "plan_name", **conn_parameters
1371                 )
1372                 self.assertIn("result", result)
1373                 self.assertEqual(result["result"], False)
1374                 self.assertIn("comment", result)
1375                 self.assertEqual(
1376                     result["comment"],
1377                     "Failed to delete usage plan plan_name, "
1378                     + repr({"error": "error"}),
1379                 )
1380                 self.assertIn("changes", result)
1381                 self.assertEqual(result["changes"], {})
1382     @pytest.mark.slow_test
1383     def test_usage_plan_absent_if_plan_has_been_deleted(self, *args):
1384         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1385             with patch.dict(
1386                 boto_apigateway.__salt__,
1387                 {
1388                     "boto_apigateway.describe_usage_plans": MagicMock(
1389                         return_value={"plans": [{"id": "id"}]}
1390                     ),
1391                     "boto_apigateway.delete_usage_plan": MagicMock(
1392                         return_value={"deleted": True}
1393                     ),
1394                 },
1395             ):
1396                 result = boto_apigateway.usage_plan_absent(
1397                     "name", "plan_name", **conn_parameters
1398                 )
1399                 self.assertIn("result", result)
1400                 self.assertEqual(result["result"], True)
1401                 self.assertIn("comment", result)
1402                 self.assertEqual(
1403                     result["comment"], "Usage plan plan_name has been deleted"
1404                 )
1405                 self.assertIn("changes", result)
1406                 self.assertEqual(
1407                     result["changes"],
1408                     {"new": {"plan": None}, "old": {"plan": {"id": "id"}}},
1409                 )
1410     @pytest.mark.slow_test
1411     def test_usage_plan_absent_if_ValueError_is_raised(self, *args):
1412         with patch.dict(
1413             boto_apigateway.__salt__,
1414             {
1415                 "boto_apigateway.describe_usage_plans": MagicMock(
1416                     side_effect=ValueError("error")
1417                 )
1418             },
1419         ):
1420             result = boto_apigateway.usage_plan_absent(
1421                 "name", "plan_name", **conn_parameters
1422             )
1423             self.assertIn("result", result)
1424             self.assertEqual(result["result"], False)
1425             self.assertIn("comment", result)
1426             self.assertEqual(result["comment"], repr(("error",)))
1427     @pytest.mark.slow_test
1428     def test_usage_plan_absent_if_IOError_is_raised(self, *args):
1429         with patch.dict(
1430             boto_apigateway.__salt__,
1431             {
1432                 "boto_apigateway.describe_usage_plans": MagicMock(
1433                     side_effect=IOError("error")
1434                 )
1435             },
1436         ):
1437             result = boto_apigateway.usage_plan_absent(
1438                 "name", "plan_name", **conn_parameters
1439             )
1440             self.assertIn("result", result)
1441             self.assertEqual(result["result"], False)
1442             self.assertIn("comment", result)
1443             self.assertEqual(result["comment"], repr(("error",)))
1444 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
1445 @skipIf(
1446     _has_required_boto() is False,
1447     "The boto3 module must be greater than or equal to version {}".format(
1448         required_boto3_version
1449     ),
1450 )
1451 @skipIf(
1452     _has_required_botocore() is False,
1453     "The botocore module must be greater than or equal to version {}".format(
1454         required_botocore_version
1455     ),
1456 )
1457 class BotoApiGatewayUsagePlanAssociationTestCase(
1458     BotoApiGatewayStateTestCaseBase, BotoApiGatewayTestCaseMixin
1459 ):
1460     @pytest.mark.slow_test
1461     def test_usage_plan_association_present_if_describe_fails(self, *args):
1462         with patch.dict(
1463             boto_apigateway.__salt__,
1464             {
1465                 "boto_apigateway.describe_usage_plans": MagicMock(
1466                     return_value={"error": "error"}
1467                 )
1468             },
1469         ):
1470             result = boto_apigateway.usage_plan_association_present(
1471                 "name", "plan_name", [association_stage_1], **conn_parameters
1472             )
1473             self.assertIn("result", result)
1474             self.assertEqual(result["result"], False)
1475             self.assertIn("comment", result)
1476             self.assertEqual(
1477                 result["comment"], "Failed to describe existing usage plans"
1478             )
1479             self.assertIn("changes", result)
1480             self.assertEqual(result["changes"], {})
1481     @pytest.mark.slow_test
1482     def test_usage_plan_association_present_if_plan_is_not_present(self, *args):
1483         with patch.dict(
1484             boto_apigateway.__salt__,
1485             {
1486                 "boto_apigateway.describe_usage_plans": MagicMock(
1487                     return_value={"plans": []}
1488                 )
1489             },
1490         ):
1491             result = boto_apigateway.usage_plan_association_present(
1492                 "name", "plan_name", [association_stage_1], **conn_parameters
1493             )
1494             self.assertIn("result", result)
1495             self.assertEqual(result["result"], False)
1496             self.assertIn("comment", result)
1497             self.assertEqual(result["comment"], "Usage plan plan_name does not exist")
1498             self.assertIn("changes", result)
1499             self.assertEqual(result["changes"], {})
1500     @pytest.mark.slow_test
1501     def test_usage_plan_association_present_if_multiple_plans_with_the_same_name_exist(
1502         self, *args
1503     ):
1504         with patch.dict(
1505             boto_apigateway.__salt__,
1506             {
1507                 "boto_apigateway.describe_usage_plans": MagicMock(
1508                     return_value={"plans": [{"id": "id1"}, {"id": "id2"}]}
1509                 )
1510             },
1511         ):
1512             result = boto_apigateway.usage_plan_association_present(
1513                 "name", "plan_name", [association_stage_1], **conn_parameters
1514             )
1515             self.assertIn("result", result)
1516             self.assertEqual(result["result"], False)
1517             self.assertIn("comment", result)
1518             self.assertEqual(
1519                 result["comment"],
1520                 "There are multiple usage plans with the same name - it is not"
1521                 " supported",
1522             )
1523             self.assertIn("changes", result)
1524             self.assertEqual(result["changes"], {})
1525     @pytest.mark.slow_test
1526     def test_usage_plan_association_present_if_association_already_exists(self, *args):
1527         with patch.dict(
1528             boto_apigateway.__salt__,
1529             {
1530                 "boto_apigateway.describe_usage_plans": MagicMock(
1531                     return_value={
1532                         "plans": [{"id": "id1", "apiStages": [association_stage_1]}]
1533                     }
1534                 )
1535             },
1536         ):
1537             result = boto_apigateway.usage_plan_association_present(
1538                 "name", "plan_name", [association_stage_1], **conn_parameters
1539             )
1540             self.assertIn("result", result)
1541             self.assertEqual(result["result"], True)
1542             self.assertIn("comment", result)
1543             self.assertEqual(
1544                 result["comment"], "Usage plan is already asssociated to all api stages"
1545             )
1546             self.assertIn("changes", result)
1547             self.assertEqual(result["changes"], {})
1548     @pytest.mark.slow_test
1549     def test_usage_plan_association_present_if_update_fails(self, *args):
1550         with patch.dict(
1551             boto_apigateway.__salt__,
1552             {
1553                 "boto_apigateway.describe_usage_plans": MagicMock(
1554                     return_value={
1555                         "plans": [{"id": "id1", "apiStages": [association_stage_1]}]
1556                     }
1557                 ),
1558                 "boto_apigateway.attach_usage_plan_to_apis": MagicMock(
1559                     return_value={"error": "error"}
1560                 ),
1561             },
1562         ):
1563             result = boto_apigateway.usage_plan_association_present(
1564                 "name", "plan_name", [association_stage_2], **conn_parameters
1565             )
1566             self.assertIn("result", result)
1567             self.assertEqual(result["result"], False)
1568             self.assertIn("comment", result)
1569             self.assertTrue(
1570                 result["comment"].startswith("Failed to associate a usage plan")
1571             )
1572             self.assertIn("changes", result)
1573             self.assertEqual(result["changes"], {})
1574     @pytest.mark.slow_test
1575     def test_usage_plan_association_present_success(self, *args):
1576         with patch.dict(
1577             boto_apigateway.__salt__,
1578             {
1579                 "boto_apigateway.describe_usage_plans": MagicMock(
1580                     return_value={
1581                         "plans": [{"id": "id1", "apiStages": [association_stage_1]}]
1582                     }
1583                 ),
1584                 "boto_apigateway.attach_usage_plan_to_apis": MagicMock(
1585                     return_value={
1586                         "result": {
1587                             "apiStages": [association_stage_1, association_stage_2]
1588                         }
1589                     }
1590                 ),
1591             },
1592         ):
1593             result = boto_apigateway.usage_plan_association_present(
1594                 "name", "plan_name", [association_stage_2], **conn_parameters
1595             )
1596             self.assertIn("result", result)
1597             self.assertEqual(result["result"], True)
1598             self.assertIn("comment", result)
1599             self.assertEqual(
1600                 result["comment"], "successfully associated usage plan to apis"
1601             )
1602             self.assertIn("changes", result)
1603             self.assertEqual(
1604                 result["changes"],
1605                 {
1606                     "new": [association_stage_1, association_stage_2],
1607                     "old": [association_stage_1],
1608                 },
1609             )
1610     @pytest.mark.slow_test
1611     def test_usage_plan_association_present_if_value_error_is_thrown(self, *args):
1612         with patch.dict(
1613             boto_apigateway.__salt__,
1614             {
1615                 "boto_apigateway.describe_usage_plans": MagicMock(
1616                     side_effect=ValueError("error")
1617                 )
1618             },
1619         ):
1620             result = boto_apigateway.usage_plan_association_present(
1621                 "name", "plan_name", [], **conn_parameters
1622             )
1623             self.assertIn("result", result)
1624             self.assertEqual(result["result"], False)
1625             self.assertIn("comment", result)
1626             self.assertEqual(result["comment"], repr(("error",)))
1627             self.assertIn("changes", result)
1628             self.assertEqual(result["changes"], {})
1629     @pytest.mark.slow_test
1630     def test_usage_plan_association_present_if_io_error_is_thrown(self, *args):
1631         with patch.dict(
1632             boto_apigateway.__salt__,
1633             {
1634                 "boto_apigateway.describe_usage_plans": MagicMock(
1635                     side_effect=IOError("error")
1636                 )
1637             },
1638         ):
1639             result = boto_apigateway.usage_plan_association_present(
1640                 "name", "plan_name", [], **conn_parameters
1641             )
1642             self.assertIn("result", result)
1643             self.assertEqual(result["result"], False)
1644             self.assertIn("comment", result)
1645             self.assertEqual(result["comment"], repr(("error",)))
1646             self.assertIn("changes", result)
1647             self.assertEqual(result["changes"], {})
1648     @pytest.mark.slow_test
1649     def test_usage_plan_association_absent_if_describe_fails(self, *args):
1650         with patch.dict(
1651             boto_apigateway.__salt__,
1652             {
1653                 "boto_apigateway.describe_usage_plans": MagicMock(
1654                     return_value={"error": "error"}
1655                 )
1656             },
1657         ):
1658             result = boto_apigateway.usage_plan_association_absent(
1659                 "name", "plan_name", [association_stage_1], **conn_parameters
1660             )
1661             self.assertIn("result", result)
1662             self.assertEqual(result["result"], False)
1663             self.assertIn("comment", result)
1664             self.assertEqual(
1665                 result["comment"], "Failed to describe existing usage plans"
1666             )
1667             self.assertIn("changes", result)
1668             self.assertEqual(result["changes"], {})
1669     @pytest.mark.slow_test
1670     def test_usage_plan_association_absent_if_plan_is_not_present(self, *args):
1671         with patch.dict(
1672             boto_apigateway.__salt__,
1673             {
1674                 "boto_apigateway.describe_usage_plans": MagicMock(
1675                     return_value={"plans": []}
1676                 )
1677             },
1678         ):
1679             result = boto_apigateway.usage_plan_association_absent(
1680                 "name", "plan_name", [association_stage_1], **conn_parameters
1681             )
1682             self.assertIn("result", result)
1683             self.assertEqual(result["result"], False)
1684             self.assertIn("comment", result)
1685             self.assertEqual(result["comment"], "Usage plan plan_name does not exist")
1686             self.assertIn("changes", result)
1687             self.assertEqual(result["changes"], {})
1688     @pytest.mark.slow_test
1689     def test_usage_plan_association_absent_if_multiple_plans_with_the_same_name_exist(
1690         self, *args
1691     ):
1692         with patch.dict(
1693             boto_apigateway.__salt__,
1694             {
1695                 "boto_apigateway.describe_usage_plans": MagicMock(
1696                     return_value={"plans": [{"id": "id1"}, {"id": "id2"}]}
1697                 )
1698             },
1699         ):
1700             result = boto_apigateway.usage_plan_association_absent(
1701                 "name", "plan_name", [association_stage_1], **conn_parameters
1702             )
1703             self.assertIn("result", result)
1704             self.assertEqual(result["result"], False)
1705             self.assertIn("comment", result)
1706             self.assertEqual(
1707                 result["comment"],
1708                 "There are multiple usage plans with the same name - it is not"
1709                 " supported",
1710             )
1711             self.assertIn("changes", result)
1712             self.assertEqual(result["changes"], {})
1713     @pytest.mark.slow_test
1714     def test_usage_plan_association_absent_if_plan_has_no_associations(self, *args):
1715         with patch.dict(
1716             boto_apigateway.__salt__,
1717             {
1718                 "boto_apigateway.describe_usage_plans": MagicMock(
1719                     return_value={"plans": [{"id": "id1", "apiStages": []}]}
1720                 )
1721             },
1722         ):
1723             result = boto_apigateway.usage_plan_association_absent(
1724                 "name", "plan_name", [association_stage_1], **conn_parameters
1725             )
1726             self.assertIn("result", result)
1727             self.assertEqual(result["result"], True)
1728             self.assertIn("comment", result)
1729             self.assertEqual(
1730                 result["comment"],
1731                 "Usage plan plan_name has no associated stages already",
1732             )
1733             self.assertIn("changes", result)
1734             self.assertEqual(result["changes"], {})
1735     @pytest.mark.slow_test
1736     def test_usage_plan_association_absent_if_plan_has_no_specific_association(
1737         self, *args
1738     ):
1739         with patch.dict(
1740             boto_apigateway.__salt__,
1741             {
1742                 "boto_apigateway.describe_usage_plans": MagicMock(
1743                     return_value={
1744                         "plans": [{"id": "id1", "apiStages": [association_stage_1]}]
1745                     }
1746                 )
1747             },
1748         ):
1749             result = boto_apigateway.usage_plan_association_absent(
1750                 "name", "plan_name", [association_stage_2], **conn_parameters
1751             )
1752             self.assertIn("result", result)
1753             self.assertEqual(result["result"], True)
1754             self.assertIn("comment", result)
1755             self.assertEqual(
1756                 result["comment"],
1757                 "Usage plan is already not asssociated to any api stages",
1758             )
1759             self.assertIn("changes", result)
1760             self.assertEqual(result["changes"], {})
1761     @pytest.mark.slow_test
1762     def test_usage_plan_association_absent_if_detaching_association_fails(self, *args):
1763         with patch.dict(
1764             boto_apigateway.__salt__,
1765             {
1766                 "boto_apigateway.describe_usage_plans": MagicMock(
1767                     return_value={
1768                         "plans": [
1769                             {
1770                                 "id": "id1",
1771                                 "apiStages": [association_stage_1, association_stage_2],
1772                             }
1773                         ]
1774                     }
1775                 ),
1776                 "boto_apigateway.detach_usage_plan_from_apis": MagicMock(
1777                     return_value={"error": "error"}
1778                 ),
1779             },
1780         ):
1781             result = boto_apigateway.usage_plan_association_absent(
1782                 "name", "plan_name", [association_stage_2], **conn_parameters
1783             )
1784             self.assertIn("result", result)
1785             self.assertEqual(result["result"], False)
1786             self.assertIn("comment", result)
1787             self.assertTrue(
1788                 result["comment"].startswith(
1789                     "Failed to disassociate a usage plan plan_name from the apis"
1790                 )
1791             )
1792             self.assertIn("changes", result)
1793             self.assertEqual(result["changes"], {})
1794     @pytest.mark.slow_test
1795     def test_usage_plan_association_absent_success(self, *args):
1796         with patch.dict(
1797             boto_apigateway.__salt__,
1798             {
1799                 "boto_apigateway.describe_usage_plans": MagicMock(
1800                     return_value={
1801                         "plans": [
1802                             {
1803                                 "id": "id1",
1804                                 "apiStages": [association_stage_1, association_stage_2],
1805                             }
1806                         ]
1807                     }
1808                 ),
1809                 "boto_apigateway.detach_usage_plan_from_apis": MagicMock(
1810                     return_value={"result": {"apiStages": [association_stage_1]}}
1811                 ),
1812             },
1813         ):
1814             result = boto_apigateway.usage_plan_association_absent(
1815                 "name", "plan_name", [association_stage_2], **conn_parameters
1816             )
1817             self.assertIn("result", result)
1818             self.assertEqual(result["result"], True)
1819             self.assertIn("comment", result)
1820             self.assertEqual(
1821                 result["comment"], "successfully disassociated usage plan from apis"
1822             )
1823             self.assertIn("changes", result)
1824             self.assertEqual(
1825                 result["changes"],
1826                 {
1827                     "new": [association_stage_1],
1828                     "old": [association_stage_1, association_stage_2],
1829                 },
1830             )
1831     @pytest.mark.slow_test
1832     def test_usage_plan_association_absent_if_ValueError_is_raised(self, *args):
1833         with patch.dict(
1834             boto_apigateway.__salt__,
1835             {
1836                 "boto_apigateway.describe_usage_plans": MagicMock(
1837                     side_effect=ValueError("error")
1838                 )
1839             },
1840         ):
1841             result = boto_apigateway.usage_plan_association_absent(
1842                 "name", "plan_name", [association_stage_1], **conn_parameters
1843             )
1844             self.assertIn("result", result)
1845             self.assertEqual(result["result"], False)
1846             self.assertIn("comment", result)
1847             self.assertEqual(result["comment"], repr(("error",)))
1848             self.assertIn("changes", result)
1849             self.assertEqual(result["changes"], {})
1850     @pytest.mark.slow_test
1851     def test_usage_plan_association_absent_if_IOError_is_raised(self, *args):
1852         with patch.dict(
1853             boto_apigateway.__salt__,
1854             {
1855                 "boto_apigateway.describe_usage_plans": MagicMock(
1856                     side_effect=IOError("error")
1857                 )
1858             },
1859         ):
1860             result = boto_apigateway.usage_plan_association_absent(
1861                 "name", "plan_name", [association_stage_1], **conn_parameters
1862             )
1863             self.assertIn("result", result)
1864             self.assertEqual(result["result"], False)
1865             self.assertIn("comment", result)
1866             self.assertEqual(result["comment"], repr(("error",)))
1867             self.assertIn("changes", result)
1868             self.assertEqual(result["changes"], {})
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
