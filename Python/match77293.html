<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_pycrypto.py &amp; test_boto_apigateway.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_pycrypto.py &amp; test_boto_apigateway.py
      </h3>
<h1 align="center">
        4.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_pycrypto.py (14.508928%)<th>test_boto_apigateway.py (2.4639878%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(235-241)<td><a href="#" name="0">(1385-1397)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(166-171)<td><a href="#" name="1">(1426-1445)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(85-87)<td><a href="#" name="2">(1532-1549)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(95-102)<td><a href="#" name="3">(418-457)</a><td align="center"><font color="#cc0000">12</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(44-52)<td><a href="#" name="4">(395-414)</a><td align="center"><font color="#cc0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_pycrypto.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import contextlib
import logging
import re
import string
import pytest
import salt.utils.platform
import salt.utils.pycrypto
from salt.exceptions import SaltInvocationError
from tests.support.mock import patch
passwd = "test_password"
invalid_salt = "thissaltistoolong" * 10
expecteds = {
    "sha512": {
        "hashed": "$6$rounds=65601$goodsalt$lZFhiN5M8RTLd9WKDin50H4lF4F8HGMIdwvKs.nTG7f8F0Y4P447Zb9/E8SkUWjY.K10QT3NuHZNDgc/P/NjT1",
        "salt": "rounds=65601$goodsalt",
        "badsalt": "badsalt",
    },
    "sha256": {
        "hashed": "$5$rounds=53501$goodsalt$W.uoco0wMfGLDOlsbW52E6raFS1Nhj0McfUTj2vORt7",
        "salt": "rounds=53501$goodsalt",
        "badsalt": "badsalt",
    },
    "blowfish": {
        "hashed": "$2b$10$goodsaltgoodsaltgoodsObFfGrJwfV.13QddrZIh2w1ccESmvj8K",
        "salt": "10$goodsaltgoodsaltgoodsa",
        "badsalt": "badsaltbadsaltbadsaltb",
    },
    "md5": {
        "hashed": "$1$goodsalt$4XQMx4a4e1MpBB8xzz.TQ0",
        "salt": "goodsalt",
        "badsalt": "badsalt",
    },
    "crypt": {"hashed": "goVHulDpuGA7w", "salt": "go", "badsalt": "ba"},
}
@pytest.fixture(params=["sha512", "sha256", "blowfish", "md5", "crypt"])
def algorithm(request):
@pytest.mark.skipif(not salt.utils.pycrypto.HAS_CRYPT, reason<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>="crypt not available")
@pytest.mark.parametrize(
    "algorithm, expected",
    [
        ("sha512", expecteds["sha512"]),
        ("sha256", expecteds["sha256"]),
        ("blowfish", expecteds["blowfish"]),
        ("md5", expecteds["md5"]),
        ("crypt", expecteds[</b></font>"crypt"]),
    ],
)
def test_gen_hash_crypt(algorithm, expected):
    """
    Test gen_hash with crypt library
    """
    with patch("salt.utils.pycrypto.methods", {}):
        ret = salt.utils.pycrypto.gen_hash(
            crypt_salt=expected["salt"], password=passwd, algorithm=algorithm
        )
        assert ret == expected["hashed"]
        ret = salt.utils.pycrypto.gen_hash(
            crypt_salt=expected["badsalt"], password=passwd, algorithm=algorithm
        )
        assert ret != expected["hashed"]
        ret = salt.utils.pycrypto.gen_hash(
            crypt_salt=None, password=passwd, algorithm=algorithm
        )
        assert ret != expected["hashed"]
@pytest.mark.skipif(not salt.utils.pycrypto.HAS_CRYPT, reason="crypt not available")
def test_gen_hash_crypt_no_arguments():
    assert salt.utils.pycrypto.gen_hash() is not None
def test_gen_hash_crypt_default_algorithm():
    default_algorithm <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= salt.utils.pycrypto.crypt.methods[0].name.lower()
    expected = expecteds[default_algorithm]
    ret = salt.</b></font>utils.pycrypto.gen_hash(crypt_salt=expected["salt"], password=passwd)
    assert ret == expected["hashed"]
@pytest.mark.skipif(not salt.utils.pycrypto.HAS_PASSLIB, reason="passlib not available")
    "algorithm, expected",
    [
        <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("sha512", expecteds["sha512"]),
        ("sha256", expecteds["sha256"]),
        ("blowfish", expecteds["blowfish"]),
        ("md5", expecteds["md5"]),
        ("crypt", expecteds["crypt"]),
    ],
)
def</b></font> test_gen_hash_passlib(algorithm, expected):
    """
    Test gen_hash with passlib
    """
    with patch("salt.utils.pycrypto.methods", {}):
        with patch("salt.utils.pycrypto.HAS_CRYPT", False):
            ret = salt.utils.pycrypto.gen_hash(
                crypt_salt=expected["salt"], password=passwd, algorithm=algorithm
            )
            assert ret == expected["hashed"]
            ret = salt.utils.pycrypto.gen_hash(
                crypt_salt=expected["badsalt"], password=passwd, algorithm=algorithm
            )
            assert ret != expected["hashed"]
            ret = salt.utils.pycrypto.gen_hash(
                crypt_salt=None, password=passwd, algorithm=algorithm
            )
            assert ret != expected["hashed"]
@pytest.mark.skipif(not salt.utils.pycrypto.HAS_PASSLIB, reason="passlib not available")
def test_gen_hash_passlib_no_arguments():
    assert salt.utils.pycrypto.gen_hash() is not None
def test_gen_hash_passlib_default_algorithm():
    default_algorithm = salt.utils.pycrypto.known_methods[0]
    expected = expecteds[default_algorithm]
    if default_algorithm in expected:
        ret = salt.utils.pycrypto.gen_hash(crypt_salt=expected["salt"], password=passwd)
        assert ret == expected["hashed"]
def test_gen_hash_no_lib():
    """
    test gen_hash with no crypt library available
    """
    with patch("salt.utils.pycrypto.HAS_CRYPT", False):
        with patch("salt.utils.pycrypto.HAS_PASSLIB", False):
            with pytest.raises(SaltInvocationError):
                salt.utils.pycrypto.gen_hash()
def test_gen_hash_selection():
    """
    verify the hash backend selection works correctly
    """
    with patch("salt.utils.pycrypto.HAS_CRYPT", True):
        with patch("salt.utils.pycrypto.methods", {"crypt": None}):
            with patch("salt.utils.pycrypto.HAS_PASSLIB", True):
                with patch(
                    "salt.utils.pycrypto._gen_hash_crypt", autospec=True
                ) as gh_crypt:
                    with patch(
                        "salt.utils.pycrypto._gen_hash_passlib", autospec=True
                    ) as gh_passlib:
                            salt.utils.pycrypto.gen_hash(algorithm="doesntexist")
                        salt<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.utils.pycrypto.gen_hash(algorithm="crypt")
                        gh_crypt.assert_called_once()
                        gh_passlib.assert_not_called()
                        gh_crypt.reset_mock()
                        salt.utils.</b></font>pycrypto.gen_hash(algorithm="sha512")
                        gh_crypt.assert_not_called()
                        gh_passlib.assert_called_once()
def test_gen_hash_crypt_warning(caplog):
    """
    Verify that a bad crypt salt triggers a warning
    """
    with caplog.at_level(logging.WARNING):
        with contextlib.suppress(Exception):
            salt.utils.pycrypto.gen_hash(
                crypt_salt="toolong", password=passwd, algorithm="crypt"
            )
    assert "Hash salt is too long for 'crypt' hash." in caplog.text
def test_secure_password():
    """
    test secure_password
    """
    with patch("salt.utils.pycrypto.HAS_RANDOM", True):
        ret = salt.utils.pycrypto.secure_password()
        check = re.compile(r"[!@#$%^&amp;*()_=+]")
        check_printable = re.compile(
            r"[^{}]".format(
                re.escape(
                    string.ascii_lowercase
                    + string.ascii_uppercase
                    + string.digits
                    + string.punctuation
                )
            )
        )
        check_whitespace = re.compile(r"[{}]".format(string.whitespace))
        assert check_printable.search(ret) is None
        assert check_whitespace.search(ret) is None
        assert ret
        assert salt.utils.pycrypto.secure_password(length=1, chars="A") == "A"
        assert len(salt.utils.pycrypto.secure_password(length=64)) == 64
def test_secure_password_all_chars():
    """
    test secure_password
    """
    with patch("salt.utils.pycrypto.HAS_RANDOM", True):
        ret = salt.utils.pycrypto.secure_password(
            lowercase=True,
            uppercase=True,
            digits=True,
            punctuation=True,
            whitespace=True,
            printable=True,
        )
        check = re.compile(r"[^{}]".format(re.escape(string.printable)))
        assert check.search(ret) is None
        assert ret
def test_secure_password_no_has_random():
    test secure_password
    """
    with patch<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("salt.utils.pycrypto.HAS_RANDOM", False):
        ret = salt.utils.pycrypto.secure_password()
        check_printable = re.compile(
            r"[^{}]".format(
                re.escape(
                    string.ascii_lowercase
                    + string.</b></font>ascii_uppercase
                    + string.digits
                    + string.punctuation
                )
            )
        )
        check_whitespace = re.compile(r"[{}]".format(string.whitespace))
        assert check_printable.search(ret) is None
        assert check_whitespace.search(ret) is None
        assert ret
        assert salt.utils.pycrypto.secure_password(length=1, chars="A") == "A"
        assert len(salt.utils.pycrypto.secure_password(length=64)) == 64
def test_secure_password_all_chars_no_has_random():
    """
    test secure_password
    """
    with patch("salt.utils.pycrypto.HAS_RANDOM", False):
        ret = salt.utils.pycrypto.secure_password(printable=True)
        check = re.compile("[^{}]".format(re.escape(string.printable)))
        assert check.search(ret) is None
        assert ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_boto_apigateway.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import datetime
import logging
import os
import random
import string
import pytest
import salt.config
import salt.loader
import salt.states.boto_apigateway as boto_apigateway
import salt.utils.files
import salt.utils.yaml
from salt.utils.versions import LooseVersion
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import MagicMock, patch
from tests.support.unit import TestCase, skipIf
from tests.unit.modules.test_boto_apigateway import BotoApiGatewayTestCaseMixin
try:
    import boto3
    import botocore
    from botocore.exceptions import ClientError
    HAS_BOTO = True
except ImportError:
    HAS_BOTO = False
required_boto3_version = "1.2.1"
required_botocore_version = "1.4.49"
region = "us-east-1"
access_key = "GKTADJGHEIQSXMKKRBJ08H"
secret_key = "askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs"
conn_parameters = {
    "region": region,
    "key": access_key,
    "keyid": secret_key,
    "profile": {},
}
error_message = (
    "An error occurred (101) when calling the {0} operation: Test-defined error"
)
error_content = {"Error": {"Code": 101, "Message": "Test-defined error"}}
api_ret = dict(
    description=(
        '{\n    "context": "See deployment or stage description",\n   '
        ' "provisioned_by": "Salt boto_apigateway.present State"\n}'
    ),
    createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
    id="vni0vq8wzi",
    name="unit test api",
)
no_apis_ret = {"items": []}
apis_ret = {"items": [api_ret]}
mock_model_ret = dict(
    contentType="application/json",
    description="mock model",
    id="123abc",
    name="mock model",
    schema=(
        "{\n"
        '    "$schema": "http://json-schema.org/draft-04/schema#",\n'
        '    "properties": {\n'
        '        "field": {\n'
        '            "type": "string"\n'
        "        }\n"
        "    }\n"
        "}"
    ),
)
models_ret = {
    "items": [
        dict(
            contentType="application/json",
            description="Error",
            id="50nw8r",
            name="Error",
            schema=(
                "{\n"
                '    "$schema": "http://json-schema.org/draft-04/schema#",\n'
                '    "properties": {\n'
                '        "code": {\n'
                '            "format": "int32",\n'
                '            "type": "integer"\n'
                "        },\n"
                '        "fields": {\n'
                '            "type": "string"\n'
                "        },\n"
                '        "message": {\n'
                '            "type": "string"\n'
                "        }\n"
                "    },\n"
                '    "title": "Error Schema",\n'
                '    "type": "object"\n'
                "}"
            ),
        ),
        dict(
            contentType="application/json",
            description="User",
            id="terlnw",
            name="User",
            schema=(
                "{\n"
                '    "$schema": "http://json-schema.org/draft-04/schema#",\n'
                '    "properties": {\n'
                '        "password": {\n'
                '            "description": "A password for the new user",\n'
                '            "type": "string"\n'
                "        },\n"
                '        "username": {\n'
                '            "description": "A unique username for the user",\n'
                '            "type": "string"\n'
                "        }\n"
                "    },\n"
                '    "title": "User Schema",\n'
                '    "type": "object"\n'
                "}"
            ),
        ),
    ]
}
root_resources_ret = {"items": [dict(id="bgk0rk8rqb", path="/")]}
resources_ret = {
    "items": [
        dict(id="bgk0rk8rqb", path="/"),
        dict(
            id="9waiaz",
            parentId="bgk0rk8rqb",
            path="/users",
            pathPart="users",
            resourceMethods={"POST": {}},
        ),
    ]
}
no_resources_ret = {"items": []}
stage1_deployment1_ret = dict(
    cacheClusterEnabled=False,
    cacheClusterSize=0.5,
    cacheClusterStatus="NOT_AVAILABLE",
    createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
    deploymentId="kobnrb",
    description=(
        "{\n"
        '    "current_deployment_label": {\n'
        '        "api_name": "unit test api",\n'
        '        "swagger_file": "temp-swagger-sample.yaml",\n'
        '        "swagger_file_md5sum": "4fb17e43bab3a96e7f2410a1597cd0a5",\n'
        '        "swagger_info_object": {\n'
        '            "description": "salt boto apigateway unit test service",\n'
        '            "title": "salt boto apigateway unit test service",\n'
        '            "version": "0.0.0"\n'
        "        }\n"
        "    }\n"
        "}"
    ),
    lastUpdatedDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
    methodSettings=dict(),
    stageName="test",
    variables=dict(),
)
stage1_deployment1_vars_ret = dict(
    cacheClusterEnabled=False,
    cacheClusterSize=0.5,
    cacheClusterStatus="NOT_AVAILABLE",
    createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
    deploymentId="kobnrb",
    description=(
        "{\n"
        '    "current_deployment_label": {\n'
        '        "api_name": "unit test api",\n'
        '        "swagger_file": "temp-swagger-sample.yaml",\n'
        '        "swagger_file_md5sum": "4fb17e43bab3a96e7f2410a1597cd0a5",\n'
        '        "swagger_info_object": {\n'
        '            "description": "salt boto apigateway unit test service",\n'
        '            "title": "salt boto apigateway unit test service",\n'
        '            "version": "0.0.0"\n'
        "        }\n"
        "    }\n"
        "}"
    ),
    lastUpdatedDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
    methodSettings=dict(),
    stageName="test",
    variables={"var1": "val1"},
)
stage1_deployment2_ret = dict(
    cacheClusterEnabled=False,
    cacheClusterSize=0.5,
    cacheClusterStatus="NOT_AVAILABLE",
    createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
    deploymentId="kobnrc",
    description=(
        "{\n"
        '    "current_deployment_label": {\n'
        '        "api_name": "unit test api",\n'
        '        "swagger_file": "temp-swagger-sample.yaml",\n'
        '        "swagger_file_md5sum": "5fd538c4336ed5c54b4bf39ddf97c661",\n'
        '        "swagger_info_object": {\n'
        '            "description": "salt boto apigateway unit test service",\n'
        '            "title": "salt boto apigateway unit test service",\n'
        '            "version": "0.0.2"\n'
        "        }\n"
        "    }\n"
        "}"
    ),
    lastUpdatedDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
    methodSettings=dict(),
    stageName="test",
    variables=dict(),
)
stage2_ret = dict(
    cacheClusterEnabled=False,
    cacheClusterSize=0.5,
    cacheClusterStatus="NOT_AVAILABLE",
    createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
    deploymentId="kobnrb",
    description=(
        "{\n"
        '    "current_deployment_label": {\n'
        '        "api_name": "unit test api",\n'
        '        "swagger_file": "temp-swagger-sample.yaml",\n'
        '        "swagger_file_md5sum": "4fb17e43bab3a96e7f2410a1597cd0a5",\n'
        '        "swagger_info_object": {\n'
        '            "description": "salt boto apigateway unit test service",\n'
        '            "title": "salt boto apigateway unit test service",\n'
        '            "version": "0.0.0"\n'
        "        }\n"
        "    }\n"
        "}"
    ),
    lastUpdatedDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
    methodSettings=dict(),
    stageName="dev",
    variables=dict(),
)
stages_stage2_ret = {"item": [stage2_ret]}
no_stages_ret = {"item": []}
deployment1_ret = dict(
    createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
    description=(
        "{\n"
        '    "api_name": "unit test api",\n'
        '    "swagger_file": "temp-swagger-sample.yaml",\n'
        '    "swagger_file_md5sum": "55a948ff90ad80ff747ec91657c7a299",\n'
        '    "swagger_info_object": {\n'
        '        "description": "salt boto apigateway unit test service",\n'
        '        "title": "salt boto apigateway unit test service",\n'
        '        "version": "0.0.0"\n'
        "    }\n"
        "}"
    ),
    id="kobnrb",
)
deployment2_ret = dict(
    createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
    description=(
        "{\n"
        '    "api_name": "unit test api",\n'
        '    "swagger_file": "temp-swagger-sample.yaml",\n'
        '    "swagger_file_md5sum": "5fd538c4336ed5c54b4bf39ddf97c661",\n'
        '    "swagger_info_object": {\n'
        '        "description": "salt boto apigateway unit test service",\n'
        '        "title": "salt boto apigateway unit test service",\n'
        '        "version": "0.0.2"\n'
        "    }\n"
        "}"
    ),
    id="kobnrc",
)
deployments_ret = {"items": [deployment1_ret, deployment2_ret]}
function_ret = dict(
    FunctionName="unit_test_api_users_post",
    Runtime="python2.7",
    Role=None,
    Handler="handler",
    Description="abcdefg",
    Timeout=5,
    MemorySize=128,
    CodeSha256="abcdef",
    CodeSize=199,
    FunctionArn="arn:lambda:us-east-1:1234:Something",
    LastModified="yes",
)
method_integration_response_200_ret = dict(
    responseParameters={"method.response.header.Access-Control-Allow-Origin": "*"},
    responseTemplates={},
    selectionPattern=".*",
    statusCode="200",
)
method_integration_ret = dict(
    cacheKeyParameters={},
    cacheNamespace="9waiaz",
    credentials="arn:aws:iam::1234:role/apigatewayrole",
    httpMethod="POST",
    integrationResponses={"200": method_integration_response_200_ret},
    requestParameters={},
    requestTemplates={
        "application/json": (
            "#set($inputRoot = $input.path('$')){\"header-params\" : {#set ($map ="
            ' $input.params().header)#foreach( $param in $map.entrySet() )"$param.key"'
            ' : "$param.value" #if( $foreach.hasNext ), #end#end},"query-params" :'
            " {#set ($map = $input.params().querystring)#foreach( $param in"
            ' $map.entrySet() )"$param.key" : "$param.value" #if( $foreach.hasNext ),'
            ' #end#end},"path-params" : {#set ($map = $input.params().path)#foreach('
            ' $param in $map.entrySet() )"$param.key" : "$param.value" #if('
            " $foreach.hasNext ), #end#end},\"body-params\" : $input.json('$')}"
        )
    },
    type="AWS",
    uri=(
        "arn:aws:apigateway:us-west-2:"
        "lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:1234567:"
        "function:unit_test_api_api_users_post/invocations"
    ),
)
method_response_200_ret = dict(
    responseModels={"application/json": "User"},
    responseParameters={"method.response.header.Access-Control-Allow-Origin": False},
    statusCode="200",
)
method_ret = dict(
    apiKeyRequired=False,
    authorizationType="None",
    httpMethod="POST",
    methodIntegration=method_integration_ret,
    methodResponses={"200": method_response_200_ret},
    requestModels={"application/json": "User"},
    requestParameters={},
)
throttle_rateLimit = 10.0
association_stage_1 = {"apiId": "apiId1", "stage": "stage1"}
association_stage_2 = {"apiId": "apiId1", "stage": "stage2"}
log = logging.getLogger(__name__)
def _has_required_boto():
    """
    Returns True/False boolean depending on if Boto is installed and correct
    version.
    """
    if not HAS_BOTO:
        return False
    elif LooseVersion(boto3.__version__) &lt; LooseVersion(required_boto3_version):
        return False
    else:
        return True
def _has_required_botocore():
    """
    Returns True/False boolean depending on if botocore supports usage plan
    """
    if not HAS_BOTO:
        return False
    elif LooseVersion(botocore.__version__) &lt; LooseVersion(required_botocore_version):
        return False
    else:
        return True
class TempSwaggerFile:
    _tmp_swagger_dict <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= {
        "info": {
            "version": "0.0.0",
            "description": "salt boto apigateway unit test service",
            "title": "salt boto apigateway unit test service",
        },
        "paths": {
            "/users": {
                "post": {
                    "responses": {
                        "200": {
                            "headers": {
                                "Access-Control-Allow-Origin": {"type": "string"}
                            },
                            "description": "The username of the new user",
                            "schema": {"$ref": "#/definitions/User"},
                        }
                    },
                    "parameters": [
                        {</b></font>
                            "description": "New user details.",
                            "name": "NewUser",
                            "schema": {<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"$ref": "#/definitions/User"},
                        }
                    ],
                    "produces": ["application/json"],
                    "description": "Creates a new user.",
                    "tags": ["Auth"],
                    "consumes": ["application/json"],
                    "summary": "Registers a new user",
                }
            }
        },
        "schemes": ["https"],
        "produces": ["application/json"],
        "basePath": "/api",
        "host": "rm06h9oac4.execute-api.us-west-2.amazonaws.com",
        "definitions": {
            "User": {
                "properties": {
                    "username": {
                        "type": "string",
                        "description": "A unique username for the user",
                    },
                    "password": {
                        "type": "string",
                        "description": "A password for the new user",
                    },
                }
            },
            "Error": {
                "properties": {
                    "fields": {"type": "string"},
                    "message": {"type": "string"},
                    "code": {"type": "integer", "format": "int32"},
                }
            },
        },
        "swagger": "2.0",
    }
    def</b></font> __enter__(self):
        self.swaggerfile = "temp-swagger-sample.yaml"
        with salt.utils.files.fopen(self.swaggerfile, "w") as fp_:
            salt.utils.yaml.safe_dump(self.swaggerdict, fp_, default_flow_style=False)
        return self.swaggerfile
    def __exit__(self, objtype, value, traceback):
        os.remove(self.swaggerfile)
    def __init__(self, create_invalid_file=False):
        if create_invalid_file:
            self.swaggerdict = TempSwaggerFile._tmp_swagger_dict.copy()
            self.swaggerdict["invalid_key"] = "invalid"
            self.swaggerdict.pop("schemes", None)
            self.swaggerdict["swagger"] = "3.0"
            self.swaggerdict.pop("info", None)
        else:
            self.swaggerdict = TempSwaggerFile._tmp_swagger_dict
class BotoApiGatewayStateTestCaseBase(TestCase, LoaderModuleMockMixin):
    conn = None
    @classmethod
    def setUpClass(cls):
        cls.opts = salt.config.DEFAULT_MINION_OPTS.copy()
        cls.opts["grains"] = salt.loader.grains(cls.opts)
    @classmethod
    def tearDownClass(cls):
        del cls.opts
    def setup_loader_modules(self):
        context = {}
        utils = salt.loader.utils(
            self.opts,
            whitelist=["boto", "boto3", "args", "systemd", "path", "platform", "reg"],
            context=context,
        )
        serializers = salt.loader.serializers(self.opts)
        self.funcs = salt.loader.minion_mods(
            self.opts, context=context, utils=utils, whitelist=["boto_apigateway"]
        )
        self.salt_states = salt.loader.states(
            opts=self.opts,
            functions=self.funcs,
            utils=utils,
            whitelist=["boto_apigateway"],
            serializers=serializers,
        )
        return {
            boto_apigateway: {
                "__opts__": self.opts,
                "__utils__": utils,
                "__salt__": self.funcs,
                "__states__": self.salt_states,
                "__serializers__": serializers,
            }
        }
    def setUp(self):
        self.addCleanup(delattr, self, "funcs")
        self.addCleanup(delattr, self, "salt_states")
        conn_parameters["key"] = "".join(
            random.choice(string.ascii_lowercase + string.digits) for _ in range(50)
        )
        patcher = patch("boto3.session.Session")
        self.addCleanup(patcher.stop)
        mock_session = patcher.start()
        session_instance = mock_session.return_value
        self.conn = MagicMock()
        self.addCleanup(delattr, self, "conn")
        session_instance.client.return_value = self.conn
@skipIf(HAS_BOTO is False, "The boto module must be installed.")
@skipIf(
    _has_required_boto() is False,
    "The boto3 module must be greater than or equal to version {}".format(
        required_boto3_version
    ),
)
class BotoApiGatewayTestCase(
    BotoApiGatewayStateTestCaseBase, BotoApiGatewayTestCaseMixin
):
    """
    TestCase for salt.modules.boto_apigateway state.module
    """
    def test_present_when_swagger_file_is_invalid(self):
        """
        Tests present when the swagger file is invalid.
        """
        result = {}
        with TempSwaggerFile(create_invalid_file=True) as swagger_file:
            result = self.salt_states["boto_apigateway.present"](
                "api present",
                "unit test api",
                swagger_file,
                "test",
                False,
                "arn:aws:iam::1234:role/apigatewayrole",
                **conn_parameters
            )
        self.assertFalse(result.get("result", True))
    def test_present_when_stage_is_already_at_desired_deployment(self):
        """
        Tests scenario where no action will be taken since we're already
        at desired state
        """
        self.conn.get_rest_apis.return_value = apis_ret
        self.conn.get_deployment.return_value = deployment1_ret
        self.conn.get_stage.return_value = stage1_deployment1_ret
        self.conn.update_stage.side_effect = ClientError(
            error_content, "update_stage should not be called"
        )
        result = {}
        with TempSwaggerFile() as swagger_file:
            result = self.salt_states["boto_apigateway.present"](
                "api present",
                "unit test api",
                swagger_file,
                "test",
                False,
                "arn:aws:iam::1234:role/apigatewayrole",
                **conn_parameters
            )
        self.assertFalse(result.get("abort"))
        self.assertTrue(result.get("current"))
        self.assertIs(result.get("result"), True)
        self.assertNotIn("update_stage should not be called", result.get("comment", ""))
    def test_present_when_stage_is_already_at_desired_deployment_and_needs_stage_variables_update(
        self,
    ):
        """
        Tests scenario where the deployment is current except for the need to update stage variables
        from {} to {'var1':'val1'}
        """
        self.conn.get_rest_apis.return_value = apis_ret
        self.conn.get_deployment.return_value = deployment1_ret
        self.conn.get_stage.return_value = stage1_deployment1_ret
        self.conn.update_stage.return_value = stage1_deployment1_vars_ret
        result = {}
        with TempSwaggerFile() as swagger_file:
            result = self.salt_states["boto_apigateway.present"](
                "api present",
                "unit test api",
                swagger_file,
                "test",
                False,
                "arn:aws:iam::1234:role/apigatewayrole",
                stage_variables={"var1": "val1"},
                **conn_parameters
            )
        self.assertFalse(result.get("abort"))
        self.assertTrue(result.get("current"))
        self.assertIs(result.get("result"), True)
    def test_present_when_stage_exists_and_is_to_associate_to_existing_deployment(self):
        """
        Tests scenario where we merely reassociate a stage to a pre-existing
        deployments
        """
        self.conn.get_rest_apis.return_value = apis_ret
        self.conn.get_deployment.return_value = deployment2_ret
        self.conn.get_deployments.return_value = deployments_ret
        self.conn.get_stage.return_value = stage1_deployment2_ret
        self.conn.update_stage.return_value = stage1_deployment1_ret
        self.conn.create_stage.side_effect = ClientError(error_content, "create_stage")
        self.conn.create_deployment.side_effect = ClientError(
            error_content, "create_deployment"
        )
        result = {}
        with TempSwaggerFile() as swagger_file:
            result = self.salt_states["boto_apigateway.present"](
                "api present",
                "unit test api",
                swagger_file,
                "test",
                False,
                "arn:aws:iam::1234:role/apigatewayrole",
                **conn_parameters
            )
        self.assertTrue(result.get("publish"))
        self.assertIs(result.get("result"), True)
        self.assertFalse(result.get("abort"))
        self.assertTrue(result.get("changes", {}).get("new", [{}])[0])
    @pytest.mark.slow_test
    def test_present_when_stage_is_to_associate_to_new_deployment(self):
        """
        Tests creation of a new api/model/resource given nothing has been created previously
        """
        self.conn.get_rest_apis.return_value = no_apis_ret
        self.conn.create_rest_api.return_value = api_ret
        self.conn.get_model.side_effect = ClientError(error_content, "get_model")
        self.conn.create_model.return_value = mock_model_ret
        self.conn.get_resources.return_value = resources_ret
        self.conn.create_resource.side_effect = ClientError(
            error_content, "create_resource"
        )
        self.conn.put_method.return_value = method_ret
        self.conn.put_integration.return_value = method_integration_ret
        self.conn.put_method_response.return_value = method_response_200_ret
        self.conn.put_intgration_response.return_value = (
            method_integration_response_200_ret
        )
        result = {}
        with patch.dict(
            self.funcs,
            {
                "boto_lambda.describe_function": MagicMock(
                    return_value={"function": function_ret}
                )
            },
        ):
            with TempSwaggerFile() as swagger_file:
                result = self.salt_states["boto_apigateway.present"](
                    "api present",
                    "unit test api",
                    swagger_file,
                    "test",
                    False,
                    "arn:aws:iam::1234:role/apigatewayrole",
                    **conn_parameters
                )
        self.assertIs(result.get("result"), True)
        self.assertIs(result.get("abort"), None)
    def test_present_when_stage_associating_to_new_deployment_errored_on_api_creation(
        self,
    ):
        """
        Tests creation of a new api/model/resource given nothing has been created previously,
        and we failed on creating the top level api object.
        """
        self.conn.get_rest_apis.return_value = no_apis_ret
        self.conn.create_rest_api.side_effect = ClientError(
            error_content, "create_rest_api"
        )
        result = {}
        with TempSwaggerFile() as swagger_file:
            result = self.salt_states["boto_apigateway.present"](
                "api present",
                "unit test api",
                swagger_file,
                "test",
                False,
                "arn:aws:iam::1234:role/apigatewayrole",
                **conn_parameters
            )
        self.assertIs(result.get("abort"), True)
        self.assertIs(result.get("result"), False)
        self.assertIn("create_rest_api", result.get("comment", ""))
    def test_present_when_stage_associating_to_new_deployment_errored_on_model_creation(
        self,
    ):
        """
        Tests creation of a new api/model/resource given nothing has been created previously,
        and we failed on creating the models after successful creation of top level api object.
        """
        self.conn.get_rest_apis.return_value = no_apis_ret
        self.conn.create_rest_api.return_value = api_ret
        self.conn.get_model.side_effect = ClientError(error_content, "get_model")
        self.conn.create_model.side_effect = ClientError(error_content, "create_model")
        result = {}
        with TempSwaggerFile() as swagger_file:
            result = self.salt_states["boto_apigateway.present"](
                "api present",
                "unit test api",
                swagger_file,
                "test",
                False,
                "arn:aws:iam::1234:role/apigatewayrole",
                **conn_parameters
            )
        self.assertIs(result.get("abort"), True)
        self.assertIs(result.get("result"), False)
        self.assertIn("create_model", result.get("comment", ""))
    def test_present_when_stage_associating_to_new_deployment_errored_on_resource_creation(
        self,
    ):
        """
        Tests creation of a new api/model/resource given nothing has been created previously,
        and we failed on creating the resource (paths) after successful creation of top level api/model
        objects.
        """
        self.conn.get_rest_apis.return_value = no_apis_ret
        self.conn.create_rest_api.return_value = api_ret
        self.conn.get_model.side_effect = ClientError(error_content, "get_model")
        self.conn.create_model.return_value = mock_model_ret
        self.conn.get_resources.return_value = root_resources_ret
        self.conn.create_resource.side_effect = ClientError(
            error_content, "create_resource"
        )
        result = {}
        with TempSwaggerFile() as swagger_file:
            result = self.salt_states["boto_apigateway.present"](
                "api present",
                "unit test api",
                swagger_file,
                "test",
                False,
                "arn:aws:iam::1234:role/apigatewayrole",
                **conn_parameters
            )
        self.assertIs(result.get("abort"), True)
        self.assertIs(result.get("result"), False)
        self.assertIn("create_resource", result.get("comment", ""))
    @pytest.mark.slow_test
    def test_present_when_stage_associating_to_new_deployment_errored_on_put_method(
        self,
    ):
        """
        Tests creation of a new api/model/resource given nothing has been created previously,
        and we failed on adding a post method to the resource after successful creation of top level
        api, model, resource objects.
        """
        self.conn.get_rest_apis.return_value = no_apis_ret
        self.conn.create_rest_api.return_value = api_ret
        self.conn.get_model.side_effect = ClientError(error_content, "get_model")
        self.conn.create_model.return_value = mock_model_ret
        self.conn.get_resources.return_value = resources_ret
        self.conn.create_resource.side_effect = ClientError(
            error_content, "create_resource"
        )
        self.conn.put_method.side_effect = ClientError(error_content, "put_method")
        result = {}
        with patch.dict(
            self.funcs,
            {
                "boto_lambda.describe_function": MagicMock(
                    return_value={"function": function_ret}
                )
            },
        ):
            with TempSwaggerFile() as swagger_file:
                result = self.salt_states["boto_apigateway.present"](
                    "api present",
                    "unit test api",
                    swagger_file,
                    "test",
                    False,
                    "arn:aws:iam::1234:role/apigatewayrole",
                    **conn_parameters
                )
        self.assertIs(result.get("abort"), True)
        self.assertIs(result.get("result"), False)
        self.assertIn("put_method", result.get("comment", ""))
    @pytest.mark.slow_test
    def test_present_when_stage_associating_to_new_deployment_errored_on_lambda_function_lookup(
        self,
    ):
        """
        Tests creation of a new api/model/resource given nothing has been created previously,
        and we failed on adding a post method due to a lamda look up failure after successful
        creation of top level api, model, resource objects.
        """
        self.conn.get_rest_apis.return_value = no_apis_ret
        self.conn.create_rest_api.return_value = api_ret
        self.conn.get_model.side_effect = ClientError(error_content, "get_model")
        self.conn.create_model.return_value = mock_model_ret
        self.conn.get_resources.return_value = resources_ret
        self.conn.create_resource.side_effect = ClientError(
            error_content, "create_resource"
        )
        self.conn.put_method.return_value = method_ret
        self.conn.put_integration.side_effect = ClientError(
            error_content, "put_integration should not be invoked"
        )
        result = {}
        with patch.dict(
            self.funcs,
            {
                "boto_lambda.describe_function": MagicMock(
                    return_value={"error": "no such lambda"}
                )
            },
        ):
            with TempSwaggerFile() as swagger_file:
                result = self.salt_states["boto_apigateway.present"](
                    "api present",
                    "unit test api",
                    swagger_file,
                    "test",
                    False,
                    "arn:aws:iam::1234:role/apigatewayrole",
                    **conn_parameters
                )
        self.assertIs(result.get("result"), False)
        self.assertNotIn(
            "put_integration should not be invoked", result.get("comment", "")
        )
        self.assertIn("not find lambda function", result.get("comment", ""))
    @pytest.mark.slow_test
    def test_present_when_stage_associating_to_new_deployment_errored_on_put_integration(
        self,
    ):
        """
        Tests creation of a new api/model/resource given nothing has been created previously,
        and we failed on adding an integration for the post method to the resource after
        successful creation of top level api, model, resource objects.
        """
        self.conn.get_rest_apis.return_value = no_apis_ret
        self.conn.create_rest_api.return_value = api_ret
        self.conn.get_model.side_effect = ClientError(error_content, "get_model")
        self.conn.create_model.return_value = mock_model_ret
        self.conn.get_resources.return_value = resources_ret
        self.conn.create_resource.side_effect = ClientError(
            error_content, "create_resource"
        )
        self.conn.put_method.return_value = method_ret
        self.conn.put_integration.side_effect = ClientError(
            error_content, "put_integration"
        )
        result = {}
        with patch.dict(
            self.funcs,
            {
                "boto_lambda.describe_function": MagicMock(
                    return_value={"function": function_ret}
                )
            },
        ):
            with TempSwaggerFile() as swagger_file:
                result = self.salt_states["boto_apigateway.present"](
                    "api present",
                    "unit test api",
                    swagger_file,
                    "test",
                    False,
                    "arn:aws:iam::1234:role/apigatewayrole",
                    **conn_parameters
                )
        self.assertIs(result.get("abort"), True)
        self.assertIs(result.get("result"), False)
        self.assertIn("put_integration", result.get("comment", ""))
    @pytest.mark.slow_test
    def test_present_when_stage_associating_to_new_deployment_errored_on_put_method_response(
        self,
    ):
        """
        Tests creation of a new api/model/resource given nothing has been created previously,
        and we failed on adding a method response for the post method to the resource after
        successful creation of top level api, model, resource objects.
        """
        self.conn.get_rest_apis.return_value = no_apis_ret
        self.conn.create_rest_api.return_value = api_ret
        self.conn.get_model.side_effect = ClientError(error_content, "get_model")
        self.conn.create_model.return_value = mock_model_ret
        self.conn.get_resources.return_value = resources_ret
        self.conn.create_resource.side_effect = ClientError(
            error_content, "create_resource"
        )
        self.conn.put_method.return_value = method_ret
        self.conn.put_integration.return_value = method_integration_ret
        self.conn.put_method_response.side_effect = ClientError(
            error_content, "put_method_response"
        )
        result = {}
        with patch.dict(
            self.funcs,
            {
                "boto_lambda.describe_function": MagicMock(
                    return_value={"function": function_ret}
                )
            },
        ):
            with TempSwaggerFile() as swagger_file:
                result = self.salt_states["boto_apigateway.present"](
                    "api present",
                    "unit test api",
                    swagger_file,
                    "test",
                    False,
                    "arn:aws:iam::1234:role/apigatewayrole",
                    **conn_parameters
                )
        self.assertIs(result.get("abort"), True)
        self.assertIs(result.get("result"), False)
        self.assertIn("put_method_response", result.get("comment", ""))
    @pytest.mark.slow_test
    def test_present_when_stage_associating_to_new_deployment_errored_on_put_integration_response(
        self,
    ):
        """
        Tests creation of a new api/model/resource given nothing has been created previously,
        and we failed on adding an integration response for the post method to the resource after
        successful creation of top level api, model, resource objects.
        """
        self.conn.get_rest_apis.return_value = no_apis_ret
        self.conn.create_rest_api.return_value = api_ret
        self.conn.get_model.side_effect = ClientError(error_content, "get_model")
        self.conn.create_model.return_value = mock_model_ret
        self.conn.get_resources.return_value = resources_ret
        self.conn.create_resource.side_effect = ClientError(
            error_content, "create_resource"
        )
        self.conn.put_method.return_value = method_ret
        self.conn.put_integration.return_value = method_integration_ret
        self.conn.put_method_response.return_value = method_response_200_ret
        self.conn.put_integration_response.side_effect = ClientError(
            error_content, "put_integration_response"
        )
        result = {}
        with patch.dict(
            self.funcs,
            {
                "boto_lambda.describe_function": MagicMock(
                    return_value={"function": function_ret}
                )
            },
        ):
            with TempSwaggerFile() as swagger_file:
                result = self.salt_states["boto_apigateway.present"](
                    "api present",
                    "unit test api",
                    swagger_file,
                    "test",
                    False,
                    "arn:aws:iam::1234:role/apigatewayrole",
                    **conn_parameters
                )
        self.assertIs(result.get("abort"), True)
        self.assertIs(result.get("result"), False)
        self.assertIn("put_integration_response", result.get("comment", ""))
    def test_absent_when_rest_api_does_not_exist(self):
        """
        Tests scenario where the given api_name does not exist, absent state should return True
        with no changes.
        """
        self.conn.get_rest_apis.return_value = apis_ret
        self.conn.get_stage.side_effect = ClientError(
            error_content, "get_stage should not be called"
        )
        result = self.salt_states["boto_apigateway.absent"](
            "api present",
            "no_such_rest_api",
            "no_such_stage",
            nuke_api=False,
            **conn_parameters
        )
        self.assertIs(result.get("result"), True)
        self.assertNotIn("get_stage should not be called", result.get("comment", ""))
        self.assertEqual(result.get("changes"), {})
    def test_absent_when_stage_is_invalid(self):
        """
        Tests scenario where the stagename doesn't exist
        """
        self.conn.get_rest_apis.return_value = apis_ret
        self.conn.get_stage.return_value = stage1_deployment1_ret
        self.conn.delete_stage.side_effect = ClientError(error_content, "delete_stage")
        result = self.salt_states["boto_apigateway.absent"](
            "api present",
            "unit test api",
            "no_such_stage",
            nuke_api=False,
            **conn_parameters
        )
        self.assertTrue(result.get("abort", False))
    def test_absent_when_stage_is_valid_and_only_one_stage_is_associated_to_deployment(
        self,
    ):
        """
        Tests scenario where the stagename exists
        """
        self.conn.get_rest_apis.return_value = apis_ret
        self.conn.get_stage.return_value = stage1_deployment1_ret
        self.conn.delete_stage.return_value = {
            "ResponseMetadata": {
                "HTTPStatusCode": 200,
                "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
            }
        }
        self.conn.get_stages.return_value = no_stages_ret
        self.conn.delete_deployment.return_value = {
            "ResponseMetadata": {
                "HTTPStatusCode": 200,
                "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
            }
        }
        result = self.salt_states["boto_apigateway.absent"](
            "api present", "unit test api", "test", nuke_api=False, **conn_parameters
        )
        self.assertTrue(result.get("result", False))
    def test_absent_when_stage_is_valid_and_two_stages_are_associated_to_deployment(
        self,
    ):
        """
        Tests scenario where the stagename exists and there are two stages associated with same deployment
        """
        self.conn.get_rest_apis.return_value = apis_ret
        self.conn.get_stage.return_value = stage1_deployment1_ret
        self.conn.delete_stage.return_value = {
            "ResponseMetadata": {
                "HTTPStatusCode": 200,
                "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
            }
        }
        self.conn.get_stages.return_value = stages_stage2_ret
        result = self.salt_states["boto_apigateway.absent"](
            "api present", "unit test api", "test", nuke_api=False, **conn_parameters
        )
        self.assertTrue(result.get("result", False))
    def test_absent_when_failing_to_delete_a_deployment_no_longer_associated_with_any_stages(
        self,
    ):
        """
        Tests scenario where stagename exists and is deleted, but a failure occurs when trying to delete
        the deployment which is no longer associated to any other stages
        """
        self.conn.get_rest_apis.return_value = apis_ret
        self.conn.get_stage.return_value = stage1_deployment1_ret
        self.conn.delete_stage.return_value = {
            "ResponseMetadata": {
                "HTTPStatusCode": 200,
                "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
            }
        }
        self.conn.get_stages.return_value = no_stages_ret
        self.conn.delete_deployment.side_effect = ClientError(
            error_content, "delete_deployment"
        )
        result = self.salt_states["boto_apigateway.absent"](
            "api present", "unit test api", "test", nuke_api=False, **conn_parameters
        )
        self.assertTrue(result.get("abort", False))
    def test_absent_when_nuke_api_and_no_more_stages_deployments_remain(self):
        """
        Tests scenario where the stagename exists and there are no stages associated with same deployment,
        the api would be deleted.
        """
        self.conn.get_rest_apis.return_value = apis_ret
        self.conn.get_stage.return_value = stage1_deployment1_ret
        self.conn.delete_stage.return_value = {
            "ResponseMetadata": {
                "HTTPStatusCode": 200,
                "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
            }
        }
        self.conn.get_stages.return_value = no_stages_ret
        self.conn.get_deployments.return_value = deployments_ret
        self.conn.delete_rest_api.return_value = {
            "ResponseMetadata": {
                "HTTPStatusCode": 200,
                "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
            }
        }
        result = self.salt_states["boto_apigateway.absent"](
            "api present", "unit test api", "test", nuke_api=True, **conn_parameters
        )
        self.assertIs(result.get("result"), True)
        self.assertIsNot(result.get("abort"), True)
        self.assertIs(
            result.get("changes", {})
            .get("new", [{}])[0]
            .get("delete_api", {})
            .get("deleted"),
            True,
        )
    def test_absent_when_nuke_api_and_other_stages_deployments_exist(self):
        """
        Tests scenario where the stagename exists and there are two stages associated with same deployment,
        though nuke_api is requested, due to remaining deployments, we will not call the delete_rest_api call.
        """
        self.conn.get_rest_apis.return_value = apis_ret
        self.conn.get_stage.return_value = stage1_deployment1_ret
        self.conn.delete_stage.return_value = {
            "ResponseMetadata": {
                "HTTPStatusCode": 200,
                "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
            }
        }
        self.conn.get_stages.return_value = stages_stage2_ret
        self.conn.get_deployments.return_value = deployments_ret
        self.conn.delete_rest_api.side_effect = ClientError(
            error_content, "unexpected_api_delete"
        )
        result = self.salt_states["boto_apigateway.absent"](
            "api present", "unit test api", "test", nuke_api=True, **conn_parameters
        )
        self.assertIs(result.get("result"), True)
        self.assertIsNot(result.get("abort"), True)
@skipIf(HAS_BOTO is False, "The boto module must be installed.")
@skipIf(
    _has_required_boto() is False,
    "The boto3 module must be greater than or equal to version {}".format(
        required_boto3_version
    ),
)
@skipIf(
    _has_required_botocore() is False,
    "The botocore module must be greater than or equal to version {}".format(
        required_botocore_version
    ),
)
class BotoApiGatewayUsagePlanTestCase(
    BotoApiGatewayStateTestCaseBase, BotoApiGatewayTestCaseMixin
):
    """
    TestCase for salt.modules.boto_apigateway state.module, usage_plans portion
    """
    @pytest.mark.slow_test
    def test_usage_plan_present_if_describe_fails(self, *args):
        """
        Tests correct error processing for describe_usage_plan failure
        """
        with patch.dict(
            boto_apigateway.__salt__,
            {
                "boto_apigateway.describe_usage_plans": MagicMock(
                    return_value={"error": "error"}
                )
            },
        ):
            result = boto_apigateway.usage_plan_present(
                "name", "plan_name", **conn_parameters
            )
            self.assertIn("result", result)
            self.assertEqual(result["result"], False)
            self.assertIn("comment", result)
            self.assertEqual(
                result["comment"], "Failed to describe existing usage plans"
            )
            self.assertIn("changes", result)
            self.assertEqual(result["changes"], {})
    @pytest.mark.slow_test
    def test_usage_plan_present_if_there_is_no_such_plan_and_test_option_is_set(
        self, *args
    ):
        """
        TestCse for salt.modules.boto_apigateway state.module, checking that if __opts__['test'] is set
        and usage plan does not exist, correct diagnostic will be returned
        """
        with patch.dict(boto_apigateway.__opts__, {"test": True}):
            with patch.dict(
                boto_apigateway.__salt__,
                {
                    "boto_apigateway.describe_usage_plans": MagicMock(
                        return_value={"plans": []}
                    )
                },
            ):
                result = boto_apigateway.usage_plan_present(
                    "name", "plan_name", **conn_parameters
                )
                self.assertIn("comment", result)
                self.assertEqual(
                    result["comment"], "a new usage plan plan_name would be created"
                )
                self.assertIn("result", result)
                self.assertEqual(result["result"], None)
    @pytest.mark.slow_test
    def test_usage_plan_present_if_create_usage_plan_fails(self, *args):
        """
        Tests behavior for the case when creating a new usage plan fails
        """
        with patch.dict(boto_apigateway.__opts__, {"test": False}):
            with patch.dict(
                boto_apigateway.__salt__,
                {
                    "boto_apigateway.describe_usage_plans": MagicMock(
                        return_value={"plans": []}
                    ),
                    "boto_apigateway.create_usage_plan": MagicMock(
                        return_value={"error": "error"}
                    ),
                },
            ):
                result = boto_apigateway.usage_plan_present(
                    "name", "plan_name", **conn_parameters
                )
                self.assertIn("result", result)
                self.assertEqual(result["result"], False)
                self.assertIn("comment", result)
                self.assertEqual(
                    result["comment"], "Failed to create a usage plan plan_name, error"
                )
                self.assertIn("changes", result)
                self.assertEqual(result["changes"], {})
    @pytest.mark.slow_test
    def test_usage_plan_present_if_plan_is_there_and_needs_no_updates(self, *args):
        """
        Tests behavior for the case when plan is present and needs no updates
        """
        with patch.dict(boto_apigateway.__opts__, {"test": False}):
                boto_apigateway.__salt__,
                {
                    "boto_apigateway.describe_usage_plans": MagicMock<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(
                        return_value={"plans": [{"id": "planid", "name": "planname"}]}
                    ),
                    "boto_apigateway.update_usage_plan": MagicMock(),
                },
            ):
                result = boto_apigateway.usage_plan_present(
                    "name", "plan_name", **conn_parameters
                )
                self.assertIn("result", result)
                self.assertEqual(result["result"], True)
                self.</b></font>assertIn("comment", result)
                self.assertEqual(
                    result["comment"],
                    "usage plan plan_name is already in a correct state",
                )
                self.assertIn("changes", result)
                self.assertEqual(result["changes"], {})
                self.assertTrue(
                    boto_apigateway.__salt__[
                        "boto_apigateway.update_usage_plan"
                    ].call_count
                    == 0
                )
    @pytest.mark.slow_test
    def test_usage_plan_present_if_plan_is_there_and_needs_updates_but_test_is_set(
        self, *args
    ):
        """
        Tests behavior when usage plan needs to be updated by tests option is set
        """
        with patch.dict(boto_apigateway.__opts__, {"test": True}):
            with patch.dict(
                boto_apigateway.__salt__,
                {
                        return_value={
                            "plans": [
                                <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
                                    "id": "planid",
                                    "name": "planname",
                                    "throttle": {"rateLimit": 10.0},
                                }
                            ]
                        }
                    ),
                    "boto_apigateway.update_usage_plan": MagicMock(),
                },
            ):
                result = boto_apigateway.usage_plan_present(
                    "name", "plan_name", **conn_parameters
                )
                self.assertIn("comment", result)
                self.assertEqual(
                    result["comment"], "a new usage plan plan_name would be updated"
                )
                self.</b></font>assertIn("result", result)
                self.assertEqual(result["result"], None)
                self.assertTrue(
                    boto_apigateway.__salt__[
                        "boto_apigateway.update_usage_plan"
                    ].call_count
                    == 0
                )
    @pytest.mark.slow_test
    def test_usage_plan_present_if_plan_is_there_and_needs_updates_but_update_fails(
        self, *args
    ):
        """
        Tests error processing for the case when updating an existing usage plan fails
        """
        with patch.dict(boto_apigateway.__opts__, {"test": False}):
            with patch.dict(
                boto_apigateway.__salt__,
                {
                    "boto_apigateway.describe_usage_plans": MagicMock(
                        return_value={
                            "plans": [
                                {
                                    "id": "planid",
                                    "name": "planname",
                                    "throttle": {"rateLimit": 10.0},
                                }
                            ]
                        }
                    ),
                    "boto_apigateway.update_usage_plan": MagicMock(
                        return_value={"error": "error"}
                    ),
                },
            ):
                result = boto_apigateway.usage_plan_present(
                    "name", "plan_name", **conn_parameters
                )
                self.assertIn("result", result)
                self.assertEqual(result["result"], False)
                self.assertIn("comment", result)
                self.assertEqual(
                    result["comment"], "Failed to update a usage plan plan_name, error"
                )
    @pytest.mark.slow_test
    def test_usage_plan_present_if_plan_has_been_created(self, *args):
        """
        Tests successful case for creating a new usage plan
        """
        with patch.dict(boto_apigateway.__opts__, {"test": False}):
            with patch.dict(
                boto_apigateway.__salt__,
                {
                    "boto_apigateway.describe_usage_plans": MagicMock(
                        side_effect=[{"plans": []}, {"plans": [{"id": "id"}]}]
                    ),
                    "boto_apigateway.create_usage_plan": MagicMock(
                        return_value={"created": True}
                    ),
                },
            ):
                result = boto_apigateway.usage_plan_present(
                    "name", "plan_name", **conn_parameters
                )
                self.assertIn("result", result)
                self.assertEqual(result["result"], True)
                self.assertIn("comment", result)
                self.assertEqual(
                    result["comment"], "A new usage plan plan_name has been created"
                )
                self.assertEqual(result["changes"]["old"], {"plan": None})
                self.assertEqual(result["changes"]["new"], {"plan": {"id": "id"}})
    @pytest.mark.slow_test
    def test_usage_plan_present_if_plan_has_been_updated(self, *args):
        """
        Tests successful case for updating a usage plan
        """
        with patch.dict(boto_apigateway.__opts__, {"test": False}):
            with patch.dict(
                {
                    "boto_apigateway.describe_usage_plans": MagicMock(
                        side_effect<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=[
                            {"plans": [{"id": "id"}]},
                            {
                                "plans": [
                                    {
                                        "id": "id",
                                        "throttle": {"rateLimit": throttle_rateLimit},
                                    }
                                ]
                            },
                        ]
                    ),
                    "boto_apigateway.update_usage_plan": MagicMock(
                        return_value={"updated": True}
                    ),
                },
            ):
                result = boto_apigateway.</b></font>usage_plan_present(
                    "name",
                    "plan_name",
                    throttle={"rateLimit": throttle_rateLimit},
                    **conn_parameters
                )
                self.assertIn("result", result)
                self.assertEqual(result["result"], True)
                self.assertIn("comment", result)
                self.assertEqual(
                    result["comment"], "usage plan plan_name has been updated"
                )
                self.assertEqual(result["changes"]["old"], {"plan": {"id": "id"}})
                self.assertEqual(
                    result["changes"]["new"],
                    {
                        "plan": {
                            "id": "id",
                            "throttle": {"rateLimit": throttle_rateLimit},
                        }
                    },
                )
    @pytest.mark.slow_test
    def test_usage_plan_present_if_ValueError_is_raised(self, *args):
        """
        Tests error processing for the case when ValueError is raised when creating a usage plan
        """
        with patch.dict(
            boto_apigateway.__salt__,
            {
                "boto_apigateway.describe_usage_plans": MagicMock(
                    side_effect=ValueError("error")
                )
            },
        ):
            result = boto_apigateway.usage_plan_present(
                "name",
                "plan_name",
                throttle={"rateLimit": throttle_rateLimit},
                **conn_parameters
            )
            self.assertIn("result", result)
            self.assertEqual(result["result"], False)
            self.assertIn("comment", result)
            self.assertEqual(result["comment"], repr(("error",)))
    @pytest.mark.slow_test
    def test_usage_plan_present_if_IOError_is_raised(self, *args):
        """
        Tests error processing for the case when IOError is raised when creating a usage plan
        """
        with patch.dict(
            boto_apigateway.__salt__,
            {
                "boto_apigateway.describe_usage_plans": MagicMock(
                    side_effect=IOError("error")
                )
            },
        ):
            result = boto_apigateway.usage_plan_present(
                "name",
                "plan_name",
                throttle={"rateLimit": throttle_rateLimit},
                **conn_parameters
            )
            self.assertIn("result", result)
            self.assertEqual(result["result"], False)
            self.assertIn("comment", result)
            self.assertEqual(result["comment"], repr(("error",)))
    @pytest.mark.slow_test
    def test_usage_plan_absent_if_describe_fails(self, *args):
        """
        Tests correct error processing for describe_usage_plan failure
        """
        with patch.dict(
            boto_apigateway.__salt__,
            {
                "boto_apigateway.describe_usage_plans": MagicMock(
                    return_value={"error": "error"}
                )
            },
        ):
            result = {}
            result = boto_apigateway.usage_plan_absent(
                "name", "plan_name", **conn_parameters
            )
            self.assertIn("result", result)
            self.assertEqual(result["result"], False)
            self.assertIn("comment", result)
            self.assertEqual(
                result["comment"], "Failed to describe existing usage plans"
            )
            self.assertIn("changes", result)
            self.assertEqual(result["changes"], {})
    @pytest.mark.slow_test
    def test_usage_plan_absent_if_plan_is_not_present(self, *args):
        """
        Tests behavior for the case when the plan that needs to be absent does not exist
        """
        with patch.dict(
            boto_apigateway.__salt__,
            {
                "boto_apigateway.describe_usage_plans": MagicMock(
                    return_value={"plans": []}
                )
            },
        ):
            result = {}
            result = boto_apigateway.usage_plan_absent(
                "name", "plan_name", **conn_parameters
            )
            self.assertIn("result", result)
            self.assertEqual(result["result"], True)
            self.assertIn("comment", result)
            self.assertEqual(
                result["comment"], "Usage plan plan_name does not exist already"
            )
            self.assertIn("changes", result)
            self.assertEqual(result["changes"], {})
    @pytest.mark.slow_test
    def test_usage_plan_absent_if_plan_is_present_but_test_option_is_set(self, *args):
        """
        Tests behavior for the case when usage plan needs to be deleted by tests option is set
        """
        with patch.dict(boto_apigateway.__opts__, {"test": True}):
            with patch.dict(
                boto_apigateway.__salt__,
                {
                    "boto_apigateway.describe_usage_plans": MagicMock(
                        return_value={"plans": [{"id": "id"}]}
                    )
                },
            ):
                result = {}
                result = boto_apigateway.usage_plan_absent(
                    "name", "plan_name", **conn_parameters
                )
                self.assertIn("result", result)
                self.assertEqual(result["result"], None)
                self.assertIn("comment", result)
                self.assertEqual(
                    result["comment"],
                    "Usage plan plan_name exists and would be deleted",
                )
                self.assertIn("changes", result)
                self.assertEqual(result["changes"], {})
    @pytest.mark.slow_test
    def test_usage_plan_absent_if_plan_is_present_but_delete_fails(self, *args):
        """
        Tests correct error processing when deleting a usage plan fails
        """
        with patch.dict(boto_apigateway.__opts__, {"test": False}):
            with patch.dict(
                boto_apigateway.__salt__,
                {
                    "boto_apigateway.describe_usage_plans": MagicMock(
                        return_value={"plans": [{"id": "id"}]}
                    ),
                    "boto_apigateway.delete_usage_plan": MagicMock(
                        return_value={"error": "error"}
                    ),
                },
            ):
                result = boto_apigateway.usage_plan_absent(
                    "name", "plan_name", **conn_parameters
                )
                self.assertIn("result", result)
                self.assertEqual(result["result"], False)
                self.assertIn("comment", result)
                self.assertEqual(
                    result["comment"],
                    "Failed to delete usage plan plan_name, "
                    + repr({"error": "error"}),
                )
                self.assertIn("changes", result)
                self.assertEqual(result["changes"], {})
    @pytest.mark.slow_test
    def test_usage_plan_absent_if_plan_has_been_deleted(self, *args):
        """
        Tests successful case for deleting a usage plan
        """
        with patch.dict(boto_apigateway.__opts__, {"test": False}):
            with patch.dict(
                boto_apigateway.__salt__,
                {
                    "boto_apigateway.describe_usage_plans": MagicMock(
                        return_value={"plans": [{"id": "id"}]}
                    ),
                    "boto_apigateway.delete_usage_plan": MagicMock(
                        return_value={"deleted": True}
                    ),
                },
            ):
                result = boto_apigateway.usage_plan_absent(
                    "name", "plan_name", **conn_parameters
                )
                self.assertIn("result", result)
                self.assertEqual(result["result"], True)
                self.assertIn("comment", result)
                self.assertEqual(
                    result["comment"], "Usage plan plan_name has been deleted"
                )
                self.assertIn("changes", result)
                self.assertEqual(
                    result["changes"],
                    {"new": {"plan": None}, "old": {"plan": {"id": "id"}}},
                )
    @pytest.mark.slow_test
    def test_usage_plan_absent_if_ValueError_is_raised(self, *args):
        """
        Tests correct error processing for the case when ValueError is raised when deleting a usage plan
        """
        with patch.dict(
            boto_apigateway.__salt__,
            {
                "boto_apigateway.describe_usage_plans": MagicMock(
                    side_effect=ValueError("error")
                )
            },
        ):
            result = boto_apigateway.usage_plan_absent(
                "name", "plan_name", **conn_parameters
            )
            self.assertIn("result", result)
            self.assertEqual(result["result"], False)
            self.assertIn("comment", result)
            self.assertEqual(result["comment"], repr(("error",)))
    @pytest.mark.slow_test
    def test_usage_plan_absent_if_IOError_is_raised(self, *args):
        """
        Tests correct error processing for the case when IOError is raised when deleting a usage plan
        """
        with patch.dict(
            boto_apigateway.__salt__,
            {
                "boto_apigateway.describe_usage_plans": MagicMock(
                    side_effect=IOError("error")
                )
            },
        ):
            result = boto_apigateway.usage_plan_absent(
                "name", "plan_name", **conn_parameters
            )
            self.assertIn("result", result)
            self.assertEqual(result["result"], False)
            self.assertIn("comment", result)
            self.assertEqual(result["comment"], repr(("error",)))
@skipIf(HAS_BOTO is False, "The boto module must be installed.")
@skipIf(
    _has_required_boto() is False,
    "The boto3 module must be greater than or equal to version {}".format(
        required_boto3_version
    ),
)
@skipIf(
    _has_required_botocore() is False,
    "The botocore module must be greater than or equal to version {}".format(
        required_botocore_version
    ),
)
class BotoApiGatewayUsagePlanAssociationTestCase(
    BotoApiGatewayStateTestCaseBase, BotoApiGatewayTestCaseMixin
):
    """
    TestCase for salt.modules.boto_apigateway state.module, usage_plans_association portion
    """
    @pytest.mark.slow_test
    def test_usage_plan_association_present_if_describe_fails(self, *args):
        """
        Tests correct error processing for describe_usage_plan failure
        """
        with patch.dict(
            boto_apigateway.__salt__,
            {
                "boto_apigateway.describe_usage_plans": MagicMock(
                    return_value={"error": "error"}
                )
            },
        ):
            result = boto_apigateway.usage_plan_association_present(
                "name", "plan_name", [association_stage_1], **conn_parameters
            )
            self.assertIn("result", result)
            self.assertEqual(result["result"], False)
            self.assertIn("comment", result)
            self.assertEqual(
                result["comment"], "Failed to describe existing usage plans"
            )
            self.assertIn("changes", result)
            self.assertEqual(result["changes"], {})
    @pytest.mark.slow_test
    def test_usage_plan_association_present_if_plan_is_not_present(self, *args):
        """
        Tests correct error processing if a plan for which association has been requested is not present
        """
        with patch.dict(
            boto_apigateway.__salt__,
            {
                "boto_apigateway.describe_usage_plans": MagicMock(
                    return_value={"plans": []}
                )
            },
        ):
            result = boto_apigateway.usage_plan_association_present(
                "name", "plan_name", [association_stage_1], **conn_parameters
            )
            self.assertIn("result", result)
            self.assertEqual(result["result"], False)
            self.assertIn("comment", result)
            self.assertEqual(result["comment"], "Usage plan plan_name does not exist")
            self.assertIn("changes", result)
            self.assertEqual(result["changes"], {})
    @pytest.mark.slow_test
    def test_usage_plan_association_present_if_multiple_plans_with_the_same_name_exist(
        self, *args
    ):
        """
        Tests correct error processing for the case when multiple plans with the same name exist
        """
        with patch.dict(
            boto_apigateway.__salt__,
            {
                "boto_apigateway.describe_usage_plans": MagicMock(
                    return_value={"plans": [{"id": "id1"}, {"id": "id2"}]}
                )
            },
        ):
            result = boto_apigateway.usage_plan_association_present(
                "name", "plan_name", [association_stage_1], **conn_parameters
            )
            self.assertIn("result", result)
            self.assertEqual(result["result"], False)
            self.assertIn("comment", result)
            self.assertEqual(
                result["comment"],
                "There are multiple usage plans with the same name - it is not"
                " supported",
            )
            self.assertIn("changes", result)
            self.assertEqual(result["changes"], {})
    @pytest.mark.slow_test
    def test_usage_plan_association_present_if_association_already_exists(self, *args):
        """
        Tests the behavior for the case when requested association is already present
        """
        with patch.dict(
            boto_apigateway.__salt__,
            {
                "boto_apigateway.describe_usage_plans": MagicMock(
                    return_value={
                        "plans": [{"id": "id1", "apiStages": [association_stage_1]}]
                    }
                )
            },
        ):
            result = boto_apigateway.usage_plan_association_present(
                "name", "plan_name", [association_stage_1], **conn_parameters
            )
            self.assertIn("result", result)
            self.assertEqual(result["result"], True)
            self.assertIn("comment", result)
            self.assertEqual(
                result["comment"], "Usage plan is already asssociated to all api stages"
            )
            self.assertIn("changes", result)
            self.assertEqual(result["changes"], {})
    @pytest.mark.slow_test
    def test_usage_plan_association_present_if_update_fails(self, *args):
        """
        Tests correct error processing for the case when adding associations fails
        """
        with patch.dict(
            boto_apigateway.__salt__,
            {
                "boto_apigateway.describe_usage_plans": MagicMock(
                    return_value={
                        "plans": [{"id": "id1", "apiStages": [association_stage_1]}]
                    }
                ),
                "boto_apigateway.attach_usage_plan_to_apis": MagicMock(
                    return_value={"error": "error"}
                ),
            },
        ):
            result = boto_apigateway.usage_plan_association_present(
                "name", "plan_name", [association_stage_2], **conn_parameters
            )
            self.assertIn("result", result)
            self.assertEqual(result["result"], False)
            self.assertIn("comment", result)
            self.assertTrue(
                result["comment"].startswith("Failed to associate a usage plan")
            )
            self.assertIn("changes", result)
            self.assertEqual(result["changes"], {})
    @pytest.mark.slow_test
    def test_usage_plan_association_present_success(self, *args):
        """
        Tests successful case for adding usage plan associations to a given api stage
        """
        with patch.dict(
            boto_apigateway.__salt__,
            {
                "boto_apigateway.describe_usage_plans": MagicMock(
                    return_value={
                        "plans": [{"id": "id1", "apiStages": [association_stage_1]}]
                    }
                ),
                "boto_apigateway.attach_usage_plan_to_apis": MagicMock(
                    return_value={
                        "result": {
                            "apiStages": [association_stage_1, association_stage_2]
                        }
                    }
                ),
            },
        ):
            result = boto_apigateway.usage_plan_association_present(
                "name", "plan_name", [association_stage_2], **conn_parameters
            )
            self.assertIn("result", result)
            self.assertEqual(result["result"], True)
            self.assertIn("comment", result)
            self.assertEqual(
                result["comment"], "successfully associated usage plan to apis"
            )
            self.assertIn("changes", result)
            self.assertEqual(
                result["changes"],
                {
                    "new": [association_stage_1, association_stage_2],
                    "old": [association_stage_1],
                },
            )
    @pytest.mark.slow_test
    def test_usage_plan_association_present_if_value_error_is_thrown(self, *args):
        """
        Tests correct error processing for the case when IOError is raised while trying to set usage plan associations
        """
        with patch.dict(
            boto_apigateway.__salt__,
            {
                "boto_apigateway.describe_usage_plans": MagicMock(
                    side_effect=ValueError("error")
                )
            },
        ):
            result = boto_apigateway.usage_plan_association_present(
                "name", "plan_name", [], **conn_parameters
            )
            self.assertIn("result", result)
            self.assertEqual(result["result"], False)
            self.assertIn("comment", result)
            self.assertEqual(result["comment"], repr(("error",)))
            self.assertIn("changes", result)
            self.assertEqual(result["changes"], {})
    @pytest.mark.slow_test
    def test_usage_plan_association_present_if_io_error_is_thrown(self, *args):
        """
        Tests correct error processing for the case when IOError is raised while trying to set usage plan associations
        """
        with patch.dict(
            boto_apigateway.__salt__,
            {
                "boto_apigateway.describe_usage_plans": MagicMock(
                    side_effect=IOError("error")
                )
            },
        ):
            result = boto_apigateway.usage_plan_association_present(
                "name", "plan_name", [], **conn_parameters
            )
            self.assertIn("result", result)
            self.assertEqual(result["result"], False)
            self.assertIn("comment", result)
            self.assertEqual(result["comment"], repr(("error",)))
            self.assertIn("changes", result)
            self.assertEqual(result["changes"], {})
    @pytest.mark.slow_test
    def test_usage_plan_association_absent_if_describe_fails(self, *args):
        """
        Tests correct error processing for describe_usage_plan failure
        """
        with patch.dict(
            boto_apigateway.__salt__,
            {
                "boto_apigateway.describe_usage_plans": MagicMock(
                    return_value={"error": "error"}
                )
            },
        ):
            result = boto_apigateway.usage_plan_association_absent(
                "name", "plan_name", [association_stage_1], **conn_parameters
            )
            self.assertIn("result", result)
            self.assertEqual(result["result"], False)
            self.assertIn("comment", result)
            self.assertEqual(
                result["comment"], "Failed to describe existing usage plans"
            )
            self.assertIn("changes", result)
            self.assertEqual(result["changes"], {})
    @pytest.mark.slow_test
    def test_usage_plan_association_absent_if_plan_is_not_present(self, *args):
        """
        Tests error processing for the case when plan for which associations need to be modified is not present
        """
        with patch.dict(
            boto_apigateway.__salt__,
            {
                "boto_apigateway.describe_usage_plans": MagicMock(
                    return_value={"plans": []}
                )
            },
        ):
            result = boto_apigateway.usage_plan_association_absent(
                "name", "plan_name", [association_stage_1], **conn_parameters
            )
            self.assertIn("result", result)
            self.assertEqual(result["result"], False)
            self.assertIn("comment", result)
            self.assertEqual(result["comment"], "Usage plan plan_name does not exist")
            self.assertIn("changes", result)
            self.assertEqual(result["changes"], {})
    @pytest.mark.slow_test
    def test_usage_plan_association_absent_if_multiple_plans_with_the_same_name_exist(
        self, *args
    ):
        """
        Tests the case when there are multiple plans with the same name but different Ids
        """
        with patch.dict(
            boto_apigateway.__salt__,
            {
                "boto_apigateway.describe_usage_plans": MagicMock(
                    return_value={"plans": [{"id": "id1"}, {"id": "id2"}]}
                )
            },
        ):
            result = boto_apigateway.usage_plan_association_absent(
                "name", "plan_name", [association_stage_1], **conn_parameters
            )
            self.assertIn("result", result)
            self.assertEqual(result["result"], False)
            self.assertIn("comment", result)
            self.assertEqual(
                result["comment"],
                "There are multiple usage plans with the same name - it is not"
                " supported",
            )
            self.assertIn("changes", result)
            self.assertEqual(result["changes"], {})
    @pytest.mark.slow_test
    def test_usage_plan_association_absent_if_plan_has_no_associations(self, *args):
        """
        Tests the case when the plan has no associations at all
        """
        with patch.dict(
            boto_apigateway.__salt__,
            {
                "boto_apigateway.describe_usage_plans": MagicMock(
                    return_value={"plans": [{"id": "id1", "apiStages": []}]}
                )
            },
        ):
            result = boto_apigateway.usage_plan_association_absent(
                "name", "plan_name", [association_stage_1], **conn_parameters
            )
            self.assertIn("result", result)
            self.assertEqual(result["result"], True)
            self.assertIn("comment", result)
            self.assertEqual(
                result["comment"],
                "Usage plan plan_name has no associated stages already",
            )
            self.assertIn("changes", result)
            self.assertEqual(result["changes"], {})
    @pytest.mark.slow_test
    def test_usage_plan_association_absent_if_plan_has_no_specific_association(
        self, *args
    ):
        """
        Tests the case when requested association is not present already
        """
        with patch.dict(
            boto_apigateway.__salt__,
            {
                "boto_apigateway.describe_usage_plans": MagicMock(
                    return_value={
                        "plans": [{"id": "id1", "apiStages": [association_stage_1]}]
                    }
                )
            },
        ):
            result = boto_apigateway.usage_plan_association_absent(
                "name", "plan_name", [association_stage_2], **conn_parameters
            )
            self.assertIn("result", result)
            self.assertEqual(result["result"], True)
            self.assertIn("comment", result)
            self.assertEqual(
                result["comment"],
                "Usage plan is already not asssociated to any api stages",
            )
            self.assertIn("changes", result)
            self.assertEqual(result["changes"], {})
    @pytest.mark.slow_test
    def test_usage_plan_association_absent_if_detaching_association_fails(self, *args):
        """
        Tests correct error processing when detaching the usage plan from the api function is called
        """
        with patch.dict(
            boto_apigateway.__salt__,
            {
                "boto_apigateway.describe_usage_plans": MagicMock(
                    return_value={
                        "plans": [
                            {
                                "id": "id1",
                                "apiStages": [association_stage_1, association_stage_2],
                            }
                        ]
                    }
                ),
                "boto_apigateway.detach_usage_plan_from_apis": MagicMock(
                    return_value={"error": "error"}
                ),
            },
        ):
            result = boto_apigateway.usage_plan_association_absent(
                "name", "plan_name", [association_stage_2], **conn_parameters
            )
            self.assertIn("result", result)
            self.assertEqual(result["result"], False)
            self.assertIn("comment", result)
            self.assertTrue(
                result["comment"].startswith(
                    "Failed to disassociate a usage plan plan_name from the apis"
                )
            )
            self.assertIn("changes", result)
            self.assertEqual(result["changes"], {})
    @pytest.mark.slow_test
    def test_usage_plan_association_absent_success(self, *args):
        """
        Tests successful case of disaccosiation the usage plan from api stages
        """
        with patch.dict(
            boto_apigateway.__salt__,
            {
                "boto_apigateway.describe_usage_plans": MagicMock(
                    return_value={
                        "plans": [
                            {
                                "id": "id1",
                                "apiStages": [association_stage_1, association_stage_2],
                            }
                        ]
                    }
                ),
                "boto_apigateway.detach_usage_plan_from_apis": MagicMock(
                    return_value={"result": {"apiStages": [association_stage_1]}}
                ),
            },
        ):
            result = boto_apigateway.usage_plan_association_absent(
                "name", "plan_name", [association_stage_2], **conn_parameters
            )
            self.assertIn("result", result)
            self.assertEqual(result["result"], True)
            self.assertIn("comment", result)
            self.assertEqual(
                result["comment"], "successfully disassociated usage plan from apis"
            )
            self.assertIn("changes", result)
            self.assertEqual(
                result["changes"],
                {
                    "new": [association_stage_1],
                    "old": [association_stage_1, association_stage_2],
                },
            )
    @pytest.mark.slow_test
    def test_usage_plan_association_absent_if_ValueError_is_raised(self, *args):
        """
        Tests correct error processing for the case where ValueError is raised while trying to remove plan associations
        """
        with patch.dict(
            boto_apigateway.__salt__,
            {
                "boto_apigateway.describe_usage_plans": MagicMock(
                    side_effect=ValueError("error")
                )
            },
        ):
            result = boto_apigateway.usage_plan_association_absent(
                "name", "plan_name", [association_stage_1], **conn_parameters
            )
            self.assertIn("result", result)
            self.assertEqual(result["result"], False)
            self.assertIn("comment", result)
            self.assertEqual(result["comment"], repr(("error",)))
            self.assertIn("changes", result)
            self.assertEqual(result["changes"], {})
    @pytest.mark.slow_test
    def test_usage_plan_association_absent_if_IOError_is_raised(self, *args):
        """
        Tests correct error processing for the case where IOError exception is raised while trying to remove plan associations
        """
        with patch.dict(
            boto_apigateway.__salt__,
            {
                "boto_apigateway.describe_usage_plans": MagicMock(
                    side_effect=IOError("error")
                )
            },
        ):
            result = boto_apigateway.usage_plan_association_absent(
                "name", "plan_name", [association_stage_1], **conn_parameters
            )
            self.assertIn("result", result)
            self.assertEqual(result["result"], False)
            self.assertIn("comment", result)
            self.assertEqual(result["comment"], repr(("error",)))
            self.assertIn("changes", result)
            self.assertEqual(result["changes"], {})
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
