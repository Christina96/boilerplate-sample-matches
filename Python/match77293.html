<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_pycrypto.py &amp; test_boto_apigateway.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_pycrypto.py &amp; test_boto_apigateway.py
      </h3>
<h1 align="center">
        4.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_pycrypto.py (14.508928%)<th>test_boto_apigateway.py (2.4639878%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(235-241)<td><a href="#" name="0">(1385-1397)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(166-171)<td><a href="#" name="1">(1426-1445)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(85-87)<td><a href="#" name="2">(1532-1549)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(95-102)<td><a href="#" name="3">(418-457)</a><td align="center"><font color="#cc0000">12</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(44-52)<td><a href="#" name="4">(395-414)</a><td align="center"><font color="#cc0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_pycrypto.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import contextlib
2 import logging
3 import re
4 import string
5 import pytest
6 import salt.utils.platform
7 import salt.utils.pycrypto
8 from salt.exceptions import SaltInvocationError
9 from tests.support.mock import patch
10 passwd = "test_password"
11 invalid_salt = "thissaltistoolong" * 10
12 expecteds = {
13     "sha512": {
14         "hashed": "$6$rounds=65601$goodsalt$lZFhiN5M8RTLd9WKDin50H4lF4F8HGMIdwvKs.nTG7f8F0Y4P447Zb9/E8SkUWjY.K10QT3NuHZNDgc/P/NjT1",
15         "salt": "rounds=65601$goodsalt",
16         "badsalt": "badsalt",
17     },
18     "sha256": {
19         "hashed": "$5$rounds=53501$goodsalt$W.uoco0wMfGLDOlsbW52E6raFS1Nhj0McfUTj2vORt7",
20         "salt": "rounds=53501$goodsalt",
21         "badsalt": "badsalt",
22     },
23     "blowfish": {
24         "hashed": "$2b$10$goodsaltgoodsaltgoodsObFfGrJwfV.13QddrZIh2w1ccESmvj8K",
25         "salt": "10$goodsaltgoodsaltgoodsa",
26         "badsalt": "badsaltbadsaltbadsaltb",
27     },
28     "md5": {
29         "hashed": "$1$goodsalt$4XQMx4a4e1MpBB8xzz.TQ0",
30         "salt": "goodsalt",
31         "badsalt": "badsalt",
32     },
33     "crypt": {"hashed": "goVHulDpuGA7w", "salt": "go", "badsalt": "ba"},
34 }
35 @pytest.fixture(params=["sha512", "sha256", "blowfish", "md5", "crypt"])
36 def algorithm(request):
37 @pytest.mark.skipif(not salt.utils.pycrypto.HAS_CRYPT, reason<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>="crypt not available")
38 @pytest.mark.parametrize(
39     "algorithm, expected",
40     [
41         ("sha512", expecteds["sha512"]),
42         ("sha256", expecteds["sha256"]),
43         ("blowfish", expecteds["blowfish"]),
44         ("md5", expecteds["md5"]),
45         ("crypt", expecteds[</b></font>"crypt"]),
46     ],
47 )
48 def test_gen_hash_crypt(algorithm, expected):
49     with patch("salt.utils.pycrypto.methods", {}):
50         ret = salt.utils.pycrypto.gen_hash(
51             crypt_salt=expected["salt"], password=passwd, algorithm=algorithm
52         )
53         assert ret == expected["hashed"]
54         ret = salt.utils.pycrypto.gen_hash(
55             crypt_salt=expected["badsalt"], password=passwd, algorithm=algorithm
56         )
57         assert ret != expected["hashed"]
58         ret = salt.utils.pycrypto.gen_hash(
59             crypt_salt=None, password=passwd, algorithm=algorithm
60         )
61         assert ret != expected["hashed"]
62 @pytest.mark.skipif(not salt.utils.pycrypto.HAS_CRYPT, reason="crypt not available")
63 def test_gen_hash_crypt_no_arguments():
64     assert salt.utils.pycrypto.gen_hash() is not None
65 def test_gen_hash_crypt_default_algorithm():
66     default_algorithm <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= salt.utils.pycrypto.crypt.methods[0].name.lower()
67     expected = expecteds[default_algorithm]
68     ret = salt.</b></font>utils.pycrypto.gen_hash(crypt_salt=expected["salt"], password=passwd)
69     assert ret == expected["hashed"]
70 @pytest.mark.skipif(not salt.utils.pycrypto.HAS_PASSLIB, reason="passlib not available")
71     "algorithm, expected",
72     [
73         <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("sha512", expecteds["sha512"]),
74         ("sha256", expecteds["sha256"]),
75         ("blowfish", expecteds["blowfish"]),
76         ("md5", expecteds["md5"]),
77         ("crypt", expecteds["crypt"]),
78     ],
79 )
80 def</b></font> test_gen_hash_passlib(algorithm, expected):
81     with patch("salt.utils.pycrypto.methods", {}):
82         with patch("salt.utils.pycrypto.HAS_CRYPT", False):
83             ret = salt.utils.pycrypto.gen_hash(
84                 crypt_salt=expected["salt"], password=passwd, algorithm=algorithm
85             )
86             assert ret == expected["hashed"]
87             ret = salt.utils.pycrypto.gen_hash(
88                 crypt_salt=expected["badsalt"], password=passwd, algorithm=algorithm
89             )
90             assert ret != expected["hashed"]
91             ret = salt.utils.pycrypto.gen_hash(
92                 crypt_salt=None, password=passwd, algorithm=algorithm
93             )
94             assert ret != expected["hashed"]
95 @pytest.mark.skipif(not salt.utils.pycrypto.HAS_PASSLIB, reason="passlib not available")
96 def test_gen_hash_passlib_no_arguments():
97     assert salt.utils.pycrypto.gen_hash() is not None
98 def test_gen_hash_passlib_default_algorithm():
99     default_algorithm = salt.utils.pycrypto.known_methods[0]
100     expected = expecteds[default_algorithm]
101     if default_algorithm in expected:
102         ret = salt.utils.pycrypto.gen_hash(crypt_salt=expected["salt"], password=passwd)
103         assert ret == expected["hashed"]
104 def test_gen_hash_no_lib():
105     with patch("salt.utils.pycrypto.HAS_CRYPT", False):
106         with patch("salt.utils.pycrypto.HAS_PASSLIB", False):
107             with pytest.raises(SaltInvocationError):
108                 salt.utils.pycrypto.gen_hash()
109 def test_gen_hash_selection():
110     with patch("salt.utils.pycrypto.HAS_CRYPT", True):
111         with patch("salt.utils.pycrypto.methods", {"crypt": None}):
112             with patch("salt.utils.pycrypto.HAS_PASSLIB", True):
113                 with patch(
114                     "salt.utils.pycrypto._gen_hash_crypt", autospec=True
115                 ) as gh_crypt:
116                     with patch(
117                         "salt.utils.pycrypto._gen_hash_passlib", autospec=True
118                     ) as gh_passlib:
119                             salt.utils.pycrypto.gen_hash(algorithm="doesntexist")
120                         salt<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.utils.pycrypto.gen_hash(algorithm="crypt")
121                         gh_crypt.assert_called_once()
122                         gh_passlib.assert_not_called()
123                         gh_crypt.reset_mock()
124                         salt.utils.</b></font>pycrypto.gen_hash(algorithm="sha512")
125                         gh_crypt.assert_not_called()
126                         gh_passlib.assert_called_once()
127 def test_gen_hash_crypt_warning(caplog):
128     with caplog.at_level(logging.WARNING):
129         with contextlib.suppress(Exception):
130             salt.utils.pycrypto.gen_hash(
131                 crypt_salt="toolong", password=passwd, algorithm="crypt"
132             )
133     assert "Hash salt is too long for 'crypt' hash." in caplog.text
134 def test_secure_password():
135     with patch("salt.utils.pycrypto.HAS_RANDOM", True):
136         ret = salt.utils.pycrypto.secure_password()
137         check = re.compile(r"[!@#$%^&amp;*()_=+]")
138         check_printable = re.compile(
139             r"[^{}]".format(
140                 re.escape(
141                     string.ascii_lowercase
142                     + string.ascii_uppercase
143                     + string.digits
144                     + string.punctuation
145                 )
146             )
147         )
148         check_whitespace = re.compile(r"[{}]".format(string.whitespace))
149         assert check_printable.search(ret) is None
150         assert check_whitespace.search(ret) is None
151         assert ret
152         assert salt.utils.pycrypto.secure_password(length=1, chars="A") == "A"
153         assert len(salt.utils.pycrypto.secure_password(length=64)) == 64
154 def test_secure_password_all_chars():
155     with patch("salt.utils.pycrypto.HAS_RANDOM", True):
156         ret = salt.utils.pycrypto.secure_password(
157             lowercase=True,
158             uppercase=True,
159             digits=True,
160             punctuation=True,
161             whitespace=True,
162             printable=True,
163         )
164         check = re.compile(r"[^{}]".format(re.escape(string.printable)))
165         assert check.search(ret) is None
166         assert ret
167 def test_secure_password_no_has_random():
168     test secure_password
169     """
170     with patch<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("salt.utils.pycrypto.HAS_RANDOM", False):
171         ret = salt.utils.pycrypto.secure_password()
172         check_printable = re.compile(
173             r"[^{}]".format(
174                 re.escape(
175                     string.ascii_lowercase
176                     + string.</b></font>ascii_uppercase
177                     + string.digits
178                     + string.punctuation
179                 )
180             )
181         )
182         check_whitespace = re.compile(r"[{}]".format(string.whitespace))
183         assert check_printable.search(ret) is None
184         assert check_whitespace.search(ret) is None
185         assert ret
186         assert salt.utils.pycrypto.secure_password(length=1, chars="A") == "A"
187         assert len(salt.utils.pycrypto.secure_password(length=64)) == 64
188 def test_secure_password_all_chars_no_has_random():
189     """
190     test secure_password
191     """
192     with patch("salt.utils.pycrypto.HAS_RANDOM", False):
193         ret = salt.utils.pycrypto.secure_password(printable=True)
194         check = re.compile("[^{}]".format(re.escape(string.printable)))
195         assert check.search(ret) is None
196         assert ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_boto_apigateway.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import datetime
2 import logging
3 import os
4 import random
5 import string
6 import pytest
7 import salt.config
8 import salt.loader
9 import salt.states.boto_apigateway as boto_apigateway
10 import salt.utils.files
11 import salt.utils.yaml
12 from salt.utils.versions import LooseVersion
13 from tests.support.mixins import LoaderModuleMockMixin
14 from tests.support.mock import MagicMock, patch
15 from tests.support.unit import TestCase, skipIf
16 from tests.unit.modules.test_boto_apigateway import BotoApiGatewayTestCaseMixin
17 try:
18     import boto3
19     import botocore
20     from botocore.exceptions import ClientError
21     HAS_BOTO = True
22 except ImportError:
23     HAS_BOTO = False
24 required_boto3_version = "1.2.1"
25 required_botocore_version = "1.4.49"
26 region = "us-east-1"
27 access_key = "GKTADJGHEIQSXMKKRBJ08H"
28 secret_key = "askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs"
29 conn_parameters = {
30     "region": region,
31     "key": access_key,
32     "keyid": secret_key,
33     "profile": {},
34 }
35 error_message = (
36     "An error occurred (101) when calling the {0} operation: Test-defined error"
37 )
38 error_content = {"Error": {"Code": 101, "Message": "Test-defined error"}}
39 api_ret = dict(
40     description=(
41         '{\n    "context": "See deployment or stage description",\n   '
42         ' "provisioned_by": "Salt boto_apigateway.present State"\n}'
43     ),
44     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
45     id="vni0vq8wzi",
46     name="unit test api",
47 )
48 no_apis_ret = {"items": []}
49 apis_ret = {"items": [api_ret]}
50 mock_model_ret = dict(
51     contentType="application/json",
52     description="mock model",
53     id="123abc",
54     name="mock model",
55     schema=(
56         "{\n"
57         '    "$schema": "http://json-schema.org/draft-04/schema#",\n'
58         '    "properties": {\n'
59         '        "field": {\n'
60         '            "type": "string"\n'
61         "        }\n"
62         "    }\n"
63         "}"
64     ),
65 )
66 models_ret = {
67     "items": [
68         dict(
69             contentType="application/json",
70             description="Error",
71             id="50nw8r",
72             name="Error",
73             schema=(
74                 "{\n"
75                 '    "$schema": "http://json-schema.org/draft-04/schema#",\n'
76                 '    "properties": {\n'
77                 '        "code": {\n'
78                 '            "format": "int32",\n'
79                 '            "type": "integer"\n'
80                 "        },\n"
81                 '        "fields": {\n'
82                 '            "type": "string"\n'
83                 "        },\n"
84                 '        "message": {\n'
85                 '            "type": "string"\n'
86                 "        }\n"
87                 "    },\n"
88                 '    "title": "Error Schema",\n'
89                 '    "type": "object"\n'
90                 "}"
91             ),
92         ),
93         dict(
94             contentType="application/json",
95             description="User",
96             id="terlnw",
97             name="User",
98             schema=(
99                 "{\n"
100                 '    "$schema": "http://json-schema.org/draft-04/schema#",\n'
101                 '    "properties": {\n'
102                 '        "password": {\n'
103                 '            "description": "A password for the new user",\n'
104                 '            "type": "string"\n'
105                 "        },\n"
106                 '        "username": {\n'
107                 '            "description": "A unique username for the user",\n'
108                 '            "type": "string"\n'
109                 "        }\n"
110                 "    },\n"
111                 '    "title": "User Schema",\n'
112                 '    "type": "object"\n'
113                 "}"
114             ),
115         ),
116     ]
117 }
118 root_resources_ret = {"items": [dict(id="bgk0rk8rqb", path="/")]}
119 resources_ret = {
120     "items": [
121         dict(id="bgk0rk8rqb", path="/"),
122         dict(
123             id="9waiaz",
124             parentId="bgk0rk8rqb",
125             path="/users",
126             pathPart="users",
127             resourceMethods={"POST": {}},
128         ),
129     ]
130 }
131 no_resources_ret = {"items": []}
132 stage1_deployment1_ret = dict(
133     cacheClusterEnabled=False,
134     cacheClusterSize=0.5,
135     cacheClusterStatus="NOT_AVAILABLE",
136     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
137     deploymentId="kobnrb",
138     description=(
139         "{\n"
140         '    "current_deployment_label": {\n'
141         '        "api_name": "unit test api",\n'
142         '        "swagger_file": "temp-swagger-sample.yaml",\n'
143         '        "swagger_file_md5sum": "4fb17e43bab3a96e7f2410a1597cd0a5",\n'
144         '        "swagger_info_object": {\n'
145         '            "description": "salt boto apigateway unit test service",\n'
146         '            "title": "salt boto apigateway unit test service",\n'
147         '            "version": "0.0.0"\n'
148         "        }\n"
149         "    }\n"
150         "}"
151     ),
152     lastUpdatedDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
153     methodSettings=dict(),
154     stageName="test",
155     variables=dict(),
156 )
157 stage1_deployment1_vars_ret = dict(
158     cacheClusterEnabled=False,
159     cacheClusterSize=0.5,
160     cacheClusterStatus="NOT_AVAILABLE",
161     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
162     deploymentId="kobnrb",
163     description=(
164         "{\n"
165         '    "current_deployment_label": {\n'
166         '        "api_name": "unit test api",\n'
167         '        "swagger_file": "temp-swagger-sample.yaml",\n'
168         '        "swagger_file_md5sum": "4fb17e43bab3a96e7f2410a1597cd0a5",\n'
169         '        "swagger_info_object": {\n'
170         '            "description": "salt boto apigateway unit test service",\n'
171         '            "title": "salt boto apigateway unit test service",\n'
172         '            "version": "0.0.0"\n'
173         "        }\n"
174         "    }\n"
175         "}"
176     ),
177     lastUpdatedDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
178     methodSettings=dict(),
179     stageName="test",
180     variables={"var1": "val1"},
181 )
182 stage1_deployment2_ret = dict(
183     cacheClusterEnabled=False,
184     cacheClusterSize=0.5,
185     cacheClusterStatus="NOT_AVAILABLE",
186     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
187     deploymentId="kobnrc",
188     description=(
189         "{\n"
190         '    "current_deployment_label": {\n'
191         '        "api_name": "unit test api",\n'
192         '        "swagger_file": "temp-swagger-sample.yaml",\n'
193         '        "swagger_file_md5sum": "5fd538c4336ed5c54b4bf39ddf97c661",\n'
194         '        "swagger_info_object": {\n'
195         '            "description": "salt boto apigateway unit test service",\n'
196         '            "title": "salt boto apigateway unit test service",\n'
197         '            "version": "0.0.2"\n'
198         "        }\n"
199         "    }\n"
200         "}"
201     ),
202     lastUpdatedDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
203     methodSettings=dict(),
204     stageName="test",
205     variables=dict(),
206 )
207 stage2_ret = dict(
208     cacheClusterEnabled=False,
209     cacheClusterSize=0.5,
210     cacheClusterStatus="NOT_AVAILABLE",
211     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
212     deploymentId="kobnrb",
213     description=(
214         "{\n"
215         '    "current_deployment_label": {\n'
216         '        "api_name": "unit test api",\n'
217         '        "swagger_file": "temp-swagger-sample.yaml",\n'
218         '        "swagger_file_md5sum": "4fb17e43bab3a96e7f2410a1597cd0a5",\n'
219         '        "swagger_info_object": {\n'
220         '            "description": "salt boto apigateway unit test service",\n'
221         '            "title": "salt boto apigateway unit test service",\n'
222         '            "version": "0.0.0"\n'
223         "        }\n"
224         "    }\n"
225         "}"
226     ),
227     lastUpdatedDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
228     methodSettings=dict(),
229     stageName="dev",
230     variables=dict(),
231 )
232 stages_stage2_ret = {"item": [stage2_ret]}
233 no_stages_ret = {"item": []}
234 deployment1_ret = dict(
235     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
236     description=(
237         "{\n"
238         '    "api_name": "unit test api",\n'
239         '    "swagger_file": "temp-swagger-sample.yaml",\n'
240         '    "swagger_file_md5sum": "55a948ff90ad80ff747ec91657c7a299",\n'
241         '    "swagger_info_object": {\n'
242         '        "description": "salt boto apigateway unit test service",\n'
243         '        "title": "salt boto apigateway unit test service",\n'
244         '        "version": "0.0.0"\n'
245         "    }\n"
246         "}"
247     ),
248     id="kobnrb",
249 )
250 deployment2_ret = dict(
251     createdDate=datetime.datetime(2015, 11, 17, 16, 33, 50),
252     description=(
253         "{\n"
254         '    "api_name": "unit test api",\n'
255         '    "swagger_file": "temp-swagger-sample.yaml",\n'
256         '    "swagger_file_md5sum": "5fd538c4336ed5c54b4bf39ddf97c661",\n'
257         '    "swagger_info_object": {\n'
258         '        "description": "salt boto apigateway unit test service",\n'
259         '        "title": "salt boto apigateway unit test service",\n'
260         '        "version": "0.0.2"\n'
261         "    }\n"
262         "}"
263     ),
264     id="kobnrc",
265 )
266 deployments_ret = {"items": [deployment1_ret, deployment2_ret]}
267 function_ret = dict(
268     FunctionName="unit_test_api_users_post",
269     Runtime="python2.7",
270     Role=None,
271     Handler="handler",
272     Description="abcdefg",
273     Timeout=5,
274     MemorySize=128,
275     CodeSha256="abcdef",
276     CodeSize=199,
277     FunctionArn="arn:lambda:us-east-1:1234:Something",
278     LastModified="yes",
279 )
280 method_integration_response_200_ret = dict(
281     responseParameters={"method.response.header.Access-Control-Allow-Origin": "*"},
282     responseTemplates={},
283     selectionPattern=".*",
284     statusCode="200",
285 )
286 method_integration_ret = dict(
287     cacheKeyParameters={},
288     cacheNamespace="9waiaz",
289     credentials="arn:aws:iam::1234:role/apigatewayrole",
290     httpMethod="POST",
291     integrationResponses={"200": method_integration_response_200_ret},
292     requestParameters={},
293     requestTemplates={
294         "application/json": (
295             "#set($inputRoot = $input.path('$')){\"header-params\" : {#set ($map ="
296             ' $input.params().header)#foreach( $param in $map.entrySet() )"$param.key"'
297             ' : "$param.value" #if( $foreach.hasNext ), #end#end},"query-params" :'
298             " {#set ($map = $input.params().querystring)#foreach( $param in"
299             ' $map.entrySet() )"$param.key" : "$param.value" #if( $foreach.hasNext ),'
300             ' #end#end},"path-params" : {#set ($map = $input.params().path)#foreach('
301             ' $param in $map.entrySet() )"$param.key" : "$param.value" #if('
302             " $foreach.hasNext ), #end#end},\"body-params\" : $input.json('$')}"
303         )
304     },
305     type="AWS",
306     uri=(
307         "arn:aws:apigateway:us-west-2:"
308         "lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:1234567:"
309         "function:unit_test_api_api_users_post/invocations"
310     ),
311 )
312 method_response_200_ret = dict(
313     responseModels={"application/json": "User"},
314     responseParameters={"method.response.header.Access-Control-Allow-Origin": False},
315     statusCode="200",
316 )
317 method_ret = dict(
318     apiKeyRequired=False,
319     authorizationType="None",
320     httpMethod="POST",
321     methodIntegration=method_integration_ret,
322     methodResponses={"200": method_response_200_ret},
323     requestModels={"application/json": "User"},
324     requestParameters={},
325 )
326 throttle_rateLimit = 10.0
327 association_stage_1 = {"apiId": "apiId1", "stage": "stage1"}
328 association_stage_2 = {"apiId": "apiId1", "stage": "stage2"}
329 log = logging.getLogger(__name__)
330 def _has_required_boto():
331     """
332     Returns True/False boolean depending on if Boto is installed and correct
333     version.
334     """
335     if not HAS_BOTO:
336         return False
337     elif LooseVersion(boto3.__version__) &lt; LooseVersion(required_boto3_version):
338         return False
339     else:
340         return True
341 def _has_required_botocore():
342     """
343     Returns True/False boolean depending on if botocore supports usage plan
344     """
345     if not HAS_BOTO:
346         return False
347     elif LooseVersion(botocore.__version__) &lt; LooseVersion(required_botocore_version):
348         return False
349     else:
350         return True
351 class TempSwaggerFile:
352     _tmp_swagger_dict <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= {
353         "info": {
354             "version": "0.0.0",
355             "description": "salt boto apigateway unit test service",
356             "title": "salt boto apigateway unit test service",
357         },
358         "paths": {
359             "/users": {
360                 "post": {
361                     "responses": {
362                         "200": {
363                             "headers": {
364                                 "Access-Control-Allow-Origin": {"type": "string"}
365                             },
366                             "description": "The username of the new user",
367                             "schema": {"$ref": "#/definitions/User"},
368                         }
369                     },
370                     "parameters": [
371                         {</b></font>
372                             "description": "New user details.",
373                             "name": "NewUser",
374                             "schema": {<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"$ref": "#/definitions/User"},
375                         }
376                     ],
377                     "produces": ["application/json"],
378                     "description": "Creates a new user.",
379                     "tags": ["Auth"],
380                     "consumes": ["application/json"],
381                     "summary": "Registers a new user",
382                 }
383             }
384         },
385         "schemes": ["https"],
386         "produces": ["application/json"],
387         "basePath": "/api",
388         "host": "rm06h9oac4.execute-api.us-west-2.amazonaws.com",
389         "definitions": {
390             "User": {
391                 "properties": {
392                     "username": {
393                         "type": "string",
394                         "description": "A unique username for the user",
395                     },
396                     "password": {
397                         "type": "string",
398                         "description": "A password for the new user",
399                     },
400                 }
401             },
402             "Error": {
403                 "properties": {
404                     "fields": {"type": "string"},
405                     "message": {"type": "string"},
406                     "code": {"type": "integer", "format": "int32"},
407                 }
408             },
409         },
410         "swagger": "2.0",
411     }
412     def</b></font> __enter__(self):
413         self.swaggerfile = "temp-swagger-sample.yaml"
414         with salt.utils.files.fopen(self.swaggerfile, "w") as fp_:
415             salt.utils.yaml.safe_dump(self.swaggerdict, fp_, default_flow_style=False)
416         return self.swaggerfile
417     def __exit__(self, objtype, value, traceback):
418         os.remove(self.swaggerfile)
419     def __init__(self, create_invalid_file=False):
420         if create_invalid_file:
421             self.swaggerdict = TempSwaggerFile._tmp_swagger_dict.copy()
422             self.swaggerdict["invalid_key"] = "invalid"
423             self.swaggerdict.pop("schemes", None)
424             self.swaggerdict["swagger"] = "3.0"
425             self.swaggerdict.pop("info", None)
426         else:
427             self.swaggerdict = TempSwaggerFile._tmp_swagger_dict
428 class BotoApiGatewayStateTestCaseBase(TestCase, LoaderModuleMockMixin):
429     conn = None
430     @classmethod
431     def setUpClass(cls):
432         cls.opts = salt.config.DEFAULT_MINION_OPTS.copy()
433         cls.opts["grains"] = salt.loader.grains(cls.opts)
434     @classmethod
435     def tearDownClass(cls):
436         del cls.opts
437     def setup_loader_modules(self):
438         context = {}
439         utils = salt.loader.utils(
440             self.opts,
441             whitelist=["boto", "boto3", "args", "systemd", "path", "platform", "reg"],
442             context=context,
443         )
444         serializers = salt.loader.serializers(self.opts)
445         self.funcs = salt.loader.minion_mods(
446             self.opts, context=context, utils=utils, whitelist=["boto_apigateway"]
447         )
448         self.salt_states = salt.loader.states(
449             opts=self.opts,
450             functions=self.funcs,
451             utils=utils,
452             whitelist=["boto_apigateway"],
453             serializers=serializers,
454         )
455         return {
456             boto_apigateway: {
457                 "__opts__": self.opts,
458                 "__utils__": utils,
459                 "__salt__": self.funcs,
460                 "__states__": self.salt_states,
461                 "__serializers__": serializers,
462             }
463         }
464     def setUp(self):
465         self.addCleanup(delattr, self, "funcs")
466         self.addCleanup(delattr, self, "salt_states")
467         conn_parameters["key"] = "".join(
468             random.choice(string.ascii_lowercase + string.digits) for _ in range(50)
469         )
470         patcher = patch("boto3.session.Session")
471         self.addCleanup(patcher.stop)
472         mock_session = patcher.start()
473         session_instance = mock_session.return_value
474         self.conn = MagicMock()
475         self.addCleanup(delattr, self, "conn")
476         session_instance.client.return_value = self.conn
477 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
478 @skipIf(
479     _has_required_boto() is False,
480     "The boto3 module must be greater than or equal to version {}".format(
481         required_boto3_version
482     ),
483 )
484 class BotoApiGatewayTestCase(
485     BotoApiGatewayStateTestCaseBase, BotoApiGatewayTestCaseMixin
486 ):
487     """
488     TestCase for salt.modules.boto_apigateway state.module
489     """
490     def test_present_when_swagger_file_is_invalid(self):
491         """
492         Tests present when the swagger file is invalid.
493         """
494         result = {}
495         with TempSwaggerFile(create_invalid_file=True) as swagger_file:
496             result = self.salt_states["boto_apigateway.present"](
497                 "api present",
498                 "unit test api",
499                 swagger_file,
500                 "test",
501                 False,
502                 "arn:aws:iam::1234:role/apigatewayrole",
503                 **conn_parameters
504             )
505         self.assertFalse(result.get("result", True))
506     def test_present_when_stage_is_already_at_desired_deployment(self):
507         """
508         Tests scenario where no action will be taken since we're already
509         at desired state
510         """
511         self.conn.get_rest_apis.return_value = apis_ret
512         self.conn.get_deployment.return_value = deployment1_ret
513         self.conn.get_stage.return_value = stage1_deployment1_ret
514         self.conn.update_stage.side_effect = ClientError(
515             error_content, "update_stage should not be called"
516         )
517         result = {}
518         with TempSwaggerFile() as swagger_file:
519             result = self.salt_states["boto_apigateway.present"](
520                 "api present",
521                 "unit test api",
522                 swagger_file,
523                 "test",
524                 False,
525                 "arn:aws:iam::1234:role/apigatewayrole",
526                 **conn_parameters
527             )
528         self.assertFalse(result.get("abort"))
529         self.assertTrue(result.get("current"))
530         self.assertIs(result.get("result"), True)
531         self.assertNotIn("update_stage should not be called", result.get("comment", ""))
532     def test_present_when_stage_is_already_at_desired_deployment_and_needs_stage_variables_update(
533         self,
534     ):
535         """
536         Tests scenario where the deployment is current except for the need to update stage variables
537         from {} to {'var1':'val1'}
538         """
539         self.conn.get_rest_apis.return_value = apis_ret
540         self.conn.get_deployment.return_value = deployment1_ret
541         self.conn.get_stage.return_value = stage1_deployment1_ret
542         self.conn.update_stage.return_value = stage1_deployment1_vars_ret
543         result = {}
544         with TempSwaggerFile() as swagger_file:
545             result = self.salt_states["boto_apigateway.present"](
546                 "api present",
547                 "unit test api",
548                 swagger_file,
549                 "test",
550                 False,
551                 "arn:aws:iam::1234:role/apigatewayrole",
552                 stage_variables={"var1": "val1"},
553                 **conn_parameters
554             )
555         self.assertFalse(result.get("abort"))
556         self.assertTrue(result.get("current"))
557         self.assertIs(result.get("result"), True)
558     def test_present_when_stage_exists_and_is_to_associate_to_existing_deployment(self):
559         """
560         Tests scenario where we merely reassociate a stage to a pre-existing
561         deployments
562         """
563         self.conn.get_rest_apis.return_value = apis_ret
564         self.conn.get_deployment.return_value = deployment2_ret
565         self.conn.get_deployments.return_value = deployments_ret
566         self.conn.get_stage.return_value = stage1_deployment2_ret
567         self.conn.update_stage.return_value = stage1_deployment1_ret
568         self.conn.create_stage.side_effect = ClientError(error_content, "create_stage")
569         self.conn.create_deployment.side_effect = ClientError(
570             error_content, "create_deployment"
571         )
572         result = {}
573         with TempSwaggerFile() as swagger_file:
574             result = self.salt_states["boto_apigateway.present"](
575                 "api present",
576                 "unit test api",
577                 swagger_file,
578                 "test",
579                 False,
580                 "arn:aws:iam::1234:role/apigatewayrole",
581                 **conn_parameters
582             )
583         self.assertTrue(result.get("publish"))
584         self.assertIs(result.get("result"), True)
585         self.assertFalse(result.get("abort"))
586         self.assertTrue(result.get("changes", {}).get("new", [{}])[0])
587     @pytest.mark.slow_test
588     def test_present_when_stage_is_to_associate_to_new_deployment(self):
589         """
590         Tests creation of a new api/model/resource given nothing has been created previously
591         """
592         self.conn.get_rest_apis.return_value = no_apis_ret
593         self.conn.create_rest_api.return_value = api_ret
594         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
595         self.conn.create_model.return_value = mock_model_ret
596         self.conn.get_resources.return_value = resources_ret
597         self.conn.create_resource.side_effect = ClientError(
598             error_content, "create_resource"
599         )
600         self.conn.put_method.return_value = method_ret
601         self.conn.put_integration.return_value = method_integration_ret
602         self.conn.put_method_response.return_value = method_response_200_ret
603         self.conn.put_intgration_response.return_value = (
604             method_integration_response_200_ret
605         )
606         result = {}
607         with patch.dict(
608             self.funcs,
609             {
610                 "boto_lambda.describe_function": MagicMock(
611                     return_value={"function": function_ret}
612                 )
613             },
614         ):
615             with TempSwaggerFile() as swagger_file:
616                 result = self.salt_states["boto_apigateway.present"](
617                     "api present",
618                     "unit test api",
619                     swagger_file,
620                     "test",
621                     False,
622                     "arn:aws:iam::1234:role/apigatewayrole",
623                     **conn_parameters
624                 )
625         self.assertIs(result.get("result"), True)
626         self.assertIs(result.get("abort"), None)
627     def test_present_when_stage_associating_to_new_deployment_errored_on_api_creation(
628         self,
629     ):
630         """
631         Tests creation of a new api/model/resource given nothing has been created previously,
632         and we failed on creating the top level api object.
633         """
634         self.conn.get_rest_apis.return_value = no_apis_ret
635         self.conn.create_rest_api.side_effect = ClientError(
636             error_content, "create_rest_api"
637         )
638         result = {}
639         with TempSwaggerFile() as swagger_file:
640             result = self.salt_states["boto_apigateway.present"](
641                 "api present",
642                 "unit test api",
643                 swagger_file,
644                 "test",
645                 False,
646                 "arn:aws:iam::1234:role/apigatewayrole",
647                 **conn_parameters
648             )
649         self.assertIs(result.get("abort"), True)
650         self.assertIs(result.get("result"), False)
651         self.assertIn("create_rest_api", result.get("comment", ""))
652     def test_present_when_stage_associating_to_new_deployment_errored_on_model_creation(
653         self,
654     ):
655         """
656         Tests creation of a new api/model/resource given nothing has been created previously,
657         and we failed on creating the models after successful creation of top level api object.
658         """
659         self.conn.get_rest_apis.return_value = no_apis_ret
660         self.conn.create_rest_api.return_value = api_ret
661         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
662         self.conn.create_model.side_effect = ClientError(error_content, "create_model")
663         result = {}
664         with TempSwaggerFile() as swagger_file:
665             result = self.salt_states["boto_apigateway.present"](
666                 "api present",
667                 "unit test api",
668                 swagger_file,
669                 "test",
670                 False,
671                 "arn:aws:iam::1234:role/apigatewayrole",
672                 **conn_parameters
673             )
674         self.assertIs(result.get("abort"), True)
675         self.assertIs(result.get("result"), False)
676         self.assertIn("create_model", result.get("comment", ""))
677     def test_present_when_stage_associating_to_new_deployment_errored_on_resource_creation(
678         self,
679     ):
680         """
681         Tests creation of a new api/model/resource given nothing has been created previously,
682         and we failed on creating the resource (paths) after successful creation of top level api/model
683         objects.
684         """
685         self.conn.get_rest_apis.return_value = no_apis_ret
686         self.conn.create_rest_api.return_value = api_ret
687         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
688         self.conn.create_model.return_value = mock_model_ret
689         self.conn.get_resources.return_value = root_resources_ret
690         self.conn.create_resource.side_effect = ClientError(
691             error_content, "create_resource"
692         )
693         result = {}
694         with TempSwaggerFile() as swagger_file:
695             result = self.salt_states["boto_apigateway.present"](
696                 "api present",
697                 "unit test api",
698                 swagger_file,
699                 "test",
700                 False,
701                 "arn:aws:iam::1234:role/apigatewayrole",
702                 **conn_parameters
703             )
704         self.assertIs(result.get("abort"), True)
705         self.assertIs(result.get("result"), False)
706         self.assertIn("create_resource", result.get("comment", ""))
707     @pytest.mark.slow_test
708     def test_present_when_stage_associating_to_new_deployment_errored_on_put_method(
709         self,
710     ):
711         """
712         Tests creation of a new api/model/resource given nothing has been created previously,
713         and we failed on adding a post method to the resource after successful creation of top level
714         api, model, resource objects.
715         """
716         self.conn.get_rest_apis.return_value = no_apis_ret
717         self.conn.create_rest_api.return_value = api_ret
718         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
719         self.conn.create_model.return_value = mock_model_ret
720         self.conn.get_resources.return_value = resources_ret
721         self.conn.create_resource.side_effect = ClientError(
722             error_content, "create_resource"
723         )
724         self.conn.put_method.side_effect = ClientError(error_content, "put_method")
725         result = {}
726         with patch.dict(
727             self.funcs,
728             {
729                 "boto_lambda.describe_function": MagicMock(
730                     return_value={"function": function_ret}
731                 )
732             },
733         ):
734             with TempSwaggerFile() as swagger_file:
735                 result = self.salt_states["boto_apigateway.present"](
736                     "api present",
737                     "unit test api",
738                     swagger_file,
739                     "test",
740                     False,
741                     "arn:aws:iam::1234:role/apigatewayrole",
742                     **conn_parameters
743                 )
744         self.assertIs(result.get("abort"), True)
745         self.assertIs(result.get("result"), False)
746         self.assertIn("put_method", result.get("comment", ""))
747     @pytest.mark.slow_test
748     def test_present_when_stage_associating_to_new_deployment_errored_on_lambda_function_lookup(
749         self,
750     ):
751         """
752         Tests creation of a new api/model/resource given nothing has been created previously,
753         and we failed on adding a post method due to a lamda look up failure after successful
754         creation of top level api, model, resource objects.
755         """
756         self.conn.get_rest_apis.return_value = no_apis_ret
757         self.conn.create_rest_api.return_value = api_ret
758         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
759         self.conn.create_model.return_value = mock_model_ret
760         self.conn.get_resources.return_value = resources_ret
761         self.conn.create_resource.side_effect = ClientError(
762             error_content, "create_resource"
763         )
764         self.conn.put_method.return_value = method_ret
765         self.conn.put_integration.side_effect = ClientError(
766             error_content, "put_integration should not be invoked"
767         )
768         result = {}
769         with patch.dict(
770             self.funcs,
771             {
772                 "boto_lambda.describe_function": MagicMock(
773                     return_value={"error": "no such lambda"}
774                 )
775             },
776         ):
777             with TempSwaggerFile() as swagger_file:
778                 result = self.salt_states["boto_apigateway.present"](
779                     "api present",
780                     "unit test api",
781                     swagger_file,
782                     "test",
783                     False,
784                     "arn:aws:iam::1234:role/apigatewayrole",
785                     **conn_parameters
786                 )
787         self.assertIs(result.get("result"), False)
788         self.assertNotIn(
789             "put_integration should not be invoked", result.get("comment", "")
790         )
791         self.assertIn("not find lambda function", result.get("comment", ""))
792     @pytest.mark.slow_test
793     def test_present_when_stage_associating_to_new_deployment_errored_on_put_integration(
794         self,
795     ):
796         """
797         Tests creation of a new api/model/resource given nothing has been created previously,
798         and we failed on adding an integration for the post method to the resource after
799         successful creation of top level api, model, resource objects.
800         """
801         self.conn.get_rest_apis.return_value = no_apis_ret
802         self.conn.create_rest_api.return_value = api_ret
803         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
804         self.conn.create_model.return_value = mock_model_ret
805         self.conn.get_resources.return_value = resources_ret
806         self.conn.create_resource.side_effect = ClientError(
807             error_content, "create_resource"
808         )
809         self.conn.put_method.return_value = method_ret
810         self.conn.put_integration.side_effect = ClientError(
811             error_content, "put_integration"
812         )
813         result = {}
814         with patch.dict(
815             self.funcs,
816             {
817                 "boto_lambda.describe_function": MagicMock(
818                     return_value={"function": function_ret}
819                 )
820             },
821         ):
822             with TempSwaggerFile() as swagger_file:
823                 result = self.salt_states["boto_apigateway.present"](
824                     "api present",
825                     "unit test api",
826                     swagger_file,
827                     "test",
828                     False,
829                     "arn:aws:iam::1234:role/apigatewayrole",
830                     **conn_parameters
831                 )
832         self.assertIs(result.get("abort"), True)
833         self.assertIs(result.get("result"), False)
834         self.assertIn("put_integration", result.get("comment", ""))
835     @pytest.mark.slow_test
836     def test_present_when_stage_associating_to_new_deployment_errored_on_put_method_response(
837         self,
838     ):
839         """
840         Tests creation of a new api/model/resource given nothing has been created previously,
841         and we failed on adding a method response for the post method to the resource after
842         successful creation of top level api, model, resource objects.
843         """
844         self.conn.get_rest_apis.return_value = no_apis_ret
845         self.conn.create_rest_api.return_value = api_ret
846         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
847         self.conn.create_model.return_value = mock_model_ret
848         self.conn.get_resources.return_value = resources_ret
849         self.conn.create_resource.side_effect = ClientError(
850             error_content, "create_resource"
851         )
852         self.conn.put_method.return_value = method_ret
853         self.conn.put_integration.return_value = method_integration_ret
854         self.conn.put_method_response.side_effect = ClientError(
855             error_content, "put_method_response"
856         )
857         result = {}
858         with patch.dict(
859             self.funcs,
860             {
861                 "boto_lambda.describe_function": MagicMock(
862                     return_value={"function": function_ret}
863                 )
864             },
865         ):
866             with TempSwaggerFile() as swagger_file:
867                 result = self.salt_states["boto_apigateway.present"](
868                     "api present",
869                     "unit test api",
870                     swagger_file,
871                     "test",
872                     False,
873                     "arn:aws:iam::1234:role/apigatewayrole",
874                     **conn_parameters
875                 )
876         self.assertIs(result.get("abort"), True)
877         self.assertIs(result.get("result"), False)
878         self.assertIn("put_method_response", result.get("comment", ""))
879     @pytest.mark.slow_test
880     def test_present_when_stage_associating_to_new_deployment_errored_on_put_integration_response(
881         self,
882     ):
883         """
884         Tests creation of a new api/model/resource given nothing has been created previously,
885         and we failed on adding an integration response for the post method to the resource after
886         successful creation of top level api, model, resource objects.
887         """
888         self.conn.get_rest_apis.return_value = no_apis_ret
889         self.conn.create_rest_api.return_value = api_ret
890         self.conn.get_model.side_effect = ClientError(error_content, "get_model")
891         self.conn.create_model.return_value = mock_model_ret
892         self.conn.get_resources.return_value = resources_ret
893         self.conn.create_resource.side_effect = ClientError(
894             error_content, "create_resource"
895         )
896         self.conn.put_method.return_value = method_ret
897         self.conn.put_integration.return_value = method_integration_ret
898         self.conn.put_method_response.return_value = method_response_200_ret
899         self.conn.put_integration_response.side_effect = ClientError(
900             error_content, "put_integration_response"
901         )
902         result = {}
903         with patch.dict(
904             self.funcs,
905             {
906                 "boto_lambda.describe_function": MagicMock(
907                     return_value={"function": function_ret}
908                 )
909             },
910         ):
911             with TempSwaggerFile() as swagger_file:
912                 result = self.salt_states["boto_apigateway.present"](
913                     "api present",
914                     "unit test api",
915                     swagger_file,
916                     "test",
917                     False,
918                     "arn:aws:iam::1234:role/apigatewayrole",
919                     **conn_parameters
920                 )
921         self.assertIs(result.get("abort"), True)
922         self.assertIs(result.get("result"), False)
923         self.assertIn("put_integration_response", result.get("comment", ""))
924     def test_absent_when_rest_api_does_not_exist(self):
925         """
926         Tests scenario where the given api_name does not exist, absent state should return True
927         with no changes.
928         """
929         self.conn.get_rest_apis.return_value = apis_ret
930         self.conn.get_stage.side_effect = ClientError(
931             error_content, "get_stage should not be called"
932         )
933         result = self.salt_states["boto_apigateway.absent"](
934             "api present",
935             "no_such_rest_api",
936             "no_such_stage",
937             nuke_api=False,
938             **conn_parameters
939         )
940         self.assertIs(result.get("result"), True)
941         self.assertNotIn("get_stage should not be called", result.get("comment", ""))
942         self.assertEqual(result.get("changes"), {})
943     def test_absent_when_stage_is_invalid(self):
944         """
945         Tests scenario where the stagename doesn't exist
946         """
947         self.conn.get_rest_apis.return_value = apis_ret
948         self.conn.get_stage.return_value = stage1_deployment1_ret
949         self.conn.delete_stage.side_effect = ClientError(error_content, "delete_stage")
950         result = self.salt_states["boto_apigateway.absent"](
951             "api present",
952             "unit test api",
953             "no_such_stage",
954             nuke_api=False,
955             **conn_parameters
956         )
957         self.assertTrue(result.get("abort", False))
958     def test_absent_when_stage_is_valid_and_only_one_stage_is_associated_to_deployment(
959         self,
960     ):
961         """
962         Tests scenario where the stagename exists
963         """
964         self.conn.get_rest_apis.return_value = apis_ret
965         self.conn.get_stage.return_value = stage1_deployment1_ret
966         self.conn.delete_stage.return_value = {
967             "ResponseMetadata": {
968                 "HTTPStatusCode": 200,
969                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
970             }
971         }
972         self.conn.get_stages.return_value = no_stages_ret
973         self.conn.delete_deployment.return_value = {
974             "ResponseMetadata": {
975                 "HTTPStatusCode": 200,
976                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
977             }
978         }
979         result = self.salt_states["boto_apigateway.absent"](
980             "api present", "unit test api", "test", nuke_api=False, **conn_parameters
981         )
982         self.assertTrue(result.get("result", False))
983     def test_absent_when_stage_is_valid_and_two_stages_are_associated_to_deployment(
984         self,
985     ):
986         """
987         Tests scenario where the stagename exists and there are two stages associated with same deployment
988         """
989         self.conn.get_rest_apis.return_value = apis_ret
990         self.conn.get_stage.return_value = stage1_deployment1_ret
991         self.conn.delete_stage.return_value = {
992             "ResponseMetadata": {
993                 "HTTPStatusCode": 200,
994                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
995             }
996         }
997         self.conn.get_stages.return_value = stages_stage2_ret
998         result = self.salt_states["boto_apigateway.absent"](
999             "api present", "unit test api", "test", nuke_api=False, **conn_parameters
1000         )
1001         self.assertTrue(result.get("result", False))
1002     def test_absent_when_failing_to_delete_a_deployment_no_longer_associated_with_any_stages(
1003         self,
1004     ):
1005         """
1006         Tests scenario where stagename exists and is deleted, but a failure occurs when trying to delete
1007         the deployment which is no longer associated to any other stages
1008         """
1009         self.conn.get_rest_apis.return_value = apis_ret
1010         self.conn.get_stage.return_value = stage1_deployment1_ret
1011         self.conn.delete_stage.return_value = {
1012             "ResponseMetadata": {
1013                 "HTTPStatusCode": 200,
1014                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
1015             }
1016         }
1017         self.conn.get_stages.return_value = no_stages_ret
1018         self.conn.delete_deployment.side_effect = ClientError(
1019             error_content, "delete_deployment"
1020         )
1021         result = self.salt_states["boto_apigateway.absent"](
1022             "api present", "unit test api", "test", nuke_api=False, **conn_parameters
1023         )
1024         self.assertTrue(result.get("abort", False))
1025     def test_absent_when_nuke_api_and_no_more_stages_deployments_remain(self):
1026         """
1027         Tests scenario where the stagename exists and there are no stages associated with same deployment,
1028         the api would be deleted.
1029         """
1030         self.conn.get_rest_apis.return_value = apis_ret
1031         self.conn.get_stage.return_value = stage1_deployment1_ret
1032         self.conn.delete_stage.return_value = {
1033             "ResponseMetadata": {
1034                 "HTTPStatusCode": 200,
1035                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
1036             }
1037         }
1038         self.conn.get_stages.return_value = no_stages_ret
1039         self.conn.get_deployments.return_value = deployments_ret
1040         self.conn.delete_rest_api.return_value = {
1041             "ResponseMetadata": {
1042                 "HTTPStatusCode": 200,
1043                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
1044             }
1045         }
1046         result = self.salt_states["boto_apigateway.absent"](
1047             "api present", "unit test api", "test", nuke_api=True, **conn_parameters
1048         )
1049         self.assertIs(result.get("result"), True)
1050         self.assertIsNot(result.get("abort"), True)
1051         self.assertIs(
1052             result.get("changes", {})
1053             .get("new", [{}])[0]
1054             .get("delete_api", {})
1055             .get("deleted"),
1056             True,
1057         )
1058     def test_absent_when_nuke_api_and_other_stages_deployments_exist(self):
1059         """
1060         Tests scenario where the stagename exists and there are two stages associated with same deployment,
1061         though nuke_api is requested, due to remaining deployments, we will not call the delete_rest_api call.
1062         """
1063         self.conn.get_rest_apis.return_value = apis_ret
1064         self.conn.get_stage.return_value = stage1_deployment1_ret
1065         self.conn.delete_stage.return_value = {
1066             "ResponseMetadata": {
1067                 "HTTPStatusCode": 200,
1068                 "RequestId": "2d31072c-9d15-11e5-9977-6d9fcfda9c0a",
1069             }
1070         }
1071         self.conn.get_stages.return_value = stages_stage2_ret
1072         self.conn.get_deployments.return_value = deployments_ret
1073         self.conn.delete_rest_api.side_effect = ClientError(
1074             error_content, "unexpected_api_delete"
1075         )
1076         result = self.salt_states["boto_apigateway.absent"](
1077             "api present", "unit test api", "test", nuke_api=True, **conn_parameters
1078         )
1079         self.assertIs(result.get("result"), True)
1080         self.assertIsNot(result.get("abort"), True)
1081 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
1082 @skipIf(
1083     _has_required_boto() is False,
1084     "The boto3 module must be greater than or equal to version {}".format(
1085         required_boto3_version
1086     ),
1087 )
1088 @skipIf(
1089     _has_required_botocore() is False,
1090     "The botocore module must be greater than or equal to version {}".format(
1091         required_botocore_version
1092     ),
1093 )
1094 class BotoApiGatewayUsagePlanTestCase(
1095     BotoApiGatewayStateTestCaseBase, BotoApiGatewayTestCaseMixin
1096 ):
1097     """
1098     TestCase for salt.modules.boto_apigateway state.module, usage_plans portion
1099     """
1100     @pytest.mark.slow_test
1101     def test_usage_plan_present_if_describe_fails(self, *args):
1102         """
1103         Tests correct error processing for describe_usage_plan failure
1104         """
1105         with patch.dict(
1106             boto_apigateway.__salt__,
1107             {
1108                 "boto_apigateway.describe_usage_plans": MagicMock(
1109                     return_value={"error": "error"}
1110                 )
1111             },
1112         ):
1113             result = boto_apigateway.usage_plan_present(
1114                 "name", "plan_name", **conn_parameters
1115             )
1116             self.assertIn("result", result)
1117             self.assertEqual(result["result"], False)
1118             self.assertIn("comment", result)
1119             self.assertEqual(
1120                 result["comment"], "Failed to describe existing usage plans"
1121             )
1122             self.assertIn("changes", result)
1123             self.assertEqual(result["changes"], {})
1124     @pytest.mark.slow_test
1125     def test_usage_plan_present_if_there_is_no_such_plan_and_test_option_is_set(
1126         self, *args
1127     ):
1128         """
1129         TestCse for salt.modules.boto_apigateway state.module, checking that if __opts__['test'] is set
1130         and usage plan does not exist, correct diagnostic will be returned
1131         """
1132         with patch.dict(boto_apigateway.__opts__, {"test": True}):
1133             with patch.dict(
1134                 boto_apigateway.__salt__,
1135                 {
1136                     "boto_apigateway.describe_usage_plans": MagicMock(
1137                         return_value={"plans": []}
1138                     )
1139                 },
1140             ):
1141                 result = boto_apigateway.usage_plan_present(
1142                     "name", "plan_name", **conn_parameters
1143                 )
1144                 self.assertIn("comment", result)
1145                 self.assertEqual(
1146                     result["comment"], "a new usage plan plan_name would be created"
1147                 )
1148                 self.assertIn("result", result)
1149                 self.assertEqual(result["result"], None)
1150     @pytest.mark.slow_test
1151     def test_usage_plan_present_if_create_usage_plan_fails(self, *args):
1152         """
1153         Tests behavior for the case when creating a new usage plan fails
1154         """
1155         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1156             with patch.dict(
1157                 boto_apigateway.__salt__,
1158                 {
1159                     "boto_apigateway.describe_usage_plans": MagicMock(
1160                         return_value={"plans": []}
1161                     ),
1162                     "boto_apigateway.create_usage_plan": MagicMock(
1163                         return_value={"error": "error"}
1164                     ),
1165                 },
1166             ):
1167                 result = boto_apigateway.usage_plan_present(
1168                     "name", "plan_name", **conn_parameters
1169                 )
1170                 self.assertIn("result", result)
1171                 self.assertEqual(result["result"], False)
1172                 self.assertIn("comment", result)
1173                 self.assertEqual(
1174                     result["comment"], "Failed to create a usage plan plan_name, error"
1175                 )
1176                 self.assertIn("changes", result)
1177                 self.assertEqual(result["changes"], {})
1178     @pytest.mark.slow_test
1179     def test_usage_plan_present_if_plan_is_there_and_needs_no_updates(self, *args):
1180         """
1181         Tests behavior for the case when plan is present and needs no updates
1182         """
1183         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1184                 boto_apigateway.__salt__,
1185                 {
1186                     "boto_apigateway.describe_usage_plans": MagicMock<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(
1187                         return_value={"plans": [{"id": "planid", "name": "planname"}]}
1188                     ),
1189                     "boto_apigateway.update_usage_plan": MagicMock(),
1190                 },
1191             ):
1192                 result = boto_apigateway.usage_plan_present(
1193                     "name", "plan_name", **conn_parameters
1194                 )
1195                 self.assertIn("result", result)
1196                 self.assertEqual(result["result"], True)
1197                 self.</b></font>assertIn("comment", result)
1198                 self.assertEqual(
1199                     result["comment"],
1200                     "usage plan plan_name is already in a correct state",
1201                 )
1202                 self.assertIn("changes", result)
1203                 self.assertEqual(result["changes"], {})
1204                 self.assertTrue(
1205                     boto_apigateway.__salt__[
1206                         "boto_apigateway.update_usage_plan"
1207                     ].call_count
1208                     == 0
1209                 )
1210     @pytest.mark.slow_test
1211     def test_usage_plan_present_if_plan_is_there_and_needs_updates_but_test_is_set(
1212         self, *args
1213     ):
1214         """
1215         Tests behavior when usage plan needs to be updated by tests option is set
1216         """
1217         with patch.dict(boto_apigateway.__opts__, {"test": True}):
1218             with patch.dict(
1219                 boto_apigateway.__salt__,
1220                 {
1221                         return_value={
1222                             "plans": [
1223                                 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
1224                                     "id": "planid",
1225                                     "name": "planname",
1226                                     "throttle": {"rateLimit": 10.0},
1227                                 }
1228                             ]
1229                         }
1230                     ),
1231                     "boto_apigateway.update_usage_plan": MagicMock(),
1232                 },
1233             ):
1234                 result = boto_apigateway.usage_plan_present(
1235                     "name", "plan_name", **conn_parameters
1236                 )
1237                 self.assertIn("comment", result)
1238                 self.assertEqual(
1239                     result["comment"], "a new usage plan plan_name would be updated"
1240                 )
1241                 self.</b></font>assertIn("result", result)
1242                 self.assertEqual(result["result"], None)
1243                 self.assertTrue(
1244                     boto_apigateway.__salt__[
1245                         "boto_apigateway.update_usage_plan"
1246                     ].call_count
1247                     == 0
1248                 )
1249     @pytest.mark.slow_test
1250     def test_usage_plan_present_if_plan_is_there_and_needs_updates_but_update_fails(
1251         self, *args
1252     ):
1253         """
1254         Tests error processing for the case when updating an existing usage plan fails
1255         """
1256         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1257             with patch.dict(
1258                 boto_apigateway.__salt__,
1259                 {
1260                     "boto_apigateway.describe_usage_plans": MagicMock(
1261                         return_value={
1262                             "plans": [
1263                                 {
1264                                     "id": "planid",
1265                                     "name": "planname",
1266                                     "throttle": {"rateLimit": 10.0},
1267                                 }
1268                             ]
1269                         }
1270                     ),
1271                     "boto_apigateway.update_usage_plan": MagicMock(
1272                         return_value={"error": "error"}
1273                     ),
1274                 },
1275             ):
1276                 result = boto_apigateway.usage_plan_present(
1277                     "name", "plan_name", **conn_parameters
1278                 )
1279                 self.assertIn("result", result)
1280                 self.assertEqual(result["result"], False)
1281                 self.assertIn("comment", result)
1282                 self.assertEqual(
1283                     result["comment"], "Failed to update a usage plan plan_name, error"
1284                 )
1285     @pytest.mark.slow_test
1286     def test_usage_plan_present_if_plan_has_been_created(self, *args):
1287         """
1288         Tests successful case for creating a new usage plan
1289         """
1290         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1291             with patch.dict(
1292                 boto_apigateway.__salt__,
1293                 {
1294                     "boto_apigateway.describe_usage_plans": MagicMock(
1295                         side_effect=[{"plans": []}, {"plans": [{"id": "id"}]}]
1296                     ),
1297                     "boto_apigateway.create_usage_plan": MagicMock(
1298                         return_value={"created": True}
1299                     ),
1300                 },
1301             ):
1302                 result = boto_apigateway.usage_plan_present(
1303                     "name", "plan_name", **conn_parameters
1304                 )
1305                 self.assertIn("result", result)
1306                 self.assertEqual(result["result"], True)
1307                 self.assertIn("comment", result)
1308                 self.assertEqual(
1309                     result["comment"], "A new usage plan plan_name has been created"
1310                 )
1311                 self.assertEqual(result["changes"]["old"], {"plan": None})
1312                 self.assertEqual(result["changes"]["new"], {"plan": {"id": "id"}})
1313     @pytest.mark.slow_test
1314     def test_usage_plan_present_if_plan_has_been_updated(self, *args):
1315         """
1316         Tests successful case for updating a usage plan
1317         """
1318         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1319             with patch.dict(
1320                 {
1321                     "boto_apigateway.describe_usage_plans": MagicMock(
1322                         side_effect<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=[
1323                             {"plans": [{"id": "id"}]},
1324                             {
1325                                 "plans": [
1326                                     {
1327                                         "id": "id",
1328                                         "throttle": {"rateLimit": throttle_rateLimit},
1329                                     }
1330                                 ]
1331                             },
1332                         ]
1333                     ),
1334                     "boto_apigateway.update_usage_plan": MagicMock(
1335                         return_value={"updated": True}
1336                     ),
1337                 },
1338             ):
1339                 result = boto_apigateway.</b></font>usage_plan_present(
1340                     "name",
1341                     "plan_name",
1342                     throttle={"rateLimit": throttle_rateLimit},
1343                     **conn_parameters
1344                 )
1345                 self.assertIn("result", result)
1346                 self.assertEqual(result["result"], True)
1347                 self.assertIn("comment", result)
1348                 self.assertEqual(
1349                     result["comment"], "usage plan plan_name has been updated"
1350                 )
1351                 self.assertEqual(result["changes"]["old"], {"plan": {"id": "id"}})
1352                 self.assertEqual(
1353                     result["changes"]["new"],
1354                     {
1355                         "plan": {
1356                             "id": "id",
1357                             "throttle": {"rateLimit": throttle_rateLimit},
1358                         }
1359                     },
1360                 )
1361     @pytest.mark.slow_test
1362     def test_usage_plan_present_if_ValueError_is_raised(self, *args):
1363         """
1364         Tests error processing for the case when ValueError is raised when creating a usage plan
1365         """
1366         with patch.dict(
1367             boto_apigateway.__salt__,
1368             {
1369                 "boto_apigateway.describe_usage_plans": MagicMock(
1370                     side_effect=ValueError("error")
1371                 )
1372             },
1373         ):
1374             result = boto_apigateway.usage_plan_present(
1375                 "name",
1376                 "plan_name",
1377                 throttle={"rateLimit": throttle_rateLimit},
1378                 **conn_parameters
1379             )
1380             self.assertIn("result", result)
1381             self.assertEqual(result["result"], False)
1382             self.assertIn("comment", result)
1383             self.assertEqual(result["comment"], repr(("error",)))
1384     @pytest.mark.slow_test
1385     def test_usage_plan_present_if_IOError_is_raised(self, *args):
1386         """
1387         Tests error processing for the case when IOError is raised when creating a usage plan
1388         """
1389         with patch.dict(
1390             boto_apigateway.__salt__,
1391             {
1392                 "boto_apigateway.describe_usage_plans": MagicMock(
1393                     side_effect=IOError("error")
1394                 )
1395             },
1396         ):
1397             result = boto_apigateway.usage_plan_present(
1398                 "name",
1399                 "plan_name",
1400                 throttle={"rateLimit": throttle_rateLimit},
1401                 **conn_parameters
1402             )
1403             self.assertIn("result", result)
1404             self.assertEqual(result["result"], False)
1405             self.assertIn("comment", result)
1406             self.assertEqual(result["comment"], repr(("error",)))
1407     @pytest.mark.slow_test
1408     def test_usage_plan_absent_if_describe_fails(self, *args):
1409         """
1410         Tests correct error processing for describe_usage_plan failure
1411         """
1412         with patch.dict(
1413             boto_apigateway.__salt__,
1414             {
1415                 "boto_apigateway.describe_usage_plans": MagicMock(
1416                     return_value={"error": "error"}
1417                 )
1418             },
1419         ):
1420             result = {}
1421             result = boto_apigateway.usage_plan_absent(
1422                 "name", "plan_name", **conn_parameters
1423             )
1424             self.assertIn("result", result)
1425             self.assertEqual(result["result"], False)
1426             self.assertIn("comment", result)
1427             self.assertEqual(
1428                 result["comment"], "Failed to describe existing usage plans"
1429             )
1430             self.assertIn("changes", result)
1431             self.assertEqual(result["changes"], {})
1432     @pytest.mark.slow_test
1433     def test_usage_plan_absent_if_plan_is_not_present(self, *args):
1434         """
1435         Tests behavior for the case when the plan that needs to be absent does not exist
1436         """
1437         with patch.dict(
1438             boto_apigateway.__salt__,
1439             {
1440                 "boto_apigateway.describe_usage_plans": MagicMock(
1441                     return_value={"plans": []}
1442                 )
1443             },
1444         ):
1445             result = {}
1446             result = boto_apigateway.usage_plan_absent(
1447                 "name", "plan_name", **conn_parameters
1448             )
1449             self.assertIn("result", result)
1450             self.assertEqual(result["result"], True)
1451             self.assertIn("comment", result)
1452             self.assertEqual(
1453                 result["comment"], "Usage plan plan_name does not exist already"
1454             )
1455             self.assertIn("changes", result)
1456             self.assertEqual(result["changes"], {})
1457     @pytest.mark.slow_test
1458     def test_usage_plan_absent_if_plan_is_present_but_test_option_is_set(self, *args):
1459         """
1460         Tests behavior for the case when usage plan needs to be deleted by tests option is set
1461         """
1462         with patch.dict(boto_apigateway.__opts__, {"test": True}):
1463             with patch.dict(
1464                 boto_apigateway.__salt__,
1465                 {
1466                     "boto_apigateway.describe_usage_plans": MagicMock(
1467                         return_value={"plans": [{"id": "id"}]}
1468                     )
1469                 },
1470             ):
1471                 result = {}
1472                 result = boto_apigateway.usage_plan_absent(
1473                     "name", "plan_name", **conn_parameters
1474                 )
1475                 self.assertIn("result", result)
1476                 self.assertEqual(result["result"], None)
1477                 self.assertIn("comment", result)
1478                 self.assertEqual(
1479                     result["comment"],
1480                     "Usage plan plan_name exists and would be deleted",
1481                 )
1482                 self.assertIn("changes", result)
1483                 self.assertEqual(result["changes"], {})
1484     @pytest.mark.slow_test
1485     def test_usage_plan_absent_if_plan_is_present_but_delete_fails(self, *args):
1486         """
1487         Tests correct error processing when deleting a usage plan fails
1488         """
1489         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1490             with patch.dict(
1491                 boto_apigateway.__salt__,
1492                 {
1493                     "boto_apigateway.describe_usage_plans": MagicMock(
1494                         return_value={"plans": [{"id": "id"}]}
1495                     ),
1496                     "boto_apigateway.delete_usage_plan": MagicMock(
1497                         return_value={"error": "error"}
1498                     ),
1499                 },
1500             ):
1501                 result = boto_apigateway.usage_plan_absent(
1502                     "name", "plan_name", **conn_parameters
1503                 )
1504                 self.assertIn("result", result)
1505                 self.assertEqual(result["result"], False)
1506                 self.assertIn("comment", result)
1507                 self.assertEqual(
1508                     result["comment"],
1509                     "Failed to delete usage plan plan_name, "
1510                     + repr({"error": "error"}),
1511                 )
1512                 self.assertIn("changes", result)
1513                 self.assertEqual(result["changes"], {})
1514     @pytest.mark.slow_test
1515     def test_usage_plan_absent_if_plan_has_been_deleted(self, *args):
1516         """
1517         Tests successful case for deleting a usage plan
1518         """
1519         with patch.dict(boto_apigateway.__opts__, {"test": False}):
1520             with patch.dict(
1521                 boto_apigateway.__salt__,
1522                 {
1523                     "boto_apigateway.describe_usage_plans": MagicMock(
1524                         return_value={"plans": [{"id": "id"}]}
1525                     ),
1526                     "boto_apigateway.delete_usage_plan": MagicMock(
1527                         return_value={"deleted": True}
1528                     ),
1529                 },
1530             ):
1531                 result = boto_apigateway.usage_plan_absent(
1532                     "name", "plan_name", **conn_parameters
1533                 )
1534                 self.assertIn("result", result)
1535                 self.assertEqual(result["result"], True)
1536                 self.assertIn("comment", result)
1537                 self.assertEqual(
1538                     result["comment"], "Usage plan plan_name has been deleted"
1539                 )
1540                 self.assertIn("changes", result)
1541                 self.assertEqual(
1542                     result["changes"],
1543                     {"new": {"plan": None}, "old": {"plan": {"id": "id"}}},
1544                 )
1545     @pytest.mark.slow_test
1546     def test_usage_plan_absent_if_ValueError_is_raised(self, *args):
1547         """
1548         Tests correct error processing for the case when ValueError is raised when deleting a usage plan
1549         """
1550         with patch.dict(
1551             boto_apigateway.__salt__,
1552             {
1553                 "boto_apigateway.describe_usage_plans": MagicMock(
1554                     side_effect=ValueError("error")
1555                 )
1556             },
1557         ):
1558             result = boto_apigateway.usage_plan_absent(
1559                 "name", "plan_name", **conn_parameters
1560             )
1561             self.assertIn("result", result)
1562             self.assertEqual(result["result"], False)
1563             self.assertIn("comment", result)
1564             self.assertEqual(result["comment"], repr(("error",)))
1565     @pytest.mark.slow_test
1566     def test_usage_plan_absent_if_IOError_is_raised(self, *args):
1567         """
1568         Tests correct error processing for the case when IOError is raised when deleting a usage plan
1569         """
1570         with patch.dict(
1571             boto_apigateway.__salt__,
1572             {
1573                 "boto_apigateway.describe_usage_plans": MagicMock(
1574                     side_effect=IOError("error")
1575                 )
1576             },
1577         ):
1578             result = boto_apigateway.usage_plan_absent(
1579                 "name", "plan_name", **conn_parameters
1580             )
1581             self.assertIn("result", result)
1582             self.assertEqual(result["result"], False)
1583             self.assertIn("comment", result)
1584             self.assertEqual(result["comment"], repr(("error",)))
1585 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
1586 @skipIf(
1587     _has_required_boto() is False,
1588     "The boto3 module must be greater than or equal to version {}".format(
1589         required_boto3_version
1590     ),
1591 )
1592 @skipIf(
1593     _has_required_botocore() is False,
1594     "The botocore module must be greater than or equal to version {}".format(
1595         required_botocore_version
1596     ),
1597 )
1598 class BotoApiGatewayUsagePlanAssociationTestCase(
1599     BotoApiGatewayStateTestCaseBase, BotoApiGatewayTestCaseMixin
1600 ):
1601     """
1602     TestCase for salt.modules.boto_apigateway state.module, usage_plans_association portion
1603     """
1604     @pytest.mark.slow_test
1605     def test_usage_plan_association_present_if_describe_fails(self, *args):
1606         """
1607         Tests correct error processing for describe_usage_plan failure
1608         """
1609         with patch.dict(
1610             boto_apigateway.__salt__,
1611             {
1612                 "boto_apigateway.describe_usage_plans": MagicMock(
1613                     return_value={"error": "error"}
1614                 )
1615             },
1616         ):
1617             result = boto_apigateway.usage_plan_association_present(
1618                 "name", "plan_name", [association_stage_1], **conn_parameters
1619             )
1620             self.assertIn("result", result)
1621             self.assertEqual(result["result"], False)
1622             self.assertIn("comment", result)
1623             self.assertEqual(
1624                 result["comment"], "Failed to describe existing usage plans"
1625             )
1626             self.assertIn("changes", result)
1627             self.assertEqual(result["changes"], {})
1628     @pytest.mark.slow_test
1629     def test_usage_plan_association_present_if_plan_is_not_present(self, *args):
1630         """
1631         Tests correct error processing if a plan for which association has been requested is not present
1632         """
1633         with patch.dict(
1634             boto_apigateway.__salt__,
1635             {
1636                 "boto_apigateway.describe_usage_plans": MagicMock(
1637                     return_value={"plans": []}
1638                 )
1639             },
1640         ):
1641             result = boto_apigateway.usage_plan_association_present(
1642                 "name", "plan_name", [association_stage_1], **conn_parameters
1643             )
1644             self.assertIn("result", result)
1645             self.assertEqual(result["result"], False)
1646             self.assertIn("comment", result)
1647             self.assertEqual(result["comment"], "Usage plan plan_name does not exist")
1648             self.assertIn("changes", result)
1649             self.assertEqual(result["changes"], {})
1650     @pytest.mark.slow_test
1651     def test_usage_plan_association_present_if_multiple_plans_with_the_same_name_exist(
1652         self, *args
1653     ):
1654         """
1655         Tests correct error processing for the case when multiple plans with the same name exist
1656         """
1657         with patch.dict(
1658             boto_apigateway.__salt__,
1659             {
1660                 "boto_apigateway.describe_usage_plans": MagicMock(
1661                     return_value={"plans": [{"id": "id1"}, {"id": "id2"}]}
1662                 )
1663             },
1664         ):
1665             result = boto_apigateway.usage_plan_association_present(
1666                 "name", "plan_name", [association_stage_1], **conn_parameters
1667             )
1668             self.assertIn("result", result)
1669             self.assertEqual(result["result"], False)
1670             self.assertIn("comment", result)
1671             self.assertEqual(
1672                 result["comment"],
1673                 "There are multiple usage plans with the same name - it is not"
1674                 " supported",
1675             )
1676             self.assertIn("changes", result)
1677             self.assertEqual(result["changes"], {})
1678     @pytest.mark.slow_test
1679     def test_usage_plan_association_present_if_association_already_exists(self, *args):
1680         """
1681         Tests the behavior for the case when requested association is already present
1682         """
1683         with patch.dict(
1684             boto_apigateway.__salt__,
1685             {
1686                 "boto_apigateway.describe_usage_plans": MagicMock(
1687                     return_value={
1688                         "plans": [{"id": "id1", "apiStages": [association_stage_1]}]
1689                     }
1690                 )
1691             },
1692         ):
1693             result = boto_apigateway.usage_plan_association_present(
1694                 "name", "plan_name", [association_stage_1], **conn_parameters
1695             )
1696             self.assertIn("result", result)
1697             self.assertEqual(result["result"], True)
1698             self.assertIn("comment", result)
1699             self.assertEqual(
1700                 result["comment"], "Usage plan is already asssociated to all api stages"
1701             )
1702             self.assertIn("changes", result)
1703             self.assertEqual(result["changes"], {})
1704     @pytest.mark.slow_test
1705     def test_usage_plan_association_present_if_update_fails(self, *args):
1706         """
1707         Tests correct error processing for the case when adding associations fails
1708         """
1709         with patch.dict(
1710             boto_apigateway.__salt__,
1711             {
1712                 "boto_apigateway.describe_usage_plans": MagicMock(
1713                     return_value={
1714                         "plans": [{"id": "id1", "apiStages": [association_stage_1]}]
1715                     }
1716                 ),
1717                 "boto_apigateway.attach_usage_plan_to_apis": MagicMock(
1718                     return_value={"error": "error"}
1719                 ),
1720             },
1721         ):
1722             result = boto_apigateway.usage_plan_association_present(
1723                 "name", "plan_name", [association_stage_2], **conn_parameters
1724             )
1725             self.assertIn("result", result)
1726             self.assertEqual(result["result"], False)
1727             self.assertIn("comment", result)
1728             self.assertTrue(
1729                 result["comment"].startswith("Failed to associate a usage plan")
1730             )
1731             self.assertIn("changes", result)
1732             self.assertEqual(result["changes"], {})
1733     @pytest.mark.slow_test
1734     def test_usage_plan_association_present_success(self, *args):
1735         """
1736         Tests successful case for adding usage plan associations to a given api stage
1737         """
1738         with patch.dict(
1739             boto_apigateway.__salt__,
1740             {
1741                 "boto_apigateway.describe_usage_plans": MagicMock(
1742                     return_value={
1743                         "plans": [{"id": "id1", "apiStages": [association_stage_1]}]
1744                     }
1745                 ),
1746                 "boto_apigateway.attach_usage_plan_to_apis": MagicMock(
1747                     return_value={
1748                         "result": {
1749                             "apiStages": [association_stage_1, association_stage_2]
1750                         }
1751                     }
1752                 ),
1753             },
1754         ):
1755             result = boto_apigateway.usage_plan_association_present(
1756                 "name", "plan_name", [association_stage_2], **conn_parameters
1757             )
1758             self.assertIn("result", result)
1759             self.assertEqual(result["result"], True)
1760             self.assertIn("comment", result)
1761             self.assertEqual(
1762                 result["comment"], "successfully associated usage plan to apis"
1763             )
1764             self.assertIn("changes", result)
1765             self.assertEqual(
1766                 result["changes"],
1767                 {
1768                     "new": [association_stage_1, association_stage_2],
1769                     "old": [association_stage_1],
1770                 },
1771             )
1772     @pytest.mark.slow_test
1773     def test_usage_plan_association_present_if_value_error_is_thrown(self, *args):
1774         """
1775         Tests correct error processing for the case when IOError is raised while trying to set usage plan associations
1776         """
1777         with patch.dict(
1778             boto_apigateway.__salt__,
1779             {
1780                 "boto_apigateway.describe_usage_plans": MagicMock(
1781                     side_effect=ValueError("error")
1782                 )
1783             },
1784         ):
1785             result = boto_apigateway.usage_plan_association_present(
1786                 "name", "plan_name", [], **conn_parameters
1787             )
1788             self.assertIn("result", result)
1789             self.assertEqual(result["result"], False)
1790             self.assertIn("comment", result)
1791             self.assertEqual(result["comment"], repr(("error",)))
1792             self.assertIn("changes", result)
1793             self.assertEqual(result["changes"], {})
1794     @pytest.mark.slow_test
1795     def test_usage_plan_association_present_if_io_error_is_thrown(self, *args):
1796         """
1797         Tests correct error processing for the case when IOError is raised while trying to set usage plan associations
1798         """
1799         with patch.dict(
1800             boto_apigateway.__salt__,
1801             {
1802                 "boto_apigateway.describe_usage_plans": MagicMock(
1803                     side_effect=IOError("error")
1804                 )
1805             },
1806         ):
1807             result = boto_apigateway.usage_plan_association_present(
1808                 "name", "plan_name", [], **conn_parameters
1809             )
1810             self.assertIn("result", result)
1811             self.assertEqual(result["result"], False)
1812             self.assertIn("comment", result)
1813             self.assertEqual(result["comment"], repr(("error",)))
1814             self.assertIn("changes", result)
1815             self.assertEqual(result["changes"], {})
1816     @pytest.mark.slow_test
1817     def test_usage_plan_association_absent_if_describe_fails(self, *args):
1818         """
1819         Tests correct error processing for describe_usage_plan failure
1820         """
1821         with patch.dict(
1822             boto_apigateway.__salt__,
1823             {
1824                 "boto_apigateway.describe_usage_plans": MagicMock(
1825                     return_value={"error": "error"}
1826                 )
1827             },
1828         ):
1829             result = boto_apigateway.usage_plan_association_absent(
1830                 "name", "plan_name", [association_stage_1], **conn_parameters
1831             )
1832             self.assertIn("result", result)
1833             self.assertEqual(result["result"], False)
1834             self.assertIn("comment", result)
1835             self.assertEqual(
1836                 result["comment"], "Failed to describe existing usage plans"
1837             )
1838             self.assertIn("changes", result)
1839             self.assertEqual(result["changes"], {})
1840     @pytest.mark.slow_test
1841     def test_usage_plan_association_absent_if_plan_is_not_present(self, *args):
1842         """
1843         Tests error processing for the case when plan for which associations need to be modified is not present
1844         """
1845         with patch.dict(
1846             boto_apigateway.__salt__,
1847             {
1848                 "boto_apigateway.describe_usage_plans": MagicMock(
1849                     return_value={"plans": []}
1850                 )
1851             },
1852         ):
1853             result = boto_apigateway.usage_plan_association_absent(
1854                 "name", "plan_name", [association_stage_1], **conn_parameters
1855             )
1856             self.assertIn("result", result)
1857             self.assertEqual(result["result"], False)
1858             self.assertIn("comment", result)
1859             self.assertEqual(result["comment"], "Usage plan plan_name does not exist")
1860             self.assertIn("changes", result)
1861             self.assertEqual(result["changes"], {})
1862     @pytest.mark.slow_test
1863     def test_usage_plan_association_absent_if_multiple_plans_with_the_same_name_exist(
1864         self, *args
1865     ):
1866         """
1867         Tests the case when there are multiple plans with the same name but different Ids
1868         """
1869         with patch.dict(
1870             boto_apigateway.__salt__,
1871             {
1872                 "boto_apigateway.describe_usage_plans": MagicMock(
1873                     return_value={"plans": [{"id": "id1"}, {"id": "id2"}]}
1874                 )
1875             },
1876         ):
1877             result = boto_apigateway.usage_plan_association_absent(
1878                 "name", "plan_name", [association_stage_1], **conn_parameters
1879             )
1880             self.assertIn("result", result)
1881             self.assertEqual(result["result"], False)
1882             self.assertIn("comment", result)
1883             self.assertEqual(
1884                 result["comment"],
1885                 "There are multiple usage plans with the same name - it is not"
1886                 " supported",
1887             )
1888             self.assertIn("changes", result)
1889             self.assertEqual(result["changes"], {})
1890     @pytest.mark.slow_test
1891     def test_usage_plan_association_absent_if_plan_has_no_associations(self, *args):
1892         """
1893         Tests the case when the plan has no associations at all
1894         """
1895         with patch.dict(
1896             boto_apigateway.__salt__,
1897             {
1898                 "boto_apigateway.describe_usage_plans": MagicMock(
1899                     return_value={"plans": [{"id": "id1", "apiStages": []}]}
1900                 )
1901             },
1902         ):
1903             result = boto_apigateway.usage_plan_association_absent(
1904                 "name", "plan_name", [association_stage_1], **conn_parameters
1905             )
1906             self.assertIn("result", result)
1907             self.assertEqual(result["result"], True)
1908             self.assertIn("comment", result)
1909             self.assertEqual(
1910                 result["comment"],
1911                 "Usage plan plan_name has no associated stages already",
1912             )
1913             self.assertIn("changes", result)
1914             self.assertEqual(result["changes"], {})
1915     @pytest.mark.slow_test
1916     def test_usage_plan_association_absent_if_plan_has_no_specific_association(
1917         self, *args
1918     ):
1919         """
1920         Tests the case when requested association is not present already
1921         """
1922         with patch.dict(
1923             boto_apigateway.__salt__,
1924             {
1925                 "boto_apigateway.describe_usage_plans": MagicMock(
1926                     return_value={
1927                         "plans": [{"id": "id1", "apiStages": [association_stage_1]}]
1928                     }
1929                 )
1930             },
1931         ):
1932             result = boto_apigateway.usage_plan_association_absent(
1933                 "name", "plan_name", [association_stage_2], **conn_parameters
1934             )
1935             self.assertIn("result", result)
1936             self.assertEqual(result["result"], True)
1937             self.assertIn("comment", result)
1938             self.assertEqual(
1939                 result["comment"],
1940                 "Usage plan is already not asssociated to any api stages",
1941             )
1942             self.assertIn("changes", result)
1943             self.assertEqual(result["changes"], {})
1944     @pytest.mark.slow_test
1945     def test_usage_plan_association_absent_if_detaching_association_fails(self, *args):
1946         """
1947         Tests correct error processing when detaching the usage plan from the api function is called
1948         """
1949         with patch.dict(
1950             boto_apigateway.__salt__,
1951             {
1952                 "boto_apigateway.describe_usage_plans": MagicMock(
1953                     return_value={
1954                         "plans": [
1955                             {
1956                                 "id": "id1",
1957                                 "apiStages": [association_stage_1, association_stage_2],
1958                             }
1959                         ]
1960                     }
1961                 ),
1962                 "boto_apigateway.detach_usage_plan_from_apis": MagicMock(
1963                     return_value={"error": "error"}
1964                 ),
1965             },
1966         ):
1967             result = boto_apigateway.usage_plan_association_absent(
1968                 "name", "plan_name", [association_stage_2], **conn_parameters
1969             )
1970             self.assertIn("result", result)
1971             self.assertEqual(result["result"], False)
1972             self.assertIn("comment", result)
1973             self.assertTrue(
1974                 result["comment"].startswith(
1975                     "Failed to disassociate a usage plan plan_name from the apis"
1976                 )
1977             )
1978             self.assertIn("changes", result)
1979             self.assertEqual(result["changes"], {})
1980     @pytest.mark.slow_test
1981     def test_usage_plan_association_absent_success(self, *args):
1982         """
1983         Tests successful case of disaccosiation the usage plan from api stages
1984         """
1985         with patch.dict(
1986             boto_apigateway.__salt__,
1987             {
1988                 "boto_apigateway.describe_usage_plans": MagicMock(
1989                     return_value={
1990                         "plans": [
1991                             {
1992                                 "id": "id1",
1993                                 "apiStages": [association_stage_1, association_stage_2],
1994                             }
1995                         ]
1996                     }
1997                 ),
1998                 "boto_apigateway.detach_usage_plan_from_apis": MagicMock(
1999                     return_value={"result": {"apiStages": [association_stage_1]}}
2000                 ),
2001             },
2002         ):
2003             result = boto_apigateway.usage_plan_association_absent(
2004                 "name", "plan_name", [association_stage_2], **conn_parameters
2005             )
2006             self.assertIn("result", result)
2007             self.assertEqual(result["result"], True)
2008             self.assertIn("comment", result)
2009             self.assertEqual(
2010                 result["comment"], "successfully disassociated usage plan from apis"
2011             )
2012             self.assertIn("changes", result)
2013             self.assertEqual(
2014                 result["changes"],
2015                 {
2016                     "new": [association_stage_1],
2017                     "old": [association_stage_1, association_stage_2],
2018                 },
2019             )
2020     @pytest.mark.slow_test
2021     def test_usage_plan_association_absent_if_ValueError_is_raised(self, *args):
2022         """
2023         Tests correct error processing for the case where ValueError is raised while trying to remove plan associations
2024         """
2025         with patch.dict(
2026             boto_apigateway.__salt__,
2027             {
2028                 "boto_apigateway.describe_usage_plans": MagicMock(
2029                     side_effect=ValueError("error")
2030                 )
2031             },
2032         ):
2033             result = boto_apigateway.usage_plan_association_absent(
2034                 "name", "plan_name", [association_stage_1], **conn_parameters
2035             )
2036             self.assertIn("result", result)
2037             self.assertEqual(result["result"], False)
2038             self.assertIn("comment", result)
2039             self.assertEqual(result["comment"], repr(("error",)))
2040             self.assertIn("changes", result)
2041             self.assertEqual(result["changes"], {})
2042     @pytest.mark.slow_test
2043     def test_usage_plan_association_absent_if_IOError_is_raised(self, *args):
2044         """
2045         Tests correct error processing for the case where IOError exception is raised while trying to remove plan associations
2046         """
2047         with patch.dict(
2048             boto_apigateway.__salt__,
2049             {
2050                 "boto_apigateway.describe_usage_plans": MagicMock(
2051                     side_effect=IOError("error")
2052                 )
2053             },
2054         ):
2055             result = boto_apigateway.usage_plan_association_absent(
2056                 "name", "plan_name", [association_stage_1], **conn_parameters
2057             )
2058             self.assertIn("result", result)
2059             self.assertEqual(result["result"], False)
2060             self.assertIn("comment", result)
2061             self.assertEqual(result["comment"], repr(("error",)))
2062             self.assertIn("changes", result)
2063             self.assertEqual(result["changes"], {})
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
