<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for boto_cfn_1.py &amp; win_task.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for boto_cfn_1.py &amp; win_task.py
      </h3>
<h1 align="center">
        3.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>boto_cfn_1.py (12.587413%)<th>win_task.py (1.9791094%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(190-225)<td><a href="#" name="0">(775-798)</a><td align="center"><font color="#ff0000">20</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(138-156)<td><a href="#" name="1">(1814-1832)</a><td align="center"><font color="#cc0000">16</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_cfn_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import salt.utils.versions
3 log = logging.getLogger(__name__)
4 try:
5     import boto
6     import boto.cloudformation
7     from boto.exception import BotoServerError
8     logging.getLogger("boto").setLevel(logging.CRITICAL)
9     HAS_BOTO = True
10 except ImportError:
11     HAS_BOTO = False
12 def __virtual__():
13     return salt.utils.versions.check_boto_reqs(check_boto3=False)
14 def __init__(opts):
15     if HAS_BOTO:
16         __utils__["boto.assign_funcs"](
17             __name__, "cfn", module="cloudformation", pack=__salt__
18         )
19 def exists(name, region=None, key=None, keyid=None, profile=None):
20     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
21     try:
22         exists = conn.describe_stacks(name)
23         log.debug("Stack %s exists.", name)
24         return True
25     except BotoServerError as e:
26         log.debug("boto_cfn.exists raised an exception", exc_info=True)
27         return False
28 def describe(name, region=None, key=None, keyid=None, profile=None):
29     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
30     try:
31         r = conn.describe_stacks(name)
32         if r:
33             stack = r[0]
34             log.debug("Found VPC: %s", stack.stack_id)
35             keys = (
36                 "stack_id",
37                 "description",
38                 "stack_status",
39                 "stack_status_reason",
40                 "tags",
41             )
42             ret = {k: getattr(stack, k) for k in keys if hasattr(stack, k)}
43             o = getattr(stack, "outputs")
44             p = getattr(stack, "parameters")
45             outputs = {}
46             parameters = {}
47             for i in o:
48                 outputs[i.key] = i.value
49             ret["outputs"] = outputs
50             for j in p:
51                 parameters[j.key] = j.value
52             ret["parameters"] = parameters
53             return {"stack": ret}
54         log.debug("Stack %s exists.", name)
55 <a name="1"></a>        return True
56     except BotoServerError as e:
57         log.warning("Could not describe stack %s.\n%s", name, e)
58         r<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>eturn False
59 def create(
60     name,
61     template_body=None,
62     template_url=None,
63     parameters=None,
64     notification_arns=None,
65     disable_rollback=None,
66     timeout_in_minutes=None,
67     capabilities=None,
68     tags=None,
69     on_failure=None,
70     stack_policy_body=None,
71     stack_policy_url=None,
72     region=None,
73     key=None,
74     keyid=</b></font>None,
75     profile=None,
76 ):
77     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
78     try:
79         return conn.create_stack(
80             name,
81             template_body,
82             template_url,
83             parameters,
84             notification_arns,
85             disable_rollback,
86             timeout_in_minutes,
87             capabilities,
88             tags,
89             on_failure,
90             stack_policy_body,
91             stack_policy_url,
92         )
93     except BotoServerError as e:
94 <a name="0"></a>        msg = "Failed to create stack {}.\n{}".format(name, e)
95         log.error(msg)
96         log.debug(e)
97         r<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>eturn False
98 def update_stack(
99     name,
100     template_body=None,
101     template_url=None,
102     parameters=None,
103     notification_arns=None,
104     disable_rollback=False,
105     timeout_in_minutes=None,
106     capabilities=None,
107     tags=None,
108     use_previous_template=None,
109     stack_policy_during_update_body=None,
110     stack_policy_during_update_url=None,
111     stack_policy_body=None,
112     stack_policy_url=None,
113     region=None,
114     key=None,
115     keyid=None,
116     profile=None,
117 ):
118     conn =</b></font> _get_conn(region=region, key=key, keyid=keyid, profile=profile)
119     try:
120         update = conn.update_stack(
121             name,
122             template_body,
123             template_url,
124             parameters,
125             notification_arns,
126             disable_rollback,
127             timeout_in_minutes,
128             capabilities,
129             tags,
130             use_previous_template,
131             stack_policy_during_update_body,
132             stack_policy_during_update_url,
133             stack_policy_body,
134             stack_policy_url,
135         )
136         log.debug("Updated result is : %s.", update)
137         return update
138     except BotoServerError as e:
139         msg = "Failed to update stack {}.".format(name)
140         log.debug(e)
141         log.error(msg)
142         return str(e)
143 def delete(name, region=None, key=None, keyid=None, profile=None):
144     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
145     try:
146         return conn.delete_stack(name)
147     except BotoServerError as e:
148         msg = "Failed to create stack {}.".format(name)
149         log.error(msg)
150         log.debug(e)
151         return str(e)
152 def get_template(name, region=None, key=None, keyid=None, profile=None):
153     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
154     try:
155         template = conn.get_template(name)
156         log.info("Retrieved template for stack %s", name)
157         return template
158     except BotoServerError as e:
159         log.debug(e)
160         msg = "Template {} does not exist".format(name)
161         log.error(msg)
162         return str(e)
163 def validate_template(
164     template_body=None,
165     template_url=None,
166     region=None,
167     key=None,
168     keyid=None,
169     profile=None,
170 ):
171     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
172     try:
173         return conn.validate_template(template_body, template_url)
174     except BotoServerError as e:
175         log.debug(e)
176         msg = "Error while trying to validate template {}.".format(template_body)
177         log.error(msg)
178         return str(e)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>win_task.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import time
3 from datetime import datetime
4 import salt.utils.platform
5 import salt.utils.winapi
6 from salt.exceptions import ArgumentValueError, CommandExecutionError
7 try:
8     import pythoncom
9     import win32com.client
10     HAS_DEPENDENCIES = True
11 except ImportError:
12     HAS_DEPENDENCIES = False
13 log = logging.getLogger(__name__)
14 __virtualname__ = "task"
15 TASK_ACTION_EXEC = 0
16 TASK_ACTION_COM_HANDLER = 5
17 TASK_ACTION_SEND_EMAIL = 6
18 TASK_ACTION_SHOW_MESSAGE = 7
19 TASK_COMPATIBILITY_AT = 0
20 TASK_COMPATIBILITY_V1 = 1
21 TASK_COMPATIBILITY_V2 = 2
22 TASK_COMPATIBILITY_V3 = 3
23 TASK_VALIDATE_ONLY = 0x1
24 TASK_CREATE = 0x2
25 TASK_UPDATE = 0x4
26 TASK_CREATE_OR_UPDATE = 0x6
27 TASK_DISABLE = 0x8
28 TASK_DONT_ADD_PRINCIPAL_ACE = 0x10
29 TASK_IGNORE_REGISTRATION_TRIGGERS = 0x20
30 TASK_INSTANCES_PARALLEL = 0
31 TASK_INSTANCES_QUEUE = 1
32 TASK_INSTANCES_IGNORE_NEW = 2
33 TASK_INSTANCES_STOP_EXISTING = 3
34 TASK_LOGON_NONE = 0
35 TASK_LOGON_PASSWORD = 1
36 TASK_LOGON_S4U = 2
37 TASK_LOGON_INTERACTIVE_TOKEN = 3
38 TASK_LOGON_GROUP = 4
39 TASK_LOGON_SERVICE_ACCOUNT = 5
40 TASK_LOGON_INTERACTIVE_TOKEN_OR_PASSWORD = 6
41 TASK_RUNLEVEL_LUA = 0
42 TASK_RUNLEVEL_HIGHEST = 1
43 TASK_STATE_UNKNOWN = 0
44 TASK_STATE_DISABLED = 1
45 TASK_STATE_QUEUED = 2
46 TASK_STATE_READY = 3
47 TASK_STATE_RUNNING = 4
48 TASK_TRIGGER_EVENT = 0
49 TASK_TRIGGER_TIME = 1
50 TASK_TRIGGER_DAILY = 2
51 TASK_TRIGGER_WEEKLY = 3
52 TASK_TRIGGER_MONTHLY = 4
53 TASK_TRIGGER_MONTHLYDOW = 5
54 TASK_TRIGGER_IDLE = 6
55 TASK_TRIGGER_REGISTRATION = 7
56 TASK_TRIGGER_BOOT = 8
57 TASK_TRIGGER_LOGON = 9
58 TASK_TRIGGER_SESSION_STATE_CHANGE = 11
59 duration = {
60     "Immediately": "PT0M",
61     "Indefinitely": "",
62     "Do not wait": "PT0M",
63     "15 seconds": "PT15S",
64     "30 seconds": "PT30S",
65     "1 minute": "PT1M",
66     "5 minutes": "PT5M",
67     "10 minutes": "PT10M",
68     "15 minutes": "PT15M",
69     "30 minutes": "PT30M",
70     "1 hour": "PT1H",
71     "2 hours": "PT2H",
72     "4 hours": "PT4H",
73     "8 hours": "PT8H",
74     "12 hours": "PT12H",
75     "1 day": ["P1D", "PT24H"],
76     "3 days": ["P3D", "PT72H"],
77     "30 days": "P30D",
78     "90 days": "P90D",
79     "180 days": "P180D",
80     "365 days": "P365D",
81 }
82 action_types = {
83     "Execute": TASK_ACTION_EXEC,
84     "Email": TASK_ACTION_SEND_EMAIL,
85     "Message": TASK_ACTION_SHOW_MESSAGE,
86 }
87 trigger_types = {
88     "Event": TASK_TRIGGER_EVENT,
89     "Once": TASK_TRIGGER_TIME,
90     "Daily": TASK_TRIGGER_DAILY,
91     "Weekly": TASK_TRIGGER_WEEKLY,
92     "Monthly": TASK_TRIGGER_MONTHLY,
93     "MonthlyDay": TASK_TRIGGER_MONTHLYDOW,
94     "OnIdle": TASK_TRIGGER_IDLE,
95     "OnTaskCreation": TASK_TRIGGER_REGISTRATION,
96     "OnBoot": TASK_TRIGGER_BOOT,
97     "OnLogon": TASK_TRIGGER_LOGON,
98     "OnSessionChange": TASK_TRIGGER_SESSION_STATE_CHANGE,
99 }
100 states = {
101     TASK_STATE_UNKNOWN: "Unknown",
102     TASK_STATE_DISABLED: "Disabled",
103     TASK_STATE_QUEUED: "Queued",
104     TASK_STATE_READY: "Ready",
105     TASK_STATE_RUNNING: "Running",
106 }
107 instances = {
108     "Parallel": TASK_INSTANCES_PARALLEL,
109     "Queue": TASK_INSTANCES_QUEUE,
110     "No New Instance": TASK_INSTANCES_IGNORE_NEW,
111     "Stop Existing": TASK_INSTANCES_STOP_EXISTING,
112 }
113 results = {
114     0x0: "The operation completed successfully",
115     0x1: "Incorrect or unknown function called",
116     0x2: "File not found",
117     0xA: "The environment is incorrect",
118     0x41300: "Task is ready to run at its next scheduled time",
119     0x41301: "Task is currently running",
120     0x41302: "Task is disabled",
121     0x41303: "Task has not yet run",
122     0x41304: "There are no more runs scheduled for this task",
123     0x41306: "Task was terminated by the user",
124     0x8004130F: "Credentials became corrupted",
125     0x8004131F: "An instance of this task is already running",
126     0x800710E0: "The operator or administrator has refused the request",
127     0x800704DD: "The service is not available (Run only when logged in?)",
128     0xC000013A: "The application terminated as a result of CTRL+C",
129     0xC06D007E: "Unknown software exception",
130 }
131 def __virtual__():
132     if salt.utils.platform.is_windows():
133         if not HAS_DEPENDENCIES:
134             log.warning("Could not load dependencies for %s", __virtualname__)
135         return __virtualname__
136     return False, "Module win_task: module only works on Windows systems"
137 def _get_date_time_format(dt_string):
138     valid_formats = [
139         "%I:%M:%S %p",
140         "%I:%M %p",
141         "%H:%M:%S",
142         "%H:%M",
143         "%Y-%m-%d",
144         "%m-%d-%y",
145         "%m-%d-%Y",
146         "%m/%d/%y",
147         "%m/%d/%Y",
148         "%Y/%m/%d",
149     ]
150     for dt_format in valid_formats:
151         try:
152             datetime.strptime(dt_string, dt_format)
153             return dt_format
154         except ValueError:
155             continue
156     return False
157 def _get_date_value(date):
158     try:
159         return "{}".format(date)
160     except ValueError:
161         return "Never"
162 def _reverse_lookup(dictionary, value):
163     value_index = -1
164     for idx, dict_value in enumerate(dictionary.values()):
165         if type(dict_value) == list:
166             if value in dict_value:
167                 value_index = idx
168                 break
169         elif value == dict_value:
170             value_index = idx
171             break
172     return list(dictionary)[value_index]
173 def _lookup_first(dictionary, key):
174     value = dictionary[key]
175     if type(value) == list:
176         return value[0]
177     else:
178         return value
179 def _save_task_definition(
180     name, task_folder, task_definition, user_name, password, logon_type
181 ):
182     try:
183         task_folder.RegisterTaskDefinition(
184             name,
185             task_definition,
186             TASK_CREATE_OR_UPDATE,
187             user_name,
188             password,
189             logon_type,
190         )
191         return True
192     except pythoncom.com_error as error:
193         hr, msg, exc, arg = error.args  # pylint: disable=W0633
194         fc = {
195             -2147024773: (
196                 "The filename, directory name, or volume label syntax is incorrect"
197             ),
198             -2147024894: "The system cannot find the file specified",
199             -2147216615: "Required element or attribute missing",
200             -2147216616: "Value incorrectly formatted or out of range",
201             -2147352571: "Access denied",
202         }
203         try:
204             failure_code = fc[exc[5]]
205         except KeyError:
206             failure_code = "Unknown Failure: {}".format(error)
207         log.debug("Failed to modify task: %s", failure_code)
208         return "Failed to modify task: {}".format(failure_code)
209 def list_tasks(location="\\"):
210     r"""
211     List all tasks located in a specific location in the task scheduler.
212     Args:
213         location (str):
214             A string value representing the folder from which you want to list
215             tasks. Default is ``\`` which is the root for the task scheduler
216             (``C:\Windows\System32\tasks``).
217     Returns:
218         list: Returns a list of tasks
219     CLI Example:
220     .. code-block:: bash
221         salt 'minion-id' task.list_tasks
222         salt 'minion-id' task.list_tasks Microsoft\XblGameSave
223     with salt.utils.winapi.Com():
224         task_service = win32com.client.Dispatch("Schedule.Service")
225         task_service.Connect()
226         task_folder = task_service.GetFolder(location)
227         folders = task_folder.GetFolders(0)
228         ret = []
229         for folder in folders:
230             ret.append(folder.Name)
231     return ret
232 def list_triggers(name, location="\\"):
233     r"""
234     List all triggers that pertain to a task in the specified location.
235     Args:
236         name (str):
237             The name of the task for which list triggers.
238         location (str):
239             A string value representing the location of the task from which to
240             list triggers. Default is ``\`` which is the root for the task
241             scheduler (``C:\Windows\System32\tasks``).
242     Returns:
243         list: Returns a list of triggers.
244     CLI Example:
245     .. code-block:: bash
246         salt 'minion-id' task.list_triggers &lt;task_name&gt;
247         salt '*' task.list_triggers XblGameSaveTask Microsoft\XblGameSave
248     with salt.utils.winapi.Com():
249         task_service = win32com.client.Dispatch("Schedule.Service")
250         task_service.Connect()
251         task_folder = task_service.GetFolder(location)
252         task_definition = task_folder.GetTask(name).Definition
253         actions = task_definition.Actions
254         ret = []
255         for action in actions:
256             ret.append(action.Id)
257     return ret
258 def create_task(
259     name, location="\\", user_name="System", password=None, force=False, **kwargs
260 ):
261     r"""
262     Create a new task in the designated location. This function has many keyword
263     arguments that are not listed here. For additional arguments see:
264         - :py:func:`edit_task`
265         - :py:func:`add_action`
266         - :py:func:`add_trigger`
267     Args:
268         name (str):
269             The name of the task. This will be displayed in the task scheduler.
270         location (str):
271             A string value representing the location in which to create the
272             task. Default is ``\`` which is the root for the task scheduler
273             (``C:\Windows\System32\tasks``).
274         user_name (str):
275             The user account under which to run the task. To specify the
276             'System' account, use 'System'. The password will be ignored.
277         password (str):
278             The password to use for authentication. This should set the task to
279             run whether the user is logged in or not, but is currently not
280             working.
281         force (bool):
282             If the task exists, overwrite the existing task.
283     Returns:
284         bool: ``True`` if successful, otherwise ``False``
285     CLI Example:
286     .. code-block:: bash
287         salt 'minion-id' task.create_task &lt;task_name&gt; user_name=System force=True action_type=Execute cmd='del /Q /S C:\\Temp' trigger_type=Once start_date=2016-12-1 start_time=01:00
288     """
289     if name in list_tasks(location) and not force:
290         return "{} already exists".format(name)
291     with salt.utils.winapi.Com():
292         task_service = win32com.client.Dispatch("Schedule.Service")
293         task_service.Connect()
294         task_definition = task_service.NewTask(0)
295         edit_task(
296             task_definition=task_definition,
297             user_name=user_name,
298             password=password,
299             **kwargs
300         )
301         add_action(task_definition=task_definition, **kwargs)
302         add_trigger(task_definition=task_definition, **kwargs)
303         task_folder = task_service.GetFolder(location)
304         _save_task_definition(
305             name=name,
306             task_folder=task_folder,
307             task_definition=task_definition,
308             user_name=task_definition.Principal.UserID,
309             password=password,
310             logon_type=task_definition.Principal.LogonType,
311         )
312     return name in list_tasks(location)
313 def create_task_from_xml(
314     name, location="\\", xml_text=None, xml_path=None, user_name="System", password=None
315 ):
316     r"""
317     Create a task based on XML. Source can be a file or a string of XML.
318     Args:
319         name (str):
320             The name of the task. This will be displayed in the task scheduler.
321         location (str):
322             A string value representing the location in which to create the
323             task. Default is ``\`` which is the root for the task scheduler
324             (``C:\Windows\System32\tasks``).
325         xml_text (str):
326             A string of xml representing the task to be created. This will be
327             overridden by ``xml_path`` if passed.
328         xml_path (str):
329             The path to an XML file on the local system containing the xml that
330             defines the task. This will override ``xml_text``
331         user_name (str):
332             The user account under which to run the task. To specify the
333             'System' account, use 'System'. The password will be ignored.
334         password (str):
335             The password to use for authentication. This should set the task to
336             run whether the user is logged in or not, but is currently not
337             working.
338     Returns:
339         bool: ``True`` if successful, otherwise ``False``
340         str: A string with the error message if there is an error
341     Raises:
342         ArgumentValueError: If arguments are invalid
343         CommandExecutionError
344     CLI Example:
345     .. code-block:: bash
346         salt '*' task.create_task_from_xml &lt;task_name&gt; xml_path=C:\task.xml
347     """
348     if name in list_tasks(location):
349         return "{} already exists".format(name)
350     if not xml_text and not xml_path:
351         raise ArgumentValueError("Must specify either xml_text or xml_path")
352     with salt.utils.winapi.Com():
353         task_service = win32com.client.Dispatch("Schedule.Service")
354         task_service.Connect()
355         if xml_path:
356             xml_text = xml_path
357         task_folder = task_service.GetFolder(location)
358         if user_name:
359             if user_name.lower() == "system":
360                 logon_type = TASK_LOGON_SERVICE_ACCOUNT
361                 user_name = "SYSTEM"
362                 password = None
363             else:
364                 if password:
365                     logon_type = TASK_LOGON_PASSWORD
366                 else:
367                     logon_type = TASK_LOGON_INTERACTIVE_TOKEN
368         else:
369             password = None
370             logon_type = TASK_LOGON_NONE
371         try:
372             task_folder.RegisterTask(
373                 name, xml_text, TASK_CREATE, user_name, password, logon_type
374             )
375         except pythoncom.com_error as error:
376             hr, msg, exc, arg = error.args  # pylint: disable=W0633
377             error_code = hex(exc[5] + 2 ** 32)
378             fc = {
379                 0x80041319: "Required element or attribute missing",
380                 0x80041318: "Value incorrectly formatted or out of range",
381                 0x80020005: "Access denied",
382                 0x80041309: "A task's trigger is not found",
383                 0x8004130A: (
384                     "One or more of the properties required to run this "
385                     "task have not been set"
386                 ),
387                 0x8004130C: (
388                     "The Task Scheduler service is not installed on this computer"
389                 ),
390                 0x8004130D: "The task object could not be opened",
391                 0x8004130E: (
392                     "The object is either an invalid task object or is not "
393                     "a task object"
394                 ),
395                 0x8004130F: (
396                     "No account information could be found in the Task "
397                     "Scheduler security database for the task indicated"
398                 ),
399                 0x80041310: "Unable to establish existence of the account specified",
400                 0x80041311: (
401                     "Corruption was detected in the Task Scheduler "
402                     "security database; the database has been reset"
403                 ),
404                 0x80041313: "The task object version is either unsupported or invalid",
405                 0x80041314: (
406                     "The task has been configured with an unsupported "
407                     "combination of account settings and run time options"
408                 ),
409                 0x80041315: "The Task Scheduler Service is not running",
410                 0x80041316: "The task XML contains an unexpected node",
411                 0x80041317: (
412                     "The task XML contains an element or attribute from an "
413                     "unexpected namespace"
414                 ),
415                 0x8004131A: "The task XML is malformed",
416                 0x0004131C: (
417                     "The task is registered, but may fail to start. Batch "
418                     "logon privilege needs to be enabled for the task principal"
419                 ),
420                 0x8004131D: "The task XML contains too many nodes of the same type",
421             }
422             try:
423                 failure_code = fc[error_code]
424             except KeyError:
425                 failure_code = "Unknown Failure: {}".format(error_code)
426             finally:
427                 log.debug("Failed to create task: %s", failure_code)
428             raise CommandExecutionError(failure_code)
429     return name in list_tasks(location)
430 def create_folder(name, location="\\"):
431     r"""
432     Create a folder in which to create tasks.
433     Args:
434         name (str):
435             The name of the folder. This will be displayed in the task
436             scheduler.
437         location (str):
438             A string value representing the location in which to create the
439             folder. Default is ``\`` which is the root for the task scheduler
440             (``C:\Windows\System32\tasks``).
441     Returns:
442         bool: ``True`` if successful, otherwise ``False``
443     CLI Example:
444     .. code-block:: bash
445         salt 'minion-id' task.create_folder &lt;folder_name&gt;
446     """
447     if name in list_folders(location):
448         return "{} already exists".format(name)
449     with salt.utils.winapi.Com():
450         task_service = win32com.client.Dispatch("Schedule.Service")
451         task_service.Connect()
452         task_folder = task_service.GetFolder(location)
453 <a name="0"></a>        task_folder.CreateFolder(name)
454     return name in list_folders(<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>location)
455 def edit_task(
456     name=None,
457     location="\\",
458     user_name=None,
459     password=None,
460     description=None,
461     enabled=None,
462     hidden=None,
463     run_if_idle=None,
464     idle_duration=None,
465     idle_wait_timeout=None,
466     idle_stop_on_end=None,
467     idle_restart=None,
468     ac_only=None,
469     stop_if_on_batteries=None,
470     wake_to_run=None,
471     run_if_network=None,
472     network_id=None,
473     network_name=</b></font>None,
474     allow_demand_start=None,
475     start_when_available=None,
476     restart_every=None,
477     restart_count=3,
478     execution_time_limit=None,
479     force_stop=None,
480     delete_after=None,
481     multiple_instances=None,
482     **kwargs
483 ):
484     r"""
485     Edit the parameters of a task. Triggers and Actions cannot be edited yet.
486     Args:
487         name (str):
488             The name of the task. This will be displayed in the task scheduler.
489         location (str):
490             A string value representing the location in which to create the
491             task. Default is ``\`` which is the root for the task scheduler
492             (``C:\Windows\System32\tasks``).
493         user_name (str):
494             The user account under which to run the task. To specify the
495             'System' account, use 'System'. The password will be ignored.
496         password (str):
497             The password to use for authentication. This should set the task to
498             run whether the user is logged in or not, but is currently not
499             working.
500             .. note::
501                 The combination of user_name and password determine how the
502                 task runs. For example, if a username is passed without at
503                 password the task will only run when the user is logged in. If a
504                 password is passed as well the task will run whether the user is
505                 logged on or not. If you pass 'System' as the username the task
506                 will run as the system account (the password parameter is
507                 ignored).
508         description (str):
509             A string representing the text that will be displayed in the
510             description field in the task scheduler.
511         enabled (bool):
512             A boolean value representing whether or not the task is enabled.
513         hidden (bool):
514             A boolean value representing whether or not the task is hidden.
515         run_if_idle (bool):
516             Boolean value that indicates that the Task Scheduler will run the
517             task only if the computer is in an idle state.
518         idle_duration (str):
519             A value that indicates the amount of time that the computer must be
520             in an idle state before the task is run. Valid values are:
521                 - 1 minute
522                 - 5 minutes
523                 - 10 minutes
524                 - 15 minutes
525                 - 30 minutes
526                 - 1 hour
527         idle_wait_timeout (str):
528             A value that indicates the amount of time that the Task Scheduler
529             will wait for an idle condition to occur. Valid values are:
530                 - Do not wait
531                 - 1 minute
532                 - 5 minutes
533                 - 10 minutes
534                 - 15 minutes
535                 - 30 minutes
536                 - 1 hour
537                 - 2 hours
538         idle_stop_on_end (bool):
539             Boolean value that indicates that the Task Scheduler will terminate
540             the task if the idle condition ends before the task is completed.
541         idle_restart (bool):
542             Boolean value that indicates whether the task is restarted when the
543             computer cycles into an idle condition more than once.
544         ac_only (bool):
545             Boolean value that indicates that the Task Scheduler will launch the
546             task only while on AC power.
547         stop_if_on_batteries (bool):
548             Boolean value that indicates that the task will be stopped if the
549             computer begins to run on battery power.
550         wake_to_run (bool):
551             Boolean value that indicates that the Task Scheduler will wake the
552             computer when it is time to run the task.
553         run_if_network (bool):
554             Boolean value that indicates that the Task Scheduler will run the
555             task only when a network is available.
556         network_id (guid):
557             GUID value that identifies a network profile.
558         network_name (str):
559             Sets the name of a network profile. The name is used for display
560             purposes.
561         allow_demand_start (bool):
562             Boolean value that indicates that the task can be started by using
563             either the Run command or the Context menu.
564         start_when_available (bool):
565             Boolean value that indicates that the Task Scheduler can start the
566             task at any time after its scheduled time has passed.
567         restart_every (str):
568             A value that specifies the interval between task restart attempts.
569             Valid values are:
570                 - False (to disable)
571                 - 1 minute
572                 - 5 minutes
573                 - 10 minutes
574                 - 15 minutes
575                 - 30 minutes
576                 - 1 hour
577                 - 2 hours
578         restart_count (int):
579             The number of times the Task Scheduler will attempt to restart the
580             task. Valid values are integers 1 - 999.
581         execution_time_limit (bool, str):
582             The amount of time allowed to complete the task. Valid values are:
583                 - False (to disable)
584                 - 1 hour
585                 - 2 hours
586                 - 4 hours
587                 - 8 hours
588                 - 12 hours
589                 - 1 day
590                 - 3 days
591         force_stop (bool):
592             Boolean value that indicates that the task may be terminated by
593             using TerminateProcess.
594         delete_after (bool, str):
595             The amount of time that the Task Scheduler will wait before deleting
596             the task after it expires. Requires a trigger with an expiration
597             date. Valid values are:
598                 - False (to disable)
599                 - Immediately
600                 - 30 days
601                 - 90 days
602                 - 180 days
603                 - 365 days
604         multiple_instances (str):
605             Sets the policy that defines how the Task Scheduler deals with
606             multiple instances of the task. Valid values are:
607                 - Parallel
608                 - Queue
609                 - No New Instance
610                 - Stop Existing
611     Returns:
612         bool: ``True`` if successful, otherwise ``False``
613     CLI Example:
614     .. code-block:: bash
615         salt '*' task.edit_task &lt;task_name&gt; description='This task is awesome'
616     """
617     with salt.utils.winapi.Com():
618         save_definition = False
619         if kwargs.get("task_definition", False):
620             task_definition = kwargs.get("task_definition")
621         else:
622             save_definition = True
623             if not name:
624                 return 'Required parameter "name" not passed'
625             if name in list_tasks(location):
626                 task_service = win32com.client.Dispatch("Schedule.Service")
627                 task_service.Connect()
628                 task_folder = task_service.GetFolder(location)
629                 task_definition = task_folder.GetTask(name).Definition
630             else:
631                 return "{} not found".format(name)
632         if save_definition:
633             task_definition.RegistrationInfo.Author = "Salt Minion"
634             task_definition.RegistrationInfo.Source = "Salt Minion Daemon"
635         if description is not None:
636             task_definition.RegistrationInfo.Description = description
637         if user_name:
638             if user_name.lower() == "system":
639                 logon_type = TASK_LOGON_SERVICE_ACCOUNT
640                 user_name = "SYSTEM"
641                 password = None
642             else:
643                 task_definition.Principal.Id = user_name
644                 if password:
645                     logon_type = TASK_LOGON_PASSWORD
646                 else:
647                     logon_type = TASK_LOGON_INTERACTIVE_TOKEN
648             task_definition.Principal.UserID = user_name
649             task_definition.Principal.DisplayName = user_name
650             task_definition.Principal.LogonType = logon_type
651             task_definition.Principal.RunLevel = TASK_RUNLEVEL_HIGHEST
652         else:
653             user_name = None
654             password = None
655         if enabled is not None:
656             task_definition.Settings.Enabled = enabled
657         if hidden is not None:
658             task_definition.Settings.Hidden = hidden
659         if run_if_idle is not None:
660             task_definition.Settings.RunOnlyIfIdle = run_if_idle
661         if task_definition.Settings.RunOnlyIfIdle:
662             if idle_stop_on_end is not None:
663                 task_definition.Settings.IdleSettings.StopOnIdleEnd = idle_stop_on_end
664             if idle_restart is not None:
665                 task_definition.Settings.IdleSettings.RestartOnIdle = idle_restart
666             if idle_duration is not None:
667                 if idle_duration in duration:
668                     task_definition.Settings.IdleSettings.IdleDuration = _lookup_first(
669                         duration, idle_duration
670                     )
671                 else:
672                     return 'Invalid value for "idle_duration"'
673             if idle_wait_timeout is not None:
674                 if idle_wait_timeout in duration:
675                     task_definition.Settings.IdleSettings.WaitTimeout = _lookup_first(
676                         duration, idle_wait_timeout
677                     )
678                 else:
679                     return 'Invalid value for "idle_wait_timeout"'
680         if ac_only is not None:
681             task_definition.Settings.DisallowStartIfOnBatteries = ac_only
682         if stop_if_on_batteries is not None:
683             task_definition.Settings.StopIfGoingOnBatteries = stop_if_on_batteries
684         if wake_to_run is not None:
685             task_definition.Settings.WakeToRun = wake_to_run
686         if run_if_network is not None:
687             task_definition.Settings.RunOnlyIfNetworkAvailable = run_if_network
688         if task_definition.Settings.RunOnlyIfNetworkAvailable:
689             if network_id:
690                 task_definition.Settings.NetworkSettings.Id = network_id
691             if network_name:
692                 task_definition.Settings.NetworkSettings.Name = network_name
693         if allow_demand_start is not None:
694             task_definition.Settings.AllowDemandStart = allow_demand_start
695         if start_when_available is not None:
696             task_definition.Settings.StartWhenAvailable = start_when_available
697         if restart_every is not None:
698             if restart_every is False:
699                 task_definition.Settings.RestartInterval = ""
700             else:
701                 if restart_every in duration:
702                     task_definition.Settings.RestartInterval = _lookup_first(
703                         duration, restart_every
704                     )
705                 else:
706                     return 'Invalid value for "restart_every"'
707         if task_definition.Settings.RestartInterval:
708             if restart_count is not None:
709                 if restart_count in range(1, 999):
710                     task_definition.Settings.RestartCount = restart_count
711                 else:
712                     return '"restart_count" must be a value between 1 and 999'
713         if execution_time_limit is not None:
714             if execution_time_limit is False:
715                 task_definition.Settings.ExecutionTimeLimit = "PT0S"
716             else:
717                 if execution_time_limit in duration:
718                     task_definition.Settings.ExecutionTimeLimit = _lookup_first(
719                         duration, execution_time_limit
720                     )
721                 else:
722                     return 'Invalid value for "execution_time_limit"'
723         if force_stop is not None:
724             task_definition.Settings.AllowHardTerminate = force_stop
725         if delete_after is not None:
726             if delete_after is False:
727                 task_definition.Settings.DeleteExpiredTaskAfter = ""
728             if delete_after in duration:
729                 task_definition.Settings.DeleteExpiredTaskAfter = _lookup_first(
730                     duration, delete_after
731                 )
732             else:
733                 return 'Invalid value for "delete_after"'
734         if multiple_instances is not None:
735             task_definition.Settings.MultipleInstances = instances[multiple_instances]
736         if save_definition:
737             return _save_task_definition(
738                 name=name,
739                 task_folder=task_folder,
740                 task_definition=task_definition,
741                 user_name=user_name,
742                 password=password,
743                 logon_type=task_definition.Principal.LogonType,
744             )
745 def delete_task(name, location="\\"):
746     r"""
747     Delete a task from the task scheduler.
748     Args:
749         name (str):
750             The name of the task to delete.
751         location (str):
752             A string value representing the location of the task. Default is
753             ``\`` which is the root for the task scheduler
754             (``C:\Windows\System32\tasks``).
755     Returns:
756         bool: ``True`` if successful, otherwise ``False``
757     CLI Example:
758     .. code-block:: bash
759         salt 'minion-id' task.delete_task &lt;task_name&gt;
760     """
761     if name not in list_tasks(location):
762         return "{} not found in {}".format(name, location)
763     with salt.utils.winapi.Com():
764         task_service = win32com.client.Dispatch("Schedule.Service")
765         task_service.Connect()
766         task_folder = task_service.GetFolder(location)
767         task_folder.DeleteTask(name, 0)
768     return name not in list_tasks(location)
769 def delete_folder(name, location="\\"):
770     r"""
771     Delete a folder from the task scheduler.
772     Args:
773         name (str):
774             The name of the folder to delete.
775         location (str):
776             A string value representing the location of the folder.  Default is
777             ``\`` which is the root for the task scheduler
778             (``C:\Windows\System32\tasks``).
779     Returns:
780         bool: ``True`` if successful, otherwise ``False``
781     CLI Example:
782     .. code-block:: bash
783         salt 'minion-id' task.delete_folder &lt;folder_name&gt;
784     """
785     if name not in list_folders(location):
786         return "{} not found in {}".format(name, location)
787     with salt.utils.winapi.Com():
788         task_service = win32com.client.Dispatch("Schedule.Service")
789         task_service.Connect()
790         task_folder = task_service.GetFolder(location)
791         task_folder.DeleteFolder(name, 0)
792     return name not in list_folders(location)
793 def run(name, location="\\"):
794     r"""
795     Run a scheduled task manually.
796     Args:
797         name (str):
798             The name of the task to run.
799         location (str):
800             A string value representing the location of the task. Default is
801             ``\`` which is the root for the task scheduler
802             (``C:\Windows\System32\tasks``).
803     Returns:
804         bool: ``True`` if successful, otherwise ``False``
805     CLI Example:
806     .. code-block:: bash
807         salt 'minion-id' task.run &lt;task_name&gt;
808     """
809     if name not in list_tasks(location):
810         return "{} not found in {}".format(name, location)
811     with salt.utils.winapi.Com():
812         task_service = win32com.client.Dispatch("Schedule.Service")
813         task_service.Connect()
814         task_folder = task_service.GetFolder(location)
815         task = task_folder.GetTask(name)
816         try:
817             task.Run("")
818             return True
819         except pythoncom.com_error:
820             return False
821 def run_wait(name, location="\\"):
822     r"""
823     Run a scheduled task and return when the task finishes
824     Args:
825         name (str):
826             The name of the task to run.
827         location (str):
828             A string value representing the location of the task. Default is
829             ``\`` which is the root for the task scheduler
830             (``C:\Windows\System32\tasks``).
831     Returns:
832         bool: ``True`` if successful, otherwise ``False``
833     CLI Example:
834     .. code-block:: bash
835         salt 'minion-id' task.run_wait &lt;task_name&gt;
836     """
837     if name not in list_tasks(location):
838         return "{} not found in {}".format(name, location)
839     with salt.utils.winapi.Com():
840         task_service = win32com.client.Dispatch("Schedule.Service")
841         task_service.Connect()
842         task_folder = task_service.GetFolder(location)
843         task = task_folder.GetTask(name)
844         if task.State == TASK_STATE_RUNNING:
845             return "Task already running"
846         try:
847             task.Run("")
848             time.sleep(1)
849             running = True
850         except pythoncom.com_error:
851             return False
852         while running:
853             running = False
854             try:
855                 running_tasks = task_service.GetRunningTasks(0)
856                 if running_tasks.Count:
857                     for item in running_tasks:
858                         if item.Name == name:
859                             running = True
860             except pythoncom.com_error:
861                 running = False
862     return True
863 def stop(name, location="\\"):
864     r"""
865     Stop a scheduled task.
866     Args:
867         name (str):
868             The name of the task to stop.
869         location (str):
870             A string value representing the location of the task. Default is
871             ``\`` which is the root for the task scheduler
872             (``C:\Windows\System32\tasks``).
873     Returns:
874         bool: ``True`` if successful, otherwise ``False``
875     CLI Example:
876     .. code-block:: bash
877         salt 'minion-id' task.list_stop &lt;task_name&gt;
878     """
879     if name not in list_tasks(location):
880         return "{} not found in {}".format(name, location)
881     with salt.utils.winapi.Com():
882         task_service = win32com.client.Dispatch("Schedule.Service")
883         task_service.Connect()
884         task_folder = task_service.GetFolder(location)
885         task = task_folder.GetTask(name)
886         try:
887             task.Stop(0)
888             return True
889         except pythoncom.com_error:
890             return False
891 def status(name, location="\\"):
892     r"""
893     Determine the status of a task. Is it Running, Queued, Ready, etc.
894     Args:
895         name (str):
896             The name of the task for which to return the status
897         location (str):
898             A string value representing the location of the task. Default is
899             ``\`` which is the root for the task scheduler
900             (``C:\Windows\System32\tasks``).
901     Returns:
902         str: The current status of the task. Will be one of the following:
903             - Unknown
904             - Disabled
905             - Queued
906             - Ready
907             - Running
908     CLI Example:
909     .. code-block:: bash
910         salt 'minion-id' task.list_status &lt;task_name&gt;
911     """
912     if name not in list_tasks(location):
913         return "{} not found in {}".format(name, location)
914     with salt.utils.winapi.Com():
915         task_service = win32com.client.Dispatch("Schedule.Service")
916         task_service.Connect()
917         task_folder = task_service.GetFolder(location)
918         task = task_folder.GetTask(name)
919         return states[task.State]
920 def info(name, location="\\"):
921     r"""
922     Get the details about a task in the task scheduler.
923     Args:
924         name (str):
925             The name of the task for which to return the status
926         location (str):
927             A string value representing the location of the task. Default is
928             ``\`` which is the root for the task scheduler
929             (``C:\Windows\System32\tasks``).
930     Returns:
931         dict: A dictionary containing the task configuration
932     CLI Example:
933     .. code-block:: bash
934         salt 'minion-id' task.info &lt;task_name&gt;
935     """
936     if name not in list_tasks(location):
937         return "{} not found in {}".format(name, location)
938     with salt.utils.winapi.Com():
939         task_service = win32com.client.Dispatch("Schedule.Service")
940         task_service.Connect()
941         task_folder = task_service.GetFolder(location)
942         task = task_folder.GetTask(name)
943         properties = {
944             "enabled": task.Enabled,
945             "last_run": _get_date_value(task.LastRunTime),
946             "last_run_result": results[task.LastTaskResult],
947             "missed_runs": task.NumberOfMissedRuns,
948             "next_run": _get_date_value(task.NextRunTime),
949             "status": states[task.State],
950         }
951         def_set = task.Definition.Settings
952         settings = {
953             "allow_demand_start": def_set.AllowDemandStart,
954             "force_stop": def_set.AllowHardTerminate,
955         }
956         if def_set.DeleteExpiredTaskAfter == "":
957             settings["delete_after"] = False
958         elif def_set.DeleteExpiredTaskAfter == "PT0S":
959             settings["delete_after"] = "Immediately"
960         else:
961             settings["delete_after"] = _reverse_lookup(
962                 duration, def_set.DeleteExpiredTaskAfter
963             )
964         if def_set.ExecutionTimeLimit == "":
965             settings["execution_time_limit"] = False
966         else:
967             settings["execution_time_limit"] = _reverse_lookup(
968                 duration, def_set.ExecutionTimeLimit
969             )
970         settings["multiple_instances"] = _reverse_lookup(
971             instances, def_set.MultipleInstances
972         )
973         if def_set.RestartInterval == "":
974             settings["restart_interval"] = False
975         else:
976             settings["restart_interval"] = _reverse_lookup(
977                 duration, def_set.RestartInterval
978             )
979         if settings["restart_interval"]:
980             settings["restart_count"] = def_set.RestartCount
981         settings["stop_if_on_batteries"] = def_set.StopIfGoingOnBatteries
982         settings["wake_to_run"] = def_set.WakeToRun
983         conditions = {
984             "ac_only": def_set.DisallowStartIfOnBatteries,
985             "run_if_idle": def_set.RunOnlyIfIdle,
986             "run_if_network": def_set.RunOnlyIfNetworkAvailable,
987             "start_when_available": def_set.StartWhenAvailable,
988         }
989         if conditions["run_if_idle"]:
990             idle_set = def_set.IdleSettings
991             conditions["idle_duration"] = idle_set.IdleDuration
992             conditions["idle_restart"] = idle_set.RestartOnIdle
993             conditions["idle_stop_on_end"] = idle_set.StopOnIdleEnd
994             conditions["idle_wait_timeout"] = idle_set.WaitTimeout
995         if conditions["run_if_network"]:
996             net_set = def_set.NetworkSettings
997             conditions["network_id"] = net_set.Id
998             conditions["network_name"] = net_set.Name
999         actions = []
1000         for actionObj in task.Definition.Actions:
1001             action = {"action_type": _reverse_lookup(action_types, actionObj.Type)}
1002             if actionObj.Path:
1003                 action["cmd"] = actionObj.Path
1004             if actionObj.Arguments:
1005                 action["arguments"] = actionObj.Arguments
1006             if actionObj.WorkingDirectory:
1007                 action["working_dir"] = actionObj.WorkingDirectory
1008             actions.append(action)
1009         triggers = []
1010         for triggerObj in task.Definition.Triggers:
1011             trigger = {"trigger_type": _reverse_lookup(trigger_types, triggerObj.Type)}
1012             if triggerObj.ExecutionTimeLimit:
1013                 trigger["execution_time_limit"] = _reverse_lookup(
1014                     duration, triggerObj.ExecutionTimeLimit
1015                 )
1016             if triggerObj.StartBoundary:
1017                 start_date, start_time = triggerObj.StartBoundary.split("T", 1)
1018                 trigger["start_date"] = start_date
1019                 trigger["start_time"] = start_time
1020             if triggerObj.EndBoundary:
1021                 end_date, end_time = triggerObj.EndBoundary.split("T", 1)
1022                 trigger["end_date"] = end_date
1023                 trigger["end_time"] = end_time
1024             trigger["enabled"] = triggerObj.Enabled
1025             if hasattr(triggerObj, "RandomDelay"):
1026                 if triggerObj.RandomDelay:
1027                     trigger["random_delay"] = _reverse_lookup(
1028                         duration, triggerObj.RandomDelay
1029                     )
1030                 else:
1031                     trigger["random_delay"] = False
1032             if hasattr(triggerObj, "Delay"):
1033                 if triggerObj.Delay:
1034                     trigger["delay"] = _reverse_lookup(duration, triggerObj.Delay)
1035                 else:
1036                     trigger["delay"] = False
1037             triggers.append(trigger)
1038         properties["settings"] = settings
1039         properties["conditions"] = conditions
1040         properties["actions"] = actions
1041         properties["triggers"] = triggers
1042         ret = properties
1043     return ret
1044 def add_action(name=None, location="\\", action_type="Execute", **kwargs):
1045     r"""
1046     Add an action to a task.
1047     Args:
1048         name (str):
1049             The name of the task to which to add the action.
1050         location (str):
1051             A string value representing the location of the task. Default is
1052             ``\`` which is the root for the task scheduler
1053             (``C:\Windows\System32\tasks``).
1054         action_type (str):
1055             The type of action to add. There are three action types. Each one
1056             requires its own set of Keyword Arguments (kwargs). Valid values
1057             are:
1058                 - Execute
1059                 - Email
1060                 - Message
1061     Required arguments for each action_type:
1062     **Execute**
1063         Execute a command or an executable
1064             cmd (str):
1065                 (required) The command or executable to run.
1066             arguments (str):
1067                 (optional) Arguments to be passed to the command or executable.
1068                 To launch a script the first command will need to be the
1069                 interpreter for the script. For example, to run a vbscript you
1070                 would pass ``cscript.exe`` in the ``cmd`` parameter and pass the
1071                 script in the ``arguments`` parameter as follows:
1072                     - ``cmd='cscript.exe' arguments='c:\scripts\myscript.vbs'``
1073                 Batch files do not need an interpreter and may be passed to the
1074                 cmd parameter directly.
1075             start_in (str):
1076                 (optional) The current working directory for the command.
1077     **Email**
1078         Send and email. Requires ``server``, ``from``, and ``to`` or ``cc``.
1079             from (str): The sender
1080             reply_to (str): Who to reply to
1081             to (str): The recipient
1082             cc (str): The CC recipient
1083             bcc (str): The BCC recipient
1084             subject (str): The subject of the email
1085             body (str): The Message Body of the email
1086             server (str): The server used to send the email
1087             attachments (list):
1088                 A list of attachments. These will be the paths to the files to
1089                 attach. ie: ``attachments="['C:\attachment1.txt',
1090                 'C:\attachment2.txt']"``
1091     **Message**
1092         Display a dialog box. The task must be set to "Run only when user is
1093         logged on" in order for the dialog box to display. Both parameters are
1094         required.
1095             title (str):
1096                 The dialog box title.
1097             message (str):
1098                 The dialog box message body
1099     Returns:
1100         dict: A dictionary containing the task configuration
1101     CLI Example:
1102     .. code-block:: bash
1103         salt 'minion-id' task.add_action &lt;task_name&gt; cmd='del /Q /S C:\\Temp'
1104     """
1105     with salt.utils.winapi.Com():
1106         save_definition = False
1107         if kwargs.get("task_definition", False):
1108             task_definition = kwargs.get("task_definition")
1109         else:
1110             save_definition = True
1111             if not name:
1112                 return 'Required parameter "name" not passed'
1113             if name in list_tasks(location):
1114                 task_service = win32com.client.Dispatch("Schedule.Service")
1115                 task_service.Connect()
1116                 task_folder = task_service.GetFolder(location)
1117                 task_definition = task_folder.GetTask(name).Definition
1118             else:
1119                 return "{} not found".format(name)
1120         task_action = task_definition.Actions.Create(action_types[action_type])
1121         if action_types[action_type] == TASK_ACTION_EXEC:
1122             task_action.Id = "Execute_ID1"
1123             if kwargs.get("cmd", False):
1124                 task_action.Path = kwargs.get("cmd")
1125             else:
1126                 return 'Required parameter "cmd" not found'
1127             task_action.Arguments = kwargs.get("arguments", "")
1128             task_action.WorkingDirectory = kwargs.get("start_in", "")
1129         elif action_types[action_type] == TASK_ACTION_SEND_EMAIL:
1130             task_action.Id = "Email_ID1"
1131             if kwargs.get("server", False):
1132                 task_action.Server = kwargs.get("server")
1133             else:
1134                 return 'Required parameter "server" not found'
1135             if kwargs.get("from", False):
1136                 task_action.From = kwargs.get("from")
1137             else:
1138                 return 'Required parameter "from" not found'
1139             if kwargs.get("to", False) or kwargs.get("cc", False):
1140                 if kwargs.get("to"):
1141                     task_action.To = kwargs.get("to")
1142                 if kwargs.get("cc"):
1143                     task_action.Cc = kwargs.get("cc")
1144             else:
1145                 return 'Required parameter "to" or "cc" not found'
1146             if kwargs.get("reply_to"):
1147                 task_action.ReplyTo = kwargs.get("reply_to")
1148             if kwargs.get("bcc"):
1149                 task_action.Bcc = kwargs.get("bcc")
1150             if kwargs.get("subject"):
1151                 task_action.Subject = kwargs.get("subject")
1152             if kwargs.get("body"):
1153                 task_action.Body = kwargs.get("body")
1154             if kwargs.get("attachments"):
1155                 task_action.Attachments = kwargs.get("attachments")
1156         elif action_types[action_type] == TASK_ACTION_SHOW_MESSAGE:
1157             task_action.Id = "Message_ID1"
1158             if kwargs.get("title", False):
1159                 task_action.Title = kwargs.get("title")
1160             else:
1161                 return 'Required parameter "title" not found'
1162             if kwargs.get("message", False):
1163                 task_action.MessageBody = kwargs.get("message")
1164             else:
1165                 return 'Required parameter "message" not found'
1166         if save_definition:
1167             return _save_task_definition(
1168                 name=name,
1169                 task_folder=task_folder,
1170                 task_definition=task_definition,
1171                 user_name=task_definition.Principal.UserID,
1172                 password=None,
1173                 logon_type=task_definition.Principal.LogonType,
1174             )
1175 def _clear_actions(name, location="\\"):
1176     r"""
1177     Remove all actions from the task.
1178     :param str name: The name of the task from which to clear all actions.
1179     :param str location: A string value representing the location of the task.
1180     Default is ``\`` which is the root for the task scheduler
1181     (``C:\Windows\System32\tasks``).
1182     :return: True if successful, False if unsuccessful
1183     :rtype: bool
1184             logon_type=task_definition.Principal.L<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ogonType,
1185         )
1186 def add_trigger(
1187     name=None,
1188     location="\\",
1189     trigger_type=None,
1190     trigger_enabled=True,
1191     start_date=None,
1192     start_time=None,
1193     end_date=None,
1194     end_time=None,
1195     random_delay=None,
1196     repeat_interval=None,
1197     repeat_duration=None,
1198     repeat_stop_at_duration_end=False,
1199     execution_time_limit=None,
1200     delay=</b></font>None,
1201     **kwargs
1202 ):
1203     r"""
1204     Add a trigger to a Windows Scheduled task
1205     .. note::
1206         Arguments are parsed by the YAML loader and are subject to
1207         yaml's idiosyncrasies. Therefore, time values in some
1208         formats (``%H:%M:%S`` and ``%H:%M``) should to be quoted.
1209         See `YAML IDIOSYNCRASIES`_ for more details.
1210     .. _`YAML IDIOSYNCRASIES`: https://docs.saltproject.io/en/latest/topics/troubleshooting/yaml_idiosyncrasies.html#time-expressions
1211     Args:
1212         name (str):
1213             The name of the task to which to add the trigger.
1214         location (str):
1215             A string value representing the location of the task. Default is
1216             ``\`` which is the root for the task scheduler
1217             (``C:\Windows\System32\tasks``).
1218         trigger_type (str):
1219             The type of trigger to create. This is defined when the trigger is
1220             created and cannot be changed later. Options are as follows:
1221                 - Event
1222                 - Once
1223                 - Daily
1224                 - Weekly
1225                 - Monthly
1226                 - MonthlyDay
1227                 - OnIdle
1228                 - OnTaskCreation
1229                 - OnBoot
1230                 - OnLogon
1231                 - OnSessionChange
1232         trigger_enabled (bool):
1233             Boolean value that indicates whether the trigger is enabled.
1234         start_date (str):
1235             The date when the trigger is activated. If no value is passed, the
1236             current date will be used. Can be one of the following formats:
1237                 - %Y-%m-%d
1238                 - %m-%d-%y
1239                 - %m-%d-%Y
1240                 - %m/%d/%y
1241                 - %m/%d/%Y
1242                 - %Y/%m/%d
1243         start_time (str):
1244             The time when the trigger is activated. If no value is passed,
1245             midnight will be used. Can be one of the following formats:
1246                 - %I:%M:%S %p
1247                 - %I:%M %p
1248                 - %H:%M:%S
1249                 - %H:%M
1250         end_date (str):
1251             The date when the trigger is deactivated. The trigger cannot start
1252             the task after it is deactivated. Can be one of the following
1253             formats:
1254                 - %Y-%m-%d
1255                 - %m-%d-%y
1256                 - %m-%d-%Y
1257                 - %m/%d/%y
1258                 - %m/%d/%Y
1259                 - %Y/%m/%d
1260         end_time (str):
1261             The time when the trigger is deactivated. If this is not passed
1262             with ``end_date`` it will be set to midnight. Can be one of the
1263             following formats:
1264                 - %I:%M:%S %p
1265                 - %I:%M %p
1266                 - %H:%M:%S
1267                 - %H:%M
1268         random_delay (str):
1269             The delay time that is randomly added to the start time of the
1270             trigger. Valid values are:
1271                 - 30 seconds
1272                 - 1 minute
1273                 - 30 minutes
1274                 - 1 hour
1275                 - 8 hours
1276                 - 1 day
1277             .. note::
1278                 This parameter applies to the following trigger types
1279                     - Once
1280                     - Daily
1281                     - Weekly
1282                     - Monthly
1283                     - MonthlyDay
1284         repeat_interval (str):
1285             The amount of time between each restart of the task. Valid values
1286             are:
1287                 - 5 minutes
1288                 - 10 minutes
1289                 - 15 minutes
1290                 - 30 minutes
1291                 - 1 hour
1292         repeat_duration (str):
1293             How long the pattern is repeated. Valid values are:
1294                 - Indefinitely
1295                 - 15 minutes
1296                 - 30 minutes
1297                 - 1 hour
1298                 - 12 hours
1299                 - 1 day
1300         repeat_stop_at_duration_end (bool):
1301             Boolean value that indicates if a running instance of the task is
1302             stopped at the end of the repetition pattern duration.
1303         execution_time_limit (str):
1304             The maximum amount of time that the task launched by the trigger is
1305             allowed to run. Valid values are:
1306                 - 30 minutes
1307                 - 1 hour
1308                 - 2 hours
1309                 - 4 hours
1310                 - 8 hours
1311                 - 12 hours
1312                 - 1 day
1313                 - 3 days (default)
1314         delay (str):
1315             The time the trigger waits after its activation to start the task.
1316             Valid values are:
1317                 - 15 seconds
1318                 - 30 seconds
1319                 - 1 minute
1320                 - 30 minutes
1321                 - 1 hour
1322                 - 8 hours
1323                 - 1 day
1324             .. note::
1325                 This parameter applies to the following trigger types:
1326                     - OnLogon
1327                     - OnBoot
1328                     - Event
1329                     - OnTaskCreation
1330                     - OnSessionChange
1331     **kwargs**
1332     There are optional keyword arguments determined by the type of trigger
1333     being defined. They are as follows:
1334     *Event*
1335         The trigger will be fired by an event.
1336             subscription (str):
1337                 An event definition in xml format that fires the trigger. The
1338                 easiest way to get this would is to create an event in Windows
1339                 Task Scheduler and then copy the xml text.
1340     *Once*
1341         No special parameters required.
1342     *Daily*
1343         The task will run daily.
1344             days_interval (int):
1345                 The interval between days in the schedule. An interval of 1
1346                 produces a daily schedule. An interval of 2 produces an
1347                 every-other day schedule. If no interval is specified, 1 is
1348                 used. Valid entries are 1 - 999.
1349     *Weekly*
1350         The task will run weekly.
1351             weeks_interval (int):
1352                 The interval between weeks in the schedule. An interval of 1
1353                 produces a weekly schedule. An interval of 2 produces an
1354                 every-other week schedule. If no interval is specified, 1 is
1355                 used. Valid entries are 1 - 52.
1356             days_of_week (list):
1357                 Sets the days of the week on which the task runs. Should be a
1358                 list. ie: ``['Monday','Wednesday','Friday']``. Valid entries are
1359                 the names of the days of the week.
1360     *Monthly*
1361         The task will run monthly.
1362             months_of_year (list):
1363                 Sets the months of the year during which the task runs. Should
1364                 be a list. ie: ``['January','July']``. Valid entries are the
1365                 full names of all the months.
1366             days_of_month (list):
1367                 Sets the days of the month during which the task runs. Should be
1368                 a list. ie: ``[1, 15, 'Last']``. Options are all days of the
1369                 month 1 - 31 and the word 'Last' to indicate the last day of the
1370                 month.
1371             last_day_of_month (bool):
1372                 Boolean value that indicates that the task runs on the last day
1373                 of the month regardless of the actual date of that day.
1374                 .. note::
1375                     You can set the task to run on the last day of the month by
1376                     either including the word 'Last' in the list of days, or
1377                     setting the parameter 'last_day_of_month' equal to ``True``.
1378     *MonthlyDay*
1379         The task will run monthly on the specified day.
1380             months_of_year (list):
1381                 Sets the months of the year during which the task runs. Should
1382                 be a list. ie: ``['January','July']``. Valid entries are the
1383                 full names of all the months.
1384             weeks_of_month (list):
1385                 Sets the weeks of the month during which the task runs. Should
1386                 be a list. ie: ``['First','Third']``. Valid options are:
1387                     - First
1388                     - Second
1389                     - Third
1390                     - Fourth
1391             last_week_of_month (bool):
1392                 Boolean value that indicates that the task runs on the last week
1393                 of the month.
1394             days_of_week (list):
1395                 Sets the days of the week during which the task runs. Should be
1396                 a list. ie: ``['Monday','Wednesday','Friday']``.  Valid entries
1397                 are the names of the days of the week.
1398     *OnIdle*
1399         No special parameters required.
1400     *OnTaskCreation*
1401         No special parameters required.
1402     *OnBoot*
1403         No special parameters required.
1404     *OnLogon*
1405         No special parameters required.
1406     *OnSessionChange*
1407         The task will be triggered by a session change.
1408             session_user_name (str):
1409                 Sets the user for the Terminal Server session. When a session
1410                 state change is detected for this user, a task is started. To
1411                 detect session status change for any user, do not pass this
1412                 parameter.
1413             state_change (str):
1414                 Sets the kind of Terminal Server session change that would
1415                 trigger a task launch. Valid options are:
1416                     - ConsoleConnect: When you connect to a user session (switch
1417                       users)
1418                     - ConsoleDisconnect: When you disconnect a user session
1419                       (switch users)
1420                     - RemoteConnect: When a user connects via Remote Desktop
1421                     - RemoteDisconnect: When a user disconnects via Remote
1422                       Desktop
1423                     - SessionLock: When the workstation is locked
1424                     - SessionUnlock: When the workstation is unlocked
1425     Returns:
1426         bool: ``True`` if successful, otherwise ``False``
1427     CLI Example:
1428     .. code-block:: bash
1429         salt 'minion-id' task.add_trigger &lt;task_name&gt; trigger_type=Once trigger_enabled=True start_date=2016/12/1 start_time='"12:01"'
1430     """
1431     if not trigger_type:
1432         return 'Required parameter "trigger_type" not specified'
1433     state_changes = {
1434         "ConsoleConnect": 1,
1435         "ConsoleDisconnect": 2,
1436         "RemoteConnect": 3,
1437         "RemoteDisconnect": 4,
1438         "SessionLock": 7,
1439         "SessionUnlock": 8,
1440     }
1441     days = {
1442         1: 0x1,
1443         2: 0x2,
1444         3: 0x4,
1445         4: 0x8,
1446         5: 0x10,
1447         6: 0x20,
1448         7: 0x40,
1449         8: 0x80,
1450         9: 0x100,
1451         10: 0x200,
1452         11: 0x400,
1453         12: 0x800,
1454         13: 0x1000,
1455         14: 0x2000,
1456         15: 0x4000,
1457         16: 0x8000,
1458         17: 0x10000,
1459         18: 0x20000,
1460         19: 0x40000,
1461         20: 0x80000,
1462         21: 0x100000,
1463         22: 0x200000,
1464         23: 0x400000,
1465         24: 0x800000,
1466         25: 0x1000000,
1467         26: 0x2000000,
1468         27: 0x4000000,
1469         28: 0x8000000,
1470         29: 0x10000000,
1471         30: 0x20000000,
1472         31: 0x40000000,
1473         "Last": 0x80000000,
1474     }
1475     weekdays = {
1476         "Sunday": 0x1,
1477         "Monday": 0x2,
1478         "Tuesday": 0x4,
1479         "Wednesday": 0x8,
1480         "Thursday": 0x10,
1481         "Friday": 0x20,
1482         "Saturday": 0x40,
1483     }
1484     weeks = {"First": 0x1, "Second": 0x2, "Third": 0x4, "Fourth": 0x8}
1485     months = {
1486         "January": 0x1,
1487         "February": 0x2,
1488         "March": 0x4,
1489         "April": 0x8,
1490         "May": 0x10,
1491         "June": 0x20,
1492         "July": 0x40,
1493         "August": 0x80,
1494         "September": 0x100,
1495         "October": 0x200,
1496         "November": 0x400,
1497         "December": 0x800,
1498     }
1499     if start_date:
1500         date_format = _get_date_time_format(start_date)
1501         if date_format:
1502             dt_obj = datetime.strptime(start_date, date_format)
1503         else:
1504             return "Invalid start_date"
1505     else:
1506         dt_obj = datetime.now()
1507     if start_time:
1508         time_format = _get_date_time_format(start_time)
1509         if time_format:
1510             tm_obj = datetime.strptime(start_time, time_format)
1511         else:
1512             return "Invalid start_time"
1513     else:
1514         tm_obj = datetime.strptime("00:00:00", "%H:%M:%S")
1515     start_boundary = "{}T{}".format(
1516         dt_obj.strftime("%Y-%m-%d"), tm_obj.strftime("%H:%M:%S")
1517     )
1518     dt_obj = None
1519     if end_date:
1520         date_format = _get_date_time_format(end_date)
1521         if date_format:
1522             dt_obj = datetime.strptime(end_date, date_format)
1523         else:
1524             return "Invalid end_date"
1525     if end_time:
1526         time_format = _get_date_time_format(end_time)
1527         if time_format:
1528             tm_obj = datetime.strptime(end_time, time_format)
1529         else:
1530             return "Invalid end_time"
1531     else:
1532         tm_obj = datetime.strptime("00:00:00", "%H:%M:%S")
1533     end_boundary = None
1534     if dt_obj and tm_obj:
1535         end_boundary = "{}T{}".format(
1536             dt_obj.strftime("%Y-%m-%d"), tm_obj.strftime("%H:%M:%S")
1537         )
1538     with salt.utils.winapi.Com():
1539         save_definition = False
1540         if kwargs.get("task_definition", False):
1541             task_definition = kwargs.get("task_definition")
1542         else:
1543             save_definition = True
1544             if not name:
1545                 return 'Required parameter "name" not passed'
1546             if name in list_tasks(location):
1547                 task_service = win32com.client.Dispatch("Schedule.Service")
1548                 task_service.Connect()
1549                 task_folder = task_service.GetFolder(location)
1550                 task_definition = task_folder.GetTask(name).Definition
1551             else:
1552                 return "{} not found".format(name)
1553         trigger = task_definition.Triggers.Create(trigger_types[trigger_type])
1554         trigger.StartBoundary = start_boundary
1555         if delay:
1556             trigger.Delay = _lookup_first(duration, delay)
1557         if random_delay:
1558             trigger.RandomDelay = _lookup_first(duration, random_delay)
1559         if repeat_interval:
1560             trigger.Repetition.Interval = _lookup_first(duration, repeat_interval)
1561             if repeat_duration:
1562                 trigger.Repetition.Duration = _lookup_first(duration, repeat_duration)
1563             trigger.Repetition.StopAtDurationEnd = repeat_stop_at_duration_end
1564         if execution_time_limit:
1565             trigger.ExecutionTimeLimit = _lookup_first(duration, execution_time_limit)
1566         if end_boundary:
1567             trigger.EndBoundary = end_boundary
1568         trigger.Enabled = trigger_enabled
1569         if trigger_types[trigger_type] == TASK_TRIGGER_EVENT:
1570             if kwargs.get("subscription", False):
1571                 trigger.Id = "Event_ID1"
1572                 trigger.Subscription = kwargs.get("subscription")
1573             else:
1574                 return 'Required parameter "subscription" not passed'
1575         elif trigger_types[trigger_type] == TASK_TRIGGER_TIME:
1576             trigger.Id = "Once_ID1"
1577         elif trigger_types[trigger_type] == TASK_TRIGGER_DAILY:
1578             trigger.Id = "Daily_ID1"
1579             trigger.DaysInterval = kwargs.get("days_interval", 1)
1580         elif trigger_types[trigger_type] == TASK_TRIGGER_WEEKLY:
1581             trigger.Id = "Weekly_ID1"
1582             trigger.WeeksInterval = kwargs.get("weeks_interval", 1)
1583             if kwargs.get("days_of_week", False):
1584                 bits_days = 0
1585                 for weekday in kwargs.get("days_of_week"):
1586                     bits_days |= weekdays[weekday]
1587                 trigger.DaysOfWeek = bits_days
1588             else:
1589                 return 'Required parameter "days_of_week" not passed'
1590         elif trigger_types[trigger_type] == TASK_TRIGGER_MONTHLY:
1591             trigger.Id = "Monthly_ID1"
1592             if kwargs.get("months_of_year", False):
1593                 bits_months = 0
1594                 for month in kwargs.get("months_of_year"):
1595                     bits_months |= months[month]
1596                 trigger.MonthsOfYear = bits_months
1597             else:
1598                 return 'Required parameter "months_of_year" not passed'
1599             if kwargs.get("days_of_month", False) or kwargs.get(
1600                 "last_day_of_month", False
1601             ):
1602                 if kwargs.get("days_of_month", False):
1603                     bits_days = 0
1604                     for day in kwargs.get("days_of_month"):
1605                         bits_days |= days[day]
1606                     trigger.DaysOfMonth = bits_days
1607                 trigger.RunOnLastDayOfMonth = kwargs.get("last_day_of_month", False)
1608             else:
1609                 return (
1610                     'Monthly trigger requires "days_of_month" or "last_day_of_'
1611                     'month" parameters'
1612                 )
1613         elif trigger_types[trigger_type] == TASK_TRIGGER_MONTHLYDOW:
1614             trigger.Id = "Monthly_DOW_ID1"
1615             if kwargs.get("months_of_year", False):
1616                 bits_months = 0
1617                 for month in kwargs.get("months_of_year"):
1618                     bits_months |= months[month]
1619                 trigger.MonthsOfYear = bits_months
1620             else:
1621                 return 'Required parameter "months_of_year" not passed'
1622             if kwargs.get("weeks_of_month", False) or kwargs.get(
1623                 "last_week_of_month", False
1624             ):
1625                 if kwargs.get("weeks_of_month", False):
1626                     bits_weeks = 0
1627                     for week in kwargs.get("weeks_of_month"):
1628                         bits_weeks |= weeks[week]
1629                     trigger.WeeksOfMonth = bits_weeks
1630                 trigger.RunOnLastWeekOfMonth = kwargs.get("last_week_of_month", False)
1631             else:
1632                 return (
1633                     'Monthly DOW trigger requires "weeks_of_month" or "last_'
1634                     'week_of_month" parameters'
1635                 )
1636             if kwargs.get("days_of_week", False):
1637                 bits_days = 0
1638                 for weekday in kwargs.get("days_of_week"):
1639                     bits_days |= weekdays[weekday]
1640                 trigger.DaysOfWeek = bits_days
1641             else:
1642                 return 'Required parameter "days_of_week" not passed'
1643         elif trigger_types[trigger_type] == TASK_TRIGGER_IDLE:
1644             trigger.Id = "OnIdle_ID1"
1645         elif trigger_types[trigger_type] == TASK_TRIGGER_REGISTRATION:
1646             trigger.Id = "OnTaskCreation_ID1"
1647         elif trigger_types[trigger_type] == TASK_TRIGGER_BOOT:
1648             trigger.Id = "OnBoot_ID1"
1649         elif trigger_types[trigger_type] == TASK_TRIGGER_LOGON:
1650             trigger.Id = "OnLogon_ID1"
1651         elif trigger_types[trigger_type] == TASK_TRIGGER_SESSION_STATE_CHANGE:
1652             trigger.Id = "OnSessionStateChange_ID1"
1653             if kwargs.get("session_user_name", False):
1654                 trigger.UserId = kwargs.get("session_user_name")
1655             if kwargs.get("state_change", False):
1656                 trigger.StateChange = state_changes[kwargs.get("state_change")]
1657             else:
1658                 return 'Required parameter "state_change" not passed'
1659         if save_definition:
1660             return _save_task_definition(
1661                 name=name,
1662                 task_folder=task_folder,
1663                 task_definition=task_definition,
1664                 user_name=task_definition.Principal.UserID,
1665                 password=None,
1666                 logon_type=task_definition.Principal.LogonType,
1667             )
1668 def clear_triggers(name, location="\\"):
1669     r"""
1670     Remove all triggers from the task.
1671     Args:
1672         name (str):
1673             The name of the task from which to clear all triggers.
1674         location (str):
1675             A string value representing the location of the task. Default is
1676             ``\`` which is the root for the task scheduler
1677             (``C:\Windows\System32\tasks``).
1678     Returns:
1679         bool: ``True`` if successful, otherwise ``False``
1680     CLI Example:
1681     .. code-block:: bash
1682         salt 'minion-id' task.clear_trigger &lt;task_name&gt;
1683     """
1684     if name not in list_tasks(location):
1685         return "{} not found in {}".format(name, location)
1686     with salt.utils.winapi.Com():
1687         task_service = win32com.client.Dispatch("Schedule.Service")
1688         task_service.Connect()
1689         task_folder = task_service.GetFolder(location)
1690         task_definition = task_folder.GetTask(name).Definition
1691         triggers = task_definition.Triggers
1692         triggers.Clear()
1693         return _save_task_definition(
1694             name=name,
1695             task_folder=task_folder,
1696             task_definition=task_definition,
1697             user_name=task_definition.Principal.UserID,
1698             password=None,
1699             logon_type=task_definition.Principal.LogonType,
1700         )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
