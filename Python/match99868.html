<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for boto_cfn_1.py &amp; win_task.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for boto_cfn_1.py &amp; win_task.py
      </h3>
<h1 align="center">
        3.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>boto_cfn_1.py (12.587413%)<th>win_task.py (1.9791094%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(190-225)<td><a href="#" name="0">(775-798)</a><td align="center"><font color="#ff0000">20</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(138-156)<td><a href="#" name="1">(1814-1832)</a><td align="center"><font color="#cc0000">16</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_cfn_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import salt.utils.versions
3 log = logging.getLogger(__name__)
4 try:
5     import boto
6     import boto.cloudformation
7     from boto.exception import BotoServerError
8     logging.getLogger("boto").setLevel(logging.CRITICAL)
9     HAS_BOTO = True
10 except ImportError:
11     HAS_BOTO = False
12 def __virtual__():
13     return salt.utils.versions.check_boto_reqs(check_boto3=False)
14 def __init__(opts):
15     if HAS_BOTO:
16         __utils__["boto.assign_funcs"](
17             __name__, "cfn", module="cloudformation", pack=__salt__
18         )
19 def exists(name, region=None, key=None, keyid=None, profile=None):
20     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
21     try:
22         exists = conn.describe_stacks(name)
23         log.debug("Stack %s exists.", name)
24         return True
25     except BotoServerError as e:
26         log.debug("boto_cfn.exists raised an exception", exc_info=True)
27         return False
28 def describe(name, region=None, key=None, keyid=None, profile=None):
29     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
30     try:
31         r = conn.describe_stacks(name)
32         if r:
33             stack = r[0]
34             log.debug("Found VPC: %s", stack.stack_id)
35             keys = (
36                 "stack_id",
37                 "description",
38                 "stack_status",
39                 "stack_status_reason",
40                 "tags",
41             )
42             ret = {k: getattr(stack, k) for k in keys if hasattr(stack, k)}
43             o = getattr(stack, "outputs")
44             p = getattr(stack, "parameters")
45             outputs = {}
46             parameters = {}
47             for i in o:
48                 outputs[i.key] = i.value
49             ret["outputs"] = outputs
50             for j in p:
51                 parameters[j.key] = j.value
52             ret["parameters"] = parameters
53             return {"stack": ret}
54         log.debug("Stack %s exists.", name)
55     except BotoServerError as e:
56         log.warning("Could not describe stack %s.\n%s", name, e)
57         r<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>eturn False
58 def create(
59     name,
60     template_body=None,
61     template_url=None,
62     parameters=None,
63     notification_arns=None,
64     disable_rollback=None,
65     timeout_in_minutes=None,
66     capabilities=None,
67     tags=None,
68     on_failure=None,
69     stack_policy_body=None,
70     stack_policy_url=None,
71     region=None,
72     key=None,
73     keyid=</b></font>None,
74     profile=None,
75 ):
76     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
77     try:
78         return conn.create_stack(
79             name,
80             template_body,
81             template_url,
82             parameters,
83             notification_arns,
84             disable_rollback,
85             timeout_in_minutes,
86             capabilities,
87             tags,
88             on_failure,
89             stack_policy_body,
90             stack_policy_url,
91         )
92     except BotoServerError as e:
93         log.error(msg)
94         log.debug(e)
95         r<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>eturn False
96 def update_stack(
97     name,
98     template_body=None,
99     template_url=None,
100     parameters=None,
101     notification_arns=None,
102     disable_rollback=False,
103     timeout_in_minutes=None,
104     capabilities=None,
105     tags=None,
106     use_previous_template=None,
107     stack_policy_during_update_body=None,
108     stack_policy_during_update_url=None,
109     stack_policy_body=None,
110     stack_policy_url=None,
111     region=None,
112     key=None,
113     keyid=None,
114     profile=None,
115 ):
116     conn =</b></font> _get_conn(region=region, key=key, keyid=keyid, profile=profile)
117     try:
118         update = conn.update_stack(
119             name,
120             template_body,
121             template_url,
122             parameters,
123             notification_arns,
124             disable_rollback,
125             timeout_in_minutes,
126             capabilities,
127             tags,
128             use_previous_template,
129             stack_policy_during_update_body,
130             stack_policy_during_update_url,
131             stack_policy_body,
132             stack_policy_url,
133         )
134         log.debug("Updated result is : %s.", update)
135         return update
136     except BotoServerError as e:
137         msg = "Failed to update stack {}.".format(name)
138         log.debug(e)
139         log.error(msg)
140         return str(e)
141 def delete(name, region=None, key=None, keyid=None, profile=None):
142     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
143     try:
144         return conn.delete_stack(name)
145     except BotoServerError as e:
146         msg = "Failed to create stack {}.".format(name)
147         log.error(msg)
148         log.debug(e)
149         return str(e)
150 def get_template(name, region=None, key=None, keyid=None, profile=None):
151     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
152     try:
153         template = conn.get_template(name)
154         log.info("Retrieved template for stack %s", name)
155         return template
156     except BotoServerError as e:
157         log.debug(e)
158         msg = "Template {} does not exist".format(name)
159         log.error(msg)
160         return str(e)
161 def validate_template(
162     template_body=None,
163     template_url=None,
164     region=None,
165     key=None,
166     keyid=None,
167     profile=None,
168 ):
169     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
170     try:
171         return conn.validate_template(template_body, template_url)
172     except BotoServerError as e:
173         log.debug(e)
174         msg = "Error while trying to validate template {}.".format(template_body)
175         log.error(msg)
176         return str(e)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>win_task.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import time
3 from datetime import datetime
4 import salt.utils.platform
5 import salt.utils.winapi
6 from salt.exceptions import ArgumentValueError, CommandExecutionError
7 try:
8     import pythoncom
9     import win32com.client
10     HAS_DEPENDENCIES = True
11 except ImportError:
12     HAS_DEPENDENCIES = False
13 log = logging.getLogger(__name__)
14 __virtualname__ = "task"
15 TASK_ACTION_EXEC = 0
16 TASK_ACTION_COM_HANDLER = 5
17 TASK_ACTION_SEND_EMAIL = 6
18 TASK_ACTION_SHOW_MESSAGE = 7
19 TASK_COMPATIBILITY_AT = 0
20 TASK_COMPATIBILITY_V1 = 1
21 TASK_COMPATIBILITY_V2 = 2
22 TASK_COMPATIBILITY_V3 = 3
23 TASK_VALIDATE_ONLY = 0x1
24 TASK_CREATE = 0x2
25 TASK_UPDATE = 0x4
26 TASK_CREATE_OR_UPDATE = 0x6
27 TASK_DISABLE = 0x8
28 TASK_DONT_ADD_PRINCIPAL_ACE = 0x10
29 TASK_IGNORE_REGISTRATION_TRIGGERS = 0x20
30 TASK_INSTANCES_PARALLEL = 0
31 TASK_INSTANCES_QUEUE = 1
32 TASK_INSTANCES_IGNORE_NEW = 2
33 TASK_INSTANCES_STOP_EXISTING = 3
34 TASK_LOGON_NONE = 0
35 TASK_LOGON_PASSWORD = 1
36 TASK_LOGON_S4U = 2
37 TASK_LOGON_INTERACTIVE_TOKEN = 3
38 TASK_LOGON_GROUP = 4
39 TASK_LOGON_SERVICE_ACCOUNT = 5
40 TASK_LOGON_INTERACTIVE_TOKEN_OR_PASSWORD = 6
41 TASK_RUNLEVEL_LUA = 0
42 TASK_RUNLEVEL_HIGHEST = 1
43 TASK_STATE_UNKNOWN = 0
44 TASK_STATE_DISABLED = 1
45 TASK_STATE_QUEUED = 2
46 TASK_STATE_READY = 3
47 TASK_STATE_RUNNING = 4
48 TASK_TRIGGER_EVENT = 0
49 TASK_TRIGGER_TIME = 1
50 TASK_TRIGGER_DAILY = 2
51 TASK_TRIGGER_WEEKLY = 3
52 TASK_TRIGGER_MONTHLY = 4
53 TASK_TRIGGER_MONTHLYDOW = 5
54 TASK_TRIGGER_IDLE = 6
55 TASK_TRIGGER_REGISTRATION = 7
56 TASK_TRIGGER_BOOT = 8
57 TASK_TRIGGER_LOGON = 9
58 TASK_TRIGGER_SESSION_STATE_CHANGE = 11
59 duration = {
60     "Immediately": "PT0M",
61     "Indefinitely": "",
62     "Do not wait": "PT0M",
63     "15 seconds": "PT15S",
64     "30 seconds": "PT30S",
65     "1 minute": "PT1M",
66     "5 minutes": "PT5M",
67     "10 minutes": "PT10M",
68     "15 minutes": "PT15M",
69     "30 minutes": "PT30M",
70     "1 hour": "PT1H",
71     "2 hours": "PT2H",
72     "4 hours": "PT4H",
73     "8 hours": "PT8H",
74     "12 hours": "PT12H",
75     "1 day": ["P1D", "PT24H"],
76     "3 days": ["P3D", "PT72H"],
77     "30 days": "P30D",
78     "90 days": "P90D",
79     "180 days": "P180D",
80     "365 days": "P365D",
81 }
82 action_types = {
83     "Execute": TASK_ACTION_EXEC,
84     "Email": TASK_ACTION_SEND_EMAIL,
85     "Message": TASK_ACTION_SHOW_MESSAGE,
86 }
87 trigger_types = {
88     "Event": TASK_TRIGGER_EVENT,
89     "Once": TASK_TRIGGER_TIME,
90     "Daily": TASK_TRIGGER_DAILY,
91     "Weekly": TASK_TRIGGER_WEEKLY,
92     "Monthly": TASK_TRIGGER_MONTHLY,
93     "MonthlyDay": TASK_TRIGGER_MONTHLYDOW,
94     "OnIdle": TASK_TRIGGER_IDLE,
95     "OnTaskCreation": TASK_TRIGGER_REGISTRATION,
96     "OnBoot": TASK_TRIGGER_BOOT,
97     "OnLogon": TASK_TRIGGER_LOGON,
98     "OnSessionChange": TASK_TRIGGER_SESSION_STATE_CHANGE,
99 }
100 states = {
101     TASK_STATE_UNKNOWN: "Unknown",
102     TASK_STATE_DISABLED: "Disabled",
103     TASK_STATE_QUEUED: "Queued",
104     TASK_STATE_READY: "Ready",
105     TASK_STATE_RUNNING: "Running",
106 }
107 instances = {
108     "Parallel": TASK_INSTANCES_PARALLEL,
109     "Queue": TASK_INSTANCES_QUEUE,
110     "No New Instance": TASK_INSTANCES_IGNORE_NEW,
111     "Stop Existing": TASK_INSTANCES_STOP_EXISTING,
112 }
113 results = {
114     0x0: "The operation completed successfully",
115     0x1: "Incorrect or unknown function called",
116     0x2: "File not found",
117     0xA: "The environment is incorrect",
118     0x41300: "Task is ready to run at its next scheduled time",
119     0x41301: "Task is currently running",
120     0x41302: "Task is disabled",
121     0x41303: "Task has not yet run",
122     0x41304: "There are no more runs scheduled for this task",
123     0x41306: "Task was terminated by the user",
124     0x8004130F: "Credentials became corrupted",
125     0x8004131F: "An instance of this task is already running",
126     0x800710E0: "The operator or administrator has refused the request",
127     0x800704DD: "The service is not available (Run only when logged in?)",
128     0xC000013A: "The application terminated as a result of CTRL+C",
129     0xC06D007E: "Unknown software exception",
130 }
131 def __virtual__():
132     if salt.utils.platform.is_windows():
133         if not HAS_DEPENDENCIES:
134             log.warning("Could not load dependencies for %s", __virtualname__)
135         return __virtualname__
136     return False, "Module win_task: module only works on Windows systems"
137 def _get_date_time_format(dt_string):
138     valid_formats = [
139         "%I:%M:%S %p",
140         "%I:%M %p",
141         "%H:%M:%S",
142         "%H:%M",
143         "%Y-%m-%d",
144         "%m-%d-%y",
145         "%m-%d-%Y",
146         "%m/%d/%y",
147         "%m/%d/%Y",
148         "%Y/%m/%d",
149     ]
150     for dt_format in valid_formats:
151         try:
152             datetime.strptime(dt_string, dt_format)
153             return dt_format
154         except ValueError:
155             continue
156     return False
157 def _get_date_value(date):
158     try:
159         return "{}".format(date)
160     except ValueError:
161         return "Never"
162 def _reverse_lookup(dictionary, value):
163     value_index = -1
164     for idx, dict_value in enumerate(dictionary.values()):
165         if type(dict_value) == list:
166             if value in dict_value:
167                 value_index = idx
168                 break
169         elif value == dict_value:
170             value_index = idx
171             break
172     return list(dictionary)[value_index]
173 def _lookup_first(dictionary, key):
174     value = dictionary[key]
175     if type(value) == list:
176         return value[0]
177     else:
178         return value
179 def _save_task_definition(
180     name, task_folder, task_definition, user_name, password, logon_type
181 ):
182     try:
183         task_folder.RegisterTaskDefinition(
184             name,
185             task_definition,
186             TASK_CREATE_OR_UPDATE,
187             user_name,
188             password,
189             logon_type,
190         )
191         return True
192     except pythoncom.com_error as error:
193         hr, msg, exc, arg = error.args  # pylint: disable=W0633
194         fc = {
195             -2147024773: (
196                 "The filename, directory name, or volume label syntax is incorrect"
197             ),
198             -2147024894: "The system cannot find the file specified",
199             -2147216615: "Required element or attribute missing",
200             -2147216616: "Value incorrectly formatted or out of range",
201             -2147352571: "Access denied",
202         }
203         try:
204             failure_code = fc[exc[5]]
205         except KeyError:
206             failure_code = "Unknown Failure: {}".format(error)
207         log.debug("Failed to modify task: %s", failure_code)
208         return "Failed to modify task: {}".format(failure_code)
209 def list_tasks(location="\\"):
210     r"""
211     List all tasks located in a specific location in the task scheduler.
212     Args:
213         location (str):
214             A string value representing the folder from which you want to list
215             tasks. Default is ``\`` which is the root for the task scheduler
216             (``C:\Windows\System32\tasks``).
217     Returns:
218         list: Returns a list of tasks
219     CLI Example:
220     .. code-block:: bash
221         salt 'minion-id' task.list_tasks
222         salt 'minion-id' task.list_tasks Microsoft\XblGameSave
223     with salt.utils.winapi.Com():
224         task_service = win32com.client.Dispatch("Schedule.Service")
225         task_service.Connect()
226         task_folder = task_service.GetFolder(location)
227         folders = task_folder.GetFolders(0)
228         ret = []
229         for folder in folders:
230             ret.append(folder.Name)
231     return ret
232 def list_triggers(name, location="\\"):
233     r"""
234     List all triggers that pertain to a task in the specified location.
235     Args:
236         name (str):
237             The name of the task for which list triggers.
238         location (str):
239             A string value representing the location of the task from which to
240             list triggers. Default is ``\`` which is the root for the task
241             scheduler (``C:\Windows\System32\tasks``).
242     Returns:
243         list: Returns a list of triggers.
244     CLI Example:
245     .. code-block:: bash
246         salt 'minion-id' task.list_triggers &lt;task_name&gt;
247         salt '*' task.list_triggers XblGameSaveTask Microsoft\XblGameSave
248     with salt.utils.winapi.Com():
249         task_service = win32com.client.Dispatch("Schedule.Service")
250         task_service.Connect()
251         task_folder = task_service.GetFolder(location)
252         task_definition = task_folder.GetTask(name).Definition
253         actions = task_definition.Actions
254         ret = []
255         for action in actions:
256             ret.append(action.Id)
257     return ret
258 def create_task(
259     name, location="\\", user_name="System", password=None, force=False, **kwargs
260 ):
261     r"""
262     Create a new task in the designated location. This function has many keyword
263     arguments that are not listed here. For additional arguments see:
264         - :py:func:`edit_task`
265         - :py:func:`add_action`
266         - :py:func:`add_trigger`
267     Args:
268         name (str):
269             The name of the task. This will be displayed in the task scheduler.
270         location (str):
271             A string value representing the location in which to create the
272             task. Default is ``\`` which is the root for the task scheduler
273             (``C:\Windows\System32\tasks``).
274         user_name (str):
275             The user account under which to run the task. To specify the
276             'System' account, use 'System'. The password will be ignored.
277         password (str):
278             The password to use for authentication. This should set the task to
279             run whether the user is logged in or not, but is currently not
280             working.
281         force (bool):
282             If the task exists, overwrite the existing task.
283     Returns:
284         bool: ``True`` if successful, otherwise ``False``
285     CLI Example:
286     .. code-block:: bash
287         salt 'minion-id' task.create_task &lt;task_name&gt; user_name=System force=True action_type=Execute cmd='del /Q /S C:\\Temp' trigger_type=Once start_date=2016-12-1 start_time=01:00
288     """
289     if name in list_tasks(location) and not force:
290         return "{} already exists".format(name)
291     with salt.utils.winapi.Com():
292         task_service = win32com.client.Dispatch("Schedule.Service")
293         task_service.Connect()
294         task_definition = task_service.NewTask(0)
295         edit_task(
296             task_definition=task_definition,
297             user_name=user_name,
298             password=password,
299             **kwargs
300         )
301         add_action(task_definition=task_definition, **kwargs)
302         add_trigger(task_definition=task_definition, **kwargs)
303         task_folder = task_service.GetFolder(location)
304         _save_task_definition(
305             name=name,
306             task_folder=task_folder,
307             task_definition=task_definition,
308             user_name=task_definition.Principal.UserID,
309             password=password,
310             logon_type=task_definition.Principal.LogonType,
311         )
312     return name in list_tasks(location)
313 def create_task_from_xml(
314     name, location="\\", xml_text=None, xml_path=None, user_name="System", password=None
315 ):
316     r"""
317     Create a task based on XML. Source can be a file or a string of XML.
318     Args:
319         name (str):
320             The name of the task. This will be displayed in the task scheduler.
321         location (str):
322             A string value representing the location in which to create the
323             task. Default is ``\`` which is the root for the task scheduler
324             (``C:\Windows\System32\tasks``).
325         xml_text (str):
326             A string of xml representing the task to be created. This will be
327             overridden by ``xml_path`` if passed.
328         xml_path (str):
329             The path to an XML file on the local system containing the xml that
330             defines the task. This will override ``xml_text``
331         user_name (str):
332             The user account under which to run the task. To specify the
333             'System' account, use 'System'. The password will be ignored.
334         password (str):
335             The password to use for authentication. This should set the task to
336             run whether the user is logged in or not, but is currently not
337             working.
338     Returns:
339         bool: ``True`` if successful, otherwise ``False``
340         str: A string with the error message if there is an error
341     Raises:
342         ArgumentValueError: If arguments are invalid
343         CommandExecutionError
344     CLI Example:
345     .. code-block:: bash
346         salt '*' task.create_task_from_xml &lt;task_name&gt; xml_path=C:\task.xml
347     """
348     if name in list_tasks(location):
349         return "{} already exists".format(name)
350     if not xml_text and not xml_path:
351         raise ArgumentValueError("Must specify either xml_text or xml_path")
352     with salt.utils.winapi.Com():
353         task_service = win32com.client.Dispatch("Schedule.Service")
354         task_service.Connect()
355         if xml_path:
356             xml_text = xml_path
357         task_folder = task_service.GetFolder(location)
358         if user_name:
359             if user_name.lower() == "system":
360                 logon_type = TASK_LOGON_SERVICE_ACCOUNT
361                 user_name = "SYSTEM"
362                 password = None
363             else:
364                 if password:
365                     logon_type = TASK_LOGON_PASSWORD
366                 else:
367                     logon_type = TASK_LOGON_INTERACTIVE_TOKEN
368         else:
369             password = None
370             logon_type = TASK_LOGON_NONE
371         try:
372             task_folder.RegisterTask(
373                 name, xml_text, TASK_CREATE, user_name, password, logon_type
374             )
375         except pythoncom.com_error as error:
376             hr, msg, exc, arg = error.args  # pylint: disable=W0633
377             error_code = hex(exc[5] + 2 ** 32)
378             fc = {
379                 0x80041319: "Required element or attribute missing",
380                 0x80041318: "Value incorrectly formatted or out of range",
381                 0x80020005: "Access denied",
382                 0x80041309: "A task's trigger is not found",
383                 0x8004130A: (
384                     "One or more of the properties required to run this "
385                     "task have not been set"
386                 ),
387                 0x8004130C: (
388                     "The Task Scheduler service is not installed on this computer"
389                 ),
390                 0x8004130D: "The task object could not be opened",
391                 0x8004130E: (
392                     "The object is either an invalid task object or is not "
393                     "a task object"
394                 ),
395                 0x8004130F: (
396                     "No account information could be found in the Task "
397                     "Scheduler security database for the task indicated"
398                 ),
399                 0x80041310: "Unable to establish existence of the account specified",
400                 0x80041311: (
401                     "Corruption was detected in the Task Scheduler "
402                     "security database; the database has been reset"
403                 ),
404                 0x80041313: "The task object version is either unsupported or invalid",
405                 0x80041314: (
406                     "The task has been configured with an unsupported "
407                     "combination of account settings and run time options"
408                 ),
409                 0x80041315: "The Task Scheduler Service is not running",
410                 0x80041316: "The task XML contains an unexpected node",
411                 0x80041317: (
412                     "The task XML contains an element or attribute from an "
413                     "unexpected namespace"
414                 ),
415                 0x8004131A: "The task XML is malformed",
416                 0x0004131C: (
417                     "The task is registered, but may fail to start. Batch "
418                     "logon privilege needs to be enabled for the task principal"
419                 ),
420                 0x8004131D: "The task XML contains too many nodes of the same type",
421             }
422             try:
423                 failure_code = fc[error_code]
424             except KeyError:
425                 failure_code = "Unknown Failure: {}".format(error_code)
426             finally:
427                 log.debug("Failed to create task: %s", failure_code)
428             raise CommandExecutionError(failure_code)
429     return name in list_tasks(location)
430 def create_folder(name, location="\\"):
431     r"""
432     Create a folder in which to create tasks.
433     Args:
434         name (str):
435             The name of the folder. This will be displayed in the task
436             scheduler.
437         location (str):
438             A string value representing the location in which to create the
439             folder. Default is ``\`` which is the root for the task scheduler
440             (``C:\Windows\System32\tasks``).
441     Returns:
442         bool: ``True`` if successful, otherwise ``False``
443     CLI Example:
444     .. code-block:: bash
445         salt 'minion-id' task.create_folder &lt;folder_name&gt;
446     """
447     if name in list_folders(location):
448         return "{} already exists".format(name)
449     with salt.utils.winapi.Com():
450         task_service = win32com.client.Dispatch("Schedule.Service")
451         task_service.Connect()
452         task_folder = task_service.GetFolder(location)
453     return name in list_folders(<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>location)
454 def edit_task(
455     name=None,
456     location="\\",
457     user_name=None,
458     password=None,
459     description=None,
460     enabled=None,
461     hidden=None,
462     run_if_idle=None,
463     idle_duration=None,
464     idle_wait_timeout=None,
465     idle_stop_on_end=None,
466     idle_restart=None,
467     ac_only=None,
468     stop_if_on_batteries=None,
469     wake_to_run=None,
470     run_if_network=None,
471     network_id=None,
472     network_name=</b></font>None,
473     allow_demand_start=None,
474     start_when_available=None,
475     restart_every=None,
476     restart_count=3,
477     execution_time_limit=None,
478     force_stop=None,
479     delete_after=None,
480     multiple_instances=None,
481     **kwargs
482 ):
483     r"""
484     Edit the parameters of a task. Triggers and Actions cannot be edited yet.
485     Args:
486         name (str):
487             The name of the task. This will be displayed in the task scheduler.
488         location (str):
489             A string value representing the location in which to create the
490             task. Default is ``\`` which is the root for the task scheduler
491             (``C:\Windows\System32\tasks``).
492         user_name (str):
493             The user account under which to run the task. To specify the
494             'System' account, use 'System'. The password will be ignored.
495         password (str):
496             The password to use for authentication. This should set the task to
497             run whether the user is logged in or not, but is currently not
498             working.
499             .. note::
500                 The combination of user_name and password determine how the
501                 task runs. For example, if a username is passed without at
502                 password the task will only run when the user is logged in. If a
503                 password is passed as well the task will run whether the user is
504                 logged on or not. If you pass 'System' as the username the task
505                 will run as the system account (the password parameter is
506                 ignored).
507         description (str):
508             A string representing the text that will be displayed in the
509             description field in the task scheduler.
510         enabled (bool):
511             A boolean value representing whether or not the task is enabled.
512         hidden (bool):
513             A boolean value representing whether or not the task is hidden.
514         run_if_idle (bool):
515             Boolean value that indicates that the Task Scheduler will run the
516             task only if the computer is in an idle state.
517         idle_duration (str):
518             A value that indicates the amount of time that the computer must be
519             in an idle state before the task is run. Valid values are:
520                 - 1 minute
521                 - 5 minutes
522                 - 10 minutes
523                 - 15 minutes
524                 - 30 minutes
525                 - 1 hour
526         idle_wait_timeout (str):
527             A value that indicates the amount of time that the Task Scheduler
528             will wait for an idle condition to occur. Valid values are:
529                 - Do not wait
530                 - 1 minute
531                 - 5 minutes
532                 - 10 minutes
533                 - 15 minutes
534                 - 30 minutes
535                 - 1 hour
536                 - 2 hours
537         idle_stop_on_end (bool):
538             Boolean value that indicates that the Task Scheduler will terminate
539             the task if the idle condition ends before the task is completed.
540         idle_restart (bool):
541             Boolean value that indicates whether the task is restarted when the
542             computer cycles into an idle condition more than once.
543         ac_only (bool):
544             Boolean value that indicates that the Task Scheduler will launch the
545             task only while on AC power.
546         stop_if_on_batteries (bool):
547             Boolean value that indicates that the task will be stopped if the
548             computer begins to run on battery power.
549         wake_to_run (bool):
550             Boolean value that indicates that the Task Scheduler will wake the
551             computer when it is time to run the task.
552         run_if_network (bool):
553             Boolean value that indicates that the Task Scheduler will run the
554             task only when a network is available.
555         network_id (guid):
556             GUID value that identifies a network profile.
557         network_name (str):
558             Sets the name of a network profile. The name is used for display
559             purposes.
560         allow_demand_start (bool):
561             Boolean value that indicates that the task can be started by using
562             either the Run command or the Context menu.
563         start_when_available (bool):
564             Boolean value that indicates that the Task Scheduler can start the
565             task at any time after its scheduled time has passed.
566         restart_every (str):
567             A value that specifies the interval between task restart attempts.
568             Valid values are:
569                 - False (to disable)
570                 - 1 minute
571                 - 5 minutes
572                 - 10 minutes
573                 - 15 minutes
574                 - 30 minutes
575                 - 1 hour
576                 - 2 hours
577         restart_count (int):
578             The number of times the Task Scheduler will attempt to restart the
579             task. Valid values are integers 1 - 999.
580         execution_time_limit (bool, str):
581             The amount of time allowed to complete the task. Valid values are:
582                 - False (to disable)
583                 - 1 hour
584                 - 2 hours
585                 - 4 hours
586                 - 8 hours
587                 - 12 hours
588                 - 1 day
589                 - 3 days
590         force_stop (bool):
591             Boolean value that indicates that the task may be terminated by
592             using TerminateProcess.
593         delete_after (bool, str):
594             The amount of time that the Task Scheduler will wait before deleting
595             the task after it expires. Requires a trigger with an expiration
596             date. Valid values are:
597                 - False (to disable)
598                 - Immediately
599                 - 30 days
600                 - 90 days
601                 - 180 days
602                 - 365 days
603         multiple_instances (str):
604             Sets the policy that defines how the Task Scheduler deals with
605             multiple instances of the task. Valid values are:
606                 - Parallel
607                 - Queue
608                 - No New Instance
609                 - Stop Existing
610     Returns:
611         bool: ``True`` if successful, otherwise ``False``
612     CLI Example:
613     .. code-block:: bash
614         salt '*' task.edit_task &lt;task_name&gt; description='This task is awesome'
615     """
616     with salt.utils.winapi.Com():
617         save_definition = False
618         if kwargs.get("task_definition", False):
619             task_definition = kwargs.get("task_definition")
620         else:
621             save_definition = True
622             if not name:
623                 return 'Required parameter "name" not passed'
624             if name in list_tasks(location):
625                 task_service = win32com.client.Dispatch("Schedule.Service")
626                 task_service.Connect()
627                 task_folder = task_service.GetFolder(location)
628                 task_definition = task_folder.GetTask(name).Definition
629             else:
630                 return "{} not found".format(name)
631         if save_definition:
632             task_definition.RegistrationInfo.Author = "Salt Minion"
633             task_definition.RegistrationInfo.Source = "Salt Minion Daemon"
634         if description is not None:
635             task_definition.RegistrationInfo.Description = description
636         if user_name:
637             if user_name.lower() == "system":
638                 logon_type = TASK_LOGON_SERVICE_ACCOUNT
639                 user_name = "SYSTEM"
640                 password = None
641             else:
642                 task_definition.Principal.Id = user_name
643                 if password:
644                     logon_type = TASK_LOGON_PASSWORD
645                 else:
646                     logon_type = TASK_LOGON_INTERACTIVE_TOKEN
647             task_definition.Principal.UserID = user_name
648             task_definition.Principal.DisplayName = user_name
649             task_definition.Principal.LogonType = logon_type
650             task_definition.Principal.RunLevel = TASK_RUNLEVEL_HIGHEST
651         else:
652             user_name = None
653             password = None
654         if enabled is not None:
655             task_definition.Settings.Enabled = enabled
656         if hidden is not None:
657             task_definition.Settings.Hidden = hidden
658         if run_if_idle is not None:
659             task_definition.Settings.RunOnlyIfIdle = run_if_idle
660         if task_definition.Settings.RunOnlyIfIdle:
661             if idle_stop_on_end is not None:
662                 task_definition.Settings.IdleSettings.StopOnIdleEnd = idle_stop_on_end
663             if idle_restart is not None:
664                 task_definition.Settings.IdleSettings.RestartOnIdle = idle_restart
665             if idle_duration is not None:
666                 if idle_duration in duration:
667                     task_definition.Settings.IdleSettings.IdleDuration = _lookup_first(
668                         duration, idle_duration
669                     )
670                 else:
671                     return 'Invalid value for "idle_duration"'
672             if idle_wait_timeout is not None:
673                 if idle_wait_timeout in duration:
674                     task_definition.Settings.IdleSettings.WaitTimeout = _lookup_first(
675                         duration, idle_wait_timeout
676                     )
677                 else:
678                     return 'Invalid value for "idle_wait_timeout"'
679         if ac_only is not None:
680             task_definition.Settings.DisallowStartIfOnBatteries = ac_only
681         if stop_if_on_batteries is not None:
682             task_definition.Settings.StopIfGoingOnBatteries = stop_if_on_batteries
683         if wake_to_run is not None:
684             task_definition.Settings.WakeToRun = wake_to_run
685         if run_if_network is not None:
686             task_definition.Settings.RunOnlyIfNetworkAvailable = run_if_network
687         if task_definition.Settings.RunOnlyIfNetworkAvailable:
688             if network_id:
689                 task_definition.Settings.NetworkSettings.Id = network_id
690             if network_name:
691                 task_definition.Settings.NetworkSettings.Name = network_name
692         if allow_demand_start is not None:
693             task_definition.Settings.AllowDemandStart = allow_demand_start
694         if start_when_available is not None:
695             task_definition.Settings.StartWhenAvailable = start_when_available
696         if restart_every is not None:
697             if restart_every is False:
698                 task_definition.Settings.RestartInterval = ""
699             else:
700                 if restart_every in duration:
701                     task_definition.Settings.RestartInterval = _lookup_first(
702                         duration, restart_every
703                     )
704                 else:
705                     return 'Invalid value for "restart_every"'
706         if task_definition.Settings.RestartInterval:
707             if restart_count is not None:
708                 if restart_count in range(1, 999):
709                     task_definition.Settings.RestartCount = restart_count
710                 else:
711                     return '"restart_count" must be a value between 1 and 999'
712         if execution_time_limit is not None:
713             if execution_time_limit is False:
714                 task_definition.Settings.ExecutionTimeLimit = "PT0S"
715             else:
716                 if execution_time_limit in duration:
717                     task_definition.Settings.ExecutionTimeLimit = _lookup_first(
718                         duration, execution_time_limit
719                     )
720                 else:
721                     return 'Invalid value for "execution_time_limit"'
722         if force_stop is not None:
723             task_definition.Settings.AllowHardTerminate = force_stop
724         if delete_after is not None:
725             if delete_after is False:
726                 task_definition.Settings.DeleteExpiredTaskAfter = ""
727             if delete_after in duration:
728                 task_definition.Settings.DeleteExpiredTaskAfter = _lookup_first(
729                     duration, delete_after
730                 )
731             else:
732                 return 'Invalid value for "delete_after"'
733         if multiple_instances is not None:
734             task_definition.Settings.MultipleInstances = instances[multiple_instances]
735         if save_definition:
736             return _save_task_definition(
737                 name=name,
738                 task_folder=task_folder,
739                 task_definition=task_definition,
740                 user_name=user_name,
741                 password=password,
742                 logon_type=task_definition.Principal.LogonType,
743             )
744 def delete_task(name, location="\\"):
745     r"""
746     Delete a task from the task scheduler.
747     Args:
748         name (str):
749             The name of the task to delete.
750         location (str):
751             A string value representing the location of the task. Default is
752             ``\`` which is the root for the task scheduler
753             (``C:\Windows\System32\tasks``).
754     Returns:
755         bool: ``True`` if successful, otherwise ``False``
756     CLI Example:
757     .. code-block:: bash
758         salt 'minion-id' task.delete_task &lt;task_name&gt;
759     """
760     if name not in list_tasks(location):
761         return "{} not found in {}".format(name, location)
762     with salt.utils.winapi.Com():
763         task_service = win32com.client.Dispatch("Schedule.Service")
764         task_service.Connect()
765         task_folder = task_service.GetFolder(location)
766         task_folder.DeleteTask(name, 0)
767     return name not in list_tasks(location)
768 def delete_folder(name, location="\\"):
769     r"""
770     Delete a folder from the task scheduler.
771     Args:
772         name (str):
773             The name of the folder to delete.
774         location (str):
775             A string value representing the location of the folder.  Default is
776             ``\`` which is the root for the task scheduler
777             (``C:\Windows\System32\tasks``).
778     Returns:
779         bool: ``True`` if successful, otherwise ``False``
780     CLI Example:
781     .. code-block:: bash
782         salt 'minion-id' task.delete_folder &lt;folder_name&gt;
783     """
784     if name not in list_folders(location):
785         return "{} not found in {}".format(name, location)
786     with salt.utils.winapi.Com():
787         task_service = win32com.client.Dispatch("Schedule.Service")
788         task_service.Connect()
789         task_folder = task_service.GetFolder(location)
790         task_folder.DeleteFolder(name, 0)
791     return name not in list_folders(location)
792 def run(name, location="\\"):
793     r"""
794     Run a scheduled task manually.
795     Args:
796         name (str):
797             The name of the task to run.
798         location (str):
799             A string value representing the location of the task. Default is
800             ``\`` which is the root for the task scheduler
801             (``C:\Windows\System32\tasks``).
802     Returns:
803         bool: ``True`` if successful, otherwise ``False``
804     CLI Example:
805     .. code-block:: bash
806         salt 'minion-id' task.run &lt;task_name&gt;
807     """
808     if name not in list_tasks(location):
809         return "{} not found in {}".format(name, location)
810     with salt.utils.winapi.Com():
811         task_service = win32com.client.Dispatch("Schedule.Service")
812         task_service.Connect()
813         task_folder = task_service.GetFolder(location)
814         task = task_folder.GetTask(name)
815         try:
816             task.Run("")
817             return True
818         except pythoncom.com_error:
819             return False
820 def run_wait(name, location="\\"):
821     r"""
822     Run a scheduled task and return when the task finishes
823     Args:
824         name (str):
825             The name of the task to run.
826         location (str):
827             A string value representing the location of the task. Default is
828             ``\`` which is the root for the task scheduler
829             (``C:\Windows\System32\tasks``).
830     Returns:
831         bool: ``True`` if successful, otherwise ``False``
832     CLI Example:
833     .. code-block:: bash
834         salt 'minion-id' task.run_wait &lt;task_name&gt;
835     """
836     if name not in list_tasks(location):
837         return "{} not found in {}".format(name, location)
838     with salt.utils.winapi.Com():
839         task_service = win32com.client.Dispatch("Schedule.Service")
840         task_service.Connect()
841         task_folder = task_service.GetFolder(location)
842         task = task_folder.GetTask(name)
843         if task.State == TASK_STATE_RUNNING:
844             return "Task already running"
845         try:
846             task.Run("")
847             time.sleep(1)
848             running = True
849         except pythoncom.com_error:
850             return False
851         while running:
852             running = False
853             try:
854                 running_tasks = task_service.GetRunningTasks(0)
855                 if running_tasks.Count:
856                     for item in running_tasks:
857                         if item.Name == name:
858                             running = True
859             except pythoncom.com_error:
860                 running = False
861     return True
862 def stop(name, location="\\"):
863     r"""
864     Stop a scheduled task.
865     Args:
866         name (str):
867             The name of the task to stop.
868         location (str):
869             A string value representing the location of the task. Default is
870             ``\`` which is the root for the task scheduler
871             (``C:\Windows\System32\tasks``).
872     Returns:
873         bool: ``True`` if successful, otherwise ``False``
874     CLI Example:
875     .. code-block:: bash
876         salt 'minion-id' task.list_stop &lt;task_name&gt;
877     """
878     if name not in list_tasks(location):
879         return "{} not found in {}".format(name, location)
880     with salt.utils.winapi.Com():
881         task_service = win32com.client.Dispatch("Schedule.Service")
882         task_service.Connect()
883         task_folder = task_service.GetFolder(location)
884         task = task_folder.GetTask(name)
885         try:
886             task.Stop(0)
887             return True
888         except pythoncom.com_error:
889             return False
890 def status(name, location="\\"):
891     r"""
892     Determine the status of a task. Is it Running, Queued, Ready, etc.
893     Args:
894         name (str):
895             The name of the task for which to return the status
896         location (str):
897             A string value representing the location of the task. Default is
898             ``\`` which is the root for the task scheduler
899             (``C:\Windows\System32\tasks``).
900     Returns:
901         str: The current status of the task. Will be one of the following:
902             - Unknown
903             - Disabled
904             - Queued
905             - Ready
906             - Running
907     CLI Example:
908     .. code-block:: bash
909         salt 'minion-id' task.list_status &lt;task_name&gt;
910     """
911     if name not in list_tasks(location):
912         return "{} not found in {}".format(name, location)
913     with salt.utils.winapi.Com():
914         task_service = win32com.client.Dispatch("Schedule.Service")
915         task_service.Connect()
916         task_folder = task_service.GetFolder(location)
917         task = task_folder.GetTask(name)
918         return states[task.State]
919 def info(name, location="\\"):
920     r"""
921     Get the details about a task in the task scheduler.
922     Args:
923         name (str):
924             The name of the task for which to return the status
925         location (str):
926             A string value representing the location of the task. Default is
927             ``\`` which is the root for the task scheduler
928             (``C:\Windows\System32\tasks``).
929     Returns:
930         dict: A dictionary containing the task configuration
931     CLI Example:
932     .. code-block:: bash
933         salt 'minion-id' task.info &lt;task_name&gt;
934     """
935     if name not in list_tasks(location):
936         return "{} not found in {}".format(name, location)
937     with salt.utils.winapi.Com():
938         task_service = win32com.client.Dispatch("Schedule.Service")
939         task_service.Connect()
940         task_folder = task_service.GetFolder(location)
941         task = task_folder.GetTask(name)
942         properties = {
943             "enabled": task.Enabled,
944             "last_run": _get_date_value(task.LastRunTime),
945             "last_run_result": results[task.LastTaskResult],
946             "missed_runs": task.NumberOfMissedRuns,
947             "next_run": _get_date_value(task.NextRunTime),
948             "status": states[task.State],
949         }
950         def_set = task.Definition.Settings
951         settings = {
952             "allow_demand_start": def_set.AllowDemandStart,
953             "force_stop": def_set.AllowHardTerminate,
954         }
955         if def_set.DeleteExpiredTaskAfter == "":
956             settings["delete_after"] = False
957         elif def_set.DeleteExpiredTaskAfter == "PT0S":
958             settings["delete_after"] = "Immediately"
959         else:
960             settings["delete_after"] = _reverse_lookup(
961                 duration, def_set.DeleteExpiredTaskAfter
962             )
963         if def_set.ExecutionTimeLimit == "":
964             settings["execution_time_limit"] = False
965         else:
966             settings["execution_time_limit"] = _reverse_lookup(
967                 duration, def_set.ExecutionTimeLimit
968             )
969         settings["multiple_instances"] = _reverse_lookup(
970             instances, def_set.MultipleInstances
971         )
972         if def_set.RestartInterval == "":
973             settings["restart_interval"] = False
974         else:
975             settings["restart_interval"] = _reverse_lookup(
976                 duration, def_set.RestartInterval
977             )
978         if settings["restart_interval"]:
979             settings["restart_count"] = def_set.RestartCount
980         settings["stop_if_on_batteries"] = def_set.StopIfGoingOnBatteries
981         settings["wake_to_run"] = def_set.WakeToRun
982         conditions = {
983             "ac_only": def_set.DisallowStartIfOnBatteries,
984             "run_if_idle": def_set.RunOnlyIfIdle,
985             "run_if_network": def_set.RunOnlyIfNetworkAvailable,
986             "start_when_available": def_set.StartWhenAvailable,
987         }
988         if conditions["run_if_idle"]:
989             idle_set = def_set.IdleSettings
990             conditions["idle_duration"] = idle_set.IdleDuration
991             conditions["idle_restart"] = idle_set.RestartOnIdle
992             conditions["idle_stop_on_end"] = idle_set.StopOnIdleEnd
993             conditions["idle_wait_timeout"] = idle_set.WaitTimeout
994         if conditions["run_if_network"]:
995             net_set = def_set.NetworkSettings
996             conditions["network_id"] = net_set.Id
997             conditions["network_name"] = net_set.Name
998         actions = []
999         for actionObj in task.Definition.Actions:
1000             action = {"action_type": _reverse_lookup(action_types, actionObj.Type)}
1001             if actionObj.Path:
1002                 action["cmd"] = actionObj.Path
1003             if actionObj.Arguments:
1004                 action["arguments"] = actionObj.Arguments
1005             if actionObj.WorkingDirectory:
1006                 action["working_dir"] = actionObj.WorkingDirectory
1007             actions.append(action)
1008         triggers = []
1009         for triggerObj in task.Definition.Triggers:
1010             trigger = {"trigger_type": _reverse_lookup(trigger_types, triggerObj.Type)}
1011             if triggerObj.ExecutionTimeLimit:
1012                 trigger["execution_time_limit"] = _reverse_lookup(
1013                     duration, triggerObj.ExecutionTimeLimit
1014                 )
1015             if triggerObj.StartBoundary:
1016                 start_date, start_time = triggerObj.StartBoundary.split("T", 1)
1017                 trigger["start_date"] = start_date
1018                 trigger["start_time"] = start_time
1019             if triggerObj.EndBoundary:
1020                 end_date, end_time = triggerObj.EndBoundary.split("T", 1)
1021                 trigger["end_date"] = end_date
1022                 trigger["end_time"] = end_time
1023             trigger["enabled"] = triggerObj.Enabled
1024             if hasattr(triggerObj, "RandomDelay"):
1025                 if triggerObj.RandomDelay:
1026                     trigger["random_delay"] = _reverse_lookup(
1027                         duration, triggerObj.RandomDelay
1028                     )
1029                 else:
1030                     trigger["random_delay"] = False
1031             if hasattr(triggerObj, "Delay"):
1032                 if triggerObj.Delay:
1033                     trigger["delay"] = _reverse_lookup(duration, triggerObj.Delay)
1034                 else:
1035                     trigger["delay"] = False
1036             triggers.append(trigger)
1037         properties["settings"] = settings
1038         properties["conditions"] = conditions
1039         properties["actions"] = actions
1040         properties["triggers"] = triggers
1041         ret = properties
1042     return ret
1043 def add_action(name=None, location="\\", action_type="Execute", **kwargs):
1044     r"""
1045     Add an action to a task.
1046     Args:
1047         name (str):
1048             The name of the task to which to add the action.
1049         location (str):
1050             A string value representing the location of the task. Default is
1051             ``\`` which is the root for the task scheduler
1052             (``C:\Windows\System32\tasks``).
1053         action_type (str):
1054             The type of action to add. There are three action types. Each one
1055             requires its own set of Keyword Arguments (kwargs). Valid values
1056             are:
1057                 - Execute
1058                 - Email
1059                 - Message
1060     Required arguments for each action_type:
1061     **Execute**
1062         Execute a command or an executable
1063             cmd (str):
1064                 (required) The command or executable to run.
1065             arguments (str):
1066                 (optional) Arguments to be passed to the command or executable.
1067                 To launch a script the first command will need to be the
1068                 interpreter for the script. For example, to run a vbscript you
1069                 would pass ``cscript.exe`` in the ``cmd`` parameter and pass the
1070                 script in the ``arguments`` parameter as follows:
1071                     - ``cmd='cscript.exe' arguments='c:\scripts\myscript.vbs'``
1072                 Batch files do not need an interpreter and may be passed to the
1073                 cmd parameter directly.
1074             start_in (str):
1075                 (optional) The current working directory for the command.
1076     **Email**
1077         Send and email. Requires ``server``, ``from``, and ``to`` or ``cc``.
1078             from (str): The sender
1079             reply_to (str): Who to reply to
1080             to (str): The recipient
1081             cc (str): The CC recipient
1082             bcc (str): The BCC recipient
1083             subject (str): The subject of the email
1084             body (str): The Message Body of the email
1085             server (str): The server used to send the email
1086             attachments (list):
1087                 A list of attachments. These will be the paths to the files to
1088                 attach. ie: ``attachments="['C:\attachment1.txt',
1089                 'C:\attachment2.txt']"``
1090     **Message**
1091         Display a dialog box. The task must be set to "Run only when user is
1092         logged on" in order for the dialog box to display. Both parameters are
1093         required.
1094             title (str):
1095                 The dialog box title.
1096             message (str):
1097                 The dialog box message body
1098     Returns:
1099         dict: A dictionary containing the task configuration
1100     CLI Example:
1101     .. code-block:: bash
1102         salt 'minion-id' task.add_action &lt;task_name&gt; cmd='del /Q /S C:\\Temp'
1103     """
1104     with salt.utils.winapi.Com():
1105         save_definition = False
1106         if kwargs.get("task_definition", False):
1107             task_definition = kwargs.get("task_definition")
1108         else:
1109             save_definition = True
1110             if not name:
1111                 return 'Required parameter "name" not passed'
1112             if name in list_tasks(location):
1113                 task_service = win32com.client.Dispatch("Schedule.Service")
1114                 task_service.Connect()
1115                 task_folder = task_service.GetFolder(location)
1116                 task_definition = task_folder.GetTask(name).Definition
1117             else:
1118                 return "{} not found".format(name)
1119         task_action = task_definition.Actions.Create(action_types[action_type])
1120         if action_types[action_type] == TASK_ACTION_EXEC:
1121             task_action.Id = "Execute_ID1"
1122             if kwargs.get("cmd", False):
1123                 task_action.Path = kwargs.get("cmd")
1124             else:
1125                 return 'Required parameter "cmd" not found'
1126             task_action.Arguments = kwargs.get("arguments", "")
1127             task_action.WorkingDirectory = kwargs.get("start_in", "")
1128         elif action_types[action_type] == TASK_ACTION_SEND_EMAIL:
1129             task_action.Id = "Email_ID1"
1130             if kwargs.get("server", False):
1131                 task_action.Server = kwargs.get("server")
1132             else:
1133                 return 'Required parameter "server" not found'
1134             if kwargs.get("from", False):
1135                 task_action.From = kwargs.get("from")
1136             else:
1137                 return 'Required parameter "from" not found'
1138             if kwargs.get("to", False) or kwargs.get("cc", False):
1139                 if kwargs.get("to"):
1140                     task_action.To = kwargs.get("to")
1141                 if kwargs.get("cc"):
1142                     task_action.Cc = kwargs.get("cc")
1143             else:
1144                 return 'Required parameter "to" or "cc" not found'
1145             if kwargs.get("reply_to"):
1146                 task_action.ReplyTo = kwargs.get("reply_to")
1147             if kwargs.get("bcc"):
1148                 task_action.Bcc = kwargs.get("bcc")
1149             if kwargs.get("subject"):
1150                 task_action.Subject = kwargs.get("subject")
1151             if kwargs.get("body"):
1152                 task_action.Body = kwargs.get("body")
1153             if kwargs.get("attachments"):
1154                 task_action.Attachments = kwargs.get("attachments")
1155         elif action_types[action_type] == TASK_ACTION_SHOW_MESSAGE:
1156             task_action.Id = "Message_ID1"
1157             if kwargs.get("title", False):
1158                 task_action.Title = kwargs.get("title")
1159             else:
1160                 return 'Required parameter "title" not found'
1161             if kwargs.get("message", False):
1162                 task_action.MessageBody = kwargs.get("message")
1163             else:
1164                 return 'Required parameter "message" not found'
1165         if save_definition:
1166             return _save_task_definition(
1167                 name=name,
1168                 task_folder=task_folder,
1169                 task_definition=task_definition,
1170                 user_name=task_definition.Principal.UserID,
1171                 password=None,
1172                 logon_type=task_definition.Principal.LogonType,
1173             )
1174 def _clear_actions(name, location="\\"):
1175     r"""
1176     Remove all actions from the task.
1177     :param str name: The name of the task from which to clear all actions.
1178     :param str location: A string value representing the location of the task.
1179     Default is ``\`` which is the root for the task scheduler
1180     (``C:\Windows\System32\tasks``).
1181     :return: True if successful, False if unsuccessful
1182     :rtype: bool
1183     """
1184             logon_type=task_definition.Principal.L<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ogonType,
1185         )
1186 def add_trigger(
1187     name=None,
1188     location="\\",
1189     trigger_type=None,
1190     trigger_enabled=True,
1191     start_date=None,
1192     start_time=None,
1193     end_date=None,
1194     end_time=None,
1195     random_delay=None,
1196     repeat_interval=None,
1197     repeat_duration=None,
1198     repeat_stop_at_duration_end=False,
1199     execution_time_limit=None,
1200     delay=</b></font>None,
1201     **kwargs
1202 ):
1203     r"""
1204     Add a trigger to a Windows Scheduled task
1205     .. note::
1206         Arguments are parsed by the YAML loader and are subject to
1207         yaml's idiosyncrasies. Therefore, time values in some
1208         formats (``%H:%M:%S`` and ``%H:%M``) should to be quoted.
1209         See `YAML IDIOSYNCRASIES`_ for more details.
1210     .. _`YAML IDIOSYNCRASIES`: https://docs.saltproject.io/en/latest/topics/troubleshooting/yaml_idiosyncrasies.html#time-expressions
1211     Args:
1212         name (str):
1213             The name of the task to which to add the trigger.
1214         location (str):
1215             A string value representing the location of the task. Default is
1216             ``\`` which is the root for the task scheduler
1217             (``C:\Windows\System32\tasks``).
1218         trigger_type (str):
1219             The type of trigger to create. This is defined when the trigger is
1220             created and cannot be changed later. Options are as follows:
1221                 - Event
1222                 - Once
1223                 - Daily
1224                 - Weekly
1225                 - Monthly
1226                 - MonthlyDay
1227                 - OnIdle
1228                 - OnTaskCreation
1229                 - OnBoot
1230                 - OnLogon
1231                 - OnSessionChange
1232         trigger_enabled (bool):
1233             Boolean value that indicates whether the trigger is enabled.
1234         start_date (str):
1235             The date when the trigger is activated. If no value is passed, the
1236             current date will be used. Can be one of the following formats:
1237                 - %Y-%m-%d
1238                 - %m-%d-%y
1239                 - %m-%d-%Y
1240                 - %m/%d/%y
1241                 - %m/%d/%Y
1242                 - %Y/%m/%d
1243         start_time (str):
1244             The time when the trigger is activated. If no value is passed,
1245             midnight will be used. Can be one of the following formats:
1246                 - %I:%M:%S %p
1247                 - %I:%M %p
1248                 - %H:%M:%S
1249                 - %H:%M
1250         end_date (str):
1251             The date when the trigger is deactivated. The trigger cannot start
1252             the task after it is deactivated. Can be one of the following
1253             formats:
1254                 - %Y-%m-%d
1255                 - %m-%d-%y
1256                 - %m-%d-%Y
1257                 - %m/%d/%y
1258                 - %m/%d/%Y
1259                 - %Y/%m/%d
1260         end_time (str):
1261             The time when the trigger is deactivated. If this is not passed
1262             with ``end_date`` it will be set to midnight. Can be one of the
1263             following formats:
1264                 - %I:%M:%S %p
1265                 - %I:%M %p
1266                 - %H:%M:%S
1267                 - %H:%M
1268         random_delay (str):
1269             The delay time that is randomly added to the start time of the
1270             trigger. Valid values are:
1271                 - 30 seconds
1272                 - 1 minute
1273                 - 30 minutes
1274                 - 1 hour
1275                 - 8 hours
1276                 - 1 day
1277             .. note::
1278                 This parameter applies to the following trigger types
1279                     - Once
1280                     - Daily
1281                     - Weekly
1282                     - Monthly
1283                     - MonthlyDay
1284         repeat_interval (str):
1285             The amount of time between each restart of the task. Valid values
1286             are:
1287                 - 5 minutes
1288                 - 10 minutes
1289                 - 15 minutes
1290                 - 30 minutes
1291                 - 1 hour
1292         repeat_duration (str):
1293             How long the pattern is repeated. Valid values are:
1294                 - Indefinitely
1295                 - 15 minutes
1296                 - 30 minutes
1297                 - 1 hour
1298                 - 12 hours
1299                 - 1 day
1300         repeat_stop_at_duration_end (bool):
1301             Boolean value that indicates if a running instance of the task is
1302             stopped at the end of the repetition pattern duration.
1303         execution_time_limit (str):
1304             The maximum amount of time that the task launched by the trigger is
1305             allowed to run. Valid values are:
1306                 - 30 minutes
1307                 - 1 hour
1308                 - 2 hours
1309                 - 4 hours
1310                 - 8 hours
1311                 - 12 hours
1312                 - 1 day
1313                 - 3 days (default)
1314         delay (str):
1315             The time the trigger waits after its activation to start the task.
1316             Valid values are:
1317                 - 15 seconds
1318                 - 30 seconds
1319                 - 1 minute
1320                 - 30 minutes
1321                 - 1 hour
1322                 - 8 hours
1323                 - 1 day
1324             .. note::
1325                 This parameter applies to the following trigger types:
1326                     - OnLogon
1327                     - OnBoot
1328                     - Event
1329                     - OnTaskCreation
1330                     - OnSessionChange
1331     **kwargs**
1332     There are optional keyword arguments determined by the type of trigger
1333     being defined. They are as follows:
1334     *Event*
1335         The trigger will be fired by an event.
1336             subscription (str):
1337                 An event definition in xml format that fires the trigger. The
1338                 easiest way to get this would is to create an event in Windows
1339                 Task Scheduler and then copy the xml text.
1340     *Once*
1341         No special parameters required.
1342     *Daily*
1343         The task will run daily.
1344             days_interval (int):
1345                 The interval between days in the schedule. An interval of 1
1346                 produces a daily schedule. An interval of 2 produces an
1347                 every-other day schedule. If no interval is specified, 1 is
1348                 used. Valid entries are 1 - 999.
1349     *Weekly*
1350         The task will run weekly.
1351             weeks_interval (int):
1352                 The interval between weeks in the schedule. An interval of 1
1353                 produces a weekly schedule. An interval of 2 produces an
1354                 every-other week schedule. If no interval is specified, 1 is
1355                 used. Valid entries are 1 - 52.
1356             days_of_week (list):
1357                 Sets the days of the week on which the task runs. Should be a
1358                 list. ie: ``['Monday','Wednesday','Friday']``. Valid entries are
1359                 the names of the days of the week.
1360     *Monthly*
1361         The task will run monthly.
1362             months_of_year (list):
1363                 Sets the months of the year during which the task runs. Should
1364                 be a list. ie: ``['January','July']``. Valid entries are the
1365                 full names of all the months.
1366             days_of_month (list):
1367                 Sets the days of the month during which the task runs. Should be
1368                 a list. ie: ``[1, 15, 'Last']``. Options are all days of the
1369                 month 1 - 31 and the word 'Last' to indicate the last day of the
1370                 month.
1371             last_day_of_month (bool):
1372                 Boolean value that indicates that the task runs on the last day
1373                 of the month regardless of the actual date of that day.
1374                 .. note::
1375                     You can set the task to run on the last day of the month by
1376                     either including the word 'Last' in the list of days, or
1377                     setting the parameter 'last_day_of_month' equal to ``True``.
1378     *MonthlyDay*
1379         The task will run monthly on the specified day.
1380             months_of_year (list):
1381                 Sets the months of the year during which the task runs. Should
1382                 be a list. ie: ``['January','July']``. Valid entries are the
1383                 full names of all the months.
1384             weeks_of_month (list):
1385                 Sets the weeks of the month during which the task runs. Should
1386                 be a list. ie: ``['First','Third']``. Valid options are:
1387                     - First
1388                     - Second
1389                     - Third
1390                     - Fourth
1391             last_week_of_month (bool):
1392                 Boolean value that indicates that the task runs on the last week
1393                 of the month.
1394             days_of_week (list):
1395                 Sets the days of the week during which the task runs. Should be
1396                 a list. ie: ``['Monday','Wednesday','Friday']``.  Valid entries
1397                 are the names of the days of the week.
1398     *OnIdle*
1399         No special parameters required.
1400     *OnTaskCreation*
1401         No special parameters required.
1402     *OnBoot*
1403         No special parameters required.
1404     *OnLogon*
1405         No special parameters required.
1406     *OnSessionChange*
1407         The task will be triggered by a session change.
1408             session_user_name (str):
1409                 Sets the user for the Terminal Server session. When a session
1410                 state change is detected for this user, a task is started. To
1411                 detect session status change for any user, do not pass this
1412                 parameter.
1413             state_change (str):
1414                 Sets the kind of Terminal Server session change that would
1415                 trigger a task launch. Valid options are:
1416                     - ConsoleConnect: When you connect to a user session (switch
1417                       users)
1418                     - ConsoleDisconnect: When you disconnect a user session
1419                       (switch users)
1420                     - RemoteConnect: When a user connects via Remote Desktop
1421                     - RemoteDisconnect: When a user disconnects via Remote
1422                       Desktop
1423                     - SessionLock: When the workstation is locked
1424                     - SessionUnlock: When the workstation is unlocked
1425     Returns:
1426         bool: ``True`` if successful, otherwise ``False``
1427     CLI Example:
1428     .. code-block:: bash
1429         salt 'minion-id' task.add_trigger &lt;task_name&gt; trigger_type=Once trigger_enabled=True start_date=2016/12/1 start_time='"12:01"'
1430     """
1431     if not trigger_type:
1432         return 'Required parameter "trigger_type" not specified'
1433     state_changes = {
1434         "ConsoleConnect": 1,
1435         "ConsoleDisconnect": 2,
1436         "RemoteConnect": 3,
1437         "RemoteDisconnect": 4,
1438         "SessionLock": 7,
1439         "SessionUnlock": 8,
1440     }
1441     days = {
1442         1: 0x1,
1443         2: 0x2,
1444         3: 0x4,
1445         4: 0x8,
1446         5: 0x10,
1447         6: 0x20,
1448         7: 0x40,
1449         8: 0x80,
1450         9: 0x100,
1451         10: 0x200,
1452         11: 0x400,
1453         12: 0x800,
1454         13: 0x1000,
1455         14: 0x2000,
1456         15: 0x4000,
1457         16: 0x8000,
1458         17: 0x10000,
1459         18: 0x20000,
1460         19: 0x40000,
1461         20: 0x80000,
1462         21: 0x100000,
1463         22: 0x200000,
1464         23: 0x400000,
1465         24: 0x800000,
1466         25: 0x1000000,
1467         26: 0x2000000,
1468         27: 0x4000000,
1469         28: 0x8000000,
1470         29: 0x10000000,
1471         30: 0x20000000,
1472         31: 0x40000000,
1473         "Last": 0x80000000,
1474     }
1475     weekdays = {
1476         "Sunday": 0x1,
1477         "Monday": 0x2,
1478         "Tuesday": 0x4,
1479         "Wednesday": 0x8,
1480         "Thursday": 0x10,
1481         "Friday": 0x20,
1482         "Saturday": 0x40,
1483     }
1484     weeks = {"First": 0x1, "Second": 0x2, "Third": 0x4, "Fourth": 0x8}
1485     months = {
1486         "January": 0x1,
1487         "February": 0x2,
1488         "March": 0x4,
1489         "April": 0x8,
1490         "May": 0x10,
1491         "June": 0x20,
1492         "July": 0x40,
1493         "August": 0x80,
1494         "September": 0x100,
1495         "October": 0x200,
1496         "November": 0x400,
1497         "December": 0x800,
1498     }
1499     if start_date:
1500         date_format = _get_date_time_format(start_date)
1501         if date_format:
1502             dt_obj = datetime.strptime(start_date, date_format)
1503         else:
1504             return "Invalid start_date"
1505     else:
1506         dt_obj = datetime.now()
1507     if start_time:
1508         time_format = _get_date_time_format(start_time)
1509         if time_format:
1510             tm_obj = datetime.strptime(start_time, time_format)
1511         else:
1512             return "Invalid start_time"
1513     else:
1514         tm_obj = datetime.strptime("00:00:00", "%H:%M:%S")
1515     start_boundary = "{}T{}".format(
1516         dt_obj.strftime("%Y-%m-%d"), tm_obj.strftime("%H:%M:%S")
1517     )
1518     dt_obj = None
1519     if end_date:
1520         date_format = _get_date_time_format(end_date)
1521         if date_format:
1522             dt_obj = datetime.strptime(end_date, date_format)
1523         else:
1524             return "Invalid end_date"
1525     if end_time:
1526         time_format = _get_date_time_format(end_time)
1527         if time_format:
1528             tm_obj = datetime.strptime(end_time, time_format)
1529         else:
1530             return "Invalid end_time"
1531     else:
1532         tm_obj = datetime.strptime("00:00:00", "%H:%M:%S")
1533     end_boundary = None
1534     if dt_obj and tm_obj:
1535         end_boundary = "{}T{}".format(
1536             dt_obj.strftime("%Y-%m-%d"), tm_obj.strftime("%H:%M:%S")
1537         )
1538     with salt.utils.winapi.Com():
1539         save_definition = False
1540         if kwargs.get("task_definition", False):
1541             task_definition = kwargs.get("task_definition")
1542         else:
1543             save_definition = True
1544             if not name:
1545                 return 'Required parameter "name" not passed'
1546             if name in list_tasks(location):
1547                 task_service = win32com.client.Dispatch("Schedule.Service")
1548                 task_service.Connect()
1549                 task_folder = task_service.GetFolder(location)
1550                 task_definition = task_folder.GetTask(name).Definition
1551             else:
1552                 return "{} not found".format(name)
1553         trigger = task_definition.Triggers.Create(trigger_types[trigger_type])
1554         trigger.StartBoundary = start_boundary
1555         if delay:
1556             trigger.Delay = _lookup_first(duration, delay)
1557         if random_delay:
1558             trigger.RandomDelay = _lookup_first(duration, random_delay)
1559         if repeat_interval:
1560             trigger.Repetition.Interval = _lookup_first(duration, repeat_interval)
1561             if repeat_duration:
1562                 trigger.Repetition.Duration = _lookup_first(duration, repeat_duration)
1563             trigger.Repetition.StopAtDurationEnd = repeat_stop_at_duration_end
1564         if execution_time_limit:
1565             trigger.ExecutionTimeLimit = _lookup_first(duration, execution_time_limit)
1566         if end_boundary:
1567             trigger.EndBoundary = end_boundary
1568         trigger.Enabled = trigger_enabled
1569         if trigger_types[trigger_type] == TASK_TRIGGER_EVENT:
1570             if kwargs.get("subscription", False):
1571                 trigger.Id = "Event_ID1"
1572                 trigger.Subscription = kwargs.get("subscription")
1573             else:
1574                 return 'Required parameter "subscription" not passed'
1575         elif trigger_types[trigger_type] == TASK_TRIGGER_TIME:
1576             trigger.Id = "Once_ID1"
1577         elif trigger_types[trigger_type] == TASK_TRIGGER_DAILY:
1578             trigger.Id = "Daily_ID1"
1579             trigger.DaysInterval = kwargs.get("days_interval", 1)
1580         elif trigger_types[trigger_type] == TASK_TRIGGER_WEEKLY:
1581             trigger.Id = "Weekly_ID1"
1582             trigger.WeeksInterval = kwargs.get("weeks_interval", 1)
1583             if kwargs.get("days_of_week", False):
1584                 bits_days = 0
1585                 for weekday in kwargs.get("days_of_week"):
1586                     bits_days |= weekdays[weekday]
1587                 trigger.DaysOfWeek = bits_days
1588             else:
1589                 return 'Required parameter "days_of_week" not passed'
1590         elif trigger_types[trigger_type] == TASK_TRIGGER_MONTHLY:
1591             trigger.Id = "Monthly_ID1"
1592             if kwargs.get("months_of_year", False):
1593                 bits_months = 0
1594                 for month in kwargs.get("months_of_year"):
1595                     bits_months |= months[month]
1596                 trigger.MonthsOfYear = bits_months
1597             else:
1598                 return 'Required parameter "months_of_year" not passed'
1599             if kwargs.get("days_of_month", False) or kwargs.get(
1600                 "last_day_of_month", False
1601             ):
1602                 if kwargs.get("days_of_month", False):
1603                     bits_days = 0
1604                     for day in kwargs.get("days_of_month"):
1605                         bits_days |= days[day]
1606                     trigger.DaysOfMonth = bits_days
1607                 trigger.RunOnLastDayOfMonth = kwargs.get("last_day_of_month", False)
1608             else:
1609                 return (
1610                     'Monthly trigger requires "days_of_month" or "last_day_of_'
1611                     'month" parameters'
1612                 )
1613         elif trigger_types[trigger_type] == TASK_TRIGGER_MONTHLYDOW:
1614             trigger.Id = "Monthly_DOW_ID1"
1615             if kwargs.get("months_of_year", False):
1616                 bits_months = 0
1617                 for month in kwargs.get("months_of_year"):
1618                     bits_months |= months[month]
1619                 trigger.MonthsOfYear = bits_months
1620             else:
1621                 return 'Required parameter "months_of_year" not passed'
1622             if kwargs.get("weeks_of_month", False) or kwargs.get(
1623                 "last_week_of_month", False
1624             ):
1625                 if kwargs.get("weeks_of_month", False):
1626                     bits_weeks = 0
1627                     for week in kwargs.get("weeks_of_month"):
1628                         bits_weeks |= weeks[week]
1629                     trigger.WeeksOfMonth = bits_weeks
1630                 trigger.RunOnLastWeekOfMonth = kwargs.get("last_week_of_month", False)
1631             else:
1632                 return (
1633                     'Monthly DOW trigger requires "weeks_of_month" or "last_'
1634                     'week_of_month" parameters'
1635                 )
1636             if kwargs.get("days_of_week", False):
1637                 bits_days = 0
1638                 for weekday in kwargs.get("days_of_week"):
1639                     bits_days |= weekdays[weekday]
1640                 trigger.DaysOfWeek = bits_days
1641             else:
1642                 return 'Required parameter "days_of_week" not passed'
1643         elif trigger_types[trigger_type] == TASK_TRIGGER_IDLE:
1644             trigger.Id = "OnIdle_ID1"
1645         elif trigger_types[trigger_type] == TASK_TRIGGER_REGISTRATION:
1646             trigger.Id = "OnTaskCreation_ID1"
1647         elif trigger_types[trigger_type] == TASK_TRIGGER_BOOT:
1648             trigger.Id = "OnBoot_ID1"
1649         elif trigger_types[trigger_type] == TASK_TRIGGER_LOGON:
1650             trigger.Id = "OnLogon_ID1"
1651         elif trigger_types[trigger_type] == TASK_TRIGGER_SESSION_STATE_CHANGE:
1652             trigger.Id = "OnSessionStateChange_ID1"
1653             if kwargs.get("session_user_name", False):
1654                 trigger.UserId = kwargs.get("session_user_name")
1655             if kwargs.get("state_change", False):
1656                 trigger.StateChange = state_changes[kwargs.get("state_change")]
1657             else:
1658                 return 'Required parameter "state_change" not passed'
1659         if save_definition:
1660             return _save_task_definition(
1661                 name=name,
1662                 task_folder=task_folder,
1663                 task_definition=task_definition,
1664                 user_name=task_definition.Principal.UserID,
1665                 password=None,
1666                 logon_type=task_definition.Principal.LogonType,
1667             )
1668 def clear_triggers(name, location="\\"):
1669     r"""
1670     Remove all triggers from the task.
1671     Args:
1672         name (str):
1673             The name of the task from which to clear all triggers.
1674         location (str):
1675             A string value representing the location of the task. Default is
1676             ``\`` which is the root for the task scheduler
1677             (``C:\Windows\System32\tasks``).
1678     Returns:
1679         bool: ``True`` if successful, otherwise ``False``
1680     CLI Example:
1681     .. code-block:: bash
1682         salt 'minion-id' task.clear_trigger &lt;task_name&gt;
1683     """
1684     if name not in list_tasks(location):
1685         return "{} not found in {}".format(name, location)
1686     with salt.utils.winapi.Com():
1687         task_service = win32com.client.Dispatch("Schedule.Service")
1688         task_service.Connect()
1689         task_folder = task_service.GetFolder(location)
1690         task_definition = task_folder.GetTask(name).Definition
1691         triggers = task_definition.Triggers
1692         triggers.Clear()
1693         return _save_task_definition(
1694             name=name,
1695             task_folder=task_folder,
1696             task_definition=task_definition,
1697             user_name=task_definition.Principal.UserID,
1698             password=None,
1699             logon_type=task_definition.Principal.LogonType,
1700         )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
