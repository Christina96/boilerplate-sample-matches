<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_postgres.py &amp; win_reg.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_postgres.py &amp; win_reg.py
      </h3>
<h1 align="center">
        2.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_postgres.py (26.086956%)<th>win_reg.py (1.5564202%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(24-34)<td><a href="#" name="0">(105-116)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_postgres.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import pytest
import salt.modules.postgres as postgres
md5_pw = "md55a231fcdb710d73268c4f44283487ba2"
scram_pw = (
    "SCRAM-SHA-256$4096:wLr5nqC+3F+r7FdQPnB+nA==$"
    "0hn08ZdX8kirGaL4TM0j13digH9Wl365OOzCtAuF2pE=:"
    "LzAh/MGUdjYkdbDzcOKpfGwa3WwPUsyGcY+TEnSpcto="
)
def idfn(val):
    if val == md5_pw:
        return "md5_pw"
    if val == scram_pw:
        return "scram_pw"
<a name="0"></a>@pytest.mark.parametrize(
    "role,password,verifier,method,result",
    [
        <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("username", "password", md5_pw, "md5", True),
        ("another", "password", md5_pw, "md5", False),
        ("username", "another", md5_pw, "md5", False),
        ("username", md5_pw, md5_pw, "md5", True),
        ("username", "md5another", md5_pw, "md5", False),
        ("username", "password", md5_pw, True, True),
        ("another", "password", md5_pw, True, False),
        ("username", "another", md5_pw, True, False),
        ("username", md5_pw, md5_pw, True, True),
        ("username", "md5another", md5_pw, True, False),
        (None</b></font>, "password", scram_pw, "scram-sha-256", True),
        (None, "another", scram_pw, "scram-sha-256", False),
        (None, scram_pw, scram_pw, "scram-sha-256", True),
        (None, "SCRAM-SHA-256$4096:AAAA$AAAA:AAAA", scram_pw, "scram-sha-256", False),
        (None, "SCRAM-SHA-256$foo", scram_pw, "scram-sha-256", False),
        (None, "password", "password", False, True),
        (None, "another", "password", False, False),
        (None, "password", "password", "foo", False),
        ("username", "password", md5_pw, "scram-sha-256", False),
        ("username", "password", scram_pw, "md5", False),
        pytest.param("another", md5_pw, md5_pw, "md5", False, marks=pytest.mark.xfail),
    ],
    ids=idfn,
)
def test_verify_password(role, password, verifier, method, result):
    assert postgres._verify_password(role, password, verifier, method) == result
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>win_reg.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import logging
import sys
import salt.utils.platform
import salt.utils.stringutils
from salt.exceptions import CommandExecutionError
try:
    import win32gui
    import win32api
    import win32con
    HAS_WINDOWS_MODULES = True
except ImportError:
    HAS_WINDOWS_MODULES = False
PY2 = sys.version_info[0] == 2
log = logging.getLogger(__name__)
__virtualname__ = "reg"
def __virtual__():
    if not salt.utils.platform.is_windows():
        return (
            False,
            "reg execution module failed to load: "
            "The module will only run on Windows systems",
        )
    if not HAS_WINDOWS_MODULES:
        return (
            False,
            "reg execution module failed to load: "
            "One of the following libraries did not load: "
            "win32gui, win32con, win32api",
        )
    return __virtualname__
def _to_mbcs(vdata):
    return salt.utils.stringutils.to_unicode(vdata, "mbcs")
def _to_unicode(vdata):
    if vdata is None:
        vdata = ""
    if isinstance(vdata, int):
        vdata = str(vdata)
    return salt.utils.stringutils.to_unicode(vdata, "utf-8")
class Registry:  # pylint: disable=R0903
<a name="0"></a>
    def __init__(self):
        self.hkeys = {
            <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"HKEY_CURRENT_CONFIG": win32con.HKEY_CURRENT_CONFIG,
            "HKEY_CLASSES_ROOT": win32con.HKEY_CLASSES_ROOT,
            "HKEY_CURRENT_USER": win32con.HKEY_CURRENT_USER,
            "HKEY_LOCAL_MACHINE": win32con.HKEY_LOCAL_MACHINE,
            "HKEY_USERS": win32con.HKEY_USERS,
            "HKCC": win32con.HKEY_CURRENT_CONFIG,
            "HKCR": win32con.HKEY_CLASSES_ROOT,
            "HKCU": win32con.HKEY_CURRENT_USER,
            "HKLM": win32con.HKEY_LOCAL_MACHINE,
            "HKU": win32con.HKEY_USERS,
        }
        self.</b></font>vtype = {
            "REG_BINARY": win32con.REG_BINARY,
            "REG_DWORD": win32con.REG_DWORD,
            "REG_EXPAND_SZ": win32con.REG_EXPAND_SZ,
            "REG_MULTI_SZ": win32con.REG_MULTI_SZ,
            "REG_SZ": win32con.REG_SZ,
            "REG_QWORD": win32con.REG_QWORD,
        }
        self.opttype = {"REG_OPTION_NON_VOLATILE": 0, "REG_OPTION_VOLATILE": 1}
        self.vtype_reverse = {
            win32con.REG_BINARY: "REG_BINARY",
            win32con.REG_DWORD: "REG_DWORD",
            win32con.REG_EXPAND_SZ: "REG_EXPAND_SZ",
            win32con.REG_MULTI_SZ: "REG_MULTI_SZ",
            win32con.REG_SZ: "REG_SZ",
            win32con.REG_QWORD: "REG_QWORD",
        }
        self.opttype_reverse = {0: "REG_OPTION_NON_VOLATILE", 1: "REG_OPTION_VOLATILE"}
        self.subkey_slash_check = {
            win32con.HKEY_CURRENT_USER: 0,
            win32con.HKEY_LOCAL_MACHINE: 1,
            win32con.HKEY_USERS: 1,
            win32con.HKEY_CURRENT_CONFIG: 1,
            win32con.HKEY_CLASSES_ROOT: 1,
        }
        self.registry_32 = {
            True: win32con.KEY_READ | win32con.KEY_WOW64_32KEY,
            False: win32con.KEY_READ,
        }
    def __getattr__(self, k):
        try:
            return self.hkeys[k]
        except KeyError:
            msg = "No hkey named '{0}. Try one of {1}'"
            hkeys = ", ".join(self.hkeys)
            raise CommandExecutionError(msg.format(k, hkeys))
def key_exists(hive, key, use_32bit_registry=False):
    local_hive = _to_unicode(hive)
    local_key = _to_unicode(key)
    registry = Registry()
    try:
        hkey = registry.hkeys[local_hive]
    except KeyError:
        raise CommandExecutionError("Invalid Hive: {}".format(local_hive))
    access_mask = registry.registry_32[use_32bit_registry]
    handle = None
    try:
        handle = win32api.RegOpenKeyEx(hkey, local_key, 0, access_mask)
        return True
    except win32api.error as exc:
        if exc.winerror == 2:
            return False
        raise
    finally:
        if handle:
            win32api.RegCloseKey(handle)
def value_exists(hive, key, vname, use_32bit_registry=False):
    local_hive = _to_unicode(hive)
    local_key = _to_unicode(key)
    local_vname = _to_unicode(vname)
    registry = Registry()
    try:
        hkey = registry.hkeys[local_hive]
    except KeyError:
        raise CommandExecutionError("Invalid Hive: {}".format(local_hive))
    access_mask = registry.registry_32[use_32bit_registry]
    try:
        handle = win32api.RegOpenKeyEx(hkey, local_key, 0, access_mask)
    except win32api.error as exc:
        if exc.winerror == 2:
            return False
        raise
    try:
        _, _ = win32api.RegQueryValueEx(handle, local_vname)
        return True
    except win32api.error as exc:
        if exc.winerror == 2 and vname is None:
            return True
        else:
            return False
    finally:
        win32api.RegCloseKey(handle)
def broadcast_change():
    _, res = win32gui.SendMessageTimeout(
        win32con.HWND_BROADCAST,
        win32con.WM_SETTINGCHANGE,
        0,
        0,
        win32con.SMTO_ABORTIFHUNG,
        5000,
    )
    return not bool(res)
def list_keys(hive, key=None, use_32bit_registry=False):
    local_hive = _to_unicode(hive)
    local_key = _to_unicode(key)
    registry = Registry()
    try:
        hkey = registry.hkeys[local_hive]
    except KeyError:
        raise CommandExecutionError("Invalid Hive: {}".format(local_hive))
    access_mask = registry.registry_32[use_32bit_registry]
    subkeys = []
    handle = None
    try:
        handle = win32api.RegOpenKeyEx(hkey, local_key, 0, access_mask)
        for i in range(win32api.RegQueryInfoKey(handle)[0]):
            subkey = win32api.RegEnumKey(handle, i)
            if PY2:
                subkeys.append(_to_mbcs(subkey))
            else:
                subkeys.append(subkey)
    except win32api.error as exc:
        if exc.winerror == 2:
            log.debug(r"Cannot find key: %s\%s", hive, key, exc_info=True)
            return False, r"Cannot find key: {}\{}".format(hive, key)
        raise
    finally:
        if handle:
            handle.Close()
    return subkeys
def list_values(hive, key=None, use_32bit_registry=False):
    local_hive = _to_unicode(hive)
    local_key = _to_unicode(key)
    registry = Registry()
    try:
        hkey = registry.hkeys[local_hive]
    except KeyError:
        raise CommandExecutionError("Invalid Hive: {}".format(local_hive))
    access_mask = registry.registry_32[use_32bit_registry]
    handle = None
    values = list()
    try:
        handle = win32api.RegOpenKeyEx(hkey, local_key, 0, access_mask)
        for i in range(win32api.RegQueryInfoKey(handle)[1]):
            vname, vdata, vtype = win32api.RegEnumValue(handle, i)
            if not vname:
                vname = "(Default)"
            value = {
                "hive": local_hive,
                "key": local_key,
                "vname": _to_mbcs(vname),
                "vtype": registry.vtype_reverse[vtype],
                "success": True,
            }
            if vtype == win32con.REG_MULTI_SZ:
                value["vdata"] = [_to_mbcs(i) for i in vdata]
            elif vtype in [win32con.REG_SZ, win32con.REG_EXPAND_SZ]:
                value["vdata"] = _to_mbcs(vdata)
            else:
                value["vdata"] = vdata
            values.append(value)
    except win32api.error as exc:
        if exc.winerror == 2:
            log.debug(r"Cannot find key: %s\%s", hive, key)
            return False, r"Cannot find key: {}\{}".format(hive, key)
        raise
    finally:
        if handle:
            handle.Close()
    return values
def read_value(hive, key, vname=None, use_32bit_registry=False):
    r"""
    Reads a registry value entry or the default value for a key. To read the
    default value, don't pass ``vname``
    Args:
        hive (str): The name of the hive. Can be one of the following:
            - HKEY_LOCAL_MACHINE or HKLM
            - HKEY_CURRENT_USER or HKCU
            - HKEY_USER or HKU
            - HKEY_CLASSES_ROOT or HKCR
            - HKEY_CURRENT_CONFIG or HKCC
        key (str):
            The key (looks like a path) to the value name.
        vname (str):
            The value name. These are the individual name/data pairs under the
            key. If not passed, the key (Default) value will be returned.
        use_32bit_registry (bool):
            Accesses the 32bit portion of the registry on 64bit installations.
            On 32bit machines this is ignored.
    Returns:
        dict: A dictionary containing the passed settings as well as the
            value_data if successful. If unsuccessful, sets success to False.
        bool: Returns False if the key is not found
        If vname is not passed:
            - Returns the first unnamed value (Default) as a string.
            - Returns none if first unnamed value is empty.
    Usage:
        The following will get the value of the ``version`` value name in the
        ``HKEY_LOCAL_MACHINE\\SOFTWARE\\Salt`` key
        .. code-block:: python
            import salt.utils.win_reg as reg
            reg.read_value(hive='HKLM', key='SOFTWARE\\Salt', vname='version')
    Usage:
        The following will get the default value of the
        ``HKEY_LOCAL_MACHINE\\SOFTWARE\\Salt`` key
        .. code-block:: python
            import salt.utils.win_reg as reg
            reg.read_value(hive='HKLM', key='SOFTWARE\\Salt')
    Sets a value in the registry. If ``vname`` is passed, it will be the value
    for that value name, otherwise it will be the default value for the
    specified key
    Args:
        hive (str):
            The name of the hive. Can be one of the following
                - HKEY_LOCAL_MACHINE or HKLM
                - HKEY_CURRENT_USER or HKCU
                - HKEY_USER or HKU
                - HKEY_CLASSES_ROOT or HKCR
                - HKEY_CURRENT_CONFIG or HKCC
        key (str):
            The key (looks like a path) to the value name.
        vname (str):
            The value name. These are the individual name/data pairs under the
            key. If not passed, the key (Default) value will be set.
        vdata (str, int, list, bytes):
            The value you'd like to set. If a value name (vname) is passed, this
            will be the data for that value name. If not, this will be the
            (Default) value for the key.
            The type of data this parameter expects is determined by the value
            type specified in ``vtype``. The correspondence is as follows:
                - REG_BINARY: Binary data (str in Py2, bytes in Py3)
                - REG_DWORD: int
                - REG_EXPAND_SZ: str
                - REG_MULTI_SZ: list of str
                - REG_QWORD: int
                - REG_SZ: str
                .. note::
                    When setting REG_BINARY, string data will be converted to
                    binary. You can pass base64 encoded using the ``binascii``
                    built-in module. Use ``binascii.b2a_base64('your data')``
            .. note::
                The type for the (Default) value is always REG_SZ and cannot be
                changed.
            .. note::
                This parameter is optional. If not passed, the Key will be
                created with no associated item/value pairs.
        vtype (str):
            The value type. The possible values of the vtype parameter are
            indicated above in the description of the vdata parameter.
        use_32bit_registry (bool):
            Sets the 32bit portion of the registry on 64bit installations. On
            32bit machines this is ignored.
        volatile (bool):
            When this parameter has a value of True, the registry key will be
            made volatile (i.e. it will not persist beyond a system reset or
            shutdown). This parameter only has an effect when a key is being
            created and at no other time.
    Returns:
        bool: True if successful, otherwise False
    Usage:
        This will set the version value to 2015.5.2 in the SOFTWARE\\Salt key in
        the HKEY_LOCAL_MACHINE hive
        .. code-block:: python
            import salt.utils.win_reg
            winreg.set_value(hive='HKLM', key='SOFTWARE\\Salt', vname='version', vdata='2015.5.2')
    Usage:
        This function is strict about the type of vdata. For instance this
        example will fail because vtype has a value of REG_SZ and vdata has a
        type of int (as opposed to str as expected).
        .. code-block:: python
            import salt.utils.win_reg
            winreg.set_value(hive='HKLM', key='SOFTWARE\\Salt', vname='str_data', vdata=1.2)
    Usage:
        In this next example vdata is properly quoted and should succeed.
        .. code-block:: python
            import salt.utils.win_reg
            winreg.set_value(hive='HKLM', key='SOFTWARE\\Salt', vname='str_data', vdata='1.2')
    Usage:
        This is an example of using vtype REG_BINARY. Both ``set_value``
        commands will set the same value ``Salty Test``
        .. code-block:: python
            import salt.utils.win_reg
            winreg.set_value(hive='HKLM', key='SOFTWARE\\Salt', vname='bin_data', vdata='Salty Test', vtype='REG_BINARY')
            import binascii
            bin_data = binascii.b2a_base64('Salty Test')
            winreg.set_value(hive='HKLM', key='SOFTWARE\\Salt', vname='bin_data_encoded', vdata=bin_data, vtype='REG_BINARY')
    Usage:
        An example using vtype REG_MULTI_SZ is as follows:
        .. code-block:: python
            import salt.utils.win_reg
            winreg.set_value(hive='HKLM', key='SOFTWARE\\Salt', vname='list_data', vdata=['Salt', 'is', 'great'], vtype='REG_MULTI_SZ')
    Cast the ``vdata` value to the appropriate data type for the registry type
    specified in ``vtype``
    Args:
        vdata (str, int, list, bytes): The data to cast
        vtype (str):
            The type of data to be written to the registry. Must be one of the
            following:
                - REG_BINARY
                - REG_DWORD
                - REG_EXPAND_SZ
                - REG_MULTI_SZ
                - REG_QWORD
                - REG_SZ
    Returns:
        The vdata cast to the appropriate type. Will be unicode string, binary,
        list of unicode strings, or int
    Usage:
        .. code-block:: python
            import salt.utils.win_reg
            winreg.cast_vdata(vdata='This is the string', vtype='REG_SZ')
    .. versionadded:: 2015.5.4
    Delete a registry key to include all subkeys and value/data pairs.
    Args:
        hive (str):
            The name of the hive. Can be one of the following
                - HKEY_LOCAL_MACHINE or HKLM
                - HKEY_CURRENT_USER or HKCU
                - HKEY_USER or HKU
                - HKEY_CLASSES_ROOT or HKCR
                - HKEY_CURRENT_CONFIG or HKCC
            key (str):
                The key to remove (looks like a path)
            use_32bit_registry (bool):
                Deletes the 32bit portion of the registry on 64bit
                installations. On 32bit machines this is ignored.
    Returns:
        dict: A dictionary listing the keys that deleted successfully as well as
            those that failed to delete.
    Usage:
        The following example will remove ``salt`` and all its subkeys from the
        ``SOFTWARE`` key in ``HKEY_LOCAL_MACHINE``:
        .. code-block:: python
            import salt.utils.win_reg
            winreg.delete_key_recursive(hive='HKLM', key='SOFTWARE\\DeleteMe')
        Enumerate keys
        Traverse the registry tree i.e. dive into the tree
    Delete a registry value entry or the default value for a key.
    Args:
        hive (str):
            The name of the hive. Can be one of the following
                - HKEY_LOCAL_MACHINE or HKLM
                - HKEY_CURRENT_USER or HKCU
                - HKEY_USER or HKU
                - HKEY_CLASSES_ROOT or HKCR
                - HKEY_CURRENT_CONFIG or HKCC
        key (str):
            The key (looks like a path) to the value name.
        vname (str):
            The value name. These are the individual name/data pairs under the
            key. If not passed, the key (Default) value will be deleted.
        use_32bit_registry (bool):
            Deletes the 32bit portion of the registry on 64bit installations. On
            32bit machines this is ignored.
    Return:
        bool: True if successful, otherwise False
    Usage:
        .. code-block:: python
            import salt.utils.win_reg
            winreg.delete_value(hive='HKLM', key='SOFTWARE\\SaltTest', vname='version')
    """
    local_hive = _to_unicode(hive)
    local_key = _to_unicode(key)
    local_vname = _to_unicode(vname)
    registry = Registry()
    try:
        hkey = registry.hkeys[local_hive]
    except KeyError:
        raise CommandExecutionError("Invalid Hive: {}".format(local_hive))
    access_mask = registry.registry_32[use_32bit_registry] | win32con.KEY_ALL_ACCESS
    handle = None
    try:
        handle = win32api.RegOpenKeyEx(hkey, local_key, 0, access_mask)
        win32api.RegDeleteValue(handle, local_vname)
        broadcast_change()
        return True
    except win32api.error as exc:
        if exc.winerror == 2:
            return None
        raise
    finally:
        if handle:
            win32api.RegCloseKey(handle)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
