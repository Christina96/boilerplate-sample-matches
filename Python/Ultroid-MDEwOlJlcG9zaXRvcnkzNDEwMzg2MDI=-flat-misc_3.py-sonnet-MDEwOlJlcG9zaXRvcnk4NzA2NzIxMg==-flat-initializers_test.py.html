
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.308985811875985%, Tokens: 10</h2>
        <div class="column">
            <h3>Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-misc_3.py</h3>
            <pre><code>1  import base64
2  import os
3  import random
4  import re
5  import string
6  from logging import WARNING
7  from random import choice, randrange, shuffle
8  from traceback import format_exc
9  from pyUltroid.exceptions import DependencyMissingError
10  try:
11      from aiohttp import ContentTypeError
12  except ImportError:
13      ContentTypeError = None
14  from telethon.tl import types
15  from telethon.utils import get_display_name, get_peer_id
16  from .. import *
17  from .._misc._wrappers import eor
18  if run_as_module:
19      from ..dB import DEVLIST
20      from ..dB._core import LIST
21  from . import some_random_headers
22  from .helper import async_searcher
23  from .tools import check_filename, json_parser
24  try:
25      import aiohttp
26  except ImportError:
27      aiohttp = None
28  try:
29      from PIL import Image
30  except ImportError:
31      Image = None
32  try:
33      import cv2
34  except ImportError:
35      cv2 = None
36  try:
37      import numpy as np
38  except ImportError:
39      np = None
40  try:
41      from bs4 import BeautifulSoup
42  except ImportError:
43      BeautifulSoup = None
44  async def randomchannel(
45      tochat, channel, range1, range2, caption=None, client=ultroid_bot
46  ):
47      do = randrange(range1, range2)
48      async for x in client.iter_messages(channel, add_offset=do, limit=1):
49          caption = caption or x.text
50          try:
51              await client.send_message(tochat, caption, file=x.media)
52          except BaseException:
53              pass
<span onclick='openModal()' class='match'>54  async def YtDataScraper(url: str):
55      to_return = {}
56      data = json_parser(
57          BeautifulSoup(
58              await async_searcher(url),
59              "html.parser",
60          )
61          .find_all("script")[41]
62          .text[20:-1]
63      )["contents"]
64      _common_data = data["twoColumnWatchNextResults"]["results"]["results"]["contents"]
65      common_data = _common_data[0]["videoPrimaryInfoRenderer"]
66      try:
67          description_data = _common_data[1]["videoSecondaryInfoRenderer"]["description"][
68              "runs"
69          ]
70      except (KeyError, IndexError):
71          description_data = [{"text": "U hurrr from here"}]
72      description = "".join(
73          description_datum["text"] for description_datum in description_data
74      )
75      to_return["title"] = common_data["title"]["runs"][0]["text"]
76      to_return["views"] = (
77          common_data["viewCount"]["videoViewCountRenderer"]["shortViewCount"][
78              "simpleText"
79          ]
80          or common_data["viewCount"]["videoViewCountRenderer"]["viewCount"]["simpleText"]
81      )
82      to_return["publish_date"] = common_data["dateText"]["simpleText"]
83      to_return["likes"] = (
84          common_data["videoActions"]["menuRenderer"]["topLevelButtons"][0][
85              "toggleButtonRenderer"
86          ]["defaultText"]["simpleText"]
87      )
88      to_return["description"] = description
89      return to_return
90  async def google_search(query):
91      query = query.replace(" ", "+")
92      _base = "https://google.com"
93      headers = {
94          "Cache-Control": "no-cache",
95          "Connection": "keep-alive",
96          "User-Agent": choice(some_random_headers),
97      }
98      con = await async_searcher(_base + "/search?q=" + query, headers=headers)
</span>99      soup = BeautifulSoup(con, "html.parser")
100      result = []
101      pdata = soup.find_all("a", href=re.compile("url="))
102      for data in pdata:
103          if not data.find("div"):
104              continue
105          try:
106              result.append(
107                  {
108                      "title": data.find("div").text,
109                      "link": data["href"].split("&url=")[1].split("&ved=")[0],
110                      "description": data.find_all("div")[-1].text,
111                  }
112              )
113          except BaseException as er:
114              LOGS.exception(er)
115      return result
116  async def allcmds(event, telegraph):
117      txt = ""
118      for z in LIST.keys():
119          txt += f"PLUGIN NAME: {z}\n"
120          for zz in LIST[z]:
121              txt += HNDLR + zz + "\n"
122          txt += "\n\n"
123      t = telegraph.create_page(title="Ultroid All Cmds", content=[txt])
124      await eor(event, f"All Ultroid Cmds : [Click Here]({t['url']})", link_preview=False)
125  async def ReTrieveFile(input_file_name):
126      if not aiohttp:
127          raise DependencyMissingError("This function needs 'aiohttp' to be installed.")
128      RMBG_API = udB.get_key("RMBG_API")
129      headers = {"X-API-Key": RMBG_API}
130      files = {"image_file": open(input_file_name, "rb").read()}
131      async with aiohttp.ClientSession() as ses:
132          async with ses.post(
133              "https://api.remove.bg/v1.0/removebg", headers=headers, data=files
134          ) as out:
135              contentType = out.headers.get("content-type")
136              if "image" not in contentType:
137                  return False, (await out.json())
138              name = check_filename("ult-rmbg.png")
139              with open(name, "wb") as file:
140                  file.write(await out.read())
141              return True, name
142  async def unsplashsearch(query, limit=None, shuf=True):
143      query = query.replace(" ", "-")
144      link = "https://unsplash.com/s/photos/" + query
145      extra = await async_searcher(link, re_content=True)
146      res = BeautifulSoup(extra, "html.parser", from_encoding="utf-8")
147      all_ = res.find_all("img", srcset=re.compile("images.unsplash.com/photo"))
148      if shuf:
149          shuffle(all_)
150      return list(map(lambda e: e['src'], all_[:limit]))
151  async def get_random_user_data():
152      base_url = "https://randomuser.me/api/"
153      cc = await async_searcher(
154          "https://random-data-api.com/api/business_credit_card/random_card", re_json=True
155      )
156      card = (
157          "**CARD_ID:** "
158          + str(cc["credit_card_number"])
159          + f" {cc['credit_card_expiry_date']}\n"
160          + f"**C-ID :** {cc['id']}"
161      )
162      data_ = (await async_searcher(base_url, re_json=True))["results"][0]
163      _g = data_["gender"]
164      gender = "ü§µüèª‚Äç‚ôÇ" if _g == "male" else "ü§µüèª‚Äç‚ôÄ"
165      name = data_["name"]
166      loc = data_["location"]
167      dob = data_["dob"]
168      msg = .format(
169          gender,
170          name["title"],
171          name["first"],
172          name["last"],
173          loc["street"]["number"],
174          loc["street"]["name"],
175          loc["city"],
176          loc["state"],
177          loc["country"],
178          loc["postcode"],
179          data_["email"],
180          data_["phone"],
181          card,
182          dob["date"][:10],
183      )
184      pic = data_["picture"]["large"]
185      return msg, pic
186  async def get_synonyms_or_antonyms(word, type_of_words):
187      if type_of_words not in ["synonyms", "antonyms"]:
188          return "Dude! Please give a corrent type of words you want."
189      s = await async_searcher(
190          f"https://tuna.thesaurus.com/pageData/{word}", re_json=True
191      )
192      li_1 = [
193          y
194          for x in [
195              s["data"]["definitionData"]["definitions"][0][type_of_words],
196              s["data"]["definitionData"]["definitions"][1][type_of_words],
197          ]
198          for y in x
199      ]
200      return [y["term"] for y in li_1]
201  class Quotly:
202      _API = "https://bot.lyo.su/quote/generate"
203      _entities = {
204          types.MessageEntityPhone: "phone_number",
205          types.MessageEntityMention: "mention",
206          types.MessageEntityBold: "bold",
207          types.MessageEntityCashtag: "cashtag",
208          types.MessageEntityStrike: "strikethrough",
209          types.MessageEntityHashtag: "hashtag",
210          types.MessageEntityEmail: "email",
211          types.MessageEntityMentionName: "text_mention",
212          types.MessageEntityUnderline: "underline",
213          types.MessageEntityUrl: "url",
214          types.MessageEntityTextUrl: "text_link",
215          types.MessageEntityBotCommand: "bot_command",
216          types.MessageEntityCode: "code",
217          types.MessageEntityPre: "pre",
218          types.MessageEntitySpoiler: "spoiler",
219      }
220      async def _format_quote(self, event, reply=None, sender=None, type_="private"):
221          async def telegraph(file_):
222              file = file_ + ".png"
223              Image.open(file_).save(file, "PNG")
224              files = {"file": open(file, "rb").read()}
225              uri = (
226                  "https://graph.org"
227                  + (
228                      await async_searcher(
229                          "https://graph.org/upload", post=True, data=files, re_json=True
230                      )
231                  )[0]["src"]
232              )
233              os.remove(file)
234              os.remove(file_)
235              return uri
236          if reply and reply.raw_text:
237              reply = {
238                  "name": get_display_name(reply.sender) or "Deleted Account",
239                  "text": reply.raw_text,
240                  "chatId": reply.chat_id,
241              }
242          else:
243              reply = {}
244          is_fwd = event.fwd_from
245          name = None
246          last_name = None
247          if sender and sender.id not in DEVLIST:
248              id_ = get_peer_id(sender)
249          elif not is_fwd:
250              id_ = event.sender_id
251              sender = await event.get_sender()
252          else:
253              id_, sender = None, None
254              name = is_fwd.from_name
255              if is_fwd.from_id:
256                  id_ = get_peer_id(is_fwd.from_id)
257                  try:
258                      sender = await event.client.get_entity(id_)
259                  except ValueError:
260                      pass
261          if sender:
262              name = get_display_name(sender)
263              if hasattr(sender, "last_name"):
264                  last_name = sender.last_name
265          entities = []
266          if event.entities:
267              for entity in event.entities:
268                  if type(entity) in self._entities:
269                      enti_ = entity.to_dict()
270                      del enti_["_"]
271                      enti_["type"] = self._entities[type(entity)]
272                      entities.append(enti_)
273          text = event.raw_text
274          if isinstance(event, types.MessageService):
275              if isinstance(event.action, types.MessageActionGameScore):
276                  text = f"scored {event.action.score}"
277                  rep = await event.get_reply_message()
278                  if rep and rep.game:
279                      text += f" in {rep.game.title}"
280              elif isinstance(event.action, types.MessageActionPinMessage):
281                  text = "pinned a message."
282          message = {
283              "entities": entities,
284              "chatId": id_,
285              "avatar": True,
286              "from": {
287                  "id": id_,
288                  "first_name": (name or (sender.first_name if sender else None))
289                  or "Deleted Account",
290                  "last_name": last_name,
291                  "username": sender.username if sender else None,
292                  "language_code": "en",
293                  "title": name,
294                  "name": name or "Deleted Account",
295                  "type": type_,
296              },
297              "text": text,
298              "replyMessage": reply,
299          }
300          if event.document and event.document.thumbs:
301              file_ = await event.download_media(thumb=-1)
302              uri = await telegraph(file_)
303              message["media"] = {"url": uri}
304          return message
305      async def create_quotly(
306          self,
307          event,
308          url="https://bot.lyo.su/quote/generate",
309          reply={},
310          bg=None,
311          sender=None,
312          file_name="quote.webp",
313      ):
314          if not isinstance(event, list):
315              event = [event]
316          from .. import udB
317          if udB.get_key("OQAPI"):
318              url = Quotly._API
319          if not bg:
320              bg = "#1b1429"
321          content = {
322              "type": "quote",
323              "format": "webp",
324              "backgroundColor": bg,
325              "width": 512,
326              "height": 768,
327              "scale": 2,
328              "messages": [
329                  await self._format_quote(message, reply=reply, sender=sender)
330                  for message in event
331              ],
332          }
333          try:
334              request = await async_searcher(url, post=True, json=content, re_json=True)
335          except ContentTypeError as er:
336              if url != self._API:
337                  return await self.create_quotly(
338                      event,
339                      url=self._API,
340                      bg=bg,
341                      sender=sender,
342                      reply=reply,
343                      file_name=file_name,
344                  )
345              raise er
346          if request.get("ok"):
347              with open(file_name, "wb") as file:
348                  image = base64.decodebytes(request["result"]["image"].encode("utf-8"))
349                  file.write(image)
350              return file_name
351          raise Exception(str(request))
352  def split_list(List, index):
353      new_ = []
354      while List:
355          new_.extend([List[:index]])
356          List = List[index:]
357      return new_
358  def rotate_image(image, angle):
359      if not cv2:
360          raise DependencyMissingError("This function needs 'cv2' to be installed!")
361      image_center = tuple(np.array(image.shape[1::-1]) / 2)
362      rot_mat = cv2.getRotationMatrix2D(image_center, angle, 1.0)
363      return cv2.warpAffine(image, rot_mat, image.shape[1::-1], flags=cv2.INTER_LINEAR)
364  def random_string(length=3):
365      return "".join(random.choices(string.ascii_uppercase, k=length))
366  setattr(random, "random_string", random_string)
</code></pre>
        </div>
        <div class="column">
            <h3>sonnet-MDEwOlJlcG9zaXRvcnk4NzA2NzIxMg==-flat-initializers_test.py</h3>
            <pre><code>1  import itertools
2  from absl.testing import parameterized
3  import numpy as np
4  from sonnet.src import initializers
5  from sonnet.src import test_utils
6  import tensorflow as tf
7  class InitializersTest(test_utils.TestCase, parameterized.TestCase):
8    def assertDifferentInitializerValues(self,
9                                         init,
10                                         shape=None,
11                                         dtype=tf.float32):
12      if shape is None:
13        shape = (100,)
14      t1 = self.evaluate(init(shape, dtype))
15      t2 = self.evaluate(init(shape, dtype))
16      self.assertEqual(t1.shape, shape)
17      self.assertEqual(t2.shape, shape)
18      self.assertFalse(np.allclose(t1, t2, rtol=1e-15, atol=1e-15))
19    def assertRange(self,
20                    init,
21                    shape,
22                    target_mean=None,
23                    target_std=None,
24                    target_max=None,
25                    target_min=None,
26                    dtype=tf.float32):
27      output = self.evaluate(init(shape, dtype))
28      self.assertEqual(output.shape, shape)
29      lim = 4e-2
30      if target_std is not None:
31        self.assertNear(output.std(), target_std, err=lim)
32      if target_mean is not None:
33        self.assertNear(output.mean(), target_mean, err=lim)
34      if target_max is not None:
35        self.assertNear(output.max(), target_max, err=lim)
36      if target_min is not None:
37        self.assertNear(output.min(), target_min, err=lim)
38  class ConstantInitializersTest(InitializersTest):
39    @parameterized.parameters(tf.float32, tf.int32)
40    def testZeros(self, dtype):
41      self.assertRange(
42          initializers.Zeros(),
43          shape=(4, 5),
44          target_mean=0.,
45          target_max=0.,
46          dtype=dtype)
47    @parameterized.parameters(tf.float32, tf.int32)
48    def testOnes(self, dtype):
49      self.assertRange(
50          initializers.Ones(),
51          shape=(4, 5),
52          target_mean=1.,
53          target_max=1.,
54          dtype=dtype)
55    @parameterized.named_parameters(
56        ("Tensor", lambda: tf.constant([1.0, 2.0, 3.0]), "Tensor"),
57        ("Variable", lambda: tf.Variable([3.0, 2.0, 1.0]), "Variable"),
58        ("List", lambda: [], "list"), ("Tuple", lambda: (), "tuple"))
59    def testConstantInvalidValue(self, value, value_type):
60      with self.assertRaisesRegex(
61          TypeError, r"Invalid type for value: .*{}.*".format(value_type)):
62        initializers.Constant(value())
63    @parameterized.parameters((42, tf.float32), (42.0, tf.float32),
64                              (42, tf.int32))
65    def testConstantValidValue(self, value, dtype):
66      self.assertRange(
67          initializers.Constant(value),
68          shape=(4, 5),
69          target_mean=42.,
70          target_max=42.,
71          dtype=dtype)
72    @parameterized.parameters(initializers.Zeros, initializers.Ones)
73    def testInvalidDataType(self, initializer):
74      init = initializer()
75      with self.assertRaisesRegex(
76          ValueError, r"Expected integer or floating point type, got "):
77        init([1], dtype=tf.string)
78    def testInvalidDataTypeConstant(self):
79      init = initializers.Constant(0)
80      with self.assertRaisesRegex(
81          ValueError, r"Expected integer or floating point type, got "):
82        init([1], dtype=tf.string)
83    def testTFFunction(self):
84      init = initializers.Constant(2)
85      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
86      expected = init([7, 4], tf.float32)
87      x = f(tf.zeros([7, 4]))
88      self.assertAllEqual(expected, x)
89    def testBatchAgnostic(self):
90      init = initializers.Constant(2)
91      spec = tf.TensorSpec(shape=[None, None])
92      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
93      f = f.get_concrete_function(spec)
94      expected = init([7, 4], tf.float32)
95      x = f(tf.ones([7, 4]))
96      self.assertAllEqual(expected, x)
97  class RandomUniformInitializerTest(InitializersTest):
98    def testRangeInitializer(self):
99      shape = (16, 8, 128)
100      self.assertRange(
101          initializers.RandomUniform(minval=-1., maxval=1., seed=124.),
102          shape,
103          target_mean=0.,
104          target_max=1,
105          target_min=-1)
106    @parameterized.parameters(tf.float32, tf.int32)
107    def testDifferentInitializer(self, dtype):
108      init = initializers.RandomUniform(0, 10)
109      self.assertDifferentInitializerValues(init, dtype=dtype)
110    def testInvalidDataType(self):
111      init = initializers.RandomUniform()
112      with self.assertRaisesRegex(
113          ValueError, r"Expected integer or floating point type, got "):
114        init([1], dtype=tf.string)
<span onclick='openModal()' class='match'>115    def testTFFunction(self):
116      init = initializers.RandomUniform(seed=42)
117      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
118      expected = init([7, 4], tf.float32)
119      x = f(tf.zeros([7, 4]))
120      self.assertEqual(x.shape, [7, 4])
121      if self.primary_device != "TPU":  # Seeds don't work as expected on TPU
122        self.assertAllEqual(expected, x)
123    def testBatchAgnostic(self):
124      init = initializers.RandomUniform(seed=42)
125      spec = tf.TensorSpec(shape=[None, None])
</span>126      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
127      f = f.get_concrete_function(spec)
128      expected = init([7, 4], tf.float32)
129      x = f(tf.ones([7, 4]))
130      self.assertEqual(x.shape, [7, 4])
131      if self.primary_device != "TPU":  # Seeds don't work as expected on TPU
132        self.assertAllEqual(expected, x)
133  class RandomNormalInitializerTest(InitializersTest):
134    def testRangeInitializer(self):
135      self.assertRange(
136          initializers.RandomNormal(mean=0, stddev=1, seed=153),
137          shape=(16, 8, 128),
138          target_mean=0.,
139          target_std=1)
140    def testDifferentInitializer(self):
141      init = initializers.RandomNormal(0.0, 1.0)
142      self.assertDifferentInitializerValues(init)
143    @parameterized.parameters(tf.int32, tf.string)
144    def testInvalidDataType(self, dtype):
145      init = initializers.RandomNormal(0.0, 1.0)
146      with self.assertRaisesRegex(ValueError,
147                                  r"Expected floating point type, got "):
148        init([1], dtype=dtype)
149    def testTFFunction(self):
150      init = initializers.RandomNormal(seed=42)
151      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
152      expected = init([7, 4], tf.float32)
153      x = f(tf.zeros([7, 4]))
154      self.assertEqual(x.shape, [7, 4])
155      if self.primary_device != "TPU":  # Seeds don't work as expected on TPU
156        self.assertAllEqual(expected, x)
157    def testBatchAgnostic(self):
158      init = initializers.RandomNormal(seed=42)
159      spec = tf.TensorSpec(shape=[None, None])
160      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
161      f = f.get_concrete_function(spec)
162      expected = init([7, 4], tf.float32)
163      x = f(tf.ones([7, 4]))
164      self.assertEqual(x.shape, [7, 4])
165      if self.primary_device != "TPU":  # Seeds don't work as expected on TPU
166        self.assertAllEqual(expected, x)
167  class TruncatedNormalInitializerTest(InitializersTest):
168    def testRangeInitializer(self):
169      self.assertRange(
170          initializers.TruncatedNormal(mean=0, stddev=1, seed=126),
171          shape=(16, 8, 128),
172          target_mean=0.,
173          target_max=2,
174          target_min=-2)
175    def testDifferentInitializer(self):
176      init = initializers.TruncatedNormal(0.0, 1.0)
177      self.assertDifferentInitializerValues(init)
178    @parameterized.parameters(tf.int32, tf.string)
179    def testInvalidDataType(self, dtype):
180      init = initializers.TruncatedNormal(0.0, 1.0)
181      with self.assertRaisesRegex(ValueError,
182                                  r"Expected floating point type, got "):
183        init([1], dtype=dtype)
184    def testTFFunction(self):
185      init = initializers.TruncatedNormal(seed=42)
186      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
187      expected = init([7, 4], tf.float32)
188      x = f(tf.zeros([7, 4]))
189      self.assertEqual(x.shape, [7, 4])
190      if self.primary_device != "TPU":  # Seeds don't work as expected on TPU
191        self.assertAllEqual(expected, x)
192    def testBatchAgnostic(self):
193      init = initializers.TruncatedNormal(seed=42)
194      spec = tf.TensorSpec(shape=[None, None])
195      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
196      f = f.get_concrete_function(spec)
197      expected = init([7, 4], tf.float32)
198      x = f(tf.ones([7, 4]))
199      self.assertEqual(x.shape, [7, 4])
200      if self.primary_device != "TPU":  # Seeds don't work as expected on TPU
201        self.assertAllEqual(expected, x)
202  class IdentityInitializerTest(InitializersTest):
203    @parameterized.parameters(
204        *itertools.product([(4, 5), (3, 3), (3, 4, 5),
205                            (6, 2, 3, 3)], [3, 1], [tf.float32, tf.int32]))
206    def testRange(self, shape, gain, dtype):
207      if self.primary_device == "GPU" and dtype == tf.int32:
208        self.skipTest("tf.int32 not supported on GPU")
209      self.assertRange(
210          initializers.Identity(gain),
211          shape=shape,
212          target_mean=gain / shape[-1],
213          target_max=gain,
214          dtype=dtype)
215    def testInvalidDataType(self):
216      init = initializers.Identity()
217      with self.assertRaisesRegex(
218          ValueError, r"Expected integer or floating point type, got "):
219        init([1, 2], dtype=tf.string)
220    @parameterized.parameters(tf.float32, tf.int32)
221    def testInvalidShape(self, dtype):
222      init = initializers.Identity()
223      with self.assertRaisesRegex(
224          ValueError,
225          "The tensor to initialize must be at least two-dimensional"):
226        init([1], dtype=dtype)
227    def testTFFunction(self):
228      init = initializers.Identity()
229      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
230      expected = init([4, 4], tf.float32)
231      x = f(tf.ones([4, 4]))
232      self.assertAllEqual(expected, x)
233    def testTFFunction4D(self):
234      init = initializers.Identity()
235      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
236      expected = init([4, 4, 3, 2], tf.float32)
237      x = f(tf.ones([4, 4, 3, 2]))
238      self.assertAllEqual(expected, x)
239    def testBatchAgnostic(self):
240      init = initializers.Identity()
241      spec = tf.TensorSpec(shape=[None, None])
242      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
243      f = f.get_concrete_function(spec)
244      expected = init([7, 4], tf.float32)
245      x = f(tf.ones([7, 4]))
246      self.assertAllEqual(expected, x)
247  class OrthogonalInitializerTest(InitializersTest):
248    def testRangeInitializer(self):
249      self.assertRange(
250          initializers.Orthogonal(seed=123), shape=(20, 20), target_mean=0.)
251    def testDuplicatedInitializer(self):
252      init = initializers.Orthogonal()
253      self.assertDifferentInitializerValues(init, (10, 10))
254    @parameterized.parameters(tf.int32, tf.string)
255    def testInvalidDataType(self, dtype):
256      init = initializers.Orthogonal()
257      with self.assertRaisesRegex(ValueError,
258                                  r"Expected floating point type, got "):
259        init([1, 2], dtype=dtype)
260    def testInvalidShape(self):
261      init = initializers.Orthogonal()
262      with self.assertRaisesRegex(
263          ValueError,
264          "The tensor to initialize must be at least two-dimensional"):
265        init([1], tf.float32)
266    @parameterized.named_parameters(
267        ("Square", (10, 10)), ("3DSquare", (100, 5, 5)),
268        ("3DRectangle", (10, 9, 8)), ("TallRectangle", (50, 40)),
269        ("WideRectangle", (40, 50)))
270    def testShapesValues(self, shape):
271      init = initializers.Orthogonal()
272      tol = 1e-5
273      t = self.evaluate(init(shape, tf.float32))
274      self.assertAllEqual(tuple(shape), t.shape)
275      t = t.reshape((np.prod(t.shape[:-1]), t.shape[-1]))
276      if t.shape[0] > t.shape[1]:
277        self.assertAllClose(
278            np.dot(t.T, t), np.eye(t.shape[1]), rtol=tol, atol=tol)
279      else:
280        self.assertAllClose(
281            np.dot(t, t.T), np.eye(t.shape[0]), rtol=tol, atol=tol)
282    def testTFFunctionSimple(self):
283      init = initializers.Orthogonal(seed=42)
284      f = tf.function(init)
285      x = f([4, 4], tf.float32)
286      self.assertAllEqual(x.shape, [4, 4])
287    def testTFFunction(self):
288      if self.primary_device == "TPU":
289        self.skipTest("Dynamic slice not supported on TPU")
290      init = initializers.Orthogonal(seed=42)
291      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
292      expected = init([4, 4], tf.float32)
293      x = f(tf.ones([4, 4]))
294      self.assertAllEqual(expected, x)
295    def testBatchAgnostic(self):
296      if self.primary_device == "TPU":
297        self.skipTest("Dynamic slice not supported on TPU")
298      init = initializers.Orthogonal(seed=42)
299      spec = tf.TensorSpec(shape=[None, None])
300      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
301      f = f.get_concrete_function(spec)
302      expected = init([7, 4], tf.float32)
303      x = f(tf.ones([7, 4]))
304      self.assertAllEqual(expected, x)
305  class VarianceScalingInitializerTest(InitializersTest):
306    def testTruncatedNormalDistribution(self):
307      shape = (100, 100)
308      init = initializers.VarianceScaling(distribution="truncated_normal")
309      self.assertRange(
310          init, shape=shape, target_mean=0., target_std=1. / np.sqrt(shape[0]))
311    def testNormalDistribution(self):
312      shape = (100, 100)
313      init = initializers.VarianceScaling(distribution="normal")
314      self.assertRange(
315          init, shape=shape, target_mean=0., target_std=1. / np.sqrt(shape[0]))
316    def testUniformDistribution(self):
317      shape = (100, 100)
318      init = initializers.VarianceScaling(distribution="uniform")
319      self.assertRange(
320          init, shape=shape, target_mean=0., target_std=1. / np.sqrt(shape[0]))
321    def testGlorotUniform(self):
322      shape = (5, 6, 4, 2)
323      fan_in, fan_out = initializers._compute_fans(shape)
324      std = np.sqrt(2. / (fan_in + fan_out))
325      self.assertRange(
326          initializers.VarianceScaling(
327              scale=1.0, mode="fan_avg", distribution="uniform", seed=123),
328          shape,
329          target_mean=0.,
330          target_std=std)
331    def test_GlorotNormal(self):
332      shape = (5, 6, 4, 2)
333      fan_in, fan_out = initializers._compute_fans(shape)
334      std = np.sqrt(2. / (fan_in + fan_out))
335      self.assertRange(
336          initializers.VarianceScaling(
337              scale=1.0,
338              mode="fan_avg",
339              distribution="truncated_normal",
340              seed=123),
341          shape,
342          target_mean=0.,
343          target_std=std)
344    def testLecunUniform(self):
345      shape = (5, 6, 4, 2)
346      fan_in, _ = initializers._compute_fans(shape)
347      std = np.sqrt(1. / fan_in)
348      self.assertRange(
349          initializers.VarianceScaling(
350              scale=1.0, mode="fan_in", distribution="uniform", seed=123),
351          shape,
352          target_mean=0.,
353          target_std=std)
354    def testLecunNormal(self):
355      shape = (5, 6, 4, 2)
356      fan_in, _ = initializers._compute_fans(shape)
357      std = np.sqrt(1. / fan_in)
358      self.assertRange(
359          initializers.VarianceScaling(
360              scale=1.0, mode="fan_in", distribution="truncated_normal",
361              seed=123),
362          shape,
363          target_mean=0.,
364          target_std=std)
365    def testHeUniform(self):
366      shape = (5, 6, 4, 2)
367      fan_in, _ = initializers._compute_fans(shape)
368      std = np.sqrt(2. / fan_in)
369      self.assertRange(
370          initializers.VarianceScaling(
371              scale=2.0, mode="fan_in", distribution="uniform", seed=123),
372          shape,
373          target_mean=0.,
374          target_std=std)
375    def testHeNormal(self):
376      shape = (5, 6, 4, 2)
377      fan_in, _ = initializers._compute_fans(shape)
378      std = np.sqrt(2. / fan_in)
379      self.assertRange(
380          initializers.VarianceScaling(
381              scale=2.0, mode="fan_in", distribution="truncated_normal",
382              seed=123),
383          shape,
384          target_mean=0.,
385          target_std=std)
386    @parameterized.parameters(
387        itertools.product(["fan_in", "fan_out", "fan_avg"],
388                          ["uniform", "truncated_normal", "normal"]))
389    def testMixedShape(self, mode, distribution):
390      init = initializers.VarianceScaling(mode=mode, distribution=distribution)
391      tf.random.set_seed(42)
392      x = init([tf.constant(4), 2], tf.float32)
393      tf.random.set_seed(42)
394      expected = init([4, 2], tf.float32)
395      self.assertEqual(x.shape, [4, 2])
396      if self.primary_device != "TPU":  # Seeds don't work as expected on TPU
397        self.assertAllEqual(expected, x)
398    @parameterized.parameters(
399        itertools.product(["fan_in", "fan_out", "fan_avg"],
400                          ["uniform", "truncated_normal", "normal"]))
401    def testWithTFFunction(self, mode, distribution):
402      init = initializers.VarianceScaling(
403          mode=mode, distribution=distribution, seed=42)
404      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
405      x = f(tf.zeros([4, 2]))
406      expected = init([4, 2], tf.float32)
407      self.assertEqual(x.shape, [4, 2])
408      if self.primary_device != "TPU":  # Seeds don't work as expected on TPU
409        self.assertAllClose(expected, x)
410    @parameterized.parameters(
411        itertools.product(["fan_in", "fan_out", "fan_avg"],
412                          ["uniform", "truncated_normal", "normal"]))
413    def testBatchAgnostic(self, mode, distribution):
414      init = initializers.VarianceScaling(
415          mode=mode, distribution=distribution, seed=42)
416      spec = tf.TensorSpec(shape=[None, None])
417      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
418      f = f.get_concrete_function(spec)
419      expected = init([7, 4], tf.float32)
420      x = f(tf.ones([7, 4]))
421      self.assertEqual(x.shape, [7, 4])
422      if self.primary_device != "TPU":  # Seeds don't work as expected on TPU
423        self.assertAllClose(expected, x)
424    @parameterized.parameters(tf.int32, tf.string)
425    def testInvalidDataType(self, dtype):
426      init = initializers.VarianceScaling()
427      with self.assertRaisesRegex(ValueError,
428                                  r"Expected floating point type, got "):
429        init([1, 2], dtype=dtype)
430    def testCheckInitializersInvalidType(self):
431      with self.assertRaisesRegex(TypeError,
432                                  "Initializers must be a dict-like object."):
433        initializers.check_initializers([1, 2, 3], ("a"))
434    def testCheckInitalizersEmpty(self):
435      a = initializers.check_initializers(None, ("b"))
436      self.assertEqual(a, {})
437    @parameterized.named_parameters(("Tuple", ("a", "b")), ("List", ["a", "b"]),
438                                    ("Set", {"a", "b"}))
439    def testCheckInitalizersValid(self, keys):
440      initializers.check_initializers({
441          "a": lambda x, y: 0,
442          "b": lambda x, y: 1
443      }, keys)
444    def testCheckInitalizersInvalid(self):
445      with self.assertRaisesRegex(
446          KeyError,
447          r"Invalid initializer keys 'a', initializers can only be provided for"):
448        initializers.check_initializers({
449            "a": lambda x, y: 0,
450            "b": lambda x, y: 1
451        }, ("b"))
452  if __name__ == "__main__":
453    tf.test.main()
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-misc_3.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from sonnet-MDEwOlJlcG9zaXRvcnk4NzA2NzIxMg==-flat-initializers_test.py</div>
                </div>
                <div class="column column_space"><pre><code>54  async def YtDataScraper(url: str):
55      to_return = {}
56      data = json_parser(
57          BeautifulSoup(
58              await async_searcher(url),
59              "html.parser",
60          )
61          .find_all("script")[41]
62          .text[20:-1]
63      )["contents"]
64      _common_data = data["twoColumnWatchNextResults"]["results"]["results"]["contents"]
65      common_data = _common_data[0]["videoPrimaryInfoRenderer"]
66      try:
67          description_data = _common_data[1]["videoSecondaryInfoRenderer"]["description"][
68              "runs"
69          ]
70      except (KeyError, IndexError):
71          description_data = [{"text": "U hurrr from here"}]
72      description = "".join(
73          description_datum["text"] for description_datum in description_data
74      )
75      to_return["title"] = common_data["title"]["runs"][0]["text"]
76      to_return["views"] = (
77          common_data["viewCount"]["videoViewCountRenderer"]["shortViewCount"][
78              "simpleText"
79          ]
80          or common_data["viewCount"]["videoViewCountRenderer"]["viewCount"]["simpleText"]
81      )
82      to_return["publish_date"] = common_data["dateText"]["simpleText"]
83      to_return["likes"] = (
84          common_data["videoActions"]["menuRenderer"]["topLevelButtons"][0][
85              "toggleButtonRenderer"
86          ]["defaultText"]["simpleText"]
87      )
88      to_return["description"] = description
89      return to_return
90  async def google_search(query):
91      query = query.replace(" ", "+")
92      _base = "https://google.com"
93      headers = {
94          "Cache-Control": "no-cache",
95          "Connection": "keep-alive",
96          "User-Agent": choice(some_random_headers),
97      }
98      con = await async_searcher(_base + "/search?q=" + query, headers=headers)
</pre></code></div>
                <div class="column column_space"><pre><code>115    def testTFFunction(self):
116      init = initializers.RandomUniform(seed=42)
117      f = tf.function(lambda t: init(tf.shape(t), t.dtype))
118      expected = init([7, 4], tf.float32)
119      x = f(tf.zeros([7, 4]))
120      self.assertEqual(x.shape, [7, 4])
121      if self.primary_device != "TPU":  # Seeds don't work as expected on TPU
122        self.assertAllEqual(expected, x)
123    def testBatchAgnostic(self):
124      init = initializers.RandomUniform(seed=42)
125      spec = tf.TensorSpec(shape=[None, None])
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    