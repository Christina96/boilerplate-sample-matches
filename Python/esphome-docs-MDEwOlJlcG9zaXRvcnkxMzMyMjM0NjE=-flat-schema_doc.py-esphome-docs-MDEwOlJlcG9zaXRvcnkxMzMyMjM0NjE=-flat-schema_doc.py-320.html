
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 12, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>esphome-docs-MDEwOlJlcG9zaXRvcnkxMzMyMjM0NjE=-flat-schema_doc.py</h3>
            <pre><code>1  from genericpath import exists
2  import re
3  import json
4  import urllib
5  from typing import MutableMapping
6  from sphinx.util import logging
7  from docutils import nodes
8  SCHEMA_PATH = &quot;../esphome-vscode/server/src/schema/&quot;
9  CONFIGURATION_VARIABLES = &quot;Configuration variables:&quot;
10  CONFIGURATION_OPTIONS = &quot;Configuration options:&quot;
11  PIN_CONFIGURATION_VARIABLES = &quot;Pin configuration variables:&quot;
12  COMPONENT_HUB = &quot;Component/Hub&quot;
13  JSON_DUMP_PRETTY = True
14  class Statistics:
15      props_documented = 0
16      enums_good = 0
17      enums_bad = 0
18  statistics = Statistics()
19  logger = logging.getLogger(__name__)
20  def setup(app):
21      import os
22      if not os.path.isfile(SCHEMA_PATH + &quot;esphome.json&quot;):
23          logger.info(f&quot;{SCHEMA_PATH} not found. Not documenting schema.&quot;)
24          return
25      app.connect(&quot;doctree-resolved&quot;, doctree_resolved)
26      app.connect(&quot;build-finished&quot;, build_finished)
27      app.files = {}
28      return {&quot;version&quot;: &quot;1.0.0&quot;, &quot;parallel_read_safe&quot;: True, &quot;parallel_write_safe&quot;: True}
29  def find_platform_component(app, platform, component):
30      file_data = get_component_file(app, component)
31      return file_data[f&quot;{component}.{platform}&quot;][&quot;schemas&quot;][&quot;CONFIG_SCHEMA&quot;]
32  def doctree_resolved(app, doctree, docname):
33      if docname == &quot;components/index&quot;:
34          return
35      handle_component(app, doctree, docname)
36  PLATFORMS_TITLES = {
37      &quot;Sensor&quot;: &quot;sensor&quot;,
38      &quot;Binary Sensor&quot;: &quot;binary_sensor&quot;,
39      &quot;Text Sensor&quot;: &quot;text_sensor&quot;,
40      &quot;Output&quot;: &quot;output&quot;,
41      &quot;Cover&quot;: &quot;cover&quot;,
42      &quot;Button&quot;: &quot;button&quot;,
43      &quot;Select&quot;: &quot;select&quot;,
44      &quot;Fan&quot;: &quot;fan&quot;,
45      &quot;Lock&quot;: &quot;lock&quot;,
46      &quot;Number&quot;: &quot;number&quot;,
47      &quot;Climate&quot;: &quot;climate&quot;,
48      &quot;CAN Bus&quot;: &quot;canbus&quot;,
49      &quot;Stepper&quot;: &quot;stepper&quot;,
50      &quot;Switch&quot;: &quot;switch&quot;,
51      &quot;IÂ²C&quot;: &quot;i2c&quot;,
52      &quot;Media Player&quot;: &quot;media_player&quot;,
53      &quot;Microphone&quot;: &quot;microphone&quot;,
54      &quot;Speaker&quot;: &quot;speaker&quot;,
55      &quot;Alarm Control Panel&quot;: &quot;alarm_control_panel&quot;,
56  }
57  CUSTOM_DOCS = {
58      &quot;guides/automations&quot;: {
59          &quot;Global Variables&quot;: &quot;globals.schemas.CONFIG_SCHEMA&quot;,
60      },
61      &quot;guides/configuration-types&quot;: {
62          &quot;Pin Schema&quot;: [
63              &quot;esp32.pin.schema&quot;,
64              &quot;esp8266.pin.schema&quot;,
65          ],
66      },
67      &quot;components/binary_sensor/index&quot;: {
68          &quot;Binary Sensor Filters&quot;: &quot;binary_sensor.registry.filter&quot;,
69      },
70      &quot;components/canbus&quot;: {
71          &quot;_LoadSchema&quot;: False,
72          &quot;Base CAN Bus Configuration&quot;: &quot;canbus.schemas.CANBUS_SCHEMA&quot;,
73      },
74      &quot;components/climate/climate_ir&quot;: {&quot;_LoadSchema&quot;: False, &quot;IR Remote Climate&quot;: []},
75      &quot;components/display/index&quot;: {
76          &quot;Images&quot;: &quot;image.schemas.CONFIG_SCHEMA&quot;,
77          &quot;Fonts&quot;: &quot;font.schemas.CONFIG_SCHEMA&quot;,
78          &quot;Color&quot;: &quot;color.schemas.CONFIG_SCHEMA&quot;,
79          &quot;Animation&quot;: &quot;animation.schemas.CONFIG_SCHEMA&quot;,
80      },
81      &quot;components/light/index&quot;: {
82          &quot;Base Light Configuration&quot;: [
83              &quot;light.schemas.ADDRESSABLE_LIGHT_SCHEMA&quot;,
84              &quot;light.schemas.BINARY_LIGHT_SCHEMA&quot;,
85              &quot;light.schemas.BRIGHTNESS_ONLY_LIGHT_SCHEMA&quot;,
86              &quot;light.schemas.LIGHT_SCHEMA&quot;,
87          ],
88          &quot;Light Effects&quot;: &quot;light.registry.effects&quot;,
89      },
90      &quot;components/light/fastled&quot;: {
<span onclick='openModal()' class='match'>91          &quot;_LoadSchema&quot;: False,
92          &quot;Clockless&quot;: &quot;fastled_clockless.platform.light.schemas.CONFIG_SCHEMA&quot;,
93          &quot;SPI&quot;: &quot;fastled_spi.platform.light.schemas.CONFIG_SCHEMA&quot;,
94      },
</span>95      &quot;components/binary_sensor/ttp229&quot;: {
96          &quot;_LoadSchema&quot;: False,
97      },
98      &quot;components/mcp230xx&quot;: {
99          &quot;_LoadSchema&quot;: False,
100          PIN_CONFIGURATION_VARIABLES: &quot;mcp23xxx.pin&quot;,
101      },
102      &quot;components/mqtt&quot;: {
103          &quot;MQTT Component Base Configuration&quot;: &quot;core.schemas.MQTT_COMMAND_COMPONENT_SCHEMA&quot;,
104          &quot;MQTTMessage&quot;: &quot;mqtt.schemas.MQTT_MESSAGE_BASE&quot;,
105      },
106      &quot;components/output/index&quot;: {
107          &quot;Base Output Configuration&quot;: &quot;output.schemas.FLOAT_OUTPUT_SCHEMA&quot;,
108      },
109      &quot;components/remote_transmitter&quot;: {
110          &quot;Remote Transmitter Actions&quot;: &quot;remote_base.schemas.BASE_REMOTE_TRANSMITTER_SCHEMA&quot;,
111      },
112      &quot;components/sensor/index&quot;: {
113          &quot;Sensor Filters&quot;: &quot;sensor.registry.filter&quot;,
114      },
115      &quot;components/time&quot;: {
116          &quot;_LoadSchema&quot;: False,
117          &quot;Base Time Configuration&quot;: &quot;time.schemas.TIME_SCHEMA&quot;,
118          &quot;on_time Trigger&quot;: &quot;time.schemas.TIME_SCHEMA.schema.config_vars.on_time.schema&quot;,
119          &quot;Home Assistant Time Source&quot;: &quot;homeassistant.platform.time.schemas.CONFIG_SCHEMA&quot;,
120          &quot;SNTP Time Source&quot;: &quot;sntp.platform.time.schemas.CONFIG_SCHEMA&quot;,
121          &quot;GPS Time Source&quot;: &quot;gps.platform.time.schemas.CONFIG_SCHEMA&quot;,
122          &quot;DS1307 Time Source&quot;: &quot;ds1307.platform.time.schemas.CONFIG_SCHEMA&quot;,
123      },
124      &quot;components/wifi&quot;: {
125          &quot;Connecting to Multiple Networks&quot;: &quot;wifi.schemas.CONFIG_SCHEMA.schema.config_vars.networks.schema&quot;,
126          &quot;Enterprise Authentication&quot;: &quot;wifi.schemas.EAP_AUTH_SCHEMA&quot;,
127      },
128      &quot;custom/custom_component&quot;: {
129          &quot;Generic Custom Component&quot;: &quot;custom_component.schemas.CONFIG_SCHEMA&quot;
130      },
131      &quot;components/esp32&quot;: {
132          &quot;Arduino framework&quot;: &quot;esp32.schemas.CONFIG_SCHEMA.schema.config_vars.framework.types.arduino&quot;,
133          &quot;ESP-IDF framework&quot;: &quot;esp32.schemas.CONFIG_SCHEMA.schema.config_vars.framework.types.esp-idf&quot;,
134      },
135      &quot;components/sensor/airthings_ble&quot;: {
136          &quot;_LoadSchema&quot;: False,
137      },
138      &quot;components/sensor/radon_eye_ble&quot;: {
139          &quot;_LoadSchema&quot;: False,
140      },
141      &quot;components/sensor/xiaomi_ble&quot;: {
142          &quot;_LoadSchema&quot;: False,
143      },
144      &quot;components/sensor/xiaomi_miscale2&quot;: {
145          &quot;_LoadSchema&quot;: False,
146      },
147      &quot;components/mcp23Sxx&quot;: {
148          &quot;_LoadSchema&quot;: False,
149      },
150      &quot;components/display/lcd_display&quot;: {&quot;_LoadSchema&quot;: False},
151      &quot;components/display/ssd1306&quot;: {&quot;_LoadSchema&quot;: False},
152      &quot;components/display/ssd1322&quot;: {&quot;_LoadSchema&quot;: False},
153      &quot;components/display/ssd1325&quot;: {&quot;_LoadSchema&quot;: False},
154      &quot;components/display/ssd1327&quot;: {&quot;_LoadSchema&quot;: False},
155      &quot;components/display/ssd1351&quot;: {&quot;_LoadSchema&quot;: False},
156      &quot;components/copy&quot;: {&quot;_LoadSchema&quot;: False},
157      &quot;components/display_menu/index&quot;: {
158          &quot;Display Menu&quot;: &quot;display_menu_base.schemas.DISPLAY_MENU_BASE_SCHEMA&quot;,
159          &quot;Select&quot;: &quot;display_menu_base.schemas.MENU_TYPES.schema.config_vars.items.types.select&quot;,
160          &quot;Menu&quot;: &quot;display_menu_base.schemas.MENU_TYPES.schema.config_vars.items.types.menu&quot;,
161          &quot;Number&quot;: &quot;display_menu_base.schemas.MENU_TYPES.schema.config_vars.items.types.number&quot;,
162          &quot;Switch&quot;: &quot;display_menu_base.schemas.MENU_TYPES.schema.config_vars.items.types.switch&quot;,
163          &quot;Custom&quot;: &quot;display_menu_base.schemas.MENU_TYPES.schema.config_vars.items.types.custom&quot;,
164      },
165      &quot;components/display_menu/lcd_menu&quot;: {
166          &quot;LCD Menu&quot;: &quot;lcd_menu.schemas.CONFIG_SCHEMA&quot;,
167      },
168      &quot;components/alarm_control_panel/index&quot;: {
169          &quot;Base Alarm Control Panel Configuration&quot;: &quot;template.alarm_control_panel.schemas.CONFIG_SCHEMA&quot;,
170      },
171  }
172  REQUIRED_OPTIONAL_TYPE_REGEX = r&quot;(\(((\*\*Required\*\*)|(\*Optional\*))(,\s(.*))*)\):\s&quot;
173  def get_node_title(node):
174      return list(node.traverse(nodes.title))[0].astext()
175  def read_file(fileName):
176      f = open(SCHEMA_PATH + fileName + &quot;.json&quot;, &quot;r&quot;, encoding=&quot;utf-8-sig&quot;)
177      str = f.read()
178      return json.loads(str)
179  def is_config_vars_title(title_text):
180      return title_text == CONFIGURATION_VARIABLES or title_text == CONFIGURATION_OPTIONS
181  class SchemaGeneratorVisitor(nodes.NodeVisitor):
182      def __init__(self, app, doctree, docname):
183          nodes.NodeVisitor.__init__(self, doctree)
184          self.app = app
185          self.doctree = doctree
186          self.docname = docname
187          self.path = docname.split(&quot;/&quot;)
188          self.json_component = None
189          self.props = None
190          self.platform = None
191          self.json_platform_component = None
192          self.title_id = None
193          self.props_section_title = None
194          self.find_registry = None
195          self.component = None
196          self.section_level = 0
197          self.file_schema = None
198          self.custom_doc = CUSTOM_DOCS.get(docname)
199          if self.path[0] == &quot;components&quot;:
200              if len(self.path) == 2:  # root component, e.g. dfplayer, logger
201                  self.component = docname[11:]
202                  if not self.custom_doc or self.custom_doc.get(&quot;_LoadSchema&quot;, True):
203                      self.file_schema = get_component_file(app, self.component)
204                      self.json_component = self.file_schema[self.component][&quot;schemas&quot;][
205                          &quot;CONFIG_SCHEMA&quot;
206                      ]
207              elif self.path[1] == &quot;display_menu&quot;:  # weird folder naming
208                  if self.path[2] == &quot;index&quot;:
209                      self.component = &quot;display_menu_base&quot;
210                  else:
211                      self.component = self.path[2]
212                      self.file_schema = get_component_file(app, self.component)
213                      self.json_component = self.file_schema[self.component][&quot;schemas&quot;][
214                          &quot;CONFIG_SCHEMA&quot;
215                      ]
216              else:  # sub component, e.g. output/esp8266_pwm
217                  self.platform = self.path[1]
218                  self.component = self.path[2]
219                  if self.component == &quot;ssd1331&quot;:
220                      self.component = &quot;ssd1331_spi&quot;
221                  if not self.custom_doc or self.custom_doc.get(&quot;_LoadSchema&quot;, True):
222                      if self.component == &quot;index&quot;:
223                          self.component = self.platform.replace(&quot; &quot;, &quot;_&quot;).lower()
224                          self.file_schema = get_component_file(app, self.component)
225                          self.json_component = self.file_schema[self.component][
226                              &quot;schemas&quot;
227                          ].get(self.component.upper() + &quot;_SCHEMA&quot;)
228                          pass
229                      else:
230                          self.json_component = get_component_file(app, self.component)
231                          self.json_platform_component = find_platform_component(
232                              app, self.platform, self.component
233                          )
234          self.previous_title_text = &quot;No title&quot;
235          self.is_component_hub = False
236          self.multi_component = None
237          self.prop_stack = []
238          self.current_prop = None
239          self.filled_props = False
240          self.accept_props = False
241          self.bullet_list_level = 0
242      def set_component_description(self, description, componentName, platformName=None):
243          if platformName is not None:
244              platform = get_component_file(self.app, platformName)
245              platform[platformName][&quot;components&quot;][componentName.lower()][
246                  &quot;docs&quot;
247              ] = description
248          else:
249              core = get_component_file(self.app, &quot;esphome&quot;)[&quot;core&quot;]
250              if componentName in core[&quot;components&quot;]:
251                  core[&quot;components&quot;][componentName][&quot;docs&quot;] = description
252              elif componentName in core[&quot;platforms&quot;]:
253                  core[&quot;platforms&quot;][componentName][&quot;docs&quot;] = description
254              else:
255                  if componentName != &quot;display_menu_base&quot;:
256                      raise ValueError(
257                          &quot;Cannot set description for component &quot; + componentName
258                      )
259      def visit_document(self, node):
260          if self.docname in [&quot;components/sensor/binary_sensor_map&quot;]:
261              raise nodes.SkipChildren
262          if self.docname in [&quot;components/climate/climate_ir&quot;]:
263              return
264          if len(list(node.traverse(nodes.paragraph))) == 0:
265              raise nodes.SkipChildren
266          self.props_section_title = get_node_title(node)
267          description = self.getMarkdownParagraph(node)
268          if self.json_platform_component:
269              self.set_component_description(description, self.component, self.platform)
270          elif self.json_component:
271              self.set_component_description(description, self.component)
272          if self.json_component or self.json_platform_component:
273              if is_component_file(
274                  self.app,
275                  self.component,
276              ):
277                  self.props = self.find_props(
278                      self.json_platform_component
279                      if self.json_platform_component
280                      else self.json_component,
281                      True,
282                  )
283      def visit_table(self, node):
284          if (
285              self.docname == &quot;components/climate/climate_ir&quot;
286              and len(CUSTOM_DOCS[&quot;components/climate/climate_ir&quot;][&quot;IR Remote Climate&quot;])
287              == 0
288          ):
289              table_rows = node[0][4]
290              for row in table_rows:
291                  components_paths = [
292                      components + &quot;.platform.climate.schemas.CONFIG_SCHEMA&quot;
293                      for components in row[1].astext().split(&quot;\n&quot;)
294                  ]
295                  CUSTOM_DOCS[&quot;components/climate/climate_ir&quot;][
296                      &quot;IR Remote Climate&quot;
297                  ] += components_paths
298      def depart_document(self, node):
299          pass
300      def visit_section(self, node):
301          self.section_level += 1
302          section_title = get_node_title(node)
303          if self.custom_doc and section_title in self.custom_doc:
304              r = self.custom_doc[section_title]
305              if &quot;.registry.&quot; in r:
306                  self.find_registry = r
307      def depart_section(self, node):
308          self.section_level -= 1
309          if self.section_level == 1:
310              self.find_registry = None
311      def unknown_visit(self, node):
312          pass
313      def unknown_departure(self, node):
314          pass
315      def visit_title(self, node):
316          title_text = node.astext()
317          if self.custom_doc is not None and title_text in self.custom_doc:
318              if isinstance(self.custom_doc[title_text], list):
319                  self.multi_component = self.custom_doc[title_text]
320                  self.filled_props = False
321                  self.props = None
322                  desc = self.getMarkdownParagraph(node.parent)
323                  for c in self.multi_component:
324                      if len(c.split(&quot;.&quot;)) == 2:
325                          self.set_component_description(desc, c.split(&quot;.&quot;)[0])
326                  return
327              json_component = self.find_component(self.custom_doc[title_text])
328              if not json_component:
329                  return
330              if self.json_component is None:
331                  self.json_component = json_component
332              parts = self.custom_doc[title_text].split(&quot;.&quot;)
333              if parts[0] not in [&quot;core&quot;, &quot;remote_base&quot;] and parts[-1] != &quot;pin&quot;:
334                  if parts[1] == &quot;platform&quot;:
335                      self.set_component_description(
336                          self.getMarkdownParagraph(node.parent), parts[0], parts[2]
337                      )
338                  else:
339                      self.set_component_description(
340                          self.getMarkdownParagraph(node.parent),
341                          parts[0],
342                      )
343              self.props_section_title = title_text
344              self.props = self.find_props(json_component)
345              return
346          elif title_text == COMPONENT_HUB:
347              self.props_section_title = f&quot;{self.path[-1]} {title_text}&quot;
348              json_component = self.get_component_schema(
349                  self.path[-1] + &quot;.CONFIG_SCHEMA&quot;
350              ).get(&quot;schema&quot;, {})
351              if json_component:
352                  self.props = self.find_props(json_component)
353                  self.set_component_description(
354                      self.getMarkdownParagraph(node.parent), self.path[-1]
355                  )
356              self.is_component_hub = True
357          elif is_config_vars_title(title_text):
358              if not self.props and self.multi_component is None:
359                  raise ValueError(
360                      f&#x27;Found a &quot;{title_text}&quot;: title after {self.previous_title_text}. Unknown object.&#x27;
361                  )
362          elif title_text == &quot;Over SPI&quot; or title_text == &quot;Over IÂ²C&quot;:
363              suffix = &quot;_spi&quot; if &quot;SPI&quot; in title_text else &quot;_i2c&quot;
364              component = self.path[-1] + suffix
365              self.props_section_title = self.path[-1] + &quot; &quot; + title_text
366              if self.platform is not None and not self.is_component_hub:
367                  json_platform_component = find_platform_component(
368                      self.app, self.platform, component
369                  )
370                  if not json_platform_component:
371                      raise ValueError(
372                          f&quot;Cannot find platform {self.platform} component &#x27;{component}&#x27; after found title: &#x27;{title_text}&#x27;.&quot;
373                      )
374                  self.props = self.find_props(json_platform_component)
375                  json_platform_component[&quot;docs&quot;] = self.getMarkdownParagraph(node.parent)
376              else:
377                  json_component = self.get_component_schema(
378                      component + &quot;.CONFIG_SCHEMA&quot;
379                  ).get(&quot;schema&quot;, {})
380                  if not json_component:
381                      raise ValueError(
382                          f&quot;Cannot find component &#x27;{component}&#x27; after found title: &#x27;{title_text}&#x27;.&quot;
383                      )
384                  self.props = self.find_props(json_component)
385                  self.set_component_description(
386                      self.getMarkdownParagraph(node.parent), component
387                  )
388          elif (
389              len(
390                  list(
391                      filter(
392                          lambda x: title_text.endswith(x), list(PLATFORMS_TITLES.keys())
393                      )
394                  )
395              )
396              &gt; 0
397          ):
398              if title_text in PLATFORMS_TITLES:
399                  platform_name = PLATFORMS_TITLES[title_text]
400                  if self.path[-1] == &quot;index&quot;:
401                      component_name = self.path[-2]
402                  else:
403                      component_name = self.path[-1]
404                  self.props_section_title = component_name + &quot; &quot; + title_text
405              else:
406                  for t in PLATFORMS_TITLES:
407                      if title_text.endswith(t):
408                          component_name = title_text[
409                              0 : len(title_text) - len(t) - 1
410                          ].replace(&quot; &quot;, &quot;_&quot;)
411                          platform_name = PLATFORMS_TITLES[t]
412                  if not platform_name:
413                      return
414                  self.props_section_title = title_text
415                  if not is_component_file(self.app, component_name):
416                      return
417              c = find_platform_component(self.app, platform_name, component_name.lower())
418              if c:
419                  self.json_platform_component = c
420                  self.set_component_description(
421                      self.getMarkdownParagraph(node.parent),
422                      component_name,
423                      platform_name,
424                  )
425              try:
426                  self.props = self.find_props(self.json_platform_component)
427              except KeyError:
428                  raise ValueError(&quot;Cannot find platform props&quot;)
429          elif title_text.endswith(&quot;Component&quot;) or title_text.endswith(&quot;Bus&quot;):
430              split_text = title_text.split(&quot; &quot;)
431              self.props_section_title = title_text
432              component_name = (
433                  &quot;_&quot;.join(split_text[:-1]).lower().replace(&quot;.&quot;, &quot;&quot;).replace(&quot;iÂ²c&quot;, &quot;i2c&quot;)
434              )
435              if component_name != self.platform and is_component_file(
436                  self.app, component_name
437              ):
438                  f = get_component_file(self.app, component_name)
439                  description = self.getMarkdownParagraph(node.parent)
440                  if component_name in f:
441                      self.set_component_description(description, component_name)
442                      c = f[component_name]
443                      if c:
444                          self.json_component = c[&quot;schemas&quot;][&quot;CONFIG_SCHEMA&quot;]
445                          try:
446                              self.props = self.find_props(self.json_component)
447                              self.multi_component = None
448                          except KeyError:
449                              raise ValueError(
450                                  &quot;Cannot find props for component &quot; + component_name
451                              )
452                          return
453                  elif f&quot;{component_name}.{self.path[1]}&quot; in f:
454                      self.set_component_description(
455                          description, component_name, self.path[1]
456                      )
457                      self.json_platform_component = f[
458                          f&quot;{component_name}.{self.path[1]}&quot;
459                      ][&quot;schemas&quot;][&quot;CONFIG_SCHEMA&quot;]
460                      try:
461                          self.props = self.find_props(self.json_platform_component)
462                      except KeyError:
463                          raise ValueError(
464                              f&quot;Cannot find props for platform {self.path[1]} component {self.component_name}&quot;
465                          )
466                      return
467          elif title_text.endswith(&quot;Trigger&quot;):
468              description = self.getMarkdownParagraph(node.parent)
469              split_text = title_text.split(&quot; &quot;)
470              if len(split_text) != 2:
471                  return
472              key = split_text[0]
473              if (
474                  not self.props or not self.props.typed
475              ):  # props are right for typed components so far
476                  c = self.json_component
477                  if c:
478                      if self.component in c:
479                          c = c[self.component][&quot;schemas&quot;][
480                              self.component.upper() + &quot;_SCHEMA&quot;
481                          ]
482                      trigger_schema = self.find_props(c).get(key)
483                      if trigger_schema is not None:
484                          self.props = self.find_props(trigger_schema)
485              self.props_section_title = title_text
486          elif title_text == PIN_CONFIGURATION_VARIABLES:
487              self.component = self.find_component(self.path[-1] + &quot;.pin&quot;)
488              self.props = self.find_props(self.component)
489              self.accept_props = True
490              if not self.component:
491                  raise ValueError(
492                      f&#x27;Found a &quot;{PIN_CONFIGURATION_VARIABLES}&quot; entry but could not find pin schema&#x27;
493                  )
494          elif title_text.endswith(&quot;Action&quot;) or title_text.endswith(&quot;Condition&quot;):
495              description = self.getMarkdownParagraph(node.parent)
496              split_text = title_text.split(&quot; &quot;)
497              if len(split_text) != 2:
498                  return
499              key = split_text[0]
500              component_parts = split_text[0].split(&quot;.&quot;)
501              if len(component_parts) == 3:
502                  try:
503                      cv = get_component_file(self.app, component_parts[1])[
504                          component_parts[1] + &quot;.&quot; + component_parts[0]
505                      ][split_text[1].lower()][component_parts[2]]
506                  except KeyError:
507                      logger.warn(
508                          f&quot;In {self.docname} cannot found schema of {title_text}&quot;
509                      )
510                      cv = None
511                  if cv is not None:
512                      cv[&quot;docs&quot;] = description
513                      self.props = self.find_props(cv.get(&quot;schema&quot;, {}))
514              elif len(component_parts) == 2:
515                  registry_name = &quot;.&quot;.join(
516                      [component_parts[0], &quot;registry&quot;, split_text[1].lower()]
517                  )
518                  key = component_parts[1]
519                  self.find_registry_prop(registry_name, key, description)
520              else:
521                  registry_name = f&quot;core.registry.{split_text[1].lower()}&quot;
522                  self.find_registry_prop(registry_name, key, description)
523          if self.section_level == 3 and self.find_registry:
524              name = title_text
525              if name.endswith(&quot; Effect&quot;):
526                  name = title_text[: -len(&quot; Effect&quot;)]
527              if name.endswith(&quot; Light&quot;):
528                  name = name[: -len(&quot; Light&quot;)]
529              key = name.replace(&quot; &quot;, &quot;_&quot;).replace(&quot;.&quot;, &quot;&quot;).lower()
530              description = self.getMarkdownParagraph(node.parent)
531              self.find_registry_prop(self.find_registry, key, description)
532              self.props_section_title = title_text
533      def get_component_schema(self, name):
534          parts = name.split(&quot;.&quot;)
535          schema_file = get_component_file(self.app, parts[0])
536          if parts[1] == &quot;registry&quot;:
537              schema = schema_file.get(parts[0], {}).get(parts[2], {})
538          elif len(parts) == 3:
539              schema = (
540                  schema_file.get(f&quot;{parts[0]}.{parts[1]}&quot;)
541                  .get(&quot;schemas&quot;, {})
542                  .get(parts[2], {})
543              )
544          else:
545              schema = schema_file.get(parts[0], {}).get(&quot;schemas&quot;, {}).get(parts[1], {})
546          return schema
547      def get_component_config_var(self, name, key):
548          c = self.get_component_schema(name)
549          if key in c:
550              return c[key]
551          if &quot;config_vars&quot; not in c:
552              return c
553          if key in c[&quot;config_vars&quot;]:
554              return c[&quot;config_vars&quot;][c]
555      def find_registry_prop(self, registry_name, key, description):
556          c = self.get_component_schema(registry_name)
557          if key in c:
558              cv = c[key]
559              if cv is not None:
560                  cv[&quot;docs&quot;] = description
561                  self.props = self.find_props(cv.get(&quot;schema&quot;, {}))
562      def depart_title(self, node):
563          if self.filled_props:
564              self.filled_props = False
565              self.props = None
566              self.current_prop = None
567              self.accept_props = False
568              self.multi_component = None
569          self.previous_title_text = node.astext()
570          self.title_id = node.parent[&quot;ids&quot;][0]
571      def find_props_previous_title(self):
572          comp = self.json_component or self.json_platform_component
573          if comp:
574              props = self.find_props(comp)
575              if self.previous_title_text in props:
576                  prop = props[self.previous_title_text]
577                  if prop:
578                      self.props = self.find_props(prop)
579                  else:
580                      self.props = {&quot;__&quot;: &quot;none&quot;}
581      def visit_Text(self, node):
582          if self.multi_component:
583              return
584          if is_config_vars_title(node.astext()):
585              if not self.props:
586                  self.find_props_previous_title()
587              if not self.props:
588                  raise ValueError(
589                      f&#x27;Found a &quot;{node.astext()}&quot; entry for unknown object after {self.previous_title_text}&#x27;
590                  )
591              self.accept_props = True
592          raise nodes.SkipChildren
593      def depart_Text(self, node):
594          pass
595      def visit_paragraph(self, node):
596          if is_config_vars_title(node.astext()):
597              if not self.props and not self.multi_component:
598                  self.find_props_previous_title()
599              if not self.props and not self.multi_component:
600                  logger.info(
601                      f&quot;In {self.docname} / {self.previous_title_text} found a {node.astext()} title and there are no props.&quot;
602                  )
603              self.accept_props = True
604          raise nodes.SkipChildren
605      def depart_paragraph(self, node):
606          pass
607      def visit_bullet_list(self, node):
608          self.bullet_list_level = self.bullet_list_level + 1
609          if (
610              self.current_prop
611              and (self.props or self.multi_component)
612              and self.bullet_list_level &gt; 1
613          ):
614              self.prop_stack.append((self.current_prop, node))
615              self.accept_props = True
616              return
617          if not self.props and self.multi_component is None:
618              raise nodes.SkipChildren
619      def depart_bullet_list(self, node):
620          self.bullet_list_level = self.bullet_list_level - 1
621          if len(self.prop_stack) &gt; 0:
622              stack_prop, stack_node = self.prop_stack[-1]
623              if stack_node == node:
624                  self.prop_stack.pop()
625                  self.filled_props = True
626                  self.current_prop = stack_prop
627      def visit_list_item(self, node):
628          if self.accept_props and self.props:
629              self.filled_props = True
630              self.current_prop, found = self.update_prop(node, self.props)
631              if self.current_prop and not found:
632                  logger.info(
633                      f&quot;In &#x27;{self.docname} {self.previous_title_text} Cannot find property {self.current_prop}&quot;
634                  )
635          elif self.multi_component:
636              found_any = False
637              self.current_prop = None
638              for c in self.multi_component:
639                  props = self.find_props(self.find_component(c))
640                  self.current_prop, found = self.update_prop(node, props)
641                  if self.current_prop and found:
642                      found_any = True
643              if self.current_prop and not found_any:
644                  logger.info(
645                      f&quot;In &#x27;{self.docname} {self.previous_title_text} Cannot find property {self.current_prop}&quot;
646                  )
647              self.filled_props = True
648      def depart_list_item(self, node):
649          pass
650      def visit_literal(self, node):
651          raise nodes.SkipChildren
652      def depart_literal(self, node):
653          pass
654      def getMarkdown(self, node):
655          from markdown import Translator
656          t = Translator(
657              urllib.parse.urljoin(self.app.config.html_baseurl, self.docname + &quot;.html&quot;),
658              self.doctree,
659          )
660          node.walkabout(t)
661          return t.output.strip(&quot;\n&quot;)
662      def getMarkdownParagraph(self, node):
663          paragraph = list(node.traverse(nodes.paragraph))[0]
664          markdown = self.getMarkdown(paragraph)
665          param_type = None
666          try:
667              name_type = markdown[: markdown.index(&quot;: &quot;) + 2]
668              ntr = re.search(
669                  REQUIRED_OPTIONAL_TYPE_REGEX,
670                  name_type,
671                  re.IGNORECASE,
672              )
673              if ntr:
674                  param_type = ntr.group(6)
675                  if param_type:
676                      markdown = (
677                          f&quot;**{param_type}**: {markdown[markdown.index(&#x27;: &#x27;) + 2 :]}&quot;
678                      )
679          except ValueError:
680              pass
681          title = list(node.traverse(nodes.title))[0]
682          if len(title) &gt; 0:
683              url = urllib.parse.urljoin(
684                  self.app.config.html_baseurl,
685                  self.docname + &quot;.html#&quot; + title.parent[&quot;ids&quot;][0],
686              )
687              if (
688                  self.props_section_title is not None
689                  and self.props_section_title.endswith(title.astext())
690              ):
691                  markdown += f&quot;\n\n*See also: [{self.props_section_title}]({url})*&quot;
692              else:
693                  markdown += f&quot;\n\n*See also: [{self.getMarkdown(title)}]({url})*&quot;
694          return markdown
695      def update_prop(self, node, props):
696          prop_name = None
697          for s_prop, n in self.prop_stack:
698              inner = props.get(s_prop)
699              if inner is not None and &quot;schema&quot; in inner:
700                  props = self.Props(self, inner[&quot;schema&quot;])
701              elif inner is not None and inner.get(&quot;type&quot;) == &quot;typed&quot;:
702                  props = self.Props(self, inner)
703              elif inner is not None and inner.get(&quot;type&quot;) == &quot;enum&quot;:
704                  enum_raw = self.getMarkdown(node)
705                  enum_match = re.search(
706                      r&quot;\* `([^`]*)`((:| -) (.*))*&quot;, enum_raw, re.IGNORECASE
707                  )
708                  if enum_match:
709                      enum_value = enum_match.group(1)
710                      enum_docs = enum_match.group(4)
711                      found = False
712                      for name in inner[&quot;values&quot;]:
713                          if enum_value.upper().replace(&quot; &quot;, &quot;_&quot;) == str(name).upper():
714                              found = True
715                              if enum_docs:
716                                  enum_docs = enum_docs.strip()
717                                  if inner[&quot;values&quot;][name] is None:
718                                      inner[&quot;values&quot;][name] = {&quot;docs&quot;: enum_docs}
719                                  else:
720                                      inner[&quot;values&quot;][name][&quot;docs&quot;] = enum_docs
721                                  statistics.props_documented += 1
722                                  statistics.enums_good += 1
723                      if not found:
724                          logger.info(
725                              f&quot;In &#x27;{self.docname} {self.previous_title_text} Property {s_prop} cannot find enum value {enum_value}&quot;
726                          )
727                  else:
728                      statistics.enums_bad += 1
729                      logger.info(
730                          f&quot;In &#x27;{self.docname} {self.previous_title_text} Property {s_prop} unexpected enum member description format&quot;
731                      )
732              else:
733                  return prop_name, False
734          raw = node.rawsource  # this has the full raw rst code for this property
735          if not raw.startswith(&quot;**&quot;):
736              return prop_name, False
737          markdown = self.getMarkdown(node)
738          markdown += f&quot;\n\n*See also: [{self.props_section_title}]({urllib.parse.urljoin(self.app.config.html_baseurl, self.docname +&#x27;.html#&#x27;+self.title_id)})*&quot;
739          try:
740              name_type = markdown[: markdown.index(&quot;: &quot;) + 2]
741          except ValueError:
742              logger.info(
743                  f&quot;In &#x27;{self.docname} {self.previous_title_text} Property format error. Missing &#x27;: &#x27; in {raw}&#x27;&quot;
744              )
745              return prop_name, False
746          PROP_NAME_REGEX = r&quot;\*\*(\w*(?:/\w*)*)\*\*&quot;
747          FULL_ITEM_PROP_NAME_TYPE_REGEX = (
748              r&quot;\* &quot; + PROP_NAME_REGEX + r&quot;\s&quot; + REQUIRED_OPTIONAL_TYPE_REGEX
749          )
750          ntr = re.search(
751              FULL_ITEM_PROP_NAME_TYPE_REGEX,
752              name_type,
753              re.IGNORECASE,
754          )
755          if ntr:
756              prop_name = ntr.group(1)
757              param_type = ntr.group(7)
758          else:
759              s2 = re.search(
760                  FULL_ITEM_PROP_NAME_TYPE_REGEX,
761                  markdown,
762                  re.IGNORECASE,
763              )
764              if s2:
765                  s3 = re.search(r&quot;\* &quot; + PROP_NAME_REGEX + r&quot;*:\s&quot;, name_type)
766                  if s3 is not None:
767                      prop_name = s3.group(1)
768                  else:
769                      logger.info(
770                          f&quot;In &#x27;{self.docname} {self.previous_title_text} Invalid list format: {node.rawsource}&quot;
771                      )
772                  param_type = None
773              else:
774                  logger.info(
775                      f&quot;In &#x27;{self.docname} {self.previous_title_text} Invalid property format: {node.rawsource}&quot;
776                  )
777                  return prop_name, False
778          prop_names = str(prop_name)
779          for k in prop_names.split(&quot;/&quot;):
780              config_var = props.get(k)
781              if not config_var:
782                  if k in [
783                      &quot;id&quot;,
784                      &quot;name&quot;,
785                      &quot;internal&quot;,
786                      &quot;address&quot;,
787                      &quot;i2c_id&quot;,
788                      &quot;update_interval&quot;,
789                      &quot;uart_id&quot;,
790                      &quot;effects&quot;,
791                      &quot;gamma_correct&quot;,
792                      &quot;default_transition_length&quot;,
793                      &quot;flash_transition_length&quot;,
794                      &quot;color_correct&quot;,
795                      &quot;lambda&quot;,
796                      &quot;pages&quot;,
797                      &quot;rotation&quot;,
798                      &quot;spi_id&quot;,
799                      &quot;cs_pin&quot;,
800                      &quot;inverted&quot;,
801                      &quot;power_supply&quot;,
802                      &quot;receiver_id&quot;,
803                  ]:
804                      config_var = props[k] = {}
805                  else:
806                      if self.path[1] == &quot;esphome&quot; and k in [
807                          &quot;platform&quot;,
808                          &quot;board&quot;,
809                          &quot;arduino_version&quot;,
810                          &quot;esp8266_restore_from_flash&quot;,
811                      ]:
812                          return prop_name, True
813                      return prop_name, False
814              desc = markdown[markdown.index(&quot;: &quot;) + 2 :].strip()
815              if param_type:
816                  desc = &quot;**&quot; + param_type + &quot;**: &quot; + desc
817              config_var[&quot;docs&quot;] = desc
818          statistics.props_documented += 1
819          return prop_name, True
820      def find_component(self, component_path):
821          path = component_path.split(&quot;.&quot;)
822          file_content = get_component_file(self.app, path[0])
823          if path[1] == &quot;platform&quot;:
824              path[2] = f&quot;{path[0]}.{path[2]}&quot;
825              path = path[2:]
826          component = file_content
827          for p in path:
828              component = component.get(p, {})
829          return component
830      class Props(MutableMapping):
831          def __init__(self, visitor, component, fail_silently=False):
832              self.visitor = visitor
833              self.component = component
834              self.store = self._get_props(component, fail_silently)
835              self.parent = None
836              self.typed = self.component.get(&quot;type&quot;) == &quot;typed&quot;
837          def _get_props(self, component, fail_silently):
838              if not (
839                  &quot;config_vars&quot; in component
840                  or &quot;extends&quot; in component
841                  or len(component) == 0
842                  or component.get(&quot;type&quot;) == &quot;typed&quot;
843              ):
844                  if fail_silently:
845                      return None
846                  raise ValueError(&quot;Unexpected component data to get props&quot;)
847              props = component.get(&quot;config_vars&quot;)
848              return props
849          def _find_extended(self, component, key):
850              for extended in component.get(&quot;extends&quot;, []):
851                  c = self.visitor.get_component_schema(extended)
852                  if c.get(&quot;type&quot;) == &quot;typed&quot;:
853                      p = self.visitor.Props(self.visitor, c)
854                      return p[key]
855                  schema = c.get(&quot;schema&quot;, {})
856                  for k, cv in schema.get(&quot;config_vars&quot;, {}).items():
857                      if k == key:
858                          return SetObservable(
859                              cv,
860                              setitem_callback=self._set_extended,
861                              inner_key=key,
862                              original_dict=schema.get(&quot;config_vars&quot;),
863                          )
864                  ex1 = self._find_extended(schema, key)
865                  if ex1:
866                      return ex1
867          def _set_extended(self, inner_key, original_dict, key, value):
868              original_dict[inner_key][key] = value
869          def _iter_extended(self, component):
870              for extended in component.get(&quot;extends&quot;, []):
871                  schema = self.visitor.get_component_schema(extended).get(&quot;schema&quot;, {})
872                  for s in self._iter_extended(schema):
873                      yield s
874                  yield schema
875          def __getitem__(self, key):
876              if self.store and key in self.store:
877                  return self.store[key]
878              extended = self._find_extended(self.component, key)
879              if extended is not None:
880                  return extended
881              if self.component.get(&quot;type&quot;) == &quot;typed&quot;:
882                  return SetObservable(
883                      {key: {&quot;type&quot;: &quot;string&quot;}},
884                      setitem_callback=self._set_typed,
885                      inner_key=key,
886                      original_dict={},
887                  )
888          def _set_typed(self, inner_key, original_dict, key, value):
889              if inner_key == self.component.get(&quot;typed_key&quot;, &quot;type&quot;):
890                  self.component[key] = value
891              else:
892                  for tk, tv in self.component[&quot;types&quot;].items():
893                      for cv_k, cv_v in tv[&quot;config_vars&quot;].items():
894                          if cv_k == inner_key:
895                              cv_v[key] = value
896          def __setitem__(self, key, value):
897              self.store[key] = value
898          def __delitem__(self, key):
899              self.store.pop(key)
900          def __iter__(self):
901              return iter(self.store)
902          def __len__(self):
903              len_extended = 0
904              if self.component.get(&quot;type&quot;):
905                  types = self.component.get(&quot;types&quot;)
906                  for t, tv in types.items():
907                      for s in self._iter_extended(types.get(t, {})):
908                          len_extended += len(s.get(&quot;config_vars&quot;, {}))
909                      len_extended += len(tv.get(&quot;config_vars&quot;, {}))
910                  return len_extended
911              for s in self._iter_extended(self.component):
912                  len_extended += len(s.get(&quot;config_vars&quot;, {}))
913              return len_extended + (len(self.store) if self.store else 0)
914      def find_props(self, component, fail_silently=False):
915          if component.get(&quot;type&quot;) in [&quot;trigger&quot;, &quot;schema&quot;]:
916              if &quot;schema&quot; not in component:
917                  return None
918              component = component.get(&quot;schema&quot;)
919          props = self.Props(self, component, fail_silently)
920          if props:
921              self.filled_props = False
922              self.accept_props = False
923              self.current_prop = None
924          return props
925  def handle_component(app, doctree, docname):
926      path = docname.split(&quot;/&quot;)
927      if path[0] == &quot;components&quot;:
928          pass
929      elif docname not in CUSTOM_DOCS:
930          return
931      try:
932          v = SchemaGeneratorVisitor(app, doctree, docname)
933          doctree.walkabout(v)
934      except Exception as e:
935          err_str = f&quot;In {docname}.rst: {str(e)}&quot;
936          logger.warning(err_str)
937  def build_finished(app, exception):
938      for fname, contents in app.files.items():
939          f = open(SCHEMA_PATH + fname + &quot;.json&quot;, &quot;w&quot;, newline=&quot;\n&quot;)
940          if JSON_DUMP_PRETTY:
941              f.write(json.dumps(contents, indent=2))
942          else:
943              f.write(json.dumps(contents, separators=(&quot;,&quot;, &quot;:&quot;)))
944      str = f&quot;Documented: {statistics.props_documented} Enums: {statistics.enums_good}/{statistics.enums_bad}&quot;
945      logger.info(str)
946  class SetObservable(dict):
947      def __init__(
948          self,
949          value,
950          setitem_callback=None,
951          inner_key=None,
952          original_dict=None,
953          *args,
954          **kwargs,
955      ):
956          super(SetObservable, self).__init__(value, *args, **kwargs)
957          self._setitem_callback = setitem_callback
958          self.inner_key = inner_key
959          self.original_dict = original_dict
960      def __setitem__(self, key, value):
961          if self._setitem_callback:
962              self._setitem_callback(self.inner_key, self.original_dict, key, value)
963          super(SetObservable, self).__setitem__(key, value)
964  def is_component_file(app: SchemaGeneratorVisitor, component):
965      if component == &quot;core&quot; or component == &quot;automation&quot;:
966          component = &quot;esphome&quot;
967      return exists(SCHEMA_PATH + component + &quot;.json&quot;)
968  def get_component_file(app: SchemaGeneratorVisitor, component):
969      if component == &quot;core&quot; or component == &quot;automation&quot;:
970          component = &quot;esphome&quot;
971      if component not in app.files:
972          app.files[component] = read_file(component)
973      return app.files[component]
</code></pre>
        </div>
        <div class="column">
            <h3>esphome-docs-MDEwOlJlcG9zaXRvcnkxMzMyMjM0NjE=-flat-schema_doc.py</h3>
            <pre><code>1  from genericpath import exists
2  import re
3  import json
4  import urllib
5  from typing import MutableMapping
6  from sphinx.util import logging
7  from docutils import nodes
8  SCHEMA_PATH = &quot;../esphome-vscode/server/src/schema/&quot;
9  CONFIGURATION_VARIABLES = &quot;Configuration variables:&quot;
10  CONFIGURATION_OPTIONS = &quot;Configuration options:&quot;
11  PIN_CONFIGURATION_VARIABLES = &quot;Pin configuration variables:&quot;
12  COMPONENT_HUB = &quot;Component/Hub&quot;
13  JSON_DUMP_PRETTY = True
14  class Statistics:
15      props_documented = 0
16      enums_good = 0
17      enums_bad = 0
18  statistics = Statistics()
19  logger = logging.getLogger(__name__)
20  def setup(app):
21      import os
22      if not os.path.isfile(SCHEMA_PATH + &quot;esphome.json&quot;):
23          logger.info(f&quot;{SCHEMA_PATH} not found. Not documenting schema.&quot;)
24          return
25      app.connect(&quot;doctree-resolved&quot;, doctree_resolved)
26      app.connect(&quot;build-finished&quot;, build_finished)
27      app.files = {}
28      return {&quot;version&quot;: &quot;1.0.0&quot;, &quot;parallel_read_safe&quot;: True, &quot;parallel_write_safe&quot;: True}
29  def find_platform_component(app, platform, component):
30      file_data = get_component_file(app, component)
31      return file_data[f&quot;{component}.{platform}&quot;][&quot;schemas&quot;][&quot;CONFIG_SCHEMA&quot;]
32  def doctree_resolved(app, doctree, docname):
33      if docname == &quot;components/index&quot;:
34          return
35      handle_component(app, doctree, docname)
36  PLATFORMS_TITLES = {
37      &quot;Sensor&quot;: &quot;sensor&quot;,
38      &quot;Binary Sensor&quot;: &quot;binary_sensor&quot;,
39      &quot;Text Sensor&quot;: &quot;text_sensor&quot;,
40      &quot;Output&quot;: &quot;output&quot;,
41      &quot;Cover&quot;: &quot;cover&quot;,
42      &quot;Button&quot;: &quot;button&quot;,
43      &quot;Select&quot;: &quot;select&quot;,
44      &quot;Fan&quot;: &quot;fan&quot;,
45      &quot;Lock&quot;: &quot;lock&quot;,
46      &quot;Number&quot;: &quot;number&quot;,
47      &quot;Climate&quot;: &quot;climate&quot;,
48      &quot;CAN Bus&quot;: &quot;canbus&quot;,
49      &quot;Stepper&quot;: &quot;stepper&quot;,
50      &quot;Switch&quot;: &quot;switch&quot;,
51      &quot;IÂ²C&quot;: &quot;i2c&quot;,
52      &quot;Media Player&quot;: &quot;media_player&quot;,
53      &quot;Microphone&quot;: &quot;microphone&quot;,
54      &quot;Speaker&quot;: &quot;speaker&quot;,
55      &quot;Alarm Control Panel&quot;: &quot;alarm_control_panel&quot;,
56  }
57  CUSTOM_DOCS = {
58      &quot;guides/automations&quot;: {
59          &quot;Global Variables&quot;: &quot;globals.schemas.CONFIG_SCHEMA&quot;,
60      },
61      &quot;guides/configuration-types&quot;: {
62          &quot;Pin Schema&quot;: [
63              &quot;esp32.pin.schema&quot;,
64              &quot;esp8266.pin.schema&quot;,
65          ],
66      },
67      &quot;components/binary_sensor/index&quot;: {
68          &quot;Binary Sensor Filters&quot;: &quot;binary_sensor.registry.filter&quot;,
69      },
70      &quot;components/canbus&quot;: {
71          &quot;_LoadSchema&quot;: False,
72          &quot;Base CAN Bus Configuration&quot;: &quot;canbus.schemas.CANBUS_SCHEMA&quot;,
73      },
74      &quot;components/climate/climate_ir&quot;: {&quot;_LoadSchema&quot;: False, &quot;IR Remote Climate&quot;: []},
75      &quot;components/display/index&quot;: {
76          &quot;Images&quot;: &quot;image.schemas.CONFIG_SCHEMA&quot;,
77          &quot;Fonts&quot;: &quot;font.schemas.CONFIG_SCHEMA&quot;,
78          &quot;Color&quot;: &quot;color.schemas.CONFIG_SCHEMA&quot;,
79          &quot;Animation&quot;: &quot;animation.schemas.CONFIG_SCHEMA&quot;,
80      },
81      &quot;components/light/index&quot;: {
82          &quot;Base Light Configuration&quot;: [
83              &quot;light.schemas.ADDRESSABLE_LIGHT_SCHEMA&quot;,
84              &quot;light.schemas.BINARY_LIGHT_SCHEMA&quot;,
85              &quot;light.schemas.BRIGHTNESS_ONLY_LIGHT_SCHEMA&quot;,
86              &quot;light.schemas.LIGHT_SCHEMA&quot;,
87          ],
88          &quot;Light Effects&quot;: &quot;light.registry.effects&quot;,
89      },
90      &quot;components/light/fastled&quot;: {
91          &quot;_LoadSchema&quot;: False,
92          &quot;Clockless&quot;: &quot;fastled_clockless.platform.light.schemas.CONFIG_SCHEMA&quot;,
93          &quot;SPI&quot;: &quot;fastled_spi.platform.light.schemas.CONFIG_SCHEMA&quot;,
94      },
95      &quot;components/binary_sensor/ttp229&quot;: {
96          &quot;_LoadSchema&quot;: False,
97      },
98      &quot;components/mcp230xx&quot;: {
99          &quot;_LoadSchema&quot;: False,
100          PIN_CONFIGURATION_VARIABLES: &quot;mcp23xxx.pin&quot;,
101      },
102      &quot;components/mqtt&quot;: {
103          &quot;MQTT Component Base Configuration&quot;: &quot;core.schemas.MQTT_COMMAND_COMPONENT_SCHEMA&quot;,
104          &quot;MQTTMessage&quot;: &quot;mqtt.schemas.MQTT_MESSAGE_BASE&quot;,
105      },
106      &quot;components/output/index&quot;: {
107          &quot;Base Output Configuration&quot;: &quot;output.schemas.FLOAT_OUTPUT_SCHEMA&quot;,
108      },
109      &quot;components/remote_transmitter&quot;: {
110          &quot;Remote Transmitter Actions&quot;: &quot;remote_base.schemas.BASE_REMOTE_TRANSMITTER_SCHEMA&quot;,
111      },
112      &quot;components/sensor/index&quot;: {
113          &quot;Sensor Filters&quot;: &quot;sensor.registry.filter&quot;,
114      },
115      &quot;components/time&quot;: {
<span onclick='openModal()' class='match'>116          &quot;_LoadSchema&quot;: False,
117          &quot;Base Time Configuration&quot;: &quot;time.schemas.TIME_SCHEMA&quot;,
118          &quot;on_time Trigger&quot;: &quot;time.schemas.TIME_SCHEMA.schema.config_vars.on_time.schema&quot;,
119          &quot;Home Assistant Time Source&quot;: &quot;homeassistant.platform.time.schemas.CONFIG_SCHEMA&quot;,
</span>120          &quot;SNTP Time Source&quot;: &quot;sntp.platform.time.schemas.CONFIG_SCHEMA&quot;,
121          &quot;GPS Time Source&quot;: &quot;gps.platform.time.schemas.CONFIG_SCHEMA&quot;,
122          &quot;DS1307 Time Source&quot;: &quot;ds1307.platform.time.schemas.CONFIG_SCHEMA&quot;,
123      },
124      &quot;components/wifi&quot;: {
125          &quot;Connecting to Multiple Networks&quot;: &quot;wifi.schemas.CONFIG_SCHEMA.schema.config_vars.networks.schema&quot;,
126          &quot;Enterprise Authentication&quot;: &quot;wifi.schemas.EAP_AUTH_SCHEMA&quot;,
127      },
128      &quot;custom/custom_component&quot;: {
129          &quot;Generic Custom Component&quot;: &quot;custom_component.schemas.CONFIG_SCHEMA&quot;
130      },
131      &quot;components/esp32&quot;: {
132          &quot;Arduino framework&quot;: &quot;esp32.schemas.CONFIG_SCHEMA.schema.config_vars.framework.types.arduino&quot;,
133          &quot;ESP-IDF framework&quot;: &quot;esp32.schemas.CONFIG_SCHEMA.schema.config_vars.framework.types.esp-idf&quot;,
134      },
135      &quot;components/sensor/airthings_ble&quot;: {
136          &quot;_LoadSchema&quot;: False,
137      },
138      &quot;components/sensor/radon_eye_ble&quot;: {
139          &quot;_LoadSchema&quot;: False,
140      },
141      &quot;components/sensor/xiaomi_ble&quot;: {
142          &quot;_LoadSchema&quot;: False,
143      },
144      &quot;components/sensor/xiaomi_miscale2&quot;: {
145          &quot;_LoadSchema&quot;: False,
146      },
147      &quot;components/mcp23Sxx&quot;: {
148          &quot;_LoadSchema&quot;: False,
149      },
150      &quot;components/display/lcd_display&quot;: {&quot;_LoadSchema&quot;: False},
151      &quot;components/display/ssd1306&quot;: {&quot;_LoadSchema&quot;: False},
152      &quot;components/display/ssd1322&quot;: {&quot;_LoadSchema&quot;: False},
153      &quot;components/display/ssd1325&quot;: {&quot;_LoadSchema&quot;: False},
154      &quot;components/display/ssd1327&quot;: {&quot;_LoadSchema&quot;: False},
155      &quot;components/display/ssd1351&quot;: {&quot;_LoadSchema&quot;: False},
156      &quot;components/copy&quot;: {&quot;_LoadSchema&quot;: False},
157      &quot;components/display_menu/index&quot;: {
158          &quot;Display Menu&quot;: &quot;display_menu_base.schemas.DISPLAY_MENU_BASE_SCHEMA&quot;,
159          &quot;Select&quot;: &quot;display_menu_base.schemas.MENU_TYPES.schema.config_vars.items.types.select&quot;,
160          &quot;Menu&quot;: &quot;display_menu_base.schemas.MENU_TYPES.schema.config_vars.items.types.menu&quot;,
161          &quot;Number&quot;: &quot;display_menu_base.schemas.MENU_TYPES.schema.config_vars.items.types.number&quot;,
162          &quot;Switch&quot;: &quot;display_menu_base.schemas.MENU_TYPES.schema.config_vars.items.types.switch&quot;,
163          &quot;Custom&quot;: &quot;display_menu_base.schemas.MENU_TYPES.schema.config_vars.items.types.custom&quot;,
164      },
165      &quot;components/display_menu/lcd_menu&quot;: {
166          &quot;LCD Menu&quot;: &quot;lcd_menu.schemas.CONFIG_SCHEMA&quot;,
167      },
168      &quot;components/alarm_control_panel/index&quot;: {
169          &quot;Base Alarm Control Panel Configuration&quot;: &quot;template.alarm_control_panel.schemas.CONFIG_SCHEMA&quot;,
170      },
171  }
172  REQUIRED_OPTIONAL_TYPE_REGEX = r&quot;(\(((\*\*Required\*\*)|(\*Optional\*))(,\s(.*))*)\):\s&quot;
173  def get_node_title(node):
174      return list(node.traverse(nodes.title))[0].astext()
175  def read_file(fileName):
176      f = open(SCHEMA_PATH + fileName + &quot;.json&quot;, &quot;r&quot;, encoding=&quot;utf-8-sig&quot;)
177      str = f.read()
178      return json.loads(str)
179  def is_config_vars_title(title_text):
180      return title_text == CONFIGURATION_VARIABLES or title_text == CONFIGURATION_OPTIONS
181  class SchemaGeneratorVisitor(nodes.NodeVisitor):
182      def __init__(self, app, doctree, docname):
183          nodes.NodeVisitor.__init__(self, doctree)
184          self.app = app
185          self.doctree = doctree
186          self.docname = docname
187          self.path = docname.split(&quot;/&quot;)
188          self.json_component = None
189          self.props = None
190          self.platform = None
191          self.json_platform_component = None
192          self.title_id = None
193          self.props_section_title = None
194          self.find_registry = None
195          self.component = None
196          self.section_level = 0
197          self.file_schema = None
198          self.custom_doc = CUSTOM_DOCS.get(docname)
199          if self.path[0] == &quot;components&quot;:
200              if len(self.path) == 2:  # root component, e.g. dfplayer, logger
201                  self.component = docname[11:]
202                  if not self.custom_doc or self.custom_doc.get(&quot;_LoadSchema&quot;, True):
203                      self.file_schema = get_component_file(app, self.component)
204                      self.json_component = self.file_schema[self.component][&quot;schemas&quot;][
205                          &quot;CONFIG_SCHEMA&quot;
206                      ]
207              elif self.path[1] == &quot;display_menu&quot;:  # weird folder naming
208                  if self.path[2] == &quot;index&quot;:
209                      self.component = &quot;display_menu_base&quot;
210                  else:
211                      self.component = self.path[2]
212                      self.file_schema = get_component_file(app, self.component)
213                      self.json_component = self.file_schema[self.component][&quot;schemas&quot;][
214                          &quot;CONFIG_SCHEMA&quot;
215                      ]
216              else:  # sub component, e.g. output/esp8266_pwm
217                  self.platform = self.path[1]
218                  self.component = self.path[2]
219                  if self.component == &quot;ssd1331&quot;:
220                      self.component = &quot;ssd1331_spi&quot;
221                  if not self.custom_doc or self.custom_doc.get(&quot;_LoadSchema&quot;, True):
222                      if self.component == &quot;index&quot;:
223                          self.component = self.platform.replace(&quot; &quot;, &quot;_&quot;).lower()
224                          self.file_schema = get_component_file(app, self.component)
225                          self.json_component = self.file_schema[self.component][
226                              &quot;schemas&quot;
227                          ].get(self.component.upper() + &quot;_SCHEMA&quot;)
228                          pass
229                      else:
230                          self.json_component = get_component_file(app, self.component)
231                          self.json_platform_component = find_platform_component(
232                              app, self.platform, self.component
233                          )
234          self.previous_title_text = &quot;No title&quot;
235          self.is_component_hub = False
236          self.multi_component = None
237          self.prop_stack = []
238          self.current_prop = None
239          self.filled_props = False
240          self.accept_props = False
241          self.bullet_list_level = 0
242      def set_component_description(self, description, componentName, platformName=None):
243          if platformName is not None:
244              platform = get_component_file(self.app, platformName)
245              platform[platformName][&quot;components&quot;][componentName.lower()][
246                  &quot;docs&quot;
247              ] = description
248          else:
249              core = get_component_file(self.app, &quot;esphome&quot;)[&quot;core&quot;]
250              if componentName in core[&quot;components&quot;]:
251                  core[&quot;components&quot;][componentName][&quot;docs&quot;] = description
252              elif componentName in core[&quot;platforms&quot;]:
253                  core[&quot;platforms&quot;][componentName][&quot;docs&quot;] = description
254              else:
255                  if componentName != &quot;display_menu_base&quot;:
256                      raise ValueError(
257                          &quot;Cannot set description for component &quot; + componentName
258                      )
259      def visit_document(self, node):
260          if self.docname in [&quot;components/sensor/binary_sensor_map&quot;]:
261              raise nodes.SkipChildren
262          if self.docname in [&quot;components/climate/climate_ir&quot;]:
263              return
264          if len(list(node.traverse(nodes.paragraph))) == 0:
265              raise nodes.SkipChildren
266          self.props_section_title = get_node_title(node)
267          description = self.getMarkdownParagraph(node)
268          if self.json_platform_component:
269              self.set_component_description(description, self.component, self.platform)
270          elif self.json_component:
271              self.set_component_description(description, self.component)
272          if self.json_component or self.json_platform_component:
273              if is_component_file(
274                  self.app,
275                  self.component,
276              ):
277                  self.props = self.find_props(
278                      self.json_platform_component
279                      if self.json_platform_component
280                      else self.json_component,
281                      True,
282                  )
283      def visit_table(self, node):
284          if (
285              self.docname == &quot;components/climate/climate_ir&quot;
286              and len(CUSTOM_DOCS[&quot;components/climate/climate_ir&quot;][&quot;IR Remote Climate&quot;])
287              == 0
288          ):
289              table_rows = node[0][4]
290              for row in table_rows:
291                  components_paths = [
292                      components + &quot;.platform.climate.schemas.CONFIG_SCHEMA&quot;
293                      for components in row[1].astext().split(&quot;\n&quot;)
294                  ]
295                  CUSTOM_DOCS[&quot;components/climate/climate_ir&quot;][
296                      &quot;IR Remote Climate&quot;
297                  ] += components_paths
298      def depart_document(self, node):
299          pass
300      def visit_section(self, node):
301          self.section_level += 1
302          section_title = get_node_title(node)
303          if self.custom_doc and section_title in self.custom_doc:
304              r = self.custom_doc[section_title]
305              if &quot;.registry.&quot; in r:
306                  self.find_registry = r
307      def depart_section(self, node):
308          self.section_level -= 1
309          if self.section_level == 1:
310              self.find_registry = None
311      def unknown_visit(self, node):
312          pass
313      def unknown_departure(self, node):
314          pass
315      def visit_title(self, node):
316          title_text = node.astext()
317          if self.custom_doc is not None and title_text in self.custom_doc:
318              if isinstance(self.custom_doc[title_text], list):
319                  self.multi_component = self.custom_doc[title_text]
320                  self.filled_props = False
321                  self.props = None
322                  desc = self.getMarkdownParagraph(node.parent)
323                  for c in self.multi_component:
324                      if len(c.split(&quot;.&quot;)) == 2:
325                          self.set_component_description(desc, c.split(&quot;.&quot;)[0])
326                  return
327              json_component = self.find_component(self.custom_doc[title_text])
328              if not json_component:
329                  return
330              if self.json_component is None:
331                  self.json_component = json_component
332              parts = self.custom_doc[title_text].split(&quot;.&quot;)
333              if parts[0] not in [&quot;core&quot;, &quot;remote_base&quot;] and parts[-1] != &quot;pin&quot;:
334                  if parts[1] == &quot;platform&quot;:
335                      self.set_component_description(
336                          self.getMarkdownParagraph(node.parent), parts[0], parts[2]
337                      )
338                  else:
339                      self.set_component_description(
340                          self.getMarkdownParagraph(node.parent),
341                          parts[0],
342                      )
343              self.props_section_title = title_text
344              self.props = self.find_props(json_component)
345              return
346          elif title_text == COMPONENT_HUB:
347              self.props_section_title = f&quot;{self.path[-1]} {title_text}&quot;
348              json_component = self.get_component_schema(
349                  self.path[-1] + &quot;.CONFIG_SCHEMA&quot;
350              ).get(&quot;schema&quot;, {})
351              if json_component:
352                  self.props = self.find_props(json_component)
353                  self.set_component_description(
354                      self.getMarkdownParagraph(node.parent), self.path[-1]
355                  )
356              self.is_component_hub = True
357          elif is_config_vars_title(title_text):
358              if not self.props and self.multi_component is None:
359                  raise ValueError(
360                      f&#x27;Found a &quot;{title_text}&quot;: title after {self.previous_title_text}. Unknown object.&#x27;
361                  )
362          elif title_text == &quot;Over SPI&quot; or title_text == &quot;Over IÂ²C&quot;:
363              suffix = &quot;_spi&quot; if &quot;SPI&quot; in title_text else &quot;_i2c&quot;
364              component = self.path[-1] + suffix
365              self.props_section_title = self.path[-1] + &quot; &quot; + title_text
366              if self.platform is not None and not self.is_component_hub:
367                  json_platform_component = find_platform_component(
368                      self.app, self.platform, component
369                  )
370                  if not json_platform_component:
371                      raise ValueError(
372                          f&quot;Cannot find platform {self.platform} component &#x27;{component}&#x27; after found title: &#x27;{title_text}&#x27;.&quot;
373                      )
374                  self.props = self.find_props(json_platform_component)
375                  json_platform_component[&quot;docs&quot;] = self.getMarkdownParagraph(node.parent)
376              else:
377                  json_component = self.get_component_schema(
378                      component + &quot;.CONFIG_SCHEMA&quot;
379                  ).get(&quot;schema&quot;, {})
380                  if not json_component:
381                      raise ValueError(
382                          f&quot;Cannot find component &#x27;{component}&#x27; after found title: &#x27;{title_text}&#x27;.&quot;
383                      )
384                  self.props = self.find_props(json_component)
385                  self.set_component_description(
386                      self.getMarkdownParagraph(node.parent), component
387                  )
388          elif (
389              len(
390                  list(
391                      filter(
392                          lambda x: title_text.endswith(x), list(PLATFORMS_TITLES.keys())
393                      )
394                  )
395              )
396              &gt; 0
397          ):
398              if title_text in PLATFORMS_TITLES:
399                  platform_name = PLATFORMS_TITLES[title_text]
400                  if self.path[-1] == &quot;index&quot;:
401                      component_name = self.path[-2]
402                  else:
403                      component_name = self.path[-1]
404                  self.props_section_title = component_name + &quot; &quot; + title_text
405              else:
406                  for t in PLATFORMS_TITLES:
407                      if title_text.endswith(t):
408                          component_name = title_text[
409                              0 : len(title_text) - len(t) - 1
410                          ].replace(&quot; &quot;, &quot;_&quot;)
411                          platform_name = PLATFORMS_TITLES[t]
412                  if not platform_name:
413                      return
414                  self.props_section_title = title_text
415                  if not is_component_file(self.app, component_name):
416                      return
417              c = find_platform_component(self.app, platform_name, component_name.lower())
418              if c:
419                  self.json_platform_component = c
420                  self.set_component_description(
421                      self.getMarkdownParagraph(node.parent),
422                      component_name,
423                      platform_name,
424                  )
425              try:
426                  self.props = self.find_props(self.json_platform_component)
427              except KeyError:
428                  raise ValueError(&quot;Cannot find platform props&quot;)
429          elif title_text.endswith(&quot;Component&quot;) or title_text.endswith(&quot;Bus&quot;):
430              split_text = title_text.split(&quot; &quot;)
431              self.props_section_title = title_text
432              component_name = (
433                  &quot;_&quot;.join(split_text[:-1]).lower().replace(&quot;.&quot;, &quot;&quot;).replace(&quot;iÂ²c&quot;, &quot;i2c&quot;)
434              )
435              if component_name != self.platform and is_component_file(
436                  self.app, component_name
437              ):
438                  f = get_component_file(self.app, component_name)
439                  description = self.getMarkdownParagraph(node.parent)
440                  if component_name in f:
441                      self.set_component_description(description, component_name)
442                      c = f[component_name]
443                      if c:
444                          self.json_component = c[&quot;schemas&quot;][&quot;CONFIG_SCHEMA&quot;]
445                          try:
446                              self.props = self.find_props(self.json_component)
447                              self.multi_component = None
448                          except KeyError:
449                              raise ValueError(
450                                  &quot;Cannot find props for component &quot; + component_name
451                              )
452                          return
453                  elif f&quot;{component_name}.{self.path[1]}&quot; in f:
454                      self.set_component_description(
455                          description, component_name, self.path[1]
456                      )
457                      self.json_platform_component = f[
458                          f&quot;{component_name}.{self.path[1]}&quot;
459                      ][&quot;schemas&quot;][&quot;CONFIG_SCHEMA&quot;]
460                      try:
461                          self.props = self.find_props(self.json_platform_component)
462                      except KeyError:
463                          raise ValueError(
464                              f&quot;Cannot find props for platform {self.path[1]} component {self.component_name}&quot;
465                          )
466                      return
467          elif title_text.endswith(&quot;Trigger&quot;):
468              description = self.getMarkdownParagraph(node.parent)
469              split_text = title_text.split(&quot; &quot;)
470              if len(split_text) != 2:
471                  return
472              key = split_text[0]
473              if (
474                  not self.props or not self.props.typed
475              ):  # props are right for typed components so far
476                  c = self.json_component
477                  if c:
478                      if self.component in c:
479                          c = c[self.component][&quot;schemas&quot;][
480                              self.component.upper() + &quot;_SCHEMA&quot;
481                          ]
482                      trigger_schema = self.find_props(c).get(key)
483                      if trigger_schema is not None:
484                          self.props = self.find_props(trigger_schema)
485              self.props_section_title = title_text
486          elif title_text == PIN_CONFIGURATION_VARIABLES:
487              self.component = self.find_component(self.path[-1] + &quot;.pin&quot;)
488              self.props = self.find_props(self.component)
489              self.accept_props = True
490              if not self.component:
491                  raise ValueError(
492                      f&#x27;Found a &quot;{PIN_CONFIGURATION_VARIABLES}&quot; entry but could not find pin schema&#x27;
493                  )
494          elif title_text.endswith(&quot;Action&quot;) or title_text.endswith(&quot;Condition&quot;):
495              description = self.getMarkdownParagraph(node.parent)
496              split_text = title_text.split(&quot; &quot;)
497              if len(split_text) != 2:
498                  return
499              key = split_text[0]
500              component_parts = split_text[0].split(&quot;.&quot;)
501              if len(component_parts) == 3:
502                  try:
503                      cv = get_component_file(self.app, component_parts[1])[
504                          component_parts[1] + &quot;.&quot; + component_parts[0]
505                      ][split_text[1].lower()][component_parts[2]]
506                  except KeyError:
507                      logger.warn(
508                          f&quot;In {self.docname} cannot found schema of {title_text}&quot;
509                      )
510                      cv = None
511                  if cv is not None:
512                      cv[&quot;docs&quot;] = description
513                      self.props = self.find_props(cv.get(&quot;schema&quot;, {}))
514              elif len(component_parts) == 2:
515                  registry_name = &quot;.&quot;.join(
516                      [component_parts[0], &quot;registry&quot;, split_text[1].lower()]
517                  )
518                  key = component_parts[1]
519                  self.find_registry_prop(registry_name, key, description)
520              else:
521                  registry_name = f&quot;core.registry.{split_text[1].lower()}&quot;
522                  self.find_registry_prop(registry_name, key, description)
523          if self.section_level == 3 and self.find_registry:
524              name = title_text
525              if name.endswith(&quot; Effect&quot;):
526                  name = title_text[: -len(&quot; Effect&quot;)]
527              if name.endswith(&quot; Light&quot;):
528                  name = name[: -len(&quot; Light&quot;)]
529              key = name.replace(&quot; &quot;, &quot;_&quot;).replace(&quot;.&quot;, &quot;&quot;).lower()
530              description = self.getMarkdownParagraph(node.parent)
531              self.find_registry_prop(self.find_registry, key, description)
532              self.props_section_title = title_text
533      def get_component_schema(self, name):
534          parts = name.split(&quot;.&quot;)
535          schema_file = get_component_file(self.app, parts[0])
536          if parts[1] == &quot;registry&quot;:
537              schema = schema_file.get(parts[0], {}).get(parts[2], {})
538          elif len(parts) == 3:
539              schema = (
540                  schema_file.get(f&quot;{parts[0]}.{parts[1]}&quot;)
541                  .get(&quot;schemas&quot;, {})
542                  .get(parts[2], {})
543              )
544          else:
545              schema = schema_file.get(parts[0], {}).get(&quot;schemas&quot;, {}).get(parts[1], {})
546          return schema
547      def get_component_config_var(self, name, key):
548          c = self.get_component_schema(name)
549          if key in c:
550              return c[key]
551          if &quot;config_vars&quot; not in c:
552              return c
553          if key in c[&quot;config_vars&quot;]:
554              return c[&quot;config_vars&quot;][c]
555      def find_registry_prop(self, registry_name, key, description):
556          c = self.get_component_schema(registry_name)
557          if key in c:
558              cv = c[key]
559              if cv is not None:
560                  cv[&quot;docs&quot;] = description
561                  self.props = self.find_props(cv.get(&quot;schema&quot;, {}))
562      def depart_title(self, node):
563          if self.filled_props:
564              self.filled_props = False
565              self.props = None
566              self.current_prop = None
567              self.accept_props = False
568              self.multi_component = None
569          self.previous_title_text = node.astext()
570          self.title_id = node.parent[&quot;ids&quot;][0]
571      def find_props_previous_title(self):
572          comp = self.json_component or self.json_platform_component
573          if comp:
574              props = self.find_props(comp)
575              if self.previous_title_text in props:
576                  prop = props[self.previous_title_text]
577                  if prop:
578                      self.props = self.find_props(prop)
579                  else:
580                      self.props = {&quot;__&quot;: &quot;none&quot;}
581      def visit_Text(self, node):
582          if self.multi_component:
583              return
584          if is_config_vars_title(node.astext()):
585              if not self.props:
586                  self.find_props_previous_title()
587              if not self.props:
588                  raise ValueError(
589                      f&#x27;Found a &quot;{node.astext()}&quot; entry for unknown object after {self.previous_title_text}&#x27;
590                  )
591              self.accept_props = True
592          raise nodes.SkipChildren
593      def depart_Text(self, node):
594          pass
595      def visit_paragraph(self, node):
596          if is_config_vars_title(node.astext()):
597              if not self.props and not self.multi_component:
598                  self.find_props_previous_title()
599              if not self.props and not self.multi_component:
600                  logger.info(
601                      f&quot;In {self.docname} / {self.previous_title_text} found a {node.astext()} title and there are no props.&quot;
602                  )
603              self.accept_props = True
604          raise nodes.SkipChildren
605      def depart_paragraph(self, node):
606          pass
607      def visit_bullet_list(self, node):
608          self.bullet_list_level = self.bullet_list_level + 1
609          if (
610              self.current_prop
611              and (self.props or self.multi_component)
612              and self.bullet_list_level &gt; 1
613          ):
614              self.prop_stack.append((self.current_prop, node))
615              self.accept_props = True
616              return
617          if not self.props and self.multi_component is None:
618              raise nodes.SkipChildren
619      def depart_bullet_list(self, node):
620          self.bullet_list_level = self.bullet_list_level - 1
621          if len(self.prop_stack) &gt; 0:
622              stack_prop, stack_node = self.prop_stack[-1]
623              if stack_node == node:
624                  self.prop_stack.pop()
625                  self.filled_props = True
626                  self.current_prop = stack_prop
627      def visit_list_item(self, node):
628          if self.accept_props and self.props:
629              self.filled_props = True
630              self.current_prop, found = self.update_prop(node, self.props)
631              if self.current_prop and not found:
632                  logger.info(
633                      f&quot;In &#x27;{self.docname} {self.previous_title_text} Cannot find property {self.current_prop}&quot;
634                  )
635          elif self.multi_component:
636              found_any = False
637              self.current_prop = None
638              for c in self.multi_component:
639                  props = self.find_props(self.find_component(c))
640                  self.current_prop, found = self.update_prop(node, props)
641                  if self.current_prop and found:
642                      found_any = True
643              if self.current_prop and not found_any:
644                  logger.info(
645                      f&quot;In &#x27;{self.docname} {self.previous_title_text} Cannot find property {self.current_prop}&quot;
646                  )
647              self.filled_props = True
648      def depart_list_item(self, node):
649          pass
650      def visit_literal(self, node):
651          raise nodes.SkipChildren
652      def depart_literal(self, node):
653          pass
654      def getMarkdown(self, node):
655          from markdown import Translator
656          t = Translator(
657              urllib.parse.urljoin(self.app.config.html_baseurl, self.docname + &quot;.html&quot;),
658              self.doctree,
659          )
660          node.walkabout(t)
661          return t.output.strip(&quot;\n&quot;)
662      def getMarkdownParagraph(self, node):
663          paragraph = list(node.traverse(nodes.paragraph))[0]
664          markdown = self.getMarkdown(paragraph)
665          param_type = None
666          try:
667              name_type = markdown[: markdown.index(&quot;: &quot;) + 2]
668              ntr = re.search(
669                  REQUIRED_OPTIONAL_TYPE_REGEX,
670                  name_type,
671                  re.IGNORECASE,
672              )
673              if ntr:
674                  param_type = ntr.group(6)
675                  if param_type:
676                      markdown = (
677                          f&quot;**{param_type}**: {markdown[markdown.index(&#x27;: &#x27;) + 2 :]}&quot;
678                      )
679          except ValueError:
680              pass
681          title = list(node.traverse(nodes.title))[0]
682          if len(title) &gt; 0:
683              url = urllib.parse.urljoin(
684                  self.app.config.html_baseurl,
685                  self.docname + &quot;.html#&quot; + title.parent[&quot;ids&quot;][0],
686              )
687              if (
688                  self.props_section_title is not None
689                  and self.props_section_title.endswith(title.astext())
690              ):
691                  markdown += f&quot;\n\n*See also: [{self.props_section_title}]({url})*&quot;
692              else:
693                  markdown += f&quot;\n\n*See also: [{self.getMarkdown(title)}]({url})*&quot;
694          return markdown
695      def update_prop(self, node, props):
696          prop_name = None
697          for s_prop, n in self.prop_stack:
698              inner = props.get(s_prop)
699              if inner is not None and &quot;schema&quot; in inner:
700                  props = self.Props(self, inner[&quot;schema&quot;])
701              elif inner is not None and inner.get(&quot;type&quot;) == &quot;typed&quot;:
702                  props = self.Props(self, inner)
703              elif inner is not None and inner.get(&quot;type&quot;) == &quot;enum&quot;:
704                  enum_raw = self.getMarkdown(node)
705                  enum_match = re.search(
706                      r&quot;\* `([^`]*)`((:| -) (.*))*&quot;, enum_raw, re.IGNORECASE
707                  )
708                  if enum_match:
709                      enum_value = enum_match.group(1)
710                      enum_docs = enum_match.group(4)
711                      found = False
712                      for name in inner[&quot;values&quot;]:
713                          if enum_value.upper().replace(&quot; &quot;, &quot;_&quot;) == str(name).upper():
714                              found = True
715                              if enum_docs:
716                                  enum_docs = enum_docs.strip()
717                                  if inner[&quot;values&quot;][name] is None:
718                                      inner[&quot;values&quot;][name] = {&quot;docs&quot;: enum_docs}
719                                  else:
720                                      inner[&quot;values&quot;][name][&quot;docs&quot;] = enum_docs
721                                  statistics.props_documented += 1
722                                  statistics.enums_good += 1
723                      if not found:
724                          logger.info(
725                              f&quot;In &#x27;{self.docname} {self.previous_title_text} Property {s_prop} cannot find enum value {enum_value}&quot;
726                          )
727                  else:
728                      statistics.enums_bad += 1
729                      logger.info(
730                          f&quot;In &#x27;{self.docname} {self.previous_title_text} Property {s_prop} unexpected enum member description format&quot;
731                      )
732              else:
733                  return prop_name, False
734          raw = node.rawsource  # this has the full raw rst code for this property
735          if not raw.startswith(&quot;**&quot;):
736              return prop_name, False
737          markdown = self.getMarkdown(node)
738          markdown += f&quot;\n\n*See also: [{self.props_section_title}]({urllib.parse.urljoin(self.app.config.html_baseurl, self.docname +&#x27;.html#&#x27;+self.title_id)})*&quot;
739          try:
740              name_type = markdown[: markdown.index(&quot;: &quot;) + 2]
741          except ValueError:
742              logger.info(
743                  f&quot;In &#x27;{self.docname} {self.previous_title_text} Property format error. Missing &#x27;: &#x27; in {raw}&#x27;&quot;
744              )
745              return prop_name, False
746          PROP_NAME_REGEX = r&quot;\*\*(\w*(?:/\w*)*)\*\*&quot;
747          FULL_ITEM_PROP_NAME_TYPE_REGEX = (
748              r&quot;\* &quot; + PROP_NAME_REGEX + r&quot;\s&quot; + REQUIRED_OPTIONAL_TYPE_REGEX
749          )
750          ntr = re.search(
751              FULL_ITEM_PROP_NAME_TYPE_REGEX,
752              name_type,
753              re.IGNORECASE,
754          )
755          if ntr:
756              prop_name = ntr.group(1)
757              param_type = ntr.group(7)
758          else:
759              s2 = re.search(
760                  FULL_ITEM_PROP_NAME_TYPE_REGEX,
761                  markdown,
762                  re.IGNORECASE,
763              )
764              if s2:
765                  s3 = re.search(r&quot;\* &quot; + PROP_NAME_REGEX + r&quot;*:\s&quot;, name_type)
766                  if s3 is not None:
767                      prop_name = s3.group(1)
768                  else:
769                      logger.info(
770                          f&quot;In &#x27;{self.docname} {self.previous_title_text} Invalid list format: {node.rawsource}&quot;
771                      )
772                  param_type = None
773              else:
774                  logger.info(
775                      f&quot;In &#x27;{self.docname} {self.previous_title_text} Invalid property format: {node.rawsource}&quot;
776                  )
777                  return prop_name, False
778          prop_names = str(prop_name)
779          for k in prop_names.split(&quot;/&quot;):
780              config_var = props.get(k)
781              if not config_var:
782                  if k in [
783                      &quot;id&quot;,
784                      &quot;name&quot;,
785                      &quot;internal&quot;,
786                      &quot;address&quot;,
787                      &quot;i2c_id&quot;,
788                      &quot;update_interval&quot;,
789                      &quot;uart_id&quot;,
790                      &quot;effects&quot;,
791                      &quot;gamma_correct&quot;,
792                      &quot;default_transition_length&quot;,
793                      &quot;flash_transition_length&quot;,
794                      &quot;color_correct&quot;,
795                      &quot;lambda&quot;,
796                      &quot;pages&quot;,
797                      &quot;rotation&quot;,
798                      &quot;spi_id&quot;,
799                      &quot;cs_pin&quot;,
800                      &quot;inverted&quot;,
801                      &quot;power_supply&quot;,
802                      &quot;receiver_id&quot;,
803                  ]:
804                      config_var = props[k] = {}
805                  else:
806                      if self.path[1] == &quot;esphome&quot; and k in [
807                          &quot;platform&quot;,
808                          &quot;board&quot;,
809                          &quot;arduino_version&quot;,
810                          &quot;esp8266_restore_from_flash&quot;,
811                      ]:
812                          return prop_name, True
813                      return prop_name, False
814              desc = markdown[markdown.index(&quot;: &quot;) + 2 :].strip()
815              if param_type:
816                  desc = &quot;**&quot; + param_type + &quot;**: &quot; + desc
817              config_var[&quot;docs&quot;] = desc
818          statistics.props_documented += 1
819          return prop_name, True
820      def find_component(self, component_path):
821          path = component_path.split(&quot;.&quot;)
822          file_content = get_component_file(self.app, path[0])
823          if path[1] == &quot;platform&quot;:
824              path[2] = f&quot;{path[0]}.{path[2]}&quot;
825              path = path[2:]
826          component = file_content
827          for p in path:
828              component = component.get(p, {})
829          return component
830      class Props(MutableMapping):
831          def __init__(self, visitor, component, fail_silently=False):
832              self.visitor = visitor
833              self.component = component
834              self.store = self._get_props(component, fail_silently)
835              self.parent = None
836              self.typed = self.component.get(&quot;type&quot;) == &quot;typed&quot;
837          def _get_props(self, component, fail_silently):
838              if not (
839                  &quot;config_vars&quot; in component
840                  or &quot;extends&quot; in component
841                  or len(component) == 0
842                  or component.get(&quot;type&quot;) == &quot;typed&quot;
843              ):
844                  if fail_silently:
845                      return None
846                  raise ValueError(&quot;Unexpected component data to get props&quot;)
847              props = component.get(&quot;config_vars&quot;)
848              return props
849          def _find_extended(self, component, key):
850              for extended in component.get(&quot;extends&quot;, []):
851                  c = self.visitor.get_component_schema(extended)
852                  if c.get(&quot;type&quot;) == &quot;typed&quot;:
853                      p = self.visitor.Props(self.visitor, c)
854                      return p[key]
855                  schema = c.get(&quot;schema&quot;, {})
856                  for k, cv in schema.get(&quot;config_vars&quot;, {}).items():
857                      if k == key:
858                          return SetObservable(
859                              cv,
860                              setitem_callback=self._set_extended,
861                              inner_key=key,
862                              original_dict=schema.get(&quot;config_vars&quot;),
863                          )
864                  ex1 = self._find_extended(schema, key)
865                  if ex1:
866                      return ex1
867          def _set_extended(self, inner_key, original_dict, key, value):
868              original_dict[inner_key][key] = value
869          def _iter_extended(self, component):
870              for extended in component.get(&quot;extends&quot;, []):
871                  schema = self.visitor.get_component_schema(extended).get(&quot;schema&quot;, {})
872                  for s in self._iter_extended(schema):
873                      yield s
874                  yield schema
875          def __getitem__(self, key):
876              if self.store and key in self.store:
877                  return self.store[key]
878              extended = self._find_extended(self.component, key)
879              if extended is not None:
880                  return extended
881              if self.component.get(&quot;type&quot;) == &quot;typed&quot;:
882                  return SetObservable(
883                      {key: {&quot;type&quot;: &quot;string&quot;}},
884                      setitem_callback=self._set_typed,
885                      inner_key=key,
886                      original_dict={},
887                  )
888          def _set_typed(self, inner_key, original_dict, key, value):
889              if inner_key == self.component.get(&quot;typed_key&quot;, &quot;type&quot;):
890                  self.component[key] = value
891              else:
892                  for tk, tv in self.component[&quot;types&quot;].items():
893                      for cv_k, cv_v in tv[&quot;config_vars&quot;].items():
894                          if cv_k == inner_key:
895                              cv_v[key] = value
896          def __setitem__(self, key, value):
897              self.store[key] = value
898          def __delitem__(self, key):
899              self.store.pop(key)
900          def __iter__(self):
901              return iter(self.store)
902          def __len__(self):
903              len_extended = 0
904              if self.component.get(&quot;type&quot;):
905                  types = self.component.get(&quot;types&quot;)
906                  for t, tv in types.items():
907                      for s in self._iter_extended(types.get(t, {})):
908                          len_extended += len(s.get(&quot;config_vars&quot;, {}))
909                      len_extended += len(tv.get(&quot;config_vars&quot;, {}))
910                  return len_extended
911              for s in self._iter_extended(self.component):
912                  len_extended += len(s.get(&quot;config_vars&quot;, {}))
913              return len_extended + (len(self.store) if self.store else 0)
914      def find_props(self, component, fail_silently=False):
915          if component.get(&quot;type&quot;) in [&quot;trigger&quot;, &quot;schema&quot;]:
916              if &quot;schema&quot; not in component:
917                  return None
918              component = component.get(&quot;schema&quot;)
919          props = self.Props(self, component, fail_silently)
920          if props:
921              self.filled_props = False
922              self.accept_props = False
923              self.current_prop = None
924          return props
925  def handle_component(app, doctree, docname):
926      path = docname.split(&quot;/&quot;)
927      if path[0] == &quot;components&quot;:
928          pass
929      elif docname not in CUSTOM_DOCS:
930          return
931      try:
932          v = SchemaGeneratorVisitor(app, doctree, docname)
933          doctree.walkabout(v)
934      except Exception as e:
935          err_str = f&quot;In {docname}.rst: {str(e)}&quot;
936          logger.warning(err_str)
937  def build_finished(app, exception):
938      for fname, contents in app.files.items():
939          f = open(SCHEMA_PATH + fname + &quot;.json&quot;, &quot;w&quot;, newline=&quot;\n&quot;)
940          if JSON_DUMP_PRETTY:
941              f.write(json.dumps(contents, indent=2))
942          else:
943              f.write(json.dumps(contents, separators=(&quot;,&quot;, &quot;:&quot;)))
944      str = f&quot;Documented: {statistics.props_documented} Enums: {statistics.enums_good}/{statistics.enums_bad}&quot;
945      logger.info(str)
946  class SetObservable(dict):
947      def __init__(
948          self,
949          value,
950          setitem_callback=None,
951          inner_key=None,
952          original_dict=None,
953          *args,
954          **kwargs,
955      ):
956          super(SetObservable, self).__init__(value, *args, **kwargs)
957          self._setitem_callback = setitem_callback
958          self.inner_key = inner_key
959          self.original_dict = original_dict
960      def __setitem__(self, key, value):
961          if self._setitem_callback:
962              self._setitem_callback(self.inner_key, self.original_dict, key, value)
963          super(SetObservable, self).__setitem__(key, value)
964  def is_component_file(app: SchemaGeneratorVisitor, component):
965      if component == &quot;core&quot; or component == &quot;automation&quot;:
966          component = &quot;esphome&quot;
967      return exists(SCHEMA_PATH + component + &quot;.json&quot;)
968  def get_component_file(app: SchemaGeneratorVisitor, component):
969      if component == &quot;core&quot; or component == &quot;automation&quot;:
970          component = &quot;esphome&quot;
971      if component not in app.files:
972          app.files[component] = read_file(component)
973      return app.files[component]
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esphome-docs-MDEwOlJlcG9zaXRvcnkxMzMyMjM0NjE=-flat-schema_doc.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esphome-docs-MDEwOlJlcG9zaXRvcnkxMzMyMjM0NjE=-flat-schema_doc.py</div>
                </div>
                <div class="column column_space"><pre><code>91          &quot;_LoadSchema&quot;: False,
92          &quot;Clockless&quot;: &quot;fastled_clockless.platform.light.schemas.CONFIG_SCHEMA&quot;,
93          &quot;SPI&quot;: &quot;fastled_spi.platform.light.schemas.CONFIG_SCHEMA&quot;,
94      },
</pre></code></div>
                <div class="column column_space"><pre><code>116          &quot;_LoadSchema&quot;: False,
117          &quot;Base Time Configuration&quot;: &quot;time.schemas.TIME_SCHEMA&quot;,
118          &quot;on_time Trigger&quot;: &quot;time.schemas.TIME_SCHEMA.schema.config_vars.on_time.schema&quot;,
119          &quot;Home Assistant Time Source&quot;: &quot;homeassistant.platform.time.schemas.CONFIG_SCHEMA&quot;,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    