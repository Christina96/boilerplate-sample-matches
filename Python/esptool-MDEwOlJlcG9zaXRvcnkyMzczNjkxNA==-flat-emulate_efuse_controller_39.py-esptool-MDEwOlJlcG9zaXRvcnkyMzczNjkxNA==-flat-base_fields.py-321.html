
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-emulate_efuse_controller_39.py</h3>
            <pre><code>1  from bitstring import BitStream
2  import reedsolo
3  from .mem_definition import EfuseDefineBlocks, EfuseDefineFields, EfuseDefineRegisters
4  from ..emulate_efuse_controller_base import EmulateEfuseControllerBase, FatalError
5  class EmulateEfuseController(EmulateEfuseControllerBase):
6      CHIP_NAME = &quot;ESP32-C2&quot;
7      mem = None
8      debug = False
9      def __init__(self, efuse_file=None, debug=False):
10          self.Blocks = EfuseDefineBlocks
11          self.Fields = EfuseDefineFields()
12          self.REGS = EfuseDefineRegisters
13          super(EmulateEfuseController, self).__init__(efuse_file, debug)
14          self.write_reg(self.REGS.EFUSE_STATUS_REG, 1)
15      def get_major_chip_version(self):
16          return 1
17      def get_minor_chip_version(self):
18          return 0
19      def get_crystal_freq(self):
20          return 40  # MHz
21      def get_security_info(self):
22          return {
23              &quot;flags&quot;: 0,
24              &quot;flash_crypt_cnt&quot;: 0,
25              &quot;key_purposes&quot;: 0,
26              &quot;chip_id&quot;: 0,
27              &quot;api_version&quot;: 0,
28          }
29      def handle_writing_event(self, addr, value):
30          if addr == self.REGS.EFUSE_CMD_REG:
31              if value &amp; self.REGS.EFUSE_PGM_CMD:
32                  self.copy_blocks_wr_regs_to_rd_regs(updated_block=(value &gt;&gt; 2) &amp; 0xF)
33                  self.clean_blocks_wr_regs()
34                  self.check_rd_protection_area()
35                  self.write_reg(addr, 0)
36                  self.write_reg(self.REGS.EFUSE_STATUS_REG, 1)
37              elif value == self.REGS.EFUSE_READ_CMD:
38                  self.write_reg(addr, 0)
39                  self.write_reg(self.REGS.EFUSE_STATUS_REG, 1)
40                  self.save_to_file()
41      def get_bitlen_of_block(self, blk, wr=False):
42          if blk.id == 0:
43              if wr:
44                  return 32 * 8
45              else:
46                  return 32 * blk.len
47          else:
48              if wr:
49                  rs_coding = 32 * 3
50                  return 32 * 8 + rs_coding
51              else:
52                  return 32 * blk.len
53      def handle_coding_scheme(self, blk, data):
54          if blk.id != 0:
55              coded_bytes = 12
56              data.pos = coded_bytes * 8
57              plain_data = data.readlist(&quot;32*uint:8&quot;)[::-1]
58              rs = reedsolo.RSCodec(coded_bytes)
59              calc_encoded_data = list(rs.encode([x for x in plain_data]))
60              data.pos = 0
61              if calc_encoded_data != data.readlist(&quot;44*uint:8&quot;)[::-1]:
62                  raise FatalError(&quot;Error in coding scheme data&quot;)
63              data = data[coded_bytes * 8 :]
64          if blk.len &lt; 8:
65              data = data[(8 - blk.len) * 32 :]
66          return data
67      def check_rd_protection_area(self):
68          def get_read_disable_mask(blk):
69              mask = 0
70              if isinstance(blk.read_disable_bit, list):
71                  for i in blk.read_disable_bit:
72                      mask |= 1 &lt;&lt; i
73              else:
74                  mask = 1 &lt;&lt; blk.read_disable_bit
75              return mask
76          read_disable_bit = self.read_field(&quot;RD_DIS&quot;, bitstring=False)
77          for b in self.Blocks.BLOCKS:
78              blk = self.Blocks.get(b)
79              block = self.read_block(blk.id)
80              if (
81                  blk.read_disable_bit is not None
82                  and read_disable_bit &amp; get_read_disable_mask(blk)
83              ):
84                  if isinstance(blk.read_disable_bit, list):
85                      if read_disable_bit &amp; (1 &lt;&lt; blk.read_disable_bit[0]):
86                          block.set(
87                              0, [i for i in range(blk.len * 32 // 2, blk.len * 32)]
88                          )
89                      if read_disable_bit &amp; (1 &lt;&lt; blk.read_disable_bit[1]):
90                          block.set(0, [i for i in range(0, blk.len * 32 // 2)])
91                  else:
92                      block.set(0)
93              else:
94                  for field in self.Fields.EFUSES:
95                      if (
96                          blk.id == field.block
97                          and field.read_disable_bit is not None
98                          and read_disable_bit &amp; get_read_disable_mask(field)
99                      ):
100                          raw_data = self.read_field(field.name)
101                          raw_data.set(0)
102                          block.pos = block.length - (
<span onclick='openModal()' class='match'>103                              field.word * 32 + field.pos + raw_data.length
104                          )
105                          block.overwrite(BitStream(raw_data.length))
</span>106              self.overwrite_mem_from_block(blk, block)
</code></pre>
        </div>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-base_fields.py</h3>
            <pre><code>1  import binascii
2  import sys
3  from bitstring import BitArray, BitStream, CreationError
4  import esptool
5  from . import util
6  class CheckArgValue(object):
7      def __init__(self, efuses, name):
8          self.efuses = efuses
9          self.name = name
10      def __call__(self, new_value_str):
11          def check_arg_value(efuse, new_value):
12              if efuse.efuse_type.startswith(&quot;bool&quot;):
13                  new_value = 1 if new_value is None else int(new_value, 0)
14                  if new_value != 1:
15                      raise esptool.FatalError(
16                          &quot;New value is not accepted for efuse &#x27;{}&#x27; &quot;
17                          &quot;(will always burn 0-&gt;1), given value={}&quot;.format(
18                              efuse.name, new_value
19                          )
20                      )
21              elif efuse.efuse_type.startswith((&quot;int&quot;, &quot;uint&quot;)):
22                  if efuse.efuse_class == &quot;bitcount&quot;:
23                      if new_value is None:
24                          old_value = efuse.get_raw()
25                          new_value = old_value
26                          bit = 1
27                          while new_value == old_value:
28                              new_value = bit | old_value
29                              bit &lt;&lt;= 1
30                      else:
31                          new_value = int(new_value, 0)
32                  else:
33                      if new_value is None:
34                          raise esptool.FatalError(
35                              &quot;New value required for efuse &#x27;{}&#x27; (given None)&quot;.format(
36                                  efuse.name
37                              )
38                          )
39                      new_value = int(new_value, 0)
40                      if new_value == 0:
41                          raise esptool.FatalError(
42                              &quot;New value should not be 0 for &#x27;{}&#x27; &quot;
43                              &quot;(given value= {})&quot;.format(efuse.name, new_value)
44                          )
45              elif efuse.efuse_type.startswith(&quot;bytes&quot;):
46                  if new_value is None:
47                      raise esptool.FatalError(
48                          &quot;New value required for efuse &#x27;{}&#x27; &quot;
49                          &quot;(given None)&quot;.format(efuse.name)
50                      )
51                  if len(new_value) * 8 != efuse.bitarray.len:
52                      raise esptool.FatalError(
53                          &quot;The length of efuse &#x27;{}&#x27; ({} bits) &quot;
54                          &quot;(given len of the new value= {} bits)&quot;.format(
55                              efuse.name, efuse.bitarray.len, len(new_value) * 8
56                          )
57                      )
58              else:
59                  raise esptool.FatalError(
60                      &quot;The &#x27;{}&#x27; type for the &#x27;{}&#x27; efuse is not supported yet.&quot;.format(
61                          efuse.efuse_type, efuse.name
62                      )
63                  )
64              return new_value
65          efuse = self.efuses[self.name]
66          new_value = efuse.check_format(new_value_str)
67          return check_arg_value(efuse, new_value)
68  class EfuseProtectBase(object):
69      def get_read_disable_mask(self, blk_part=None):
70          mask = 0
71          if isinstance(self.read_disable_bit, list):
72              if blk_part is None:
73                  for i in self.read_disable_bit:
74                      mask |= 1 &lt;&lt; i
75              else:
76                  mask |= 1 &lt;&lt; self.read_disable_bit[blk_part]
77          else:
78              mask = 1 &lt;&lt; self.read_disable_bit
79          return mask
80      def get_count_read_disable_bits(self):
81          return bin(self.get_read_disable_mask()).count(&quot;1&quot;)
82      def is_readable(self, blk_part=None):
83          num_bit = self.read_disable_bit
84          if num_bit is None:
85              return True  # read cannot be disabled
86          return (self.parent[&quot;RD_DIS&quot;].get() &amp; self.get_read_disable_mask(blk_part)) == 0
87      def disable_read(self):
88          num_bit = self.read_disable_bit
89          if num_bit is None:
90              raise esptool.FatalError(&quot;This efuse cannot be read-disabled&quot;)
91          if not self.parent[&quot;RD_DIS&quot;].is_writeable():
92              raise esptool.FatalError(
93                  &quot;This efuse cannot be read-disabled due the to RD_DIS field is &quot;
94                  &quot;already write-disabled&quot;
95              )
96          self.parent[&quot;RD_DIS&quot;].save(self.get_read_disable_mask())
97      def is_writeable(self):
98          num_bit = self.write_disable_bit
99          if num_bit is None:
100              return True  # write cannot be disabled
101          return (self.parent[&quot;WR_DIS&quot;].get() &amp; (1 &lt;&lt; num_bit)) == 0
102      def disable_write(self):
103          num_bit = self.write_disable_bit
104          if not self.parent[&quot;WR_DIS&quot;].is_writeable():
105              raise esptool.FatalError(
106                  &quot;This efuse cannot be write-disabled due to the WR_DIS field is &quot;
107                  &quot;already write-disabled&quot;
108              )
109          self.parent[&quot;WR_DIS&quot;].save(1 &lt;&lt; num_bit)
110      def check_wr_rd_protect(self):
111          if not self.is_readable():
112              error_msg = &quot;\t{} is read-protected.&quot;.format(self.name)
113              &quot;The written value can not be read, the efuse/block looks as all 0.\n&quot;
114              error_msg += &quot;\tBurn in this case may damage an already written value.&quot;
115              self.parent.print_error_msg(error_msg)
116          if not self.is_writeable():
117              error_msg = &quot;\t{} is write-protected. Burn is not possible.&quot;.format(
118                  self.name
119              )
120              self.parent.print_error_msg(error_msg)
121  class EfuseBlockBase(EfuseProtectBase):
122      def __init__(self, parent, param, skip_read=False):
123          self.parent = parent
124          self.name = param.name
125          self.alias = param.alias
126          self.id = param.id
127          self.rd_addr = param.rd_addr
128          self.wr_addr = param.wr_addr
129          self.write_disable_bit = param.write_disable_bit
130          self.read_disable_bit = param.read_disable_bit
131          self.len = param.len
132          self.key_purpose_name = param.key_purpose
133          bit_block_len = self.get_block_len() * 8
134          self.bitarray = BitStream(bit_block_len)
135          self.bitarray.set(0)
136          self.wr_bitarray = BitStream(bit_block_len)
137          self.wr_bitarray.set(0)
138          self.fail = False
139          self.num_errors = 0
140          if self.id == 0:
141              self.err_bitarray = BitStream(bit_block_len)
142              self.err_bitarray.set(0)
143          else:
144              self.err_bitarray = None
145          if not skip_read:
146              self.read()
147      def get_block_len(self):
148          coding_scheme = self.get_coding_scheme()
149          if coding_scheme == self.parent.REGS.CODING_SCHEME_NONE:
150              return self.len * 4
151          elif coding_scheme == self.parent.REGS.CODING_SCHEME_34:
152              return (self.len * 3 // 4) * 4
153          elif coding_scheme == self.parent.REGS.CODING_SCHEME_RS:
154              return self.len * 4
155          else:
156              raise esptool.FatalError(
157                  &quot;Coding scheme (%d) not supported&quot; % (coding_scheme)
158              )
159      def get_coding_scheme(self):
160          if self.id == 0:
161              return self.parent.REGS.CODING_SCHEME_NONE
162          else:
163              return self.parent.coding_scheme
164      def get_raw(self, from_read=True):
165          if from_read:
166              return self.bitarray.bytes
167          else:
168              return self.wr_bitarray.bytes
169      def get(self, from_read=True):
170          self.get_bitstring(from_read=from_read)
171      def get_bitstring(self, from_read=True):
172          if from_read:
173              return self.bitarray
174          else:
175              return self.wr_bitarray
176      def convert_to_bitstring(self, new_data):
177          if isinstance(new_data, BitArray):
178              return new_data
179          else:
180              return BitArray(bytes=new_data, length=len(new_data) * 8)
181      def get_words(self):
182          def get_offsets(self):
183              return [x + self.rd_addr for x in range(0, self.get_block_len(), 4)]
184          return [self.parent.read_reg(offs) for offs in get_offsets(self)]
185      def read(self):
186          words = self.get_words()
187          data = BitArray()
188          for word in reversed(words):
189              data.append(&quot;uint:32=%d&quot; % word)
190          self.bitarray.overwrite(data, pos=0)
191          self.print_block(self.bitarray, &quot;read_regs&quot;)
192      def print_block(self, bit_string, comment, debug=False):
193          if self.parent.debug or debug:
194              bit_string.pos = 0
195              print(
196                  &quot;%-15s (%-16s) [%-2d] %s:&quot;
197                  % (self.name, &quot; &quot;.join(self.alias)[:16], self.id, comment),
198                  &quot; &quot;.join(
199                      [
200                          &quot;%08x&quot; % word
201                          for word in bit_string.readlist(
202                              &quot;%d*uint:32&quot; % (bit_string.len / 32)
203                          )[::-1]
204                      ]
205                  ),
206              )
207      def check_wr_data(self):
208          wr_data = self.wr_bitarray
209          if wr_data.all(False):
210              if self.parent.debug:
211                  print(&quot;[{:02}] {:20} nothing to burn&quot;.format(self.id, self.name))
212              return False
213          if len(wr_data.bytes) != len(self.bitarray.bytes):
214              raise esptool.FatalError(
215                  &quot;Data does not fit: the block%d size is %d bytes, data is %d bytes&quot;
216                  % (self.id, len(self.bitarray.bytes), len(wr_data.bytes))
217              )
218          self.check_wr_rd_protect()
219          if self.get_bitstring().all(False):
220              print(
221                  &quot;[{:02}] {:20} is empty, will burn the new value&quot;.format(
222                      self.id, self.name
223                  )
224              )
225          else:
226              if self.get_bitstring() == wr_data:
227                  print(
228                      &quot;[{:02}] {:20} is already written the same value, &quot;
229                      &quot;continue with EMPTY_BLOCK&quot;.format(self.id, self.name)
230                  )
231                  wr_data.set(0)
232              else:
233                  print(&quot;[{:02}] {:20} is not empty&quot;.format(self.id, self.name))
234                  print(&quot;\t(written ):&quot;, self.get_bitstring())
235                  print(&quot;\t(to write):&quot;, wr_data)
236                  mask = self.get_bitstring() &amp; wr_data
237                  if mask == wr_data:
238                      print(
239                          &quot;\tAll wr_data bits are set in the written block, &quot;
240                          &quot;continue with EMPTY_BLOCK.&quot;
241                      )
242                      wr_data.set(0)
243                  else:
244                      coding_scheme = self.get_coding_scheme()
245                      if coding_scheme == self.parent.REGS.CODING_SCHEME_NONE:
246                          print(&quot;\t(coding scheme = NONE)&quot;)
247                      elif coding_scheme == self.parent.REGS.CODING_SCHEME_RS:
248                          print(&quot;\t(coding scheme = RS)&quot;)
249                          error_msg = (
250                              &quot;\tBurn into %s is forbidden &quot;
251                              &quot;(RS coding scheme does not allow this).&quot; % (self.name)
252                          )
253                          self.parent.print_error_msg(error_msg)
254                      elif coding_scheme == self.parent.REGS.CODING_SCHEME_34:
255                          print(&quot;\t(coding scheme = 3/4)&quot;)
256                          data_can_not_be_burn = False
257                          for i in range(0, self.get_bitstring().len, 6 * 8):
258                              rd_chunk = self.get_bitstring()[i : i + 6 * 8 :]
259                              wr_chunk = wr_data[i : i + 6 * 8 :]
260                              if rd_chunk.any(True):
261                                  if wr_chunk.any(True):
262                                      print(
263                                          &quot;\twritten chunk [%d] and wr_chunk &quot;
264                                          &quot;are not empty. &quot; % (i // (6 * 8)),
265                                          end=&quot;&quot;,
266                                      )
267                                      if rd_chunk == wr_chunk:
268                                          print(
269                                              &quot;wr_chunk == rd_chunk. &quot;
270                                              &quot;Countinue with empty chunk.&quot;
271                                          )
272                                          wr_data[i : i + 6 * 8 :].set(0)
273                                      else:
274                                          print(&quot;wr_chunk != rd_chunk. Can not burn.&quot;)
275                                          print(&quot;\twritten &quot;, rd_chunk)
276                                          print(&quot;\tto write&quot;, wr_chunk)
277                                          data_can_not_be_burn = True
278                          if data_can_not_be_burn:
279                              error_msg = (
280                                  &quot;\tBurn into %s is forbidden &quot;
281                                  &quot;(3/4 coding scheme does not allow this).&quot; % (self.name)
282                              )
283                              self.parent.print_error_msg(error_msg)
284                      else:
285                          raise esptool.FatalError(
286                              &quot;The coding scheme ({}) is not supported&quot;.format(
287                                  coding_scheme
288                              )
289                          )
290      def save(self, new_data):
291          data = BitStream(bytes=new_data[::-1], length=len(new_data) * 8)
292          if self.parent.debug:
293              print(
294                  &quot;\twritten : {} -&gt;\n\tto write: {}&quot;.format(self.get_bitstring(), data)
295              )
296          self.wr_bitarray.overwrite(self.wr_bitarray | data, pos=0)
297      def burn_words(self, words):
298          for burns in range(3):
299              self.parent.efuse_controller_setup()
300              if self.parent.debug:
301                  print(&quot;Write data to BLOCK%d&quot; % (self.id))
302              write_reg_addr = self.wr_addr
303              for word in words:
304                  if self.parent.debug:
305                      print(&quot;Addr 0x%08x, data=0x%08x&quot; % (write_reg_addr, word))
306                  self.parent.write_reg(write_reg_addr, word)
307                  write_reg_addr += 4
308              self.parent.write_efuses(self.id)
309              for _ in range(5):
310                  self.parent.efuse_read()
311                  self.parent.get_coding_scheme_warnings(silent=True)
312                  if self.fail or self.num_errors:
313                      print(
314                          &quot;Error in BLOCK%d, re-burn it again (#%d), to fix it. &quot;
315                          &quot;fail_bit=%d, num_errors=%d&quot;
316                          % (self.id, burns, self.fail, self.num_errors)
317                      )
318                      break
319              if not self.fail and self.num_errors == 0:
320                  break
321      def burn(self):
322          if self.wr_bitarray.all(False):
323              return
324          before_burn_bitarray = self.bitarray[:]
325          assert before_burn_bitarray is not self.bitarray
326          self.print_block(self.wr_bitarray, &quot;to_write&quot;)
327          words = self.apply_coding_scheme()
328          self.burn_words(words)
329          self.read()
330          if not self.is_readable():
331              print(
332                  &quot;{} ({}) is read-protected. &quot;
333                  &quot;Read back the burn value is not possible.&quot;.format(
334                      self.name, self.alias
335                  )
336              )
337              if self.bitarray.all(False):
338                  print(&quot;Read all &#x27;0&#x27;&quot;)
339              else:
340                  raise esptool.FatalError(
341                      &quot;The {} is read-protected but not all &#x27;0&#x27; ({})&quot;.format(
342                          self.name, self.bitarray.hex
343                      )
344                  )
345          else:
346              if self.wr_bitarray == self.bitarray:
347                  print(&quot;BURN BLOCK%-2d - OK (write block == read block)&quot; % self.id)
348              elif (
349                  self.wr_bitarray &amp; self.bitarray == self.wr_bitarray
350                  and self.bitarray &amp; before_burn_bitarray == before_burn_bitarray
351              ):
352                  print(&quot;BURN BLOCK%-2d - OK (all write block bits are set)&quot; % self.id)
353              else:
354                  self.print_block(self.wr_bitarray, &quot;Expected&quot;)
355                  self.print_block(self.bitarray, &quot;Real    &quot;)
356                  if self.id != 0:
357                      raise esptool.FatalError(
358                          &quot;Burn {} ({}) was not successful&quot;.format(self.name, self.alias)
359                      )
360          self.wr_bitarray.set(0)
361  class EspEfusesBase(object):
362      _esp = None
363      blocks = []
364      efuses = []
365      coding_scheme = None
366      force_write_always = None
367      batch_mode_cnt = 0
368      def __iter__(self):
369          return self.efuses.__iter__()
370      def get_crystal_freq(self):
371          return self._esp.get_crystal_freq()
372      def read_efuse(self, n):
373          return self._esp.read_efuse(n)
374      def read_reg(self, addr):
375          return self._esp.read_reg(addr)
376      def write_reg(self, addr, value, mask=0xFFFFFFFF, delay_us=0, delay_after_us=0):
377          return self._esp.write_reg(addr, value, mask, delay_us, delay_after_us)
378      def update_reg(self, addr, mask, new_val):
379          return self._esp.update_reg(addr, mask, new_val)
380      def efuse_controller_setup(self):
381          pass
382      def reconnect_chip(self, esp):
383          print(&quot;Re-connecting...&quot;)
384          baudrate = esp._port.baudrate
385          port = esp._port.port
386          esp._port.close()
387          return esptool.cmds.detect_chip(port, baudrate)
388      def get_index_block_by_name(self, name):
389          for block in self.blocks:
390              if block.name == name or name in block.alias:
391                  return block.id
392          return None
393      def read_blocks(self):
394          for block in self.blocks:
395              block.read()
396      def update_efuses(self):
397          for efuse in self.efuses:
398              efuse.update(self.blocks[efuse.block].bitarray)
399      def burn_all(self, check_batch_mode=False):
400          if check_batch_mode:
401              if self.batch_mode_cnt != 0:
402                  print(
403                      &quot;\nBatch mode is enabled, &quot;
404                      &quot;the burn will be done at the end of the command.&quot;
405                  )
406                  return False
407          print(&quot;\nCheck all blocks for burn...&quot;)
408          print(&quot;idx, BLOCK_NAME,          Conclusion&quot;)
409          have_wr_data_for_burn = False
410          for block in self.blocks:
411              block.check_wr_data()
412              if not have_wr_data_for_burn and block.get_bitstring(from_read=False).any(
413                  True
414              ):
415                  have_wr_data_for_burn = True
416          if not have_wr_data_for_burn:
417              print(&quot;Nothing to burn, see messages above.&quot;)
418              return
419          EspEfusesBase.confirm(&quot;&quot;, self.do_not_confirm)
420          for block in reversed(self.blocks):
421              old_fail = block.fail
422              old_num_errors = block.num_errors
423              block.burn()
424              if (block.fail and old_fail != block.fail) or (
425                  block.num_errors and block.num_errors &gt; old_num_errors
426              ):
427                  raise esptool.FatalError(&quot;Error(s) were detected in eFuses&quot;)
428          print(&quot;Reading updated efuses...&quot;)
429          self.read_coding_scheme()
430          self.read_blocks()
431          self.update_efuses()
432          return True
433      @staticmethod
434      def confirm(action, do_not_confirm):
435          print(
436              &quot;%s%s\nThis is an irreversible operation!&quot;
437              % (action, &quot;&quot; if action.endswith(&quot;\n&quot;) else &quot;. &quot;)
438          )
439          if not do_not_confirm:
440              print(&quot;Type &#x27;BURN&#x27; (all capitals) to continue.&quot;)
441              sys.stdout.flush()
442              yes = input()
443              if yes != &quot;BURN&quot;:
444                  print(&quot;Aborting.&quot;)
445                  sys.exit(0)
446      def print_error_msg(self, error_msg):
447          if self.force_write_always is not None:
448              if not self.force_write_always:
449                  error_msg += &quot;(use &#x27;--force-write-always&#x27; option to ignore it)&quot;
450          if self.force_write_always:
451              print(error_msg, &quot;Skipped because &#x27;--force-write-always&#x27; option.&quot;)
452          else:
453              raise esptool.FatalError(error_msg)
454      def get_block_errors(self, block_num):
455          return self.blocks[block_num].num_errors, self.blocks[block_num].fail
456  class EfuseFieldBase(EfuseProtectBase):
457      def __init__(self, parent, param):
458          self.category = param.category
459          self.parent = parent
460          self.block = param.block
461          self.word = param.word
462          self.pos = param.pos
463          self.write_disable_bit = param.write_disable_bit
464          self.read_disable_bit = param.read_disable_bit
465          self.name = param.name
466          self.efuse_class = param.class_type
467          self.efuse_type = param.type
468          self.description = param.description
469          self.dict_value = param.dictionary
470          self.bit_len = param.bit_len
471          self.alt_names = param.alt_names
472          self.fail = False
473          self.num_errors = 0
474          self.bitarray = BitStream(self.bit_len)
475          self.bitarray.set(0)
476          self.update(self.parent.blocks[self.block].bitarray)
477      def is_field_calculated(self):
478          return self.word is None or self.pos is None
479      def check_format(self, new_value_str):
480          if new_value_str is None:
481              return new_value_str
482          else:
483              if self.efuse_type.startswith(&quot;bytes&quot;):
484                  if new_value_str.startswith(&quot;0x&quot;):
485                      return binascii.unhexlify(new_value_str[2:])[::-1]
486                  else:
487                      return binascii.unhexlify(new_value_str)
488              else:
489                  return new_value_str
490      def convert_to_bitstring(self, new_value):
491          if isinstance(new_value, BitArray):
492              return new_value
493          else:
494              if self.efuse_type.startswith(&quot;bytes&quot;):
495                  return BitArray(bytes=new_value[::-1], length=len(new_value) * 8)
496              else:
497                  try:
498                      return BitArray(self.efuse_type + &quot;={}&quot;.format(new_value))
499                  except CreationError as err:
500                      print(
501                          &quot;New value &#x27;{}&#x27; is not suitable for {} ({})&quot;.format(
502                              new_value, self.name, self.efuse_type
503                          )
504                      )
505                      raise esptool.FatalError(err)
506      def check_new_value(self, bitarray_new_value):
507          bitarray_old_value = self.get_bitstring() | self.get_bitstring(from_read=False)
508          if bitarray_new_value.len != bitarray_old_value.len:
509              raise esptool.FatalError(
510                  &quot;For {} efuse, the length of the new value is wrong, &quot;
511                  &quot;expected {} bits, was {} bits.&quot;.format(
512                      self.name, bitarray_old_value.len, bitarray_new_value.len
513                  )
514              )
515          if bitarray_new_value == bitarray_old_value:
516              error_msg = &quot;\tThe same value for {} &quot;.format(self.name)
517              error_msg += &quot;is already burned. Do not change the efuse.&quot;
518              print(error_msg)
519              bitarray_new_value.set(0)
520          elif bitarray_new_value == self.get_bitstring(from_read=False):
521              error_msg = &quot;\tThe same value for {} &quot;.format(self.name)
522              error_msg += &quot;is already prepared for the burn operation.&quot;
523              print(error_msg)
524              bitarray_new_value.set(0)
525          else:
526              if self.name not in [&quot;WR_DIS&quot;, &quot;RD_DIS&quot;]:
527                  if bitarray_new_value | bitarray_old_value != bitarray_new_value:
528                      error_msg = &quot;\tNew value contains some bits that cannot be cleared &quot;
529                      error_msg += &quot;(value will be {})&quot;.format(
530                          bitarray_old_value | bitarray_new_value
531                      )
532                      self.parent.print_error_msg(error_msg)
533              self.check_wr_rd_protect()
534      def save_to_block(self, bitarray_field):
535          block = self.parent.blocks[self.block]
536          wr_bitarray_temp = block.wr_bitarray.copy()
537          position = wr_bitarray_temp.length - (
<span onclick='openModal()' class='match'>538              self.word * 32 + self.pos + bitarray_field.len
539          )
540          wr_bitarray_temp.overwrite(bitarray_field, pos=position)
</span>541          block.wr_bitarray |= wr_bitarray_temp
542      def save(self, new_value):
543          bitarray_field = self.convert_to_bitstring(new_value)
544          self.check_new_value(bitarray_field)
545          self.save_to_block(bitarray_field)
546      def update(self, bit_array_block):
547          if self.is_field_calculated():
548              self.bitarray.overwrite(
549                  self.convert_to_bitstring(self.check_format(self.get())), pos=0
550              )
551              return
552          field_len = self.bitarray.len
553          bit_array_block.pos = bit_array_block.length - (
554              self.word * 32 + self.pos + field_len
555          )
556          self.bitarray.overwrite(bit_array_block.read(field_len), pos=0)
557          err_bitarray = self.parent.blocks[self.block].err_bitarray
558          if err_bitarray is not None:
559              err_bitarray.pos = err_bitarray.length - (
560                  self.word * 32 + self.pos + field_len
561              )
562              self.fail = not err_bitarray.read(field_len).all(False)
563          else:
564              self.fail = self.parent.blocks[self.block].fail
565              self.num_errors = self.parent.blocks[self.block].num_errors
566      def get_raw(self, from_read=True):
567          return self.get_bitstring(from_read).read(self.efuse_type)
568      def get(self, from_read=True):
569          if self.efuse_type.startswith(&quot;bytes&quot;):
570              return util.hexify(self.get_bitstring(from_read).bytes[::-1], &quot; &quot;)
571          else:
572              return self.get_raw(from_read)
573      def get_meaning(self, from_read=True):
574          if self.dict_value:
575              try:
576                  return self.dict_value[self.get_raw(from_read)]
577              except KeyError:
578                  pass
579          return self.get(from_read)
580      def get_bitstring(self, from_read=True):
581          if from_read:
582              self.bitarray.pos = 0
583              return self.bitarray
584          else:
585              field_len = self.bitarray.len
586              block = self.parent.blocks[self.block]
587              block.wr_bitarray.pos = block.wr_bitarray.length - (
588                  self.word * 32 + self.pos + field_len
589              )
590              return block.wr_bitarray.read(self.bitarray.len)
591      def burn(self, new_value):
592          self.save(new_value)
593          self.parent.burn_all()
594      def get_info(self):
595          output = f&quot;{self.name} (BLOCK{self.block})&quot;
596          if self.block == 0:
597              if self.fail:
598                  output += &quot;[error]&quot;
599          else:
600              errs, fail = self.parent.get_block_errors(self.block)
601              if errs != 0 or fail:
602                  output += &quot;[error]&quot;
603          if self.efuse_class == &quot;keyblock&quot;:
604              name = self.parent.blocks[self.block].key_purpose_name
605              if name is not None:
606                  output += f&quot;\n  Purpose: {self.parent[name].get()}\n &quot;
607          return output
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-emulate_efuse_controller_39.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-base_fields.py</div>
                </div>
                <div class="column column_space"><pre><code>103                              field.word * 32 + field.pos + raw_data.length
104                          )
105                          block.overwrite(BitStream(raw_data.length))
</pre></code></div>
                <div class="column column_space"><pre><code>538              self.word * 32 + self.pos + bitarray_field.len
539          )
540          wr_bitarray_temp.overwrite(bitarray_field, pos=position)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    