<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_aix_status.py & nova.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_aix_status.py & nova.py
      </h3>
      <h1 align="center">
        1.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_aix_status.py (16.25%)<TH>nova.py (0.6770833%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match232089-0.html#0',2,'match232089-1.html#0',3)" NAME="0">(116-160)<TD><A HREF="javascript:ZweiFrames('match232089-0.html#0',2,'match232089-1.html#0',3)" NAME="0">(962-970)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_aix_status.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
import logging
import sys

import pytest
import salt.modules.status as status
from tests.support.mock import MagicMock, patch

log = logging.getLogger(__name__)


@pytest.fixture
def configure_loader_modules():

    return {
        status: {
            &quot;__grains__&quot;: {
                &quot;ip4_interfaces&quot;: {
                    &quot;en0&quot;: [&quot;129.40.94.58&quot;],
                    &quot;en1&quot;: [&quot;172.24.94.58&quot;],
                    &quot;lo0&quot;: [&quot;127.0.0.1&quot;],
                },
                &quot;ip6_interfaces&quot;: {&quot;en0&quot;: [], &quot;en1&quot;: [], &quot;lo0&quot;: [&quot;1&quot;]},
                &quot;kernel&quot;: &quot;AIX&quot;,
                &quot;osarch&quot;: &quot;PowerPC_POWER8&quot;,
                &quot;os&quot;: &quot;AIX&quot;,
                &quot;os_family&quot;: &quot;AIX&quot;,
                &quot;osmajorrelease&quot;: 7,
            },
        },
    }


@pytest.mark.skipif(
    sys.version_info[0] == 3 and sys.version_info[1] &lt;= 5,
    reason=&quot;run on Python 3.6 or greater where OrderedDict is default&quot;,
)
def test_netdev():
    &quot;&quot;&quot;
    Test status.netdev for AIX

    :return:
    &quot;&quot;&quot;
    # Output from netstat -i -n -I &lt;en0|en1|lo0&gt; -f inet
    netstat_inet4_en0 = &quot;&quot;&quot;Name   Mtu   Network     Address                 Ipkts     Ierrs        Opkts     Oerrs  Coll
en0    1500  link#2      fa.41.f5.e9.bd.20  1523125     0   759364     0     0
en0    1500  129.40.94.5 129.40.94.58      1523125     0   759364     0     0
&quot;&quot;&quot;

    netstat_inet4_en1 = &quot;&quot;&quot;Name   Mtu   Network     Address                 Ipkts     Ierrs        Opkts     Oerrs  Coll
en1    1500  link#3      fa.41.f5.e9.bd.21     1089     0      402     0     0
en1    1500  172.24.94.5 172.24.94.58         1089     0      402     0     0
&quot;&quot;&quot;

    netstat_inet4_lo0 = &quot;&quot;&quot;Name   Mtu   Network     Address                 Ipkts     Ierrs        Opkts     Oerrs  Coll
lo0    16896 link#1                          25568     0    25568     0     0
lo0    16896 127         127.0.0.1           25568     0    25568     0     0
&quot;&quot;&quot;

    # Output from netstat -i -n -I &lt;en0|en1|lo0&gt; -f inet6
    netstat_inet6_en0 = &quot;&quot;&quot;Name   Mtu   Network     Address                 Ipkts     Ierrs        Opkts     Oerrs  Coll
en0    1500  link#2      fa.41.f5.e9.bd.20  1523160     0   759397     0     0
&quot;&quot;&quot;

    netstat_inet6_en1 = &quot;&quot;&quot;Name   Mtu   Network     Address                 Ipkts     Ierrs        Opkts     Oerrs  Coll
en1    1500  link#3      fa.41.f5.e9.bd.21     1089     0      402     0     0
&quot;&quot;&quot;

    netstat_inet6_lo0 = &quot;&quot;&quot;Name   Mtu   Network     Address                 Ipkts     Ierrs        Opkts     Oerrs  Coll
lo0    16896 link#1                          25611     0    25611     0     0
lo0    16896 ::1%1                           25611     0    25611     0     0
&quot;&quot;&quot;

    # allow en0, en1 and lo0 for ipv4 and ipv6
    netstats_out = MagicMock(
        side_effect=[
            netstat_inet4_en0,
            netstat_inet6_en0,
            netstat_inet4_en1,
            netstat_inet6_en1,
            netstat_inet4_lo0,
            netstat_inet6_lo0,
            netstat_inet4_en0,
            netstat_inet6_en0,
            netstat_inet4_en1,
            netstat_inet6_en1,
            netstat_inet4_lo0,
            netstat_inet6_lo0,
        ]
    )

    with patch.dict(
        status.__grains__,
        {
            &quot;osarch&quot;: &quot;PowerPC_POWER8&quot;,
            &quot;ip4_interfaces&quot;: {
                &quot;en0&quot;: [&quot;129.40.94.58&quot;],
                &quot;en1&quot;: [&quot;172.24.94.58&quot;],
                &quot;lo0&quot;: [&quot;127.0.0.1&quot;],
            },
            &quot;ip6_interfaces&quot;: {
                &quot;en0&quot;: [],
                &quot;en1&quot;: [],
                &quot;lo0&quot;: [&quot;::1&quot;],
            },
            &quot;kernel&quot;: &quot;AIX&quot;,
        },
    ), patch.dict(status.__salt__, {&quot;cmd.run&quot;: netstats_out}):
        netdev_out = status.netdev()
        assert netstats_out.call_count == 12
        netstats_out.assert_any_call(&quot;netstat -i -n -I en0 -f inet&quot;)
        netstats_out.assert_any_call(&quot;netstat -i -n -I en1 -f inet&quot;)
        netstats_out.assert_any_call(&quot;netstat -i -n -I lo0 -f inet&quot;)
<A NAME="0"></A>        netstats_out.assert_any_call(&quot;netstat -i -n -I en0 -f inet6&quot;)
        netstats_out.assert_any_call(&quot;netstat -i -n -I en1 -f inet6&quot;)
        netstats_out.assert_any_call(&quot;netstat -i -n -I lo0 -f inet6&quot;)
        expected <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match232089-1.html#0',3,'match232089-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>= {
            &quot;en0&quot;: [
                {
                    &quot;ipv4&quot;: {
                        &quot;Mtu&quot;: &quot;1500&quot;,
                        &quot;Network&quot;: &quot;129.40.94.5&quot;,
                        &quot;Address&quot;: &quot;129.40.94.58&quot;,
                        &quot;Ipkts&quot;: &quot;1523125&quot;,
                        &quot;Ierrs&quot;: &quot;0&quot;,
                        &quot;Opkts&quot;: &quot;759364&quot;,
                        &quot;Oerrs&quot;: &quot;0&quot;,
                        &quot;Coll&quot;: &quot;0&quot;,
                    }
                }
            ],
            &quot;en1&quot;: [
                {
                    &quot;ipv4&quot;: {
                        &quot;Mtu&quot;: &quot;1500&quot;,
                        &quot;Network&quot;: &quot;172.24.94.5&quot;,
                        &quot;Address&quot;: &quot;172.24.94.58&quot;,
                        &quot;Ipkts&quot;: &quot;1089&quot;,
                        &quot;Ierrs&quot;: &quot;0&quot;,
                        &quot;Opkts&quot;: &quot;402&quot;,
                        &quot;Oerrs&quot;: &quot;0&quot;,
                        &quot;Coll&quot;: &quot;0&quot;,
                    }
                }
            ],
            &quot;lo0&quot;: [
                {
                    &quot;ipv4&quot;: {
                        &quot;Mtu&quot;: &quot;16896&quot;,
                        &quot;Network&quot;: &quot;127&quot;,
                        &quot;Address&quot;: &quot;127.0.0.1&quot;,
                        &quot;Ipkts&quot;: &quot;25568&quot;,
                        &quot;Ierrs&quot;: &quot;0&quot;,
                        &quot;Opkts&quot;: &quot;25568&quot;,
                        &quot;Oerrs&quot;: &quot;0&quot;,
                        &quot;Coll&quot;: &quot;0&quot;,
                    }
                },
                {
                    &quot;ipv6&quot;: {
                        &quot;Mtu&quot;</B></FONT>: &quot;16896&quot;,
                        &quot;Network&quot;: &quot;::1%1&quot;,
                        &quot;Address&quot;: &quot;25611&quot;,
                        &quot;Ipkts&quot;: &quot;0&quot;,
                        &quot;Ierrs&quot;: &quot;25611&quot;,
                        &quot;Opkts&quot;: &quot;0&quot;,
                        &quot;Oerrs&quot;: &quot;0&quot;,
                    }
                },
            ],
        }
        assert netdev_out == expected
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>nova.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Nova class
&quot;&quot;&quot;


import inspect
import logging
import time

import salt.utils.cloud
import salt.utils.files
from salt.exceptions import SaltCloudSystemExit
from salt.utils.versions import LooseVersion as _LooseVersion

HAS_NOVA = False
# pylint: disable=import-error
try:
    import novaclient
    from novaclient import client
    from novaclient.shell import OpenStackComputeShell
    import novaclient.utils
    import novaclient.auth_plugin
    import novaclient.exceptions
    import novaclient.extension
    import novaclient.base

    HAS_NOVA = True
except ImportError:
    pass

HAS_KEYSTONEAUTH = False
try:
    import keystoneauth1.loading
    import keystoneauth1.session

    HAS_KEYSTONEAUTH = True
except ImportError:
    pass
# pylint: enable=import-error


# Get logging started
log = logging.getLogger(__name__)

# Version added to novaclient.client.Client function
NOVACLIENT_MINVER = &quot;2.6.1&quot;
NOVACLIENT_MAXVER = &quot;6.0.1&quot;

# dict for block_device_mapping_v2
CLIENT_BDM2_KEYS = {
    &quot;id&quot;: &quot;uuid&quot;,
    &quot;source&quot;: &quot;source_type&quot;,
    &quot;dest&quot;: &quot;destination_type&quot;,
    &quot;bus&quot;: &quot;disk_bus&quot;,
    &quot;device&quot;: &quot;device_name&quot;,
    &quot;size&quot;: &quot;volume_size&quot;,
    &quot;format&quot;: &quot;guest_format&quot;,
    &quot;bootindex&quot;: &quot;boot_index&quot;,
    &quot;type&quot;: &quot;device_type&quot;,
    &quot;shutdown&quot;: &quot;delete_on_termination&quot;,
}


def check_nova():
    if HAS_NOVA:
        novaclient_ver = _LooseVersion(novaclient.__version__)
        min_ver = _LooseVersion(NOVACLIENT_MINVER)
        max_ver = _LooseVersion(NOVACLIENT_MAXVER)
        if min_ver &lt;= novaclient_ver &lt;= max_ver:
            return HAS_NOVA
        elif novaclient_ver &gt; max_ver:
            log.debug(
                &quot;Older novaclient version required. Maximum: %s&quot;, NOVACLIENT_MAXVER
            )
            return False
        log.debug(&quot;Newer novaclient version required.  Minimum: %s&quot;, NOVACLIENT_MINVER)
    return False


if check_nova():
    try:
        import novaclient.auth_plugin
    except ImportError:
        log.debug(
            &quot;Using novaclient version 7.0.0 or newer. Authentication &quot;
            &quot;plugin auth_plugin.py is not available anymore.&quot;
        )


# kwargs has to be an object instead of a dictionary for the __post_parse_arg__
class KwargsStruct:
    def __init__(self, **entries):
        self.__dict__.update(entries)


def _parse_block_device_mapping_v2(
    block_device=None, boot_volume=None, snapshot=None, ephemeral=None, swap=None
):
    bdm = []
    if block_device is None:
        block_device = []
    if ephemeral is None:
        ephemeral = []

    if boot_volume is not None:
        bdm_dict = {
            &quot;uuid&quot;: boot_volume,
            &quot;source_type&quot;: &quot;volume&quot;,
            &quot;destination_type&quot;: &quot;volume&quot;,
            &quot;boot_index&quot;: 0,
            &quot;delete_on_termination&quot;: False,
        }
        bdm.append(bdm_dict)

    if snapshot is not None:
        bdm_dict = {
            &quot;uuid&quot;: snapshot,
            &quot;source_type&quot;: &quot;snapshot&quot;,
            &quot;destination_type&quot;: &quot;volume&quot;,
            &quot;boot_index&quot;: 0,
            &quot;delete_on_termination&quot;: False,
        }
        bdm.append(bdm_dict)

    for device_spec in block_device:
        bdm_dict = {}

        for key, value in device_spec.items():
            bdm_dict[CLIENT_BDM2_KEYS[key]] = value

        # Convert the delete_on_termination to a boolean or set it to true by
        # default for local block devices when not specified.
        if &quot;delete_on_termination&quot; in bdm_dict:
            action = bdm_dict[&quot;delete_on_termination&quot;]
            bdm_dict[&quot;delete_on_termination&quot;] = action == &quot;remove&quot;
        elif bdm_dict.get(&quot;destination_type&quot;) == &quot;local&quot;:
            bdm_dict[&quot;delete_on_termination&quot;] = True

        bdm.append(bdm_dict)

    for ephemeral_spec in ephemeral:
        bdm_dict = {
            &quot;source_type&quot;: &quot;blank&quot;,
            &quot;destination_type&quot;: &quot;local&quot;,
            &quot;boot_index&quot;: -1,
            &quot;delete_on_termination&quot;: True,
        }
        if &quot;size&quot; in ephemeral_spec:
            bdm_dict[&quot;volume_size&quot;] = ephemeral_spec[&quot;size&quot;]
        if &quot;format&quot; in ephemeral_spec:
            bdm_dict[&quot;guest_format&quot;] = ephemeral_spec[&quot;format&quot;]

        bdm.append(bdm_dict)

    if swap is not None:
        bdm_dict = {
            &quot;source_type&quot;: &quot;blank&quot;,
            &quot;destination_type&quot;: &quot;local&quot;,
            &quot;boot_index&quot;: -1,
            &quot;delete_on_termination&quot;: True,
            &quot;guest_format&quot;: &quot;swap&quot;,
            &quot;volume_size&quot;: swap,
        }
        bdm.append(bdm_dict)

    return bdm


class NovaServer:
    def __init__(self, name, server, password=None):
        &quot;&quot;&quot;
        Make output look like libcloud output for consistency
        &quot;&quot;&quot;
        self.name = name
        self.id = server[&quot;id&quot;]
        self.image = server.get(&quot;image&quot;, {}).get(&quot;id&quot;, &quot;Boot From Volume&quot;)
        self.size = server[&quot;flavor&quot;][&quot;id&quot;]
        self.state = server[&quot;state&quot;]
        self._uuid = None
        self.extra = {&quot;metadata&quot;: server[&quot;metadata&quot;], &quot;access_ip&quot;: server[&quot;accessIPv4&quot;]}

        self.addresses = server.get(&quot;addresses&quot;, {})
        self.public_ips, self.private_ips = [], []
        self.fixed_ips, self.floating_ips = [], []
        for network in self.addresses.values():
            for addr in network:
                if salt.utils.cloud.is_public_ip(addr[&quot;addr&quot;]):
                    self.public_ips.append(addr[&quot;addr&quot;])
                else:
                    self.private_ips.append(addr[&quot;addr&quot;])
                if addr.get(&quot;OS-EXT-IPS:type&quot;) == &quot;floating&quot;:
                    self.floating_ips.append(addr[&quot;addr&quot;])
                else:
                    self.fixed_ips.append(addr[&quot;addr&quot;])

        if password:
            self.extra[&quot;password&quot;] = password

    def __str__(self):
        return self.__dict__


def get_entry(dict_, key, value, raise_error=True):
    for entry in dict_:
        if entry[key] == value:
            return entry
    if raise_error is True:
        raise SaltCloudSystemExit(&quot;Unable to find {} in {}.&quot;.format(key, dict_))
    return {}


def get_entry_multi(dict_, pairs, raise_error=True):
    for entry in dict_:
        if all([entry[key] == value for key, value in pairs]):
            return entry
    if raise_error is True:
        raise SaltCloudSystemExit(&quot;Unable to find {} in {}.&quot;.format(pairs, dict_))
    return {}


def get_endpoint_url_v3(catalog, service_type, region_name):
    for service_entry in catalog:
        if service_entry[&quot;type&quot;] == service_type:
            for endpoint_entry in service_entry[&quot;endpoints&quot;]:
                if (
                    endpoint_entry[&quot;region&quot;] == region_name
                    and endpoint_entry[&quot;interface&quot;] == &quot;public&quot;
                ):
                    return endpoint_entry[&quot;url&quot;]
    return None


def sanatize_novaclient(kwargs):
    variables = (
        &quot;username&quot;,
        &quot;api_key&quot;,
        &quot;project_id&quot;,
        &quot;auth_url&quot;,
        &quot;insecure&quot;,
        &quot;timeout&quot;,
        &quot;proxy_tenant_id&quot;,
        &quot;proxy_token&quot;,
        &quot;region_name&quot;,
        &quot;endpoint_type&quot;,
        &quot;extensions&quot;,
        &quot;service_type&quot;,
        &quot;service_name&quot;,
        &quot;volume_service_name&quot;,
        &quot;timings&quot;,
        &quot;bypass_url&quot;,
        &quot;os_cache&quot;,
        &quot;no_cache&quot;,
        &quot;http_log_debug&quot;,
        &quot;auth_system&quot;,
        &quot;auth_plugin&quot;,
        &quot;auth_token&quot;,
        &quot;cacert&quot;,
        &quot;tenant_id&quot;,
    )
    ret = {}
    for var in kwargs:
        if var in variables:
            ret[var] = kwargs[var]

    return ret


# Function alias to not shadow built-ins
class SaltNova:
    &quot;&quot;&quot;
    Class for all novaclient functions
    &quot;&quot;&quot;

    extensions = []

    def __init__(
        self,
        username,
        project_id,
        auth_url,
        region_name=None,
        password=None,
        os_auth_plugin=None,
        use_keystoneauth=False,
        **kwargs
    ):
        &quot;&quot;&quot;
        Set up nova credentials
        &quot;&quot;&quot;
        if all([use_keystoneauth, HAS_KEYSTONEAUTH]):
            self._new_init(
                username=username,
                project_id=project_id,
                auth_url=auth_url,
                region_name=region_name,
                password=password,
                os_auth_plugin=os_auth_plugin,
                **kwargs
            )
        else:
            self._old_init(
                username=username,
                project_id=project_id,
                auth_url=auth_url,
                region_name=region_name,
                password=password,
                os_auth_plugin=os_auth_plugin,
                **kwargs
            )

    def _new_init(
        self,
        username,
        project_id,
        auth_url,
        region_name,
        password,
        os_auth_plugin,
        auth=None,
        verify=True,
        **kwargs
    ):
        if auth is None:
            auth = {}

        loader = keystoneauth1.loading.get_plugin_loader(os_auth_plugin or &quot;password&quot;)

        self.client_kwargs = kwargs.copy()
        self.kwargs = auth.copy()
        if not self.extensions:
            if hasattr(OpenStackComputeShell, &quot;_discover_extensions&quot;):
                self.extensions = OpenStackComputeShell()._discover_extensions(&quot;2.0&quot;)
            else:
                self.extensions = client.discover_extensions(&quot;2.0&quot;)
            for extension in self.extensions:
                extension.run_hooks(&quot;__pre_parse_args__&quot;)
            self.client_kwargs[&quot;extensions&quot;] = self.extensions

        self.kwargs[&quot;username&quot;] = username
        self.kwargs[&quot;project_name&quot;] = project_id
        self.kwargs[&quot;auth_url&quot;] = auth_url
        self.kwargs[&quot;password&quot;] = password
        if auth_url.endswith(&quot;3&quot;):
            self.kwargs[&quot;user_domain_name&quot;] = kwargs.get(&quot;user_domain_name&quot;, &quot;default&quot;)
            self.kwargs[&quot;project_domain_name&quot;] = kwargs.get(
                &quot;project_domain_name&quot;, &quot;default&quot;
            )

        self.client_kwargs[&quot;region_name&quot;] = region_name
        self.client_kwargs[&quot;service_type&quot;] = &quot;compute&quot;

        if hasattr(self, &quot;extensions&quot;):
            # needs an object, not a dictionary
            self.kwargstruct = KwargsStruct(**self.client_kwargs)
            for extension in self.extensions:
                extension.run_hooks(&quot;__post_parse_args__&quot;, self.kwargstruct)
            self.client_kwargs = self.kwargstruct.__dict__

        # Requires novaclient version &gt;= 2.6.1
        self.version = str(kwargs.get(&quot;version&quot;, 2))

        self.client_kwargs = sanatize_novaclient(self.client_kwargs)
        options = loader.load_from_options(**self.kwargs)
        self.session = keystoneauth1.session.Session(auth=options, verify=verify)
        conn = client.Client(
            version=self.version, session=self.session, **self.client_kwargs
        )
        self.kwargs[&quot;auth_token&quot;] = conn.client.session.get_token()
        identity_service_type = kwargs.get(&quot;identity_service_type&quot;, &quot;identity&quot;)
        self.catalog = (
            conn.client.session.get(
                &quot;/auth/catalog&quot;, endpoint_filter={&quot;service_type&quot;: identity_service_type}
            )
            .json()
            .get(&quot;catalog&quot;, [])
        )
        if conn.client.get_endpoint(service_type=identity_service_type).endswith(&quot;v3&quot;):
            self._v3_setup(region_name)
        else:
            self._v2_setup(region_name)

    def _old_init(
        self,
        username,
        project_id,
        auth_url,
        region_name,
        password,
        os_auth_plugin,
        **kwargs
    ):
        self.kwargs = kwargs.copy()
        if not self.extensions:
            if hasattr(OpenStackComputeShell, &quot;_discover_extensions&quot;):
                self.extensions = OpenStackComputeShell()._discover_extensions(&quot;2.0&quot;)
            else:
                self.extensions = client.discover_extensions(&quot;2.0&quot;)
            for extension in self.extensions:
                extension.run_hooks(&quot;__pre_parse_args__&quot;)
            self.kwargs[&quot;extensions&quot;] = self.extensions

        self.kwargs[&quot;username&quot;] = username
        self.kwargs[&quot;project_id&quot;] = project_id
        self.kwargs[&quot;auth_url&quot;] = auth_url
        self.kwargs[&quot;region_name&quot;] = region_name
        self.kwargs[&quot;service_type&quot;] = &quot;compute&quot;

        # used in novaclient extensions to see if they are rackspace or not, to know if it needs to load
        # the hooks for that extension or not.  This is cleaned up by sanatize_novaclient
        self.kwargs[&quot;os_auth_url&quot;] = auth_url

        if os_auth_plugin is not None:
            novaclient.auth_plugin.discover_auth_systems()
            auth_plugin = novaclient.auth_plugin.load_plugin(os_auth_plugin)
            self.kwargs[&quot;auth_plugin&quot;] = auth_plugin
            self.kwargs[&quot;auth_system&quot;] = os_auth_plugin

        if not self.kwargs.get(&quot;api_key&quot;, None):
            self.kwargs[&quot;api_key&quot;] = password

        # This has to be run before sanatize_novaclient before extra variables are cleaned out.
        if hasattr(self, &quot;extensions&quot;):
            # needs an object, not a dictionary
            self.kwargstruct = KwargsStruct(**self.kwargs)
            for extension in self.extensions:
                extension.run_hooks(&quot;__post_parse_args__&quot;, self.kwargstruct)
            self.kwargs = self.kwargstruct.__dict__

        self.kwargs = sanatize_novaclient(self.kwargs)

        # Requires novaclient version &gt;= 2.6.1
        self.kwargs[&quot;version&quot;] = str(kwargs.get(&quot;version&quot;, 2))

        conn = client.Client(**self.kwargs)
        try:
            conn.client.authenticate()
        except novaclient.exceptions.AmbiguousEndpoints:
            raise SaltCloudSystemExit(
                &quot;Nova provider requires a 'region_name' to be specified&quot;
            )

        self.kwargs[&quot;auth_token&quot;] = conn.client.auth_token
        self.catalog = conn.client.service_catalog.catalog[&quot;access&quot;][&quot;serviceCatalog&quot;]

        self._v2_setup(region_name)

    def _v3_setup(self, region_name):
        if region_name is not None:
            self.client_kwargs[&quot;bypass_url&quot;] = get_endpoint_url_v3(
                self.catalog, &quot;compute&quot;, region_name
            )
            log.debug(&quot;Using Nova bypass_url: %s&quot;, self.client_kwargs[&quot;bypass_url&quot;])

        self.compute_conn = client.Client(
            version=self.version, session=self.session, **self.client_kwargs
        )

        volume_endpoints = get_entry(
            self.catalog, &quot;type&quot;, &quot;volume&quot;, raise_error=False
        ).get(&quot;endpoints&quot;, {})
        if volume_endpoints:
            if region_name is not None:
                self.client_kwargs[&quot;bypass_url&quot;] = get_endpoint_url_v3(
                    self.catalog, &quot;volume&quot;, region_name
                )
                log.debug(
                    &quot;Using Cinder bypass_url: %s&quot;, self.client_kwargs[&quot;bypass_url&quot;]
                )

            self.volume_conn = client.Client(
                version=self.version, session=self.session, **self.client_kwargs
            )
            if hasattr(self, &quot;extensions&quot;):
                self.expand_extensions()
        else:
            self.volume_conn = None

    def _v2_setup(self, region_name):
        if region_name is not None:
            servers_endpoints = get_entry(self.catalog, &quot;type&quot;, &quot;compute&quot;)[&quot;endpoints&quot;]
            self.kwargs[&quot;bypass_url&quot;] = get_entry(
                servers_endpoints, &quot;region&quot;, region_name
            )[&quot;publicURL&quot;]

        self.compute_conn = client.Client(**self.kwargs)

        volume_endpoints = get_entry(
            self.catalog, &quot;type&quot;, &quot;volume&quot;, raise_error=False
        ).get(&quot;endpoints&quot;, {})
        if volume_endpoints:
            if region_name is not None:
                self.kwargs[&quot;bypass_url&quot;] = get_entry(
                    volume_endpoints, &quot;region&quot;, region_name
                )[&quot;publicURL&quot;]

            self.volume_conn = client.Client(**self.kwargs)
            if hasattr(self, &quot;extensions&quot;):
                self.expand_extensions()
        else:
            self.volume_conn = None

    def expand_extensions(self):
        for connection in (self.compute_conn, self.volume_conn):
            if connection is None:
                continue
            for extension in self.extensions:
                for attr in extension.module.__dict__:
                    if not inspect.isclass(getattr(extension.module, attr)):
                        continue
                    for key, value in connection.__dict__.items():
                        if not isinstance(value, novaclient.base.Manager):
                            continue
                        if value.__class__.__name__ == attr:
                            setattr(
                                connection, key, extension.manager_class(connection)
                            )

    def get_catalog(self):
        &quot;&quot;&quot;
        Return service catalog
        &quot;&quot;&quot;
        return self.catalog

    def server_show_libcloud(self, uuid):
        &quot;&quot;&quot;
        Make output look like libcloud output for consistency
        &quot;&quot;&quot;
        server_info = self.server_show(uuid)
        server = next(iter(server_info.values()))
        server_name = next(iter(server_info.keys()))
        if not hasattr(self, &quot;password&quot;):
            self.password = None
        ret = NovaServer(server_name, server, self.password)

        return ret

    def boot(self, name, flavor_id=0, image_id=0, timeout=300, **kwargs):
        &quot;&quot;&quot;
        Boot a cloud server.
        &quot;&quot;&quot;
        nt_ks = self.compute_conn
        kwargs[&quot;name&quot;] = name
        kwargs[&quot;flavor&quot;] = flavor_id
        kwargs[&quot;image&quot;] = image_id or None
        ephemeral = kwargs.pop(&quot;ephemeral&quot;, [])
        block_device = kwargs.pop(&quot;block_device&quot;, [])
        boot_volume = kwargs.pop(&quot;boot_volume&quot;, None)
        snapshot = kwargs.pop(&quot;snapshot&quot;, None)
        swap = kwargs.pop(&quot;swap&quot;, None)
        kwargs[&quot;block_device_mapping_v2&quot;] = _parse_block_device_mapping_v2(
            block_device=block_device,
            boot_volume=boot_volume,
            snapshot=snapshot,
            ephemeral=ephemeral,
            swap=swap,
        )
        response = nt_ks.servers.create(**kwargs)
        self.uuid = response.id
        self.password = getattr(response, &quot;adminPass&quot;, None)

        start = time.time()
        trycount = 0
        while True:
            trycount += 1
            try:
                return self.server_show_libcloud(self.uuid)
            except Exception as exc:  # pylint: disable=broad-except
                log.debug(&quot;Server information not yet available: %s&quot;, exc)
                time.sleep(1)
                if time.time() - start &gt; timeout:
                    log.error(
                        &quot;Timed out after %s seconds while waiting for data&quot;, timeout
                    )
                    return False

                log.debug(&quot;Retrying server_show() (try %s)&quot;, trycount)

    def show_instance(self, name):
        &quot;&quot;&quot;
        Find a server by its name (libcloud)
        &quot;&quot;&quot;
        return self.server_by_name(name)

    def root_password(self, server_id, password):
        &quot;&quot;&quot;
        Change server(uuid's) root password
        &quot;&quot;&quot;
        nt_ks = self.compute_conn
        nt_ks.servers.change_password(server_id, password)

    def server_by_name(self, name):
        &quot;&quot;&quot;
        Find a server by its name
        &quot;&quot;&quot;
        return self.server_show_libcloud(self.server_list().get(name, {}).get(&quot;id&quot;, &quot;&quot;))

    def _volume_get(self, volume_id):
        &quot;&quot;&quot;
        Organize information about a volume from the volume_id
        &quot;&quot;&quot;
        if self.volume_conn is None:
            raise SaltCloudSystemExit(&quot;No cinder endpoint available&quot;)
        nt_ks = self.volume_conn
        volume = nt_ks.volumes.get(volume_id)
        response = {
            &quot;name&quot;: volume.display_name,
            &quot;size&quot;: volume.size,
            &quot;id&quot;: volume.id,
            &quot;description&quot;: volume.display_description,
            &quot;attachments&quot;: volume.attachments,
            &quot;status&quot;: volume.status,
        }
        return response

    def volume_list(self, search_opts=None):
        &quot;&quot;&quot;
        List all block volumes
        &quot;&quot;&quot;
        if self.volume_conn is None:
            raise SaltCloudSystemExit(&quot;No cinder endpoint available&quot;)
        nt_ks = self.volume_conn
        volumes = nt_ks.volumes.list(search_opts=search_opts)
        response = {}
        for volume in volumes:
            response[volume.display_name] = {
                &quot;name&quot;: volume.display_name,
                &quot;size&quot;: volume.size,
                &quot;id&quot;: volume.id,
                &quot;description&quot;: volume.display_description,
                &quot;attachments&quot;: volume.attachments,
                &quot;status&quot;: volume.status,
            }
        return response

    def volume_show(self, name):
        &quot;&quot;&quot;
        Show one volume
        &quot;&quot;&quot;
        if self.volume_conn is None:
            raise SaltCloudSystemExit(&quot;No cinder endpoint available&quot;)

        volumes = self.volume_list(
            search_opts={&quot;display_name&quot;: name},
        )
        volume = volumes[name]

        return volume

    def volume_create(
        self, name, size=100, snapshot=None, voltype=None, availability_zone=None
    ):
        &quot;&quot;&quot;
        Create a block device
        &quot;&quot;&quot;
        if self.volume_conn is None:
            raise SaltCloudSystemExit(&quot;No cinder endpoint available&quot;)
        nt_ks = self.volume_conn
        response = nt_ks.volumes.create(
            size=size,
            display_name=name,
            volume_type=voltype,
            snapshot_id=snapshot,
            availability_zone=availability_zone,
        )

        return self._volume_get(response.id)

    def volume_delete(self, name):
        &quot;&quot;&quot;
        Delete a block device
        &quot;&quot;&quot;
        if self.volume_conn is None:
            raise SaltCloudSystemExit(&quot;No cinder endpoint available&quot;)
        nt_ks = self.volume_conn
        try:
            volume = self.volume_show(name)
        except KeyError as exc:
            raise SaltCloudSystemExit(&quot;Unable to find {} volume: {}&quot;.format(name, exc))
        if volume[&quot;status&quot;] == &quot;deleted&quot;:
            return volume
        response = nt_ks.volumes.delete(volume[&quot;id&quot;])
        return volume

    def volume_detach(self, name, timeout=300):
        &quot;&quot;&quot;
        Detach a block device
        &quot;&quot;&quot;
        try:
            volume = self.volume_show(name)
        except KeyError as exc:
            raise SaltCloudSystemExit(&quot;Unable to find {} volume: {}&quot;.format(name, exc))
        if not volume[&quot;attachments&quot;]:
            return True
        response = self.compute_conn.volumes.delete_server_volume(
            volume[&quot;attachments&quot;][0][&quot;server_id&quot;], volume[&quot;attachments&quot;][0][&quot;id&quot;]
        )
        trycount = 0
        start = time.time()
        while True:
            trycount += 1
            try:
                response = self._volume_get(volume[&quot;id&quot;])
                if response[&quot;status&quot;] == &quot;available&quot;:
                    return response
            except Exception as exc:  # pylint: disable=broad-except
                log.debug(&quot;Volume is detaching: %s&quot;, name)
                time.sleep(1)
                if time.time() - start &gt; timeout:
                    log.error(
                        &quot;Timed out after %d seconds while waiting for data&quot;, timeout
                    )
                    return False

                log.debug(&quot;Retrying volume_show() (try %d)&quot;, trycount)

    def volume_attach(self, name, server_name, device=&quot;/dev/xvdb&quot;, timeout=300):
        &quot;&quot;&quot;
        Attach a block device
        &quot;&quot;&quot;
        try:
            volume = self.volume_show(name)
        except KeyError as exc:
            raise SaltCloudSystemExit(&quot;Unable to find {} volume: {}&quot;.format(name, exc))
        server = self.server_by_name(server_name)
        response = self.compute_conn.volumes.create_server_volume(
            server.id, volume[&quot;id&quot;], device=device
        )
        trycount = 0
        start = time.time()
        while True:
            trycount += 1
            try:
                response = self._volume_get(volume[&quot;id&quot;])
                if response[&quot;status&quot;] == &quot;in-use&quot;:
                    return response
            except Exception as exc:  # pylint: disable=broad-except
                log.debug(&quot;Volume is attaching: %s&quot;, name)
                time.sleep(1)
                if time.time() - start &gt; timeout:
                    log.error(
                        &quot;Timed out after %s seconds while waiting for data&quot;, timeout
                    )
                    return False

                log.debug(&quot;Retrying volume_show() (try %s)&quot;, trycount)

    def suspend(self, instance_id):
        &quot;&quot;&quot;
        Suspend a server
        &quot;&quot;&quot;
        nt_ks = self.compute_conn
        response = nt_ks.servers.suspend(instance_id)
        return True

    def resume(self, instance_id):
        &quot;&quot;&quot;
        Resume a server
        &quot;&quot;&quot;
        nt_ks = self.compute_conn
        response = nt_ks.servers.resume(instance_id)
        return True

    def lock(self, instance_id):
        &quot;&quot;&quot;
        Lock an instance
        &quot;&quot;&quot;
        nt_ks = self.compute_conn
        response = nt_ks.servers.lock(instance_id)
        return True

    def delete(self, instance_id):
        &quot;&quot;&quot;
        Delete a server
        &quot;&quot;&quot;
        nt_ks = self.compute_conn
        response = nt_ks.servers.delete(instance_id)
        return True

    def flavor_list(self):
        &quot;&quot;&quot;
        Return a list of available flavors (nova flavor-list)
        &quot;&quot;&quot;
        nt_ks = self.compute_conn
        ret = {}
        for flavor in nt_ks.flavors.list():
            links = {}
            for link in flavor.links:
                links[link[&quot;rel&quot;]] = link[&quot;href&quot;]
            ret[flavor.name] = {
                &quot;disk&quot;: flavor.disk,
                &quot;id&quot;: flavor.id,
                &quot;name&quot;: flavor.name,
                &quot;ram&quot;: flavor.ram,
                &quot;swap&quot;: flavor.swap,
                &quot;vcpus&quot;: flavor.vcpus,
                &quot;links&quot;: links,
            }
            if hasattr(flavor, &quot;rxtx_factor&quot;):
                ret[flavor.name][&quot;rxtx_factor&quot;] = flavor.rxtx_factor
        return ret

    list_sizes = flavor_list

    def flavor_create(
        self,
        name,  # pylint: disable=C0103
        flavor_id=0,  # pylint: disable=C0103
        ram=0,
        disk=0,
        vcpus=1,
    ):
        &quot;&quot;&quot;
        Create a flavor
        &quot;&quot;&quot;
        nt_ks = self.compute_conn
        nt_ks.flavors.create(
            name=name, flavorid=flavor_id, ram=ram, disk=disk, vcpus=vcpus
        )
        return {&quot;name&quot;: name, &quot;id&quot;: flavor_id, &quot;ram&quot;: ram, &quot;disk&quot;: disk, &quot;vcpus&quot;: vcpus}

    def flavor_delete(self, flavor_id):  # pylint: disable=C0103
        &quot;&quot;&quot;
        Delete a flavor
        &quot;&quot;&quot;
        nt_ks = self.compute_conn
        nt_ks.flavors.delete(flavor_id)
        return &quot;Flavor deleted: {}&quot;.format(flavor_id)

    def keypair_list(self):
        &quot;&quot;&quot;
        List keypairs
        &quot;&quot;&quot;
        nt_ks = self.compute_conn
        ret = {}
        for keypair in nt_ks.keypairs.list():
            ret[keypair.name] = {
                &quot;name&quot;: keypair.name,
                &quot;fingerprint&quot;: keypair.fingerprint,
                &quot;public_key&quot;: keypair.public_key,
            }
        return ret

    def keypair_add(self, name, pubfile=None, pubkey=None):
        &quot;&quot;&quot;
        Add a keypair
        &quot;&quot;&quot;
        nt_ks = self.compute_conn
        if pubfile:
            with salt.utils.files.fopen(pubfile, &quot;r&quot;) as fp_:
                pubkey = salt.utils.stringutils.to_unicode(fp_.read())
        if not pubkey:
            return False
        nt_ks.keypairs.create(name, public_key=pubkey)
        ret = {&quot;name&quot;: name, &quot;pubkey&quot;: pubkey}
        return ret

    def keypair_delete(self, name):
        &quot;&quot;&quot;
        Delete a keypair
        &quot;&quot;&quot;
        nt_ks = self.compute_conn
        nt_ks.keypairs.delete(name)
        return &quot;Keypair deleted: {}&quot;.format(name)

    def image_show(self, image_id):
        &quot;&quot;&quot;
        Show image details and metadata
        &quot;&quot;&quot;
        nt_ks = self.compute_conn
        image = nt_ks.images.get(image_id)
        links = {}
        for link in image.links:
            links[link[&quot;rel&quot;]] = link[&quot;href&quot;]
        ret = {
            &quot;name&quot;: image.name,
            &quot;id&quot;: image.id,
            &quot;status&quot;: image.status,
            &quot;progress&quot;: image.progress,
            &quot;created&quot;: image.created,
            &quot;updated&quot;: image.updated,
            &quot;metadata&quot;: image.metadata,
            &quot;links&quot;: links,
        }
        if hasattr(image, &quot;minDisk&quot;):
            ret[&quot;minDisk&quot;] = image.minDisk
        if hasattr(image, &quot;minRam&quot;):
            ret[&quot;minRam&quot;] = image.minRam

        return ret

    def image_list(self, name=None):
        &quot;&quot;&quot;
        List server images
        &quot;&quot;&quot;
        nt_ks = self.compute_conn
        ret = {}
        for image in nt_ks.images.list():
            links = {}
            for link in image.links:
                links[link[&quot;rel&quot;]] = link[&quot;href&quot;]
            ret[image.name] = {
                &quot;name&quot;: image.name,
                &quot;id&quot;: image.id,
                &quot;status&quot;: image.status,
                &quot;progress&quot;: image.progress,
                &quot;created&quot;: image.created,
                &quot;updated&quot;: image.updated,
                &quot;metadata&quot;: image.metadata,
                &quot;links&quot;: links,
            }
            if hasattr(image, &quot;minDisk&quot;):
                ret[image.name][&quot;minDisk&quot;] = image.minDisk
            if hasattr(image, &quot;minRam&quot;):
                ret[image.name][&quot;minRam&quot;] = image.minRam
        if name:
            return {name: ret[name]}
        return ret

    list_images = image_list

    def image_meta_set(
        self, image_id=None, name=None, **kwargs
    ):  # pylint: disable=C0103
        &quot;&quot;&quot;
        Set image metadata
        &quot;&quot;&quot;
        nt_ks = self.compute_conn
        if name:
            for image in nt_ks.images.list():
                if image.name == name:
                    image_id = image.id  # pylint: disable=C0103
        if not image_id:
            return {&quot;Error&quot;: &quot;A valid image name or id was not specified&quot;}
        nt_ks.images.set_meta(image_id, kwargs)
        return {image_id: kwargs}

    def image_meta_delete(
        self, image_id=None, name=None, keys=None  # pylint: disable=C0103
    ):
        &quot;&quot;&quot;
        Delete image metadata
        &quot;&quot;&quot;
        nt_ks = self.compute_conn
        if name:
            for image in nt_ks.images.list():
                if image.name == name:
                    image_id = image.id  # pylint: disable=C0103
        pairs = keys.split(&quot;,&quot;)
        if not image_id:
            return {&quot;Error&quot;: &quot;A valid image name or id was not specified&quot;}
        nt_ks.images.delete_meta(image_id, pairs)
        return {image_id: &quot;Deleted: {}&quot;.format(pairs)}

    def server_list(self):
        &quot;&quot;&quot;
        List servers
        &quot;&quot;&quot;
        nt_ks = self.compute_conn
<A NAME="0"></A>        ret = {}
        for item in nt_ks.servers.list():
            try:
                ret[item.name] <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match232089-0.html#0',2,'match232089-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>= {
                    &quot;id&quot;: item.id,
                    &quot;name&quot;: item.name,
                    &quot;state&quot;: item.status,
                    &quot;accessIPv4&quot;: item.accessIPv4,
                    &quot;accessIPv6&quot;: item.accessIPv6,
                    &quot;flavor&quot;: {&quot;id&quot;: item.flavor[&quot;id&quot;], &quot;links&quot;: item.flavor[&quot;links&quot;]},
                    &quot;image&quot;: {
                        &quot;id&quot;</B></FONT>: item.image[&quot;id&quot;] if item.image else &quot;Boot From Volume&quot;,
                        &quot;links&quot;: item.image[&quot;links&quot;] if item.image else &quot;&quot;,
                    },
                }
            except TypeError:
                pass
        return ret

    def server_list_min(self):
        &quot;&quot;&quot;
        List minimal information about servers
        &quot;&quot;&quot;
        nt_ks = self.compute_conn
        ret = {}
        for item in nt_ks.servers.list(detailed=False):
            try:
                ret[item.name] = {&quot;id&quot;: item.id, &quot;state&quot;: &quot;Running&quot;}
            except TypeError:
                pass
        return ret

    def server_list_detailed(self):
        &quot;&quot;&quot;
        Detailed list of servers
        &quot;&quot;&quot;
        nt_ks = self.compute_conn
        ret = {}
        for item in nt_ks.servers.list():
            try:
                ret[item.name] = {
                    &quot;OS-EXT-SRV-ATTR&quot;: {},
                    &quot;OS-EXT-STS&quot;: {},
                    &quot;accessIPv4&quot;: item.accessIPv4,
                    &quot;accessIPv6&quot;: item.accessIPv6,
                    &quot;addresses&quot;: item.addresses,
                    &quot;created&quot;: item.created,
                    &quot;flavor&quot;: {&quot;id&quot;: item.flavor[&quot;id&quot;], &quot;links&quot;: item.flavor[&quot;links&quot;]},
                    &quot;hostId&quot;: item.hostId,
                    &quot;id&quot;: item.id,
                    &quot;image&quot;: {
                        &quot;id&quot;: item.image[&quot;id&quot;] if item.image else &quot;Boot From Volume&quot;,
                        &quot;links&quot;: item.image[&quot;links&quot;] if item.image else &quot;&quot;,
                    },
                    &quot;key_name&quot;: item.key_name,
                    &quot;links&quot;: item.links,
                    &quot;metadata&quot;: item.metadata,
                    &quot;name&quot;: item.name,
                    &quot;state&quot;: item.status,
                    &quot;tenant_id&quot;: item.tenant_id,
                    &quot;updated&quot;: item.updated,
                    &quot;user_id&quot;: item.user_id,
                }
            except TypeError:
                continue

            ret[item.name][&quot;progress&quot;] = getattr(item, &quot;progress&quot;, &quot;0&quot;)

            if hasattr(item.__dict__, &quot;OS-DCF:diskConfig&quot;):
                ret[item.name][&quot;OS-DCF&quot;] = {
                    &quot;diskConfig&quot;: item.__dict__[&quot;OS-DCF:diskConfig&quot;]
                }
            if hasattr(item.__dict__, &quot;OS-EXT-SRV-ATTR:host&quot;):
                ret[item.name][&quot;OS-EXT-SRV-ATTR&quot;][&quot;host&quot;] = item.__dict__[
                    &quot;OS-EXT-SRV-ATTR:host&quot;
                ]
            if hasattr(item.__dict__, &quot;OS-EXT-SRV-ATTR:hypervisor_hostname&quot;):
                ret[item.name][&quot;OS-EXT-SRV-ATTR&quot;][
                    &quot;hypervisor_hostname&quot;
                ] = item.__dict__[&quot;OS-EXT-SRV-ATTR:hypervisor_hostname&quot;]
            if hasattr(item.__dict__, &quot;OS-EXT-SRV-ATTR:instance_name&quot;):
                ret[item.name][&quot;OS-EXT-SRV-ATTR&quot;][&quot;instance_name&quot;] = item.__dict__[
                    &quot;OS-EXT-SRV-ATTR:instance_name&quot;
                ]
            if hasattr(item.__dict__, &quot;OS-EXT-STS:power_state&quot;):
                ret[item.name][&quot;OS-EXT-STS&quot;][&quot;power_state&quot;] = item.__dict__[
                    &quot;OS-EXT-STS:power_state&quot;
                ]
            if hasattr(item.__dict__, &quot;OS-EXT-STS:task_state&quot;):
                ret[item.name][&quot;OS-EXT-STS&quot;][&quot;task_state&quot;] = item.__dict__[
                    &quot;OS-EXT-STS:task_state&quot;
                ]
            if hasattr(item.__dict__, &quot;OS-EXT-STS:vm_state&quot;):
                ret[item.name][&quot;OS-EXT-STS&quot;][&quot;vm_state&quot;] = item.__dict__[
                    &quot;OS-EXT-STS:vm_state&quot;
                ]
            if hasattr(item.__dict__, &quot;security_groups&quot;):
                ret[item.name][&quot;security_groups&quot;] = item.__dict__[&quot;security_groups&quot;]
        return ret

    def server_show(self, server_id):
        &quot;&quot;&quot;
        Show details of one server
        &quot;&quot;&quot;
        ret = {}
        try:
            servers = self.server_list_detailed()
        except AttributeError:
            raise SaltCloudSystemExit(
                &quot;Corrupt server in server_list_detailed. Remove corrupt servers.&quot;
            )
        for server_name, server in servers.items():
            if str(server[&quot;id&quot;]) == server_id:
                ret[server_name] = server
        return ret

    def secgroup_create(self, name, description):
        &quot;&quot;&quot;
        Create a security group
        &quot;&quot;&quot;
        nt_ks = self.compute_conn
        nt_ks.security_groups.create(name, description)
        ret = {&quot;name&quot;: name, &quot;description&quot;: description}
        return ret

    def secgroup_delete(self, name):
        &quot;&quot;&quot;
        Delete a security group
        &quot;&quot;&quot;
        nt_ks = self.compute_conn
        for item in nt_ks.security_groups.list():
            if item.name == name:
                nt_ks.security_groups.delete(item.id)
                return {name: &quot;Deleted security group: {}&quot;.format(name)}
        return &quot;Security group not found: {}&quot;.format(name)

    def secgroup_list(self):
        &quot;&quot;&quot;
        List security groups
        &quot;&quot;&quot;
        nt_ks = self.compute_conn
        ret = {}
        for item in nt_ks.security_groups.list():
            ret[item.name] = {
                &quot;name&quot;: item.name,
                &quot;description&quot;: item.description,
                &quot;id&quot;: item.id,
                &quot;tenant_id&quot;: item.tenant_id,
                &quot;rules&quot;: item.rules,
            }
        return ret

    def _item_list(self):
        &quot;&quot;&quot;
        List items
        &quot;&quot;&quot;
        nt_ks = self.compute_conn
        ret = []
        for item in nt_ks.items.list():
            ret.append(item.__dict__)
        return ret

    def _network_show(self, name, network_lst):
        &quot;&quot;&quot;
        Parse the returned network list
        &quot;&quot;&quot;
        for net in network_lst:
            if net.label == name:
                return net.__dict__
        return {}

    def network_show(self, name):
        &quot;&quot;&quot;
        Show network information
        &quot;&quot;&quot;
        nt_ks = self.compute_conn
        net_list = nt_ks.networks.list()
        return self._network_show(name, net_list)

    def network_list(self):
        &quot;&quot;&quot;
        List extra private networks
        &quot;&quot;&quot;
        nt_ks = self.compute_conn
        return [network.__dict__ for network in nt_ks.networks.list()]

    def _sanatize_network_params(self, kwargs):
        &quot;&quot;&quot;
        Sanatize novaclient network parameters
        &quot;&quot;&quot;
        params = [
            &quot;label&quot;,
            &quot;bridge&quot;,
            &quot;bridge_interface&quot;,
            &quot;cidr&quot;,
            &quot;cidr_v6&quot;,
            &quot;dns1&quot;,
            &quot;dns2&quot;,
            &quot;fixed_cidr&quot;,
            &quot;gateway&quot;,
            &quot;gateway_v6&quot;,
            &quot;multi_host&quot;,
            &quot;priority&quot;,
            &quot;project_id&quot;,
            &quot;vlan_start&quot;,
            &quot;vpn_start&quot;,
        ]

        for variable in list(kwargs):  # iterate over a copy, we might delete some
            if variable not in params:
                del kwargs[variable]
        return kwargs

    def network_create(self, name, **kwargs):
        &quot;&quot;&quot;
        Create extra private network
        &quot;&quot;&quot;
        nt_ks = self.compute_conn
        kwargs[&quot;label&quot;] = name
        kwargs = self._sanatize_network_params(kwargs)
        net = nt_ks.networks.create(**kwargs)
        return net.__dict__

    def _server_uuid_from_name(self, name):
        &quot;&quot;&quot;
        Get server uuid from name
        &quot;&quot;&quot;
        return self.server_list().get(name, {}).get(&quot;id&quot;, &quot;&quot;)

    def virtual_interface_list(self, name):
        &quot;&quot;&quot;
        Get virtual interfaces on slice
        &quot;&quot;&quot;
        nt_ks = self.compute_conn
        nets = nt_ks.virtual_interfaces.list(self._server_uuid_from_name(name))
        return [network.__dict__ for network in nets]

    def virtual_interface_create(self, name, net_name):
        &quot;&quot;&quot;
        Add an interfaces to a slice
        &quot;&quot;&quot;
        nt_ks = self.compute_conn
        serverid = self._server_uuid_from_name(name)
        networkid = self.network_show(net_name).get(&quot;id&quot;, None)
        if networkid is None:
            return {net_name: False}
        nets = nt_ks.virtual_interfaces.create(networkid, serverid)
        return nets

    def floating_ip_pool_list(self):
        &quot;&quot;&quot;
        List all floating IP pools

        .. versionadded:: 2016.3.0
        &quot;&quot;&quot;
        nt_ks = self.compute_conn
        pools = nt_ks.floating_ip_pools.list()
        response = {}
        for pool in pools:
            response[pool.name] = {
                &quot;name&quot;: pool.name,
            }
        return response

    def floating_ip_list(self):
        &quot;&quot;&quot;
        List floating IPs

        .. versionadded:: 2016.3.0
        &quot;&quot;&quot;
        nt_ks = self.compute_conn
        floating_ips = nt_ks.floating_ips.list()
        response = {}
        for floating_ip in floating_ips:
            response[floating_ip.ip] = {
                &quot;ip&quot;: floating_ip.ip,
                &quot;fixed_ip&quot;: floating_ip.fixed_ip,
                &quot;id&quot;: floating_ip.id,
                &quot;instance_id&quot;: floating_ip.instance_id,
                &quot;pool&quot;: floating_ip.pool,
            }
        return response

    def floating_ip_show(self, ip):
        &quot;&quot;&quot;
        Show info on specific floating IP

        .. versionadded:: 2016.3.0
        &quot;&quot;&quot;
        nt_ks = self.compute_conn
        floating_ips = nt_ks.floating_ips.list()
        for floating_ip in floating_ips:
            if floating_ip.ip == ip:
                response = {
                    &quot;ip&quot;: floating_ip.ip,
                    &quot;fixed_ip&quot;: floating_ip.fixed_ip,
                    &quot;id&quot;: floating_ip.id,
                    &quot;instance_id&quot;: floating_ip.instance_id,
                    &quot;pool&quot;: floating_ip.pool,
                }
                return response
        return {}

    def floating_ip_create(self, pool=None):
        &quot;&quot;&quot;
        Allocate a floating IP

        .. versionadded:: 2016.3.0
        &quot;&quot;&quot;
        nt_ks = self.compute_conn
        floating_ip = nt_ks.floating_ips.create(pool)
        response = {
            &quot;ip&quot;: floating_ip.ip,
            &quot;fixed_ip&quot;: floating_ip.fixed_ip,
            &quot;id&quot;: floating_ip.id,
            &quot;instance_id&quot;: floating_ip.instance_id,
            &quot;pool&quot;: floating_ip.pool,
        }
        return response

    def floating_ip_delete(self, floating_ip):
        &quot;&quot;&quot;
        De-allocate a floating IP

        .. versionadded:: 2016.3.0
        &quot;&quot;&quot;
        ip = self.floating_ip_show(floating_ip)
        nt_ks = self.compute_conn
        return nt_ks.floating_ips.delete(ip)

    def floating_ip_associate(self, server_name, floating_ip):
        &quot;&quot;&quot;
        Associate floating IP address to server

        .. versionadded:: 2016.3.0
        &quot;&quot;&quot;
        nt_ks = self.compute_conn
        server_ = self.server_by_name(server_name)
        server = nt_ks.servers.get(server_.__dict__[&quot;id&quot;])
        server.add_floating_ip(floating_ip)
        return self.floating_ip_list()[floating_ip]

    def floating_ip_disassociate(self, server_name, floating_ip):
        &quot;&quot;&quot;
        Disassociate a floating IP from server

        .. versionadded:: 2016.3.0
        &quot;&quot;&quot;
        nt_ks = self.compute_conn
        server_ = self.server_by_name(server_name)
        server = nt_ks.servers.get(server_.__dict__[&quot;id&quot;])
        server.remove_floating_ip(floating_ip)
        return self.floating_ip_list()[floating_ip]


# The following is a list of functions that need to be incorporated in the
# nova module. This list should be updated as functions are added.
#
# absolute-limits     Print a list of absolute limits for a user
# actions             Retrieve server actions.
# add-fixed-ip        Add new IP address to network.
# aggregate-add-host  Add the host to the specified aggregate.
# aggregate-create    Create a new aggregate with the specified details.
# aggregate-delete    Delete the aggregate by its id.
# aggregate-details   Show details of the specified aggregate.
# aggregate-list      Print a list of all aggregates.
# aggregate-remove-host
#                     Remove the specified host from the specified aggregate.
# aggregate-set-metadata
#                     Update the metadata associated with the aggregate.
# aggregate-update    Update the aggregate's name and optionally
#                     availability zone.
# cloudpipe-create    Create a cloudpipe instance for the given project
# cloudpipe-list      Print a list of all cloudpipe instances.
# console-log         Get console log output of a server.
# credentials         Show user credentials returned from auth
# describe-resource   Show details about a resource
# diagnostics         Retrieve server diagnostics.
# dns-create          Create a DNS entry for domain, name and ip.
# dns-create-private-domain
#                     Create the specified DNS domain.
# dns-create-public-domain
#                     Create the specified DNS domain.
# dns-delete          Delete the specified DNS entry.
# dns-delete-domain   Delete the specified DNS domain.
# dns-domains         Print a list of available dns domains.
# dns-list            List current DNS entries for domain and ip or domain
#                     and name.
# endpoints           Discover endpoints that get returned from the
#                     authenticate services
# get-vnc-console     Get a vnc console to a server.
# host-action         Perform a power action on a host.
# host-update         Update host settings.
# image-create        Create a new image by taking a snapshot of a running
#                     server.
# image-delete        Delete an image.
# live-migration      Migrates a running instance to a new machine.
# meta                Set or Delete metadata on a server.
# migrate             Migrate a server.
# pause               Pause a server.
# rate-limits         Print a list of rate limits for a user
# reboot              Reboot a server.
# rebuild             Shutdown, re-image, and re-boot a server.
# remove-fixed-ip     Remove an IP address from a server.
# rename              Rename a server.
# rescue              Rescue a server.
# resize              Resize a server.
# resize-confirm      Confirm a previous resize.
# resize-revert       Revert a previous resize (and return to the previous
#                     VM).
# root-password       Change the root password for a server.
# secgroup-add-group-rule
#                     Add a source group rule to a security group.
# secgroup-add-rule   Add a rule to a security group.
# secgroup-delete-group-rule
#                     Delete a source group rule from a security group.
# secgroup-delete-rule
#                     Delete a rule from a security group.
# secgroup-list-rules
#                     List rules for a security group.
# ssh                 SSH into a server.
# unlock              Unlock a server.
# unpause             Unpause a server.
# unrescue            Unrescue a server.
# usage-list          List usage data for all tenants
# volume-list         List all the volumes.
# volume-snapshot-create
#                     Add a new snapshot.
# volume-snapshot-delete
#                     Remove a snapshot.
# volume-snapshot-list
#                     List all the snapshots.
# volume-snapshot-show
#                     Show details about a snapshot.
# volume-type-create  Create a new volume type.
# volume-type-delete  Delete a specific flavor
# volume-type-list    Print a list of available 'volume types'.
# x509-create-cert    Create x509 cert for a user in tenant
# x509-get-root-cert  Fetches the x509 root cert.
</PRE>
</div>
  </div>
</body>
</html>
