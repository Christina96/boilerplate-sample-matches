<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_aix_status.py &amp; nova.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_aix_status.py &amp; nova.py
      </h3>
<h1 align="center">
        1.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_aix_status.py (16.25%)<th>nova.py (0.6770833%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(116-160)<td><a href="#" name="0">(962-970)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_aix_status.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import sys
3 import pytest
4 import salt.modules.status as status
5 from tests.support.mock import MagicMock, patch
6 log = logging.getLogger(__name__)
7 @pytest.fixture
8 def configure_loader_modules():
9     return {
10         status: {
11             "__grains__": {
12                 "ip4_interfaces": {
13                     "en0": ["129.40.94.58"],
14                     "en1": ["172.24.94.58"],
15                     "lo0": ["127.0.0.1"],
16                 },
17                 "ip6_interfaces": {"en0": [], "en1": [], "lo0": ["1"]},
18                 "kernel": "AIX",
19                 "osarch": "PowerPC_POWER8",
20                 "os": "AIX",
21                 "os_family": "AIX",
22                 "osmajorrelease": 7,
23             },
24         },
25     }
26 @pytest.mark.skipif(
27     sys.version_info[0] == 3 and sys.version_info[1] &lt;= 5,
28     reason="run on Python 3.6 or greater where OrderedDict is default",
29 )
30 def test_netdev():
31     netstat_inet4_en0 = """Name   Mtu   Network     Address                 Ipkts     Ierrs        Opkts     Oerrs  Coll
32 en0    1500  link#2      fa.41.f5.e9.bd.20  1523125     0   759364     0     0
33 en0    1500  129.40.94.5 129.40.94.58      1523125     0   759364     0     0
34     netstat_inet4_lo0 = """Name   Mtu   Network     Address                 Ipkts     Ierrs        Opkts     Oerrs  Coll
35 lo0    16896 link#1                          25568     0    25568     0     0
36 lo0    16896 127         127.0.0.1           25568     0    25568     0     0
37     netstat_inet6_en1 = """Name   Mtu   Network     Address                 Ipkts     Ierrs        Opkts     Oerrs  Coll
38 en1    1500  link#3      fa.41.f5.e9.bd.21     1089     0      402     0     0
39     netstats_out = MagicMock(
40         side_effect=[
41             netstat_inet4_en0,
42             netstat_inet6_en0,
43             netstat_inet4_en1,
44             netstat_inet6_en1,
45             netstat_inet4_lo0,
46             netstat_inet6_lo0,
47             netstat_inet4_en0,
48             netstat_inet6_en0,
49             netstat_inet4_en1,
50             netstat_inet6_en1,
51             netstat_inet4_lo0,
52             netstat_inet6_lo0,
53         ]
54     )
55     with patch.dict(
56         status.__grains__,
57         {
58             "osarch": "PowerPC_POWER8",
59             "ip4_interfaces": {
60                 "en0": ["129.40.94.58"],
61                 "en1": ["172.24.94.58"],
62                 "lo0": ["127.0.0.1"],
63             },
64             "ip6_interfaces": {
65                 "en0": [],
66                 "en1": [],
67                 "lo0": ["::1"],
68             },
69             "kernel": "AIX",
70         },
71     ), patch.dict(status.__salt__, {"cmd.run": netstats_out}):
72         netdev_out = status.netdev()
73         assert netstats_out.call_count == 12
74         netstats_out.assert_any_call("netstat -i -n -I en0 -f inet")
75         netstats_out.assert_any_call("netstat -i -n -I en1 -f inet")
76         netstats_out.assert_any_call("netstat -i -n -I lo0 -f inet")
77 <a name="0"></a>        netstats_out.assert_any_call("netstat -i -n -I en0 -f inet6")
78         netstats_out.assert_any_call("netstat -i -n -I en1 -f inet6")
79         netstats_out.assert_any_call("netstat -i -n -I lo0 -f inet6")
80         expected <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= {
81             "en0": [
82                 {
83                     "ipv4": {
84                         "Mtu": "1500",
85                         "Network": "129.40.94.5",
86                         "Address": "129.40.94.58",
87                         "Ipkts": "1523125",
88                         "Ierrs": "0",
89                         "Opkts": "759364",
90                         "Oerrs": "0",
91                         "Coll": "0",
92                     }
93                 }
94             ],
95             "en1": [
96                 {
97                     "ipv4": {
98                         "Mtu": "1500",
99                         "Network": "172.24.94.5",
100                         "Address": "172.24.94.58",
101                         "Ipkts": "1089",
102                         "Ierrs": "0",
103                         "Opkts": "402",
104                         "Oerrs": "0",
105                         "Coll": "0",
106                     }
107                 }
108             ],
109             "lo0": [
110                 {
111                     "ipv4": {
112                         "Mtu": "16896",
113                         "Network": "127",
114                         "Address": "127.0.0.1",
115                         "Ipkts": "25568",
116                         "Ierrs": "0",
117                         "Opkts": "25568",
118                         "Oerrs": "0",
119                         "Coll": "0",
120                     }
121                 },
122                 {
123                     "ipv6": {
124                         "Mtu"</b></font>: "16896",
125                         "Network": "::1%1",
126                         "Address": "25611",
127                         "Ipkts": "0",
128                         "Ierrs": "25611",
129                         "Opkts": "0",
130                         "Oerrs": "0",
131                     }
132                 },
133             ],
134         }
135         assert netdev_out == expected
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>nova.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import inspect
2 import logging
3 import time
4 import salt.utils.cloud
5 import salt.utils.files
6 from salt.exceptions import SaltCloudSystemExit
7 from salt.utils.versions import LooseVersion as _LooseVersion
8 HAS_NOVA = False
9 try:
10     import novaclient
11     from novaclient import client
12     from novaclient.shell import OpenStackComputeShell
13     import novaclient.utils
14     import novaclient.auth_plugin
15     import novaclient.exceptions
16     import novaclient.extension
17     import novaclient.base
18     HAS_NOVA = True
19 except ImportError:
20     pass
21 HAS_KEYSTONEAUTH = False
22 try:
23     import keystoneauth1.loading
24     import keystoneauth1.session
25     HAS_KEYSTONEAUTH = True
26 except ImportError:
27     pass
28 log = logging.getLogger(__name__)
29 NOVACLIENT_MINVER = "2.6.1"
30 NOVACLIENT_MAXVER = "6.0.1"
31 CLIENT_BDM2_KEYS = {
32     "id": "uuid",
33     "source": "source_type",
34     "dest": "destination_type",
35     "bus": "disk_bus",
36     "device": "device_name",
37     "size": "volume_size",
38     "format": "guest_format",
39     "bootindex": "boot_index",
40     "type": "device_type",
41     "shutdown": "delete_on_termination",
42 }
43 def check_nova():
44     if HAS_NOVA:
45         novaclient_ver = _LooseVersion(novaclient.__version__)
46         min_ver = _LooseVersion(NOVACLIENT_MINVER)
47         max_ver = _LooseVersion(NOVACLIENT_MAXVER)
48         if min_ver &lt;= novaclient_ver &lt;= max_ver:
49             return HAS_NOVA
50         elif novaclient_ver &gt; max_ver:
51             log.debug(
52                 "Older novaclient version required. Maximum: %s", NOVACLIENT_MAXVER
53             )
54             return False
55         log.debug("Newer novaclient version required.  Minimum: %s", NOVACLIENT_MINVER)
56     return False
57 if check_nova():
58     try:
59         import novaclient.auth_plugin
60     except ImportError:
61         log.debug(
62             "Using novaclient version 7.0.0 or newer. Authentication "
63             "plugin auth_plugin.py is not available anymore."
64         )
65 class KwargsStruct:
66     def __init__(self, **entries):
67         self.__dict__.update(entries)
68 def _parse_block_device_mapping_v2(
69     block_device=None, boot_volume=None, snapshot=None, ephemeral=None, swap=None
70 ):
71     bdm = []
72     if block_device is None:
73         block_device = []
74     if ephemeral is None:
75         ephemeral = []
76     if boot_volume is not None:
77         bdm_dict = {
78             "uuid": boot_volume,
79             "source_type": "volume",
80             "destination_type": "volume",
81             "boot_index": 0,
82             "delete_on_termination": False,
83         }
84         bdm.append(bdm_dict)
85     if snapshot is not None:
86         bdm_dict = {
87             "uuid": snapshot,
88             "source_type": "snapshot",
89             "destination_type": "volume",
90             "boot_index": 0,
91             "delete_on_termination": False,
92         }
93         bdm.append(bdm_dict)
94     for device_spec in block_device:
95         bdm_dict = {}
96         for key, value in device_spec.items():
97             bdm_dict[CLIENT_BDM2_KEYS[key]] = value
98         if "delete_on_termination" in bdm_dict:
99             action = bdm_dict["delete_on_termination"]
100             bdm_dict["delete_on_termination"] = action == "remove"
101         elif bdm_dict.get("destination_type") == "local":
102             bdm_dict["delete_on_termination"] = True
103         bdm.append(bdm_dict)
104     for ephemeral_spec in ephemeral:
105         bdm_dict = {
106             "source_type": "blank",
107             "destination_type": "local",
108             "boot_index": -1,
109             "delete_on_termination": True,
110         }
111         if "size" in ephemeral_spec:
112             bdm_dict["volume_size"] = ephemeral_spec["size"]
113         if "format" in ephemeral_spec:
114             bdm_dict["guest_format"] = ephemeral_spec["format"]
115         bdm.append(bdm_dict)
116     if swap is not None:
117         bdm_dict = {
118             "source_type": "blank",
119             "destination_type": "local",
120             "boot_index": -1,
121             "delete_on_termination": True,
122             "guest_format": "swap",
123             "volume_size": swap,
124         }
125         bdm.append(bdm_dict)
126     return bdm
127 class NovaServer:
128     def __init__(self, name, server, password=None):
129         self.name = name
130         self.id = server["id"]
131         self.image = server.get("image", {}).get("id", "Boot From Volume")
132         self.size = server["flavor"]["id"]
133         self.state = server["state"]
134         self._uuid = None
135         self.extra = {"metadata": server["metadata"], "access_ip": server["accessIPv4"]}
136         self.addresses = server.get("addresses", {})
137         self.public_ips, self.private_ips = [], []
138         self.fixed_ips, self.floating_ips = [], []
139         for network in self.addresses.values():
140             for addr in network:
141                 if salt.utils.cloud.is_public_ip(addr["addr"]):
142                     self.public_ips.append(addr["addr"])
143                 else:
144                     self.private_ips.append(addr["addr"])
145                 if addr.get("OS-EXT-IPS:type") == "floating":
146                     self.floating_ips.append(addr["addr"])
147                 else:
148                     self.fixed_ips.append(addr["addr"])
149         if password:
150             self.extra["password"] = password
151     def __str__(self):
152         return self.__dict__
153 def get_entry(dict_, key, value, raise_error=True):
154     for entry in dict_:
155         if entry[key] == value:
156             return entry
157     if raise_error is True:
158         raise SaltCloudSystemExit("Unable to find {} in {}.".format(key, dict_))
159     return {}
160 def get_entry_multi(dict_, pairs, raise_error=True):
161     for entry in dict_:
162         if all([entry[key] == value for key, value in pairs]):
163             return entry
164     if raise_error is True:
165         raise SaltCloudSystemExit("Unable to find {} in {}.".format(pairs, dict_))
166     return {}
167 def get_endpoint_url_v3(catalog, service_type, region_name):
168     for service_entry in catalog:
169         if service_entry["type"] == service_type:
170             for endpoint_entry in service_entry["endpoints"]:
171                 if (
172                     endpoint_entry["region"] == region_name
173                     and endpoint_entry["interface"] == "public"
174                 ):
175                     return endpoint_entry["url"]
176     return None
177 def sanatize_novaclient(kwargs):
178     variables = (
179         "username",
180         "api_key",
181         "project_id",
182         "auth_url",
183         "insecure",
184         "timeout",
185         "proxy_tenant_id",
186         "proxy_token",
187         "region_name",
188         "endpoint_type",
189         "extensions",
190         "service_type",
191         "service_name",
192         "volume_service_name",
193         "timings",
194         "bypass_url",
195         "os_cache",
196         "no_cache",
197         "http_log_debug",
198         "auth_system",
199         "auth_plugin",
200         "auth_token",
201         "cacert",
202         "tenant_id",
203     )
204     ret = {}
205     for var in kwargs:
206         if var in variables:
207             ret[var] = kwargs[var]
208     return ret
209 class SaltNova:
210     extensions = []
211     def __init__(
212         self,
213         username,
214         project_id,
215         auth_url,
216         region_name=None,
217         password=None,
218         os_auth_plugin=None,
219         use_keystoneauth=False,
220         **kwargs
221     ):
222         if all([use_keystoneauth, HAS_KEYSTONEAUTH]):
223             self._new_init(
224                 username=username,
225                 project_id=project_id,
226                 auth_url=auth_url,
227                 region_name=region_name,
228                 password=password,
229                 os_auth_plugin=os_auth_plugin,
230                 **kwargs
231             )
232         else:
233             self._old_init(
234                 username=username,
235                 project_id=project_id,
236                 auth_url=auth_url,
237                 region_name=region_name,
238                 password=password,
239                 os_auth_plugin=os_auth_plugin,
240                 **kwargs
241             )
242     def _new_init(
243         self,
244         username,
245         project_id,
246         auth_url,
247         region_name,
248         password,
249         os_auth_plugin,
250         auth=None,
251         verify=True,
252         **kwargs
253     ):
254         if auth is None:
255             auth = {}
256         loader = keystoneauth1.loading.get_plugin_loader(os_auth_plugin or "password")
257         self.client_kwargs = kwargs.copy()
258         self.kwargs = auth.copy()
259         if not self.extensions:
260             if hasattr(OpenStackComputeShell, "_discover_extensions"):
261                 self.extensions = OpenStackComputeShell()._discover_extensions("2.0")
262             else:
263                 self.extensions = client.discover_extensions("2.0")
264             for extension in self.extensions:
265                 extension.run_hooks("__pre_parse_args__")
266             self.client_kwargs["extensions"] = self.extensions
267         self.kwargs["username"] = username
268         self.kwargs["project_name"] = project_id
269         self.kwargs["auth_url"] = auth_url
270         self.kwargs["password"] = password
271         if auth_url.endswith("3"):
272             self.kwargs["user_domain_name"] = kwargs.get("user_domain_name", "default")
273             self.kwargs["project_domain_name"] = kwargs.get(
274                 "project_domain_name", "default"
275             )
276         self.client_kwargs["region_name"] = region_name
277         self.client_kwargs["service_type"] = "compute"
278         if hasattr(self, "extensions"):
279             self.kwargstruct = KwargsStruct(**self.client_kwargs)
280             for extension in self.extensions:
281                 extension.run_hooks("__post_parse_args__", self.kwargstruct)
282             self.client_kwargs = self.kwargstruct.__dict__
283         self.version = str(kwargs.get("version", 2))
284         self.client_kwargs = sanatize_novaclient(self.client_kwargs)
285         options = loader.load_from_options(**self.kwargs)
286         self.session = keystoneauth1.session.Session(auth=options, verify=verify)
287         conn = client.Client(
288             version=self.version, session=self.session, **self.client_kwargs
289         )
290         self.kwargs["auth_token"] = conn.client.session.get_token()
291         identity_service_type = kwargs.get("identity_service_type", "identity")
292         self.catalog = (
293             conn.client.session.get(
294                 "/auth/catalog", endpoint_filter={"service_type": identity_service_type}
295             )
296             .json()
297             .get("catalog", [])
298         )
299         if conn.client.get_endpoint(service_type=identity_service_type).endswith("v3"):
300             self._v3_setup(region_name)
301         else:
302             self._v2_setup(region_name)
303     def _old_init(
304         self,
305         username,
306         project_id,
307         auth_url,
308         region_name,
309         password,
310         os_auth_plugin,
311         **kwargs
312     ):
313         self.kwargs = kwargs.copy()
314         if not self.extensions:
315             if hasattr(OpenStackComputeShell, "_discover_extensions"):
316                 self.extensions = OpenStackComputeShell()._discover_extensions("2.0")
317             else:
318                 self.extensions = client.discover_extensions("2.0")
319             for extension in self.extensions:
320                 extension.run_hooks("__pre_parse_args__")
321             self.kwargs["extensions"] = self.extensions
322         self.kwargs["username"] = username
323         self.kwargs["project_id"] = project_id
324         self.kwargs["auth_url"] = auth_url
325         self.kwargs["region_name"] = region_name
326         self.kwargs["service_type"] = "compute"
327         self.kwargs["os_auth_url"] = auth_url
328         if os_auth_plugin is not None:
329             novaclient.auth_plugin.discover_auth_systems()
330             auth_plugin = novaclient.auth_plugin.load_plugin(os_auth_plugin)
331             self.kwargs["auth_plugin"] = auth_plugin
332             self.kwargs["auth_system"] = os_auth_plugin
333         if not self.kwargs.get("api_key", None):
334             self.kwargs["api_key"] = password
335         if hasattr(self, "extensions"):
336             self.kwargstruct = KwargsStruct(**self.kwargs)
337             for extension in self.extensions:
338                 extension.run_hooks("__post_parse_args__", self.kwargstruct)
339             self.kwargs = self.kwargstruct.__dict__
340         self.kwargs = sanatize_novaclient(self.kwargs)
341         self.kwargs["version"] = str(kwargs.get("version", 2))
342         conn = client.Client(**self.kwargs)
343         try:
344             conn.client.authenticate()
345         except novaclient.exceptions.AmbiguousEndpoints:
346             raise SaltCloudSystemExit(
347                 "Nova provider requires a 'region_name' to be specified"
348             )
349         self.kwargs["auth_token"] = conn.client.auth_token
350         self.catalog = conn.client.service_catalog.catalog["access"]["serviceCatalog"]
351         self._v2_setup(region_name)
352     def _v3_setup(self, region_name):
353         if region_name is not None:
354             self.client_kwargs["bypass_url"] = get_endpoint_url_v3(
355                 self.catalog, "compute", region_name
356             )
357             log.debug("Using Nova bypass_url: %s", self.client_kwargs["bypass_url"])
358         self.compute_conn = client.Client(
359             version=self.version, session=self.session, **self.client_kwargs
360         )
361         volume_endpoints = get_entry(
362             self.catalog, "type", "volume", raise_error=False
363         ).get("endpoints", {})
364         if volume_endpoints:
365             if region_name is not None:
366                 self.client_kwargs["bypass_url"] = get_endpoint_url_v3(
367                     self.catalog, "volume", region_name
368                 )
369                 log.debug(
370                     "Using Cinder bypass_url: %s", self.client_kwargs["bypass_url"]
371                 )
372             self.volume_conn = client.Client(
373                 version=self.version, session=self.session, **self.client_kwargs
374             )
375             if hasattr(self, "extensions"):
376                 self.expand_extensions()
377         else:
378             self.volume_conn = None
379     def _v2_setup(self, region_name):
380         if region_name is not None:
381             servers_endpoints = get_entry(self.catalog, "type", "compute")["endpoints"]
382             self.kwargs["bypass_url"] = get_entry(
383                 servers_endpoints, "region", region_name
384             )["publicURL"]
385         self.compute_conn = client.Client(**self.kwargs)
386         volume_endpoints = get_entry(
387             self.catalog, "type", "volume", raise_error=False
388         ).get("endpoints", {})
389         if volume_endpoints:
390             if region_name is not None:
391                 self.kwargs["bypass_url"] = get_entry(
392                     volume_endpoints, "region", region_name
393                 )["publicURL"]
394             self.volume_conn = client.Client(**self.kwargs)
395             if hasattr(self, "extensions"):
396                 self.expand_extensions()
397         else:
398             self.volume_conn = None
399     def expand_extensions(self):
400         for connection in (self.compute_conn, self.volume_conn):
401             if connection is None:
402                 continue
403             for extension in self.extensions:
404                 for attr in extension.module.__dict__:
405                     if not inspect.isclass(getattr(extension.module, attr)):
406                         continue
407                     for key, value in connection.__dict__.items():
408                         if not isinstance(value, novaclient.base.Manager):
409                             continue
410                         if value.__class__.__name__ == attr:
411                             setattr(
412                                 connection, key, extension.manager_class(connection)
413                             )
414     def get_catalog(self):
415         return self.catalog
416     def server_show_libcloud(self, uuid):
417         server_info = self.server_show(uuid)
418         server = next(iter(server_info.values()))
419         server_name = next(iter(server_info.keys()))
420         if not hasattr(self, "password"):
421             self.password = None
422         ret = NovaServer(server_name, server, self.password)
423         return ret
424     def boot(self, name, flavor_id=0, image_id=0, timeout=300, **kwargs):
425         nt_ks = self.compute_conn
426         kwargs["name"] = name
427         kwargs["flavor"] = flavor_id
428         kwargs["image"] = image_id or None
429         ephemeral = kwargs.pop("ephemeral", [])
430         block_device = kwargs.pop("block_device", [])
431         boot_volume = kwargs.pop("boot_volume", None)
432         snapshot = kwargs.pop("snapshot", None)
433         swap = kwargs.pop("swap", None)
434         kwargs["block_device_mapping_v2"] = _parse_block_device_mapping_v2(
435             block_device=block_device,
436             boot_volume=boot_volume,
437             snapshot=snapshot,
438             ephemeral=ephemeral,
439             swap=swap,
440         )
441         response = nt_ks.servers.create(**kwargs)
442         self.uuid = response.id
443         self.password = getattr(response, "adminPass", None)
444         start = time.time()
445         trycount = 0
446         while True:
447             trycount += 1
448             try:
449                 return self.server_show_libcloud(self.uuid)
450             except Exception as exc:  # pylint: disable=broad-except
451                 log.debug("Server information not yet available: %s", exc)
452                 time.sleep(1)
453                 if time.time() - start &gt; timeout:
454                     log.error(
455                         "Timed out after %s seconds while waiting for data", timeout
456                     )
457                     return False
458                 log.debug("Retrying server_show() (try %s)", trycount)
459     def show_instance(self, name):
460         return self.server_by_name(name)
461     def root_password(self, server_id, password):
462         nt_ks = self.compute_conn
463         nt_ks.servers.change_password(server_id, password)
464     def server_by_name(self, name):
465         return self.server_show_libcloud(self.server_list().get(name, {}).get("id", ""))
466     def _volume_get(self, volume_id):
467         if self.volume_conn is None:
468             raise SaltCloudSystemExit("No cinder endpoint available")
469         nt_ks = self.volume_conn
470         volume = nt_ks.volumes.get(volume_id)
471         response = {
472             "name": volume.display_name,
473             "size": volume.size,
474             "id": volume.id,
475             "description": volume.display_description,
476             "attachments": volume.attachments,
477             "status": volume.status,
478         }
479         return response
480     def volume_list(self, search_opts=None):
481         if self.volume_conn is None:
482             raise SaltCloudSystemExit("No cinder endpoint available")
483         nt_ks = self.volume_conn
484         volumes = nt_ks.volumes.list(search_opts=search_opts)
485         response = {}
486         for volume in volumes:
487             response[volume.display_name] = {
488                 "name": volume.display_name,
489                 "size": volume.size,
490                 "id": volume.id,
491                 "description": volume.display_description,
492                 "attachments": volume.attachments,
493                 "status": volume.status,
494             }
495         return response
496     def volume_show(self, name):
497         if self.volume_conn is None:
498             raise SaltCloudSystemExit("No cinder endpoint available")
499         volumes = self.volume_list(
500             search_opts={"display_name": name},
501         )
502         volume = volumes[name]
503         return volume
504     def volume_create(
505         self, name, size=100, snapshot=None, voltype=None, availability_zone=None
506     ):
507         if self.volume_conn is None:
508             raise SaltCloudSystemExit("No cinder endpoint available")
509         nt_ks = self.volume_conn
510         response = nt_ks.volumes.create(
511             size=size,
512             display_name=name,
513             volume_type=voltype,
514             snapshot_id=snapshot,
515             availability_zone=availability_zone,
516         )
517         return self._volume_get(response.id)
518     def volume_delete(self, name):
519         if self.volume_conn is None:
520             raise SaltCloudSystemExit("No cinder endpoint available")
521         nt_ks = self.volume_conn
522         try:
523             volume = self.volume_show(name)
524         except KeyError as exc:
525             raise SaltCloudSystemExit("Unable to find {} volume: {}".format(name, exc))
526         if volume["status"] == "deleted":
527             return volume
528         response = nt_ks.volumes.delete(volume["id"])
529         return volume
530     def volume_detach(self, name, timeout=300):
531         try:
532             volume = self.volume_show(name)
533         except KeyError as exc:
534             raise SaltCloudSystemExit("Unable to find {} volume: {}".format(name, exc))
535         if not volume["attachments"]:
536             return True
537         response = self.compute_conn.volumes.delete_server_volume(
538             volume["attachments"][0]["server_id"], volume["attachments"][0]["id"]
539         )
540         trycount = 0
541         start = time.time()
542         while True:
543             trycount += 1
544             try:
545                 response = self._volume_get(volume["id"])
546                 if response["status"] == "available":
547                     return response
548             except Exception as exc:  # pylint: disable=broad-except
549                 log.debug("Volume is detaching: %s", name)
550                 time.sleep(1)
551                 if time.time() - start &gt; timeout:
552                     log.error(
553                         "Timed out after %d seconds while waiting for data", timeout
554                     )
555                     return False
556                 log.debug("Retrying volume_show() (try %d)", trycount)
557     def volume_attach(self, name, server_name, device="/dev/xvdb", timeout=300):
558         try:
559             volume = self.volume_show(name)
560         except KeyError as exc:
561             raise SaltCloudSystemExit("Unable to find {} volume: {}".format(name, exc))
562         server = self.server_by_name(server_name)
563         response = self.compute_conn.volumes.create_server_volume(
564             server.id, volume["id"], device=device
565         )
566         trycount = 0
567         start = time.time()
568         while True:
569             trycount += 1
570             try:
571                 response = self._volume_get(volume["id"])
572                 if response["status"] == "in-use":
573                     return response
574             except Exception as exc:  # pylint: disable=broad-except
575                 log.debug("Volume is attaching: %s", name)
576                 time.sleep(1)
577                 if time.time() - start &gt; timeout:
578                     log.error(
579                         "Timed out after %s seconds while waiting for data", timeout
580                     )
581                     return False
582                 log.debug("Retrying volume_show() (try %s)", trycount)
583     def suspend(self, instance_id):
584         nt_ks = self.compute_conn
585         response = nt_ks.servers.suspend(instance_id)
586         return True
587     def resume(self, instance_id):
588         nt_ks = self.compute_conn
589         response = nt_ks.servers.resume(instance_id)
590         return True
591     def lock(self, instance_id):
592         nt_ks = self.compute_conn
593         response = nt_ks.servers.lock(instance_id)
594         return True
595     def delete(self, instance_id):
596         nt_ks = self.compute_conn
597         response = nt_ks.servers.delete(instance_id)
598         return True
599     def flavor_list(self):
600         nt_ks = self.compute_conn
601         ret = {}
602         for flavor in nt_ks.flavors.list():
603             links = {}
604             for link in flavor.links:
605                 links[link["rel"]] = link["href"]
606             ret[flavor.name] = {
607                 "disk": flavor.disk,
608                 "id": flavor.id,
609                 "name": flavor.name,
610                 "ram": flavor.ram,
611                 "swap": flavor.swap,
612                 "vcpus": flavor.vcpus,
613                 "links": links,
614             }
615             if hasattr(flavor, "rxtx_factor"):
616                 ret[flavor.name]["rxtx_factor"] = flavor.rxtx_factor
617         return ret
618     list_sizes = flavor_list
619     def flavor_create(
620         self,
621         name,  # pylint: disable=C0103
622         flavor_id=0,  # pylint: disable=C0103
623         ram=0,
624         disk=0,
625         vcpus=1,
626     ):
627         nt_ks = self.compute_conn
628         nt_ks.flavors.create(
629             name=name, flavorid=flavor_id, ram=ram, disk=disk, vcpus=vcpus
630         )
631         return {"name": name, "id": flavor_id, "ram": ram, "disk": disk, "vcpus": vcpus}
632     def flavor_delete(self, flavor_id):  # pylint: disable=C0103
633         nt_ks = self.compute_conn
634         nt_ks.flavors.delete(flavor_id)
635         return "Flavor deleted: {}".format(flavor_id)
636     def keypair_list(self):
637         nt_ks = self.compute_conn
638         ret = {}
639         for keypair in nt_ks.keypairs.list():
640             ret[keypair.name] = {
641                 "name": keypair.name,
642                 "fingerprint": keypair.fingerprint,
643                 "public_key": keypair.public_key,
644             }
645         return ret
646     def keypair_add(self, name, pubfile=None, pubkey=None):
647         nt_ks = self.compute_conn
648         if pubfile:
649             with salt.utils.files.fopen(pubfile, "r") as fp_:
650                 pubkey = salt.utils.stringutils.to_unicode(fp_.read())
651         if not pubkey:
652             return False
653         nt_ks.keypairs.create(name, public_key=pubkey)
654         ret = {"name": name, "pubkey": pubkey}
655         return ret
656     def keypair_delete(self, name):
657         nt_ks = self.compute_conn
658         nt_ks.keypairs.delete(name)
659         return "Keypair deleted: {}".format(name)
660     def image_show(self, image_id):
661         nt_ks = self.compute_conn
662         image = nt_ks.images.get(image_id)
663         links = {}
664         for link in image.links:
665             links[link["rel"]] = link["href"]
666         ret = {
667             "name": image.name,
668             "id": image.id,
669             "status": image.status,
670             "progress": image.progress,
671             "created": image.created,
672             "updated": image.updated,
673             "metadata": image.metadata,
674             "links": links,
675         }
676         if hasattr(image, "minDisk"):
677             ret["minDisk"] = image.minDisk
678         if hasattr(image, "minRam"):
679             ret["minRam"] = image.minRam
680         return ret
681     def image_list(self, name=None):
682         nt_ks = self.compute_conn
683         ret = {}
684         for image in nt_ks.images.list():
685             links = {}
686             for link in image.links:
687                 links[link["rel"]] = link["href"]
688             ret[image.name] = {
689                 "name": image.name,
690                 "id": image.id,
691                 "status": image.status,
692                 "progress": image.progress,
693                 "created": image.created,
694                 "updated": image.updated,
695                 "metadata": image.metadata,
696                 "links": links,
697             }
698             if hasattr(image, "minDisk"):
699                 ret[image.name]["minDisk"] = image.minDisk
700             if hasattr(image, "minRam"):
701                 ret[image.name]["minRam"] = image.minRam
702         if name:
703             return {name: ret[name]}
704         return ret
705     list_images = image_list
706     def image_meta_set(
707         self, image_id=None, name=None, **kwargs
708     ):  # pylint: disable=C0103
709         nt_ks = self.compute_conn
710         if name:
711             for image in nt_ks.images.list():
712                 if image.name == name:
713                     image_id = image.id  # pylint: disable=C0103
714         if not image_id:
715             return {"Error": "A valid image name or id was not specified"}
716         nt_ks.images.set_meta(image_id, kwargs)
717         return {image_id: kwargs}
718     def image_meta_delete(
719         self, image_id=None, name=None, keys=None  # pylint: disable=C0103
720     ):
721         nt_ks = self.compute_conn
722         if name:
723             for image in nt_ks.images.list():
724                 if image.name == name:
725                     image_id = image.id  # pylint: disable=C0103
726         pairs = keys.split(",")
727         if not image_id:
728             return {"Error": "A valid image name or id was not specified"}
729         nt_ks.images.delete_meta(image_id, pairs)
730         return {image_id: "Deleted: {}".format(pairs)}
731     def server_list(self):
732         nt_ks = self.compute_conn
733 <a name="0"></a>        ret = {}
734         for item in nt_ks.servers.list():
735             try:
736                 ret[item.name] <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= {
737                     "id": item.id,
738                     "name": item.name,
739                     "state": item.status,
740                     "accessIPv4": item.accessIPv4,
741                     "accessIPv6": item.accessIPv6,
742                     "flavor": {"id": item.flavor["id"], "links": item.flavor["links"]},
743                     "image": {
744                         "id"</b></font>: item.image["id"] if item.image else "Boot From Volume",
745                         "links": item.image["links"] if item.image else "",
746                     },
747                 }
748             except TypeError:
749                 pass
750         return ret
751     def server_list_min(self):
752         nt_ks = self.compute_conn
753         ret = {}
754         for item in nt_ks.servers.list(detailed=False):
755             try:
756                 ret[item.name] = {"id": item.id, "state": "Running"}
757             except TypeError:
758                 pass
759         return ret
760     def server_list_detailed(self):
761         nt_ks = self.compute_conn
762         ret = {}
763         for item in nt_ks.servers.list():
764             try:
765                 ret[item.name] = {
766                     "OS-EXT-SRV-ATTR": {},
767                     "OS-EXT-STS": {},
768                     "accessIPv4": item.accessIPv4,
769                     "accessIPv6": item.accessIPv6,
770                     "addresses": item.addresses,
771                     "created": item.created,
772                     "flavor": {"id": item.flavor["id"], "links": item.flavor["links"]},
773                     "hostId": item.hostId,
774                     "id": item.id,
775                     "image": {
776                         "id": item.image["id"] if item.image else "Boot From Volume",
777                         "links": item.image["links"] if item.image else "",
778                     },
779                     "key_name": item.key_name,
780                     "links": item.links,
781                     "metadata": item.metadata,
782                     "name": item.name,
783                     "state": item.status,
784                     "tenant_id": item.tenant_id,
785                     "updated": item.updated,
786                     "user_id": item.user_id,
787                 }
788             except TypeError:
789                 continue
790             ret[item.name]["progress"] = getattr(item, "progress", "0")
791             if hasattr(item.__dict__, "OS-DCF:diskConfig"):
792                 ret[item.name]["OS-DCF"] = {
793                     "diskConfig": item.__dict__["OS-DCF:diskConfig"]
794                 }
795             if hasattr(item.__dict__, "OS-EXT-SRV-ATTR:host"):
796                 ret[item.name]["OS-EXT-SRV-ATTR"]["host"] = item.__dict__[
797                     "OS-EXT-SRV-ATTR:host"
798                 ]
799             if hasattr(item.__dict__, "OS-EXT-SRV-ATTR:hypervisor_hostname"):
800                 ret[item.name]["OS-EXT-SRV-ATTR"][
801                     "hypervisor_hostname"
802                 ] = item.__dict__["OS-EXT-SRV-ATTR:hypervisor_hostname"]
803             if hasattr(item.__dict__, "OS-EXT-SRV-ATTR:instance_name"):
804                 ret[item.name]["OS-EXT-SRV-ATTR"]["instance_name"] = item.__dict__[
805                     "OS-EXT-SRV-ATTR:instance_name"
806                 ]
807             if hasattr(item.__dict__, "OS-EXT-STS:power_state"):
808                 ret[item.name]["OS-EXT-STS"]["power_state"] = item.__dict__[
809                     "OS-EXT-STS:power_state"
810                 ]
811             if hasattr(item.__dict__, "OS-EXT-STS:task_state"):
812                 ret[item.name]["OS-EXT-STS"]["task_state"] = item.__dict__[
813                     "OS-EXT-STS:task_state"
814                 ]
815             if hasattr(item.__dict__, "OS-EXT-STS:vm_state"):
816                 ret[item.name]["OS-EXT-STS"]["vm_state"] = item.__dict__[
817                     "OS-EXT-STS:vm_state"
818                 ]
819             if hasattr(item.__dict__, "security_groups"):
820                 ret[item.name]["security_groups"] = item.__dict__["security_groups"]
821         return ret
822     def server_show(self, server_id):
823         ret = {}
824         try:
825             servers = self.server_list_detailed()
826         except AttributeError:
827             raise SaltCloudSystemExit(
828                 "Corrupt server in server_list_detailed. Remove corrupt servers."
829             )
830         for server_name, server in servers.items():
831             if str(server["id"]) == server_id:
832                 ret[server_name] = server
833         return ret
834     def secgroup_create(self, name, description):
835         nt_ks = self.compute_conn
836         nt_ks.security_groups.create(name, description)
837         ret = {"name": name, "description": description}
838         return ret
839     def secgroup_delete(self, name):
840         nt_ks = self.compute_conn
841         for item in nt_ks.security_groups.list():
842             if item.name == name:
843                 nt_ks.security_groups.delete(item.id)
844                 return {name: "Deleted security group: {}".format(name)}
845         return "Security group not found: {}".format(name)
846     def secgroup_list(self):
847         nt_ks = self.compute_conn
848         ret = {}
849         for item in nt_ks.security_groups.list():
850             ret[item.name] = {
851                 "name": item.name,
852                 "description": item.description,
853                 "id": item.id,
854                 "tenant_id": item.tenant_id,
855                 "rules": item.rules,
856             }
857         return ret
858     def _item_list(self):
859         nt_ks = self.compute_conn
860         ret = []
861         for item in nt_ks.items.list():
862             ret.append(item.__dict__)
863         return ret
864     def _network_show(self, name, network_lst):
865         for net in network_lst:
866             if net.label == name:
867                 return net.__dict__
868         return {}
869     def network_show(self, name):
870         nt_ks = self.compute_conn
871         net_list = nt_ks.networks.list()
872         return self._network_show(name, net_list)
873     def network_list(self):
874         nt_ks = self.compute_conn
875         return [network.__dict__ for network in nt_ks.networks.list()]
876     def _sanatize_network_params(self, kwargs):
877         params = [
878             "label",
879             "bridge",
880             "bridge_interface",
881             "cidr",
882             "cidr_v6",
883             "dns1",
884             "dns2",
885             "fixed_cidr",
886             "gateway",
887             "gateway_v6",
888             "multi_host",
889             "priority",
890             "project_id",
891             "vlan_start",
892             "vpn_start",
893         ]
894         for variable in list(kwargs):  # iterate over a copy, we might delete some
895             if variable not in params:
896                 del kwargs[variable]
897         return kwargs
898     def network_create(self, name, **kwargs):
899         nt_ks = self.compute_conn
900         kwargs["label"] = name
901         kwargs = self._sanatize_network_params(kwargs)
902         net = nt_ks.networks.create(**kwargs)
903         return net.__dict__
904     def _server_uuid_from_name(self, name):
905         return self.server_list().get(name, {}).get("id", "")
906     def virtual_interface_list(self, name):
907         nt_ks = self.compute_conn
908         nets = nt_ks.virtual_interfaces.list(self._server_uuid_from_name(name))
909         return [network.__dict__ for network in nets]
910     def virtual_interface_create(self, name, net_name):
911         nt_ks = self.compute_conn
912         serverid = self._server_uuid_from_name(name)
913         networkid = self.network_show(net_name).get("id", None)
914         if networkid is None:
915             return {net_name: False}
916         nets = nt_ks.virtual_interfaces.create(networkid, serverid)
917         return nets
918     def floating_ip_pool_list(self):
919         nt_ks = self.compute_conn
920         pools = nt_ks.floating_ip_pools.list()
921         response = {}
922         for pool in pools:
923             response[pool.name] = {
924                 "name": pool.name,
925             }
926         return response
927     def floating_ip_list(self):
928         nt_ks = self.compute_conn
929         floating_ips = nt_ks.floating_ips.list()
930         response = {}
931         for floating_ip in floating_ips:
932             response[floating_ip.ip] = {
933                 "ip": floating_ip.ip,
934                 "fixed_ip": floating_ip.fixed_ip,
935                 "id": floating_ip.id,
936                 "instance_id": floating_ip.instance_id,
937                 "pool": floating_ip.pool,
938             }
939         return response
940     def floating_ip_show(self, ip):
941         nt_ks = self.compute_conn
942         floating_ips = nt_ks.floating_ips.list()
943         for floating_ip in floating_ips:
944             if floating_ip.ip == ip:
945                 response = {
946                     "ip": floating_ip.ip,
947                     "fixed_ip": floating_ip.fixed_ip,
948                     "id": floating_ip.id,
949                     "instance_id": floating_ip.instance_id,
950                     "pool": floating_ip.pool,
951                 }
952                 return response
953         return {}
954     def floating_ip_create(self, pool=None):
955         nt_ks = self.compute_conn
956         floating_ip = nt_ks.floating_ips.create(pool)
957         response = {
958             "ip": floating_ip.ip,
959             "fixed_ip": floating_ip.fixed_ip,
960             "id": floating_ip.id,
961             "instance_id": floating_ip.instance_id,
962             "pool": floating_ip.pool,
963         }
964         return response
965     def floating_ip_delete(self, floating_ip):
966         ip = self.floating_ip_show(floating_ip)
967         nt_ks = self.compute_conn
968         return nt_ks.floating_ips.delete(ip)
969     def floating_ip_associate(self, server_name, floating_ip):
970         nt_ks = self.compute_conn
971         server_ = self.server_by_name(server_name)
972         server = nt_ks.servers.get(server_.__dict__["id"])
973         server.add_floating_ip(floating_ip)
974         return self.floating_ip_list()[floating_ip]
975     def floating_ip_disassociate(self, server_name, floating_ip):
976         nt_ks = self.compute_conn
977         server_ = self.server_by_name(server_name)
978         server = nt_ks.servers.get(server_.__dict__["id"])
979         server.remove_floating_ip(floating_ip)
980         return self.floating_ip_list()[floating_ip]
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
