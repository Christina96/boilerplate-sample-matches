<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for gen.py &amp; version.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for gen.py &amp; version.py
      </h3>
<h1 align="center">
        0.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>gen.py (0.9456265%)<th>version.py (0.7707129%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(986-991)<td><a href="#" name="0">(319-324)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>gen.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from __future__ import absolute_import, division, print_function
2 import collections
3 import functools
4 import itertools
5 import os
6 import sys
7 import textwrap
8 import types
9 import weakref
10 import salt.ext.tornado as tornado
11 from salt.ext.tornado.concurrent import Future, TracebackFuture, is_future, chain_future
12 from salt.ext.tornado.ioloop import IOLoop
13 from salt.ext.tornado.log import app_log
14 from salt.ext.tornado import stack_context
15 from salt.ext.tornado.util import PY3, raise_exc_info
16 try:
17     try:
18         from functools import singledispatch  # type: ignore
19     except ImportError:
20         from singledispatch import singledispatch  # backport
21 except ImportError:
22     if 'APPENGINE_RUNTIME' not in os.environ:
23         raise
24     singledispatch = None
25 try:
26     try:
27         from collections.abc import Generator as GeneratorType  # type: ignore
28     except ImportError:
29         from salt.ext.backports_abc import Generator as GeneratorType  # type: ignore
30     try:
31         from inspect import isawaitable  # type: ignore
32     except ImportError:
33         from salt.ext.backports_abc import isawaitable
34 except ImportError:
35     if 'APPENGINE_RUNTIME' not in os.environ:
36         raise
37     from types import GeneratorType
38     def isawaitable(x):  # type: ignore
39         return False
40 if PY3:
41     import builtins
42 else:
43     import __builtin__ as builtins
44 class KeyReuseError(Exception):
45     pass
46 class UnknownKeyError(Exception):
47     pass
48 class LeakedCallbackError(Exception):
49     pass
50 class BadYieldError(Exception):
51     pass
52 class ReturnValueIgnoredError(Exception):
53     pass
54 class TimeoutError(Exception):
55 def _value_from_stopiteration(e):
56     try:
57         return e.value
58     except AttributeError:
59         pass
60     try:
61         return e.args[0]
62     except (AttributeError, IndexError):
63         return None
64 def engine(func):
65     func = _make_coroutine_wrapper(func, replace_callback=False)
66     @functools.wraps(func)
67     def wrapper(*args, **kwargs):
68         future = func(*args, **kwargs)
69         def final_callback(future):
70             if future.result() is not None:
71                 raise ReturnValueIgnoredError(
72                     "@gen.engine functions cannot return values: %r" %
73                     (future.result(),))
74         future.add_done_callback(stack_context.wrap(final_callback))
75     return wrapper
76 def coroutine(func, replace_callback=True):
77     return _make_coroutine_wrapper(func, replace_callback=True)
78 _futures_to_runners = weakref.WeakKeyDictionary()
79 def _make_coroutine_wrapper(func, replace_callback):
80     wrapped = func
81     if hasattr(types, 'coroutine'):
82         func = types.coroutine(func)
83     @functools.wraps(wrapped)
84     def wrapper(*args, **kwargs):
85         future = TracebackFuture()
86         if replace_callback and 'callback' in kwargs:
87             callback = kwargs.pop('callback')
88             IOLoop.current().add_future(
89                 future, lambda future: callback(future.result()))
90         try:
91             result = func(*args, **kwargs)
92         except (Return, StopIteration) as e:
93             result = _value_from_stopiteration(e)
94         except Exception:
95             future.set_exc_info(sys.exc_info())
96             return future
97         else:
98             if isinstance(result, GeneratorType):
99                 try:
100                     orig_stack_contexts = stack_context._state.contexts
101                     yielded = next(result)
102                     if stack_context._state.contexts is not orig_stack_contexts:
103                         yielded = TracebackFuture()
104                         yielded.set_exception(
105                             stack_context.StackContextInconsistentError(
106                                 'stack_context inconsistency (probably caused '
107                                 'by yield within a "with StackContext" block)'))
108                 except (StopIteration, Return) as e:
109                     future.set_result(_value_from_stopiteration(e))
110                 except Exception:
111                     future.set_exc_info(sys.exc_info())
112                 else:
113                     _futures_to_runners[future] = Runner(result, future, yielded)
114                 yielded = None
115                 try:
116                     return future
117                 finally:
118                     future = None
119         future.set_result(result)
120         return future
121     wrapper.__wrapped__ = wrapped
122     wrapper.__tornado_coroutine__ = True
123     return wrapper
124 def is_coroutine_function(func):
125     return getattr(func, '__tornado_coroutine__', False)
126 class Return(Exception):
127     def __init__(self, value=None):
128         super(Return, self).__init__()
129         self.value = value
130         self.args = (value,)
131 class WaitIterator(object):
132     def __init__(self, *args, **kwargs):
133         if args and kwargs:
134             raise ValueError(
135                 "You must provide args or kwargs, not both")
136         if kwargs:
137             self._unfinished = dict((f, k) for (k, f) in kwargs.items())
138             futures = list(kwargs.values())
139         else:
140             self._unfinished = dict((f, i) for (i, f) in enumerate(args))
141             futures = args
142         self._finished = collections.deque()
143         self.current_index = self.current_future = None
144         self._running_future = None
145         for future in futures:
146             future.add_done_callback(self._done_callback)
147     def done(self):
148         if self._finished or self._unfinished:
149             return False
150         self.current_index = self.current_future = None
151         return True
152     def next(self):
153         self._running_future = TracebackFuture()
154         if self._finished:
155             self._return_result(self._finished.popleft())
156         return self._running_future
157     def _done_callback(self, done):
158         if self._running_future and not self._running_future.done():
159             self._return_result(done)
160         else:
161             self._finished.append(done)
162     def _return_result(self, done):
163         chain_future(done, self._running_future)
164         self.current_future = done
165         self.current_index = self._unfinished.pop(done)
166     def __aiter__(self):
167         raise self
168     def __anext__(self):
169         if self.done():
170             raise getattr(builtins, 'StopAsyncIteration')()
171         return self.next()
172 class YieldPoint(object):
173     def start(self, runner):
174         raise NotImplementedError()
175     def is_ready(self):
176         raise NotImplementedError()
177     def get_result(self):
178         raise NotImplementedError()
179 class Callback(YieldPoint):
180     def __init__(self, key):
181         self.key = key
182     def start(self, runner):
183         self.runner = runner
184         runner.register_callback(self.key)
185     def is_ready(self):
186         return True
187     def get_result(self):
188         return self.runner.result_callback(self.key)
189 class Wait(YieldPoint):
190     def __init__(self, key):
191         self.key = key
192     def start(self, runner):
193         self.runner = runner
194     def is_ready(self):
195         return self.runner.is_ready(self.key)
196     def get_result(self):
197         return self.runner.pop_result(self.key)
198 class WaitAll(YieldPoint):
199     def __init__(self, keys):
200         self.keys = keys
201     def start(self, runner):
202         self.runner = runner
203     def is_ready(self):
204         return all(self.runner.is_ready(key) for key in self.keys)
205     def get_result(self):
206         return [self.runner.pop_result(key) for key in self.keys]
207 def Task(func, *args, **kwargs):
208     future = Future()
209     def handle_exception(typ, value, tb):
210         if future.done():
211             return False
212         future.set_exc_info((typ, value, tb))
213         return True
214     def set_result(result):
215         if future.done():
216             return
217         future.set_result(result)
218     with stack_context.ExceptionStackContext(handle_exception):
219         func(*args, callback=_argument_adapter(set_result), **kwargs)
220     return future
221 class YieldFuture(YieldPoint):
222     def __init__(self, future, io_loop=None):
223         self.future = future
224         self.io_loop = io_loop or IOLoop.current()
225     def start(self, runner):
226         if not self.future.done():
227             self.runner = runner
228             self.key = object()
229             runner.register_callback(self.key)
230             self.io_loop.add_future(self.future, runner.result_callback(self.key))
231         else:
232             self.runner = None
233             self.result_fn = self.future.result
234     def is_ready(self):
235         if self.runner is not None:
236             return self.runner.is_ready(self.key)
237         else:
238             return True
239     def get_result(self):
240         if self.runner is not None:
241             return self.runner.pop_result(self.key).result()
242         else:
243             return self.result_fn()
244 def _contains_yieldpoint(children):
245     if isinstance(children, dict):
246         return any(isinstance(i, YieldPoint) for i in children.values())
247     if isinstance(children, list):
248         return any(isinstance(i, YieldPoint) for i in children)
249     return False
250 def multi(children, quiet_exceptions=()):
251     if _contains_yieldpoint(children):
252         return MultiYieldPoint(children, quiet_exceptions=quiet_exceptions)
253     else:
254         return multi_future(children, quiet_exceptions=quiet_exceptions)
255 Multi = multi
256 class MultiYieldPoint(YieldPoint):
257     def __init__(self, children, quiet_exceptions=()):
258         self.keys = None
259         if isinstance(children, dict):
260             self.keys = list(children.keys())
261             children = children.values()
262         self.children = []
263         for i in children:
264             if not isinstance(i, YieldPoint):
265                 i = convert_yielded(i)
266             if is_future(i):
267                 i = YieldFuture(i)
268             self.children.append(i)
269         assert all(isinstance(i, YieldPoint) for i in self.children)
270         self.unfinished_children = set(self.children)
271         self.quiet_exceptions = quiet_exceptions
272     def start(self, runner):
273         for i in self.children:
274             i.start(runner)
275     def is_ready(self):
276         finished = list(itertools.takewhile(
277             lambda i: i.is_ready(), self.unfinished_children))
278         self.unfinished_children.difference_update(finished)
279         return not self.unfinished_children
280     def get_result(self):
281         result_list = []
282         exc_info = None
283         for f in self.children:
284             try:
285                 result_list.append(f.get_result())
286             except Exception as e:
287                 if exc_info is None:
288                     exc_info = sys.exc_info()
289                 else:
290                     if not isinstance(e, self.quiet_exceptions):
291                         app_log.error("Multiple exceptions in yield list",
292                                       exc_info=True)
293         if exc_info is not None:
294             raise_exc_info(exc_info)
295         if self.keys is not None:
296             return dict(zip(self.keys, result_list))
297         else:
298             return list(result_list)
299 def multi_future(children, quiet_exceptions=()):
300     if isinstance(children, dict):
301         keys = list(children.keys())
302         children = children.values()
303     else:
304         keys = None
305     children = list(map(convert_yielded, children))
306     assert all(is_future(i) for i in children)
307     unfinished_children = set(children)
308     future = Future()
309     if not children:
310         future.set_result({} if keys is not None else [])
311     def callback(f):
312         unfinished_children.remove(f)
313         if not unfinished_children:
314             result_list = []
315             for f in children:
316                 try:
317                     result_list.append(f.result())
318                 except Exception as e:
319                     if future.done():
320                         if not isinstance(e, quiet_exceptions):
321                             app_log.error("Multiple exceptions in yield list",
322                                           exc_info=True)
323                     else:
324                         future.set_exc_info(sys.exc_info())
325             if not future.done():
326                 if keys is not None:
327                     future.set_result(dict(zip(keys, result_list)))
328                 else:
329                     future.set_result(result_list)
330     listening = set()
331     for f in children:
332         if f not in listening:
333             listening.add(f)
334             f.add_done_callback(callback)
335     return future
336 def maybe_future(x):
337     if is_future(x):
338         return x
339     else:
340         fut = Future()
341         fut.set_result(x)
342         return fut
343 def with_timeout(timeout, future, io_loop=None, quiet_exceptions=()):
344     future = convert_yielded(future)
345     result = Future()
346     chain_future(future, result)
347     if io_loop is None:
348         io_loop = IOLoop.current()
349     def error_callback(future):
350         try:
351             future.result()
352         except Exception as e:
353             if not isinstance(e, quiet_exceptions):
354                 app_log.error("Exception in Future %r after timeout",
355                               future, exc_info=True)
356     def timeout_callback():
357         result.set_exception(TimeoutError("Timeout"))
358         future.add_done_callback(error_callback)
359     timeout_handle = io_loop.add_timeout(
360         timeout, timeout_callback)
361     if isinstance(future, Future):
362         future.add_done_callback(
363             lambda future: io_loop.remove_timeout(timeout_handle))
364     else:
365         io_loop.add_future(
366             future, lambda future: io_loop.remove_timeout(timeout_handle))
367     return result
368 def sleep(duration):
369     f = Future()
370     IOLoop.current().call_later(duration, lambda: f.set_result(None))
371     return f
372 _null_future = Future()
373 _null_future.set_result(None)
374 moment = Future()
375 moment.__doc__ = \
376 moment.set_result(None)
377 class Runner(object):
378     def __init__(self, gen, result_future, first_yielded):
379         self<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.gen = gen
380         self.result_future = result_future
381         self.future = _null_future
382         self.yield_point = None
383         self.pending_callbacks = None
384         self.results =</b></font> None
385         self.running = False
386         self.finished = False
387         self.had_exception = False
388         self.io_loop = IOLoop.current()
389         self.stack_context_deactivate = None
390         if self.handle_yield(first_yielded):
391             gen = result_future = first_yielded = None
392             self.run()
393     def register_callback(self, key):
394         if self.pending_callbacks is None:
395             self.pending_callbacks = set()
396             self.results = {}
397         if key in self.pending_callbacks:
398             raise KeyReuseError("key %r is already pending" % (key,))
399         self.pending_callbacks.add(key)
400     def is_ready(self, key):
401         if self.pending_callbacks is None or key not in self.pending_callbacks:
402             raise UnknownKeyError("key %r is not pending" % (key,))
403         return key in self.results
404     def set_result(self, key, result):
405         self.results[key] = result
406         if self.yield_point is not None and self.yield_point.is_ready():
407             try:
408                 self.future.set_result(self.yield_point.get_result())
409             except:
410                 self.future.set_exc_info(sys.exc_info())
411             self.yield_point = None
412             self.run()
413     def pop_result(self, key):
414         self.pending_callbacks.remove(key)
415         return self.results.pop(key)
416     def run(self):
417         if self.running or self.finished:
418             return
419         try:
420             self.running = True
421             while True:
422                 future = self.future
423                 if not future.done():
424                     return
425                 self.future = None
426                 try:
427                     orig_stack_contexts = stack_context._state.contexts
428                     exc_info = None
429                     try:
430                         value = future.result()
431                     except Exception:
432                         self.had_exception = True
433                         exc_info = sys.exc_info()
434                     future = None
435                     if exc_info is not None:
436                         try:
437                             yielded = self.gen.throw(*exc_info)
438                         finally:
439                             exc_info = None
440                     else:
441                         yielded = self.gen.send(value)
442                     if stack_context._state.contexts is not orig_stack_contexts:
443                         self.gen.throw(
444                             stack_context.StackContextInconsistentError(
445                                 'stack_context inconsistency (probably caused '
446                                 'by yield within a "with StackContext" block)'))
447                 except (StopIteration, Return) as e:
448                     self.finished = True
449                     self.future = _null_future
450                     if self.pending_callbacks and not self.had_exception:
451                         raise LeakedCallbackError(
452                             "finished without waiting for callbacks %r" %
453                             self.pending_callbacks)
454                     self.result_future.set_result(_value_from_stopiteration(e))
455                     self.result_future = None
456                     self._deactivate_stack_context()
457                     return
458                 except Exception:
459                     self.finished = True
460                     self.future = _null_future
461                     self.result_future.set_exc_info(sys.exc_info())
462                     self.result_future = None
463                     self._deactivate_stack_context()
464                     return
465                 if not self.handle_yield(yielded):
466                     return
467                 yielded = None
468         finally:
469             self.running = False
470     def handle_yield(self, yielded):
471         if _contains_yieldpoint(yielded):
472             yielded = multi(yielded)
473         if isinstance(yielded, YieldPoint):
474             self.future = TracebackFuture()
475             def start_yield_point():
476                 try:
477                     yielded.start(self)
478                     if yielded.is_ready():
479                         self.future.set_result(
480                             yielded.get_result())
481                     else:
482                         self.yield_point = yielded
483                 except Exception:
484                     self.future = TracebackFuture()
485                     self.future.set_exc_info(sys.exc_info())
486             if self.stack_context_deactivate is None:
487                 with stack_context.ExceptionStackContext(
488                         self.handle_exception) as deactivate:
489                     self.stack_context_deactivate = deactivate
490                     def cb():
491                         start_yield_point()
492                         self.run()
493                     self.io_loop.add_callback(cb)
494                     return False
495             else:
496                 start_yield_point()
497         else:
498             try:
499                 self.future = convert_yielded(yielded)
500             except BadYieldError:
501                 self.future = TracebackFuture()
502                 self.future.set_exc_info(sys.exc_info())
503         if not self.future.done() or self.future is moment:
504             def inner(f):
505                 f = None # noqa
506                 self.run()
507             self.io_loop.add_future(
508                 self.future, inner)
509             return False
510         return True
511     def result_callback(self, key):
512         return stack_context.wrap(_argument_adapter(
513             functools.partial(self.set_result, key)))
514     def handle_exception(self, typ, value, tb):
515         if not self.running and not self.finished:
516             self.future = TracebackFuture()
517             self.future.set_exc_info((typ, value, tb))
518             self.run()
519             return True
520         else:
521             return False
522     def _deactivate_stack_context(self):
523         if self.stack_context_deactivate is not None:
524             self.stack_context_deactivate()
525             self.stack_context_deactivate = None
526 Arguments = collections.namedtuple('Arguments', ['args', 'kwargs'])
527 def _argument_adapter(callback):
528     def wrapper(*args, **kwargs):
529         if kwargs or len(args) &gt; 1:
530             callback(Arguments(args, kwargs))
531         elif args:
532             callback(args[0])
533         else:
534             callback(None)
535     return wrapper
536 if sys.version_info &gt;= (3, 3):
537     exec(textwrap.dedent("""
538     @coroutine
539     def _wrap_awaitable(x):
540         if hasattr(x, '__await__'):
541             x = x.__await__()
542         return (yield from x)
543     The default implementation accepts lists, dictionaries, and Futures.
544     If the `~functools.singledispatch` library is available, this function
545     may be extended to support additional types. For example::
546         @convert_yielded.register(asyncio.Future)
547         def _(asyncio_future):
548             return tornado.platform.asyncio.to_tornado_future(asyncio_future)
549     .. versionadded:: 4.1
550 Set up the version of Salt
551     Handle SaltStack versions class.
552     Knows how to parse ``git describe`` output, knows about release candidates
553     and also supports version comparison.
554     """
555         self<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.major = major
556         self.minor = minor
557         self.bugfix = bugfix
558         self.mbugfix = mbugfix
559         self.pre_type = pre_type
560         self.pre_num =</b></font> pre_num
561         if self.new_version(major):
562             vnames_key = (major,)
563         else:
564             vnames_key = (major, minor)
565         self.name = self.VNAMES.get(vnames_key)
566         self.noc = noc
567         self.sha = sha
568     def new_version(self, major):
569         """
570         determine if using new versioning scheme
571         """
572         return bool(int(major) &gt;= 3000 and int(major) &lt; VERSION_LIMIT)
573     @classmethod
574     def parse(cls, version_string):
575         if version_string.lower() in cls.LNAMES:
576             return cls.from_name(version_string)
577         vstr = (
578             version_string.decode()
579             if isinstance(version_string, bytes)
580             else version_string
581         )
582         match = cls.git_describe_regex.match(vstr)
583         if not match:
584             raise ValueError(
585                 "Unable to parse version string: '{}'".format(version_string)
586             )
587         return cls(*match.groups())
588     @classmethod
589     def from_name(cls, name):
590         if name.lower() not in cls.LNAMES:
591             raise ValueError("Named version '{}' is not known".format(name))
592         return cls(*cls.LNAMES[name.lower()])
593     @classmethod
594     def from_last_named_version(cls):
595         import salt.utils.versions
596         salt.utils.versions.warn_until(
597             SaltVersionsInfo.SULFUR,
598             "The use of SaltStackVersion.from_last_named_version() is "
599             "deprecated and set to be removed in {version}. Please use "
600             "SaltStackVersion.current_release() instead.",
601         )
602         return cls.current_release()
603     @classmethod
604     def current_release(cls):
605         return cls(*SaltVersionsInfo.current_release().info)
606     @classmethod
607     def next_release(cls):
608         return cls(*SaltVersionsInfo.next_release().info)
609     @property
610     def sse(self):
611         return 0 &lt; self.major &lt; 2014
612     def min_info(self):
613         info = [self.major]
614         if self.new_version(self.major):
615             if self.minor:
616                 info.append(self.minor)
617         else:
618             info.extend([self.minor, self.bugfix, self.mbugfix])
619         return info
620     @property
621     def info(self):
622         return tuple(self.min_info())
623     @property
624     def pre_info(self):
625         info = self.min_info()
626         info.extend([self.pre_type, self.pre_num])
627         return tuple(info)
628     @property
629     def noc_info(self):
630         info = self.min_info()
631         info.extend([self.pre_type, self.pre_num, self.noc])
632         return tuple(info)
633     @property
634     def full_info(self):
635         info = self.min_info()
636         info.extend([self.pre_type, self.pre_num, self.noc, self.sha])
637         return tuple(info)
638     @property
639     def full_info_all_versions(self):
640         """
641         Return the full info regardless
642         of which versioning scheme we
643         are using.
644         """
645         info = [
646             self.major,
647             self.minor,
648             self.bugfix,
649             self.mbugfix,
650             self.pre_type,
651             self.pre_num,
652             self.noc,
653             self.sha,
654         ]
655         return tuple(info)
656     @property
657     def string(self):
658         if self.new_version(self.major):
659             version_string = "{}".format(self.major)
660             if self.minor:
661                 version_string = "{}.{}".format(self.major, self.minor)
662         else:
663             version_string = "{}.{}.{}".format(self.major, self.minor, self.bugfix)
664         if self.mbugfix:
665             version_string += ".{}".format(self.mbugfix)
666         if self.pre_type:
667             version_string += "{}{}".format(self.pre_type, self.pre_num)
668         if self.noc and self.sha:
669             noc = self.noc
670             if noc &lt; 0:
671                 noc = "0na"
672             version_string += "+{}.{}".format(noc, self.sha)
673         return version_string
674     @property
675     def formatted_version(self):
676         if self.name and self.major &gt; 10000:
677             version_string = self.name
678             if self.sse:
679                 version_string += " Enterprise"
680             version_string += " (Unreleased)"
681             return version_string
682         version_string = self.string
683         if self.sse:
684             version_string += " Enterprise"
685         if (self.major, self.minor) in self.RMATCH:
686             version_string += " ({})".format(self.RMATCH[(self.major, self.minor)])
687         return version_string
688     @property
689     def pre_index(self):
690         if self.new_version(self.major):
691             pre_type = 2
692             if not isinstance(self.minor, int):
693                 pre_type = 1
694         else:
695             pre_type = 4
696         return pre_type
697     def __str__(self):
698         return self.string
699     def __compare__(self, other, method):
700         if not isinstance(other, SaltStackVersion):
701             if isinstance(other, str):
702                 other = SaltStackVersion.parse(other)
703             elif isinstance(other, (list, tuple)):
704                 other = SaltStackVersion(*other)
705             else:
706                 raise ValueError(
707                     "Cannot instantiate Version from type '{}'".format(type(other))
708                 )
709         pre_type = self.pre_index
710         other_pre_type = other.pre_index
711         other_noc_info = list(other.noc_info)
712         noc_info = list(self.noc_info)
713         if self.new_version(self.major):
714             if self.minor and not other.minor:
715                 if self.minor &gt; 0:
716                     other_noc_info[1] = 0
717             if not self.minor and other.minor:
718                 if other.minor &gt; 0:
719                     noc_info[1] = 0
720         if self.pre_type and not other.pre_type:
721             other_noc_info[other_pre_type] = "zzzzz"
722         if not self.pre_type and other.pre_type:
723             noc_info[pre_type] = "zzzzz"
724         return method(tuple(noc_info), tuple(other_noc_info))
725     def __lt__(self, other):
726         return self.__compare__(other, lambda _self, _other: _self &lt; _other)
727     def __le__(self, other):
728         return self.__compare__(other, lambda _self, _other: _self &lt;= _other)
729     def __eq__(self, other):
730         return self.__compare__(other, lambda _self, _other: _self == _other)
731     def __ne__(self, other):
732         return self.__compare__(other, lambda _self, _other: _self != _other)
733     def __ge__(self, other):
734         return self.__compare__(other, lambda _self, _other: _self &gt;= _other)
735     def __gt__(self, other):
736         return self.__compare__(other, lambda _self, _other: _self &gt; _other)
737     def __repr__(self):
738         parts = []
739         if self.name:
740             parts.append("name='{}'".format(self.name))
741         parts.extend(["major={}".format(self.major), "minor={}".format(self.minor)])
742         if self.new_version(self.major):
743             if not self.minor:
744                 parts.remove("".join([x for x in parts if re.search("^minor*", x)]))
745         else:
746             parts.extend(["bugfix={}".format(self.bugfix)])
747         if self.mbugfix:
748             parts.append("minor-bugfix={}".format(self.mbugfix))
749         if self.pre_type:
750             parts.append("{}={}".format(self.pre_type, self.pre_num))
751         noc = self.noc
752         if noc == -1:
753             noc = "0na"
754         if noc and self.sha:
755             parts.extend(["noc={}".format(noc), "sha={}".format(self.sha)])
756         return "&lt;{} {}&gt;".format(self.__class__.__name__, " ".join(parts))
757 __saltstack_version__ = SaltStackVersion.current_release()
758 def __discover_version(saltstack_version):
759     import os
760     import subprocess
761     if "SETUP_DIRNAME" in globals():
762         cwd = SETUP_DIRNAME  # pylint: disable=E0602
763         if not os.path.exists(os.path.join(cwd, ".git")):
764             return saltstack_version
765     else:
766         cwd = os.path.abspath(os.path.dirname(__file__))
767         if not os.path.exists(os.path.join(os.path.dirname(cwd), ".git")):
768             return saltstack_version
769     try:
770         kwargs = dict(stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=cwd)
771         if not sys.platform.startswith("win"):
772             kwargs["close_fds"] = True
773         process = subprocess.Popen(
774             [
775                 "git",
776                 "describe",
777                 "--tags",
778                 "--long",
779                 "--match",
780                 "v[0-9]*",
781                 "--always",
782             ],
783             **kwargs
784         )
785         out, err = process.communicate()
786         out = out.decode().strip()
787         err = err.decode().strip()
788         if not out or err:
789             return saltstack_version
790         if SaltStackVersion.git_sha_regex.match(out):
791             saltstack_version.sha = out.strip()
792             saltstack_version.noc = -1
793             return saltstack_version
794         return SaltStackVersion.parse(out)
795     except OSError as os_err:
796         if os_err.errno != 2:
797             raise
798     return saltstack_version
799 def __get_version(saltstack_version):
800     """
801     If we can get a version provided at installation time or from Git, use
802     that instead, otherwise we carry on.
803     """
804     try:
805         from salt._version import __saltstack_version__  # pylint: disable=E0611,F0401
806         return __saltstack_version__
807     except ImportError:
808         return __discover_version(saltstack_version)
809 __saltstack_version__ = __get_version(__saltstack_version__)
810 if __saltstack_version__.name:
811     SaltVersionsInfo._current_release = getattr(
812         SaltVersionsInfo, __saltstack_version__.name.upper()
813     )
814 del __get_version
815 __version_info__ = __saltstack_version__.info
816 __version__ = __saltstack_version__.string
817 def salt_information():
818     """
819     Report version of salt.
820     """
821     yield "Salt", __version__
822 def dependency_information(include_salt_cloud=False):
823     """
824     Report versions of library dependencies.
825     """
826     libs = [
827         ("Python", None, sys.version.rsplit("\n")[0].strip()),
828         ("Jinja2", "jinja2", "__version__"),
829         ("M2Crypto", "M2Crypto", "version"),
830         ("msgpack", "msgpack", "version"),
831         ("msgpack-pure", "msgpack_pure", "version"),
832         ("pycrypto", "Crypto", "__version__"),
833         ("pycryptodome", "Cryptodome", "version_info"),
834         ("PyYAML", "yaml", "__version__"),
835         ("PyZMQ", "zmq", "__version__"),
836         ("ZMQ", "zmq", "zmq_version"),
837         ("Mako", "mako", "__version__"),
838         ("Tornado", "tornado", "version"),
839         ("timelib", "timelib", "version"),
840         ("dateutil", "dateutil", "__version__"),
841         ("pygit2", "pygit2", "__version__"),
842         ("libgit2", "pygit2", "LIBGIT2_VERSION"),
843         ("smmap", "smmap", "__version__"),
844         ("cffi", "cffi", "__version__"),
845         ("pycparser", "pycparser", "__version__"),
846         ("gitdb", "gitdb", "__version__"),
847         ("gitpython", "git", "__version__"),
848         ("python-gnupg", "gnupg", "__version__"),
849         ("mysql-python", "MySQLdb", "__version__"),
850         ("cherrypy", "cherrypy", "__version__"),
851         ("docker-py", "docker", "__version__"),
852     ]
853     if include_salt_cloud:
854         libs.append(
855             ("Apache Libcloud", "libcloud", "__version__"),
856         )
857     for name, imp, attr in libs:
858         if imp is None:
859             yield name, attr
860             continue
861         try:
862             imp = __import__(imp)
863             version = getattr(imp, attr)
864             if callable(version):
865                 version = version()
866             if isinstance(version, (tuple, list)):
867                 version = ".".join(map(str, version))
868             yield name, version
869         except Exception:  # pylint: disable=broad-except
870             yield name, None
871 def system_information():
872     """
873     Report system versions.
874     """
875     from distro import linux_distribution
876     def system_version():
877         """
878         Return host system version.
879         """
880         lin_ver = linux_distribution()
881         mac_ver = platform.mac_ver()
882         win_ver = platform.win32_ver()
883         if mac_ver[0]:
884             if isinstance(mac_ver[1], (tuple, list)) and "".join(mac_ver[1]):
885                 return " ".join([mac_ver[0], ".".join(mac_ver[1]), mac_ver[2]])
886             else:
887                 return " ".join([mac_ver[0], mac_ver[2]])
888         elif win_ver[0]:
889             return " ".join(win_ver)
890         elif lin_ver[0]:
891             return " ".join(lin_ver)
892         else:
893             return ""
894     if platform.win32_ver()[0]:
895         import win32api  # pylint: disable=3rd-party-module-not-gated
896         import win32con  # pylint: disable=3rd-party-module-not-gated
897         hkey = win32con.HKEY_LOCAL_MACHINE
898         key = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"
899         value_name = "ProductName"
900         reg_handle = win32api.RegOpenKey(hkey, key)
901         product_name, _ = win32api.RegQueryValueEx(reg_handle, value_name)
902         version = "Unknown"
903         release = ""
904         if "Server" in product_name:
905             for item in product_name.split(" "):
906                 if re.match(r"\d+", item):
907                     version = item
908                 if re.match(r"^R\d+$", item):
909                     release = item
910             release = "{}Server{}".format(version, release)
911         else:
912             for item in product_name.split(" "):
913                 if re.match(r"^(\d+(\.\d+)?)|Thin|Vista$", item):
914                     version = item
915             release = version
916         _, ver, service_pack, extra = platform.win32_ver()
917         version = " ".join([release, ver, service_pack, extra])
918     else:
919         version = system_version()
920         release = platform.release()
921     system = [
922         ("system", platform.system()),
923         ("dist", " ".join(linux_distribution(full_distribution_name=False))),
924         ("release", release),
925         ("machine", platform.machine()),
926         ("version", version),
927         ("locale", __salt_system_encoding__),
928     ]
929     for name, attr in system:
930         yield name, attr
931         continue
932 def extensions_information():
933     """
934     Gather infomation about any installed salt extensions
935     """
936     import salt.utils.entrypoints
937     extensions = {}
938     for entry_point in salt.utils.entrypoints.iter_entry_points("salt.loader"):
939         dist_nv = salt.utils.entrypoints.name_and_version_from_entry_point(entry_point)
940         if not dist_nv:
941             continue
942         if dist_nv.name in extensions:
943             continue
944         extensions[dist_nv.name] = dist_nv.version
945     return extensions
946 def versions_information(include_salt_cloud=False, include_extensions=True):
947     """
948     Report the versions of dependent software.
949     """
950     salt_info = list(salt_information())
951     lib_info = list(dependency_information(include_salt_cloud))
952     sys_info = list(system_information())
953     info = {
954         "Salt Version": dict(salt_info),
955         "Dependency Versions": dict(lib_info),
956         "System Versions": dict(sys_info),
957     }
958     if include_extensions:
959         extensions_info = extensions_information()
960         if extensions_info:
961             info["Salt Extensions"] = extensions_info
962     return info
963 def versions_report(include_salt_cloud=False, include_extensions=True):
964     """
965     Yield each version properly formatted for console output.
966     """
967     ver_info = versions_information(
968         include_salt_cloud=include_salt_cloud, include_extensions=include_extensions
969     )
970     not_installed = "Not Installed"
971     ns_pad = len(not_installed)
972     lib_pad = max(len(name) for name in ver_info["Dependency Versions"])
973     sys_pad = max(len(name) for name in ver_info["System Versions"])
974     if include_extensions and "Salt Extensions" in ver_info:
975         ext_pad = max(len(name) for name in ver_info["Salt Extensions"])
976     else:
977         ext_pad = 1
978     padding = max(lib_pad, sys_pad, ns_pad, ext_pad) + 1
979     fmt = "{0:&gt;{pad}}: {1}"
980     info = []
981     for ver_type in (
982         "Salt Version",
983         "Dependency Versions",
984         "Salt Extensions",
985         "System Versions",
986     ):
987         if ver_type == "Salt Extensions" and ver_type not in ver_info:
988             continue
989         info.append("{}:".format(ver_type))
990         for name in sorted(ver_info[ver_type], key=lambda x: x.lower()):
991             ver = fmt.format(
992                 name, ver_info[ver_type][name] or not_installed, pad=padding
993             )
994             info.append(ver)
995         info.append(" ")
996     yield from info
997 if __name__ == "__main__":
998     print(__version__)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
